- en: Part 2\. The View and ViewModel
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二部分\. 视图和视图模型
- en: The meat of this book lies in the View and ViewModel section. These chapters
    look deeper into Vue and all the elements and pieces that make up a Vue application.
    We’ll start out simple and add interactivity to our application. We’ll then move
    onto forms and inputs, conditionals, and looping.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的精髓在于视图和视图模型部分。这些章节更深入地探讨了Vue以及构成Vue应用程序的所有元素和部分。我们将从简单开始，为我们的应用程序添加交互性。然后我们将转向表单和输入、条件语句和循环。
- en: Several of the most important concepts are in [chapters 6](kindle_split_017.html#ch06)
    and [7](kindle_split_018.html#ch07), where we look at components in depth. These
    are truly the building blocks of our application. This is the first chapter where
    we’ll see single-file components—a powerful tool in your Vue.js toolbelt.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的几个概念在[第6章](kindle_split_017.html#ch06)和[第7章](kindle_split_018.html#ch07)中，我们深入探讨了组件。这些确实是我们的应用程序的构建块。这是我们将看到单文件组件的第一个章节——这是Vue.js工具箱中的一个强大工具。
- en: The last two chapters will look at transitions, animations, and how to extend
    Vue. This will make our applications more efficient and look a little prettier.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 后两章将探讨过渡、动画以及如何扩展Vue。这将使我们的应用程序更高效，外观也更漂亮。
- en: Chapter 3\. Adding interactivity
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3章\. 添加交互性
- en: '*This chapter covers*'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Deriving new output from data with computed properties
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用计算属性从数据中派生新的输出
- en: Adding event bindings to the DOM
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将事件绑定添加到DOM
- en: Observing data during the update portion of the Vue lifecycle
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Vue生命周期更新部分观察数据
- en: Responding to user interaction
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应用户交互
- en: Conditionally rendering markup
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件渲染标记
- en: Believe it or not, now that we’ve got our first product all wired up, we’re
    ready to add interaction to our webstore.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 信不信由你，现在我们已经将我们的第一个产品全部连接好了，我们准备好为我们的网店添加交互了。
- en: Adding interactivity to an application means binding to DOM events, responding
    to them in application code, and providing feedback to users about what happened
    because of their actions. Vue creates and manages all the event and data bindings
    for us, but there are decisions we need to make about how to manipulate data within
    our application, as well as how to meet user expectations in our interface.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为应用程序添加交互性意味着绑定到DOM事件，在应用程序代码中响应它们，并给用户提供关于他们行动所发生的事情的反馈。Vue为我们创建和管理所有的事件和数据绑定，但我们需要做出一些决定，关于如何在我们的应用程序中操作数据，以及如何在我们的界面中满足用户期望。
- en: We’ll begin exploring user interaction by letting customers add our single product
    to a shopping cart, but along the way we’ll also look at how our work fits into
    the overall picture of a Vue application.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过让客户将我们的单个产品添加到购物车中来开始探索用户交互，但在这个过程中，我们也会看看我们的工作如何融入Vue应用程序的整体画面。
- en: To get a feel for where we’re headed in this chapter, [figure 3.1](#ch03fig01)
    shows how the application will look when all our work is done.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解本章我们将要走向何方，[图3.1](#ch03fig01)显示了当我们的所有工作都完成时应用程序将看起来如何。
- en: 'Figure 3.1\. Our product listing with new elements: a shopping cart and an
    Add to cart button.'
  id: totrans-15
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.1\. 我们的产品列表，包含新元素：购物车和“添加到购物车”按钮。
- en: '![](03fig01_alt.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](03fig01_alt.jpg)'
- en: 3.1\. Shopping cart data starts with adding an array
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1\. 购物车数据从添加一个数组开始
- en: Before we can build any of our super-cool shopping cart functionality, we’ll
    need a container to hold all those items in our application instance. Fortunately,
    all we need at this stage is a simple array, onto which we’ll push our products.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够构建任何超级酷的购物车功能之前，我们需要一个容器来存储我们应用程序实例中的所有这些商品。幸运的是，在这个阶段我们只需要一个简单的数组，我们将把我们的产品推送到这个数组上。
- en: I’ve broken up the code into small snippets, similar to the way we did it in
    the last chapter. You’ll need to add these to your index.html file that you created
    last chapter to continue the application. You can always download the code for
    this chapter if needed.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经将代码拆分成小的片段，类似于我们在上一章中所做的那样。您需要将这些添加到上一章中创建的index.html文件中，以继续应用程序。如果需要，您始终可以下载本章的代码。
- en: 'Listing 3.1\. All we need is an array: chapter-03/add-array.js'
  id: totrans-20
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.1\. 我们只需要一个数组：chapter-03/add-array.js
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '***1* Shows our existing product data, for reference**'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 显示我们的现有产品数据，仅供参考**'
- en: '***2* Shows an array for holding cart items**'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 显示用于存储购物车商品的数组**'
- en: That gives us our shopping cart . . . done. In all seriousness, though, we’ll
    get good mileage out of this simple array, but eventually we’ll create a cart
    component that will manage its contents internally.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这就给我们提供了购物车……完成了。不过，说真的，我们将从这个简单的数组中获得很多好处，但最终我们将创建一个可以内部管理其内容的购物车组件。
- en: '|  |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Remember
  id: totrans-26
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 记住
- en: You need to add a comma after `product` in [listing 3.1](#ch03ex01) before you
    add the cart array. Forgetting to add one will throw an error in the console and
    is a common gotcha. (An error I’m well acquainted with!)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在你添加购物车数组之前，需要在[列表3.1](#ch03ex01)中的`product`后面添加一个逗号。忘记添加逗号会在控制台抛出错误，这是一个常见的陷阱。（我非常熟悉的一个错误！）
- en: '|  |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 3.2\. Binding to DOM events
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2\. 绑定到DOM事件
- en: To add interaction to our application, we need to bind elements of the DOM to
    functions we define in our Vue instance. We can bind an element to any standard
    DOM event—click, mouseup, keyup, and so on—by using an *event binding*. Vue takes
    care of all the wiring under the hood, so we can stay focused on how our application
    reacts to an event when it occurs.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给我们的应用程序添加交互，我们需要将DOM元素绑定到我们在Vue实例中定义的函数。我们可以通过使用*事件绑定*将任何标准DOM事件（如点击、mouseup、keyup等）绑定到元素。Vue会处理所有底层的连接，这样我们就可以专注于应用程序如何对事件做出反应。
- en: 3.2.1\. Event binding basics
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.1\. 事件绑定基础
- en: Event bindings use the `v-on` directive to bind a snippet of JavaScript, or
    a function, to a DOM element, as shown in [figure 3.2](#ch03fig02). The bound
    code or function gets executed when the specified DOM event is triggered.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 事件绑定使用`v-on`指令将一小段JavaScript或函数绑定到DOM元素，如图3.2所示。当指定的DOM事件被触发时，绑定的代码或函数将被执行。
- en: Figure 3.2\. The syntax of an event binding.
  id: totrans-33
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.2\. 事件绑定的语法。
- en: '![](03fig02_alt.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig02_alt.jpg)'
- en: 'Here are two common patterns for an event binding’s JavaScript:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是事件绑定JavaScript的两种常见模式：
- en: '***Using a function name, we can bind an event to a function we define in our
    instance.*** If we had a binding such as `v-on:click="clickHappened"`, a click
    on our element would call the function `clickHappened`.'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***使用函数名，我们可以将事件绑定到我们在实例中定义的函数。*** 如果我们有一个绑定，如`v-on:click="clickHappened"`，那么点击我们的元素将调用`clickHappened`函数。'
- en: '***We can write inline JavaScript that acts on an exposed property.*** In this
    case, the binding might look like `v-on:keyup="charactersRemaining -= 1"`, which
    would decrease the `charactersRemaining` property by one.'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***我们可以编写内联JavaScript来作用于一个公开的属性。*** 在这个例子中，绑定可能看起来像`v-on:keyup="charactersRemaining
    -= 1"`，这将减少`charactersRemaining`属性一个单位。'
- en: Each strategy has its place in an application, but first we’re going to look
    at using a function to handle an event.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 每种策略在应用程序中都有其位置，但首先我们将看看如何使用函数来处理事件。
- en: '|  |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-40
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: An easier shorthand way to write the `v-on` directive exists. Instead of using
    `v-on,` you can replace it with the `@` symbol. For example, if you want to use
    `v-on:click="..."` you could replace that with `@click="..."` instead. We’ll use
    this shorthand later in the book.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一种更简短的`v-on`指令的写法。你不需要使用`v-on`，你可以用`@`符号替换它。例如，如果你想使用`v-on:click="..."`，你可以用`@click="..."`来代替。我们将在本书的后面使用这个简写。
- en: '|  |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 3.2.2\. Bind an event to the Add to cart button
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.2\. 将事件绑定到“添加到购物车”按钮
- en: For a customer to add products to their shopping cart, they need a button. We’ll
    instruct Vue to bind that button’s click event to a function that handles pushing
    a product onto the `cart` array.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让客户将产品添加到他们的购物车中，他们需要一个按钮。我们将指示Vue将按钮的点击事件绑定到处理将产品推入`cart`数组的函数。
- en: Before we add the button to our markup, we should write our function. To do
    so, we need to add a `methods` object to our application’s options. After the
    `filters` object, add this code. (Don’t forget a comma after the `filters` object!)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将按钮添加到标记之前，我们应该编写我们的函数。为此，我们需要向应用程序的选项中添加一个`methods`对象。在`filters`对象之后，添加以下代码。（别忘了在`filters`对象后面加逗号！）
- en: 'Listing 3.2\. The `addToCart` method: chapter-03/add-to-cart.js'
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.2\. `addToCart`方法：chapter-03/add-to-cart.js
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '***1* The methods object contains our new function.**'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 方法对象包含我们的新函数。**'
- en: '***2* Defines the addToCart function**'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 定义了`addToCart`函数**'
- en: For now, adding a product to the cart means pushing the product’s `id` property
    from the product data onto the `cart` array. Keep in mind, you’ll need to add
    the `this` keyword to access all data properties.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，将产品添加到购物车意味着将产品数据的`id`属性推入`cart`数组。请注意，你需要添加`this`关键字来访问所有数据属性。
- en: '|  |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Pushing the id, not the object**'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**推动理念，而非对象**'
- en: It may seem simpler to push the entire product object onto our `cart` array
    in the code from [listing 3.2](#ch03ex02)—`this.cart.push( this.product );`—but
    if we did, things would get a bit awkward. JavaScript is neither a pure pass-by-reference
    language, nor a pure pass-by-copy language, so it takes a bit of practice to know
    when one or the other will occur.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 从[列表3.2](#ch03ex02)中的代码来看，将整个产品对象推送到我们的`cart`数组中（`this.cart.push( this.product
    );`）可能看起来更简单，但如果我们这样做，事情会变得有些尴尬。JavaScript既不是纯按引用传递语言，也不是纯按副本传递语言，所以需要一些实践才能知道何时会发生哪种情况。
- en: Pushing the product onto the `cart` array would push a reference to the product
    object defined in our data, not a copy. If the product definition in our data
    changes, perhaps when we retrieve new product data from the server, it might be
    replaced in the cart or the reference may become `undefined`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 将产品推送到`cart`数组中会推送一个指向我们数据中定义的产品对象的引用，而不是一个副本。如果我们从服务器检索新的产品数据，产品定义可能会在购物车中替换，或者引用可能变为`undefined`。
- en: By pushing the product `id` onto the `cart` array instead, we push a copy of
    the value of our product’s `id`, not a reference. If the product definition changes,
    the value(s) in the `cart` array remain unaltered.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将产品`id`推送到`cart`数组中，我们推送的是产品`id`值的副本，而不是引用。如果产品定义发生变化，`cart`数组中的值保持不变。
- en: Technically speaking, JavaScript is a call-by-sharing language. You can find
    a brief explanation of call-by-sharing, and how it compares to other strategies,
    on Wikipedia at [https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing](https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上来说，JavaScript是一种按共享调用语言。你可以在维基百科上找到关于按共享的简要解释，以及它与其他策略的比较：[https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing](https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing)。
- en: '|  |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Now we’ve got a function that will add products to our cart so we can go ahead
    and add button markup. Right after the price markup in our product `div`, add
    the button from this listing.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个函数可以添加产品到我们的购物车，所以我们可以继续添加按钮标记。在我们的产品`div`中的价格标记之后，添加此列表中的按钮。
- en: 'Listing 3.3\. A button to add products to the cart: chapter-03/button-product.js'
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.3\. 添加到购物车的按钮：chapter-03/button-product.js
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***1* Shows our Add to cart button**'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 显示我们的“添加到购物车”按钮**'
- en: '***2* Binds the button’s click event to the addToCart function**'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将按钮的点击事件绑定到addToCart函数**'
- en: Now, when a visitor clicks this button, the `addToCart` function is called.
    Time to give it a whirl.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当访客点击这个按钮时，会调用`addToCart`函数。是时候试一试了。
- en: Head over to Chrome, ensure that the console is open, and switch to the Vue
    tab because we’ll want to peek at the data that’s added to our shopping cart.
    The `cart` array should be empty, so if you don’t see `Array[0]` as shown in [figure
    3.3](#ch03fig03), go ahead and reload the page.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 打开Chrome，确保控制台是打开的，并切换到Vue标签，因为我们想查看添加到我们的购物车中的数据。`cart`数组应该是空的，所以如果你没有看到如图3.3中所示的`Array[0]`，请继续并重新加载页面。
- en: Figure 3.3\. An empty array is what we should see before any products are added.
    If it’s not empty, go ahead and reload the page.
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.3\. 在添加任何产品之前，我们应该看到一个空数组。如果它不为空，请继续并重新加载页面。
- en: '![](03fig03_alt.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig03_alt.jpg)'
- en: Now, click the Add to cart button a few times. Open the vue-devtools pane and
    click `<Root>`. You should see the product’s `id` getting pushed onto the array
    with each click as seen in [figure 3.4](#ch03fig04).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，多次点击“添加到购物车”按钮。打开vue-devtools面板并点击`<Root>`。你应该会看到每次点击都会将产品的`id`推送到数组中，就像在[图3.4](#ch03fig04)中看到的那样。
- en: Figure 3.4\. The array fills up as you add items to the cart.
  id: totrans-68
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.4\. 随着你向购物车添加商品，数组会填满。
- en: '![](03fig04_alt.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig04_alt.jpg)'
- en: Seeing how many items are in the shopping cart using vue-devtools or the console
    may be okay for developers, but customers will need feedback in the view itself.
    Time to add an item counter.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用vue-devtools或控制台查看购物车中的商品数量可能对开发者来说是可以的，但客户需要在视图中得到反馈。是时候添加一个项目计数器了。
- en: 3.3\. Adding a cart item button and count
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3\. 添加购物车项目按钮和计数
- en: To display the number of items a customer has in the shopping cart, we’ll use
    a *computed property*. Computed properties can be bound to the DOM like any other
    property defined by our instance, but they typically provide functionality to
    derive new information from the current state of an application. In addition,
    we’ll add a cart item button that will display our checkout cart.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示客户购物车中的项目数量，我们将使用一个*计算属性*。计算属性可以像我们的实例定义的任何其他属性一样绑定到DOM，但它们通常提供从应用程序当前状态推导新信息的功能。此外，我们还将添加一个购物车项目按钮，用于显示我们的结账购物车。
- en: Before we add an item count to our shopping cart, let’s take a more general
    look at computed properties and how they work.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将项目数量添加到购物车之前，让我们更广泛地了解一下计算属性以及它们是如何工作的。
- en: 3.3.1\. When to use a computed property
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.1\. 何时使用计算属性
- en: It might help to think of the properties in the `data` object as representing
    data we’d store in a database and computed properties as dynamic values that are
    used primarily within the context of our view. This may be an overly broad characterization,
    but it serves as a good first rule of thumb.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 将`data`对象中的属性视为代表我们在数据库中存储的数据，将计算属性视为主要用于视图上下文中的动态值，可能会有所帮助。这可能是一个过于宽泛的描述，但它可以作为一条很好的经验法则。
- en: Let’s consider a common example of a computed property that displays a user’s
    full name, as shown in [listing 3.4](#ch03ex04). It makes sense to store someone’s
    first and last names as separate entities in a database, but it would be redundant
    and error prone to also store their full name. If the need to display a user’s
    full name arose, combining the first and last name from existing data is a perfect
    use case for a computed property.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个常见的计算属性示例，它显示用户的全名，如[列表3.4](#ch03ex04)所示。在数据库中将某人的首名和姓氏作为单独的实体存储是有意义的，但存储他们的全名将是冗余且容易出错的。如果需要显示用户的全名，从现有数据中组合首名和姓氏是计算属性的一个完美用例。
- en: 'Listing 3.4\. Computing a user’s full name: chapter-03/computed.js'
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.4\. 计算用户的全名：chapter-03/computed.js
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1* fullName returns the value of a user’s first and last name, joined by
    a single space.**'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* `fullName`返回用户的首名和姓氏，由一个空格连接。**'
- en: The result returned by the `fullName` function is conceptually equivalent to
    having a `fullName` property in our data object, which means we can easily bind
    to it in our markup (see [figure 3.5](#ch03fig05)).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`fullName`函数返回的结果在概念上等同于在我们的数据对象中有一个`fullName`属性，这意味着我们可以在我们的标记中轻松地绑定到它（参见[图3.5](#ch03fig05)）。'
- en: Figure 3.5\. Combining the user’s first and last name from a dataset into a
    full name for display.
  id: totrans-81
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.5\. 将用户的数据集中的首名和姓氏组合成一个用于显示的完整姓名。
- en: '![](03fig05_alt.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig05_alt.jpg)'
- en: One additional benefit of using computed properties is that we can change the
    internals of our function to use different or additional data from our application.
    In [figure 3.5](#ch03fig05), for example, we could use the `prefix` property to
    add more formality to a user’s full name.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用计算属性的一个额外好处是我们可以更改函数的内部结构，以使用来自应用程序的不同或附加数据。例如，在[图3.5](#ch03fig05)中，我们可以使用`prefix`属性为用户的完整姓名添加更多正式性。
- en: Using computed properties in this way, we can combine, or otherwise manipulate,
    any instance data without requiring changes to the backend or the database.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式使用计算属性，我们可以组合或以其他方式操作任何实例数据，而无需对后端或数据库进行更改。
- en: 3.3.2\. Examining update events with computed properties
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.2\. 使用计算属性检查更新事件
- en: Because computed properties are typically calculated using instance data, their
    return value is updated automatically when the underlying data changes. Any view
    markup bound to the computed property will therefore update to reflect the new
    value as well.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于计算属性通常使用实例数据进行计算，因此当底层数据发生变化时，它们的返回值会自动更新。因此，绑定到计算属性的任何视图标记都会更新以反映新值。
- en: This behavior is at the heart of the update cycle within the greater Vue instance
    lifecycle. To get a feel for how the update cycle behaves, let’s work through
    another example of when a computed property is a perfect fit for the job. Consider
    the task of computing the area of a rectangle, based on its length and width.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为是Vue实例生命周期中更新周期的核心。为了了解更新周期的行为，让我们通过另一个例子来探讨何时计算属性是这项工作的完美选择。考虑根据矩形的长度和宽度计算面积的任务。
- en: 'Listing 3.5\. Computing the area of a rectangle: chapter-03/computed-rect.js'
  id: totrans-88
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.5\. 计算矩形的面积：chapter-03/computed-rect.js
- en: '[PRE4]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***1* Shows a data object that contains length and width properties**'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 显示了一个包含长度和宽度属性的数据对象**'
- en: '***2* Shows a computed property that exposes area the same as a data property**'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 展示了一个暴露区域与数据属性相同的计算属性**'
- en: 'The computed property `area` will have an initial value of 15\. Any subsequent
    change to `length` or `width` reactively triggers a series of updates to the application:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 计算属性 `area` 将有一个初始值15。任何对 `length` 或 `width` 的后续更改都会引发一系列应用程序的更新：
- en: When the value of `length` or `width` is changed . . .
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 `length` 或 `width` 的值发生变化时 . . .
- en: . . . the computed property `area` is recalculated . . .
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: . . . 计算属性 `area` 会被重新计算 . . .
- en: . . . then any markup bound to these properties is updated.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: . . . 然后任何绑定到这些属性的标记都会更新。
- en: '[Figure 3.6](#ch03fig06) shows the update cycle of the application.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.6](#ch03fig06) 展示了应用程序的更新周期。'
- en: Figure 3.6\. Changes in an instance’s data trigger a cascade of activity within
    the update cycle of an application.
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.6\. 实例数据的变化触发了应用程序更新周期内的活动级联。
- en: '![](03fig06_alt.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig06_alt.jpg)'
- en: We can see the lifecycle in action by using *watch functions* to observe when
    the data in an instance changes, and the `beforeUpdate` lifecycle hook, which
    should be executed only after the data changes.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 *watch函数* 来观察实例中的数据何时发生变化，以及 `beforeUpdate` 生命周期钩子（它应该在数据更改后执行）来看到生命周期在实际中的应用。
- en: '|  |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Info
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 信息
- en: A watch function works the same way as a lifecycle hook but is triggered when
    the data it’s “watching” is updated. We can even create a watch function to observe
    a computed property.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一个watch函数的工作方式与生命周期钩子相同，但它是在它所“监视”的数据更新时被触发的。我们甚至可以创建一个watch函数来观察一个计算属性。
- en: '|  |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[Listing 3.6](#ch03ex06) puts our area calculation in the context of a complete
    application. The application also contains three watch functions that log messages
    to the console whenever `length`, `width`, or `area` change, and one function
    to log when the update cycle begins. These functions must be specified in the
    watch option of the Vue instance for them to work.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表3.6](#ch03ex06) 将我们的面积计算放在一个完整应用程序的上下文中。该应用程序还包含三个watch函数，每当 `length`、`width`
    或 `area` 发生变化时，这些函数都会将消息记录到控制台，并且还有一个函数用于记录更新周期开始时的情况。这些函数必须在Vue实例的watch选项中指定，才能正常工作。'
- en: '|  |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-106
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: You can find the code for this listing in the samples that accompany this chapter
    in the file chapter-03/area.html. It’s entirely self-contained, so you can open
    it directly in Chrome.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本章提供的示例文件 chapter-03/area.html 中找到此列表的代码。它是完全自包含的，因此您可以直接在Chrome中打开它。
- en: '|  |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Listing 3.6\. Computed properties and update event logging: chapter-03/area.html'
  id: totrans-109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.6\. 计算属性和更新事件记录：chapter-03/area.html
- en: '[PRE5]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1* Lists the data binding that displays the value of area**'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 列出了显示面积值的绑定数据**'
- en: '***2* Shows the buttons that increase the value of length or width by 1, respectively**'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 展示了分别增加长度或宽度值的按钮**'
- en: '***3* Shows the original values for length and width**'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 展示长度和宽度的原始值**'
- en: '***4* Gives the area computed property**'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 给出面积计算属性**'
- en: '***5* Shows the function that logs when length changes**'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 展示了当长度变化时记录日志的功能**'
- en: '***6* Shows the function that logs when width changes**'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 展示了当宽度变化时记录日志的功能**'
- en: '***7* Shows the function that logs when area changes**'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 展示了当区域变化时记录日志的功能**'
- en: '***8* Lists the beforeUpdate lifecycle hook function**'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 列出了 beforeUpdate 生命周期钩子函数**'
- en: When you load this file in Chrome, you’ll see an initial value for `area` is
    15 as seen in [figure 3.7](#ch03fig07). Be sure the JavaScript console is open,
    then try clicking the buttons to trigger the update cycle. The console should
    log messages about the application’s data when the Add length button and Add width
    button are clicked (see [figure 3.8](#ch03fig08)).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在Chrome中加载此文件时，您会看到 `area` 的初始值是15，如图 [图3.7](#ch03fig07) 所示。请确保JavaScript控制台已打开，然后尝试点击按钮以触发更新周期。当点击“增加长度”按钮和“增加宽度”按钮时，控制台应该记录有关应用程序数据的信息（见图
    [图3.8](#ch03fig08)）。
- en: Figure 3.7\. The initial state of our area calculating application.
  id: totrans-120
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.7\. 我们面积计算应用程序的初始状态。
- en: '![](03fig07_alt.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig07_alt.jpg)'
- en: Figure 3.8\. Observing our properties changing in response to clicking buttons.
  id: totrans-122
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.8\. 观察我们的属性在点击按钮时如何变化。
- en: '![](03fig08_alt.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig08_alt.jpg)'
- en: Now that we’ve seen how the application behaves, we can map the data and functions
    from [listing 3.6](#ch03ex06) onto our diagram of the update cycle in [figure
    3.9](#ch03fig09).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了应用程序的行为，我们可以将 [列表3.6](#ch03ex06) 中的数据和函数映射到 [图3.9](#ch03fig09) 中的更新周期图上。
- en: Figure 3.9\. Changes in an instance’s data trigger a cascade of activity within
    the update cycle of an application.
  id: totrans-125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.9\. 实例数据的变化触发了应用程序更新周期内的活动级联。
- en: '![](03fig09_alt.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig09_alt.jpg)'
- en: One last thing to note, if you remove the `{{ area }}` binding from the sample
    code, and reload the page in your browser, you’ll see a difference in the console
    output when you click either button (see [figure 3.10](#ch03fig10)).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要注意的一点是，如果你从示例代码中移除`{{ area }}`绑定，并在浏览器中重新加载页面，当你点击任一按钮时，你会在控制台输出中看到差异（见[图3.10](#ch03fig10)）。
- en: Figure 3.10\. No update message displays if nothing gets updated.
  id: totrans-128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.10\. 如果没有更新，则不会显示更新消息。
- en: '![](03fig10_alt.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig10_alt.jpg)'
- en: With no outlet for the computed property, there’s nothing to update, and therefore
    no reason to enter the update cycle. The `beforeUpdate` function won’t be executed
    and the corresponding message won’t be logged to the console.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有计算属性的输出端口，没有需要更新的内容，因此没有理由进入更新周期。`beforeUpdate`函数将不会执行，相应的消息也不会被记录到控制台。
- en: 3.3.3\. Displaying a cart item count and testing
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.3\. 显示购物车项目计数并测试
- en: Now that we have a good understanding of computed properties, let’s look at
    our shopping cart example again. Let’s add a computed property to our Vue instance
    that will display the number of items in the shopping cart, as shown in the following
    listing. Don’t forget to add a `computed` object to the `options` object, so our
    function will have a place to live.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对计算属性有了很好的理解，让我们再次看看我们的购物车示例。让我们向我们的Vue实例添加一个计算属性，该属性将显示购物车中的项目数，如下所示列表。别忘了向`options`对象添加一个`computed`对象，这样我们的函数就有地方存放了。
- en: 'Listing 3.7\. The `cartItemCount`’s computed property: chapter-03/cart-item-count.js'
  id: totrans-133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.7\. `cartItemCount`的计算属性：chapter-03/cart-item-count.js
- en: '[PRE6]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1* Adds a computed object**'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 添加一个计算对象**'
- en: '***2* Returns a count of items in the cart array**'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 返回购物车数组中的项目数**'
- en: This is a straightforward use of a computed property. We use an existing JavaScript
    property—`length`—of an array to retrieve our count, because it’s really not necessary
    to add our own counting mechanism for the shopping cart.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个计算属性的简单使用。我们使用一个现有的JavaScript数组属性——`length`——来获取我们的计数，因为实际上没有必要为购物车添加自己的计数机制。
- en: This is also a good example of why it’s inappropriate to store this kind of
    data as a property of the `data` object. Because the value of `cartItemCount`
    is the result of user interaction, and not something that came from a database,
    we wouldn’t expect to see it in our `data` object.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是一个很好的例子，说明了为什么将这类数据作为`data`对象的属性存储是不合适的。因为`cartItemCount`的值是用户交互的结果，而不是来自数据库的东西，所以我们不会期望在`data`对象中看到它。
- en: It’s worth noting that there are times when such an item count might be in the
    data object. For example, if a user was looking at a “previous orders” page, there
    might be an item count associated with each order. This is consistent with our
    thinking so far, because that data would come from the database after an order
    had been processed and persisted.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，有时这种项目计数可能存在于数据对象中。例如，如果用户正在查看“历史订单”页面，每个订单可能都有一个项目计数。这与我们之前的思考是一致的，因为这种数据会在订单处理并持久化后从数据库中获取。
- en: Function in place, we’re ready to add a little bit of HTML to our application’s
    header so that we have a shopping cart and a place to display the item count.
    Update the markup in the header as shown here.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 函数就位，我们准备在我们的应用程序的页眉中添加一点HTML，以便我们有购物车和显示项目计数的空间。按照以下所示更新页眉的标记。
- en: 'Listing 3.8\. Adding the cart indicator: chapter-03/cart-indicator.html'
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.8\. 添加购物车指示器：chapter-03/cart-indicator.html
- en: '[PRE7]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '***1* Aligns our cart to the right**'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将我们的购物车对齐到右边**'
- en: '***2* Shows the data binding that displays the computed property**'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 显示显示计算属性的绑定**'
- en: We add a new `div` element to the header so we have a place for our cart, and
    we use the `cartItemCount` binding to display the value of our computed property.
    The binding is surrounded by a `span` element, which is used as a style hook to
    add a cart icon next to our counter. It’s time to test things out.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在页眉中添加一个新的`div`元素，以便我们有地方放置购物车，并使用`cartItemCount`绑定来显示计算属性的值。绑定被一个`span`元素包围，该元素用作样式钩子，在计数器旁边添加购物车图标。现在是时候测试一下了。
- en: After reloading the webstore application in Chrome, clicking Add to cart should
    cause the indicator to increase with each click. You can double-check that the
    count is correct by examining the `cart` array in the console once again (see
    [figure 3.11](#ch03fig11)).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在Chrome中重新加载webstore应用程序后，点击“添加到购物车”应该会导致指示器随着每次点击而增加。你可以通过再次检查控制台中的`cart`数组来双重检查计数是否正确（见[图3.11](#ch03fig11)）。
- en: Figure 3.11\. Observing change in our application’s header and inspecting the
    cart in the console.
  id: totrans-147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.11\. 观察应用程序的标题变化并在控制台中检查购物车。
- en: '![](03fig11_alt.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig11_alt.jpg)'
- en: 3.4\. Adding user affordance to our button
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4\. 为我们的按钮添加用户可用性
- en: People bring a wide variety of experience and expectation with them when they
    arrive at a website or use a web application. One of the most fundamental, and
    deeply ingrained, is that when an interactive element behaves differently than
    expected, a product can feel broken or disorienting. The idea behind *user affordance*
    is to provide visual (or other) cues and feedback to a user that keeps our application
    consistent with their expectations.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当人们到达网站或使用网络应用程序时，他们会带着各种各样的经验和期望。其中最基本、最根深蒂固的是，当一个交互元素的行为与预期不同时，产品可能会感觉损坏或迷失方向。*用户可用性*背后的理念是提供视觉（或其他）提示和反馈，使我们的应用程序与他们的期望保持一致。
- en: '|  |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Info
  id: totrans-152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 信息
- en: For more information on user affordance and its importance in the experience
    of digital products, start at the Interaction Design Foundation at [http://mng.bz/Xv96](http://mng.bz/Xv96).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 关于用户可用性和其在数字产品体验中的重要性，更多信息请从交互设计基金会开始，访问[http://mng.bz/Xv96](http://mng.bz/Xv96)。
- en: '|  |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'We now have a button that lets a customer endlessly add a product to their
    shopping cart. There may be many reasons to limit the number of items a customer
    can purchase: limited available product, restrictions on per-customer purchases,
    quantity discounts, and so on. If there’s a limited quantity, then the Add to
    cart button should become unavailable at some point or otherwise indicate that
    the action is no longer possible.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个按钮，允许客户无限地向他们的购物车添加产品。可能有许多原因限制客户可以购买的项目数量：产品可用性有限、每个客户的购买限制、数量折扣等等。如果数量有限，那么“添加到购物车”按钮应该在某个时候变得不可用，或者以其他方式表明该操作不再可能。
- en: To accomplish this task, we need to track our available inventory, compare it
    against how many instances of a product are in the shopping cart, and act to keep
    customers from adding more products than there are available. Let’s start with
    tracking the inventory.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个任务，我们需要跟踪我们的可用库存，将其与购物车中产品的实例数量进行比较，并采取措施防止客户添加超过可用数量的产品。让我们从跟踪库存开始。
- en: 3.4.1\. Keeping an eye on inventory
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.4.1\. 关注库存
- en: To keep a customer from buying too many of a given product, we’ll need to add
    a new property to our product object, as shown in the following listing. The `availableInventory`
    property will represent how many individual units of a product our store has available.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止客户购买过多的一种产品，我们需要在我们的产品对象中添加一个新的属性，如下面的列表所示。`availableInventory`属性将代表我们的商店有多少个产品的单个单位可用。
- en: 'Listing 3.9\. Adding `availableInventory` to our product: chapter-03/available-inventory.js'
  id: totrans-159
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.9\. 将`availableInventory`添加到我们的产品：chapter-03/available-inventory.js
- en: '[PRE8]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '***1* Adds the availableInventory property after our other product data**'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在我们的其他产品数据之后添加了availableInventory属性**'
- en: It’s still necessary to double-check product availability when a purchase is
    being finalized—in case another customer has purchased one or more of the same
    product in the middle of a transaction—but we can implement a simple solution
    in our application to greatly reduce the chance a user will be disappointed later
    by hiding, or disabling, the Add to cart button.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在最终确定购买时，仍然有必要检查产品可用性——以防在交易过程中有其他客户购买了相同的产品——但我们可以在应用程序中实现一个简单的解决方案，以极大地减少用户因失望而隐藏或禁用“添加到购物车”按钮的可能性。
- en: '|  |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-164
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: Never rely on values from the client when it comes to transactions, financial
    or otherwise. The backend of your application should always interpret the incoming
    data as expressing the user’s intent, not reality.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在交易（无论是财务还是其他方面）时，永远不要依赖客户端的值。你的应用程序的后端应该始终将传入的数据解释为表达用户的意图，而不是现实。
- en: '|  |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 3.4.2\. Working with computed properties and inventory
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.4.2\. 使用计算属性和库存
- en: We don’t want to mutate the `availableInventory` value, because that represents
    a fixed value that should be updated only by a process that manages actual inventory
    (something we’ll come back to much later in the book). But we do want to restrict
    the amount of product a customer can add to their shopping cart based on the value
    of `availableInventory`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望修改`availableInventory`值，因为这代表了一个固定值，它应该只由管理实际库存的过程（我们将在本书的后面部分再次回到这个话题）来更新。但我们也想根据`availableInventory`的值来限制客户可以添加到购物车中的产品数量。
- en: To do this, we need a way to keep track of the number of items in a customer’s
    shopping cart relative to the fixed amount of product available. We’ll use a computed
    property to perform this calculation in real-time, as a customer adds items to
    their shopping cart.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们需要一种方法来跟踪客户购物车中的商品数量与固定产品数量的相对数量。我们将使用计算属性在客户向购物车添加商品时实时执行此计算。
- en: 'Listing 3.10\. A computed property for remaining inventory: chapter-03/computed-remaining.js'
  id: totrans-170
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.10\. 剩余库存的计算属性：chapter-03/computed-remaining.js
- en: '[PRE9]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '***1* Uses the canAddToCart computed property**'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用 canAddToCart 计算属性**'
- en: '***2* Compares availableInventory to the number of items already in the cart**'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将 availableInventory 与购物车中的商品数量进行比较**'
- en: Because our code can consume computed properties in the same way as properties
    of our instance data, we get a chance to leverage one computed property, `cartItemCount`,
    within another. Our new computed property checks to see whether the available
    inventory is greater than the number of items already in the shopping cart. If
    not, that means the customer has added the maximum number of products to their
    cart, and we’ll have to act to keep them from adding more.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的代码可以像使用实例数据属性一样使用计算属性，我们有机会在另一个计算属性中利用一个计算属性，即 `cartItemCount`。我们的新计算属性会检查可用库存是否大于购物车中已有的商品数量。如果不是，这意味着客户已经将最大数量的产品添加到购物车中，我们将不得不采取措施阻止他们添加更多。
- en: '|  |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**“Truthiness” in JavaScript**'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**“JavaScript 中的真值”**'
- en: As you may already be aware, evaluating the truth value of an expression in
    JavaScript can be a bit tricky. Here’s a quick example you can try in a console
    for yourself.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已经知道，在 JavaScript 中评估表达式的真值可能有点棘手。这里有一个您可以在控制台中尝试的快速示例。
- en: When using the non-strict equality operator `==`, the integer value `1` compared
    to the string value `"1"` evaluates to `true`. This occurs because JavaScript,
    attempting to be “helpful,” does a type conversion before the comparison is evaluated.
    Using the strict equality operator `===` produces the expected `false` result.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用非严格相等运算符 `==` 时，整数值 `1` 与字符串值 `"1"` 的比较结果为 `true`。这是因为 JavaScript 在比较评估之前尝试“有帮助”，进行了类型转换。使用严格相等运算符
    `===` 会产生预期的 `false` 结果。
- en: In our `canAddToCart` function, we use the greater than operator `>` to compare
    two integer values. If we had any doubt about where those values came from, or
    if they were in fact integers, we could force the conversion using the `parseInt`
    method or otherwise ensuring the values are integers.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `canAddToCart` 函数中，我们使用大于运算符 `>` 来比较两个整数值。如果我们对这些值的来源有任何疑问，或者它们实际上是整数，我们可以使用
    `parseInt` 方法强制转换，或者确保这些值是整数。
- en: Much has been written about JavaScript’s type conversions and equality operators,
    but perhaps the most illuminating reference is this series of diagrams on the
    topic at [https://dorey.github.io/JavaScript-Equality-Table/](https://dorey.github.io/JavaScript-Equality-Table/).
    Be sure to compare (hah!) the `==` and `===` tabs.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 JavaScript 的类型转换和相等运算符已经有很多讨论，但可能最具有启发性的参考资料是关于这个主题的这些图表，可以在 [https://dorey.github.io/JavaScript-Equality-Table/](https://dorey.github.io/JavaScript-Equality-Table/)
    找到。务必比较一下（哈哈！）`==` 和 `===` 选项卡。
- en: '|  |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 3.4.3\. v-show directive basics
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.4.3\. v-show 指令基础
- en: Now that we have a mechanism to determine whether a customer can take the Add
    to cart action, let’s make the interface respond accordingly. The `v-show` directive
    renders markup if, and only if, the specified condition evaluates to `true`. Adding
    it to our existing button results in the button being hidden from the DOM if our
    `canAddToCart` property returns `false`, shown here.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了确定客户是否可以执行“添加到购物车”操作的方法，让我们让界面相应地做出反应。`v-show` 指令仅在指定的条件评估为 `true` 时渲染标记。将其添加到现有的按钮中会导致按钮在
    `canAddToCart` 属性返回 `false` 时从 DOM 中隐藏，如这里所示。
- en: 'Listing 3.11\. Button with `v-show` directive: chapter-03/button-v-show.html'
  id: totrans-184
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.11\. 带有 `v-show` 指令的按钮：chapter-03/button-v-show.html
- en: '[PRE10]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '***1* The v-show directive is bound to our canAddToCart computed property.**'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* v-show 指令绑定到我们的 canAddToCart 计算属性。**'
- en: If you reload the application in Chrome and try adding six products to your
    shopping cart, the button should disappear on the fifth click, because that’s
    the value of `availableInventory` as seen in [figure 3.12](#ch03fig12).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你用 Chrome 重新加载应用程序并尝试将六个产品添加到购物车，按钮应该在第五次点击时消失，因为这是从 [图 3.12](#ch03fig12)
    中看到的 `availableInventory` 的值。
- en: Figure 3.12\. The Add to cart button is hidden when we exhaust the available
    inventory.
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.12\. 当可用库存耗尽时，添加到购物车按钮被隐藏。
- en: '![](03fig12_alt.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig12_alt.jpg)'
- en: The `v-show` directive works a bit differently than other directives we’ve encountered
    so far. When the expression evaluates to `false`, Vue sets the element’s `display`
    CSS property to `none` as an inline style. This effectively hides the element
    (and its contents) from view, though it’s still present in the DOM. If the result
    of the expression later changes to `true`, the inline style is removed and the
    element is once again shown to the user.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`v-show` 指令的工作方式与其他我们迄今为止遇到的指令略有不同。当表达式评估为 `false` 时，Vue 将元素的 `display` CSS
    属性设置为 `none` 作为内联样式。这实际上隐藏了元素（及其内容）的视图，尽管它仍然存在于 DOM 中。如果表达式的结果后来变为 `true`，则移除内联样式，并将元素再次显示给用户。'
- en: '|  |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-192
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: One side effect of this behavior is that any inline declaration of display you
    had will be overwritten. But have no fear, Vue will restore the original value
    when it removes its own `display:none`. Still, it’s best to avoid inline styles
    wherever possible in favor of class definitions in your stylesheet.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为的一个副作用是，您之前对显示的任何内联声明都将被覆盖。但不必担心，Vue 在移除自己的 `display:none` 时将恢复原始值。尽管如此，最好尽可能避免内联样式，而使用样式表中的类定义。
- en: '|  |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: One other thing to keep in mind is that the `v-show` directive is most effective
    when bound to a single element, rather than several adjacent elements. Here’s
    an example.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件需要注意的事情是，`v-show` 指令在绑定到单个元素时最有效，而不是绑定到多个相邻元素。以下是一个例子。
- en: 'Listing 3.12\. Wrapping content for `v-show`: chapter-03/wrap-content.html'
  id: totrans-196
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.12\. 为 `v-show` 包装内容：chapter-03/wrap-content.html
- en: '[PRE11]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '***1* Avoid using the v-show directive on adjacent elements.**'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 避免在相邻元素上使用 v-show 指令。**'
- en: '***2* Instead, wrap adjacent elements, and use a single v-show directive.**'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 相反，包装相邻元素，并使用单个 v-show 指令。**'
- en: To be clear, it’s okay to use `v-show` throughout your application wherever
    you need to. Whenever possible it’s best to aggregate multiple elements that will
    respond reactively to data, both for better performance and to reduce the chance
    of forgetting to keep all your elements up-to-date if you make a change. Removing
    the Add to cart button when inventory is exhausted certainly works, but it’s a
    bit drastic. Let’s try another way.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清楚起见，在您的应用程序中需要使用 `v-show` 的任何地方都是可以的。尽可能地将多个将响应式地响应用户数据的元素聚合在一起，这不仅可以提高性能，还可以减少在您进行更改时忘记更新所有元素的风险。当库存耗尽时移除“添加到购物车”按钮当然可以工作，但这有点过于激烈。让我们尝试另一种方法。
- en: 3.4.4\. Using v-if and v-else to display a disabled button
  id: totrans-201
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.4.4\. 使用 v-if 和 v-else 显示禁用按钮
- en: Removing the Add to cart button certainly keeps a customer from adding too many
    product instances to the cart, but it’s a bit heavy-handed. It might be more informative
    to the user to render the button disabled, because that doesn’t disrupt the continuity
    of the interface as much and it preserves the layout flow.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 移除“添加到购物车”按钮当然可以防止客户将过多的产品实例添加到购物车中，但这有点过于强硬。渲染按钮为禁用状态可能对用户更有信息量，因为这不会像那样破坏界面的连续性，并且保留了布局流程。
- en: The `v-if` and `v-else` directives are used to display one of two choices based
    on the truth value of the provided expression. We’ll use `canAddToCart` as a condition
    to evaluate, the way we did in the previous example.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`v-if` 和 `v-else` 指令用于根据提供的表达式的真值显示两个选择之一。我们将使用 `canAddToCart` 作为条件来评估，就像我们在前面的例子中所做的那样。'
- en: In [figure 3.13](#ch03fig13) you can see how the `v-if` directive works. If
    the `canAddToCart` is true the button appears, if not, the button doesn’t appear.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 3.13](#ch03fig13) 中，您可以查看 `v-if` 指令是如何工作的。如果 `canAddToCart` 为真，按钮就会出现，如果不为真，按钮就不会出现。
- en: Figure 3.13\. Diagram explaining how the `v-if` directive conditional works.
  id: totrans-205
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.13\. 解释 `v-if` 指令条件工作的图解。
- en: '![](03fig13_alt.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig13_alt.jpg)'
- en: In this listing we can see how this works with our `v-if` and `v-else` directives.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个列表中，我们可以看到 `v-if` 和 `v-else` 指令是如何工作的。
- en: 'Listing 3.13\. Buttons with `v-if` and `v-else` directives: chapter-03/v-if-and-v-else.html'
  id: totrans-208
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.13\. 带有 `v-if` 和 `v-else` 指令的按钮：chapter-03/v-if-and-v-else.html
- en: '[PRE12]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***1* The button is displayed when canAddToCart returns true.**'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 当 canAddToCart 返回 true 时显示按钮。**'
- en: '***2* The button to displayed when canAddToCart is false.**'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 当 canAddToCart 为 false 时显示的按钮。**'
- en: When using `v-if` and `v-else` together, we need two elements in our markup,
    one for when the condition is `true` and one for when it’s `false`. Additionally,
    the two elements need to be listed one directly after the other in the markup
    for Vue to bind to them correctly.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当一起使用 `v-if` 和 `v-else` 时，我们需要在我们的标记中包含两个元素，一个用于条件为 `true` 时，另一个用于条件为 `false`
    时。此外，这两个元素需要在标记中直接相邻列出，以便 Vue 正确地绑定到它们。
- en: 'In [listing 3.13](#ch03ex13) we use two different button elements:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 3.13](#ch03ex13) 中，我们使用了两个不同的按钮元素：
- en: If `canAddToCart` returns `true`, we render our familiar button, with the `addToCart`
    event binding, and the `default` CSS class.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `canAddToCart` 返回 `true`，我们将渲染我们熟悉的按钮，带有 `addToCart` 事件绑定和 `default` CSS
    类。
- en: If `canAddToCart` returns `false`, we render a button with no event binding
    so that it becomes unclickable and with a `disabled` CSS class so that its appearance
    changes accordingly.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `canAddToCart` 返回 `false`，我们将渲染一个没有事件绑定的按钮，使其不可点击，并带有 `disabled` CSS 类，以便其外观相应地改变。
- en: This time, when you try out the application in Chrome, the button should switch
    the active button ([figure 3.14](#ch03fig14)) to the disabled button once you’ve
    added five products to the shopping cart.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，当你尝试在 Chrome 中运行应用程序时，一旦你将五个产品添加到购物车，按钮应该将活动按钮（[图 3.14](#ch03fig14)）切换到禁用按钮。
- en: Figure 3.14\. Using `v-if` and `v-else` means we can render a disabled button,
    rather than making it disappear entirely when the inventory is exhausted.
  id: totrans-217
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.14\. 使用 `v-if` 和 `v-else` 意味着我们可以在库存耗尽时渲染一个禁用按钮，而不是让它完全消失。
- en: '![](03fig14_alt.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig14_alt.jpg)'
- en: With the `v-if` and `v-else` directives, Vue.js removes the element from the
    DOM (the `false` condition) and removes it from the other (the `true` condition).
    All of this is accomplished as part of a single, simultaneous update to the DOM.
    Try it out by fiddling with the value of `availableInventory` in the console and
    keeping an eye on the `display` property of these elements.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `v-if` 和 `v-else` 指令，Vue.js 会从 DOM（`false` 条件）中移除元素，并从另一个（`true` 条件）中移除。所有这些都是在
    DOM 的单一、同时更新中完成的。通过在控制台中调整 `availableInventory` 的值并关注这些元素的 `display` 属性来尝试一下。
- en: As with the `v-show` directive, it’s important to have a single containing element
    to attach `v-if` and `v-else` to, especially with the added criterion that the
    `v-else` markup must remain adjacent to the `v-if` markup, as shown here.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `v-show` 指令一样，将 `v-if` 和 `v-else` 绑定到一个单一包含元素上很重要，特别是考虑到 `v-else` 标记必须与 `v-if`
    标记相邻，如这里所示。
- en: Listing 3.14\. Single container elements for `v-if` and `v-else` chapter-03/single-container.html
  id: totrans-221
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.14\. `v-if` 和 `v-else` 的单个容器元素 chapter-03/single-container.html
- en: '[PRE13]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '***1* This won’t work; v-if and v-else are broken up by the second paragraph
    element.**'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 这不会起作用；v-if 和 v-else 被第二个段落元素分隔开。**'
- en: '***2* This won’t work; v-if and v-else are not adjacent in the markup.**'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 这不会起作用；v-if 和 v-else 在标记中不是相邻的。**'
- en: '***3* This will work; wrap related content in an element, then bind v-if and
    v-else to that element.**'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 这将有效；将相关内容包裹在一个元素中，然后在该元素上绑定 v-if 和 v-else。**'
- en: Keeping all the DOM elements for a given condition within an outer element—used
    as a grouping container—is the goal here. Later, we’ll explore different strategies
    that use templates or components to isolate the markup for conditionals, greatly
    simplifying the amount of markup needed in the main application itself.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 将给定条件的所有 DOM 元素都包含在一个外部元素中（用作分组容器）是这里的目标。稍后，我们将探讨使用模板或组件的不同策略，这些策略用于隔离条件性标记，极大地简化了主应用程序本身所需的标记量。
- en: 3.4.5\. Adding the cart item button as a toggle
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.4.5\. 将购物车按钮作为切换添加
- en: Let’s add a button for the checkout page. We’ll begin by adding a new method
    and property to our application.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个用于结账页面的按钮。我们将首先向我们的应用程序添加一个新的方法和属性。
- en: 'Listing 3.15\. Adding the cart button: chapter-03/cart-button.js'
  id: totrans-229
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.15\. 添加购物车按钮：chapter-03/cart-button.js
- en: '[PRE14]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '***1* This property tracks whether to show product page.**'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 此属性跟踪是否显示产品页面。**'
- en: '***2* The showCheckout method is triggered after clicking the cart button.**'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 点击购物车按钮后触发 showCheckout 方法。**'
- en: '***3* Shows the ternary operation that toggles between true and false**'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 显示在真和假之间切换的三元操作**'
- en: The new `showProduct` property will toggle the display of the checkout page.
    Let’s look at that in more detail. The `showCheckout` method toggles the `showProduct`
    property by using something called a ternary operation in JavaScript. The *ternary
    operator* is a shortcut for the `if` statement and takes three parameters. The
    first parameter is the condition, in this case, `this.showProduct`. If it resolves
    to true, it then returns the first expression, `false`. Otherwise it returns the
    last expression, `true`. The ternary conditional operator is a useful tool to
    have in your back pocket when you need to create a quick conditional statement.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `showProduct` 属性将切换结账页面的显示。让我们更详细地看看。`showCheckout` 方法通过使用 JavaScript 中的三元运算符来切换
    `showProduct` 属性。*三元运算符*是 `if` 语句的快捷方式，并接受三个参数。第一个参数是条件，在这种情况下，`this.showProduct`。如果它解析为真，它将返回第一个表达式，`false`。否则，它返回最后一个表达式，`true`。三元条件运算符是在你需要创建快速条件语句时可以放在口袋里的有用工具。
- en: You may have noticed that the method definition was missing the `function()`
    declaration after `showCheckout()`. ES6, also known as ES2015, allows for a shorter
    syntax for method definitions. We’ll use this syntax for our method definitions
    throughout the rest of the book.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，方法定义中缺少了 `showCheckout()` 后面的 `function()` 声明。ES6，也称为 ES2015，允许方法定义有更短的语法。我们将在这本书的其余部分使用这种语法。
- en: We now need to add the button to our view and bind it to a click event.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要将按钮添加到我们的视图中，并将其绑定到点击事件。
- en: 'Listing 3.16\. Adding the cart button: chapter-03/add-cart-button.html'
  id: totrans-237
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.16\. 添加购物车按钮：chapter-03/add-cart-button.html
- en: '[PRE15]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '***1* A click event added to button triggers the showCheckout method.**'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 添加到按钮上的点击事件触发 `showCheckout` 方法。**'
- en: When the button is clicked, the `showCheckout` method will fire, causing the
    `showProduct` method to toggle, or flip, between states. The checkout button is
    important because we need somewhere to put our checkout information. We’ll look
    at this more in the next section.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当按钮被点击时，`showCheckout` 方法将被触发，导致 `showProduct` 方法在状态之间切换或翻转。结账按钮很重要，因为我们需要一个地方来放置我们的结账信息。我们将在下一节中更详细地探讨这一点。
- en: 3.4.6\. Using v-if to display a checkout page
  id: totrans-241
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.4.6\. 使用 v-if 显示结账页面
- en: Our application is limited. It only shows one product on one page. To make it
    more complete we need another page that displays checkout information. We can
    do this many different ways. In [chapter 7](kindle_split_018.html#ch07), we’ll
    learn about components which give us a way to easily break down our application
    into smaller reusable pieces. This could be one way of adding a checkout page.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序有限。它只在单页面上显示一个产品。为了使其更完整，我们需要另一个显示结账信息的页面。我们可以用多种不同的方法来做这件事。在[第 7 章](kindle_split_018.html#ch07)中，我们将学习关于组件的内容，这些组件为我们提供了一种将应用程序轻松分解成更小、可重用部分的方法。这可能是添加结账页面的一个方法。
- en: Another way is to wrap our view in a `v-if` directive and bind it to the `showProduct`
    property we created earlier. We’ll need to add the `v-if` directive to the top
    of index file after the `main` and `div` elements, as shown in this listing.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用 `v-if` 指令包裹我们的视图，并将其绑定到我们之前创建的 `showProduct` 属性。我们需要在 `main` 和 `div`
    元素之后，索引文件的顶部添加 `v-if` 指令，如本列表所示。
- en: 'Listing 3.17\. Using `v-if` to display a checkout page: chapter-03/v-if-checkout.html'
  id: totrans-244
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.17\. 使用 `v-if` 显示结账页面：chapter-03/v-if-checkout.html
- en: '[PRE16]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '***1* v-if directive that will display if showProduct is true.**'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 当 `showProduct` 为真时将显示的 `v-if` 指令。**'
- en: '***2* Shows the product listing for the view, including the picture of the
    product and description**'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 显示视图的产品列表，包括产品的图片和描述**'
- en: '***3* This is where the checkout page will go.**'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 这将是结账页面的位置。**'
- en: Earlier in the chapter, we created a checkout button. When this button is pressed,
    the `showProduct` property will toggle, from `true` to `false`, or `false` to
    `true`. This will trigger the `v-if` directive in [listing 3.17](#ch03ex17). Either
    the product information that we’ve been creating in this chapter will show, or
    a blank screen will display with only the top navigation at the top ([figure 3.15](#ch03fig15)).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期，我们创建了一个结账按钮。当按下此按钮时，`showProduct` 属性将在 `true` 和 `false` 之间切换，或从 `false`
    切换到 `true`。这将触发[列表 3.17](#ch03ex17)中的 `v-if` 指令。要么显示我们在本章创建的产品信息，要么显示一个只有顶部导航的空白屏幕([图
    3.15](#ch03fig15))。
- en: Figure 3.15\. View of webstore after checkout button is pressed. Pressing the
    checkout button again shows the product page.
  id: totrans-250
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.15\. 按下结账按钮后的网店视图。再次按下结账按钮将显示产品页面。
- en: '![](03fig15_alt.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig15_alt.jpg)'
- en: For now, don’t worry about the blank page that we see in [figure 3.15](#ch03fig15).
    This will be taken care of in the next chapter when we look into different types
    of input bindings.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，不要担心我们在[图3.15](#ch03fig15)中看到的空白页面。这将在下一章中当我们探讨不同类型的输入绑定时得到解决。
- en: 3.4.7\. Comparing v-show with v-if/v-else
  id: totrans-253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.4.7\. 比较 v-show 与 v-if/v-else
- en: Both techniques—`v-show` and `v-if/v-else`—have advantages and disadvantages,
    for a user and for us as developers. As we know, the `v-show` directive hides
    or shows an element using CSS, while the `v-if/v-else` directive removes the content
    from the DOM. With that said, understanding when to use one or the other depends
    mostly on what we’re trying to achieve, so perhaps the best way to compare them
    is to think about a few use cases for each.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种技术——`v-show` 和 `v-if/v-else`——对用户和开发者都有优点和缺点。正如我们所知，`v-show` 指令通过CSS隐藏或显示一个元素，而
    `v-if/v-else` 指令从DOM中移除内容。话虽如此，了解何时使用哪一个主要取决于我们想要实现的目标，所以也许最好的比较方式是考虑每个的几个用例。
- en: 'The `v-show` directive is best suited to scenarios where there’s no “else”
    case. That is, when you have markup to show if a condition is `true` and no alternative
    content to show when it’s `false`. Here are several possible use cases where `v-show`
    is the right choice:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`v-show` 指令最适合没有“else”情况的场景。也就是说，当条件为 `true` 时显示标记，当条件为 `false` 时不显示任何替代内容。以下是一些
    `v-show` 是正确选择的可能用例：'
- en: A message banner for things that are temporal, such as an announcement of a
    sale or a change in the Terms & Conditions.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于显示临时信息的消息横幅，例如销售公告或条款和条件变更。
- en: A signup advertisement, or other inducement, when a visitor isn’t logged in.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当访客未登录时的注册广告或其他诱导。
- en: Paging elements for lists that run across multiple pages, which would be superfluous
    if there were only one page.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于跨越多页的列表的分页元素，如果只有一页，这些元素将是多余的。
- en: 'The `v-if` and `v-else` directives are the right choice when one of two chunks
    of markup should be rendered, but *at least* one of them should always be showing.
    If there’s no fallback (else) case, then `v-show` is more appropriate. Here are
    several scenarios where `v-if` and `v-else` should be used:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个标记块中的一个应该被渲染，但至少其中一个应该始终显示时，`v-if` 和 `v-else` 指令是正确的选择。如果没有回退（else）情况，那么
    `v-show` 更为合适。以下是一些应该使用 `v-if` 和 `v-else` 的场景：
- en: Showing a Log in link for logged out users, versus a Log out link for those
    who are logged in.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于未登录的用户显示登录链接，而对于已登录的用户显示登出链接。
- en: Rendering conditional sections of a form, such as country-specific address fields
    based on a selection made by a user. For example, a U.S. address form shows a
    “state” field, where a Canadian address form shows it as a “province.”
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染表单的基于用户选择的条件部分，例如根据用户选择显示特定国家的地址字段。例如，美国地址表单显示“州”字段，而加拿大地址表单显示为“省”。
- en: Search results listings versus placeholder content when no search has been conducted.
    (We’ll explore an example that adds a third state, using `v-else-if`, in a later
    chapter.)
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索结果列表与未进行搜索时的占位符内容。（我们将在下一章中通过使用 `v-else-if` 添加第三个状态来探索一个示例。）
- en: Endless scenarios exist where you’ll need to use one conditional or the other.
    Perhaps the best way to think about which one fits your needs is to consider whether
    there’s a fallback, or default, chunk of content you want to display. Next up,
    we’re going to make our webstore a little more useful to potential customers by
    offering more than a single bag of cat food.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 无尽的情况需要使用其中一个条件或另一个。也许最好的思考方式是考虑是否有一个回退或默认的内容块要显示。接下来，我们将通过提供不止一袋猫粮来使我们的网店对潜在客户更有用。
- en: Exercise
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: 'Use your knowledge from this chapter to answer this question:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本章的知识来回答这个问题：
- en: Earlier in the chapter we looked at computed properties and methods. What are
    the differences between them?
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章早期，我们探讨了计算属性和方法。它们之间有什么区别？
- en: '*See the solution in [appendix B](kindle_split_026.html#app02).*'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '*请参阅附录B中的解决方案[appendix B](kindle_split_026.html#app02)。*'
- en: Summary
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Presenting data that isn’t inside the data object using a computed property.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用计算属性展示数据对象内部不存在的数据。
- en: Conditionally showing parts of our application with a `v-if` and `v-else` directive.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `v-if` 和 `v-else` 指令有条件地显示我们应用程序的某些部分。
- en: Adding more functionality to our application with methods.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用方法添加更多功能到我们的应用程序中。
- en: Chapter 4\. Forms and inputs
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第4章\. 表单和输入
- en: '*This chapter covers*'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Binding values to the DOM
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将值绑定到DOM
- en: Using text binding
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用文本绑定
- en: Modifiers
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修饰符
- en: Our application has evolved substantially since [chapter 1](kindle_split_011.html#ch01).
    We’ve created items and allowed users to add items to a cart. We now need a way
    for our customers to check out and enter their information. Let’s add input forms
    to our application so the customer can enter their address and billing information
    into the app. Then we need to save this information in our app for later use.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 [第 1 章](kindle_split_011.html#ch01) 以来，我们的应用程序已经发生了显著的变化。我们创建了项目，并允许用户将项目添加到购物车中。我们现在需要一种方式让我们的客户进行结账并输入他们的信息。让我们向应用程序添加输入表单，以便客户可以在应用程序中输入他们的地址和账单信息。然后我们需要将这些信息保存在我们的应用程序中以便以后使用。
- en: To accomplish our goal, we must bind the form data to our model in our application.
    The `v-model` directive was made for this use case.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现我们的目标，我们必须将表单数据绑定到我们应用程序中的模型。`v-model` 指令就是为了这个用例而设计的。
- en: '|  |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Definition
  id: totrans-280
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义
- en: The `v-model` directive creates a two-way data binding between form or text
    area inputs and the template. This assures data in our application model will
    always be in sync with our UI.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`v-model` 指令在表单或文本区域输入与模板之间创建双向数据绑定。这确保了我们的应用程序模型中的数据始终与我们的 UI 保持同步。'
- en: '|  |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Two-way data binding vs. one-way data binding**'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '**双向数据绑定与单向数据绑定**'
- en: In practice, two-way data binding ([figure 4.1](#ch04fig01)) may, or may not,
    be the best solution. In certain instances, data will never need to change after
    it’s captured from user input. Other frameworks and libraries such as React and
    Angular 2 have chosen one-way data bindings by default. Angular 1 started with
    two-way binding and dropped it for performance management reasons when building
    Angular 2\. One-way data binding occurs when data captured isn’t synced from the
    model to the view when the input changes. Additional logic needs to be added for
    the values to change in the model or view. Ember.js decided to stick with two-way
    data binding by default. With the `v-model` directive, the data is bound two ways.
    Regardless, we can specify a property as one-way bound in Vue using the `v-once`
    directive.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，双向数据绑定（[图 4.1](#ch04fig01)）可能或可能不是最佳解决方案。在某些情况下，数据在从用户输入捕获后可能永远不需要更改。其他框架和库，如
    React 和 Angular 2，默认选择单向数据绑定。Angular 1 以双向绑定开始，在构建 Angular 2 时出于性能管理的原因放弃了它。单向数据绑定发生在输入更改时，捕获的数据没有从模型同步到视图。需要添加额外的逻辑来使模型或视图中的值发生变化。Ember.js
    决定默认坚持使用双向数据绑定。使用 `v-model` 指令，数据是双向绑定的。无论如何，我们可以在 Vue 中使用 `v-once` 指令将属性指定为单向绑定。
- en: Figure 4.1\. The model updates the view while the view updates the model.
  id: totrans-286
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.1\. 模型更新视图，同时视图更新模型。
- en: '![](04fig01.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig01.jpg)'
- en: The `v-once` directive renders an element or component once only. On any additional
    re-renders, the element or component will be treated as static content and skipped.
    To learn more about the `v-once` directive, check out the official API documentation
    at [https://vuejs.org/v2/api/#v-once](https://vuejs.org/v2/api/#v-once).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`v-once` 指令仅渲染元素或组件一次。在任何额外的重新渲染中，元素或组件将被视为静态内容并跳过。要了解更多关于 `v-once` 指令的信息，请查看官方
    API 文档 [https://vuejs.org/v2/api/#v-once](https://vuejs.org/v2/api/#v-once)。'
- en: Later in the book we’ll discuss component properties and how they can be passed
    to other components. These properties form a one-way-down binding between the
    parent property and the child one. This will become useful in the future.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的后面部分，我们将讨论组件属性以及它们如何传递给其他组件。这些属性在父属性和子属性之间形成单向向下绑定。这将在未来变得很有用。
- en: '|  |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The `v-model` directive was made to work with all sorts of form inputs, including
    text boxes, text areas, check boxes, radio buttons, and select drop-down controls.
    We’ll need all these elements to build our new checkout form. Let’s look at using
    the `v-model` directive and how it works with binding inputs.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`v-model` 指令旨在与所有类型的表单输入一起工作，包括文本框、文本区域、复选框、单选按钮和下拉选择控件。我们需要所有这些元素来构建我们的新结账表单。让我们看看如何使用
    `v-model` 指令以及它是如何与绑定输入一起工作的。'
- en: 4.1\. Using v-model binding
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1\. 使用 v-model 绑定
- en: Model binding in our applications will help us update data on our user inputs
    with our template. In our application, we’ve worked primarily with the Vue data
    object to display static information. Interaction with the application has been
    limited to a few button-click events. We need to add a way for users to fill in
    their shipping information at checkout. To keep track of the form inputs, we’ll
    use the `v-model` directive and basic input bindings to add more reactivity to
    the application.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，模型绑定将帮助我们通过模板更新用户输入的数据。在我们的应用程序中，我们主要使用Vue数据对象来显示静态信息。与应用程序的交互仅限于几个按钮点击事件。我们需要添加一种方式让用户在结账时填写他们的送货信息。为了跟踪表单输入，我们将使用`v-model`指令和基本的输入绑定来为应用程序添加更多的响应性。
- en: Before we begin, you might be wondering what the differences are between the
    `v-model` directive and the `v-bind` directive that we used in [chapter 2](kindle_split_012.html#ch02).
    Keep in mind that the `v-model` directive is used mainly for input and form binding.
    We’ll use the `v-model` directive in this chapter to bind our text inputs for
    our checkout page. The `v-bind` directive is mostly used to bind HTML attributes.
    We could use `v-bind` on an `src` attribute on an `<img>` tag or bind it to the
    class attribute on a `<div>` tag for example. Both are useful, yet they’re used
    in different situations. We’ll look at the `v-bind` directive in more detail later
    in the chapter.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，你可能想知道`v-model`指令和我们在[第2章](kindle_split_012.html#ch02)中使用的`v-bind`指令之间有什么区别。记住，`v-model`指令主要用于输入和表单绑定。在本章中，我们将使用`v-model`指令来绑定我们的结账页面的文本输入。`v-bind`指令主要用于绑定HTML属性。例如，我们可以在`<img>`标签的`src`属性上使用`v-bind`，或者将其绑定到`<div>`标签的类属性上。两者都很有用，但它们在不同的场景中使用。我们将在本章的后面更详细地讨论`v-bind`指令。
- en: 'It’s worth mentioning that the `v-model` directive uses the `v-bind` directive
    behind the scenes. Let’s say you had `<input v-model="something">`. The `v-model`
    directive is syntactic sugar for `<input v-bind:"something" v-on: input="something=$event.target.value">`.
    Regardless, using the `v-model` directive is much easier to type and understand.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '值得注意的是，`v-model`指令在幕后使用了`v-bind`指令。假设你有`<input v-model="something">`。`v-model`指令是`<input
    v-bind:"something" v-on: input="something=$event.target.value">`的语法糖。无论如何，使用`v-model`指令更容易输入和理解。'
- en: In [figure 4.2](#ch04fig02) we see how the `v-model` directive is broken down.
    It is added to the input and creates a two-way data bound object.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图4.2](#ch04fig02)中，我们看到`v-model`指令是如何分解的。它被添加到输入中，创建了一个双向数据绑定对象。
- en: Figure 4.2\. Up close with the `v-model` directive
  id: totrans-297
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.2\. `v-model`指令的近距离观察
- en: '![](04fig02.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig02.jpg)'
- en: To begin, we’ll need to add new HTML to our application. Open the index.html
    page that you created in the last two chapters and look for the `v-else` directive
    (or you can download the supplied index.html file for [chapter 3](kindle_split_014.html#ch03)).
    Inside this `<div>` tag we’ll add the HTML code in this chapter. In [chapter 7](kindle_split_018.html#ch07)
    we’ll discuss a better way of breaking up our application into components. For
    now, we’ll use the simple `v-if` directive as a toggle to display our checkout
    page.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要向我们的应用程序添加新的HTML。打开你在前两章中创建的index.html页面，并查找`v-else`指令（或者你可以下载提供的index.html文件，用于[第3章](kindle_split_014.html#ch03)）。在这个`<div>`标签内，我们将添加本章中的HTML代码。在[第7章](kindle_split_018.html#ch07)中，我们将讨论将我们的应用程序分解成组件的更好方法。现在，我们将使用简单的`v-if`指令作为切换来显示我们的结账页面。
- en: As with the previous chapters, each code snippet is split into its own file.
    Please combine this with the index.html to create a completed application.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 与前几章一样，每个代码片段都分成了自己的文件。请将此与index.html结合，以创建一个完整的应用程序。
- en: 'Listing 4.1\. A `v-model` directive with first and last name inputs: chapter-04/first-last.html'
  id: totrans-301
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.1\. 包含姓氏和名字输入的`v-model`指令：chapter-04/first-last.html
- en: '[PRE17]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '***1* The firstName and lastName are bound using v-model.**'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* firstName和lastName使用v-model进行绑定。**'
- en: '***2* The firstName and lastName properties are displayed in real time as values
    change in input.**'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 随着输入中值的改变，firstName和lastName属性会实时显示。**'
- en: The code creates two text boxes for the first and last name and each text box
    is bound to a property that’s synced in real time. These properties are created
    in the data object. To make this easier, we’ll use an `order` property to keep
    these values saved in our Vue instance data object. This will be added to the
    index.html file.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 代码创建了两个用于姓氏和名字的文本框，每个文本框都绑定到一个实时同步的属性。这些属性是在数据对象中创建的。为了使这个过程更简单，我们将使用`order`属性来保存这些值到我们的Vue实例数据对象中。这将添加到index.html文件中。
- en: In the data object, we’ll need to add our new order property. We need this order
    property so we can keep track of the first and last names. Add the following code
    to the existing index.html data object that we used from the previous chapter.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据对象中，我们需要添加我们的新订单属性。我们需要这个订单属性来跟踪姓氏和名字。将以下代码添加到之前章节中使用的现有index.html数据对象中。
- en: 'Listing 4.2\. The Vue instance data object `order` property: chapter-04/data-property.js'
  id: totrans-307
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.2\. Vue实例数据对象`order`属性：chapter-04/data-property.js
- en: '[PRE18]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `order` object in this listing is in the data object inside the Vue constructor.
    We can reference this object throughout our code using the double curly brace
    Mustache syntax `{{}}` that we learned about in [chapter 2](kindle_split_012.html#ch02).
    For example, `{{order.firstName}}` will be replaced by the `firstName` from the
    `order` object. Keeping our order information in an object makes it easier to
    understand where the data is in the future.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的`order`对象位于Vue构造函数内部的数据对象中。我们可以使用我们在[第2章](kindle_split_012.html#ch02)中了解到的双大括号Mustache语法`{{}}`在代码中引用此对象。例如，`{{order.firstName}}`将被`order`对象中的`firstName`替换。将订单信息保存在对象中使得在未来更容易理解数据的位置。
- en: It’s worth mentioning that we could use an empty `order` object here and not
    define the properties `firstName` and `lastName` explicitly inside it. Vue.js
    can implicitly add the properties to the object. For the sake of simplicity, and
    to keep the code base a little cleaner, we’ll add the properties so we can see
    how everything works.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，我们在这里可以使用一个空的`order`对象，并且不需要在内部显式定义`firstName`和`lastName`属性。Vue.js可以隐式地向对象添加属性。为了简化过程，并使代码库更干净，我们将添加属性，以便我们可以看到一切是如何工作的。
- en: After typing data into our checkout form, notice that values appear in real
    time in the box ([figure 4.3](#ch04fig03)). This is the beauty of two-way data
    binding. Values are automatically synced to each other without any other logic
    needed.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在将数据输入到我们的结账表单后，请注意值会实时出现在框中（[图4.3](#ch04fig03)）。这就是双向数据绑定的美妙之处。值会自动同步，无需任何其他逻辑。
- en: Figure 4.3\. Text is updated in real time into the box at the bottom.
  id: totrans-312
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.3\. 文本实时更新到底部的框中。
- en: '![](04fig03_alt.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig03_alt.jpg)'
- en: We now have the start of our checkout page. Let’s add more form inputs to our
    index.html file so our customer can add in their address information, as shown
    next. We can add this HTML after the HTML code that we added in [listing 4.1](#ch04ex01).
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了结账页面的开始。让我们向index.html文件添加更多表单输入，以便我们的客户可以添加他们的地址信息，如下所示。我们可以在添加在[列表4.1](#ch04ex01)中的HTML代码之后添加此HTML。
- en: 'Listing 4.3\. Adding in our other text inputs and select box: chapter-04/text-input.html'
  id: totrans-315
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.3\. 添加其他文本输入和选择框：chapter-04/text-input.html
- en: '[PRE19]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '***1* Inputs text with v-model**'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用v-model输入文本**'
- en: '***2* Selects Input with v-model**'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 选择带有v-model的输入**'
- en: '***3* <pre> tag displays data**'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* `<pre>`标签显示数据**'
- en: We added our form fields for the address, city, state, and ZIP Code. The address,
    city, and ZIP Code are all text inputs that use the `v-model` directive to bind
    the input. Choosing a state is a little different. Instead of using a text box,
    we’ll use a select drop-down control. The `v-model` has been added to the select
    element.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了地址、城市、州和ZIP代码的表单字段。地址、城市和ZIP代码都是使用`v-model`指令绑定的文本输入。选择州的方式略有不同。我们不会使用文本框，而是使用选择下拉控件。`v-model`已添加到选择元素中。
- en: You might wonder how we can easily add more states to our select drop-down control.
    For this simple example, hard-coding all four states is fine. But if we were to
    add all 50 states, we’d probably want to dynamically generate the select box.
    In the next section, we’ll look at using value bindings to help generate dynamic
    options.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道我们如何轻松地为我们的下拉选择控件添加更多状态。在这个简单示例中，硬编码所有四个状态是可行的。但如果我们需要添加所有50个州，我们可能希望动态生成选择框。在下一节中，我们将探讨使用值绑定来帮助生成动态选项。
- en: Before we move on, let’s not forget to add our new properties to the data object
    in the Vue instance.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，别忘了将我们的新属性添加到Vue实例中的数据对象。
- en: 'Listing 4.4\. Updating the Vue instance data object with new properties: chapter-04/data-new-properties.js'
  id: totrans-323
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.4\. 使用新属性更新Vue实例数据对象：chapter-04/data-new-properties.js
- en: '[PRE20]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As we saw in [figure 4.3](#ch04fig03), if any of these properties are changed
    within any of the form elements, these values are updated in the `<pre>` tag at
    the bottom. Reload the browser and your new form should look like [figure 4.4](#ch04fig04).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[图4.3](#ch04fig03)中看到的，如果这些属性中的任何一个在表单元素中发生变化，这些值将在底部的`<pre>`标签中更新。重新加载浏览器，你的新表单应该看起来像[图4.4](#ch04fig04)。
- en: Figure 4.4\. Adding the address, city, state, and ZIP Code form fields into
    our checkout page.
  id: totrans-326
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.4\. 将地址、城市、州和ZIP代码表单字段添加到我们的结账页面中。
- en: '![](04fig04_alt.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig04_alt.jpg)'
- en: Our form checkout page is looking good, but we need to add in a couple more
    things. Let’s allow our customer an option to ship items as a gift. To do this,
    we’ll add a simple check box. If the check box is selected, we’ll ship the items
    as a gift. If it isn’t, selected items won’t be shipped as a gift. To keep track
    of the binding we’ll use the `order.gift` property.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的形式结账页面看起来不错，但我们需要添加一些其他内容。让我们允许我们的客户选择将商品作为礼物邮寄。为此，我们将添加一个简单的复选框。如果复选框被选中，我们将商品作为礼物邮寄。如果没有选中，则选中的商品不会作为礼物邮寄。为了跟踪绑定，我们将使用`order.gift`属性。
- en: Next up, we need to allow our customer an option to ship to a home or business
    address. Let’s add a radio button to our code for this purpose. In Vue, we must
    set the `v-model` directive in both check boxes to the same value, otherwise the
    radio buttons won’t update after they’re clicked.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要允许我们的客户选择将商品邮寄到家庭地址或商业地址。为此，让我们在我们的代码中添加一个单选按钮。在Vue中，我们必须将`v-model`指令设置在两个复选框中相同的值，否则点击后单选按钮不会更新。
- en: Finally we’ll need to update the `<pre>` tag with `order.method` and `order.gift`,
    as shown in the following listing. Add this HTML after [listing 4.3](#ch04ex03)
    in the index.html file.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要更新`<pre>`标签中的`order.method`和`order.gift`，如下面的列表所示。在index.html文件中，在[列表4.3](#ch04ex03)之后添加此HTML代码。
- en: 'Listing 4.5\. Adding check boxes and radio buttons: chapter-04/adding-buttons.html'
  id: totrans-331
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.5\. 添加复选框和单选按钮：chapter-04/adding-buttons.html
- en: '[PRE21]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '***1* Adds checkbox with v-model**'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 添加带有v-model的复选框**'
- en: '***2* Adds radio button v-model**'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 添加单选按钮v-model**'
- en: '***3* Updates <pre> tag with order.method and order.gift**'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 更新<pre>标签中的order.method和order.gift**'
- en: Let’s add our properties to our data object by adding this code.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过添加以下代码将我们的属性添加到数据对象中。
- en: 'Listing 4.6\. Adding more properties to our Vue data object: chapter-04/more-props.js'
  id: totrans-337
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.6\. 向我们的Vue数据对象添加更多属性：chapter-04/more-props.js
- en: '[PRE22]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You may have noticed that we added default values for both `method` and `gift`.
    The reason behind this is simple. By default, the method radio button is selected,
    and the check box isn’t selected. Therefore, it would be clever of us to set a
    default value in this code for now.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们为`method`和`gift`都添加了默认值。背后的原因很简单。默认情况下，方法单选按钮被选中，而复选框没有被选中。因此，我们现在在这个代码中设置一个默认值是明智的。
- en: One last thing we need to do is add a Place Order (submit) button. For now,
    we’ll mock out the button so we can use it the future. You have a couple of ways
    to create a Place Order button. You could attach an action to a form element that
    encompasses all our inputs. (We’ll look at this more in [chapter 6](kindle_split_017.html#ch06)
    on Events.) Instead, let’s use the `v-on` directive that we first learned about
    in [chapter 3](kindle_split_014.html#ch03). The `v-on` directive can bind functions
    to DOM elements in the application. Add it to the click event on the Place Order
    button. This HTML code can be added after [listing 4.5](#ch04ex05).
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后需要做的一件事是添加一个“下单”（提交）按钮。目前，我们将模拟这个按钮以便将来使用。你可以有几种方法来创建一个“下单”按钮。你可以将一个动作附加到一个包含我们所有输入的表单元素上。（我们将在[第6章](kindle_split_017.html#ch06)中更详细地探讨这一点。）相反，让我们使用我们最初在第3章中学习的`v-on`指令。`v-on`指令可以将函数绑定到应用中的DOM元素。将其添加到“下单”按钮的点击事件上。这段HTML代码可以添加到[列表4.5](#ch04ex05)之后。
- en: 'Listing 4.7\. Adding the `v-on` directive to the click event: chapter-04/adding-v-on.html'
  id: totrans-341
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.7\. 将`v-on`指令添加到点击事件：chapter-04/adding-v-on.html
- en: '[PRE23]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '***1* The Place Order button is attached to the v-on directive.**'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 下单按钮附加到v-on指令。**'
- en: In future chapters, we’ll add functionality to our Place Order button. For our
    purposes now, let’s create a simple function and verify that the button works
    by adding an alert popup. Add the `submitForm` function to the method’s object
    that exists in the index.html file, as shown in this listing.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来的章节中，我们将为“下单”按钮添加功能。就我们现在的目的而言，让我们创建一个简单的函数，并通过添加一个弹出窗口来验证按钮是否工作。将`submitForm`函数添加到存在于index.html文件中的方法对象中，如所示列表。
- en: 'Listing 4.8\. Creating the new `submitForm` method: chapter-04/submit.js'
  id: totrans-345
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.8\. 创建新的`submitForm`方法：chapter-04/submit.js
- en: '[PRE24]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Inside the Vue constructor is the `methods` object which holds all our functions
    that can be triggered in the application. The `submitForm` function will display
    an alert popup when triggered. In the browser, click the Place Order button and
    you’ll see this popup ([figure 4.5](#ch04fig05)) that was triggered by the `submitForm`
    function.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vue构造函数中是`methods`对象，它包含所有可以在应用程序中触发的函数。当触发时，`submitForm`函数将显示一个弹出窗口。在浏览器中，点击“下单”按钮，你会看到由`submitForm`函数触发的这个弹出窗口([图4.5](#ch04fig05))。
- en: Figure 4.5\. This popup was triggered by the `submitForm` function.
  id: totrans-348
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.5\. 这个弹出窗口是由`submitForm`函数触发的。
- en: '![](04fig05.jpg)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig05.jpg)'
- en: Now that we have the form in place with a Place Order button, it should look
    like [figure 4.6](#ch04fig06) when it’s all put together.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了包含“下单”按钮的表单，当所有内容都整合在一起时，它应该看起来像[图4.6](#ch04fig06)。
- en: Figure 4.6\. Completed checkout page with all form elements included.
  id: totrans-351
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.6\. 包含所有表单元素的完成结账页面。
- en: '![](04fig06_alt.jpg)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig06_alt.jpg)'
- en: Each property in the form is bound to our Vue.js model! Now let’s see if we
    can make our input bindings a little better.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 表单中的每个属性都绑定到了我们的Vue.js模型！现在让我们看看我们能否使我们的输入绑定变得更好。
- en: 4.2\. A look at value binding
  id: totrans-354
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2\. 价值绑定概述
- en: The `v-model` directive has been useful in binding properties for us so far.
    We’ve used it to bind many basic inputs. We have a problem, though. How do you
    bind the value for check boxes, radio buttons, and select drop-down controls?
    If you remember, we hard-coded the values for both check boxes and radio buttons.
    For our select box control, we left the values blank. All the HTML elements can,
    and sometimes should, have a value associated with the selected option. Instead
    of using hard-coded values, let’s rewrite our select box, check box, and radio
    buttons to use properties from our data object. Let’s begin by updating our check
    box with values by using the `v-bind` directive.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，`v-model`指令在为我们绑定属性方面非常有用。我们用它来绑定了许多基本输入。然而，我们有一个问题。如何绑定复选框、单选按钮和下拉选择控件的值？如果你记得，我们为复选框和单选按钮硬编码了值。对于我们的下拉框控件，我们留空了值。所有的HTML元素都可以，有时也应该与选定的选项关联一个值。我们不用硬编码的值，而是将我们的下拉框、复选框和单选按钮重写为使用数据对象中的属性。让我们首先通过使用`v-bind`指令来更新我们的复选框，并为其添加值。
- en: 4.2.1\. Binding values to our check box
  id: totrans-356
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.1\. 将值绑定到我们的复选框
- en: In our first example, our check box was bound to the `order.gift` property.
    We could set it to be either `true` or `false`. With that said, our customers
    don’t want to see true or false. They’d rather see a message that lets them know
    if the order will be shipped as a gift. We can add that.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个例子中，我们的复选框绑定到了`order.gift`属性。我们可以将其设置为`true`或`false`。话虽如此，我们的客户不希望看到`true`或`false`。他们更希望看到一个消息，告诉他们订单是否将以礼物形式发货。我们可以添加这样的消息。
- en: The `v-bind` directive binds values to attributes in our HTML elements. In this
    case, we’re binding the `true-value` attribute to a property. The `true-value`
    attribute is unique to the `v-bind` directive, and it allows us to bind properties
    based on the check box being checked or not, either `true` or `false`. This will
    change the value of the `order.gift`. In [listing 4.9](#ch04ex09), the `true-value`
    binds to the `order.sendGift` property. Likewise, the `false-value` binds to the
    `order.dontSendGift` property. When the check box is checked, the `order.sendGift`
    message displays. If the check box isn’t checked, the `order.dontSendGift` property
    displays. Add this HTML after [listing 4.8](#ch04ex08) in the index.html.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '`v-bind`指令将值绑定到我们的HTML元素的属性中。在这种情况下，我们将`true-value`属性绑定到一个属性上。`true-value`属性是`v-bind`指令特有的，它允许我们根据复选框是否被选中来绑定属性，即`true`或`false`。这将改变`order.gift`的值。在[列表4.9](#ch04ex09)中，`true-value`绑定到`order.sendGift`属性。同样，`false-value`绑定到`order.dontSendGift`属性。当复选框被选中时，`order.sendGift`消息显示。如果复选框没有被选中，则显示`order.dontSendGift`属性。在[index.html](#ch04ex08)之后添加此HTML。'
- en: 'Listing 4.9\. Binding `true` and `false` values to the gift check box: chapter-04/true-false.html'
  id: totrans-359
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.9\. 将`true`和`false`值绑定到礼物复选框：chapter-04/true-false.html
- en: '[PRE25]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '***1* Sets the order.sendGift property when the checkbox is checked**'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 当复选框选中时设置order.sendGift属性**'
- en: '***2* Sets the order.dontSendGift property when the checkbox isn’t checked**'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 当复选框未选中时设置order.dontSendGift属性**'
- en: '***3* Binds order.gift to the input**'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将order.gift绑定到输入**'
- en: To make this binding work as we expect, we’ll need to add in these new properties
    to our `order` object, as shown in the next listing. Update the `order` object
    in the index.html values with the `sendGift` and `dontSendGift` properties.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个绑定工作如我们所期望的那样，我们需要将这些新属性添加到我们的`order`对象中，如下一个列表所示。在index.html中更新`order`对象的值，包括`sendGift`和`dontSendGift`属性。
- en: 'Listing 4.10\. Adding the `sendGift` property to the `order` object: chapter-04/prop-gift.js'
  id: totrans-365
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.10\. 将`sendGift`属性添加到`order`对象：chapter-04/prop-gift.js
- en: '[PRE26]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '***1* The default value of checkbox defaults to the Send As A Gift check box.**'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 复选框的默认值是“作为礼物发送”复选框。**'
- en: '***2* The order.sendGift property is a text message that displays when the
    check box is checked.**'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 当复选框选中时，order.sendGift属性显示一条文本消息。**'
- en: '***3* The order.dontSendGift property is a text message that displays when
    the check box isn’t checked.**'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 当复选框未选中时，order.dontSendGift属性显示一条文本消息。**'
- en: Our data object is getting bigger! We can now assign text values if the check
    box is checked or not checked. Refresh the page and uncheck the Ship As Gift check
    box. Look at our box at the bottom ([figure 4.7](#ch04fig07)); we’ll see the new
    values represented in the `{{order.gift}}` property in the UI.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据对象正在变大！现在我们可以根据复选框是否选中来分配文本值。刷新页面并取消选中“作为礼物发送”复选框。看看我们底部的框（[图4.7](#ch04fig07)）；我们将看到在UI中的`{{order.gift}}`属性中代表的新值。
- en: Figure 4.7\. The {{order.gift}} property is displayed.
  id: totrans-371
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.7\. 显示{{order.gift}}属性。
- en: '![](04fig07_alt.jpg)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig07_alt.jpg)'
- en: Toggling the check box changes the values from the Do Not Send As A Gift to
    the Send As A Gift string. Note that because we set the `order.gift` property
    value to Send As A Gift, it will default the check box to checked. If needed,
    we could assign it to the other value. This would cause the check box to display
    as unchecked.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 切换复选框将值从“不作为礼物发送”更改为“作为礼物发送”字符串。注意，因为我们设置了`order.gift`属性值为“作为礼物发送”，它将默认复选框为选中状态。如果需要，我们可以将其分配给其他值。这将导致复选框显示为未选中状态。
- en: 4.2.2\. Working with value bindings and radio buttons
  id: totrans-374
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.2\. 使用值绑定和单选按钮工作
- en: Like check boxes, we can assign values to radio buttons. We can do this by binding
    the value directly. This could be a useful feature for our application. Let’s
    display to the user the home address if the user selects the Home radio button
    and the business address if the user selects the Business radio button. Add this
    HTML to the index.html after the previous check box code.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 与复选框一样，我们可以为单选按钮分配值。我们可以通过直接绑定值来实现这一点。这可能是我们应用程序的一个有用功能。让我们向用户显示，如果用户选择“家庭”单选按钮，则显示家庭地址；如果用户选择“商业”单选按钮，则显示商业地址。在之前的复选框代码之后，将此HTML添加到index.html中。
- en: 'Listing 4.11\. Binding values to our radio buttons: chapter-04/radio-bind.html'
  id: totrans-376
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.11\. 将值绑定到我们的单选按钮：chapter-04/radio-bind.html
- en: '[PRE27]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '***1* Sets the v-bind directive to the value attribute on the input element
    for the first radio button**'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将v-bind指令设置为第一个单选按钮的输入元素的值属性**'
- en: '***2* Sets the v-bind directive to the value attribute on the input element
    for the second radio button**'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将v-bind指令设置为第二个单选按钮的输入元素的值属性**'
- en: The `v-bind` directive binds `order.home` to the first radio button and `order.business`
    to the second radio button. This can be powerful, because we can dynamically change
    these values at any time.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '`v-bind`指令将`order.home`绑定到第一个单选按钮，将`order.business`绑定到第二个单选按钮。这很强大，因为我们可以在任何时间动态地更改这些值。'
- en: To finish this example, let’s add these new properties to the `order` object
    in data in the index.html, as shown in the following listing.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个例子，让我们将这些新属性添加到index.html中的`order`对象的数据中，如下所示。
- en: 'Listing 4.12\. Updating the `order` object with business and home: chapter-04/update-order.html'
  id: totrans-382
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.12\. 更新`order`对象以包含商业和住宅：chapter-04/update-order.html
- en: '[PRE28]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '***1* Sets the default value to the ‘Home Address’ radio button**'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将默认值设置为“家庭地址”单选按钮**'
- en: '***2* Displays the order.business property text message when the first radio
    button is selected**'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 当第一个单选按钮被选中时显示order.business属性文本消息**'
- en: '***3* Displays the order.home property text message when the second radio button
    is selected**'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 当选择第二个单选按钮时显示 order.home 属性的文本消息**'
- en: This new `order` object now has a couple of new properties—home and business—that
    are bound to the radio buttons. If we select either one, the value at the bottom
    will toggle between Home Address and Business Address ([figure 4.8](#ch04fig08)).
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的 `order` 对象现在有几个新的属性——home 和 business，它们绑定到单选按钮上。如果我们选择任何一个，底部的值将在 Home
    Address 和 Business Address 之间切换（[图 4.8](#ch04fig08)）。
- en: Figure 4.8\. Method is updated from the radio button.
  id: totrans-388
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.8\. 方法通过单选按钮更新。
- en: '![](04fig08_alt.jpg)'
  id: totrans-389
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig08_alt.jpg)'
- en: Our customer can see that they have a package being delivered to a business
    address (Erik Hanchett at 123 Street Ln, Reno, NV) and it won’t be shipped as
    a gift! Binding properties to any attribute value in our form makes things much
    cleaner and easier. We now need to look at the US states select box control in
    the next section.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的客户可以看到他们有一个包裹将被送到商业地址（Erik Hanchett 在 123 Street Ln, Reno, NV），并且它不会作为礼物发货！将属性绑定到我们的表单中的任何属性值会使事情变得更加整洁和简单。我们现在需要查看下一节中的美国州选择框控件。
- en: 4.2.3\. Learning the v-for directive
  id: totrans-391
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.3\. 学习 v-for 指令
- en: Our select box control lists US states that our customer can choose from. We
    need to update the select drop-down control so the state shows in our box when
    we refresh the page. Let’s look at how we can bind the state values. Replace the
    state drop-down in the index.html after the city input with the markup shown in
    the following listing.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的选择框控件列出了我们的客户可以选择的美国州。我们需要更新选择下拉控件，以便在刷新页面时状态显示在我们的框中。让我们看看我们如何绑定状态值。用以下列表中的标记替换
    index.html 中城市输入后的状态下拉。
- en: 'Listing 4.13\. Binding values to our select box: chapter-04/bind-select.html'
  id: totrans-393
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.13\. 将值绑定到我们的选择框：chapter-04/bind-select.html
- en: '[PRE29]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '***1* Assigns the v-bind directive value attribute to states.AL property**'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将 v-bind 指令的值属性分配给 states.AL 属性**'
- en: '***2* The v-bind directive value attribute is assigned to the states.AR property.**'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* v-bind 指令的值属性被分配给 states.AR 属性。**'
- en: '***3* The v-bind directive value attribute is assigned to the states.CA property.**'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* v-bind 指令的值属性被分配给 states.CA 属性。**'
- en: '***4* The v-bind directive value attribute is assigned to the states.NV property.**'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* v-bind 指令的值属性被分配给 states.NV 属性。**'
- en: As we saw before, the `v-bind` directive is assigning our value attribute. This
    time we’ve created a new data property called `states`. Inside that `states` property,
    I’ve listed US states. The `states` object holds four values. We can access them
    inside our select box by using the `v-bind` directive. Update the index.html file
    and add the `states` object to the data object.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`v-bind` 指令正在分配我们的值属性。这次我们创建了一个名为 `states` 的新数据属性。在 `states` 属性内部，我列出了美国州。`states`
    对象持有四个值。我们可以通过使用 `v-bind` 指令在选择框内部访问它们。更新 index.html 文件并将 `states` 对象添加到数据对象中。
- en: 'Listing 4.14\. Adding the `states` property to the Vue instance data object:
    chapter-04/states.html'
  id: totrans-400
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.14\. 将 `states` 属性添加到 Vue 实例数据对象中：chapter-04/states.html
- en: '[PRE30]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: After everything is updated, we should see these values inside our text box
    in our template at the bottom of the page ([figure 4.9](#ch04fig09)). As you can
    see, the state is spelled out, making it clear what’s happening.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 更新完所有内容后，我们应该能在页面底部的模板中的文本框内看到这些值（[图 4.9](#ch04fig09)）。正如你所见，状态被明确地拼写出来，使得发生的事情一目了然。
- en: Figure 4.9\. State text property is displaying the correct state selected.
  id: totrans-403
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.9\. 状态文本属性显示了正确选中的状态。
- en: '![](04fig09_alt.jpg)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig09_alt.jpg)'
- en: Earlier in this chapter, I mentioned a critical problem with our drop-down.
    In this example, only four states are listed. As we grow our list of states, we’ll
    need to create an `option>` tag for each one. This could be tedious and repetitive.
    Luckily, Vue has something that can help us with this. It’s called the `v-for`
    directive.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期，我提到了我们下拉列表的一个关键问题。在这个例子中，只列出了四个州。随着我们州列表的增长，我们需要为每个州创建一个 `option>` 标签。这可能会很繁琐且重复。幸运的是，Vue
    有一个可以帮助我们的东西。它被称为 `v-for` 指令。
- en: The `v-for` directive makes it easy to loop over values in a list or object,
    which is perfect for our situation. To make this work, we’ll define all our states
    in the `state` object. We’ll then iterate over every state while using the `v-bind`
    directive so everything matches. Let’s give it a shot!
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '`v-for` 指令使得在列表或对象中循环遍历值变得容易，这对于我们的情况来说非常完美。为了使这生效，我们将在 `state` 对象中定义所有我们的州。然后我们将使用
    `v-bind` 指令迭代每个州，以确保一切匹配。让我们试一试！'
- en: Many things are happening here, so I’ll break it down. The `v-for` directive
    requires a special syntax in the form of `state in states`. `states` is the source
    data array, while the `state` is an alias for the array element that is being
    iterated on. In this case, `state` is Alabama, Arizona, California, and so on.
    Replace the state drop-down in the index.html after the city input with the HTML
    as shown here.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 这里正在发生很多事情，所以我将把它分解。`v-for` 指令需要一个特殊的语法形式，即 `state in states`。`states` 是源数据数组，而
    `state` 是正在迭代的数组元素的别名。在这种情况下，`state` 是阿拉巴马州、亚利桑那州、加利福尼亚州等等。在输入城市后，将 index.html
    中的州下拉列表替换为这里显示的 HTML。
- en: 'Listing 4.15\. Updating the select drop down with `v-for`: chapter-04/select-drop-down.html'
  id: totrans-408
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.15\. 使用 `v-for` 更新选择下拉列表：chapter-04/select-drop-down.html
- en: '[PRE31]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '***1* The v-for directive iterating through the state object with each key
    and value.**'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用 `v-for` 指令遍历带有每个键和值的州对象。**'
- en: '***2* The v-bind directive value attribute is assigned to the state property.**'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将 `v-bind` 指令的值属性分配给状态属性。**'
- en: '***3* The key property is displayed.**'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 显示了键属性。**'
- en: The `key` value is an optional argument that specifies the index of the current
    item. This is important in our select drop-down control because our `key` value
    can be used as the abbreviated state, while the actual value is the full state
    name.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '`key` 值是一个可选参数，它指定了当前项的索引。这在我们的选择下拉控制中很重要，因为我们的 `key` 值可以用作缩写州名，而实际值是完整的州名。'
- en: The `v-bind` directive binds the value of `state` to the value on the `<option>`
    tag, as shown in [listing 4.16](#ch04ex16). After replacing this code in your
    application, peek at the HTML that is generated by opening up your web browser
    and looking at the source of the index.html. The `<option>` tag will show every
    state in the `states` property.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '`v-bind` 指令将 `state` 的值绑定到 `<option>` 标签上的值，如 [列表 4.16](#ch04ex16) 所示。在您的应用程序中替换此代码后，打开您的网络浏览器并查看
    index.html 的源代码，查看生成的 HTML。`<option>` 标签将显示 `states` 属性中的每个州。'
- en: 'Listing 4.16\. HTML generated by the `v-for` directive: chapter-04/options.html'
  id: totrans-415
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.16\. 由 `v-for` 指令生成的 HTML：chapter-04/options.html
- en: '[PRE32]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This is good news for our application. Because we can now bind the values and
    iterate over them with `v-for`, we no longer need to hard-code every US state.
    Our select box can grow dynamically based on how we create the `states` object.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我们应用程序是个好消息。因为我们现在可以用 `v-for` 绑定值并遍历它们，所以我们不再需要硬编码每个美国州。我们的选择框可以根据我们如何创建 `states`
    对象动态增长。
- en: 4.2.4\. The v-for directive without the optional key
  id: totrans-418
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.4\. 没有可选键的 `v-for` 指令
- en: I mentioned that the `key` value is optional, so what would a `v-for` directive
    look like without the `key` value? Taking a quick detour and seeing how that works,
    let’s start from an empty detour.html file and create a brand-new application.
    Create a Vue constructor and add in a data object with a `states` array.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到 `key` 值是可选的，那么没有 `key` 值的 `v-for` 指令会是什么样子？让我们快速偏离一下，看看它是如何工作的。让我们从一个空的
    detour.html 文件开始，创建一个全新的应用程序。创建一个 Vue 构造函数，并添加一个包含 `states` 数组的数据对象。
- en: 'Listing 4.17\. Updating the `states` object in data: chapter 04-/detour.html'
  id: totrans-420
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.17\. 更新数据中的 `states` 对象：chapter 04-/detour.html
- en: '[PRE33]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '***1* The v-for directive using the state in states syntax.**'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用 `state in states` 语法的 `v-for` 指令。**'
- en: '|  |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: More
  id: totrans-424
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 更多
- en: The `states` array has five values. Let’s create an ordered list to display
    each item. We don’t have any keys, so we don’t need to worry about that. To create
    our list, we’ll use the <`ol>` and <`li>` tags. Add these tags to the top of the
    new detour.html file.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '`states` 数组有五个值。让我们创建一个有序列表来显示每个项目。我们没有键，所以我们不需要担心这一点。要创建我们的列表，我们将使用 `<ol>`
    和 `<li>` 标签。将这些标签添加到新的 detour.html 文件顶部。'
- en: '|  |'
  id: totrans-426
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The `v-for` directive iterates through the `states` array and displays each
    `state` in the list. Keep in mind that `state` is an alias to the array element
    being iterated on, whereas `states` is the array item. It’s easy to get this confused;
    remember the alias always comes first, then the optional key, then the array or
    object being iterated on.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '`v-for` 指令遍历 `states` 数组，并在列表中显示每个 `state`。请注意，`state` 是正在迭代的数组元素的别名，而 `states`
    是数组项。很容易混淆这一点；请记住，别名总是先出现，然后是可选的键，最后是正在迭代的数组或对象。'
- en: 'When rendered, we’ll see a list of ours states in an ordered numbered list,
    as follows:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 当渲染时，我们将看到一个有序编号列表，显示我们的州，如下所示：
- en: Alabama
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 阿拉巴马州
- en: Alaska
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 阿拉斯加
- en: Arizona
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 亚利桑那州
- en: California
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加利福尼亚州
- en: Nevada
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内华达州
- en: We can now grow our list by adding values to our `states` object without having
    to change the template.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过向 `states` 对象中添加值来扩展我们的列表，而无需更改模板。
- en: '|  |'
  id: totrans-435
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-436
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You may run into a situation where you need to directly manipulate the DOM,
    and you may not want to use the `v-model` directive. In this instance Vue.js offers
    us `$el`. You can use `$el` inside your Vue instance with `this.$el`. This will
    be the root DOM element that the Vue instance is managing. From there you can
    run any type of `Document` method, like `querySelector()`, to retrieve any element
    you’d like. Remember, if you can, try to use the built-in Vue.js directives when
    working with the DOM. They are there to make your job easier! For more information
    on `$el` and other APIs check out the official API documentation at [https://vuejs.org/v2/api/](https://vuejs.org/v2/api/).
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会遇到需要直接操作 DOM 的情况，并且可能不想使用 `v-model` 指令。在这种情况下，Vue.js 为我们提供了 `$el`。你可以在 Vue
    实例中使用 `this.$el` 来使用 `$el`。这将是由 Vue 实例管理的根 DOM 元素。从那里，你可以运行任何类型的 `Document` 方法，如
    `querySelector()`，以检索你想要的任何元素。记住，如果你能的话，尝试在处理 DOM 时使用内置的 Vue.js 指令。它们是为了使你的工作更简单！有关
    `$el` 和其他 API 的更多信息，请查看官方 API 文档 [https://vuejs.org/v2/api/](https://vuejs.org/v2/api/)。
- en: '|  |'
  id: totrans-438
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 4.3\. Learning modifiers with the application
  id: totrans-439
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3\. 使用应用程序学习修饰符
- en: As mentioned earlier in the chapter, the `v-model` directive can bind to our
    input values. These values update with each input event. We can use modifiers
    with the `v-model` directive to change that behavior. We can, for example, typecast
    values to numbers using .`number` and use `.trim` with our inputs (for more information
    about modifiers, go to [https://vuejs.org/v2/guide/forms.html#Modifiers](https://vuejs.org/v2/guide/forms.html#Modifiers)).
    We can also chain modifiers by adding one after the other (for example, `v-model.trim.number`).
    Let’s add several of these modifiers to our checkout page on the application.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所述，`v-model` 指令可以绑定到我们的输入值。这些值会随着每个输入事件而更新。我们可以使用修饰符与 `v-model` 指令来改变这种行为。例如，我们可以使用
    `.number` 来将值转换为数字，并使用 `.trim` 来处理我们的输入（有关修饰符的更多信息，请参阅 [https://vuejs.org/v2/guide/forms.html#Modifiers](https://vuejs.org/v2/guide/forms.html#Modifiers)）。我们还可以通过依次添加修饰符来链式使用修饰符（例如，`v-model.trim.number`）。让我们在我们的应用程序的结账页面上添加几个这些修饰符。
- en: 4.3.1\. Using the .number modifier
  id: totrans-441
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.3.1\. 使用 `.number` 修饰符
- en: The `.number` modifier is used to automatically typecast values in the `v-model`
    directive as a number. This will be useful in our ZIP input box (we’ll assume
    ZIP Codes in our app don’t start with a zero, otherwise the `.number` modifier
    removes the leading zero). Let’s update the ZIP Code in the index.html file to
    use the `.number` modifier and see what effect it has in the following listing.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '`.number` 修饰符用于自动将 `v-model` 指令中的值转换为数字。这将在我们的 ZIP 输入框中很有用（我们假设我们的应用程序中的 ZIP
    码不以零开头，否则 `.number` 修饰符会移除前导零）。让我们更新 index.html 文件中的 ZIP 码以使用 `.number` 修饰符，并查看以下列表中的效果。'
- en: 'Listing 4.18\. The `.number` modifier on the ZIP form element: chapter-04/number-mod.html'
  id: totrans-443
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.18\. ZIP 表单元素上的 `.number` 修饰符：chapter-04/number-mod.html
- en: '[PRE34]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '***1* Shows the v-model directive with the .number modifier**'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 显示带有 .number 修饰符的 v-model 指令**'
- en: HTML inputs always return as strings, even if you add in `type="number"`. Adding
    the `.number` modifier prevents this behavior and instead returns as a number.
    To verify this, let’s update the index.html with the `typeof` operator while displaying
    the `order.zip` property in the template.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 输入始终返回字符串，即使你添加了 `type="number"`。添加 `.number` 修饰符可以防止这种行为，并返回一个数字。为了验证这一点，让我们在模板中显示
    `order.zip` 属性的同时，更新 index.html 以使用 `typeof` 操作符。
- en: 'Listing 4.19\. Using the `typeof` operator on `order.zip`: chapter-04/type-of.html'
  id: totrans-447
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.19\. 在 `order.zip` 上使用 `typeof` 操作符：chapter-04/type-of.html
- en: '[PRE35]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '***1* The JavaScript typeof operator returns the type of the unevaluated operand.**'
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* JavaScript typeof 操作符返回未评估操作数的类型。**'
- en: Before we added the `.number` modifier, it would have displayed as a string.
    Now it returns as a number. Type a number into the ZIP input box and re-render
    the page to see the new output< as seen in [figure 4.10](#ch04fig10).
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加 `.number` 修饰符之前，它将以字符串的形式显示。现在它返回一个数字。在 ZIP 输入框中输入一个数字，然后重新渲染页面以查看新的输出<如[图
    4.10](#ch04fig10)所示。
- en: Figure 4.10\. Type of value entered into the zip property.
  id: totrans-451
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.10\. 输入到 zip 属性中的值的类型。
- en: '![](04fig10_alt.jpg)'
  id: totrans-452
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig10_alt.jpg)'
- en: You can see the ZIP column shows number in [figure 4.10](#ch04fig10). Because
    we wrapped the ZIP Code in the `typeof` operand, it shows us the type of that
    property. We’ll be using this feature later; for now we’ll remove the `typeof`
    operand so it returns the ZIP Code. Delete the `typeof` operand from the `order.zip`
    property so all that remains is the property `{{order.zip}}`.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到 ZIP 列显示的是 [图 4.10](#ch04fig10) 中的数字。因为我们用 `typeof` 操作符包裹了 ZIP Code，所以它显示了该属性的类型。我们将在稍后使用这个功能；现在我们将移除
    `typeof` 操作符，以便它返回 ZIP Code。从 `order.zip` 属性中删除 `typeof` 操作符，剩下的只是属性 `{{order.zip}}`。
- en: 4.3.2\. Trimming the input values
  id: totrans-454
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.3.2\. 修剪输入值
- en: When extracting form information, we often have no use for preceding whitespace
    or whitespace after the text has been entered. If a user accidentally enters a
    few spaces before typing their name, we need to remove them. Vue.js gives us a
    nice modifier to trim the space automatically from our inputs.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 在提取表单信息时，我们通常不需要使用文本输入前的空白或文本输入后的空白。如果用户在输入名字之前不小心输入了一些空格，我们需要移除它们。Vue.js 给我们提供了一个很好的修饰符来自动修剪输入中的空格。
- en: In our application, we use input-string text boxes for the first name, last
    name, address, and city. In the following listing, let’s update the first name
    and last name in the index.html to see how the `.trim` modifier works.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们使用输入字符串文本框来输入名字、姓氏、地址和城市。在下面的列表中，让我们更新 index.html 中的名字和姓氏，看看 `.trim`
    修饰符是如何工作的。
- en: 'Listing 4.20\. The `.trim` modifier on first and last name: chapter-04/trim-mod.html'
  id: totrans-457
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.20\. 名字和姓氏上的 `.trim` 修饰符：chapter-04/trim-mod.html
- en: '[PRE36]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '***1* The v-model directive uses the .trim modifier for the order.firstName
    property.**'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* v-model 指令为 order.firstName 属性使用 `.trim` 修饰符。**'
- en: '***2* The v-model directive uses the .trim modifier for the order.lastName
    directive.**'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* v-model 指令为 order.lastName 指令使用 `.trim` 修饰符。**'
- en: To add the `.trim` modifier all we need to do is add `.trim` to the end of the
    `v-model` directive. This will now trim our whitespace automatically for us! Now
    we can add it to the address and city inputs in the index.html.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加 `.trim` 修饰符，我们只需要在 `v-model` 指令的末尾添加 `.trim`。现在它会自动为我们修剪空白！现在我们可以将其添加到 index.html
    中的地址和城市输入中。
- en: 'Listing 4.21\. The `.trim` modifier on the address and city: chapter-04/trim-mod-add.html'
  id: totrans-462
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.21\. 地址和城市上的 `.trim` 修饰符：chapter-04/trim-mod-add.html
- en: '[PRE37]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '***1* The v-model directive uses the .trim modifier for the order.address property.**'
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* v-model 指令为 order.address 属性使用 `.trim` 修饰符。**'
- en: '***2* The v-model directive uses the .trim modifier for the order.city directive.**'
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* v-model 指令为 order.city 指令使用 `.trim` 修饰符。**'
- en: If we look at the output at the bottom of the page after browser refresh, we’ll
    notice that the whitespace is removed ([figure 4.11](#ch04fig11)).
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在浏览器刷新后查看页面底部的输出，我们会注意到空白已被移除 ([图 4.11](#ch04fig11))。
- en: Figure 4.11\. An example of using the `.trim` modifier on the `v-model` directive.
  id: totrans-467
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.11\. 在 `v-model` 指令上使用 `.trim` 修饰符的示例。
- en: '![](04fig11_alt.jpg)'
  id: totrans-468
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig11_alt.jpg)'
- en: The first name input text box has the name Erik in it with many preceding whitespaces.
    With that said, the output at the bottom has the trimmed value on display. In
    fact, if we click outside the box, the value in the first name box syncs to the
    trimmed value. This is the power of the `.trim` modifier.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 名字输入文本框中包含名为 Erik 的内容，前面有许多空格。换句话说，底部的输出显示了修剪后的值。实际上，如果我们点击框外，名字框中的值会同步到修剪后的值。这就是
    `.trim` 修饰符的力量。
- en: 4.3.3\. The .lazy v-model modifier
  id: totrans-470
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.3.3\. `.lazy` v-model 修饰符
- en: There is one last modifier that is known as the `.lazy` modifier. As I mentioned
    earlier, the `v-model` directive syncs after each input event. In practice, this
    occurs in a text box after each letter is typed. The value is synced on each keystroke.
    The `.lazy` modifier will sync on change events instead. Change events occur in
    a variety of situations depending on the form element used. A check box or radio
    button will trigger a change event when it’s clicked. An input text box will trigger
    a change event when it loses focus. Different browsers might not trigger change
    events on the same interactions, so keep that in mind.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 最后还有一个名为 `.lazy` 的修饰符。如我之前提到的，`v-model` 指令在每个输入事件后同步。在实践中，这发生在文本框中每个字母输入后。值在每个按键时同步。`.lazy`
    修饰符将在更改事件上同步。更改事件发生在各种情况下，具体取决于表单元素的使用。复选框或单选按钮在点击时会触发更改事件。输入文本框在失去焦点时会触发更改事件。不同的浏览器可能在相同的交互上不会触发更改事件，所以请记住这一点。
- en: 'Typically, a `.lazy` modifier will look like the following when added to a
    `v-model` directive:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当添加到 `v-model` 指令时，`.lazy` 修饰符看起来如下：
- en: '[PRE38]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Exercise
  id: totrans-474
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: 'Use your knowledge from this chapter to answer these questions:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本章的知识来回答这些问题：
- en: How does two-way data binding work? When should you use it in your Vue.js application?
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双向数据绑定是如何工作的？在您的 Vue.js 应用程序中何时应该使用它？
- en: '*See the solution in [appendix B](kindle_split_026.html#app02).*'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '*请参阅[附录 B](kindle_split_026.html#app02)中的解决方案。*'
- en: Summary
  id: totrans-478
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: The `v-model` directive can be used to bind input, select, text areas, and components.
    It creates a two-way data binding on form input elements and components.
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v-model` 指令可以用于绑定输入、选择、文本区域和组件。它为表单输入元素和组件创建双向数据绑定。'
- en: The `v-for` directive renders data multiple times based on the data that it’s
    given. You can use an alias in the expression on the current element being iterated
    on as well.
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v-for` 指令根据提供的数据多次渲染数据。您还可以在当前正在迭代的元素的表达式中使用别名。'
- en: The v-`model` directive has the `.trim`, `.lazy`, and `.number` modifiers. The
    `.trim` modifier eliminates whitespace while the `.number` modifier typecasts
    strings as numbers. The `.lazy` modifier changes when data is synced.
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v-model` 指令具有 `.trim`、`.lazy` 和 `.number` 修饰符。`.trim` 修饰符会消除空白字符，而 `.number`
    修饰符将字符串类型转换为数字。`.lazy` 修饰符在数据同步时改变。'
- en: Chapter 5\. Conditionals, looping, and lists
  id: totrans-482
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 5 章\. 条件、循环和列表
- en: '*This chapter covers*'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Working with the conditionals `v-if` and `v-if-else`
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `v-if` 和 `v-if-else` 条件进行工作
- en: Looping using `v-for`
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `v-for` 进行循环
- en: Looking at array changes
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看数组变化
- en: In the previous chapter, we saw the power of the `v-model` directive and how
    we can use it to bind inputs to our application. We constructed a checkout page
    that displayed all the input forms we needed to gather from the user. To display
    this page, we used a conditional statement.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了 `v-model` 指令的力量以及我们如何使用它来绑定输入到我们的应用程序。我们构建了一个显示我们所需收集的所有输入表单的结账页面。为了显示此页面，我们使用了条件语句。
- en: In [chapter 3](kindle_split_014.html#ch03), we created a checkout button bound
    to a click event method. This method toggles a property called `showProduct`.
    In our template, we used the `v-if` directive and the `v-else` directive. If `showProduct`
    was `true`, the product page was displayed; if `showProduct` was `false`, the
    checkout page was displayed. By clicking the checkout button, users can easily
    switch between these pages. In later chapters, we’ll look at refactoring this
    code to use components and routes, but for now this will work.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 3 章](kindle_split_014.html#ch03)中，我们创建了一个绑定到点击事件方法的结账按钮。该方法切换一个名为 `showProduct`
    的属性。在我们的模板中，我们使用了 `v-if` 指令和 `v-else` 指令。如果 `showProduct` 为 `true`，则显示产品页面；如果
    `showProduct` 为 `false`，则显示结账页面。通过点击结账按钮，用户可以轻松地在这些页面之间切换。在后面的章节中，我们将探讨如何重构此代码以使用组件和路由，但现在这将是可行的。
- en: To expand our app, we’ll look at other types of conditionals. For example, we
    need to add a new feature that displays messages to the user based on available
    inventory levels. In addition, we need to add more products to our product page.
    We’ll look at that more closely in [section 5.2](#ch05lev1sec2).
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 为了扩展我们的应用程序，我们将探讨其他类型的条件。例如，我们需要添加一个新功能，根据可用库存水平向用户显示消息。此外，我们还需要在我们的产品页面上添加更多产品。我们将在[第
    5.2 节](#ch05lev1sec2)中更详细地探讨这一点。
- en: 5.1\. Show an available inventory message
  id: totrans-490
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1\. 显示可用库存信息
- en: Every time an additional item is added to our shopping cart, the `cartItemCount`
    computed property is updated. What if we want to let the user know how many are
    available? Let’s display a few messages when the available inventory is almost
    out. We’ll use the `v-if`, `v-else-if`, and `v-else` directives to make this possible.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们向购物车添加额外项目时，`cartItemCount` 计算属性都会更新。如果我们想让用户知道有多少是可用的呢？让我们在可用库存即将耗尽时显示一些消息。我们将使用
    `v-if`、`v-else-if` 和 `v-else` 指令来实现这一点。
- en: 5.1.1\. Adding how many are left with v-if
  id: totrans-492
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.1\. 使用 v-if 添加剩余数量
- en: Before we begin, let’s add more inventory. This will make it easier to display
    a message to the user as they put more items into their cart. To add inventory,
    we can update our product property in the data object. Edit the `availableInventory`
    product property in index.html. Let’s change it from 5 to 10, as shown in [listing
    5.1](#ch05ex01). That should be enough for now.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，让我们添加更多库存。这将使用户在将更多项目放入购物车时更容易显示消息。为了添加库存，我们可以更新数据对象中的产品属性。编辑 index.html
    中的 `availableInventory` 产品属性。让我们将其从 5 更改为 10，如[列表 5.1](#ch05ex01)所示。现在应该足够了。
- en: If you’ve been following along from previous chapters, you should have an index.html
    file. If not, you can always download the completed [chapter 4](kindle_split_015.html#ch04)
    index.html file that’s included with this book as a starting point, along with
    any code snippets and CSS. As always, each listing is broken into its own file.
    Make sure to add each snippet into index.html as you continue.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经跟随前面的章节，您应该有一个index.html文件。如果没有，您可以从本书中下载包含的[第4章](kindle_split_015.html#ch04)
    index.html文件作为起点，以及任何代码片段和CSS。一如既往，每个列表都被拆分到自己的文件中。确保在继续时将每个片段添加到index.html中。
- en: 'Listing 5.1\. Updating the inventory: chapter-05/update-inventory.js'
  id: totrans-495
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.1\. 更新库存：chapter-05/update-inventory.js
- en: '[PRE39]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '***1* Adds inventory**'
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 添加库存**'
- en: Now that the inventory has been updated, let’s add a conditional to the template
    when the available inventory is low. We’ll display a message showing the remaining
    inventory that the user can add to their cart. In [listing 5.2](#ch05ex02) we
    can see the new span tag with the `v-if` directive. A class called `inventory-message`
    was also added to this span. This CSS makes the message stand out better and positions
    it correctly. I’ve added basic formatting to make our message look a little nicer.
    The `v-if` directive is flexible. You’ll notice that we aren’t using a specific
    property the way we did in [chapter 3](kindle_split_014.html#ch03) with `showProduct`.
    Instead, we’re using an expression. This is a nice touch that Vue.js allows us
    to do.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 现在库存已经更新，让我们在模板中添加一个条件，当可用库存低时。我们将显示一个消息，显示用户可以添加到购物车中的剩余库存。在[列表5.2](#ch05ex02)中，我们可以看到带有`v-if`指令的新span标签。还添加了一个名为`inventory-message`的类到这个span标签。这个CSS使得消息更加突出，并正确地定位它。我已经添加了基本的格式化，使我们的消息看起来更美观。`v-if`指令是灵活的。您会注意到，我们并没有像在第3章（kindle_split_014.html#ch03）中使用`showProduct`那样使用特定的属性，而是使用了一个表达式。这是Vue.js允许我们做的很好的一件事。
- en: When the Add to cart button is clicked, the checkout number at the top increments.
    When the inventory reaches fewer than 5 (`product.availableInventory – cartItemCount`),
    a message appears that displays the amount of remaining inventory. This count
    continues to decrement as the button is pressed until the inventory reaches zero.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击“添加到购物车”按钮时，顶部的结账数量会增加。当库存减少到5以下（`product.availableInventory – cartItemCount`）时，会出现一个消息，显示剩余库存的数量。这个计数会随着按钮的按下而继续递减，直到库存达到零。
- en: Locate the `addToCart` button in our template. Add a new span tag with our `v-if`
    directive in the index.html file, as shown here.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的模板中定位`addToCart`按钮。在index.html文件中添加一个新的span标签，并使用我们的`v-if`指令，如下所示。
- en: 'Listing 5.2\. Adding a new message based on inventory: chapter-05/add-message.html'
  id: totrans-501
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.2\. 基于库存添加新消息：chapter-05/add-message.html
- en: '[PRE40]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '***1* Span class adds a message and adds an inventory-message class**'
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* Span类添加消息和库存消息类**'
- en: '***2* The v-if directive will only display if the expression is true.**'
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* v-if指令仅在表达式为真时显示。**'
- en: '|  |'
  id: totrans-505
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Reminder
  id: totrans-506
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Keep in mind the source code, including this app.css file, is available to download
    for this chapter and all other chapters from Manning at [www.manning.com/books/vue-js-in-action](http://www.manning.com/books/vue-js-in-action).
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，包括这个app.css文件在内的源代码可以从Manning在[www.manning.com/books/vue-js-in-action](http://www.manning.com/books/vue-js-in-action)提供的所有章节中下载。
- en: '|  |'
  id: totrans-508
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: We could have used a computed property in this `v-if` directive but for the
    sake of simplicity, using an expression like this will work. Keep in mind that
    if your expressions are getting too long inside your template, you’re probably
    better off using a computed property.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这个`v-if`指令中使用计算属性，但为了简单起见，使用这样的表达式将有效。请注意，如果您的模板中的表达式变得太长，您可能最好使用计算属性。
- en: '|  |'
  id: totrans-510
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**A quick look at v-show**'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速了解v-show**'
- en: 'The `v-show` directive is a close relative of the `v-if` directive. The use
    of both is similar: `<span v-show="product.availableInventory - cartItemCount
    < 5">Message</span>`. The only real difference is that the `v-show` directive
    will always be rendered in the DOM. Vue.js uses a simple toggle in CSS to display
    the element. If you’re confused about which one to use, use `v-if` if it’s followed
    by `v-else` or `v-else-if`. Use `v-show` if it’s more likely to be shown/rendered
    in most cases or if it’s likely that the visibility of the element will be changed
    more than once during the lifetime of the page. Otherwise, use `v-if`.'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '`v-show`指令是`v-if`指令的近亲。两者的使用方式相似：`<span v-show="product.availableInventory
    - cartItemCount < 5">Message</span>`。唯一的真正区别是`v-show`指令将始终在DOM中渲染。Vue.js使用CSS中的简单切换来显示元素。如果你对使用哪个有疑问，如果它后面跟着`v-else`或`v-else-if`，则使用`v-if`。如果它更有可能在大多数情况下显示/渲染，或者如果元素的可视性在页面生命周期中可能会改变多次，则使用`v-show`。否则，使用`v-if`。'
- en: '|  |'
  id: totrans-513
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Let’s look at what we have so far ([figure 5.1](#ch05fig01)).
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看到目前为止我们有什么([图5.1](#ch05fig01))。
- en: Figure 5.1\. Product page with only four items left, the result of using the
    `v-if` directive.
  id: totrans-515
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.1\. 只有四个商品剩余的产品页面，这是使用`v-if`指令的结果。
- en: '![](05fig01_alt.jpg)'
  id: totrans-516
  prefs: []
  type: TYPE_IMG
  zh: '![](05fig01_alt.jpg)'
- en: 5.1.2\. Adding more messaging with v-else and v-else-if
  id: totrans-517
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.2\. 使用`v-else`和`v-else-if`添加更多消息
- en: We have a slight problem. When the inventory reaches 0, the message displays
    “Only 0 left!” Obviously, that doesn’t make sense, so let’s update the code so
    it outputs a better message when the inventory reaches 0\. Add a message that
    encourages the user to buy now. This time we’ll introduce the `v-else-if` and
    `v-else` directives! Let’s break down what we want to do and how we’ll do it.
    The `v-if` directive will display if the inventory count, minus the cart item
    count, equals zero. If we add all the items to the cart, the product inventory
    is all gone.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个小问题。当库存达到0时，消息显示“只剩0个！”这显然没有意义，所以让我们更新代码，以便当库存达到0时输出更好的消息。添加一个鼓励用户现在就购买的消息。这次我们将介绍`v-else-if`和`v-else`指令！让我们分析一下我们想要做什么以及我们将如何做。`v-if`指令将在库存数量减去购物车商品数量等于零时显示。如果我们把所有商品都添加到购物车中，产品库存就会全部耗尽。
- en: In [figure 5.2](#ch05fig02), we see the completed functionality that shows a
    message (All Out) when the inventory is sold out.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图5.2](#ch05fig02)中，我们看到当库存售罄时显示消息（All Out）的完整功能。
- en: Figure 5.2\. Product page shows All Out! after the inventory is exhausted.
  id: totrans-520
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.2\. 产品页面在库存耗尽后显示“All Out!”
- en: '![](05fig02_alt.jpg)'
  id: totrans-521
  prefs: []
  type: TYPE_IMG
  zh: '![](05fig02_alt.jpg)'
- en: If the product isn’t sold out, we continue to the `v-else-if` directive. If
    the available inventory is close to selling out and fewer than five are left,
    we’ll display a message, as you can see in [figure 5.3](#ch05fig03).
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 如果产品没有售罄，我们继续到`v-else-if`指令。如果可用库存接近售罄且剩余少于五个，我们将显示一个消息，就像你在[图5.3](#ch05fig03)中看到的那样。
- en: Figure 5.3\. Shows the Buy Now! screen
  id: totrans-523
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.3\. 显示“立即购买！”屏幕
- en: '![](05fig03_alt.jpg)'
  id: totrans-524
  prefs: []
  type: TYPE_IMG
  zh: '![](05fig03_alt.jpg)'
- en: '[Figure 5.3](#ch05fig03) shows the Buy Now! message. When you click the Add
    to cart button, you should see the message change. When the inventory is fewer
    than 5, you’ll see [figure 5.1](#ch05fig01). After the inventory runs out, you’ll
    see [figure 5.2](#ch05fig02).'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.3](#ch05fig03)显示了“立即购买！”消息。当你点击“加入购物车”按钮时，你应该看到消息改变。当库存少于5时，你会看到[图5.1](#ch05fig01)。当库存耗尽后，你会看到[图5.2](#ch05fig02)。'
- en: The last `else` triggers only if both the `v-else` and `v-else-if` are `false`.
    The `v-else` directive is a catch-all when everything else falls through. If this
    occurs, we want a Buy Now message to appear next to the cart button. Update the
    span tag we added with the following code in the index.html file.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的`else`仅在`v-else`和`v-else-if`都为`false`时触发。`v-else`指令是在其他所有情况都失败时的一个通用的捕获指令。如果发生这种情况，我们希望在购物车按钮旁边显示一个“立即购买”消息。更新我们在index.html文件中添加的span标签，使用以下代码。
- en: 'Listing 5.3\. Adding multiple inventory messages: chapter 05/multiple-inventory.html'
  id: totrans-527
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.3\. 添加多个库存消息：第五章/multiple-inventory.html
- en: '[PRE41]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '***1* Shows the v-if directive that will only display if the inventory runs
    out**'
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 显示当库存耗尽时才会显示的`v-if`指令**'
- en: '***2* This directive will only trigger if the first v-if fails.**'
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 此指令仅在第一个`v-if`失败时触发。**'
- en: '***3* The v-else will trigger if both v-if and v-if-else fail.**'
  id: totrans-531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 当`v-if`和`v-if-else`都失败时，`v-else`会触发。**'
- en: '|  |'
  id: totrans-532
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Working with conditionals**'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用条件语句**'
- en: When working with `v-if`, `v-else`, and `v-else-if`, we must be aware of a few
    things. Any time you use `v-else`, it must immediately follow a `v-if` or `v-else-if`.
    You cannot create extra elements in between. Like `v-else`, `a v-else-if` must
    also immediately follow a `v-if` or `v-else-if` element. Failure to do this causes
    the `v-else-if` or `v-else` not to be recognized.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`v-if`、`v-else`和`v-else-if`时，我们必须注意几点。每次使用`v-else`时，它必须紧随一个`v-if`或`v-else-if`。你无法在之间创建额外的元素。就像`v-else`一样，`v-else-if`也必须紧随一个`v-if`或`v-else-if`元素。未能这样做会导致`v-else-if`或`v-else`不被识别。
- en: Keep in mind that the `v-else-if` directive can be used more than once in the
    same block. For example, in our application we could have included multiple messages
    when the item was close to selling out. This would have been possible with the
    `v-else-if` directive.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`v-else-if`指令可以在同一个块中使用多次。例如，在我们的应用程序中，当商品接近售罄时，我们可以包含多条消息。这可以通过`v-else-if`指令实现。
- en: With all that said, be careful with using too many conditionals and putting
    too much logic in the template. Instead, use computed properties and methods when
    needed. This will make your code easier to read and more understandable.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这里，使用过多的条件语句和在模板中放置过多的逻辑时要小心。相反，当需要时，使用计算属性和方法。这将使你的代码更容易阅读和理解。
- en: '|  |'
  id: totrans-537
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 5.2\. Looping our products
  id: totrans-538
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2\. 循环我们的产品
- en: Since we introduced our pet depot store in [chapter 2](kindle_split_012.html#ch02),
    we’ve been working with only one product. This has worked well up to now with
    the examples in previous chapters, but once we add more products, we’ll need a
    way to display them all in our template. In addition, we want to show a simple
    star rating at the bottom of each product. The versatile `v-for` directive can
    handle both scenarios.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 自从我们在[第 2 章](kindle_split_012.html#ch02)中介绍了我们的宠物仓库商店以来，我们一直在使用单一的产品。到目前为止，这在前几章的示例中效果很好，但一旦我们添加更多产品，我们就需要在模板中显示它们。此外，我们还想在每件产品的底部显示一个简单的星级评级。多功能的`v-for`指令可以处理这两种情况。
- en: 5.2.1\. Adding a star rating with v-for range
  id: totrans-540
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.1\. 使用`v-for`范围添加星级评级
- en: Vue.js has the `v-for` directive to loop through items, as we saw briefly in
    [chapter 4](kindle_split_015.html#ch04). It’s worth mentioning that we can use
    it with objects, arrays, or even components. One of the simplest ways of using
    the `v-for` directive is by giving it an integer. When added to an element, it
    will be repeated that many times, which is sometimes referred as a `v-for` range.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js 有`v-for`指令来遍历项目，正如我们在[第 4 章](kindle_split_015.html#ch04)中简要看到的。值得一提的是，我们可以用它与对象、数组甚至组件一起使用。使用`v-for`指令的最简单方法之一是给它一个整数。当添加到元素中时，它将重复那么多次，这有时被称为`v-for`范围。
- en: Let’s begin by adding a five-star rating system to our product. To keep it simple,
    let’s use a span tag and add the `v-for` directive to it. The `v-for` syntax is
    always in the form of `item in items`. The `items` refers to the source array
    data being iterated on. The `item` is an alias element being iterated on. As you
    can see in [figure 5.4](#ch05fig04), the `v-for` directive uses the `item` as
    an alias of `items`. The `items` is an array.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从添加一个五星评级系统到我们的产品开始。为了保持简单，让我们使用`span`标签并将其`v-for`指令添加到其中。`v-for`的语法始终以`item
    in items`的形式出现。`items`指的是正在迭代的源数组数据。`item`是正在迭代的别名元素。正如你在[图 5.4](#ch05fig04)中可以看到的，`v-for`指令使用`item`作为`items`的别名。`items`是一个数组。
- en: Figure 5.4\. Diagram showing how `v-for` alias works.
  id: totrans-543
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.4\. 展示`v-for`别名如何工作的图解。
- en: '![](05fig04.jpg)'
  id: totrans-544
  prefs: []
  type: TYPE_IMG
  zh: '![05fig04.jpg]'
- en: When using `v-for` ranges, the source data is the upper inclusive limit of the
    range. This signifies how many times an element will be repeated. In [figure 5.5](#ch05fig05)
    you can see that `n` is iterated on five times.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`v-for`范围时，源数据是范围的上级包含极限。这表示一个元素将被重复多少次。在[图 5.5](#ch05fig05)中，你可以看到`n`被迭代了五次。
- en: Figure 5.5\. Diagram showing how v-for ranges works.
  id: totrans-546
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.5\. 展示`v-for`范围如何工作的图解。
- en: '![](05fig05.jpg)'
  id: totrans-547
  prefs: []
  type: TYPE_IMG
  zh: '![05fig05.jpg]'
- en: In [listing 5.4](#ch05ex04), we’re going to repeat the ![](star.jpg) symbol
    five times. We also add in a `div` with a class called `rating.` (Remember to
    download the ap.css for this book; you’ll find more information in [appendix A](kindle_split_025.html#app01).)
    Add this span as shown in the following listing inside the index.html below the
    inventory messages we added in [section 5.1](#ch05lev1sec1).
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 5.4](#ch05ex04)中，我们将重复五次![星号](star.jpg)符号。我们还添加了一个带有`rating`类的`div`元素。（请记住下载此书的ap.css文件；你可以在[附录
    A](kindle_split_025.html#app01)中找到更多信息。）将此`span`元素添加到以下列表中，位于`index.html`文件中我们添加的库存信息下方，这些信息是在[第
    5.1 节](#ch05lev1sec1)中添加的。
- en: 'Listing 5.4\. Adding star symbol using `v-for`: chapter 05/star-symbol.html'
  id: totrans-549
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.4\. 使用 `v-for` 添加星号：chapter 05/star-symbol.html
- en: '[PRE42]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '***1* Repeats the star symbol five times**'
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 重复星号符号五次**'
- en: Once we add the stars to the template, refresh your browser. It should look
    like [figure 5.6](#ch05fig06).
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将星级添加到模板中，请刷新您的浏览器。它应该看起来像[图 5.6](#ch05fig06)。
- en: Figure 5.6\. With star rating
  id: totrans-553
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.6\. 带有星级
- en: '![](05fig06_alt.jpg)'
  id: totrans-554
  prefs: []
  type: TYPE_IMG
  zh: '![05fig06_alt.jpg](05fig06_alt.jpg)'
- en: 'As you can see, there isn’t much to show with our star rating: each star is
    empty. We’ll need a way to dynamically bind a class to our CSS so we can show
    a filled-in star.'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的星级评分没有太多可以展示的：每个星号都是空的。我们需要一种方法来动态地将类绑定到我们的 CSS，以便显示填充的星号。
- en: 5.2.2\. Binding an HTML class to our star rating
  id: totrans-556
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.2\. 将 HTML 类绑定到我们的星级评分
- en: Vue.js gives us a way to dynamically add or remove classes to HTML elements
    in our template. We can pass data objects, arrays, expressions, methods, or even
    computed properties to help determine which classes appear.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js 给我们一种方法，可以动态地向模板中的 HTML 元素添加或删除类。我们可以传递数据对象、数组、表达式、方法，甚至是计算属性，以帮助确定哪些类出现。
- en: Before we can get started, we need to edit the product data object property
    and add a rating. This rating will determine how many stars each product should
    display. Open the index.html file and find the `product` property under order.
    Add the rating to the bottom of the product property, as shown in the following
    listing.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我们需要编辑产品数据对象属性并添加一个评分。这个评分将决定每个产品应该显示多少颗星。打开 index.html 文件，在 order 下找到
    `product` 属性。将评分添加到产品属性底部，如下所示。
- en: 'Listing 5.5\. Adding to the `product` property: chapter 05/add-product.js'
  id: totrans-559
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.5\. 添加到 `product` 属性：chapter 05/add-product.js
- en: '[PRE43]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '***1* Adds a new rating property**'
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 添加新的评分属性**'
- en: Next, we need to display the star rating on the screen. The easiest way of doing
    this is with CSS and a little bit of JavaScript. We’ll add simple CSS that creates
    a black star when the class is added to our span element. For our example, we’ll
    need the first three stars to appear black. The last two remaining stars will
    appear as white. [Figure 5.7](#ch05fig07) is an example of what it should look
    like when we’re done.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在屏幕上显示星级评分。最简单的方法是使用 CSS 和一点 JavaScript。我们将添加简单的 CSS，当类被添加到我们的 span
    元素时，它会创建一个黑色星号。在我们的例子中，我们需要前三个星号显示为黑色。剩下的两个星号将显示为白色。[图 5.7](#ch05fig07) 是完成后的示例。
- en: Figure 5.7\. With filled-in star rating for the cat food product
  id: totrans-563
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.7\. 填充星级的猫粮产品
- en: '![](05fig07_alt.jpg)'
  id: totrans-564
  prefs: []
  type: TYPE_IMG
  zh: '![05fig07_alt.jpg](05fig07_alt.jpg)'
- en: As I mentioned, we can use a method to help determine whether a class should
    appear. Because we’re using a `v-for` range, we’ll need to pass in the range to
    a method. Let’s add a new method that reads the rating from the product and then
    returns `true` if the class should be added or not to the span. The class will
    make the star black.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我提到的，我们可以使用一个方法来帮助确定是否应该出现一个类。因为我们使用的是 `v-for` 范围，所以我们需要将范围传递给一个方法。让我们添加一个新的方法，该方法从产品中读取评分，然后根据是否应该将类添加到
    span 中返回 `true` 或 `false`。这个类将使星号变黑。
- en: To make this work, we must pass in a variable `n` to the method. The passed-in
    variable `n` comes from the `v-for` range directive `<span v-for="n in 5">`![](star.jpg)`</span>`.
    Although we didn’t display it in our template, `n` increments from 1 to 5\. The
    first loop’s `n` is 1, the next loop’s `n` is 2, and so on. We know that as `n`
    loops it will increment from 1, 2, 3, 4, to 5\. We can use simple math to determine
    if the star should be filled in.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这生效，我们必须向方法传递一个变量 `n`。传入的变量 `n` 来自于 `v-for` 范围指令 `<span v-for="n in 5">`![star.jpg](star.jpg)`</span>`。尽管我们没有在模板中显示它，但
    `n` 从 1 增加到 5。第一个循环的 `n` 是 1，下一个循环的 `n` 是 2，依此类推。我们知道当 `n` 循环时，它将从 1、2、3、4 增加到
    5。我们可以使用简单的数学来确定星号是否应该被填充。
- en: In our example the first iteration `n` should be 1 and `this.product.rating`
    will always be 3\. *3 – 1 = 2* is greater or equal to 0 so we return `true` and
    the class is added. The next iteration `n` will be 2\. *3 – 2 = 1* is greater
    than or equal to 0 so it evaluates to `true` again. The next iteration `n` will
    be 3\. *3 – 3 = 0*, so the class is added again. The next iteration `n` will be
    4\. *3 – 4 = -1* and therefore the method returns `false`. It’s that simple. Add
    a new method called `checkRating` at the top of the method object in the index.html
    file, as shown here.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，第一次迭代的 `n` 应该是 1，`this.product.rating` 将始终是 3。*3 – 1 = 2* 大于或等于 0，因此我们返回
    `true` 并添加了类。下一次迭代 `n` 将是 2。*3 – 2 = 1* 大于或等于 0，因此它再次评估为 `true`。下一次迭代 `n` 将是 3。*3
    – 3 = 0*，因此类再次被添加。下一次迭代 `n` 将是 4。*3 – 4 = -1*，因此方法返回 `false`。就这么简单。在 index.html
    文件的方法对象顶部添加一个名为 `checkRating` 的新方法，如这里所示。
- en: 'Listing 5.6\. Adding a method to check if class should be added: chapter 05/check.js'
  id: totrans-568
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.6\. 添加一个检查是否应该添加类的函数：chapter 05/check.js
- en: '[PRE44]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '***1* Returns true or false depending on rating and *n***'
  id: totrans-570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 根据评分和 *n* 返回 true 或 false。**'
- en: To put our new star rating all together, we need to add the `v-bind:class` syntax
    to our span element. It will add our new class, `rating-active`, if the method
    returns `true`. Otherwise it will be ignored. In this example, we’re passing an
    object to the `v-bind:class`. The truthiness of the `checkRating` method will
    determine if the `rating-active` class is added. Because this is in a loop, we
    must also pass in the value `n`, as we discussed before, which iterates with every
    loop.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 要将我们的新星级评分全部放在一起，我们需要向我们的 span 元素添加 `v-bind:class` 语法。如果方法返回 `true`，它将添加我们新的类
    `rating-active`。否则，它将被忽略。在这个例子中，我们向 `v-bind:class` 传递了一个对象。`checkRating` 方法的真值将决定是否添加
    `rating-active` 类。因为这是一个循环，我们必须也传递之前讨论过的值 `n`，它随着每个循环迭代。
- en: Update the rating span in index.html and add the new `v-bind:class` directive
    to it, as shown in the next listing. Make sure to add the quotes around `rating-active.`
    Otherwise, you’ll get an error in the console.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 index.html 中的评分 span 并向其中添加新的 `v-bind:class` 指令，如下一列表所示。确保在 `rating-active.`
    周围添加引号。否则，您将在控制台中收到错误。
- en: 'Listing 5.7\. Adding class binding: chapter 05/add-class-bind.html'
  id: totrans-573
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.7\. 添加类绑定：chapter 05/add-class-bind.html
- en: '[PRE45]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '***1* The binding of rating-active is determined by checkRating.**'
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* rating-active 的绑定由 checkRating 决定。**'
- en: These are the basics of binding HTML classes. Vue.js allows you to add multiple
    classes and use arrays and components. For more information on how to bind classes,
    check out the official Vue.js guides on classes and style bindings at [https://vuejs.org/v2/guide/class-and-style.html](https://vuejs.org/v2/guide/class-and-style.html).
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是绑定 HTML 类的基本知识。Vue.js 允许您添加多个类并使用数组和组件。有关如何绑定类的更多信息，请参阅官方 Vue.js 指南中的类和样式绑定[https://vuejs.org/v2/guide/class-and-style.html](https://vuejs.org/v2/guide/class-and-style.html)。
- en: 5.2.3\. Setting up our products
  id: totrans-577
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.3\. 设置我们的产品
- en: Until now we’ve worked with only one product. A real pet store app would have
    hundreds if not thousands of products. We won’t go that far! Let’s see what it
    takes to add in five new products and what we could use to loop through those
    products on our product page.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只处理了一个产品。一个真正的宠物商店应用程序可能会有数百甚至数千个产品。我们不会走那么远！让我们看看添加五个新产品需要什么，以及我们可以在产品页面上循环这些产品时使用什么。
- en: To get started, we’ll look at our product object. It’s already taking up space
    in our index.html file and at this point it will be easier to put it in a separate
    file.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们将查看我们的产品对象。它已经在我们的 index.html 文件中占用了空间，在这个时候，将其放入单独的文件中会更简单。
- en: We need to create a new products.json file and add it to the chapter-05 folder.
    That way, we can more easily organize our data from our main application. If you
    want, you can add your own products, the way you did in the data object. But if
    you don’t want to type all this, you can grab the products.json file from the
    code that’s included with the book and copy it to the chapter-05 folder. You can
    find instructions on how to download the code for this book in [appendix A](kindle_split_025.html#app01).
    This listing shows the products in the products.json file.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个新的 products.json 文件并将其添加到 chapter-05 文件夹中。这样，我们可以更轻松地组织来自主应用程序的数据。如果您愿意，您可以添加自己的产品，就像在数据对象中做的那样。但如果您不想输入所有这些，您可以从书中包含的代码中获取
    products.json 文件并将其复制到 chapter-05 文件夹中。您可以在[附录 A](kindle_split_025.html#app01)中找到如何下载本书代码的说明。此列表显示了
    products.json 文件中的产品。
- en: 'Listing 5.8\. Products in the products.json file: chapter 05/products.json'
  id: totrans-581
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.8\. products.json 文件中的产品：chapter 05/products.json
- en: '[PRE46]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '***1* Shows the products array in JSON**'
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 显示产品数组在 JSON 中**'
- en: '***2* Shows the first product**'
  id: totrans-584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 显示第一个产品**'
- en: '***3* Shows the second product**'
  id: totrans-585
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 显示第二个产品**'
- en: '***4* Shows the third product**'
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 显示第三个产品**'
- en: '***5* Shows the fourth product**'
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 显示第四个产品**'
- en: '***6* Shows the fifth product**'
  id: totrans-588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 显示第五个产品**'
- en: After you’ve added or downloaded the products.json file and moved it to the
    [chapter 5](#ch05) root folder, you’ll need to do additional refactoring. If you’re
    following along, there’s a good chance you’re loading up everything locally from
    your hard drive instead of using a web server. This is perfectly fine and works
    great, except for one thing. Due to security concerns from browser creators, we
    can’t easily load our products.json file. To do this right, we need to create
    a web server.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 在您添加或下载了 products.json 文件并将其移动到 [第 5 章](#ch05) 根目录后，您需要进行额外的重构。如果您正在跟随教程，那么您很可能会从您的硬盘本地加载所有内容，而不是使用网络服务器。这完全没问题，效果也很好，除了有一点。由于浏览器制作者的安全问题，我们无法轻松地加载我们的
    products.json 文件。为了正确地做到这一点，我们需要创建一个网络服务器。
- en: '|  |'
  id: totrans-590
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Looking ahead
  id: totrans-591
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 展望未来
- en: When you run a site using a local web server, it can load JSON files from your
    hard drive with no problem, and you won’t have any security concerns. In later
    chapters, we’ll use the Vue CLI. This command-line tool will create a web server
    for us. Until we get there, we can use an npm module called http-server. You can
    find instructions on how to install npm in [appendix A](kindle_split_025.html#app01).
    This lightweight module makes it a snap to create a simple web server for our
    app.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用本地网络服务器运行网站时，它可以无问题地从您的硬盘加载 JSON 文件，并且您不会有任何安全问题。在后面的章节中，我们将使用 Vue CLI。这个命令行工具将为我们创建一个网络服务器。在我们到达那里之前，我们可以使用一个名为
    http-server 的 npm 模块。您可以在 [附录 A](kindle_split_025.html#app01) 中找到如何安装 npm 的说明。这个轻量级模块使得为我们的应用程序创建一个简单的网络服务器变得非常简单。
- en: '|  |'
  id: totrans-593
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'We’ll use npm to create a web server. Open a terminal window and run the following
    command from the command prompt to install the http-server module:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 npm 创建一个网络服务器。打开一个终端窗口，从命令提示符运行以下命令来安装 http-server 模块：
- en: '[PRE47]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'After the installation completes, change directories to the [chapter 5](#ch05)
    folder. Run the command to start a server running your index.html on port 8000:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，更改目录到 [第 5 章](#ch05) 文件夹。运行以下命令以在端口 8000 上启动一个服务器，该服务器运行您的 index.html：
- en: '[PRE48]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: If you receive any errors after running this command, verify that you don’t
    have any other programs running on port 8000. You may want to try 8001 as the
    port number instead.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在运行此命令后收到任何错误，请验证您没有在其他程序上运行端口 8000。您可能想尝试使用 8001 作为端口号。
- en: Once it starts, open your favorite web browser and head over to http://localhost:8000
    to display your web page. If the page doesn’t display, double-check the command
    line for errors. You may want to try changing the port if port 8000 is already
    taken.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启动，打开您最喜欢的网络浏览器，转到 http://localhost:8000 来显示您的网页。如果页面没有显示，请检查命令行是否有错误。您可能需要尝试更改端口，如果端口
    8000 已经被占用。
- en: 5.2.4\. Importing products from product.json
  id: totrans-600
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.4\. 从 product.json 导入产品
- en: Remember in [chapter 2](kindle_split_012.html#ch02) when we learned about Vue.js
    lifecycle hooks? We need to load our JSON file as soon as the webpage loads. One
    of those hooks would be perfect in this situation. Do you know which one? If you
    said the created lifecycle hook you are correct! The created lifecycle hook is
    called after the instance is created. We can use this hook to load the JSON file.
    To make this work we’ll need another library.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在 [第 2 章](kindle_split_012.html#ch02) 中我们学习了 Vue.js 生命周期钩子吗？我们需要在网页加载时立即加载我们的
    JSON 文件。在这种情况下，其中一个钩子将非常合适。你知道是哪一个吗？如果你说是 created 生命周期钩子，你就对了！created 生命周期钩子在实例创建后调用。我们可以使用这个钩子来加载
    JSON 文件。为了使这可行，我们需要另一个库。
- en: Axios is a promise-based HTTP client for the browser and Node.js. It has several
    helpful features such as automatic transforms of JSON data that will come in handy.
    Let’s add this library to our project. Inside the index.html, add a new script
    tag for Axios in the head tag, as shown in the following listing.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: Axios 是一个基于 Promise 的浏览器和 Node.js HTTP 客户端。它有几个有用的功能，例如自动转换即将到来的 JSON 数据，这将非常有用。让我们将这个库添加到我们的项目中。在
    index.html 中，在 head 标签内添加一个新的 Axios 脚本标签，如下所示。
- en: 'Listing 5.9\. Adding Axios script tag: chapter 05/script-tags.html'
  id: totrans-603
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.9\. 添加 Axios 脚本标签：第五章/script-tags.html
- en: '[PRE49]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '***1* Shows a CDN script tag for Axios**'
  id: totrans-605
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 显示 Axios 的 CDN 脚本标签**'
- en: After this tag is added, we can use Axios in our created lifecycle hook. Insert
    the created hook in the index.html file right after the filters object. We’ll
    need to add in code that retrieves the products.json file from the hard drive
    and overwrites our existing product data. Update the index.html and add the Axios
    code.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加此标签后，我们可以在创建的生命周期钩子中使用 Axios。在 index.html 文件中插入创建的钩子，紧接在 filters 对象之后。我们需要添加代码来从硬盘驱动器检索
    products.json 文件并覆盖现有的产品数据。更新 index.html 并添加 Axios 代码。
- en: 'Listing 5.10\. Adding Axios tag to create a lifecycle hook: chapter 05/axios-lifecycle.js'
  id: totrans-607
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.10\. 添加 Axios 标签以创建生命周期钩子：第 05 章/axios-lifecycle.js
- en: '[PRE50]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '***1* Retrieves the products.json file**'
  id: totrans-609
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 获取 products.json 文件**'
- en: '***2* Adds the response data to products**'
  id: totrans-610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将响应数据添加到 products**'
- en: The `axios.get` command takes in a location, in our case the local file. It
    then returns a promise that has a `.then` method. The promise is fulfilled or
    rejected and returns a response object. Per Axios documentation, this object has
    a data property. We copy the `response.data.products` reference to `this.products`
    (this refers to the Vue instance). To make sure everything is okay, we also console-logged
    the output.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: '`axios.get` 命令接受一个位置，在我们的例子中是本地文件。然后它返回一个具有 `.then` 方法的承诺。承诺被实现或拒绝并返回一个响应对象。根据
    Axios 文档，此对象有一个数据属性。我们将 `response.data.products` 的引用复制到 `this.products`（this 指的是
    Vue 实例）。为了确保一切正常，我们还控制台输出了输出。'
- en: If you look closely at the code in [listing 5.10](#ch05ex10), you may realize
    that we’re assigning the data from the JSON file to `this.products`, not `this.product`.
    We need to create a new `products` property on our data object because it helps
    clean up the code.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细查看 [列表 5.10](#ch05ex10) 中的代码，你可能会意识到我们正在将 JSON 文件中的数据分配给 `this.products`，而不是
    `this.product`。我们需要在我们的数据对象上创建一个新的 `products` 属性，因为它有助于清理代码。
- en: Open the index.html file and look for the data object near the middle of the
    file. Add the new `products` property and then replace the `product` property
    because we no longer need it, as shown in the following listing.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 index.html 文件，在文件中间附近查找数据对象。添加新的 `products` 属性，然后替换 `product` 属性，因为我们不再需要它，如下面的列表所示。
- en: 'Listing 5.11\. `product` property, add `products`: chapter 05/product-delete.js'
  id: totrans-614
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.11\. `product` 属性，添加 `products`：第 05 章/product-delete.js
- en: '[PRE51]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '***1* Orders object without any changes**'
  id: totrans-616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 不做任何更改的订单对象**'
- en: '***2* Shows the new products array that replaces product object**'
  id: totrans-617
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 展示替换产品对象的新的产品数组**'
- en: At this point, if you try to refresh your browser you’ll get an error because
    we removed the product object. We’ll fix that when we add the `v-for` directive
    to loop through all the products.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，如果你尝试刷新浏览器，你会得到一个错误，因为我们移除了产品对象。我们将在添加 `v-for` 指令来遍历所有产品时修复它。
- en: 5.2.5\. Refactoring our app with the v-for directive
  id: totrans-619
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.5\. 使用 v-for 指令重构我们的应用
- en: Before we can start looping through our products, we’ll need to make slight
    changes to the `div` classes that control our CSS. Because we’re using Bootstrap
    3, we want each row to be a product because we must now accommodate more than
    one product. When we get done, it will look like [figure 5.8](#ch05fig08).
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以开始遍历我们的产品之前，我们需要对控制 CSS 的 `div` 类别进行一些小的修改。因为我们使用的是 Bootstrap 3，我们希望每一行都是一个产品，因为我们现在必须容纳多个产品。完成之后，它将看起来像
    [图 5.8](#ch05fig08)。
- en: Figure 5.8\. Final update of products.
  id: totrans-621
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.8\. 产品最终的更新。
- en: '![](05fig08_alt.jpg)'
  id: totrans-622
  prefs: []
  type: TYPE_IMG
  zh: '![05fig08_alt.jpg](05fig08_alt.jpg)'
- en: Update index.html and locate the `v-else` directive that displays the checkout
    page. Add another `div` tag for a new row, as shown in the following listing.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 index.html 并定位显示结账页面的 `v-else` 指令。添加另一个 `div` 标签以创建新的行，如下面的列表所示。
- en: 'Listing 5.12\. Fixing CSS for Bootstrap: chapter 05/bootstrap-fix.html'
  id: totrans-624
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.12\. 修复 Bootstrap 的 CSS：第 05 章/bootstrap-fix.html
- en: '[PRE52]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '***1* Shows the new Bootstrap row**'
  id: totrans-626
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 展示新的 Bootstrap 行**'
- en: We’ll need to move the `div` with the class `row` that’s right before the `showProduct
    v-if` directive. Move the `div` class to the position below `showProduct`, as
    seen in the following listing. Update the index.html so it matches.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将位于 `showProduct v-if` 指令之前的具有 `row` 类的 `div` 移动。将 `div` 类移到 `showProduct`
    下方，如下面的列表所示。更新 index.html 以匹配。
- en: 'Listing 5.13\. Fixing CSS for bootstrap: chapter 05/bootstrap-fix-v-if.html'
  id: totrans-628
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.13\. 修复 bootstrap 的 CSS：第 05 章/bootstrap-fix-v-if.html
- en: '[PRE53]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '***1* Moves div for row below showProduct**'
  id: totrans-630
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将行 div 移到 showProduct 下方**'
- en: Now that we have the minor issues with the CSS/HTML resolved, we can add our
    `v-for` directive that loops through all the products. This will display all the
    products on our page. In our example, we’ll use the syntax `product in products`.
    `products` is the object that we loaded earlier; it is now an alias to each individual
    product in `products`. We’ll also update the column widths using Bootstrap so
    that our products are displayed a little nicer.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经解决了 CSS/HTML 的一些小问题，我们可以添加 `v-for` 指令来遍历所有产品。这将显示我们页面上的所有产品。在我们的例子中，我们将使用
    `product in products` 的语法。`products` 是我们之前加载的对象；现在它是 `products` 中每个单独产品的别名。我们还将使用
    Bootstrap 更新列宽，以便我们的产品显示得更好一些。
- en: Inside index.html, add the `v-for` directive below the `showProduct v-if` directive.
    Make sure to end the `div` tag at the bottom of the page, as shown here.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 在 index.html 中，在 `showProduct v-if` 指令下方添加 `v-for` 指令。确保在页面底部结束 `div` 标签，如下所示。
- en: 'Listing 5.14\. Adding the `v-for` directive for `products`: chapter 05/v-for-product.html'
  id: totrans-633
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.14\. 为 `products` 添加 `v-for` 指令：第五章/v-for-product.html
- en: '[PRE54]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '***1* Loops through all the products using the v-for directive**'
  id: totrans-635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用 v-for 指令遍历所有产品**'
- en: '***2* Changes column width to 5 without offset**'
  id: totrans-636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 不使用偏移量将列宽更改为 5**'
- en: '***3* Changes column width without offset**'
  id: totrans-637
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 不使用偏移量更改列宽**'
- en: '***4* Adds horizontal rule tag**'
  id: totrans-638
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 添加水平线标签**'
- en: '***5* Shows the closing tag for v-for directive**'
  id: totrans-639
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 显示 v-for 指令的结束标签**'
- en: We’ve added the `v-for` directive but we have a few small problems. The `checkRating`
    method and the `canAddToCart` computed property are still referencing `this.product`.
    We need to change this so it references the `this.products` array instead.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经添加了 `v-for` 指令，但还有一些小问题。`checkRating` 方法以及 `canAddToCart` 计算属性仍然引用 `this.product`。我们需要将其改为引用
    `this.products` 数组。
- en: This can be a little tricky. Let’s begin by fixing the `checkRating` method.
    This method helps us determine how many stars each product has. We can fix it
    by passing the product alias into the method. Inside index.html, update the `checkRating`
    method, as shown here.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能有点棘手。让我们先修复 `checkRating` 方法。这个方法帮助我们确定每个产品有多少颗星。我们可以通过将产品别名传递给方法来修复它。在 index.html
    中，更新 `checkRating` 方法，如下所示。
- en: 'Listing 5.15\. Updating `checkRating` with product info: chapter 05/check-rating.js'
  id: totrans-642
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.15\. 使用产品信息更新 `checkRating`：第五章/check-rating.js
- en: '[PRE55]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '***1* Shows the new checkRating method that accepts a product**'
  id: totrans-644
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 显示接受产品的新的 checkRating 方法**'
- en: We now need to update the template and pass in the product to our updated method.
    Update the index.html and look for the `checkRating` method below the inventory
    messages. Add `product` to the `checkRating` method, as shown next.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要更新模板并传递产品到更新的方法中。更新 index.html 并查找库存消息下方的 `checkRating` 方法。将 `product`
    添加到 `checkRating` 方法中，如下所示。
- en: 'Listing 5.16\. Updating template for ratings: chapter 05/update-template.html'
  id: totrans-646
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.16\. 更新模板以显示评分：第五章/update-template.html
- en: '[PRE56]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '***1* Updates the checkRating method so it accepts a product**'
  id: totrans-648
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 更新 checkRating 方法以接受一个产品**'
- en: If you haven’t done so, grab the pictures from the chapter in the assets/images
    folder and copy them to your local assets/images folder. Also grab the app.css
    file, if you haven’t already, and copy it to your assets/css folder.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有这样做，从 assets/images 文件夹中获取该章节的图片，并将它们复制到你的本地 assets/images 文件夹中。如果你还没有，也请获取
    app.css 文件，并将其复制到你的 assets/css 文件夹中。
- en: One of the last things we need to do to finish refactoring our app is to fix
    the `canAddToCart` computed property. This property greys out the Add to Cart
    button after the available inventory exceeds the amount in the cart.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成重构我们的应用程序，我们需要做的最后一件事是修复 `canAddToCart` 计算属性。这个属性在可用库存超过购物车中的数量后，将“添加到购物车”按钮变灰。
- en: You may be wondering how we can accomplish this. Before, we had only one product,
    so it was easy to figure out if that product’s inventory had been exceeded. With
    multiple products, we need to loop through every product in the cart and calculate
    whether or not we can add another item.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道我们是如何完成这个任务的。以前，我们只有一个产品，所以很容易判断该产品的库存是否超过了。现在有了多个产品，我们需要遍历购物车中的每一个产品，并计算是否可以添加另一个商品。
- en: This is easier than you might think. We need to move the `canAddToCart` computed
    property and make it a method. Then we need to update the method so it can accept
    a product. Finally, we’ll update the conditional so it retrieves the count.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 这比你想象的要简单。我们需要将 `canAddToCart` 计算属性移动并使其成为一个方法。然后我们需要更新这个方法，使其可以接受一个产品。最后，我们将更新条件以检索计数。
- en: To retrieve the count, we’ll use a new method called `cartCount` that accepts
    an ID and returns the number of items for that ID. The `cartCount` method uses
    a simple `for` loop to iterate through the cart array. For every match, it increments
    the `count` variable. It then returns that variable at the end.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索计数，我们将使用一个新的方法 `cartCount`，它接受一个 ID 并返回该 ID 的项目数量。`cartCount` 方法使用简单的 `for`
    循环遍历购物车数组。对于每个匹配项，它增加 `count` 变量。然后它在该变量结束时返回。
- en: Update index.html with the new `canAddToCart` method. You can move it from the
    computed property section to methods. Create a `cartCount` method as well.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新的 `canAddToCart` 方法更新 index.html。您可以将它从计算属性部分移动到方法中。同时创建一个 `cartCount` 方法。
- en: 'Listing 5.17\. Updating `canAddToCart` and adding `cartCount` method: chapter
    05/update-carts.js'
  id: totrans-655
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.17\. 更新 `canAddToCart` 并添加 `cartCount` 方法：第五章/更新-carts.js
- en: '[PRE57]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '***1* Returns whether the available inventory is greater than the count of
    items in the cart**'
  id: totrans-657
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1** 返回可用库存是否大于购物车中项目数量'
- en: '***2* Shows the new cartCount method that returns the number of items in the
    cart for ID**'
  id: totrans-658
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2** 显示了新的 `cartCount` 方法，它返回具有特定 ID 的购物车中的项目数量'
- en: '***3* Shows the loop that checks every item in the cart**'
  id: totrans-659
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3** 显示检查购物车中每个项目的循环'
- en: To complete our updates to `canAddToCart`, we must update our template and pass
    the product to it. At the same time, let’s update the `addToCart` method and make
    sure it also accepts a product. Update index.html and pass in the product alias
    to the `canAddToCart` and `addToCart` methods.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成对 `canAddToCart` 的更新，我们必须更新我们的模板并将产品传递给它。同时，让我们更新 `addToCart` 方法并确保它也接受一个产品。更新
    index.html 并将产品别名传递给 `canAddToCart` 和 `addToCart` 方法。
- en: 'Listing 5.18\. Updating `canAddToCart` template: chapter 05/update-can-add-cart.html'
  id: totrans-661
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.18\. 更新 `canAddToCart` 模板：第五章/更新-can-add-cart.html
- en: '[PRE58]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '***1* Updates addToCart so it accepts product**'
  id: totrans-663
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3** 更新 `addToCart` 以接受产品'
- en: '***2* Updates canAddToCart so it accepts product**'
  id: totrans-664
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2** 更新 `canAddToCart` 以接受产品'
- en: This was a simple update to both methods. Because we’ve updated the template
    to `addToCart`, we must also update the method to push the ID of the product.
    For this we’ll use the push mutation method, shown in [listing 5.19](#ch05ex19).
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对两个方法的简单更新。因为我们已经更新了模板到 `addToCart`，所以我们也必须更新方法以推送产品的 ID。为此，我们将使用推送突变方法，如[列表
    5.19](#ch05ex19)所示。
- en: '|  |'
  id: totrans-666
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Mutation methods**'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: '**突变方法**'
- en: Vue has many mutation methods that you can use with your arrays. Vue, by convention,
    wraps arrays in observers. When any changes occur to the array, the template is
    notified and updated. Mutation methods mutate the original array they’re called
    upon. These mutation methods include push, pop, shift, unshift, splice, sort,
    and reverse.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: Vue 有许多突变方法可以与您的数组一起使用。按照惯例，Vue 将数组包装在观察者中。当数组发生任何更改时，模板会收到通知并更新。突变方法会突变它们被调用的原始数组。这些突变方法包括
    push、pop、shift、unshift、splice、sort 和 reverse。
- en: 'Be careful: there are certain changes to arrays that Vue cannot detect. These
    include directly setting an item, `this.cart[index] = newValue` and modifying
    the length, `this.item.length = newLength`. To learn more about mutations, see
    the official guide at [https://vuejs.org/v2/guide/list.html#Mutation-Methods](https://vuejs.org/v2/guide/list.html#Mutation-Methods).'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Vue 无法检测到数组的一些更改。这包括直接设置一个项，`this.cart[index] = newValue` 和修改长度，`this.item.length
    = newLength`。要了解更多关于突变的信息，请参阅官方指南[https://vuejs.org/v2/guide/list.html#Mutation-Methods](https://vuejs.org/v2/guide/list.html#Mutation-Methods)。
- en: '|  |'
  id: totrans-670
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Listing 5.19\. Updating `addToCart` method: chapter 05/update-add-to-cart.js'
  id: totrans-671
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.19\. 更新 `addToCart` 方法：第五章/更新-add-to-cart.js
- en: '[PRE59]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '***1* Pushes the product ID into the cart**'
  id: totrans-673
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1** 将产品 ID 推入购物车'
- en: Now we can click the Add to cart button without any problems. Every time the
    button is clicked, the product ID will be pushed into the cart and the cart count
    will be updated automatically at the top of the screen.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以点击“添加到购物车”按钮而不会出现任何问题。每次点击按钮时，产品 ID 将被推入购物车，并且购物车数量将自动更新到屏幕顶部。
- en: The last step of our refactor is to fix the product inventory messages that
    we created earlier. The problem is that we’re still using the total cart item
    count to determine which messages to display. We need to change this code so that
    we now calculate the message based on the cart item count of only that item.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重构的最后一步是修复我们之前创建的产品库存消息。问题是我们仍在使用总购物车项目数量来确定要显示哪些消息。我们需要更改此代码，以便我们现在根据该项目的购物车项目数量来计算消息。
- en: To fix this issue, let’s change from the `cartItemCount` method to our new `cartCount`
    method, which will accept a product ID. Update the index.html and locate the inventory
    messages. Update the `v-if` and `v-else-if` directives with the new expression
    that uses `cartCount`, as shown here.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，让我们将 `cartItemCount` 方法更改为我们的新 `cartCount` 方法，该方法将接受一个产品 ID。更新 index.html
    并定位库存信息。更新 `v-if` 和 `v-else-if` 指令，使用新的表达式，该表达式使用 `cartCount`，如下所示。
- en: 'Listing 5.20\. Updating the inventory message: chapter 05/update-inventory.html'
  id: totrans-677
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.20\. 更新库存信息：第五章/更新库存.html
- en: '[PRE60]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '***1* Lists the new expression for v-if directive with cartCount**'
  id: totrans-679
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 列出了带有 cartCount 的 v-if 指令的新表达式**'
- en: '***2* Lists the new expression for v-else-if directive with cartCount**'
  id: totrans-680
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 列出了带有 cartCount 的 v-else-if 指令的新表达式**'
- en: That’s it! We can now load our page and see the results. Make sure that you
    have the http-server running `http-server -p 8000` and reload your web browser.
    You should see the updated webpage with all the items listed that were pulled
    from the products.json file. [Figure 5.9](#ch05fig09) shows our completed refactored
    app using the `v-for` directive to loop through our `products` object.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们现在可以加载我们的页面并查看结果。确保 http-server 正在运行 `http-server -p 8000`，并重新加载您的网络浏览器。您应该看到更新后的网页，其中列出了从
    products.json 文件中提取的所有项目。[图 5.9](#ch05fig09) 显示了我们使用 `v-for` 指令通过 `products` 对象循环完成的重构应用。
- en: Figure 5.9\. Showing several items that are being looped through the product.json
    file
  id: totrans-682
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.9\. 显示通过 product.json 文件循环的多个项目
- en: '![](05fig09_alt.jpg)'
  id: totrans-683
  prefs: []
  type: TYPE_IMG
  zh: '![](05fig09_alt.jpg)'
- en: In your browser, make sure that everything works as you expect. Click the Add
    to cart button and see the messages change. Verify that the button is disabled
    when the item count reaches zero. Try to change the products.json file and reload
    the browser. Everything should update accordingly.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的浏览器中，确保一切按预期工作。点击“添加到购物车”按钮并查看消息是否更改。验证当项目计数达到零时按钮是否被禁用。尝试更改 products.json
    文件并重新加载浏览器。一切都应该相应更新。
- en: 5.3\. Sorting records
  id: totrans-685
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3\. 记录排序
- en: Often when working with arrays, or objects in our case, you may want to sort
    the values when displaying them using the `v-for` directive. Vue makes this easy
    to do. In our case, we’ll need to create a computed property that returns our
    sorted results.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理数组或对象时，我们通常希望在显示它们时使用 `v-for` 指令对值进行排序。Vue 使得这一操作变得简单。在我们的例子中，我们需要创建一个计算属性，该属性返回我们的排序结果。
- en: In our app, we load the product list from the JSON file. The order displayed
    matches the order in the file. Let’s update the sort order so products are listed
    alphabetically by product title. To do this, we’ll create a new computed property
    called `sortedProducts`. We first need to update the template.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用中，我们从 JSON 文件中加载产品列表。显示的顺序与文件中的顺序相匹配。让我们更新排序顺序，使产品按产品标题字母顺序列出。为此，我们将创建一个名为
    `sortedProducts` 的新计算属性。我们首先需要更新模板。
- en: Update the index.html file and find the `v-for` directive in the template that
    lists our products. Change the `v-for` to use `sortedProducts` instead of the
    `products` object.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 index.html 文件并找到模板中列出我们的产品的 `v-for` 指令。将 `v-for` 更改为使用 `sortedProducts` 而不是
    `products` 对象。
- en: 'Listing 5.21\. Adding sorting to the template: chapter 05/add-in-sort.html'
  id: totrans-689
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.21\. 在模板中添加排序：第五章/add-in-sort.html
- en: '[PRE61]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '***1* Adds new sortedProducts computed property**'
  id: totrans-691
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 添加了新的 sortedProducts 计算属性**'
- en: Now that we’ve `sortedProducts` in place in the template, we need to create
    the computed property. But we’ve a problem to solve. We’ll need to be aware that
    the data for `this.products` may not be available right away because information
    from the products.json file is loaded from a promise in the create lifecycle hook
    as the app loads. To make sure this isn’t a problem, we’ll surround our code with
    an `if` block that verifies the products exist.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在模板中放置了 `sortedProducts`，我们需要创建计算属性。但我们有一个问题要解决。我们需要意识到 `this.products`
    的数据可能不会立即可用，因为产品.json 文件的信息是在应用加载时从 create 生命周期钩子中的 promise 加载的。为了确保这不是一个问题，我们将代码包裹在一个
    `if` 块中，该块验证产品是否存在。
- en: Let’s define our own compare function that will sort on the title, as shown
    in the following listing. Then we’ll use JavaScript’s array sort, with our passed-in
    compare function, to alphabetically sort by title.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义自己的比较函数，该函数将按标题排序，如下所示。然后我们将使用 JavaScript 的数组排序，并传递我们的比较函数，以按标题字母顺序排序。
- en: 'Listing 5.22\. `sortedProducts` computed property: chapter 05/sort-products-comp.js'
  id: totrans-694
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.22\. `sortedProducts` 计算属性：第五章/sort-products-comp.js
- en: '[PRE62]'
  id: totrans-695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '***1* Converts object to array using JavaScript’s slice**'
  id: totrans-696
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用 JavaScript 的 slice 方法将对象转换为数组**'
- en: '***2* Compares function that will compare based on title**'
  id: totrans-697
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 比较基于标题的函数**'
- en: '***3* Returns new product array**'
  id: totrans-698
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 返回新的产品数组**'
- en: That should do it. Refresh the browser and you should see an alphabetical list
    of all the products by title. [Figure 5.10](#ch05fig10) shows the output of our
    sorted array. If you scroll down, all products should be listed. Double-check
    to verify that the functionality works as expected.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 这就足够了。刷新浏览器，你应该会看到一个按标题字母顺序排列的所有产品的列表。[图5.10](#ch05fig10)显示了我们的排序数组的输出。如果你向下滚动，应该会列出所有产品。请再次检查以验证功能是否按预期工作。
- en: Figure 5.10\. Sorted products array
  id: totrans-700
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.10\. 排序后的产品数组
- en: '![](05fig10_alt.jpg)'
  id: totrans-701
  prefs: []
  type: TYPE_IMG
  zh: '![图片](05fig10_alt.jpg)'
- en: Exercise
  id: totrans-702
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: Use your knowledge from this chapter to answer this question.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本章的知识来回答这个问题。
- en: What’s a `v-for` range and how does it compare to a normal `v-for`?
  id: totrans-704
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是`v-for`范围，它与普通的`v-for`有何不同？
- en: '*See the solution in [appendix B](kindle_split_026.html#app02).*'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: '*请参阅[附录B](kindle_split_026.html#app02)中的解决方案。*'
- en: Summary
  id: totrans-706
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: Conditionals in Vue are created using the `v-if`, `v-else-if`, and `v-else`
    directives. Occasionally we’ll use the `v-show` directive but not often.
  id: totrans-707
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vue中的条件语句是通过`v-if`、`v-else-if`和`v-else`指令创建的。偶尔我们会使用`v-show`指令，但并不经常使用。
- en: The `v-for` directive is very versatile. It can be used to iterate over a range
    of positive integers (that is, starting at 1), array elements, or object property
    values and keys to replicate HTML markup, Vue templates, or Vue components. Any
    type of expression can be used to loop through items.
  id: totrans-708
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v-for`指令非常灵活。它可以用来遍历一系列正整数（即从1开始）、数组元素或对象的属性值和键，以复制HTML标记、Vue模板或Vue组件。任何类型的表达式都可以用来遍历项目。'
- en: We can easily sort values with computed properties. Computed properties can
    be used with the `v-for` directive to sort output
  id: totrans-709
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用计算属性轻松地对值进行排序。计算属性可以与`v-for`指令一起使用来排序输出
- en: Chapter 6\. Working with components
  id: totrans-710
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第6章\. 使用组件
- en: '*This chapter covers*'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Understanding parent and child relationships in components
  id: totrans-712
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解组件中的父级和子级关系
- en: Learning about local and global registration
  id: totrans-713
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解局部和全局注册
- en: Using props and prop validation
  id: totrans-714
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用属性和属性验证
- en: Adding custom events
  id: totrans-715
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加自定义事件
- en: In the previous chapters, we learned about conditionals, looping, and lists.
    Instead of repeating code, we used loops to simplify things. We used conditionals
    to show different messages depending on the user action. This works, but you may
    have noticed that our application has grown to more than 300 lines of code. The
    index.html file we’ve been updating every chapter has computed properties, filters,
    methods, lifecycle hooks, and data properties in it. With all this information,
    it’s not easy finding things.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了条件语句、循环和列表。为了避免代码重复，我们使用了循环来简化事情。我们使用条件语句来显示根据用户操作的不同消息。这很有效，但你可能已经注意到，我们的应用程序已经增长到超过300行代码。我们每章都在更新的index.html文件中包含了计算属性、过滤器、方法、生命周期钩子和数据属性。有了所有这些信息，找到东西并不容易。
- en: To help solve this, we need to separate our code and componentize it. Each part
    of the code should be reusable and allow properties and events to be passed to
    it.
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要将我们的代码分离并组件化。代码的每一部分都应该是可重用的，并允许传递属性和事件给它。
- en: Vue.js components can help us accomplish this. Before we begin, let’s look at
    several of the fundamentals of components and a few examples of how they work.
    Then we’ll look at local and global registration of components. Afterward, we’ll
    see a few examples on how to pass props and how to validate them. We’ll end the
    chapter with defining our templates and custom events.
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js组件可以帮助我们完成这项任务。在我们开始之前，让我们看看组件的一些基本原理和它们的工作方式的一些示例。然后我们将探讨组件的局部和全局注册。之后，我们将看到一些关于如何传递属性和验证它们的示例。我们将以定义我们的模板和自定义事件结束本章。
- en: You maybe be wondering what happened to our pet store application. Don’t worry,
    we’ll look at this in the next chapter when we look at single-file components,
    build tools, and Vue-CLI.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道我们的宠物商店应用程序发生了什么。别担心，我们将在下一章中查看这一点，当时我们将查看单文件组件、构建工具和Vue-CLI。
- en: 6.1\. What are components?
  id: totrans-720
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1\. 组件是什么？
- en: '*Components* in Vue.js are a powerful construct that reduce and simplify our
    code base. Most Vue.js apps consist of one or more components. With components,
    we can pull out repeated parts of our code and separate them into smaller logical
    parts that make more sense to us. We can reuse each component throughout our application.
    Components are defined as a collection of elements that can be accessed through
    a single element. In certain cases, they can appear as a native HTML element using
    a special `is` attribute (we’ll look at that operator later in this chapter).'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: '*组件* 在Vue.js中是一个强大的结构，它可以减少和简化我们的代码库。大多数Vue.js应用程序由一个或多个组件组成。通过组件，我们可以提取代码中的重复部分，并将它们分离成更小的逻辑部分，这些部分对我们来说更有意义。我们可以在整个应用程序中重用每个组件。组件被定义为可以通过单个元素访问的元素集合。在某些情况下，它们可以使用特殊的
    `is` 属性作为原生HTML元素（我们将在本章后面讨论该操作符）。'
- en: '[Figure 6.1](#ch06fig01) is a simple example of converting a few HTML tags
    into one component. All of the HTML inside the opening and closing `<div>` tags
    are encapsulated in the one component: `my-component`. It’s worth mentioning that
    you can also have a self-closing tag, `<my-component/>` if your web browser supports
    it or you’re using single-file components that we’ll discuss later in the chapter.'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6.1](#ch06fig01) 是将几个HTML标签转换为一个组件的简单示例。所有在打开和关闭 `<div>` 标签内的HTML都被封装在这个组件中：`my-component`。值得一提的是，如果你的网页浏览器支持或者你正在使用我们将在本章后面讨论的单文件组件，你也可以有一个自闭合标签，`<my-component/>`。'
- en: Figure 6.1\. Example of encapsulating code into a component
  id: totrans-723
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.1\. 将代码封装到组件中的示例
- en: '![](06fig01_alt.jpg)'
  id: totrans-724
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig01_alt.jpg)'
- en: 6.1.1\. Creating components
  id: totrans-725
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.1\. 创建组件
- en: Before we can create our first Vue component we must create a Vue.js root instance,
    and then we must decide how to structure our application. Vue.js gives us the
    option to register our components either locally or globally. Global components
    can be used throughout the application, while local components can only be used
    in the Vue.js instance that created it. Let’s create a global component first.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够创建我们的第一个Vue组件之前，我们必须创建一个Vue.js根实例，然后我们必须决定如何构建我们的应用程序。Vue.js给我们提供了注册组件的本地或全局选项。全局组件可以在整个应用程序中使用，而局部组件只能在其创建的Vue.js实例中使用。让我们首先创建一个全局组件。
- en: Global components, as we mentioned earlier, can be used in all Vue.js instances.
    In this example, we’re creating a global component called `my-component`. Vue.js
    allows much flexibility in naming our components. Keep in mind that Vue.js doesn’t
    enforce any rules for component names, the way other frameworks do. It’s good
    practice to name all your components lowercase with hyphens.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，全局组件可以在所有Vue.js实例中使用。在这个例子中，我们创建了一个名为 `my-component` 的全局组件。Vue.js允许我们在组件命名上拥有很大的灵活性。请注意，Vue.js不像其他框架那样强制执行任何关于组件名的规则。将所有组件命名为小写并使用连字符是一种良好的做法。
- en: 6.1.2\. Global registration
  id: totrans-728
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.2\. 全局注册
- en: To create a global component, we must place it before the Vue instance. As you
    can see from [listing 6.1](#ch06ex01), the global component (`my-component`) is
    defined right before it’s created with `new Vue`.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个全局组件，我们必须将其放置在Vue实例之前。正如你在 [列表6.1](#ch06ex01) 中可以看到的，全局组件 (`my-component`)
    定义在用 `new Vue` 创建之前。
- en: To display information in our component, we must add a template property. The
    template is where the HTML resides. Keep in mind that all templates must be surrounded
    by a tag. In our example, we’ve surrounded it in a `<div>` tag; otherwise, you’ll
    see an error in the console, and the template won’t render on the screen.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在组件中显示信息，我们必须添加一个模板属性。模板是HTML所在的地方。请注意，所有模板都必须被一个标签包围。在我们的例子中，我们用 `<div>`
    标签包围了它；否则，你将在控制台中看到错误，并且模板将不会在屏幕上渲染。
- en: The last thing we need to do to get our component to render is to add it to
    the parent’s template. To get this working, we add the `<my-component></mycomponent>`
    custom tag inside the parent entry point of our app, `<div id="app">`, as shown
    in the following listing. While going through this chapter, try these examples
    for yourself. Make sure to save them as a .HTML file and load them in your web
    browser.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的组件能够渲染，我们需要将其添加到父模板中。为了实现这一点，我们在应用的父入口点 `<div id="app">` 内添加了 `<my-component></mycomponent>`
    自定义标签，如下所示。在阅读本章时，请亲自尝试这些示例。确保将它们保存为 .HTML 文件并在你的网页浏览器中加载。
- en: Listing 6.1\. Creating our first global component chapter-06/global-component-example.html
  id: totrans-732
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.1\. 创建我们的第一个全局组件 chapter-06/global-component-example.html
- en: '[PRE63]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '***1* Adds script tag to Vue.js**'
  id: totrans-734
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 向Vue.js添加脚本标签**'
- en: '***2* Adds component to template**'
  id: totrans-735
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将组件添加到模板**'
- en: '***3* Registers global Vue to component**'
  id: totrans-736
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 注册全局 Vue 组件**'
- en: '***4* Renders template for component**'
  id: totrans-737
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 渲染组件的模板**'
- en: '***5* Instantiates Vue instance**'
  id: totrans-738
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 实例化 Vue 实例**'
- en: It goes without saying that our application isn’t too useful. If you open this
    file in a web browser, you’ll see a message on the page, “Hello From Global Component.”
    This is a trivial example on how components work so you can understand the fundamentals.
    Let’s look at local registration and see how that differs.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 不言而喻，我们的应用程序并不太有用。如果你在网页浏览器中打开此文件，你会在页面上看到一个消息，“Hello From Global Component。”这是一个关于组件如何工作的简单示例，以便你可以理解基础知识。让我们看看本地注册，看看它有何不同。
- en: '|  |'
  id: totrans-740
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**The is special attribute**'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: '**这是一个特殊的属性**'
- en: You have special restrictions when using components in our DOM. Certain HTML
    tags—`<ul>`, `<ol>`, `<table>`, and `<select>`—have restrictions on the type of
    elements that can appear inside them. This is due to how the DOM hoists components
    out as invalid content. The workaround is to use the `is` attribute. Instead of
    putting the component inside those HTML tags, you can add the component to the
    element itself—for example, `<table> <tr is="my-row"></tr></table>`. The `tr`
    element will now be associated with the `my-row` component. We can create our
    own `tr` component to match whatever functionality we like. This limitation doesn’t
    apply to inline, x-templates, or .vue components. For more information on this
    attribute, check out the official guides at [http://mng.bz/eqUY](http://mng.bz/eqUY).
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 DOM 中使用组件时，有一些特殊的限制。某些 HTML 标签——`<ul>`、`<ol>`、`<table>`和`<select>`——对其内部可以出现的元素类型有限制。这是由于
    DOM 将组件提升为无效内容的方式。解决方案是使用`is`属性。你不必将这些组件放入那些 HTML 标签中，而是可以将组件添加到元素本身——例如，`<table>
    <tr is="my-row"></tr></table>`。现在`tr`元素将与`my-row`组件相关联。我们可以创建自己的`tr`组件以匹配我们喜欢的任何功能。这种限制不适用于内联、x-templates或.vue组件。有关此属性的更多信息，请参阅官方指南[http://mng.bz/eqUY](http://mng.bz/eqUY)。
- en: '|  |'
  id: totrans-743
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 6.1.3\. Local registration
  id: totrans-744
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.3\. 本地注册
- en: Local registration restricts scope to only one Vue instance. We can do this
    by registering it with the component’s instance option. After the component is
    registered locally, it can only be accessed by the Vue instance that registered
    it.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 本地注册将作用域限制为仅一个 Vue 实例。我们可以通过将组件的实例选项进行注册来实现这一点。在组件本地注册后，它只能被注册它的 Vue 实例访问。
- en: In [listing 6.2](#ch06ex02) we see a simple example of a local component. It
    looks similar to the global component that we registered before. The biggest difference
    is that we have a new instance option called `components`.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 6.2](#ch06ex02)中，我们看到一个本地组件的简单示例。它看起来与我们之前注册的全局组件相似。最大的区别是我们有一个新的实例选项，称为`components`。
- en: The components instance option declares all components needed for that Vue instance.
    Each component is a key-value pair. The key is always the name of the component
    that you’ll reference later inside the parent template. The value is the component
    definition. In [listing 6.2](#ch06ex02) the name of the component is `my-component`.
    The value is `Component`. Component is a `const` variable that defines what’s
    inside the component.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 组件实例选项声明了该 Vue 实例所需的所有组件。每个组件都是一个键值对。键始终是你稍后将在父模板内部引用的组件名称。值是组件定义。在[列表 6.2](#ch06ex02)中，组件的名称是`my-component`。值是`Component`。`Component`是一个`const`变量，它定义了组件内部的内容。
- en: In the following listing, we name our component `my-component` and the variable
    `Component`. You can name these whatever you like, although, as mentioned earlier,
    try to name the component using hyphens and lowercase, also known as kebab case.
    It’s good practice.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的列表中，我们命名我们的组件为`my-component`和变量`Component`。你可以随意命名它们，尽管如前所述，尽量使用连字符和小写字母来命名组件，也称为kebab
    case。这是一个好习惯。
- en: 'Listing 6.2\. Registering a local component: chapter-06/local-component-example.html'
  id: totrans-749
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.2\. 注册本地组件：chapter-06/local-component-example.html
- en: '[PRE64]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '***1* Shows the const variable that has the component declaration in it**'
  id: totrans-751
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 展示了包含组件声明的 const 变量**'
- en: '***2* This is the template that will be displayed for this component.**'
  id: totrans-752
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 这是将为该组件显示的模板。**'
- en: '***3* Shows the components instance option that declares components**'
  id: totrans-753
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 展示了声明组件实例选项的组件**'
- en: Load the web page in a browser and you’ll see “Hello From Local Component.”
    If not, double-check the console for any errors. It’s easy to leave a typo in,
    forget to surround the template in the `<div>` tag, or forget to close all your
    HTML tags.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中加载网页，你会看到“来自本地组件的问候”。如果没有，请检查控制台是否有任何错误。很容易在模板中留下打字错误，忘记用`<div>`标签包围模板，或者忘记关闭所有的HTML标签。
- en: '|  |'
  id: totrans-755
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Kebab case vs. camelCase**'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: '**斜杠命名法 vs. 骆驼峰命名法**'
- en: Although you can name your components whatever you like, there’s one caveat.
    Inside your HTML templates you must use the *kebab case* (lowercase with hyphens)
    equivalent to the name you chose. Let’s say you register your component “myComponent”.
    When using camelCase, your HTML templates must be in kebab case. Therefore, the
    component would be named <my-component>. This is also true for PascalCase. If
    you name your component, MyComponent, then your HTML template must be in kebab
    case, <my-component> as well. This rule also applies to props, which we’ll learn
    about later.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: '虽然你可以随意命名你的组件，但有一个注意事项。在你的HTML模板内部，你必须使用与所选名称相对应的*斜杠命名法*（小写带连字符）。假设你注册了组件“myComponent”。当使用骆驼峰命名法时，你的HTML模板必须是斜杠命名法。因此，组件的名称将是`<my-component>`。这也适用于PascalCase。如果你将组件命名为MyComponent，那么你的HTML模板也必须是斜杠命名法，即`<my-component>`。这个规则也适用于props，我们稍后会学习到。 '
- en: Later, when we look at single-file components, this won’t be a problem. Until
    then, stick with kebab case. You can learn more about camelCase versus kebab case
    in the official documentation at [http://mng.bz/5q9q](http://mng.bz/5q9q).
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看单文件组件之前，这不会是一个问题。在此之前，坚持使用斜杠命名法。你可以在官方文档中了解更多关于骆驼峰命名法与斜杠命名法的区别，网址为[http://mng.bz/5q9q](http://mng.bz/5q9q)。
- en: '|  |'
  id: totrans-759
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 6.2\. Relationships in components
  id: totrans-760
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2. 组件中的关系
- en: Imagine you’re designing a commenting system. The system should display a list
    of comments from each user. Each comment needs to contain the username, time and
    date, and the comment. Each user of our system can delete and edit each of their
    own comments.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你正在设计一个评论系统。系统应该显示每个用户的评论列表。每个评论都需要包含用户名、时间和日期以及评论内容。我们系统中的每个用户都可以删除和编辑他们自己的评论。
- en: Your first thought might be to use the `v-for` directive. This worked well in
    the last chapter when it was used to iterate through our inventory list. That
    could work, but let’s say our requirements change, and now we need to add a way
    to show threaded comments, or a new upvote and downvote system is needed. The
    code will become complicated very quickly.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 你的第一个想法可能是使用`v-for`指令。在上一个章节中，当它被用来遍历我们的库存列表时，这工作得很好。这可能可行，但假设我们的需求发生了变化，现在我们需要添加一种显示嵌套评论的方法，或者需要一个新的点赞和踩赞系统。代码会很快变得复杂。
- en: Components can help solve this problem. In such a relationship, comments will
    be displayed in a comment-list component. The parent (the Vue.js root instance)
    is responsible for the rest of the app. The parent also contains a method to retrieve
    all the comment data from a backend. The parent passes down the data it retrieved
    to the child component, `comment-list`. The `comment-list` component is responsible
    for displaying all the comments passed down to it.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 组件可以帮助解决这个问题。在这种关系中，评论将在评论列表组件中显示。父组件（Vue.js根实例）负责应用程序的其余部分。父组件还包含一个从后端检索所有评论数据的方法。父组件将检索到的数据传递给子组件`comment-list`。`comment-list`组件负责显示传递给它的所有评论。
- en: 'Keep in mind that each component has its own isolated scope, so it should never
    access the parent’s data directly. That’s why we always pass that data down. In
    Vue.js, the data that’s passed down is called *props*. This is short for properties;
    but inside Vue.js you must refer to it as `props`. Child components must explicitly
    state each prop it expects to receive using the `props` option. This option will
    reside in the Vue.js instance and will contain an array in the form like this:
    `props: [''comment''].` In this example, `''comment''` is a property that will
    be passed down into the component. If we had multiple props, then we’d separate
    each with a comma. Props are one-way from the parent component to the child component
    ([figure 6.2](#ch06fig02)).'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: '请记住，每个组件都有自己的独立作用域，因此它永远不应该直接访问父组件的数据。这就是我们总是向下传递数据的原因。在Vue.js中，向下传递的数据称为*props*。这是属性的简称；但在Vue.js内部，你必须将其称为`props`。子组件必须明确声明它期望接收的每个prop，使用`props`选项。这个选项将位于Vue.js实例中，并包含一个类似这样的数组：`props:
    [''comment'']`。在这个例子中，`''comment''`是一个将被传递到组件中的属性。如果我们有多个props，那么我们就会用逗号分隔每个属性。Props是从父组件到子组件的单向传递（[图6.2](#ch06fig02)）。'
- en: Figure 6.2\. A parent component can send data to a child component.
  id: totrans-765
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.2\. 父组件可以向子组件发送数据。
- en: '![](06fig02.jpg)'
  id: totrans-766
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig02.jpg)'
- en: In [chapter 4](kindle_split_015.html#ch04), we discussed how the `v-model` directive
    creates a two-way data binding on form inputs and text area elements. Changes
    to `v-model` elements update the data properties in the Vue.js instance and vice
    versa. But components form a one-way data binding. When the parent updates properties,
    it flows down to the child component and not the other way around. This is an
    important distinction because it prevents the child from accidentally mutating
    the parent’s state. If you mutate state, you’ll see an error in your console,
    like the one in [figure 6.3](#ch06fig03).
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](kindle_split_015.html#ch04)中，我们讨论了`v-model`指令如何在表单输入和文本区域元素上创建双向数据绑定。对`v-model`元素的改变会更新Vue.js实例中的数据属性，反之亦然。但组件形成的是单向数据绑定。当父组件更新属性时，它会流向子组件，而不是反过来。这是一个重要的区别，因为它防止子组件意外地修改父组件的状态。如果你修改了状态，你会在控制台看到错误，就像[图6.3](#ch06fig03)中显示的那样。
- en: Figure 6.3\. Error in console warns against mutating props directly.
  id: totrans-768
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.3\. 控制台中的错误警告直接修改props。
- en: '![](06fig03_alt.jpg)'
  id: totrans-769
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig03_alt.jpg)'
- en: Note that all values are passed by reference. If an object or array is mutated
    in the child, it will affect the parent state. This isn’t always the desired outcome
    and should be avoided. Instead you should make the changes in the parent only.
    Later in this chapter we’ll see how we can use events to update data from the
    child to the parent.
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，所有值都是通过引用传递的。如果子组件中修改了对象或数组，它将影响父组件的状态。这并不总是期望的结果，应该避免。相反，你应该只在父组件中进行更改。在本章的后面部分，我们将看到如何使用事件从子组件更新数据到父组件。
- en: 6.3\. Using props to pass data
  id: totrans-771
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3\. 使用props传递数据
- en: As mentioned, props are used to pass data from the parent to the child components.
    Props are intended for one-way communication only. You can think of props as variables
    the component has that can only be assigned from the parent.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，props用于从父组件传递数据到子组件。props仅用于单向通信。你可以把props看作是组件拥有的变量，只能从父组件赋值。
- en: Props also can be validated. We can make sure the values passed in follow a
    certain type of validation. We’ll look at this too.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: Props也可以进行验证。我们可以确保传递的值遵循某种类型的验证。我们也会探讨这一点。
- en: 6.3.1\. Literal props
  id: totrans-774
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.1\. 字面量props
- en: The easiest to use type of props are literal props. They’re plain strings that
    we can pass in to the component. Inside the template, we create the component
    in the usual manner, but we add our new prop within the angle brackets of our
    component as an additional attribute, `<my-component text="World"></my-component>`.
    This text will be passed down as a string to the text prop we created. The template
    will interpolate it within the curly braces.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 最容易使用的props类型是字面量props。它们是普通的字符串，我们可以将其传递给组件。在模板内部，我们以通常的方式创建组件，但我们将在组件的尖括号内添加我们的新prop作为额外的属性，`<my-component
    text="World"></my-component>`。这段文本将作为字符串传递给我们的text prop。模板将在大括号内进行插值。
- en: 'Be aware, this is a common mistake by many beginners: oftentimes, you might
    want to pass in a real value into the prop, not only a string. You might accidentally
    pass in a string instead of passing in a value. To pass in a value, you’ll need
    to make sure you use the `v-bind` directive as we’ll see in the next section.'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这是许多初学者常见的错误：你可能会想将实际值传递给prop，而不仅仅是字符串。你可能会不小心传递了一个字符串而不是传递值。要传递值，你需要确保使用`v-bind`指令，就像我们将在下一节中看到的那样。
- en: In [listing 6.3](#ch06ex03) we see an example of passing in a literal prop.
    Copy this example into your editor and try it out for yourself. You’ll see that
    `my-component` has the passed-in value of `"World"`. You can display that value
    using the `text` prop inside the template, as shown here.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表6.3](#ch06ex03)中，我们看到了一个传递字面量props的例子。将此示例复制到你的编辑器中并亲自尝试。你会发现`my-component`具有传递的值`"World"`。你可以在模板中使用`text`
    prop来显示这个值，就像这里所示。
- en: 'Listing 6.3\. Using literal props in our component: chapter 06/literal-props.html'
  id: totrans-778
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.3\. 在我们的组件中使用字面量props：chapter 06/literal-props.html
- en: '[PRE65]'
  id: totrans-779
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '***1* Shows the component with passed-in text literal**'
  id: totrans-780
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 显示了传递文本字面量的组件**'
- en: '***2* The template displays Hello and the passed-in prop**'
  id: totrans-781
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 模板显示Hello和传递的prop**'
- en: 6.3.2\. Dynamic props
  id: totrans-782
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.2\. 动态props
- en: '*Dynamic props* are props that are passed in from the parent that are bound
    to a property that can change (unlike literal props, that are static text). We
    can use the `v-bind` directive to make sure it’s passed in correctly. Let’s update
    our example from the previous section and pass in the message to our new prop
    named `text`.'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: '*动态属性* 是从父组件传递进来并绑定到可以改变的属性（与静态文本的属性不同）的属性。我们可以使用 `v-bind` 指令来确保它被正确传递。让我们更新上一节中的示例，并将消息传递给我们的新属性
    `text`。'
- en: The component `<my-component v-bind:text="message"></my-component>` has a new
    `v-bind` directive attribute. This will bind the prop `text` to our new `message`.
    The `message` is a property from our data function.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 组件 `<my-component v-bind:text="message"></my-component>` 有一个新的 `v-bind` 属性指令。这将把
    `text` 属性绑定到我们的新 `message`。`message` 是我们数据函数中的一个属性。
- en: 'If you’ve been following along in previous chapters, you may have noticed that
    data, in our Vue.js instance, is no longer an object `data: { }` as you can see
    in [listing 6.4](#ch06ex04). This is an intentional choice. Components behave
    a little differently, and data must be represented as a function, not an object.'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你一直在前几章中跟随，你可能已经注意到，在我们的 Vue.js 实例中，数据不再是对象 `data: { }`，正如你在 [列表 6.4](#ch06ex04)
    中看到的。这是一个有意的选择。组件的行为略有不同，数据必须表示为一个函数，而不是一个对象。'
- en: If I add a data object to `my-component`, an error displays in the console.
    To stay consistent, we’ll use `data` as a function for both our components and
    the root Vue instance for the rest of the book.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我在 `my-component` 中添加一个数据对象，控制台会显示一个错误。为了保持一致性，我们将在本书的其余部分使用 `data` 函数作为我们的组件和根
    Vue 实例的数据。
- en: This listing is an example of using dynamic props. Copy this into an editor
    and try it for yourself.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表是使用动态属性的一个例子。将其复制到编辑器中，亲自试一试。
- en: 'Listing 6.4\. Using dynamic props: chapter 06/dynamic-props.html'
  id: totrans-788
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.4\. 使用动态属性：chapter 06/dynamic-props.html
- en: '[PRE66]'
  id: totrans-789
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '***1* Uses the v-bind directive to bind message from parent to text in child**'
  id: totrans-790
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用 v-bind 指令将父组件的消息绑定到子组件的 text 中**'
- en: '***2* This is the template that displays the text prop.**'
  id: totrans-791
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 这是显示文本属性的模板。**'
- en: '***3* The data function that returns the message**'
  id: totrans-792
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 返回消息的数据函数**'
- en: Before we move on, let’s imagine that we need to update our program to add three
    counters. Each counter needs to start at zero and increment independently. Each
    counter is represented by a button that you can click to increment. How can we
    do this with components?
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们想象一下我们需要更新我们的程序以添加三个计数器。每个计数器需要从零开始独立递增。每个计数器都由一个你可以点击来递增的按钮表示。我们如何使用组件来实现这一点？
- en: Let’s take the code from [listing 6.4](#ch06ex04) and update it. Add a data
    function to `MyComponent` and a counter. Your first thought might be to add a
    global variable. Let’s try that and see what happens.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把 [列表 6.4](#ch06ex04) 中的代码取出来并更新它。向 `MyComponent` 添加一个数据函数和一个计数器。你的第一个想法可能是添加一个全局变量。让我们试一试，看看会发生什么。
- en: As you can see from [listing 6.5](#ch06ex05), we added the component three times.
    We created a global `const` object called counter, and it’s initialized to zero.
    In our template, we created a simple binding to the click event using the `v-on`
    directive. The counter variable will increment by one on every click.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [列表 6.5](#ch06ex05) 所示，我们创建了三次组件。我们创建了一个名为 `counter` 的全局 `const` 对象，并将其初始化为零。在我们的模板中，我们使用
    `v-on` 指令创建了一个简单的绑定到点击事件的绑定。计数器变量在每次点击时将递增。
- en: 'Listing 6.5\. Dynamic props with global counter: chapter 06/dynamic-props-counter.html'
  id: totrans-796
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.5\. 带全局计数器的动态属性：chapter 06/dynamic-props-counter.html
- en: '[PRE67]'
  id: totrans-797
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '***1* Lists component three times**'
  id: totrans-798
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 列出组件三次**'
- en: '***2* Shows the global variable counter**'
  id: totrans-799
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 显示全局变量计数器**'
- en: '***3* The counter increments on every click.**'
  id: totrans-800
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 计数器在每次点击时递增。**'
- en: '***4* The data function returns the global counter.**'
  id: totrans-801
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 数据函数返回全局计数器。**'
- en: Open your browser to the code you wrote. Click the button on the page a few
    times and see what occurs ([figure 6.4](#ch06fig04)).
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的浏览器到你所写的代码。点击页面上的按钮几次，看看会发生什么 ([图 6.4](#ch06fig04))。
- en: Figure 6.4\. Dynamic props example in a browser.
  id: totrans-803
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.4\. 浏览器中的动态属性示例。
- en: '![](06fig04_alt.jpg)'
  id: totrans-804
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig04_alt.jpg)'
- en: You might be surprised to see that every counter increments when we click any
    of the buttons. This is certainly not what we want, although it’s a good illustration
    on how to share scope.
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会惊讶地看到，当我们点击任何一个按钮时，每个计数器都会递增。这当然不是我们想要的，尽管这是一个很好的说明如何共享作用域的例子。
- en: Take the listing from 6.5 and update it so we can correct this problem, as shown
    in [listing 6.6](#ch06ex06). Remove the `const` counter and update the data function.
    Instead of having the data function return the global counter, have it return
    its own counter. This counter is scoped locally for the component, and therefore
    isn’t shared with other components.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 从6.5节中获取列表并更新它，以便我们可以纠正这个问题，如[列表6.6](#ch06ex06)所示。移除`const`计数器并更新数据函数。数据函数不再返回全局计数器，而是返回它自己的计数器。这个计数器的作用域是局部组件，因此不会与其他组件共享。
- en: 'Listing 6.6\. Updating counters with correct return object: chapter 06/dynamic-props-counter-correct.html'
  id: totrans-807
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.6\. 使用正确返回对象的更新计数器：chapter 06/dynamic-props-counter-correct.html
- en: '[PRE68]'
  id: totrans-808
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '***1* The data function returns a counter.**'
  id: totrans-809
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 数据函数返回一个计数器。**'
- en: Fire up your browser and open the updated code you wrote. Click a few of the
    buttons and observe the counter ([figure 6.5](#ch06fig05)).
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 启动你的浏览器并打开你更新的代码。点击几个按钮并观察计数器([图6.5](#ch06fig05))。
- en: Figure 6.5\. Dynamic props with a local scope counter example.
  id: totrans-811
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.5\. 带局部作用域计数器的动态props示例。
- en: '![](06fig05_alt.jpg)'
  id: totrans-812
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig05_alt.jpg)'
- en: This time things look correct! As we click each button, the counter increments
    by itself only and doesn’t affect the other counters.
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 这次看起来一切正常！当我们点击每个按钮时，计数器只自己增加，不会影响其他计数器。
- en: 6.3.3\. Prop validation
  id: totrans-814
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.3\. Prop验证
- en: Vue.js has a nice feature called *prop validation* that ensures that the props
    that we receive from the parent pass validation. This can be particularly useful
    when working on a team, where multiple people use the same component.
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js有一个很好的功能叫做*prop验证*，它确保我们从父组件接收的props通过验证。当在团队中工作时，这一点尤其有用，因为多个人使用相同的组件。
- en: 'Let’s begin by checking the type of our props. Vue.js provides the following
    native constructors to make this possible:'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从检查我们的props类型开始。Vue.js提供了以下原生构造函数来实现这一点：
- en: String
  id: totrans-817
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串
- en: Number
  id: totrans-818
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字
- en: Boolean
  id: totrans-819
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔
- en: Function
  id: totrans-820
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数
- en: Object
  id: totrans-821
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象
- en: Array
  id: totrans-822
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组
- en: Symbol
  id: totrans-823
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 符号
- en: In [listing 6.7](#ch06ex07), you can see the use of prop validation. We’ll first
    create a component called `my-component` and pass in values to it. The component
    will display those values in its template.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表6.7](#ch06ex07)中，你可以看到prop验证的使用。我们首先创建一个名为`my-component`的组件，并向它传递值。组件将在其模板中显示这些值。
- en: 'Instead of creating a prop array, `prop: [''nameofProp''`], we create an object.
    Each object is named after the `prop`. We then create another object to specify
    the type; we can add either required or default. *Default* refers to the default
    value if no value is passed in to the `prop`. If the type of property is an object,
    it must have a default value assigned. The *required* property, as the name suggests,
    requires the property to be added to the component during creation in the template.'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: '我们不是创建一个prop数组，`prop: [''nameofProp''`]，而是创建一个对象。每个对象都以其`prop`命名。然后我们创建另一个对象来指定类型；我们可以添加必需的或默认的。*默认*指的是如果没有传递值给`prop`，则使用的默认值。如果属性的属性类型是对象，则必须分配默认值。*必需*属性，正如其名所示，要求在模板中创建组件时添加属性。'
- en: The last thing you’ll notice from [listing 6.7](#ch06ex07) is the even `prop`.
    This is called a custom validator. In this case, we’re checking whether or not
    the value is even. If it’s even, it’ll return `true`. If it’s not even, then an
    error will be shown in the console. Keep in mind that custom validators can perform
    any type of function you like. The only rule is that they must return `true` or
    `false`.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 你最后会注意到[列表6.7](#ch06ex07)中的even `prop`。这被称为自定义验证器。在这种情况下，我们正在检查值是否为偶数。如果是偶数，它将返回`true`。如果不是偶数，那么控制台将显示错误。请注意，自定义验证器可以执行任何你喜欢的函数。唯一的规则是它们必须返回`true`或`false`。
- en: Keep in mind also that a single colon (:) by itself is shorthand for `v-bind`.
    This is similar to the way the at symbol (@) is shorthand for `v-on`.
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，单个冒号(:)本身是`v-bind`的简写。这与at符号(@)是`v-on`的简写的方式类似。
- en: 'Listing 6.7\. Validating props: chapter 06/props-example.html'
  id: totrans-828
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.7\. 验证props：chapter 06/props-example.html
- en: '[PRE69]'
  id: totrans-829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '***1* Passes in values to my-component**'
  id: totrans-830
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 向my-component传递值**'
- en: '***2* The MyComponent template is used to display all the properties.**'
  id: totrans-831
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* MyComponent模板用于显示所有属性。**'
- en: '***3* Number validation must be present.**'
  id: totrans-832
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 必须存在数字验证。**'
- en: '***4* String validation includes a default value.**'
  id: totrans-833
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 字符串验证包括一个默认值。**'
- en: '***5* Object validation has a default message.**'
  id: totrans-834
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 对象验证有一个默认消息。**'
- en: '***6* Custom validator has to check whether or not the number is even.**'
  id: totrans-835
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 自定义验证器必须检查数字是否为偶数。**'
- en: Open a browser and run the code in this example. The output is shown in [figure
    6.6](#ch06fig06).
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 打开浏览器并运行这个例子中的代码。输出显示在[图 6.6](#ch06fig06)中。
- en: Figure 6.6\. Validation number, string, and object using prop validation.
  id: totrans-837
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.6\. 使用属性验证验证数字、字符串和对象。
- en: '![](06fig06_alt.jpg)'
  id: totrans-838
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig06_alt.jpg)'
- en: This is what we expect! But is there a problem? If you look at the code, you’ll
    notice our custom validator checks whether a number is even or odd. If it’s odd,
    it returns `false`. Why don’t we see `false` where it shows `IsEven?`
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们期望的！但是有问题吗？如果你查看代码，你会注意到我们的自定义验证器检查一个数字是奇数还是偶数。如果是奇数，它返回`false`。为什么我们在`IsEven?`那里没有看到`false`？
- en: In fact, Vue.js does show it as `false`! But it’s not in the template. By default,
    prop validations don’t prevent passed-in values from showing up in the template.
    Vue.js checks the validation and emits warnings in the console. Open the Chrome
    console and look. Your console should look similar to [figure 6.7](#ch06fig07).
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Vue.js确实将其显示为`false`！但它不在模板中。默认情况下，属性验证不会阻止传入的值在模板中显示。Vue.js检查验证并在控制台发出警告。打开Chrome控制台查看。你的控制台应该类似于[图
    6.7](#ch06fig07)。
- en: Figure 6.7\. Error showing validation failure.
  id: totrans-841
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.7\. 显示验证失败的错误。
- en: '![](06fig07_alt.jpg)'
  id: totrans-842
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig07_alt.jpg)'
- en: The error shows that our custom validator failed for prop `even`. This is good
    to know, and we should change the passed in number to an even number. Keep this
    type of error in mind while using prop validations.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 错误显示我们的自定义验证器在属性`even`上失败。这是好事，我们应该将传入的数字改为偶数。在使用属性验证时，请记住这种类型的错误。
- en: 6.4\. Defining a template component
  id: totrans-844
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4\. 定义模板组件
- en: Until now, we’ve used local and global registration to define our components.
    Templates in each of our components have been defined as a string. This can be
    problematic as our components get larger and more complicated. The template strings
    aren’t the easiest to work with due to different development environments that
    may cause issues with syntax highlighting. In addition, multiline template strings
    need escape characters, which clutter our component definition.
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用本地和全局注册来定义我们的组件。我们每个组件中的模板都定义为字符串。当我们的组件变得更大更复杂时，这可能会成为问题。由于不同的开发环境可能会引起语法高亮问题，模板字符串并不容易处理。此外，多行模板字符串需要转义字符，这会使得我们的组件定义变得杂乱。
- en: Vue.js has multiple ways to display templates that can help fix this. We’ll
    discuss this and how we can use ES2015 literals to make our component templates
    easier to use.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js有多种显示模板的方法，可以帮助解决这个问题。我们将讨论这一点以及我们如何使用ES2015字面量来使我们的组件模板更容易使用。
- en: 6.4.1\. Using inline template strings
  id: totrans-847
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.4.1\. 使用内联模板字符串
- en: One of the simplest ways of working with a template is to use it inline. To
    make this work, we need to include the template information inside the component
    when it’s added to the parent template.
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 与模板一起工作的最简单方法之一是使用内联模板。为了使这可行，我们需要在将模板信息包含在组件中时添加到父模板。
- en: In [listing 6.8](#ch06ex08), you can see that we declare the component as `<my-component
    :my-info="message" inline-template>` in the template. The `inline-template` tells
    Vue to render the contents of the component within the opening and closing of
    the `my-component` tag.
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 6.8](#ch06ex08)中，你可以看到我们在模板中将组件声明为`<my-component :my-info="message" inline-template>`。`inline-template`告诉Vue在`my-component`标签的开启和关闭之间渲染组件的内容。
- en: One downside of using inline templates is that they separate the template from
    the rest of the definition of the component. For smaller applications, this will
    work, although it’s not recommended for use in larger applications. In larger
    applications, you should look into the single-file components that we’ll discuss
    in the next chapter.
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内联模板的一个缺点是它们将模板与组件的其他定义部分分开。对于较小的应用程序，这可以工作，尽管不推荐在较大的应用程序中使用。在较大的应用程序中，你应该考虑我们在下一章中将要讨论的单文件组件。
- en: 'Listing 6.8\. Using templates inline: chapter 06/inline-component-example.html'
  id: totrans-851
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.8\. 使用内联模板：第 06 章/inline-component-example.html
- en: '[PRE70]'
  id: totrans-852
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '***1* The inline template displays HTML.**'
  id: totrans-853
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 内联模板显示HTML。**'
- en: '***2* Shows the passed-in property**'
  id: totrans-854
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 显示传入的属性**'
- en: 6.4.2\. Text/x-template script elements
  id: totrans-855
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.4.2\. Text/x-template脚本元素
- en: Another way of defining a template in our component is by using `text/x-template`
    script elements. In this case, we create a script tag with the type `text/x-template`.
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的组件中定义模板的另一种方式是使用`text/x-template`脚本元素。在这种情况下，我们创建一个类型为`text/x-template`的脚本标签。
- en: In [listing 6.9](#ch06ex09), we use the `text/x-template` to define the template
    for `my-component`. The thing to remember here is that you must define the script
    as `type="text/x-template"`, otherwise it won’t work.
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 6.9](#ch06ex09) 中，我们使用 `text/x-template` 来定义 `my-component` 的模板。这里要记住的是，你必须将脚本定义为
    `type="text/x-template"`，否则它将不起作用。
- en: Once again, we run into the same downside as with the inline templates. The
    biggest problem is that we’re separating the component definition from the template.
    This will work, but it’s useful only in smaller applications and not in larger
    ones.
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 再次遇到与内联模板相同的问题。最大的问题是我们将组件定义与模板分开了。这可以工作，但只适用于小型应用程序，不适用于大型应用程序。
- en: 'Listing 6.9\. Working with text/x-templates: chapter 06/x-template-example.html'
  id: totrans-859
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.9\. 使用 text/x-模板：chapter 06/x-template-example.html
- en: '[PRE71]'
  id: totrans-860
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '***1* Shows the x-template script**'
  id: totrans-861
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 展示了 x-template 脚本**'
- en: 6.4.3\. Using single-file components
  id: totrans-862
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.4.3\. 使用单文件组件
- en: Earlier in our examples, we used strings to represent our templates in our components.
    With ES2015 template literals, we can help eliminate several problems we had using
    strings. In ES2015, if you surround a string with a backtick (`), it becomes a
    template literal. Template literals can be multiline without having to escape
    them. They can have embedded expressions in them, too. This makes writing our
    templates much easier.
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的示例中，我们使用字符串来表示组件中的模板。使用 ES2015 模板字面量，我们可以帮助消除使用字符串时遇到的一些问题。在 ES2015 中，如果你用反引号（`）包围一个字符串，它就变成了模板字面量。模板字面量可以是多行的，无需转义。它们还可以包含嵌入的表达式。这使得编写我们的模板变得更加容易。
- en: 'With all that said, ES2015 template literals still have several of the same
    drawbacks as strings. It still looks a little cluttered in your component definition,
    and certain development environments won’t have syntax highlighting. You have
    one more option to help fix all these problems: single-file components.'
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前所说的，ES2015 模板字面量仍然有与字符串相同的几个缺点。它在组件定义中看起来有点杂乱，并且某些开发环境可能没有语法高亮。你还有一个选项可以帮助解决所有这些问题：单文件组件。
- en: Single-file components combine your template and definitions into one .vue file.
    Each one has its own scope, and you don’t have to worry about forcing unique names
    for every component. CSS is also scoped for each component, which is helpful in
    those larger applications. To top it all off, you no longer have to worry about
    dealing with string templates or having to work with unusual script tags.
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 单文件组件将你的模板和定义合并到一个 .vue 文件中。每个组件都有自己的作用域，你不必担心为每个组件强制使用唯一的名称。CSS 也为每个组件进行了作用域限制，这在大型应用程序中非常有用。最重要的是，你再也不必担心处理字符串模板或处理不寻常的脚本标签了。
- en: In the following listing, you can see that the HTML is surrounded by the template
    tag, unlike in our previous examples. The .vue file uses ES2015 export to return
    the data for the component.
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的列表中，你可以看到 HTML 被模板标签包围，这与我们之前的示例不同。.vue 文件使用 ES2015 导出返回组件的数据。
- en: 'Listing 6.10\. Single-file components: chapter 06/single-file-component.vue'
  id: totrans-867
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.10\. 单文件组件：chapter 06/single-file-component.vue
- en: '[PRE72]'
  id: totrans-868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '***1* The template displays information for the component.**'
  id: totrans-869
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 模板显示组件的信息。**'
- en: '***2* Shows the ES2015 export of the data**'
  id: totrans-870
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 展示了 ES2015 的数据导出**'
- en: To use single-file components, you’ll have to get familiar with several modern
    build tools. You’ll need to use a tool such as Webpack or Browserify to build
    the .vue code. Vue.js has made this process easy with its own scaffolding generator
    called Vue-CLI. It contains all the necessary build tools. We’ll discuss tools
    in the next chapter. For now, know that there are many ways to work with templates
    and that single-file components are the way to go for larger applications.
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用单文件组件，你需要熟悉几个现代构建工具。你需要使用像 Webpack 或 Browserify 这样的工具来构建 .vue 代码。Vue.js 通过其自己的脚手架生成器
    Vue-CLI 使这个过程变得简单，Vue-CLI 包含了所有必要的构建工具。我们将在下一章讨论工具。现在，要知道有许多方法可以处理模板，而对于大型应用程序来说，单文件组件是最佳选择。
- en: 6.5\. Working with custom events
  id: totrans-872
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5\. 使用自定义事件
- en: Vue.js has its own event interface. Unlike normal events that we saw in [chapter
    3](kindle_split_014.html#ch03), custom events are used when passing events from
    parent to child components. The event interface can listen to events using the
    `$on(eventname)` and trigger events using `$emit(eventName)`. Typically, `$on(eventname)`
    is used when sending events between different components that aren’t parent and
    child. For parent and child events, we must use the `v-on` directive. We can use
    this interface so parent components can listen directly to child components.
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js 有自己的事件接口。与我们在[第3章](kindle_split_014.html#ch03)中看到的普通事件不同，自定义事件用于在父组件和子组件之间传递事件。事件接口可以使用
    `$on(eventname)` 监听事件，并使用 `$emit(eventName)` 触发事件。通常，`$on(eventname)` 用于在不是父子关系的不同组件之间发送事件。对于父子事件，我们必须使用
    `v-on` 指令。我们可以使用这个接口，这样父组件可以直接监听子组件。
- en: 6.5.1\. Listening to events
  id: totrans-874
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.5.1\. 监听事件
- en: Imagine you’re creating a counter. You want to have a button on the screen that
    increments the counter by 1 every time it’s clicked but you’d like to have that
    button in a child component and the counter in a parent Vue.js instance. You don’t
    want the counter to mutate inside the child component. Instead, it should notify
    the parent that the counter should be updated. On every button click, the counter
    in the parent needs to update. Let’s look at how to do this.
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你正在创建一个计数器。你希望在屏幕上有一个按钮，每次点击都会增加计数器1，但你希望这个按钮在子组件中，计数器在父Vue.js实例中。你不想在子组件内部修改计数器。相反，它应该通知父组件计数器应该更新。每次按钮点击时，父组件中的计数器都需要更新。让我们看看如何做到这一点。
- en: Let’s start by creating a component. When we add it to our template, we’ll need
    to use the `v-on` directive and create a custom event. As you can see in [listing
    6.11](#ch06ex11), we’ve added the component and created a custom event called
    `increment-me`. This custom event is bound to the `incrementCounter` method that
    we defined in the parent Vue instance. We’ll also add a normal button that’s bound
    to the click event that triggers `incrementCounter`, too. This button resides
    in the parent’s template.
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个组件开始。当我们将其添加到模板中时，我们需要使用 `v-on` 指令并创建一个自定义事件。正如你在[列表6.11](#ch06ex11)中看到的，我们已经添加了组件并创建了一个名为
    `increment-me` 的自定义事件。这个自定义事件绑定到我们在父Vue实例中定义的 `incrementCounter` 方法。我们还将添加一个绑定到触发
    `incrementCounter` 的点击事件的普通按钮。这个按钮位于父组件的模板中。
- en: Inside the definition of our component, we’ll need to add a button. We’ll again
    use the `v-on` directive bound to the click event. This triggers the `childIncrementCounter`
    method that we defined in the child component.
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们组件的定义中，我们需要添加一个按钮。我们再次使用绑定到点击事件的 `v-on` 指令。这会触发我们在子组件中定义的 `childIncrementCounter`
    方法。
- en: The `childIncrementCounter` has only one responsibility, and that’s to emit
    the custom event we created earlier. This is where it might get confusing. We’ll
    use `this.$emit('increment-me')` to trigger the bound event, `incrementCounter`,
    defined in the parent methods. We’re triggering the parent Vue.js instance `incrementCounter`
    method, which will increment the counter. This is powerful and allows us to modify
    values in the parent while keeping the one-way data principle intact.
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: '`childIncrementCounter` 只有一个职责，那就是触发我们之前创建的自定义事件。这可能有点令人困惑。我们将使用 `this.$emit(''increment-me'')`
    来触发绑定的事件，即父组件方法中定义的 `incrementCounter`。我们正在触发父Vue.js实例的 `incrementCounter` 方法，这将增加计数器。这是强大的，允许我们在保持单向数据原则完整的同时修改父组件中的值。'
- en: 'Listing 6.11\. Incrementing a parent counter using `$emit`: chapter 06/event-listen.html'
  id: totrans-879
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.11\. 使用 `$emit` 增加父组件计数器：chapter 06/event-listen.html
- en: '[PRE73]'
  id: totrans-880
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '***1* Shows the button to increment the counter from the parent**'
  id: totrans-881
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 显示了从父组件增加计数器的按钮**'
- en: '***2* Indicates the component that sets the increment-me event to incrementCounter**'
  id: totrans-882
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 指示设置增量-me事件的组件**'
- en: '***3* Indicates the component button that triggers the childIncrementCounter
    method**'
  id: totrans-883
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 指示触发子IncrementCounter方法的组件按钮**'
- en: '***4* Emits the increment-me event**'
  id: totrans-884
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 触发增量-me事件**'
- en: '***5* Shows the method to increment the counter by 1**'
  id: totrans-885
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 显示了通过1增加计数器的方法**'
- en: If we load the Chrome browser, you’ll see two buttons. Both will increment the
    counter setup in the parent and be displayed in the component ([figure 6.8](#ch06fig08)).
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们加载Chrome浏览器，你会看到两个按钮。这两个按钮都会增加父组件中设置的计数器，并在组件中显示（[图6.8](#ch06fig08)）。
- en: Figure 6.8\. Shows two buttons; both increment the counter from the parent.
  id: totrans-887
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.8\. 显示了两个按钮；它们都从父组件增加计数器。
- en: '![](06fig08_alt.jpg)'
  id: totrans-888
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig08_alt.jpg)'
- en: 6.5.2\. Modifying child props using .sync
  id: totrans-889
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.5.2\. 使用 .sync 修改子组件属性
- en: In most situations, we don’t want to have the child component mutate a prop
    from the parent. We’d rather have the parent do it. This is one of the fundamental
    rules of the one-way data flow that we mentioned earlier in the chapter. Vue.js
    allows us to break this rule, though.
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，我们不想让子组件从父组件中修改 prop。我们更希望父组件来做。这是我们之前在章节中提到的单向数据流的基本规则之一。尽管如此，Vue.js
    允许我们打破这个规则。
- en: The `.sync` modifier allows us to modify values in a parent component from inside
    a child component. It was introduced in Vue 1.x and removed from Vue 2.0 but the
    Vue.js core team decided to reintroduce it in 2.3.0+. With all that said, be cautious
    when using it.
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: '`.sync` 修饰符允许我们从子组件内部修改父组件中的值。它在 Vue 1.x 中被引入，但在 Vue 2.0 中被移除，但 Vue.js 核心团队决定在
    2.3.0+ 中重新引入它。话虽如此，使用它时要小心。'
- en: Let’s create an example that shows how `.sync` can update a value. Modify the
    code in [listing 6.11](#ch06ex11) by updating `my-component` and `childIncrementCounter`.
    To begin, we’ll look at the `.sync` modifier. To use the `.sync` modifier you
    can attach it to any prop on the component. In [listing 6.12](#ch06ex12), it’s
    attached at `<my-component :my-counter.sync="counter">.` The `my-counter` prop
    is bound to `counter`.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个示例，展示 `.sync` 如何更新一个值。通过更新 `my-component` 和 `childIncrementCounter` 来修改
    [代码清单 6.11](#ch06ex11) 中的代码。首先，我们将查看 `.sync` 修饰符。要使用 `.sync` 修饰符，你可以将其附加到组件上的任何
    prop。在 [代码清单 6.12](#ch06ex12) 中，它附加在 `<my-component :my-counter.sync="counter">.`
    上。`my-counter` prop 被绑定到 `counter`。
- en: The `.sync` modifier is syntactic sugar for this `<my-component :my-counter="counter"
    @update:my-counter="val => bar = val"></my-component>`. The new event created
    is called `update`. That event will take the `my-counter` prop and assign it to
    whatever variable is passed in.
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: '`.sync` 修饰符是这个 `<my-component :my-counter="counter" @update:my-counter="val
    => bar = val"></my-component>` 的语法糖。新创建的事件称为 `update`。该事件将 `my-counter` prop 分配给传递的任何变量。'
- en: To make this work, we still need to emit our new event that was created and
    pass in the value we want the counter to be updated to. We’ll use `this.$emit`
    to do this. The `this.myCounter+1` is the first argument that will be passed to
    the update event.
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这生效，我们仍然需要发出我们创建的新事件，并传递我们想要更新的计数器值。我们将使用 `this.$emit` 来完成这个操作。`this.myCounter+1`
    是将被传递到更新事件的第一个参数。
- en: Listing 6.12\. Working with `.sync` to modify props from child chapter 06/event-listen-sync.html
  id: totrans-895
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.12\. 使用 `.sync` 从子组件修改属性（06/event-listen-sync.html）
- en: '[PRE74]'
  id: totrans-896
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '***1* Shows the component setup with the .sync modifier**'
  id: totrans-897
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 显示了带有 .sync 修饰符的组件设置**'
- en: '***2* Emits to update event followed by a comma**'
  id: totrans-898
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在更新事件后跟一个逗号**'
- en: If we load the browser, you’ll see two buttons. If we click either one, it updates
    the counter ([figure 6.9](#ch06fig09)).
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们加载浏览器，你会看到两个按钮。如果我们点击任何一个，它都会更新计数器（[图 6.9](#ch06fig09)）。
- en: Figure 6.9\. This example uses `.sync` to modify the counter.
  id: totrans-900
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.9\. 此示例使用 `.sync` 来修改计数器。
- en: '![](06fig09_alt.jpg)'
  id: totrans-901
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig09_alt.jpg)'
- en: Exercise
  id: totrans-902
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: 'Use your knowledge from this chapter to answer these questions:'
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本章的知识来回答这些问题：
- en: How do you pass information from a parent to a child component? What do you
    use to pass information from a child component back to a parent component?
  id: totrans-904
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你如何从父组件传递信息到子组件？你使用什么来从子组件将信息传递回父组件？
- en: '*See the solution in [appendix B](kindle_split_026.html#app02).*'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: '*请参阅附录 B 中的解决方案（kindle_split_026.html#app02）。*'
- en: Summary
  id: totrans-906
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Local registration for components has local scope. It can be created by using
    the components option when constructing a new Vue instance.
  id: totrans-907
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件的局部注册具有局部作用域。它可以通过在构建新的 Vue 实例时使用 components 选项来创建。
- en: Global registration for components uses the `Vue.components` instance operator
    where the component is defined.
  id: totrans-908
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件的全局注册使用 `Vue.components` 实例运算符，其中组件被定义。
- en: Components use one-way data binding between the parent and child component.
  id: totrans-909
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件在父组件和子组件之间使用单向数据绑定。
- en: Props are used in components to define what can be passed to them.
  id: totrans-910
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在组件中使用 Props 来定义可以传递给它们的内容。
- en: Single-file components combine all template and script information into one
    file.
  id: totrans-911
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单文件组件将所有模板和脚本信息合并到一个文件中。
- en: You can use `$emit` to send information to the parent component.
  id: totrans-912
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 `$emit` 向父组件发送信息。
- en: Chapter 7\. Advanced components and routing
  id: totrans-913
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 7 章\. 高级组件和路由
- en: '*This chapter covers*'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Working with slots
  id: totrans-915
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与插槽一起工作
- en: Using dynamic components
  id: totrans-916
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用动态组件
- en: Implementing async components
  id: totrans-917
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现异步组件
- en: Using single-file components with Vue-CLI
  id: totrans-918
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Vue-CLI 与单文件组件
- en: Now that we’ve looked at components and how they can be used to break applications
    into smaller parts, let’s look deeper into components and explore more of their
    advanced features. These features will help us create more dynamic and robust
    applications.
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了组件以及它们如何被用来将应用程序分解成更小的部分，让我们更深入地了解组件并探索它们更多的高级特性。这些特性将帮助我们创建更动态和健壮的应用程序。
- en: We’ll look at slots first. *Slots* interweave the parent’s content with the
    child components template, making it easier to dynamically update content inside
    components. Then we’ll move on to dynamic components, which offer the ability
    to switch out components in real time. This feature makes it easy to change out
    whole components based on user action. For example, you might be creating an admin
    panel that displays multiple graphs. You can easily swap out each graph with dynamic
    components based on user action.
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先来看插槽。*插槽*将父组件的内容与子组件模板交织在一起，使得动态更新组件内部内容变得更加容易。然后我们将转向动态组件，它们提供了实时切换组件的能力。这个特性使得根据用户操作更换整个组件变得简单。例如，你可能正在创建一个显示多个图表的管理面板。你可以根据用户操作轻松地用动态组件替换每个图表。
- en: We’ll also look at async components and how to divide an application into smaller
    chunks. Each chunk will load only when needed—a nice addition when our application
    grows large and we need to be sensitive to how much data we load when the application
    starts up.
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将探讨异步组件以及如何将应用程序划分为更小的部分。每个部分只有在需要时才会加载——当我们的应用程序变得很大并且我们需要对应用程序启动时加载的数据量保持敏感时，这是一个很好的补充。
- en: While we’re here, we’ll look at single-file components and Vue-CLI. With Vue-CLI
    we can set up and create an application within seconds without having to worry
    about learning complicated tooling. We’ll take everything we’ve learned from this
    chapter and refactor our pet store application to take advantage of Vue-CLI!
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在这里时，我们将探讨单文件组件和Vue-CLI。使用Vue-CLI，我们可以在几秒钟内设置和创建一个应用程序，而无需担心学习复杂的工具。我们将利用本章所学的一切，重构我们的宠物商店应用程序以利用Vue-CLI！
- en: Finally, we’ll look at routing and how we can use it to create route parameters
    and child routes. Let’s begin!
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将探讨路由以及我们如何使用它来创建路由参数和子路由。让我们开始吧！
- en: 7.1\. Working with slots
  id: totrans-924
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1. 使用插槽
- en: When working with components, we occasionally need to weave in parent content
    with the child content, meaning that you’ll need data passed into your component.
    Imagine you have a custom form component that you’d like to use on a book-publishing
    site. Inside the form are two text input elements, named author and title. Preceding
    each text input element is a label that describes them. Each label’s title is
    already defined inside the root Vue.js instance data function.
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 当与组件一起工作时，我们偶尔需要将父内容与子内容交织在一起，这意味着你需要将数据传递到你的组件中。想象一下，你有一个自定义表单组件，你希望在图书出版网站上使用它。在表单中包含两个文本输入元素，分别命名为作者和标题。每个文本输入元素之前都有一个标签来描述它们。每个标签的标题已经在根Vue.js实例的数据函数中定义好了。
- en: You may have noticed when working with components that you can’t add content
    in between the opening and closing tags. As you can see in [figure 7.1](#ch07fig01),
    any content in between the opening and closing tags will be replaced.
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 当你与组件一起工作时，你可能已经注意到你无法在开标签和闭标签之间添加内容。正如你在[图7.1](#ch07fig01)中看到的，开标签和闭标签之间的任何内容都将被替换。
- en: Figure 7.1\. Information inside component tags will be discarded.
  id: totrans-927
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.1. 组件标签内的信息将被丢弃。
- en: '![](07fig01_alt.jpg)'
  id: totrans-928
  prefs: []
  type: TYPE_IMG
  zh: '![07fig01_alt](07fig01_alt.jpg)'
- en: The easiest way to make sure content is shown is to use the slot element, as
    we’ll see next. This can be accomplished with Vue’s *slot* element, a special
    tag that Vue.js uses to represent where data that’s added in between the opening
    and closing tags of a component should be shown. In other JavaScript frameworks,
    this process is also known as *content distribution*; in Angular, it’s called
    *transclusion* and it’s similar to React’s child components. No matter the name
    or framework being used, the idea is the same. It’s a way to embed content from
    the parent to the child without passing it in.
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 确保内容显示的最简单方法是使用插槽元素，正如我们接下来将要看到的。这可以通过Vue的*slot*元素来完成，这是一个Vue.js用来表示在组件的开标签和闭标签之间添加的数据应该显示在哪里的特殊标签。在其他JavaScript框架中，这个过程也被称为*内容分发*；在Angular中，它被称为*transclusion*，它与React的子组件类似。无论名称或使用的框架如何，想法是相同的。这是一种将内容从父组件嵌入到子组件中而不传递它的方法。
- en: At first, you may think of passing the values down from the root Vue.js instance
    to the child component. This will work, but let’s see if we run into any limitations.
    We’ll take each property and pass it down to the component.
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，你可能认为将值从根Vue.js实例传递到子组件。这会起作用，但让我们看看我们是否会遇到任何限制。我们将逐个属性传递到组件中。
- en: 'Create a new file for this example and create a local component called `form-component`
    and a simple form inside it. The goal here is to create two simple props that
    the component will accept: title and author. In the root Vue.js instance, pass
    in the props to the component, as you can see in [listing 7.1](#ch07ex01). This
    is similar to the prop passing we learned in [chapter 6](kindle_split_017.html#ch06).'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 为这个示例创建一个新文件，创建一个本地组件`form-component`并在其中创建一个简单的表单。这里的目的是创建两个组件将接受的简单props：标题和作者。在根Vue.js实例中，将props传递给组件，如[列表7.1](#ch07ex01)中所示。这与我们在[第6章](kindle_split_017.html#ch06)中学到的prop传递类似。
- en: For the next few examples we’ll create smaller standalone examples. Feel free
    to copy, or type, this into your text editor and follow along.
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几个示例中，我们将创建更小的独立示例。请随意将其复制或输入到您的文本编辑器中并跟随。
- en: 'Listing 7.1\. Creating a normal parent/child component with props: chapter-07/parent-child.html'
  id: totrans-933
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.1\. 使用props创建一个正常的父/子组件：chapter-07/parent-child.html
- en: '[PRE75]'
  id: totrans-934
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '***1* Passes in author label to form component**'
  id: totrans-935
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将作者标签传递给表单组件**'
- en: '***2* Passes in title label to form component**'
  id: totrans-936
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将标题标签传递给表单组件**'
- en: '***3* Displays passed in element title**'
  id: totrans-937
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 显示传递进来的元素标题**'
- en: '***4* Displays passed in element author**'
  id: totrans-938
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 显示传递进来的元素作者**'
- en: As I mentioned, the code will work, but as the form scales, we’ll need to deal
    with passing in several attributes. What if we added in ISBN, date, and year to
    the form? We need to add more props and more attributes to the component. This
    can become tedious and means many properties to keep track of, which can lead
    to errors in your code.
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我提到的，代码会起作用，但随着表单的扩展，我们需要处理传递多个属性。如果我们向表单中添加ISBN、日期和年份怎么办？我们需要向组件添加更多的props和更多属性。这可能会变得繁琐，意味着需要跟踪许多属性，这可能导致代码中的错误。
- en: Instead, let’s rewrite this example to use slots. To begin, add text that can
    be displayed at the top of the form. Instead of passing the value in as props,
    we’ll use a slot to display it. We won’t need to pass everything into the component
    as a property. We can display whatever we want directly inside the opening and
    closing brackets of the component. When the form is completed, it should look
    like [figure 7.2](#ch07fig02).
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，让我们重写这个示例以使用插槽。首先，添加可以在表单顶部显示的文本。而不是将值作为props传递，我们将使用一个插槽来显示它。我们不需要将所有内容作为一个属性传递给组件。我们可以在组件的开头和结尾括号内直接显示我们想要的任何内容。当表单完成时，它应该看起来像[图7.2](#ch07fig02)。
- en: Figure 7.2\. Book form page example.
  id: totrans-941
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.2\. 图书表单页面示例。
- en: '![](07fig02_alt.jpg)'
  id: totrans-942
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig02_alt.jpg)'
- en: Copy and paste [listing 7.1](#ch07ex01) into a file and change the data function
    and add a new property called `header`. (Remember you can always download the
    code for this book at my GitHub at [https://github.com/ErikCH/VuejsInActionCode](https://github.com/ErikCH/VuejsInActionCode).)
    As you can see in [figure 7.2](#ch07fig02), we’ll add a new header property that
    displays the Book Author Form. Next, find the opening and closing `form-component`
    that’s declared in the parent’s Vue.js instance. Add the `header` property in
    between those tags. Finally, we need to update the `form-component` itself. Immediately
    after the first `<form>`, add the `<slot></slot>` elements. This tells Vue to
    add whatever is in between the opening and closing tags of the form-component.
    To run this example, update the code from [listing 7.1](#ch07ex01) with the new
    updates in this listing.
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 将[列表7.1](#ch07ex01)复制并粘贴到一个文件中，更改data函数并添加一个名为`header`的新属性。（记住，你可以在我的GitHub上下载这本书的代码：[https://github.com/ErikCH/VuejsInActionCode](https://github.com/ErikCH/VuejsInActionCode)。）正如你在[图7.2](#ch07fig02)中看到的，我们将添加一个新的标题属性来显示“图书作者表单”。接下来，找到在父Vue.js实例中声明的`form-component`的开头和结尾标签。在这些标签之间添加`header`属性。最后，我们需要更新`form-component`本身。在第一个`<form>`标签之后立即添加`<slot></slot>`元素。这告诉Vue在表单组件的开头和结尾标签之间添加任何内容。要运行这个示例，请使用这个列表中的新更新更新[列表7.1](#ch07ex01)中的代码。
- en: 'Listing 7.2\. Adding in the `slot` element: chapter-07/parent-child-slots-extract.html'
  id: totrans-944
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.2\. 添加`slot`元素：chapter-07/parent-child-slots-extract.html
- en: '[PRE76]'
  id: totrans-945
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '***1* Shows header variable added inside form-component**'
  id: totrans-946
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在表单组件内添加了标题变量**'
- en: '***2* Inserts slot element from parent**'
  id: totrans-947
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 从父组件插入插槽元素**'
- en: '***3* Adds new header property**'
  id: totrans-948
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 添加新的标题属性**'
- en: 7.2\. A look at named slots
  id: totrans-949
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2\. 命名插槽的概述
- en: As of now, we’ve added only one slot element to our component. But, as you may
    have guessed, this isn’t too flexible. What if we had multiple props we wanted
    to pass in to a component and each prop needed to be displayed at different locations?
    Once again, passing in every single prop can be tedious, so what if we decided
    to use slots instead? Is there a way to do it?
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只向我们的组件添加了一个插槽元素。但是，正如你可能猜到的，这并不太灵活。如果我们想向组件传递多个属性，并且每个属性都需要在不同的位置显示呢？再次，传递每个单独的属性可能会很繁琐，那么如果我们决定使用插槽会怎样呢？有没有办法做到？
- en: This is where *named slots* come in. Named slots are like normal slots except
    they can be specifically placed inside a component. And unlike unnamed slots,
    we can have multiple named slots in our components. We can place these named slots
    anywhere in our components. Let’s add two named slots to our example app. To add
    them, we need to define exactly where we want them added in our child component.
    In [listing 7.3](#ch07ex03) we’ll add two named slots—`titleSlot` and `authorSlot`—to
    the `form-component`.
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是命名插槽发挥作用的地方。命名插槽就像普通插槽一样，但它们可以被具体放置在组件内部。与未命名插槽不同，我们可以在我们的组件中拥有多个命名插槽。我们可以在组件的任何位置放置这些命名插槽。让我们在我们的示例应用中添加两个命名插槽。要添加它们，我们需要在子组件中精确地定义我们想要它们添加的位置。在[列表
    7.3](#ch07ex03)中，我们将添加两个命名插槽——`titleSlot` 和 `authorSlot`——到 `form-component`。
- en: We’ll begin by replacing the `form-components` template with the new slot names.
    To do this, we must add a new `named-slot` element into the HTML. Take the completed
    code listing from 7.2 and move the label elements from the `form-component` to
    the parent’s template as seen in [listing 7.3](#ch07ex03). Make sure to change
    the name of the property in the label from `title` to `titleLabel` and from `author`
    to `authorLabel`.
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从用新的插槽名称替换 `form-components` 模板开始。为此，我们必须在 HTML 中添加一个新的 `named-slot` 元素。将
    7.2 中的完整代码列表中的标签元素从 `form-component` 移动到父模板中，如[列表 7.3](#ch07ex03)所示。确保将标签中的属性名从
    `title` 更改为 `titleLabel`，从 `author` 更改为 `authorLabel`。
- en: 'Next, add two new slot elements. Each will replace the label in the form component’s
    template. It should look like this: `<slot name="titleSlot"></slot>` and `<slot
    name="authorSlot"></slot>`.'
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加两个新的插槽元素。每个元素都将替换表单组件模板中的标签。它应该看起来像这样：`<slot name="titleSlot"></slot>`
    和 `<slot name="authorSlot"></slot>`。
- en: 'Inside the parent’s template, update the label we moved over and add a new
    attribute called slot to it. Each label should have a slot attribute like this:
    `<label for="title" slot="titleSlot">`. This tells Vue.js to make sure that the
    contents of this label are added to the corresponding named slot. Because we’re
    no longer using the passed-in props, we can delete them from the form component.
    This is the completed code listing.'
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: 在父模板内部，更新我们移动的标签，并给它添加一个名为 slot 的新属性。每个标签都应该有一个 slot 属性，如下所示：`<label for="title"
    slot="titleSlot">`。这告诉 Vue.js 确保这个标签的内容被添加到相应的命名插槽中。因为我们不再使用传入的属性，所以我们可以从表单组件中删除它们。这是完整的代码列表。
- en: 'Listing 7.3\. Using named slots: chapter-07/named-slots.html'
  id: totrans-955
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.3\. 使用命名插槽：chapter-07/named-slots.html
- en: '[PRE77]'
  id: totrans-956
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '***1* Displays the label using the slot titleSlot**'
  id: totrans-957
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用 slot titleSlot 显示标签**'
- en: '***2* Displays the label for the author linked to slot authorSlot**'
  id: totrans-958
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 显示与 slot authorSlot 链接的作者标签**'
- en: '***3* Inserts the named slot for titleSlot**'
  id: totrans-959
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 插入名为 titleSlot 的命名插槽**'
- en: '***4* Inserts the named slot for authorSlot**'
  id: totrans-960
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 插入名为 authorSlot 的命名插槽**'
- en: The named slots make it much easier to insert elements from the parent into
    the child component in various places. As we can see, the code is a little shorter
    and cleaner. In addition, there are no more props passing, and we no longer have
    to bind attributes when declaring the `form-component`. As you design more complicated
    applications, this will come in handy.
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 命名插槽使得将父组件中的元素插入到子组件的各个位置变得更加容易。正如我们所看到的，代码变得更短、更简洁。此外，不再需要传递属性，我们也不再需要在声明 `form-component`
    时绑定属性。当你设计更复杂的应用程序时，这将非常有用。
- en: '|  |'
  id: totrans-962
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Compilation scope with slots**'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: '**带有插槽的编译作用域**'
- en: In [listing 7.3](#ch07ex03) we added a data property from the root Vue.js instance
    within the opening and closing tags of our form component. Keep in mind that the
    child component doesn’t have access to this element because it was added from
    the parent. It’s easy to accidentally mistake the correct scope for elements when
    using slots. Remember that everything in the parent template is compiled in the
    parent’s scope. Everything compiled in the child template is compiled in the child
    scope. This is good to memorize because you might run into these problems in the
    future.
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 7.3](#ch07ex03)中，我们在表单组件的开头和结尾标签内添加了从根 Vue.js 实例的数据属性。请注意，子组件无法访问此元素，因为它是从父组件添加的。在使用插槽时，很容易错误地混淆元素的正确范围。记住，父模板中的所有内容都是在父范围中编译的。在子模板中编译的所有内容都是在子范围中编译的。这一点值得记住，因为你可能在将来遇到这些问题。
- en: '|  |'
  id: totrans-965
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 7.3\. Scoped slots
  id: totrans-966
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3\. 范围插槽
- en: '*Scoped slots* are like named slots except they’re more like reusable templates
    that you can pass data to. To do this, they use a special template element with
    a special attribute called `slot-scope`.'
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: '*范围插槽*类似于命名插槽，但它们更像是可以传递数据的可重用模板。为了做到这一点，它们使用一个特殊的模板元素，并具有一个名为 `slot-scope`
    的特殊属性。'
- en: The `slot-scope` attribute is a temporary variable that holds properties that
    are passed in from the component. Instead of passing values into a child component,
    we can pass values from the child component back to the parent.
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: '`slot-scope` 属性是一个临时变量，用于存储从组件传递过来的属性。我们不是将值传递给子组件，而是可以将值从子组件传递回父组件。'
- en: To illustrate this, imagine you have a web page that lists books. Each book
    has an author and title. We want to create a book component that holds the look
    and feel of the page, but we want to style each book that’s listed inside the
    parent. In this case, we’ll need to pass the book list from the child back to
    the parent. When all is said and done, it should look like [figure 7.3](#ch07fig03).
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，想象你有一个列出书籍的网页。每本书都有一个作者和标题。我们想要创建一个书籍组件，该组件包含页面的外观和感觉，但我们想要为父组件内列出的每本书添加样式。在这种情况下，我们需要将书籍列表从子组件传递回父组件。当一切完成时，它应该看起来像[图
    7.3](#ch07fig03)。
- en: Figure 7.3\. List of books and authors in the book list.
  id: totrans-970
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.3\. 书籍列表中的书籍和作者列表。
- en: '![](07fig03_alt.jpg)'
  id: totrans-971
  prefs: []
  type: TYPE_IMG
  zh: '![图片](07fig03_alt.jpg)'
- en: This is a bit of a contrived example, but it shows the power of scoped slots
    and how we can easily pass data back and forth from child components. To create
    this app, we’ll create a new book component. Inside the component we’ll display
    a header using a named slot, and we’ll create another named slot for each book.
    As you can see in [listing 7.4](#ch07ex04), we’ll add a `v-for` directive that
    will loop through all the books and bind values to each one.
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有点牵强的例子，但它展示了范围插槽的力量以及我们如何轻松地在子组件之间传递数据。为了创建这个应用程序，我们将创建一个新的书籍组件。在组件内部，我们将使用命名插槽显示标题，并为每本书创建另一个命名插槽。正如你在[列表
    7.4](#ch07ex04) 中可以看到的，我们将添加一个 `v-for` 指令，该指令将遍历所有书籍并将值绑定到每一本。
- en: The books array is created in the root Vue.js instance. It’s basically an array
    of objects, each having a title and author. We can pass that books array into
    the book-component using the `v-bind` directive `:books`.
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 书籍数组是在根 Vue.js 实例中创建的。它基本上是一个对象数组，每个对象都有一个标题和作者。我们可以使用 `v-bind` 指令 `:books`
    将该书籍数组传递给 book-component。
- en: Inside the parent’s template we’ve add the new `<template>` element. We must
    also add the `slot-scope` attribute to the template tag for this to work. The
    `slot-scope` attribute binds the passed-in value from the child component. In
    this case, `{{props.text}}` is equal to `{{book}}` from the child component.
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: 在父组件的模板中，我们添加了新的 `<template>` 元素。为了使其生效，我们还需要将 `slot-scope` 属性添加到模板标签上。`slot-scope`
    属性将子组件传递的值绑定。在这种情况下，`{{props.text}}` 等于子组件中的 `{{book}}`。
- en: Inside the template tags, we can now access the `{{props.text}}` as if it were
    `{{books}}`. In other words, `{{props.text.title}}` is the same as `{{book .title}}.`
    We’ll add special styling to each title and author to make it stand out.
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板标签内部，我们现在可以访问 `{{props.text}}`，就像它是 `{{books}}` 一样。换句话说，`{{props.text.title}}`
    与 `{{book .title}}` 相同。我们将为每个标题和作者添加特殊样式，使其突出显示。
- en: Open your code editor and try to copy the code yourself from [listing 7.4](#ch07ex04).
    What you’ll see is that we took the books array and passed it into the book component.
    We then displayed each book in a slot that got passed into a template that the
    parent displayed to the user.
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的代码编辑器并尝试自己从[列表7.4](#ch07ex04)复制代码。你会看到我们取了书籍数组并将其传递到书籍组件中。然后我们在一个传递给父组件的模板的槽中显示了每本书。
- en: 'Listing 7.4\. Scoped slots: chapter-07/name-scoped-slots.html'
  id: totrans-977
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.4\. 作用域插槽：chapter-07/name-scoped-slots.html
- en: '[PRE78]'
  id: totrans-978
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '***1* Shows book component with passed-in books**'
  id: totrans-979
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 显示带有传入书籍的书籍组件**'
- en: '***2* Shows header text using named slot header**'
  id: totrans-980
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用名为header的插槽显示头部文本**'
- en: '***3* Inserts template element with slot-scope of props**'
  id: totrans-981
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 插入具有slot-scope属性模板元素**'
- en: '***4* Displays text for each individual book**'
  id: totrans-982
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 显示每本单独的书籍文本**'
- en: '***5* Inserts named slot that binds the v-for directive**'
  id: totrans-983
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 插入名为slot的插槽，绑定v-for指令**'
- en: '***6* Passes in alias book from book in books**'
  id: totrans-984
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 从books中的book传递别名book**'
- en: '***7* Sets an array of books**'
  id: totrans-985
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 设置书籍数组**'
- en: This might be a little confusing at first, but using scoped slots is powerful.
    We can take values from our component and display them in our parent to do special
    styling. As you’re dealing with more complicated components with lists of data,
    this is a nice tool to have.
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能一开始有点令人困惑，但使用作用域插槽非常强大。我们可以从我们的组件中获取值，并在父组件中显示它们以进行特殊样式设计。当你处理更复杂的组件和数据列表时，这是一个很好的工具。
- en: 7.4\. Creating a dynamic components app
  id: totrans-987
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4\. 创建动态组件应用程序
- en: Another powerful feature of Vue.js is *dynamic components*. This feature lets
    us dynamically change between multiple components using the reserved `<component>`
    element and the `is` attribute.
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js的另一个强大功能是*动态组件*。这个功能允许我们使用保留的`<component>`元素和`is`属性在多个组件之间动态切换。
- en: Inside our data function, we can create a property that will determine which
    component will display. Then, inside our template, we need to add the component
    element with the `is` attribute which points to the data property we created.
    Let’s look at a practical example.
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的数据函数中，我们可以创建一个属性来决定哪个组件将显示。然后，在我们的模板中，我们需要添加带有指向我们创建的数据属性的`is`属性的组件元素。让我们看看一个实际例子。
- en: Imagine that we’re creating an app with three different components. We need
    to add a button so we can cycle through each one. One component will list our
    books, another will list a form to add books, and the last will display header
    information. When we get it all done, it should look like [figure 7.4](#ch07fig04).
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 想象我们正在创建一个包含三个不同组件的应用程序。我们需要添加一个按钮，以便我们可以循环遍历每一个。一个组件将列出我们的书籍，另一个将列出添加书籍的表单，最后一个将显示头部信息。当我们完成所有这些后，它应该看起来像[图7.4](#ch07fig04)。
- en: Figure 7.4\. Dynamic book component cycle that displays each component after
    clicking the Cycle button.
  id: totrans-991
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.4\. 点击“循环”按钮后显示每个组件的动态书籍组件循环。
- en: '![](07fig04_alt.jpg)'
  id: totrans-992
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig04_alt.jpg)'
- en: Clicking the Cycle button displays the next component. The Cycle button triggers
    simple JavaScript that rotates through the book component to the form component
    then to the header component.
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“循环”按钮将显示下一个组件。循环按钮触发简单的JavaScript，使书组件旋转到表单组件，然后到头部组件。
- en: Open your text editor and create a new Vue.js application. Instead of creating
    one component, we’ll create three. In each template, we’ll display text letting
    the user know which component is activated. You can see an example of this in
    [listing 7.5](#ch07ex05).
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的文本编辑器并创建一个新的Vue.js应用程序。我们不会创建一个组件，而是创建三个。在每个模板中，我们将显示文本，让用户知道哪个组件被激活。你可以在[列表7.5](#ch07ex05)中看到一个例子。
- en: The data function will have one property called `currentView`. This property
    will point to the `BookComponent` at the start of the application. Next, create
    a method called `cycle`. This will update the `currentView` property on every
    click so it cycles through all the components.
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 数据函数将有一个名为`currentView`的属性。这个属性将在应用程序开始时指向`BookComponent`。接下来，创建一个名为`cycle`的方法。这个方法将在每次点击时更新`currentView`属性，以便它循环遍历所有组件。
- en: 'As a final step, in the root Vue.js instance we’ll add our button, with a click
    event attached like this: `<button @click="cycle">Cycle</button>`. Under the button
    we’ll add an <`h1>` tag with our new component element. The component element
    will have one attribute, `is`, which will point to `currentView`. This is how
    you can dynamically change the component. The `currentView` property will update
    on every button click. To run this example, create a dynamic-components.html file.
    Add in this code.'
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，在根Vue.js实例中，我们将添加我们的按钮，并附加一个点击事件，如下所示：`<button @click="cycle">Cycle</button>`。在按钮下方，我们将添加一个`<h1>`标签，其中包含我们的新组件元素。组件元素将有一个属性，`is`，它将指向`currentView`。这就是你可以动态更改组件的方式。`currentView`属性将在每次按钮点击时更新。要运行此示例，创建一个dynamic-components.html文件。添加以下代码。
- en: 'Listing 7.5\. Dynamic components: chapter-07/dynamic-components.html'
  id: totrans-997
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.5\. 动态组件：chapter-07/dynamic-components.html
- en: '[PRE79]'
  id: totrans-998
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '***1* On every button click, the cycle method is triggered that changes currentView.**'
  id: totrans-999
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在每次按钮点击时，都会触发cycle方法来改变当前视图。**'
- en: '***2* Shows the component element that’s dynamically bound to currentView**'
  id: totrans-1000
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 显示与当前视图动态绑定的组件元素**'
- en: '***3* Lists all components created**'
  id: totrans-1001
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 列出所有创建的组件**'
- en: '***4* This is the property that’s assigned initially to the BookComponent.**'
  id: totrans-1002
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 这是分配给BookComponent的初始属性。**'
- en: '***5* Shows the method to cycle through all three components**'
  id: totrans-1003
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 显示循环所有三个组件的方法**'
- en: You’ve learned how you can use one button to cycle through three different components.
    It’s also possible to do this example using multiple `v-if` and `v-else` directives
    but this is much easier to understand and works better.
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学会了如何使用一个按钮来循环三个不同的组件。也可以使用多个`v-if`和`v-else`指令来做这个示例，但这更容易理解且效果更好。
- en: 7.5\. Setting up async components
  id: totrans-1005
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5\. 设置异步组件
- en: When working with larger applications, there might be times when we need to
    divide the app into smaller components and load only parts of the app when needed.
    Vue makes this easy with asynchronous components. Each component can be defined
    as a function that asynchronously resolves the component. Furthermore, Vue.js
    will cache the results for future re-renders.
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理大型应用程序时，可能会有需要将应用程序分成更小的组件，并在需要时只加载应用程序的部分的情况。Vue通过异步组件使这变得简单。每个组件都可以定义为异步解决组件的函数。此外，Vue.js将缓存结果以供未来的重新渲染。
- en: Let’s set up a simple example and simulate a server load. Going back to our
    book example, let’s say we’re loading a book list from a backend, and that backend
    takes a second to respond. Let’s resolve this using Vue.js. [Figure 7.5](#ch07fig05)
    is how it will look when we’re all done.
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置一个简单的示例并模拟服务器负载。回到我们的书籍示例，假设我们从后端加载书籍列表，并且后端需要一秒钟来响应。让我们使用Vue.js来解决这个问题。[图7.5](#ch07fig05)展示了我们完成后的样子。
- en: Figure 7.5\. Async component rendered after 1 second onscreen.
  id: totrans-1008
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.5\. 在屏幕上渲染1秒后的异步组件。
- en: '![](07fig05_alt.jpg)'
  id: totrans-1009
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig05_alt.jpg)'
- en: The function has a resolve and reject callback and we must set up our component
    to handle the situations. Create an app and new book component, as seen in [listing
    7.6](#ch07ex06).
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: 函数有一个resolve和reject回调，我们必须设置我们的组件来处理这些情况。创建一个应用程序和一个新的书籍组件，如[列表7.6](#ch07ex06)所示。
- en: This simple component displays text on the screen after it resolves. We’ll create
    a timeout so it will take 1 second. The timeout is used to simulate network latency.
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的组件在解决后会在屏幕上显示文本。我们将创建一个超时，使其需要1秒钟。超时用于模拟网络延迟。
- en: The most important thing to do when creating an async component is to define
    it as a function with a resolve and reject callback. You can trigger different
    actions to occur, depending on whether the callback is resolved or rejected.
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 创建异步组件时最重要的事情是将它定义为一个带有resolve和reject回调的函数。你可以根据回调是解决还是拒绝来触发不同的操作。
- en: To run this example, create a file called async-componets.html. Copy the code
    in the following listing to see it in action. You should see a simple asynchronous
    component. We’re simulating a server that takes 1 second to respond. We could
    have also created a reject as well that would have resolved if the call failed.
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此示例，创建一个名为async-componets.html的文件。将以下列表中的代码复制到文件中，以查看其效果。你应该会看到一个简单的异步组件。我们模拟了一个需要1秒钟来响应的服务器。我们也可以创建一个reject，如果调用失败，它将解决。
- en: Listing 7.6\. Async components; chapter-07/async-components.html
  id: totrans-1014
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.6\. 异步组件；chapter-07/async-components.html
- en: '[PRE80]'
  id: totrans-1015
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '***1* Displays book component in template**'
  id: totrans-1016
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在模板中显示书籍组件**'
- en: '***2* Shows an asynchronous book component that must resolve or reject**'
  id: totrans-1017
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 显示必须解决或拒绝的异步书籍组件**'
- en: '***3* Shows a timeout that simulates a server and resolves after 1000 ms**'
  id: totrans-1018
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 显示一个模拟服务器并在 1000 毫秒后解决的超时**'
- en: '|  |'
  id: totrans-1019
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Advanced async components**'
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: '**高级异步组件**'
- en: Since Vue 2.3.0, you can now create more advanced async components. In these
    components, you can set up loading components that will display when the component
    is loaded. You can set error components and set timeouts. If you’d like to learn
    more about these components, check out the official guides at [http://mng.bz/thlA](http://mng.bz/thlA).
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 Vue 2.3.0 版本以来，你现在可以创建更高级的异步组件。在这些组件中，你可以设置加载组件，当组件加载时将显示这些组件。你可以设置错误组件和设置超时。如果你想了解更多关于这些组件的信息，请查看官方指南[http://mng.bz/thlA](http://mng.bz/thlA)。
- en: '|  |'
  id: totrans-1022
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 7.6\. Converting the pet store app using Vue-CLI
  id: totrans-1023
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.6\. 使用 Vue-CLI 转换宠物商店应用程序
- en: Until now, we’ve built our applications using one file. This has proved challenging
    because our pet store application has grown. One thing that would make our code
    base cleaner is to break the application into separate components.
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用单个文件构建我们的应用程序。这已经证明是具有挑战性的，因为我们的宠物商店应用程序已经增长。让我们的代码库更整洁的一件事是将应用程序分解成单独的组件。
- en: As we saw in [chapter 6](kindle_split_017.html#ch06), there are many ways to
    break up our application. One of the most powerful ways is using single-file components,
    which have many advantages over the other ways of creating components. The most
    important advantages are component-scoped CSS, syntax highlighting, ease of reuse,
    and ES6 modules.
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第 6 章](kindle_split_017.html#ch06)中看到的，有很多方法可以拆分我们的应用程序。其中最强大的方法之一是使用单文件组件，它比其他创建组件的方法具有许多优势。最重要的优势是组件作用域的
    CSS、语法高亮、易于重用和 ES6 模块。
- en: Component-scoped CSS lets us scope CSS per component. This can help us easily
    make specific styles for each component. Syntax highlighting is improved because
    we no longer have to worry about our IDE not recognizing our component’s template
    text since it no longer has to be assigned to a variable or property. ES6 modules
    make it easier to pull in our favorite third-party libraries. Each has advantages
    that make writing Vue.js applications a little easier.
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: 组件作用域的 CSS 允许我们按组件划分 CSS。这可以帮助我们轻松地为每个组件创建特定的样式。语法高亮得到了改进，因为我们不再需要担心我们的 IDE
    无法识别我们的组件模板文本，因为它不再需要分配给变量或属性。ES6 模块使得引入我们喜欢的第三方库变得更加容易。每个都有优势，使得编写 Vue.js 应用程序变得稍微容易一些。
- en: To take full advantage of single-file components, we’ll need to use a build
    tool such as Webpack that helps bundle all our modules and dependencies. In addition,
    we can use tools such as Babel to transpile our JavaScript so we can ensure that
    it’s compatible with every browser. We could try to do this all ourselves, but
    Vue.js has given us Vue-CLI to make this process much easier.
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用单文件组件，我们需要使用像 Webpack 这样的构建工具来帮助我们捆绑所有模块和依赖项。此外，我们可以使用像 Babel 这样的工具来转译我们的
    JavaScript，以确保它与每个浏览器兼容。我们本可以自己尝试做这件事，但 Vue.js 给我们提供了 Vue-CLI 来使这个过程变得更加容易。
- en: 'Vue-CLI is a scaffolding tool to help jumpstart your Vue.js applications. It
    comes with all the glue needed to get started. The CLI has a number of official
    templates, so you can start your application with the tools you prefer. (You can
    learn more about Vue-CLI from the official GitHub page at [https://vuejs.org/v2/guide/installation.html](https://vuejs.org/v2/guide/installation.html).)
    The following is a list of the most common templates:'
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: Vue-CLI 是一个脚手架工具，可以帮助你快速启动 Vue.js 应用程序。它包含了启动所需的所有粘合剂。CLI 提供了多个官方模板，因此你可以使用你喜欢的工具开始你的应用程序。（你可以在官方
    GitHub 页面[https://vuejs.org/v2/guide/installation.html](https://vuejs.org/v2/guide/installation.html)上了解更多关于
    Vue-CLI 的信息。）以下是最常见的模板列表：
- en: '***webpack*—** A full-featured Webpack build with Vue loader, hot reload, linting
    testing, and CSS extraction.'
  id: totrans-1029
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***webpack*—** 一个功能齐全的 Webpack 构建，带有 Vue loader、热重载、代码检查和 CSS 提取。'
- en: '***webpack-simple*—** A simple Webpack + Vue loader for quick prototyping.'
  id: totrans-1030
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***webpack-simple*—** 一个简单的 Webpack + Vue loader，用于快速原型设计。'
- en: '***browserify*—** A full-featured Browserify + Vuetify setup with hot reload,
    linting, and unit testing.'
  id: totrans-1031
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***browserify*—** 一个功能齐全的 Browserify + Vuetify 设置，带有热重载、代码检查和单元测试。'
- en: '***browserify-simple*—** A simple Browserify + Vuetify setup for quick prototyping.'
  id: totrans-1032
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***browserify-simple*—** 一个简单的 Browserify + Vuetify 设置，用于快速原型设计。'
- en: '***pwa*—** A PWA (Progressive Web Application) template based on Webpack.'
  id: totrans-1033
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***pwa*—** 基于 Webpack 的 PWA（渐进式网络应用程序）模板。'
- en: '***Simple*—** The simplest possible Vue setup in a single HTML file.'
  id: totrans-1034
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Simple*—** 在单个 HTML 文件中可能最简单的 Vue 设置。'
- en: To create an application, you’ll need to install Node and Git, and then install
    Vue-CLI. (If you haven’t done this yet, please refer to [appendix A](kindle_split_025.html#app01)
    for more information.)
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个应用，你需要安装 Node 和 Git，然后安装 Vue-CLI。（如果你还没有这样做，请参阅 [附录 A](kindle_split_025.html#app01)
    获取更多信息。）
- en: '|  |'
  id: totrans-1036
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-1037
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**注意**'
- en: As of this writing Vue-CLI 3.0 is still in beta. This chapter was written with
    the latest version of Vue-CLI, 2.9.2\. If you’re using Vue-CLI 3.0, several of
    these options will be different. Instead of creating the application with `vue
    init`, you’ll use `vue create <project name>`. It will then ask you a new set
    of questions. You can either select a set of default presets or the features you
    want from a list. These include TypeScript, Router, Vuex, and CSS pre-processors,
    to name a few. If you’re following along, make sure to select the same options
    as you see in [listing 7.7](#ch07ex07). You can then skip ahead to [section 7.6.2](#ch07lev2sec2).
    For more information on Vue-CLI 3.0, check out the official readme at [https://github.com/vuejs/vue-cli/blob/dev/docs/README.md](https://github.com/vuejs/vue-cli/blob/dev/docs/README.md).
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: 到本文写作时，Vue-CLI 3.0 仍然处于测试版。本章是使用 Vue-CLI 的最新版本 2.9.2 编写的。如果你使用 Vue-CLI 3.0，其中一些选项可能会有所不同。你将不会使用
    `vue init` 来创建应用，而是使用 `vue create <项目名称>`。然后它会问你一系列新问题。你可以选择一组默认预设或从列表中选择你想要的功能。这些包括
    TypeScript、Router、Vuex 和 CSS 预处理器等。如果你正在跟随，请确保选择与你在 [列表 7.7](#ch07ex07) 中看到相同的选项。然后你可以跳到
    [7.6.2 节](#ch07lev2sec2)。有关 Vue-CLI 3.0 的更多信息，请查看官方的 README 文件，链接为 [https://github.com/vuejs/vue-cli/blob/dev/docs/README.md](https://github.com/vuejs/vue-cli/blob/dev/docs/README.md)。
- en: '|  |'
  id: totrans-1039
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 7.6.1\. Creating a new application with Vue-CLI
  id: totrans-1040
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.6.1\. 使用 Vue-CLI 创建新应用
- en: Let’s create an application using Vue-CLI for our pet store. Open your terminal
    and type in `vue init webpack petstore`. This command tells Vue-CLI to create
    an application using the Webpack template.
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Vue-CLI 为我们的宠物商店创建一个应用。打开你的终端，输入 `vue init webpack petstore`。这个命令告诉 Vue-CLI
    使用 Webpack 模板创建一个应用。
- en: As of this writing the latest Vue-CLI version is 2.9.2\. If you’re using a later
    version don’t worry, the questions should be similar and self-explanatory. If
    you run into any issues, follow the official guides on the installation and use
    of Vue-CLI at [https://vuejs.org/v2/guide/installation.html](https://vuejs.org/v2/guide/installation.html)
    - CLI.
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: 到本文写作时，最新的 Vue-CLI 版本是 2.9.2。如果你使用的是更高版本，请不要担心，问题应该是类似的，并且是自我解释的。如果你遇到任何问题，请遵循
    Vue-CLI 的官方指南，了解其安装和使用方法，链接为 [https://vuejs.org/v2/guide/installation.html](https://vuejs.org/v2/guide/installation.html)
    - CLI。
- en: After you run the command, you’re prompted with a few questions. The first asks
    for a name, then a description and author. Type in the name as `petstore` and
    put in any description and author you like. The next few questions prompt you
    whether to run Vue.js with a runtime only or runtime and compiler. I recommend
    running with the runtime and compiler together. This makes it easier when we’re
    creating our templates; otherwise all templates are allowed in only .vue files.
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行命令后，你会被提示几个问题。第一个问题要求输入名称，然后是描述和作者。输入名称为 `petstore`，并输入任何你喜欢的描述和作者。接下来的几个问题会询问你是否要使用仅运行时或运行时和编译器版本的
    Vue.js。我建议同时运行运行时和编译器。这样在我们创建模板时会更方便；否则，所有模板都只能在 .vue 文件中使用。
- en: The next question asks about installing the vue-router. Type `yes`. After this,
    it asks if you want to use ESLint. This is a linting library that will check your
    code on every save. For our purposes, we’ll say no here because this isn’t important
    to our project. The last two questions are about testing. In later chapters, I’ll
    show you how to create test cases using the vue-test-utils library, but for now
    you can answer yes to both. Follow along with the this listing and create a new
    Vue-CLI application for our pet store app.
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个问题会询问是否安装 vue-router。输入 `yes`。之后，它会询问你是否想使用 ESLint。这是一个在每次保存时都会检查你代码的代码检查库。对于我们的目的，我们在这里说“不”，因为这对我们的项目来说并不重要。最后两个问题是关于测试的。在后面的章节中，我会向你展示如何使用
    vue-test-utils 库创建测试用例，但到目前为止，你可以对两个问题都回答“是”。跟随这个列表，为我们的宠物商店应用创建一个新的 Vue-CLI 应用程序。
- en: Listing 7.7\. Terminal commands
  id: totrans-1045
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.7\. 终端命令
- en: '[PRE81]'
  id: totrans-1046
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '***1* Shows the init command that creates a new application**'
  id: totrans-1047
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 显示创建新应用的 init 命令**'
- en: '***2* Lists setup questions and answers**'
  id: totrans-1048
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 列出设置问题和答案**'
- en: 'After the application is created and the template is downloaded, you need to
    install all the dependencies. Change directories to petstore and run `npm install`,
    or YARN, to install all the dependencies by running the following commands at
    the prompt:'
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序创建并下载模板后，你需要安装所有依赖项。切换到 petstore 目录，并运行 `npm install` 或 YARN，在提示符下运行以下命令来安装所有依赖项：
- en: '[PRE82]'
  id: totrans-1050
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'This will install all the dependencies for your application. This could take
    several minutes. After all the dependencies are installed, you should now be able
    to run the server with the following command:'
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装应用程序的所有依赖项。这可能需要几分钟。所有依赖项安装完成后，你现在应该能够使用以下命令运行服务器：
- en: '[PRE83]'
  id: totrans-1052
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Open your web browser and navigate to localhost:8080, where you should see the
    Welcome to Your Vue.js App window as seen in [figure 7.6](#ch07fig06). (While
    the server is running, any changes will be hot reloaded in your browser.) If the
    server doesn’t start, make sure another application isn’t running on the default
    8080 port.
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的网络浏览器，导航到 localhost:8080，你应该会看到欢迎来到您的 Vue.js 应用程序窗口，如图 7.6 所示。（当服务器运行时，任何更改都将通过浏览器进行热重载。）如果服务器没有启动，请确保没有其他应用程序在默认的
    8080 端口上运行。
- en: Figure 7.6\. Default welcome screen for Vue-CLI
  id: totrans-1054
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.6\. Vue-CLI 的默认欢迎屏幕
- en: '![](07fig06_alt.jpg)'
  id: totrans-1055
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig06_alt.jpg)'
- en: We’re now ready to move to our pet store application.
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好进入我们的宠物商店应用程序。
- en: 7.6.2\. Setting up our routes
  id: totrans-1057
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.6.2\. 设置我们的路由
- en: Vue-CLI comes with an advanced routing library called *vue-router*, the official
    router for Vue.js. It supports all sorts of features, including route parameters,
    query parameters, and wildcards. In addition, it has HTML5 history mode and hash
    mode with auto-fallback for Internet Explorer 9\. You should have the ability
    to create any route you need with it and not have to worry about browser compatibility.
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: Vue-CLI 内置了一个高级路由库，称为 *vue-router*，它是 Vue.js 的官方路由器。它支持各种功能，包括路由参数、查询参数和通配符。此外，它具有
    HTML5 历史模式和哈希模式，并自动回退到 Internet Explorer 9。你应该能够使用它创建任何所需的路由，而无需担心浏览器兼容性。
- en: For our pet store app, we’ll create two routes called `Main` and `Form`. The
    `Main` route will display the list of products from our products.json file. The
    `Form` route will be our checkout page.
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的宠物商店应用程序，我们将创建两个名为 `Main` 和 `Form` 的路由。`Main` 路由将显示来自我们的 products.json
    文件的产品列表。`Form` 路由将是我们的结账页面。
- en: Inside the app we created, open the src/router/index.js file and look for the
    routes array. You may see the default `Hello` route in it; feel free to delete
    this. Update the routes array so it matches [listing 7.8](#ch07ex08). Every object
    in the array has at a minimum a path and a component. The path is the URL that
    you’ll need to navigate to inside the browser to visit the route. The component
    is the name of the component we’ll use for that route.
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建的应用程序内部，打开 src/router/index.js 文件，查找路由数组。你可能会在其中看到默认的 `Hello` 路由；你可以自由地删除它。更新路由数组，使其与
    [列表 7.8](#ch07ex08) 匹配。数组中的每个对象至少有一个路径和一个组件。路径是你需要在浏览器中导航到的 URL，以访问该路由。组件是我们将用于该路由的组件名称。
- en: Optionally we can also add a name property. This name represents the route.
    We’ll use the route name later. Props is another optional property. This tells
    Vue.js if the component should expect props being sent to it.
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，我们还可以添加一个名称属性。这个名称代表路由。我们将在稍后使用路由名称。Props 是另一个可选属性。这告诉 Vue.js 组件是否应该期望接收传递给它的属性。
- en: After updating the array make sure to import the `Form` and `Main` components
    into the router. Any time we refer to a component, you must import it. By default,
    Vue-CLI uses the ES6 import style. If the components aren’t imported, you’ll see
    an error in the console.
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新数组后，请确保将 `Form` 和 `Main` 组件导入到路由器中。每次我们引用一个组件时，都必须导入它。默认情况下，Vue-CLI 使用 ES6
    导入风格。如果组件没有导入，你将在控制台看到错误。
- en: 'Finally, by default the vue-router uses hashes when routing. When navigating
    to `form` in the browser, Vue will construct the URL as `#/form` instead of `/form`.
    We can turn this off by adding `mode: ''history''` to the router.'
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，默认情况下，vue-router 在路由时使用哈希。当在浏览器中导航到 `form` 时，Vue 将构造 URL 为 `#/form` 而不是
    `/form`。我们可以通过向路由器添加 `mode: ''history''` 来关闭这个功能。'
- en: 'Listing 7.8\. Adding routes: chapter-07/petstore/src/router/index.js'
  id: totrans-1064
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.8\. 添加路由：chapter-07/petstore/src/router/index.js
- en: '[PRE84]'
  id: totrans-1065
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '***1* Imports the components Form and Main**'
  id: totrans-1066
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入组件 Form 和 Main**'
- en: '***2* Shows history mode with routes without hashes**'
  id: totrans-1067
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 显示没有哈希的路由的历史模式**'
- en: '***3* Shows iMain route at /**'
  id: totrans-1068
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 显示 iMain 路由在 /****'
- en: '***4* Shows Form route at /form**'
  id: totrans-1069
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 显示 /form 路由的表单**'
- en: It’s a good idea to start any new application with your routes first. It gives
    you a good indication on how you want to construct the app.
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: 任何新的应用程序都应该首先从路由开始。这能给你一个很好的指示，了解你想要如何构建应用程序。
- en: 7.6.3\. Adding CSS, Bootstrap, and Axios to our application
  id: totrans-1071
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.6.3\. 将 CSS、Bootstrap 和 Axios 添加到我们的应用程序中
- en: Our pet store app uses a handful of different libraries that we need to add
    to our CLI project. We can handle this in different ways.
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的宠物商店应用程序使用了一些不同的库，我们需要将它们添加到我们的 CLI 项目中。我们可以用不同的方式处理这个问题。
- en: One way is to use a Vue.js-specific library. As Vue has grown, so has the ecosystem.
    New Vue.js-specific libraries are popping up all the time. For example, BootstrapVue,
    is a Vue.js-specific library to add Bootstrap to our project. Vuetify is a popular
    material-design library. We’ll be looking at several of these libraries in the
    future, but not right now.
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是用 Vue.js 特定的库。随着 Vue 的增长，其生态系统也在增长。新的 Vue.js 特定库层出不穷。例如，BootstrapVue 是一个用于将
    Bootstrap 添加到我们的项目的 Vue.js 特定库。Vuetify 是一个流行的材料设计库。我们将在未来探讨这些库中的几个，但不是现在。
- en: Another common way of adding libraries is to include them in the index file.
    This is useful when there isn’t a Vue.js-specific library available.
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: 添加库的另一种常见方式是将它们包含在索引文件中。当没有特定于 Vue.js 的库可用时，这很有用。
- en: To get started, open the index.html file in the root folder of our pet store
    application. To stay consistent with our original application from [chapter 5](kindle_split_016.html#ch05),
    we’ll add a link to Bootstrap 3 and Axios CDN in this file, as shown in the following
    listing. By adding these libraries in this file, we now have access to it throughout
    the application.
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请打开宠物商店应用程序根目录中的 index.html 文件。为了与第 5 章[中的原始应用程序](kindle_split_016.html#ch05)保持一致，我们将在该文件中添加
    Bootstrap 3 和 Axios CDN 的链接，如下所示。通过在这份文件中添加这些库，我们现在可以在整个应用程序中访问它们。
- en: 'Listing 7.9\. Adding Axios and Bootstrap: chapter-07/petstore/index.html'
  id: totrans-1076
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 7.9\. 添加 Axios 和 Bootstrap: chapter-07/petstore/index.html'
- en: '[PRE85]'
  id: totrans-1077
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '***1* Denotes Axios library CDN**'
  id: totrans-1078
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 表示 Axios 库 CDN**'
- en: '***2* Shows Bootstrap 3 library CDN**'
  id: totrans-1079
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 显示 Bootstrap 3 库 CDN**'
- en: We have a few ways we can add in the CSS. As we’ll see later, one way to add
    CSS is to scope it to each component. This is a helpful feature if we have specific
    CSS we want to use for a component.
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几种方法可以添加 CSS。正如我们稍后将要看到的，添加 CSS 的一种方法是将它限制在每个组件中。如果我们想为组件使用特定的 CSS，这是一个有用的功能。
- en: We can also specify CSS that will be used throughout the site. To keep things
    simple, let’s add our CSS to our pet store app so it can be accessed by all components
    inside it. (Later, we’ll look at using scoped CSS.)
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以指定将在整个网站上使用的 CSS。为了保持简单，让我们将我们的 CSS 添加到我们的宠物商店应用程序中，以便所有内部组件都可以访问它。（稍后我们将探讨使用作用域
    CSS。）
- en: Open the src/main.js file. This is where the root Vue.js instance lives. From
    here we can import the CSS we’d like to use for our application. Because we’re
    using Webpack we’ll need to use the `require` keyword with the relative path to
    the asset.
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 src/main.js 文件。这是根 Vue.js 实例所在的地方。从这里我们可以导入我们想要用于应用程序的 CSS。因为我们使用 Webpack，所以我们需要使用带有相对路径的
    `require` 关键字。
- en: '|  |'
  id: totrans-1083
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: FYI
  id: totrans-1084
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: FYI
- en: For more information on how Webpack and assets work, check out the documentation
    at [https://vuejs-templates.github.io/webpack/static.html](https://vuejs-templates.github.io/webpack/static.html).
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于 Webpack 和资源如何工作的信息，请查看[https://vuejs-templates.github.io/webpack/static.html](https://vuejs-templates.github.io/webpack/static.html)上的文档。
- en: '|  |'
  id: totrans-1086
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Copy the app.css file into the src/assets folder, as shown in the next listing.
    You can find a copy of the app.css with the included code for the book in the
    [appendix A](kindle_split_025.html#app01).
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: 将 app.css 文件复制到 src/assets 文件夹中，如下所示的下一条列表所示。您可以在[附录 A](kindle_split_025.html#app01)中找到包含书中代码的
    app.css 的副本。
- en: 'Listing 7.10\. Adding CSS: chapter-07/petstore/src/main.js'
  id: totrans-1088
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 7.10\. 添加 CSS: chapter-07/petstore/src/main.js'
- en: '[PRE86]'
  id: totrans-1089
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '***1* Adds the app.css to the application**'
  id: totrans-1090
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将 app.css 添加到应用程序中**'
- en: After the CSS is added to the application, every component will use it.
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 添加到应用程序后，每个组件都将使用它。
- en: 7.6.4\. Setting up our components
  id: totrans-1092
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.6.4\. 设置我们的组件
- en: As we discussed previously, components make it easy to break our application
    into smaller reusable parts. Let’s break our pet store app into a few smaller
    pieces so we can more easily work with our application. For the pet store we’ll
    have a `Main`, `Form`, and `Header`. The `Header` component will display our site
    name and navigation, `Main` will list all our products, and `Form` will display
    the checkout form.
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，组件使得将我们的应用程序分解成更小的可重用部分变得容易。让我们将宠物商店应用程序分解成几个更小的部分，这样我们可以更容易地处理我们的应用程序。对于宠物商店，我们将有`Main`、`Form`和`Header`。`Header`组件将显示我们的网站名称和导航，`Main`将列出所有产品，而`Form`将显示结账表单。
- en: Before we begin, delete the HelloWorld.vue file in the src/components folder.
    We won’t use this. Create a file called Header.vue in this folder instead. This
    file is where we’ll put in our header information.
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，请删除位于src/components文件夹中的HelloWorld.vue文件。我们不会使用这个文件。在这个文件夹中创建一个名为Header.vue的文件代替。这个文件是我们放置头部信息的地点。
- en: Most .vue files follow a simple pattern. The top of the file is usually where
    the template resides. The template is surrounded by an opening and closing `template`
    tag. As we’ve seen before, you must also include a root element after the template
    tag. I usually put a `<div>` tag in but a <`header>` tag will work too. Keep in
    mind a template can only have one root element.
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数.vue文件遵循一个简单的模式。文件的顶部通常是模板所在的位置。模板被一个开标签和一个闭标签`template`包围。正如我们之前看到的，在模板标签之后也必须包含一个根元素。我通常放一个`<div>`标签，但一个`<header>`标签也可以。记住，一个模板只能有一个根元素。
- en: After the template is a `<script>` tag. This is where we’ll create our Vue instance.
    After the `<script>` tag is a `<style>` tag, which is where we can optionally
    put in our CSS code and scope it to the component. (You’ll see this in [listing
    7.12](#ch07ex12).)
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: 模板之后是一个`<script>`标签。这是我们将创建Vue实例的地方。在`<script>`标签之后是一个`<style>`标签，我们可以在其中可选地放入CSS代码并将其范围限定在组件内。（你将在[列表7.12](#ch07ex12)中看到这一点。）
- en: Go ahead and copy the code from [listing 7.11](#ch07ex11) for the template.
    This code is similar to the code in [chapter 5](kindle_split_016.html#ch05) for
    the header. You’ll notice that we have a new element in the template called `router-link`,
    which is a part of the vue-router library. The `router-link` element creates internal
    links in our Vue.js application between routes. The `<router-link>` tag has an
    attribute called `to`. We can bind that attribute to one of our named routes.
    Let’s bind it to the `Main` route.
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: 现在复制[列表7.11](#ch07ex11)中的代码到模板中。这段代码与[第5章](kindle_split_016.html#ch05)中用于头部的代码类似。你会注意到模板中有一个新元素叫做`router-link`，它是vue-router库的一部分。`router-link`元素在Vue.js应用程序的路线之间创建内部链接。`<router-link>`标签有一个名为`to`的属性。我们可以将这个属性绑定到我们命名的路线之一。让我们将其绑定到`Main`路线。
- en: 'Listing 7.11\. Header template: chapter-07/petstore/src/components/Header.vue'
  id: totrans-1098
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.11\. Header模板：chapter-07/petstore/src/components/Header.vue
- en: '[PRE87]'
  id: totrans-1099
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '***1* This links to the iMain route.**'
  id: totrans-1100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 这链接到iMain路线。**'
- en: Next, we need to create the logic for this component. We’ll copy and paste from
    our previous pet store application into the Header.vue file. We’ll need to make
    a few changes though. When we last updated the pet store application in [chapter
    5](kindle_split_016.html#ch05), we used a `v-if` directive to determine whether
    or not to display the checkout page. We created a method that toggled `showProduct`
    when the Checkout button was clicked.
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要为这个组件创建逻辑。我们将从之前的宠物商店应用程序中复制粘贴到Header.vue文件中。但是我们需要做一些修改。当我们上一次在[第5章](kindle_split_016.html#ch05)中更新宠物商店应用程序时，我们使用了一个`v-if`指令来确定是否显示结账页面。我们创建了一个方法，当点击Checkout按钮时切换`showProduct`。
- en: Let’s replace that logic so that instead of toggling `showProduct` we switch
    to the Form route we created earlier. As you can see in [listing 7.14](#ch07ex14),
    this is done with `this.$router.push`. Similar to the `router-link`, we need to
    provide the router with the name of the route we want to navigate to. For this
    reason, we’ll have the Checkout button navigate to the Form route.
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们替换这个逻辑，这样我们就不需要切换`showProduct`，而是切换到我们之前创建的Form路线。正如你在[列表7.14](#ch07ex14)中看到的，这是通过`this.$router.push`完成的。与`router-link`类似，我们需要向路由器提供我们想要导航到的路线的名称。因此，我们将Checkout按钮导航到Form路线。
- en: Because we changed the `sitename` variable to a link using `router-link`, it
    now looks a little different than it did before. We should update the CSS for
    our new anchor tag by putting it in the `<style>` section. Because we added the
    keyword `scoped` to it, Vue.js will make sure the CSS will be scoped for this
    component only.
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们将 `sitename` 变量通过 `router-link` 改为了链接，所以它现在看起来与之前略有不同。我们应该通过将其放在 `<style>`
    部分来更新我们的新锚标签的 CSS。因为我们在其中添加了关键字 `scoped`，Vue.js 将确保 CSS 只针对此组件进行作用域限制。
- en: Also, you may notice from [listing 7.12](#ch07ex12) that we’re no longer using
    the Vue.js instance initializer that we used in previous chapters. The CLI doesn’t
    require it. Instead we use a simpler syntax, the ES6 module default export (`export
    default { })`. Put all your Vue.js code in here.
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可能已经注意到从[列表7.12](#ch07ex12)中，我们不再使用之前章节中使用的 Vue.js 实例初始化器。CLI 不需要它。相反，我们使用更简单的语法，ES6
    模块默认导出（`export default { }`）。将所有 Vue.js 代码放在这里。
- en: In our CSS, we’ll turn off text decorations and set the color to black. Combine
    [listings 7.11](#ch07ex11) and [7.12](#ch07ex12) into one file.
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 CSS 中，我们将关闭文本装饰并将颜色设置为黑色。将[列表7.11](#ch07ex11)和[7.12](#ch07ex12)合并到一个文件中。
- en: 'Listing 7.12\. Adding the script and CSS: chapter-07/petstore/src/components/Header.vue'
  id: totrans-1106
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.12\. 添加脚本和 CSS：chapter-07/petstore/src/components/Header.vue
- en: '[PRE88]'
  id: totrans-1107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '***1* Navigates Vue.js app to the Form route**'
  id: totrans-1108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导航 Vue.js 应用到 Form 路由**'
- en: '***2* Shows scoped CSS**'
  id: totrans-1109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 显示作用域 CSS**'
- en: From there you should be all set with this component. You may have also noticed
    that our header accepts a prop called `cartItemCount`. Our main component will
    pass this information in, as we’ll see when we create the Main component. The
    `cartItemCount` will keep track of how many items we’ve added to our cart.
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，你应该已经设置好这个组件了。你可能也注意到我们的头部接受一个名为 `cartItemCount` 的属性。我们的主组件将传递这个信息，正如我们在创建
    Main 组件时将看到的。`cartItemCount` 将跟踪我们添加到购物车中的项目数量。
- en: 7.6.5\. Creating the Form component
  id: totrans-1111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.6.5\. 创建 Form 组件
- en: The `Form` component is where the checkout page resides. It will remain close
    to what we created in [chapter 5](kindle_split_016.html#ch05). The biggest difference
    is that we’re now referencing the new `my-header` component at the top of the
    template. We’ll also pass in the `cartItemCount` into the header.
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: '`Form` 组件是结账页面所在的位置。它将与我们[第5章](kindle_split_016.html#ch05)中创建的类似。最大的不同之处在于我们现在在模板顶部引用了新的
    `my-header` 组件。我们还将 `cartItemCount` 传递给头部。'
- en: Create a component in the src/components folder and call it Form.vue. As you
    can see in [listing 7.13](#ch07ex13), the HTML code in the template is almost
    exactly what we saw in [chapter 5](kindle_split_016.html#ch05). The only change
    is that we’ve added a new component at the top for the header. I won’t copy it
    all here, so I suggest that you download the code for chapter 07 (download instructions
    are in [appendix A](kindle_split_025.html#app01)).
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: 在 src/components 文件夹中创建一个组件，命名为 Form.vue。正如你在[列表7.13](#ch07ex13)中看到的，模板中的 HTML
    代码几乎与[第5章](kindle_split_016.html#ch05)中看到的一样。唯一的区别是我们已经在顶部添加了一个新的头部组件。我不会在这里复制所有内容，所以我建议你下载第07章的代码（下载说明在[附录A](kindle_split_025.html#app01)中）。
- en: 'Listing 7.13\. Creating the form component: chapter-07/petstore/src/components/Form.vue'
  id: totrans-1114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.13\. 创建表单组件：chapter-07/petstore/src/components/Form.vue
- en: '[PRE89]'
  id: totrans-1115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '***1* The header component shows a passed-in value of cartItemCount.**'
  id: totrans-1116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 头部组件显示传入的 cartItemCount 值。**'
- en: The script code for this component resembles that from [chapter 5](kindle_split_016.html#ch05).
    One difference is that now it accepts a prop called `cartItemCount`. In addition,
    we must define the `Header` component so it can be used in the template, as shown
    in this listing.
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件的脚本代码与[第5章](kindle_split_016.html#ch05)中的类似。一个不同之处在于现在它接受一个名为 `cartItemCount`
    的属性。此外，我们必须定义 `Header` 组件，以便它可以在模板中使用，如下所示。
- en: 'Listing 7.14\. Adding the script tag: chapter-07/petstore/src/components/Form.vue'
  id: totrans-1118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.14\. 添加脚本标签：chapter-07/petstore/src/components/Form.vue
- en: '[PRE90]'
  id: totrans-1119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '***1* Imports Header component**'
  id: totrans-1120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入 Header 组件**'
- en: '***2* Passes-in the prop cartItemCount**'
  id: totrans-1121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 传入 cartItemCount 属性**'
- en: Combine [listings 7.13](#ch07ex13) and [7.14](#ch07ex14) and you should be all
    set. In later chapters we’ll add more logic for inputs, but for now this will
    work.
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: 将[列表7.13](#ch07ex13)和[7.14](#ch07ex14)合并，你应该就绪了。在后面的章节中，我们将为输入添加更多逻辑，但到目前为止这已经足够了。
- en: 7.6.6\. Adding the Main component
  id: totrans-1123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.6.6\. 添加 Main 组件
- en: The `Main` component of the pet store application will display all our products.
    It’s where we’ll add products to our cart and see the star ratings. We’ve already
    written all the logic for this, so the only thing we really need to do is get
    it into one .vue file.
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: 宠物商店应用程序的`Main`组件将显示所有我们的产品。它是我们添加产品到购物车和查看星级评价的地方。我们已经为这部分写好了所有逻辑，所以我们真正需要做的只是将它放入一个.vue文件中。
- en: As with the `Form` component, we’ll add the `my-header` component to the top
    of the file and pass in the `cartItemCount` to it. Create a file called Main.vue
    in the src/components folder. Add the following code into it.
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Form`组件一样，我们将`my-header`组件添加到文件顶部，并将`cartItemCount`传递给它。在src/components文件夹中创建一个名为Main.vue的文件。将以下代码添加到其中。
- en: 'Listing 7.15\. Creating the main template: chapter-07/petstore/src/components/Main.vue'
  id: totrans-1126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.15\. 创建主模板：chapter-07/petstore/src/components/Main.vue
- en: '[PRE91]'
  id: totrans-1127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '***1* The my-header component is added to the code.**'
  id: totrans-1128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将my-header组件添加到代码中。**'
- en: 'After you add the template, we’ll need to add the Vue.js code. Add a new `MyHeader`
    import statement at the top of the file, as seen in [listing 7.16](#ch07ex16).
    You’ll also need to declare the component by referencing `components: { MyHeader
    }` after the data function.'
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: '在添加模板后，我们需要添加Vue.js代码。在文件顶部添加一个新的`MyHeader`导入语句，如[列表7.16](#ch07ex16)所示。您还需要在data函数之后通过引用`components:
    { MyHeader }`来声明组件。'
- en: Before we add the rest of the code, make sure to copy the image folder and the
    products.json files into the petstore/static folder. You can find these files
    and the code for [chapter 7](#ch07) at [https://github.com/ErikCH/VuejsInActionCode](https://github.com/ErikCH/VuejsInActionCode).
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们添加其余代码之前，请确保将图片文件夹和products.json文件复制到petstore/static文件夹中。您可以在[https://github.com/ErikCH/VuejsInActionCode](https://github.com/ErikCH/VuejsInActionCode)找到这些文件和第7章的代码。
- en: When using the CLI, we can store files in two places—either the assets folder
    or the static folder. Asset files are processed by Webpack’s url-loader and file-loader.
    The assets are inlined/copied/renamed during the build, so they’re essentially
    the same as the source code. Whenever you reference files in the assets folder,
    you do so by using relative paths. The ./assets/logo.png file could be the location
    of the logo in the assets folder.
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用CLI时，我们可以将文件存储在两个地方——要么是assets文件夹，要么是static文件夹。资产文件由Webpack的url-loader和file-loader处理。资产在构建过程中内联/复制/重命名，因此它们基本上与源代码相同。每次您在assets文件夹中引用文件时，您都应使用相对路径。./assets/logo.png文件可能是assets文件夹中logo的位置。
- en: Static files aren’t processed by Webpack at all; they’re directly copied to
    their final destination as is. When referencing these files, you must do so using
    absolute paths. Because we’re loading all our files using a products.json file,
    it’s easier to copy the files to a static folder and reference them from there.
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: 静态文件完全不经过Webpack处理；它们直接以原样复制到最终目的地。在引用这些文件时，您必须使用绝对路径。因为我们使用products.json文件加载所有文件，所以将文件复制到静态文件夹并从那里引用它们更容易。
- en: Go ahead and update the Main.vue file in the src/components folder. (Filters
    and methods are excluded in [listing 7.16](#ch07ex16).) Grab the Vue.js instance
    data, methods, filters, and lifecycle hooks from the pet store application and
    add it to the Main.vue file below the template.
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: 请继续更新src/components文件夹中的Main.vue文件。（在[列表7.16](#ch07ex16)中排除了过滤器和方法。）从宠物商店应用程序中获取Vue.js实例数据、方法和过滤器，并将它们添加到下面的Main.vue文件中的模板下方。
- en: 'Listing 7.16\. Creating the script for Main.vue: chapter-07/petstore/src/components/Main.vue'
  id: totrans-1134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.16\. 创建Main.vue的脚本：chapter-07/petstore/src/components/Main.vue
- en: '[PRE92]'
  id: totrans-1135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '***1* Imports MyHeader into project**'
  id: totrans-1136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将MyHeader导入到项目中**'
- en: '***2* JSON products file is located in the static folder with the absolute
    path.**'
  id: totrans-1137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* JSON产品文件位于静态文件夹中，使用绝对路径。**'
- en: After copying the file, delete the styles and logo.png `<img>` tag in the App.vue
    file. If you like, you can also delete the logo.png file in the assets folder.
    Make sure to restart the Vue-CLI server by running `npm run dev`, if you haven’t
    already. You should see the pet store application launch, where you can navigate
    to the checkout page by clicking the Checkout button ([figure 7.7](#ch07fig07)).
    If you receive any errors, double-check the console. For example, if you forgot
    to import the Axios library inside index.html as we did in [listing 7.9](#ch07ex09),
    you’ll get an error.
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: 在复制文件后，删除 App.vue 文件中的样式和 logo.png `<img>` 标签。如果您愿意，也可以删除 assets 文件夹中的 logo.png
    文件。确保通过运行 `npm run dev` 重新启动 Vue-CLI 服务器，如果您还没有这样做的话。您应该看到宠物商店应用程序启动，您可以通过点击 Checkout
    按钮导航到结账页面（[图 7.7](#ch07fig07)）。如果您收到任何错误，请检查控制台。例如，如果您忘记在 index.html 中导入 Axios
    库，就像我们在 [代码列表 7.9](#ch07ex09) 中做的那样，您将收到一个错误。
- en: Figure 7.7\. Pet store application opened with Vue-CLI.
  id: totrans-1139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.7\. 使用 Vue-CLI 打开的宠物商店应用程序。
- en: '![](07fig07_alt.jpg)'
  id: totrans-1140
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig07_alt.jpg)'
- en: 7.7\. Routing
  id: totrans-1141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.7\. 路由
- en: Now that we have our app using Vue-CLI, let’s take a deeper look at routing.
    Earlier in the chapter, we set up a couple of routes. In this section, we’ll add
    a couple more.
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们的应用已经使用了 Vue-CLI，让我们更深入地了解一下路由。在本章的早期部分，我们设置了一些路由。在本节中，我们将添加更多。
- en: In any single-page application such as Vue.js, routing helps with the navigation
    of the app. In the pet store, we have a Form route. When you load the application
    and go to /form, the route is loaded. Unlike traditional web apps, data doesn’t
    have to be sent from the server for the route to load. When the URL changes, the
    Vue router intercepts the request and displays the appropriate route. This is
    an important concept because it allows us to create all the routing on the client
    side instead of having to rely on the server.
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何单页应用程序，如 Vue.js 中，路由有助于应用程序的导航。在宠物商店中，我们有一个表单路由。当您加载应用程序并访问 /form 时，该路由将被加载。与传统
    Web 应用程序不同，数据不需要从服务器发送以加载路由。当 URL 发生变化时，Vue 路由拦截请求并显示相应的路由。这是一个重要的概念，因为它允许我们在客户端而不是服务器上创建所有路由。
- en: Inside this section, we’ll look at how to create child routes, use parameters
    to pass information between routes, and how to set up redirection and wildcards.
    We aren’t going to cover everything, so if you need more information, please check
    out the official Vue router documentation at [https://router.vuejs.org/en/](https://router.vuejs.org/en/).
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何创建子路由，使用参数在路由之间传递信息，以及如何设置重定向和通配符。我们不会涵盖所有内容，所以如果您需要更多信息，请查看官方 Vue
    路由文档：[https://router.vuejs.org/en/](https://router.vuejs.org/en/)。
- en: 7.7.1\. Adding a product route with parameters
  id: totrans-1145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.7.1\. 添加带参数的产品路由
- en: In our application, we have only two routes, Main and Form. Let’s add another
    route for our product. Let’s imagine we’ve been given a new requirement for our
    pet store app. We’ve been told to add a product description page This can be achieved
    with dynamic route matching, using route *parameters*. Parameters are dynamic
    values sent inside the URL. After we add the new product description route, you’ll
    look up a product page using the URL, as shown in [figure 7.8](#ch07fig08). Notice
    how the URL at the top is product/1001? This is the dynamic route.
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们只有两个路由，主路由和表单路由。让我们为我们的产品添加另一个路由。让我们假设我们为宠物商店应用程序收到了一个新的需求。我们被告知要添加一个产品描述页面。这可以通过使用动态路由匹配和路由
    *参数* 来实现。参数是发送在 URL 内部的动态值。在我们添加新的产品描述路由后，您将使用 URL 查找产品页面，如图 7.8 所示。注意顶部的 URL
    是 product/1001？这是一个动态路由。
- en: Figure 7.8\. Dynamic segment for product 1001.
  id: totrans-1147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.8\. 产品 1001 的动态段。
- en: '![](07fig08_alt.jpg)'
  id: totrans-1148
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig08_alt.jpg)'
- en: We designate dynamic routes with a colon (`:)`inside the router file. This tells
    Vue.js to match any route after /product to the Product component. In other words,
    both routes /product/1001 and /product/1002 would be handled by the Product component.
    The 1001 and 1002 will be passed into the component as a parameter with the name
    `id`.
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在路由文件中使用冒号（`:`）来指定动态路由。这告诉 Vue.js 将任何以 /product 开头的路由匹配到 Product 组件。换句话说，/product/1001
    和 /product/1002 这两个路由都会由 Product 组件处理。1001 和 1002 将作为名为 `id` 的参数传递给组件。
- en: Inside the pet store app, look for the src/router folder. The index.js file
    has our existing routes. Copy the snippet of code from the following listing and
    add it to the routes array in the src/router/index.js file. Make sure to import
    the Product component at the top. We’ll create that next.
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: 在宠物商店应用中，查找 src/router 文件夹。index.js 文件包含我们现有的路由。从以下列表中复制代码片段并将其添加到 src/router/index.js
    文件中的路由数组中。确保在顶部导入 Product 组件。我们将在下一步创建它。
- en: 'Listing 7.17\. Editing the router file: chapter-07/route-product.js'
  id: totrans-1151
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.17\. 编辑路由文件：chapter-07/route-product.js
- en: '[PRE93]'
  id: totrans-1152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '***1* Shows the dynamic route segment called id**'
  id: totrans-1153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 显示名为 id 的动态路由段**'
- en: We have a dynamic segment with a parameter named `id`. We set the name of the
    route to `Id` so we can easily look it up later using the router-link component.
    As mentioned, let’s create a Product component.
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个名为 `id` 的动态段。我们将路由名称设置为 `Id`，这样我们就可以使用 router-link 组件轻松地稍后查找它。如前所述，让我们创建一个
    Product 组件。
- en: Inside the Product component is a single product that we’ll retrieve from the
    route params. Our purpose is to display that product information inside the component.
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Product 组件内部，有一个我们将从路由参数中检索的单个产品。我们的目的是在组件内部显示该产品信息。
- en: Inside the product template, we’ll have access to the `$route.params.id`. This
    will display the `id` passed into the parameter. We’ll display the `id` at the
    top of the component to verify that it was passed in correctly.
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: 在产品模板内部，我们将能够访问 `$route.params.id`。这将显示传递到参数中的 `id`。我们将在组件顶部显示 `id` 以验证它是否正确传递。
- en: Copy the following code into a new file at src/components/Product.vue. This
    is the top of the file for the component.
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码复制到 src/components/Product.vue 的新文件中。这是组件的顶部。
- en: 'Listing 7.18\. Adding the product template: chapter-07/product-template.vue'
  id: totrans-1158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.18\. 添加产品模板：chapter-07/product-template.vue
- en: '[PRE94]'
  id: totrans-1159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '***1* The $route.params.id shows the passed-in id.**'
  id: totrans-1160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* $route.params.id 显示传递的 id。**'
- en: The template was straightforward but the bottom of the component, where the
    logic and script live, is a little more complex. To load the correct product for
    the template, we need to find the correct product using the `id` that was passed
    in.
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: 模板很简单，但组件的底部，即逻辑和脚本所在的位置，要复杂一些。为了加载模板的正确产品，我们需要使用传递的 `id` 找到正确的产品。
- en: Luckily, with simple JavaScript we can do exactly that. We’ll use the Axios
    library again to access the products.json flat file. This time we’ll use the JavaScript
    filter function to return only the products whose ID matches `this.$route.params.id`.
    The filter should return only one value because all the IDs are unique. If for
    any reason this doesn’t occur, double-check the products.json flat file and make
    sure each ID is unique.
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以用简单的 JavaScript 做到这一点。我们将再次使用 Axios 库来访问 products.json 平面文件。这次我们将使用
    JavaScript 过滤函数来返回 ID 与 `this.$route.params.id` 匹配的产品。过滤函数应该只返回一个值，因为所有 ID 都是唯一的。如果出于任何原因这没有发生，请检查
    products.json 平面文件，并确保每个 ID 都是唯一的。
- en: Last, we’ll need to add a fo`/`’ character in front of the `this.product.image`
    that’s returned from our flat file ([listing 7.19](#ch07ex19)). This needs to
    be done because we’re using dynamic route matching and relative paths to files
    can cause problems.
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要在从我们的平面文件返回的 `this.product.image` 前添加一个 fo`/`’ 字符（[列表 7.19](#ch07ex19)）。这是因为我们正在使用动态路由匹配和相对路径，而文件相对路径可能会引起问题。
- en: Copy the code in this listing and add it to the bottom of the src/components/Product.vue
    file. Make sure that the code from both [listings 7.18](#ch07ex18) and [7.19](#ch07ex19)
    are present in the file.
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: 将此列表中的代码复制并添加到 src/components/Product.vue 文件的底部。确保文件中包含来自 [列表 7.18](#ch07ex18)
    和 [7.19](#ch07ex19) 的代码。
- en: 'Listing 7.19\. Product script: chapter-07/product-script.js'
  id: totrans-1165
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.19\. 产品脚本：chapter-07/product-script.js
- en: '[PRE95]'
  id: totrans-1166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '***1* Imports Header component into file**'
  id: totrans-1167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将 Header 组件导入到文件中**'
- en: '***2* Retrieves the static file with the Axios library**'
  id: totrans-1168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用 Axios 库检索静态文件**'
- en: '***3* Filters the response data**'
  id: totrans-1169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 过滤响应数据**'
- en: '***4* Adds only data that matches the route params to this.product**'
  id: totrans-1170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 只将匹配路由参数的数据添加到 this.product**'
- en: '***5* Adds a ‘/’ to the front of product.image to help with the relative path**'
  id: totrans-1171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 在 product.image 前添加一个 ''/'' 以帮助处理相对路径**'
- en: With the product component in place, we can now save the file and open our web
    browser. We don’t have a way to access the route directly yet, but we can type
    the URL inside the browser at http://localhost:8080/product/1001\. This will display
    the first product.
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Product 组件就绪后，我们现在可以保存文件并打开我们的网络浏览器。我们目前还没有直接访问路由的方法，但我们可以将 URL 打入浏览器中的 http://localhost:8080/product/1001。这将显示第一个产品。
- en: '|  |'
  id: totrans-1173
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Troubleshooting
  id: totrans-1174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 故障排除
- en: If the route doesn’t load, open the console and look for any errors. Make sure
    you saved the data inside the router file; otherwise, the route won’t load. It’s
    also easy to forget to add the ‘`/`’ in front of `this.product.image`.
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果路由没有加载，请打开控制台并查找任何错误。确保你在路由文件中保存了数据；否则，路由将不会加载。也容易忘记在 `this.product.image`
    前面添加 `'`/`'。
- en: '|  |'
  id: totrans-1176
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 7.7.2\. Setting up a router-link with tags
  id: totrans-1177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.7.2\. 使用标签设置 router-link
- en: 'Routes can be useless unless we add links to them inside our app. Otherwise,
    our users would have to memorize each URL. With Vue router, we can make routing
    to a path easy. One of the easiest ways, which we saw earlier in the chapter,
    is using the `router-link` component. You can define the route you want to navigate
    to by using the `:to` property. This can be bound to a specific path or object
    that defines the name of the route to navigate to. For example, `<router-link
    :to="{ name: ''Id'' }">Product</router-link>` will route to the named route `Id`.
    In our app, it’s the Product component.'
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: '除非我们在应用内部为它们添加链接，否则路由可能毫无用处。否则，我们的用户必须记住每个 URL。使用 Vue router，我们可以使路径路由变得简单。我们之前在本章中看到的最简单的方法之一是使用
    `router-link` 组件。你可以通过使用 `:to` 属性来定义你想要导航到的路由。这可以绑定到一个特定的路径或对象，该对象定义了要导航到的路由名称。例如，`<router-link
    :to="{ name: ''Id'' }">Product</router-link>` 将导航到名为 `Id` 的路由。在我们的应用中，它是产品组件。'
- en: The `router-link` component has a few other tricks up its sleeve. This component
    has many additional props that add more functionality. In this section, we’ll
    focus on the `active-class` and `tag` props.
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: '`router-link` 组件还有一些其他的技巧。这个组件有许多额外的属性，增加了更多的功能。在本节中，我们将重点关注 `active-class`
    和 `tag` 属性。'
- en: Let’s imagine we’ve been given another requirement for our pet store app. We
    want the Checkout button to appear like it’s been clicked when the user navigates
    to the Form route. When the user leaves the route, the button must return to its
    normal state. We can do this by adding a class named `active` to the button when
    the route is activated and remove the class when the user is not on the route.
    We also need to add a way for the user to click the title of any product and have
    it route to the product description page.
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们为我们的宠物商店应用收到了另一个要求。我们希望当用户导航到表单路由时，结账按钮看起来像是被点击过的。当用户离开路由时，按钮必须恢复到正常状态。我们可以通过在路由激活时给按钮添加一个名为
    `active` 的类，并在用户不在路由上时移除该类来实现这一点。我们还需要为用户提供一种方式，点击任何产品的标题，使其导航到产品描述页面。
- en: When all is done, our app will appear like [figure 7.9](#ch07fig09) after the
    user clicks the Checkout button. Notice the button’s appearance when the user
    is on the checkout page.
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: 当一切完成时，用户点击结账按钮后，我们的应用将像 [图 7.9](#ch07fig09) 一样显示。注意当用户在结账页面上时按钮的外观。
- en: Figure 7.9\. Checkout button updated with new style.
  id: totrans-1182
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.9\. 更新了样式的结账按钮。
- en: '![](07fig09_alt.jpg)'
  id: totrans-1183
  prefs: []
  type: TYPE_IMG
  zh: '![07fig09_alt.jpg](07fig09_alt.jpg)'
- en: Let’s add the link to our new product page. Open the src/Main.vue file and look
    for the `h1` tag that displays `{{product.title}}.` Delete it and add a new `router-link`.
    Inside the `router-link,` add a `tag` prop. The `tag` prop is used to convert
    the `router-link` to the tag listed. In this case, the `router-link` will display
    as an `h1` tag in the browser.
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的新产品页面添加链接。打开 src/Main.vue 文件，并查找显示 `{{product.title}}` 的 `h1` 标签。删除它并添加一个新的
    `router-link`。在 `router-link` 中添加一个 `tag` 属性。`tag` 属性用于将 `router-link` 转换为列出的标签。在这种情况下，`router-link`
    将在浏览器中显示为 `h1` 标签。
- en: 'The `to` prop is used to denote the target route of the link. It has an optional
    descriptor object that we can pass to it. To send a `param`, use the `params:
    {id: product.id}` syntax. This tells Vue router to send the `product.id` as the
    `id` to the dynamic segment. For example, if the `product.id` was 1005, the route
    would be /product/1005.'
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: '`to` 属性用于表示链接的目标路由。它可以传递一个可选的描述符对象。要发送 `param`，使用 `params: {id: product.id}`
    语法。这告诉 Vue router 将 `product.id` 作为 `id` 发送到动态段。例如，如果 `product.id` 是 1005，则路由将是
    /product/1005。'
- en: Open the src/Main.vue file and update the component with the code in the following
    listing. Notice how the `:to` has two different props, `name` and `params`. You
    can separate each prop with a comma.
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 src/Main.vue 文件，并使用以下列表中的代码更新组件。注意 `:to` 有两个不同的属性，`name` 和 `params`。你可以用逗号分隔每个属性。
- en: 'Listing 7.20\. Updating router-link in main: chapter-07/route-link-example.html'
  id: totrans-1187
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.20\. 在 main 中更新 router-link：chapter-07/route-link-example.html
- en: '[PRE96]'
  id: totrans-1188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '***1* Starts router-link**'
  id: totrans-1189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 开始 router-link**'
- en: '***2* Converts router- link to show up as an h1 tag**'
  id: totrans-1190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将 router-link 转换为显示为 h1 标签**'
- en: '***3* The target of the route is Id and the params is passed.**'
  id: totrans-1191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 路由的目标是 Id，参数被传递。**'
- en: '***4* This will be the clickable text.**'
  id: totrans-1192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 这将是可点击的文本。**'
- en: Save and open the browser after running the command, `npm run dev`. You can
    now click the title of any product to navigate to the Product component. The `id`
    param will be sent to the Product route and used to display the product.
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: 运行命令 `npm run dev` 后保存并打开浏览器。现在你可以点击任何产品的标题来导航到产品组件。`id` 参数将被发送到产品路由并用于显示产品。
- en: '|  |'
  id: totrans-1194
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Query parameters**'
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: '**查询参数**'
- en: 'Query parameters are another way we can send information between routes. Parameters
    are appended to the end of the URL. Instead of using a dynamic route segment,
    we could send the product ID using a query parameter. To add a query parameter
    with Vue router, all you need to do is add a query prop to the descriptor object
    like this:'
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: 查询参数是我们可以在路由之间发送信息的另一种方式。参数附加到 URL 的末尾。我们不必使用动态路由段，可以使用查询参数发送产品 ID。要在 Vue 路由中添加查询参数，你只需要像这样向描述符对象添加一个查询属性：
- en: '[PRE97]'
  id: totrans-1197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Multiple query parameters can be added, but each one must be separated by a
    comma; for example, `{Id: ''123'', info: ''erik''}`. This will show up in the
    URL as `?id=123&info=erik`. You can access queries inside the template with `$route.query.info`.
    If you want more information on query parameters, check out the official documentation
    at [https://router.vuejs.org/en/api/router-link](https://router.vuejs.org/en/api/router-link).'
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: '可以添加多个查询参数，但每个参数都必须用逗号分隔；例如，`{Id: ''123'', info: ''erik''}`。这将在 URL 中显示为 `?id=123&info=erik`。你可以在模板中使用
    `$route.query.info` 访问查询。如果你想了解更多关于查询参数的信息，请查看官方文档[https://router.vuejs.org/en/api/router-link](https://router.vuejs.org/en/api/router-link)。'
- en: '|  |'
  id: totrans-1199
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 7.7.3\. Setting up a router-link with style
  id: totrans-1200
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.7.3\. 设置具有样式的 router-link
- en: One of our requirements is to find a way to activate the Checkout button after
    the user navigates to the `Form` route. The `active-class` prop makes this easy.
    When the route is active, the `router-link` will automatically add whatever value
    we assign to `active-class` to the tag. Because we’re using Bootstrap, the class
    name `active` will make the button look like it’s been activated.
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的一个要求是在用户导航到 `Form` 路由后激活结账按钮。`active-class` 属性使得这变得简单。当路由处于活动状态时，`router-link`
    将自动将我们分配给 `active-class` 的任何值添加到标签上。因为我们使用 Bootstrap，类名 `active` 将使按钮看起来已经激活。
- en: Open the src/components/Header.vue file and update the button element for `{{cartItemCount}}`.
    Delete the existing button and add the `router-link` instead, as in this listing.
    You can also delete the `showCheckout` method because it will no longer be needed.
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `src/components/Header.vue` 文件，并更新 `{{cartItemCount}}` 的按钮元素。删除现有的按钮，并添加
    `router-link`，如下所示。你也可以删除 `showCheckout` 方法，因为它将不再需要。
- en: 'Listing 7.21\. Updating header links when route is active: chapter-07/header-link.html'
  id: totrans-1203
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.21\. 当路由处于活动状态时更新头部链接：chapter-07/header-link.html
- en: '[PRE98]'
  id: totrans-1204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '***1* Notes the router-link element that will navigate to the checkout page**'
  id: totrans-1205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 记录将导航到结账页面的 router-link 元素**'
- en: '***2* The active-class prop will add the active class.**'
  id: totrans-1206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* active-class 属性将添加活动类。**'
- en: '***3* Converts route-link to h1 tag**'
  id: totrans-1207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将 route-link 转换为 h1 标签**'
- en: '***4* Bootstraps classes for button**'
  id: totrans-1208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 按钮的 Bootstrap 类**'
- en: '***5* Navigates to the Form route**'
  id: totrans-1209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 导航到 Form 路由**'
- en: Save the changes to the header component and navigate the app. If you open the
    browser console, you’ll see how the active class is added to the checkout button
    inside the header after each time it’s clicked. When you navigate to the `Main`
    route again, the active class is removed. The active class is added to the button
    only if the route is active. When the user navigates away from the `Form` route,
    the active class is removed.
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: 保存头部组件的更改并导航应用程序。如果你打开浏览器控制台，你将看到每次点击后，活动类都会添加到头部中的结账按钮。当你再次导航到 `Main` 路由时，活动类会被移除。只有当路由处于活动状态时，活动类才会添加到按钮上。当用户从
    `Form` 路由导航离开时，活动类会被移除。
- en: As of Vue 2.5.0+, a new CSS class was added whenever the user changes route.
    This is called the `router-link-exact-active` class. We can use this class out
    of the box and define functionality. Let’s say we wanted to change the link to
    the color blue whenever the class was active.
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Vue 2.5.0+ 开始，每当用户更改路由时，都会添加一个新的 CSS 类。这个类叫做 `router-link-exact-active`。我们可以直接使用这个类并定义功能。假设我们想要在类激活时将链接颜色改为蓝色。
- en: 'Inside the src/components/Header.vue, add a new CSS selector at the bottom:
    copy the snippet from this listing. This class will be added to only the `router-link`
    element when the route is active.'
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/components/Header.vue`内部，在底部添加一个新的CSS选择器：复制此列表中的代码片段。此类将仅在路由激活时添加到`router-link`元素。
- en: 'Listing 7.22\. Router-link-exact-active: chapter-07/route-link.css'
  id: totrans-1213
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 7.22\. Router-link-exact-active: chapter-07/route-link.css'
- en: '[PRE99]'
  id: totrans-1214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '***1* Sets element to blue when route is active**'
  id: totrans-1215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 当路由激活时将元素设置为蓝色**'
- en: Save the file and try navigating around in the browser. You’ll notice that the
    Checkout button text in the header changes to blue when the route is active. For
    the rest of this book, we’ll change this CSS selector to black, because blue doesn’t
    look as nice as black. It’s nice knowing it’s there if we need it.
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件，并在浏览器中尝试导航。您会注意到，当路由激活时，页眉中的“结账”按钮文本变为蓝色。在这本书的其余部分，我们将更改此CSS选择器为黑色，因为蓝色不如黑色看起来那么好。如果需要，知道它在那里是件好事。
- en: 7.7.4\. Adding a child edit route
  id: totrans-1217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.7.4\. 添加子编辑路由
- en: The new `Id` route displays each individual product, but let’s suppose we need
    to add a way to edit each product. Let’s add another route that will display inside
    the `Product` route that’s triggered whenever the user clicks the Edit Product
    button.
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`Id`路由显示每个单独的产品，但假设我们需要添加一种编辑每个产品的方法。让我们添加另一个路由，该路由将在用户点击“编辑产品”按钮时在`Product`路由内部显示。
- en: '|  |'
  id: totrans-1219
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-1220
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: For the sake of simplicity, we won’t implement the edit functionality. With
    our current implementation, there’s no way we can save changes to our static file.
    Rather, we’ll focus on how to add a child route and save the implementation of
    changing the product for the future.
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，我们不会实现编辑功能。根据我们当前的实现，我们无法保存对静态文件的更改。相反，我们将专注于如何添加子路由，并为将来更改产品保存实现。
- en: '|  |'
  id: totrans-1222
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Child routes are nested routes. They’re perfect for situations where you need
    to edit or delete information within a current route. You can access these routes
    by adding a router-view component within the parent route, as we’ll see.
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: 子路由是嵌套路由。它们非常适合需要编辑或删除当前路由内信息的情况。您可以通过在父路由内添加`router-view`组件来访问这些路由，正如我们将看到的。
- en: When we have everything wired together, the new Edit route should look like
    [figure 7.10](#ch07fig10). Take notice of the URL, product/1001/Edit.
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将所有东西连接在一起时，新的编辑路由应该看起来像[图 7.10](#ch07fig10)。注意URL，product/1001/Edit。
- en: Figure 7.10\. The child Edit route of a product.
  id: totrans-1225
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.10\. 产品的一个子编辑路由。
- en: '![](07fig10_alt.jpg)'
  id: totrans-1226
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig10_alt.jpg)'
- en: Let’s begin by adding a new component. Inside the src/components folder, add
    a new file and call it EditProduct.vue. Copy this listing and add it to the src/components/EditProduct.vue
    file.
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从添加一个新组件开始。在`src/components`文件夹内，添加一个新文件，并将其命名为`EditProduct.vue`。复制此列表并将其添加到`src/components/EditProduct.vue`文件中。
- en: 'Listing 7.23\. Adding the `EditProduct` component: chapter-07/edit-comp.vue'
  id: totrans-1228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 7.23\. 添加 `EditProduct` 组件: chapter-07/edit-comp.vue'
- en: '[PRE100]'
  id: totrans-1229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '***1* Gives a future implementation for editing the product**'
  id: totrans-1230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 给出了编辑产品的未来实现**'
- en: Inside the `Product` component, add a `router-view` component. This component
    is internal to Vue router and is used for the endpoint for new routes. When this
    route is activated, the `EditProduct` component will display inside where the
    `router-view` component is located.
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Product`组件中添加一个`router-view`组件。该组件是Vue路由的内部组件，用于新路由的端点。当此路由激活时，`EditProduct`组件将显示在`router-view`组件所在的位置。
- en: Copy the code snippet in the following listing and edit the src/components/Product.vue
    file to add a new button at the bottom and the router-view component. The button
    will trigger the new edit method. This pushes the `Edit` route and activates it.
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: 复制以下列表中的代码片段，并编辑`src/components/Product.vue`文件，以在底部添加一个新按钮和`router-view`组件。该按钮将触发新编辑方法。这将推送`Edit`路由并激活它。
- en: 'Listing 7.24\. Adding the `Edit Product` button: chapter-07/edit-button.vue'
  id: totrans-1233
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 7.24\. 添加 `Edit Product` 按钮: chapter-07/edit-button.vue'
- en: '[PRE101]'
  id: totrans-1234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '***1* Shows the button that triggers the edit method**'
  id: totrans-1235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 显示触发编辑方法的按钮**'
- en: '***2* The router-view component is the entry point for the route.**'
  id: totrans-1236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* The router-view component is the entry point for the route.**'
- en: '***3* The $router.push activates the Edit route.**'
  id: totrans-1237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* The $router.push activates the Edit route.**'
- en: Now we have everything in place to update the router file. Add a new array called
    `children` inside the `Id` route. Inside the children array, we’ll add the `Edit`
    route and the component `EditProduct`.
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好更新路由文件了。在`Id`路由内部添加一个新的数组，名为`children`。在`children`数组中，我们将添加`Edit`路由和`EditProduct`组件。
- en: Take the code from the next listing and update the src/router/index.js file.
    Update the `Id` route and add the new `children` array. Make sure to also import
    the `EditProduct` component at the top.
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: 从下一个列表中获取代码并更新`src/router/index.js`文件。更新`Id`路由并添加新的`children`数组。确保在顶部也导入`EditProduct`组件。
- en: 'Listing 7.25\. Updating the router with the new child route: chapter-07/child-route.js'
  id: totrans-1240
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.25\. 使用新子路由更新路由：chapter-07/child-route.js
- en: '[PRE102]'
  id: totrans-1241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '***1* Defines a new child route that will only appear inside the Id route.**'
  id: totrans-1242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 定义一个新子路由，该路由仅在Id路由内显示。**'
- en: Save the index.js file and check out the new route in your browser. Click the
    Edit Product button and you should see the Edit Product Info message. If the route
    isn’t loading, double-check for errors in the console and verify the index.js
    file again.
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: 保存`index.js`文件并在浏览器中查看新路由。点击编辑产品按钮，你应该会看到编辑产品信息消息。如果路由没有加载，请双检查控制台中的错误并再次验证`index.js`文件。
- en: 7.7.5\. Using redirection and wildcards
  id: totrans-1244
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.7.5\. 使用重定向和通配符
- en: The last features of Vue router I want to cover are *redirection* and *wildcard
    routes*. Let’s imagine we’re given one final requirement for our pet store app.
    We need to make sure that if anyone accidentally enters the wrong URL, it routes
    them back to the main page. This is done with wildcard routes and redirection.
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: 我想要介绍的Vue路由的最后一个特性是*重定向*和*通配符路由*。让我们想象一下，我们为我们的宠物商店应用得到了一个最终的要求。我们需要确保如果有人不小心输入了错误的URL，它将他们重定向回主页。这是通过通配符路由和重定向实现的。
- en: When creating a route, we can use a wildcard, also known as the * symbol, to
    catch any routes that aren’t already covered by the other routes. This route must
    be added at the bottom of all the other routes.
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建路由时，我们可以使用通配符，也称为*符号，来捕获其他路由尚未覆盖的所有路由。此路由必须添加到所有其他路由的底部。
- en: The `redirect` option redirects the browser to another route. Go ahead and edit
    the src/routes/index.js file. At the bottom of the route, add this snippet of
    code.
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: '`redirect`选项会将浏览器重定向到另一个路由。请继续编辑`src/routes/index.js`文件。在路由底部添加以下代码片段。'
- en: 'Listing 7.26\. Adding wildcard for route: chapter-07/wildcard-route.js'
  id: totrans-1248
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.26\. 为路由添加通配符：chapter-07/wildcard-route.js
- en: '[PRE103]'
  id: totrans-1249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '***1* Catches all**'
  id: totrans-1250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 捕获所有**'
- en: '***2* Redirects to “/”**'
  id: totrans-1251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 重定向到“/”**'
- en: Save the file and try to browse to /anything or /testthis. Both URLs will route
    you back to the main “/” route.
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件并尝试浏览到/anything或/testthis。这两个URL都会将您重定向回主“/”路由。
- en: '|  |'
  id: totrans-1253
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Navigation guards**'
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: '**导航守卫**'
- en: '*Navigation guards*, as the name suggests, guard navigation by redirecting
    or canceling routes. This might be particularly helpful if you’re trying to validate
    a user before letting them enter a route. One way to use navigation guards is
    to add a `beforeEnter` guard directly in the route configuration object. It might
    look like this:'
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
  zh: '*导航守卫*，正如其名所示，通过重定向或取消路由来保护导航。如果您在允许用户进入路由之前需要验证用户，这可能特别有用。使用导航守卫的一种方法是在路由配置对象中直接添加`beforeEnter`守卫。它可能看起来像这样：'
- en: '[PRE104]'
  id: totrans-1256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: You can also add a `beforeEnter(to, from, next)` hook inside any component.
    This is loaded before the route loads. The `next()` tells the route to continue.
    A `next(false)` will stop the route from loading. If you’d like more information,
    see the official documentation at [https://router.vuejs.org/guide/advanced/navigation-guards.html](https://router.vuejs.org/guide/advanced/navigation-guards.html).
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在任何组件内部添加`beforeEnter(to, from, next)`钩子。这将在路由加载之前加载。`next()`告诉路由继续。`next(false)`将停止路由加载。如果您需要更多信息，请参阅官方文档[https://router.vuejs.org/guide/advanced/navigation-guards.html](https://router.vuejs.org/guide/advanced/navigation-guards.html)。
- en: '|  |'
  id: totrans-1258
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: For reference, this listing shows the full src/routes/index.js file.
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: 为了参考，此列表显示了完整的`src/routes/index.js`文件。
- en: 'Listing 7.27\. Full router file: chapter-07/petstore/src/router/index.js'
  id: totrans-1260
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.27\. 完整路由文件：chapter-07/petstore/src/router/index.js
- en: '[PRE105]'
  id: totrans-1261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '***1* Notes the dynamic route segment for id**'
  id: totrans-1262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 记录id的动态路由段**'
- en: '***2* Shows the child route inside Id route**'
  id: totrans-1263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在Id路由内显示子路由**'
- en: '***3* Catches all at the bottom of routes that redirect to “/”**'
  id: totrans-1264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在重定向到“/”的路由底部捕获所有**'
- en: '|  |'
  id: totrans-1265
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Lazy loading**'
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: '**懒加载**'
- en: The Vue-CLI uses Webpack to bundle the JavaScript code. This bundle can become
    quite big. This could affect load times in larger applications or for users with
    slow internet connections. We can use vue.js async component features and code
    splitting with lazy loading to help decrease the size of our bundles. This concept
    is beyond this book, but I strongly suggest you look up the official documentation
    for more information on it. You can find it at [https://router.vuejs.org/guide/advanced/lazy-loading.html](https://router.vuejs.org/guide/advanced/lazy-loading.html).
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: Vue-CLI 使用 Webpack 打包 JavaScript 代码。这个包可能相当大。这可能会影响大型应用程序或网络连接较慢的用户加载时间。我们可以使用
    vue.js 异步组件功能和代码拆分与懒加载来帮助我们减小包的大小。这个概念超出了本书的范围，但我强烈建议您查找有关此信息的官方文档。您可以在[https://router.vuejs.org/guide/advanced/lazy-loading.html](https://router.vuejs.org/guide/advanced/lazy-loading.html)找到它。
- en: '|  |'
  id: totrans-1268
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Routes are fundamental to most Vue applications. Anything beyond a simple “Hello
    World” app will need them. Make sure to take time and map out your routes accordingly
    so they make logical sense. Use child routes to specify things such as adding
    or editing. When passing information between routes, don’t be afraid to use parameters.
    If you’re stuck on a routing issue, don’t forget to check out the official documentation
    at [http://router.vuejs.org/en](http://router.vuejs.org/en).
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: 路由对于大多数 Vue 应用程序都是基本的。任何超出简单“Hello World”应用程序的内容都需要它们。请确保花时间并相应地规划您的路由，以便它们具有逻辑性。使用子路由来指定添加或编辑等事项。在路由之间传递信息时，不要害怕使用参数。如果您在路由问题上遇到困难，不要忘记查看官方文档[http://router.vuejs.org/en](http://router.vuejs.org/en)。
- en: Exercise
  id: totrans-1270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: 'Use your knowledge of this chapter to answer the following question:'
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本章的知识来回答以下问题：
- en: Name two ways you can navigate between different routes.
  id: totrans-1272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出两种在不同路由之间导航的方法。
- en: '*See the solution in [appendix B](kindle_split_026.html#app02).*'
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: '*请参阅附录 B 中的解决方案[appendix B](kindle_split_026.html#app02)。*'
- en: Summary
  id: totrans-1274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: Using slots makes an application more dynamic when passing information into
    components.
  id: totrans-1275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用插槽在将信息传递到组件时使应用程序更加动态。
- en: You can use a dynamic component to switch between components within an application.
  id: totrans-1276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用动态组件在应用程序内部切换组件。
- en: Adding asynchronous component to an application improves speed.
  id: totrans-1277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向应用程序添加异步组件可以提高速度。
- en: You can use Vue-CLI to convert an application.
  id: totrans-1278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 Vue-CLI 转换应用程序。
- en: You can pass values using props between components.
  id: totrans-1279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 props 在组件之间传递值。
- en: Child routes can be used to edit information inside parent routes.
  id: totrans-1280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子路由可以用来编辑父路由内的信息。
- en: Chapter 8\. Transitions and animations
  id: totrans-1281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 8 章\. 过渡和动画
- en: '*This chapter covers*'
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Understanding transition classes
  id: totrans-1283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解过渡类
- en: Using animations
  id: totrans-1284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用动画
- en: Adding JavaScript hooks
  id: totrans-1285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加 JavaScript 钩子
- en: Updating the pet store application
  id: totrans-1286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新宠物商店应用程序
- en: In [chapter 7](kindle_split_018.html#ch07) we looked at advanced components
    and discussed how we could use single-file components to break our application
    into smaller parts. In this chapter we’ll look at transitions and animations using
    Vue.js. We’ll create simple transitions and animations using these built-in animation/transition
    classes. After this, we’ll use JavaScript hooks to create animations. We’ll then
    look at transitions between components. At the end of the chapter we’ll update
    our pet store application and add transitions and animations to it.
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 7 章](kindle_split_018.html#ch07)中，我们探讨了高级组件，并讨论了如何使用单文件组件将应用程序分解成更小的部分。在本章中，我们将使用
    Vue.js 来查看过渡和动画。我们将使用这些内置的动画/过渡类创建简单的过渡和动画。之后，我们将使用 JavaScript 钩子来创建动画。然后，我们将查看组件之间的过渡。在本章结束时，我们将更新我们的宠物商店应用程序并添加过渡和动画。
- en: 8.1\. Transitions basics
  id: totrans-1288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1\. 过渡基础
- en: To create a transition in Vue.js, you must first understand the `<transition>`
    component element. This is a special element that signifies to Vue.js that you
    want to transition or animate one or more elements. The `<transition>` element
    wraps a conditional, a dynamic component, or a component root node.
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vue.js 中创建过渡之前，您必须首先了解 `<transition>` 组件元素。这是一个特殊元素，表示您希望 Vue.js 过渡或动画一个或多个元素。`<transition>`
    元素包裹了一个条件、一个动态组件或组件根节点。
- en: The transition component is either inserted or removed from the DOM, depending
    on certain conditions. For example, a `v-if` directive may add or remove an element
    that it surrounds. The transition component can recognize if there are any CSS
    transitions or animations when this action occurs. It will then either remove
    or add the CSS classes at the appropriate time to create the transition or animation.
    You can also add special JavaScript hooks to the component to create more complex
    scenarios. If no CSS transitions or animations are found, the DOM operations for
    insertion and removal will happen immediately; otherwise, the transition or animation
    occurs. Let’s look at an example.
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: 过渡组件根据某些条件从 DOM 中插入或删除。例如，一个 `v-if` 指令可能会添加或删除它所包围的元素。当这个动作发生时，过渡组件可以识别是否存在
    CSS 过渡或动画。然后，它将在适当的时间添加或删除 CSS 类来创建过渡或动画。你还可以向组件添加特殊的 JavaScript 钩子来创建更复杂的情况。如果没有找到
    CSS 过渡或动画，插入和删除 DOM 的操作将立即发生；否则，过渡或动画将发生。让我们看看一个例子。
- en: Imagine you’re creating a website with a list of book titles. You want the user
    to toggle the description on or off by clicking the title. As we’ve learned in
    previous chapters, we can use a `v-if` directive to do this.
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你正在创建一个包含书籍标题列表的网站。你希望用户通过点击标题来切换描述的开启或关闭。正如我们在前面的章节中学到的，我们可以使用 `v-if` 指令来做这件事。
- en: But you want the description to slowly fade in after clicking the title. You
    then need it to fade out after clicking the title again. You can do this in Vue.js
    using CSS transitions and the `<transition>` element.
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: 但你希望点击标题后描述缓慢淡入。然后你需要它在再次点击标题后淡出。你可以在 Vue.js 中使用 CSS 过渡和 `<transition>` 元素来实现这一点。
- en: Open your editor and create an application, as you see in [listing 8.1](#ch08ex01).
    To begin, create a simple application that shows a fictitious title of an imaginary
    book as an <`h2>` tag at the top of the page. We’ll surround this element by a
    <`div>` tag and attach a click event to it using `@click`. The purpose of this
    click event is to toggle a variable named `show`. If `show` is `true`, and the
    user clicks the button, it toggles it to `false`. If it’s `false`, it will toggle
    to `true`.
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的编辑器并创建一个应用程序，就像你在[列表 8.1](#ch08ex01)中看到的那样。首先，创建一个简单的应用程序，在页面顶部显示一个虚构的书籍标题作为
    `<h2>` 标签。我们将用 `<div>` 标签包围这个元素，并使用 `@click` 附加一个点击事件。这个点击事件的目的就是切换一个名为 `show`
    的变量。如果 `show` 是 `true`，并且用户点击按钮，它将切换为 `false`。如果它是 `false`，它将切换为 `true`。
- en: Inside the body tag you’ll need to add your new transition element. Transition
    elements can also have a `name` attribute. Set the name to `fade`. Wrapped inside
    the transition element is the `v-if` directive. This directive will toggle the
    description. At the bottom of our application, add the Vue constructor with the
    data function. This will hold all the variables for our application.
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: 在 body 标签内部，你需要添加你的新过渡元素。过渡元素也可以有一个 `name` 属性。将名称设置为 `fade`。包裹在过渡元素内部的是 `v-if`
    指令。这个指令将切换描述。在应用程序底部，添加带有数据函数的 Vue 构造函数。这将保存我们应用程序的所有变量。
- en: 'Listing 8.1\. Creating a description transition: chapter-08/transition-book-1.html'
  id: totrans-1295
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.1\. 创建描述过渡：chapter-08/transition-book-1.html
- en: '[PRE106]'
  id: totrans-1296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '***1* Denotes the div tag that toggles variable show to be true or false**'
  id: totrans-1297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 表示切换变量 show 为真或假的 div 标签**'
- en: '***2* Shows the new transition element that’s named fade**'
  id: totrans-1298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 显示了名为 fade 的新过渡元素**'
- en: '***3* Shows the v-if directive that toggles showing the description or not**'
  id: totrans-1299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 显示了切换显示描述与否的 v-if 指令**'
- en: '***4* Notes the Vue.js constructor**'
  id: totrans-1300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 记录了 Vue.js 构造函数**'
- en: '***5* Shows the data function with variables**'
  id: totrans-1301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 显示了带有变量的数据函数**'
- en: Load the application in a browser and open it. You should see a page that looks
    like [figure 8.1](#ch08fig01). If you click the title, the description will pop
    up below it. This example has no transition at all. Clicking the title toggles
    the description either off or on. To add the transition, we must add the transition
    classes.
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中加载应用程序并打开它。你应该看到一个看起来像[图 8.1](#ch08fig01)的页面。如果你点击标题，描述将弹出在下面。这个例子完全没有过渡。点击标题会切换描述的开启或关闭。要添加过渡，我们必须添加过渡类。
- en: Figure 8.1\. Toggle without any transition
  id: totrans-1303
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.1\. 无过渡的切换
- en: '![](08fig01_alt.jpg)'
  id: totrans-1304
  prefs: []
  type: TYPE_IMG
  zh: '![08fig01_alt.jpg](08fig01_alt.jpg)'
- en: Using [listing 8.1](#ch08ex01), add a style tag inside the `head` element. For
    the purposes of simplicity, we’ll inline the CSS inside the style tags in our
    example. That way, we don’t have to worry about adding a separate CSS file.
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [列表 8.1](#ch08ex01)，在 `head` 元素内添加一个样式标签。为了简化，我们将在示例中将 CSS 内联在样式标签中。这样，我们就不必担心添加单独的
    CSS 文件。
- en: 'There are six Vue.js CSS classes that can be applied to the enter and leave
    transitions. In this example we’ll use four: `v-enter-active`, `v-leave-active`,
    `v-enter`, and `v-leave-to`. The other two we’ll use later are `v-enter-to` and
    `v-leave`.'
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: 有六个 Vue.js CSS 类可以应用于进入和离开过渡。在这个例子中，我们将使用四个：`v-enter-active`、`v-leave-active`、`v-enter`
    和 `v-leave-to`。我们稍后会使用的另外两个是 `v-enter-to` 和 `v-leave`。
- en: In [listing 8.1](#ch08ex01), we didn’t add any animation classes. As I mentioned
    earlier, if no CSS classes are present, the `v-if` directive conditional fires
    immediately and there are no CSS transitions. We’ll need to add CSS transition
    classes to make the fade effect work. First, let’s look at what each of these
    classes does and when they’re added or deleted from the DOM. Be aware that a frame
    is an array-like property that represents all elements in the current window.
    [Table 8.1](#ch08table01) shows all the CSS transition classes that you should
    be aware of.
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 8.1](#ch08ex01) 中，我们没有添加任何动画类。如我之前提到的，如果没有 CSS 类存在，`v-if` 指令的条件会立即触发，并且没有
    CSS 过渡。我们需要添加 CSS 过渡类来使淡入效果生效。首先，让我们看看这些类各自的作用以及它们何时被添加或从 DOM 中删除。请注意，帧是一个类似数组的属性，代表当前窗口中的所有元素。[表
    8.1](#ch08table01) 显示了你应该注意的所有 CSS 过渡类。
- en: Table 8.1\. CSS transition classes
  id: totrans-1308
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 8.1\. CSS 过渡类
- en: '| Transition class | Description |'
  id: totrans-1309
  prefs: []
  type: TYPE_TB
  zh: '| 过渡类 | 描述 |'
- en: '| --- | --- |'
  id: totrans-1310
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| v-enter | This is the first state. It is added before the element is inserted
    and removed one frame after the element is inserted. |'
  id: totrans-1311
  prefs: []
  type: TYPE_TB
  zh: '| v-enter | 这是第一个状态。它在元素插入之前被添加，并在元素插入后的一帧被移除。|'
- en: '| v-enter-active | This class is added to the element as long as the element
    is entering the DOM. It’s inserted before the element is inserted and removed
    when the transition/animation is finished. This is where you enter in the duration,
    delay, and easing curve for the entire transition. |'
  id: totrans-1312
  prefs: []
  type: TYPE_TB
  zh: '| v-enter-active | 当元素进入 DOM 时，此类会被添加到元素上。它在元素插入之前被插入，并在过渡/动画完成后被移除。这是你设置整个过渡的持续时间、延迟和缓动曲线的地方。|'
- en: '| v-enter-to | This class was introduced in Vue.js 2.1.8+. This is added one
    frame after the element is inserted and removed when the transition/animation
    is finished. |'
  id: totrans-1313
  prefs: []
  type: TYPE_TB
  zh: '| v-enter-to | 这个类是在 Vue.js 2.1.8+ 中引入的。它在元素插入后的一帧被添加，并在过渡/动画完成后被移除。|'
- en: '| v-leave | This class is added as soon as the element is leaving, or being
    removed, from the DOM. It’s removed after one frame. |'
  id: totrans-1314
  prefs: []
  type: TYPE_TB
  zh: '| v-leave | 当元素从 DOM 中离开或被移除时，此类会被添加。它在下一帧后被移除。|'
- en: '| v-leave-active | This is the active state for the leave animation/transition.
    This is similar to the v-enter-active. You can use it to set the duration, delay,
    and easing curve of the leaving transition/animation. It’s added immediately when
    the leave transition is triggered and removed when the transition/animation finishes.
    |'
  id: totrans-1315
  prefs: []
  type: TYPE_TB
  zh: '| v-leave-active | 这是离开动画/过渡的激活状态。它与 v-enter-active 类似。你可以用它来设置离开过渡/动画的持续时间、延迟和缓动曲线。它在离开过渡被触发时立即添加，并在过渡/动画完成后被移除。|'
- en: '| v-leave-to | This is similar to the v-enter-to and was added after Vue.js
    2.1.8+. This is the ending state for the leave. It’s added one frame after a leaving
    transition is triggered and removed when the animation/transition is finished.
    |'
  id: totrans-1316
  prefs: []
  type: TYPE_TB
  zh: '| v-leave-to | 这与 v-enter-to 类似，是在 Vue.js 2.1.8+ 后添加的。这是离开的结束状态。它在触发离开过渡后的一帧被添加，并在动画/过渡完成后被移除。|'
- en: Each of these classes is added and removed at different times when elements
    in the DOM are added or removed. We can use these elements to construct transitions
    and animations. For more information on the transition classes, check out the
    official documentation at [http://mng.bz/5mb2](http://mng.bz/5mb2).
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: 当 DOM 中的元素被添加或移除时，这些类会在不同时间被添加和移除。我们可以使用这些类来构建过渡和动画。有关过渡类的更多信息，请查看官方文档 [http://mng.bz/5mb2](http://mng.bz/5mb2)。
- en: 'Let’s add the transitions in the style element inside the `head`. Before we
    add these classes, you may have noticed in [listing 8.1](#ch08ex01) that we added
    a name attribute to the transition element. Because we added a name attribute,
    the CSS class names will begin with the name we added, `fade`, instead of `v-`.
    If we chose not to add the name attribute to the transition element, the names
    of the classes would have remained: `v-enter-active`, `v-leave-active`, and so
    on. Instead, the class names will start with `fade`, `fade-enter-active`, and
    `fade-leave-active`, for example.'
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`head`内部的样式元素中添加过渡。在我们添加这些类之前，你可能已经注意到在[列表8.1](#ch08ex01)中，我们给过渡元素添加了一个名称属性。因为我们添加了名称属性，所以CSS类名将以我们添加的名称`fade`开头，而不是`v-`。如果我们没有给过渡元素添加名称属性，类名将保持不变：`v-enter-active`、`v-leave-active`等。相反，类名将以`fade`、`fade-enter-active`和`fade-leave-active`等开头，例如。
- en: Add the `fade-enter-active` and `fade-leave-active` CSS transition classes inside
    the style tag in the application code from the previous listing. As mentioned,
    active classes are where we put the CSS transitions with the delay. In this example
    we’ll set opacity, 2.5 seconds, and `ease-out`. This will create a nice fade effect
    that will take 2.5 seconds to complete.
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个列表中的应用代码中的样式标签内添加`fade-enter-active`和`fade-leave-active` CSS过渡类。如前所述，活跃类是我们放置带有延迟的CSS过渡的地方。在这个例子中，我们将设置不透明度、2.5秒和`ease-out`。这将创建一个2.5秒完成的淡入淡出效果。
- en: Next, we’ll add a `fade-enter` and `fade-leave-to`. This will set our initial
    opacity to 0\. This will make sure that the fade occurs correctly with the opacity
    at 0\. Update the previous example with the new style and see how it works. For
    the sake of simplicity, I’ve removed the other code, and because it’s the same
    as [listing 8.1](#ch08ex01). You can always consult the completed code that’s
    included with the book.
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加`fade-enter`和`fade-leave-to`。这将设置我们的初始不透明度为0。这将确保淡入淡出时透明度为0。更新之前的示例，并查看其效果。为了简化，我已经移除了其他代码，因为它与[列表8.1](#ch08ex01)相同。你始终可以查阅书中包含的完整代码。
- en: 'Listing 8.2\. Description transition with fade: chapter-08/transition-book.html'
  id: totrans-1321
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.2\. 带有淡入淡出的描述过渡：chapter-08/transition-book.html
- en: '[PRE107]'
  id: totrans-1322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '***1* Active states show the duration and easing of transition.**'
  id: totrans-1323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 活跃状态显示过渡的持续时间和缓动效果。**'
- en: '***2* Enters and leaves states for opacity 0**'
  id: totrans-1324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 透明度为0的进入和离开状态**'
- en: Load this in your browser and open the development tools. You may notice something
    interesting when you click the title of the book and look at the source. For 3.0s
    you’ll see a new class that surrounds the description, `fade-enter-active` and
    `fade-enter-to`. You can see it in [figure 8.2](#ch08fig02).
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的浏览器中加载此文件并打开开发工具。当你点击书的标题并查看源代码时，你可能会注意到一些有趣的事情。对于3.0秒，你会看到一个围绕描述的新类，`fade-enter-active`和`fade-enter-to`。你可以在[图8.2](#ch08fig02)中看到它。
- en: Figure 8.2\. Classes when element is being added to the DOM
  id: totrans-1326
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.2\. 元素被添加到DOM中的类
- en: '![](08fig02_alt.jpg)'
  id: totrans-1327
  prefs: []
  type: TYPE_IMG
  zh: '![](08fig02_alt.jpg)'
- en: These classes will show up only for the duration of the fade. Afterward, the
    classes will be removed. If we click the title again, it will begin fading out
    the text. You can see in the browser `fade-leave-active` and `fade-leave-to` are
    added to the HTML node during the transition in [figure 8.3](#ch08fig03).
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类只会在淡入淡出过程中出现。之后，这些类将被移除。如果我们再次点击标题，它将开始淡出文本。你可以在浏览器中看到，在[图8.3](#ch08fig03)中的过渡过程中，`fade-leave-active`和`fade-leave-to`被添加到HTML节点上。
- en: Figure 8.3\. Classes shown when the element is removed from the DOM.
  id: totrans-1329
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.3\. 元素从DOM中移除时显示的类。
- en: '![](08fig03_alt.jpg)'
  id: totrans-1330
  prefs: []
  type: TYPE_IMG
  zh: '![](08fig03_alt.jpg)'
- en: These classes are added momentarily while the element is being removed from
    the DOM. This is how Vue.js creates its animations and transitions. By adding
    and removing classes at different times, elements in Vue.js can create neat transitions
    and animations.
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: 当元素从DOM中移除时，这些类会瞬间添加。这就是Vue.js创建动画和过渡的方式。通过在不同时间添加和移除类，Vue.js中的元素可以创建整洁的过渡和动画。
- en: 8.2\. Animations basics
  id: totrans-1332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2\. 动画基础
- en: Animations are another important feature that Vue.js is good at. You may be
    wondering what the difference is between animations and transitions. Transitions
    are moving from one state to another, whereas animations have multiple states.
    In the last example, we went from seeing the text to fading the text. We also
    saw a transition from no text on the page to fading the text back in.
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: 动画是 Vue.js 另一个重要的特性。你可能想知道动画和过渡之间的区别是什么。过渡是从一个状态移动到另一个状态，而动画有多个状态。在上一个例子中，我们从看到文本到淡出文本。我们还看到了从页面上没有文本到淡入文本的过渡。
- en: Animations are a bit different. You can have multiple states for each animation
    that can be within one declaration. You can do neat stuff with animations, such
    as create complex movements and chain multiple animations together. Animations
    can act like transitions too, but they aren’t transitions.
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
  zh: 动画有一些不同。每个动画可以有多个状态，这些状态可以包含在一个声明中。你可以用动画做一些很酷的事情，比如创建复杂的运动并将多个动画链接在一起。动画也可以像过渡一样工作，但它们不是过渡。
- en: Let’s take the same example from [listing 8.2](#ch08ex02) and add an animation.
    We’ll use the same code, except this time we’ll add a nice bounce effect using
    CSS keyframes. We want the animation to fade in and scale when the title is clicked.
    When the title is clicked again, we want the animation to scale and fade out.
    Open your text editor and copy [listing 8.2](#ch08ex02). Update the transition
    name to bounce, as seen in [listing 8.3](#ch08ex03).
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 [列表 8.2](#ch08ex02) 中的相同示例开始，并添加一个动画。我们将使用相同的代码，但这次我们将使用 CSS 关键帧添加一个漂亮的弹跳效果。当点击标题时，我们希望动画淡入并缩放。当再次点击标题时，我们希望动画缩放并淡出。打开你的文本编辑器并复制
    [列表 8.2](#ch08ex02)。将过渡名称更新为 bounce，如 [列表 8.3](#ch08ex03) 所示。
- en: 'Listing 8.3\. Animation with scale: chapter-08/animation-book-1.html'
  id: totrans-1336
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.3\. 使用缩放的动画：chapter-08/animation-book-1.html
- en: '[PRE108]'
  id: totrans-1337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '***1* Shows the bounce transition**'
  id: totrans-1338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 显示 bounce 过渡**'
- en: Now we need to add our new animation. This animation needs the `enter-active`
    and `leave-active` classes. Begin by deleting the old CSS transition elements.
    Then add the `bounce-enter-active` and the `bounce-leave-active` classes. Add
    a CSS animation with a `bounceIn` of 2s inside the `bounce-enter-active` class.
    Add the same to the `bounce-leave-active` class and add a `reverse`.
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要添加新的动画。这个动画需要 `enter-active` 和 `leave-active` 类。首先删除旧的 CSS 过渡元素。然后添加 `bounce-enter-active`
    和 `bounce-leave-active` 类。在 `bounce-enter-active` 类中添加一个持续时间为 2 秒的 `bounceIn`
    CSS 动画。同样添加到 `bounce-leave-active` 类中，并添加一个 `reverse`。
- en: Next create the CSS keyframes. Use `@keyframes` and add 0%, 60%, and 100%. We’ll
    use CSS transform with a scale of .1 for 0%, 1.2 for 60%, and 1 for 100%. We’ll
    also change the opacity from 0 to 1\. Add this into the style as shown here.
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来创建 CSS 关键帧。使用 `@keyframes` 并添加 0%，60% 和 100%。我们将使用 CSS 变换，0% 时缩放为 .1，60%
    时缩放为 1.2，100% 时缩放为 1。我们还将透明度从 0 变更到 1。按照此处所示将其添加到样式表中。
- en: 'Listing 8.4\. Animation with scale full: chapter-08/animation-book.html'
  id: totrans-1341
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.4\. 使用缩放全屏的动画：chapter-08/animation-book.html
- en: '[PRE109]'
  id: totrans-1342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '***1* Enters active state that uses keyframe bounceIn**'
  id: totrans-1343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 进入使用关键帧 bounceIn 的活动状态**'
- en: '***2* Leaves active state that uses keyframe bounceIn**'
  id: totrans-1344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 离开使用关键帧 bounceIn 的活动状态**'
- en: '***3* Shows the keyframes for animation**'
  id: totrans-1345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 显示动画的关键帧**'
- en: '***4* 0% animation transforms the scale to 0.1 and sets the opacity at 0.**'
  id: totrans-1346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 0% 动画将缩放转换为 0.1 并将透明度设置为 0。**'
- en: '***5* 60% animation transforms the scale to 1.2 and sets the opacity at 1.**'
  id: totrans-1347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 60% 动画将缩放转换为 1.2 并将透明度设置为 1。**'
- en: '***6* Final animation at 100% transforms the scale to 1.**'
  id: totrans-1348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 在 100% 时将缩放转换为 1。**'
- en: Open the file in your browser and check out the animation. You should see the
    fade in and scale occur when you click the title of the book. If you click it
    again, it will fade away. [Figure 8.4](#ch08fig04) is a screenshot of the animation
    halfway through.
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中打开文件并查看动画。当你点击书的标题时，你应该会看到淡入和缩放效果。如果你再次点击它，它将淡出。[图 8.4](#ch08fig04) 是动画进行到一半时的截图。
- en: Figure 8.4\. Screenshot of transition
  id: totrans-1350
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.4\. 过渡截图
- en: '![](08fig04_alt.jpg)'
  id: totrans-1351
  prefs: []
  type: TYPE_IMG
  zh: '![](08fig04_alt.jpg)'
- en: The animation creates an effect where the text gets bigger and shrinks at the
    end.
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
  zh: 动画创建了一个效果，文本在结束时变大并缩小。
- en: 8.3\. JavaScript hooks
  id: totrans-1353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3\. JavaScript 钩子
- en: The transition and animation classes Vue.js provides should cover most basic
    transitions and animations you need, but Vue.js gives us an even more robust solution
    if we need it. We can set JavaScript hooks to do even more complex transitions
    and animations. We do this by combining the hooks with JavaScript that manipulate
    and direct CSS.
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js 提供的过渡和动画类应该涵盖你需要的所有基本过渡和动画，但如果需要，Vue.js 还提供了一个更强大的解决方案。我们可以设置 JavaScript
    钩子来进行更复杂的过渡和动画。我们通过将钩子与操纵和指导 CSS 的 JavaScript 结合来实现这一点。
- en: These hooks may remind you of the hooks we discussed in an earlier chapter for
    the Vue.js lifecycle. These JavaScript hooks are similar but are used for only
    transitions/animation. Remember a few things before using these hooks. First,
    we must always use the done callback when using the `enter` and `leave` hooks.
    Otherwise, they’ll be called synchronously and the transition will finish right
    away. In addition, it’s a good idea to add `v-bind:css="false"` when using JavaScript-only
    transitions so that Vue can skip all the CSS detection for that transition. One
    last thing to remember is that all hooks have the `el`, or element parameter,
    passed in except for `enter` and `leave,` which also passes `done` as a parameter.
    Don’t worry if this is a little confusing; I’ll show you in the next section how
    this works.
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: 这些钩子可能会让你想起我们在早期章节中讨论的 Vue.js 生命周期中的钩子。这些 JavaScript 钩子类似，但仅用于过渡/动画。在使用这些钩子之前，请记住以下几点。首先，我们必须始终在使用`enter`和`leave`钩子时使用`done`回调。否则，它们将同步调用，并且过渡将立即完成。此外，当使用仅
    JavaScript 的过渡时，添加`v-bind:css="false"`是一个好主意，这样 Vue 可以跳过对该过渡的所有 CSS 检测。最后，要记住的是，除了`enter`和`leave`，所有钩子都传递了`el`或元素参数，这些钩子还传递了`done`作为参数。不用担心这有点令人困惑；我将在下一节中向你展示它是如何工作的。
- en: The JavaScript hooks that we can use when entering are `beforeEnter`, `enter`,
    `afterEnter`, and `enterCancelled`. When a transition is leaving, there’s `beforeLeave`,
    `leave`, `afterLeave`, and `leaveCancelled`. All these hooks are triggered at
    various times of the animation.
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: 当进入时，我们可以使用的 JavaScript 钩子有`beforeEnter`、`enter`、`afterEnter`和`enterCancelled`。当过渡离开时，有`beforeLeave`、`leave`、`afterLeave`和`leaveCancelled`。所有这些钩子都在动画的各个时间点触发。
- en: Let’s imagine we’re updating our book example to use the same sort of animations
    we were using earlier, except this time, we want to use JavaScript hooks instead
    of the CSS classes. How can we do this? Let’s begin by taking our program from
    [listing 8.4](#ch08ex04) and deleting the `bounce-enter-active` and the `bounce-leave-active`
    classes. We’ll leave the keyframes in. Instead, we’ll use the JavaScript hooks
    for `enter` and `leave` to do the animation in JavaScript.
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一下，我们正在更新我们的书籍示例，以使用我们之前使用的那种动画，但这次，我们想使用 JavaScript 钩子而不是 CSS 类。我们该如何做呢？让我们从[列表
    8.4](#ch08ex04)开始，删除`bounce-enter-active`和`bounce-leave-active`类。我们将保留关键帧。相反，我们将使用`enter`和`leave`的
    JavaScript 钩子来在 JavaScript 中进行动画。
- en: Let’s change the transition element so it has all the JavaScript hooks listed.
    To do this we’ll need to use the `v-on` directive or use the `@` sign for short.
    Add the JavaScript hooks for `before-enter`, `enter`, `before-leave`, `leave`,
    `after-leave`, `after-enter`, `enter-cancelled`, and `leave-cancelled`.
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更改过渡元素，使其包含所有列出的 JavaScript 钩子。为此，我们需要使用`v-on`指令或使用`@`符号进行简写。添加`before-enter`、`enter`、`before-leave`、`leave`、`after-leave`、`after-enter`、`enter-cancelled`和`leave-cancelled`的
    JavaScript 钩子。
- en: 'Listing 8.5\. JavaScript hooks transition: chapter-08/jshooks-1.html'
  id: totrans-1359
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.5\. JavaScript 钩子过渡：chapter-08/jshooks-1.html
- en: '[PRE110]'
  id: totrans-1360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '***1* Shows all the hooks for the transition**'
  id: totrans-1361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 显示过渡的所有钩子**'
- en: Next, we’ll need to add the JavaScript hooks in our `methods` object inside
    the Vue instance. To make this work correctly, we’ll need to detect when the animation
    is completed. That way, we can clear the style and run `done` on the event. `done`
    is the parameter that’s used in the `enter` and `leave` JavaScript hooks. `done`
    must be executed in these hooks. To do that, we’ll create a new event listener.
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在 Vue 实例内部的`methods`对象中添加 JavaScript 钩子。为了正确地完成这项工作，我们需要检测动画何时完成。这样，我们可以清除样式并在事件上运行`done`。`done`是在`enter`和`leave`
    JavaScript 钩子中使用的参数。在这些钩子中必须执行`done`。为此，我们将创建一个新的事件监听器。
- en: The event listener waits until the animation completes by looking for `animationend`.
    When the animation completes, the callback will reset the style and execute `done`.
    We’ll add this code above the Vue constructor in your HTML file, as shown here.
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: 事件监听器等待动画完成，通过查找`animationend`。当动画完成时，回调将重置样式并执行`done`。我们将在 HTML 文件中的 Vue 构造函数上方添加此代码，如下所示。
- en: 'Listing 8.6\. JavaScript hooks event listener: chapter-08/jshook-2.html'
  id: totrans-1364
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.6\. JavaScript 钩子事件监听器：chapter-08/jshook-2.html
- en: '[PRE111]'
  id: totrans-1365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '***1* The Event listener watches for the animation to end.**'
  id: totrans-1366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 事件监听器监视动画结束。**'
- en: Even though we’re using only `leave` and `enter`, let’s add all the JavaScript
    hooks to our program. Each hook will write to the console log so you can get a
    better idea when they’re triggered.
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们只使用 `leave` 和 `enter`，但让我们将所有 JavaScript 钩子添加到我们的程序中。每个钩子都会写入控制台日志，这样您就可以更好地了解它们何时被触发。
- en: Add a new `methods` object to your Vue.js instance. Add all the JavaScript hooks
    that you added to the transition to that `methods` object. Inside the `enter`
    method, add a function to call the `addEventListener` that was created earlier
    and make sure to pass in the `element` and `done`, as you can see in [listing
    8.7](#ch08ex07). Next, we’ll use JavaScript to set up the animation. The `el.style.animationName`
    is the name of the keyframe animation we created inside the style. The `el.style.animationDuration`
    will be set to 1.5 s.
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的 Vue.js 实例中添加一个新的 `methods` 对象。将您添加到过渡中的所有 JavaScript 钩子添加到该 `methods` 对象中。在
    `enter` 方法中，添加一个调用之前创建的 `addEventListener` 的函数，并确保传入 `element` 和 `done`，正如[列表
    8.7](#ch08ex07)中所示。接下来，我们将使用 JavaScript 设置动画。`el.style.animationName` 是我们在样式内部创建的关键帧动画的名称。`el.style.animationDuration`
    将设置为 1.5 秒。
- en: Inside the `leave` hook, add the same `animationName` and `animationDuration`.
    We’ll also add an `el.style.animationDirection` and set it to reverse. This will
    reverse the animation when the element is leaving the DOM.
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `leave` 钩子内部，添加相同的 `animationName` 和 `animationDuration`。我们还将添加一个 `el.style.animationDirection`
    并将其设置为 reverse。这将使元素离开 DOM 时动画反转。
- en: 'Listing 8.7\. JavaScript hooks methods: chapter-08/jshooks.html'
  id: totrans-1370
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.7\. JavaScript 钩子方法：chapter-08/jshooks.html
- en: '[PRE112]'
  id: totrans-1371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '***1* The enter hook**'
  id: totrans-1372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* enter 钩子**'
- en: '***2* Inside the enter hook is a call to the addEventListener function.**'
  id: totrans-1373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* enter 钩子内部调用了 addEventListener 函数。**'
- en: '***3* The leave hook**'
  id: totrans-1374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* leave 钩子**'
- en: '***4* Inside the leave hook is a call to the addEventListener function.**'
  id: totrans-1375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* leave 钩子内部调用了 addEventListener 函数。**'
- en: '***5* The beforeEnter hook**'
  id: totrans-1376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* beforeEnter 钩子**'
- en: '***6* The afterEnter hook**'
  id: totrans-1377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* afterEnter 钩子**'
- en: '***7* The enterCancelled hook**'
  id: totrans-1378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* enterCancelled 钩子**'
- en: '***8* The beforeLeave hook**'
  id: totrans-1379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* beforeLeave 钩子**'
- en: '***9* The afterLeave hook**'
  id: totrans-1380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9* afterLeave 钩子**'
- en: '***10* The leaveCancelled hook**'
  id: totrans-1381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***10* leaveCancelled 钩子**'
- en: After running this example, it should behave exactly like the book example in
    [listing 8.4](#ch08ex04). Click the title and the animation will begin. If you
    click again, the animation will start in reverse. Keep an eye on the console.
    When you first click the title, you’ll see a few messages, `before enter`, `enter`,
    and then `after enter`, as seen in [figure 8.5](#ch08fig05).
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此示例后，其行为应与[列表 8.4](#ch08ex04)中的书籍示例完全一致。点击标题，动画将开始。再次点击，动画将以相反方向开始。请密切关注控制台。当您第一次点击标题时，您将看到一些消息，如`before
    enter`、`enter`，然后是`after enter`，正如[图 8.5](#ch08fig05)所示。
- en: Figure 8.5\. Hooks triggered after clicking title
  id: totrans-1383
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.5\. 点击标题后触发的钩子
- en: '![](08fig05.jpg)'
  id: totrans-1384
  prefs: []
  type: TYPE_IMG
  zh: '![](08fig05.jpg)'
- en: This is the order the hooks are executed. The `after enter` doesn’t fire until
    the animation is completed. After clicking the title button again, we can see
    the order in which the hooks are triggered. First is `before leave`, then `leave`,
    and finally `after leave`, as you can see in [figure 8.6](#ch08fig06).
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
  zh: 这是钩子执行的顺序。`after enter` 不会在动画完成之前触发。再次点击标题按钮后，我们可以看到触发钩子的顺序。首先是 `before leave`，然后是
    `leave`，最后是 `after leave`，正如[图 8.6](#ch08fig06)所示。
- en: Figure 8.6\. Hooks triggered when element is removed from the DOM.
  id: totrans-1386
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.6\. 当元素从 DOM 中移除时触发的钩子。
- en: '![](08fig06.jpg)'
  id: totrans-1387
  prefs: []
  type: TYPE_IMG
  zh: '![](08fig06.jpg)'
- en: If you look at the source, you’ll also notice the CSS being added and removed
    after every click. This is much like the CSS transition classes we saw previously.
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看源代码，您还会注意到每次点击后都会添加和移除 CSS。这与我们之前看到的 CSS 过渡类非常相似。
- en: 8.4\. Transitioning components
  id: totrans-1389
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4\. 组件过渡
- en: In the previous chapter we looked at dynamic components. These are components
    that we can swap out easily by use of the `is` attribute which points to a variable
    that’s used to reflect the current component selected.
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了动态组件。这些组件可以通过使用指向用于反映当前所选组件的变量的 `is` 属性来轻松替换。
- en: We can use transitions with components the way we did with the `v-if` conditional
    directive that we used earlier. To make things easier, we’ll modify the dynamic-components.html
    example from [chapter 7](kindle_split_018.html#ch07). Grab a copy of [listing
    7.5](kindle_split_018.html#ch07ex05) and make the changes that follow.
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用与之前使用的`v-if`条件指令相同的方式使用过渡。为了使事情更简单，我们将修改第7章中的`dynamic-components.html`示例。获取[列表7.5](kindle_split_018.html#ch07ex05)的副本，并按照以下步骤进行修改。
- en: First surround the dynamic component, `<component :is="currentView"/>`, with
    the `<transition name="component-fade">` element. Before we go on, let’s introduce
    transition modes.
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，用`<transition name="component-fade">`元素包围动态组件`<component :is="currentView"/>`。在我们继续之前，让我们介绍过渡模式。
- en: By default, when transitioning components, you’ll notice that one component
    will transition in while the other transitions out. This might not always be the
    desired outcome. We can add an attribute to our transition called `mode`. We can
    either have it set to `in-out` or `out-in`. If the element is set to `in-out`,
    the new element transitions in first; then when complete, the current element
    transitions out. But when it’s set to `out-in` the current element transitions
    out first; then when complete, the new element transitions in. This `out-in` is
    what we need for our example so that way the previous component fades out before
    the new one appears. In this case, let’s surround our dynamic component with `<transition
    name="component-fade" mode="out-in">`.
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，在组件过渡时，你会注意到一个组件会进入过渡，而另一个组件会退出过渡。这可能并不总是我们想要的结果。我们可以在我们的过渡中添加一个名为`mode`的属性。我们可以将其设置为`in-out`或`out-in`。如果元素设置为`in-out`，新元素将首先过渡进入；然后当完成时，当前元素将过渡退出。但是当它设置为`out-in`时，当前元素将首先过渡退出；然后当完成时，新元素将过渡进入。这种`out-in`就是我们需要的，这样上一个组件在新的组件出现之前会淡出。在这种情况下，让我们用`<transition
    name="component-fade" mode="out-in">`将我们的动态组件包围起来。
- en: Next, we need to add in our transition classes, as shown in the following listing.
    Add the transitions class `component-fade-enter-active` and the `component-fade-leave-active`.
    We’ll add an `opacity:0` to the `component-fade-enter` and the `component-fade-leave-to`.
    This is the completed code.
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加我们的过渡类，如下所示列表所示。添加过渡类`component-fade-enter-active`和`component-fade-leave-active`。我们将向`component-fade-enter`和`component-fade-leave-to`添加`opacity:0`。这是完成后的代码。
- en: 'Listing 8.8\. Transitioning dynamic components: chapter-08/component-transition.html'
  id: totrans-1395
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.8\. 动态组件的过渡：chapter-08/component-transition.html
- en: '[PRE113]'
  id: totrans-1396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '***1* Shows the transition classes used to fade component**'
  id: totrans-1397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 展示用于淡出组件的过渡类**'
- en: '***2* Shows the transition class used to set the opacity**'
  id: totrans-1398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 展示用于设置不透明度的过渡类**'
- en: '***3* Shows the transition component with the mode out-in**'
  id: totrans-1399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 展示使用模式out-in的过渡组件**'
- en: Open a browser with the current code and you’ll see a Cycle button. Click the
    Cycle button and the previous component, Book Component, will fade out and the
    new component, Form Component, will fade in. [Figure 8.7](#ch08fig07) shows a
    screenshot of the fade halfway through.
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: 使用当前代码打开浏览器，你会看到一个循环按钮。点击循环按钮，上一个组件，即书籍组件，将会淡出，而新的组件，即表单组件，将会淡入。[图8.7](#ch08fig07)
    展示了淡入淡出过程的一半截图。
- en: Figure 8.7\. In-between transition of components
  id: totrans-1401
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.7\. 组件之间的过渡
- en: '![](08fig07_alt.jpg)'
  id: totrans-1402
  prefs: []
  type: TYPE_IMG
  zh: '![](08fig07_alt.jpg)'
- en: If you click the Cycle button again, the `Form` component will fade away to
    the `Header` component. It then starts over again at Book.
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次点击循环按钮，`Form`组件将淡出到`Header`组件。然后它从`Book`重新开始。
- en: 8.5\. Updating the pet store application
  id: totrans-1404
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5\. 更新宠物商店应用程序
- en: We updated the pet store application in the last chapter when we switched it
    over to using Vue CLI with single-file components. Now that we have the power
    of transitions and animations, let’s update the app to give it a little more flair.
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，当我们切换到使用Vue CLI和单文件组件时，我们更新了宠物商店应用程序。现在我们有了过渡和动画的能力，让我们更新这个应用程序，让它看起来更加生动。
- en: Keep in mind that, depending on the web application you’re creating, animations
    and transitions might be overkill. Unless you’re creating a highly interactive
    app, you should probably stick to fewer animations and transitions. For this app,
    we’ll add one animation and one transition. Let’s look at the transition first.
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，根据你创建的Web应用程序，动画和过渡可能过于复杂。除非你正在创建一个高度交互的应用程序，否则你可能应该坚持使用更少的动画和过渡。对于这个应用程序，我们将添加一个动画和一个过渡。让我们先看看过渡。
- en: 8.5.1\. Adding a transition to the pet store application
  id: totrans-1407
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.5.1\. 向宠物商店应用程序添加过渡效果
- en: In our app, we want the page to fade in and out between routes. Let’s add a
    simple fade-in and fade-out transition when navigating to the checkout page and
    back to the home page. As we did before, we’ll use the Vue.js animation classes
    to accomplish this. [Figure 8.8](#ch08fig08) shows what it will look like mid-transition
    from the home page to the checkout page.
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们希望页面在路由之间淡入淡出。当导航到结账页面并返回主页时，让我们添加一个简单的淡入淡出过渡。像之前一样，我们将使用 Vue.js
    动画类来完成这个任务。[图 8.8](#ch08fig08) 展示了从主页到结账页面过渡过程中的样子。
- en: Figure 8.8\. Page transitioning to the checkout page
  id: totrans-1409
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.8\. 页面过渡到结账页面
- en: '![](08fig08_alt.jpg)'
  id: totrans-1410
  prefs: []
  type: TYPE_IMG
  zh: '![](08fig08_alt.jpg)'
- en: Retrieve the pet store application we were working with in [chapter 7](kindle_split_018.html#ch07)
    from the code included with this book. Go into the App.vue file inside the src
    folder. This file is where we set up our router from [chapter 7](kindle_split_018.html#ch07).
    Similar to what we did with our previous examples, add a transition element and
    have it surround the router-view. Make sure to add the mode `out-in` as you see
    in [listing 8.9](#ch08ex09).
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
  zh: 从本书附带代码中检索我们在 [第 7 章](kindle_split_018.html#ch07) 中使用的宠物商店应用程序。进入 src 文件夹中的
    App.vue 文件。这是我们设置路由的地方 [第 7 章](kindle_split_018.html#ch07)。类似于我们之前的示例，添加一个过渡元素并使其包围
    router-view。确保添加模式 `out-in`，就像你在 [列表 8.9](#ch08ex09) 中看到的那样。
- en: Next, add the `fade-enter-active` and the `fade-leave-active` class to the style
    tag at the bottom. Set the transition to `opacity` with a `.5s ease-out`. Add
    the `fade-enter` and the `fade-leave-to` classes and set the `opacity` to 0.
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将 `fade-enter-active` 和 `fade-leave-active` 类添加到底部的样式标签中。将过渡设置为 `opacity`
    并使用 `.5s ease-out`。添加 `fade-enter` 和 `fade-leave-to` 类并将 `opacity` 设置为 0。
- en: 'Listing 8.9\. Adding transition to pet store: chapter-08/petstore/src/App.vue'
  id: totrans-1413
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.9\. 向宠物商店添加过渡：chapter-08/petstore/src/App.vue
- en: '[PRE114]'
  id: totrans-1414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '***1* Transition component with mode out-in surrounds the router-view.**'
  id: totrans-1415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1 个带有模式 out-in 的过渡组件包围着 router-view。**'
- en: '***2* Vue.js transition classes that set the transition.**'
  id: totrans-1416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2 个设置过渡的 Vue.js 过渡类。**'
- en: '***3* Vue.js transition classes that set the opacity.**'
  id: totrans-1417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3 个设置透明度的 Vue.js 过渡类。**'
- en: After making these changes, save the file and run the `npm run dev` command.
    This will start the web server, and the web page should pop up in your browser.
    If not, navigate to localhost:8081 and check out the application. Click the checkout
    button and the home page and you’ll see the page fade.
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行这些更改后，保存文件并运行 `npm run dev` 命令。这将启动网络服务器，网页应该会在您的浏览器中弹出。如果没有，请导航到 localhost:8081
    并检查应用程序。点击结账按钮和主页，您会看到页面淡出。
- en: 8.5.2\. Adding an animation to the pet store application
  id: totrans-1419
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.5.2\. 向宠物商店应用程序添加动画
- en: When adding items to the cart, we added several `v-if`, `v-else-if`, and `v-else`
    directives. This lets the user know how much inventory is left that they can add
    to their cart. When the inventory runs out, an All Out message is displayed. Let’s
    add an animation that shakes the text and briefly turns it red when the inventory
    is depleted for any item. To do this, we’ll use the Vue.js animation CSS classes
    we learned about earlier. [Figure 8.9](#ch08fig09) shows an example of how it
    will look with the All Out! animation moving left and right.
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
  zh: 当向购物车添加项目时，我们添加了几个 `v-if`、`v-else-if` 和 `v-else` 指令。这使用户知道他们可以添加到购物车中的库存量。当库存耗尽时，会显示“全部售罄”的消息。让我们添加一个动画，当任何商品的库存耗尽时，它会摇动文本并短暂将其变为红色。为此，我们将使用我们之前学到的
    Vue.js 动画 CSS 类。[图 8.9](#ch08fig09) 展示了一个示例，展示了 All Out! 动画如何左右移动。
- en: Figure 8.9\. All Out! animation. The text moves left and right.
  id: totrans-1421
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.9\. All Out! 动画。文本左右移动。
- en: '![](08fig09.jpg)'
  id: totrans-1422
  prefs: []
  type: TYPE_IMG
  zh: '![](08fig09.jpg)'
- en: Open the Main.vue file and scroll all the way to the bottom. We’re going to
    use one of the animation classes, `enter-active`, to create this animation. We
    don’t need to worry about the animation when the element is removed from the DOM,
    so we’ll skip adding the `leave-active` class.
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 Main.vue 文件并将页面滚动到最底部。我们将使用其中一个动画类，`enter-active`，来创建这个动画。当元素从 DOM 中移除时，我们不需要担心动画，所以我们将跳过添加
    `leave-active` 类。
- en: Add an animation that shakes the text for around .72 seconds. We’ll use a CSS
    `cubic-bezier` and a `transform`. In addition, we’ll set up animation keyframes
    at every 10%. Copy this listing to the Main.vue file.
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个持续约 .72 秒的文本摇动动画。我们将使用 CSS `cubic-bezier` 和 `transform`。此外，我们将在每个 10% 处设置动画关键帧。将此列表复制到
    Main.vue 文件中。
- en: 'Listing 8.10\. Add animation to pet store: chapter-08/petstore/src/components/Main.vue'
  id: totrans-1425
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.10\. 向宠物商店添加动画：chapter-08/petstore/src/components/Main.vue
- en: '[PRE115]'
  id: totrans-1426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '***1* Enter the active class that starts the animation.**'
  id: totrans-1427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 进入激活类以开始动画。**'
- en: '***2* Shows specific keyframes**'
  id: totrans-1428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 显示特定的关键帧**'
- en: After adding the CSS, we’ll need to add the transition element for our animation.
    In the Main.vue file, look for the inventory messages. Each message will have
    the class of `inventory-message`. Add the `<transition>` element and surround
    the `inventory-message`. Make sure to add the `mode="out-in"` to the transition
    as you can see from [listing 8.11](#ch08ex11).
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
  zh: 添加 CSS 之后，我们需要为我们的动画添加过渡元素。在 Main.vue 文件中，查找库存消息。每条消息都将具有 `inventory-message`
    类。添加 `<transition>` 元素并围绕 `inventory-message` 包围起来。确保添加 `mode="out-in"`，正如你在[列表
    8.11](#ch08ex11) 中看到的那样。
- en: In the previous examples, we transitioned or animated only one element. To animate
    more than one element, we need to add a key attribute to the `v-else-if` and `v-if`
    directives. Otherwise, Vue’s compiler won’t animate the content correctly.
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们只过渡或动画化了一个元素。要动画化多个元素，我们需要向 `v-else-if` 和 `v-if` 指令添加关键属性。否则，Vue 的编译器无法正确地动画化内容。
- en: '|  |'
  id: totrans-1431
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The Key Attribute
  id: totrans-1432
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 关键属性
- en: The key attribute is needed whenever you want to transition elements that have
    the same tag name. To make them distinct, you must add a unique key attribute.
    It’s good practice to always add the key attribute when you’re dealing with multiple
    items within a transition component.
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想过渡具有相同标签名的元素时，需要关键属性。为了使它们区分开来，你必须添加一个唯一的关键属性。在处理过渡组件内的多个项目时，始终添加关键属性是一个好习惯。
- en: '|  |'
  id: totrans-1434
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Add a key attribute to the `v-else-if` and `v-if` directives. For the `v-else-if,`
    the key will be empty. This is intentional, so it won’t animate. For the `v-if`
    directive we’ll set the key to 0, as shown here.
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
  zh: 向 `v-else-if` 和 `v-if` 指令添加关键属性。对于 `v-else-if`，关键属性将为空。这是故意的，所以它不会动画化。对于 `v-if`
    指令，我们将关键属性设置为 0，如下所示。
- en: 'Listing 8.11\. Add animation to pet store transition element: chapter-08/petstore/src/components/Main.vue'
  id: totrans-1436
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.11\. 向宠物商店过渡元素添加动画：chapter-08/petstore/src/components/Main.vue
- en: '[PRE116]'
  id: totrans-1437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '***1* The transition for bounce with a mode attribute**'
  id: totrans-1438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 带有模式属性的过渡 bounce**'
- en: '***2* The key is added to v-if and set to zero.**'
  id: totrans-1439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将关键属性添加到 v-if 并设置为 0。**'
- en: '***3* Another key is added so it won’t animate.**'
  id: totrans-1440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 添加另一个关键属性，使其不会动画化。**'
- en: Start the web server by running the `npm run dev` command and try out the app.
    Click the add to cart button until the inventory runs out. You’ll see the All
    Out text move and shake for a few seconds and turn red.
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行 `npm run dev` 命令启动网络服务器，并尝试应用程序。点击添加到购物车按钮，直到库存耗尽。你会看到“全部售罄”文本移动并摇动几秒钟，并变成红色。
- en: Exercise
  id: totrans-1442
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: Use your knowledge from this chapter to answer this question.
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本章的知识来回答这个问题。
- en: What’s the difference between an animation and a transition?
  id: totrans-1444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画和过渡之间有什么区别？
- en: '*See the solution in [appendix B](kindle_split_026.html#app02).*'
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
  zh: '*参见附录 B 中的解决方案（kindle_split_026.html#app02）。*'
- en: Summary
  id: totrans-1446
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Transitions can move elements on your page.
  id: totrans-1447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过渡可以在你的页面上移动元素。
- en: Animations can be scaled, and you can shrink text on the page programmatically.
  id: totrans-1448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画可以缩放，你可以通过编程方式缩小页面上的文本。
- en: JavaScript animation hooks can be used to make complex animations.
  id: totrans-1449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用 JavaScript 动画钩子来制作复杂的动画。
- en: Transitions with dynamic components are useful for cycling through text.
  id: totrans-1450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用动态组件的过渡对于循环文本很有用。
- en: Chapter 9\. Extending Vue
  id: totrans-1451
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第九章\. 扩展Vue
- en: '*This chapter covers*'
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Learning about mixins
  id: totrans-1453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习混入
- en: Understanding custom directives
  id: totrans-1454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解自定义指令
- en: Using the render function
  id: totrans-1455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用渲染函数
- en: Implementing JSX
  id: totrans-1456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现JSX
- en: In the previous chapter we discussed transitions and animations. In this chapter
    we’ll look at different ways we can reuse code in Vue.js. This is important because
    it allows us to extend the functionality of our Vue.js applications and make them
    more robust.
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了过渡和动画。在本章中，我们将探讨在 Vue.js 中重用代码的不同方法。这很重要，因为它允许我们扩展 Vue.js 应用程序的功能，并使它们更加健壮。
- en: We’ll begin by looking at *mixins*. Mixins are a way to share information between
    components; functionality is essentially “mixed” into the component. They’re objects
    that have the same methods and properties that you’d see in any Vue.js component.
    Next, we’ll look at *custom directives*. Custom directives allow us to register
    our own directives, which we can use to create whatever functionality we want.
    Then we’ll look at the `render` *function*. With the `render` function we can
    go beyond using normal templates and create our own using JavaScript. Last, we’ll
    look at using the `render` function with JSX, which is an XML-like syntax for
    JavaScript.
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从查看 *混入* 开始。混入是一种在组件之间共享信息的方式；功能本质上被“混合”到组件中。它们是具有与任何 Vue.js 组件中相同的 方法和属性的
    对象。接下来，我们将查看 *自定义指令*。自定义指令允许我们注册自己的指令，我们可以使用这些指令来创建我们想要的功能。然后我们将查看 `render` *函数*。使用
    `render` 函数，我们可以超越使用普通模板，并使用 JavaScript 创建自己的模板。最后，我们将查看使用 JSX 的 `render` 函数，JSX
    是一种类似于 XML 的 JavaScript 语法。
- en: Don’t worry, I haven’t forgotten about the pet store application. In the next
    chapter we’ll revisit it with Vuex.
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
  zh: 别担心，我没有忘记宠物商店应用程序。在下一章中，我们将使用 Vuex 重新访问它。
- en: 9.1\. Reusing functionality with mixins
  id: totrans-1460
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1\. 使用混入重用功能
- en: Mixins are a great tool for many projects. They allow us to take small pieces
    of functionality and share them between one or many components. As you write your
    Vue.js applications, you’ll notice that your components will start to look alike.
    One important aspect in software design is a concept known as DRY (don’t repeat
    yourself). If you notice that you’re repeating the same code in multiple components,
    it’s time to refactor that code into a mixin.
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
  zh: 混入是许多项目的优秀工具。它们允许我们将小块功能提取出来，并在一个或多个组件之间共享。随着你编写 Vue.js 应用程序，你会发现你的组件开始看起来相似。软件设计中的一个重要方面是称为
    DRY（不要重复自己）的概念。如果你注意到你在多个组件中重复相同的代码，那么是时候将这段代码重构到混入中去了。
- en: Let’s imagine you have an app that needs to collect a phone number or email
    address from your customer. We’ll design our app to have two different components.
    Each component will contain a form with an input and a button. When the user clicks
    the button, it triggers an alert box that displays the text that was entered into
    the input box. It will look like [figure 9.1](#ch09fig01) when we’re done.
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设你有一个需要从你的客户那里收集电话号码或电子邮件地址的应用程序。我们将设计我们的应用程序以拥有两个不同的组件。每个组件将包含一个带有输入和按钮的表单。当用户点击按钮时，它将触发一个显示输入框中输入文本的警告框。完成时，它将看起来像
    [图 9.1](#ch09fig01)。
- en: Figure 9.1\. Mixin example with multiple components
  id: totrans-1463
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.1\. 具有多个组件的混入示例
- en: '![](09fig01_alt.jpg)'
  id: totrans-1464
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig01_alt.jpg)'
- en: This somewhat contrived example shows how we can extract logic as a mixin, in
    this case the logic that handles the button click and alert box. This keeps our
    code clean and avoids repeating code.
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
  zh: 这个有些牵强的示例展示了我们可以如何将逻辑作为混入提取出来，在这种情况下，是处理按钮点击和警告框的逻辑。这使我们的代码更干净，避免了代码重复。
- en: To get started with this example, create a file called mixins.html. To begin,
    we’ll add our script tag for Vue.js and a link tag so we can add in Bootstrap
    for our styling. Then we’ll add a basic HTML layout. The HTML will use Bootstrap’s
    grid layout with one row and three columns. The first column will be set to `col-md-3`
    with an offset of `col-md-offset-2`. This column will display our first component.
    The next column will have a column size `of col-md-3`. The third column will have
    a column size of `col-md-3` and will show the last component.
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始这个示例，创建一个名为 mixins.html 的文件。首先，我们将添加我们的 Vue.js 脚本标签和一个链接标签，以便我们可以添加 Bootstrap
    来进行样式设计。然后我们将添加一个基本的 HTML 布局。HTML 将使用 Bootstrap 的网格布局，包含一行和三列。第一列将设置为 `col-md-3`，偏移量为
    `col-md-offset-2`。这个列将显示我们的第一个组件。下一个列将具有 `col-md-3` 的列大小。第三个列将具有 `col-md-3` 的列大小，并将显示最后一个组件。
- en: Open your mixins.html file and enter the HTML code in the following listing.
    This is the first part of the code for this example. We’ll add more code throughout
    this section. If you’d like to see the completed code for this example, look for
    the mixins.html file included with the code for this book.
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的 mixins.html 文件，并输入以下列表中的 HTML 代码。这是本例代码的第一部分。我们将在本节中添加更多代码。如果你想看到本例的完整代码，请查找本书附带代码中的
    mixins.html 文件。
- en: 'Listing 9.1\. Adding our mixin HTML/CSS: chapter-09/mixin-html.html'
  id: totrans-1468
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.1\. 添加我们的混入 HTML/CSS：chapter-09/mixin-html.html
- en: '[PRE117]'
  id: totrans-1469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '***1* Adds Bootstrap CSS code to file**'
  id: totrans-1470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将 Bootstrap CSS 代码添加到文件**'
- en: '***2* Shows the Bootstrap grid system for columns**'
  id: totrans-1471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 展示了 Bootstrap 网格系统用于列**'
- en: '***3* Lists the first component**'
  id: totrans-1472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 列出了第一个组件**'
- en: '***4* Lists the second component**'
  id: totrans-1473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 列出第二个组件**'
- en: Now that we’ve added HTML, we’ll work on the Vue.js code. Open the mixins.html
    file and add an opening and closing script tag. It’s worth mentioning for this
    example that we aren’t using single-file components with Vue-CLI. If we were to
    do so, this would work the same way. The only difference is that each component
    and mixin would be in its own file.
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了 HTML，我们将开始处理 Vue.js 代码。打开 mixins.html 文件，并添加一个开标签和闭标签的脚本。对于这个例子来说，值得注意的是，我们并没有使用
    Vue-CLI 的单文件组件。如果我们这样做，它将以相同的方式工作。唯一的区别是每个组件和 mixin 都会放在自己的文件中。
- en: Add a new Vue instance in between the opening and closing script tag. Inside
    the Vue instance we’ll add a data object that returns a title. Because we’re using
    components, we’ll also need to declare both components that we’re using in this
    example. Add the code in this listing to the mixins.html file.
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
  zh: 在开标签和闭标签的脚本之间添加一个新的 Vue 实例。在 Vue 实例内部，我们将添加一个返回标题的数据对象。因为我们使用组件，我们还需要声明在这个例子中使用的两个组件。将本列表中的代码添加到
    mixins.html 文件中。
- en: 'Listing 9.2\. Adding the Vue.js instance: chapter-09/mixins-vue.html'
  id: totrans-1476
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.2\. 添加 Vue.js 实例：chapter-09/mixins-vue.html
- en: '[PRE118]'
  id: totrans-1477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '***1* Shows the root Vue.js instance declaration**'
  id: totrans-1478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 展示根 Vue.js 实例的声明**'
- en: '***2* Lists the data object that returns the title property**'
  id: totrans-1479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 列出返回标题属性的 data 对象**'
- en: '***3* Shows the declaration of components for myComp1 and myComp2**'
  id: totrans-1480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 展示 myComp1 和 myComp2 组件的声明**'
- en: We have a few other things left to do. We need to add both of our components
    and our mixin. Each component needs to display text, show an input, and show a
    button. The button needs to take whatever input was entered and display an alert
    box.
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一些其他的事情要做。我们需要添加我们的两个组件和我们的 mixin。每个组件需要显示文本，显示输入，并显示按钮。按钮需要显示输入框中输入的内容，并显示一个警告框。
- en: Each component is similar in a few ways. Both have a title, both have an input
    box, and both have a button. They also behave the same way after clicking a button.
    At first it might seem like a good idea to create one component but the visual
    look and feel of each component is different. For example, each button is styled
    differently and the input boxes themselves accept different values. For this example,
    we’ll leave them as separate components.
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
  zh: 每个组件在几个方面是相似的。它们都有标题，都有输入框，都有按钮。它们在点击按钮后的行为也是相同的。一开始可能觉得创建一个组件是个好主意，但每个组件的视觉外观和感觉是不同的。例如，每个按钮的样式都不同，输入框本身接受不同的值。在这个例子中，我们将它们作为独立的组件保留。
- en: With that said, we still have similar logic outside the template. We need to
    create a mixin that handles a method called `pressed` that displays an alert box.
    Open the mixin.html file and add a new `const` called `myButton` above the Vue.js
    instance. Make sure to add in the `pressed` function, an alert, and a data object
    that returns an item, as seen in this listing.
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们仍然在模板外部有类似的逻辑。我们需要创建一个 mixin 来处理名为 `pressed` 的方法，该方法显示一个警告框。打开 mixin.html
    文件，并在 Vue.js 实例上方添加一个新的 `const`，称为 `myButton`。确保添加 `pressed` 函数、一个警告和一个返回项目的数据对象，如本列表所示。
- en: 'Listing 9.3\. Adding the mixin: chapter-09/my-mixin.html'
  id: totrans-1484
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.3\. 添加 mixin：chapter-09/my-mixin.html
- en: '[PRE119]'
  id: totrans-1485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '***1* Notes the myButton object mixin**'
  id: totrans-1486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 记录 myButton 对象 mixin**'
- en: '***2* Shows methods for the mixin**'
  id: totrans-1487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 展示 mixin 的方法**'
- en: '***3* Notes the pressed function that shows alert box**'
  id: totrans-1488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 按压功能显示警告框**'
- en: Now that we have the mixin in place, we can go ahead and add our components.
    After the `myButton` object, add two new components called `comp1` and `comp2`.
    Each one will contain an `h1` tag, a form, and a button.
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了 mixin，我们可以继续添加我们的组件。在 `myButton` 对象之后，添加两个新的组件，分别称为 `comp1` 和 `comp2`。每个都将包含一个
    `h1` 标签，一个表单和一个按钮。
- en: In `comp1,` our input will use a `v-model` directive to bind the input to a
    property called `item`. In our button, we’ll use the `v-on` directive shorthand
    `@` symbol to bind the click event to the `pressed` method. Then we’ll pass the
    item property into the method. The last thing we need to add to our `comp1` is
    to declare the mixin we created. We add the mixins array at the bottom, as you
    can see in [listing 9.4](#ch09ex04).
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `comp1` 中，我们的输入将使用 `v-model` 指令将输入绑定到名为 `item` 的属性。在我们的按钮中，我们将使用 `v-on` 指令的缩写
    `@` 符号将点击事件绑定到 `pressed` 方法。然后我们将项目属性传递到方法中。我们需要为 `comp1` 添加的最后一件事情是声明我们创建的 mixin。我们在底部添加了
    mixins 数组，正如你在 [列表 9.4](#ch09ex04) 中看到的。
- en: For `comp2,` we’ll add an `h1` tag with a form, an input, and a button. For
    this component, we’ll use the `v-model` directive to bind the item property. The
    button will use the `v-on` directive shorthand `@` to bind the click event to
    the `pressed` method, as the same way we did in `comp1`. We’ll pass the `item`
    property into the method. As with the other component, we’ll need to define which
    mixins we want with this component by using the `mixins` property array at that
    bottom.
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`comp2`，我们将添加一个包含表单、输入和按钮的`h1`标签。对于这个组件，我们将使用`v-model`指令来绑定`item`属性。按钮将使用`v-on`指令的缩写`@`将点击事件绑定到`pressed`方法，就像我们在`comp1`中做的那样。我们将把`item`属性传递到方法中。与其他组件一样，我们需要通过使用底部的`mixins`属性数组来定义我们想要与该组件一起使用的混入。
- en: '|  |'
  id: totrans-1492
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Info
  id: totrans-1493
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 信息
- en: Mixins aren’t shared between components. Each component receives its own copy
    of the mixin. Variables inside the mixin aren’t shared.
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
  zh: 混入不是在组件之间共享的。每个组件都接收它自己的混入副本。混入内部的变量不是共享的。
- en: '|  |'
  id: totrans-1495
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: I won’t go into detail, but we’ve also added basic Bootstrap classes to the
    form elements to style them.
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会深入细节，但我们还向表单元素添加了基本的Bootstrap类来设置样式。
- en: 'Listing 9.4\. Adding in the components: chapter-09/comp1comp2.html'
  id: totrans-1497
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.4\. 添加组件：chapter-09/comp1comp2.html
- en: '[PRE120]'
  id: totrans-1498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '***1* Shows the component 1 declaration**'
  id: totrans-1499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 显示组件1的声明**'
- en: '***2* Inputs v-model directive binding item**'
  id: totrans-1500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 输入v-model指令绑定项**'
- en: '***3* Shows the v-on directive with alias @ binds click event to pressed**'
  id: totrans-1501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 显示v-on指令使用别名@将点击事件绑定到pressed**'
- en: '***4* Notes the declaration of mixin for component**'
  id: totrans-1502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 记录组件混入的声明**'
- en: '***5* The v-model directive binds the input to the item.**'
  id: totrans-1503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* v-model指令将输入绑定到item**'
- en: '***6* The v-on directive with alias @ binds the click event to pressed.**'
  id: totrans-1504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 使用别名@的v-on指令将点击事件绑定到pressed**'
- en: '***7* Shows the mixin declaration at the bottom**'
  id: totrans-1505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 显示在底部的小节声明**'
- en: Open a browser and load the mixins.html file we’re working on. You should see
    [figure 9.1](#ch09fig01). Go ahead and enter an email into the Enter Email box.
    Click the button and you should see a pop up, as seen in [figure 9.2](#ch09fig02).
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
  zh: 打开浏览器并加载我们正在工作的mixins.html文件。你应该能看到[图9.1](#ch09fig01)。接下来，在“输入邮箱”框中输入一个邮箱。点击按钮，你应该会看到一个弹出窗口，如图[图9.2](#ch09fig02)所示。
- en: Figure 9.2\. The image from [figure 9.1](#ch09fig01) after clicking Press Button
    1
  id: totrans-1507
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.2\. 点击“按按钮1”后的[图9.1](#ch09fig01)中的图像
- en: '![](09fig02_alt.jpg)'
  id: totrans-1508
  prefs: []
  type: TYPE_IMG
  zh: '![09fig02_alt.jpg](09fig02_alt.jpg)'
- en: This works the same if we enter values into the Phone Number box.
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在电话号码框中输入值，效果也是一样的。
- en: 9.1.1\. Global mixins
  id: totrans-1510
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.1\. 全局混入
- en: Until now, we’ve used named mixins that we’ve declared inside each of our components.
    Another type of mixin, a *global mixin,* doesn’t require any type of declaration.
    Global mixins affect every Vue instance created in the app.
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用了在各个组件内部声明的命名混入。另一种类型的混入，*全局混入*，不需要任何类型的声明。全局混入会影响应用程序中创建的每个Vue实例。
- en: You’ll need to be cautious when using global mixins. If you’re using any special
    third-party tools, they’ll also be affected. Global mixins are good to use when
    you’re trying to add custom options that need to be added to every Vue.js component
    and instance. Let’s say you need to add authentication to your app and you want
    the authenticated user to be available in every Vue component in the application.
    Instead of registering the mixin in every component, you can create a global mixin.
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
  zh: 使用全局混入时需要谨慎。如果你使用任何特殊的第三方工具，它们也会受到影响。当你尝试添加需要添加到每个Vue.js组件和实例中的自定义选项时，全局混入很有用。比如说，你需要给你的应用程序添加身份验证，并且希望认证用户在应用程序的每个Vue组件中都可用。而不是在每个组件中注册混入，你可以创建一个全局混入。
- en: Let’s look at our app from the last section. We’ll go ahead and change it to
    a global mixin. First, take a copy of the mixins.html file from the previous example
    and copy it to mixins-global.html. We’ll refactor our application in this file.
  id: totrans-1513
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从上一节的应用程序开始。我们将将其更改为全局混入。首先，从上一个示例中复制mixins.html文件到mixins-global.html。我们将在该文件中重构我们的应用程序。
- en: Look for the `const myButton` line inside the script tags. This is our mixin;
    to use global mixins, we need to change this from a `const` to a `Vue.mixin`.
    `The Vue.mixin` tells Vue.js that this is a global mixin and that it must be injected
    into every instance. Delete the `const` line and add the `Vue.mixin({` line to
    the top. Next, close the parenthesis at the bottom as you can see in the following
    listing.
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本标签内寻找`const myButton`行。这是我们混入；要使用全局混入，我们需要将这个`const`改为`Vue.mixin`。`Vue.mixin`告诉Vue.js这是一个全局混入，并且它必须注入到每个实例中。删除`const`行，并在顶部添加`Vue.mixin({`行。接下来，像以下列表中看到的那样，在底部关闭括号。
- en: 'Listing 9.5\. Global mixin: chapter-09/global-mixin.html'
  id: totrans-1515
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.5\. 全局混入：chapter-09/global-mixin.html
- en: '[PRE121]'
  id: totrans-1516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '***1* Shows the declaration of the global mixin**'
  id: totrans-1517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 显示全局混入的声明**'
- en: '***2* Notes the closing parenthesis**'
  id: totrans-1518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 注意括号的结尾**'
- en: 'Now that we have the global mixin declared, we can remove the declarations
    for `myButton` inside the components. Delete the `mixins: [myButton]` line from
    each component. That should do it—now you’re using global mixins! If you load
    the browser with the newly created mixins-global.html file, it should behave and
    look the exact same as you saw previously.'
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我们已经声明了全局混入，我们可以从组件中删除`myButton`的声明。从每个组件中删除`mixins: [myButton]`行。这样就可以了——现在你正在使用全局混入！如果你用新创建的mixins-global.html文件加载浏览器，它应该表现得和之前看到的一模一样。'
- en: '|  |'
  id: totrans-1520
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Troubleshooting
  id: totrans-1521
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 故障排除
- en: If you run into any problems, it might be because you left the mixins declaration
    at the bottom of the component definitions. Make sure to delete any reference
    to `myButton` in your app or you’ll get an error.
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到任何问题，可能是因为你将混入声明留在了组件定义的底部。确保删除你应用中任何对`myButton`的引用，否则你会得到一个错误。
- en: '|  |'
  id: totrans-1523
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 9.2\. Learning custom directives with examples
  id: totrans-1524
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2\. 通过示例学习自定义指令
- en: In the last eight chapters, we’ve looked at all sorts of directives, including
    `v-on`, `v-model`, and `v-text`. But what if we needed to create our own special
    directive? That’s where *custom directives* come in. Custom directives give us
    low-level DOM access to plain elements. We can take any element on the page, add
    a directive, and give it new functionality.
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的八章中，我们查看了许多种指令，包括`v-on`、`v-model`和`v-text`。但如果我们需要创建自己的特殊指令呢？这就是自定义指令的用武之地。自定义指令为我们提供了对普通元素的底层DOM访问。我们可以对页面上的任何元素添加一个指令，并赋予它新的功能。
- en: Keep in mind that custom directives are different than components and mixins.
    All three, mixins, custom directives, and components, help promote code reuse
    but there are differences. Components are great for taking a large piece of functionality
    and separating it into smaller parts and making it available as one tag. Usually
    this consists of more than one HTML element and includes a template. Mixins are
    great at separating logic into smaller reusable chunks of code that can be shared
    in multiple components and instances. Custom directives are geared toward adding
    low-level DOM access to elements. Before using any of these three, take a minute
    to understand which one will be best for the problem you’re trying to solve.
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，自定义指令与组件和混入不同。三者——混入、自定义指令和组件——都有助于促进代码重用，但它们之间有区别。组件非常适合将一大块功能分割成更小的部分，并作为一个标签使其可用。通常这包括多个HTML元素，并包含一个模板。混入擅长将逻辑分割成更小的可重用代码块，这些代码块可以在多个组件和实例中共享。自定义指令旨在为元素添加低级DOM访问。在使用这三种方法之前，花一分钟时间了解哪一种最适合你试图解决的问题。
- en: Two types of directives exist, local and global. Global directives can be accessed
    throughout the app at any place on any element. Typically, when you’re creating
    directives you want them to be global, so you can use them everywhere.
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
  zh: 存在两种类型的指令，局部和全局。全局指令可以在应用的任何地方、任何元素上访问。通常，当你创建指令时，你希望它们是全局的，这样你就可以在各个地方使用它们。
- en: Local directives can be used only in the component that registered that directive.
    This is nice to use when you have a specific custom directive that only needs
    to be used in one component. For example, you might create a specific select drop-down
    that works with only one component.
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
  zh: 局部指令只能在注册该指令的组件中使用。当你有一个特定的自定义指令，只需要在一个组件中使用时，这会很有用。例如，你可能创建一个特定的下拉选择框，它只与一个组件一起工作。
- en: Before we look at each one, let’s create a simple local custom directive that
    sets the color and font size, and adds a Bootstrap class name to an element. It
    should look like [figure 9.3](#ch09fig03) when we’re done.
  id: totrans-1529
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看每一个之前，让我们创建一个简单的本地自定义指令，该指令设置颜色和字体大小，并将Bootstrap类名添加到元素中。完成时，它应该看起来像[图9.3](#ch09fig03)。
- en: Figure 9.3\. Hello World text added using a custom directive.
  id: totrans-1530
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.3\. 使用自定义指令添加的Hello World文本。
- en: '![](09fig03_alt.jpg)'
  id: totrans-1531
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig03_alt.jpg)'
- en: Open a new file and name it directive-example.html. Inside the new file, add
    simple HTML. The HTML should include the script tag for Vue and the stylesheet
    for the Bootstrap CDN. Inside our app, we’ll create a new directive called `v-style-me`,
    as you can see in this listing. This directive will attach to the `p` tag.
  id: totrans-1532
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个新文件，并将其命名为directive-example.html。在新文件中，添加简单的HTML。HTML应包括Vue的脚本标签和Bootstrap
    CDN的样式表。在我们的应用中，我们将创建一个新的指令`v-style-me`，如列表所示。这个指令将附加到`p`标签上。
- en: 'Listing 9.6\. Vue.js local custom directive: chapter-09/directive-html.html'
  id: totrans-1533
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.6\. Vue.js本地自定义指令：chapter-09/directive-html.html
- en: '[PRE122]'
  id: totrans-1534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '***1* Shows the Bootstrap added to the app**'
  id: totrans-1535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 显示了添加到应用中的Bootstrap**'
- en: '***2* Lists the custom directive for style-me**'
  id: totrans-1536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 列出了用于style-me的自定义指令**'
- en: All custom directives start with a `v-*`. Now that we have our custom directive
    in place on our `p` tag, we can add the Vue logic to the app.
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
  zh: 所有自定义指令都以`v-*`开头。现在，我们已经在我们的`p`标签上设置了自定义指令，我们可以在应用中添加Vue逻辑。
- en: Create a Vue instance and a data function. This function will return a welcome
    message. Next, we’ll need to add a directives object. This will register a local
    custom directive. Inside that directives object we can create our directives.
  id: totrans-1538
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个Vue实例和一个数据函数。这个函数将返回一个欢迎信息。接下来，我们需要添加一个指令对象。这将注册一个本地自定义指令。在指令对象内部，我们可以创建我们的指令。
- en: 'Create a directive called `styleMe`. Each directive has access to a number
    of arguments that it can use:'
  id: totrans-1539
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`styleMe`的指令。每个指令都可以访问它可以使用的一组参数：
- en: '***el*—** The element the directive is bound to.'
  id: totrans-1540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***el*—** 指令绑定的元素。'
- en: '***binding*—** An object containing several properties, including `name`, `value`,
    `oldValue`, and `expression`. (See the custom-directive guide for the full list
    at [http://mng.bz/4NNI](http://mng.bz/4NNI).)'
  id: totrans-1541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***binding*—** 包含多个属性的对象，包括`name`、`value`、`oldValue`和`expression`。（有关完整列表，请参阅自定义指令指南[http://mng.bz/4NNI](http://mng.bz/4NNI)。）'
- en: '***vnode*—** The virtual node produced by Vue’s compiler.'
  id: totrans-1542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***vnode*—** Vue编译器生成的虚拟节点。'
- en: '***oldVnode*—** The previous virtual node.'
  id: totrans-1543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***oldVnode*—** 之前的虚拟节点。'
- en: For our example we’ll use only `el`, for the element. This is always the first
    argument in the list. Keep in mind that our `styleMe` element is in camelCase.
    Because it was declared in camelCase, it must be in kebab case (`v-style-me`)
    in the template.
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，我们将只使用`el`，即元素。这总是列表中的第一个参数。请注意，我们的`styleMe`元素是驼峰式命名。因为它是以驼峰式声明的，所以在模板中必须以短横线命名（`v-style-me`）。
- en: 'All custom directives must specify a hook. Much like the lifecycle and animation
    hooks we looked at in earlier chapters, the custom directive also has many similar
    hooks. These hooks are called at various times of the custom directive’s life
    cycle:'
  id: totrans-1545
  prefs: []
  type: TYPE_NORMAL
  zh: 所有自定义指令都必须指定一个钩子。与我们在早期章节中查看的生命周期和动画钩子类似，自定义指令也有许多类似的钩子。这些钩子在自定义指令的生命周期中的不同时间被调用：
- en: '***bind*—** This hook is called only once, when the directive is bound to the
    element. This is a good place to do setup work.'
  id: totrans-1546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***bind*—** 这个钩子只在指令绑定到元素时调用。这是一个进行设置工作的好地方。'
- en: '***inserted*—** This is called when the bound element has been inserted into
    the parent node.'
  id: totrans-1547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***inserted*—** 当绑定的元素被插入到父节点时调用。'
- en: '***update*—** This is called after the containing component VNode has updated.'
  id: totrans-1548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***update*—** 在包含组件的VNode更新后调用。'
- en: '***componentUpdate*—** This is called after the containing component’s VNode
    and the children of the VNodes have updated.'
  id: totrans-1549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***componentUpdate*—** 在包含组件的VNode及其子VNode更新后调用。'
- en: '***unbind*—** This is called when the directive is unbound from the element.'
  id: totrans-1550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***unbind*—** 当指令从元素解绑时调用。'
- en: You may be wondering what a VNode is. In Vue.js the *VNode* is part of the virtual
    DOM that Vue creates when the application is started. VNode is short for virtual
    node and is used in the virtual tree that’s created when Vue.js interacts with
    the DOM.
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道VNode是什么。在Vue.js中，*VNode*是Vue在应用启动时创建的虚拟DOM的一部分。VNode是virtual node的缩写，用于Vue.js与DOM交互时创建的虚拟树。
- en: For our simple example, we’ll use the bind hook. This is fired as soon as the
    directive is bound to the element. The bind hook is a good place to do setup work
    to style the element. Using JavaScript, we’ll use the `style` and `className`
    methods of the element. First add the color blue, then the `fontSize 42px`, and
    finally the `className` text-center inside the bind hook.
  id: totrans-1552
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的简单示例，我们将使用绑定钩子。这个钩子会在指令绑定到元素上时立即触发。绑定钩子是进行设置工作以样式化元素的绝佳位置。使用JavaScript，我们将使用元素的`style`和`className`方法。首先添加蓝色颜色，然后是`fontSize
    42px`，最后在绑定钩子内添加`className` text-center。
- en: Go ahead and update the directive-example.html file. Your code should match
    the following listing.
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
  zh: 继续更新`directive-example.html`文件。你的代码应该与以下列表匹配。
- en: 'Listing 9.7\. Local directive Vue instance: chapter-09/directive-vue.html'
  id: totrans-1554
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.7\. 本地指令Vue实例：chapter-09/directive-vue.html
- en: '[PRE123]'
  id: totrans-1555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '***1* The data function returns the welcome property.**'
  id: totrans-1556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 数据函数返回欢迎属性。**'
- en: '***2* This is where directives are registered.**'
  id: totrans-1557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 这是注册指令的地方。**'
- en: '***3* Shows the name of the local custom directive, with arguments**'
  id: totrans-1558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 显示本地自定义指令的名称，带有参数**'
- en: '***4* Notes the bind hook**'
  id: totrans-1559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 注意绑定钩子**'
- en: Load up the browser and you should see the Hello World message. Now that we
    have this custom directive, we can use it on any element. Create a new `div` element
    and add the `v-style-me` directive. You’ll notice that after you refresh the browser
    the text is centered, the font size is changed, and the color is blue.
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
  zh: 打开浏览器，你应该会看到Hello World消息。现在我们有了这个自定义指令，我们可以在任何元素上使用它。创建一个新的`div`元素，并添加`v-style-me`指令。你会注意到，在刷新浏览器后，文本居中，字体大小已更改，颜色为蓝色。
- en: 9.2.1\. Global custom directives with modifiers, values, and args
  id: totrans-1561
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.1\. 带有修饰符、值和参数的全局自定义指令
- en: Now that we have a local directive, let’s see what it looks like using a global
    directive. We’ll convert our simple example, then we’ll look at the binding argument.
    With the binding argument, we’ll add a couple of new features to our custom directive.
    Let’s give to the directive the ability to pass in the color of the text. In addition,
    we’ll add a modifier so we can choose the size of our text, and we’ll pass an
    arg for the class name. When it’s all done it will look like [figure 9.4](#ch09fig04).
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个本地指令，让我们看看使用全局指令时的样子。我们将转换我们的简单示例，然后我们将查看绑定参数。有了绑定参数，我们将向我们的自定义指令添加一些新功能。让我们给指令赋予传递文本颜色的能力。此外，我们将添加一个修饰符，以便我们可以选择文本的大小，并将类名作为参数传递。完成之后，它将看起来像[图9.4](#ch09fig04)。
- en: Figure 9.4\. Using global directives with the binding argument
  id: totrans-1563
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.4\. 使用全局指令与绑定参数
- en: '![](09fig04_alt.jpg)'
  id: totrans-1564
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig04_alt.jpg)'
- en: Copy the last example directive-example.html to directive-global-example.html.
    The first thing we need to do is to remove the directives object from the Vue.js
    instance. Go into our newly created directive-global-example.html file and remove
    the directives object below the data object.
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
  zh: 将最后的示例指令`directive-example.html`复制到`directive-global-example.html`。我们需要做的第一件事是从Vue.js实例中移除指令对象。进入我们新创建的`directive-global-example.html`文件，并从数据对象下方移除指令对象。
- en: Next, we’ll need to create a new `Vue.directive`. This will tell Vue.js that
    we’re creating a global directive. The first argument is the name of the directive.
    Go ahead and name it `style-me`. Then we’ll assign the name of the hook. We’ll
    use the bind hook the same way we did in the last example.
  id: totrans-1566
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个新的`Vue.directive`。这将告诉Vue.js我们正在创建一个全局指令。第一个参数是指令的名称。继续并给它命名为`style-me`。然后我们将分配钩子的名称。我们将使用与上一个示例相同的绑定钩子。
- en: Inside the bind hook we’ll have two arguments, `el` and `binding`. The first
    argument is the element itself. As we did in the previous example, we can use
    the `el` argument to manipulate the element the directive is attached to by changing
    its `fontSize`, `className`, and `color`. The second argument is called `binding`.
    This object has several properties; let’s take a look at `binding.modifiers`,
    `binding.value`, and `binding.arg`.
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
  zh: 在绑定钩子中，我们将有两个参数，`el`和`binding`。第一个参数是元素本身。正如我们在上一个示例中所做的那样，我们可以使用`el`参数通过更改其`fontSize`、`className`和`color`来操作指令附加到的元素。第二个参数被称为`binding`。这个对象有几个属性；让我们看看`binding.modifiers`、`binding.value`和`binding.arg`。
- en: 'The easiest binding property to work with is `binding.value`. When we add our
    new custom directive to an element, we can specify a value with it. For example,
    we could bind `''red''` to `binding.value`, as follows:'
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
  zh: 最容易处理的绑定属性是`binding.value`。当我们将我们的新自定义指令添加到元素时，我们可以指定一个值。例如，我们可以将`'red'`绑定到`binding.value`，如下所示：
- en: '[PRE124]'
  id: totrans-1569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'We can also use object literals to pass in multiple values:'
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用对象字面量传入多个值：
- en: '[PRE125]'
  id: totrans-1571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: We could then access each value using `binding.value.color` and `binding.value.text`.
    In [listing 9.8](#ch09ex08), you can see that we set the element `el.style.color`
    to `binding.value`. If `binding.value` does not exist, it defaults to blue.
  id: totrans-1572
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `binding.value.color` 和 `binding.value.text` 访问每个值。在 [列表 9.8](#ch09ex08)
    中，你可以看到我们将元素 `el.style.color` 设置为 `binding.value`。如果 `binding.value` 不存在，它默认为蓝色。
- en: 'The `binding.modifiers` are accessed by adding a dot to the end of the custom
    directive:'
  id: totrans-1573
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在自定义指令的末尾添加一个点来访问 `binding.modifiers`：
- en: '[PRE126]'
  id: totrans-1574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: When we access `binding.modifers.large`, it will return `true` or `false`, depending
    if the custom directive was declared when attached to the element. In [listing
    9.8](#ch09ex08), you can see that we check if `binding.modifiers.large` is `true`.
    If so, we set the font size to `42px`. Else if `binding.modifiers.small` is `true`,
    the font size is set to `17px`. If neither one of these modifiers is present,
    the font size isn’t changed.
  id: totrans-1575
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们访问 `binding.modifers.large` 时，它将返回 `true` 或 `false`，这取决于自定义指令在附加到元素时是否被声明。在
    [列表 9.8](#ch09ex08) 中，你可以看到我们检查 `binding.modifiers.large` 是否为 `true`。如果是，我们将字体大小设置为
    `42px`。否则，如果 `binding.modifiers.small` 为 `true`，字体大小设置为 `17px`。如果这两个修饰符都不存在，则不更改字体大小。
- en: 'The last binding property we’ll look at is `binding.arg`, declared in the custom
    directive with a colon and then the name. In this example, `text-center` is the
    argument:'
  id: totrans-1576
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的最后一个绑定属性是 `binding.arg`，它在自定义指令中以冒号声明，然后是名称。在这个例子中，`text-center` 是参数：
- en: '[PRE127]'
  id: totrans-1577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: With all that said, you can chain `modifiers`, `args`, and `values` together.
    We can combine all three. The `binding.arg` is `'red'`, the `binding.modifier`
    is set to `large`, and the `binding.value` is `text-center`.
  id: totrans-1578
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这里，你可以将 `modifiers`、`args` 和 `values` 连接起来。我们可以将这三个结合起来。`binding.arg` 是 `'red'`，`binding.modifier`
    被设置为 `large`，而 `binding.value` 是 `text-center`。
- en: '[PRE128]'
  id: totrans-1579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: After adding the global custom directive make sure to go back into the HTML
    and add the second custom directive with text that displays `Hi everybody`. In
    this text, we’ll use the binding modifier small on it, as shown in the following
    listing.
  id: totrans-1580
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加全局自定义指令后，请确保回到 HTML 中并添加第二个自定义指令，显示文本“Hi everybody”。在这个文本中，我们将使用绑定修饰符 small，如下面的列表所示。
- en: 'Listing 9.8\. Completed Vue global directive: chapter-09/directive-global-example.html'
  id: totrans-1581
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.8\. 完成的 Vue 全局指令：chapter-09/directive-global-example.html
- en: '[PRE129]'
  id: totrans-1582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '***1* Shows the Bootstrap CSS added to the app**'
  id: totrans-1583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 展示了添加到应用中的 Bootstrap CSS**'
- en: '***2* Notes the custom directive declaration with values, arg, and modifier**'
  id: totrans-1584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 记录了带有值、参数和修饰符的自定义指令声明**'
- en: '***3* Lists the second custom directive with only a modifier**'
  id: totrans-1585
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 列出了只有一个修饰符的第二自定义指令**'
- en: '***4* The global custom directive declaration uses the bind hook.**'
  id: totrans-1586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 全局自定义指令声明使用了 bind 钩子。**'
- en: '***5* The element el.style.color is set to the binding.value or blue.**'
  id: totrans-1587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 元素 el.style.color 被设置为 binding.value 或蓝色。**'
- en: '***6* binding.modifiers are checked here to change the font size.**'
  id: totrans-1588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 这里检查 binding.modifiers 以更改字体大小。**'
- en: '***7* binding.arg is set to the class name on the element.**'
  id: totrans-1589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* binding.arg 被设置为元素上的类名。**'
- en: After loading up the browser, you should see the Hello World message. Notice
    how the second text, Hi Everybody, isn’t centered and is smaller to the left of
    the screen. We got this because we used the `v-style-me` directive with only the
    small modifier. In that case, it changed the font size; however, it left the default
    color blue.
  id: totrans-1590
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载浏览器后，你应该看到 Hello World 消息。注意第二个文本“Hi Everybody”没有居中，并且位于屏幕左侧较小。我们之所以得到这个结果，是因为我们使用了只有
    small 修饰符的 `v-style-me` 指令。在这种情况下，它更改了字体大小；然而，它保留了默认颜色蓝色。
- en: 'If you look closely at the source, you’ll notice that a class of “undefined”
    was added to the second text `div`, because we assigned the `binding.arg` to `el.className`
    in the custom directive. However, because we didn’t declare it, it’s undefined
    by default. Beware this could happen: it would probably be a good idea to do a
    check on `binding.arg` before we set it to `el.className`. I’ll leave that for
    you to do.'
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细查看源代码，你会注意到在第二个文本 `div` 上添加了一个类名为“undefined”，因为我们把 `binding.arg` 赋值给了自定义指令中的
    `el.className`。然而，因为我们没有声明它，它默认为 undefined。请注意，这可能会发生：在我们将其设置为 `el.className`
    之前，检查 `binding.arg` 可能是一个好主意。我将把这个留给你来做。
- en: 9.3\. Render functions and JSX
  id: totrans-1592
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3\. 渲染函数和 JSX
- en: Until now we’ve written all Vue.js applications using templates. This will work
    most of the time; however, there may be instances where you need to have the full
    power of JavaScript. For those cases, we can define our own render function instead
    of using a template. The render function will operate similarly to templates.
    It will output HTML, but you must write it in JavaScript.
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直使用模板来编写所有 Vue.js 应用程序。这通常可以工作；然而，可能存在需要使用 JavaScript 全部功能的情况。对于这些情况，我们可以定义自己的渲染函数而不是使用模板。渲染函数将类似于模板的操作。它将输出
    HTML，但你必须用 JavaScript 来编写它。
- en: JSX is an XML-like syntax that can be converted to JavaScript using a plugin.
    It’s a way we can define our HTML inside JavaScript, like the `render` function.
    It’s more commonly used with React, another frontend framework. We can use the
    full power of JSX with Vue.js, with the help of a Babel plugin.
  id: totrans-1594
  prefs: []
  type: TYPE_NORMAL
  zh: JSX 是一种类似于 XML 的语法，可以使用插件将其转换为 JavaScript。这是我们可以在 JavaScript 中定义 HTML 的方式，就像
    `render` 函数一样。它更常与 React 这样的前端框架一起使用。我们可以使用 Vue.js 的全部 JSX 功能，借助 Babel 插件。
- en: Using JSX isn’t the same as using the `render` function. To use JSX, you need
    to install a special plugin. But the `render` function works without any special
    setup inside your Vue.js instances.
  id: totrans-1595
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 JSX 与使用 `render` 函数不同。要使用 JSX，你需要安装一个特殊的插件。但 `render` 函数在 Vue.js 实例内部无需任何特殊设置即可工作。
- en: In my experience, using the `render` function in Vue.js to create complex HTML
    is difficult. Common directives such as `v-for`, `v-if`, and `v-model` aren’t
    available. You have alternatives for these directives, but you’ll have to write
    extra JavaScript. But JSX is a strong suitable alternative. The JSX community
    is large and the syntax is much closer to templates, and you still get the benefit
    and power of JavaScript. The Babel plugin for Vue.js and JSX is well-supported
    and maintained, which is also nice. For those reasons, I’ll only give a simple
    overview of the `render` function before we move on to JSX.
  id: totrans-1596
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的经验，在 Vue.js 中使用 `render` 函数创建复杂的 HTML 是困难的。常见的指令如 `v-for`、`v-if` 和 `v-model`
    都不可用。你有这些指令的替代方案，但你需要编写额外的 JavaScript。但 JSX 是一个强大的替代方案。JSX 社区很大，语法与模板更接近，你仍然可以享受到
    JavaScript 的优势和力量。Vue.js 和 JSX 的 Babel 插件得到了良好的支持和维护，这也是一个优点。出于这些原因，在我们转向 JSX
    之前，我将只简要概述 `render` 函数。
- en: '|  |'
  id: totrans-1597
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-1598
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you’d like to learn about the `render` function in more detail, check out
    the official guides at [https://vuejs.org/v2/guide/render-function.html](https://vuejs.org/v2/guide/render-function.html).
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要更详细地了解 `render` 函数，请查看官方指南 [https://vuejs.org/v2/guide/render-function.html](https://vuejs.org/v2/guide/render-function.html)。
- en: '|  |'
  id: totrans-1600
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 9.3.1\. Render function example
  id: totrans-1601
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.1\. 渲染函数示例
- en: Let’s create a simple example using `render`. Let’s imagine we have a global
    Vue.js component that has a property named welcome. We want it to display the
    welcome message with an HTML header. We’ll use a prop called header to pass in
    which header to use, `h1`, `h2`, `h3`, `h4`, or `h5`. In addition, we’ll add a
    click event to the message so it shows an alert box. To make this good looking,
    we’ll use Bootstrap’s classes. Let’s make sure our `h1` tag also has a class of
    `text-center` on it. When it’s all done it will look like [figure 9.5](#ch09fig05).
  id: totrans-1602
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过 `render` 创建一个简单的示例。让我们假设我们有一个全局 Vue.js 组件，它有一个名为 welcome 的属性。我们希望它显示带有
    HTML 标题的欢迎信息。我们将使用一个名为 header 的属性来传递要使用的标题，`h1`、`h2`、`h3`、`h4` 或 `h5`。此外，我们还将向消息添加一个点击事件，以便显示一个警告框。为了使其看起来更好，我们将使用
    Bootstrap 的类。让我们确保我们的 `h1` 标签上也有 `text-center` 类。完成所有这些后，它将看起来像 [图 9.5](#ch09fig05)。
- en: Figure 9.5\. An example of using the render function
  id: totrans-1603
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.5\. 使用渲染函数的示例
- en: '![](09fig05_alt.jpg)'
  id: totrans-1604
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig05_alt.jpg)'
- en: Create a file called render-basic.html. In this file, we’ll create our small
    app. Before we create our component, let’s create the HTML. Inside the HTML, add
    your script for Vue and your link to the Bootstrap CDN.
  id: totrans-1605
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 render-basic.html 的文件。在这个文件中，我们将创建我们的小型应用程序。在我们创建组件之前，让我们创建 HTML。在 HTML
    中，添加你的 Vue 脚本和指向 Bootstrap CDN 的链接。
- en: 'Inside the body, include a `div` with ID of `app` and a new component called
    `my-comp`. The `div` is optional; we could assign the ID of app directly to the
    `my-comp` component. For the sake of clarity, we’ll leave the `div` in as is.
    Inside that component, it will have a prop called `header` that will be assigned
    to 1\. Inside the opening and closing brackets, we’ll put in a name: Erik. Remember
    from a previous chapter anything in between the brackets of a component can be
    referenced with a slot. We can access slots using the `render` function, as we’ll
    see next. Copy and paste the code from the following listing into the render-basic.html
    file.'
  id: totrans-1606
  prefs: []
  type: TYPE_NORMAL
  zh: 在 body 内部，包含一个 ID 为 `app` 的 `div` 和一个名为 `my-comp` 的新组件。`div` 是可选的；我们可以直接将 app
    的 ID 分配给 `my-comp` 组件。为了清晰起见，我们将保持 `div` 不变。在这个组件内部，它将有一个名为 `header` 的 prop，将被分配为
    1。在开闭括号内，我们将放入一个名称：Erik。记得从上一章中，组件括号之间的任何内容都可以用 slot 引用。我们可以使用 `render` 函数访问 slots，正如我们接下来将要看到的。将以下列表中的代码复制并粘贴到
    render-basic.html 文件中。
- en: 'Listing 9.9\. Render basics html: chapter-09/render-html.html'
  id: totrans-1607
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '清单 9.9\. 渲染基础 html: chapter-09/render-html.html'
- en: '[PRE130]'
  id: totrans-1608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '***1* Vue.js script is added.**'
  id: totrans-1609
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1* 添加 Vue.js 脚本。**'
- en: '***2* Bootstrap stylesheet is added.**'
  id: totrans-1610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2* 添加了 Bootstrap 样式表。**'
- en: '***3* Component is added with header prop.**'
  id: totrans-1611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3* 添加了带有 header prop 的组件。**'
- en: 'Now that we have the HTML in place, we must add a root Vue.js instance before
    we can add a global component. At the bottom of the page inside the script tags,
    add `new Vue({el: ''#app''})`.'
  id: totrans-1612
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我们已经放置了 HTML，我们必须在添加全局组件之前添加一个根 Vue.js 实例。在页面底部的脚本标签内，添加 `new Vue({el: ''#app''})`。'
- en: After we add our root Vue.js instance, let’s create our global component. Make
    sure to have the root Vue.js instance after the global component or you’ll get
    an error. The first thing we’ll need inside our component is a data function that
    returns welcome. We’ll make it say, “Hello World.” We also need to declare our
    prop header.
  id: totrans-1613
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们添加根 Vue.js 实例后，让我们创建我们的全局组件。确保在全局组件之后有根 Vue.js 实例，否则你会得到一个错误。我们组件内部首先需要的是一个返回
    welcome 的数据函数。我们将让它显示“Hello World。”我们还需要声明我们的 prop header。
- en: Instead of declaring a template property on the component, we’ll declare a `render`
    function. Inside that function it will have one argument called `createElement`.
    (You may sometimes see this as `h`; it’s the same thing.) Inside the `render`
    function, you must return `createElement` with the proper arguments.
  id: totrans-1614
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是在组件上声明模板属性，而是在其中声明一个 `render` 函数。在这个函数中，它将有一个名为 `createElement` 的参数。（你有时可能看到它作为
    `h`，它是同一件事。）在 `render` 函数内部，你必须返回带有正确参数的 `createElement`。
- en: When you return `createElement`, you’re building a virtual DOM by describing
    the elements and child elements you’d like to define in your HTML. This is also
    known as a virtual node (VNode). You are essentially creating a tree of VNodes
    that represents the virtual DOM.
  id: totrans-1615
  prefs: []
  type: TYPE_NORMAL
  zh: 当你返回 `createElement` 时，你正在通过描述你希望在 HTML 中定义的元素和子元素来构建一个虚拟 DOM。这也被称为虚拟节点（VNode）。你实际上是在创建一个代表虚拟
    DOM 的 VNode 树。
- en: As you can see from [listing 9.10](#ch09ex10), the `createElement` accepts three
    arguments. The first is a string, object, or function. This is usually where you
    put in the DOM element, such as a `div`. The second argument is an object. This
    represents the attributes you want included on the element. The third is an array
    or string. If it’s a string, it represents the text that will be included inside
    the tag. But if it’s an array, it usually represents the child VNodes. Each VNode
    is like adding another `createElement`. It has the same arguments. For this example,
    we’ll use only a string.
  id: totrans-1616
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [清单 9.10](#ch09ex10) 所示，`createElement` 接受三个参数。第一个是一个字符串、对象或函数。这通常是放置 DOM
    元素的地方，例如 `div`。第二个参数是一个对象。它代表你想要包含在元素上的属性。第三个是一个数组或字符串。如果它是一个字符串，它代表将包含在标签内的文本。但如果它是一个数组，它通常代表子
    VNodes。每个 VNode 都像添加另一个 `createElement` 一样。它有相同的参数。对于这个例子，我们将只使用一个字符串。
- en: Inside our `Vue.component` add the `render(createElement)` function. Inside
    the function, return `createElement`, as you see in [listing 9.10](#ch09ex10).
    The first argument we want is the `header` tag. We need to use the prop passed
    in to form the header value. In this case we sent in 1, which we need to create
    an `h1`. We can concatenate the letter `h` with our prop `this.header`.
  id: totrans-1617
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `Vue.component` 中添加 `render(createElement)` 函数。在函数内部，返回 `createElement`，正如你在
    [清单 9.10](#ch09ex10) 中看到的。我们想要的第一个参数是 `header` 标签。我们需要使用传递的 prop 来形成 header 值。在这种情况下，我们发送了
    1，我们需要创建一个 `h1`。我们可以将字母 `h` 与我们的 prop `this.header` 连接起来。
- en: The next argument is the attribute object. Because we’re using Bootstrap, we
    want to use the `text-center` class to align the text in the middle of the screen.
    To do that, we create an object and have the first property be `class`, with the
    value being `text-center`. In JavaScript, `class` is a defined keyword, so it
    must be in quotes. Our next attribute is our event. Event handlers are represented
    by the keyword `on` when using the `render` function. In this example, we use
    the click event and display an alert box that shows `clicked`.
  id: totrans-1618
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个参数是属性对象。因为我们使用 Bootstrap，我们想要使用 `text-center` 类来将文本居中显示在屏幕中间。为此，我们创建一个对象，并将第一个属性设置为
    `class`，其值为 `text-center`。在 JavaScript 中，`class` 是一个定义好的关键字，所以它必须用引号括起来。我们的下一个属性是我们的事件。当使用
    `render` 函数时，事件处理程序由关键字 `on` 表示。在这个例子中，我们使用点击事件并显示一个显示 `clicked` 的警告框。
- en: The last argument is the array or string. This will define what we see inside
    our `header` tag. To make things more interesting, we’ll combine the welcome message
    that we defined in the data function and the text inside the opening and closing
    brackets of the component, `Erik`. To get this text, we can use `this.$slots.default[0].text`.
    This will get the text in the brackets as if it was the default text in a slot.
    We can now concatenate that with the welcome message. Copy this code into the
    render-basic.html. It should be all you need.
  id: totrans-1619
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个参数是数组或字符串。这将定义我们在 `header` 标签内看到的内容。为了使事情更有趣，我们将结合在数据函数中定义的欢迎信息和组件开头和结尾括号内的文本，`Erik`。为了获取这个文本，我们可以使用
    `this.$slots.default[0].text`。这将获取括号内的文本，就像它是槽中的默认文本一样。我们现在可以将它与欢迎信息连接起来。将此代码复制到
    render-basic.html 中。这应该是你需要的所有内容。
- en: 'Listing 9.10\. Adding the `render` function: chapter-09/render-js.html'
  id: totrans-1620
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.10\. 添加 `render` 函数：chapter-09/render-js.html
- en: '[PRE131]'
  id: totrans-1621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '***1* Notes the global component called my-comp**'
  id: totrans-1622
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 记录了全局组件 my-comp**'
- en: '***2* The render function is paired with the createElement argument.**'
  id: totrans-1623
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* `render` 函数与 `createElement` 参数配对。**'
- en: '***3* Returns the createElement argument**'
  id: totrans-1624
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 返回 `createElement` 参数**'
- en: '***4* The attribute object with the class and click event defined**'
  id: totrans-1625
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 定义了类和点击事件的属性对象**'
- en: '***5* Notes the string that will show in the header element**'
  id: totrans-1626
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 记录将在标题元素中显示的字符串**'
- en: '***6* Lists the root Vue.js instance that must be added**'
  id: totrans-1627
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 列出必须添加的根 Vue.js 实例**'
- en: Load the render-basic.html file and look at the output, it should show the Hello
    World Erik message. Change the prop header to a different value. You should see
    the text get smaller as you increase the number. Click the message and you should
    see [figure 9.6](#ch09fig06).
  id: totrans-1628
  prefs: []
  type: TYPE_NORMAL
  zh: 加载 render-basic.html 文件并查看输出，它应该显示“Hello World Erik”消息。将 prop header 更改为不同的值。你应该看到随着数字的增加文本会变小。点击消息，你应该看到[图
    9.6](#ch09fig06)。
- en: Figure 9.6\. The alert box created using the render function after clicking
    the message.
  id: totrans-1629
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.6\. 点击消息后使用 `render` 函数创建的警告框。
- en: '![](09fig06_alt.jpg)'
  id: totrans-1630
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig06_alt.jpg)'
- en: 9.3.2\. JSX example
  id: totrans-1631
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.2\. JSX 示例
- en: With JSX, you can create HTML similarly to templates and still have the full
    power of JavaScript. To do this, we’ll create an app using Vue-CLI. Our goal is
    to re-create the last example but use JSX instead. This example should accept
    a property, a class, and show an alert box when the message is clicked.
  id: totrans-1632
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 JSX，你可以像模板一样创建 HTML，同时仍然拥有 JavaScript 的全部功能。为此，我们将使用 Vue-CLI 创建一个应用程序。我们的目标是重新创建上一个示例，但使用
    JSX。这个示例应该接受一个属性、一个类，当点击消息时显示一个警告框。
- en: 'Before we start, make sure you have Vue-CLI installed: the instructions are
    in [appendix A](kindle_split_025.html#app01). Open a terminal window and create
    an app called jsx-example. You’ll be asked to respond to a few prompts: enter
    no for all of them.'
  id: totrans-1633
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，请确保你已经安装了 Vue-CLI：说明在[附录 A](kindle_split_025.html#app01)。打开一个终端窗口，创建一个名为
    jsx-example 的应用程序。你将需要回答几个提示：对所有提示都输入 no。
- en: Listing 9.11\. Terminal commands to create jsx project
  id: totrans-1634
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.11\. 创建 jsx 项目的终端命令
- en: '[PRE132]'
  id: totrans-1635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: Next, change to the jsx-example directory and run `npm install`. This will install
    all the dependencies. Now we’ll need to install the Babel plugin for JSX. If you
    have any problems with the installation of the plugin, please check the official
    GitHub page at [https://github.com/vuejs/babel-plugin-transform-vue-jsx](https://github.com/vuejs/babel-plugin-transform-vue-jsx).
    The example I’m about to introduce to you only touches on the basics of JSX. I
    highly recommend reading the official documentation on the GitHub website on all
    the options available. Run `npm install` for all the recommended libraries, as
    shown here.
  id: totrans-1636
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，切换到 jsx-example 目录并运行 `npm install`。这将安装所有依赖项。现在我们需要安装 JSX 的 Babel 插件。如果您在插件安装过程中遇到任何问题，请检查官方
    GitHub 页面 [https://github.com/vuejs/babel-plugin-transform-vue-jsx](https://github.com/vuejs/babel-plugin-transform-vue-jsx)。我将向您介绍的这个示例仅涉及
    JSX 的基础知识。我强烈建议您阅读 GitHub 网站上的官方文档，了解所有可用的选项。按照这里所示运行 `npm install` 以安装所有推荐的库。
- en: Listing 9.12\. Terminal commands to install plugin
  id: totrans-1637
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.12\. 安装插件的终端命令
- en: '[PRE133]'
  id: totrans-1638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: After you have the plugin installed, you’ll need to update the .babelrc file.
    This is in the root folder. Inside it, you’ll see many presets and plugins. Add
    `"env"` to the list of presets and `"transform-vue-jsx"` to the list of plugins,
    as in this listing.
  id: totrans-1639
  prefs: []
  type: TYPE_NORMAL
  zh: 在您安装了插件之后，您需要更新 .babelrc 文件。这个文件在根目录中。在里面，您会看到许多预设和插件。将 `"env"` 添加到预设列表，将 `"transform-vue-jsx"`
    添加到插件列表，如下所示。
- en: 'Listing 9.13\. Update .babelrc: chapter-09/jsx-example/.babelrc'
  id: totrans-1640
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.13\. 更新 .babelrc：chapter-09/jsx-example/.babelrc
- en: '[PRE134]'
  id: totrans-1641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '***1* Adds env to the list of presets**'
  id: totrans-1642
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将环境变量添加到预设列表**'
- en: '***2* Adds transform-vue-jsx to the list of plugins**'
  id: totrans-1643
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将 transform-vue-jsx 添加到插件列表**'
- en: Now that we’ve set up JSX, we can start coding. By default, Vue-CLI creates
    a HelloWorld.vue file. We’ll use that file, but we’ll need to make several modifications.
    Go into the src/App.vue file and update the template. Remove the `img` node and
    add the `HelloWorld` component with two props. The first prop is our header, which
    will determine the header tag level. The second prop will be called name. In [listing
    9.10](#ch09ex10), we used slots instead of a named prop. In the following listing,
    we’ll make a slight modification and pass the name in as a property instead. The
    result will be the same. Update your src/App.vue file so it matches this.
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了 JSX，我们可以开始编码。默认情况下，Vue-CLI 创建了一个 HelloWorld.vue 文件。我们将使用该文件，但我们需要进行一些修改。进入
    src/App.vue 文件并更新模板。删除 `img` 节点并添加具有两个属性的 `HelloWorld` 组件。第一个属性是我们的 header，它将确定头部标签的级别。第二个属性将被称为
    name。在 [列表 9.10](#ch09ex10) 中，我们使用了插槽而不是命名属性。在下面的列表中，我们将进行轻微的修改，并将 name 作为属性传递。结果将是相同的。更新您的
    src/App.vue 文件，使其与以下内容匹配。
- en: 'Listing 9.14\. Update App.vue: chapter-09/jsx-example/src/App.vue'
  id: totrans-1645
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.14\. 更新 App.vue：chapter-09/jsx-example/src/App.vue
- en: '[PRE135]'
  id: totrans-1646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '***1* The Hello World component with two props, name and header**'
  id: totrans-1647
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 具有两个属性，name 和 header 的 Hello World 组件**'
- en: Because we’re using Bootstrap, we need to include it somewhere. Find the index.html
    file in the root folder. Add the link to the Bootstrap CDN, as shown here.
  id: totrans-1648
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们使用 Bootstrap，所以我们需要将其包含在某个地方。在根目录中找到 index.html 文件。添加 Bootstrap CDN 的链接，如下所示。
- en: 'Listing 9.15\. Update the index.html file: chapter-09/jsx-example/index.html'
  id: totrans-1649
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.15\. 更新 index.html 文件：chapter-09/jsx-example/index.html
- en: '[PRE136]'
  id: totrans-1650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '***1* Adds Bootstrap CDN**'
  id: totrans-1651
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 添加 Bootstrap CDN**'
- en: Open the src/components/HelloWorld.vue file. Delete the top template—because
    we’ll be using JSX, we no longer need it. Inside the `export default`, let’s set
    up the data object first. The data object will return welcome, as well as a message.
    The `msg` property will construct the HTML for the header and it will concatenate
    the message we want to show on screen using ES6 template literals.
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 src/components/HelloWorld.vue 文件。删除顶部的模板——因为我们将会使用 JSX，所以我们不再需要它。在 `export
    default` 内，我们首先设置数据对象。数据对象将返回欢迎信息以及一条消息。`msg` 属性将构建头部 HTML，并且将我们想在屏幕上显示的消息使用 ES6
    模板字符串连接起来。
- en: Add a `methods` object as well. This will have a `pressed` method that will
    trigger an alert box that shows `clicked`. Last, add a props array at the bottom,
    for header and name.
  id: totrans-1653
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要添加一个 `methods` 对象。这个对象将有一个 `pressed` 方法，它将触发一个显示 `clicked` 的警告框。最后，在底部添加一个
    props 数组，用于 header 和 name。
- en: The `render` function for JSX is similar to the `render` function we used in
    our first example. By convention, instead of using `createElement`, we use the
    letter `h`. Then we return the JSX we need.
  id: totrans-1654
  prefs: []
  type: TYPE_NORMAL
  zh: JSX 的 `render` 函数与我们在第一个示例中使用的 `render` 函数类似。按照惯例，我们不用 `createElement`，而是使用字母
    `h`。然后我们返回所需的 JSX。
- en: As you can see in [listing 9.16](#ch09ex16), the `render` function returns several
    tags. The first is a `div` tag that surrounds all the JSX. Then we have a `div`
    with a class that equals `text-center`. We then add an on-click event handler
    that is assigned to `this.pressed`. In normal Vue.js, data binding is done with
    text interpolation using the Mustache syntax (double braces). In JSX, we use only
    a single brace.
  id: totrans-1655
  prefs: []
  type: TYPE_NORMAL
  zh: 如[列表 9.16](#ch09ex16)所示，`render`函数返回多个标签。第一个是一个包围所有JSX的`div`标签。然后我们有一个类等于`text-center`的`div`。我们接着添加一个分配给`this.pressed`的点击事件处理器。在正常的Vue.js中，数据绑定是通过使用Mustache语法（双大括号）进行文本插值来完成的。在JSX中，我们只使用单个大括号。
- en: The last thing we add is a special property called `domPropsInnerHTML`. This
    is a special option added by the `babel-plugin-transform-vue` plugin. If you’re
    familiar with React, it’s similar to the `dangerouslySetInnerHTML` option. It
    takes `this.msg` and interprets it as HTML. Be aware that taking user input and
    converting it to HTML may lead to cross-site-scripting attacks, so be cautious
    whenever you use `domPropsInnerHTML`. Copy the text from the following listing
    if you haven’t already and save it in your project.
  id: totrans-1656
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后添加的是一个名为`domPropsInnerHTML`的特殊属性。这是由`babel-plugin-transform-vue`插件添加的特殊选项。如果您熟悉React，它类似于`dangerouslySetInnerHTML`选项。它将`this.msg`解释为HTML。请注意，将用户输入转换为HTML可能会导致跨站脚本攻击，因此在使用`domPropsInnerHTML`时请谨慎。如果您还没有复制以下列表中的文本，请将其复制并保存在您的项目中。
- en: 'Listing 9.16\. Update HelloWorld.vue: chapter-09/jsx-example/HelloWorld.vue'
  id: totrans-1657
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 9.16\. 更新HelloWorld.vue: chapter-09/jsx-example/HelloWorld.vue'
- en: '[PRE137]'
  id: totrans-1658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '***1* A JSX render function**'
  id: totrans-1659
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* JSX渲染函数**'
- en: '***2* Notes a div tag surrounding the JSX**'
  id: totrans-1660
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 注意包围JSX的div标签**'
- en: '***3* Notes a div tag with the class attribute**'
  id: totrans-1661
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 注意具有类属性的div标签**'
- en: '***4* The on click event handler that creates pop up box**'
  id: totrans-1662
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 创建弹出框的点击事件处理器**'
- en: '***5* The domPropsInnerHTML adds this.msg to div.**'
  id: totrans-1663
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* domPropsInnerHTML将this.msg添加到div中。**'
- en: '***6* The Hello World with name added message**'
  id: totrans-1664
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 添加了名称的Hello World消息**'
- en: '***7* This is the method that shows the alert box.**'
  id: totrans-1665
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 这是显示警告框的方法。**'
- en: '***8* Shows the two props for header and name**'
  id: totrans-1666
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 显示标题和名称的两个属性**'
- en: Save the file and start your server. Run `npm run dev` (or `npm run serve` if
    you’re on vue-cli 3.0) on the command line, and you can open the webpage at http://localhost:8080\.
    It should show the `Hello World Erik` message. Try to change several of the values
    passed into the `HelloWorld` component inside App.vue. By changing the header,
    you can change the level of header tag that’s displayed.
  id: totrans-1667
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件并启动您的服务器。在命令行中运行`npm run dev`（如果您使用的是vue-cli 3.0，则为`npm run serve`），然后您可以在http://localhost:8080打开网页。它应该显示`Hello
    World Erik`消息。尝试更改App.vue中传递给`HelloWorld`组件的几个值。通过更改标题，您可以更改显示的标题标签级别。
- en: Exercise
  id: totrans-1668
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: 'Use your knowledge from this chapter to answer this question:'
  id: totrans-1669
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本章的知识来回答以下问题：
- en: What is a mixin and when should you use it?
  id: totrans-1670
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混入是什么，何时应该使用它？
- en: '*See the solution in [appendix B](kindle_split_026.html#app02).*'
  id: totrans-1671
  prefs: []
  type: TYPE_NORMAL
  zh: '*请参阅附录B中的解决方案[appendix B](kindle_split_026.html#app02)。*'
- en: Summary
  id: totrans-1672
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: You can share code snippets between multiple components using mixins.
  id: totrans-1673
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用混入（mixins）在多个组件之间共享代码片段。
- en: You can use custom directives to change the behavior of individual elements.
  id: totrans-1674
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用自定义指令来改变单个元素的行为。
- en: You can use modifiers, values, and args to pass information into custom directives
    to create dynamic elements on the page.
  id: totrans-1675
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用修饰符、值和参数将信息传递到自定义指令中，以在页面上创建动态元素。
- en: The render function gives you the full power of JavaScript inside your HTML.
  id: totrans-1676
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染函数赋予您在HTML中JavaScript的全部功能。
- en: JSX can be used in your Vue.js application as an alternative to using the `render`
    function and still allow you to use the full power of JavaScript inside your HTML.
  id: totrans-1677
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSX可以在您的Vue.js应用程序中使用，作为使用`render`函数的替代方案，同时仍然允许您在HTML中使用JavaScript的全部功能。
