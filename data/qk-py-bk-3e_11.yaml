- en: Chapter 10\. Modules and scoping rules
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 10 章\. 模块和作用域规则
- en: '*This chapter covers:*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖：*'
- en: Defining a module
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义模块
- en: Writing a first module
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写第一个模块
- en: Using the `import` statement
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `import` 语句
- en: Modifying the module search path
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改模块搜索路径
- en: Making names private in modules
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模块中使名称私有
- en: Importing standard library and third-party modules
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入标准库和第三方模块
- en: Understanding Python scoping rules and namespaces
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Python 作用域规则和命名空间
- en: Modules are used to organize larger Python projects. The Python standard library
    is split into modules to make it more manageable. You don’t need to organize your
    own code into modules, but if you’re writing any programs that are more than a
    few pages long or any code that you want to reuse, you should probably do so.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 模块用于组织更大的 Python 项目。Python 标准库被分割成模块以使其更易于管理。你不需要将你的代码组织成模块，但如果你在编写超过几页的任何程序或任何你想要重用的代码，你可能需要这样做。
- en: 10.1\. What is a module?
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1\. 什么是模块？
- en: A *module* is a file containing code. It defines a group of Python functions
    or other objects, and the name of the module is derived from the name of the file.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*模块* 是一个包含代码的文件。它定义了一组 Python 函数或其他对象，模块的名称来自文件的名称。'
- en: Modules most often contain Python source code, but they can also be compiled
    C or C++ object files. Compiled modules and Python source modules are used the
    same way.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 模块通常包含 Python 源代码，但它们也可以是编译后的 C 或 C++ 对象文件。编译模块和 Python 源模块的使用方式相同。
- en: As well as grouping related Python objects, modules help avert name-clash problems.
    You might write a module for your program called `mymodule`, which defines a function
    called `reverse`. In the same program, you might also want to use somebody else’s
    module called `othermodule`, which also defines a function called `reverse` but
    does something different from your `reverse` function. In a language without modules,
    it would be impossible to use two different functions named `reverse`. In Python,
    the process is trivial; you refer to the functions in your main program as `mymodule.reverse`
    and `othermodule.reverse`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 除了分组相关的 Python 对象外，模块还有助于避免命名冲突问题。你可能为你的程序编写一个名为 `mymodule` 的模块，该模块定义了一个名为 `reverse`
    的函数。在同一个程序中，你也可能想要使用另一个名为 `othermodule` 的模块，该模块也定义了一个名为 `reverse` 的函数，但与你的 `reverse`
    函数执行不同的操作。在没有模块的语言中，使用两个不同名称的 `reverse` 函数是不可能的。在 Python 中，这个过程非常简单；你通过在主程序中引用函数作为
    `mymodule.reverse` 和 `othermodule.reverse` 来引用这些函数。
- en: Using the module names keeps the two `reverse` functions straight because Python
    uses namespaces. A *namespace* is essentially a dictionary of the identifiers
    available to a block, function, class, module, and so on. I discuss namespaces
    a bit more at the end of this chapter, but be aware that each module has its own
    namespace, which helps prevent naming conflicts.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模块名称可以保持两个 `reverse` 函数清晰，因为 Python 使用命名空间。*命名空间* 实质上是一个包含一个代码块、函数、类、模块等可访问标识符的字典。我在本章末尾对命名空间进行了更多讨论，但请注意，每个模块都有自己的命名空间，这有助于防止命名冲突。
- en: Modules are also used to make Python itself more manageable. Most standard Python
    functions aren’t built into the core of the language but are provided via specific
    modules, which you can load as needed.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 模块还用于使 Python 本身更易于管理。大多数标准 Python 函数并没有内置到语言的核心中，而是通过特定的模块提供，你可以按需加载这些模块。
- en: 10.2\. A first module
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2\. 第一个模块
- en: The best way to learn about modules is probably to make one, so you get started
    in this section.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 了解模块的最佳方式可能是自己创建一个，所以你将在本节中开始。
- en: Create a text file called mymath.py, and in that text file, enter the Python
    code in [listing 10.1](#ch10ex01). (If you’re using IDLE, choose File > New Window
    and start typing, as shown in [figure 10.1](#ch10fig01).)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 mymath.py 的文本文件，并在该文本文件中输入 [列表 10.1](#ch10ex01) 中的 Python 代码。（如果你使用的是
    IDLE，请选择文件 > 新窗口并开始输入，如图 [图 10.1](#ch10fig01) 所示。）
- en: Listing 10.1\. File mymath.py
  id: totrans-19
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.1\. 文件 mymath.py
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Figure 10.1\. An IDLE edit window provides the same editing functionality as
    the shell window, including automatic indentation and colorization.
  id: totrans-21
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.1\. IDLE 编辑窗口提供了与 shell 窗口相同的编辑功能，包括自动缩进和着色。
- en: '![](images/10fig01_alt.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](images/10fig01_alt.jpg)'
- en: Save this code for now in the directory where your Python executable is. This
    code merely assigns `pi` a value and defines a function. The .py filename suffix
    is strongly suggested for all Python code files; it identifies that file to the
    Python interpreter as consisting of Python source code. As with functions, you
    have the option of putting in a document string as the first line of your module.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码暂时保存在你的 Python 可执行文件所在的目录中。此代码仅将 `pi` 赋予一个值并定义一个函数。强烈建议所有 Python 代码文件使用
    .py 文件名后缀；它将文件标识为 Python 源代码。与函数一样，你还有选择在模块的第一行放置文档字符串。
- en: 'Now start up the Python shell and type the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在启动 Python 壳，并输入以下内容：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In other words, Python doesn’t have the constant `pi` or the function `area`
    built in.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，Python 并没有内置的常量 `pi` 或函数 `area`。
- en: Now type
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在输入
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You’ve brought in the definitions for `pi` and `area` from the mymath.py file,
    using the `import` statement (which automatically adds the .py suffix when it
    searches for the file defining the module named `mymath`). But the new definitions
    aren’t directly accessible; typing `pi` by itself gave an error, and typing `area(2)`
    by itself would give an error. Instead, you access `pi` and `area` by *prepending*
    them with the name of the module that contains them, which guarantees name safety.
    Another module out there may also define `pi` (maybe the author of that module
    thinks that pi is 3.14 or 3.14159265), but that module is of no concern. Even
    if that other module is imported, its version of `pi` will be accessed by `othermodulename.pi`,
    which is different from `mymath.pi`. This form of access is often referred to
    as *qualification* (that is, the variable `pi` is being qualified by the module
    `mymath`). You may also refer to `pi` as an *attribute* of `mymath`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经从 `mymath.py` 文件中引入了 `pi` 和 `area` 的定义，使用了 `import` 语句（当它搜索名为 `mymath` 的模块定义文件时会自动添加
    .py 后缀）。但是，新的定义不能直接访问；单独输入 `pi` 会报错，单独输入 `area(2)` 也会报错。相反，你需要通过在它们前面加上包含它们的模块的名称来访问
    `pi` 和 `area`，这保证了名称的安全性。另一个模块也可能定义了 `pi`（也许那个模块的作者认为 pi 是 3.14 或 3.14159265），但那个模块并不重要。即使那个其他模块被导入，它的
    `pi` 版本也将通过 `othermodulename.pi` 访问，这与 `mymath.pi` 不同。这种访问方式通常被称为 *限定*（即变量 `pi`
    正在被模块 `mymath` 限定）。你也可以将 `pi` 称为 `mymath` 的 *属性*。
- en: Definitions within a module can access other definitions within that module
    without prepending the module name. The `mymath.area` function accesses the `mymath.pi`
    constant as just `pi`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 模块内的定义可以访问该模块内的其他定义，而无需前置模块名称。`mymath.area` 函数通过 `pi` 访问 `mymath.pi` 常量。
- en: If you want to, you can also specifically ask for names from a module to be
    imported in such a manner that you don’t have to prepend them with the module
    name. Type
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想，你也可以以这种方式特别请求从模块中导入名称，这样你就不需要用模块名称来前置它们。输入
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The name `pi` is now directly accessible because you specifically requested
    it by using `from mymath import pi`. The function `area` still needs to be called
    as `mymath .area`, though, because it wasn’t explicitly imported.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你通过使用 `from mymath import pi` 特意请求了它，`pi` 的名称现在可以直接访问。尽管如此，函数 `area` 仍然需要以
    `mymath .area` 的方式调用，因为它没有被明确导入。
- en: 'You may want to use the basic interactive mode or IDLE’s Python shell to incrementally
    test a module as you’re creating it. But if you change your module on disk, retyping
    the `import` command won’t cause it to load again. You need to use the `reload`
    function from the `importlib` module for this purpose. The `importlib` module
    provides an interface to the mechanisms behind importing modules:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想使用基本的交互模式或 IDLE 的 Python 壳来逐步测试你创建的模块。但是，如果你在磁盘上更改了你的模块，重新输入 `import` 命令不会使其再次加载。你需要使用
    `importlib` 模块中的 `reload` 函数来完成此操作。`importlib` 模块提供了一个接口，用于导入模块背后的机制：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When a module is reloaded (or imported for the first time), all of its code
    is parsed. A syntax exception is raised if an error is found. On the other hand,
    if everything is okay, a .pyc file (for example, mymath.pyc) containing Python
    byte code is created.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个模块被重新加载（或首次导入）时，它的所有代码都会被解析。如果发现错误，将引发语法异常。另一方面，如果一切正常，将创建一个包含 Python 字节码的
    .pyc 文件（例如，mymath.pyc）。
- en: Reloading a module doesn’t put you back into exactly the same situation as when
    you start a new session and import it for the first time. But the differences
    won’t normally cause you any problems. If you’re interested, you can look up `reload`
    in the section on the `importlib` module in the *Python Language Reference,* found
    at [https://docs.python.org/3/reference/import.html](https://docs.python.org/3/reference/import.html)
    in this page’s importlib section, to find the details.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载模块不会使您回到与您开始新会话并首次导入时完全相同的情况。但通常这些差异不会给您带来任何问题。如果您感兴趣，可以在 *Python 语言参考*
    的 `importlib` 模块部分中查找 `reload`，该部分位于本页的 importlib 部分 [https://docs.python.org/3/reference/import.html](https://docs.python.org/3/reference/import.html)。
- en: Modules don’t need to be used only from the interactive Python shell, of course.
    You can also import them into scripts (or other modules, for that matter); enter
    suitable `import` statements at the beginning of your program file. Internally
    to Python, the interactive session and a script are considered to be modules as
    well.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，模块不仅可以从交互式 Python 命令行使用。您也可以将它们导入到脚本（或其他模块）中；在程序文件的开头输入合适的 `import` 语句。在
    Python 内部，交互式会话和脚本也被视为模块。
- en: 'To summarize:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 总结如下：
- en: A module is a file defining Python objects.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块是一个定义 Python 对象的文件。
- en: If the name of the module file is modulename.py, the Python name of the module
    is `modulename`.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果模块文件的名称是 `modulename.py`，则该模块的 Python 名称是 `modulename`。
- en: You can bring a module named `modulename` into use with the `import modulename`
    statement. After this statement is executed, objects defined in the module can
    be accessed as `modulename.objectname`.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 `import modulename` 语句将名为 `modulename` 的模块投入使用。执行此语句后，模块中定义的对象可以通过 `modulename.objectname`
    访问。
- en: Specific names from a module can be brought directly into your program by using
    the `from modulename import objectname` statement. This statement makes `objectname`
    accessible to your program without your needing to prepend it with `modulename`,
    and it’s useful for bringing in names that are often used.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 `from modulename import objectname` 语句直接将模块中的特定名称引入到您的程序中。此语句使 `objectname`
    对您的程序可用，而无需在前面加上 `modulename`，这对于引入经常使用的名称非常有用。
- en: 10.3\. The import statement
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3. 导入语句
- en: The `import` statement takes three different forms. The most basic is
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`import` 语句有三种不同的形式。最基本的是'
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: which searches for a Python module of the given name, parses its contents, and
    makes it available. The importing code can use the contents of the module, but
    any references by that code to names within the module must still be prepended
    with the module name. If the named module isn’t found, an error is generated.
    I discuss exactly where Python looks for modules in [section 10.4](#ch10lev1sec4).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 它会搜索给定名称的 Python 模块，解析其内容，并使其可用。导入的代码可以使用模块的内容，但该代码对模块内名称的任何引用都必须在前面加上模块名称。如果找不到指定的模块，将生成错误。我将在[第
    10.4 节](#ch10lev1sec4)中详细讨论 Python 查找模块的位置。
- en: 'The second form permits specific names from a module to be explicitly imported
    into the code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种形式允许从模块中显式导入特定的名称到代码中：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Each of `name1`, `name2`, and so forth from within `modulename` is made available
    to the importing code; code after the `import` statement can use any of `name1`,
    `name2`, `name3`, and so on without your prepending the module name.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`modulename` 内的 `name1`、`name2` 等名称都可供导入的代码使用；在 `import` 语句之后，代码可以使用 `name1`、`name2`、`name3`
    等等，而无需在前面加上模块名称。'
- en: 'Finally, there’s a general form of the `from . . . import . . .` statement:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`from ... import ...` 语句有一个通用形式：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `*` stands for all the exported names in `modulename`. `from modulename
    import *` imports all public names from `modulename`—that is, those that don’t
    begin with an underscore—and makes them available to the importing code without
    the necessity of prepending the module name. But if a list of names called `__all__`
    exists in the module (or the package’s __init__.py), the names are the ones imported,
    whether or not they begin with an underscore.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`*` 代表 `modulename` 中所有导出的名称。`from modulename import *` 导入了 `modulename` 中的所有公共名称——即不以下划线开头的名称——并使它们对导入的代码可用，而无需在前面加上模块名称。但如果模块（或包的
    `__init__.py`）中存在名为 `__all__` 的名称列表，则导入的名称就是这些，无论它们是否以下划线开头。'
- en: You should take care when using this particular form of importing. If two modules
    both define a name, and you import both modules using this form of importing,
    you’ll end up with a name clash, and the name from the second module will replace
    the name from the first. This technique also makes it more difficult for readers
    of your code to determine where the names you’re using originate. When you use
    either of the two previous forms of the import statement, you give your reader
    explicit information about where they’re from.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用这种特定的导入形式时，您应该小心。如果两个模块都定义了同一个名称，并且您使用这种导入形式导入这两个模块，您最终会遇到名称冲突，第二个模块的名称将替换第一个模块的名称。这种技术也使得读者更难确定您使用的名称的来源。当您使用两种之前的导入语句形式之一时，您向您的读者提供了关于它们来源的明确信息。
- en: But some modules (such as `tkinter`) name their functions to make it obvious
    where they originate and to make it unlikely that name clashes will occur. It’s
    also common to use the general import to save keystrokes when using an interactive
    shell.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 但某些模块（如 `tkinter`）命名它们的函数，以便清楚地表明它们的来源，并减少名称冲突的可能性。在交互式外壳中使用时，也常用通用导入来节省按键。
- en: 10.4\. The module search path
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4\. 模块搜索路径
- en: 'Exactly where Python looks for modules is defined in a variable called `path`,
    which you can access through a module called `sys`. Enter the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Python 查找模块的确切位置由一个名为 `path` 的变量定义，您可以通过一个名为 `sys` 的模块来访问它。输入以下内容：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The value shown in place of `_list of directories in the search path_` depends
    on the configuration of your system. Regardless of the details, the string indicates
    a list of directories that Python searches (in order) when attempting to execute
    an `import` statement. The first module found that satisfies the `import` request
    is used. If there’s no satisfactory module in the module search path, an `ImportError`
    exception is raised.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 显示在 `_搜索路径中的目录列表_` 位置上的值取决于您系统的配置。无论细节如何，该字符串表示 Python 在尝试执行 `import` 语句时按顺序搜索的目录列表。找到的第一个满足
    `import` 请求的模块被使用。如果在模块搜索路径中没有找到满意的模块，将引发 `ImportError` 异常。
- en: If you’re using IDLE, you can graphically look at the search path and the modules
    on it by using the Path Browser window, which you can start from the File menu
    of the Python shell window.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用 IDLE，您可以通过路径浏览器窗口图形化地查看搜索路径及其上的模块，您可以从 Python 壳窗口的文件菜单启动它。
- en: The `sys.path` variable is initialized from the value of the environment (operating
    system) variable `PYTHONPATH`, if it exists, or from a default value that’s dependent
    on your installation. In addition, whenever you run a Python script, the `sys.path`
    variable for that script has the directory containing the script inserted as its
    first element, which provides a convenient way of determining where the executing
    Python program is located. In an interactive session such as the previous one,
    the first element of `sys.path` is set to the empty string, which Python takes
    as meaning that it should first look for modules in the current directory.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在，`sys.path` 变量将从环境（操作系统）变量 `PYTHONPATH` 的值初始化，或者从依赖于您安装的默认值初始化。此外，每次您运行一个
    Python 脚本时，该脚本的 `sys.path` 变量都会将包含脚本的目录作为其第一个元素插入，这为确定执行中的 Python 程序的位置提供了一个方便的方法。在一个如前所述的交互式会话中，`sys.path`
    的第一个元素被设置为空字符串，Python 将其视为应在当前目录中首先查找模块。
- en: 10.4.1\. Where to place your own modules
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.4.1\. 将您的模块放置在哪里
- en: 'In the example that starts this chapter, the `mymath` module is accessible
    to Python because (1) when you execute Python interactively, the first element
    of `sys.path` is `""`, telling Python to look for modules in the current directory;
    and (2) you executed Python in the directory that contained the mymath.py file.
    In a production environment, neither of these conditions typically is true. You
    won’t be running Python interactively, and Python code files won’t be located
    in your current directory. To ensure that your programs can use the modules you
    coded, you need to:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章开始的示例中，`mymath` 模块对 Python 可用，因为（1）当您以交互方式执行 Python 时，`sys.path` 的第一个元素是
    `""`，告诉 Python 在当前目录中查找模块；（2）您在包含 mymath.py 文件的目录中执行了 Python。在生产环境中，这两个条件通常都不成立。您不会以交互方式运行
    Python，Python 代码文件也不会位于您的当前目录中。为了确保您的程序可以使用您编写的模块，您需要：
- en: Place your modules in one of the directories that Python normally searches for
    modules.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将您的模块放置在 Python 通常搜索模块的目录之一。
- en: Place all the modules used by a Python program in the same directory as the
    program.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Python程序使用的所有模块放置在程序所在的同一目录中。
- en: Create a directory (or directories) to hold your modules, and modify the `sys
    .path` variable so that it includes this new directory (or directories).
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个目录（或多个目录）来存放您的模块，并修改`sys.path`变量，使其包括这个新目录（或多个目录）。
- en: Of these three options, the first is apparently the easiest and is also an option
    that you should *never* choose unless your version of Python includes local code
    directories in its default module search path. Such directories are specifically
    intended for site-specific code (that is, code specific to your machine) and aren’t
    in danger of being overwritten by a new Python install because they’re not part
    of the Python installation. If your `sys.path` refers to such directories, you
    can put your modules there.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这三个选项中，第一个显然是最简单的，也是您应该*永远*不选择的一个选项，除非您的Python版本在其默认模块搜索路径中包含本地代码目录。这些目录专门用于特定于站点的代码（即特定于您的机器的代码），并且不会因为新的Python安装而被覆盖，因为它们不是Python安装的一部分。如果您的`sys.path`引用了这样的目录，您可以将模块放在那里。
- en: The second option is a good choice for modules that are associated with a particular
    program. Just keep them with the program.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选择对于与特定程序关联的模块来说是个不错的选择。只需将它们与程序放在一起即可。
- en: The third option is the right choice for site-specific modules that will be
    used in more than one program at that site. You can modify `sys.path` in various
    ways. You can assign to it in your code, which is easy, but doing so hardcodes
    directory locations into your program code. You can set the `PYTHONPATH` environment
    variable, which is relatively easy, but it may not apply to all users at your
    site; or you can add it to the default search path by using a .pth file.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种选择是针对将在该站点多个程序中使用的特定于站点的模块的正确选择。您可以通过多种方式修改`sys.path`。您可以在代码中将其赋值，这很简单，但这样做会将目录位置硬编码到您的程序代码中。您可以通过设置`PYTHONPATH`环境变量来实现，这相对简单，但它可能不适用于您站点的所有用户；或者您可以使用.pth文件将其添加到默认搜索路径中。
- en: Examples of how to set `PYTHONPATH` are in the Python documentation in the Python
    Setup and Usage section (under Command line and environment). The directory or
    directories you set it to are prepended to the `sys.path` variable. If you use
    `PYTHONPATH`, be careful that you don’t define a module with the same name as
    one of the existing library modules that you’re using. If you do that your module
    will be found before the library module. In some cases, this may be what you want,
    but probably not often.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如何设置`PYTHONPATH`的示例可以在Python文档的Python设置和使用部分（在命令行和环境部分下）找到。您设置的目录或目录将添加到`sys.path`变量之前。如果您使用`PYTHONPATH`，请确保您没有定义与您正在使用的现有库模块同名的一个模块。如果您这样做，您的模块将在库模块之前被找到。在某些情况下，这可能是您想要的，但可能并不常见。
- en: You can avoid this issue by using a .pth file. In this case, the directory or
    directories you added will be appended to `sys.path`. The last of these mechanisms
    is best illustrated by an example. On Windows, you can place a .pth file in the
    directory pointed to by `sys.prefix`. Assume your `sys.prefix` is `c:\program
    files \python`, and place the file in this listing in that directory.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用.pth文件来避免这个问题。在这种情况下，您添加的目录或目录将被追加到`sys.path`。以下机制的最佳说明是一个例子。在Windows上，您可以将.pth文件放置在`sys.prefix`指向的目录中。假设您的`sys.prefix`是`c:\program
    files \python`，并将文件放置在这个目录中。
- en: Listing 10.2\. File myModules.pth
  id: totrans-72
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.2\. 文件myModules.pth
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The next time a Python interpreter is started, `sys.path` will have `c:\program
    files \python\mymodules` and `c:\Users\naomi\My Documents\python\modules` added
    to it, if they exist. Now you can place your modules in these directories. Note
    that the mymodules directory still runs the danger of being overwritten with a
    new installation. The modules directory is safer. You also may have to move or
    create a mymodules.pth file when you upgrade Python. See the description of the
    `site` module in the *Python Library Reference* if you want more details on using
    .pth files.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 下次启动Python解释器时，如果它们存在，`sys.path`将包含`c:\program files \python\mymodules`和`c:\Users\naomi\My
    Documents\python\modules`，现在您可以将模块放置在这些目录中。请注意，mymodules目录仍然有被新安装覆盖的风险。模块目录更安全。您还可能需要在升级Python时移动或创建一个mymodules.pth文件。如果您想了解更多关于使用.pth文件的信息，请参阅*Python库参考*中`site`模块的描述。
- en: 10.5\. Private names in modules
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.5\. 模块中的私有名称
- en: I mentioned earlier in the chapter that you can enter `from module import *`
    to import *almost* all names from a module. The exception is that identifiers
    in the module beginning with an underscore can’t be imported with `from module
    import *`. People can write modules that are intended for importation with `from
    module import *` but still keep certain function or variables from being imported.
    By starting all internal names (that is, names that shouldn’t be accessed outside
    the module) with an underscore, you can ensure that `from module import *` brings
    in only those names that the user will want to access.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我在前面章节中提到，你可以输入 `from module import *` 来导入一个模块中的几乎所有名称。唯一的例外是模块中以下划线开头的标识符不能通过
    `from module import *` 来导入。人们可以编写旨在通过 `from module import *` 导入的模块，但仍然保留某些函数或变量不被导入。通过以下划线开头所有内部名称（即不应在模块外部访问的名称），你可以确保
    `from module import *` 只导入用户希望访问的名称。
- en: To see this technique in action, assume that you have a file called modtest.py
    containing this code.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到这个技术在实际中的应用，假设你有一个名为 modtest.py 的文件，其中包含以下代码。
- en: Listing 10.3\. File modtest.py
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.3\. 文件 modtest.py
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now start up an interactive session and enter the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在启动一个交互式会话，并输入以下内容：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As you can see, the names `f` and `a` are imported, but the names `_g` and
    `_b` remain hidden outside `modtest`. Note that this behavior occurs only with
    `from ... import *`. You can do the following to access `_g` or `_b`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，名称 `f` 和 `a` 被导入，但名称 `_g` 和 `_b` 在 `modtest` 外部保持隐藏。请注意，这种行为仅在 `from ...
    import *` 时发生。你可以这样做来访问 `_g` 或 `_b`：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The convention of leading underscores to indicate private names is used throughout
    Python, not just in modules.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下划线开头表示私有名称的约定在 Python 中被广泛使用，而不仅仅是模块中。
- en: 10.6\. Library and third-party modules
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.6\. 库和第三方模块
- en: At the beginning of this chapter, I mentioned that the standard Python distribution
    is split into modules to make it more manageable. After you’ve installed Python,
    all the functionality in these library modules is available to you. All that’s
    needed is to import the appropriate modules, functions, classes, and so forth
    explicitly, before you use them.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章开头，我提到标准的 Python 发行版被分割成模块，以便更好地管理。在你安装 Python 之后，这些库模块中的所有功能都对你可用。你所需要做的只是在使用之前明确导入适当的模块、函数、类等等。
- en: Many of the most common and useful standard modules are discussed throughout
    this book. But the standard Python distribution includes far more than what this
    book describes. At the very least, you should browse the table of contents of
    the *Python Library Reference*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 本书通篇讨论了许多最常见和有用的标准模块。但标准的 Python 发行版包含的远不止本书所描述的内容。至少，你应该浏览一下 *Python 库参考* 的目录。
- en: In IDLE, you can easily browse to and look at those modules written in Python
    by using the Path Browser window. You can also search for example code that uses
    modules with the Find in Files dialog box, which you can open from the Edit menu
    of the Python shell window. You can search your own modules as well in this way.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IDLE 中，你可以使用路径浏览器窗口轻松浏览并查看用 Python 编写的模块。你还可以使用“在文件中查找”对话框搜索使用模块的示例代码，你可以从
    Python 壳窗口的编辑菜单中打开它。你也可以以这种方式搜索你自己的模块。
- en: Available third-party modules and links to them are identified in the Python
    Package Index (pyPI), which I discuss in [chapter 19](kindle_split_031.html#ch19).
    You need to download these modules and install them in a directory in your module
    search path to make them available for import into your programs.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的第三方模块及其链接在 Python 包索引（pyPI）中标识，我在第 19 章中讨论了它。[第 19 章](kindle_split_031.html#ch19)。你需要下载这些模块并将它们安装在你模块搜索路径中的一个目录中，以便将它们导入到你的程序中。
- en: '|  |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Quick Check: Modules'
  id: totrans-91
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：模块
- en: Suppose that you have a module called `new_math` that contains a function called
    `new_divide`. What are the ways that you might import and then use that function?
    What are the pros and cons of each method?
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个名为 `new_math` 的模块，其中包含一个名为 `new_divide` 的函数。你可能会以哪些方式导入并使用这个函数？每种方法的优缺点是什么？
- en: Suppose that the `new_math` module contains a function call `_helper_math()`.
    How will the underscore character affect the way that `_helper_math()` is imported?
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 `new_math` 模块中包含一个名为 `_helper_math()` 的函数调用。下划线字符会如何影响 `_helper_math()` 的导入方式？
- en: '|  |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 10.7\. Python scoping rules and namespaces
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.7\. Python 作用域规则和命名空间
- en: Python’s scoping rules and namespaces will become more interesting as your experience
    as a Python programmer grows. If you’re new to Python, you probably don’t need
    to do anything more than quickly read through the text to get the basic ideas.
    For more details, look up *namespaces* in the *Python Language Reference*.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你作为Python程序员的经验的增长，Python的作用域规则和命名空间将变得更加有趣。如果你是Python的新手，你可能不需要做任何事情，只需快速阅读文本以获得基本概念。对于更多细节，请在*Python语言参考*中查找*命名空间*。
- en: 'The core concept here is that of a namespace. A *namespace* in Python is a
    mapping from identifiers to objects—that is, how Python keeps track of what variables
    and identifiers are active and what they point to. So a statement like `x = 1`
    adds `x` to a namespace (assuming that it isn’t already there) and associates
    it with the value `1`. When a block of code is executed in Python, it has three
    namespaces: *local*, *global*, and *built-in* (see [figure 10.2](#ch10fig02)).'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的核心概念是命名空间。Python中的命名空间是将标识符映射到对象的一种映射——也就是说，Python是如何跟踪哪些变量和标识符是活动的以及它们指向什么的。因此，一个像`x
    = 1`这样的语句会将`x`添加到命名空间中（假设它还没有在那里），并将其与值`1`关联起来。当在Python中执行代码块时，它有三个命名空间：*局部*、*全局*和*内置*（见[图10.2](#ch10fig02)）。
- en: Figure 10.2\. The order in which namespaces are checked to locate identifiers
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.2。检查命名空间以定位标识符的顺序
- en: '![](images/10fig02.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](images/10fig02.jpg)'
- en: When an identifier is encountered during execution, Python first looks in the
    *local namespace* for it. If the identifier isn’t found, the *global namespace*
    is looked in next. If the identifier still hasn’t been found, the *built-in namespace*
    is checked. If it doesn’t exist there, this situation is considered to be an error,
    and a `NameError` exception occurs.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行过程中遇到标识符时，Python首先在*局部命名空间*中查找它。如果找不到标识符，则查找*全局命名空间*。如果标识符仍然没有找到，则检查*内置命名空间*。如果它不存在那里，这种情况被认为是错误，并发生`NameError`异常。
- en: For a module, a command executed in an interactive session, or a script running
    from a file, the global and local namespaces are the same. Creating any variable
    or function or importing anything from another module results in a new entry,
    or *binding*, being made in this namespace.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于模块、交互会话中执行的命令或从文件运行的脚本，全局和局部命名空间是相同的。创建任何变量或函数或从另一个模块导入任何内容都会导致在这个命名空间中创建新的条目或*绑定*。
- en: But when a function call is made, a local namespace is created, and a binding
    is entered in it for each parameter of the call. Then a new binding is entered
    into this local namespace whenever a variable is created within the function.
    The global namespace of a function is the global namespace of the containing block
    of the function (that of the module, script file, or interactive session). It’s
    independent of the dynamic context from which it’s called.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当进行函数调用时，会创建一个局部命名空间，并且为调用的每个参数在该命名空间中创建一个绑定。然后，每当在函数内部创建变量时，都会将新的绑定进入这个局部命名空间。函数的全局命名空间是函数包含块的全局命名空间（模块、脚本文件或交互会话的）。它与调用它的动态上下文无关。
- en: In all of these situations, the built-in namespace is that of the `__builtins__`
    module. This module contains, among other things, all the built-in functions you’ve
    encountered (such as `len`, `min`, `max`, `int`, `float`, `list`, `tuple`, `range`,
    `str`, and `repr`) and the other built-in classes in Python, such as the exceptions
    (like `NameError`).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些情况下，内置命名空间是`__builtins__`模块的。此模块包含了许多内置函数，例如你遇到过的`len`、`min`、`max`、`int`、`float`、`list`、`tuple`、`range`、`str`和`repr`，以及Python中的其他内置类，例如异常（如`NameError`）。
- en: One thing that sometimes trips up new Python programmers is the fact that you
    can override items in the built-in module. If, for example, you create a list
    in your program and put it in a variable called `list`, you can’t subsequently
    use the built-in `list` function. The entry for your list is found first. There’s
    no differentiation between names for functions and modules and other objects.
    The most recent occurrence of a binding for a given identifier is used.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，新Python程序员可能会遇到的一个问题是，你可以覆盖内置模块中的项。例如，如果你在程序中创建了一个列表并将其放入名为`list`的变量中，那么你将无法使用内置的`list`函数。你的列表条目首先被找到。对于函数、模块和其他对象的名称没有区别。给定标识符的绑定中最近的一次出现会被使用。
- en: 'Enough talk—it’s time to explore some examples. The examples use two built-in
    functions: `locals` and `globals`. These functions return dictionaries containing
    the bindings in the local and global namespaces, respectively.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 足够的讨论了——现在是时候探索一些例子了。这些例子使用了两个内置函数：`locals` 和 `globals`。这些函数分别返回包含局部和全局命名空间绑定的字典。
- en: 'Start a new interactive session:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 开始一个新的交互会话：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The local and global namespaces for this new interactive session are the same.
    They have three initial key-value pairs that are for internal use: (1) an empty
    documentation string `__doc__`, (2) the main module name `__name__` (which for
    interactive sessions and scripts run from files is always `__main__`), and (3)
    the module used for the built-in namespace `__builtins__` (the module `__builtins__`).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新交互会话的局部和全局命名空间是相同的。它们有三个初始的键值对，用于内部使用：(1) 一个空的文档字符串 `__doc__`，(2) 主模块名称 `__name__`（对于交互式会话和从文件运行的脚本，总是
    `__main__`），以及(3) 用于内置命名空间的模块 `__builtins__`（模块 `__builtins__`）。
- en: 'Now if you continue by creating a variable and importing from modules, you
    see several bindings created:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果你继续通过创建变量和从模块中导入，你会看到创建了几个绑定：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As expected, the local and global namespaces continue to be equivalent. Entries
    have been added for `z` as a number, `math` as a module, and `cos` from the `cmath`
    module as a function.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，局部和全局命名空间继续保持等效。为 `z` 作为数字、`math` 作为模块以及从 `cmath` 模块中的 `cos` 作为函数添加了条目。
- en: 'You can use the `del` statement to remove these new bindings from the namespace
    (including the module bindings created with the `import` statements):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `del` 语句从命名空间中删除这些新绑定（包括使用 `import` 语句创建的模块绑定）：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The result isn’t drastic, because you’re able to import the `math` module and
    use it again. Using `del` in this manner can be handy when you’re in the interactive
    mode.^([[1](#ch10fn1)])
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 结果并不剧烈，因为你能够导入 `math` 模块并再次使用它。在交互模式下使用 `del` 的这种方式可能很有用。[^1]
- en: ¹
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Using `del` and then `import` again won’t pick up changes made to a module on
    disk. It isn’t removed from memory and then loaded from disk again. The binding
    is taken out of and then put back into your namespace. You still need to use `importlib.reload`
    if you want to pick up changes made to a file.
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用 `del` 然后再次 `import` 不会拾取对磁盘上模块所做的更改。它不会被从内存中移除并再次从磁盘加载。绑定是从你的命名空间中取出并放回的。如果你想拾取对文件所做的更改，你仍然需要使用
    `importlib.reload`。
- en: For the trigger-happy, yes, it’s also possible to use `del` to remove the `__doc__`,
    `__main__`, and `__builtins__` entries. But resist doing this, because it wouldn’t
    be good for the health of your session!
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些喜欢冒险的人来说，是的，你也可以使用 `del` 来删除 `__doc__`、`__main__` 和 `__builtins__` 的条目。但请抵制这样做，因为这不会对你的会话健康有益！
- en: 'Now look at a function created in an interactive session:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看在交互会话中创建的函数：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you dissect this apparent mess, you see that as expected, upon entry the
    parameter `x` is the original entry in `f`’s local namespace, but `y` is added
    later. The global namespace is the same as that of your interactive session, which
    is where `f` was defined. Note that it contains `z`, which was defined after `f`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你剖析这个明显的混乱，你会看到，正如预期的那样，在进入时，参数 `x` 是 `f` 的局部命名空间中的原始条目，但 `y` 是后来添加的。全局命名空间与你的交互会话相同，这是
    `f` 被定义的地方。注意它包含 `z`，这是在 `f` 之后定义的。
- en: In a production environment, you normally call functions that are defined in
    modules. Their global namespace is that of the module in which the functions are
    defined. Assume that you’ve created the file in this listing.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，你通常调用定义在模块中的函数。它们的全局命名空间是定义函数的模块的命名空间。假设你已经创建了本列表中的文件。
- en: Listing 10.4\. File scopetest.py
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列出 10.4\. 文件 scopetest.py
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Note that you’ll be printing only the keys (identifiers) of the dictionary
    returned by `globals` to reduce clutter in the results. You print only the keys
    because modules are optimized to store the whole `__builtins__` dictionary as
    the value field for the `__builtins__` key:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你将只打印 `globals` 返回的字典的键（标识符），以减少结果中的混乱。你只打印键，因为模块被优化为将整个 `__builtins__` 字典作为
    `__builtins__` 键的值字段存储：
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now the global namespace is that of the `scopetest` module and includes the
    function `f` and integer `v` (but not `z` from your interactive session). Thus,
    when creating a module, you have complete control over the namespaces of its functions.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在全局命名空间是 `scopetest` 模块的命名空间，包括函数 `f` 和整数 `v`（但不包括你的交互会话中的 `z`）。因此，当你创建一个模块时，你可以完全控制其函数的命名空间。
- en: 'I’ve covered local and global namespaces. Next, I move on to the built-in namespace.
    This example introduces another built-in function, `dir`, which, given a module,
    returns a list of the names defined in it:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经介绍了局部和全局命名空间。接下来，我将转向内建命名空间。这个例子介绍了另一个内建函数 `dir`，它给定一个模块，返回其中定义的名称列表：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: There are a lot of entries here. Those entries ending in `Error` and `Exit`
    are the names of the exceptions built into Python, which I discuss in [chapter
    14](kindle_split_025.html#ch14).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多条目。以 `Error` 和 `Exit` 结尾的条目是 Python 内建异常的名称，我在 [第 14 章](kindle_split_025.html#ch14)
    中讨论了这些异常。
- en: 'The last group (from `abs` to `zip`) is built-in functions of Python. You’ve
    already seen many of these functions in this book and will see more, but I don’t
    cover all of them here. If you’re interested, you can find details on the rest
    in the *Python Library Reference*. You can also easily obtain the documentation
    string for any of them by using the `help()` function or by printing the docstring
    directly:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个组（从 `abs` 到 `zip`）是 Python 的内建函数。你已经在本书中看到了许多这些函数，并将看到更多，但在这里我不会涵盖所有这些函数。如果你感兴趣，你可以在
    *Python 库参考* 中找到其余部分的详细信息。你也可以通过使用 `help()` 函数或直接打印文档字符串来轻松地获取它们的文档字符串：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As I mentioned earlier, it’s not unheard-of for a new Python programmer to
    inadvertently override a built-in function:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，一个新 Python 程序员无意中覆盖内建函数的情况并不少见：
- en: '[PRE21]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The Python interpreter won’t look beyond the new binding for `list` as a `list`,
    even though you’re using the built-in `list` function syntax.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你使用的是内建 `list` 函数的语法，Python 解释器也不会超出新的 `list` 绑定来寻找 `list` 作为 `list`。
- en: 'The same thing happens, of course, if you try to use the same identifier twice
    in a single namespace. The previous value is overwritten, regardless of its type:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你在单个命名空间中尝试使用相同的标识符两次，也会发生相同的事情。无论其类型如何，前一个值都会被覆盖：
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When you’re aware of this situation, it isn’t a significant issue. Reusing
    identifiers, even for different types of objects, wouldn’t make for the most readable
    code anyway. If you do inadvertently make one of these mistakes when in interactive
    mode, it’s easy to recover. You can use `del` to remove your binding, to regain
    access to an overridden built-in, or to import your module again to regain access:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当你意识到这种情况时，这并不是一个重大问题。即使是为不同类型的对象重用标识符，代码的可读性也不会因此而降低。如果你在交互模式下无意中犯了这些错误，恢复起来也很容易。你可以使用
    `del` 来删除你的绑定，以重新访问被覆盖的内建函数，或者再次导入你的模块以重新访问：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `locals` and `globals` functions can be useful as simple debugging tools.
    The `dir` function doesn’t give the current settings, but if you call it without
    parameters, it returns a sorted list of the identifiers in the local namespace.
    This practice helps you catch the mistyped variable error that compilers usually
    catch for you in languages that require declarations:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`locals` 和 `globals` 函数可以作为简单的调试工具使用。`dir` 函数不会给出当前的设置，但如果你不带参数调用它，它将返回本地命名空间中标识符的排序列表。这种做法有助于你捕捉到编译器通常在需要声明的语言中为你捕获的误拼变量错误：'
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The debugger that’s bundled with IDLE has settings that allow you to view the
    local and global variable settings as you step through your code; it displays
    the output of the `locals` and `globals` functions.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 与 IDLE 一起捆绑的调试器具有设置，允许你在执行代码时查看局部和全局变量设置；它显示 `locals` 和 `globals` 函数的输出。
- en: '|  |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Quick Check: Namespaces and scope'
  id: totrans-144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：命名空间和作用域
- en: 'Consider a variable `width` that’s in the module `make_window.py`. In which
    of the following contexts is `width` in scope?:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个位于 `make_window.py` 模块中的变量 `width`。在以下哪个上下文中 `width` 是作用域内的？
- en: (A) within the module itself
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: (A) 在模块本身内部
- en: (B) inside the `resize()` function in the module
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: (B) 在模块中的 `resize()` 函数内部
- en: (C) within the script that imported the `make_window.py` module
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: (C) 在导入 `make_window.py` 模块的脚本内部
- en: '|  |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Lab 10: Create a module'
  id: totrans-151
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实验室 10：创建一个模块
- en: Package the functions created at the end of [chapter 9](kindle_split_020.html#ch09)
    as a standalone module. Although you can include code to run the module as the
    main program, the goal should be for the functions to be completely usable from
    another script.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 将 [第 9 章](kindle_split_020.html#ch09) 结尾创建的函数打包成一个独立的模块。虽然你可以包含代码以将模块作为主程序运行，但目标应该是使函数可以从另一个脚本中完全使用。
- en: '|  |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Summary
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Python modules allow you to put related code and objects into a file.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 模块允许你将相关的代码和对象放入一个文件中。
- en: Using modules also helps prevent conflicting variable names, because imported
    objects are normally named in association with their module.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模块还有助于防止变量名冲突，因为导入的对象通常与其模块相关联命名。
