- en: 11 Working with dates and times
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11 处理日期和时间
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Converting `Series` of strings to datetimes
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将字符串 `Series` 转换为日期时间
- en: Retrieving date and time information from datetime objects
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从日期时间对象检索日期和时间信息
- en: Rounding dates to week, month, and quarter ends
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将日期四舍五入到周、月和季度末
- en: Adding and subtracting datetimes to and from each other
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在日期时间之间添加和减去
- en: A *datetime* is a data type for storing date and time. It can model a specific
    date (such as October 4, 2021), a particular time (such as 11:50 a.m.), or both
    (such as October 4, 2021 at 11:50 a.m.). Datetimes are valuable because they allow
    us to track trends over time. A financial analyst may use datetimes to determine
    the weekdays when a stock performs best. A restaurant owner may use them to discover
    the peak hours that customers are patronizing the business. An operations manager
    may use them to identify the parts of a process that are creating bottlenecks
    in production. The *when* in a data set can often lead to the *why*.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *datetime* 是用于存储日期和时间的数据类型。它可以表示一个特定的日期（例如 2021 年 10 月 4 日），一个特定的时间（例如上午
    11:50），或者两者（例如 2021 年 10 月 4 日上午 11:50）。日期时间非常有价值，因为它们允许我们跟踪时间趋势。一个金融分析师可能会使用日期时间来确定股票表现最佳的星期几。一个餐馆老板可能会使用它们来发现顾客光顾业务的高峰时段。一个运营经理可能会使用它们来识别生产中造成瓶颈的过程部分。数据集中的
    *何时* 常常可以引导到 *为什么*。
- en: In this chapter, we’ll review Python’s built-in datetime objects and see how
    pandas improves them with its `Timestamp` and `Timedelta` objects. We’ll also
    learn how to use the library to convert strings to dates, add and subtract offsets
    of time, calculate durations, and more. There’s no time to waste (pun intended),
    so let’s dive in.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将回顾 Python 的内置 datetime 对象，并了解 pandas 如何通过其 `Timestamp` 和 `Timedelta`
    对象来改进它们。我们还将学习如何使用该库将字符串转换为日期，添加和减去时间偏移量，计算持续时间，等等。没有时间可以浪费（这里有个双关语），让我们开始吧。
- en: 11.1 Introducing the Timestamp object
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1 介绍 Timestamp 对象
- en: A *module* is a file with Python code. Python's standard library is a collection
    of more than 250 modules baked into the language that provide battle-tested solutions
    to common problems such as database connections, mathematics, and testing. The
    standard library exists so developers can write software that uses core language
    features rather than install additional dependencies. It’s often said that Python
    comes with “batteries included”; like a toy, the language is ready to be used
    out of the box.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *模块* 是一个包含 Python 代码的文件。Python 的标准库是语言中内置的超过 250 个模块的集合，它们为常见问题提供经过实战检验的解决方案，例如数据库连接、数学和测试。标准库的存在是为了让开发者能够编写使用核心语言特性的软件，而不是安装额外的依赖项。常有人说
    Python “自带电池”；就像玩具一样，语言可以直接使用。
- en: 11.1.1 How Python works with datetimes
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.1 Python 如何处理日期时间
- en: 'To reduce memory consumption, Python does not autoload its standard library
    modules by default. Instead, we must explicitly import any desired modules into
    our project. As with an external package (such as pandas), we can import a module
    with the `import` keyword and assign it an alias with the `as` keyword. The standard
    library’s `datetime` module is our target; it stores classes for working with
    dates and times. `dt` is a popular alias for the `datetime` module. Let’s spin
    up a fresh Jupyter Notebook and import `datetime` along with the `pandas` library:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少内存消耗，Python 默认不会自动加载其标准库模块。相反，我们必须明确地将任何所需的模块导入到我们的项目中。与外部包（如 pandas）一样，我们可以使用
    `import` 关键字导入一个模块，并使用 `as` 关键字为其分配别名。标准库的 `datetime` 模块是我们的目标；它存储用于处理日期和时间的类。`dt`
    是 `datetime` 模块的流行别名。让我们启动一个新的 Jupyter Notebook 并导入 `datetime` 以及 `pandas` 库：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s review four classes in the module: `date`, `time`, `datetime`, and `timedelta`.
    (See appendix B for more details on classes and objects.)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾模块中的四个类：`date`、`time`、`datetime` 和 `timedelta`。（有关类和对象的更多详细信息，请参阅附录 B。）
- en: 'A `date` models a single day in history. The object does not store any time.
    The `date` class constructor accepts sequential `year`, `month`, and `day` parameters.
    All parameters expect integers. The next example instantiates a `date` object
    for my birthday, April 12, 1991:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`date` 模型历史中的一个单独的一天。该对象不存储任何时间。`date` 类构造函数接受顺序的 `year`、`month` 和 `day` 参数。所有参数都期望是整数。下一个示例为我的生日，1991
    年 4 月 12 日，实例化一个 `date` 对象：'
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `date` object saves the constructor’s arguments as object attributes. We
    can access their values with the `year`, `month`, and `day` attributes:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`date` 对象将构造函数的参数保存为对象属性。我们可以通过 `year`、`month` 和 `day` 属性来访问它们的值：'
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'A `date` object is *immutable*—we cannot change its internal state after we
    create it. Python will raise an `AttributeError` exception if we attempt to overwrite
    any `date` attributes:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`date`对象是*不可变的*——我们创建后不能更改其内部状态。如果我们尝试覆盖任何`date`属性，Python将引发`AttributeError`异常：'
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The complementary `time` class models a specific time of day. The date is irrelevant.
    The `time` constructor’s first three parameters accept integer arguments for `hour`,
    `minute`, and `second`. Like a `date` object, a `time` object is immutable. The
    next example instantiates a `time` object modeling 6:43:25 a.m.:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 补充的`time`类表示一天中的特定时间。日期无关紧要。`time`构造函数的前三个参数接受整数参数，用于`hour`、`minute`和`second`。与`date`对象一样，`time`对象是不可变的。下一个示例实例化一个`time`对象，表示上午6:43:25：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The default argument for all three parameters is 0\. If we instantiate a `time`
    object without arguments, it will represent midnight (12:00:00 a.m.). Midnight
    is 0 hours, 0 minutes, and 0 seconds into the day:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三个参数的默认值都是0。如果我们不带参数实例化一个`time`对象，它将代表午夜（凌晨12:00:00）。午夜是一天的0小时、0分钟和0秒：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The next example passes in 9 for the `hour` parameter, 42 for the `second`
    parameter, and no value for the `minute` parameter. The `time` object substitutes
    0 for the `minutes` value. The resulting time is 9:00:42 a.m.:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例将9传递给`hour`参数，42传递给`second`参数，没有为`minute`参数传递值。`time`对象将`minutes`值替换为0。得到的时间是上午9:00:42：
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `time` constructor uses a 24-hour clock; we can pass it an `hour` value
    greater than or equal to 12 to represent a time in the afternoon or evening,.
    The next example models 19:43:22 or, equivalently, 7:43:22 p.m.:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`time`构造函数使用24小时制时钟；我们可以传递大于或等于12的`hour`值来表示下午或晚上的时间。下一个示例表示19:43:22或等价于晚上7:43:22：'
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `time` object saves our constructor arguments as object attributes. We
    can access their values with the `hour`, `minute`, and `second` attributes:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`time`对象将构造函数参数保存为对象属性。我们可以使用`hour`、`minute`和`second`属性访问它们的值：'
- en: '[PRE8]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next in line is the `datetime` object, which holds both a date and a time.
    Its first six parameters are the `year`, `month`, `day`, `hour`, `minute`, and
    `second`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`datetime`对象，它包含日期和时间。它的前六个参数是`year`、`month`、`day`、`hour`、`minute`和`second`：
- en: '[PRE9]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `year`, `month`, and `day` parameters are required. The time-related attributes
    are optional and default to `0`. The next example models midnight on January 1,
    2020 (12:00:00 a.m.). We explicitly pass in the `year`, `month`, and `day` parameters;
    the `hour`, `minute`, and `second` parameters implicitly fall back to `0`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`year`、`month`和`day`参数是必需的。与时间相关的属性是可选的，默认值为`0`。下一个示例表示2020年1月1日凌晨（12:00:00
    a.m.）。我们明确传递了`year`、`month`和`day`参数；`hour`、`minute`和`second`参数隐式地回退到`0`：'
- en: '[PRE10]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Our final noteworthy object from the `datetime` module is `timedelta`, which
    models a duration—a length of time. Its constructor’s parameters include `weeks`,
    `days`, and `hours`. All the parameters are optional and default to `0`. The constructor
    adds the time lengths to calculate the total duration. In the next example, we
    add 8 weeks and 6 days for a total of 62 days (8 weeks * 7 days + 6 days). Python
    also adds 3 hours, 58 minutes, and 12 seconds for a grand total of 14,292 seconds
    (238 minutes * 60 seconds + 12 seconds):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`datetime`模块中的最后一个值得注意的对象是`timedelta`，它表示一个持续时间——时间的长度。其构造函数的参数包括`weeks`、`days`和`hours`。所有参数都是可选的，默认值为`0`。构造函数将时间长度相加以计算总持续时间。在下一个示例中，我们添加了8周和6天，总共62天（8周
    * 7天 + 6天）。Python还添加了3小时、58分钟和12秒，总共有14,292秒（238分钟 * 60秒 + 12秒）：
- en: '[PRE11]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now that we’ve familiarized ourselves with how Python models dates, times, and
    durations, let’s explore how pandas builds on these concepts.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了Python如何表示日期、时间和持续时间，让我们来探索pandas如何在此基础上构建这些概念。
- en: 11.1.2 How pandas works with datetimes
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.2 Pandas如何处理日期时间
- en: Python’s `datetime` module has had its share of criticism. Some common complaints
    include
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`datetime`模块受到了一些批评。一些常见的投诉包括
- en: A large number of modules to keep track of. We introduced only `datetime` in
    this chapter, but additional modules are available for calendars, time conversions,
    utility functions, and more.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要跟踪大量的模块。我们只在本章中介绍了`datetime`，但还有其他模块可用于日历、时间转换、实用函数等。
- en: A large number of classes to remember.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要记住大量的课程。
- en: Complex, difficult object APIs for time-zone logic.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂、困难的对象API用于时区逻辑。
- en: Pandas introduces the `Timestamp` object as a replacement for Python’s `datetime`
    object. We can view the `Timestamp` and `datetime` objects as being siblings;
    they are often interchangeable in the pandas ecosystem, such as when being passed
    as method arguments. Much as the `Series` expands on a Python list, the `Timestamp`
    adds features to the more primitive `datetime` object. We’ll see some of these
    bells and whistles as we progress through the chapter.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas 引入了 `Timestamp` 对象作为 Python 的 `datetime` 对象的替代品。我们可以将 `Timestamp` 和 `datetime`
    对象视为兄弟；在 pandas 生态系统中，它们经常可以互换，例如作为方法参数传递。就像 `Series` 扩展了 Python 列表一样，`Timestamp`
    为更原始的 `datetime` 对象添加了功能。随着我们进入本章，我们将看到一些这些特性：
- en: 'The `Timestamp` constructor is available at the top level of pandas; it accepts
    the same parameters as a `datetime` constructor. The three date-related parameters
    (`year`, `month`, and `day`) are required. Time-related parameters are optional
    and default to `0.` Here, we again model April 12, 1991, a glorious day:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`Timestamp` 构造函数在 pandas 的顶层可用；它接受与 `datetime` 构造函数相同的参数。三个与日期相关的参数（`year`、`month`
    和 `day`）是必需的。与时间相关的参数是可选的，默认为 `0.` 这里，我们再次模拟 1991 年 4 月 12 日，一个辉煌的日子：'
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Pandas considers a `Timestamp` to be equal to a `date`/`datetime` if the two
    objects store the same information. We can use the `==` symbols to compare object
    equality:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas 认为如果两个对象存储相同的信息，则 `Timestamp` 等于 `date`/`datetime`。我们可以使用 `==` 符号来比较对象相等性：
- en: '[PRE13]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The two objects will be unequal if there is any difference in date or time.
    The next example instantiates a `Timestamp` with a `minute` value of `2` and a
    `datetime` with a `minute` value of `1`. The equality comparison yields `False`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果日期或时间有任何差异，两个对象将不相等。下一个示例使用 `minute` 值为 `2` 的 `Timestamp` 和 `minute` 值为 `1`
    的 `datetime` 实例化。相等比较的结果为 `False`：
- en: '[PRE14]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `Timestamp` constructor is remarkably flexible and accepts a variety of
    inputs. The next example passes the constructor a string instead of a sequence
    of integers. The text stores a date in the common YYYY-MM-DD format (four-digit
    year, two-digit month, two-digit day). Pandas correctly deciphers the month, day,
    and year from the input:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`Timestamp` 构造函数非常灵活，接受各种输入。下一个示例将字符串传递给构造函数而不是整数序列。文本存储了一个日期，格式为 YYYY-MM-DD（四位年份，两位月份，两位日期）。Pandas
    正确地解析了输入中的月份、日期和年份：'
- en: '[PRE15]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Pandas recognizes many standard datetime string formats. The next example replaces
    the dashes in the date string with slashes:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas 识别许多标准的 datetime 字符串格式。下一个示例将日期字符串中的破折号替换为斜杠：
- en: '[PRE16]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The next example passes a string in MM/DD/YYYY format, which is no problem
    for pandas:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例传递一个 MM/DD/YYYY 格式的字符串，这对 pandas 来说没问题：
- en: '[PRE17]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can also include the time in a variety of written formats:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以以各种书面格式包含时间：
- en: '[PRE18]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, the `Timestamp` constructor accepts Python’s native `date`, `time`,
    and `datetime` objects. The next example parses data from a `datetime` object:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Timestamp` 构造函数接受 Python 的原生 `date`、`time` 和 `datetime` 对象。下一个示例从 `datetime`
    对象解析数据：
- en: '[PRE19]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `Timestamp` object implements all `datetime` attributes, such as `hour`,
    `minute`, and `second`. The next example saves the previous `Timestamp` to a variable
    and then outputs several attributes:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`Timestamp` 对象实现了所有 `datetime` 属性，如 `hour`、`minute` 和 `second`。下一个示例将之前的 `Timestamp`
    保存到变量中，然后输出几个属性：'
- en: '[PRE20]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Pandas does its best to ensure that its datetime objects work similarly to Python’s
    built-in ones. We can consider the objects to be effectively swappable in pandas
    operations.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas 尽力确保其 datetime 对象与 Python 内置的类似。我们可以认为这些对象在 pandas 操作中是有效可互换的。
- en: 11.2 Storing multiple timestamps in a DatetimeIndex
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.2 在 DatetimeIndex 中存储多个时间戳
- en: 'An *index* is the collection of identifier labels attached to a pandas data
    structure. The most common index we’ve encountered so far is the `RangeIndex`,
    a sequence of ascending or descending numeric values. We can access the index
    of a `Series` or a `DataFrame` via the `index` attribute:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*索引* 是附加到 pandas 数据结构上的标识标签集合。我们迄今为止遇到的最常见的索引是 `RangeIndex`，它是一系列升序或降序的数值。我们可以通过
    `index` 属性访问 `Series` 或 `DataFrame` 的索引：'
- en: '[PRE21]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Pandas uses an `Index` object to store a collection of string labels. In the
    next example, notice that the index object pandas attaches to a `Series` changes
    based on its contents:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas 使用一个 `Index` 对象来存储一系列字符串标签。在下一个示例中，请注意 pandas 附加到 `Series` 的索引对象会根据其内容而变化：
- en: '[PRE22]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `DatetimeIndex` is an index for storing `Timestamp` objects. If we pass
    a list of `Timestamp`s to the `Series` constructor’s `index` parameter, pandas
    will attach a `DatetimeIndex` to the `Series`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`DatetimeIndex` 是用于存储 `Timestamp` 对象的索引。如果我们向 `Series` 构造函数的 `index` 参数传递一个
    `Timestamp`s 的列表，pandas 将将 `DatetimeIndex` 附加到 `Series`：'
- en: '[PRE23]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Pandas will also use a `DatetimeIndex` if we pass a list of Python `datetime`
    objects:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们传递一个 Python `datetime` 对象的列表，Pandas 也会使用 `DatetimeIndex`：
- en: '[PRE24]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can also create a `DatetimeIndex` from scratch. Its constructor is available
    at the top level of pandas. The constructor’s `data` parameter accepts any iterable
    collection of dates. We can pass the dates as strings, datetimes, `Timestamp`s,
    or even a mix of data types. Pandas will convert all values to equivalent `Timestamp`s
    and store them within the index:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以从头创建一个 `DatetimeIndex`。其构造函数位于 pandas 的顶层。构造函数的 `data` 参数接受任何日期的可迭代集合。我们可以将日期作为字符串、datetimes、`Timestamp`s
    或甚至数据类型的混合传递。Pandas 将将所有值转换为等效的 `Timestamp`s 并存储在索引中：
- en: '[PRE25]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now that we have a `DatetimeIndex` assigned to a `dt_index` variable, let’s
    attach it to a pandas data structure. The next example connects the index to a
    sample `Series`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将 `DatetimeIndex` 分配给 `dt_index` 变量，让我们将其附加到 pandas 数据结构中。下一个示例将索引连接到一个样本
    `Series`：
- en: '[PRE26]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Date- and time-related operations become possible in pandas only when we store
    our values as `Timestamp`s rather than strings. Pandas can’t deduce a day of the
    week from a string like `"2018-01-02"` because it views it as being a collection
    of digits and dashes, not an actual date. That’s why it’s imperative to convert
    all relevant string columns to datetimes when importing a data set for the first
    time.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当我们将值存储为 `Timestamp`s 而不是字符串时，pandas 才能执行日期和时间相关的操作。Pandas 无法从像 `"2018-01-02"`
    这样的字符串中推断出星期几，因为它将其视为数字和短划线的集合，而不是实际的日期。这就是为什么在第一次导入数据集时，将所有相关字符串列转换为日期时间至关重要：
- en: 'We can use the `sort_index` method to sort a `DatetimeIndex` in ascending or
    descending order. The next example sorts the index dates in ascending order (earliest
    to latest):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `sort_index` 方法按升序或降序排序 `DatetimeIndex`。下一个示例按升序（从最早到最新）排序索引日期：
- en: '[PRE27]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Pandas accounts for both date and time when sorting or comparing datetimes.
    If two `Timestamp`s use the same date, pandas will compare their hours, minutes,
    seconds, and so on.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas 在排序或比较日期时间时考虑日期和时间。如果两个 `Timestamp`s 使用相同的日期，pandas 将比较它们的时、分、秒等：
- en: 'A variety of sorting and comparison operations are available for `Timestamp`s
    out of the box. The less-than symbol ( `<` ) , for example, checks whether one
    `Timestamp` occurs earlier than another:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Timestamp`s，有各种排序和比较操作可用。例如，小于符号（`<`）检查一个 `Timestamp` 是否早于另一个：
- en: '[PRE28]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In section 11.7, we’ll learn how to apply these types of comparisons to all
    values in a `Series`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在 11.7 节中，我们将学习如何将这些类型的比较应用于 `Series` 中的所有值。
- en: 11.3 Converting column or index values to datetimes
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.3 将列或索引值转换为日期时间
- en: 'Our first data set for this chapter, disney.csv, holds nearly 60 years’ worth
    of stock prices for the Walt Disney Company, one of the world’s most recognized
    entertainment brands. Each row includes a date, the stock’s highest and lowest
    value throughout that day, and its opening and closing price:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本章的第一个数据集，disney.csv，包含了华特迪士尼公司近60年的股价，这是世界上最知名娱乐品牌之一。每一行包括一个日期，该日股票的最高价和最低价，以及开盘价和收盘价：
- en: '[PRE29]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `read_csv` function defaults to importing all values in non-numeric columns
    as strings. We can access the `dtypes` attribute on the `DataFrame` to see the
    columns’ data types. Notice that the Date column has a data type of `"object"`,
    the pandas designation for a string:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`read_csv` 函数默认将非数字列的所有值导入为字符串。我们可以通过 `DataFrame` 的 `dtypes` 属性来查看列的数据类型。注意，日期列的数据类型为
    `"object"`，这是 pandas 对字符串的指定：'
- en: '[PRE30]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We must explicitly tell pandas which columns’ values to convert to datetimes.
    One option we’ve seen before is the `read_csv` function’s `parse_dates` parameter,
    introduced in chapter 3\. We can pass the parameter a list of columns whose values
    pandas should convert to datetimes:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须明确告诉 pandas 哪些列的值要转换为日期时间。我们之前看到的一个选项是 `read_csv` 函数的 `parse_dates` 参数，它在第
    3 章中引入。我们可以将参数传递给一个列表，其中包含 pandas 应将其值转换为日期时间的列：
- en: '[PRE31]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'An alternative solution is the `to_datetime` conversion function at the top
    level of pandas. The function accepts an iterable object (such as a Python list,
    tuple, `Series`, or index), converts its values to datetimes, and returns the
    new values in a `DatetimeIndex`. Here’s a small example:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个解决方案是pandas顶层中的`to_datetime`转换函数。该函数接受一个可迭代对象（例如Python列表、元组、`Series`或索引），将其值转换为日期时间，并返回新的值在一个`DatetimeIndex`中。以下是一个小例子：
- en: '[PRE32]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let’s pass the Date `Series` from the disney `DataFrame` to the `to_datetime`
    function:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把来自disney `DataFrame`的日期`Series`传递给`to_datetime`函数：
- en: '[PRE33]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We’ve got a `Series` of datetimes, so let’s overwrite the original `DataFrame`.
    The next code sample replaces the original Date column with the new datetime `Series`.
    Remember that Python evaluates the right side of an equal sign first:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个日期时间的`Series`，所以让我们覆盖原始`DataFrame`。接下来的代码示例将原始日期列替换为新的日期时间`Series`。记住，Python首先评估等号右侧的表达式：
- en: '[PRE34]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let’s check on the Date column again via the `dtypes` attribute:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次通过`dtypes`属性检查日期列：
- en: '[PRE35]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Excellent; we have a datetime column! With our Date values stored correctly,
    we can explore the powerful datetime functionalities that pandas provides out
    of the box.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了；我们有一个日期时间列！我们的日期值存储正确后，我们可以探索pandas提供的强大的内置日期时间功能。
- en: 11.4 Using the DatetimeProperties object
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.4 使用DatetimeProperties对象
- en: 'A datetime `Series` holds a special `dt` attribute that exposes a `DatetimeProperties`
    object:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一个日期时间`Series`包含一个特殊的`dt`属性，它暴露了一个`DatetimeProperties`对象：
- en: '[PRE36]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We can access attributes and invoke methods on the `DatetimeProperties` object
    to extract information from the columns’ datetime values. The `dt` attribute is
    to datetimes what the `str` attribute is to strings. (See chapter 6 for a review
    of `str`.) Both attributes specialize in manipulations of a specific type of data.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`DatetimeProperties`对象上访问属性并调用方法来从列的日期时间值中提取信息。`dt`属性对于日期时间就像`str`属性对于字符串一样。（参见第6章对`str`的回顾。）这两个属性都专门用于特定类型数据的操作。
- en: 'Let’s begin our exploration of the `DatetimeProperties` object with the `day`
    attribute, which pulls out the day from each date. Pandas returns the values in
    a new `Series`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`DatetimeProperties`对象的`day`属性开始探索，该属性从每个日期中提取出天。Pandas返回值在一个新的`Series`中：
- en: '[PRE37]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `month` attribute returns a `Series` with the month numbers. January has
    a `month` value of `1`, February has a `month` value of `2`, and so on. It’s important
    to note that this is different from how we typically count in Python/pandas, where
    we assign the first item a value of `0`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`month`属性返回一个包含月份数字的`Series`。1月有`month`值为`1`，2月有`month`值为`2`，依此类推。需要注意的是，这与我们在Python/pandas中通常的计数方式不同，在那里我们给第一个元素分配值为`0`：'
- en: '[PRE38]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `year` attribute returns a new `Series` with the years:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`year`属性返回一个新的包含年份的`Series`：'
- en: '[PRE39]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The previous attributes are pretty simple. We can ask pandas to extract more-interesting
    pieces of information. One example is the `dayofweek` attribute, which returns
    a `Series` of numbers for each date’s day of the week. `0` denotes Monday, `1`
    denotes Tuesday, and so on up to `6` for Sunday. In the following output, the
    value of `1` at index position 0 indicates that January 2, 1962, fell on a Tuesday:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的属性相当简单。我们可以要求pandas提取更有趣的信息。一个例子是`dayofweek`属性，它返回每个日期星期数的`Series`。`0`表示星期一，`1`表示星期二，以此类推，直到`6`表示星期日。在以下输出中，索引位置0处的`1`值表示1962年1月2日是星期二：
- en: '[PRE40]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'What if we wanted the weekday’s name instead of its number? The `day_name`
    method does the trick. Be careful with the syntax. We invoke the method on the
    `dt` object, not on the `Series` itself:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要的是星期的名称而不是数字，那么`day_name`方法就能派上用场。注意语法。我们是在`dt`对象上调用这个方法，而不是在`Series`本身上：
- en: '[PRE41]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can pair these `dt` attributes and methods with other pandas features for
    advanced analyses. Here’s an example. Let’s calculate the average performance
    of Disney’s stock by weekday. We’ll begin by attaching the `Series` returned from
    the `dt.day_name` method to the disney `DataFrame`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这些`dt`属性和方法与其他pandas功能结合使用进行高级分析。以下是一个例子。让我们计算迪士尼股票按星期的平均表现。我们将首先将`dt.day_name`方法返回的`Series`附加到disney
    `DataFrame`上：
- en: '[PRE42]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We can group the rows based on the values in the new Day of Week column (a
    technique introduced in chapter 7):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据新星期几列的值对行进行分组（这是一种在第7章中介绍的技术）：
- en: '[PRE43]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can invoke the `GroupBy` object’s `mean` method to calculate the average
    of values for each grouping:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以调用`GroupBy`对象的`mean`方法来计算每个分组的值的平均值：
- en: '[PRE44]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In three lines of code, we’ve calculated the average stock performance by day
    of week.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在三行代码中，我们计算了按周计算的平均股票表现。
- en: 'Let’s come back to `dt` object methods. The complementary `month_name` method
    returns a `Series` with the dates’ month names:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到`dt`对象方法。补充的`month_name`方法返回包含日期月份名称的`Series`：
- en: '[PRE45]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Some attributes on the `dt` object return Booleans. Suppose that we want to
    explore Disney’s stock performance at the start of each quarter in its history.
    The four quarters of a business year start on January 1, April 1, July 1, and
    October 1\. The `is_quarter_start` attribute returns a Boolean `Series` in which
    `True` denotes that the row’s date fell on a quarter start day:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`dt`对象上的一些属性返回布尔值。假设我们想探索迪士尼在其历史中每个季度的股票表现。商业年的四个季度分别从1月1日、4月1日、7月1日和10月1日开始。`is_quarter_start`属性返回一个布尔`Series`，其中`True`表示该行的日期落在季度开始日：'
- en: '[PRE46]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We can use the Boolean `Series` to extract the disney rows that fell at the
    beginning of a quarter. The next example uses the familiar square-bracket syntax
    to pull out the rows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用布尔`Series`来提取在季度开始时掉落的迪士尼行。下一个示例使用熟悉的方括号语法来提取行：
- en: '[PRE47]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We can use the `is_quarter_end` attribute to pull out dates that fell at the
    end of a quarter:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`is_quarter_end`属性来提取在季度结束时掉落的日期：
- en: '[PRE48]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The complementary `is_month_start` and `is_month_end` attributes confirm that
    a date fell at the beginning or end of a month:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 补充的`is_month_start`和`is_month_end`属性确认日期是在月份的开始或结束：
- en: '[PRE49]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `is_year_start` attribute returns `True` if a date falls at the start of
    a year. The next example returns an empty `DataFrame`; the stock market is closed
    on New Year’s Day, so no dates in the data set fit the criteria:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`is_year_start`属性如果日期在年初，则返回`True`。下一个示例返回一个空的`DataFrame`；由于新年那天股市关闭，数据集中的日期都不符合标准：'
- en: '[PRE50]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The complementary `is_year_end` attribute returns `True` if a date falls at
    the end of a year:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 补充的`is_year_end`属性如果日期在年底，则返回`True`：
- en: '[PRE51]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Regardless of the attribute, the filtering process remains the same: create
    a Boolean `Series` and then pass it inside square brackets after the `DataFrame`.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 无论属性如何，过滤过程都保持不变：创建一个布尔`Series`，然后将其传递到`DataFrame`后面的方括号内。
- en: 11.5 Adding and subtracting durations of time
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.5 添加和减去时间持续时间
- en: 'We can add or subtract consistent durations of time with the `DateOffset` object.
    Its constructor is available at the top level of pandas. The constructor accepts
    parameters for `years`, `months`, `days`, and more. The next example models a
    time of three years, four months, and three days:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`DateOffset`对象添加或减去一致的时间持续时间。其构造函数在pandas的顶层可用。构造函数接受`years`、`months`、`days`等参数。下一个示例模拟了三年、四个月和三天的时间：
- en: '[PRE52]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Here’s a reminder of the first five rows of the disney `DataFrame`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是迪士尼`DataFrame`前五行的提醒：
- en: '[PRE53]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'For the sake of example, let’s imagine that our recordkeeping system malfunctioned,
    and the dates in the Date column are off by five days. We can add a consistent
    amount of time to each date in a datetime `Series` with a plus sign (`+`) and
    a `DateOffset` object. The plus sign means “move forward” or “into the future.”
    The next example adds five days to each date in the Date column:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了举例，让我们假设我们的记录系统出现故障，日期列中的日期偏差了五天。我们可以使用加号（`+`）和`DateOffset`对象向日期时间`Series`中的每个日期添加一个一致的时间量。加号表示“向前移动”或“进入未来。”下一个示例将日期列中的每个日期增加五天：
- en: '[PRE54]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'When paired with a `DateOffset`, the minus sign (`-`) subtracts a duration
    from each date in a datetime `Series`. The minus sign means “move backward” or
    “into the past.” The next example moves each date back three days:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当与`DateOffset`一起使用时，减号（`-`）从日期`Series`中的每个日期减去一个持续时间。减号表示“向后移动”或“进入过去。”下一个示例将每个日期向后移动三天：
- en: '[PRE55]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Although the previous output does not show it, the `Timestamp` objects *do*
    store a time internally. When we converted the Date column’s values to datetimes,
    pandas assumed a time of midnight for each date. The next example adds an `hours`
    parameter to the `DateOffset` constructor to add a consistent time to each datetime
    in Date. The resulting `Series` displays the date and time:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前面的输出没有显示，但`Timestamp`对象确实内部存储时间。当我们将日期列的值转换为日期时间时，pandas假设每个日期的时间为午夜。下一个示例向`DateOffset`构造函数添加一个`hours`参数，以向日期中的每个日期时间添加一个一致的时间。结果`Series`显示日期和时间：
- en: '[PRE56]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Pandas applies the same logic when subtracting a duration. The next example
    subtracts one year, three months, ten days, six hours, and three minutes from
    each date:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas在减去持续时间时应用相同的逻辑。下一个示例从每个日期减去一年、三个月、十天、六小时和三分钟：
- en: '[PRE57]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The `DateOffset` constructor supports additional keyword parameters for seconds,
    microseconds, and nanoseconds. See the pandas documentation for more info.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`DateOffset`构造函数支持额外的秒、微秒和纳秒关键字参数。有关更多信息，请参阅pandas文档。'
- en: 11.6 Date offsets
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.6 日期偏移
- en: The `DateOffset` object is optimal for adding or subtracting a consistent amount
    of time to or from each date. Real-world analyses often demand a more dynamic
    calculation. Let’s say we want to round each date to the end of its current month.
    Each date is a different number of days from the end of its month, so a consistent
    `DateOffset` addition won’t suffice.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`DateOffset`对象对于向每个日期添加或减去固定的时间量是最优的。现实世界的分析通常需要更动态的计算。假设我们想要将每个日期四舍五入到当前月的月底。每个日期距离其月底的天数不同，因此一致的`DateOffset`添加是不够的。'
- en: 'Pandas ships with prebuilt offset objects for dynamic time-based calculations.
    These objects are defined in `offsets.py`, a module within the library. In our
    code, we have to prefix these offsets with their complete path: `pd.offsets`.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas提供了预构建的偏移对象，用于动态的时间计算。这些对象定义在库中的`offsets.py`模块中。在我们的代码中，我们必须使用它们的完整路径作为前缀：`pd.offsets`。
- en: 'One sample offset is `MonthEnd`, which rounds each date to the next month-end.
    Here’s a refresher on the last five rows in the Date column:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例偏移量是`MonthEnd`，它将每个日期四舍五入到下个月的月底。这里是对日期列最后五行的复习：
- en: '[PRE58]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We can apply the addition and subtraction syntax from section 11.5 to pandas’
    offset objects. The next example returns a new `Series` that rounds each datetime
    to the month-end. The plus sign moves forward in time, so we move to the next
    month-end:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将第11.5节中的加法和减法语法应用于pandas的偏移对象。下一个示例返回一个新的`Series`，将每个日期时间四舍五入到月底。加号表示时间向前移动，因此我们移动到下个月的月底：
- en: '[PRE59]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: There has to be some movement in the intended direction. Pandas cannot round
    a date to the same date. Thus, if a date falls at the end of a month, the library
    rounds it to the end of the following month. Pandas rounds 2020-06-30 at index
    position 14724 to 2020-07-31, the next available month-end.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 必须在预期的方向上有所移动。Pandas不能将日期四舍五入到相同的日期。因此，如果一个日期位于月底，库会将其四舍五入到下个月的月底。Pandas将索引位置14724处的2020-06-30四舍五入到2020-07-31，即下一个可用的月底。
- en: 'The minus sign moves each date backward in time. The next example uses the
    `MonthEnd` offset to round the dates to the previous month-end. Pandas rounds
    the first three dates (2020-06-26, 2020-06-29, and 2020-06-30) to 2020-05-31,
    the last day in May. It rounds the final two dates (2020-07-01 and 2020-07-02)
    to 2020-06-30, the last day in June:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 减号将每个日期向后移动。下一个示例使用`MonthEnd`偏移量将日期四舍五入到上个月的月底。Pandas将前三个日期（2020-06-26、2020-06-29和2020-06-30）四舍五入到5月的最后一天，即2020-05-31。它将最后两个日期（2020-07-01和2020-07-02）四舍五入到6月的最后一天，即2020-06-30：
- en: '[PRE60]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The complementary `MonthBegin` offset rounds to the first date of a month.
    The next example uses a `+` sign to round each date to the next month’s beginning.
    Pandas rounds the first three dates (2020-06-26, 2020-06-29, and 2020-06-30) to
    2020-07-01, the beginning of July. Pandas rounds the two remaining July dates
    (2020-07-01 and 2020-07-02) to 2020-08-01, the first day of August:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 相补的`MonthBegin`偏移量将四舍五入到一个月的第一天。下一个示例使用加号`+`将每个日期四舍五入到下个月的第一天。Pandas将前三个日期（2020-06-26、2020-06-29和2020-06-30）四舍五入到7月的开始，即2020-07-01。Pandas将剩下的两个7月日期（2020-07-01和2020-07-02）四舍五入到8月的第一天，即2020-08-01：
- en: '[PRE61]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We can pair the `MonthBegin` offset with the minus sign to round dates backward
    to the beginning of a month. In the next example, pandas rounds the first three
    dates (2020-06-26, 2020-06-29, and 2020-06-30) to the start of June, 2020-06-01\.
    It rounds the last date, 2020-07-02, to the beginning of July, 2020-07-01\. The
    curious case is 2020-07-01 at index position 14725\. As we mentioned earlier,
    pandas cannot round a date to the same date. There has to be some movement backward,
    so pandas rounds to the previous month’s start, 2020-06-01:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`MonthBegin`偏移量与减号结合使用，将日期回滚到月份的开始。在下一个示例中，pandas将前三个日期（2020-06-26、2020-06-29和2020-06-30）回滚到2020年6月1日，即6月的开始。它将最后一个日期，2020-07-02，回滚到7月的开始，即2020-07-01。一个有趣的情况是索引位置14725处的2020-07-01。正如我们之前提到的，pandas不能将日期回滚到相同的日期。因此，必须有一些回滚的动作，所以pandas将其回滚到上个月的开头，即2020-06-01：
- en: '[PRE62]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: A special group of offsets is available for business time calculations; their
    names begin with a capital `"B"`. The Business Month End (`BMonthEnd`) offset,
    for example, rounds to the month’s last business day. The five business days are
    Monday, Tuesday, Wednesday, Thursday, and Friday.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对于商业时间计算，有一组特殊的偏移量可用；它们的名称以大写 `"B"` 开头。例如，商业月末 (`BMonthEnd`) 偏移量将四舍五入到该月的最后工作日。这五个工作日是星期一、星期二、星期三、星期四和星期五。
- en: 'Consider the following `Series` of three datetimes. The three dates fall on
    Thursday, Friday, and Saturday, respectively:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下三个日期时间的 `Series`。这三个日期分别落在星期四、星期五和星期六：
- en: '[PRE63]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Let’s compare the `MonthEnd` and `BMonthEnd` offsets. When we pair the `MonthEnd`
    offset with a plus sign, pandas rounds all three dates to the last day of May,
    2020-05-31\. Whether that date falls on a business day or the weekend is irrelevant:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较 `MonthEnd` 和 `BMonthEnd` 偏移量。当我们用加号搭配 `MonthEnd` 偏移量时，pandas 将所有三个日期四舍五入到
    2020 年 5 月的最后一天，即 2020-05-31。无论这个日期是否是工作日或周末都无关紧要：
- en: '[PRE64]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The `BMonthEnd` offset returns a different set of results. The last business
    day of May 2020 is Friday, May 29\. Pandas rounds the first date in the `Series`,
    2020-05-28, to the 29th. The next date, 2020-05-29, falls *on* the month’s last
    business date. Pandas cannot round a date to the same date, so it rounds 2020-05-29
    to June’s last business day, 2020-06-30, a Tuesday. The last date in the `Series`,
    2020-05-30, is a Saturday. No business days are left in May, so pandas similarly
    rounds the date to June’s last business day, 2020-06-30:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`BMonthEnd` 偏移量返回不同的结果集。2020 年 5 月的最后工作日是星期五，5 月 29 日。Pandas 将 `Series` 中的第一个日期，2020-05-28，四舍五入到
    29 日。下一个日期，2020-05-29，正好是该月的最后工作日。Pandas 不能将日期四舍五入到相同的日期，所以它将 2020-05-29 四舍五入到
    6 月的最后工作日，即 2020-06-30，星期二。`Series` 中的最后一个日期，2020-05-30，是星期六。5 月没有剩余的工作日，所以 pandas
    同样将日期四舍五入到 6 月的最后工作日，即 2020-06-30：'
- en: '[PRE65]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The `pd.offsets` module includes additional offsets for rounding to the starts
    and ends of quarters, business quarters, years, business years, and more. Feel
    free to explore them in your free time.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`pd.offsets` 模块包括额外的偏移量，用于四舍五入到季度、商业季度、年份、商业年份等的开始和结束。请在你的空闲时间自由探索它们。'
- en: 11.7 The Timedelta object
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.7 `Timedelta` 对象
- en: You may recall Python’s native `timedelta` object from earlier in the chapter.
    A `timedelta` models duration—the distance between two times. A duration such
    as one hour represents a length of time; it does not have a specific date or time
    attached. Pandas models a duration with its own `Timedelta` object.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得本章前面提到的 Python 的原生 `timedelta` 对象。`timedelta` 模型了持续时间——两个时间点之间的距离。像一小时这样的持续时间表示时间的长度；它没有特定的日期或时间。Pandas
    使用自己的 `Timedelta` 对象来模型持续时间。
- en: NOTE It’s easy to confuse the two objects. `timedelta` is built into Python,
    whereas `Timedelta` is built into pandas. The two are interchangeable when used
    with pandas operations.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：这两个对象很容易混淆。`timedelta` 是 Python 内置的，而 `Timedelta` 是 pandas 内置的。当与 pandas
    操作一起使用时，这两个对象是可以互换的。
- en: 'The `Timedelta` constructor is available at the top level of pandas. It accepts
    keyword parameters for units of time such as `days`, `hours`, `minutes`, and `seconds`.
    The next example instantiates a `Timedelta` modeling eight days, seven hours,
    six minutes, and five seconds:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`Timedelta` 构造函数在 pandas 顶层可用。它接受时间单位的键控参数，如 `days`、`hours`、`minutes` 和 `seconds`。下一个示例实例化了一个
    `Timedelta`，它模型了八天、七小时、六分钟和五秒：'
- en: '[PRE66]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The `to_timedelta` function at the top level of pandas converts its argument
    to a `Timedelta` object. We can pass in a string, as in the next example:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: pandas 顶层中的 `to_timedelta` 函数将它的参数转换为 `Timedelta` 对象。我们可以传递一个字符串，如下一个示例所示：
- en: '[PRE67]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We can also pass an integer to the `to_timedelta` function along with a `unit`
    parameter. The `unit` parameter declares the unit of time that the number represents.
    Accepted arguments include `"hour"`, `"day"`, and `"minute"`. The next example’s
    `Timedelta` models a five-hour duration:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将一个整数和一个 `unit` 参数一起传递给 `to_timedelta` 函数。`unit` 参数声明了数字所代表的时间单位。接受的参数包括
    `"hour"`、`"day"` 和 `"minute"`。下一个示例中的 `Timedelta` 模型了一个五小时的持续时间：
- en: '[PRE68]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We can pass an iterable object such as a list to the `to_timedelta` function
    to convert its values to `Timedeltas`. Pandas will store the `Timedeltas` in a
    `TimedeltaIndex`, a pandas index for storing durations:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将一个可迭代对象，如列表，传递给 `to_timedelta` 函数，将其值转换为 `Timedeltas`。Pandas 将 `Timedeltas`
    存储在 `TimedeltaIndex` 中，这是一个用于存储持续时间的 pandas 索引：
- en: '[PRE69]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Usually, `Timedelta` objects are derived rather than created from scratch.
    The subtraction of one `Timestamp` from another, for example, returns a `Timedelta`
    automatically:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`Timedelta` 对象是从头创建的，而不是从头创建的。例如，从一个 `Timestamp` 减去另一个 `Timestamp` 会自动返回一个
    `Timedelta`：
- en: '[PRE70]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now that we’ve gotten acquainted with `Timedelta`s, let’s import our second
    data set for the chapter: deliveries.csv. The CSV tracks product shipments for
    a fictional company. Each row includes an order date and a delivery date:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了 `Timedelta`，让我们导入本章的第二个数据集：deliveries.csv。CSV 跟踪一家虚构公司的产品运输。每一行包括订单日期和交货日期：
- en: '[PRE71]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Let’s practice converting the values in the two columns to datetimes. Yes,
    we can use the `parse_dates` parameter, but let’s try another approach. One option
    is invoking the `to_datetime` function twice, once for the order_date column and
    once for the delivery_date column, and overwriting the existing `DataFrame` columns:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们练习将两个列中的值转换为日期时间。是的，我们可以使用 `parse_dates` 参数，但让我们尝试另一种方法。一个选项是两次调用 `to_datetime`
    函数，一次用于订单日期列，一次用于交货日期列，并覆盖现有的 `DataFrame` 列：
- en: '[PRE72]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'A more scalable solution is to iterate over the column names with a `for` loop.
    We can reference a deliveries column dynamically, use `to_datetime` to create
    a `DatetimeIndex` of `Timestamps` from it, and then overwrite the original column:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更可扩展的解决方案是使用 `for` 循环遍历列名。我们可以动态地引用一个交货列，使用 `to_datetime` 从它创建一个 `Timestamps`
    的 `DatetimeIndex`，然后覆盖原始列：
- en: '[PRE73]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Let’s take a look at deliveries. The new column format confirms that we’ve
    converted the strings to datetimes:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看交货情况。新的列格式确认我们已经将字符串转换为日期时间：
- en: '[PRE74]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Let’s calculate the duration of each shipment. With pandas, this calculation
    is as simple as subtracting the order_date column from the delivery_date column:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来计算每批货物的持续时间。使用pandas，这个计算就像从订单日期列减去交货日期列一样简单：
- en: '[PRE75]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Pandas returns a `Series` of `timedelta`s. Let’s attach the new `Series` to
    the end of the deliveries `DataFrame`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas 返回一个 `timedelta` 的 `Series`。让我们将这个新的 `Series`附加到交货 `DataFrame` 的末尾：
- en: '[PRE76]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Now we have two `Timestamp` columns and one `Timedelta` column:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个 `Timestamp` 列和一个 `Timedelta` 列：
- en: '[PRE77]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'We can add or subtract `Timedelta`s from `Timestamp` objects. The next example
    subtracts each row’s duration from the delivery_date column. Predictably, the
    values in the new `Series` are identical to the values in the order_date column:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从 `Timestamp` 对象中添加或减去 `Timedelta`。下一个示例从每行的持续时间中减去交货日期列。可预测的是，新 `Series`
    中的值与订单日期列中的值相同：
- en: '[PRE78]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'A plus symbol adds a `Timedelta` to a `Timestamp`. Let’s say we wanted to find
    the date of delivery if each package took twice as long to arrive. We can add
    the `Timedelta` values in the duration column to the `Timestamp` values in the
    delivery_date column:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 加号符号将 `Timedelta` 添加到 `Timestamp`。假设我们想找到每个包裹需要两倍时间到达的交货日期。我们可以将持续时间列中的 `Timedelta`
    值添加到交货日期列中的 `Timestamp` 值：
- en: '[PRE79]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The `sort_values` method works with `Timedelta` `Series`. The next example
    sorts the duration column in ascending order, from the shortest delivery to the
    longest one:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort_values` 方法与 `Timedelta` `Series` 一起工作。下一个示例按升序对持续时间列进行排序，从最短的交货到最长的交货：'
- en: '[PRE80]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Mathematical methods are also available on `Timedelta` `Series`. The next few
    examples highlight three methods we’ve used throughout the book: `max` for the
    largest value, `min` for the smallest value, and `mean` for the average:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 数学方法也适用于 `Timedelta` `Series`。接下来的几个示例突出了我们在本书中使用的三种方法：`max` 用于最大值，`min` 用于最小值，`mean`
    用于平均值：
- en: '[PRE81]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Here’s the next challenge. Let’s filter the `DataFrame` for packages that took
    more than a year to deliver. We can use the greater-than symbol (`>`) to compare
    each duration column value to a fixed duration. We can specify the length of time
    as a `Timedelta` or as a string. The next example uses `"365 days"`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这是下一个挑战。让我们过滤 `DataFrame`，以找到交货时间超过一年的包裹。我们可以使用大于符号 (`>`) 来比较每个持续时间列的值与固定持续时间。我们可以将时间长度指定为
    `Timedelta` 或字符串。下一个示例使用 `"365 days"`：
- en: '[PRE82]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Let’s use the Boolean `Series` to filter for the `deliveries` rows with a delivery
    time greater than 365 days:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用布尔 `Series` 过滤出交货时间超过365天的 `deliveries` 行：
- en: '[PRE83]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'We can get as granular as needed with the comparison duration. The next example
    includes the days, hours, and minutes in the string, separating the units of time
    with commas:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据需要将比较持续时间细化。下一个示例包括字符串中的天数、小时和分钟，用逗号分隔时间单位：
- en: '[PRE84]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: As a reminder, Pandas can sort `Timedelta` columns. To discover the longest
    or shortest durations, we can invoke the `sort_values` method on the duration
    `Series`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，Pandas 可以对 `Timedelta` 列进行排序。要发现最长或最短时长，我们可以在时长 `Series` 上调用 `sort_values`
    方法。
- en: 11.8 Coding challenge
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.8 编程挑战
- en: Here’s your chance to practice the concepts introduced in this chapter.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这是练习本章引入的概念的机会。
- en: 11.8.1 Problems
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.8.1 问题
- en: 'Citi Bike NYC is New York City’s official bike-sharing program. Residents and
    tourists can pick up and drop off bicycles at hundreds of locations around the
    city. Ride data is publicly available and released monthly by the city at [https://www.citibikenyc.com/system-data](https://www.citibikenyc.com/system-data).
    citibike.csv is a collection of ~1.9 million rides that cyclists took in June
    2020\. For simplicity’s sake, the data set has been modified from its original
    version and includes only two columns: each ride’s start time and end time. Let’s
    import the data set and assign it to a `citi_bike` variable:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Citi Bike NYC 是纽约市的官方自行车共享计划。居民和游客可以在城市数百个地点取车和还车。骑行数据是公开的，由市政府每月发布，网址为 [https://www.citibikenyc.com/system-data](https://www.citibikenyc.com/system-data)。citibike.csv
    是 2020 年 6 月骑行的约 190 万次骑行数据的集合。为了简化，数据集已从原始版本修改，仅包括两个列：每次骑行的开始时间和结束时间。让我们导入数据集并将其分配给
    `citi_bike` 变量：
- en: '[PRE85]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The datetime entries in the start_time and stop_time columns include the year,
    month, day, hour, minute, second, and microsecond. (A *microsecond* is a unit
    of time equal to one millionth of a second.)
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: start_time 和 stop_time 列中的 datetime 条目包括年、月、日、时、分、秒和微秒。（*微秒*是等于一百万分之一秒的时间单位。）
- en: 'We can use the `info` method to print a summary that includes the `DataFrame`’s
    length, the columns’ data types, and the memory use. Notice that pandas has imported
    the two columns’ values as strings:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `info` 方法打印一个摘要，包括 `DataFrame` 的长度、列的数据类型和内存使用情况。注意，pandas 已经将两个列的值作为字符串导入：
- en: '[PRE86]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Here are the challenges for this section:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这是练习本章引入的概念的机会。
- en: Convert the start_time and stop_time columns to store datetime (`Timestamp`)
    values instead of strings.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 start_time 和 stop_time 列转换为存储 datetime (`Timestamp`) 值而不是字符串。
- en: Count the rides that occurred on each day of the week (Monday, Tuesday, and
    so on). Which weekday is the most popular for a bike ride? Use the start_time
    column as your starting point.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算每周每天（周一、周二等）发生的骑行次数。哪一天是骑行最受欢迎的工作日？以 start_time 列作为起点。
- en: Count the rides per week for each week within the month. To do so, round each
    date in the start_time column to its previous or current Monday. Assume that each
    week starts on a Monday and ends on a Sunday. Thus, the first week of June would
    be Monday, June 1 through Sunday, June 7.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算每月每周内每周的骑行次数。为此，将 start_time 列中的每个日期四舍五入到其前一个或当前的周一。假设每周从周一开始，周日结束。因此，六月的第一个星期是
    6 月 1 日星期一到 6 月 7 日星期日。
- en: Calculate the duration of each ride, and save the results to a new duration
    column.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算每次骑行的时长，并将结果保存到一个新的时长列中。
- en: Find the average duration of a bike ride.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找一次骑行的平均时长。
- en: Extract the five longest bike rides by duration from the data set.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从数据集中提取按时长排序的前五次最长骑行。
- en: 11.8.2 Solutions
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.8.2 解决方案
- en: 'Let’s tackle the problems one by one:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个解决这些问题：
- en: 'The `to_datetime` conversion function at the top level of pandas works well
    to convert the start_time and end_time columns’ values to `Timestamps`. The next
    code sample iterates over a list of the column names with a `for` loop, passes
    each column into the `to_datetime` function, and overwrites the existing string
    column with the new datetime `Series`:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: pandas 顶层中的 `to_datetime` 转换函数可以很好地将 start_time 和 end_time 列的值转换为 `Timestamps`。下面的代码示例使用
    `for` 循环遍历列名列表，将每个列传递给 `to_datetime` 函数，并用新的 datetime `Series` 覆盖现有的字符串列：
- en: '[PRE87]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Let’s invoke the `info` method again to confirm that the two columns store
    datetime values:'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们再次调用 `info` 方法来确认这两个列存储的是 datetime 值：
- en: '[PRE88]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'We’ll have to take two steps to count the number of bike rides per weekday.
    First, we extract the weekday from each datetime in the start_time column; then
    we count the weekdays’ occurrences. The `dt.day_name` method returns a `Series`
    with the weekday names for each date:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要分两步来计算每周的骑行次数。首先，我们从 start_time 列中的每个 datetime 提取星期几；然后计算星期几的出现次数。`dt.day_name`
    方法返回一个包含每个日期星期几名称的 `Series`：
- en: '[PRE89]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Then we can invoke the trusty `value_counts` method on the returned `Series`
    to count the weekdays. In June 2020, Tuesday was the most popular day for a bike
    ride:'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们可以在返回的 `Series` 上调用可靠的 `value_counts` 方法来计算工作日。在 2020 年 6 月，星期二是最受欢迎的骑行日：
- en: '[PRE90]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The next challenge requires us to group each date into its corresponding week
    bucket. We can do so by rounding the date to its previous or current Monday. Here’s
    a clever solution: we can use the `dayofweek` attribute to return a `Series` of
    numbers. `0` denotes Monday, `1` denotes Tuesday, `6` denotes Sunday, and so on:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个挑战要求我们将每个日期分组到其对应的周桶中。我们可以通过将日期四舍五入到其前一个或当前星期一来实现。这里有一个巧妙的解决方案：我们可以使用 `dayofweek`
    属性来返回一个数字 `Series`。`0` 表示星期一，`1` 表示星期二，`6` 表示星期日，依此类推：
- en: '[PRE91]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The weekday number also represents the distance in days from the closest Monday.
    Monday, June 1, for example, has a `dayofweek` value of `0`. The date is 0 days
    away from the closest Monday. Similarly, Tuesday, June 2, has a `dayofweek` value
    of 1\. The date is one day away from the closest Monday (June 1). Let’s save this
    `Series` to a `days_away_from_monday` variable:'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 星期几的数字也代表从最近的星期一到当前日期的天数距离。例如，6 月 1 日的星期一有 `dayofweek` 值为 `0`。该日期距离最近的星期一有 0
    天。同样，6 月 2 日的星期二有 `dayofweek` 值为 1。该日期距离最近的星期一（6 月 1 日）有 1 天。让我们将这个 `Series` 保存到
    `days_away_from_monday` 变量中：
- en: '[PRE92]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'If we subtract a date’s `dayofweek` value from the date itself, we’ll effectively
    round each date to its previous Monday. We can pass the `dayofweek` `Series` into
    the `to_timedelta` function to convert it to a `Series` of durations. We’ll pass
    a unit parameter set to `"day"` to tell pandas to treat the numeric values as
    the number of days:'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们从日期中减去 `dayofweek` 值，我们将有效地将每个日期四舍五入到其前一个星期一。我们可以将 `dayofweek` `Series`
    传递给 `to_timedelta` 函数以将其转换为时长 `Series`。我们将传递一个设置为 `"day"` 的单位参数，告诉 pandas 将数值视为天数：
- en: '[PRE93]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Let’s save the new `Series` to a `dates_rounded_to_monday` variable:'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们将新的 `Series` 保存到 `dates_rounded_to_monday` 变量中：
- en: '[PRE94]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'We’re halfway there. We’ve rounded the dates to the correct Mondays, but the
    `value_counts` method won’t work yet. The differences in times between the dates
    will lead pandas to deem them unequal:'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经完成了一半。我们已经将日期四舍五入到正确的星期一，但 `value_counts` 方法还不能使用。日期之间的时间差异会导致 pandas 认为它们不相等：
- en: '[PRE95]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Let’s use the `dt.date` attribute to return a `Series` with the dates from
    each datetime:'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们使用 `dt.date` 属性来返回一个包含每个 datetime 的 `Series`：
- en: '[PRE96]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Now that we’ve isolated the dates, we can invoke the `value_counts` method
    to count each value’s occurrences. The week of Monday, June 15 to Sunday, June
    21 saw the highest number of bike rides throughout the month:'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们已经隔离了日期，我们可以调用 `value_counts` 方法来计算每个值的出现次数。从 6 月 15 日星期一到 6 月 21 日星期日的这一周，是整个月自行车骑行次数最多的一周：
- en: '[PRE97]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'To calculate each ride’s duration, we can subtract the start_time column from
    the stop_time column. Pandas will return a `Series` of `Timedelta`s. We’ll need
    to save this `Series` for the next example, so let’s attach it to the `DataFrame`
    as a new column called duration:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要计算每段骑行的时长，我们可以从停止时间列减去开始时间列。Pandas 将返回一个 `Timedelta`s 的 `Series`。我们需要将这个 `Series`
    保存到下一个示例中，所以让我们将其附加到 `DataFrame` 作为一个名为 duration 的新列：
- en: '[PRE98]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Note that the previous subtraction would raise an error if the columns were
    storing strings; that’s why it’s imperative to convert them to datetimes first.
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，如果列存储的是字符串，之前的减法操作将引发错误；这就是为什么在转换它们为日期时间之前，这是强制性的。
- en: 'Next up, we have to find the average duration of all bike rides. This process
    is a simple one: we can invoke the `mean` method on the new duration column for
    the calculation. The average ride was 27 minutes and 19 seconds:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须找出所有自行车骑行平均时长。这个过程很简单：我们可以在新的时长列上调用 `mean` 方法进行计算。平均骑行时长为 27 分钟和 19
    秒：
- en: '[PRE99]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'The final question asks to identify the five longest bike rides in the data
    set. One solution is to sort the duration column values in descending order with
    the `sort_values` method and then use the `head` method to view the first five
    rows. These sessions likely belonged to people who forgot to check their bikes
    in after finishing their ride:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个问题要求识别数据集中最长的五段自行车骑行。一个解决方案是使用 `sort_values` 方法按降序排序时长列的值，然后使用 `head` 方法查看前五行。这些会话可能属于那些在完成骑行后忘记检查自行车的人：
- en: '[PRE100]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Another option is the `nlargest` method. We can invoke this method on either
    the duration `Series` or the `DataFrame` as a whole. Let’s go with the latter
    approach:'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另一个选项是 `nlargest` 方法。我们可以在时长 `Series` 或整个 `DataFrame` 上调用此方法。让我们选择后者：
- en: '[PRE101]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'There you have it: the five longest bike rides in the data set. Congratulations
    on completing the coding challenge!'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是数据集中最长的五次骑行记录。恭喜您完成编码挑战！
- en: Summary
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: The pandas `Timestamp` object is a flexible, powerful replacement for Python’s
    native `datetime` object.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pandas 的 `Timestamp` 对象是一个灵活、强大的替代品，用于 Python 的原生 `datetime` 对象。
- en: The `dt` accessor on a datetime `Series` reveals a `DatetimeProperties` object
    with attributes and methods for extracting the day, month, weekday name, and more.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 datetime `Series` 上的 `dt` 访问器揭示了一个具有属性和方法以提取日期、月份、星期名称等属性的 `DatetimeProperties`
    对象。
- en: The `Timedelta` object models a duration.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Timedelta` 对象表示一个持续时间。'
- en: Pandas creates a `Timedelta` object when we subtract two `Timestamp` objects
    from each other.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们从两个 `Timestamp` 对象中减去时，Pandas 创建一个 `Timedelta` 对象。
- en: The offsets in the `pd.offsets` package dynamically round dates to the closest
    week, month, quarter, and more. We can round forward with the plus sign and backward
    with the minus sign.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pd.offsets` 包中的偏移量动态地将日期四舍五入到最近的周、月、季度等。我们可以用加号向前四舍五入，用减号向后四舍五入。'
- en: A `DatetimeIndex` is a container for `Timestamp` values. We can add it as an
    index or column to a pandas data structure.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DatetimeIndex` 是 `Timestamp` 值的容器。我们可以将其作为索引或列添加到 Pandas 数据结构中。'
- en: The `TimedeltaIndex` is a container for `Timedelta` objects.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TimedeltaIndex` 是 `Timedelta` 对象的容器。'
- en: The top-level `to_datetime` function converts an iterable of values to a `DatetimeIndex`
    of `Timestamp`s.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最高级的 `to_datetime` 函数将值的可迭代序列转换为 `Timestamp` 的 `DatetimeIndex`。
