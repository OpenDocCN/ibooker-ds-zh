- en: 9 Exploring FlixTube
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 探索FlixTube
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Revisiting the tools you’ve learned so far
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回顾你已学到的工具
- en: Understanding the layout, structure, and main code paths of FlixTube
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解FlixTube的布局、结构和主要代码路径
- en: Building, running, and testing FlixTube in development
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发环境中构建、运行和测试FlixTube
- en: Using Terraform to deploy FlixTube to production
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Terraform将FlixTube部署到生产环境
- en: Building the continuous delivery pipeline for FlixTube
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建FlixTube的持续交付管道
- en: Getting to chapter 9 has been a long road to travel. Along the way, we used
    numerous tools to build microservices, test those, and deploy them to production.
    In this chapter, we’ll see the fruits of our labor come together in the completed
    version of the FlixTube example application.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 通过第9章的旅程是一条漫长的道路。在这个过程中，我们使用了众多工具来构建微服务，测试它们并将它们部署到生产环境中。在本章中，我们将看到我们辛勤工作的成果，即FlixTube示例应用的完整版本。
- en: Through this chapter, we’ll learn how FlixTube works as a whole and meet some
    new microservices. We’ll revise and consolidate our skills and demonstrate those
    skills in the context of a complete, although still relatively simple, microservices
    application.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章，我们将了解FlixTube作为一个整体是如何工作的，并遇到一些新的微服务。我们将复习和巩固我们的技能，并在一个完整但相对简单的微服务应用中展示这些技能。
- en: We will start by building and running FlixTube in development. Next, we’ll run
    our tests from chapter 8 against it. Ultimately, we’ll deploy FlixTube to our
    production Kubernetes cluster and create a continuous delivery (CD) pipeline for
    it.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先在开发环境中构建和运行FlixTube。接下来，我们将运行第8章中的测试。最终，我们将FlixTube部署到我们的生产Kubernetes集群，并为其创建一个持续交付（CD）管道。
- en: 9.1 No new tools!
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1 没有新工具！
- en: Congratulations! You have already learned all the main tools you need to start
    building microservices applications. There is, of course, a deeper level of knowledge
    to be acquired. There are also many other useful tools that you could learn, and
    new tools will arrive on the scene in the future.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经学会了所有开始构建微服务应用所需的主要工具。当然，还有更深层次的知识需要掌握。还有许多其他有用的工具你可以学习，未来也会有新的工具出现。
- en: But, for the purposes of this book, we have learned the minimum amount of tooling
    to build products based on microservices. As you dive deeper into ongoing development,
    you’ll find problems that are specific to your project, and you’ll need to dive
    deeper into these tools. You’ll need to learn a deeper level of Docker, Kubernetes,
    and Terraform. For now, though, we have enough tools in our toolbox to complete
    our first version of FlixTube. So let’s get to it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，就本书的目的而言，我们已经学到了构建基于微服务产品的最小工具集。随着你深入到持续的开发中，你会发现一些特定于你项目的难题，你需要更深入地研究这些工具。你需要学习更深入的Docker、Kubernetes和Terraform知识。然而，目前我们工具箱中的工具已经足够我们完成FlixTube的第一个版本。所以，让我们开始吧。
- en: 9.2 Getting the code
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2 获取代码
- en: To follow along with this chapter, you need to download the code or clone the
    repository.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章，你需要下载代码或克隆仓库。
- en: 'Download a zip file of the code from here:'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从这里下载代码的zip文件：
- en: '[https://github.com/bootstrapping-microservices/chapter-9](https://github.com/bootstrapping-microservices/chapter-9)'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://github.com/bootstrapping-microservices/chapter-9](https://github.com/bootstrapping-microservices/chapter-9)'
- en: 'You can clone the code using Git like this:'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用Git克隆代码，如下所示：
- en: '`git clone https://github.com/bootstrapping-microservices/chapter-9.git`'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`git clone https://github.com/bootstrapping-microservices/chapter-9.git`'
- en: For help on installing and using Git, see chapter 2\. If you have problems with
    the code, log an issue against the repository in GitHub.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如需安装和使用Git的帮助，请参阅第2章。如果你在代码上遇到问题，请在GitHub的仓库中记录一个问题。
- en: 9.3 Revisiting essential skills
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3 回顾基本技能
- en: As we work through the complete FlixTube example, we will exercise the essential
    skills we have learned to build, run, test, and deploy microservices. When you
    see it in a list like this, you realize just how much ground we have covered!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成整个FlixTube示例的过程中，我们将练习我们学到的构建、运行、测试和部署微服务的基本技能。当你看到这样的列表时，你会意识到我们已经覆盖了多少内容！
- en: Running microservices with Node.js (from chapter 2)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Node.js运行微服务（来自第2章）
- en: Packaging and publishing our microservices with Docker (from chapters 3 and
    6)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker打包和发布我们的微服务（来自第3章和第6章）
- en: Building and running our application in development with Docker Compose (from
    chapters 4 and 5)
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker Compose在开发环境中构建和运行我们的应用（来自第4章和第5章）
- en: Storing and retrieving data using a database (from chapter 4)
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数据库存储和检索数据（来自第4章）
- en: Storing and retrieving files using external file storage (from chapter 4)
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用外部文件存储存储和检索文件（来自第 4 章）
- en: Communication between microservices with HTTP requests and RabbitMQ messages
    (from chapter 5)
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 HTTP 请求和 RabbitMQ 消息在微服务之间进行通信（来自第 5 章）
- en: Testing individual microservices with Jest (from chapter 8)
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Jest 测试单个微服务（来自第 8 章）
- en: Testing the whole application with Cypress (from chapter 8)
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Cypress 测试整个应用程序（来自第 8 章）
- en: Deploying the application to a Kubernetes cluster using Terraform (from chapters
    6 and 7)
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Terraform 将应用程序部署到 Kubernetes 集群（来自第 6 章和第 7 章）
- en: Creating a CD pipeline with Bitbucket Pipelines (chapter 7)
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Bitbucket Pipelines 创建 CD 管道（第 7 章）
- en: Figure 9.1 illustrates the skills we will revisit and shows their context in
    the scheme of things. To make the most of this chapter, follow along with the
    examples. You should get FlixTube running for yourself so you can study it and
    understand how it works. To test and improve your understanding, you should try
    making your own changes. Practice is the best way to cement these skills in your
    mind.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 展示了我们将回顾的技能及其在事物方案中的上下文。为了充分利用本章内容，请跟随示例。您应该自己运行 FlixTube，以便研究它并理解其工作原理。为了测试和加深您的理解，您应该尝试进行自己的更改。实践是巩固这些技能的最佳方式。
- en: '![](../Images/CH09_F01_Davis4.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH09_F01_Davis4.png)'
- en: Figure 9.1 Essential skills we revisit in this chapter
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 本章回顾的基本技能
- en: 9.4 Overview of FlixTube
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.4 FlixTube 概述
- en: 'The code for this chapter only includes a single example: the complete FlixTube
    project. You can find it in the example-1 subdirectory of the chapter 9 code repository.
    Let’s start with a bird’s eye view of its structure. Figure 9.2 shows the latest
    incarnation of FlixTube.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码仅包含一个示例：完整的 FlixTube 项目。您可以在第 9 章代码仓库的 example-1 子目录中找到它。让我们先从其结构的一个鸟瞰图开始。图
    9.2 展示了 FlixTube 的最新版本。
- en: '![](../Images/CH09_F02_Davis4.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH09_F02_Davis4.png)'
- en: Figure 9.2 Overview of the completed FlixTube example application
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 完成的 FlixTube 示例应用程序概述
- en: 9.4.1 FlixTube microservices
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4.1 FlixTube 微服务
- en: You already know some of the microservices shown in figure 9.2\. For example
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经了解图 9.2 中显示的一些微服务。例如
- en: Video streaming (first encountered in chapter 2)
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视频流（首次在第 2 章中遇到）
- en: Video storage (from chapter 4)
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视频存储（来自第 4 章）
- en: History (from chapter 5)
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 历史（来自第 5 章）
- en: Metadata (from chapter 8)
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元数据（来自第 8 章）
- en: 'There are also some new microservices that you haven’t seen yet: gateway and
    video upload. Table 9.1 lists the purpose for each of these microservices.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些您尚未见过的新的微服务：网关和视频上传。表 9.1 列出了这些微服务的每个目的。
- en: Table 9.1 FlixTube microservices
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9.1 FlixTube 微服务
- en: '| Microservice | Purpose |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 微服务 | 目的 |'
- en: '| Gateway | The entry point to the application. Serves the front end and provides
    a REST API. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 网关 | 应用程序的入口点。服务于前端并提供 REST API。|'
- en: '| Video streaming | Streams videos from storage to be watched by the user.
    |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 视频流 | 从存储流式传输视频供用户观看。|'
- en: '| History | Records the user’s viewing history. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 历史 | 记录用户的观看历史。|'
- en: '| Metadata | Records details and metadata about each video. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 元数据 | 记录每个视频的详细信息及其元数据。|'
- en: '| Video upload | Orchestrates upload of videos to storage. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 视频上传 | 协调视频上传到存储。|'
- en: '| Video storage | Responsible for storing and retrieving videos from external
    cloud storage. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 视频存储 | 负责从外部云存储中存储和检索视频。|'
- en: 9.4.2 Microservice project structure
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4.2 微服务项目结构
- en: Before we look at the project structure for the entire application, let’s first
    revisit the structure of an individual Node.js microservice. Open the metadata
    directory under example-1 in the chapter 9 code repository to follow along.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看整个应用程序的项目结构之前，让我们首先回顾单个 Node.js 微服务的结构。打开第 9 章代码仓库中 example-1 目录下的元数据目录，以跟随示例。
- en: Using the metadata microservice as an example, figure 9.3 describes the layout
    of its project. This is a typical Node.js project, and all of FlixTube’s microservices
    have virtually this same structure.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以元数据微服务为例，图 9.3 描述了其项目的布局。这是一个典型的 Node.js 项目，FlixTube 的所有微服务几乎都有这种相同的结构。
- en: '![](../Images/CH09_F03_Davis4.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH09_F03_Davis4.png)'
- en: Figure 9.3 The structure of a Node.js microservice project (the metadata microservice)
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 Node.js 微服务项目结构（元数据微服务）
- en: 9.4.3 FlixTube project structure
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4.3 FlixTube 项目结构
- en: Now, let’s look at the structure of the whole FlixTube project. Figure 9.4 shows
    its layout, including subdirectories for each microservice. Open the example-1
    directory from the chapter 9 code repository to take a look for yourself.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看整个 FlixTube 项目的结构。图 9.4 展示了其布局，包括每个微服务的子目录。打开第 9 章代码仓库中的 example-1 目录，亲自查看一下。
- en: For simplicity, FlixTube was built in a single code repository. Using a single
    repo is a great way to learn development with microservices (it makes it simpler
    for you), and in general, even after you are an expert in microservices, using
    a single repo is a simple and convenient way to bootstrap a new microservices
    application. Of course, using a single repo is also a convenient way for me to
    share the example code with you.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，FlixTube 是在一个代码仓库中构建的。使用单个仓库是学习微服务开发的绝佳方式（它使你的任务变得更简单），而且一般来说，即使你成为微服务的专家，使用单个仓库也是启动新的微服务应用程序的一种简单方便的方式。当然，使用单个仓库也是我与你分享示例代码的一种方便方式。
- en: 'Having said all that, microservices in production are usually never contained
    in a single code repository. Using a single repository removes the biggest advantages
    of using microservices: that they can be independently deployed. Having all the
    microservices in the single repo means that these will be deployed together (unless
    you have an unusually smart CD pipeline).'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 说了这么多，生产环境中的微服务通常永远不会包含在单个代码仓库中。使用单个仓库会消除使用微服务的最大优势：它们可以独立部署。将所有微服务放在单个仓库中意味着它们将一起部署（除非你有非常聪明的
    CD 流水线）。
- en: '![](../Images/CH09_F04_Davis4.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH09_F04_Davis4.png)'
- en: Figure 9.4 The structure of the entire FlixTube project
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 整个 FlixTube 项目的结构
- en: In real-life situations, microservices are almost always split into separate
    repositories, and usually, there is a separate repository for each microservice.
    For the moment, for simplicity and convenience, we’ll continue with FlixTube in
    a single repository. In chapter 11, we’ll talk about mono- vs. multi-repos and
    how we can take FlixTube forward by splitting it out to separate code repositories.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实情况下，微服务几乎总是被分割成独立的仓库，通常每个微服务都有一个独立的仓库。为了简单和方便起见，我们暂时将 FlixTube 放在一个仓库中。在第
    11 章中，我们将讨论单仓库与多仓库的对比，以及如何通过将 FlixTube 分割到独立的代码仓库中来推进它。
- en: 9.5 Running FlixTube in development
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.5 在开发中运行 FlixTube
- en: Our first step is to have FlixTube running on our development workstation (or
    personal computer). Figure 9.5 shows how it looks in development. Note that we
    have replaced the video-storage microservice with a mock version of it. We’ll
    discuss the why and how of this soon.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步是将 FlixTube 运行在我们的开发工作站（或个人电脑）上。图 9.5 展示了它在开发中的样子。请注意，我们已经用它的模拟版本替换了视频存储微服务。我们很快会讨论为什么以及如何这样做。
- en: '![](../Images/CH09_F05_Davis4.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH09_F05_Davis4.png)'
- en: Figure 9.5 FlixTube as it now looks in development
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5 FlixTube 在开发中的样子
- en: 9.5.1 Booting a microservice
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5.1 启动微服务
- en: Before booting the whole application, it’s worth revising how we start an individual
    microservice. When developing a new microservice or focusing our current work
    on an existing microservice, we’ll frequently need to run that microservice on
    its own outside the context of the application.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动整个应用程序之前，回顾一下我们如何启动单个微服务是有意义的。当开发新的微服务或专注于现有微服务时，我们经常需要在该微服务之外的应用程序上下文中单独运行该微服务。
- en: 'We are using Node.js for our microservices, so that means running our microservices
    directly under Node.js on our development workstations. If you followed along
    in chapter 2 and chapter 8, you’ll already have Node.js installed. If not, return
    to section 2.5.4 in chapter 2 for instructions. Before running a Node.js project,
    you must first install dependencies like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Node.js 作为我们的微服务，这意味着我们的微服务将直接在我们的开发工作站上的 Node.js 下运行。如果你在第二章和第八章中一直跟随，那么你已经有
    Node.js 安装了。如果没有，请回到第二章 2.5.4 节获取说明。在运行 Node.js 项目之前，你必须首先安装依赖项，如下所示：
- en: '[PRE0]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To run a Node.js project, use the npm start script convention:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 Node.js 项目时，请使用 npm start 脚本约定：
- en: '[PRE1]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This invokes a command line that is specified in the project’s package.json
    file. All microservices in FlixTube follow this common Node.js convention. That
    means you know how to start any microservice in FlixTube to run it standalone
    in *production mode*.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这将调用在项目的 package.json 文件中指定的命令行。FlixTube 中的所有微服务都遵循这个常见的 Node.js 约定。这意味着你知道如何启动
    FlixTube 中的任何微服务，以独立运行在 *生产模式* 下。
- en: 'What’s more appropriate during ongoing development is to run the microservice
    in *development mode**.* This enables *live reload* (first covered in section
    2.6.8), so we can edit our code and have the microservice restart itself automatically
    to include the changes. We use the start:dev script (my personal convention) to
    run any of the FlixTube microservices in development mode:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在持续开发期间，更合适的是以*开发模式*运行微服务。这启用了*实时重新加载*（首次在第2.6.8节中介绍），这样我们就可以编辑我们的代码，并且微服务会自动重新启动以包含更改。我们使用start:dev脚本来以开发模式运行FlixTube的任何微服务（我的个人约定）：
- en: '[PRE2]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: (You can revise further on production mode, development mode, and live reload.
    To learn more, return to sections 2.6.7 and 2.6.8 in chapter 2.)
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: (您可以在生产模式、开发模式和实时重新加载中进行进一步修改。要了解更多信息，请返回第2章的2.6.7和2.6.8节。)
- en: 'You may have noticed that most of the FlixTube microservices now have dependencies
    that make them more difficult to start on their own. Most of these either need
    a database or a RabbitMQ server. Some of them require both. We can deal with this
    in any of the following ways:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，FlixTube的大多数微服务现在都有依赖项，这使得它们单独启动变得更加困难。其中大部分需要数据库或RabbitMQ服务器。其中一些需要两者。我们可以通过以下任何一种方式来处理这个问题：
- en: '*Install MongoDB and RabbitMQ on your development workstation.* This is annoying
    in the short term, but quite useful in the long term.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在您的开发工作站上安装MongoDB和RabbitMQ。* 这在短期内可能很烦人，但从长远来看非常有用。'
- en: '*Instantiate MongoDB and RabbitMQ servers containers using Docker or Docker
    Compose.* This is a convenient, effective, and simple way to do this.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Docker或Docker Compose实例化MongoDB和RabbitMQ服务器容器。* 这是一种方便、有效且简单的方法。'
- en: '*Mock the libraries for MongoDB, RabbitMQ and other dependencies.* This is
    similar to what we did in chapter 8\. You’ll probably want to do this for your
    automated testing.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*模拟MongoDB、RabbitMQ和其他依赖项的库。* 这与我们在第8章中做的是类似的。您可能想为您的自动化测试做这件事。'
- en: 9.5.2 Booting the application
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5.2 启动应用程序
- en: Now let’s boot the entire FlixTube application using Docker Compose, the useful
    tool we first encountered in chapter 4 and have used since. Frequently, during
    day-to-day product development, we’ll build and restart our application, and Docker
    Compose makes this much simpler. Often, we’ll take time out to focus on an individual
    microservice, but we’ll still frequently want to test our larger application while
    we evolve its constituent microservices.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用Docker Compose启动整个FlixTube应用程序，这是我们首次在第4章中遇到的有用工具，并且自那时起一直在使用。在日常产品开发中，我们经常构建和重新启动我们的应用程序，而Docker
    Compose使这变得更加简单。我们经常抽出时间专注于单个微服务，但我们在微服务组件演变的同时，仍然经常想要测试我们的更大应用程序。
- en: If you followed along in chapters 4, 5, and 8, you will already have Docker
    Compose installed. If not, refer back to section 4.3.2 and install it so you can
    follow along. You should now open the example-1 subdirectory from chapter 9 in
    VS Code to see the code for yourself.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您跟随了第4章、第5章和第8章的内容，您已经安装了Docker Compose。如果没有，请参考第4.3.2节并安装它，以便您可以继续操作。现在您应该打开VS
    Code中的第9章的example-1子目录，以查看代码。
- en: Listing 9.1 reminds us of what a Docker Compose file (docker-compose.yaml) looks
    like. FlixTube’s version of this file is the biggest in this book, so listing
    9.1 has been abbreviated for brevity. Most entries in this file are similar, so
    these can be safely omitted. If you’ve seen one, you’ve basically seen them all.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.1让我们回忆起Docker Compose文件（docker-compose.yaml）的样子。FlixTube版本的此文件是本书中最大的，因此列表9.1为了简洁而进行了缩写。此文件中的大多数条目都是相似的，因此可以安全地省略。如果您看过一个，基本上就看过它们了。
- en: Listing 9.1 The Docker Compose file for booting FlixTube in development (abbreviated
    from chapter-9/example-1/docker-compose.yaml)
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.1 启动FlixTube开发环境的Docker Compose文件（从第9章的chapter-9/example-1/docker-compose.yaml缩写）
- en: '[PRE3]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ① Starts the container for the MongoDB database
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ① 启动MongoDB数据库的容器
- en: ② Starts the container for the RabbitMQ server
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ② 启动RabbitMQ服务器的容器
- en: ③ Starts the REST API for loading database fixtures
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 启动用于加载数据库固定数据的REST API
- en: ④ Builds and starts the video-streaming microservice
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 构建并启动视频流微服务
- en: ⑤ All the other FlixTube microservices go here.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 其他所有FlixTube微服务都在这里。
- en: 'Most FlixTube microservices have been omitted from listing 9.1, but one you
    can see is our old friend, the video-streaming microservice. There is also the
    setup for our database (covered in chapter 4), RabbitMQ (covered in chapter 5),
    and the database fixtures REST API we will use in our automated testing (covered
    in chapter 8). Now use Docker Compose to build and start FlixTube:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数FlixTube微服务在列表9.1中被省略了，但你可以看到的是我们熟悉的老朋友，视频流微服务。还包括我们数据库的设置（在第4章中介绍），RabbitMQ（在第5章中介绍），以及我们将用于自动化测试的数据库固定REST
    API（在第8章中介绍）。现在使用Docker Compose构建并启动FlixTube：
- en: '[PRE4]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It takes some time to build and start, especially if you haven’t done this before.
    Docker needs to download and cache the base images.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 构建和启动需要一些时间，尤其是如果你之前没有这样做过。Docker需要下载和缓存基础镜像。
- en: 'Now, with the FlixTube application running, open your browser and navigate
    to http://localhost:4000 to see FlixTube’s main page. You’ll notice FlixTube has
    a shiny new user interface (UI)! We’ll talk more about that soon. For now, take
    some time to explore FlixTube’s UI:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，随着FlixTube应用程序的运行，打开你的浏览器并导航到http://localhost:4000以查看FlixTube的主页。你会发现FlixTube有一个闪亮的新用户界面（UI）！我们很快会更多地讨论这一点。现在，花些时间探索FlixTube的UI：
- en: Navigate to the upload page.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到上传页面。
- en: Upload a video.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上传视频。
- en: Navigate back to the main page to see the uploaded video in the list.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航回主页以查看列表中的上传视频。
- en: Click the video to play it.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击视频播放它。
- en: When you have finished development, don’t forget to shutdown FlixTube so that
    it’s not continuing to consume resources on your development workstation. You
    can do that by pressing Ctrl-C in the terminal where Docker Compose is running
    and by then invoking
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成开发后，别忘了关闭FlixTube，以免它在你的开发工作站上继续消耗资源。你可以通过在Docker Compose运行的终端中按Ctrl-C来做到这一点，然后调用
- en: '[PRE5]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 9.6 Testing FlixTube in development
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.6 开发中测试FlixTube
- en: Testing is essential to the practice of development. We can and should do manual
    testing, but nothing beats automated testing for efficiency, reliability, and
    repeatability.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 测试对于开发实践至关重要。我们可以也应该进行手动测试，但自动化测试在效率、可靠性和可重复性方面无与伦比。
- en: In chapter 8, we looked at multiple ways of testing using Jest and Cypress.
    We’ll revisit those again here. The various tests that we looked at in that chapter
    are repeated here in the chapter 9 code repo. We’ll run those now against the
    completed FlixTube example.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在第8章中，我们探讨了使用Jest和Cypress的多种测试方法。我们在这里将再次回顾这些方法。我们在那一章中查看的各种测试在本章9的代码库中重复出现。我们现在将对完成的FlixTube示例运行这些测试。
- en: Of course, any real application will have many more tests than the few we are
    running here. This is just a demonstration, and I haven’t aimed for anything near
    complete test coverage. Follow along in the coming sections, and try running these
    tests for yourself.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，任何真正的应用程序都将比我们这里运行的几个测试有更多的测试。这只是一个演示，我并没有追求接近完整的测试覆盖率。在接下来的章节中，尝试自己运行这些测试。
- en: 9.6.1 Testing a microservice with Jest
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.6.1 使用Jest测试微服务
- en: 'The metadata microservice in FlixTube includes the Jest unit tests from chapter
    8\. Before running the tests, you’ll need to install dependencies:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: FlixTube中的元数据微服务包括第8章中的Jest单元测试。在运行测试之前，你需要安装依赖项：
- en: '[PRE6]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now run the tests using the standard npm `test` script convention as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在按照以下标准npm `test`脚本来运行测试：
- en: '[PRE7]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This executes the associated command line in the metadata microservice’s package
    .json file that we configured in chapter 8\. Figure 9.6 shows the results of a
    successful test run.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在第8章中配置的元数据微服务的package.json文件中执行相关的命令行。图9.6显示了成功测试运行的结果。
- en: '![](../Images/CH09_F06_Davis4.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH09_F06_Davis4.png)'
- en: Figure 9.6 A successful run of the automated tests for the metadata microservice
    using Jest
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 使用Jest对元数据微服务进行自动测试的成功运行
- en: 'You can also run the tests in *live reload* mode, which means you can edit
    your code, and the tests will restart automatically. We do this using another
    npm script called `test:watch` (my own personal convention):'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在*实时重新加载*模式下运行测试，这意味着你可以编辑你的代码，测试将自动重新启动。我们使用另一个名为`test:watch`的npm脚本来做到这一点（我的个人约定）：
- en: '[PRE8]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To revise Jest in more detail, return to section 8.5\. To revisit the Jest setup
    for npm and live reload, see section 8.5.8.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要更详细地复习Jest，请回到第8.5节。要回顾npm和实时重新加载的Jest设置，请参阅第8.5.8节。
- en: 9.6.2 Testing the application with Cypress
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.6.2 使用Cypress测试应用程序
- en: 'We can also run the Cypress end-to-end test from chapter 8 against the FlixTube
    application. In chapter 8, we ran this test against a cutdown version of FlixTube.
    Here though, we run it against the full application. To run this test, you’ll
    need to install dependencies for the FlixTube project:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以从第8章开始运行 Cypress 端到端测试，针对 FlixTube 应用程序。在第8章中，我们针对 FlixTube 的简化版本运行了这个测试。然而，这次我们将针对完整的应用程序运行它。要运行这个测试，你需要为
    FlixTube 项目安装依赖项：
- en: '[PRE9]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Be sure to actually start the application if you haven’t done so already:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有这样做，请确保实际启动应用程序：
- en: '[PRE10]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, run the regular npm test script, which in this case is configured to invoke
    Cypress:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行常规的 npm test 脚本，在这个例子中，它被配置为调用 Cypress：
- en: '[PRE11]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'That runs Cypress from the terminal in headless mode. During development, we’ll
    want to bring up the Cypress UI, as shown in figure 9.7\. In this case, we’ll
    use the `test:watch` script that we configured to start the Cypress UI:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在终端中以无头模式运行 Cypress。在开发过程中，我们希望启动 Cypress UI，如图9.7所示。在这种情况下，我们将使用我们配置的 `test:watch`
    脚本来启动 Cypress UI：
- en: '[PRE12]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '![](../Images/CH09_F07_Davis4.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH09_F07_Davis4.png)'
- en: Figure 9.7 A successful test run of the automated tests for the FlixTube UI
    using Cypress
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 使用 Cypress 对 FlixTube UI 的自动化测试成功运行
- en: With the Cypress UI running, we can make code changes that affect our front
    end and see the results in a very visual way. To revise Cypress in more detail,
    return to section 8.8\. To revisit Cypress setup for npm, go to section 8.8.7.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Cypress UI 运行的情况下，我们可以对影响我们前端代码的代码进行更改，并以非常直观的方式看到结果。要更详细地修订 Cypress，请返回到第8.8节。要回顾
    Cypress 的 npm 设置，请转到第8.8.7节。
- en: 9.7 FlixTube deep dive
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.7 深入了解 FlixTube
- en: 'By now, you should understand FlixTube from a high level. You know the microservices
    and the purposes of each. You know how to build, run, and test the application
    on your development workstation. Before we deploy FlixTube to production, let’s
    first understand some of its deeper details. Throughout this section, we’ll look
    at various aspects of FlixTube:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该从高层次上理解了 FlixTube。你知道微服务以及每个微服务的目的。你知道如何在你的开发工作站上构建、运行和测试应用程序。在我们将
    FlixTube 部署到生产之前，让我们首先了解一些其更深入细节。在本节中，我们将查看 FlixTube 的各个方面：
- en: Database fixtures
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库固定值
- en: Mocking the storage microservice
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟存储微服务
- en: The gateway
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网关
- en: The FlixTube UI
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FlixTube UI
- en: Video streaming
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视频流
- en: Video upload
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视频上传
- en: 9.7.1 Database fixtures
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.7.1 数据库固定值
- en: We first talked about database fixtures in chapter 8, where we used these to
    load our database with realistic sets of data prior to running automated tests.
    We saw database fixtures used for automated testing, but these are also useful
    for manual testing and even for product demonstrations. Being able to boot your
    application and have it ready to show, complete with realistic data, is extremely
    useful!
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第8章中首先讨论了数据库固定值，在那里我们使用这些固定值在运行自动化测试之前将真实数据集加载到数据库中。我们看到了数据库固定值在自动化测试中的应用，但它们对手动测试甚至产品演示也非常有用。能够启动应用程序并展示包含真实数据的完整应用程序是非常有用的！
- en: When unit testing with Jest, we didn’t need any data because we mocked the MongoDB
    database library and were able to replace real data with fake data provided through
    the mock version of the database library. When integration testing with Jest,
    we were able to interact with our MongoDB database within our test code by directly
    using the MongoDB library. This meant we could have test data inline in our test
    code, but it was convenient not to have to create separate data files for it.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Jest 进行单元测试时，我们不需要任何数据，因为我们模拟了 MongoDB 数据库库，并能够通过数据库库的模拟版本提供的假数据替换真实数据。当使用
    Jest 进行集成测试时，我们能够在测试代码中直接使用 MongoDB 库与我们的 MongoDB 数据库进行交互。这意味着我们可以在测试代码中内联测试数据，但不必为它创建单独的数据文件。
- en: When doing end-to-end testing with Cypress, we had to find a different solution.
    Because Cypress tests run in the browser (Cypress is built on Electron, which
    is based on Chrome), we don’t have access to the MongoDB library (which only runs
    under Node.js). In this case, we don’t have direct access to manipulate our MongoDB
    database.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Cypress 进行端到端测试时，我们必须找到不同的解决方案。因为 Cypress 测试在浏览器中运行（Cypress 是基于 Electron
    构建的，而 Electron 是基于 Chrome 的），所以我们无法访问 MongoDB 库（它只在 Node.js 下运行）。在这种情况下，我们无法直接操作我们的
    MongoDB 数据库。
- en: To solve this problem, I created the *database fixtures* *REST API*. This is
    a REST API that looks similar to any of the other microservices you have seen
    in this book. We won’t look at its code directly, but if you’d like to look at
    it yourself, you’ll find that it’s already quite familiar. The code for the REST
    API is included in the chapter 8 code repository and copied to the chapter 9 code
    repository so that we can use it when running our tests against FlixTube. Additionally,
    you can find the original source code for it on GitHub at [https://github.com/ashleydavis/db-fixture-rest-api](https://github.com/ashleydavis/db-fixture-rest-api).
    You can see the setup for the REST API’s container in the Docker Compose file
    earlier in listing 9.1.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我创建了 *数据库固定配置* *REST API*。这是一个看起来与其他你在本书中看到的任何其他微服务相似的 REST API。我们不会直接查看其代码，但如果你想自己查看，你会发现它已经相当熟悉了。REST
    API 的代码包含在第 8 章代码存储库中，并复制到第 9 章代码存储库，以便我们在对 FlixTube 运行测试时可以使用它。此外，你可以在 GitHub
    上找到它的原始源代码：[https://github.com/ashleydavis/db-fixture-rest-api](https://github.com/ashleydavis/db-fixture-rest-api)。你可以在列表
    9.1 中找到 REST API 容器的设置。
- en: For an understanding of what a database fixture looks like, see listing 9.2\.
    In general, our database fixtures are stored under the fixtures subdirectory of
    chapter-9/ example-1.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解数据库固定配置的外观，请参阅列表 9.2。一般来说，我们的数据库固定配置存储在 chapter-9/example-1 的 fixtures 子目录下。
- en: FlixTube only has one database fixture in the file videos.js (shown in listing
    9.2). The name of the file denotes the database collection that the data will
    be stored in. The data from this fixture will be loaded into the videos collection.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: FlixTube 只有一个数据库固定配置文件在 videos.js 文件中（如列表 9.2 所示）。文件名表示数据将要存储的数据库集合。从这个固定配置文件中获取的数据将被加载到视频集合中。
- en: The directory that contains the file denotes the name of the fixture. In this
    case, the name of the directory is two-videos, so the name of the database fixture
    is two-videos. I’ve given the fixture this name because its purpose is to load
    metadata for two videos into our database. In general, we should give meaningful
    names to our database fixtures so that we can easily remember their purpose.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 包含该文件的目录表示固定配置的名称。在这种情况下，目录的名称是 two-videos，因此数据库固定配置的名称是 two-videos。我之所以给固定配置起这个名字，是因为它的目的是将两个视频的元数据加载到我们的数据库中。一般来说，我们应该给我们的数据库固定配置起有意义的名字，这样我们就可以轻松记住它们的目的。
- en: Each database fixture can consist of many files. Even though here we only have
    one file for our two-videos fixture, it could have more such files to set the
    contents of other collections in our database.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数据库固定配置可以由多个文件组成。尽管在这里我们只为我们的双视频固定配置文件只有一个文件，但它可以有更多这样的文件来设置数据库中其他集合的内容。
- en: Listing 9.2 An example database fixture for FlixTube (chapter-9/example-1/fixtures/two-videos/videos.js)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.2 FlixTube 的一个示例数据库固定配置（chapter-9/example-1/fixtures/two-videos/videos.js）
- en: '[PRE13]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ① Imports the MongoDB library so we can create database IDs
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ① 导入 MongoDB 库以便我们可以创建数据库 ID
- en: ② Exports the data that’s inserted into the videos collection of the metadata
    database
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ② 将插入到元数据库视频集合中的数据导出
- en: ③ Creates database IDs for new records
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 为新记录创建数据库 ID
- en: ④ Sets the filenames for the videos
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 设置视频的文件名
- en: If you ran the Cypress test earlier in section 9.6.2, then you have already
    used this database fixture! Note that the fixture shown in listing 9.2 is actually
    a JavaScript file. We can use either JSON format or JavaScript for these database
    fixtures. JSON is appropriate for static data, but JavaScript is a great option
    for generating dynamic data. That gives us a lot of flexibility for producing
    test data. In listing 9.2, see how we use the MongoDB library to produce database
    IDs for our test data.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前在 9.6.2 节中运行了 Cypress 测试，那么你已经使用了这个数据库固定配置！请注意，列表 9.2 中显示的固定配置实际上是一个 JavaScript
    文件。我们可以使用 JSON 格式或 JavaScript 来创建这些数据库固定配置。JSON 适用于静态数据，但 JavaScript 是生成动态数据的一个很好的选择。这为我们生成测试数据提供了很大的灵活性。在列表
    9.2 中，看看我们如何使用 MongoDB 库为我们的测试数据生成数据库 ID。
- en: 9.7.2 Mocking storage
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.7.2 模拟存储
- en: For convenience during development, we replaced the Azure version of the video-storage
    microservice with a mock version. This is similar to the mocking we used in section
    8.5.10\. Except, rather than replacing functions, objects, and libraries with
    mock versions, we now replace an entire microservice with a fake version. Figure
    9.8 shows what FlixTube looks like when Azure storage has been replaced by the
    mock storage microservice.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开发期间的方便，我们将视频存储微服务的Azure版本替换为模拟版本。这与我们在第8.5.10节中使用的模拟类似。不同之处在于，我们不是用模拟版本替换函数、对象和库，而是现在用一个假版本替换整个微服务。图9.8显示了当Azure存储被模拟存储微服务替换时FlixTube的样子。
- en: Our mock storage microservice is not a complete fake though! It still does the
    job of storage, but instead of using cloud storage, it stores videos in the local
    filesystem. The main reason we do this is not just for testing; it’s for the convenience
    and performance of being able to limit our entire application to our development
    workstation.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模拟存储微服务并不是完全的虚构！它仍然执行存储的任务，但不是使用云存储，而是在本地文件系统中存储视频。我们这样做的主要原因不仅仅是测试；它还为了方便和性能，能够将整个应用程序限制在我们的开发工作站上。
- en: '![](../Images/CH09_F08_Davis4.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH09_F08_Davis4.png)'
- en: Figure 9.8 Replacing cloud storage with a mock microservice for more convenient
    and efficient use during development
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8 在开发期间用模拟微服务替换云存储，以实现更方便和高效的使用
- en: When running in development, we’d prefer to eliminate external dependencies
    like connections to cloud storage. In this case, limiting our storage to the local
    filesystem makes the setup for development easier. Performance is improved because
    videos are stored locally and not sent out to the cloud. Besides this change,
    FlixTube works as normal, and the other microservices have no idea that the Azure
    storage microservice has been kicked out and replaced with a mock version.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发期间运行时，我们更喜欢消除外部依赖，如连接到云存储。在这种情况下，将存储限制在本地文件系统使开发设置更加简单。性能得到提升，因为视频是本地存储的，而不是发送到云端。除了这个变化之外，FlixTube仍然按正常工作，其他微服务并不知道Azure存储微服务已被踢出并替换为模拟版本。
- en: Being able to replace complex microservices with simpler mock versions is not
    just convenient, it might also be necessary at some point in the future. Right
    now, FlixTube is a small application, but you can imagine as it grows into the
    world-dominating streaming service it is destined to be that it will become too
    big to run on a single computer.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 能够用更简单的模拟版本替换复杂微服务不仅方便，而且在未来的某个时刻可能也是必要的。目前，FlixTube是一个小型应用程序，但你可以想象，随着它成长为注定要成为世界主导的流媒体服务，它将变得太大，无法在单台计算机上运行。
- en: At that point, we need to use every trick in the book to make it fit. This includes
    cutting out microservices that we don’t need; for example, you could remove the
    history microservice from the Docker Compose file if you don’t need to test it.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 到那时，我们需要使出浑身解数来使其适应。这包括删除我们不需要的微服务；例如，如果你不需要测试它，你可以从Docker Compose文件中移除历史微服务。
- en: Note Removing or replacing big complex microservices-possibly even whole groups
    of microservices-is an important technique for reducing the size of our application
    so that it can fit on a single computer and be able to run during development.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：移除或替换大型复杂微服务——甚至可能是整个微服务组——是减少我们应用程序大小的重要技术，以便它可以在单台计算机上运行并在开发期间运行。
- en: Listing 9.3 shows the setup of our mock storage microservice in FlixTube’s Docker
    Compose file. It looks similar to the configuration of the Azure storage microservice.
    One thing that’s different is the storage subdirectory that is shared between
    the host operating system and the container. This is the directory where uploaded
    videos are stored. Sharing it like this means that we can inspect uploaded videos
    ourselves on the host OS to test that the microservice is functioning correctly.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.3展示了FlixTube的Docker Compose文件中我们的模拟存储微服务的配置。它看起来与Azure存储微服务的配置相似。不同的一点是，存储子目录是在主机操作系统和容器之间共享的。这是上传视频存储的目录。以这种方式共享意味着我们可以在主机操作系统上自行检查上传的视频，以测试微服务是否正常运行。
- en: Listing 9.3 Mock storage microservice setup in the Docker Compose file (extract
    from chapter-9/example-1/docker-compose.yaml)
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.3 Docker Compose文件中的模拟存储微服务设置（摘自第9章/示例-1/docker-compose.yaml）
- en: '[PRE14]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ① Sets the DNS name as video-storage. (The other microservices don’t know that
    the Azure storage microservice has been replaced with a mock version.)
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ① 将 DNS 名称设置为 video-storage。（其他微服务不知道 Azure 存储微服务已被模拟版本替换。）
- en: ② Instead of building the container from the azure-storage subdirectory, we
    build the mock version from the mock-storage subdirectory.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们不是从 azure-storage 子目录构建容器，而是从 mock-storage 子目录构建模拟版本。
- en: ③ Shares the storage directory between the host OS and the container and stores
    the videos in this directory. You can inspect them from the host to ensure the
    mock storage microservice works correctly.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 在主机操作系统和容器之间共享存储目录，并将视频存储在此目录中。您可以从主机检查它们，以确保模拟存储微服务正常工作。
- en: It’s a great option for development to be able to replace microservices with
    mocks. It can help make development easier, but there are times when we need to
    focus on the real version of the microservice; we need to test it rather than
    the mock version. At those times, we can simply swap the mock version for the
    real version in the Docker Compose file. If you like, you can try this for yourself.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 能够用模拟替换微服务是开发中的一个很好的选项。它可以帮助简化开发，但有时我们需要关注微服务的实际版本；我们需要测试它而不是模拟版本。在这些时候，我们可以在
    Docker Compose 文件中简单地用实际版本替换模拟版本。如果您愿意，您可以亲自尝试一下。
- en: Listing 9.4 shows the commented out configuration for the real storage microservice.
    Simply uncomment this and then comment out the configuration for the mock version.
    Now rebuild and restart your application. You can now test the real storage microservice
    in development!
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.4 显示了实际存储微服务的已注释配置。只需取消注释此配置，然后注释掉模拟版本的配置。现在重新构建并重启您的应用程序。您现在可以在开发中测试实际存储微服务了！
- en: Listing 9.4 The real storage microservice commented out (extract from chapter-9/example-1/docker-compose.yaml)
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.4 实际存储微服务已注释（摘自第 9 章示例 1 的 docker-compose.yaml）
- en: '[PRE15]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ① Uncomment this to include the Azure storage microservice in the application
    during development. To make this work, you must then comment out the mock storage
    microservice (shown in listing 9.3), effectively replacing it with the real one.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ① 取消注释此行以在开发期间将 Azure 存储微服务包含在应用程序中。为了使此操作生效，您必须先注释掉模拟存储微服务（如列表 9.3 所示），实际上用实际版本替换它。
- en: Listing 9.5 shows the code for the mock storage microservice. The mock version
    replaces the /video and /upload routes from the real storage microservice with
    versions that use the local filesystem. The mock microservice is a drop-in replacement
    because its REST API conforms to the interface of the real microservice.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.5 显示了模拟存储微服务的代码。模拟版本用使用本地文件系统的版本替换了实际存储微服务的 /video 和 /upload 路由。模拟微服务是一个即插即用的替代品，因为它的
    REST API 符合实际微服务的接口。
- en: Listing 9.5 The mock storage microservice (extract from chapter-9/example-1/mock-storage/src/index.js)
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.5 模拟存储微服务（摘自第 9 章示例 1 的 mock-storage/src/index.js）
- en: '[PRE16]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ① Sets the path for storing videos in the local filesystem
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ① 设置在本地文件系统中存储视频的路径
- en: ② HTTP GET route handler that streams a video from storage
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ② HTTP GET 路由处理程序，从存储中流式传输视频
- en: ③ Sends the local file directly as a response to the HTTP request
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 将本地文件直接作为响应发送给 HTTP 请求
- en: ④ HTTP POST route handler that uploads a video to storage
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ④ HTTP POST 路由处理程序，将视频上传到存储
- en: ⑤ Streams the body of the incoming HTTP request (the uploaded file) into a local
    file
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 将传入的 HTTP 请求体（上传的文件）流式传输到本地文件
- en: 9.7.3 The gateway
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.7.3 网关
- en: FlixTube has a single gateway microservice. It’s called a *gateway* because
    it acts as a gateway into the application for our users. For the current version
    of FlixTube, this is the single entry point to the whole application. The gateway
    provides the front-end UI that allows our users to interact with FlixTube in their
    web browser. It also provides a REST API so the front end can interact with the
    backend.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: FlixTube 有一个单独的网关微服务。它被称为 *网关*，因为它充当用户进入应用程序的网关。对于 FlixTube 的当前版本，这是整个应用程序的唯一入口点。网关提供了前端
    UI，使用户能够通过他们的网络浏览器与 FlixTube 交互。它还提供了一个 REST API，以便前端可以与后端交互。
- en: FlixTube doesn’t support any kind of authentication yet, but in the future,
    we’d probably like to upgrade the gateway to authenticate our users. A FlixTube
    user would have to sign in before the gateway allows them to interact with the
    backend.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: FlixTube 目前还不支持任何类型的身份验证，但未来我们可能会升级网关以验证我们的用户。FlixTube 用户必须在网关允许他们与后端交互之前进行登录。
- en: Figure 9.9 shows a potential future for FlixTube with more than one gateway.
    This illustrates a well-known pattern called *backends* *for front ends**.* Each
    front end has its own gateway. There is one gateway for access by a web browser;
    another gateway for access by a mobile app; and another gateway for the FlixTube
    admin portal.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9 展示了 FlixTube 多个网关的潜在未来。这说明了被称为“前端的后端”的已知模式。每个前端都有自己的网关。有一个网关供网络浏览器访问；另一个网关供移动应用访问；还有一个网关供
    FlixTube 管理门户使用。
- en: '![](../Images/CH09_F09_Davis4.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH09_F09_Davis4.png)'
- en: Figure 9.9 What FlixTube would look like with multiple gateways
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9 多个网关的 FlixTube 将看起来如何
- en: If possible, we’d want to keep things simple and to support only a single gateway.
    It’s completely OK to share a gateway across multiple types of front ends. But
    if we find our front ends having different requirements (for instance, different
    forms of authentication between web and mobile or different security considerations
    between the web and admin portals), then *backends for front ends* is a pattern
    that can help.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能的话，我们希望保持简单，并只支持单个网关。在多个类型的客户端之间共享网关是完全可行的。但如果我们发现前端有不同的需求（例如，网络和移动之间的不同认证形式或网络和管理门户之间的不同安全考虑），那么“前端的后端”模式可以提供帮助。
- en: If we do expand to have multiple gateways, we’d then want to use separate hostnames
    or subdomains to access them. For example, the main gateway for the browser could
    use flixtube.com, the mobile gateway using mobile.flixtube.com, and the admin
    portal using admin.flixtube.com. To assign domain names to your application, you’ll
    need to use a DNS provider to buy domain names and configure each one to point
    to the IP address of a particular gateway microservice.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们扩展到拥有多个网关，那么我们就会希望使用单独的主机名或子域名来访问它们。例如，浏览器的主要网关可以使用 flixtube.com，移动网关使用
    mobile.flixtube.com，而管理门户使用 admin.flixtube.com。为了将域名分配给您的应用程序，您需要使用 DNS 提供商购买域名，并将每个域名配置为指向特定网关微服务的
    IP 地址。
- en: Forwarding HTTP requests into the cluster is one of the main jobs of a gateway
    microservice. We’ll see code examples of this in upcoming sections. A more advanced
    gateway (FlixTube isn’t this advanced yet) will have REST API routes that issue
    requests to multiple internal microservices. Then it will integrate multiple responses
    into a single response that is returned to the front end.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 将 HTTP 请求转发到集群是网关微服务的主要任务之一。我们将在接下来的章节中看到这方面的代码示例。更高级的网关（FlixTube 目前还没有这么高级）将具有
    REST API 路由，这些路由会向多个内部微服务发出请求。然后它将多个响应整合成一个返回给前端的单一响应。
- en: For example, imagine a REST API that retrieves an individual user’s history.
    This might require HTTP requests to a user account microservice (FlixTube doesn’t
    have this yet) and the history microservice before integrating a response and
    sending it to the front end. In this theoretical example, the gateway has merged
    the responses of both HTTP requests.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一个 REST API，它检索单个用户的历史记录。这可能需要向用户账户微服务（FlixTube 目前还没有这个）和历史微服务发送 HTTP 请求，然后在整合响应并发送到前端之前。在这个理论示例中，网关合并了这两个
    HTTP 请求的响应。
- en: 9.7.4 The user interface (UI)
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.7.4 用户界面（UI）
- en: If you haven’t had a chance to explore FlixTube’s UI, do so now. Build and start
    the application as discussed in section 9.5.2, then navigate your web browser
    to http:// localhost:4000.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有机会探索 FlixTube 的用户界面，现在就去做吧。按照 9.5.2 节中的讨论构建并启动应用程序，然后使用您的网络浏览器导航到 http://localhost:4000。
- en: Figure 9.10 shows the main page of FlixTube (the video list) *after* some videos
    have been uploaded to it. We can click any video in the list to watch it. We can
    click between Videos, Upload, and History, in the navigation bar at the top to
    switch among the main pages.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.10 展示了 FlixTube（视频列表）在已上传一些视频后的主页。我们可以点击列表中的任何视频来观看它。我们可以在顶部的导航栏中点击“视频”、“上传”和“历史”，在主要页面之间切换。
- en: FlixTube is implemented as a traditional server-rendered web page, rather than
    as a modern single-page application (an SPA) rendered in the browser. If FlixTube
    were a real commercial application, it would most likely be coded as an SPA using
    React, Angular, or Vue.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: FlixTube 是作为一个传统的服务器端渲染网页实现的，而不是作为在浏览器中渲染的现代单页应用程序（SPA）。如果 FlixTube 是一个真正的商业应用程序，它很可能会使用
    React、Angular 或 Vue 编码为一个 SPA。
- en: FlixTube uses server-side rendering via Express and the Handlebars template
    engine with vanilla JavaScript in the front end. The FlixTube front end is plain
    old HTML, CSS, and JavaScript with no fancy modern frameworks.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: FlixTube使用Express和Handlebars模板引擎通过服务器端渲染，前端使用纯JavaScript。FlixTube前端是普通的HTML、CSS和JavaScript，没有任何花哨的现代框架。
- en: Why not use one of the popular modern SPA frameworks? Well, the simple reason
    is that it’s outside the scope of this book. This book isn’t about UIs and that’s
    why the front end is as simple as it can be. (Besides that, I didn’t want to choose
    sides and stoke the war between the SPA framework disciples, but all the cool
    kids use React, right?).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不使用流行的现代SPA框架之一呢？嗯，简单的原因是这超出了本书的范围。这本书不是关于UI的，这就是为什么前端尽可能简单。（此外，我不想选择任何一方，挑起SPA框架信徒之间的战争，但所有酷炫的孩子都在用React，对吧？）。
- en: '![](../Images/CH09_F10_Davis4.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH09_F10_Davis4.png)'
- en: Figure 9.10 The main page of the FlixTube UI shows the list of videos that have
    been uploaded.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10 FlixTube UI的主页显示了已上传的视频列表。
- en: Listing 9.6 is an extract from the gateway microservice’s main code file. It
    shows the HTTP GET route that renders the main page. The main page shows the list
    of uploaded videos. This route handler starts by requesting data from the metadata
    microservice. We then render the web page using the video-list template and input
    the list of videos as the template’s data.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.6是网关微服务主代码文件的摘录。它显示了渲染主页的HTTP GET路由。主页显示了上传的视频列表。此路由处理程序首先从元数据微服务请求数据。然后我们使用视频列表模板渲染网页，并将视频列表作为模板的数据输入。
- en: Listing 9.6 The gateway code that renders the video list web page (extract from
    chapter-9/example-1/gateway/src/index.js)
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.6 渲染视频列表网页的网关代码（摘自第9章/示例-1/网关/src/index.js）
- en: '[PRE17]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ① Declares a HTTP GET route handler that retrieves the main web page and shows
    the list of uploaded videos
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ① 声明一个HTTP GET路由处理程序，用于检索主网页并显示上传的视频列表
- en: ② Makes a HTTP request to the metadata service to get the list of videos
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ② 向元数据服务发送HTTP请求以获取视频列表
- en: ③ Renders a web page using the video-list template (listing 9.8 shows the template).
    We pass the array of videos in as the data for rendering the template.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 使用视频列表模板（列表9.8显示了模板）渲染网页。我们将视频数组作为渲染模板的数据传递。
- en: The code to make the HTTP request in listing 9.6 is using the built-in Node.js
    `http.request` function, so it’s quite verbose. After seeing Axios in chapter
    8, you might wonder why I haven’t used it instead.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.6中制作HTTP请求的代码使用的是内置的Node.js `http.request`函数，因此相当冗长。在看到第8章中的Axios之后，你可能会想知道为什么我没有使用它。
- en: Axios is a fantastic modern library and I highly recommend it! It is simple
    to use, quite flexible, and it works well with the new `async` and `await` keywords
    in Java-Script. The reason it’s not used in this chapter is that it’s easier to
    control the built-in libraries as a Node.js stream, which we aren’t using just
    yet, but you will see examples of that soon.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Axios是一个出色的现代库，我强烈推荐它！它使用简单，相当灵活，并且与Java-Script中的新`async`和`await`关键字配合得很好。它没有在本章中使用的原因是，作为Node.js流控制内置库更容易，但我们还没有使用它，但很快你将看到这方面的例子。
- en: I didn’t use a JavaScript framework for FlixTube, but I did use a CSS framework
    (Tailwind CSS). That’s so that I could make a nice UI without having to mess about
    with the nuts and bolts of CSS.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有为FlixTube使用JavaScript框架，但我确实使用了CSS框架（Tailwind CSS）。这样我就可以制作一个漂亮的UI，而无需与CSS的细节纠缠。
- en: Listing 9.7 shows the main page of FlixTube. This is a HTML document contained
    within a Handlebars template. Handlebars is a simple and powerful template library
    that we can use to generate web pages based on data. If you look back to listing
    9.6, you’ll see that the list of videos is passed as the template data. Now in
    listing 9.7, you can see that we are generating a sequence of HTML `div` elements
    from this template data.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.7显示了FlixTube的主页。这是一个包含在Handlebars模板中的HTML文档。Handlebars是一个简单而强大的模板库，我们可以用它根据数据生成网页。如果你回顾列表9.6，你会看到视频列表作为模板数据传递。现在在列表9.7中，你可以看到我们正在从这个模板数据生成一系列HTML
    `div`元素。
- en: When the web browser requests the main page, the gateway microservice requests
    the data from the metadata microservice. From that data, it renders the HTML to
    display to the user in their web browser.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当网络浏览器请求主页时，网关微服务会从元数据微服务请求数据。从这些数据中，它将渲染HTML以在用户的网络浏览器中显示。
- en: Listing 9.7 The Handlebars template for the video list web page (chapter-9/example-1/gateway/src/views/video-list.hbs)
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.7 视频列表网页的Handlebars模板（chapter-9/example-1/gateway/src/views/video-list.hbs）
- en: '[PRE18]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ① A HTML5 web page
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ① 一个HTML5网页
- en: ② Includes Tailwind CSS. Using a CSS framework makes CSS much easier to deal
    with!
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ② 包含Tailwind CSS。使用CSS框架使CSS处理起来容易得多！
- en: ③ Includes FlixTube-specific CSS
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 包含FlixTube特定的CSS
- en: ④ Renders a navigation bar at the top of the web page
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 在网页顶部渲染导航栏
- en: ⑤ The main content for the web page
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 网页的主要内容
- en: ⑥ Container for the list of videos
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 视频列表的容器
- en: ⑦ Handlebars syntax for rendering the template from data
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 从数据渲染模板的Handlebars语法
- en: ⑧ This element is repeatedly rendered for each video.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 该元素为每个视频重复渲染。
- en: ⑨ Renders a link to the video from the template data
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 从模板数据渲染视频链接
- en: ⑩ Displays a message before uploading videos
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ 在上传视频前显示消息
- en: 9.7.5 Video streaming
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.7.5 视频流
- en: At the heart of FlixTube is video streaming. We first looked at this back in
    chapter 2, and it’s been a theme throughout the book. Now, it’s time to see how
    video streaming works in the completed FlixTube example application. Some of this
    will be revision, but it’s important to see how it works in the bigger context
    now that we have the gateway microservice and the UI.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: FlixTube的核心是视频流。我们早在第2章就讨论了这一点，并且它贯穿了整本书。现在，是时候看看在完成的FlixTube示例应用程序中视频流是如何工作的了。其中一些内容将是复习，但重要的是现在我们已经有了网关微服务和UI，要看到它在更大的上下文中是如何工作的。
- en: Figure 9.11 illustrates the path of a streaming video, starting with external
    cloud storage on the left and ending with display to the user in the web browser
    on the right. The streaming video passes through three microservices on its journey
    to the user. Let’s now follow that journey through the code.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.11说明了流媒体视频的路径，从左侧的外部云存储开始，到右侧在网页浏览器中向用户显示结束。流媒体视频在其到达用户的过程中通过了三个微服务。现在，让我们通过代码跟随这段旅程。
- en: '![](../Images/CH09_F11_Davis4.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图9.11 Davis4](../Images/CH09_F11_Davis4.png)'
- en: Figure 9.11 The path of streaming video through FlixTube
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.11 FlixTube中流媒体视频的路径
- en: Listing 9.8 is an extract that shows where the streaming video journey starts
    in the Azure version of the video-storage microservice. The HTTP GET /video route
    retrieves a video from Azure storage and streams it to the HTTP response. The
    details of how this works aren’t important at the moment, but if you’d like to
    know, see section 4.4.1.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.8是一个摘录，展示了在Azure版本的视频存储微服务中流媒体视频旅程的起始点。HTTP GET /video路由从Azure存储检索视频并将其流式传输到HTTP响应。目前如何工作的细节并不重要，但如果你想了解，请参阅第4.4.1节。
- en: Listing 9.8 Streaming video from Azure storage (extract from chapter-9/example-1/azure-storage/src/index.js)
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.8 从Azure存储流式传输视频（第9章/example-1/azure-storage/src/index.js的摘录）
- en: '[PRE19]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ① The HTTP GET route handler retrieves streaming video from the video-storage
    microservice.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ① HTTP GET路由处理程序从视频存储微服务检索流媒体视频。
- en: ② Inputs the ID of the video to be retrieved as a HTTP query parameter
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: ② 输入要检索的视频ID作为HTTP查询参数
- en: ③ Streams the video from Azure storage to the HTTP response
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 从Azure存储将视频流式传输到HTTP响应
- en: ④ Handles any errors that might occur
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 处理可能发生的任何错误
- en: Continuing our journey to the video-streaming microservice, listing 9.9 is an
    extract showing how the HTTP GET /video route *pipes* the streaming video from
    video storage to its own HTTP response using Node.js streams.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 继续我们的视频流微服务之旅，列表9.9是一个摘录，展示了如何使用Node.js流将HTTP GET /video路由的流媒体视频从视频存储管道传输到其自己的HTTP响应。
- en: The video-streaming microservice also has another job. It broadcasts the “video
    viewed” message to other microservices in the application. This kind of *event-driven*
    programming means that we can later decide to have other microservices respond
    to the event without us having to update the code for the video-streaming microservice.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 视频流微服务还有另一个任务。它向应用程序中的其他微服务广播“已观看视频”消息。这种*事件驱动*编程意味着我们可以在以后决定让其他微服务响应事件，而无需更新视频流微服务的代码。
- en: As it stands, you might remember from section 5.8 in chapter 5, it is the history
    microservice that picks up this message and uses it to record the user’s viewing
    history. This use of indirect messaging keeps the video-streaming and history
    microservices nicely decoupled from each other. It also highlights one of the
    reasons why microservices applications are so flexible and extensible.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从第5章第5.8节所知，是历史微服务接收到这条消息并使用它来记录用户的观看历史。这种间接消息的使用方式使得视频流和历史微服务之间保持良好的解耦。这也突出了微服务应用程序之所以如此灵活和可扩展的原因之一。
- en: Listing 9.9 Forwarding streaming video through the video-streaming microservice
    (extract from chapter-9/example-1/video-streaming/src/index.js)
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.9 通过视频流微服务转发流式视频（摘自第9章/示例-1/video-streaming/src/index.js）
- en: '[PRE20]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ① Defines a HTTP GET route handler that retrieves streaming video from the video-streaming
    microservice
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ① 定义一个HTTP GET路由处理程序，从视频流微服务检索流式视频
- en: ② Forwards the HTTP GET request to the video-storage microservice
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ② 将HTTP GET请求转发到视频存储微服务
- en: ③ Pipes the response (using Node.js streams) from the video-storage microservice
    to the response for this request
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 将视频存储微服务的响应（使用Node.js流）管道传输到该请求的响应中
- en: ④ Broadcasts the video viewed message for other microservices to know that the
    user is watching a video
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 向其他微服务广播观看视频的消息，以便它们知道用户正在观看视频
- en: Our video streaming journey continues to the gateway microservice, the last
    stop before the UI. The HTTP GET /video route in listing 9.10 pipes the streaming
    video from the video-streaming microservice to its own HTTP response. This is
    where the video leaves the cluster, thus delivering the video to the front end.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的视频流之旅继续到网关微服务，这是UI之前的最后一站。列表9.10中的HTTP GET /video路由将流式视频从视频流微服务管道传输到其自己的HTTP响应。这是视频离开集群的地方，因此将视频传送到前端。
- en: Listing 9.10 Forwarding streaming video through the gateway microservice (extractfrom
    chapter-9/example-1/gateway/src/index.js)+
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.10 通过网关微服务转发流式视频（摘自第9章/示例-1/gateway/src/index.js）
- en: '[PRE21]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ① Defines a HTTP GET route handler that retrieves streaming video from the gateway
    microservice
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ① 定义一个HTTP GET路由处理程序，从网关微服务检索流式视频
- en: ② Forwards the HTTP GET request to the video-streaming microservice
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: ② 将HTTP GET请求转发到视频流微服务
- en: ③ Pipes the response (using Node.js streams) from the video-streaming microservice
    to the response for this request
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 将视频流微服务的响应（使用Node.js流）管道传输到该请求的响应中
- en: Our video-streaming journey concludes in the UI. You can see the HTML `video`
    element in listing 9.11\. The `source` element and its `src` field triggers the
    HTTP GET request to the gateway, which triggers the request to video streaming,
    which triggers the request to video storage. The streaming video is then piped
    all the way back through video storage, through video streaming, through the gateway,
    and finally, displayed to the user through the `video` element in their web browser.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的视频流之旅在UI中结束。您可以在列表9.11中看到HTML `video`元素。`source`元素及其`src`字段触发对网关的HTTP GET请求，这触发了对视频流的请求，进而触发了对视频存储的请求。然后，流式视频通过视频存储、视频流、网关，最终通过用户浏览器中的`video`元素显示给用户。
- en: Listing 9.11 Playing the video in the front end with the HTML video element
    (extract from chapter-9/example-1/gateway/src/views/play-video.hbs)
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.11 使用HTML视频元素在前端播放视频（摘自第9章/示例-1/gateway/src/views/play-video.hbs）
- en: '[PRE22]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ① Uses the HTML video element to display streaming video in the front end
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: ① 使用HTML视频元素在前端显示流式视频
- en: ② Links to the /api/video route in the gateway microservice to retrieve streaming
    video for display in the video element
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ② 在网关微服务中链接到/api/video路由以检索用于在视频元素中显示的流式视频
- en: 9.7.6 Video upload
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.7.6 视频上传
- en: Video streaming is just one side of the FlixTube equation. The other is video
    upload, which is how we add videos to FlixTube in the first place. Video upload
    isn’t something we have yet seen in the book, although, it’s similar to how video
    streaming works, so you won’t have any trouble with it.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 视频流只是FlixTube方程的一侧。另一侧是视频上传，这是我们最初如何将视频添加到FlixTube的方式。视频上传在书中尚未介绍，尽管它与视频流的工作方式相似，所以您不会遇到任何麻烦。
- en: Figure 9.12 illustrates the path of video upload through the application. A
    video file is selected by the user and uploaded from the FlixTube front end. The
    uploaded video arrives in the cluster at the gateway microservice before being
    forwarded through the video upload microservice to the video-storage microservice.
    There it is safely secured in the external cloud storage. Again we’ll follow this
    journey through the code.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.12 展示了通过应用程序上传视频的路径。用户通过 FlixTube 前端选择视频文件并上传。上传的视频到达网关微服务的集群，然后通过视频上传微服务转发到视频存储微服务。在那里，它被安全地存储在外部云存储中。我们再次将这段旅程通过代码来追踪。
- en: '![](../Images/CH09_F12_Davis4.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH09_F12_Davis4.png)'
- en: Figure 9.12 The path of a video upload through FlixTube.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.12 通过 FlixTube 上传视频的路径。
- en: Figure 9.13 is a screenshot of FlixTube’s Upload web page. If you followed along
    in section 9.5.2, you will have already seen this and tried uploading a video.
    The user clicks Choose File and selects a file to upload. Once the upload completes,
    the UI is updated (as seen in figure 9.13) to give some feedback that the upload
    completed without error. If an error occurs, the error is displayed instead.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.13 是 FlixTube 上传网页的截图。如果你在 9.5.2 节中跟随了操作，你将已经看到这个并尝试上传一个视频。用户点击选择文件并选择要上传的文件。一旦上传完成，UI
    将更新（如图 9.13 所示），以提供上传无错误完成的反馈。如果发生错误，将显示错误。
- en: '![](../Images/CH09_F13_Davis4.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH09_F13_Davis4.png)'
- en: Figure 9.13 The FlixTube UI for uploading videos
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.13 FlixTube 上传视频的用户界面
- en: Listing 9.12 is a snippet of the front-end code that uploads the video to the
    backend. This is using the `fetch` function to upload the video via a HTTP POST
    request. At this point, you might rightly be thinking why are we using yet another
    HTTP request library?
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.12 是前端代码片段，用于将视频上传到后端。这是使用 `fetch` 函数通过 HTTP POST 请求上传视频。此时，你可能正确地想到为什么我们还要使用另一个
    HTTP 请求库？
- en: Well, normally, we would use something like the Axios library in the front end.
    However, this is a vanilla JavaScript web page with no build process. That makes
    it rather difficult to install an npm package like Axios and use it in our front-end
    JavaScript code; we don’t have a way to bundle it into our front end.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，通常情况下，我们会在前端使用像 Axios 这样的库。然而，这是一个没有构建过程的纯 JavaScript 网页。这使得安装像 Axios 这样的
    npm 包并在我们的前端 JavaScript 代码中使用它变得相当困难；我们没有将其捆绑到前端的方法。
- en: The simplest approach that remains is to use something that comes with the browser
    to make the HTTP request. We could do this using the good old XMLHttpRequest,
    but that’s kind of complicated. Instead, we’ll use the more modern `fetch` function,
    which is also significantly simpler to use. Unfortunately, `fetch` isn’t implemented
    in older versions of web browsers, and that may impact our user base. Fortunately,
    we only use it here in place of not being able to use Axios.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的最简单的方法是使用浏览器自带的功能来发起 HTTP 请求。我们可以使用古老的 XMLHttpRequest 来做这件事，但这有点复杂。相反，我们将使用更现代的
    `fetch` 函数，它也更容易使用。不幸的是，`fetch` 并未在旧版网络浏览器中实现，这可能会影响我们的用户群。幸运的是，我们在这里只是用它来替代无法使用
    Axios 的情况。
- en: Listing 9.12 Using `fetch` to upload videos in the front-end code (extract from
    chapter-9/example-1/gateway/public/js/upload.js)
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.12 使用 `fetch` 在前端代码中上传视频（摘自 chapter-9/example-1/gateway/public/js/upload.js）
- en: '[PRE23]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ① Uses the browser’s “fetch” function to make a HTTP request to the /api/video
    route
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: ① 使用浏览器的“fetch”函数向 /api/video 路径发起 HTTP 请求
- en: ② Sets the file to upload as the body of the HTTP request
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: ② 将要上传的文件设置为 HTTP 请求的主体
- en: ③ Sets the HTTP method to POST
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 设置 HTTP 方法为 POST
- en: ④ Stores the filename and mime type in the request headers
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 在请求头中存储文件名和 MIME 类型
- en: ⑤ Executes after the request is successful
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 请求成功后执行
- en: ⑥ Executes if the request fails
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 如果请求失败则执行
- en: After the upload from the web browser, the HTTP POST request lands in the gateway
    where it is handled by the /api/upload route shown in the following listing. Here
    we see the request forwarded to the video-upload microservice.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在从网络浏览器上传后，HTTP POST 请求到达网关，在那里它被以下列表中显示的 /api/upload 路由处理。在这里，我们看到请求被转发到视频上传微服务。
- en: Listing 9.13 The gateway microservice forwards the HTTP POST to the video-upload
    microservice (extract from chapter-9/example-1/gateway/src/index.js)
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.13 网关微服务将 HTTP POST 请求转发到视频上传微服务（摘自 chapter-9/example-1/gateway/src/index.js）
- en: '[PRE24]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ① Defines a HTTP POST route handler that uploads a video to the gateway microservice
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: ① 定义一个 HTTP POST 路由处理程序，将视频上传到网关微服务
- en: ② Forwards the request to the video-upload microservice
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: ② 将请求转发到视频上传微服务
- en: ③ Pipes the response (using Node.js streams) from the video-upload microservice
    to the response for this request
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 将视频上传微服务的响应（使用 Node.js 流）通过管道传输到当前请求的响应
- en: ④ Pipes the request itself (the body of the request is the video) to another
    request
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 将请求本身（请求体是视频）通过管道传输到另一个请求
- en: Listing 9.14 shows how the video-upload microservice handles the incoming video.
    At this point, we create a unique ID for the video by creating an instance of
    MongoDB’s `ObjectId` class. The request is then forwarded to the video-storage
    microservice.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.14 展示了视频上传微服务如何处理传入的视频。在此阶段，我们通过创建 MongoDB 的 `ObjectId` 类的实例为视频创建一个唯一 ID。然后，请求被转发到视频存储微服务。
- en: After the upload is successful, the message “video uploaded” is broadcast to
    let the other microservice services know that a new video is available within
    the system. The metadata microservice handles this message and records the new
    video in its database.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 上传成功后，消息“视频已上传”被广播出去，以便让其他微服务知道系统中有了新的视频。元数据微服务处理此消息并在其数据库中记录新的视频。
- en: Listing 9.14 Handling video upload via HTTP POST (extract from chapter-9/example-1/video-upload/src/index.js)
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.14 通过 HTTP POST 处理视频上传（摘自 chapter-9/example-1/video-upload/src/index.js）
- en: '[PRE25]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ① Defines a HTTP POST route handler that uploads a video to the video-upload
    microservice
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: ① 定义一个 HTTP POST 路由处理程序，用于将视频上传到视频上传微服务
- en: ② Extracts the original filename from the request header
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: ② 从请求头中提取原始文件名
- en: ③ Creates a unique ID for the new video
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 为新视频创建一个唯一 ID
- en: ④ Adds the video ID to the headers
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 将视频 ID 添加到头信息中
- en: ⑤ Forwards the HTTP request to the video-storage microservice
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 将 HTTP 请求转发到视频存储微服务
- en: ⑥ Successfully captures the video for the video-storage microservice. This is
    the most important thing; we can’t lose our user’s data!
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 成功捕获视频以供视频存储微服务使用。这是最重要的事情；我们不能丢失用户数据！
- en: ⑦ Broadcasts the video uploaded message so that other microservices know a new
    video has uploaded.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 广播视频上传消息，以便其他微服务知道已上传新的视频。
- en: Finally, the uploaded video arrives in the video-storage microservice, which
    you can see in listing 9.15\. From here the video is saved into Azure storage.
    Once this whole chain has completed, we have successfully saved a copy of the
    video the user has uploaded. If you’d like to dive deeper into how a file is added
    to Azure storage, load the full index.js for the video-storage microservice into
    VS Code.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，上传的视频到达视频存储微服务，您可以在列表 9.15 中看到。从这里开始，视频被保存到 Azure 存储。一旦整个链路完成，我们就成功保存了用户上传的视频副本。如果您想深入了解文件如何添加到
    Azure 存储，请将视频存储微服务的完整 index.js 文件加载到 VS Code 中。
- en: Listing 9.15 Streaming the video from HTTP POST to Azure Storage (extract from
    chapter-9/example-1/azure-storage/src/index.js)
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.15 从 HTTP POST 流式传输视频到 Azure 存储（摘自 chapter-9/example-1/azure-storage/src/index.js）
- en: '[PRE26]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ① HTTP POST route handler that uploads a video to Azure Storage
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: ① HTTP POST 路由处理程序，用于将视频上传到 Azure 存储
- en: ② Extracts video details from the request headers
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: ② 从请求头中提取视频详情
- en: ③ Streams the video from the HTTP request to Azure Storage
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 将视频从 HTTP 请求流式传输到 Azure 存储
- en: ④ Indicates a successful upload
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 表示上传成功
- en: ⑤ Indicates that the upload failed
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 表示上传失败
- en: 9.8 Manually deploying FlixTube to production with Terraform
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.8 使用 Terraform 手动部署 FlixTube 到生产环境
- en: If you already have FlixTube up and running in development, that’s a huge step!
    In order to make FlixTube available for use by the general public, we now must
    deploy it to production using the same tools and techniques that we used previously
    in chapters 6 and 7.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经在开发环境中运行了 FlixTube，那么这是一个巨大的进步！为了使 FlixTube 可供公众使用，我们现在必须使用与第 6 章和第 7 章中相同的技术和工具将其部署到生产环境。
- en: These next two sections are the most challenging in this chapter, but if you
    can follow along and get through these, it’s going to be a great experience for
    you. If at any time it seems too difficult, feel free to go back and revisit chapters
    6 and 7, which have more detailed instructions.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 本章接下来的两个部分最具挑战性，但如果您能跟上并完成这些任务，这将是一次极好的体验。如果在任何时候感觉太难，请随时回顾第 6 章和第 7 章，那里有更详细的说明。
- en: 'Ultimately, we aim to have a CD pipeline for FlixTube that automatically deploys
    to production whenever we push updated code to our hosted code repository. Before
    we get to that though, we must first manually deploy FlixTube. Here’s why:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们希望为FlixTube有一个CD管道，每当我们将更新后的代码推送到我们的托管代码仓库时，它会自动部署到生产环境。不过，在我们达到那个目标之前，我们必须首先手动部署FlixTube。原因如下：
- en: '*When first developing your deployment scripts, you’ll do so incrementally.*
    As you evolve your deployment scripts, you’ll need a way to test these, get feedback,
    and fix issues.'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在最初开发部署脚本时，你会逐步进行。* 随着你对部署脚本的演变，你需要一种方法来测试这些脚本，获取反馈，并修复问题。'
- en: '*In the future, if you discover issues in your CD pipeline, you’ll need to
    have the skills to run deployment scripts in development.* This is necessary so
    that you can figure out and fix problems.'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在未来，如果你在你的CD管道中发现问题，你需要有在开发中运行部署脚本的能力。这是必要的，这样你就可以找出并修复问题。*'
- en: Figure 9.14 highlights what we’ll do. We’ll use Terraform to create our infrastructure
    in the cloud. We’ll then use Docker to package and publish our images, and we’ll
    use Terraform to deploy containers to our Kubernetes cluster.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.14突出了我们将要做什么。我们将使用Terraform在云中创建我们的基础设施。然后，我们将使用Docker打包和发布我们的镜像，并使用Terraform将容器部署到我们的Kubernetes集群。
- en: '![](../Images/CH09_F14_Davis4.png)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![图9.14](../Images/CH09_F14_Davis4.png)'
- en: Figure 9.14 Using Terraform to manually deploy FlixTube from the development
    workstation to production
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.14 使用Terraform从开发工作站手动部署FlixTube到生产
- en: 9.8.1 The Terraform scripts structure
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.8.1 Terraform脚本结构
- en: Figure 9.15 shows the layout of the scripts directory for FlixTube. You’ll recognize
    some of the code files here from chapters 6 and 7, but there are also some that
    are new.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.15显示了FlixTube脚本目录的布局。你将在这里识别出一些来自第6章和第7章的代码文件，但也有一些是新的。
- en: Notably, we now see our first use of a Terraform module. The file main.tf in
    the modules/microservice directory is a reusable Terraform code module. We can
    use it to deploy all of our microservice without having to repeat this code. We’ll
    look at the code for this module in a moment.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 显著的是，我们现在看到了第一次使用Terraform模块。在`modules/microservice`目录中的`main.tf`文件是一个可重用的Terraform代码模块。我们可以使用它来部署我们所有的微服务，而无需重复此代码。我们稍后将查看此模块的代码。
- en: '![](../Images/CH09_F15_Davis4.png)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![图9.15](../Images/CH09_F15_Davis4.png)'
- en: Figure 9.15 The scripts subdirectory contains the Terraform scripts to deploy
    FlixTube to production
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.15 脚本子目录包含将FlixTube部署到生产的Terraform脚本
- en: 9.8.2 Prerequisites
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.8.2 前提条件
- en: 'To deploy FlixTube, you’ll need a few tools installed. You’ll already have
    these if you followed along in chapters 6 and 7; if not, you can install these
    now. First, you need the Azure CLI tool. Check if it’s installed like this:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署FlixTube，你需要安装一些工具。如果你在第6章和第7章中跟随了操作，你已经有这些工具了；如果没有，你现在可以安装这些工具。首先，你需要Azure
    CLI工具。检查它是否已安装，方法如下：
- en: '[PRE27]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If you don’t already have the Azure CLI tool, follow the installation instructions
    here:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有Azure CLI工具，请按照以下安装说明进行操作：
- en: '[https://docs.microsoft.com/en-us/cli/azure/install-azure-cli](https://docs.microsoft.com/en-us/cli/azure/install-azure-cli)'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/cli/azure/install-azure-cli](https://docs.microsoft.com/en-us/cli/azure/install-azure-cli)'
- en: 'You also need Terraform installed. Check if you have it like this:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要安装Terraform。检查你是否已经安装了它，方法如下：
- en: '[PRE28]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Otherwise, install the latest version from here:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，从以下链接安装最新版本：
- en: '[https://www.terraform.io/downloads.html](https://www.terraform.io/downloads.html)'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.terraform.io/downloads.html](https://www.terraform.io/downloads.html)'
- en: 9.8.3 Azure authentication
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.8.3 Azure身份验证
- en: Before deploying infrastructure to Azure, you’ll first need to authenticate
    with your account. If you followed along in chapters 6 and 7, you have already
    done this. If not, then refer back to section 6.6.2 for detailed instructions.
    Use the Azure CLI tool to check which account you are currently using by typing
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在将基础设施部署到Azure之前，你首先需要使用你的账户进行身份验证。如果你在第6章和第7章中跟随了操作，你已经完成了这项操作。如果没有，请参阅第6.6.2节以获取详细说明。使用Azure
    CLI工具，通过输入以下命令来检查你当前正在使用哪个账户：
- en: '[PRE29]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Copy the output because you’ll soon need values from the `id` field (your Azure
    subscription ID) and the `tenantID` field.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 复制输出，因为你很快就需要从`id`字段（你的Azure订阅ID）和`tenantID`字段中获取值。
- en: Note Make sure you are using the right account! It might be embarrassing if
    you accidentally deploy infrastructure to your work account.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：确保你使用的是正确的账户！如果你不小心将基础设施部署到工作账户，可能会很尴尬。
- en: 'You also need to create a service principal that your Kubernetes cluster uses
    to interact with your Azure account (for example, when it creates an Azure load
    balancer for you). If you already have a service principal from chapter 6, you
    can reuse that now; otherwise, create a new one like this:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要创建一个服务主体，你的 Kubernetes 集群将使用它来与你的 Azure 账户交互（例如，当它为你创建 Azure 负载均衡器时）。如果你已经在第
    6 章中有一个服务主体，你现在可以重用它；否则，创建一个新的，如下所示：
- en: '[PRE30]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Be sure to replace `<subscription-id>` with your actual subscription ID that
    you noted a moment ago. Then copy the output, which you’ll need soon. The values
    you’ll need are from `appId` (which we call `client_id` in our Terraform script)
    and `password` (which we call `client_secret`) fields. For a more detailed description
    of creating a service principal, see section 6.11.2.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要将 `<subscription-id>` 替换为你刚才记下的实际订阅 ID。然后复制输出结果，你很快就会需要它。你需要的是来自 `appId`（在我们的
    Terraform 脚本中我们称之为 `client_id`）和 `password`（我们称之为 `client_secret`）字段中的值。有关创建服务主体的更详细说明，请参阅第
    6.11.2 节。
- en: 9.8.4 Configuring storage
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.8.4 配置存储
- en: To deploy FlixTube to production, you also need an Azure storage account. The
    Azure storage microservice uses this account to store and retrieve videos. If
    you followed along in chapter 4, you already have an account, and you can reuse
    that if you like. Otherwise, follow the instructions in section 4.4.1 to create
    a storage account.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 FlixTube 部署到生产环境，你还需要一个 Azure 存储账户。Azure 存储微服务使用此账户来存储和检索视频。如果你在第 4 章中跟随操作，你已经有一个账户，并且如果你愿意可以重用它。否则，按照第
    4.4.1 节中的说明创建一个存储账户。
- en: You’ll need to create a videos container in your storage account. Note that
    this isn’t a Docker *container* ; it’s the container concept from Azure storage,
    a container in which we can store arbitrary files. Make a note of your storage
    account name and access key. You’ll need these soon.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在你的存储账户中创建一个视频容器。请注意，这并不是一个 Docker *容器*；这是 Azure 存储中的容器概念，一个可以存储任意文件的容器。记下你的存储账户名称和访问密钥。你很快就会需要这些信息。
- en: 9.8.5 Deploying the application
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.8.5 部署应用程序
- en: 'Now it’s time to invoke Terraform to evaluate our scripts and deploy FlixTube
    to production. First, we must initialize Terraform. To do this, initialize Terraform
    and install the various providers that we need:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候调用 Terraform 来评估我们的脚本并将 FlixTube 部署到生产环境了。首先，我们必须初始化 Terraform。为此，初始化 Terraform
    并安装我们需要的各种提供者：
- en: '[PRE31]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now invoke Terraform to deploy our infrastructure:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 现在调用 Terraform 来部署我们的基础设施：
- en: '[PRE32]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Before it begins, you must provide values for the following input variables:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，你必须为以下输入变量提供值：
- en: '`app_version` —You can just type 1 the first time. For subsequent times that
    you invoke `terraform apply`, you should increment this number.'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app_version` —第一次你可以直接输入 1。在随后的 `terraform apply` 调用中，你应该增加这个数字。'
- en: '`client_id` —The ID of your Azure service principal that you jotted down in
    section 9.8.3.'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`client_id` —你在第 9.8.3 节中记下的 Azure 服务主体的 ID。'
- en: '`client_secret` —The password for your service principal.'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`client_secret` —你的服务主体的密码。'
- en: '`storage_account_name` —The name of your Azure storage account for storing
    videos that you jotted down in section 9.8.4.'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`storage_account_name` —你在第 9.8.4 节中记下的用于存储视频的 Azure 存储账户名称。'
- en: '`storage_access_key` —The access key for your storage account.'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`storage_access_key` —你的存储账户的访问密钥。'
- en: Deploying FlixTube will take some time. Feel free to make a cup of tea (or several).
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 部署 FlixTube 需要一些时间。你可以随意泡一杯茶（或者几杯）。
- en: 9.8.6 Checking that it works
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.8.6 检查是否工作
- en: 'To check that FlixTube is deployed and functioning, we can load its front end
    into our web browser. For that, though, we must know its IP address. Just like
    we did in various sections from chapter 7, we can use the Kubernetes CLI tool
    to do this:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查 FlixTube 是否已部署并正常工作，我们可以将其前端加载到我们的网页浏览器中。为此，我们必须知道它的 IP 地址。就像我们在第 7 章的各个部分中所做的那样，我们可以使用
    Kubernetes CLI 工具来完成这个任务：
- en: '[PRE33]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: To remember how to install and use Kubectl, revisit section 6.12\. You can see
    the tabular output from Kubectl that is shown in figure 9.16\. Find the IP address
    in the `EXTERNAL-IP` column for the gateway container. Copy the IP address into
    your web browser.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 要记住如何安装和使用 Kubectl，请回顾第 6.12 节。你可以看到 Kubectl 显示在图 9.16 中的表格输出。在网关容器的 `EXTERNAL-IP`
    列中找到 IP 地址。将 IP 地址复制到你的网页浏览器中。
- en: '![](../Images/CH09_F16_Davis4.png)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH09_F16_Davis4.png)'
- en: Figure 9.16 Using the Kubernetes command-line tool to get the IP address of
    the gateway so we can test FlixTube in the browser
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.16 使用 Kubernetes 命令行工具获取网关的 IP 地址，以便我们可以在浏览器中测试 FlixTube
- en: You don’t need to use any particular port number. We used port 4000 to access
    the dev version of FlixTube, but FlixTube in production is configured to use port
    80\. This is the default port for HTTP (because it’s the default, we don’t need
    to specify it).
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要使用任何特定的端口号。我们使用4000端口来访问FlixTube的开发版本，但生产中的FlixTube配置为使用端口80。这是HTTP的默认端口（因为它默认，所以我们不需要指定它）。
- en: You might have noticed that we are using the HTTP protocol here. That’s why
    the browser says “Not secure” next to Fixtube’s IP address. For security purposes,
    we should actually be using (like all modern web servers) the secure version of
    HTTP, called HTTPS. This stands for Hypertext Transfer Protocol Secure, and we’ll
    mention it again in chapter 11\. If all has gone according to plan, you should
    now be able to navigate the FlixTube UI to upload and play videos.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们在这里使用的是HTTP协议。这就是为什么浏览器会在Fixtube的IP地址旁边显示“不安全”。出于安全考虑，我们实际上应该使用（就像所有现代Web服务器一样）HTTP的安全版本，称为HTTPS。这代表安全超文本传输协议，我们将在第11章再次提到。如果一切按计划进行，你现在应该能够导航到FlixTube
    UI来上传和播放视频。
- en: At this point, feel free to experiment with FlixTube and Terraform however you
    like. You can make changes to the FlixTube or Terraform code and then apply your
    changes using `terraform apply`. Do this as many times as you like.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你可以随意尝试使用FlixTube和Terraform。你可以修改FlixTube或Terraform代码，然后使用`terraform apply`应用你的更改。你可以这样做多少次就做多少次。
- en: 9.8.7 Teardown
  id: totrans-357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.8.7 拆卸
- en: 'When you are done with FlixTube, make sure you clean it all up. Running this
    infrastructure in the cloud will cost you money. If you only just created your
    Azure account, you’ll be using the free credit that it gives you to try it out,
    but let’s not waste it. Destroy your infrastructure when you are finished with
    it:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成FlixTube后，确保清理所有内容。在云中运行此基础设施将花费你金钱。如果你刚刚创建了Azure账户，你将使用它提供的免费信用额度来尝试它，但让我们不要浪费它。当你完成使用后，销毁你的基础设施：
- en: '[PRE34]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 9.8.8 Terraform modules
  id: totrans-360
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.8.8 Terraform模块
- en: Much of Terraform code in the chapter 9 code repository is the same as that
    already seen in chapters 6 and 7\. However, there’s one new thing that needs further
    explanation.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 第9章代码库中的大部分Terraform代码与第6章和第7章中已经看到的代码相同。然而，这里有一个需要进一步解释的新内容。
- en: 'Remember the Terraform code to deploy a microservice? If you need a refresher,
    skim over section 7.6\. We could get by with simply repeating that same code over
    and over for each microservice in FlixTube. But most of the code is the same,
    so it’s not an efficient way of working. To cope with this, we’ll bring in a more
    advanced feature of Terraform: Terraform modules.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 记得部署微服务的Terraform代码吗？如果你需要复习，可以快速浏览第7.6节。我们可以通过简单地重复相同的代码来应对FlixTube中的每个微服务。但大部分代码是相同的，所以这不是一种高效的工作方式。为了应对这种情况，我们将引入Terraform的一个更高级的功能：Terraform模块。
- en: Terraform modules allow us to write reusable code modules that we can use in
    different circumstances by supplying different input variables. Listing 9.16 shows
    the Terraform module that is used to deploy each of FlixTube’s six microservices.
    This looks, more or less, just like any other Terraform code file.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform模块允许我们编写可重用的代码模块，我们可以通过提供不同的输入变量在不同的环境中使用它们。列表9.16显示了用于部署FlixTube六个微服务的Terraform模块。这看起来或多或少就像任何其他Terraform代码文件。
- en: The listing starts with a Kubernetes deployment that instantiates a microservice
    into our Kubernetes cluster. It ends with a Kubernetes service that makes the
    microservice accessible within the cluster via DNS. Note that the `type` field
    of the Kubernetes service is parameterized so that we can enable or disable an
    Azure load balancer for the microservice. You’ll learn more about what a load
    balancer can do in the next chapter. For now, this is so we can allocate an IP
    address to the gateway microservices and make it accessible to the outside world.
    (This is how our customers will interact with our application.)
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 列表从Kubernetes部署开始，该部署将微服务实例化到我们的Kubernetes集群中。它以Kubernetes服务结束，该服务通过DNS使微服务在集群内可访问。请注意，Kubernetes服务的`type`字段是参数化的，这样我们就可以为微服务启用或禁用Azure负载均衡器。你将在下一章中了解更多关于负载均衡器可以做什么的信息。现在，这是为了我们可以分配一个IP地址给网关微服务，并使其对外界可访问。（这就是我们的客户将如何与我们应用程序交互的方式。）
- en: There’s nothing else particularly special about the Terraform code in listing
    9.16, other than it being located in the modules/microservice subdirectory. Note
    the numerous input variables defined at the start of the listing. These are normal
    Terraform variables, but in this instance, these are the inputs that allow us
    to customize the module’s behavior. For example, we can set the name of the microservice
    through the `service_name` variable. We must also pass in details of the container
    registry that hosts the images for the microservices. Another significant variable
    is `env`. This allows us to configure the set of environment variables individually
    for each microservice.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.16中的Terraform代码没有特别特殊的地方，除了它位于modules/microservice子目录中。请注意列表开头定义的多个输入变量。这些是正常的Terraform变量，但在这个例子中，这些是允许我们定制模块行为的输入。例如，我们可以通过`service_name`变量设置微服务的名称。我们还必须传递托管微服务镜像的容器注册库的详细信息。另一个重要的变量是`env`。它允许我们为每个微服务单独配置环境变量集。
- en: Listing 9.16 A reusable Terraform module deploys a microservice to Kubernetes
    (abbreviated from chapter-9/example-1/scripts/modules/microservice/main.tf)
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.16 一个可重用的Terraform模块将微服务部署到Kubernetes（摘自第9章/示例1/脚本/modules/microservice/main.tf）
- en: '[PRE35]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: ① Defines variables that are inputs to this Terraform module
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: ① 定义此Terraform模块的输入变量
- en: ② Defines local variables to use in this module
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: ② 定义在此模块中使用的局部变量
- en: ③ Deploys a container to our Kubernetes cluster
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 将容器部署到我们的Kubernetes集群
- en: ④ Uses variables to customize the configuration of this module for each microservice
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 使用变量来为每个微服务定制此模块的配置
- en: ⑤ Uses variables to setup environment variables that are specific for each microservice
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 使用变量来设置针对每个微服务特定的环境变量
- en: ⑥ Deploys a service that makes the container accessible from other containers
    via DNS
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 部署一个服务，使容器可以通过DNS从其他容器访问
- en: ⑦ Uses variables to customize the configuration of this module for each microservice
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 使用变量来为每个微服务定制此模块的配置
- en: ⑧ Uses variables to customize the configuration of this module for each microservice
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 使用变量来为每个微服务定制此模块的配置
- en: Listing 9.17 shows how we use the Terraform module to deploy our microservices.
    Only the gateway microservice is shown. The others are omitted because they all
    look much the same, although, some have different configurations for their environment
    variables. In the following listing, note how the module is imported, how its
    source file is specified, and how environment variables are configured.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.17展示了我们如何使用Terraform模块来部署我们的微服务。这里只展示了网关微服务。其他服务被省略，因为它们看起来几乎相同，尽管它们的环境变量配置可能有所不同。在下面的列表中，请注意模块是如何导入的，其源文件是如何指定的，以及环境变量是如何配置的。
- en: Listing 9.17 The Terraform microservice module deploys the gateway microservice
    to Kubernetes (abbreviated from chapter-9/example-1/scripts/microservices.tf)
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.17 Terraform微服务模块将网关微服务部署到Kubernetes（摘自第9章/示例1/脚本/microservices.tf）
- en: '[PRE36]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: ① Sets local variables for use across this script
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: ① 设置用于整个脚本的局部变量
- en: ② Imports the microservice Terraform module (the one from listing 9.16) to deploy
    our gateway microservice
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: ② 导入微服务Terraform模块（来自列表9.16），以部署我们的网关微服务
- en: ③ Specifies the source of the module loaded from the subdirectory ./modules/microservice,
    which contains the file main.tf (the one from listing 9.16)
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 指定从子目录./modules/microservice加载的模块的来源，其中包含main.tf文件（来自列表9.16）
- en: ④ Sets input variables to configure the microservice module for the gateway
    microservice
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 将输入变量设置为配置网关微服务的微服务模块
- en: ⑤ Configures environment variables that are specific to the individual microservice
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 配置针对单个微服务的特定环境变量
- en: Terraform modules are a more advanced feature of Terraform, and there’s still
    plenty more in Terraform for you to explore. See the end of this chapter for a
    reference to go deeper into Terraform.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform模块是Terraform的高级功能之一，而且Terraform中还有更多内容等待您去探索。请参阅本章末尾，以获取深入了解Terraform的参考信息。
- en: 9.9 Continuous delivery to production
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.9 持续交付到生产环境
- en: After manually deploying FlixTube to production, we are now ready to bring the
    continuous delivery (CD) pipeline online.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在手动将FlixTube部署到生产环境之后，我们现在可以上线持续交付（CD）管道。
- en: You can follow along, but this can be even more challenging than the previous
    section, especially if something goes wrong! You might have to go back to manual
    deployment (what we just did in section 9.7) to figure out the problem.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以跟随操作，但这可能比上一节更具挑战性，尤其是如果出现问题的话！您可能需要回到手动部署（我们在9.7节中刚刚做过的）来找出问题。
- en: As we did in chapter 7, we’ll create our CD pipeline with Bitbucket Pipelines.
    It should be fairly easy for you to transfer this over to any other CD platform.
    Like I said in chapter 7, a CD pipeline is really just a glorified shell script,
    even when some providers also give you a fancy UI.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在第7章中做的那样，我们将使用Bitbucket Pipelines创建我们的CD管道。对于您来说，将其转移到任何其他CD平台应该相当容易。正如我在第7章中所说的，CD管道实际上只是一个被美化的shell脚本，即使某些提供商也提供了花哨的UI。
- en: Porting your deployment shell script from one provider to another isn’t difficult.
    However, Bitbucket is good value because it provides a free tier. It’s worthwhile
    following the instructions here to practice getting this working before you try
    taking it to a different CD provider. Figure 9.17 illustrates the structure of
    FlixTube’s CD pipeline.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的部署shell脚本从一个提供商迁移到另一个提供商并不困难。然而，Bitbucket因其提供免费层而具有很高的性价比。在尝试将其迁移到不同的持续交付（CD）提供商之前，遵循这里的说明来练习使其工作是有价值的。图9.17展示了FlixTube的CD管道结构。
- en: '![](../Images/CH09_F17_Davis4.png)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH09_F17_Davis4.png)'
- en: Figure 9.17 The continuous delivery (CD) pipeline for FlixTube
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.17 FlixTube的持续交付（CD）管道
- en: 9.9.1 Prerequisites
  id: totrans-392
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.9.1 前提条件
- en: You’ll need an account with Bitbucket. You’ll already have this if you followed
    along in chapter 7\. Otherwise, signup for a free account at [https://bitbucket.org](https://bitbucket.org).
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一个Bitbucket账户。如果您在第7章中跟随了操作，您已经有了这个账户。否则，请前往[https://bitbucket.org](https://bitbucket.org)注册一个免费账户。
- en: 9.9.2 Setting up your code repository
  id: totrans-394
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.9.2 设置您的代码存储库
- en: The next step is to import FlixTube’s code into a Bitbucket code repository.
    Copy the entire contents of the example-1 subdirectory from the chapter 9 code
    repository to a new location. Create a fresh Git repo here and then push the code
    to your hosted Bitbucket repository. Next, enable Bitbucket Pipelines for the
    repository. Revisit section 7.7.2 for detailed instructions on the Bitbucket repository
    setup.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将FlixTube的代码导入到Bitbucket代码存储库中。将第9章代码存储库中example-1子目录的全部内容复制到一个新位置。在这里创建一个新的Git仓库，然后将代码推送到您的托管Bitbucket仓库。接下来，为存储库启用Bitbucket
    Pipelines。请参阅7.7.2节以获取有关Bitbucket存储库设置的详细说明。
- en: Now, configure your environment variables for the repository. You need to add
    variables for Azure authentication just like you did in section 7.7.6\. For security
    reasons, we’ll store sensitive configuration details as repository variables instead
    of storing these in the code. Like we did in chapter 7, add variables for ARM_CLIENT_ID,
    ARM_CLIENT_SECRET, ARM_TENANT_ID, and ARM_SUBSCRIPTION_ID. You noted down the
    values for these variables earlier in section 9.8.3.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，配置您的环境变量以用于存储库。您需要添加与Azure身份验证相关的变量，就像在7.7.6节中所做的那样。出于安全原因，我们将敏感配置细节作为存储库变量存储，而不是将这些存储在代码中。就像在第7章中做的那样，添加ARM_CLIENT_ID、ARM_CLIENT_SECRET、ARM_TENANT_ID和ARM_SUBSCRIPTION_ID的变量。您在9.8.3节中已经记录了这些变量的值。
- en: In addition, we need to add some new variables to authenticate the video-storage
    microservice’s access to the Azure storage account where we store the videos.
    For that, also add variables for STORAGE_ACCOUNT_NAME and STORAGE_ACCESS_KEY and
    set these to the values you noted in section 9.8.4.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要添加一些新变量来验证视频存储微服务对存储视频的Azure存储账户的访问权限。为此，也添加STORAGE_ACCOUNT_NAME和STORAGE_ACCESS_KEY的变量，并将这些值设置为在9.8.4节中记录的值。
- en: 9.9.3 Preparing the backend
  id: totrans-398
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.9.3 准备后端
- en: Before the first invocation of your CD pipeline, you need to configure the backend
    so that Terraform’s state file persists between subsequent invocations. For a
    refresher on Terraform state, revisit section 6.8.7 and section 7.7.4.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的CD管道首次调用之前，您需要配置后端，以便Terraform的状态文件在后续调用之间持久化。关于Terraform状态的复习，请参阅6.8.7节和7.7.4节。
- en: Create a different Azure storage container for use by Terraform. You can use
    the one you created in chapter 7 for this purpose or create a new one. Don’t reuse
    the videos container for this! That would be using the one container for different
    purposes, and that’s the kind of thing that ultimately makes it more difficult
    to understand and reason about your application.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 为Terraform创建一个不同的Azure存储容器。您可以使用在第7章中创建的容器，或者创建一个新的容器。不要重复使用视频容器！这样会使用同一个容器进行不同的目的，这最终会使理解并推理您的应用程序变得更加困难。
- en: The Terraform script backend.tf is already configured to store the Terraform
    state in our Azure storage account. You just need to uncomment the code in that
    file (you commented it while you were manually deploying FlixTube). Make sure
    you set the details to your own storage account and container.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform脚本backend.tf已经配置为将Terraform状态存储在我们的Azure存储账户中。您只需取消注释该文件中的代码（您在手动部署FlixTube时注释了它）。请确保设置详细信息以匹配您自己的存储账户和容器。
- en: Listing 9.18 shows backend.tf after we have uncommented the code. Make sure
    you rename the resource group and storage account to those that exist in your
    own Azure account. You’ll also need to create an Azure storage container called
    `terraform`. Terraform will persist its state into this container under the name
    terraform.tfstate.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.18显示了在取消注释代码后的backend.tf。请确保将资源组和存储账户重命名为您自己的Azure账户中存在的名称。您还需要创建一个名为`terraform`的Azure存储容器。Terraform将在此容器下以`terraform.tfstate`的名称持久化其状态。
- en: Listing 9.18 Terraform backend configuration (chapter-9/example-1/scripts/backend.tf)
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.18 Terraform后端配置（第9章/示例-1/脚本/backend.tf）
- en: '[PRE37]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: ① Sets the name of the resource group that contains the storage account. Rename
    this to a resource group that exists in your Azure account.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: ① 设置包含存储账户的资源组名称。将其重命名为您Azure账户中存在的资源组。
- en: ② Sets the name of the storage account in which we store the Terraform state.
    Rename this to a storage account that exists in your Azure account.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: ② 设置存储Terraform状态的存储账户名称。将其重命名为您Azure账户中存在的存储账户。
- en: ③ The name of the container in which we store the Terraform state. No need to
    rename this, but make sure the container exists in your Azure account.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 存储Terraform状态的容器名称。无需重命名，但请确保该容器存在于您的Azure账户中。
- en: ④ The name of the file in which we store the Terraform state. This can be set
    to anything, but we are using the default name of the Terraform state file because
    that makes sense and we can easily remember what it means.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 存储Terraform状态的文件名。这可以设置为任何名称，但我们使用Terraform状态文件的默认名称，因为这更有意义，我们也容易记住它的含义。
- en: 9.9.4 The deployment shell script
  id: totrans-409
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.9.4 部署shell脚本
- en: As mentioned earlier, a shell script is usually what’s at the heart of any CD
    pipeline. Listing 9.19 is the deployment shell script for FlixTube. Note that
    it’s barely different from the deployment script from chapter 7\. In listing 9.19,
    some of the code is omitted for brevity, and there’s a couple of extra environment
    variables being passed through to Terraform.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，shell脚本通常是任何持续交付（CD）管道的核心。列表9.19是FlixTube的部署shell脚本。请注意，它与第7章中的部署脚本几乎没有区别。在列表9.19中，为了简洁起见，省略了一些代码，并且有几个额外的环境变量被传递给Terraform。
- en: Most of our deployment code is in Terraform code, that’s why this shell script
    remains so small. There is plenty more we could do directly in this shell script
    if we wanted, for example, building and publishing Docker images. But for FlixTube,
    at least, we have managed to contain our entire deployment within the Terraform
    code. To revise the deployment shell script in more detail, revisit section 7.7.3.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的大部分部署代码都在Terraform代码中，这就是为什么这个shell脚本如此之小。如果我们想在这里直接做更多的事情，比如构建和发布Docker镜像，我们完全可以做到。但至少对于FlixTube来说，我们已经成功地将整个部署包含在Terraform代码中。要更详细地修订部署shell脚本，请回顾第7.7.3节。
- en: Listing 9.19 A shell script for deployment using Terraform (extract from chapter-9/example-1/scripts/deploy.sh)
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.19 使用Terraform进行部署的shell脚本（第9章/示例-1/脚本/deploy.sh摘录）
- en: '[PRE38]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: ① Changes to the directory that contains our Terraform scripts
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: ① 修改包含我们的Terraform脚本的目录
- en: ② Invokes Terraform initialization
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: ② 调用Terraform初始化
- en: ③ Invokes Terraform apply with auto approve enabled, then runs our Terraform
    scripts and deploys our infrastructure and microservices
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 启用自动批准后调用Terraform apply，然后运行我们的Terraform脚本并部署我们的基础设施和微服务
- en: ④ Passing environment variables through for our Terraform scripts
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 通过环境变量传递给我们的Terraform脚本
- en: 9.9.5 FlixTube’s CD configuration
  id: totrans-418
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.9.5 FlixTube的CD配置
- en: The final piece of the CD pipeline puzzle is the configuration file. For Bitbucket
    Pipelines, this is a YAML file that is placed in the root of your code repository.
    It’s called bitbucket-pipelines.yaml. Some other CD providers use similar YAML
    formats.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: CD管道拼图中最后一块是配置文件。对于Bitbucket Pipelines，这是一个放置在你代码仓库根目录的YAML文件。它被称为bitbucket-pipelines.yaml。一些其他CD提供商使用类似的YAML格式。
- en: Listing 9.20 shows the simple CD pipeline configuration for FlixTube. This is
    simple because all we are really doing here is invoking the deployment shell script
    that we saw in listing 9.19\. For more details on Bitbucket Pipelines configuration,
    revisit section 7.7.5.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.20显示了FlixTube的简单CD管道配置。这是因为我们在这里真正做的只是调用我们在列表9.19中看到的部署shell脚本。有关Bitbucket
    Pipelines配置的更多详细信息，请参阅第7.7.5节。
- en: Listing 9.20 CD configuration for Bitbucket Pipelines (chapter-9/example-1/bitbucket-pipelines.yaml)
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.20 Bitbucket Pipelines的CD配置（chapter-9/example-1/bitbucket-pipelines.yaml）
- en: '[PRE39]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: ① Invokes our deployment shell script
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: ① 调用我们的部署shell脚本
- en: 9.9.6 Testing the continuous delivery (CD) pipeline
  id: totrans-424
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.9.6 测试持续交付（CD）管道
- en: Now we are ready to test our CD pipeline. Assuming your repository is configured
    and you have enabled Bitbucket Pipelines (see section 9.9.2), we need to push
    an update to the code. We can also trigger a CD pipeline manually in the Bitbucket
    Pipelines dashboard, but the usual way to trigger deployment is to change some
    code and push the change to our hosted repository. Let’s test that it works.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备测试我们的CD管道。假设你的仓库已配置并且你已启用Bitbucket Pipelines（见第9.9.2节），我们需要推送代码更新。你还可以在Bitbucket
    Pipelines仪表板中手动触发CD管道，但通常触发部署的方式是更改一些代码并将更改推送到我们的托管仓库。让我们测试一下它是否工作。
- en: Try pushing a code change-only a small change is necessary. Maybe change some
    text in the UI? Then save the file, commit the change, and push it to Bitbucket.
    You can then watch in the Bitbucket Pipelines dashboard as the pipeline is triggered.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试推送一个代码更改——只需要进行一个小改动即可。也许更改一下UI中的文本？然后保存文件，提交更改，并将其推送到Bitbucket。然后你可以在Bitbucket
    Pipelines仪表板中观察管道被触发。
- en: Note The first time the pipeline is invoked, it will take some time as it deploys
    the first instance of your infrastructure and microservices.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：第一次调用管道时，由于部署了你的基础设施和微服务的第一个实例，所以会花费一些时间。
- en: Once it’s ready, you can again use `kubectl get services` (like in section 9.8.6)
    to get the IP address of the gateway to load in your web browser and do some testing.
    Now you are all set up for continuous deployment! Any code changes you push to
    Bitbucket will automatically be deployed to production.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦准备就绪，你就可以再次使用 `kubectl get services`（如第9.8.6节中所述）来获取网关的IP地址，然后在你的网页浏览器中加载并进行一些测试。现在你已经为持续部署做好了准备！你推送到Bitbucket的任何代码更改都将自动部署到生产环境。
- en: 9.9.7 Adding automated testing
  id: totrans-429
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.9.7 添加自动化测试
- en: A final step that you can take with your CD pipeline is to add automated testing.
    The example code for chapter 9 includes some automated tests that you might have
    tried out earlier in section 9.6\. Adding automated testing to your application
    is as simple as putting the right commands in the right places.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用CD管道执行的最后一步是添加自动化测试。第9章的示例代码包括一些你可能已经在第9.6节中尝试过的自动化测试。将自动化测试添加到你的应用程序就像将正确的命令放在正确的位置一样简单。
- en: This is simplified because we are following conventions. This means we only
    need to know one command and that is `npm test`. We don’t have to remember whether
    we are using Jest, Cypress, or some other JavaScript testing framework. Whatever
    we use, we only need to make sure that the script for `npm test` is configured
    to invoke it.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们遵循了约定。这意味着我们只需要知道一个命令，那就是 `npm test`。我们不需要记住我们是否在使用Jest、Cypress或其他JavaScript测试框架。无论我们使用什么，我们只需要确保
    `npm test` 的脚本配置正确，以便调用它。
- en: As for the right place to invoke this command, that’s more difficult because
    we have our entire application in a single repository and configured with a single
    CD pipeline. We could invoke `npm test` from our deployment shell script (listing
    9.21) or directly from our Bitbucket Pipelines configuration file (listing 9.22).
    Listings 9.21 and 9.22 show both ways this might work for the metadata microservice.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 至于调用此命令的正确位置，这更困难，因为我们有一个完整的应用程序在一个仓库中，并且配置了一个CD管道。我们可以从我们的部署shell脚本（列表9.21）或直接从我们的Bitbucket
    Pipelines配置文件（列表9.22）中调用 `npm test`。列表9.21和9.22显示了这两种方法可能适用于元数据微服务。
- en: As you might imagine, this is just the tip of the iceberg. As we build more
    automated tests for our other microservices, we’ll have to invoke `npm test` repeatedly
    for each microservice. That doesn’t seem elegant, but it will be resolved when
    we transition to a multi-repo scalable deployment architecture. Just hold on until
    chapter 11 for more on that.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想，这仅仅是冰山一角。随着我们为其他微服务构建更多的自动化测试，我们不得不为每个微服务重复调用 `npm test`。这看起来并不优雅，但当我们过渡到多仓库可扩展部署架构时，这个问题将会得到解决。只需耐心等待第
    11 章的更多内容。
- en: Listing 9.21 Adding automated tests to the deployment shell script
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.21 将自动化测试添加到部署 shell 脚本中
- en: '[PRE40]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: ① Causes subsequent failing commands in the shell script to fail the entire
    script
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: ① 导致 shell 脚本中后续失败的命令使整个脚本失败
- en: ② Changes directory to the metadata microservice
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: ② 切换到元数据微服务目录
- en: ③ Installs dependencies (this installs Jest)
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 安装依赖项（这会安装 Jest）
- en: ④ Runs the tests. If this fails, the shell aborts with an error code. This in
    turn aborts the CD pipelinewith an error.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 运行测试。如果失败，shell 会以错误代码终止。这反过来又会导致 CD 管道因错误而终止。
- en: ⑤ Changes directory back to the main project
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 切换回主项目目录
- en: Listing 9.22 Adding automated tests directly to the CD configuration file
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.22 将自动化测试直接添加到 CD 配置文件中
- en: '[PRE41]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: ① Invokes our automated tests directly from the Bitbucket Pipelines configuration
    file. If the tests fail, the CD pipeline aborts with an error.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: ① 直接从 Bitbucket Pipelines 配置文件中调用我们的自动化测试。如果测试失败，CD 管道会因错误而终止。
- en: We might even invoke our automated tests directly from our Terraform code. But,
    arguably, with building and publishing Docker images, we are already doing too
    much in Terraform. We have taken it beyond its original purpose of provisioning
    our cloud infrastructure, even though this is a convenient way to bootstrap our
    microservices application. In chapter 11, we talk about how to refactor our development
    and deployment processes as we scale up FlixTube.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以直接从我们的 Terraform 代码中调用我们的自动化测试。但是，可以说，我们已经用构建和发布 Docker 镜像做了太多的事情，在 Terraform
    中。我们已经将其用途扩展到了其原始的云基础设施供应目的之外，尽管这是启动我们的微服务应用程序的一种方便方式。在第 11 章中，我们将讨论如何随着 FlixTube
    的扩展来重构我们的开发和部署流程。
- en: As noted in chapter 8, running Cypress in the CD pipeline is essentially the
    same, although, with some additional difficulties. Again we’ll invoke `npm test`,
    but with it configured to invoke Cypress instead of Jest.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 如第 8 章所述，在 CD 管道中运行 Cypress 实质上是一样的，尽管有一些额外的困难。我们再次将 `npm test` 调用，但这次配置为调用
    Cypress 而不是 Jest。
- en: 'The problem with Cypress is that it is big! Installing it into our CD pipeline
    each time the pipeline is invoked is slow and inefficient (especially if you are
    paying by the minute for the amount of time your pipeline is executing). If you
    want to use Cypress in your CD pipeline, then you are going to have to learn how
    to use the caching facilities from your CD provider. But I’m afraid this book
    is already too long, so you’ll have to tackle that on your own. You can learn
    more about caching in Bitbucket Pipelines here:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: Cypress 的问题在于它很大！每次管道被调用时都将其安装到我们的 CD 管道中是缓慢且低效的（尤其是如果你按分钟支付管道执行时间的话）。如果你想在
    CD 管道中使用 Cypress，那么你将不得不学习如何使用你的 CD 提供者的缓存设施。但恐怕这本书已经太长了，所以你将不得不自己解决这个问题。你可以在
    Bitbucket Pipelines 中了解更多关于缓存的信息：
- en: '[https://support.atlassian.com/bitbucket-cloud/docs/cache-dependencies/](https://support.atlassian.com/bitbucket-cloud/docs/cache-dependencies/)'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://support.atlassian.com/bitbucket-cloud/docs/cache-dependencies/](https://support.atlassian.com/bitbucket-cloud/docs/cache-dependencies/)'
- en: 9.10 Review
  id: totrans-448
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.10 回顾
- en: Congratulations! If you followed along in the chapter, you now have FlixTube
    running in production, and you are all set to continue evolving FlixTube. You
    can make code changes, test them in development, and then deploy updates to production
    using CD. Use table 9.2 to review the commands used in this chapter.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！如果你跟随着本章的内容，你现在已经在生产环境中运行了 FlixTube，并且已经准备好继续演进 FlixTube。你可以进行代码更改，在开发环境中测试它们，然后使用
    CD 部署更新到生产环境。使用表 9.2 来回顾本章中使用的命令。
- en: Table 9.2 Review of commands in chapter 9 `(continued)`
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9.2 第 9 章命令回顾（续）
- en: '| Command | Description |'
  id: totrans-451
  prefs: []
  type: TYPE_TB
  zh: '| 命令 | 描述 |'
- en: '| `npm start` | The conventional npm script for starting a Node.js application
    regardless of what name the main script file has or what command-line parameters
    it expects.Typically, this translates into `node` `index.js` in the package.json
    file, but it all depends on the author of the project and how they have set it
    up. The nice thing is that no matter how a particular project is structured, you
    only have to remember `npm` `start`. |'
  id: totrans-452
  prefs: []
  type: TYPE_TB
  zh: '| `npm start` | 不论主脚本文件命名如何或它期望的命令行参数如何，都是启动Node.js应用程序的传统npm脚本。通常，这会在package.json文件中转换为`node
    index.js`，但这完全取决于项目的作者以及他们如何设置。好事是，无论特定项目结构如何，您只需记住`npm start`即可。|'
- en: '| `npm run start:dev` | My personal convention for starting a Node.js project
    in development. I add this to the scripts in package.json, and typically, it runs
    something like Nodemon to enable live reload of your code as you work on it. |'
  id: totrans-453
  prefs: []
  type: TYPE_TB
  zh: '| `npm run start:dev` | 我启动Node.js项目开发时的个人约定。我将此添加到package.json中的脚本中，通常它会运行类似Nodemon的东西，以便在您工作时实时重新加载您的代码。|'
- en: '| `docker-compose up`➥ `--build` | Builds and instantiates an application composed
    of multiple containers as defined by the Docker Compose file (docker-compose.yaml)
    in the current working directory |'
  id: totrans-454
  prefs: []
  type: TYPE_TB
  zh: '| `docker-compose up`➥ `--build` | 根据当前工作目录中定义的Docker Compose文件（docker-compose.yaml）构建和实例化由多个容器组成的应用程序|'
- en: '| `docker-compose`➥ `down` | Stops and destroys the application, leaving the
    development workstation in a clean state |'
  id: totrans-455
  prefs: []
  type: TYPE_TB
  zh: '| `docker-compose`➥ `down` | 停止并销毁应用程序，使开发工作站保持干净状态|'
- en: '| `npm test` | The npm script convention for running tests. This can run Jest
    or Cypress (or even both) depending on how you configured your package.json file.This
    is the command you should run in your CD pipeline to execute your test suite.
    |'
  id: totrans-456
  prefs: []
  type: TYPE_TB
  zh: '| `npm test` | 运行测试的npm脚本约定。这可以运行Jest或Cypress（甚至两者都可以），具体取决于您如何配置package.json文件。这是您应在CD管道中运行的命令，以执行测试套件。|'
- en: '| `npm run test:watch` | This is my personal convention for running tests in
    live reload mode. You need to configure this script in your package.json file
    to use it. |'
  id: totrans-457
  prefs: []
  type: TYPE_TB
  zh: '| `npm run test:watch` | 这是我在实时重新加载模式下运行测试的个人约定。您需要配置package.json文件中的此脚本才能使用它。|'
- en: '| `terraform init` | Initializes a Terraform project and downloads the provider
    plugins |'
  id: totrans-458
  prefs: []
  type: TYPE_TB
  zh: '| `terraform init` | 初始化Terraform项目并下载提供者插件|'
- en: '| `terraform apply` | Executes Terraform scripts in the working directory to
    incrementally apply changes to our infrastructure |'
  id: totrans-459
  prefs: []
  type: TYPE_TB
  zh: '| `terraform apply` | 在工作目录中执行Terraform脚本，以增量方式对我们的基础设施应用更改|'
- en: '| `terraform destroy` | Destroys all infrastructure that’s created by the Terraform
    project |'
  id: totrans-460
  prefs: []
  type: TYPE_TB
  zh: '| `terraform destroy` | 销毁由Terraform项目创建的所有基础设施|'
- en: 9.11 FlixTube in the future
  id: totrans-461
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.11 FlixTube的未来
- en: 'Where to now for FlixTube? That’s for you to imagine! In chapter 11, we’ll
    discuss the technical aspects of FlixTube’s future:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: FlixTube接下来该往哪里发展？这需要您来想象！在第11章中，我们将讨论FlixTube未来的技术方面：
- en: How do we scale up to cater for our growing user base?
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何扩大规模以适应不断增长的用户群体？
- en: How do we scale up our development and deployment processes as the application
    grows and the size of the development team increases?
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着应用程序的增长和开发团队规模的增加，我们如何扩大我们的开发和部署流程？
- en: For now, just imagine the types of microservices you’d like to add to FlixTube
    in the future. Figure 9.18 gives you some inspiration as to what it might look
    like as it grows.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，只需想象一下您将来希望添加到FlixTube中的微服务类型。图9.18为您提供了关于它随着增长可能看起来怎样的灵感。
- en: 9.12 Continue your learning
  id: totrans-466
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.12 继续你的学习
- en: In this chapter, we studied the structure and layout of the FlixTube example
    application. We built, ran, and tested it in development. Then we deployed it
    to production through its CD pipeline.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了FlixTube示例应用程序的结构和布局。我们在开发环境中构建、运行和测试了它。然后我们通过其CD管道将其部署到生产环境。
- en: You have FlixTube running, so what now? Reading any book will only take you
    so far. The key to you retaining these skills is to practice, practice, and then
    practice some more. Experiment with the code. Try to add features. Try to add
    new microservices. Try to break FlixTube just to see what happens. Practicing
    the art of development is what takes you to the next level.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经运行了FlixTube，接下来该做什么呢？阅读任何书籍都只能让您走这么远。保留这些技能的关键是练习，练习，然后再练习。尝试对代码进行实验。尝试添加功能。尝试添加新的微服务。尝试破坏FlixTube以查看会发生什么。练习开发艺术是让您达到下一个层次的关键。
- en: '![](../Images/CH09_F18_Davis4.png)'
  id: totrans-469
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH09_F18_Davis4.png)'
- en: Figure 9.18 What FlixTube could look like in the future
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.18 FlixTube未来可能的样子
- en: Development is not without challenges. In fact, it is a never-ending rollercoaster
    of problems and solutions. When you hit problems with any tool or technology,
    go back and review the appropriate chapter in this book. You might find the answer
    you need. Otherwise, you’ll need to go deeper and explore other resources.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 开发并非没有挑战。事实上，它是一连串不断的问题和解决方案的永无止境的过山车。当你遇到任何工具或技术的难题时，回到这本书中相应的章节进行回顾。你可能会找到你需要的答案。否则，你可能需要深入研究并探索其他资源。
- en: The final chapters in this book contain guidance that will help you navigate
    your future development path with microservices. The references at the end of
    each chapter (including this one) will help you continue your learning journey.
    But just remember that your key to success and your key to retaining these skills
    is consistent practice.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 本书最后几章包含的指导将帮助您在微服务未来的开发道路上导航。每章末尾的参考文献（包括本章）将帮助您继续您的学习之旅。但请记住，您成功的关键和保持这些技能的关键是持续的练习。
- en: 'To learn about UI development, see the following books:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解UI开发，请参阅以下书籍：
- en: '*Angular in Action* by *Jeremy Wilken (Manning, 2018)*'
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Angular实战》* by *Jeremy Wilken (Manning, 2018)*'
- en: '*Getting MEAN with Mongo, Express, Angular, and Node*, 2nd ed., by *Simon D.
    Holmes and Clive Harber (Manning, 2019)*'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《使用Mongo, Express, Angular和Node实现MEAN》*，第2版，by *Simon D. Holmes and Clive
    Harber (Manning, 2019)*'
- en: '*Micro Frontends in Action* by *Michael Geers (Manning, 2020)*'
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《微前端实战》* by *Michael Geers (Manning, 2020)*'
- en: 'To learn more about development with microservices, see these books:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于使用微服务进行开发的信息，请参阅以下书籍：
- en: '*Microservices in Action* by Morgan Bruce, Paulo A. Pereira *(Manning, 2018)*'
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《微服务实战》* by Morgan Bruce, Paulo A. Pereira *(Manning, 2018)*'
- en: '*Microservices Patterns* by Chris Richardson *(Manning, 2018)*'
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《微服务模式》* by Chris Richardson *(Manning, 2018)*'
- en: '*The Tao of Microservices* by Richard Rodger *(Manning, 2017)*'
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《微服务之道》* by Richard Rodger *(Manning, 2017)*'
- en: '*Microservices in .NET Core*, 2nd ed., by Christian Horsdal Gammelgaard *(Manning,
    2020)*'
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《.NET Core微服务》*，第2版，by Christian Horsdal Gammelgaard *(Manning, 2020)*'
- en: '*Developing Microservice APIs with Python* by José Haro Peralta *(Manning,
    est, Spring 2021)*'
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《使用Python开发微服务API》* by José Haro Peralta *(Manning, est, Spring 2021)*'
- en: 'To dive deeper into Terraform, see this book:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 要深入了解Terraform，请参阅以下书籍：
- en: '*Terraform in Action* by *Scott Winkler (Manning, est Spring, 2021)*'
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Terraform实战》* by *Scott Winkler (Manning, est Spring, 2021)*'
- en: Summary
  id: totrans-485
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: We learned how FlixTube works as a whole and met some new microservices along
    the way.
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们了解了FlixTube的整体工作原理，并在过程中遇到了一些新的微服务。
- en: We revisited some of the essential tools needed to build, run, test, and deploy
    microservices.
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们回顾了构建、运行、测试和部署微服务所需的一些基本工具。
- en: We ran an individual microservice from our FlixTube application in production
    mode and in development mode, which enables live reload, before booting the entire
    application.
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在FlixTube应用程序的生产模式和开发模式下分别运行了一个单独的微服务，这使我们可以实现实时重载，然后再启动整个应用程序。
- en: We used Jest and Cypress to test FlixTube.
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用Jest和Cypress测试了FlixTube。
- en: To make FlixTube available for use by the general public, we deployed it to
    production and brought the continuous delivery (CD) pipeline online.
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了使FlixTube可供公众使用，我们将其部署到生产环境，并上线了持续交付（CD）管道。
