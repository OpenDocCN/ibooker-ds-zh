- en: Part 1\. Microservices basics
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第1部分\. 微服务基础
- en: What are Microservices? A *microservice* consists of a single deployment executing
    within a single process. How do microservices differ from traditional Enterprise
    Java applications? In what situations is it appropriate to use microservices?
    These are just some of the questions that we’ll address in these first five chapters.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是微服务？*微服务*由单个在单个进程中执行的部署组成。微服务与传统Enterprise Java应用程序有何不同？在什么情况下使用微服务是合适的？这些问题只是我们将在前五章中解决的一些问题。
- en: '[Part 1](#part01) also explores the runtime options available for Enterprise
    Java micro-services, before finishing with how to test microservices and deploy
    them to the cloud.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[第1部分](#part01)还探讨了Enterprise Java微服务的运行时选项，在结束之前，介绍了如何测试微服务并将它们部署到云中。'
- en: Chapter 1\. Enterprise Java microservices
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第1章\. Enterprise Java微服务
- en: '*This chapter covers*'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Enterprise Java history
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Enterprise Java历史
- en: Microservices and distributed architecture
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务与分布式架构
- en: Patterns for migration to microservices
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迁移到微服务的模式
- en: Enterprise Java microservices
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Enterprise Java微服务
- en: Before you dive in, let’s step back and discuss what I hope you achieve during
    the course of this book. We all know that there’s no such thing as a *free lunch*,
    so I won’t pretend that microservices are easy. This chapter introduces microservices—their
    concepts, benefits, and drawbacks—to provide a basis on which you can build your
    technical knowledge. [Chapters 2](kindle_split_011.xhtml#ch02) and [3](kindle_split_012.xhtml#ch03)
    provide an example of a RESTful endpoint microservice and cover some of your runtime
    and deployment options for Enterprise Java microservices.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在你深入之前，让我们回顾一下，我希望你在本书的学习过程中达到什么目标。我们都知道没有免费的午餐，所以我不假装微服务很容易。本章介绍了微服务——它们的概念、优点和缺点——为你构建技术知识提供一个基础。[第2章](kindle_split_011.xhtml#ch02)和[第3章](kindle_split_012.xhtml#ch03)提供了一个RESTful端点微服务的示例，并涵盖了你的Enterprise
    Java微服务的运行时和部署选项。
- en: So what is an *Enterprise Java microservice*? In a nutshell, it’s the result
    of applying Enterprise Java to the development of microservices. The latter part
    of this chapter and the remainder of the book explore in detail what that means.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是*Enterprise Java微服务*？简而言之，它是将Enterprise Java应用于微服务开发的结果。本章的后半部分和本书的其余部分将详细探讨这意味着什么。
- en: After you’ve learned the basics of microservices, you’ll delve into tools and
    techniques for use in Enterprise Java to mitigate the drawbacks and complexity
    of micro-services. Being more familiar with microservices, you’ll then look at
    an existing Enterprise Java application and how it could be migrated to take advantage
    of micro-services. The last few chapters touch on more advanced microservice topics
    related to security and event streaming.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在你学习了微服务的基础之后，你将深入研究在Enterprise Java中使用以减轻微服务缺点和复杂性的工具和技术。在更熟悉微服务之后，你将查看一个现有的Enterprise
    Java应用程序，以及它如何迁移以利用微服务。最后几章涉及与安全和事件流相关的更高级微服务主题。
- en: 1.1\. Enterprise Java—a short history
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1\. Enterprise Java——简史
- en: If you’re reading this book, you’re most likely already an experienced Enterprise
    Java developer. If you aren’t, I appreciate and applaud your desire to broaden
    your horizons into Enterprise Java!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在阅读这本书，你很可能已经是一位经验丰富的Enterprise Java开发者。如果你不是，我赞赏并赞扬你想要拓宽视野到Enterprise Java的愿望！
- en: 1.1.1\. What is Enterprise Java?
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.1\. 什么是Enterprise Java？
- en: For those who are new to, or need a refresher in, Enterprise Java, what is it?
    *Enterprise Java* is a set of APIs, and their implementations, that can provide
    the entire stack of an application from the UI down to the database, communicate
    with external applications via web services, and integrate with internal legacy
    systems, to name a few, with the goal of supporting the business requirements
    of an enterprise. Though it’s possible to achieve such a result with Java on its
    own, rewriting all the low-level architecture required for an application would
    be tedious and error prone, and would significantly impact the ability of a business
    to deliver value in a timely manner.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些对Enterprise Java新手，或者需要复习的人来说，什么是Enterprise Java？*Enterprise Java*是一组API及其实现，可以提供从UI到数据库的应用程序整个堆栈，通过Web服务与外部应用程序进行通信，并与内部遗留系统集成，仅举几个例子，其目标是支持企业的业务需求。尽管使用Java本身可以实现这样的结果，但重写所有为应用程序所需的基础低级架构将是繁琐且容易出错的，并且会严重影响企业及时交付价值的能力。
- en: It wasn’t long after Java was first released more than 20 years ago that various
    frameworks began to crop up to solve the low-level architecture concerns of developers.
    These frameworks allowed developers to focus on delivering business value with
    application-specific code.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java首次发布20多年后的不久，各种框架开始出现，以解决开发者对低级架构的关注。这些框架允许开发者专注于使用特定于应用程序的代码来交付业务价值。
- en: '|  |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Enterprise Java**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**企业Java**'
- en: 'Many frameworks have come and gone, but two have remained the most popular
    through the years: Java Platform, Enterprise Edition (Java EE), and Spring. These
    two frameworks account for most development by an enterprise with Enterprise Java.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 许多框架已经出现又消失，但有两个框架在多年中一直是最受欢迎的：Java平台，企业版（Java EE）和Spring。这两个框架占到了企业使用企业Java的大部分开发工作。
- en: Java EE incorporates many specifications, each with one or more implementations.
    Spring is a collection of libraries, some of which wrap Java EE specifications.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE包含许多规范，每个规范都有一个或多个实现。Spring是一组库，其中一些库封装了Java EE规范。
- en: '|  |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 1.1.2\. Typical Enterprise Java architecture
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.2. 典型的企业Java架构
- en: In the early days of Enterprise Java, our applications were all *greenfield*
    development, because no preexisting code was being extended.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业Java的早期，我们的应用程序都是*绿地*开发，因为没有扩展任何现有代码。
- en: '|  |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Definition
  id: totrans-25
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义
- en: '*Greenfield* refers to the development of an entirely new application without
    any preexisting code that needs to be taken into consideration, excluding any
    common libraries that might be required.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*绿地*指的是开发一个全新的应用程序，没有任何需要考虑的现有代码，不包括可能需要的任何通用库。'
- en: '|  |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Greenfield development presents the greatest opportunity to develop a *clean*
    layered architecture for an application. Typically, architects would devise an
    architecture similar to that shown in [figure 1.1](#ch01fig01).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 绿地开发为开发一个应用程序的*清洁*分层架构提供了最大的机会。通常，架构师会设计一个类似于[图1.1](#ch01fig01)所示的架构。
- en: Figure 1.1\. Typical Enterprise Java application architecture
  id: totrans-29
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.1. 典型的企业Java应用程序架构
- en: '![](Images/01fig01_alt.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/01fig01_alt.jpg)'
- en: 'Here you’ll likely recognize familiar pieces of architectures you’ve worked
    on in the past: a *view* layer, a *controller*, possibly using a reusable *business
    service*, and finally, the *model* that interacts with the database. You can also
    see the application packaged as a WAR, but many combinations of packaging for
    each layer could be applied, including JAR and EAR. Typically, the *view* and
    *controller* are packaged in a WAR. The *business service* and *model* are packaged
    in JARs, either inside a WAR or EAR.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可能会认出你过去工作过的熟悉架构片段：一个*视图*层，一个*控制器*，可能使用一个可重用的*业务服务*，最后是和数据库交互的*模型*。你还可以看到应用程序被打包成WAR文件，但每个层可能都有多种打包组合，包括JAR和EAR。通常，*视图*和*控制器*被打包在WAR文件中。*业务服务*和*模型*被打包在JAR文件中，这些JAR文件可能位于WAR或EAR内部。
- en: As the years passed, we continued developing greenfield applications with Enterprise
    Java using such a pattern, but there reached a point where most enterprises were,
    for the most part, enhancing existing applications. From that day, many Enterprise
    Java applications became a legacy burden on enterprises by virtue of the maintenance
    work required—not because of a flaw or deficiency in Java, though there have been
    several, but because developers aren’t the best at architecting changes to existing
    applications and systems. This is complicated further for enterprises that have
    hundreds of architects and developers pass through their doors, each bringing
    their own preferences and patterns to extending existing applications.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，我们继续使用企业Java开发绿地应用程序，但最终大多数企业主要是增强现有应用程序。从那天起，许多企业Java应用程序由于维护工作而成为企业的遗产负担——这并不是因为Java本身存在缺陷或不足，尽管确实存在一些，而是因为开发者不是最擅长对现有应用程序和系统进行架构变更。对于有数百名架构师和开发者通过其大门的企业来说，这个问题更加复杂，因为每个人都会带来他们自己的偏好和扩展现有应用程序的模式。
- en: '|  |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-34
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: I’m not sitting in an ivory tower disparaging developers. Many times I’ve made
    decisions about how a feature should be implemented without fully grasping existing
    functionality—not through any intent or malice, but because those who wrote the
    code are no longer employed at the enterprise and therefore can’t be asked about
    the code, and because documentation may be lacking or nonintuitive. Such a situation
    means developers are left to make a judgment call as to whether or not they’ve
    understood the existing system sufficiently to make modifications. Throw in some
    deadline pressure from management, and such a situation becomes even more fraught
    with problems.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我并不是坐在象牙塔里贬低开发者。很多时候，我在没有完全掌握现有功能的情况下就做出了关于如何实现特性的决定——这并非出于任何意图或恶意，而是因为编写代码的人已经不再在该公司工作，因此无法询问代码相关的问题，也因为文档可能缺乏或不够直观。这种情况下，开发者不得不做出判断，是否已经充分理解现有系统，以便进行修改。再加上管理层的截止日期压力，这种情况变得更加充满问题。
- en: '|  |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Over time, many Enterprise Java applications diverged from the clean architecture
    shown in [figure 1.1](#ch01fig01) and became a mess of spaghetti more closely
    resembling [figure 1.2](#ch01fig02). In [figure 1.2](#ch01fig02) you can see how
    clear boundaries between functionality within a layer have become blurred, resulting
    in components in each layer no longer having a well-defined purpose.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，许多企业Java应用程序偏离了[图1.1](#ch01fig01)中所示的清晰架构，变成了更接近[图1.2](#ch01fig02)的混乱意大利面。在[图1.2](#ch01fig02)中，你可以看到层内功能之间的清晰边界已经变得模糊，导致每个层的组件不再有明确的目的。
- en: This situation is where many enterprises find themselves today. Only a few applications
    of an enterprise may fit this mold, but this mess of spaghetti is a problem that
    must be solved in order for an application to foster future development without
    significant costs being incurred each time.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况是许多企业目前所处的境地。企业中的应用程序可能只有少数符合这种模式，但这个混乱的意大利面问题是必须解决的，以便应用程序能够在不产生重大成本的情况下促进未来的发展。
- en: 1.1.3\. What is a monolith?
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.3\. 什么是单体？
- en: 'What defines an Enterprise Java application as a monolith? A *monolith* is
    an application that has all its components contained within a single deployable,
    and that typically has a release cadence of 3–18 months. Some applications may
    even have a release cadence of two years, which doesn’t make for an agile enterprise.
    Monoliths typically evolve over time from attempts to make quick iterative enhancements
    to an application, without any concern for appropriate boundaries between different
    parts, or components, within it. Indicators of an application being a monolith
    can include the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是定义企业Java应用程序为单体？一个*单体*是指所有组件都包含在单个可部署单元中的应用程序，并且通常具有3-18个月的发布周期。一些应用程序甚至可能有两年的发布周期，这并不适合敏捷企业。单体通常随着时间的推移从尝试快速迭代增强应用程序，而不考虑不同部分或组件之间适当的边界，而逐渐演变。一个应用程序是单体的指标可能包括以下内容：
- en: Multiple WARs that are part of a single deployment, due to their intertwined
    behavior
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于相互交织的行为，多个WAR文件是单个部署的一部分
- en: EARs that contain potentially dozens of other WARs and JARs to provide all the
    necessary functionality
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含可能数十个其他WAR和JAR文件的EAR文件，以提供所有必要的功能
- en: Is [figure 1.2](#ch01fig02) a monolith? It most certainly is, and an extremely
    bad one, because of the blurring of functional separation between components.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1.2](#ch01fig02)是一个单体吗？它当然是一个单体，而且是一个非常糟糕的单体，因为组件之间的功能分离变得模糊不清。'
- en: Figure 1.2\. Enterprise Java spaghetti
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.2\. 企业Java意大利面
- en: '![](Images/01fig02_alt.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/01fig02_alt.jpg)'
- en: Why do the preceding factors make an application a monolith? A single deployable
    for an application is perfectly fine when you have a small footprint, but when
    you have potentially thousands of classes and dozens of third-party libraries,
    an application becomes infinitely more complex. Testing even a minor change to
    the application would require large amounts of regression testing to ensure that
    no other part of the application was impacted. Even if the regression testing
    were automated, it’d still be a mammoth task.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么上述因素会使一个应用程序成为单体？当你的应用程序占用空间小的时候，一个可部署的单体应用程序是完全可以接受的，但是当你有数千个类和数十个第三方库时，应用程序就变得无限复杂。即使对应用程序的微小更改进行测试，也需要大量的回归测试来确保应用程序的其他部分没有受到影响。即使回归测试是自动化的，这仍然是一项巨大的任务。
- en: Whether an application is a monolith is also determined in part by its architecture.
    Classifying as a monolith isn’t based on the size of the application on disk,
    or the size of the runtime being used to execute the monolith. It’s all about
    how that application has been architected with respect to the components within
    it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序是否是单体也部分取决于其架构。将应用程序归类为单体并不是基于磁盘上应用程序的大小，或者执行单体所使用的运行时大小。这完全取决于该应用程序在内部组件方面的架构方式。
- en: Release cadence is a forcing function for enterprises. If an application is
    released only every 3–18 months, the business (unknowingly or not) will focus
    on larger feature changes that take significant time to develop. No incentive
    exists to request a minor tweak that could be made and released in a few hours,
    or days, when even the most simple change won’t reach production for months.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 发布节奏是企业的一个推动因素。如果一个应用程序每3-18个月才发布一次，那么业务（无论是有意还是无意）都会关注那些需要大量时间开发的大功能变更。没有动力去请求一些可以在几小时或几天内完成并发布的微小调整，即使是最简单的变更也需要数月才能达到生产环境。
- en: Release cadence dictated by the time it takes to develop and test changes has
    a direct impact on the ability of an enterprise to be agile and respond to a changing
    environment. For instance, if a competitor were to begin selling the same widget
    as your enterprise for 15% less than you do, can you react? Taking several months
    to make a simple change to reduce the selling price of a product could have disastrous
    consequences for the bottom line. If that widget was the biggest seller, and the
    enterprise was unable to compete on price for three months, it may even be on
    the verge of going out of business by the time a price change was released.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由开发和测试变更所需时间决定的发布节奏直接影响企业敏捷性和对变化环境的响应能力。例如，如果竞争对手开始以比你的企业低15%的价格销售与你企业相同的商品，你能做出反应吗？为了降低产品的销售价格而进行几个月的简单变更可能会对底线产生灾难性的后果。如果那个商品是最大的卖家，而企业在价格上无法竞争三个月，那么在价格变更发布时，企业甚至可能处于破产的边缘。
- en: Along with release cadence, it’s critical to note that discussions around *micro*
    versus *monolith* don’t have any relation to constraints on size. You could have
    a microservice that’s 100 MB in size, or a monolith that’s only 20 MB. The definition
    is more about the coupling of dependencies between components, leading to the
    benefit of updating a single component without needing to cascade updates across
    many components. This decoupling is what allows for a faster release cadence.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 除了发布节奏，还必须注意，关于*微服务*与*单体*的讨论与对大小的限制无关。你可以有一个100MB大小的微服务，或者一个只有20MB的单体。定义更多的是组件之间的依赖耦合，这导致了更新单个组件而无需对许多组件进行级联更新的好处。这种解耦使得发布节奏更快。
- en: Though it appears that monolithic Enterprise Java applications are all gloom
    and doom, is that really the case? In many situations, it makes sense for an enterprise
    to continue with, or develop, a monolith. How do you know if you should stick
    with a monolith?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然看起来单体企业Java应用都是一片阴霾和末日，但这真的是情况吗？在许多情况下，企业继续使用或开发单体是有意义的。你如何知道是否应该坚持使用单体？
- en: '*Your enterprise may have only a few applications that it actively develops
    and maintains.* It may not make sense to significantly increase the development,
    testing, and release burden when you have so few applications.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*你的企业可能只有少数几个正在积极开发和维护的应用程序。* 当你有这么少的应用程序时，显著增加开发和测试以及发布的负担可能并不合理。'
- en: '*If the current development team has a dozen people, splitting them into one-
    or two-person teams for microservices may not provide any benefit.* In some cases,
    that split will be detrimental. Basecamp ([https://basecamp.com/](https://basecamp.com/))
    is a perfect example of a monolith that’s fine the way it is, developed by a team
    of 12.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*如果当前的开发团队有十几个人，将他们分成一两个人的微服务团队可能不会带来任何好处。* 在某些情况下，这种分割甚至可能是有害的。Basecamp ([https://basecamp.com/](https://basecamp.com/))
    是一个很好的例子，它是一个由12人团队开发的单体，目前的状态已经很好。'
- en: '*Does your enterprise need multiple releases a week, or even a day?* If not,
    and the existing monolith has a clear separation of components, reducing the release
    cadence may be all that’s required to derive increased business agility and value.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*你的企业是否需要每周甚至每天发布多个版本？* 如果不是，并且现有的单体有清晰的组件分离，那么减少发布节奏可能就是提高业务敏捷性和价值的全部需求。'
- en: Whether staying with a monolith is the right thing for an enterprise varies,
    depending on the current circumstances and the long-term goals.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于企业来说，是否坚持使用单体架构取决于当前的环境和长期目标。
- en: 1.1.4\. What are the problems associated with monoliths?
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.4. 与单体架构相关的问题有哪些？
- en: 'In general, an architectural design akin to the one in [figure 1.1](#ch01fig01)
    is a good idea, but drawbacks exist as well:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，类似于[图1.1](#ch01fig01)中的那种建筑设计是一个好主意，但同时也存在一些缺点：
- en: '***Inability to scale individual components*—** This may not seem to be a major
    problem, but certain factors can alter the impact of poor scaling. If a single
    instance of the application requires a large amount of memory or space, scaling
    that out to a not-insignificant number of nodes requires a large investment in
    hardware.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***无法扩展单个组件*—** 这可能看起来不是一个主要问题，但某些因素可以改变不良扩展的影响。如果一个应用程序的单个实例需要大量的内存或空间，将其扩展到相当数量的节点需要大量的硬件投资。'
- en: '***Performance of individual components*—** With a single deployment containing
    many components, it’s easy for one component to perform worse than the rest. You
    then have a single component slowing down the entire system, which isn’t a good
    situation, and the operations team won’t be pleased.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***单个组件的性能*—** 在包含许多组件的单个部署中，一个组件的性能可能比其他组件差。这样，一个组件就会减慢整个系统的速度，这不是一个好的情况，而且运维团队也不会高兴。'
- en: '***Deployability of individual components*—** When the entire application is
    a single deployment, any changes require a deployment of the entire application,
    even if you have a single-line change in one component. That’s not good for business
    agility and often results in release cadences of many months to include many changes
    in one updated deployment.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***单个组件的可部署性*—** 当整个应用程序是一个单一部署时，任何更改都需要重新部署整个应用程序，即使只有一个组件中的一行更改。这对业务敏捷性不利，通常会导致需要数月时间才能完成的一次更新部署中包含许多更改。'
- en: '***Greater code complexity*—** When an application has many components, it’s
    easy for the functional boundaries between them to become blurred. Blurring the
    separation of components further increases the complexity of code, both in terms
    of code execution and for a developer understanding the intent of the code.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***代码复杂性增加*—** 当一个应用程序有多个组件时，它们之间的功能边界很容易变得模糊。进一步模糊组件之间的分离会增加代码的复杂性，无论是在代码执行方面还是在开发者理解代码意图方面。'
- en: '***Difficulty in accurately testing an application*—** When the complexity
    of an application grows, the amount of testing and time required to ensure that
    any change didn’t cause a regression grows. What seems like the smallest and most
    insignificant change can easily lead to unforeseen errors and problems in completely
    unrelated components.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***准确测试应用程序的难度*—** 当应用程序的复杂性增加时，确保任何更改没有引起回归所需的测试量和时间也会增加。看似最小且最不重要的更改很容易导致完全无关的组件中出现未预见的错误和问题。'
- en: All these issues cause great cost to enterprises, as well as slowing the speed
    with which they can take advantage of new opportunities. But these potential drawbacks
    are still small in comparison to starting from a clean slate.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些问题给企业带来了巨大的成本，同时也减缓了他们利用新机会的速度。但与从头开始相比，这些潜在的缺点仍然很小。
- en: If an enterprise has an application that has evolved with new features over
    a decade or more, attempting to replace it with a greenfield project would cost
    hundreds of man years in effort. This is a huge factor in why enterprises continue
    maintaining existing monoliths.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个企业有一个经过十年或更长时间发展并增加了新功能的应用程序，尝试用绿色项目来替换它将需要数百人年的努力。这是企业继续维护现有单体架构的一个巨大因素。
- en: When it’s too costly to replace a monolith with a more modern alternative, that
    application becomes entrenched in an enterprise. It becomes a critical application,
    and any downtime causes business impacts. This situation becomes ever more compounded
    with continual enhancements and fixes.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当用更现代的替代品替换单体架构的成本过高时，该应用程序就会在企业中根深蒂固。它成为了一个关键应用程序，任何停机都会对业务造成影响。随着持续的增强和修复，这种情况会变得更加复杂。
- en: On the flipside, some monoliths have been running well for years and can be
    easily managed by a handful of developers without much effort. Maybe they’re in
    a maintenance mode and not under heavy feature development. These monoliths are
    perfectly OK as they are. If it ain’t broke, don’t fix it.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 反过来，一些单体已经运行多年，并且可以由少数几个开发者轻松管理，无需太多努力。也许它们处于维护模式，没有进行大量的功能开发。这些单体现状很好。如果它没有坏，就别修它。
- en: What do you do with monoliths that are too cumbersome to replace with a greenfield
    project, even though the enterprise knows it’s costing them a great deal in business
    agility and expense? How do you update them to use newer frameworks and technologies
    so they don’t become legacy? We’ll answer these questions next.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些即使企业知道它们在业务敏捷性和成本上花费很大，也无法用绿色项目替换的笨重单体，你该怎么办？如何更新它们以使用更新的框架和技术，使它们不会成为遗留系统？我们将在下一节回答这些问题。
- en: 1.2\. Microservices and distributed architecture
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2. 微服务和分布式架构
- en: Before delving into the definitions for *microservices* and *distributed architecture*,
    let’s revisit how [figure 1.2](#ch01fig02) might look when using them; see [figure
    1.3](#ch01fig03). This depiction has certainly cleared up the separation between
    components by splitting them into separate microservices with clear boundaries
    between them.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨*微服务*和*分布式架构*的定义之前，让我们回顾一下在使用它们时[图1.2](#ch01fig02)可能的样子；参见[图1.3](#ch01fig03)。这种描述确实通过将它们拆分为具有明确边界的独立微服务，澄清了组件之间的分离。
- en: Figure 1.3\. Enterprise Java microservices
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.3. 企业Java微服务
- en: '![](Images/01fig03_alt.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/01fig03_alt.jpg)'
- en: So what do I mean by a microservice? A *microservice* consists of a single deployment
    executing within a single process, isolated from other deployments and processes,
    that supports the fulfillment of a specific piece of business functionality. Each
    micro-service focuses on the required tasks within a *Bounded Context*, which
    is a logical way to separate the various domain models of an enterprise. We’ll
    cover this in greater detail later in this chapter.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我所说的微服务是什么意思呢？一个*微服务*由一个在单个进程中执行的单一部署组成，与其他部署和进程隔离，支持特定业务功能的实现。每个微服务都专注于*边界上下文*内的所需任务，这是一种逻辑上分离企业各种领域模型的方法。我们将在本章后面更详细地介绍这一点。
- en: From the definition, you can see that a microservice, in and of itself, isn’t
    useful. It becomes useful when you have many loosely coupled microservices working
    together to fulfill the needs of an application. A microservices architecture
    containing many microservices communicating with each other can also be referred
    to as a *distributed architecture*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 从定义中，你可以看到，微服务本身并不是有用的。只有当你有许多松散耦合的微服务协同工作以满足应用程序的需求时，它才变得有用。包含许多微服务并相互通信的微服务架构也可以被称为*分布式架构*。
- en: To make a microservice useful, it needs to be easily used from other microservices
    and components of the entire system. It’s impossible to achieve that when a microservice
    attempts to accomplish too much. You want a microservice to focus on a single
    task.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要使微服务变得有用，它需要能够轻松地从其他微服务和整个系统的组件中使用。当微服务试图完成太多事情时，这是不可能实现的。你希望微服务专注于单一任务。
- en: 1.2.1\. Do one thing well
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.1. 做好一件事
- en: In 1978, Douglas McIlroy, best known for developing UNIX pipelines and various
    UNIX tools, documented the UNIX philosophy, one part of which is, *Make each program
    do one thing well*. This same philosophy has been adopted by microservice developers.
    Microservices aren’t the kitchen sink of application development; you can’t throw
    everything in them and expect them to function at an optimal level. In that case,
    you’d have a *monolithic microservice*, also referred to as a *distributed monolith*!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 1978年，Douglas McIlroy，最著名的成就是开发UNIX管道和各种UNIX工具，记录了UNIX哲学，其中一部分是，“让每个程序做好一件事”。这种相同的哲学被微服务开发者所采纳。微服务不是应用程序开发的“大杂烩”；你不能把所有东西都扔进去，并期望它们以最佳水平运行。在这种情况下，你会有一个*单体微服务*，也称为*分布式单体*！
- en: A well-designed microservice should have a single task to perform that’s sufficiently
    fine-grained, delivering a business capability or adding business value. Going
    beyond a single task brings us back to the problems of Enterprise Java monoliths,
    which we don’t want to repeat.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一个设计良好的微服务应该有一个单一的任务去执行，这个任务足够细粒度，提供业务能力或增加业务价值。超出单一任务将使我们回到企业Java单体的问题，我们不想重蹈覆辙。
- en: It’s not always easy to figure out a sufficiently granular task for a microservice.
    Later in the chapter we’ll discuss Domain-Driven Design as a method to assist
    in defining that granularity.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于微服务来说，确定足够细粒度的任务并不总是容易。在本章的后面部分，我们将讨论领域驱动设计作为辅助定义这种粒度的方法。
- en: 1.2.2\. What is a distributed architecture?
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.2\. 什么是分布式架构？
- en: A *distributed architecture* consists of multiple pieces that work with each
    other to make up the full functionality of an application distributed across processes,
    and often across network boundaries as well. What’s distributed can be any part
    of an application, such as RESTful endpoints, message queues, and web services,
    but it’s most definitely not limited to only these components.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *分布式架构* 由多个相互协作的组件组成，这些组件共同构成了一个跨进程、甚至经常跨网络边界的应用程序的完整功能。分布式可以是应用程序的任何部分，例如RESTful端点、消息队列和Web服务，但它绝对不仅限于这些组件。
- en: '[Figure 1.4](#ch01fig04) shows what a distributed architecture for microservices
    might look like. In this depiction, the *microservice* instances are described
    as being in a *runtime*, but that doesn’t dictate how the instance is packaged.
    It could be packaged as *uber jars* or Linux containers, but many other options
    are available. The runtime is purely for delineating the operating environment
    of a microservice, showing that the microservices are running independently.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1.4](#ch01fig04) 展示了微服务分布式架构可能的样子。在这个描述中，*微服务*实例被描述为处于 *运行时*，但这并不规定实例的打包方式。它可以打包为
    *uber jar* 或 Linux 容器，但还有许多其他选项。运行时纯粹是为了界定微服务的操作环境，表明微服务是独立运行的。'
- en: Figure 1.4\. Typical microservices architecture
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.4\. 典型的微服务架构
- en: '![](Images/01fig04_alt.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/01fig04_alt.jpg)'
- en: '|  |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: An *uber jar*, also known as a *fat jar*, indicates that the JAR file contains
    more than a single application or library, and that it can be run from the command
    line with `java -jar`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*uber jar*，也称为 *fat jar*，表示JAR文件包含多个应用程序或库，并且可以从命令行使用`java -jar`运行。'
- en: '|  |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 1.2.3\. Why should you care about being distributed?
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.3\. 为什么你应该关心分布式？
- en: 'Now that you’ve seen a distributed architecture, let’s look at some of the
    benefits:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了分布式架构，让我们来看看一些好处：
- en: '*Services are location-independent.* Services can locate and communicate with
    other services no matter where they’re physically located. Such location independence
    allows services to be located on the same virtual hardware, same physical hardware,
    same data center, different data centers, or even a public cloud, and all act
    is if they’re in the same JVM. The main downside to location independence is the
    extra time required to make the network calls between them, and by the nature
    of adding new network calls, you’ve reduced the likelihood of successful completion.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*服务是位置无关的。* 不论服务物理位置在哪里，服务都可以定位并与其他服务进行通信。这种位置无关性使得服务可以位于相同的虚拟硬件、相同的物理硬件、相同的数据中心、不同的数据中心，甚至公共云中，并且它们都表现得好像它们在同一个JVM中一样。位置无关性的主要缺点是它们之间进行网络调用所需的时间额外增加，并且由于添加新的网络调用的性质，你降低了成功完成的几率。'
- en: '*Services are language-independent.* Though this book focuses on Enterprise
    Java, we’re not so naive as to believe that there won’t be times that services
    need, or are desired, to be developed in different languages. When services aren’t
    required to run in the same environment, you can use different languages for different
    services.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*服务是语言无关的。* 虽然这本书主要关注企业Java，但我们并不那么天真，认为服务不会需要或希望用不同的语言开发。当服务不需要在相同的环境中运行时，你可以为不同的服务使用不同的语言。'
- en: '*Service deployments are small and single-purpose.* When a deployment is smaller,
    less effort is required for testing, and this makes it possible to shrink the
    release cadence of that deployment down to a week or less. Having small, single-purpose
    deployments enables an enterprise to more easily react to business needs in a
    near-real-time fashion.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*服务部署小且用途单一。* 当部署较小，测试所需的努力就较少，这使得将部署的发布周期缩短到一周或更少成为可能。拥有小型、单一用途的部署使得企业能够更容易地以近乎实时的方式对业务需求做出反应。'
- en: '*New services are defined by the recomposition of existing service functionality.*
    Having discrete distributed services throughout your architecture greatly enhances
    your ability to recombine those services in new ways to create additional value.
    This recombination can be as straightforward as deploying a single new service,
    combined with a handful of services already deployed. This enables you to create
    something new for the business in a shorter time frame.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*新服务是通过现有服务功能的重新组合来定义的。* 在你的架构中拥有离散的分布式服务大大增强了你以新的方式重新组合这些服务以创造额外价值的能力。这种重新组合可以简单到部署单个新服务，结合已经部署的一小部分服务。这使你能够在更短的时间内为业务创造新的东西。'
- en: Sounds awesome—how can you develop distributed applications right now? You need
    to pull back on the reins a bit here. Yes, being distributed does improve a lot
    of the issues that we’ve had with Enterprise Java over the years, but it also
    introduces its own challenges. Developing distributed applications is in no way
    a silver bullet, and you can easily shoot yourself in the foot.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来很棒——你如何现在就能开发分布式应用程序呢？你需要稍微收紧一下缰绳。是的，分布式确实在很大程度上改善了多年来我们在企业Java中遇到的问题，但它也带来了自己的挑战。开发分布式应用程序绝不是万能的，你很容易就会自食其果。
- en: You’ve seen some benefits of being distributed, but there’s never a free lunch
    with most things—and definitely not with distributed architecture. If you have
    a bunch of services that interoperate through communication and no coupling, what
    problems can that introduce?
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了分布式的一些好处，但大多数事情都不是免费的午餐——分布式架构更是如此。如果你有一堆通过通信和没有耦合相互操作的服务，这可能会带来什么问题？
- en: Location independence for services is great, but how do they find each other?
    You need a means of defining services logically, regardless of what their physical
    location or IP address might be. With a means of discovery, you can locate a service
    by its logical name and ignore wherever it might be physically located. Service
    discovery serves this purpose. [Part 2](kindle_split_015.xhtml#part02) of this
    book covers how to use service discovery.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于服务来说，地理位置的独立性是很好的，但他们如何找到彼此呢？你需要一种逻辑上定义服务的方法，无论它们的物理位置或IP地址可能是什么。有了发现方法，你可以通过逻辑名称定位服务，而忽略其物理位置。服务发现就起到了这个作用。本书的[第二部分](kindle_split_015.xhtml#part02)介绍了如何使用服务发现。
- en: How do you handle failure without impacting customers? You need a means of gracefully
    degrading functionality when services fail, instead of crashing the application.
    You need service resilience and fault tolerance to provide alternatives when services
    fail. [Part 2](kindle_split_015.xhtml#part02) covers how to provide fault tolerance
    and resilience for your services.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何处理故障而不影响客户？当服务失败时，你需要一种优雅地降级功能的方法，而不是让应用程序崩溃。你需要服务的弹性和容错性，以便在服务失败时提供替代方案。[第二部分](kindle_split_015.xhtml#part02)介绍了如何为你的服务提供容错性和弹性。
- en: Having hundreds or thousands of services, versus a handful of applications,
    places additional burdens on operations. Most operations teams aren’t experienced
    in dealing with such a large number of services. How do you mitigate some of this
    complexity? Monitoring needs to play a major part here—in particular, automated
    monitoring. You need to automate the monitoring of hundreds of services to reduce
    the burden on operations, while also providing information that’s as near to real-time
    as possible about the entire system.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有数百或数千个服务，而不是少数几个应用程序，给运维带来了额外的负担。大多数运维团队没有处理如此大量服务的经验。如何减轻一些这种复杂性？监控需要在这里扮演重要角色——特别是自动化监控。你需要自动化监控数百个服务以减轻运维负担，同时尽可能提供关于整个系统的实时信息。
- en: 1.2.4\. What can be done to assist in developing microservices?
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.4. 如何协助开发微服务？
- en: Microservice development is hard, so what can you do to make it easier? There’s
    no panacea for making it easy, but this section covers a couple of options for
    making microservice development more manageable.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务开发很困难，那么你能做些什么来让它更容易呢？没有一劳永逸的方法来让它变得容易，但本节介绍了几个使微服务开发更易于管理的选项。
- en: 1.2.5\. Product over project
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.5. 产品而非项目
- en: Netflix has been a major proponent of the product-over-project idea for its
    microservices since rewriting its entire architecture under the leadership of
    Adrian Cockroft.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Netflix自从在Adrian Cockroft的领导下重写其整个架构以来，一直是其微服务产品而非项目理念的坚定支持者。
- en: All these years, we’ve been developing projects and not products. Why? Because
    we develop an application that meets a set of requirements and then hand it over
    to operations. The application might require two weeks or two years to develop,
    but it’s still a project if, at the end, the application is handed over and the
    team disbanded. Some team members may be retained for a period to handle maintenance
    requests and enhancements, but the effort is still considered a project followed
    by lots of mini projects.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这些年来，我们一直在开发项目而不是产品。为什么？因为我们开发的应用程序满足了一组需求，然后将其移交给运营。该应用程序可能需要两周或两年时间来开发，但如果最终是将其移交给运营团队解散，那么它仍然是一个项目。一些团队成员可能会保留一段时间来处理维护请求和增强功能，但这种努力仍然被视为项目，随后是许多小项目。
- en: So how do you develop a *product*? Developing a product means that a single
    team owns it for the entirety of its lifespan, whether that be 2 months or 20
    years. The team will develop it, release it, manage the operational aspects of
    the application, resolve production issues—pretty much everything.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何开发一个 *产品* 呢？开发一个产品意味着一个团队在整个生命周期内拥有它，无论是 2 个月还是 20 年。团队将开发它、发布它、管理应用程序的运营方面、解决生产问题——几乎一切。
- en: Why does the differentiation between a project and a product matter? Owning
    a product engenders a greater sense of responsibility about the way an application
    is developed. How? Do you want to be paged in the middle of the night because
    an application is failing? I know I don’t!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么区分项目和产品很重要？拥有一个产品意味着对应用程序开发方式有更大的责任感。如何？你希望半夜被叫醒，因为一个应用程序失败了？我知道我不希望这样！
- en: How does a shift of focus from project to product help with developing microservices?
    When you’re seeking a release cadence of a week or less, as is typical for true
    microservices, it’s hard to reach that release frequency with developers who aren’t
    familiar with the codebase, as would be the case with a *project* approach.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 从项目转向产品如何帮助开发微服务？当你寻求一周或更短的发布周期，这是真正的微服务典型的，对于不熟悉代码库的开发者来说，很难达到那种发布频率，就像 *项目*
    方法一样。
- en: 1.2.6\. Continuous integration and delivery
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.6\. 持续集成和交付
- en: Without continuous integration and delivery, developing microservices becomes
    a great deal more difficult.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 没有持续集成和交付，开发微服务会变得困难得多。
- en: '*Continuous integration* refers to the processes that ensure any change, or
    commit, to a source repository results in a new build of the application, including
    all associated tests of that application. This provides quick feedback on whether
    or not changes broke the application, provided the tests are sufficient enough
    to discover it.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*持续集成* 指的是确保对源存储库的任何更改或提交都会导致应用程序的新构建，包括该应用程序的所有相关测试。这提供了快速反馈，以确定更改是否破坏了应用程序，前提是测试足够充分以发现它。'
- en: '*Continuous delivery* is a reasonably new phenomenon that has come from the
    DevOps movement, whereby application changes are continuously delivered between
    environments, including production, to ensure expeditious delivery of application
    changes. A manual step may occur to approve a build going into production, but
    not always. Having a manual step is likely for critical user applications and
    less so for others. Continuous delivery is usually offered by means of a build
    pipeline, which can consist of automatic or manual steps, such as a manual step
    to approve a release for production.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*持续交付* 是一个相对较新的现象，它源自 DevOps 运动，其中应用程序更改在环境之间持续交付，包括生产环境，以确保应用程序更改的快速交付。可能有一个手动步骤来批准构建进入生产，但并不总是如此。对于关键用户应用程序，可能需要手动步骤，而对于其他应用程序则不太需要。持续交付通常通过构建管道提供，该管道可以包括自动或手动步骤，例如手动步骤来批准生产版本的发布。'
- en: Continuous integration and delivery, referred to as *CI/CD*, are key tools in
    facilitating a short release cadence. Why? They enable developers to find possible
    bugs earlier in the process in an automated manner. But more important, CI/CD
    significantly reduces the amount of time between determining that a piece of code
    is ready for production and having it live for users. If a release process takes
    a day or two to complete, that isn’t conducive to releasing multiple times a day
    or even once a day.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成和交付，简称 *CI/CD*，是促进短期发布周期的关键工具。为什么？它们使开发者能够以自动化的方式在过程中早期发现可能的错误。但更重要的是，CI/CD
    显著减少了确定代码块已准备好投入生产到它对用户可见之间的时间。如果发布过程需要一天或两天才能完成，那么这不利于每天多次或每天至少一次的发布。
- en: Another important benefit of CI/CD is the ability to be more incremental in
    delivering functionality. The goal isn’t just to be able to physically release
    code faster; being able to deploy smaller pieces of functionality is crucial for
    minimizing risk as well. If a small change reaches production that causes a failure,
    backing out that change is a relatively easy task.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: CI/CD的另一个重要好处是能够更渐进地交付功能。目标不仅仅是能够更快地物理发布代码；能够部署更小的功能片段对于最小化风险至关重要。如果一个小改动在生产中导致失败，撤销该改动是一个相对容易的任务。
- en: 1.3\. Patterns for migration to microservices
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3. 演进到微服务模式的策略
- en: You’ve looked at Enterprise Java with its existing monoliths and you’ve learned
    about microservices in a distributed architecture. But how do you get from one
    to the other? This section delves into patterns that can be applied to the problem
    of splitting an existing monolith into multiple microservices.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解了具有现有单体架构的企业Java，你也学习了分布式架构中的微服务。但你是如何从一种过渡到另一种的呢？本节深入探讨了可以应用于将现有单体拆分为多个微服务的问题的模式。
- en: 1.3.1\. Domain-Driven Design
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.1. 领域驱动设计
- en: '*Domain-Driven Design* (DDD) is a set of patterns and methodologies for modeling
    our understanding of the domains in our software. A key part of this is the Bounded
    Context pattern ([https://martinfowler.com/bliki/BoundedContext.html](https://martinfowler.com/bliki/BoundedContext.html)),
    which enables you to segregate parts of the system to be modeled at a single time.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**领域驱动设计**（DDD）是一套用于建模我们对软件中领域理解的模式和方法的集合。其关键部分是**边界上下文模式**（[https://martinfowler.com/bliki/BoundedContext.html](https://martinfowler.com/bliki/BoundedContext.html)），它允许你将系统的一部分在单次建模中隔离开来。'
- en: This topic is far too broad to be covered in a few small paragraphs in this
    book, especially because many books are already dedicated to DDD. But we’ll cover
    it briefly here as another piece in the puzzle of developing with microservices.
    DDD can be used both in greenfield microservice development and in migrating to
    microservices.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个主题过于广泛，无法在这本书的几小段文字中涵盖，尤其是考虑到已经有许多书籍专门讨论领域驱动设计（DDD）。但在这里，我们将简要介绍它，作为使用微服务进行开发的谜题中的一部分。领域驱动设计（DDD）是一套用于建模我们对软件中领域理解的模式和方法的集合。其中关键的部分是**边界上下文模式**（[https://martinfowler.com/bliki/BoundedContext.html](https://martinfowler.com/bliki/BoundedContext.html)），它允许你将系统的一部分在单次建模中隔离开来。
- en: A sufficiently large application or system can be divided into multiple Bounded
    Contexts, enabling design and development to focus on the core domain of a given
    Bounded Context at any one point. This pattern acknowledges that it’s difficult
    to come up with a domain model for an entire enterprise at any one time, because
    too many complexities exist. Dividing such a model into manageable Bounded Contexts
    provides a way to focus on a portion of that model without concerning yourself
    with the remainder of the, likely unknown, domain model. [Figure 1.5](#ch01fig05)
    is an example to help you understand the concepts behind DDD.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一个足够大的应用程序或系统可以被划分为多个边界上下文，使得设计和开发在任何时候都能专注于给定边界上下文的核心理念。这种模式承认，在任何时候为整个企业提出一个领域模型都是困难的，因为存在太多的复杂性。将这样的模型划分为可管理的边界上下文，提供了一种在不关心其余部分（可能未知）的领域模型的情况下，专注于模型一部分的方法。[图1.5](#ch01fig05)是一个帮助你理解DDD背后概念的示例。
- en: Figure 1.5\. Store domain model
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.5. 商店领域模型
- en: '![](Images/01fig05_alt.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/01fig05_alt.jpg)'
- en: Say you have a store that wants to develop microservices, and its domain model
    consists of an order, items within an order, a product, and a supplier of that
    product. The current domain model combines the different ways a Product can be
    defined. From the perspective of an Order, it doesn’t care who supplies the product,
    how many are currently in stock, what the manufacturer price is, or any other
    information that’s relevant to only the administration of the business. Conversely,
    the administration side isn’t necessarily concerned with how many orders a product
    may be associated with.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个想要开发微服务的商店，其领域模型包括订单、订单中的项目、产品以及该产品的供应商。当前的领域模型结合了产品定义的不同方式。从订单的角度来看，它不关心谁供应产品，当前有多少库存，制造商的价格，或任何仅与业务管理相关的其他信息。相反，管理方面也不一定关心一个产品可能关联的订单数量。
- en: '[Figure 1.6](#ch01fig06) shows you now have Product in each Bounded Context;
    each represents a different view of a product. The Order Bounded Context has only
    information such as a product code and description. All the product information
    required by the business is within the Product Bounded Context.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1.6](#ch01fig06) 显示你现在在每个边界上下文中都有产品；每个都代表产品的一个不同视图。订单边界上下文只有产品代码和描述等信息。所有业务所需的产品信息都在产品边界上下文中。'
- en: Figure 1.6\. Separate Bounded Contexts
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.6\. 分离的边界上下文
- en: '![](Images/01fig06_alt.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/01fig06_alt.jpg)'
- en: In some cases, a clean split will exist in the domain model of a Bounded Context,
    but in others there will be commonality between the separate models, as in the
    preceding example. In this situation, it’s important to consider that although
    a part of the domain model is shared between Bounded Contexts, one domain can
    be classed as the *owner*.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，边界上下文的领域模型中可能存在清晰的分割，但在其他情况下，不同的模型之间将存在共性，就像前面的例子中那样。在这种情况下，重要的是要考虑，尽管领域模型的一部分在边界上下文中是共享的，但一个领域可以被归类为
    *所有者*。
- en: Having defined the owner of a piece of the domain, it becomes necessary to make
    that domain available to external Bounded Contexts—but in a way that doesn’t implicitly
    tie the two Bounded Contexts together. This does make it trickier to handle the
    boundary, but patterns such as Event Sourcing can help with this problem.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了领域的一部分的所有者之后，使其领域对外部边界上下文可用就变得必要了——但要以不隐式地将两个边界上下文联系起来的方式。这确实使得处理边界变得更加复杂，但像事件溯源这样的模式可以帮助解决这个问题。
- en: '|  |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: '*Event sourcing* is the practice of firing events for every state change in
    an application, which is usually recorded as a log in a certain format. Such a
    log can then be used to rebuild entire database structures, or as in this case,
    as a way to populate a piece of a domain model that’s owned externally.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*事件溯源* 是在应用程序中为每个状态变化触发事件的实践，这通常以某种格式记录为日志。这样的日志可以用来重建整个数据库结构，或者在本例中，作为填充外部拥有的部分领域模型的方式。'
- en: '|  |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: How do all these Bounded Contexts fit together? Each Bounded Context forms part
    of a greater whole, a context map. A *context map* is a global view of an application,
    identifying all the required Bounded Contexts and the way they should communicate
    and integrate with each other.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些边界上下文是如何相互配合的？每个边界上下文都是更大整体的一部分，即上下文图。*上下文图* 是应用程序的全局视图，标识了所有所需的边界上下文以及它们应该如何相互通信和集成。
- en: In this example, because you’ve split Product into two, you’d need such a data
    feed from the Product to Order Bounded Contexts to be able to populate the Product
    with appropriate data.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，因为你已经将产品分成了两部分，你需要从产品到订单边界上下文的数据馈送，以便能够用适当的数据填充产品。
- en: As you saw in our example, one side benefit of shared domain models in Bounded
    Contexts is that each can have its own view of the same data. An application is
    no longer forced into viewing a piece of data in the same way as its owner does.
    This can provide huge benefits when a domain needs only a small subset of the
    data in each record that the owner might hold. For additional information on Domain-Driven
    Design and Bounded Contexts, I recommend *Functional and Reactive Domain Modeling*
    by Debasish Ghosh (Manning, 2016).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在我们的示例中看到的，在边界上下文中共享领域模型的一个附带好处是，每个上下文都可以拥有对相同数据的自己的视图。应用程序不再被迫以与其所有者相同的方式查看数据的一部分。当领域只需要记录中所有者可能持有的数据的一个小子集时，这可以提供巨大的好处。关于领域驱动设计和边界上下文的更多信息，我推荐
    Debasish Ghosh 的《功能性和反应式领域建模》（Manning, 2016）。
- en: 1.3.2\. Big Bang pattern
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.2\. 大爆炸模式
- en: The *Big Bang pattern* for migrating to microservices in an enterprise is by
    far the most complicated and challenging. It entails breaking apart every single
    piece of an existing monolith into microservices, such that there’s a single cutover
    from one to the other.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业中迁移到微服务时的 *大爆炸模式* 一直以来都是最复杂和最具挑战性的。它涉及到将现有单体中的每一块拆分成微服务，使得从一种到另一种有一个单一的切换。
- en: Because deployment is a single cutover—a Big Bang—to production, developing
    for such a change can take just as long as developing on a monolith. Certainly,
    by the end of the process, you’ve moved to microservices, but this pattern would
    be a bumpier road for most enterprises than other patterns for migrating to microservices—especially
    when considering the internal process and procedure changes required to move between
    the two deployment models. Such an abrupt change would be traumatic and potentially
    damaging to an enterprise.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 由于部署是一个单一的切换——大爆炸——到生产，为这种变化开发可能需要与单体开发一样长的时间。当然，到过程结束时，你已经迁移到了微服务，但与其他迁移到微服务的模式相比，这种模式对大多数企业来说道路会更加坎坷——特别是考虑到在两种部署模型之间移动所需的内部流程和程序变更。这种突然的变化可能会对企业的运营造成创伤，并可能造成损害。
- en: The Big Bang pattern isn’t recommended for most enterprises as a means of migrating,
    and most definitely not for those who aren’t experienced with microservices already.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 大爆炸模式不建议作为大多数企业迁移的手段，尤其是对于那些还没有微服务经验的企业。
- en: 1.3.3\. Strangler pattern
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.3. Strangler模式
- en: The *Strangler pattern* is based on the Strangler Application defined by Martin
    Fowler ([www.martinfowler.com/bliki/StranglerApplication.html](http://www.martinfowler.com/bliki/StranglerApplication.html)).
    Martin describes this pattern as a way to rewrite an existing system by gradually
    creating a new system at the edges of the existing one. The new system slowly
    grows over several years, until the old system is strangled into nonexistence.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*Strangler模式*基于马丁·福勒定义的Strangler应用程序([www.martinfowler.com/bliki/StranglerApplication.html](http://www.martinfowler.com/bliki/StranglerApplication.html))。马丁将此模式描述为通过逐步在现有系统的边缘创建新系统来重写现有系统的方式。新系统在几年内缓慢增长，直到旧系统被扼杀至不存在。'
- en: 'You may find a similar end result as the Big Bang pattern—not necessarily a
    bad thing—but it’s achieved over a much longer time span while still delivering
    business value in the interim. This approach significantly reduces the risk involved,
    compared to the Big Bang pattern. Through monitoring progress of the application
    over time, you can adjust the way you implement microservices as you learn with
    each new one implemented. This is another huge advantage over the Big Bang pattern:
    being able to adjust and react to issues that might arise in processes or procedures.
    With a Big Bang approach, an enterprise is tied into its processes until everything
    has cutover.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会发现与大爆炸模式类似的结果——不一定是坏事——但这是在更长的时间跨度内实现的，同时仍然在过渡期间提供业务价值。这种方法与大爆炸模式相比，显著降低了风险。通过监控应用程序随时间的发展，你可以随着每个新实现的微服务的学习来调整实现微服务的方式。这是大爆炸模式之外的另一个巨大优势：能够调整和应对可能出现在流程或程序中的问题。采用大爆炸方法，企业会一直绑定到其流程，直到一切切换完成。
- en: 1.3.4\. Hybrid pattern
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.4. 混合模式
- en: Now that you’ve seen both the Big Bang and Strangler patterns, let’s look at
    the *Hybrid pattern*. I feel this pattern will become the predominant pattern
    for enterprises migrating to and developing microservices.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了大爆炸模式和Strangler模式，让我们来看看*混合模式*。我感觉这个模式将成为企业迁移到和发展微服务的主要模式。
- en: 'This pattern begins life in a similar fashion to the Strangler. The difference
    is that you never fully strangle the original monolith. You retain some functionality
    within a monolith and integrate that with new microservices. [Figure 1.7](#ch01fig07)
    shows the path of a request through an existing Enterprise Java monolith and a
    new microservices architecture:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式与Strangler模式有相似之处，不同之处在于你永远不会完全扼杀原始单体。你保留单体中的一些功能，并将其与新的微服务集成。[图1.7](#ch01fig07)显示了请求通过现有的企业Java单体和新微服务架构的路径：
- en: A user makes a request from a browser specifying which view of an application
    they wish to see.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户从浏览器发出请求，指定他们希望看到的应用程序视图。
- en: The view calls out to a controller to retrieve whatever information might be
    required to construct itself.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 视图会调用控制器以检索构建自身可能需要的信息。
- en: The controller calls a business service, possibly to aggregate data from different
    sources.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制器调用业务服务，可能从不同的来源聚合数据。
- en: The business service then passes the request into the microservices environment,
    where it enters the gateway.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 业务服务然后将请求传递到微服务环境，在那里它进入网关。
- en: The gateway routes the request to the appropriate microservice based on routing
    rules that have been defined.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网关根据定义的路由规则将请求路由到适当的微服务。
- en: A microservice receives the request and performs some of its own processing
    on it before calling another microservice.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 微服务接收请求并在调用另一个微服务之前对其进行一些自己的处理。
- en: The last microservice in the chain interacts with the data storage layer to
    read/write records.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 链接中的最后一个微服务与数据存储层交互以读取/写入记录。
- en: An architecture such as that in [figure 1.7](#ch01fig07) provides a great deal
    of flexibility for growth and delivering business value in a timely fashion. Components
    that require high performance and/or high availability can be deployed to the
    microservices environment. Components that are too costly to be migrated to the
    new architecture can remain deployed on an Enterprise Java platform.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图1.7](#ch01fig07)所示的架构为增长和及时交付业务价值提供了很大的灵活性。需要高性能和高可用性的组件可以部署到微服务环境中。那些迁移到新架构成本过高的组件可以继续部署在企业Java平台上。
- en: Figure 1.7\. Enterprise Java and microservices hybrid architecture
  id: totrans-152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.7\. 企业Java和微服务混合架构
- en: '![](Images/01fig07_alt.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/01fig07_alt.jpg)'
- en: You’ll focus on the Hybrid pattern later in the book, when you migrate an existing
    Enterprise Java application to use microservices.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在本书的后面部分关注混合模式，当您将现有的企业Java应用程序迁移到使用微服务时。
- en: 1.4\. What are Enterprise Java microservices?
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4\. 什么是企业Java微服务？
- en: As I mentioned at the beginning of the chapter, Enterprise Java microservices
    are purely microservices developed with Enterprise Java. So let’s take a look
    at a simple example to see it in practice.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在本章开头提到的，企业Java微服务是纯粹使用企业Java开发的微服务。那么，让我们通过一个简单的例子来看看它在实际中的应用。
- en: Let’s create a simple RESTful Java EE microservice that uses CDI and JAX-RS.
    This microservice exposes a RESTful endpoint to greet the user by name; the message
    returned is being provided via a CDI service you inject ([listing 1.1](#ch01ex01)).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的RESTful Java EE微服务，该服务使用CDI和JAX-RS。这个微服务通过一个RESTful端点按名称问候用户；返回的消息是通过注入的CDI服务提供的（[列表1.1](#ch01ex01)）。
- en: Listing 1.1\. CDI service
  id: totrans-158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表1.1\. CDI服务
- en: '[PRE0]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '***1* CDI annotation that says you want a new HelloService instance for each
    servlet Request made. In this instance, because you’re not storing state, it could
    easily have been @ApplicationScoped instead.**'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* CDI注解表示您希望为每个servlet请求创建一个新的HelloService实例。在这种情况下，因为您没有存储状态，它很容易被@ApplicationScoped替代。**'
- en: '***2* Service method that takes a single parameter and returns it prefixed
    “Hello”**'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 服务方法接受单个参数并返回前缀为“Hello”的结果**'
- en: The preceding service defines a single `sayHello()` method that returns `Hello`
    combined with the value of the `name` parameter.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的服务定义了一个单一的`sayHello()`方法，该方法返回与`name`参数值结合的`Hello`。
- en: You can then `@Inject` that service into your controller.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以将该服务`@Inject`到您的控制器中。
- en: Listing 1.2\. JAX-RS endpoint
  id: totrans-164
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表1.2\. JAX-RS端点
- en: '[PRE1]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '***1* CDI annotation that states you need only a single instance for the entire
    application**'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* CDI注解表示您只需要整个应用程序的单个实例**'
- en: '***2* Defines the RESTful URL path of this controller. In this case, it’s set
    to “/hello”.**'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 定义了此控制器的RESTful URL路径。在这种情况下，它被设置为“/hello”。**'
- en: '***3* You inject an instance of HelloService that you can use.**'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 注入一个HelloService实例，您可以使用它。**'
- en: '***4* Defines the type of HTTP requests the method handles**'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 定义方法处理的HTTP请求类型**'
- en: '***5* Specifies the URL path for the method. You also specify a parameter called
    name that can be passed on the URL of the request.**'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 指定方法的URL路径。您还可以指定一个名为name的参数，该参数可以传递到请求的URL上。**'
- en: '***6* The method produces a text response only.**'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 该方法仅产生文本响应。**'
- en: '***7* Assigns the path parameter called name as the method parameter**'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 将名为name的路径参数分配为方法参数**'
- en: '***8* Calls sayHello on the injected service passing the name parameter value**'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 在注入的服务上调用sayHello，传递name参数值**'
- en: If you’ve developed JAX-RS resources before, you’ll recognize everything in
    the preceding code. What does that mean? It means that you can develop microservices
    with Enterprise Java just as if you were developing an Enterprise Java application.
    The ability to develop a microservice with existing Enterprise Java knowledge
    is a significant advantage in using Enterprise Java for microservices.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您之前开发过JAX-RS资源，您会认出前面代码中的所有内容。这意味着什么？这意味着您可以使用企业Java开发微服务，就像您在开发企业Java应用程序一样。使用现有企业Java知识开发微服务的能力是使用企业Java进行微服务的一个重大优势。
- en: This microservice example is simplified because you’re dealing with only the
    producer side of the equation. If the service also consumed other microservices,
    it would be more complex. But you’ll come to that in [part 2](kindle_split_015.xhtml#part02)
    of this book.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这个微服务示例被简化了，因为你只处理等式的生产者一侧。如果服务还消费了其他微服务，它就会更复杂。但你在本书的[第二部分](kindle_split_015.xhtml#part02)中会了解到这一点。
- en: Though the preceding example was implemented with Java EE APIs, it could just
    as easily have been implemented using Spring instead.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前面的例子是用 Java EE API 实现的，但它同样可以用 Spring 来实现。
- en: 1.4.1\. Why Enterprise Java is a good fit for microservices
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.4.1. 为什么企业 Java 适合微服务
- en: 'You’ve seen how easy it is to develop a RESTful endpoint as an Enterprise Java
    micro-service, but why should you? Wouldn’t you be better off using a newfangled
    framework or technology specifically built for microservices? You have plenty
    to choose from right now: Go, Rust, and Node.js are just some examples.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了开发一个企业 Java 微服务的 RESTful 端点是多么容易，但你为什么要这样做呢？你不会更愿意使用专门为微服务构建的新颖框架或技术吗？现在你有大量的选择：Go、Rust
    和 Node.js 只是其中的一些例子。
- en: In some situations, using a newer technology may make more sense. But if an
    enterprise has significant investment in Enterprise Java through existing applications,
    developers, and so forth, it makes a lot more sense to continue using that technology,
    because developers have one less thing to learn in developing a microservice.
    And by *technology* I don’t mean Java EE or Spring per se; it’s more about the
    APIs that a technology offers and developers’ familiarity with those APIs. If
    the same APIs can be used with monoliths, microservices, or whatever the next
    buzzword is to hit developer mindshare, that’s far more valuable than relearning
    APIs for each type of development situation.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，使用较新的技术可能更有意义。但如果企业通过现有应用程序、开发人员等在 Enterprise Java 上有重大投资，那么继续使用该技术更有意义，因为开发者开发微服务时可以少学一样东西。而且，我说的**技术**并不是指
    Java EE 或 Spring 本身；更多的是指技术提供的 API 以及开发者对这些 API 的熟悉程度。如果相同的 API 可以用于单体、微服务或即将成为开发者思维共享的下一个热门词汇，那么这比重新学习每种开发情况下的
    API 要有价值得多。
- en: If a developer is building microservices for an enterprise for the first time,
    using a technology that the developer already knows and understands allows that
    developer to focus on the requirements of a microservice—without being concerned
    about learning the nuances of a language or framework at the same time.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个开发者是第一次为企业构建微服务，使用开发者已经熟悉和理解的技术可以让开发者专注于微服务的要求——而不必担心同时学习语言或框架的细微差别。
- en: Using a technology that’s been around for nearly 20 years also has significant
    advantages. Why? A technology that’s been around that long is almost guaranteed
    not to disappear in the near future. Can anyone say Cobol?
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用已经存在了近20年的技术也具有显著的优势。为什么？存在了那么长时间的技术几乎可以保证在不久的将来不会消失。有人能说出 Cobol 吗？
- en: It’s a great comfort to enterprises to know that whatever technology they’re
    developing and investing in isn’t going to be defunct in a few short years. Such
    a risk is typically why enterprises are reluctant to invest in extremely new technology.
    Though it can be frustrating not being able to use the latest and greatest, it
    does have advantages, at least for an enterprise.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对于企业来说，知道他们正在开发和投资的技术在短短几年内不会过时，这是一件非常令人欣慰的事情。这种风险通常是企业不愿意投资于极新技术的原因。虽然不能使用最新和最好的技术可能会让人感到沮丧，但它确实有优势，至少对于企业来说是这样。
- en: 'Enterprises aren’t the only factor that need to be considered when choosing
    a technology for developing microservices. You also need to consider the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择用于开发微服务的技术时，企业并不是唯一需要考虑的因素。你还需要考虑以下内容：
- en: '***Experience and skills of developers in the marketplace*—** There’s no point
    in choosing a particular technology for microservice development if you don’t
    have a sufficiently large pool of resources to choose from. A huge pool of developers
    have Enterprise Java experience, so using that is advantageous.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**市场上的开发者和技能经验**——如果你没有足够大的资源池可供选择，那么选择特定技术进行微服务开发是没有意义的。有大量的开发者拥有企业 Java 经验，因此使用它是具有优势的。'
- en: '***Vendor support*—** It’s all well and good to choose a technology for developing
    microservices, but if no vendors are offering support of that technology, it’s
    difficult. It’s difficult because enterprises like to have a vendor available
    24/7 for support problems with a technology, usually in a production situation.
    Without vendor support, an enterprise needs to employ those who work directly
    on that technology to guarantee they can resolve any issues of their microservices
    in production.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***供应商支持*—** 选择一种技术来开发微服务固然很好，但如果没有任何供应商提供对该技术的支持，那就很困难。困难之处在于，企业希望有一个供应商可以
    24/7 提供技术支持，通常是在生产环境中。没有供应商支持，企业需要雇佣那些直接从事该技术工作的人，以确保他们能够解决生产中微服务的任何问题。'
- en: '***Cost of change*—** If an enterprise has been developing with Enterprise
    Java for a decade or more and has a stable group of developers who have worked
    on projects over that time, does it make sense for an enterprise to abandon that
    history and carve out a new path with different technology? Though in some cases,
    that does make sense, the majority of enterprises should stick with experience
    and skills even if moving to microservices.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***变更成本*—** 如果一个企业已经使用企业 Java 开发了十年或更长时间，并且有一群在该时间段内参与过项目的稳定开发者，那么企业放弃这一历史，开辟一条使用不同技术的全新道路是否合理？尽管在某些情况下，这样做是有道理的，但大多数企业应该坚持经验和技能，即使迁移到微服务。'
- en: '***Existing operational experience and infrastructure*—** In addition to developers,
    the convenience of having years of operational experience with Enterprise Java
    is just as critical. Applications don’t monitor and fix themselves, though that
    would be nice. Having to hire or retrain operations staff on new languages and
    frameworks can be just as time-consuming as doing it for developers.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***现有的运营经验和基础设施*—** 除了开发者外，拥有多年企业 Java 运营经验同样关键。应用程序不会自我监控和修复，尽管那会很理想。需要雇佣或重新培训运营人员学习新的语言和框架可能和为开发者做同样的事情一样耗时。'
- en: Summary
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: A microservice consists of a single deployment executing within a single process.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务由单个部署在单个进程中执行的单个进程组成。
- en: An Enterprise Java monolith is an application in which all its components are
    contained within a single deployment.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 企业 Java 单体是一个所有组件都包含在单个部署中的应用程序。
- en: An Enterprise Java microservice is a microservice developed using Enterprise
    Java frameworks.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 企业 Java 微服务是使用企业 Java 框架开发的微服务。
- en: An Enterprise Java monolith isn’t suitable for a fast release cadence.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 企业 Java 单体不适合快速发布周期。
- en: Implementing microservices isn’t a silver bullet and requires additional consideration
    to implement successfully.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施微服务并非万能药，需要额外的考虑才能成功实施。
- en: Migrating to microservices from a monolith can be best achieved with the Hybrid
    pattern.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从单体迁移到微服务，最佳方式是使用混合模式。
- en: An enterprise’s history of Enterprise Java development shouldn’t be disregarded
    in the decision to implement microservices.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在决定实施微服务时，不应忽视企业使用企业 Java 开发的历史。
- en: Chapter 2\. Developing a simple RESTful microservice
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 2 章\. 开发简单的 RESTful 微服务
- en: '*This chapter covers*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Introducing the Cayambe monolith
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Cayambe 单块石
- en: Developing a simple RESTful application
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发简单的 RESTful 应用程序
- en: Packaging your simple RESTful application as a microservice
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将简单的 RESTful 应用程序打包为微服务
- en: Understanding development with Enterprise Java for microservices
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解企业 Java 微服务开发
- en: This chapter will introduce you to the Cayambe monolith. The Cayambe monolith
    will assist as we develop Enterprise Java microservices throughout the book, with
    each microservice becoming a part of a new Hybrid monolith in [chapter 10](kindle_split_020.xhtml#ch10).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向您介绍 Cayambe 单块石。Cayambe 单块石将在本书开发企业 Java 微服务的过程中提供帮助，每个微服务将成为第 10 章（[kindle_split_020.xhtml#ch10](https://kindle_split_020.xhtml#ch10)）中新的混合单体的一部分。
- en: 2.1\. Cayambe monolith
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1\. Cayambe 单块石
- en: Cayambe is an e-commerce application that hasn’t been maintained for the last
    15 years and needs serious modernization. It’s easy to see from the homepage in
    [figure 2.1](#ch02fig01) that it doesn’t quite have the same look as modern websites
    do today.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Cayambe 是一个已经停止维护 15 年的电子商务应用程序，需要严重的现代化。从图 2.1（[#ch02fig01](#ch02fig01)）中的主页很容易看出，它与现代网站的外观并不完全相同。
- en: Figure 2.1\. Cayambe homepage
  id: totrans-205
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.1\. Cayambe 主页
- en: '![](Images/02fig01_alt.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig01_alt.jpg)'
- en: As you can see in [figure 2.2](#ch02fig02), Cayambe is an EAR deployment that
    consists of three WARs, a common JAR for the UIs, and a JAR containing the EJBs
    (Enterprise Java-Beans) and DAOs (data access objects) for interacting with the
    database.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图2.2](#ch02fig02)所示，Cayambe是一个由三个WAR文件、一个用于UI的通用JAR文件以及包含EJB（企业JavaBeans）和DAO（数据访问对象）以与数据库交互的JAR文件组成的EAR部署。
- en: Figure 2.2\. Cayambe monolith architecture
  id: totrans-208
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.2. Cayambe单体架构
- en: '![](Images/02fig02.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig02.jpg)'
- en: Throughout the book, you’ll work toward moving Cayambe to a series of deployments,
    as represented in [figure 2.3](#ch02fig03). [Chapter 10](kindle_split_020.xhtml#ch10)
    outlines additional details of Cayambe; in that chapter, you’ll integrate the
    monolith with the microservices you develop over the coming chapters.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，你将致力于将Cayambe迁移到一系列部署，如图2.3所示。[第10章](kindle_split_020.xhtml#ch10)概述了Cayambe的更多细节；在第10章中，你将集成单体与你在接下来的章节中开发的微服务。
- en: Figure 2.3\. Cayambe future architecture
  id: totrans-211
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.3. Cayambe未来架构
- en: '![](Images/02fig03_alt.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig03_alt.jpg)'
- en: 2.2\. New administration site
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2. 新管理站点
- en: As part of modernizing Cayambe, you’ll split out the administration of the site,
    enabling the customer aspects of the site to be scaled without also scaling the
    administration aspects.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Cayambe现代化的部分，你将分离站点的管理，使得站点的客户方面可以扩展，而无需同时扩展管理方面。
- en: The first tasks are to develop a JAX-RS RESTful microservice to provide the
    necessary administration endpoints, and to develop a new UI for it by using ReactJS.
    For those already familiar with JAX-RS, you’ll see some repetition of prior knowledge.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 第一项任务是开发一个JAX-RS RESTful微服务，以提供必要的行政端点，并使用ReactJS开发一个新的UI。对于那些已经熟悉JAX-RS的人来说，你会看到一些先前知识的重复。
- en: '[Figure 2.4](#ch02fig04) is the current administration interface for Cayambe.
    Viewing or updating categories in the UI isn’t possible except for the main category
    Transportation. This is far from an ideal situation, so you’ll begin by developing
    a new administration site and microservice to handle managing the product categories.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.4](#ch02fig04)是Cayambe当前的行政界面。在UI中查看或更新类别是不可能的，除非是主要类别运输。这远非理想情况，因此你将首先开发一个新的管理站点和微服务来处理产品类别的管理。'
- en: Figure 2.4\. Old Cayambe administration interface
  id: totrans-217
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.4. 旧的Cayambe管理界面
- en: '![](Images/02fig04_alt.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig04_alt.jpg)'
- en: '[Figure 2.5](#ch02fig05) shows the new administration interface with ReactJS,
    along with the category data displayed as a tree.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.5](#ch02fig05)显示了使用ReactJS的新管理界面，以及以树状结构显示的类别数据。'
- en: Figure 2.5\. New Cayambe administration interface
  id: totrans-220
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.5. 新的Cayambe管理界面
- en: '![](Images/02fig05_alt.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig05_alt.jpg)'
- en: '[Figure 2.6](#ch02fig06) shows where the RESTful microservice you’re developing
    in this chapter will fit into the new Cayambe architecture when you’re finished
    with the book.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.6](#ch02fig06)显示了当你完成本书后，你在此章节中开发的RESTful微服务将如何融入新的Cayambe架构。'
- en: Let’s dive into creating the RESTful microservice you need in order to enable
    the new interface to work.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入创建所需的RESTful微服务，以便启用新接口的工作。
- en: Figure 2.6\. Cayambe administration microservice and UI
  id: totrans-224
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.6. Cayambe管理微服务和UI
- en: '![](Images/02fig06_alt.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig06_alt.jpg)'
- en: 2.2.1\. Use cases
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.1. 用例
- en: For this chapter, you’ll focus on developing the category management parts of
    the administration, but you’ll want to migrate the other aspects from the previous
    administration site at some point as well. Doing so simplifies what you’re learning
    to a single problem domain instead of many, focusing on the code required to make
    category management possible.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你将专注于开发管理部分的类别管理，但你也会在某个时候将其他方面从之前的管理站点迁移过来。这样做可以将你所学的内容简化为一个单一的问题域，而不是多个，专注于实现类别管理所需的代码。
- en: As part of category management, you need to support Create, Read, Update, and
    Delete (CRUD) operations on the categories. This process certainly isn’t the most
    interesting part of developing RESTful endpoints, but most services will need
    some type of CRUD at their core.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 作为类别管理的一部分，你需要支持在类别上执行创建、读取、更新和删除（CRUD）操作。这个过程当然不是开发RESTful端点中最有趣的部分，但大多数服务在其核心都需要某种类型的CRUD。
- en: The UI will call the CRUD operations on the microservice for maintaining categories.
    The microservice RESTful endpoints could be called from any client, but you’ll
    show them operating with your UI. [Figure 2.7](#ch02fig07) details the states
    and transitions between them for managing the categories within the UI.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: UI将调用微服务上的CRUD操作来维护类别。微服务的RESTful端点可以从任何客户端调用，但你将展示它们如何通过你的UI进行操作。[图2.7](#ch02fig07)详细说明了在UI中管理类别时的状态和它们之间的转换。
- en: Figure 2.7\. Category management state flow
  id: totrans-230
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.7\. 类别管理状态流
- en: '![](Images/02fig07_alt.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig07_alt.jpg)'
- en: 2.2.2\. Architecture of the application
  id: totrans-232
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.2\. 应用程序架构
- en: Ignoring microservices for now, the architecture for your application will look
    something like [figure 2.8](#ch02fig08). At the *presentation layer*, you use
    ReactJS for the UI, though we won’t be covering the development of the UI as part
    of this chapter. The *API layer* contains the RESTful endpoints using JAX-RS for
    the category. Finally, you have JPA entities of the category in your *data layer*
    that interacts with the physical database. The API layer is responsible for interacting
    with the data layer to persist record updates.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 目前忽略微服务，你的应用程序架构将类似于[图2.8](#ch02fig08)。在*表示层*，你使用ReactJS来构建UI，尽管我们不会在本章中涵盖UI的开发。*API层*包含使用JAX-RS为类别提供的RESTful端点。最后，你在*数据层*中有类别的JPA实体，它与物理数据库交互。API层负责与数据层交互以持久化记录更新。
- en: Figure 2.8\. Category management architecture
  id: totrans-234
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.8\. 类别管理架构
- en: '![](Images/02fig08_alt.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig08_alt.jpg)'
- en: You could’ve separated the API layer and used services within a business layer
    on top of the data layer, but I chose to simplify it by removing an unnecessary
    layer. Typically, all these layers would be packaged within a single WAR for deployment
    to an application server.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你本可以将API层分离出来，并在数据层之上使用业务层中的服务，但我选择通过移除不必要的层来简化它。通常，所有这些层都会打包在一个WAR文件中，以便部署到应用程序服务器。
- en: How does the architecture change when you shift to constructing a microservice?
    See [figure 2.9](#ch02fig09).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当你转向构建微服务时，架构是如何变化的？参见[图2.9](#ch02fig09)。
- en: Figure 2.9\. Category management microservice architecture
  id: totrans-238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.9\. 类别管理微服务架构
- en: '![](Images/02fig09_alt.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig09_alt.jpg)'
- en: 'Here you can see that your server-side layers are encompassed in a single microservice.
    Your UI then sits in its own WAR to package and deploy the UI to a separate runtime.
    The application architecture is now split into separate deployable pieces: the
    UI, a microservice, and a database.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到你的服务器端层包含在一个单独的微服务中。然后，你的UI位于自己的WAR文件中，用于打包和部署UI到单独的运行时。现在，应用程序架构已分为可独立部署的组件：UI、微服务和数据库。
- en: '|  |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-242
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: On this occasion, you choose to package the UI as a WAR, but because it’s solely
    HTML/CSS/JS, you could’ve used any means for packaging and deploying static sites.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次操作中，你选择将UI打包成WAR文件，但由于它仅包含HTML/CSS/JS，你可以使用任何方式来打包和部署静态网站。
- en: '|  |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Because you’ve split your UI and services into separate runtimes, you need to
    add support for *cross-origin resource sharing* (CORS). If you don’t, the browser
    will prevent the UI from making an HTTP request to the microservice. To do that,
    your microservice needs a filter.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你已将UI和服务拆分到单独的运行时中，你需要添加对*跨源资源共享*（CORS）的支持。如果不这样做，浏览器将阻止UI向微服务发起HTTP请求。为此，你的微服务需要一个过滤器。
- en: Listing 2.1\. CORSFilter
  id: totrans-246
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.1\. CORSFilter
- en: '[PRE2]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '|  |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-249
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: Keep in mind where a UI retrieves data from, and whether CORS needs to be taken
    into account. Not doing so can easily lead to frustrating UI bugs when RESTful
    calls fail for seemingly no reason. On the flip side, if your UI is using an API
    gateway to interact with microservices, the API gateway could offer configuration
    to handle CORS directly as opposed to in a microservice.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住UI从哪里获取数据，以及是否需要考虑CORS。如果不这样做，当RESTful调用失败时，可能会轻易导致令人沮丧的UI错误，看似没有原因。另一方面，如果你的UI正在使用API网关与微服务交互，API网关可以提供配置来直接处理CORS，而不是在微服务中处理。
- en: '|  |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 2.2.3\. Creating RESTful endpoints with JAX-RS
  id: totrans-252
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.3\. 使用JAX-RS创建RESTful端点
- en: To keep the microservice simple, you’ll focus on the RESTful endpoint, the API
    layer, and ignore the development of the JPA entities you need for the database.
    You’ll assume that another kind developer has already written them for you! Rest
    assured that this kind developer has made them available in the project code.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持微服务简单，你将专注于RESTful端点、API层，并忽略数据库所需的JPA实体开发。你将假设另一位开发者已经为你编写了它们！放心，这位开发者已经将它们包含在项目代码中。
- en: In addition to the JPA entities, the developer has provided a convenient `load.sql`
    file containing initial categories that will be used on startup to populate the
    database.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 除了JPA实体之外，开发者还提供了一个包含初始类别（在启动时用于填充数据库）的方便的`load.sql`文件。
- en: '[Figure 2.10](#ch02fig10) shows what you’ll be developing in this section.
    The code for this section can be found in the /chapter2/admin directory of the
    book’s example code.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.10](#ch02fig10)显示了在本节中你将开发的内容。本节代码可在书籍示例代码的/chapter2/admin目录中找到。'
- en: Figure 2.10\. Category management—API layer
  id: totrans-256
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.10\. 类别管理—API层
- en: '![](Images/02fig10_alt.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig10_alt.jpg)'
- en: In this section, you’ll develop `CategoryResource`. Your `CategoryResource`
    will focus on making the CRUD-style operations for category data available from
    RESTful endpoints. It specifies that the RESTful `@Path` for the controller is
    /category. You define `EntityManager` to be injected with CDI, which then provides
    a way to perform operations on the database.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将开发`CategoryResource`。你的`CategoryResource`将专注于从RESTful端点使类别数据的CRUD操作可用。它指定了控制器的RESTful
    `@Path`为/ category。你定义`EntityManager`以通过CDI注入，然后提供了一种在数据库上执行操作的方法。
- en: '|  |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-260
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Though many would argue CRUD isn’t appropriate for RESTful services, it’s often
    used that way by developers as a means of bolting RESTful onto existing CRUD.
    Many levels of REST also are defined by Leonard Richardson in the Richardson Maturity
    Model. Hypermedia as the Engine of Application State (HATEOAS) is the most complex
    and difficult level within the model. The examples in this book don’t conform
    to the HATEOAS level of REST, mostly because it’s not what many enterprise developers
    are familiar with in their regular work. Take a look at [http://mng.bz/vMPk](http://mng.bz/vMPk)
    and [https://restfulapi.net/richardson-maturity-model/](https://restfulapi.net/richardson-maturity-model/)
    for further information on the maturity model.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管许多人会争论CRUD不适合RESTful服务，但开发者通常将其用作将RESTful附加到现有CRUD的手段。Leonard Richardson在Richardson成熟度模型中也定义了许多REST级别。作为模型中最复杂和最困难的级别，超媒体作为应用程序状态引擎（HATEOAS）。本书中的示例不符合REST的HATEOAS级别，主要是因为这不是许多企业开发者在其日常工作中所熟悉的。有关成熟度模型的更多信息，请参阅[http://mng.bz/vMPk](http://mng.bz/vMPk)和[https://restfulapi.net/richardson-maturity-model/](https://restfulapi.net/richardson-maturity-model/)。
- en: '|  |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: By default, all JAX-RS resource instances are active only on a per-request basis.
    If you don’t change that, every request will spend time creating the necessary
    `EntityManager` instance to be injected. That doesn’t have a huge performance
    impact, but if you can avoid it, you should. To avoid the re-creation of `EntityManager`,
    you need to mark it as `@ApplicationScoped`. This tells the runtime that you want
    `CategoryResource` to have its lifecycle managed by CDI, and not by JAX-RS. You
    need to define a JAX-RS application class to define the root path for your microservice.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，所有JAX-RS资源实例仅在请求的基础上激活。如果你不改变这一点，每个请求都将花费时间创建必要的`EntityManager`实例以进行注入。这不会对性能产生巨大影响，但如果你能避免它，你应该避免。为了避免`EntityManager`的重新创建，你需要将其标记为`@ApplicationScoped`。这告诉运行时你希望`CategoryResource`的生命周期由CDI管理，而不是由JAX-RS管理。你需要定义一个JAX-RS应用程序类来定义你的微服务的根路径。
- en: Listing 2.2\. AdminApplication
  id: totrans-264
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.2\. AdminApplication
- en: '[PRE3]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1*** Defines the RESTful URL for the root of the application'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 定义应用程序根的RESTful URL'
- en: That’s all you need to do for this class. Because you’re asking CDI to manage
    the lifecycle of `CategoryResource`, you don’t need to configure any singletons
    within JAX-RS. Now it’s time to develop the RESTful endpoints you need for CRUD
    operations of your categories.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个类，你需要做的就这些。因为你要求CDI管理`CategoryResource`的生命周期，所以你不需要在JAX-RS中配置任何单例。现在是你开发所需用于类别CRUD操作的RESTful端点的时候了。
- en: Viewing all categories
  id: totrans-268
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 查看所有类别
- en: The main screen for your application is a tree of categories. Populating the
    list on the screen requires a RESTful endpoint to retrieve all the categories
    from the database.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的主屏幕是一个类别树。在屏幕上填充列表需要RESTful端点从数据库检索所有类别。
- en: Listing 2.3\. @`GET` on `CategoryResource`
  id: totrans-270
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.3\. 在 `CategoryResource` 上 `@GET`
- en: '[PRE4]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***1*** Specifies the particular persistence unit, AdminPU, that you want an
    EntityManager for'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 指定你想要 EntityManager 的特定持久化单元，AdminPU'
- en: '***2*** @GET indicates that the method will accept only HTTP GET requests.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** @GET 表示该方法将仅接受 HTTP GET 请求。'
- en: '***3*** RESTful URL to the endpoint is set as /categorytree.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 端点的 RESTful URL 设置为 /categorytree。'
- en: '***4*** Indicates that the method returns data that has been marshaled to JSON'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** 表示该方法返回已序列化为 JSON 的数据'
- en: '***5*** Returns a CategoryTree as the root category. All other categories will
    be retrieved as children of the root.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** 返回一个作为根类别的 CategoryTree。所有其他类别都将作为根的子类别检索。'
- en: '***6*** Finds the CategoryTree instance with primary key of 1 using the injected
    EntityManager'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** 使用注入的 EntityManager 查找主键为 1 的 CategoryTree 实例'
- en: Deleting a category
  id: totrans-278
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 删除类别
- en: After you have a category, you need the ability to delete an old one that isn’t
    used. For that, you need to add a RESTful endpoint for deleting a category from
    the database as shown in [listing 2.4](#ch02ex04).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在你拥有一个类别后，你需要能够删除不再使用的旧类别。为此，你需要添加一个 RESTful 端点以从数据库中删除类别，如[列表 2.4](#ch02ex04)所示。
- en: Listing 2.4\. @`DELETE` on `CategoryResource`
  id: totrans-280
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.4\. 在 `CategoryResource` 上 `@DELETE`
- en: '[PRE5]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1*** @DELETE indicates the method will accept only HTTP DELETE requests.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** @DELETE 表示该方法将仅接受 HTTP DELETE 请求。'
- en: '***2*** Defines that the method accepts a parameter and gives it a name of
    categoryId'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 定义该方法接受一个参数，并将其命名为 categoryId'
- en: '***3*** Requires a transaction to be present when executing this endpoint'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 在执行此端点时需要存在事务'
- en: '***4*** Finds the Category instance based on the categoryId you received as
    a parameter'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** 根据你作为参数接收的 categoryId 查找类别实例'
- en: '***5*** Removes the Category instance from being persisted'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** 从持久化中删除 Category 实例'
- en: '***6*** If you encountered an exception, returns a server error containing
    the exception message using JAX-RS Response'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** 如果遇到异常，则使用 JAX-RS 响应返回包含异常消息的服务器错误'
- en: '***7*** Returns an empty response if the Category was successfully deleted'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7*** 如果类别成功删除，则返回一个空响应'
- en: Adding a category
  id: totrans-289
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 添加类别
- en: Sometimes new categories need to be added. For that, you have a RESTful endpoint
    to add a new category into your database.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 有时需要添加新的类别。为此，你有一个 RESTful 端点可以将新类别添加到你的数据库中。
- en: Listing 2.5\. @`POST` on `CategoryResource`
  id: totrans-291
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.5\. 在 `CategoryResource` 上 `@POST`
- en: '[PRE6]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1*** @POST indicates the method will accept only HTTP POST requests.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** @POST 表示该方法将仅接受 HTTP POST 请求。'
- en: '***2*** Indicates that the method will accept only JSON that can be marshaled
    to a Category instance'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 表示该方法将仅接受可以序列化为类别实例的 JSON'
- en: '***3*** The method also returns a Category that’s marshaled to JSON.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 该方法还返回一个序列化为 JSON 的类别。'
- en: '***4*** If the Category has an ID set, returns a 409 response status to indicate
    a conflict with the record attempting to be created'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** 如果类别已设置 ID，则返回 409 响应状态以指示与尝试创建的记录冲突'
- en: '***5*** Persists the new Category into the database'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** 将新类别持久化到数据库中'
- en: '***6*** As part of the Response, sets the location path to the new Category
    with its identifier'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** 作为响应的一部分，将位置路径设置为具有其标识符的新类别'
- en: In addition, the `CategoryResource` has RESTful endpoints defined to retrieve
    and update a category. The code for the additional methods is available in the
    [chapter 2](#ch02) source.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`CategoryResource` 定义了 RESTful 端点以检索和更新类别。附加方法的代码可在[第 2 章](#ch02)源代码中找到。
- en: 2.2.4\. Running it
  id: totrans-300
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.4\. 运行它
- en: Although you’ve indicated that your RESTful endpoint is an administration microservice,
    nothing in the code you’ve developed prevents it from being built as a WAR and
    deployed to an application server.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你已表明你的 RESTful 端点是一个管理微服务，但你开发的代码中没有任何东西阻止它被构建为 WAR 并部署到应用程序服务器。
- en: Because you’re dealing with a UI communicating with only a single microservice,
    there isn’t any difference between that and existing Enterprise Java development
    with WARs. The upside to the similarity is that migrating existing Enterprise
    Java code into a microservice is easier if no code changes are required for a
    microservice producer.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你只与一个微服务进行 UI 通信，因此它与现有的企业 Java 开发（使用 WAR）之间没有区别。这种相似性的优点是，如果微服务生产者不需要进行代码更改，则将现有的企业
    Java 代码迁移到微服务更容易。
- en: To give more of a microservice feel for our example, you’ll package it as an
    uber jar with Thorntail. Thorntail offers an alternative approach to packaging
    your applications as a WAR or EAR and then deploying to a full Java EE application
    server. It allows you to choose the parts you need from WildFly and package them
    into an uber jar that can be run from the command line. [Chapter 3](kindle_split_012.xhtml#ch03)
    covers the features of Thorntail in detail. To run the microservice, you need
    to add the plugin in [listing 2.6](#ch02ex06) to your pom.xml.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的示例更具微服务感，你将使用Thorntail将其打包为一个uber jar。Thorntail提供了一种将你的应用程序打包为WAR或EAR，然后部署到完整的Java
    EE应用服务器的方法的替代方案。它允许你从WildFly中选择所需的组件，并将它们打包成一个可以从命令行运行的uber jar。[第3章](kindle_split_012.xhtml#ch03)详细介绍了Thorntail的功能。要运行微服务，你需要在pom.xml中添加[列表2.6](#ch02ex06)中的插件。
- en: Listing 2.6\. Maven plugin configuration
  id: totrans-304
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.6。Maven插件配置
- en: '[PRE7]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '***1*** Latest version of Thorntail'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** Thorntail的最新版本'
- en: '***2*** Run the package goal of the plugin when executed.'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 在执行时运行插件的打包目标。'
- en: '***3*** Specify a port offset of 1 so your microservice will start on port
    8081.'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 指定端口偏移量为1，以便你的微服务将在端口8081上启动。'
- en: 'That’s all you need to do to provide a way to run the microservice from the
    directory, as well as package it as an uber jar. So how and what do you run? Two
    pieces need to be run: one for the UI and one for the microservice. If you wanted
    to execute tests against the RESTful endpoints directly, without using the UI,
    you need to start only the microservice.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需做这些就能提供一个从目录中运行微服务以及将其打包为uber jar的方法。那么你应该如何运行什么？需要运行两个部分：一个用于UI，一个用于微服务。如果你想要直接对RESTful端点执行测试，而不使用UI，你只需要启动微服务。
- en: Starting the microservice
  id: totrans-310
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 启动微服务
- en: 'Open a terminal, or command window, and navigate to the /chapter2/admin directory
    of the book example code. From that directory, run this:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个终端或命令窗口，导航到书中示例代码的/chapter2/admin目录。从该目录运行以下命令：
- en: '[PRE8]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This starts the administration microservice containing your RESTful endpoints.
    After the log shows that the microservice is deployed, you can go to a browser
    and open it to http://localhost:8081/admin/category. Your browser will load the
    category data and display it in JSON format. Now that you know the microservice
    is running, let’s run the UI.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动包含你的RESTful端点的管理微服务。在日志显示微服务已部署后，你可以打开浏览器并访问http://localhost:8081/admin/category。你的浏览器将加载类别数据并以JSON格式显示。现在你知道微服务正在运行，让我们运行UI。
- en: Starting the UI
  id: totrans-314
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 启动UI
- en: 'Open a terminal and navigate to the /chapter2/ui directory of the book’s example
    code. From that directory, run the following:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个终端，导航到书中示例代码的/chapter2/ui目录。从该目录运行以下命令：
- en: '[PRE9]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This packages the UI in an uber jar, and then starts the uber jar that contains
    a web server with the UI code only. After the log shows that it’s deployed, you
    can go to a browser and open it to the following:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这个将UI打包成一个uber jar，然后启动包含仅UI代码的web服务器的uber jar。在日志显示已部署后，你可以打开浏览器并访问以下链接：
- en: '[PRE10]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Your browser will load the UI containing the Cayambe category data, as shown
    previously in [figure 2.5](#ch02fig05). Both the microservice and UI can be stopped
    by pressing Ctrl-C in each terminal window.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 你的浏览器将加载包含Cayambe类别数据的UI，如图2.5所示。可以通过在每个终端窗口中按Ctrl-C来停止微服务和UI。
- en: Summary
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: You can develop a category management microservice with JAX-RS.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用JAX-RS开发一个类别管理微服务。
- en: RESTful microservices can easily be created with Enterprise Java.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用企业Java可以轻松创建RESTful微服务。
- en: Developing RESTful endpoints doesn’t change between Enterprise Java and a microservice.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在企业Java和微服务之间开发RESTful端点没有区别。
- en: Enterprise Java experience is easily transferable to developing Enterprise Java
    microservices.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 企业Java经验可以轻松转移到开发企业Java微服务。
- en: Chapter 3\. Just enough Application Server for microservices
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3章。适用于微服务的Just enough Application Server
- en: '*This chapter covers*'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: What is Just enough Application Server?
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是Just enough Application Server？
- en: What is MicroProfile?
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是MicroProfile？
- en: What runtimes support JeAS?
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些运行时支持JeAS？
- en: How do JeAS runtimes compare?
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JeAS运行时如何比较？
- en: This chapter explores the ideas behind Just enough Application Server (JeAS)
    and the runtime options that we as developers have for developing Enterprise Java
    microservices using JeAS. We’ll begin by defining JeAS and how it compares to
    Java EE. To aid in the discussion, a hypothetical microservice, requiring several
    specifications, will be described so its needs may be evaluated against what the
    various JeAS runtimes offer. As part of the comparison, we’ll detail each of the
    JeAS runtimes and how they differ as we develop a Beach Vacation shopping application.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了Just enough Application Server（JeAS）背后的理念以及我们作为开发者使用JeAS开发企业Java微服务的运行时选项。我们将从定义JeAS以及它与Java
    EE的比较开始。为了帮助讨论，我们将描述一个假设的微服务，该微服务需要几个规范，以便评估各种JeAS运行时提供的功能。作为比较的一部分，我们将详细说明每个JeAS运行时以及它们在我们开发海滩度假购物应用时的差异。
- en: 3.1\. Just enough Application Server
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1\. Just enough Application Server
- en: The term *Just enough Application Server* has been used occasionally over the
    years, but usually in relation to customizing a full application server by removing
    functionality manually. Only since the popularity of microservices has JeAS become
    *crucial* for Enterprise Java. This section covers what JeAS means, its benefits,
    and what an example developed in each of the JeAS runtimes looks like.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: “Just enough Application Server”（JeAS）这个术语在过去的几年里偶尔被使用，但通常与通过手动删除功能来定制完整应用服务器相关。只有随着微服务的流行，JeAS才对企业Java变得*至关重要*。本节将涵盖JeAS的含义、其优势以及在每个JeAS运行时开发的示例。
- en: 3.1.1\. What does JeAS mean?
  id: totrans-334
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.1\. JeAS是什么意思？
- en: Say you need to develop a microservice that interacts with an enterprise information
    system (EIS), such as SAP, to retrieve Human Resources (HR) information on employees.
    For this microservice, you’ve chosen to use JAX-RS, CDI, and JMS. If you were
    to develop such a microservice for deployment onto a typical Java EE application
    server, it’d most likely be done against the full Java EE platform, as illustrated
    in [figure 3.1](#ch03fig01).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要开发一个与企业信息系统（EIS）交互的微服务，例如SAP，以检索员工的人力资源（HR）信息。对于这个微服务，你选择了使用JAX-RS、CDI和JMS。如果你要为部署到典型的Java
    EE应用服务器开发这样的微服务，它很可能会基于完整的Java EE平台，如图3.1所示。
- en: Figure 3.1\. Microservice specification usage of full Java EE platform
  id: totrans-336
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.1\. 全Java EE平台的微服务规范使用
- en: '![](Images/03fig01_alt.jpg)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/03fig01_alt.jpg)'
- en: As you can see, there are lots of specifications within the full platform that
    you’re not using, but they’re still there even though you don’t require them.
    The full platform has 33 JSRs included within it. That’s a lot of specifications
    that you may not always need.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在完整平台中有许多你未使用的规范，尽管你不需要它们，但它们仍然存在。完整平台包含33个JSR。这可能是你并不总是需要的许多规范。
- en: Maybe there’s a Java EE profile you can use to slim it down? You have only one
    option right now. Let’s try the Web Profile and see how that works; see [figure
    3.2](#ch03fig02).
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 也许有一个Java EE配置可以用来精简它？目前你只有一个选项。让我们尝试Web Profile看看效果如何；参见[图3.2](#ch03fig02)。
- en: Figure 3.2\. Microservice specification usage of Java EE Web Profile
  id: totrans-340
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.2\. Java EE Web Profile的微服务规范使用
- en: '![](Images/03fig02.jpg)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/03fig02.jpg)'
- en: That results in fewer unused specifications, but now you have the problem that
    JMS isn’t part of the Web Profile. You can still add an implementation of JMS
    to your microservice as part of the deployment, but it’s no longer automatically
    part of the stack and may require additional configuration that you didn’t need
    with the full platform.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做减少了未使用的规范，但现在你面临的问题是JMS不再是Web Profile的一部分。你仍然可以在部署微服务时添加JMS的实现，但它不再是堆栈的自动部分，可能需要额外的配置，而这在完整平台中是不需要的。
- en: What’s the answer? Can JeAS help? And what exactly is Just enough Application
    Server? In a nutshell, JeAS inverts the relationship between an application server
    and an application, ensuring that you package only the parts of an application
    server that your application requires. In the case of our preceding microservice
    example, you know that you need JMS, so you choose the full platform of an application
    server. But you know your application will never use large parts of that application
    server.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是什么？JeAS能帮忙吗？那么，Just enough Application Server（JeAS）究竟是什么呢？简单来说，JeAS颠倒了应用服务器和应用之间的关系，确保你只打包应用服务器中应用所需的部分。以我们之前的微服务示例为例，你知道你需要JMS，因此你选择了完整的应用服务器平台。但你清楚你的应用永远不会使用该应用服务器的大部分功能。
- en: '|  |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Java EE profiles**'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java EE配置**'
- en: Since Java EE 6, we’ve had one profile and the full platform available for developers
    to choose as their application server. Although you may not be familiar with these
    options, the following provides an overview of which specifications the full platform
    and Web Profile contain.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 自 Java EE 6 以来，我们为开发者提供了一种配置文件和全平台可供选择作为他们的应用程序服务器。尽管您可能不熟悉这些选项，以下提供了全平台和 Web
    配置文件包含哪些规范的概述。
- en: '| Feature | Web Profile | Full platform |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| 功能 | Web 配置文件 | 全平台 |'
- en: '| --- | --- | --- |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| EJB (Local) | ✓ | ✓ |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| EJB (Local) | ✓ | ✓ |'
- en: '| JTS/JTA | ✓ | ✓ |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| JTS/JTA | ✓ | ✓ |'
- en: '| Clustering | ✓ | ✓ |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| 集群 | ✓ | ✓ |'
- en: '| Servlet | ✓ | ✓ |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| Servlet | ✓ | ✓ |'
- en: '| JSF | ✓ | ✓ |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| JSF | ✓ | ✓ |'
- en: '| JPA | ✓ | ✓ |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| JPA | ✓ | ✓ |'
- en: '| JBDC | ✓ | ✓ |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| JBDC | ✓ | ✓ |'
- en: '| CDI | ✓ | ✓ |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| CDI | ✓ | ✓ |'
- en: '| Bean validation | ✓ | ✓ |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| Bean 验证 | ✓ | ✓ |'
- en: '| JAX-RS | ✓ | ✓ |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| JAX-RS | ✓ | ✓ |'
- en: '| JSON-P | ✓ | ✓ |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| JSON-P | ✓ | ✓ |'
- en: '| EJB (remote) |   | ✓ |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| EJB (远程) |   | ✓ |'
- en: '| JCA |   | ✓ |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| JCA |   | ✓ |'
- en: '| JAX-WS |   | ✓ |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '| JAX-WS |   | ✓ |'
- en: '| JAXB |   | ✓ |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '| JAXB |   | ✓ |'
- en: '| JMS |   | ✓ |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| JMS |   | ✓ |'
- en: '| JavaMail |   | ✓ |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| JavaMail |   | ✓ |'
- en: '| JAX-RPC |   | ✓ |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '| JAX-RPC |   | ✓ |'
- en: '| JAXR |   | ✓ |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| JAXR |   | ✓ |'
- en: '|  |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Many application servers provide the flexibility to slim down their distribution
    by removing components and their associated configuration. I’ve worked with many
    customers in the past who have taken this approach. But finding the correct combination
    that still ensures that the application server functions properly requires somewhat
    of a trial-and-error approach. In some cases, there may even be a component that
    you’d like to remove but can’t, usually because that component is a key part of
    the application server.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序服务器提供了通过删除组件及其相关配置来精简其分发的灵活性。我过去曾与许多客户合作，他们采取了这种方法。但找到正确的组合以确保应用程序服务器正常工作需要一定的试错方法。在某些情况下，甚至可能有一个您想删除但无法删除的组件，通常因为这个组件是应用程序服务器的一个关键部分。
- en: Customizing an application server for many different applications quickly devolves
    into a complex set of differing configurations that need to be managed and maintained.
    In these situations, developers typically prefer to simplify their lives and choose
    the full platform as opposed to spending time trying to slim the application server.
    They opt to accept the extra overhead that comes with not using all components
    of the application server.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 为许多不同的应用程序快速定制应用程序服务器很快就会变成一组复杂的、不同的配置，这些配置需要被管理和维护。在这些情况下，开发者通常更喜欢简化他们的生活，选择全平台，而不是花时间尝试精简应用程序服务器。他们选择接受不使用应用程序服务器所有组件带来的额外开销。
- en: Over the years, several application servers, such as WildFly, have worked to
    reduce the footprint of components that aren’t being used. Though the dependencies
    required for various components are still on the classpath, the application server
    is clever enough to not load those classes into memory if the deployed applications
    don’t require them. This can go only so far, unfortunately, because many components
    are too central to the functioning of the application server, no matter what an
    application might require.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 几年来，几个应用程序服务器，如 WildFly，一直在努力减少未使用组件的占用空间。尽管各种组件所需的依赖项仍然在类路径上，但应用程序服务器足够聪明，如果部署的应用程序不需要这些类，就不会将它们加载到内存中。不幸的是，这只能做到如此，因为许多组件对于应用程序服务器的功能来说过于核心，无论应用程序可能需要什么。
- en: So where does JeAS fit in with your microservices architecture from [figure
    1.4](kindle_split_010.xhtml#ch01fig04)? Take a look at [figure 3.3](#ch03fig03).
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 那么 JeAS 在您的微服务架构中与 [图 1.4](kindle_split_010.xhtml#ch01fig04) 的关系如何？请看 [图 3.3](#ch03fig03)。
- en: Figure 3.3\. JeAS as runtime for microservices architecture
  id: totrans-373
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.3\. JeAS 作为微服务架构的运行时
- en: '![](Images/03fig03_alt.jpg)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/03fig03_alt.jpg)'
- en: As you can see, the focus of JeAS is on the runtime needed for a microservice.
    A JeAS runtime aims to provide a whittled-down application server for microservices,
    but the way it’s packaged can differ among implementations.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，JeAS 的重点是微服务所需的运行时。JeAS 运行时旨在为微服务提供一个精简的应用程序服务器，但它的打包方式可能因实现而异。
- en: JeAS runtimes provide a simple and manageable way to include only the parts
    of an application server that your application requires. Some runtimes are more
    flexible than others in terms of what’s included, and we’ll cover those details
    shortly.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: JeAS 运行时提供了一种简单且易于管理的方法，仅包含应用程序服务器中您应用程序所需的部分。一些运行时在包含内容方面比其他运行时更灵活，我们将在稍后介绍这些细节。
- en: Which JeAS runtime is chosen can impact the packaging available to a microservice.
    The driving factor, however, should always be about what’s supported by a JeAS
    runtime and not how it needs to be packaged.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 选择的 JeAS 运行时可能会影响微服务可用的打包方式。然而，驱动因素始终应该是 JeAS 运行时支持的内容，而不是它需要如何打包。
- en: 3.1.2\. What are the benefits?
  id: totrans-378
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.2. 优点是什么？
- en: In your SAP microservice from the previous section, you saw how painful it can
    be when your application relies on the smaller-footprint Web Profile. It requires
    you to bring in additional libraries and configure them to work with the rest
    of the application server.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，您看到了当您的应用程序依赖于较小的 Web 配置文件时，可能会多么痛苦。它需要您引入额外的库并将它们配置为与整个应用服务器一起工作。
- en: As developers, we want to spend our time effectively, developing new features
    or fixing bugs. We don’t want to spend it endlessly configuring application servers
    based on differing requirements between applications. More often than not, we’d
    choose the full platform for the sake of simplicity.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，我们希望有效地利用我们的时间，开发新功能或修复错误。我们不想无休止地根据应用程序之间的不同需求配置应用服务器。更常见的是，我们会为了简单起见选择完整平台。
- en: What’s the big deal with using the full platform? Sure, there are lots of parts
    you may not use today, but you plan to one day, right? Certainly, in some cases
    an application will grow to include the use of one, or maybe two, additional specifications
    that weren’t part of the original design. It’s highly doubtful that an application
    would suddenly grow to include all specifications of the full platform. If it
    does, there’s likely a need to redesign the application, because it contains too
    many features for a single application. So that leaves a large part of a full
    platform application server unused.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 使用完整平台有什么大不了的？当然，今天您可能不会使用很多部分，但您计划有一天会使用，对吧？当然，在某些情况下，应用程序可能会增长到包括使用一个或两个原始设计之外的额外规范。一个应用程序突然增长到包括完整平台的所有规范的可能性非常小。如果确实如此，可能需要重新设计应用程序，因为它包含的功能太多，不适合单个应用程序。因此，完整平台应用程序服务器的大部分功能都将被闲置。
- en: Wouldn’t it be nice if application servers weren’t *one size fits all*? This
    is one of the use cases that JeAS aims to solve, by allowing the developer to
    choose which features, or specifications, of an application server are required
    for a given application.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用服务器不是“一刀切”的，那岂不是很好？这是 JeAS 旨在解决的问题之一，通过允许开发者选择给定应用程序所需的应用服务器功能或规范。
- en: Why does that matter? If an application needs only servlets, it can be deployed
    to a JeAS runtime that has only servlets available for an application. With a
    JeAS runtime, if an application needs to add a feature, such as JAX-RS, a developer
    can choose to add that feature into the JeAS runtime as a standalone piece. It’s
    no longer necessary to choose between only two Java EE options, or attempt to
    customize the application server yourself.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 这有什么关系？如果一个应用程序只需要 servlets，它可以部署到仅提供 servlets 的 JeAS 运行时。使用 JeAS 运行时，如果应用程序需要添加一个功能，例如
    JAX-RS，开发者可以选择将此功能作为独立部分添加到 JeAS 运行时。不再需要仅在两个 Java EE 选项之间选择，或者尝试自己定制应用服务器。
- en: 'This flexibility means that JeAS runtimes have great benefits:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 这种灵活性意味着 JeAS 运行时具有很大的好处：
- en: '***Reduced package size*—** When compared against an application bundled with
    the application server it’s deployed to.'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减小打包大小**—**与部署到应用服务器的应用程序捆绑包相比。'
- en: '***Reduction in allocated memory*—** How reduced will depend on many factors,
    such as the number of classes that are no longer being loaded.'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少分配的内存**—**减少的程度将取决于许多因素，例如不再加载的类数量。'
- en: '***Reduced security footprint*—** Fewer ports are being opened for various
    features, and fewer services are running. In addition, you have a significantly
    reduced surface area for potential critical vulnerabilities (CVEs).'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少安全足迹**—**为各种功能打开的端口更少，运行的服务也更少。此外，潜在的关键漏洞（CVE）的暴露面积显著减少。'
- en: '***Greater separation between applications*—** Many applications were usually
    deployed to a single application server.'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序之间的分离度更高**—**许多应用程序通常部署到单个应用服务器。'
- en: '***Simplified upgrades*—** The upgrade impacts a single application only.'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简化升级**—**升级仅影响单个应用程序。'
- en: Greater separation between applications can mean a great many things, so it
    warrants additional explanation. Over the years that Enterprise Java applications
    have been deployed into production, an application server rarely would contain
    a single application. Typically, an application server would be running anywhere
    from a handful to dozens of applications in a single instance.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 应用之间的更大分离可以意味着很多事情，因此需要额外的解释。多年来，企业Java应用在生产环境中部署，应用服务器很少只包含一个应用。通常，一个应用服务器会在单个实例中运行从几个到几十个应用。
- en: As you can see in [figure 3.4](#ch03fig04), JeAS runtimes provide a greater
    isolation between different microservices than applications in a traditional Java
    EE application server.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图3.4](#ch03fig04)所示，JeAS运行时在提供不同微服务之间的隔离方面比传统Java EE应用服务器中的应用提供了更大的隔离。
- en: Figure 3.4\. Traditional Java EE vs. JeAS runtimes
  id: totrans-392
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.4\. 传统Java EE与JeAS运行时对比
- en: '![](Images/03fig04_alt.jpg)'
  id: totrans-393
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/03fig04_alt.jpg)'
- en: Why was this the case? Historically, the biggest reason is cost—and not just
    the cost of the application server, which usually wasn’t cheap, but all the physical
    hardware that was required to run a single application server. Certainly, over
    the last decade, with improved virtual machines and the rise of containers in
    recent years, the amount of required physical hardware for production environments
    has dropped significantly—and along with it, the cost of production environments
    for enterprises.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么会是这种情况呢？从历史上看，最大的原因是成本——不仅仅是应用服务器的成本，通常并不便宜，还包括运行单个应用服务器所需的全部物理硬件。当然，在过去十年中，随着虚拟机的改进和近年来容器技术的兴起，生产环境所需的物理硬件数量显著下降——随之而来的是，企业生产环境的成本也相应降低。
- en: 'With JeAS runtimes, it’s possible, ignoring containers for now, to run many
    instances of them on a single piece of physical hardware. Each JeAS runtime running
    in its own process is isolated from the others, preventing a common problem of
    collocated applications in an application server: namely, that one application
    failure causes the whole application server, and all applications running on it,
    to fail in an unrecoverable manner.'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在JeAS运行时中，现在可以（暂时忽略容器），在单个物理硬件上运行它们的多个实例。每个在其自身进程中运行的JeAS运行时与其他运行时隔离，防止了应用服务器中常见的一个问题：即一个应用的失败会导致整个应用服务器以及其上运行的所有应用以不可恢复的方式失败。
- en: 3.1.3\. Eclipse MicroProfile
  id: totrans-396
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.3\. Eclipse MicroProfile
- en: For anyone following developments in the landscape of Enterprise Java and microservices
    over the last couple of years, you’ve likely heard about Eclipse MicroProfile.
    It’s a community initiative to “optimize Enterprise Java for microservices” that
    was formed with collaboration from Red Hat, IBM, Tomitribe, Payara, and the London
    Java Community. Since its initial formation, the community has moved to the Eclipse
    Foundation.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在过去几年中关注企业Java和微服务领域发展的人来说，你很可能已经听说过Eclipse MicroProfile。这是一个由Red Hat、IBM、Tomitribe、Payara和伦敦Java社区合作发起的社区倡议，旨在“优化企业Java以适应微服务”。自其最初形成以来，该社区已迁移至Eclipse基金会。
- en: From the first release with JAX-RS, CDI, and JSON-P forming the base Java EE
    technologies, we’ve now surpassed version 1.3, including eight new MicroProfile
    specifications over those versions so far. [Table 3.1](#ch03table01) details the
    specifications included in each MicroProfile release.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 从最初的JAX-RS、CDI和JSON-P构成基础Java EE技术的第一个版本开始，我们现在已经超过了1.3版本，包括到目前为止的八个新的MicroProfile规范。[表3.1](#ch03table01)详细说明了每个MicroProfile版本中包含的规范。
- en: Table 3.1\. MicroProfile specifications in each release
  id: totrans-399
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表3.1\. 每个版本中的MicroProfile规范
- en: '| Specification | 1.0 (Sep 2016) | 1.1 (July 2017) | 1.2 (Sep 2017) | 1.3 (Jan
    2018) |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
  zh: '| 规范 | 1.0 (2016年9月) | 1.1 (2017年7月) | 1.2 (2017年9月) | 1.3 (2018年1月) |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| JAX-RS | ✓ | ✓ | ✓ | ✓ |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
  zh: '| JAX-RS | ✓ | ✓ | ✓ | ✓ |'
- en: '| CDI | ✓ | ✓ | ✓ | ✓ |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
  zh: '| CDI | ✓ | ✓ | ✓ | ✓ |'
- en: '| JSON-P | ✓ | ✓ | ✓ | ✓ |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
  zh: '| JSON-P | ✓ | ✓ | ✓ | ✓ |'
- en: '| Config |   | ✓ | ✓ | ✓ |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
  zh: '| 配置 |   | ✓ | ✓ | ✓ |'
- en: '| Fault tolerance |   |   | ✓ | ✓ |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
  zh: '| 容错 |   |   | ✓ | ✓ |'
- en: '| JWT propagation |   |   | ✓ | ✓ |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
  zh: '| JWT传播 |   |   | ✓ | ✓ |'
- en: '| Metrics |   |   | ✓ | ✓ |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
  zh: '| 指标 |   |   | ✓ | ✓ |'
- en: '| Health check |   |   | ✓ | ✓ |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
  zh: '| 健康检查 |   |   | ✓ | ✓ |'
- en: '| Open tracing |   |   |   | ✓ |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
  zh: '| 开放追踪 |   |   |   | ✓ |'
- en: '| Open API |   |   |   | ✓ |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
  zh: '| 开放API |   |   |   | ✓ |'
- en: '| Type-safe REST client |   |   |   | ✓ |'
  id: totrans-412
  prefs: []
  type: TYPE_TB
  zh: '| 类型安全的REST客户端 |   |   |   | ✓ |'
- en: The community has an aim of providing a new release roughly every quarter. The
    project has done well to hold closely to that schedule, though a delay occurred
    after the 1.0 release for the project submission to the Eclipse Foundation. Time
    was needed for all existing project code and documentation to be reviewed by the
    Eclipse Foundation, as is required by the foundation.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 社区有一个目标，大约每季度发布一个新版本。项目很好地坚持了这个时间表，尽管在 1.0 版本发布后，项目提交给 Eclipse 基金会时出现了延误。需要时间让
    Eclipse 基金会对所有现有项目代码和文档进行审查，这是基金会要求的。
- en: Eclipse MicroProfile creates specifications for Enterprise Java microservices,
    with the benefit that microservices become portable between JeAS runtimes that
    support Eclipse MicroProfile. There will certainly be JeAS runtimes that don’t
    implement the specifications, and those that provide more flexibility than is
    defined. The goal isn’t to cover every possible use case for Enterprise Java microservice
    development, but to collaborate on what an opinionated stack should contain that
    covers the majority of use cases.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse MicroProfile 为企业 Java 微服务创建规范，其好处是微服务可以在支持 Eclipse MicroProfile 的 JeAS
    运行时之间移植。当然，会有一些 JeAS 运行时不实现这些规范，还有一些提供了比定义的更多灵活性的运行时。目标不是涵盖企业 Java 微服务开发的每一个可能用例，而是合作确定一个有偏见的堆栈应该包含哪些内容，以覆盖大多数用例。
- en: Over the last 18 months, the MicroProfile community has delivered functionality
    for solving the problems of Enterprise Java, microservices, and the cloud. It
    has done so in a collaborative and inclusive manner, with more individual contributors
    and vendors joining the effort as it moves forward.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的 18 个月里，MicroProfile 社区为解决企业 Java、微服务和云的问题提供了功能。它以协作和包容的方式做到了这一点，随着项目的推进，越来越多的个人贡献者和供应商加入了这一努力。
- en: 3.2\. Choosing Just enough Application Server
  id: totrans-416
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2\. 选择足够的应用服务器
- en: Now it’s time to evaluate a handful of the most popular runtimes for Enterprise
    Java microservices. You’ll follow the development of a simple microservice example
    application to show the differences among the frameworks, both in the way the
    code differs and in the sets of features that each framework brings to the table.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候评估一些最受欢迎的企业 Java 微服务运行时了。您将跟随一个简单的微服务示例应用程序的开发，以展示不同框架之间的差异，包括代码的不同以及每个框架带来的功能集。
- en: The full code of the example application for each runtime is available in the
    source code for this book ([https://github.com/kenfinnigan/ejm-samples](https://github.com/kenfinnigan/ejm-samples)).
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 每个运行时的示例应用程序的完整代码都可在本书的源代码中找到（[https://github.com/kenfinnigan/ejm-samples](https://github.com/kenfinnigan/ejm-samples)）。
- en: 3.2.1\. Beach Vacation example application
  id: totrans-419
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.1\. 沙滩度假示例应用程序
- en: Our Beach Vacation example application will be a simple shopping cart that has
    a RESTful interface and a single class representing an item in the cart. You’ll
    pre-populate the contents of the shopping cart with items that everyone needs
    on a beach vacation! To keep it simple, you’ll store only a name and quantity
    in your `CartItem`.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的沙滩度假示例应用程序将是一个简单的购物车，它具有 RESTful 接口，并且有一个类代表购物车中的项目。您将预先填充购物车的内容，包括每个人在沙滩度假时都需要的项目！为了保持简单，您只需在您的
    `CartItem` 中存储名称和数量。
- en: Listing 3.1\. `CartItem`
  id: totrans-421
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.1\. `CartItem`
- en: '[PRE11]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '***1*** Name of the item.'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 项目的名称。'
- en: '***2*** Quantity to be bought.'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 需要购买的数量。'
- en: '***3*** Construct an instance of CartItem with the provided name and quantity.'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 使用提供的名称和数量构建 `CartItem` 的实例。'
- en: '***4*** Convenience method for increasing the quantity by a specified amount'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** 通过指定数量增加数量的便捷方法'
- en: 'The other piece you need is your RESTful interface. In keeping it simple, you
    won’t be using a database to store items; the data will be held in memory only.
    Your `CartController` will initialize a list of items for you to use as a base
    for the shopping cart. [Listing 3.2](#ch03ex02) is your controller code at its
    simplest so you can see exactly what each framework requires within the class
    and methods later. It provides three methods that you’ll make available over REST:
    `all()`, `addOrUpdateItem()`, and `getItem()`. The `addOrUpdateItem()` method
    is the most complicated, because it handles adding quantity to an existing item
    in the cart or adding an entirely new item.'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要的是你的RESTful接口。为了保持简单，你不会使用数据库来存储项目；数据将仅在内存中保留。你的`CartController`将为你初始化一个项目列表，作为购物车的基础。[列表3.2](#ch03ex02)是你控制器代码的最简单形式，这样你可以清楚地看到每个框架在类和方法中需要什么。它提供了三个你将通过REST提供的功能：`all()`、`addOrUpdateItem()`和`getItem()`。`addOrUpdateItem()`方法是最复杂的，因为它处理向购物车中现有项目添加数量或添加全新的项目。
- en: Listing 3.2\. `CartController`
  id: totrans-428
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.2\. `CartController`
- en: '[PRE12]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***1*** Populates the cart with commonly required items for a beach vacation'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 为海滩度假填充购物车中常用的项目'
- en: '***2*** Returns all the current items in the cart'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 返回购物车中的所有当前项目'
- en: '***3*** Streams all the cart items to find one whose name matches'
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 将所有购物车项目流式传输以找到名称匹配的项目'
- en: '***4*** Checks whether you found an item by name. If yes, then update the quantity.'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** 检查是否通过名称找到了一个项目。如果是，则更新数量。'
- en: '***5*** Item wasn’t found in cart, so add it.'
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** 项目未在购物车中找到，因此添加它。'
- en: '***6*** Filters all cart items to find the one whose name matches'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** 过滤所有购物车项目以找到名称匹配的项目'
- en: Now you’ve covered the two main classes you’ll need for your Beach Vacation
    shopping application. In the following sections, you’ll update these two classes
    for each JeAS runtime based on their particular requirements.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经涵盖了你在海滩度假购物应用程序中需要的两个主要类。在接下来的章节中，你将根据它们的特定要求更新这两个类以适应每个JeAS运行时。
- en: '|  |'
  id: totrans-437
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-438
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The following examples don’t always follow the proper use of REST HTTP verbs
    and semantics. The examples illustrate a comparison of the runtimes, rather than
    proper REST patterns.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例并不总是遵循REST HTTP动词和语义的正确使用。这些示例展示了运行时的比较，而不是正确的REST模式。
- en: '|  |'
  id: totrans-440
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 3.2.2\. Dropwizard—the original opinionated Microservice runtime
  id: totrans-441
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.2\. Dropwizard——原始的具有明确观点的微服务运行时
- en: 'Dropwizard provides a small JeAS runtime by being opinionated about what developers
    need in order to build a microservice. For Dropwizard, that means the following:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: Dropwizard通过提供开发者构建微服务所需的小型JeAS运行时，具有明确的观点。对于Dropwizard来说，这意味着以下内容：
- en: Eclipse Jetty as an HTTP server
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Eclipse Jetty作为HTTP服务器
- en: Jersey for RESTful endpoints
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jersey用于RESTful端点
- en: Jackson for transforming data to/from JSON
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jackson用于将数据转换为JSON或从JSON转换
- en: Hibernate Validator
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hibernate Validator
- en: Dropwizard Metrics to provide insight into code behavior in production
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dropwizard Metrics用于在生产中提供对代码行为的洞察
- en: Dropwizard provides additional libraries to make it easier to develop a microservice,
    in addition to the preceding ones. Check out [www.dropwizard.io](http://www.dropwizard.io)
    for the full list.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面提到的库之外，Dropwizard还提供了额外的库，以简化微服务的开发。查看[www.dropwizard.io](http://www.dropwizard.io)获取完整的列表。
- en: If your application requires libraries that Dropwizard doesn’t include for you,
    you need to add the necessary Maven dependencies to your project, adding whatever
    configuration those libraries might require as well.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序需要Dropwizard为你提供的库，你需要将必要的Maven依赖项添加到你的项目中，并添加那些库可能需要的任何配置。
- en: '|  |'
  id: totrans-450
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-451
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Dropwizard began in early 2011 and was the first project to put together an
    opinionated JeAS runtime for microservices. Dropwizard has now surpassed version
    1.3.0.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: Dropwizard始于2011年初，是第一个为微服务组合具有明确观点的JeAS运行时的项目。现在，Dropwizard已经超过了1.3.0版本。
- en: '|  |'
  id: totrans-453
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Let’s go back to the sample microservice we talked about earlier that uses JAX-RS,
    CDI, and JMS. [Figure 3.5](#ch03fig05) shows what the microservice looks like
    with Dropwizard.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到之前提到的使用JAX-RS、CDI和JMS的示例微服务。![图3.5](#ch03fig05)显示了使用Dropwizard的微服务的外观。
- en: Figure 3.5\. Microservice usage in Dropwizard
  id: totrans-455
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.5\. Dropwizard中的微服务使用
- en: '![](Images/03fig05.jpg)'
  id: totrans-456
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/03fig05.jpg)'
- en: When developing microservices that use more than just JAX-RS from Java EE, it’s
    obvious that everything else you need must be added and integrated. Though this
    is possible, it may not be the most practical option because it requires a lot
    more initial project setup before being able to develop any code.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发使用 Java EE 中的 JAX-RS 之外的其他技术的微服务时，很明显，你需要添加和集成的其他所有内容。虽然这是可能的，但这可能不是最实用的选项，因为它需要在能够开发任何代码之前进行大量的初始项目设置。
- en: It’s for this reason that Thorntail, not Dropwizard, is my preferred runtime
    for Enterprise Java microservices. Dropwizard covers only a small portion of what
    would be required. This is especially true when converting existing Enterprise
    Java applications into microservices, because you don’t want to have to rewrite
    all the code to use different technologies. Ideally, you want to take an existing
    application and package it in a different manner for use with a JeAS runtime.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 正是因为这个原因，Thorntail 而不是 Dropwizard，是我首选的企业 Java 微服务运行时。Dropwizard 只覆盖了所需功能的一小部分。这尤其适用于将现有的企业
    Java 应用程序转换为微服务，因为你不希望需要重写所有代码以使用不同的技术。理想情况下，你希望将现有应用程序以不同的方式打包，以便与 JeAS 运行时一起使用。
- en: 'Back to our Beach Vacation shopping cart, let’s create your Dropwizard project
    by generating a project with the Maven archetype:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的海滩度假购物车，让我们通过使用 Maven 架构生成项目来创建你的 Dropwizard 项目：
- en: '[PRE13]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now that you have your project, let’s modify the basic code so it can be used
    with Dropwizard. The first change is easy: adding a default constructor to your
    `CartItem` bean.'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了你的项目，让我们修改基本的代码，使其可以与 Dropwizard 一起使用。第一个更改很简单：为你的 `CartItem` 实体添加默认构造函数。
- en: Your `CartController` needs modification to make it RESTful. First you need
    to define the RESTful path that your controller will be accessible from.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 `CartController` 需要修改以使其成为 RESTful。首先，你需要定义控制器可从其访问的 RESTful 路径。
- en: Listing 3.3\. `CartController` RESTful path
  id: totrans-463
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.3\. `CartController` RESTful 路径
- en: '[PRE14]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now you need to add the JAX-RS annotations to your methods.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你需要将 JAX-RS 注解添加到你的方法中。
- en: Listing 3.4\. `CartController` methods with annotations
  id: totrans-466
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.4\. 带有注解的 `CartController` 方法
- en: '[PRE15]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '***1*** Indicates that the method supports only HTTP GET requests'
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 表示该方法仅支持 HTTP GET 请求'
- en: '***2*** Endpoint is accessible as /add.'
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 端点可通过 /add 访问。'
- en: '***3*** Method parameters that will be passed on the URL, such as /add?item=hat&qty=2'
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 将通过 URL 传递的参数，例如 /add?item=hat&qty=2'
- en: '***4*** Parameter defined as part of the URL path, /get/hat.'
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** 定义为 URL 路径一部分的参数，/get/hat。'
- en: The JAX-RS annotations you’ve added have no surprises, because they’re regularly
    used for RESTful endpoints. Your three methods are all annotated with `@GET`.
    The `all()` and `getItem()` methods both produce JSON output, so you’ve added
    `@Produces` to indicate the correct media type for JSON. The `addOrUpdateItem()`
    method is accessible with a URL path of /add, and you add the necessary `@QueryParam`
    definitions to your method parameters. It maps URL query string parameters into
    your method parameters on invocation based on the name you pass to `@QueryParam`.
    Finally, `getItem()` specifies a URL path that defines the path parameter `@Path("/get/{itemName}")`,
    which is then passed to your method by setting `@PathParam("itemName")` on the
    parameter.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 你添加的 JAX-RS 注解没有惊喜，因为它们通常用于 RESTful 端点。你的三个方法都被标注为 `@GET`。`all()` 和 `getItem()`
    方法都生成 JSON 输出，所以你添加了 `@Produces` 来指示正确的媒体类型为 JSON。`addOrUpdateItem()` 方法可以通过 URL
    路径 /add 访问，并且你在方法参数中添加了必要的 `@QueryParam` 定义。它在调用时根据你传递给 `@QueryParam` 的名称将 URL
    查询字符串参数映射到你的方法参数。最后，`getItem()` 指定了一个 URL 路径，它定义了路径参数 `@Path("/get/{itemName}")`，然后通过在参数上设置
    `@PathParam("itemName")` 将其传递给你的方法。
- en: '|  |'
  id: totrans-473
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-474
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: '`CartController.addOrUpdateItem()` is defined with `@GET`, which does break
    normal RESTful semantics; it isn’t an idempotent operation, because you’re modifying
    data. But I’ve taken this route purely for simplicity, because your object model
    has only two fields and it enables you to call the endpoint directly from a browser
    URL, removing the need to use `curl` or browser extensions to `POST` data for
    testing.'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '`CartController.addOrUpdateItem()` 使用 `@GET` 定义，这打破了正常的 RESTful 语义；它不是一个幂等操作，因为你正在修改数据。但我纯粹为了简单起见选择了这条路线，因为你的对象模型只有两个字段，这使你能够直接从浏览器
    URL 调用端点，从而无需使用 `curl` 或浏览器扩展来 `POST` 测试数据。'
- en: '|  |'
  id: totrans-476
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Now you need to add custom classes so that Dropwizard knows what to run and
    how it’s configured. First, you need to create a configuration class that specifies
    any environment-specific parameters that your application requires. In this example,
    you’re not worried about environment parameters, so the class can be empty.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您需要添加自定义类，以便 Dropwizard 知道要运行什么以及如何配置。首先，您需要创建一个配置类，该类指定了应用程序所需的任何特定环境参数。在这个例子中，您不担心环境参数，因此该类可以是空的。
- en: Listing 3.5\. `Chapter3Configuration`
  id: totrans-478
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.5\. `Chapter3Configuration`
- en: '[PRE16]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Finally, you need to extend `Application` from Dropwizard so you can specify
    what needs to be run.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您需要从 Dropwizard 扩展 `Application`，以便您可以指定需要运行的内容。
- en: Listing 3.6\. `Chapter3Application`
  id: totrans-481
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.6\. `Chapter3Application`
- en: '[PRE17]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '***1*** Used by Dropwizard to start your application.'
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 由 Dropwizard 用于启动您的应用程序。'
- en: '***2*** Configure any parts of the application that need to be set up before
    it’s run.'
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 配置在运行之前需要设置的任何应用程序部分。'
- en: '***3*** Register an instance of your RESTful endpoint with Jersey.'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 使用 Jersey 注册您的 RESTful 端点实例。'
- en: 'Now that you’ve built the application, how can you run it? By creating the
    project with the Maven archetype, it has added the necessary plugins to build
    an uber jar. The only thing you need to do is ensure that the plugins in pom.xml
    reference the application class you created on any configuration that needs `mainClass`.
    Now build the application:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经构建了应用程序，如何运行它？通过使用 Maven 架构创建项目，它已经添加了构建 uber jar 所需的插件。您需要做的只是确保 pom.xml
    中的插件引用了您在需要 `mainClass` 的任何配置中创建的应用程序类。现在构建应用程序：
- en: '[PRE18]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'and run the application:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 并运行应用程序：
- en: '[PRE19]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: It’s now possible to access the application by going to http://localhost:8080/
    in a browser. This returns the list of current items in the cart. You can look
    at the details of `hat` in your cart by navigating to http://localhost:8080/get/hat.
    Update the quantity of an existing item with http://localhost:8080/add?item=towel&qty=1
    or add a new item to your cart with http://localhost:8080/add?item=kite&qty=2.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以通过在浏览器中访问 http://localhost:8080/ 来访问应用程序。这将返回购物车中当前项目的列表。您可以通过导航到 http://localhost:8080/get/hat
    查看购物车中 `hat` 的详细信息。使用 http://localhost:8080/add?item=towel&qty=1 更新现有项目的数量，或者使用
    http://localhost:8080/add?item=kite&qty=2 向您的购物车添加新项目。
- en: Dropwizard has many other features that we didn’t cover here, such as Metrics
    and Health Checks, so check out [www.dropwizard.io/1.0.0/docs/index.html](http://www.dropwizard.io/1.0.0/docs/index.html)
    for further information.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: Dropwizard 还有许多我们没有在这里介绍的其他功能，例如度量标准和健康检查，因此请查看 [www.dropwizard.io/1.0.0/docs/index.html](http://www.dropwizard.io/1.0.0/docs/index.html)
    以获取更多信息。
- en: 3.2.3\. Payara Micro—slimmed Java EE app server in a JAR
  id: totrans-492
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.3\. Payara Micro—一个瘦化的 JAR 格式的 Java EE 应用服务器
- en: Payara Micro is similar to Dropwizard in that it provides an opinionated JeAS
    runtime where the stack is defined. Any additional libraries that you want to
    be used need to be added to the application directly.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: Payara Micro 与 Dropwizard 类似，它提供了一个有观点的 JeAS 运行时，其中堆栈是定义好的。您想要使用的任何附加库都需要直接添加到应用程序中。
- en: Payara Micro also has a different deployment model than the other runtimes you’ll
    look at, as Payara provides a distribution that can be executed directly. Payara’s
    distribution is like a prebuilt application server, except that it can be started
    with `java -jar payara-micro.jar` and given a WAR to deploy with `--deploy myApp.war`
    as part of the same command. Without `--deploy`, the distribution starts up just
    as a normal application server, but with nothing deployed.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: Payara Micro 与您将要查看的其他运行时相比，具有不同的部署模型，因为 Payara 提供了一个可以直接执行的发行版。Payara 的发行版就像一个预构建的应用程序服务器，但它可以通过
    `java -jar payara-micro.jar` 启动，并通过 `--deploy myApp.war` 作为同一命令的一部分部署一个 WAR 文件。如果没有
    `--deploy`，则发行版将像普通应用程序服务器一样启动，但没有部署任何内容。
- en: '|  |'
  id: totrans-495
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-496
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Payara Micro came out of the work that Payara was doing in providing fixes and
    enhancements to GlassFish v4.x via its Payara Server. Payara Micro was first released
    in May 2015 as a subset of Payara Server. Payara Micro has now surpassed version
    5.181.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: Payara Micro 是由 Payara 在提供对 GlassFish v4.x 的修复和增强功能时开发的，它最初作为 Payara Server
    的一个子集于 2015 年 5 月首次发布。现在，Payara Micro 已经超过了 5.181 版本。
- en: '|  |'
  id: totrans-498
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: There are certainly advantages to having a distribution that you deploy your
    application to, as in a traditional application server. The biggest advantage
    is that the Payara Micro distribution can be used as a Docker layer. This makes
    it possible to create a Docker image containing that layer, which can then be
    used many times to package different applications with Docker.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统应用程序服务器中部署应用程序时，拥有一个可部署的应用程序分发版本确实有优势。最大的优势是 Payara Micro 分发可以用作 Docker 层。这使得创建包含该层的
    Docker 镜像成为可能，然后可以使用该镜像多次打包不同的应用程序。
- en: The major downside to this type of JeAS runtime is that it isn’t possible to
    remove additional pieces. For instance, if your application requires only servlets,
    there’s no way to remove parts such as JAX-RS. The advantages of this approach
    might outweigh such a downside, but that’s a decision for an enterprise to make
    based on its situation. We’ll cover a more flexible approach to JeAS a bit later.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型 JeAS 运行时的主要缺点是，无法移除额外的组件。例如，如果您的应用程序只需要 servlets，则无法移除 JAX-RS 等部分。这种方法的优点可能超过这种缺点，但这是一个企业根据其情况做出的决定。我们稍后会介绍一种更灵活的
    JeAS 方法。
- en: What does Payara Micro provide? [Figure 3.6](#ch03fig06) compares the Payara
    Micro distribution with the Web Profile.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: Payara Micro 提供了什么？[图 3.6](#ch03fig06) 将 Payara Micro 分发与 Web Profile 进行了比较。
- en: Figure 3.6\. Payara Micro compared to Web Profile
  id: totrans-502
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.6\. 与 Web Profile 相比的 Payara Micro
- en: '![](Images/03fig06.jpg)'
  id: totrans-503
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/03fig06.jpg)'
- en: Let’s take a look at how your JAX-RS, CDI, JMS microservice uses Payara Micro;
    see [figure 3.7](#ch03fig07).
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看您的 JAX-RS、CDI、JMS 微服务如何使用 Payara Micro；请参阅 [图 3.7](#ch03fig07)。
- en: Figure 3.7\. Microservice usage in Payara Micro
  id: totrans-505
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.7\. Payara Micro 中的微服务使用情况
- en: '![](Images/03fig07.jpg)'
  id: totrans-506
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/03fig07.jpg)'
- en: Because Payara Micro doesn’t include the JMS specification, you need to add
    an implementation to your microservice yourself. This isn’t a major issue, but
    needing to include additional implementations is easier if they’re already provided
    in a distribution. But then you’re back to the problem of application server pieces
    being present but not used.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Payara Micro 不包含 JMS 规范，您需要自己向微服务中添加一个实现。这不是一个大问题，但如果它们已经包含在分发中，则需要包含额外实现会更容易。但这样您又回到了应用程序服务器组件存在但未使用的问题。
- en: To create your Payara Micro project, you create a regular Maven WAR project
    as if you were developing a Java EE application that was being deployed to an
    application server. You can add a Maven dependency
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建您的 Payara Micro 项目，您创建一个常规 Maven WAR 项目，就像您正在开发一个将被部署到应用程序服务器的 Java EE 应用程序一样。您可以添加一个
    Maven 依赖项
- en: '[PRE20]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: and gain access to all the APIs that your application may require.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 并获取到应用程序可能需要的所有 API。
- en: 'Because you also want to use JAXB, with Jackson, you need to add the following
    dependency:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 因为您还希望使用 JAXB，与 Jackson 一起，您需要添加以下依赖项：
- en: '[PRE21]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now that you have your project, let’s modify the basic code so it can be used
    with Payara Micro. For the `CartItem` bean, you need to identify it as being mappable
    to JAXB, create a default constructor, and use properly named setter methods.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经有了项目，让我们修改基本代码，使其可以与 Payara Micro 一起使用。对于 `CartItem` 实体，您需要将其标识为可映射到 JAXB，创建一个默认构造函数，并使用正确命名的设置方法。
- en: Listing 3.7\. `CartItem` with JAXB mappings
  id: totrans-514
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.7\. 带有 JAXB 映射的 `CartItem`
- en: '[PRE22]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '***1*** Enables Java class as JAXB mapping element'
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 允许将 Java 类作为 JAXB 映射元素'
- en: '***2*** Method changed from itemQuantity() to setItemQuantity()'
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 方法从 itemQuantity() 更改为 setItemQuantity()'
- en: '|  |'
  id: totrans-518
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-519
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Payara Micro requires that a bean use proper setter methods, as you have in
    [listing 3.7](#ch03ex07). A bean that contains Builder pattern–type named setter
    methods won’t correctly marshal to JSON.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: Payara Micro 要求一个实体使用正确的设置方法，就像您在 [列表 3.7](#ch03ex07) 中所做的那样。包含 Builder 模式类型的命名设置方法的实体无法正确地序列化为
    JSON。
- en: '|  |'
  id: totrans-521
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Your `CartController`, as shown in [listing 3.8](#ch03ex08), needs the same
    modifications to make it RESTful as you made for Dropwizard. Both use the JAX-RS
    APIs for RESTful endpoints.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [列表 3.8](#ch03ex08) 所示，您的 `CartController` 需要进行相同的修改，以便使其成为 RESTful，就像您为 Dropwizard
    做的那样。两者都使用 JAX-RS API 来实现 RESTful 端点。
- en: Listing 3.8\. `CartController` with Payara
  id: totrans-523
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.8\. 带有 Payara 的 `CartController`
- en: '[PRE23]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '***1*** Endpoint is accessible as /add.'
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 端点可通过 /add 访问。'
- en: '***2*** Method parameters that will be passed on the URL, such as /add?item=hat&qty=2'
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 将要传递到 URL 上的方法参数，例如 /add?item=hat&qty=2'
- en: '***3*** Parameter defined as part of the URL path, /get/hat.'
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 定义为 URL 路径一部分的参数，/get/hat。'
- en: Now that your RESTful endpoint is defined, you need to tell the runtime that
    you want to make it available. With Payara Micro, you do that with a custom JAX-RS
    `Application` class that registers your resource.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的 RESTful 端点已经定义好了，你需要告诉运行时你希望使其可用。使用 Payara Micro，你可以通过一个自定义的 JAX-RS `Application`
    类来注册你的资源。
- en: Listing 3.9\. `JaxrsApplication` with Payara
  id: totrans-529
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.9\. 使用 Payara 的 `JaxrsApplication`
- en: '[PRE24]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You specify a URL path for the whole application and then add your `CartController`
    class to a set of classes that the application makes available to the JAX-RS runtime
    for instantiation.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 你为整个应用程序指定一个 URL 路径，然后将你的 `CartController` 类添加到应用程序使其对 JAX-RS 运行时实例化的类集合中。
- en: Now that you’ve developed the application, let’s run it. Before you can run
    it, you need to download the Payara Micro runtime from [www.payara.fish/downloads](http://www.payara.fish/downloads).
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经开发了这个应用程序，让我们来运行它。在你能够运行它之前，你需要从 [www.payara.fish/downloads](http://www.payara.fish/downloads)
    下载 Payara Micro 运行时。
- en: '|  |'
  id: totrans-533
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-534
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: After downloading the runtime, it’s worth renaming the file to payara-micro.jar
    and removing the version information. You don’t need this information for running
    the file locally, and the omission makes the command line easier to read.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 下载运行时后，将其文件重命名为 payara-micro.jar 并删除版本信息是有意义的。你不需要这些信息来在本地运行文件，省略这些信息可以使命令行更容易阅读。
- en: '|  |'
  id: totrans-536
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Because it’s a regular Maven WAR project, you build it as usual:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它是一个常规的 Maven WAR 项目，所以你按照常规方式构建它：
- en: '[PRE25]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'and run the application:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行应用程序：
- en: '[PRE26]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: It’s now possible to access the application at http://localhost:8080/chapter3/
    in a browser. This returns the list of current items in the cart. You can look
    at the details of `hat` in your cart by navigating to http://localhost:8080/chapter3/get/hat.
    Update the quantity of an existing item with http://localhost:8080/chapter3/add?item=towel&qty=1
    or add a new item to your cart with http://localhost:8080/chapter3/add?item=kite&qty=2.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以在浏览器中通过 http://localhost:8080/chapter3/ 访问应用程序。这会返回购物车中当前项目的列表。你可以通过导航到
    http://localhost:8080/chapter3/get/hat 查看购物车中 `hat` 的详细信息。使用 http://localhost:8080/chapter3/add?item=towel&qty=1
    更新现有项目的数量，或者使用 http://localhost:8080/chapter3/add?item=kite&qty=2 向购物车添加新项目。
- en: 3.2.4\. Spring Boot—opinionated Spring microservices
  id: totrans-542
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.4\. Spring Boot—有观点的 Spring 微服务
- en: Spring Boot came about from a desire to remove the need for boilerplate configuration
    by following conventions instead. Annotations were also introduced to provide
    a means of enabling various parts of Spring Boot without needing configuration
    to do so.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 产生于通过遵循约定来移除样板配置的需求。还引入了注解，以提供一种无需配置即可启用 Spring Boot 各部分的方法。
- en: 'Spring Boot provides many starters as dependencies for your project that combine
    related libraries and frameworks and configuration for many features that you
    may require when developing a microservice. For example, the `spring-boot-starter-data-jpa`
    dependency brings in all that’s required to use Spring and JPA for accessing a
    database. A full list of all the available starters can be found in the GitHub
    repository: [http://mng.bz/cuQ3](http://mng.bz/cuQ3). Or take a look at [http://start.spring.io](http://start.spring.io),
    where you can create a Maven project based on the starters that you need for your
    application.'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 为你的项目提供了许多作为依赖项的启动器，这些启动器结合了相关的库、框架和配置，以便你在开发微服务时可能需要使用到的许多功能。例如，`spring-boot-starter-data-jpa`
    依赖项引入了使用 Spring 和 JPA 访问数据库所需的所有内容。所有可用的启动器的完整列表可以在 GitHub 仓库中找到：[http://mng.bz/cuQ3](http://mng.bz/cuQ3)。或者查看
    [http://start.spring.io](http://start.spring.io)，在那里你可以根据你的应用程序需要的启动器创建一个 Maven
    项目。
- en: '[Figure 3.8](#ch03fig08) shows how your JAX-RS, CDI, JMS microservice uses
    Spring Boot. The biggest challenge with this microservice would be rewriting existing
    code that uses CDI to use Spring dependency injection instead. Options are available
    to make CDI work inside Spring, but if you’re looking for the project to remain
    as a Spring-based project, rewriting it to use Spring injection makes better sense.'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3.8](#ch03fig08) 展示了你的 JAX-RS、CDI、JMS 微服务如何使用 Spring Boot。这个微服务最大的挑战可能是重写使用
    CDI 的现有代码，以使用 Spring 依赖注入代替。有可用的选项使 CDI 在 Spring 内部工作，但如果你希望项目保持为基于 Spring 的项目，将其重写为使用
    Spring 注入更有意义。'
- en: Figure 3.8\. Microservice usage in Spring Boot
  id: totrans-546
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.8\. Spring Boot 中的微服务使用
- en: '![](Images/03fig08.jpg)'
  id: totrans-547
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/03fig08.jpg)'
- en: With *starters,* Spring Boot is able to provide a flexible JeAS runtime that
    can be expanded or contracted as required based on the evolving requirements of
    the application. Modifying the application’s functionality is only a matter of
    adding or removing Spring Starter dependencies and rebuilding the application.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *启动器*，Spring Boot 能够提供一个灵活的 JeAS 运行时环境，可以根据应用程序不断变化的需求进行扩展或缩减。修改应用程序的功能只需添加或删除
    Spring Starter 依赖项并重新构建应用程序即可。
- en: If you’re not sure what specific starters you might need, head over to [http://start.spring.io](http://start.spring.io)
    to look at the options. The website contains a project generator that’s a great
    place to see the entire landscape of available starters and the types of functionality
    they provide, or the use cases they might solve. Starters are available for regular
    development tasks such as database access, but also for microservice programming
    patterns such as circuit breaking and service discovery.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不确定可能需要哪些特定的启动器，请访问 [http://start.spring.io](http://start.spring.io) 查看选项。该网站包含一个项目生成器，是查看可用的启动器及其提供的功能类型或可能解决的用例的绝佳场所。启动器适用于常规开发任务，如数据库访问，也适用于微服务编程模式，如断路器和服务发现。
- en: '|  |'
  id: totrans-550
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-551
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Spring Boot started in October 2012, and it has surpassed version 1.5.10.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 于 2012 年 10 月启动，并已超过版本 1.5.10。
- en: '|  |'
  id: totrans-553
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'You can use [http://start.spring.io](http://start.spring.io) to create a project
    that includes the `Web` starter. This should give you a pom.xml that contains
    the following dependency:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 [http://start.spring.io](http://start.spring.io) 创建一个包含 `Web` 启动器的项目。这将为您提供包含以下依赖项的
    pom.xml 文件：
- en: '[PRE27]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now that you have your project, let’s modify the basic code so it can be used
    with Spring Boot. For the `CartItem` bean, you need to add only the `@XmlRootElement`
    to it. With your `CartController`, you need to add the necessary annotations to
    make it a RESTful endpoint. This is similar to your JAX-RS-based annotations,
    but the names are slightly different.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您有了项目，让我们修改基本代码，使其可以与 Spring Boot 一起使用。对于 `CartItem` 实例，您只需向其中添加 `@XmlRootElement`。对于您的
    `CartController`，您需要添加必要的注解使其成为 RESTful 端点。这与您的基于 JAX-RS 的注解类似，但名称略有不同。
- en: Listing 3.10\. `CartController` with Spring Boot
  id: totrans-557
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.10\. `CartController` 基于 Spring Boot
- en: '[PRE28]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '***1*** Indicates to Spring that the class will provide RESTful endpoint methods'
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 告诉 Spring 该类将提供 RESTful 端点方法'
- en: '***2*** Method will be available on a URL path of / for HTTP GET requests.'
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 方法将在 HTTP GET 请求的 / 路径上可用。'
- en: '***3*** A URL query parameter called item will be mapped into this method parameter.'
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 一个名为 item 的 URL 查询参数将被映射到这个方法参数。'
- en: '***4*** URL path variable is expected after /get/ for this endpoint.'
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** 预期在 /get/ 之后为该端点映射 URL 路径变量。'
- en: '***5*** URL path variable will be mapped to this method parameter.'
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** URL 路径变量将被映射到这个方法参数。'
- en: Each of the methods on your controller provide the same details as your other
    JAX-RS examples but in a single annotation. `@RequestMapping` holds all the information
    of your JAX-RS examples that used `@GET`, `@Produces`, and `@Path`. The other
    difference is that `@QueryParam` from JAX-RS is `@RequestParam` with Spring, and
    `@PathParam` from JAX-RS is `@PathVariable` with Spring.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 您控制器上的每种方法都提供与您的其他 JAX-RS 示例相同的详细信息，但仅在一个注解中。`@RequestMapping` 包含了您使用 `@GET`、`@Produces`
    和 `@Path` 的 JAX-RS 示例中所有信息。另一个区别是，JAX-RS 中的 `@QueryParam` 在 Spring 中对应于 `@RequestParam`，而
    JAX-RS 中的 `@PathParam` 在 Spring 中对应于 `@PathVariable`。
- en: '|  |'
  id: totrans-565
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-566
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Spring offers shortcuts for `@RequestMapping` as well. Instead of `@RequestMapping(method
    = RequestMethod.GET, path = "/", produces = "application/json")`, you could use
    `@GetMapping(path = "/", produces = "application/json")`.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 为 `@RequestMapping` 也提供了快捷方式。您可以使用 `@GetMapping(path = "/", produces
    = "application/json")` 而不是 `@RequestMapping(method = RequestMethod.GET, path =
    "/", produces = "application/json")`。
- en: '|  |'
  id: totrans-568
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Your RESTful endpoint has now been defined, so last of all you create your Spring
    Boot application class.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 RESTful 端点现在已经定义，所以最后您创建您的 Spring Boot 应用程序类。
- en: Listing 3.11\. `Chapter3SpringBootApplication`
  id: totrans-570
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.11\. `Chapter3SpringBootApplication`
- en: '[PRE29]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: All you’re doing here is saying that `main()` should activate `@SpringBootApplication`.
    It’s in this class that you’d add additional annotations for various parts of
    Spring Boot that you want to activate.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 您在这里所做的只是说明 `main()` 应该激活 `@SpringBootApplication`。您将在该类中添加您想要激活的 Spring Boot
    各个部分的附加注解。
- en: 'Now that you’ve developed the application, let’s run it. With Spring Boot,
    you have a couple of options for running your application:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经开发了这个应用程序，让我们来运行它。使用 Spring Boot，您有几种运行应用程序的选项：
- en: Running from the command line
  id: totrans-574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从命令行运行
- en: Building the project and running an uber jar
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建项目和运行uber jar
- en: Providing multiple execution options allows developers to choose what’s best
    for their situation. For instance, when doing lots of iterative development, running
    from the command line may be faster because it doesn’t require the project to
    be built on every change. But when a developer wants to verify production-like
    behavior, running the uber jar will provide a more accurate reflection of production.
    Not that there’s anything broken with one method as opposed to another, but it’s
    always preferable to verify applications prior to production deployment in an
    environment and manner that reflects the way it’ll be executed in production.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 提供多个执行选项允许开发者选择最适合他们情况的方法。例如，在进行大量迭代开发时，从命令行运行可能更快，因为它不需要在每次更改时都构建项目。但是，当开发者想要验证类似生产环境的行为时，运行uber
    jar将提供更准确的生产反映。并不是说一种方法比另一种方法有问题，但总是更倾向于在生产部署前在一个反映生产执行方式的环境和方式中验证应用程序。
- en: 'To run from the command line without having built your application with Maven,
    you can start the Spring Boot server with the following:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 要在没有使用Maven构建你的应用程序的情况下从命令行运行，你可以使用以下命令启动Spring Boot服务器：
- en: '[PRE30]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This uses the Maven plugin from Spring Boot to execute the application as if
    it had been packaged into an uber jar.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用Spring Boot的Maven插件来执行应用程序，就像它已经被打包成一个uber jar一样。
- en: 'The alternative approach is to construct an uber jar. You build the Maven project
    as usual:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是构建一个uber jar。你像往常一样构建Maven项目：
- en: '[PRE31]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'and run the application:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行应用程序：
- en: '[PRE32]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: It’s now possible to access the application at http://localhost:8080/ in a browser.
    This will return the list of current items in the cart. You can look at the details
    of hat in your cart by navigating to http://localhost:8080/get/hat. Update the
    quantity of an existing item with http://localhost:8080/add?item=towel&qty=1 or
    add a new item to your cart with http://localhost:8080/add?item=kite&qty=2.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以在浏览器中通过http://localhost:8080/访问应用程序。这将返回购物车中当前项目的列表。你可以通过导航到http://localhost:8080/get/hat查看购物车中帽子的详细信息。使用http://localhost:8080/add?item=towel&qty=1更新现有项目的数量，或者使用http://localhost:8080/add?item=kite&qty=2向购物车添加新项目。
- en: 3.2.5\. Thorntail—the most flexible JeAS runtime
  id: totrans-585
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.5. Thorntail——最灵活的JeAS运行时
- en: Thorntail was born out of the desire to take advantage of the modularization
    within the WildFly application server. That effort enables different groups of
    modules to be gathered and installed into the server for use. This also enables
    Thorntail to be the most flexible JeAS runtime available for Java EE. Choosing
    a single piece of Java EE functionality to use with your application is now super
    simple.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: Thorntail的诞生源于利用WildFly应用程序服务器内模块化的愿望。这一努力使得不同的模块组可以被收集并安装到服务器中以供使用。这也使得Thorntail成为可用的最灵活的Java
    EE运行时。现在，选择与你的应用程序一起使用的单个Java EE功能变得非常简单。
- en: Thorntail defines each dependency that can be included by your application,
    such as JPA, JAX-RS, and most parts of Java EE. In addition to Java EE dependencies,
    Thorntail provides dependencies for libraries that can assist with developing
    Enterprise Java microservices such as Swagger, Keycloak, and other frameworks
    and libraries.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: Thorntail定义了应用程序可以包含的每个依赖项，例如JPA、JAX-RS和Java EE的大部分内容。除了Java EE依赖项之外，Thorntail还提供了有助于开发企业Java微服务的库的依赖项，例如Swagger、Keycloak以及其他框架和库。
- en: If you’re unsure of what Thorntail dependencies might be needed by your application,
    you have a couple of options. You can generate a skeleton project by visiting
    [http://wildfly-swarm.io/generator](http://wildfly-swarm.io/generator) and selecting
    the types of functionality that you need for your microservice. There are options
    for Java EE features and non-Java EE features such as Eclipse MicroProfile, Hibernate
    Search, fault tolerance, and security, to name a few.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不确定你的应用程序可能需要的Thorntail依赖项，你有几个选择。你可以通过访问[http://wildfly-swarm.io/generator](http://wildfly-swarm.io/generator)并选择你需要的微服务功能类型来生成一个骨架项目。这里有Java
    EE功能和非Java EE功能的选择，例如Eclipse MicroProfile、Hibernate Search、容错性和安全性等，仅举几例。
- en: The other option for developing your Thorntail application, if you’re unsure
    of what dependencies you need, is to add the Maven plugin to your pom.xml and
    allow the plugin to autodetect dependencies. *Auto Detect* inspects your application
    code to determine which APIs are being used, and therefore which dependencies
    are required. This is usually the simplest means of using Thorntail, especially
    when converting from an existing Java EE application; it allows the rest of the
    application to remain the same because you added only a new plugin into pom.xml.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不确定需要哪些依赖项，开发你的 Thorntail 应用程序的另一种选择是将 Maven 插件添加到你的 pom.xml 中，并允许插件自动检测依赖项。*自动检测*
    会检查你的应用程序代码以确定正在使用哪些 API，因此需要哪些依赖项。这通常是使用 Thorntail 的最简单方法，尤其是在从现有的 Java EE 应用程序转换时；因为它允许应用程序的其他部分保持不变，因为你只向
    pom.xml 中添加了一个新的插件。
- en: '|  |'
  id: totrans-590
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-591
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Though *Auto Detect* is easy for getting started, it does mean the plugin is
    a bit slower to package an application than specifying dependencies directly.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 *自动检测* 对于入门来说很容易，但这确实意味着与直接指定依赖项相比，插件打包应用程序要慢一些。
- en: '|  |'
  id: totrans-593
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: After a developer is more familiar with the available dependencies or requires
    dependencies that can’t be detected by the plugin, switching to using direct Maven
    dependencies is easy. An easy way to see what dependencies are detected by the
    plugin is to look at the log output from building the project. It’s then possible
    to use that list as a set of Maven dependencies that need to be added.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发者对可用的依赖项更加熟悉或需要插件无法检测到的依赖项后，切换到使用直接 Maven 依赖项很容易。查看构建项目时的日志输出是查看插件检测到的依赖项的一个简单方法。然后可以使用该列表作为需要添加的
    Maven 依赖项的集合。
- en: '|  |'
  id: totrans-595
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-596
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Thorntail was founded in February 2015, and has now surpassed version 2.2.0.Final.
    The project was renamed from WildFly Swarm to Thorntail in May 2018.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: Thorntail 于 2015 年 2 月成立，现已超过 2.2.0.Final 版本。该项目于 2018 年 5 月从 WildFly Swarm
    重命名为 Thorntail。
- en: '|  |'
  id: totrans-598
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '[Figure 3.9](#ch03fig09) illustrates how your JAX-RS, CDI, JMS microservice
    uses specifications within Thorntail. Here you can see that Thorntail provides
    exactly what your microservice needs—no more and no less. Thorntail provides the
    ideal JeAS runtime because it always gives you just enough for your microservice.
    No other JeAS runtime can match your application’s requirements so closely. The
    other runtimes have unused portions or require you to include additional libraries
    in your application.'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3.9](#ch03fig09) 展示了你的 JAX-RS、CDI、JMS 微服务如何在 Thorntail 中使用规范。在这里，你可以看到 Thorntail
    提供了你的微服务所需的一切——不多也不少。Thorntail 提供了理想的 JeAS 运行时，因为它总是给你足够的资源，让你的微服务运行。没有其他 JeAS
    运行时能如此紧密地匹配你的应用程序需求。其他运行时有一些未使用的部分，或者需要你在应用程序中包含额外的库。'
- en: Figure 3.9\. Microservice usage in Thorntail
  id: totrans-600
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.9\. Thorntail 中的微服务使用
- en: '![](Images/03fig09.jpg)'
  id: totrans-601
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/03fig09.jpg)'
- en: To create your project, you’ll use a basic Maven WAR project and add the following
    plugin definition.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建你的项目，你将使用一个基本的 Maven WAR 项目，并添加以下插件定义。
- en: Listing 3.12\. Plugin configuration
  id: totrans-603
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.12\. 插件配置
- en: '[PRE33]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '***1*** Artifact ID for the Thorntail plugin'
  id: totrans-605
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** Thorntail 插件的工件 ID'
- en: '***2*** Version of Thorntail'
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** Thorntail 的版本'
- en: '***3*** Execute plugin during package phase.'
  id: totrans-607
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 在打包阶段执行插件。'
- en: 'And then you add the Java EE Web APIs in the provided scope:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你在提供的范围内添加 Java EE Web API：
- en: '[PRE34]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now that you have your project, let’s modify the basic code so it can be run
    with the Thorntail JeAS runtime.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了你的项目，让我们修改基本的代码，使其能够与 Thorntail JeAS 运行时一起运行。
- en: For the `CartItem` bean, you need to add only the `@XmlRootElement` to it. The
    `CartController` needs the same JAX-RS annotations as you added for Payara Micro
    and Dropwizard. Finally, you need an `Application` class to activate JAX-RS.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `CartItem` 实体，你只需要向其中添加 `@XmlRootElement`。`CartController` 需要与你为 Payara Micro
    和 Dropwizard 添加的相同的 JAX-RS 注解。最后，你需要一个 `Application` 类来激活 JAX-RS。
- en: Listing 3.13\. `JaxrsApplication` with Thorntail
  id: totrans-612
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.13\. Thorntail 下的 `JaxrsApplication`
- en: '[PRE35]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now that you’ve developed the application, let’s run it. With Thorntail, you
    have a couple of options for running your application:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经开发了这个应用程序，让我们来运行它。使用 Thorntail，你有几种运行应用程序的选择：
- en: Running from the command line
  id: totrans-615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从命令行运行
- en: Building the project and running an uber jar
  id: totrans-616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建项目和运行 fat jar
- en: 'As with Spring Boot, Thorntail provides flexibility as to how a developer might
    prefer to run an application based on their requirements. Without having built
    your application with Maven, you can start the Thorntail JeAS runtime with this:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Spring Boot 类似，Thorntail 提供了根据开发者的需求运行应用程序的灵活性。在没有使用 Maven 构建您的应用程序的情况下，您可以使用以下方式启动
    Thorntail JeAS 运行时：
- en: '[PRE36]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This uses the Maven plugin from Thorntail to execute the application as if it
    had been packaged into an uber jar.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用 Thorntail 的 Maven 插件来执行应用程序，就像它被打包成一个超级 JAR 一样。
- en: 'The other approach is to construct an uber jar. You build the Maven project
    as usual:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是构建一个超级 JAR。你像往常一样构建 Maven 项目：
- en: '[PRE37]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'and run the application:'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 并运行应用程序：
- en: '[PRE38]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: It’s now possible to access the application at http://localhost:8080/ in a browser.
    This returns the list of current items in the cart. You can look at the details
    of hat in your cart by navigating to http://localhost:8080/get/hat. Update the
    quantity of an existing item with http://localhost:8080/add?item=towel&qty=1 or
    add a new item to your cart with http://localhost:8080/add?item=kite&qty=2.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以在浏览器中访问 http://localhost:8080/ 以访问应用程序。这返回购物车中当前项目的列表。您可以通过导航到 http://localhost:8080/get/hat
    查看购物车中帽子的详细信息。使用 http://localhost:8080/add?item=towel&qty=1 更新现有项目的数量，或使用 http://localhost:8080/add?item=kite&qty=2
    向购物车添加新项目。
- en: 3.2.6\. How do they compare?
  id: totrans-625
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.6\. 它们是如何比较的？
- en: You’ve taken a look at some JeAS runtimes and the way the code for each differs
    for a simple application that exposes a few RESTful endpoints. Let’s compare some
    of the features of the JeAS runtimes in [table 3.2](#ch03table02).
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经查看了一些 JeAS 运行时以及每个运行时为简单应用程序（暴露几个 RESTful 端点）的代码差异。让我们比较一下 JeAS 运行时的某些功能[表
    3.2](#ch03table02)。
- en: Table 3.2\. JeAS runtime comparison
  id: totrans-627
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 3.2\. JeAS 运行时比较
- en: '| Feature | Dropwizard | Payara Micro | Spring Boot | Thorntail |'
  id: totrans-628
  prefs: []
  type: TYPE_TB
  zh: '| 功能 | Dropwizard | Payara Micro | Spring Boot | Thorntail |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-629
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| Dependency injection (DI) |   | ✓ | ✓ | ✓ |'
  id: totrans-630
  prefs: []
  type: TYPE_TB
  zh: '| 依赖注入 (DI) |   | ✓ | ✓ | ✓ |'
- en: '| Uber jar packaging | ✓ |   | ✓ | ✓ |'
  id: totrans-631
  prefs: []
  type: TYPE_TB
  zh: '| 超级 JAR 打包 | ✓ |   | ✓ | ✓ |'
- en: '| WAR deployment |   | ✓ | ✓ | ✓ |'
  id: totrans-632
  prefs: []
  type: TYPE_TB
  zh: '| WAR 部署 |   | ✓ | ✓ | ✓ |'
- en: '| Maven plugin run |   |   | ✓ | ✓ |'
  id: totrans-633
  prefs: []
  type: TYPE_TB
  zh: '| Maven 插件运行 |   |   | ✓ | ✓ |'
- en: '| Project generator | ✓ |   | ✓ | ✓ |'
  id: totrans-634
  prefs: []
  type: TYPE_TB
  zh: '| 项目生成器 | ✓ |   | ✓ | ✓ |'
- en: '| Auto Detect dependencies |   |   |   | ✓ |'
  id: totrans-635
  prefs: []
  type: TYPE_TB
  zh: '| 自动检测依赖项 |   |   |   | ✓ |'
- en: '| Java EE APIs |   | ✓ |   | ✓ |'
  id: totrans-636
  prefs: []
  type: TYPE_TB
  zh: '| Java EE API |   | ✓ |   | ✓ |'
- en: 'When it comes to choosing the best JeAS runtime for your application or enterprise,
    many factors play a role. Some of the more critical factors are as follows:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到为您的应用程序或企业选择最佳的 JeAS 运行时，许多因素都会发挥作用。以下是一些更关键的因素：
- en: Is there experience and knowledge of either Java EE or Spring?
  id: totrans-638
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您是否有 Java EE 或 Spring 的经验和知识？
- en: What’s the preferred packaging method for production?
  id: totrans-639
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生产中首选的打包方法是什么？
- en: Is there prior experience of either of the non-JeAS runtimes of the frameworks?
  id: totrans-640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您是否有任何非 JeAS 运行时框架的经验？
- en: These are just some of the factors that will influence which is the preferred
    JeAS framework for an application. It may be that Thorntail is the preferred choice
    for developers with previous Java EE experience, but developers looking for a
    simple stack that doesn’t require many Java EE APIs may choose Dropwizard instead.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是影响选择哪个 JeAS 框架作为应用程序首选的一些因素。可能 Thorntail 是具有先前 Java EE 经验的开发者的首选选择，但寻找不需要许多
    Java EE API 的简单堆栈的开发者可能会选择 Dropwizard。
- en: Summary
  id: totrans-642
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: JeAS enables the packaging of just enough runtime along with a microservice.
    Of the runtimes covered in this chapter, Thorntail is the most customizable JeAS
    runtime.
  id: totrans-643
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JeAS 允许打包足够的运行时以及一个微服务。在本章中涵盖的运行时中，Thorntail 是最可定制的 JeAS 运行时。
- en: You choose pieces of an Enterprise Java application server by using a JeAS runtime,
    selecting only what you need.
  id: totrans-644
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您通过使用 JeAS 运行时选择企业 Java 应用程序服务器的一部分，仅选择您需要的部分。
- en: JeAS runtimes are the perfect deployment method for RESTful microservices.
  id: totrans-645
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JeAS 运行时是 RESTful 微服务的完美部署方法。
- en: MicroProfile offers critical features for cloud native microservice development.
  id: totrans-646
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MicroProfile 为云原生微服务开发提供了关键功能。
- en: Chapter 4\. Microservices testing
  id: totrans-647
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 4 章\. 微服务测试
- en: '*This chapter covers*'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: What types of testing do you need to consider?
  id: totrans-649
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要考虑哪些类型的测试？
- en: Which tools are appropriate for microservices?
  id: totrans-650
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些工具适用于微服务？
- en: Implementing unit testing for microservices
  id: totrans-651
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为微服务实现单元测试
- en: Implementing integration testing for microservices
  id: totrans-652
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为微服务实现集成测试
- en: Using consumer-driven contract testing
  id: totrans-653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用消费者驱动的合同测试
- en: Where to start! So many types and levels of testing can be implemented for anything.
    Complicating things further is that different people will likely have different
    points of view, specifically in regard to what the various types of testing should
    accomplish.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 从哪里开始！对于任何事物，都可以实施如此多种类和级别的测试。进一步复杂化的是，不同的人可能会有不同的观点，特别是关于各种测试类型应该实现什么目标。
- en: Let’s get on the same page with respect to the types of testing and create a
    common understanding of their meaning for us all! In this chapter, you’ll focus
    only on the types of testing that are relevant for our purposes. There are too
    many types of testing to cover them all; it’d become overwhelming.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们就测试类型达成共识，并共同理解它们对我们所有人的意义！在本章中，你将只关注与我们目的相关的测试类型。测试类型太多，难以全部涵盖；这会变得令人不知所措。
- en: Then you’ll use the admin service you created in [chapter 2](kindle_split_011.xhtml#ch02)
    to show the types of testing that can be performed with a microservice.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你将使用在[第2章](kindle_split_011.xhtml#ch02)中创建的管理服务来展示可以使用微服务执行的测试类型。
- en: 4.1\. What type of testing do you need?
  id: totrans-657
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1\. 你需要哪种类型的测试？
- en: 'Three types of testing are covered in this chapter:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了三种测试类型：
- en: '*Unit testing* is focused on testing the internals of your microservice.'
  id: totrans-659
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*单元测试*专注于测试您的微服务的内部结构。'
- en: '*Integration testing* covers the entirety of your service, in addition to the
    way it interacts with external services, such as a database.'
  id: totrans-660
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*集成测试*涵盖了您的整个服务，以及它与外部服务（如数据库）交互的方式。'
- en: '*Consumer-driven contract testing* deals with the boundary between a consumer
    of your microservice and the microservice itself, via a Pact document that defines
    the contract.'
  id: totrans-661
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*消费者驱动的契约测试*处理您的微服务消费者与微服务本身之间的边界，通过定义契约的Pact文档。'
- en: It’s important to note that unit and integration testing are far from new concepts.
    They’ve been part of software development for decades. The application of integration
    testing to microservices may increase its complexity, through more external integration
    points, but the way we develop them hasn’t greatly changed.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，单元和集成测试远非新概念。它们已经软件开发的组成部分几十年了。集成测试在微服务中的应用可能会通过更多的外部集成点增加其复杂性，但我们的开发方式并没有发生很大变化。
- en: Why did I choose these three types of testing to focus on, given that dozens
    of types are available? I’m not saying that these three are the only types you
    need to worry about, but these are certainly crucial to your goal of ensuring
    that a microservice is as robust as possible. Unit and integration testing are
    focused on ensuring that what you, as a developer of a microservice, have written
    meets the requirements that have been outlined for a microservice. Consumer-driven
    contract testing changes perspectives to look from outside a microservice, to
    ensure that a microservice can correctly process whatever clients are passing
    to you. Though it may not be part of the requirements of a microservice, it’s
    possible that a client expects slightly different behavior than has been developed.
    [Figure 4.1](#ch04fig01) shows how the three types of testing fit in terms of
    your code.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我会选择这三种测试类型来重点关注，尽管有数十种类型可供选择？我并不是说这三种是唯一需要关注的类型，但它们确实对于确保微服务尽可能健壮至关重要。单元和集成测试专注于确保您作为微服务的开发者所编写的代码符合为微服务概述的要求。消费者驱动的契约测试将视角转向从微服务外部看，以确保微服务可以正确处理客户端传递给您的任何内容。尽管这可能不是微服务的要求之一，但客户端可能期望的行为与已开发的行为略有不同。[图4.1](#ch04fig01)展示了三种测试类型在您的代码中的位置。
- en: Figure 4.1\. Types of testing
  id: totrans-664
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.1\. 测试类型
- en: '![](Images/04fig01_alt.jpg)'
  id: totrans-665
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/04fig01_alt.jpg)'
- en: The key point with respect to testing of any type is that you’re not writing
    tests for fun or for one-off execution. The purpose, and benefit, of writing any
    test is the ability to continually execute it against code as it changes and is
    modified, typically as part of a continuous integration process that regularly
    builds your code. And why do you want these tests running all the time on old
    and updated code? For the simple reason that it reduces the number of errors,
    or bugs, that make it into production code. As I mentioned in [chapter 1](kindle_split_010.xhtml#ch01),
    anything you can do to reduce the number of times you’re called about production
    bugs, the better you are for it.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 关于任何类型测试的关键点在于，你并不是为了乐趣或一次性执行而编写测试。编写任何测试的目的和好处是能够持续地对代码进行执行，代码在变化和修改时也是如此，通常作为持续集成过程的一部分，该过程定期构建你的代码。你为什么想让这些测试一直运行在旧代码和更新后的代码上？简单来说，这是因为它减少了进入生产代码的错误或缺陷的数量。正如我在[第1章](kindle_split_010.xhtml#ch01)中提到的，你可以做任何减少你被要求处理生产缺陷次数的事情，这对你是更好的。
- en: 4.2\. Unit testing
  id: totrans-667
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2. 单元测试
- en: Typically created by developers as part of writing code, *unit testing* tests
    the internal behavior of classes and their methods. Doing so often requires mocks
    or stubs to *mimic* the behavior of external systems.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 通常由开发者在编写代码时创建，*单元测试*用于测试类及其方法内部的行为。这样做通常需要模拟或存根来*模仿*外部系统的行为。
- en: '|  |'
  id: totrans-669
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-670
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Stubs and mocks are tools you can employ to make it possible to unit test code
    that interacts with external services, such as a database, without needing a database.
    Though serving the same purpose, they operate in different ways. *Stubs* are handcrafted
    implementations of a service that a developer has written to return precanned
    responses to each method. *Mocks* offer greater flexibility, as each test can
    set up whatever you expect the method to return for that particular test, and
    then verify that the mock acted in the way you anticipated. Testing with mocks
    requires each test to set the expectations for the service being called and then
    verify it afterward, but it saves you from writing every test situation possible
    into a stub.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 存根和模拟是你可以使用的工具，可以使与外部服务（如数据库）交互的代码进行单元测试成为可能，而无需数据库。尽管它们服务于相同的目的，但它们以不同的方式运行。*存根*是开发者手工编写的服务的实现，为每个方法返回预定义的响应。*模拟*提供了更大的灵活性，因为每个测试都可以为特定测试设置你期望方法返回的内容，然后验证模拟是否按预期行事。使用模拟进行测试要求每个测试设置被调用服务的期望，并在之后进行验证，但这样可以节省你将所有可能的测试情况写入存根中的时间。
- en: '|  |'
  id: totrans-672
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Why do you need unit testing at all? You need to ensure that a method on a class
    performs the function as it’s intended. If a method has parameters passed to it,
    these should be validated to ensure they’re appropriate. This can be as simple
    as ensuring that the value is non-`null`, or as complex as validating an email
    address format. Likewise, you need to verify that passing particular inputs as
    parameters returns the result you expect from those inputs. Unit testing is the
    lowest level of testing, but is often the most crucial to get right. If your smallest
    unit of code, a method, doesn’t perform as you expect, then your entire service
    could function incorrectly.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 你为什么需要单元测试呢？你需要确保类上的方法按预期执行功能。如果一个方法有传递给它的参数，这些参数应该得到验证以确保它们是合适的。这可能只是确保值不是`null`那么简单，也可能像验证电子邮件地址格式那样复杂。同样，你需要验证传递特定输入作为参数返回的结果是否符合你的预期。单元测试是测试的最低级别，但通常是正确执行的最关键部分。如果你的最小代码单元，即方法，没有按预期执行，那么你的整个服务可能会运行不正确。
- en: The two most popular and widely used frameworks for this level of testing are
    JUnit ([http://junit.org/](http://junit.org/)) and TestNG ([http://testng.org/doc/](http://testng.org/doc/)).
    JUnit has been around the longest and was the inspiration for TestNG being created.
    There aren’t many differences between their features, or even the names of annotations
    in some cases!
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试级别上，最流行和最广泛使用的框架是JUnit ([http://junit.org/](http://junit.org/)) 和 TestNG
    ([http://testng.org/doc/](http://testng.org/doc/))。JUnit存在的时间最长，也是TestNG被创建的灵感来源。它们的功能之间没有太多差异，在某些情况下，甚至注解的名称也没有太多差异！
- en: The biggest difference is in their goals. JUnit’s focus is purely on unit testing,
    and was a huge driver for the adoption of test-driven development. TestNG aims
    to support wider testing use cases than just unit testing.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 它们最大的区别在于目标。JUnit的关注点纯粹是单元测试，并且是推动测试驱动开发采用的一个巨大动力。TestNG旨在支持比单元测试更广泛的测试用例。
- en: Whichever a developer chooses is purely a personal choice. At any time, JUnit
    or TestNG may have more features than the other, but it’s highly likely that the
    other will soon catch up. Such back and forth has happened over the years many
    times.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者选择哪个完全是个人选择。在任何时候，JUnit或TestNG可能比另一个有更多功能，但其他很快就会赶上。这样的来回已经发生了很多次。
- en: The code as it stood from [chapter 2](kindle_split_011.xhtml#ch02) has been
    copied to /chapter4/admin, to enable you to see the differences in the code after
    you’ve added tests. This is particularly important to show relevant code changes
    that were required to fix any dreaded bugs found. For writing our unit tests,
    I use JUnit, simply because I’ve used that framework the most in my career and
    I’m the most familiar with it.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 从[第2章](kindle_split_011.xhtml#ch02)的代码已经被复制到/chapter4/admin，以便你可以在添加测试后看到代码中的差异。这尤其重要，可以展示出修复任何令人讨厌的错误所需的相关的代码更改。对于编写我们的单元测试，我使用JUnit，仅仅因为我在我职业生涯中使用了最多的这个框架，并且我对它最熟悉。
- en: The admin microservice is focused on CRUD operations for the `Category` model
    at the moment, and has a JAX-RS resource for providing the RESTful endpoints to
    interact with it.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 管理微服务目前专注于`Category`模型的CRUD操作，并有一个JAX-RS资源来提供与它交互的RESTful端点。
- en: As you’re dealing with unit testing, `Category` is the only viable code you
    can test with unit tests without mocking databases. It’s certainly possible to
    mock out `EntityManager` to test the JAX-RS resource as well, but it’s preferable
    to test it fully with a database as part of integration testing.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你正在处理单元测试，`Category`是你可以测试的唯一有效代码，无需模拟数据库。当然，你可以模拟`EntityManager`来测试JAX-RS资源，但最好是将其与数据库一起作为集成测试的一部分进行全面测试。
- en: 'The first thing you need to do is add dependencies to your pom.xml for testing:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做的第一件事是在pom.xml中添加测试依赖项：
- en: '[PRE39]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now let’s take a look at some unit tests for `Category`, as it’s the lowest
    level in any method execution stack at runtime.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看`Category`的一些单元测试，因为它是运行时任何方法执行堆栈中的最低层。
- en: Listing 4.1\. `CategoryTest`
  id: totrans-683
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.1. `CategoryTest`
- en: '[PRE40]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '***1*** Test for verifying that two Category instances are identified as equal
    in all ways.'
  id: totrans-685
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 测试验证两个Category实例在所有方面都被视为相等。'
- en: '***2*** Uses a helper method on the test to create any Category instances you
    need for testing'
  id: totrans-686
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 在测试中使用了辅助方法来创建所需的任何Category实例'
- en: '***3*** Uses fluent methods from Fest Assertions to simplify test code'
  id: totrans-687
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 使用Fest Assertions的流畅方法简化测试代码'
- en: '***4*** Test for ensuring that a Category is different after calling a setter
    on it.'
  id: totrans-688
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** 测试确保在调用setter后Category不同。'
- en: '***5*** Test of whether a parent with the same ID on a Category is considered
    equal.'
  id: totrans-689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** 测试具有相同ID的父Category是否被视为相等。'
- en: '***6*** Helper method to create a Category instance for testing.'
  id: totrans-690
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** 用于创建测试用例的Category实例的辅助方法。'
- en: You may have noticed that in the `createCategory()` method of the test class,
    you instantiated a `TestCategoryObject` class. Where did that come from? `TestCategoryObject`
    has an important purpose for our testing. Because it extends `Category`, you can
    directly set fields such as `id` and `version` that have only getter methods on
    `Category`. This allows you to retain the important immutability parts of `Category`,
    while still being able to set and change the properties of `Category` that you
    need for testing. `TestCategoryObject` provides two constructors that allow you
    to set the ID of a `Category`, which is extremely useful for testing. Take a look
    at the chapter code (on GitHub or downloaded from [www.manning.com/books/enterprise-java-microservices](http://www.manning.com/books/enterprise-java-microservices))
    for the full code listing.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到在测试类的`createCategory()`方法中，你实例化了`TestCategoryObject`类。它从哪里来的？`TestCategoryObject`在我们的测试中有一个重要的用途。因为它扩展了`Category`，你可以直接设置只有getter方法的`Category`上的字段，例如`id`和`version`。这允许你保留`Category`的重要不可变部分，同时仍然能够设置和更改测试所需的`Category`属性。`TestCategoryObject`提供了两个构造函数，允许你设置`Category`的ID，这在测试中非常有用。查看章节代码（在GitHub上或从[www.manning.com/books/enterprise-java-microservices](http://www.manning.com/books/enterprise-java-microservices)下载）以获取完整的代码列表。
- en: 4.3\. What is immutability?
  id: totrans-692
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3. 什么是不可变性？
- en: '*Immutability* is a concept from object-oriented programming for identifying
    whether an object’s state can be altered. An object’s state is considered immutable
    if it can’t be altered after its creation.'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: '*不可变性*是面向对象编程中的一个概念，用于确定一个对象的状态是否可以被改变。如果一个对象在创建后不能被改变，则认为其状态是不可变的。'
- en: In our case, `Category` isn’t entirely immutable, but `id`, `created`, and `version`
    are fields that you want to be immutable. For that reason, `Category` has only
    getter methods defined for them, no setter methods.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，`Category`并非完全不可变，但`id`、`created`和`version`是您希望不可变的字段。因此，`Category`只为它们定义了getter方法，没有setter方法。
- en: 'To run the tests with Maven from inside /chapter4/admin, you run this:'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 要从/chapter4/admin内部使用Maven运行测试，您运行以下命令：
- en: '[PRE41]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: When running `CategoryTest` with the existing code from [chapter 2](kindle_split_011.xhtml#ch02),
    you see a failure! The `categoriesWithIdenticalParentIdAreEqual()` test fails,
    because it doesn’t consider the two categories to be equal.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用来自[第2章](kindle_split_011.xhtml#ch02)的现有代码运行`CategoryTest`时，您会看到失败！`categoriesWithIdenticalParentIdAreEqual()`测试失败，因为它没有将两个类别视为相等。
- en: With any test failure, two possibilities exist for what happened. Did you make
    incorrect assertions in your test, or is there a bug in your code?
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何测试失败，都存在两种可能的情况。您在测试中是否做出了错误的断言，或者您的代码中是否存在错误？
- en: In this case, do you expect a `Category` with the same ID but different names
    to be equal? A first instinct might be to say no, they shouldn’t be equal. But
    for this situation, you need to remember that the ID is a unique identifier for
    `Category`, so you’d expect there to be only a single `Category` with any particular
    ID present. So here it’s apparent that your test assertions are correct, as the
    name of a `Category` could’ve been modified in subsequent requests, but there’s
    a bug in your code in how it determines whether a `Category` is equal.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您期望具有相同ID但不同名称的`Category`对象相等吗？一种直觉可能认为不应该相等，它们不应该相等。但针对这种情况，您需要记住，ID是`Category`的唯一标识符，因此您会期望只有一个具有任何特定ID的`Category`对象存在。因此，很明显，您的测试断言是正确的，因为`Category`的名称可能在后续请求中已被修改，但您的代码在确定`Category`是否相等的方式中存在一个错误。
- en: 'Let’s take a look at the `equals()` implementation you currently have on `Category`,
    which was autogenerated by an IDE:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看您目前在`Category`上自动生成的`equals()`实现：
- en: '[PRE42]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: You can see that you’re comparing the entirety of the `parent` of each `Category`
    instance. As you saw in your test, a parent `Category` with the same ID but different
    names will fail an equality test.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，您正在比较每个`Category`实例的`parent`的全部内容。正如您在测试中看到的那样，具有相同ID但不同名称的父`Category`将失败等性测试。
- en: From what we discussed earlier, it doesn’t make sense to compare the entire
    state of one parent category with another. There’s always a chance that one category
    instance might be retrieved after another, and in between those retrievals the
    parent category could be updated with a different name. Although the ID is the
    same, other state differs between the two instances.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们之前讨论的内容来看，比较一个父类别的整个状态与另一个父类别的状态是没有意义的。总有可能在检索一个类别实例之后，另一个类别实例被检索，并且在两次检索之间，父类别可能被更新为不同的名称。尽管ID相同，但两个实例之间的其他状态不同。
- en: 'You can resolve this conflict by concerning yourself with only the ID of the
    parent category, and not the entire object state:'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过只关注父类别的ID，而不是整个对象状态来解决这个问题：
- en: '[PRE43]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Here you’ve modified the parent equality check to verify whether either parent
    is `null`, before comparing whether the ID value is equal. This change makes your
    code more robust and less error prone.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您已修改了父类等性检查，以验证任一父类是否为`null`，然后再比较ID值是否相等。这个更改使您的代码更加健壮，且错误倾向降低。
- en: A similar change is required to `Category.hashCode()` to ensure that you include
    the parent category ID only when generating a hash for a `Category` instance.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 需要对`Category.hashCode()`进行类似的更改，以确保在为`Category`实例生成哈希值时仅包含父类别ID。
- en: You’ve just seen how some short unit tests can assist in improving your internal
    code by reducing the potential for bugs. Let’s take the next step and write some
    integration tests!
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚刚看到一些简短的单元测试如何通过减少潜在的错误可能性来帮助改进您的内部代码。让我们再进一步，编写一些集成测试！
- en: 4.4\. Integration testing
  id: totrans-709
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4. 集成测试
- en: Integration testing is similar to unit testing, and uses the same frameworks,
    but it’s also used to test a microservice interaction with external systems. This
    could include databases, messaging systems, other microservices, or pretty much
    anything it needs to talk to that isn’t internal code to the microservice. If
    you had unit tests that used mocks or stubs to integrate with external systems,
    as part of integration testing the mocks and stubs are replaced with calls to
    the actual systems instead. Removing mocks or stubs opens your code to execution
    paths that haven’t been tested before, as well as introducing more test scenarios
    as you need to test handling of errors in those external systems.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试类似于单元测试，并使用相同的框架，但它也用于测试微服务与外部系统的交互。这可能包括数据库、消息系统、其他微服务，或者几乎任何它需要与之通信的、不是微服务内部代码的东西。如果你有使用模拟或存根与外部系统集成的单元测试，作为集成测试的一部分，模拟和存根将被替换为对实际系统的调用。移除模拟或存根将使你的代码暴露于之前未测试过的执行路径，同时随着你需要测试那些外部系统中错误处理的需要，引入更多的测试场景。
- en: Depending on the type of systems a microservice integrates with, it may not
    be possible to execute these tests on a local developer’s machine. Integration
    testing is perfectly suited to continuous improvement environments, where resources
    are more plentiful and any systems that are required can be installed.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 根据微服务集成的系统类型，可能无法在本地开发者的机器上执行这些测试。集成测试非常适合持续改进环境，那里资源更丰富，所需的任何系统都可以安装。
- en: With integration testing, you can expand the scope of what you’re intending
    to test and verify that it works as you expect. It also allows you to use external
    systems as part of your testing as opposed to mocking anything external. Testing
    with the actual services and systems that a microservice will rely on in production
    greatly improves your confidence that going to production won’t result in errors
    from your code changes. You aren’t going to be running your integration tests
    against production systems, but you can run them against systems that closely
    mirror production setup and data.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 通过集成测试，你可以扩展你打算测试和验证的范围，并确保它按预期工作。它还允许你使用外部系统作为测试的一部分，而不是模拟任何外部系统。使用微服务在生产中依赖的实际服务和系统进行测试，可以极大地提高你对代码更改投入生产不会导致错误的信心。你不会在生产系统上运行集成测试，但可以在与生产设置和数据紧密相似的系统上运行它们。
- en: To assist in developing integration tests, you’ll be using Arquillian. *Arquillian*
    is a highly extensible testing platform for the JVM that allows the easy creation
    of integration, functional, and acceptance tests. Many extensions to the core
    of Arquillian exist to handle specific frameworks, such as JSF, or for browser
    testing integration with Selenium. Full details of all the extensions available
    for Arquillian can be found at [http://arquillian.org/](http://arquillian.org/).
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助开发集成测试，你将使用 Arquillian。*Arquillian* 是一个高度可扩展的 JVM 测试平台，它允许轻松创建集成、功能和验收测试。Arquillian
    的核心存在许多扩展，用于处理特定的框架，例如 JSF，或者用于与 Selenium 集成进行浏览器测试。有关 Arquillian 可用所有扩展的详细信息，请参阅
    [http://arquillian.org/](http://arquillian.org/)。
- en: I’ve chosen Arquillian to help with integration testing because it assists in
    replicating a production environment as closely as possible without being in production.
    Your services are started in the same runtime container as would be the case in
    production, so your service has access to CDI injection, persistence, or whatever
    runtime pieces your service needs.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择 Arquillian 来帮助进行集成测试，因为它有助于尽可能接近地复制生产环境，而不必在生产环境中进行。你的服务将在与生产相同的运行时容器中启动，因此你的服务可以访问
    CDI 注入、持久性或你的服务需要的任何运行时组件。
- en: 'To be able to use Arquillian for integration testing, you need to add the necessary
    dependencies into your pom.xml:'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够使用 Arquillian 进行集成测试，你需要将必要的依赖项添加到你的 pom.xml 文件中：
- en: '[PRE44]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The first dependency adds the runtime container for Thorntail to be used within
    Arquillian tests, and the second adds the integration you require between Arquillian
    and JUnit. For Arquillian to be able to *deploy* anything, it needs access to
    a runtime container. The `arquillian` dependency of Thorntail registers itself
    with Arquillian as being a runtime container, enabling Arquillian to deploy to
    it. Without either of these, you couldn’t execute your integration tests within
    a runtime container.
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个依赖项添加了 Thorntail 在 Arquillian 测试中使用的运行时容器，第二个添加了 Arquillian 和 JUnit 之间的集成。为了
    Arquillian 能够 *部署* 任何内容，它需要访问运行时容器。Thorntail 的 `arquillian` 依赖项将自身注册为运行时容器，使 Arquillian
    能够将其部署到其中。如果没有这些之一，你将无法在运行时容器中执行集成测试。
- en: 'To simplify the code required in your tests to execute HTTP requests, you’ll
    use REST Assured, which also needs to be added to your pom.xml:'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化在测试中执行 HTTP 请求所需的代码，你将使用 REST Assured，这也需要添加到你的 pom.xml 中：
- en: '[PRE45]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The focus of your integration testing will be on the JAX-RS `Resource` class,
    as it defines the RESTful endpoints a consumer will interact with, as well as
    persisting changes to the database. With integration testing we focus on the provider
    side of microservice interactions—you’re only validating that your service API
    works as you’ve designed. This doesn’t take into account what a consumer expects
    of your API; that’s dealt with in consumer-driven contract testing.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 你的集成测试的重点将是 JAX-RS `Resource` 类，因为它定义了消费者将与之交互的 RESTful 端点，以及持久化对数据库的更改。通过集成测试，我们关注微服务交互的提供方——你只是在验证你的服务
    API 是否按你设计的方式工作。这并不考虑消费者对你 API 的期望；这将在消费者驱动的合同测试中处理。
- en: To begin, as shown in [listing 4.2](#ch04ex02), you’ll create a test to verify
    that all categories from the database are correctly retrieved. This single integration
    test will verify that your external-facing API returns information that’s expected,
    as well as validate that your persistence code is properly reading database entries
    to return. Either of those aspects not working as you expect will result in the
    test failing.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如[列表 4.2](#ch04ex02)所示，你需要创建一个测试来验证从数据库中正确检索所有类别。这个单一的集成测试将验证你的外部 API 是否返回预期的信息，以及验证你的持久化代码是否正确读取数据库条目以返回。如果这两个方面中的任何一个没有按预期工作，测试将失败。
- en: Listing 4.2\. Retrieve all categories in listing 4.1’s `CategoryResourceTest`
  id: totrans-722
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.2\. 在 4.1 列表中检索所有类别
- en: '[PRE46]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '***1*** Use Arquillian runner for JUnit test.'
  id: totrans-724
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 使用 Arquillian 运行器进行 JUnit 测试。'
- en: '***2*** Create the deployment for Arquillian based on the type of Thorntail
    project (WAR or JAR).'
  id: totrans-725
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 根据 Thorntail 项目的类型（WAR 或 JAR）创建 Arquillian 部署。'
- en: '***3*** You’re testing RESTful endpoints of your microservice, so you execute
    the tests as a client.'
  id: totrans-726
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 你正在测试微服务的 RESTful 端点，因此你作为客户端执行测试。'
- en: '***4*** Run test methods in order based on the name.'
  id: totrans-727
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** 根据名称顺序运行测试方法。'
- en: '***5*** REST Assured’s fluent methods for executing HTTP requests'
  id: totrans-728
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** REST Assured 执行 HTTP 请求的流畅方法'
- en: '***6*** Verify that you received all categories from the database that you
    expected.'
  id: totrans-729
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** 验证你是否收到了预期的所有数据库类别。'
- en: '***7*** Retrieve a single category record from the list and then verify its
    values.'
  id: totrans-730
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7*** 从列表中检索单个类别记录，然后验证其值。'
- en: The first line in your test is to tell JUnit, via `@RunWith`, that you want
    to use an Arquillian test runner. `@DefaultDeployment` informs the Thorntail integration
    with Arquillian to create an Arquillian deployment to execute the tests against,
    which will use the type of Maven project to create a WAR or JAR for deployment.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的测试中的第一行是告诉 JUnit，通过 `@RunWith`，你想要使用 Arquillian 测试运行器。`@DefaultDeployment`
    通知 Thorntail 与 Arquillian 集成以创建一个 Arquillian 部署来执行测试，这将使用 Maven 项目的类型来创建用于部署的
    WAR 或 JAR。
- en: The other key annotation on the test class is `@RunAsClient`. This annotation
    tells Arquillian that you want to treat the deployment as a black box and execute
    the tests from outside the container. Not including the annotation would indicate
    to Arquillian that the tests are intended to be executed within the container.
    It’s also possible to mix the use of `@RunAsClient` on individual test methods,
    but in this case you’re testing entirely from outside the container.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 测试类上的另一个关键注解是 `@RunAsClient`。这个注解告诉 Arquillian，你想要将部署视为黑盒，并从容器外部执行测试。如果不包含这个注解，将向
    Arquillian 表明测试是打算在容器内执行的。还可能混合使用 `@RunAsClient` 在单个测试方法上，但在这个案例中，你是在容器外部完全测试。
- en: The test itself executes an HTTP GET request on `"/admin/category"` and converts
    the response JSON into a list of maps with key/value pairs. You verify that the
    size of the list you get back matches the number of `Category` records you know
    are present in the database, and then you retrieve the first map from the list
    and assert that the details on the `Category` match the root-level category in
    the database.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 测试本身在 `"/admin/category"` 上执行 HTTP GET 请求，并将响应 JSON 转换为包含键/值对的映射列表。你验证你得到的列表的大小与你知道数据库中存在的
    `Category` 记录数相匹配，然后从列表中检索第一个映射并断言 `Category` 的详细信息与数据库中的顶级类别匹配。
- en: 'As with the unit test, you execute your integration test with this:'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 与单元测试一样，你使用以下命令执行集成测试：
- en: '[PRE47]'
  id: totrans-735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As the test executes, you’ll see the Thorntail container starting and the SQL
    being executed to insert the initial category records into the database, as was
    discussed in [chapter 2](kindle_split_011.xhtml#ch02). With this first test run,
    you have one successful test with `Category-ResourceTest`, in addition to the
    existing `CategoryTest` unit tests.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 随着测试的执行，你会看到 Thorntail 容器启动，并执行 SQL 语句将初始类别记录插入数据库，正如在第 2 章中讨论的那样。在这个第一次测试运行中，你有一个成功的测试
    `Category-ResourceTest`，以及现有的 `CategoryTest` 单元测试。
- en: Let’s add a test for retrieving a single category directly, but also map the
    JSON you receive onto a `Category` object to verify that deserialization is working.
    This test differs from the previous one in that it uses a different method on
    the `EntityManager` from JPA to retrieve a single `Category` instead of all of
    them. There’s the double bonus that you’re testing additional methods on your
    JAX-RS resource, but also validating that your persistence and database entities
    are properly defined.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个直接检索单个类别的测试，同时将你接收到的 JSON 映射到 `Category` 对象上以验证反序列化是否正常工作。这个测试与之前的测试不同，因为它使用
    JPA 的 `EntityManager` 上的不同方法来检索单个 `Category` 而不是所有类别。双重奖励是，你不仅测试了你的 JAX-RS 资源上的额外方法，而且还验证了你的持久化和数据库实体是否正确定义。
- en: Listing 4.3\. Retrieve category in `CategoryResourceTest`
  id: totrans-738
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.3\. 在 `CategoryResourceTest` 中检索类别
- en: '[PRE48]'
  id: totrans-739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '***1*** Set a parameter into the request for categoryId.'
  id: totrans-740
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 在请求中设置一个参数用于 categoryId。'
- en: '***2*** Specify where in the URL path the categoryId should be added.'
  id: totrans-741
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 指定在 URL 路径中应添加 categoryId 的位置。'
- en: '***3*** Convert the JSON, via deserialization, you received into the Category
    instance.'
  id: totrans-742
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 通过反序列化将你收到的 JSON 转换为 Category 实例。'
- en: 'If you now execute the test again, your new test fails with this error:'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在再次执行测试，你的新测试会失败，并出现以下错误：
- en: '[PRE49]'
  id: totrans-744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Following that error in the log is the JSON message you received, but at the
    end it references the piece of data that caused the issue, `ejm.chapter4.admin.model.Category
    ["created"]`. From this, you know that the test had an issue deserializing the
    `created` field on `Category` into a `LocalDateTime` instance.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 在日志中的错误之后是您收到的 JSON 消息，但最后它引用了导致问题的数据片段，`ejm.chapter4.admin.model.Category ["created"]`。从这一点，你知道测试在将
    `Category` 上的 `created` 字段反序列化为 `LocalDateTime` 实例时遇到了问题。
- en: 'To resolve the problem, you need to give the JSON serialization library, in
    this case Jackson, help to convert your `LocalDateTime` instance into JSON that
    the library knows how to deserialize. To give Jackson help, you need to register
    a JAX-RS provider to add configuration to Jackson with the `JavaTimeModule`. First,
    though, you need to add a dependency to the pom.xml, making that available:'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，你需要给 JSON 序列化库，在这种情况下是 Jackson，提供帮助以将你的 `LocalDateTime` 实例转换为库知道如何反序列化的
    JSON。为了给 Jackson 提供帮助，你需要注册一个 JAX-RS 提供者，向 Jackson 添加配置 `JavaTimeModule`。不过，首先，你需要向
    pom.xml 添加一个依赖项，使其可用：
- en: '[PRE50]'
  id: totrans-747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now let’s look at the provider:'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看提供者：
- en: Listing 4.4\. `ConfigureJacksonProvider`
  id: totrans-749
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.4\. `ConfigureJacksonProvider`
- en: '[PRE51]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '***1*** Identify the class as a JAX-RS provider.'
  id: totrans-751
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 将类标识为 JAX-RS 提供者。'
- en: '***2*** Specify that this provider is used for resolving ObjectMapper instances'
  id: totrans-752
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 指定此提供者用于解析 ObjectMapper 实例'
- en: '***3*** Register JavaTimeModule with the Jackson mapper to correctly serialize
    LocalDateTime.'
  id: totrans-753
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 将 JavaTimeModule 与 Jackson mapper 注册以正确序列化 LocalDateTime。'
- en: Rerunning `mvn test`, you see the test pass. Another bug resolved by a test!
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行 `mvn test`，你会看到测试通过。另一个通过测试解决的错误！
- en: You’ve now covered two cases of retrieving categories from your RESTful endpoints.
    Let’s see whether your JAX-RS resource can store data as well.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经涵盖了从你的 RESTful 端点检索类别的两种情况。让我们看看你的 JAX-RS 资源是否也能存储数据。
- en: Listing 4.5\. Create category in `CategoryResourceTest`
  id: totrans-756
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.5\. 在 `CategoryResourceTest` 中创建类别
- en: '[PRE52]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '***1*** Indicate you’re sending JSON in the HTTP request.'
  id: totrans-758
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 指明您正在发送JSON到HTTP请求。'
- en: '***2*** Set the Category instance you created as the body of the request.'
  id: totrans-759
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 将您创建的类别实例设置为请求的主体。'
- en: '***3*** Verify you received a response of 201, and the category was created.'
  id: totrans-760
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 确认您收到了状态码为201的响应，并且已成功创建了类别。'
- en: '***4*** Location will be the URL of the Category that was created for you.'
  id: totrans-761
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** 位置将是为您创建的类别的URL。'
- en: '***5*** Extract the ID of the Category you created from the Location.'
  id: totrans-762
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** 从位置中提取您创建的类别的ID。'
- en: '***6*** Assert that the total number of categories retrieved is now 22 and
    not 21.'
  id: totrans-763
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** 断言检索到的类别总数现在是22而不是21。'
- en: '***7*** Set a path parameter to be the category ID you retrieved from Location
    for a new GET request.'
  id: totrans-764
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7*** 为新的GET请求设置路径参数，即从位置检索到的类别ID。'
- en: '***8*** Set the path for the request, defining where the parameter for the
    category ID needs to be replaced.'
  id: totrans-765
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8*** 设置请求的路径，定义需要替换类别ID参数的位置。'
- en: '***9*** Deserialize the JSON you received into a Category instance.'
  id: totrans-766
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9*** 将您收到的JSON反序列化为类别实例。'
- en: '***10*** Validate that the ID on the category matches what you extracted from
    Location.'
  id: totrans-767
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***10*** 验证类别的ID与您从位置提取的ID相匹配。'
- en: The preceding test starts by creating a new `Category` instance and setting
    appropriate values on it, including setting a parent with `id` of `1009`. Next
    you submit a POST request to the RESTful endpoint for `Category` to create a new
    record. You validate that the response you received was correct and extract the
    new `id` for the category. Then you retrieve all the categories and validate that
    you now have 22 records instead of 21, and finally retrieve the new record and
    validate that its information is the same as what you submitted when you created
    it.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的测试首先创建一个新的`Category`实例，并在其上设置适当的值，包括设置具有`id`为`1009`的父类别。接下来，您向`Category`的RESTful端点提交POST请求以创建新记录。您验证收到的响应是否正确，并提取类别的新的`id`。然后，您检索所有类别并验证现在有22条记录而不是21条，最后检索新记录并验证其信息与您创建时提交的信息相同。
- en: 'Let’s run `mvn test` again to see whether your code has any bugs! This time,
    your test fails because it expected to receive an HTTP status code of 201, but
    you received 500 instead. What went wrong? If you trace back through the terminal
    output, you can see the microservice experienced an error:'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次运行`mvn test`以查看您的代码是否存在任何错误！这次，您的测试失败，因为它期望收到状态码为201的HTTP响应，但您收到了500。发生了什么？如果您通过终端输出回溯，您可以看到微服务遇到了错误：
- en: '[PRE53]'
  id: totrans-770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: You can see it’s not able to save the link to the parent category that you specified.
    That’s because the instance you provided to POST doesn’t have any data on it that
    helps the persistence layer understand that this instance is already saved.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到它无法保存您指定的父类别的链接。这是因为您提供给POST的实例上没有任何数据可以帮助持久层理解这个实例已经被保存。
- en: To resolve this, you need to have your RESTful method for creation retrieve
    the persistence object for the parent category before you attempt to save your
    new one.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个问题，您需要在尝试保存新的类别之前，从持久层检索父类别的持久化对象。
- en: Listing 4.6\. `CategoryResource`
  id: totrans-773
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.6\. `CategoryResource`
- en: '[PRE54]'
  id: totrans-774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '***1*** Check that you have a parent category and ID before trying to retrieve
    it.'
  id: totrans-775
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 在尝试检索之前，检查您是否有一个父类别及其ID。'
- en: '***2*** Get the parent category and set it on the new category instance.'
  id: totrans-776
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 获取父类别并将其设置到新的类别实例上。'
- en: All you’ve done is add into `create()` the ability to retrieve a valid parent
    category from the persistence layer, and then set it onto your new category instance.
    Everything else in the method is as it was from [chapter 2](kindle_split_011.xhtml#ch02).
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 您所做的一切就是在`create()`方法中添加了从持久层检索有效父类别的功能，然后将它设置到新的类别实例上。该方法中的其他一切都与[第2章](kindle_split_011.xhtml#ch02)中的内容相同。
- en: Rerunning `mvn test`, you now see all tests pass! Let’s add one more test, to
    see whether your error handling can properly reject a bad request.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行`mvn test`，您现在看到所有测试都通过了！让我们添加一个额外的测试，以查看您的错误处理是否能够正确拒绝一个无效的请求。
- en: Listing 4.7\. Fail to create category in `CategoryResourceTest`
  id: totrans-779
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.7\. 在`CategoryResourceTest`中未能创建类别
- en: '[PRE55]'
  id: totrans-780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '***1*** Create a Category instance with no name set.'
  id: totrans-781
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 创建一个未设置名称的类别实例。'
- en: '***2*** Should receive HTTP status code 400.'
  id: totrans-782
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 应该收到HTTP状态码400。'
- en: '***3*** Validate you still have only 22 categories in the database.'
  id: totrans-783
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 验证数据库中仍然只有22个类别。'
- en: Running `mvn test` with this new test method results in a failure. Your test
    is expecting a response code of 400, but you receive 500 instead.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个新的测试方法运行 `mvn test` 会导致失败。你的测试期望得到一个400响应码，但你收到了500。
- en: 'Scrolling through the terminal output, you see this:'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动查看终端输出，你看到如下内容：
- en: '[PRE56]'
  id: totrans-786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Though that’s the correct error you’d expect to see in the logs, your microservice
    isn’t handling the error properly. On completion of the RESTful method, the transaction
    was trying to commit the database changes, but that failed because you didn’t
    have a valid `Category` instance.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是你预期在日志中看到的正确错误，但你的微服务并没有正确处理这个错误。在完成RESTful方法后，事务试图提交数据库更改，但失败了，因为你没有有效的`Category`实例。
- en: You need to bring forward the point at which the validation occurs, so that
    your method can properly handle it and return the response code you desire ([listing
    4.8](#ch04ex08)).
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要提前验证发生的点，以便你的方法可以正确处理它并返回你想要的响应码（[列表4.8](#ch04ex08)）。
- en: Listing 4.8\. `CategoryResource.create()`
  id: totrans-789
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.8\. `CategoryResource.create()`
- en: '[PRE57]'
  id: totrans-790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '***1*** Flush the changes present in the entity manager.'
  id: totrans-791
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 清除实体管理器中存在的更改。'
- en: '***2*** Catch any constraint-specific exceptions.'
  id: totrans-792
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 捕获任何特定的约束异常。'
- en: '***3*** Return the response with 400 status code and error messages.'
  id: totrans-793
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 返回带有400状态码和错误信息的响应。'
- en: All you’ve done here is modify `create()` to flush the changes in the entity
    manager, which causes the validation to be triggered, and then catch any constraint
    violations to return a response. Running `mvn test` with this change now allows
    the test to pass, because it’s now returning the correct response code.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这里所做的所有事情只是修改了`create()`以清除实体管理器中的更改，这触发了验证，然后捕获任何约束违规并返回一个响应。现在使用这个更改运行`mvn
    test`允许测试通过，因为它现在返回了正确的响应码。
- en: Integration testing is a crucial piece that all microservices need. As you’ve
    just seen, it’ll quickly identify potential failure points in integrating with
    external systems, such as a database, caused by situations that the existing code
    wasn’t written to handle. Integrating with databases and transferring data via
    HTTP requests are two common uses for which problems with your existing code can
    be exposed.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试是所有微服务都需要的关键部分。正如你所看到的，它能够快速识别与外部系统（如数据库）集成时可能出现的潜在故障点，这些故障点是由现有代码未编写来处理的情况引起的。与数据库集成并通过HTTP请求传输数据是两种常见的用途，在这些用途中，你现有代码中的问题可能会暴露出来。
- en: Developers are human; we make mistakes. Proper integration testing is a key
    way to ensure that you’ve developed code that matches what’s expected. It’s often
    a good idea to have a different developer create these types of tests, because
    another developer won’t have any preconceived notions about how the code works
    and will be concerned only with testing the required functionality of the microservice.
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者都是人，我们会犯错误。适当的集成测试是确保你开发的代码符合预期的关键方式。通常，让不同的开发者创建这些类型的测试是个好主意，因为另一个开发者不会有任何关于代码如何工作的先入为主的观念，他们只会关注测试微服务的所需功能。
- en: 4.5\. Consumer-driven contract testing
  id: totrans-797
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5\. 消费者驱动的契约测试
- en: When developing a microservice, you don’t necessarily have real consumers of
    your service available to test against. But if a service can be provided with
    details of what a consumer will pass on a request, and what the expected response
    is, then you can execute those expectations against your real service to ensure
    that you meet them. What better way to validate that your service’s API works
    than a consumer specifying what it’s expecting for you to test with!
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发微服务时，你并不一定有真实的服务消费者来测试。但如果一个服务可以提供消费者将在请求中传递的详细信息以及预期的响应，那么你可以针对你的真实服务执行这些预期，以确保你满足它们。还有什么比消费者指定你用来测试的期望来验证你的服务API工作得更好呢！
- en: '*Consumer-driven contract testing* uses this approach, as you’re testing both
    a consumer and a provider to ensure that proper information is passed between
    them. How do you do that? [Figure 4.2](#ch04fig02) shows how to use a *mock server*
    to capture requests from a consumer, and return the response that was defined
    for that request.'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: '*消费者驱动的契约测试*使用这种方法，因为你正在测试消费者和提供者以确保他们之间传递了适当的信息。你如何做到这一点？[图4.2](#ch04fig02)展示了如何使用*模拟服务器*捕获消费者的请求，并返回为该请求定义的响应。'
- en: Figure 4.2\. Mock responses to a client request
  id: totrans-800
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.2\. 对客户端请求的模拟响应
- en: '![](Images/04fig02_alt.jpg)'
  id: totrans-801
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/04fig02_alt.jpg)'
- en: Bear in mind, the response being returned is what the developer of the consumer
    thinks should be returned. This expectation can easily differ from the service’s
    response, but then again, finding those types of problems is the benefit of this
    type of testing.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，返回的响应是消费者开发者认为应该返回的内容。这种期望可能很容易与服务的响应不同，但再次强调，发现这类问题是这种测试的好处。
- en: By executing what’s shown in [figure 4.2](#ch04fig02), a *contract* of what
    the consumer is expecting to send and receive when communicating with the provider
    microservice can be created. [Figure 4.3](#ch04fig03) shows how it’s then possible
    to replay those requests on your service, with the service returning a response
    based on its actual code. Then each response received from the service can be
    compared against what’s expected, to ensure that both consumer and provider are
    in agreement about what should occur.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行[图4.2](#ch04fig02)中所示的内容，可以创建一个*合同*，说明消费者在与提供者微服务通信时期望发送和接收的内容。[图4.3](#ch04fig03)显示了如何在您的服务上重新播放这些请求，并且服务根据其实际代码返回响应。然后可以将从服务收到的每个响应与预期内容进行比较，以确保消费者和提供者对应该发生的事情达成一致。
- en: Figure 4.3\. Requests sent to the microservice
  id: totrans-804
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.3\. 发送到微服务的请求
- en: '![](Images/04fig03_alt.jpg)'
  id: totrans-805
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/04fig03_alt.jpg)'
- en: A popular tool for testing these concepts is Pact ([https://docs.pact.io/](https://docs.pact.io/)),
    which you’ll use in [listing 4.10](#ch04ex10). The process sounds tricky, but
    it’s not too bad when using Pact. Pact is a family of frameworks that makes it
    easy to create and use tests for consumer-driven contracts.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 测试这些概念的一个流行工具是Pact ([https://docs.pact.io/](https://docs.pact.io/))，你将在[列表4.10](#ch04ex10)中使用它。这个过程听起来很复杂，但使用Pact时并不太糟糕。Pact是一系列框架，它使得创建和使用消费者驱动的合同测试变得容易。
- en: The first thing you need to do is create a consumer that’s trying to integrate
    with the admin microservice, shown next. In chapter4/admin-client, you have the
    following consumer.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 首件事是创建一个尝试与行政微服务集成的消费者，如下所示。在chapter4/admin-client中，您有以下消费者。
- en: Listing 4.9\. `AdminClient`
  id: totrans-808
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.9\. `AdminClient`
- en: '[PRE58]'
  id: totrans-809
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '***1*** Constructor for AdminClient that takes the URL representing the admin
    microservice'
  id: totrans-810
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** AdminClient的构造函数，它接受表示管理微服务的URL'
- en: '***2*** Method to retrieve a single Category by its ID'
  id: totrans-811
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 通过ID检索单个类别的方法'
- en: '***3*** Use Jackson to map the response JSON into Category, registering the
    JavaTimeModule as well.'
  id: totrans-812
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 使用Jackson将响应JSON映射到Category，并注册JavaTimeModule。'
- en: 'You now have a basic client for interacting with the admin microservice. To
    have Pact create the necessary contract for it, you need to add it as a dependency
    in pom.xml:'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在有一个基本的客户端，可以与行政微服务交互。为了使Pact为它创建必要的合同，您需要将其添加到pom.xml中作为依赖项：
- en: '[PRE59]'
  id: totrans-814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This dependency specifies that you’ll be using JUnit to generate the contract.
    Let’s create a JUnit test to generate the contract.
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 这个依赖项指定您将使用JUnit生成合同。让我们创建一个JUnit测试来生成合同。
- en: Listing 4.10\. `ConsumerPactTest`
  id: totrans-816
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.10\. `ConsumerPactTest`
- en: '[PRE60]'
  id: totrans-817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '***1*** Extend ConsumerPactTestMk2 to have the required integration hooks for
    Pact and JUnit.'
  id: totrans-818
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 将ConsumerPactTestMk2扩展到具有Pact和JUnit所需的集成钩子。'
- en: '***2*** Helper method for creating categories with the required creation date'
  id: totrans-819
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 用于创建具有所需创建日期的类别的辅助方法'
- en: '***3*** Return the Pact that the consumer expects.'
  id: totrans-820
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 返回消费者期望的Pact。'
- en: '***4*** Define what should be received as a response based on the request that’s
    received.'
  id: totrans-821
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** 根据接收到的请求定义应接收的响应。'
- en: '***5*** Set a unique name for the provider.'
  id: totrans-822
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** 为提供者设置一个独特的名称。'
- en: '***6*** Set a unique name for the consumer.'
  id: totrans-823
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** 为消费者设置一个独特的名称。'
- en: '***7*** Which version of the Pact specification you should use for the contract'
  id: totrans-824
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7*** 应该为合同使用哪个版本的Pact规范'
- en: '***8*** Run the AdminClient against the Pact mock server and verify the expected
    results.'
  id: totrans-825
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8*** 运行AdminClient针对Pact模拟服务器，并验证预期的结果。'
- en: 'Though there’s a lot here, the listing boils down to the following:'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这里有很多内容，但列表归结为以下几点：
- en: A method that identifies what should be returned from a request to the admin
    microservice, given a particular response it receives. This is what Pact uses
    to mock the provider side of the contract creation process.
  id: totrans-827
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个识别从对管理微服务的请求中应该返回什么的方法，给定它接收的特定响应。这是Pact用于模拟合同创建过程中提供者一侧的方法。
- en: A method to use your client code that interacts with the mock server from Pact,
    and verifies that the response object you receive has the appropriate values.
  id: totrans-828
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个使用您的客户端代码与Pact的模拟服务器交互的方法，并验证您收到的响应对象具有适当的值。
- en: Running `mvn test` will then execute the JUnit Pact test and produce a JSON
    file in /chapter4/admin-client/target/pacts.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行 `mvn test` 将执行 JUnit Pact 测试，并在 /chapter4/admin-client/target/pacts 生成一个
    JSON 文件。
- en: Listing 4.11\. Pact JSON output
  id: totrans-830
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.11\. Pact JSON 输出
- en: '[PRE61]'
  id: totrans-831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '|  |'
  id: totrans-832
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-833
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: For brevity, I’ve included only the start of the JSON that’s generated, because
    all the response data is lengthy.
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，我只包括了生成的 JSON 的开头，因为所有响应数据都很长。
- en: '|  |'
  id: totrans-835
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'With this JSON file generated, you can now set up the other side of consumer-driven
    contract testing: verifying that the provider works as the consumer expects it
    to.'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个生成的 JSON 文件，你现在可以设置消费者驱动合同测试的另一部分：验证提供者是否按消费者期望的方式工作。
- en: For simplicity, I’ve manually copied the generated JSON across to /chapter4/admin/src/test/resources/pacts.
    For serious testing with continuous integration, Pact has other ways to store
    the JSON so that it can be automatically retrieved when running the provider test.
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，我手动将生成的 JSON 复制到了 /chapter4/admin/src/test/resources/pacts。对于需要持续集成的严肃测试，Pact
    有其他方式来存储 JSON，以便在运行提供者测试时自动检索。
- en: For verifying the provider, because you require an instance of the admin microservice
    to be running, you’ll use Maven to execute the Pact verification. The verification
    will take place in the integration test phase of Maven. First you modify your
    pom.xml to start and stop the Thorntail container around the integration test
    phase.
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证提供者，因为你需要一个正在运行的 admin 微服务实例，你将使用 Maven 执行 Pact 验证。验证将在 Maven 的集成测试阶段进行。首先，你修改你的
    pom.xml 文件，在集成测试阶段启动和停止 Thorntail 容器。
- en: Listing 4.12\. Thorntail Maven plugin execution for integration tests
  id: totrans-839
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.12\. Thorntail Maven 插件执行集成测试
- en: '[PRE62]'
  id: totrans-840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '***1*** Start the microservice during the pre-integration-test phase of Maven.'
  id: totrans-841
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 在 Maven 的预集成测试阶段启动微服务。'
- en: '***2*** Define locations for the logs of the microservice.'
  id: totrans-842
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 定义微服务的日志位置。'
- en: '***3*** Stop the microservice in the post-integration-test phase.'
  id: totrans-843
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 在集成测试阶段停止微服务。'
- en: Next you add the Pact plugin to execute the contract against your provider.
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将 Pact 插件添加到执行针对你的提供者的合同。
- en: Listing 4.13\. Pact Maven plugin execution
  id: totrans-845
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.13\. Pact Maven 插件执行
- en: '[PRE63]'
  id: totrans-846
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '***1*** Define the location of the admin microservice provider.'
  id: totrans-847
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 定义管理微服务提供者的位置。'
- en: '***2*** Set the directory where the Pact contract files can be found.'
  id: totrans-848
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 设置 Pact 合同文件可以找到的目录。'
- en: '***3*** Pact verification runs during the integration-test phase of Maven.'
  id: totrans-849
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** Pact 验证在 Maven 的集成测试阶段运行。'
- en: '***4*** Use the verify goal of the Pact plugin.'
  id: totrans-850
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** 使用 Pact 插件的 verify 目标。'
- en: 'Running `mvn verify` will execute all the tests you’d defined previously, but
    also run the Pact verification as the last step. You should see output in the
    terminal to indicate it succeeded:'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `mvn verify` 将执行你之前定义的所有测试，但也将作为最后一步运行 Pact 验证。你应该在终端中看到表示它成功的输出：
- en: '[PRE64]'
  id: totrans-852
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Well, that was smooth, but what does it look like if it doesn’t work? To try
    that out, you can add the following code into the `CategoryResource.get()` method,
    before the current `return` statement, so that you return a different category
    for your Pact test:'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这很顺利，但如果它不起作用会是什么样子？为了尝试这一点，你可以在 `CategoryResource.get()` 方法中，在当前的 `return`
    语句之前添加以下代码，以便为你的 Pact 测试返回不同的类别：
- en: '[PRE65]'
  id: totrans-854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'If you now run the test with `mvn verify` again, you’ll see a test failure
    with output containing the following:'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在再次使用 `mvn verify` 运行测试，你将看到包含以下内容的测试失败输出：
- en: '[PRE66]'
  id: totrans-856
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This log message provides detailed information about what crucial data, such
    as ID and name, it found for each category in the hierarchy, and how that differs
    from what the Pact contract had defined.
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 这条日志消息提供了关于它在每个类别中找到的至关重要的数据（如 ID 和名称）的详细信息，以及它与 Pact 合同定义的差异。
- en: As mentioned previously, such a discrepancy could be a result of an invalid
    assumption on the part of the consumer, or a bug in the provider. What such a
    failure really indicates is that developers from the consumer and provider sides
    need to discuss how the API needs to operate.
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这种差异可能是消费者方面的无效假设或提供者中的错误的结果。这种失败真正表明的是，消费者和提供者方面的开发者需要讨论 API 需要如何操作。
- en: 4.6\. Additional reading
  id: totrans-859
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.6\. 额外阅读
- en: As I mentioned earlier, there are many other types of testing I won’t be covering.
    A couple of the critical ones are user acceptance testing and end-to-end testing.
    Though they are both crucial to ensuring that adequate testing is performed, they’re
    beyond the scope of this book because they deal with a higher level of testing.
    For additional information on testing with microservices, I recommend *Testing
    Java Microservices* by Alex Soto Bueno, Jason Porter, and Andy Gumbrecht (Manning,
    2018).
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，还有许多其他类型的测试我不会涉及。其中两个关键的是用户验收测试和端到端测试。尽管它们对于确保进行充分的测试都至关重要，但它们超出了本书的范围，因为它们涉及更高层次的测试。关于使用微服务的测试的更多信息，我推荐Alex
    Soto Bueno、Jason Porter和Andy Gumbrecht的《Testing Java Microservices》（Manning，2018）。
- en: 4.7\. Additional exercises
  id: totrans-861
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.7. 额外练习
- en: Here are some additional tests that you could write to experiment with the different
    testing methods, and also help improve the code for the example!
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些额外的测试，你可以编写来尝试不同的测试方法，并帮助改进示例代码的代码！
- en: Add a method to `CategoryResourceTest` that verifies the ability to update `Category`.
  id: totrans-863
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向`CategoryResourceTest`添加一个方法来验证更新`Category`的能力。
- en: Add a method to `CategoryResourceTest` to verify that `Category` can be removed
    from the database successfully.
  id: totrans-864
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向`CategoryResourceTest`添加一个方法来验证`Category`可以从数据库中成功删除。
- en: Add methods to `AdminClient` for retrieving all categories, adding a category,
    updating a category, and removing a category. Then add the request/response pairs
    in `ConsumerPactTest.createPact()` for the new methods, and update `ConsumerPactTest.runTest()`
    to execute and verify each of them.
  id: totrans-865
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向`AdminClient`添加方法以检索所有类别、添加类别、更新类别和删除类别。然后在`ConsumerPactTest.createPact()`中添加新方法的需求/响应对，并更新`ConsumerPactTest.runTest()`以执行和验证每个方法。
- en: If you take on any of these exercises and would like to see them included in
    the code for the book, please submit a pull request to the project on GitHub.
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你承担了这些练习中的任何一个，并希望看到它们包含在本书的代码中，请向GitHub上的项目提交一个pull请求。
- en: Summary
  id: totrans-867
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Unit testing is important, but the need to test doesn’t end there. You need
    to test all aspects of a service as realistically as possible.
  id: totrans-868
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试很重要，但测试的需求并不止于此。你需要尽可能真实地测试服务的各个方面。
- en: Arquillian is a great framework for simplifying more-complex testing that requires
    a runtime container to interact with and provide near-production execution.
  id: totrans-869
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arquillian是一个简化需要与运行时容器交互并提供近似生产级执行的更复杂测试的出色框架。
- en: The key to microservice testing is ensuring that the contract that a microservice
    defines, the API it exposes, is tested against not only what the microservice
    intends to expose, but also what a client is expecting to pass and receive.
  id: totrans-870
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务测试的关键是确保微服务定义的合同、它暴露的API不仅针对微服务打算暴露的内容进行测试，而且还要针对客户端期望传递和接收的内容进行测试。
- en: Chapter 5\. Cloud native development
  id: totrans-871
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第5章. 云原生开发
- en: '*This chapter covers*'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Why is the cloud important?
  id: totrans-873
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云为什么很重要？
- en: What is cloud native development?
  id: totrans-874
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是云原生开发？
- en: What do you need to deploy your microservice to the cloud?
  id: totrans-875
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要什么来将你的微服务部署到云中？
- en: How does your application scale in the cloud?
  id: totrans-876
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的应用程序如何在云中扩展？
- en: Can you test your application in the cloud before production?
  id: totrans-877
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你能在生产之前在云中测试你的应用程序吗？
- en: In this chapter, you’ll extend the admin service from [chapter 4](kindle_split_013.xhtml#ch04),
    giving it the ability to be deployed to a local cloud environment, and then run
    tests against the service deployed to that environment.
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将扩展来自[第4章](kindle_split_013.xhtml#ch04)的管理服务，使其能够部署到本地云环境，然后对该环境中部署的服务进行测试。
- en: First, you’ll learn what *cloud* means and about the cloud providers you have
    to choose from. You’ll also explore your options for running the cloud on your
    local machine. After you’ve chosen a type of cloud, you’ll modify the admin service
    from [chapter 4](kindle_split_013.xhtml#ch04) to deploy into the cloud. After
    completing deployment, you’ll scale the application to show how it can handle
    the additional load, and finish up by running tests with your application deployed
    in the cloud.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你将学习*云*的含义以及你必须从中选择的云服务提供商。你还将探索在本地机器上运行云的选项。在你选择了一种云类型之后，你将修改来自[第4章](kindle_split_013.xhtml#ch04)的管理服务以部署到云中。完成部署后，你将扩展应用程序以展示它如何处理额外的负载，并通过在云中部署应用程序运行测试来完成。
- en: 5.1\. What is the cloud anyway?
  id: totrans-880
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1. 云到底是什么？
- en: The cloud, and cloud computing, have been present in software engineering for
    decades. These terms are usually used in reference to a platform for distributed
    computing. It wasn’t until the early to mid-1990s that their use became more prevalent.
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 云和云计算已经存在于软件工程领域几十年了。这些术语通常用于指代分布式计算的平台。直到20世纪90年代初，它们的使用才变得更加普遍。
- en: 'Some of the key benefits of the cloud are as follows:'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 云的一些关键好处如下：
- en: '***Cost efficiencies*—** Most cloud providers charge enterprises to use their
    services as a measure of CPU time that’s spent. This significantly reduces the
    overall cost of running the environments compared to physical machines.'
  id: totrans-883
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***成本效益***—**大多数云服务提供商根据消耗的CPU时间来向企业收费。与物理机器相比，这显著降低了运行环境的总体成本。'
- en: '***Ability to scale*—** Cloud providers provide ways to scale up and down individual
    services as required, ensuring that you never have too much or too little capacity.
    The spread of information can occur quickly, thanks to social media, so being
    able to immediately scale up identical instances to handle immediate short-term
    load is crucial. How quickly can an enterprise scale up when it takes months to
    purchase and provision just one machine? In such a situation, the cloud provider
    will provide scale by replicating instances with identical configuration of memory,
    CPU, and so forth.'
  id: totrans-884
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***可扩展性***—**云服务提供商提供按需扩展和缩减单个服务的方法，确保你不会有过多的或过少的容量。由于社交媒体的普及，信息的传播可以非常迅速，因此能够立即扩展相同配置的实例来处理即时短期负载至关重要。当购买和配置一台机器需要数月时间时，企业如何快速扩展？在这种情况下，云服务提供商将通过复制具有相同内存、CPU配置等的实例来提供扩展。'
- en: '***Freedom of choice*—** If you work for an enterprise that develops only in
    Java, because that’s what its operations team knows how to manage, how do you
    experiment with new programming languages such as Node.js or Go? Cloud brings
    additional languages to your fingertips like never before. You don’t need to have
    internal experience maintaining environments for new languages; that’s what a
    cloud provider is for!'
  id: totrans-885
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***选择自由***—**如果你在一家只使用Java进行开发的企业的员工，因为这是其运维团队知道如何管理的方式，你如何尝试新的编程语言，如Node.js或Go？云以前所未有的方式将额外的语言带到了你的指尖。你不需要有维护新语言环境的内部经验；这正是云服务提供商的作用所在！'
- en: 5.2\. Service models
  id: totrans-886
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2\. 服务模型
- en: '[Figure 5.1](#ch05fig01) shows the multiple types of service models for the
    cloud, along with where an application fits within that. In this illustration,
    an application has code on the server. If you have an application that’s purely
    mobile or is browser based that interacts with one or more services via Software
    as a Service (SaaS), it’s still an application, but not an application as depicted
    here. In this context, an application could be an executable JAR, or a WAR or
    EAR deployed to an application server.'
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.1](#ch05fig01) 展示了云服务的多种服务模型，以及应用程序在该模型中的位置。在这个示例中，应用程序在服务器上有代码。如果你有一个纯移动或基于浏览器的应用程序，它通过软件即服务（SaaS）与一个或多个服务交互，它仍然是一个应用程序，但不是像这里所描述的那样。在这种情况下，应用程序可能是一个可执行的JAR文件，或者是一个部署到应用服务器的WAR或EAR文件。'
- en: Figure 5.1\. Service models in the cloud
  id: totrans-888
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.1\. 云中的服务模型
- en: '![](Images/05fig01_alt.jpg)'
  id: totrans-889
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig01_alt.jpg)'
- en: 'Let’s briefly describe each of these layers:'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要描述每一层：
- en: '***Infrastructure as a Service* (IaaS)—** Provides an abstraction over network
    infrastructure that includes computing resources, data partitioning, scaling,
    security, and backup. IaaS usually involves a hypervisor that runs virtual machines
    as guests. To use an IaaS requires constructing a virtual machine that could be
    deployed to the environment. Some well-known IaaS providers are Amazon Web Services,
    OpenStack, Google Compute Engine, and Microsoft Azure.'
  id: totrans-891
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***基础设施即服务* (IaaS)**—**提供对包括计算资源、数据分区、扩展、安全和备份在内的网络基础设施的抽象。IaaS通常涉及运行虚拟机的虚拟机管理程序。要使用IaaS，需要构建一个可以部署到环境中的虚拟机。一些知名的IaaS提供商包括亚马逊网络服务、OpenStack、谷歌计算引擎和微软Azure。'
- en: '***Platform as a Service* (PaaS)—** Forms the layer above IaaS to provide a
    development environment that includes an operating system, an execution environment
    for various programming languages, databases, and web servers. A PaaS saves a
    developer from needing to purchase, install, and configure hardware and software
    to have an environment for deploying an application. Popular PaaS providers include
    Red Hat OpenShift, Amazon Web Services, Google App Engine, IBM Bluemix, Cloud
    Foundry, Microsoft Azure, and Heroku.'
  id: totrans-892
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***平台即服务*（PaaS）——** 位于IaaS之上，提供包括操作系统、各种编程语言的执行环境、数据库和Web服务器的开发环境。PaaS可以节省开发者购买、安装和配置硬件和软件以部署应用程序的环境。流行的PaaS提供商包括Red
    Hat OpenShift、Amazon Web Services、Google App Engine、IBM Bluemix、Cloud Foundry、Microsoft
    Azure和Heroku。'
- en: '***Software as a Service* (SaaS)—** Provides common pieces of applications,
    or sometimes entire applications, on an as-needed or on-demand basis. SaaS is
    usually charged on a pay per use basis. What’s offered as a SaaS can vary from
    a niche service, such as everything related to marketing, to an entire suite of
    SaaS to manage a business from beginning to end. Many SaaS providers exist, and
    more are cropping up every day. Some of the well-known ones are [Salesforce.com](http://Salesforce.com),
    Eloqua, NetSuite, and Cloud9.'
  id: totrans-893
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***软件即服务*（SaaS）——** 根据需要或按需提供应用程序的常见组件，有时甚至提供整个应用程序。SaaS通常按使用付费。作为SaaS提供的可以是从营销相关的利基服务到从开始到结束管理整个业务的全套SaaS。存在许多SaaS提供商，并且每天都有更多出现。其中一些知名的有[Salesforce.com](http://Salesforce.com)、Eloqua、NetSuite和Cloud9。'
- en: Over the last couple of years—with the rise of containers, and in particular
    the growth and popularity of Docker as a container solution—a new layer has been
    created in cloud service models.
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中——随着容器（尤其是作为容器解决方案的Docker的增长和普及）的兴起——云服务模型中已经创建了一个新的层次。
- en: '[Figure 5.2](#ch05fig02) introduces *Containers as a Service* (CaaS) as a new
    foundation for PaaS providers. CaaS takes advantage of container technology, such
    as Docker, to simplify the deployment, scaling, and management of multiple applications
    or services. Containers allow you to package any application or service into its
    own operating system environment, with whatever custom software or configuration
    might be required, while also being able to reduce the size of the image that’s
    generated when compared to traditional virtual machines.'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.2](#ch05fig02) 介绍了作为PaaS提供商新基础的*容器即服务*（CaaS）。CaaS利用容器技术，如Docker，简化了多个应用程序或服务的部署、扩展和管理。容器允许您将任何应用程序或服务打包到其自己的操作系统环境中，无论可能需要什么自定义软件或配置，同时还能减少与传统虚拟机相比生成的镜像大小。'
- en: Figure 5.2\. Service models in the cloud with containers
  id: totrans-896
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.2\. 云中的容器服务模型
- en: '![](Images/05fig02_alt.jpg)'
  id: totrans-897
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig02_alt.jpg)'
- en: The other major advantage to CaaS, and containers in general, is their immutable
    nature. Because a container image is derived from a specific version of that container,
    updating that container in any way requires a new container image and version
    to be built. Mutable deployments have long been an issue with deploying to internally
    managed servers, because operations could update something on the system and potentially
    break an application. Immutable container images can then be sent through CI/CD
    processes to verify that the container performs as expected before being released
    in production.
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: CaaS（容器即服务）的另一个主要优势，以及容器的一般优势，是它们的不可变性。因为容器镜像是从特定版本的容器派生出来的，所以以任何方式更新该容器都需要构建一个新的容器镜像和版本。可变部署长期以来一直是部署到内部管理的服务器的问题，因为操作可能会在系统上更新某些内容，从而可能破坏应用程序。不可变容器镜像可以随后通过CI/CD流程发送，以验证容器在发布到生产之前是否按预期运行。
- en: Currently, the most popular CaaS provider is Kubernetes. Kubernetes was created
    by Google and was heavily influenced by the way it managed containerized applications
    internally. Previous PaaS providers already have shifted to be built on top of
    a CaaS, and in particular Kubernetes. Red Hat OpenShift is one such PaaS that
    now takes advantage of Kubernetes as its CaaS.
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，最受欢迎的CaaS提供商是Kubernetes。Kubernetes由Google创建，并受到了其内部管理容器化应用程序的方式的强烈影响。之前的PaaS提供商已经转向在CaaS之上构建，特别是Kubernetes。Red
    Hat OpenShift就是这样一种PaaS，现在它利用Kubernetes作为其CaaS。
- en: CaaS is the best way to manage deployments, but you don’t always want something
    that low level. Generally, our ideal environment is a PaaS that’s built on top
    of a CaaS, such as with Red Hat OpenShift.
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: CaaS 是管理部署的最佳方式，但你并不总是想要一个如此低级别的解决方案。通常，我们理想的环境是在 CaaS 之上构建的 PaaS，例如 Red Hat
    OpenShift。
- en: 5.3\. Cloud native development
  id: totrans-901
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3\. 云原生开发
- en: You may have heard the term *cloud native development* before, but new terms
    are always cropping up, so it doesn’t hurt to clarify the definition. *Cloud native
    development* is the process of developing an application or service for deployment
    to cloud environments, where it can take advantage of loosely coupled cloud services.
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能之前听说过 *云原生开发* 这个术语，但新术语总是层出不穷，所以澄清定义是有好处的。*云原生开发* 是指为部署到云环境中的应用或服务进行开发的过程，在那里它可以利用松散耦合的云服务。
- en: Shifting to this type of development requires an alteration in mindset when
    developing, as you’re no longer concerned with the details of external services
    that an application requires. All you need to know is that there will be a service,
    such as a database, available to your application in the cloud, and which environment
    variables you might require to connect with it.
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 转向这种类型的开发需要在开发时改变思维方式，因为你不再关心应用程序所需的外部服务的细节。你所需要知道的是，云中将有服务，例如数据库，可供你的应用程序使用，以及你可能需要连接它的环境变量。
- en: You can also look at cloud native development from another angle, in that it
    abstracts away much of what your application or service requires to function correctly.
    Cloud native development allows the developer to expend effort on things that
    add business value, by focusing on developing business logic and not plumbing
    code.
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以从另一个角度看待云原生开发，即它抽象掉了你的应用或服务正常运行所需的大部分内容。云原生开发允许开发者将精力集中在增加业务价值的事情上，通过专注于开发业务逻辑而不是管道代码。
- en: Though not present with most cloud providers, the idea of a service catalog
    is being introduced into Kubernetes for just this purpose. A *service catalog*
    provides a definition of services that can be connected to within the cloud, along
    with the environment variables that are required to connect with them. It’s then
    possible for a service to specify criteria about an external service it needs
    to connect to. Criteria could include `database` and `postgresql`, which would
    translate into a PostgreSQL database instance from the service catalog.
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大多数云服务提供商没有提供，但服务目录的概念正是为了这个目的被引入到 Kubernetes 中。一个 *服务目录* 提供了可以在云中连接的服务定义，以及连接它们所需的配置变量。然后，一个服务可以指定它需要连接的外部服务的标准。这些标准可能包括
    `数据库` 和 `postgresql`，这将从服务目录中转换为一个 PostgreSQL 数据库实例。
- en: This concept isn’t that much different from providing environment-specific configuration
    for databases, as we’ve done for many years. But as work on the service catalog
    continues, we may reach a point where an application connecting to an external
    service through specific environment variables is no longer needed. A database
    client may be injected into a service, with configuration already set by the service
    catalog.
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念与我们多年来为数据库提供的特定环境配置并没有太大的不同。但随着服务目录工作的继续，我们可能会达到这样一个点，即通过特定环境变量连接到外部服务的应用程序不再需要。数据库客户端可以被注入到服务中，配置已经由服务目录设置好。
- en: Cloud native development sounds great, but how can you quickly test and debug
    your service if you have to deploy it to the cloud every time? Won’t that slow
    your development speed? Yes, deploying to the cloud for every code change to see
    the impact would likely slow development speed, if only marginally, and possibly
    more.
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生开发听起来很棒，但如果你每次都必须将其部署到云中才能快速测试和调试你的服务，该怎么办？这不会减慢你的开发速度吗？是的，每次代码更改都要部署到云中查看影响，可能会略微减慢开发速度，甚至更多。
- en: But what if you can bring the cloud, or something as near as identical to the
    cloud used for production, onto your local development machines? That would certainly
    speed up the round-trip time from code change to seeing it in action. Do cloud
    providers offer such a thing? Some of them do!
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你能将云，或者与生产中使用的云尽可能相似的东西带到你的本地开发机器上呢？这无疑会加快从代码更改到看到实际效果之间的往返时间。云提供商提供这样的服务吗？其中一些确实提供了！
- en: Minikube was the first to offer a single-node Kubernetes cluster that could
    be run on your local machine. All that’s required is a virtual environment, such
    as VirtualBox, Hyper-V, or xhyve driver, installed on your machine that can be
    used by Minikube to create a virtual cluster on your machine.
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: Minikube是第一个提供可以在本地机器上运行的单一节点Kubernetes集群的产品。所需的所有东西是在您的机器上安装的虚拟环境，例如VirtualBox、Hyper-V或xhyve驱动程序，Minikube可以使用它们在您的机器上创建虚拟集群。
- en: Since Minikube formed, Minishift was founded to extend Minikube with a built-in
    PaaS of a single-node OpenShift cluster. Minishift uses the upstream of OpenShift,
    OpenShift Origin, as the PaaS. Revisiting where a CaaS fits into service models,
    [figure 5.3](#ch05fig03) shows what Minishift provides.
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 自从Minikube出现以来，Minishift被创建出来，以扩展Minikube，使其内置一个单节点OpenShift集群的PaaS。Minishift使用OpenShift的上游，即OpenShift
    Origin，作为PaaS。回顾CaaS在服务模型中的位置，[图5.3](#ch05fig03)显示了Minishift提供的内容。
- en: Figure 5.3\. What Minishift provides
  id: totrans-911
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.3\. Minishift提供的内容
- en: '![](Images/05fig03_alt.jpg)'
  id: totrans-912
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig03_alt.jpg)'
- en: There’s nothing wrong with using a CaaS directly, such as Kubernetes, but there
    are benefits of using a PaaS on top. One main benefit is a nice UI to visualize
    what’s deployed. Because of its simplicity in setting up, and wanting to use a
    PaaS over a CaaS, we’ll use Minishift to create our local cloud environment.
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 直接使用CaaS，如Kubernetes，并没有什么问题，但使用PaaS在之上还有好处。一个主要的好处是有一个很好的UI来可视化部署的内容。由于其设置简单，并且我们希望使用PaaS而不是CaaS，我们将使用Minishift来创建我们的本地云环境。
- en: 5.4\. Deploying to the cloud
  id: totrans-914
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4\. 将应用部署到云
- en: 'Quite separate from the service model that the cloud might offer, there are
    also three main deployment models that the cloud could use:'
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 除了云可能提供的服务模型之外，云还可以使用三种主要的部署模型：
- en: '***Private cloud*—** A cloud that’s solely for the use of a single enterprise,
    which is usually hosted internally.'
  id: totrans-916
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***私有云*—**仅供单个企业使用的云，通常内部托管。'
- en: '***Public cloud*—** Services within the cloud are available over a public network.
    The main difference between this and a private cloud relates to security. Whether
    a microservice or database, they need to have more stringent security because
    these services are accessible on a public network.'
  id: totrans-917
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***公有云*—**云中的服务通过公共网络提供。与私有云相比，主要区别在于安全性。无论是微服务还是数据库，它们都需要有更严格的安全措施，因为这些服务可以在公共网络上访问。'
- en: '***Hybrid cloud*—** A combination of public and private clouds. It’s also possible
    that each of these clouds could use different providers. The hybrid cloud deployment
    model is quickly becoming the most common, as it provides the best of both worlds,
    especially when wanting to quickly ramp up capacity and scale.'
  id: totrans-918
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***混合云*—**公共云和私有云的组合。也有可能每个云都可以使用不同的提供商。混合云部署模型正在迅速成为最常见的方式，因为它提供了两者的最佳结合，尤其是在需要快速增加容量和扩展时。'
- en: Minishift, in essence, gives you your own private cloud instance running on
    your local machine. But the PaaS within Minishift, OpenShift, is the same PaaS
    that would be used in a public cloud or hybrid cloud deployment. The only difference
    is it’s running locally.
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: Minishift本质上为您提供了一个在本地机器上运行的私有云实例。但Minishift内部的PaaS，即OpenShift，与在公共云或混合云部署中使用的PaaS相同。唯一的区别是它是本地运行的。
- en: Whether you’re using a cloud for microservices, a monolith, or anything else,
    the way a deployment is pushed to the cloud is no different. The only difference
    might be that a microservice is more likely to have a CI/CD process that automatically
    pushes releases into production. It’s more likely that a deployment of a monolith
    will require greater coordination than an automatic deployment.
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您是使用云来部署微服务、单体应用还是其他任何东西，将部署推送到云的方式都是一样的。唯一的区别可能是一个微服务更有可能有一个CI/CD流程，该流程会自动将发布版本推送到生产环境。而单体应用的部署可能需要比自动部署更多的协调。
- en: 5.5\. Starting Minishift
  id: totrans-921
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5\. 启动Minishift
- en: The first thing you need to do is install Minishift on your local machine. Head
    over to [http://mng.bz/w6g8](http://mng.bz/w6g8) and follow the instructions to
    install the necessary prerequisites, if they aren’t already installed, and then
    install Minishift.
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要做的第一件事是在您的本地机器上安装Minishift。请访问[http://mng.bz/w6g8](http://mng.bz/w6g8)并按照说明安装必要的先决条件，如果它们尚未安装，然后安装Minishift。
- en: '|  |'
  id: totrans-923
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-924
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The examples have been tested with Minishift 1.12.0 and OpenShift 3.6.1.
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 示例已在Minishift 1.12.0和OpenShift 3.6.1上进行了测试。
- en: '|  |'
  id: totrans-926
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'After Minishift is installed, open a terminal window and start it with the
    default settings:'
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Minishift后，打开一个终端窗口，并使用默认设置启动它：
- en: '[PRE67]'
  id: totrans-928
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'By default, this gives you a virtual machine with two virtual CPUs, 2 GB of
    RAM, and 20 GB of hard drive space for it. The terminal provides details of what
    Minishift is doing as it starts, including which version of OpenShift Origin is
    being installed. After the installation is finished, the last output will provide
    details for the web console URL, and login credentials for developer and administrator
    accounts:'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，这会给你提供一个带有两个虚拟CPU、2GB RAM和20GB硬盘空间的虚拟机。终端在启动时会提供Minishift正在执行的操作的详细信息，包括正在安装的OpenShift
    Origin版本。安装完成后，最后的输出将提供Web控制台的URL和开发者和管理员账户的登录凭证：
- en: '[PRE68]'
  id: totrans-930
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'For most things you need to do, either through the web console or via the OpenShift
    command-line interface (CLI), you need only the developer credentials. There’s
    also a handy way to launch the OpenShift web console without having to remember
    the URL and port:'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你需要做的绝大多数事情，无论是通过Web控制台还是通过OpenShift命令行界面（CLI），你只需要开发者的凭证。还有一个方便的方法可以启动OpenShift
    Web控制台，无需记住URL和端口号：
- en: '[PRE69]'
  id: totrans-932
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: This command opens a browser window directly at the login page of the web console.
    After logging in, the console looks like [figure 5.4](#ch05fig04).
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令会直接在浏览器窗口中打开Web控制台的登录页面。登录后，控制台看起来像[图5.4](#ch05fig04)。
- en: Figure 5.4\. OpenShift web console
  id: totrans-934
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.4\. OpenShift web控制台
- en: '![](Images/05fig04_alt.jpg)'
  id: totrans-935
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig04_alt.jpg)'
- en: By default, a fresh instance of OpenShift sets up an empty project called My
    Project for you. You can then choose to delete it and create your own, or use
    it; the choice doesn’t really matter.
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，一个新的OpenShift实例会为你设置一个名为“我的项目”的空项目。你可以选择删除它并创建自己的项目，或者使用它；选择其实并不重要。
- en: You now have a cloud that you can deploy your services into, but you first need
    to make your service deployable to it.
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在有一个可以部署服务的云平台，但首先你需要让你的服务能够部署到这个云平台上。
- en: 5.6\. Microservice cloud deployment
  id: totrans-938
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.6\. 微服务云部署
- en: You’ll take the admin service that you updated in [chapter 4](kindle_split_013.xhtml#ch04),
    and add the necessary configuration to support deploying to the cloud.
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用在第4章中更新的管理服务，并添加必要的配置以支持部署到云平台。
- en: By far, the easiest way to deploy your application is the fabric8 Maven plugin
    ([https://maven.fabric8.io/](https://maven.fabric8.io/)). A huge benefit to the
    plugin is it can bring Java applications to OpenShift or Kubernetes! You can go
    from no configuration deployments to adding as much configuration as you might
    require.
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，部署你的应用程序最简单的方法是使用fabric8 Maven插件([https://maven.fabric8.io/](https://maven.fabric8.io/))。这个插件的一个巨大好处是它可以将Java应用程序带到OpenShift或Kubernetes！你可以从无配置部署过渡到添加你可能需要的任何配置。
- en: Let’s start by modifying your pom.xml to include the plugin in a profile called
    `openshift`.
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从修改你的pom.xml文件开始，将其包含在名为`openshift`的配置文件中。
- en: Listing 5.1\. Maven profile for OpenShift deployment
  id: totrans-942
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.1\. OpenShift部署的Maven配置文件
- en: '[PRE70]'
  id: totrans-943
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '***1*** Name of the fabric8 Maven plugin'
  id: totrans-944
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** fabric8 Maven插件的名称'
- en: '***2*** Creates Kubernetes or OpenShift resource descriptors'
  id: totrans-945
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 创建Kubernetes或OpenShift资源描述符'
- en: '***3*** Generates a Docker image of the application in a container'
  id: totrans-946
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 在容器中生成应用程序的Docker镜像'
- en: The goals that are defined in the plugin inform it of what you want it to do.
    With this configuration, the plugin will create the necessary resource descriptors
    for OpenShift and then use Docker to build a container image with your deployment
    inside it. What the code does is no different than if you created an image with
    Docker directly, but without the hassle of having to remember the correct command
    each time you need it!
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: 插件中定义的目标会告知它你希望它执行的操作。有了这个配置，插件将为OpenShift创建必要的资源描述符，然后使用Docker构建一个包含你的部署的容器镜像。代码所做的工作与直接使用Docker创建镜像没有区别，但无需每次都记住正确的命令！
- en: I mentioned that the plugin generates resource descriptors for you, but what
    are they? Take a look at this listing.
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到插件为你生成资源描述符，但它们是什么？看看这个列表。
- en: Listing 5.2\. service-chapter5-admin.json
  id: totrans-949
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.2\. service-chapter5-admin.json
- en: '[PRE71]'
  id: totrans-950
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This is just one of the many resource descriptors that could be created by the
    plugin, depending on which options are specified. You don’t want to be handcrafting
    files this long for every microservice you deploy! The beauty of the fabric8 Maven
    plugin is that it hides all that boilerplate configuration you don’t need to know
    about unless you want to.
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是插件可能创建的许多资源描述符之一，具体取决于指定的选项。你不需要为每个部署的微服务手动创建这么长的文件！fabric8 Maven插件的优点是它隐藏了你不需要知道的所有样板配置，除非你想要了解。
- en: If finer control over service configuration is needed, it can be achieved with
    custom YAML files that are used by the plugin to generate the necessary JSON.
    That’s beyond the scope of this book, but further information is available at
    the fabric8 website, [https://maven.fabric8.io/](https://maven.fabric8.io/).
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要更精细的服务配置控制，可以使用自定义YAML文件来实现，这些文件由插件用于生成必要的JSON。这超出了本书的范围，但更多信息可在fabric8网站上找到，[https://maven.fabric8.io/](https://maven.fabric8.io/)。
- en: Though Minishift is already started, you need to do one more thing before you
    can deploy your service with the fabric8 Maven plugin. You need to log in to OpenShift
    in the terminal, because the fabric8 Maven plugin uses the credentials to create
    resources within OpenShift. This is necessary only once, or until your authenticated
    session expires and you need to log in again.
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Minishift已经启动，但在你可以使用fabric8 Maven插件部署你的服务之前，你还需要做一件事。你需要在终端中登录到OpenShift，因为fabric8
    Maven插件使用凭证在OpenShift内创建资源。这只需要一次，或者直到你的认证会话过期，你需要再次登录。
- en: 'To log in, you need the OpenShift CLI installed. There are two ways to do that:'
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: 要登录，你需要安装OpenShift CLI。有两种方法可以实现：
- en: Add the .minishift/cache/oc/v3.6.0 directory onto your path, because the `oc`
    binary is retrieved by Minishift for you.
  id: totrans-955
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将.minishift/cache/oc/v3.6.0目录添加到你的路径中，因为`oc`二进制文件是由Minishift为你检索的。
- en: Download the CLI directly from [www.openshift.org/download.html](http://www.openshift.org/download.html).
  id: totrans-956
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接从[www.openshift.org/download.html](http://www.openshift.org/download.html)下载CLI。
- en: 'After the CLI is installed, you can authenticate in the terminal:'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: CLI安装后，你可以在终端中进行身份验证：
- en: '[PRE72]'
  id: totrans-958
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: You’ll be prompted to enter the user ID, `developer`, and any value for a password.
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 你将被提示输入用户ID `developer` 和密码的任何值。
- en: 'You’re going to use the default My Project for now, so you can deploy the admin
    service into OpenShift with the following:'
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 目前你将使用默认的My Project，因此你可以使用以下命令将admin服务部署到OpenShift：
- en: '[PRE73]'
  id: totrans-961
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: You invoke the fabric8 `deploy` goal, which will be executed after the `resource`
    and `build` goals you defined in pom.xml. You also specified the `openshift` profile
    so that the fabric8 Maven plugin is available.
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: 你调用了fabric8的`deploy`目标，该目标将在pom.xml中定义的`resource`和`build`目标之后执行。你还指定了`openshift`配置文件，以便fabric8
    Maven插件可用。
- en: In the terminal, you’ll see the usual Maven build logging, mixed in with messages
    from the fabric8 plugin telling you what it’s generating for deployment to OpenShift.
    After it’s finished deploying the service, you can open My Project in the console
    and see all the details of your deployed service, as shown in [figure 5.5](#ch05fig05).
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，你会看到通常的Maven构建日志，其中混合了fabric8插件的消息，告诉你它正在为部署到OpenShift生成什么。在它完成部署服务后，你可以在控制台中打开My
    Project，查看你部署的服务所有详细信息，如图5.5所示。
- en: 'Here you can easily see at a glance the various pieces of information in your
    service:'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以轻松地一眼看到你服务中的各种信息：
- en: Name of the deployment
  id: totrans-965
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署的名称
- en: Which Docker image is used for the deployment
  id: totrans-966
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署所使用的Docker镜像
- en: Which build created the Docker image
  id: totrans-967
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Docker镜像的构建
- en: The ports that are exposed from the container
  id: totrans-968
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从容器中暴露的端口
- en: How many pods are running and whether they’re healthy
  id: totrans-969
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行中的pod数量以及它们是否健康
- en: The external route pointing at your deployment
  id: totrans-970
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向你的部署的外部路由
- en: '|  |'
  id: totrans-971
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-972
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: A *pod* is a grouping of container(s), such as Docker containers, that use shared
    storage and network infrastructure. A pod is equivalent to a physical or virtual
    machine with collocated applications.
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: '*pod*是一组使用共享存储和网络基础设施的容器（例如Docker容器），相当于具有协同应用程序的物理或虚拟机。'
- en: '|  |'
  id: totrans-974
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Figure 5.5\. OpenShift web console, showing the admin service
  id: totrans-975
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.5\. OpenShift web控制台，显示admin服务
- en: '![](Images/05fig05_alt.jpg)'
  id: totrans-976
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig05_alt.jpg)'
- en: Clicking the route URL for external traffic opens a new browser window at the
    root URL of the service. Because the admin service doesn’t serve anything at /,
    you need to modify the URL in the browser to include /admin/category before you
    can see the JSON data that was retrieved from the database.
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: 点击外部流量路由URL将在服务的根URL处打开一个新的浏览器窗口。因为admin服务在/路径下不提供任何内容，所以在你能够看到从数据库检索到的JSON数据之前，你需要修改浏览器中的URL以包含/admin/category。
- en: With the admin service functioning, can you scale the number of instances you
    have of that service running? Within the OpenShift console, scaling is super easy.
    All you do is expand the section for the chapter5-admin deployment, if it’s not
    already expanded, as shown in [figure 5.6](#ch05fig06). Then click the arrowheads
    next to the blue circle, which denotes the number of current pods. As noted previously,
    *pod* is the Kubernetes term for the containerized deployment, but essentially
    it’s the number of instances of a given service.
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 当管理服务运行正常时，你能扩展该服务运行的实例数量吗？在 OpenShift 控制台中，扩展非常简单。你只需展开 chapter5-admin 部署的章节，如果尚未展开，如
    [图 5.6](#ch05fig06) 所示。然后点击蓝色圆圈旁边的箭头，该圆圈表示当前 pod 的数量。如前所述，“pod”是 Kubernetes 对容器化部署的术语，但本质上它是给定服务的实例数量。
- en: Figure 5.6\. Admin service pod instances
  id: totrans-979
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.6. 管理服务 pod 实例
- en: '![](Images/05fig06_alt.jpg)'
  id: totrans-980
  prefs: []
  type: TYPE_IMG
  zh: '![图片 05fig06_alt](Images/05fig06_alt.jpg)'
- en: Here you can see that the number of pods has increased from the default of 1,
    up to 3\. Open several private browser windows and click the endpoint for /admin/category
    a few times in each. Then head back to the OpenShift console and take a look at
    the logs for each of the pods that are running. You should see the SQL calls that
    were made against the different pods.
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到 pod 的数量已从默认的 1 个增加到 3 个。打开几个私有浏览器窗口，并在每个窗口中多次点击 /admin/category 的端点。然后返回到
    OpenShift 控制台，查看正在运行的每个 pod 的日志。你应该会看到针对不同 pod 执行的 SQL 调用。
- en: 'If you want to remove the admin service, you can just as easily remove it from
    OpenShift with the following:'
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要删除管理服务，你可以像从 OpenShift 中删除它一样轻松地删除它：
- en: '[PRE74]'
  id: totrans-983
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '|  |'
  id: totrans-984
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Warning
  id: totrans-985
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: To undeploy your service, you didn’t use the Maven clean goal. As part of deploy,
    fabric8 stores files in /target that contain details of all the resources that
    were deployed to OpenShift. If you clean them out before `undeploy` can run, fabric8
    has absolutely no idea what it’s trying to undeploy and is unable to do anything.
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: 要取消部署你的服务，你没有使用 Maven clean 目标。作为部署的一部分，fabric8 将文件存储在 /target 目录中，这些文件包含已部署到
    OpenShift 的所有资源的详细信息。如果你在 `undeploy` 运行之前清理它们，fabric8 完全不知道它试图取消部署什么，并且无法执行任何操作。
- en: '|  |'
  id: totrans-987
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: You can now deploy and undeploy the admin service to OpenShift locally running
    inside Minishift, but can you execute tests in the same way? That’s what the next
    section is all about!
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以在 Minishift 内部本地部署和取消部署管理服务，但你能否以同样的方式执行测试？这正是下一节要讨论的内容！
- en: 5.7\. Testing in the cloud
  id: totrans-989
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.7. 云中测试
- en: Because you’re able to deploy the admin service to a local cloud with Minishift,
    can you also use that local cloud to test it as well? You most certainly can!
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你能够使用 Minishift 将管理服务部署到本地云，你也能使用该本地云来测试它吗？你当然可以！
- en: To help develop tests that integrate with OpenShift you’re going to use an extension
    from the Arquillian ecosystem called *Arquillian Cube* ([http://arquillian.org/arquillian-cube/](http://arquillian.org/arquillian-cube/)).
    Arquillian Cube gives you the ability to run tests against code inside Docker
    containers, by providing hooks for controlling the execution of Docker containers.
    Though OpenShift is much more than just Docker, because it uses Docker for its
    container images, you can still use Arquillian Cube to control the deployment
    and run tests against it.
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助开发与 OpenShift 集成的测试，你将使用来自 Arquillian 生态系统的一个扩展，称为 *Arquillian Cube* ([http://arquillian.org/arquillian-cube/](http://arquillian.org/arquillian-cube/))。Arquillian
    Cube 通过提供控制 Docker 容器执行的钩子，使你能够运行针对 Docker 容器内代码的测试。尽管 OpenShift 远不止 Docker，因为它使用
    Docker 作为其容器镜像，但你仍然可以使用 Arquillian Cube 来控制部署并对它执行测试。
- en: What’s the benefit of executing your tests in a cloud as opposed to what can
    be achieved with integration testing? It all comes down to wanting to test your
    microservice in an environment that, as closely as possible, resembles production.
    If you’re deploying your microservice into production in a cloud, your best chance
    of finding out problems with such a deployment is being able to deploy your tests
    to a cloud as well. To be able to do that, you need to add the following to pom.xml.
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 在云中执行测试与通过集成测试所能实现的效果相比有什么好处？这都归结于想要在一个尽可能接近生产环境的条件下测试你的微服务。如果你将微服务部署到云中的生产环境，你发现此类部署问题的最佳机会是将测试也部署到云中。为了能够做到这一点，你需要在
    pom.xml 中添加以下内容。
- en: Listing 5.3\. Arquillian Cube dependencies
  id: totrans-993
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.3. Arquillian Cube 依赖项
- en: '[PRE75]'
  id: totrans-994
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '***1*** Import all Arquillian Cube dependencies so they’re available.'
  id: totrans-995
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 导入所有 Arquillian Cube 依赖项，以便它们可用。'
- en: '***2*** Add the main Arquillian Cube artifact as a test dependency to the project.'
  id: totrans-996
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 将主Arquillian Cube组件作为测试依赖项添加到项目中。'
- en: '***3*** Exclude Undertow as a transitive dependency from Arquillian Cube. It
    interferes with Thorntail.'
  id: totrans-997
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 从Arquillian Cube中排除Undertow作为传递依赖项。它会干扰Thorntail。'
- en: '***4*** Add a test dependency for Awaitility to help with waiting for endpoints
    to be available.'
  id: totrans-998
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** 添加Awaitility测试依赖项，以帮助等待端点可用。'
- en: 'Because you want to be able to run tests outside the cloud as well, though
    the code for [chapter 5](#ch05) has them currently removed, you need a separate
    profile to activate the tests you have for your cloud, OpenShift:'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管目前[第5章](#ch05)的代码中已经移除了测试，但您仍然想要能够在云外运行测试，因此您需要一个单独的配置文件来激活您为云、OpenShift准备的测试：
- en: '[PRE76]'
  id: totrans-1000
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Here you tell Maven that you want the `maven-failsafe-plugin` to execute your
    test, `integration-test` goal, and then `verify` the results.
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您告诉Maven您想要执行`maven-failsafe-plugin`的测试，`integration-test`目标，然后`verify`结果。
- en: Now it’s time to create your test! You’re going to create a test similar to
    one of your integration tests from [chapter 4](kindle_split_013.xhtml#ch04), but
    it’ll be executed against your cloud, OpenShift, instead of a local instance.
    As the fail-safe plugin requires `IT` in the test class name to activate it, you’ll
    name it `CategoryResourceIT`.
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候创建您的测试了！您将创建一个类似于[第4章](kindle_split_013.xhtml#ch04)中集成测试之一的测试，但它将针对您的云、OpenShift执行，而不是本地实例。由于fail-safe插件需要在测试类名中包含`IT`以激活它，所以您将命名为`CategoryResourceIT`。
- en: Listing 5.4\. `CategoryResourceIT`
  id: totrans-1003
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.4\. `CategoryResourceIT`
- en: '[PRE77]'
  id: totrans-1004
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '***1*** Inject a URL pointing at the OpenShift Route for chapter5-admin.'
  id: totrans-1005
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 注入指向chapter5-admin OpenShift路由的URL。'
- en: '***2*** Execute the method before a test to ensure you’re ready for testing.'
  id: totrans-1006
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 在测试之前执行该方法，以确保您已准备好进行测试。'
- en: '***3*** Wait no more than 2 minutes for /admin/category to respond with a 200
    response.'
  id: totrans-1007
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 等待不超过2分钟，直到/admin/category响应200状态码。'
- en: '***4*** Set the root URL for use with RestAssured.'
  id: totrans-1008
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** 设置用于RestAssured的根URL。'
- en: '***5*** Retrieve the category with ID 1014, ensuring you received a 200 response.'
  id: totrans-1009
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** 获取ID为1014的类别，确保您收到了200响应。'
- en: '***6*** Verify that the details of the Category you received match what you
    expected.'
  id: totrans-1010
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** 确认您收到的类别详情与您预期的相符。'
- en: It’s time to test it out!
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候测试它了！
- en: 'First you need to ensure that you have Minishift running, and that you’ve recently
    logged in with `oc login`. Authentications do expire! If all that’s done, you
    run the following:'
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要确保Minishift正在运行，并且您最近已经使用`oc login`登录。认证是会过期的！如果一切就绪，您将运行以下命令：
- en: '[PRE78]'
  id: totrans-1013
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Here you activate the profiles for `openshift` and `openshift-it`. The `openshift-it`
    profile will execute your test, but without the `openshift` profile being present,
    the admin service won’t be deployed to OpenShift! If the service successfully
    deploys and the tests pass, the terminal should show a Maven build that completed
    without error.
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您将激活`openshift`和`openshift-it`的配置文件。`openshift-it`配置文件将执行您的测试，但如果没有`openshift`配置文件，管理员服务将不会部署到OpenShift！如果服务成功部署且测试通过，终端应显示一个没有错误的Maven构建完成。
- en: 'You’ve only just scratched the surface of what’s possible with the fabric8
    Maven plugin and Minishift, but you have a solid footing to begin exploring further
    on your own. Because it’ll be a while before you use Minishift again, let’s stop
    it for now:'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚刚只是触及了fabric8 Maven插件和Minishift所能做到的一小部分，但您已经有了坚实的基础，可以开始自行进一步探索。因为您可能还需要一段时间才会再次使用Minishift，所以我们现在就停止它：
- en: '[PRE79]'
  id: totrans-1016
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 5.8\. Additional exercises
  id: totrans-1017
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.8\. 额外练习
- en: 'Here are additional exercises for you to grow your understanding of OpenShift
    and to help improve the code for the example:'
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些额外的练习，可以帮助您加深对OpenShift的理解，并有助于改进示例代码：
- en: Modify the deployment of the admin service to use PostgreSQL or MySQL when running
    on OpenShift.
  id: totrans-1019
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改管理员服务的部署，以便在OpenShift上运行时使用PostgreSQL或MySQL。
- en: Add test methods for `CategoryResourceIT` for creating a `Category`, and another
    that fails the name validation.
  id: totrans-1020
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为`CategoryResourceIT`添加创建`Category`的测试方法，以及另一个失败的名称验证测试方法。
- en: If you take on these exercises and would like to see them included into the
    code for the book, please submit a pull request to the project on GitHub.
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您接受这些练习并希望看到它们包含在书籍的代码中，请向GitHub上的项目提交一个pull request。
- en: Summary
  id: totrans-1022
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: You can take advantage of immutable container images by choosing a PaaS that
    uses a CaaS internally.
  id: totrans-1023
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过选择使用CaaS内部平台的PaaS来利用不可变容器镜像。
- en: Minishift provides a cloud environment with OpenShift on your local machine,
    to simplify both the execution and testing of microservices without needing to
    provision lots of machines.
  id: totrans-1024
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Minishift 在您的本地机器上提供了一个带有 OpenShift 的云环境，以简化微服务的执行和测试，无需配置大量机器。
- en: The fabric8 Maven plugin removes all the boilerplate needed to define resources
    and services within OpenShift or Kubernetes to reduce the configuration hurdles
    before seeing a microservice running in the cloud.
  id: totrans-1025
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: fabric8 Maven 插件移除了在 OpenShift 或 Kubernetes 中定义资源和服务所需的所有样板代码，以减少在云中看到微服务运行之前所需的配置障碍。
