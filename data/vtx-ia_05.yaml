- en: 4 Asynchronous data and event streams
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 异步数据和事件流
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Why streams are a useful abstraction on top of eventing
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么流是在事件之上一个有用的抽象
- en: What back-pressure is, and why it is fundamental for asynchronous producers
    and consumers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 背压是什么，以及为什么它是异步生产者和消费者基本的原因
- en: How to parse protocol data from streams
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何从流中解析协议数据
- en: So far we have been processing events using *callbacks*, and from various sources
    such as HTTP or TCP servers. Callbacks allow us to reason about events *one at
    a time*.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用*回调*处理事件，来自各种来源，如HTTP或TCP服务器。回调允许我们一次处理一个事件。
- en: 'Processing an incoming data buffer from a TCP connection, from a file, or from
    an HTTP request is not very different: you need to declare a callback handler
    that *reacts* to each event and allows custom processing.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 处理来自TCP连接、文件或HTTP请求的传入数据缓冲区并不太不同：你需要声明一个回调处理程序，该处理程序*响应*每个事件并允许自定义处理。
- en: That being said, most events need to be processed as a *series* rather than
    as *isolated* events. Processing the body of an HTTP request is a good example,
    as several buffers of different sizes need to be assembled to reconstitute the
    full body payload.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，大多数事件需要作为*一系列*而不是*孤立*的事件来处理。处理HTTP请求的主体是一个很好的例子，因为需要组装不同大小的多个缓冲区来重新构成完整的主体有效负载。
- en: Since reactive applications deal with non-blocking I/O, efficient and correct
    stream processing is key. In this chapter we’ll look at why streams pose challenges
    and how Vert.x offers a comprehensive unified stream model.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 由于反应式应用程序处理非阻塞I/O，高效且正确的流处理是关键。在本章中，我们将探讨为什么流会带来挑战，以及Vert.x如何提供全面的统一流模型。
- en: 4.1 Unified stream model
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 统一流模型
- en: Vert.x offers a unified abstraction of *streams* across several types of resources,
    such as files, network sockets, and more. A *read stream* is a source of events
    that can be read, whereas a *write stream* is a destination for events to be sent
    to. For example, an HTTP request is a read stream, and an HTTP response is a write
    stream.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Vert.x提供了一种跨多种资源类型的统一流抽象，例如文件、网络套接字等。*读取流*是可读取的事件源，而*写入流*是发送事件的目的地。例如，HTTP请求是一个读取流，而HTTP响应是一个写入流。
- en: Streams in Vert.x span a wide range of sources and sinks, including those listed
    in table 4.1.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Vert.x中的流涵盖了广泛的来源和目的地，包括表4.1中列出的那些。
- en: Table 4.1 Vert.x common read and write streams
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.1 Vert.x常见读取和写入流
- en: '| Stream resource | Read support | Write support |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 流资源 | 读取支持 | 写入支持 |'
- en: '| TCP sockets | Yes | Yes |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| TCP套接字 | 是 | 是 |'
- en: '| UDP datagrams | Yes | Yes |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| UDP数据报 | 是 | 是 |'
- en: '| HTTP requests and responses | Yes | Yes |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| HTTP请求和响应 | 是 | 是 |'
- en: '| WebSockets | Yes | Yes |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| WebSockets | 是 | 是 |'
- en: '| Files | Yes | Yes |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 文件 | 是 | 是 |'
- en: '| SQL results | Yes | No |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| SQL结果 | 是 | 否 |'
- en: '| Kafka events | Yes | Yes |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| Kafka事件 | 是 | 是 |'
- en: '| Periodic timers | Yes | No |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 定时器 | 是 | 否 |'
- en: Read and write stream are defined through the `ReadStream` and `WriteStream`
    interfaces of the `io.vertx.core.streams` package. You will mostly deal with APIs
    that implement these two interfaces rather than implement them yourself, although
    you may have to do so if you want to connect to some third-party asynchronous
    event API.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 读取和写入流是通过`io.vertx.core.streams`包中的`ReadStream`和`WriteStream`接口定义的。你将主要处理实现这两个接口的API，而不是自己实现它们，尽管如果你想要连接到某些第三方异步事件API，你可能必须这样做。
- en: 'These interfaces can be seen as each having two parts:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这些接口可以看作每个都包含两个部分：
- en: Essential methods for reading or writing data
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取或写入数据的基本方法
- en: '*Back-pressure* management methods that we will cover in the next section'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*背压*管理方法，我们将在下一节中介绍'
- en: 'Table 4.2 lists the *essential* methods of read streams. They define callbacks
    for being notified of three types of events: some data has been read, an exception
    has arisen, and the stream has ended.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.2列出了读取流的*基本*方法。它们定义了回调，用于通知三种类型的事件：读取了一些数据，发生了异常，以及流已结束。
- en: Table 4.2 `ReadStream` essential methods
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.2 `ReadStream`基本方法
- en: '| Method | Description |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| `handler(Handler<T>)` | Handles a new read value of type `T` (e.g., `Buffer`,
    `byte[]`, `JsonObject`, etc.) |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `handler(Handler<T>)` | 处理类型为`T`的新读取值（例如，`Buffer`，`byte[]`，`JsonObject`等）
    |'
- en: '| `exceptionHandler(Handler<Throwable>)` | Handles a read exception |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `exceptionHandler(Handler<Throwable>)` | 处理读取异常 |'
- en: '| `endHandler(Handler<Void>)` | Called when the stream has ended, either because
    all data has been read or because an exception has been raised |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `endHandler(Handler<Void>)` | 当流结束时调用，无论是所有数据都已读取还是因为发生了异常 |'
- en: Similarly, the essential methods of write streams listed in table 4.3 allow
    us to write data, end a stream, and be notified when an exception arises.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，列表 4.3 中列出的写入流的必要方法允许我们写入数据、结束流并在出现异常时通知我们。
- en: Table 4.3 `WriteStream` essential methods
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.3 `WriteStream` 必要方法
- en: '| Method | Description |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| `write(T)` | Writes some data of type, `T` (e.g., `Buffer`, `byte[]`, `JsonObject`,
    etc.) |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `write(T)` | 写入类型为 `T` 的数据（例如，`Buffer`、`byte[]`、`JsonObject` 等） |'
- en: '| `exceptionHandler(Handler<Throwable>)` | Handles a write exception |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `exceptionHandler(Handler<Throwable>)` | 处理写入异常 |'
- en: '| `end()` | Ends the stream |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `end()` | 结束流 |'
- en: '| `end(T)` | Writes some data of type, `T`, and then ends the stream |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `end(T)` | 写入类型为 `T` 的数据，然后结束流 |'
- en: We already manipulated streams in the previous chapters without knowing it,
    such as with TCP and HTTP servers.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前的章节中已经操纵了流，而没有意识到这一点，例如使用 TCP 和 HTTP 服务器。
- en: The `java.io` APIs form a classic stream I/O abstraction for reading and writing
    data from various sources in Java, albeit using blocking APIs. It is interesting
    to compare the JDK streams with the Vert.x non-blocking stream APIs.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: The `java.io` APIs form a classic stream I/O abstraction for reading and writing
    data from various sources in Java, albeit using blocking APIs. It is interesting
    to compare the JDK streams with the Vert.x non-blocking stream APIs.
- en: Suppose we want to read the content of a file and output its content to the
    standard console output.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要读取文件的内容并将其输出到标准控制台输出。
- en: Listing 4.1 Reading a file using JDK I/O APIs
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.1 使用 JDK I/O API 读取文件
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Using try-with-resources we ensure that reader.close() is always going to
    be called, whether the execution completes normally or exceptionally.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 try-with-resources 我们确保无论执行是否正常完成或异常完成，都会调用 reader.close()。
- en: ❷ We insert two lines to the console once reading has finished.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 读取完成后，我们在控制台插入两行。
- en: Listing 4.1 shows a classic example of using JDK I/O streams to read a file
    and then output its content to the console, while taking care of possible errors.
    We read data to a buffer and then immediately write the buffer content to the
    standard console before recycling the buffer for the next read.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.1 展示了使用 JDK I/O 流读取文件并将内容输出到控制台的经典示例，同时注意可能的错误。我们将数据读取到缓冲区中，然后立即将缓冲区内容写入标准控制台，然后再回收缓冲区以进行下一次读取。
- en: The following listing shows the same code as in listing 4.1, but using the Vert.x
    asynchronous file APIs.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了与列表 4.1 相同的代码，但使用 Vert.x 异步文件 API。
- en: Listing 4.2 Reading a file using Vert.x streams
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.2 使用 Vert.x 流读取文件
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Opening a file with Vert.x requires options, such as whether the file is in
    read, write, append mode, and more
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 Vert.x 打开文件需要选项，例如文件是处于读取、写入、追加模式，等等。
- en: ❷ Opening a file is an asynchronous operation.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 打开文件是一个异步操作。
- en: ❸ AsyncFile is the interface for Vert.x asynchronous files.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ AsyncFile 是 Vert.x 异步文件接口。
- en: ❹ The callback for new buffer data
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 新缓冲区数据的回调
- en: ❺ The callback when an exception arises
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 当出现异常时调用的回调
- en: ❻ The callback when the stream ends
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 当流结束时调用的回调
- en: The approach is declarative here, as we define handlers for the different types
    of events when reading the stream. We are being *pushed* data, whereas in listing
    4.1 we were *pulling* data from the stream.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，方法是声明式的，因为我们定义了读取流时不同类型事件的处理器。我们正在被*推送*数据，而在列表 4.1 中，我们从流中*拉取*数据。
- en: This difference may seem cosmetic at first sight, with data being pulled in
    one example, while being pushed in the other. However, the difference is major,
    and we need to understand it to master asynchronous streams, whether with Vert.x
    or with other solutions.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这种差异乍一看可能只是外观上的，一个例子中数据是被拉入的，而另一个例子中数据是被推入的。然而，这种差异是重大的，我们需要理解它，以便掌握异步流，无论是使用
    Vert.x 还是其他解决方案。
- en: This brings us to the notion of *back-pressure*.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了*背压*的概念。
- en: 4.2 What is back-pressure?
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 什么是背压？
- en: Back-pressure is a mechanism for a *consumer* of events to *signal* an event’s
    *producer* that it is emitting events at a faster rate than the consumer can handle
    them. In reactive systems, back-pressure is used to pause or slow down a producer
    so that consumers avoid accumulating unprocessed events in unbounded memory buffers,
    possibly exhausting resources.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 背压是一种机制，允许事件的*消费者*向事件的*生产者**信号*它正在以比消费者处理它们更快的速度发出事件。在反应式系统中，背压用于暂停或减慢生产者，以便消费者避免在无界内存缓冲区中积累未处理的事件，从而可能耗尽资源。
- en: To understand why back-pressure matters with asynchronous streams, let’s take
    the example of an HTTP server used for downloading Linux distribution images,
    and consider the implementation without any back-pressure management strategy
    in place.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解为什么背压对异步流很重要，让我们以一个用于下载Linux发行版镜像的HTTP服务器为例，并考虑没有实施任何背压管理策略的实现。
- en: 'Linux distribution images are often distributed as .iso files and can easily
    weigh several gigabytes. Implementing a server that could distribute such files
    would involve doing the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Linux发行版镜像通常以.iso文件的形式分发，很容易达到几个GB。实现一个能够分发此类文件的服务器将涉及以下操作：
- en: Open an HTTP server.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个HTTP服务器。
- en: For each incoming HTTP request, find the corresponding file.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个传入的HTTP请求，找到相应的文件。
- en: For each buffer read from the file, write it to the HTTP response body.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于从文件中读取的每个缓冲区，将其写入HTTP响应体。
- en: Figure 4.1 provides an illustration of how this would work with Vert.x, although
    this also applies to any non-blocking I/O API. Data buffers are read from the
    file stream, and then passed to a handler. The handler is unlikely to do anything
    but directly write each buffer to the HTTP response stream. Each buffer is eventually
    written to the underlying TCP buffer, either directly or as smaller chunks. Since
    the TCP buffer may be full (either because of the network or because the client
    is busy), it is necessary to maintain a buffer of pending buffers to be written
    (the write queue in figure 4.1). Remember, a write operation is non-blocking,
    so buffering is needed. This sounds like a very simple processing pipeline, so
    what could possibly go wrong?
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1提供了使用Vert.x如何工作的说明，尽管这也适用于任何非阻塞I/O API。数据缓冲区从文件流中读取，然后传递给处理器。处理器不太可能做任何事情，而是直接将每个缓冲区写入HTTP响应流。每个缓冲区最终被写入底层的TCP缓冲区，要么直接写入，要么作为更小的块。由于TCP缓冲区可能已满（要么是因为网络，要么是因为客户端正忙），因此有必要维护一个待写入的缓冲区缓冲区（图4.1中的写入队列）。记住，写入操作是非阻塞的，因此需要缓冲。这听起来是一个非常简单的处理管道，那么可能出什么问题呢？
- en: '![](../Images/CH04_F01_Ponge.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1](../Images/CH04_F01_Ponge.png)'
- en: Figure 4.1 Reading and then writing data between streams without any back-pressure
    signaling
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 无背压信号的情况下在流之间读取和写入数据
- en: Reading from a filesystem is generally fast and low-latency, and given several
    read requests, an operating system is likely to cache some pages into RAM. By
    contrast, writing to the network is much slower, and bandwidth depends on the
    weakest network link. Delays also occur.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 从文件系统中读取通常速度快且低延迟，并且给定几个读取请求，操作系统可能会将一些页面缓存到RAM中。相比之下，写入网络要慢得多，带宽取决于最弱的网络链路。延迟也会发生。
- en: As the reads are much faster than writes, a write buffer, as shown in figure
    4.1, may quickly grow very large. If we have several thousand concurrent connections
    to download ISO images, we may have lots of buffers accumulated in write buffer
    queues. We may actually have several gigabytes worth of ISO images in a JVM process
    memory, waiting to be written over the network! The more buffers there are in
    write queues, the more memory the process consumes.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于读取速度远快于写入速度，写入缓冲区，如图4.1所示，可能会迅速变得非常大。如果我们有数千个并发连接来下载ISO镜像，我们可能在写入缓冲区队列中积累了大量缓冲区。实际上，我们可能在JVM进程内存中有几个GB的ISO镜像，等待通过网络写入！写入队列中的缓冲区越多，进程消耗的内存就越多。
- en: The risk here is clearly that of exhaustion, either because the process eats
    all available physical memory, or because it runs in a memory-capped environment
    such as a container. This raises the risk of consuming too much memory and even
    crashing.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的风险显然是耗尽，要么是因为进程消耗了所有可用的物理内存，要么是因为它在内存受限的环境中运行，如容器。这增加了消耗过多内存甚至崩溃的风险。
- en: As you can probably guess, one solution is *back-pressure signaling*, which
    enables the read stream to adapt to the throughput of the write stream. In the
    previous example, when the HTTP response write queue grows too big, it should
    be able to notify the file read stream that it is going too fast. In practice,
    pausing the source stream is a good way to manage back-pressure, because it gives
    time to write the items in the write buffer while not accumulating new ones.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能猜到的，一个解决方案是*背压信号*，它使读取流能够适应写入流的吞吐量。在先前的例子中，当HTTP响应写入队列变得过大时，它应该能够通知文件读取流它正在运行得太快。在实践中，暂停源流是管理背压的好方法，因为它在不会积累新项目的同时，为写入写入缓冲区中的项目提供了时间。
- en: Tip Blocking I/O APIs have an implicit form of back-pressure by blocking execution
    threads until I/O operations complete. Write operations block when buffers are
    full, which prevents blocked threads from pulling more data until write operations
    have completed.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 提示 阻塞I/O API通过阻塞执行线程直到I/O操作完成来隐式地提供背压。当缓冲区满时，写入操作会阻塞，这阻止了阻塞的线程在写入操作完成之前拉取更多数据。
- en: Table 4.4 lists the back-pressure management methods of `ReadStream`. By default,
    a read stream reads data as fast as it can, unless it is being paused. A processor
    can pause and then resume a read stream to control the data flow.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.4列出了`ReadStream`的背压管理方法。默认情况下，读取流尽可能快地读取数据，除非它被暂停。处理器可以暂停并恢复读取流以控制数据流。
- en: Table 4.4 `ReadStream` back-pressure management methods
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.4 `ReadStream` 背压管理方法
- en: '| Method | Description |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| `pause()` | Pauses the stream, preventing further data from being sent to
    the handler. |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `pause()` | 暂停流，防止进一步的数据被发送到处理器。 |'
- en: '| `resume()` | Starts reading data again and sending it to the handler. |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `resume()` | 重新开始读取数据并将其发送到处理器。 |'
- en: '| `fetch(n)` | Demands a number, `n`, of elements to be read (at most). The
    stream must be paused before calling `fetch(n)`. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `fetch(n)` | 请求读取（最多）`n`个元素。在调用`fetch(n)`之前必须暂停流。 |'
- en: When a read stream has been paused, it is possible to ask for a certain number
    of elements to be fetched, which is a form of asynchronous pulling. This means
    that a processor can ask for elements using `fetch`, setting its own pace. You
    will see concrete examples of that in the last section of this chapter.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当读取流被暂停时，可以请求获取一定数量的元素，这是一种异步拉取的形式。这意味着处理器可以使用`fetch`请求元素，并设置自己的节奏。你将在本章的最后部分看到具体的例子。
- en: In any case, calling `resume()` causes the stream to start pushing data again
    as fast as it can.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，调用`resume()`都会使流尽可能快地开始推送数据。
- en: Table 4.5 shows the corresponding back-pressure management methods for `WriteStream`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.5显示了`WriteStream`对应的背压管理方法。
- en: Table 4.5 `WriteStream` back-pressure management methods
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.5 `WriteStream` 背压管理方法
- en: '| Method | Description |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| `setWriteQueueMaxSize(int)` | Defines what the maximum write buffer queue
    size should be before being considered full. This is a size in terms of queued
    Vert.x buffers to be written, not a size in terms of actual bytes, because the
    queued buffers may be of different sizes. |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `setWriteQueueMaxSize(int)` | 定义在被视为满之前写入缓冲队列的最大大小。这是一个要写入的排队Vert.x缓冲区的大小，而不是实际字节数，因为排队缓冲区可能具有不同的大小。
    |'
- en: '| `boolean writeQueueFull()` | Indicates when the write buffer queue size is
    full. |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `boolean writeQueueFull()` | 指示写入缓冲队列的大小是否已满。 |'
- en: '| `drainHandler(Handler<Void>)` | Defines a callback indicating when the write
    buffer queue has been drained (typically when it is back to half of its maximum
    size). |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `drainHandler(Handler<Void>)` | 定义一个回调，指示何时写入缓冲队列已排空（通常是在其最大大小的一半时）。 |'
- en: The write buffer queue has a maximum size after which it is considered to be
    full. Write queues have default sizes that you will rarely want to tweak, but
    you can do so if you want to. Note that writes can still be made, and data will
    accumulate in the queue. A writer is supposed to check when the queue is full,
    but there is no enforcement on writes. When the writer knows that the write queue
    is full, it can be notified through a *drain handler* when data can be written
    again. In general this happens when half the write queue has been drained.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 写缓冲队列达到最大大小时被认为是满的。写队列有默认大小，你很少需要调整它们，但如果你想的话可以这样做。注意，仍然可以进行写入，数据将在队列中积累。写入器应该在队列满时进行检查，但对于写入没有强制执行。当写入器知道写入队列已满时，可以通过*排水处理器*通知数据可以再次写入。通常这发生在写入队列的一半被排空时。
- en: 'Now that you have seen the back-pressure operations provided in `ReadStream`
    and `WriteStream`, here is the recipe for controlling the flow in our example
    of providing ISO images via HTTP:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了`ReadStream`和`WriteStream`提供的背压操作，以下是通过HTTP提供ISO镜像的示例中控制流的方法：
- en: For each read buffer, write it to the HTTP response stream.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个读取缓冲区，将其写入HTTP响应流。
- en: Check if the write buffer queue is full.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查写入缓冲队列是否已满。
- en: If it is full
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果已满
- en: Pause the file read stream.
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 暂停文件读取流。
- en: Install a drain handler that resumes the file read stream when it is called.
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装一个排水处理器，当调用时恢复文件读取流。
- en: 'Note that this back-pressure management strategy is not always what you need:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这种后压力管理策略并不总是你所需要的：
- en: There may be cases where dropping data when a write queue is full is functionally
    correct and even desirable.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能存在这样的情况，当写入队列满时丢弃数据在功能上是正确的，甚至可能是所希望的。
- en: Sometimes the source of events does not support pausing like a Vert.x `ReadStream`
    does, and you will need to choose between dropping data or buffering even if it
    may cause memory exhaustion.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时事件源不支持暂停，就像Vert.x的 `ReadStream` 一样，即使这可能导致内存耗尽，你也必须在丢弃数据或缓冲之间做出选择。
- en: The appropriate strategy for dealing with back-pressure depends on the functional
    requirements of the code you are writing. In general, you will prefer flow control
    like Vert.x streams offer, but when that’s not possible, you will need to adopt
    another strategy.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 处理后压力的适当策略取决于你正在编写的代码的功能需求。一般来说，你将更喜欢Vert.x流提供的流控制，但如果没有可能，你需要采用另一种策略。
- en: Let’s now assemble all that we’ve seen into an application.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将所见的一切组装成一个应用程序。
- en: 4.3 Making a music-streaming jukebox
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 制作音乐流式点唱机
- en: We are going to illustrate Vert.x streams and back-pressure management through
    the example of a music-streaming jukebox (see figure 4.2).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过音乐流式点唱机的例子（见图4.2）来说明Vert.x流和后压力管理。
- en: '![](../Images/CH04_F02_Ponge.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F02_Ponge.png)'
- en: Figure 4.2 Jukebox application overview
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 点唱机应用程序概览
- en: The idea is that the jukebox has a few MP3 files stored locally, and clients
    can connect over HTTP to listen to the stream. Individual files can also be downloaded
    over HTTP. In turn, controlling when to play, pause, and schedule a song happens
    over a simple, text-based TCP protocol. All connected players will be listening
    to the same audio at the same time, apart from minor delays due to the buffering
    put in place by the players.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是点唱机存储了一些本地的MP3文件，客户端可以通过HTTP连接来收听流。单个文件也可以通过HTTP下载。反过来，播放、暂停和安排歌曲的时间是通过一个简单基于文本的TCP协议来控制的。所有连接的播放器都将同时收听相同的音频，除了由于播放器放置的缓冲造成的微小延迟。
- en: This example will allow us to see how we can deal with custom flow pacing and
    different back-pressure management strategies, and also how to parse streams.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例将使我们能够看到我们如何处理自定义流速度和不同的后压力管理策略，以及如何解析流。
- en: 4.3.1 Features and usage
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.1 特性和用法
- en: The application that we will build can be run from the code in the book’s GitHub
    repository using a Gradle task, as shown in the console output of listing 4.3.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要构建的应用程序可以通过书籍GitHub仓库中的代码使用Gradle任务运行，如列表4.3的控制台输出所示。
- en: note You will need to copy some of your MP3 files to a folder named tracks/
    in the project directory if you want the jukebox to have music to play.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: note 如果你想让点唱机有音乐可播放，你需要将一些MP3文件复制到项目目录中名为tracks/的文件夹中。
- en: Listing 4.3 Running the jukebox application
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.3 运行点唱机应用程序
- en: '[PRE2]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ The main class is chapter4.jukebox.Jukebox.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 主类是 chapter4.jukebox.Jukebox。
- en: ❷ We are deploying two verticles.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们正在部署两个垂直结构。
- en: 'There are two verticles being deployed in this application:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在此应用程序中部署了两个垂直结构：
- en: '`Jukebox` provides the main music-streaming logic and HTTP server interface
    for music players to connect to.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`点唱机` 提供了主要的音乐流式逻辑和 HTTP 服务器接口，供音乐播放器连接使用。'
- en: '`NetControl` provides a text-based TCP protocol for remotely controlling the
    jukebox application.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NetControl` 提供了一个基于文本的TCP协议，用于远程控制点唱机应用程序。'
- en: '![](../Images/CH04_F03_Ponge.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F03_Ponge.png)'
- en: Figure 4.3 VLC connected to the jukebox
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 VLC连接到点唱机
- en: To listen to music, the user can connect a player such as VLC (see figure 4.3)
    or even open a web browser directly at http://localhost:8080/.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要收听音乐，用户可以连接一个播放器，如VLC（见图4.3），或者甚至直接在 http://localhost:8080/ 打开网页浏览器。
- en: On the other hand, the player can be controlled via a tool like `netcat`, with
    plain text commands to list all files, schedule a track to be played, and pause
    or restart the stream. Listing 4.4 shows an interactive session using `netcat`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，播放器可以通过像 `netcat` 这样的工具进行控制，使用纯文本命令列出所有文件、安排播放曲目以及暂停或重新启动流。列表4.4显示了使用 `netcat`
    的交互会话。
- en: Listing 4.4 Controlling the jukebox with `netcat`
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.4 使用 `netcat` 控制点唱机
- en: '[PRE3]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ The control TCP server listens on port 3000.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 控制TCP服务器监听在端口3000。
- en: ❷ This command lists all files.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 此命令列出所有文件。
- en: ❸ Scheduling adds the file to a playlist.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 安排将文件添加到播放列表中。
- en: ❹ This pauses the stream for all connected players.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 这将暂停所有连接播放器的流。
- en: ❺ This resumes the stream.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 这将恢复流。
- en: ❻ We schedule another track when the first has finished.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 当第一首歌曲结束后，我们安排另一首歌曲。
- en: ❼ We can exit the netcat session with Ctrl+C with no harm.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 我们可以用 Ctrl+C 安全地退出 netcat 会话。
- en: Tip `netcat` may be available as `nc` on your Unix environment. I am not aware
    of a friendly and equivalent tool for Windows, outside of a WSL environment.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 提示 `netcat` 可能在你的 Unix 环境中作为 `nc` 提供。我并不知道在 WSL 环境之外，有哪个友好且等效的工具适用于 Windows。
- en: 'Finally, we want to be able to download any MP3 for which we know the filename
    over HTTP:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们希望能够通过 HTTP 下载我们知道的任何 MP3 文件名：
- en: '[PRE4]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Let’s now dissect the various parts of the implementation.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来剖析实现的各种部分。
- en: '4.3.2 HTTP processing: The big picture'
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.2 HTTP 处理：整体视图
- en: There will be many code snippets referring to HTTP server processing, so it
    is good to look at figure 4.4 to understand how the next pieces of code will fit
    together.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 将会有许多代码片段涉及 HTTP 服务器处理，因此查看图 4.4 以了解接下来的代码片段如何组合在一起是很好的。
- en: '![](../Images/CH04_F04_Ponge.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F04_Ponge.png)'
- en: Figure 4.4 Big picture of the HTTP server processing
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 HTTP 服务器处理的整体视图
- en: 'There are two types of incoming HTTP requests: either a client wants to directly
    download a file by name, or it wants to join the audio stream. The processing
    strategies are very different.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的传入 HTTP 请求：客户端要么直接通过名称下载文件，要么想要加入音频流。处理策略非常不同。
- en: In the case of downloading a file, the goal is to perform a direct copy from
    the file read stream to the HTTP response write stream. This will be done with
    back-pressure management to avoid excessive buffering.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在下载文件的情况下，目标是直接从文件读取流复制到 HTTP 响应写入流。这将通过背压管理来完成，以避免过度的缓冲。
- en: Streaming is a bit more involved, as we need to keep track of all the streamers’
    HTTP response write streams. A timer periodically reads data from the current
    MP3 file, and the data is duplicated and written for each streamer.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 流式传输稍微复杂一些，因为我们需要跟踪所有流式传输者的 HTTP 响应写入流。计时器定期从当前 MP3 文件中读取数据，并将数据复制并写入每个流式传输者。
- en: Let’s look at how these parts are implemented.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些部分是如何实现的。
- en: 4.3.3 Jukebox verticle basics
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.3 Jukebox 垂直基本
- en: The next listing shows that the state of the `Jukebox` verticle class is defined
    by a play status and a playlist.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示 `Jukebox` 垂直类的状态是由播放状态和播放列表定义的。
- en: Listing 4.5 State of the `Jukebox` class
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.5 `Jukebox` 类的状态
- en: '[PRE5]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: An enumerated type, `State`, defines two states, while a `Queue` holds all scheduled
    tracks to be played next. Again, the Vert.x threading model ensures single-threaded
    access, so there is no need for concurrent collections and critical sections.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举类型 `State` 定义了两种状态，而 `Queue` 保存所有计划播放的下一条曲目。再次强调，Vert.x 线程模型确保单线程访问，因此不需要并发集合和临界区。
- en: The `start` method of the `Jukebox` verticle (listing 4.6) needs to configure
    a few event-bus handlers that correspond to the commands and actions that can
    be used from the TCP text protocol. The `NetControl` verticle, which we will dissect
    later, deals with the inners of the TCP server and sends messages to the event
    bus.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`Jukebox` 垂直的 `start` 方法（列表 4.6）需要配置一些与可以从 TCP 文本协议使用的命令和动作相对应的事件总线处理程序。稍后我们将剖析的
    `NetControl` 垂直处理 TCP 服务器的内部，并向事件总线发送消息。'
- en: Listing 4.6 Setting up the event-bus handlers in the `Jukebox` verticle
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.6 在 `Jukebox` 垂直中设置事件总线处理程序
- en: '[PRE6]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that because we’ve abstracted the transfer of commands over the event-bus,
    we can easily plug in new ways to command the jukebox, such as using mobile applications,
    web applications, and so on.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，因为我们已经抽象化了通过事件总线传输命令，所以我们很容易插入新的方式来控制 jukebox，例如使用移动应用程序、Web 应用程序等。
- en: The following listing provides the play/pause and schedule handlers. These methods
    directly manipulate the play and playlist state.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表提供了播放/暂停和调度处理程序。这些方法直接操作播放和播放列表状态。
- en: Listing 4.7 Play/pause and schedule operations in the `Jukebox` verticle
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.7 `Jukebox` 垂直中的播放/暂停和调度操作
- en: '[PRE7]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ This allows us to automatically resume playing when no track is playing and
    we schedule a new one.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这允许我们在没有播放曲目且安排了新的曲目时自动恢复播放。
- en: Listing the available files is a bit more involved, as the next listing shows.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 列出可用文件稍微复杂一些，如下一个列表所示。
- en: Listing 4.8 Listing all available files in the `Jukebox` verticle
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.8 列出 `Jukebox` 垂直中的所有可用文件
- en: '[PRE8]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ We asynchronously get all files ending with .mp3 in the tracks/ folder.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们异步获取 tracks/ 文件夹中所有以 .mp3 结尾的文件。
- en: ❷ We build a JSON response.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们构建一个 JSON 响应。
- en: ❸ This is an example of sending a failure code and error message in a request/reply
    communication over the event bus.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 这是在事件总线上的请求/回复通信中发送失败代码和错误消息的示例。
- en: 4.3.4 Incoming HTTP connections
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.4 进入HTTP连接
- en: 'There are two types of incoming HTTP clients: either they want the audio stream
    or they want to download a file.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的进入HTTP客户端：要么他们想要音频流，要么他们想要下载文件。
- en: The HTTP server is started in the `start` method of the verticle (see the next
    listing).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP服务器在垂直结构的`start`方法中启动（见下一条列表）。
- en: Listing 4.9 Setting up the HTTP server in the `Jukebox` verticle
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.9 在`Jukebox`垂直结构中设置HTTP服务器
- en: '[PRE9]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ We will expand on this later with MP3 streaming.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们将在MP3流中进一步扩展这一点。
- en: The request handler used by the Vert.x HTTP server is shown in the following
    listing. It forwards HTTP requests to the `openAudioStream` and `download` utility
    methods, which complete the requests and proceed.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Vert.x HTTP服务器使用的请求处理程序如下所示。它将HTTP请求转发到`openAudioStream`和`download`实用方法，这些方法完成请求并继续。
- en: Listing 4.10 HTTP request handler and dispatcher
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.10 HTTP请求处理程序和分配器
- en: '[PRE10]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ This string substitution prevents malicious attempts to read files from other
    directories (think of someone willing to read /etc/passwd).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 此字符串替换防止了恶意尝试从其他目录读取文件（想想有人愿意读取 /etc/passwd）。
- en: ❷ When nothing matches, we give a 404 (not found) response.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 当没有匹配项时，我们返回404（未找到）响应。
- en: The implementation of the `openAudioStream` method is shown in the following
    listing. It prepares the stream to be in *chunking* mode, sets the proper content
    type, and sets the response object aside for later.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`openAudioStream`方法的实现如下所示。它将流准备为*分块*模式，设置适当的内容类型，并将响应对象保留以供以后使用。'
- en: Listing 4.11 Dealing with new stream players
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.11 处理新的流播放器
- en: '[PRE11]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ We track all current streamers in a set of HTTP responses.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们跟踪所有当前的流式传输者在一个HTTP响应的集合中。
- en: ❷ It is a stream, so the length is unknown.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 它是一个流，因此长度是未知的。
- en: ❸ When a stream exits, it is no longer tracked.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 当流退出时，它就不再被跟踪。
- en: 4.3.5 Downloading as efficiently as possible
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.5 尽可能高效地下载
- en: Downloading a file is a perfect example where back-pressure management can be
    used to coordinate a source stream (the file) and a sink stream (the HTTP response).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 下载文件是一个完美的例子，其中可以使用背压管理来协调源流（文件）和汇流（HTTP响应）。
- en: The following listing shows how we look for the file, and when it exists, we
    forward the final download duty to the `downloadFile` method.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了如何查找文件，当文件存在时，我们将最终的下载任务转发到`downloadFile`方法。
- en: Listing 4.12 Download method
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.12 下载方法
- en: '[PRE12]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Unless you are on a networked filesystem, the possible blocking time is marginal,
    so we avoid a nested callback level.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 除非你在一个网络文件系统上，否则可能的阻塞时间微乎其微，所以我们避免嵌套回调级别。
- en: The implementation of the `downloadFile` method is shown in the following listing.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`downloadFile`方法的实现如下所示。'
- en: Listing 4.13 Downloading a file
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.13 下载文件
- en: '[PRE13]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Writing too fast!
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 写得太快！
- en: ❷ Back-pressure application by pausing the read stream
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 通过暂停读取流来应用背压
- en: ❸ Resuming when drained
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 当排空时恢复
- en: Back-pressure is taken care of while copying data between the two streams. This
    is so commonly done when the strategy is to pause the source and not lose any
    data that the same code can be rewritten as in the following listing.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个流之间复制数据时处理背压。当策略是暂停源流而不丢失任何数据时，这通常这样做，因此相同的代码可以重写如下所示。
- en: Listing 4.14 Pipe helper
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.14 管道辅助工具
- en: '[PRE14]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ Pipes data from file to response
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从文件到响应的数据管道
- en: A pipe deals with back-pressure when copying between a pausable `ReadStream`
    and a `WriteStream`. It also manages the end of the source stream and errors on
    both streams. The code of listing 4.14 does exactly what’s shown in listing 4.13,
    but without the boilerplate. There are other variants of `pipeTo` for specifying
    custom handlers.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 管道在可暂停的`ReadStream`和`WriteStream`之间复制数据时处理背压。它还管理源流和两个流上的错误。列表4.14的代码正好与列表4.13中显示的内容相同，但没有样板代码。还有其他`pipeTo`变体，用于指定自定义处理程序。
- en: 4.3.6 Reading MP3 files, but not too fast
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.6 读取MP3文件，但不要太快
- en: MP3 files have a header containing metadata such as the artist name, genre,
    bit rate, and so on. Several frames containing compressed audio data follow, which
    decoders can turn into *pulse-code modulation* data, which can eventually be turned
    into sound.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: MP3文件包含一个包含艺术家名称、流派、比特率等元数据的标题。随后是几个包含压缩音频数据的帧，解码器可以将这些数据转换为*脉冲编码调制*数据，最终可以转换为声音。
- en: MP3 decoders are very resilient to errors, so if they start decoding in the
    middle of a file, they will still manage to figure out the bit rate, and they
    will align with the next frame to start decoding the audio. You can even concatenate
    multiple MP3 files and send them to a player. The audio will be decoded as long
    as all files are using the same bit rate and stereo mode.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: MP3解码器对错误非常健壮，因此如果它们在文件中间开始解码，它们仍然能够确定比特率，并且将与下一个帧对齐以开始解码音频。你甚至可以将多个MP3文件连接起来并发送给玩家。只要所有文件都使用相同的比特率和立体声模式，音频就会被解码。
- en: 'This is interesting for us as we design a music-streaming jukebox: if our files
    have been encoded in the same way, we can simply push each file of a playlist
    one after the other, and the decoders will handle the audio just fine.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我们来说很有趣，因为我们正在设计一个音乐流媒体点唱机：如果我们的文件已经以相同的方式编码，我们只需依次推送播放列表中的每个文件，解码器就可以很好地处理音频。
- en: Why back-pressure alone is not enough
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么仅后压力是不够的
- en: Feeding MP3 data to many connected players is not as simple as it may seem.
    The main issue is ensuring that all current and future players are listening to
    the same music at *roughly* the same time. All players have different local buffering
    strategies to ensure smooth playback, even when the network suffers delays, but
    if the server simply pushes files as fast as it can, not all clients will be synchronized.
    Worse, when a new player connects, it may receive nothing to play while the current
    players have several minutes of music remaining in their buffers. To provide a
    sensible playback experience, we need to control the pace at which files are read,
    and for that we will use a timer.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 将MP3数据传输给许多连接的玩家并不像看起来那么简单。主要问题是确保所有当前和未来的玩家都大致在同一时间收听相同的音乐。所有玩家都有不同的本地缓冲策略，以确保即使在网络延迟的情况下也能流畅播放，但如果服务器简单地以尽可能快的速度推送文件，则并非所有客户端都会同步。更糟糕的是，当新玩家连接时，它可能什么也收不到可以播放的，而当前玩家在他们的缓冲区中可能还有几分钟的音乐剩余。为了提供合理的播放体验，我们需要控制读取文件的速度，为此我们将使用计时器。
- en: This is illustrated in figure 4.5, which shows what happens *without* and *with*
    rate control on the streams. In both cases, suppose that Player A joined the stream
    at the beginning, while Player B joined, say, 10 seconds later. Without read-rate
    control, we find ourselves in a similar case to that of downloading an MP3 file.
    We may have back-pressure in place to ensure efficient resource usage while copying
    MP3 data chunks to the connected clients, but the streaming experience will be
    very bad.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这在图4.5中得到了说明，该图显示了在流中*没有*和*有*速率控制时会发生什么。在两种情况下，假设玩家A在开始时加入了流，而玩家B在10秒后加入。在没有读取速率控制的情况下，我们发现自己处于与下载MP3文件类似的情况。我们可能已经设置了后压力来确保在将MP3数据块复制到连接的客户端时高效地使用资源，但流式传输体验将会非常糟糕。
- en: '![](../Images/CH04_F05_Ponge.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F05_Ponge.png)'
- en: Figure 4.5 Streaming without and with rate control
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 无速率控制和有速率控制的流
- en: Since we are basically streaming data as fast as we can, Player A finds its
    internal buffers filled with almost all the current file data. While it may be
    playing at position 0 minutes 15 seconds, it has already received data beyond
    the 3-minute mark. When Player B joins, it starts receiving MP3 data chunks from
    much farther on in the file, so it starts playing at position 3 minutes and 30
    seconds. If we extend our reasoning to multiple files, a new player can join and
    receive no data at all, while the previously connected players may have multiple
    songs to play in their internal buffers.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们基本上是以尽可能快的速度流式传输数据，玩家A发现其内部缓冲区几乎充满了当前文件的所有数据。虽然它可能在0分15秒的位置播放，但它已经接收到了超过3分钟标记的数据。当玩家B加入时，它开始从文件中较远的位置接收MP3数据块，因此它从3分30秒的位置开始播放。如果我们将我们的推理扩展到多个文件，新加入的玩家可能根本接收不到数据，而之前已经连接的玩家可能在他们的内部缓冲区中有多首歌曲要播放。
- en: By contrast, if we control the read rate of the MP3 file, and hence the rate
    at which MP3 chunks are being copied and written to the connected players, we
    can ensure that they are all, more or less, at the same position.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，如果我们控制MP3文件的读取速率，从而控制MP3数据块被复制和写入连接玩家的速率，我们就可以确保它们都大致处于相同的位置。
- en: Rate control here is all about ensuring that all players receive data fast enough
    so that they can play without interruption, but not too quickly so they do not
    buffer too much data.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，速率控制主要是确保所有玩家都能以足够快的速度接收数据，以便他们可以不间断地播放，但又不能太快，以免缓冲过多的数据。
- en: Rate-limited streaming implementation
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 速率限制流实现
- en: Let’s look at the complete `Jukebox` verticle `start` method, as it shows that
    much needed timer.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看完整的 `Jukebox` 垂直 `start` 方法，因为它显示了所需的计时器。
- en: Listing 4.15 `Jukebox` verticle class `start` method
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.15 `Jukebox` 垂直类 `start` 方法
- en: '[PRE15]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ streamAudioChunk periodically pushes new MP3 data (100 ms is purely empirical,
    so feel free to adjust it).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `streamAudioChunk` 定期推送新的 MP3 数据（100 毫秒完全是经验值，所以请随意调整）。
- en: Beyond connecting the event-bus handlers and starting an HTTP server, the `start`
    method also defines a timer so that data is streamed every 100 milliseconds.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 除了连接事件总线处理程序和启动 HTTP 服务器之外，`start` 方法还定义了一个计时器，以便每 100 毫秒进行数据流传输。
- en: Next, we can look at the implementation of the `streamAudioChunk` method.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以看看 `streamAudioChunk` 方法的实现。
- en: Listing 4.16 Streaming file chunks
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.16 流式传输文件块
- en: '[PRE16]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ Buffers cannot be reused across I/O operations, so we need a new one.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在 I/O 操作之间不能重用缓冲区，因此我们需要一个新的缓冲区。
- en: ❷ This is where data is being copied to all players.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 这就是数据被复制到所有播放器的地方。
- en: Why these values?
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么是这些值？
- en: Why do we read data every 100 milliseconds? And why read buffers of 4096 bytes?
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们每 100 毫秒读取数据？为什么读取 4096 字节的缓冲区？
- en: I have empirically found these values work well for 320 KBps constant bit rate
    MP3 files on my laptop. They ensured no drops in tests while preventing players
    from buffering too much data, and thus ending several seconds apart in the audio
    stream.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我在我的笔记本电脑上通过经验发现这些值对于 320 KBps 恒定比特率 MP3 文件来说效果很好。它们确保了测试中没有丢失，同时防止播放器缓冲过多数据，从而在音频流中结束几秒钟。
- en: Feel free to tinker with these values as you run the examples.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行示例时，请随意调整这些值。
- en: The code of `streamAudioChunk` reads blocks of, at most, 4096 bytes. Since the
    method will always be called 10 times per second, it also needs to check whether
    anything is being played at all. The `processReadBuffer` method streams data,
    as shown in the following listing.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`streamAudioChunk` 函数的代码读取最多 4096 字节的数据块。由于该方法每秒会被调用 10 次，因此它还需要检查是否正在播放任何内容。`processReadBuffer`
    方法以如下所示的方式流式传输数据。'
- en: Listing 4.17 Streaming data chunks to players
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.17 将数据块流式传输到播放器
- en: '[PRE17]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ This happens when the end of the file has been reached.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这发生在文件末尾到达时。
- en: ❷ Back-pressure again
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 再次遇到背压
- en: ❸ Remember, buffers cannot be reused.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 记住，缓冲区不能被重用。
- en: 'For every HTTP response stream to a player, the method copies the read data.
    Note that we have another case of back-pressure management here: when the write
    queue of a client is full, we simply discard data. On the player’s end, this will
    result in audio drops, but since the queue is full on the server, it means that
    the player will have delays or drops anyway. Discarding data is fine, as MP3 decoders
    know how to recover, and it ensures that playback will remain closely on time
    with the other players.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个发送到播放器的 HTTP 响应流，该方法会复制读取的数据。请注意，我们在这里还有另一个背压管理的情况：当客户端的写入队列已满时，我们简单地丢弃数据。在播放器的端，这将导致音频丢失，但由于服务器上的队列已满，这意味着播放器将会有延迟或丢失。丢弃数据是可以的，因为
    MP3 解码器知道如何恢复，并且这确保了播放将与其他播放器保持紧密的时间同步。
- en: warning Vert.x buffers cannot be reused once they have been written, as they
    are placed in a write queue. Reusing buffers will always result in bugs, so don’t
    look for unnecessary optimizations here.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：一旦写入，Vert.x 缓冲区就不能被重用，因为它们被放置在写入队列中。重用缓冲区总会导致错误，所以在这里不要寻找不必要的优化。
- en: Finally, the helper methods in the following listing enable the opening and
    closing of files.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以下列表中的辅助方法可以启用文件的打开和关闭。
- en: Listing 4.18 Opening and closing files
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.18 打开和关闭文件
- en: '[PRE18]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Again, we use the blocking variant, but it will rarely be an issue for opening
    a file.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 再次，我们使用阻塞变体，但对于打开文件来说，这很少会成为问题。
- en: 4.4 Parsing simple streams
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 简单流的解析
- en: So far our dissection of the jukebox example has focused on the `Jukebox` verticle
    used to download and stream MP3 data. Now it’s time to dissect the `NetControl`
    verticle, which exposes a TCP server on port 3000 for receiving text commands
    to control what the jukebox plays. Extracting data from asynchronous data streams
    is a common requirement, and Vert.x provides effective tools for doing that.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们对音乐盒示例的分析主要集中在用于下载和流式传输 MP3 数据的 `Jukebox` 垂直上。现在是时候分析 `NetControl` 垂直了，它在一个
    TCP 服务器上暴露端口 3000，用于接收文本命令以控制音乐盒播放的内容。从异步数据流中提取数据是一个常见的需求，Vert.x 提供了有效的工具来完成这项工作。
- en: 'The commands in our text protocol are of the following form:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们文本协议中的命令形式如下：
- en: '[PRE19]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'These are the actions:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是操作：
- en: '`/list`--Lists the files available for playback'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/list`--列出可播放的文件'
- en: '`/play`--Ensures the stream plays'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/play`--确保流播放'
- en: '`/pause`--Pauses the stream'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/pause`--暂停流'
- en: '`/schedule file`--Appends `file` at the end of the playlist'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/schedule file`--将 `file` 添加到播放列表的末尾'
- en: Each text line can have exactly one command, so the protocol is said to be *newline*-separated.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 每个文本行可以恰好有一个命令，因此该协议被认为是*换行符*分隔的。
- en: 'We need a parser for this, as buffers arrive in chunks that rarely correspond
    to one line each. For example, a first read buffer could contain the following:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个解析器来处理这个问题，因为缓冲区以块的形式到达，很少对应于每一行。例如，第一次读取的缓冲区可能包含以下内容：
- en: '[PRE20]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The next one may look like this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个可能看起来像这样：
- en: '[PRE21]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And it may be followed by this:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 并且可能接着是：
- en: '[PRE22]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: What we actually want is reasoning about *lines*, so the solution is to concatenate
    buffers as they arrive, and split them again on newlines so we have one line per
    buffer. Instead of manually assembling intermediary buffers, Vert.x offers a handy
    parsing helper with the `RecordParser` class. The parser ingests buffers and emits
    new buffers with parsed data, either by looking for delimiters or by working with
    chunks of fixed size.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上想要的是关于*行*的推理，所以解决方案是将到达的缓冲区连接起来，并在换行符上再次分割，这样我们就有每个缓冲区一行。而不是手动组装中间缓冲区，Vert.x
    提供了一个方便的解析辅助工具，即 `RecordParser` 类。解析器消耗缓冲区，并以新的缓冲区形式发出解析后的数据，要么通过查找分隔符，要么通过处理固定大小的块。
- en: In our case, we need to look for newline delimiters in the stream. The following
    listing shows how to use `RecordParser` in the `NetControl` verticle.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们需要在流中查找换行分隔符。以下列表显示了如何在 `NetControl` 竖线中使用 `RecordParser`。
- en: Listing 4.19 A `recordparser` based on newlines over a TCP server stream
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.19 基于TCP服务器流的 `recordparser`
- en: '[PRE23]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ Parse by looking for new lines.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 通过查找新行进行解析。
- en: ❷ Now buffers are lines.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 现在缓冲区是行。
- en: The parser is both a read and a write stream, as it functions as an adapter
    between two streams. It ingests intermediate buffers coming from the TCP socket,
    and it emits parsed data as new buffers. This is fairly transparent and simplifies
    the rest of the verticle implementation.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 解析器既是读取流也是写入流，因为它充当两个流之间的适配器。它消耗来自 TCP 套接字的中间缓冲区，并以新的缓冲区形式发出解析后的数据。这是相当透明的，简化了竖线其余部分的实现。
- en: In the next listing, each buffer is known to be a line, so we can go directly
    to processing commands.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个列表中，每个缓冲区都已知是一个行，因此我们可以直接处理命令。
- en: Listing 4.20 Handling parsed buffers
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.20 处理解析后的缓冲区
- en: '[PRE24]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ Buffer-to-string decoding with the default charset
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用默认字符集进行缓冲区到字符串的解码
- en: The simple commands are in the `case` clauses, and the other commands are in
    separate methods shown in the following listing.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的命令在 `case` 子句中，其他命令在以下列表中显示的单独方法中。
- en: Listing 4.21 Other commands
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.21 其他命令
- en: '[PRE25]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ❶ The first 10 characters are for /schedule and a space.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 前面的 10 个字符用于 `/schedule` 和一个空格。
- en: ❷ We write each filename to the standard console output.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们将每个文件名写入标准控制台输出。
- en: 4.5 Parsing complex streams
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5 解析复杂流
- en: Streams can be more complex than just lines of text, and `RecordParser` can
    also simplify our work with these. Let’s take the example of key/value database
    storage, where each key and value is a string.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 流可以比纯文本行更复杂，`RecordParser` 也可以简化我们与这些流的工作。让我们以键/值数据库存储为例，其中每个键和值都是字符串。
- en: In such a database, we could have entries such as `1 -> {foo}` and `2 -> {bar,
    baz}`, with `1` and `2` being keys. There are countless ways to define a serialization
    scheme for this type of data structure, so imagine that we must use the stream
    format in table 4.6.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在此类数据库中，我们可能有条目如 `1 -> {foo}` 和 `2 -> {bar, baz}`，其中 `1` 和 `2` 是键。为这种类型的数据结构定义序列化方案有无数种方式，所以想象我们必须使用表
    4.6 中的流格式。
- en: Table 4.6 Database stream format
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.6 数据库流格式
- en: '| Data | Description |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| 数据 | 描述 |'
- en: '| Magic header | A sequence of bytes `1`, `2`, `3`, and `4` to identify the
    file type |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| 魔法标题 | 用字节序列 `1`, `2`, `3`, 和 `4` 来标识文件类型 |'
- en: '| Version | An integer with the database stream format version |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| 版本 | 表示数据库流格式版本的整数 |'
- en: '| Name | Name of the database as a string, ending with a newline character
    |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 以换行符结尾的字符串形式的数据库名称 |'
- en: '| Key length | Integer with the number of characters for the next key |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| 密钥长度 | 表示下一个密钥字符数的整数 |'
- en: '| Key name | A sequence of characters for the key name |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| 密钥名称 | 密钥名称的字符序列 |'
- en: '| Value length | Integer with the number of characters for the next value |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| 值长度 | 表示下一个值字符数的整数 |'
- en: '| Value | A sequence of characters for the value |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| 值 | 值的字符序列 |'
- en: '| (...) | Remaining `{key, value}` sequences |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| (...) | 剩余的 `{key, value}` 序列 |'
- en: The format mixes binary and text records, as the stream starts with a magic
    number, a version number, a name, and then a sequence of key and value entries.
    While the format in itself is questionable on some points, it is a good example
    to illustrate more complex parsing.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 格式混合了二进制和文本记录，因为流以魔数、版本号、名称开始，然后是一系列键和值条目。虽然格式本身在某些方面可能存在问题，但它是一个很好的例子，可以说明更复杂的解析。
- en: First of all, let’s have a program that writes a database to a file with two
    key/value entries. The following listing shows how to use the Vert.x filesystem
    APIs to open a file, append data to a buffer, and then write it.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们有一个程序，它将数据库写入文件，包含两个键/值条目。下面的列表显示了如何使用 Vert.x 文件系统 API 打开文件、向缓冲区追加数据，然后写入它。
- en: Listing 4.22 Writing a sample database to a file
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.22 将示例数据库写入文件
- en: '[PRE26]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ Magic number
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 魔数
- en: ❷ Version
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 版本
- en: ❸ Database name
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 数据库名称
- en: ❹ First entry
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 第一个条目
- en: ❺ Second entry
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 第二个条目
- en: In this example we had little data, so we used a single buffer that we prepared
    wholly before writing it to the file, but we could equally use a buffer for the
    header and new buffers for each key/value entry.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们数据很少，所以我们使用了一个单独的缓冲区，我们在将其写入文件之前完全准备好了它，但我们同样可以使用一个用于头部的缓冲区，以及每个键/值条目的新缓冲区。
- en: Writing is easy, but what about reading it back? The interesting property of
    `RecordParser` is that its parsing mode can be switched on the fly. We can start
    parsing buffers of fixed size 5, then switch to parsing based on tab characters,
    then chunks of 12 bytes, and so on.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 写入很简单，但如何读取它呢？`RecordParser` 的有趣特性是它的解析模式可以即时切换。我们可以开始解析固定大小为 5 的缓冲区，然后切换到基于制表符的解析，然后是
    12 字节的数据块，等等。
- en: 'The parsing logic is better expressed by splitting it into methods where each
    method corresponds to a parsing state: a method for parsing the database name,
    a method for parsing a value entry, and so on.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 解析逻辑通过将其分解为对应于解析状态的方法来表达得更好：一个用于解析数据库名称的方法，一个用于解析值条目的方法，等等。
- en: The following listing opens the file that we previously wrote and puts the `RecordParser`
    object into fixed mode, as we are looking for a sequence of four bytes that represents
    the magic header. The handler that we install is called when a magic number is
    read.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表打开我们之前写入的文件，并将 `RecordParser` 对象置于固定模式，因为我们正在寻找表示魔数头部的四个字节的序列。我们安装的处理程序在读取到魔数时被调用。
- en: Listing 4.23 Reading a database stream, step 1
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.23 读取数据库流，步骤 1
- en: '[PRE27]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ❶ We first want to read the magic number.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们首先想读取魔数。
- en: The next listing provides the implementation of further methods.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表提供了进一步方法的实现。
- en: Listing 4.24 Reading a database stream, step 2
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.24 读取数据库流，步骤 2
- en: '[PRE28]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ❶ The parser mode can be switched on the fly.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 解析器模式可以即时切换。
- en: The `readMagicNumber` method extracts the four bytes of the magic number from
    a buffer. We know that the buffer is exactly four bytes since the parser was in
    fixed-sized mode.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`readMagicNumber` 方法从缓冲区中提取魔数的前四个字节。我们知道缓冲区正好是四个字节，因为解析器处于固定大小模式。'
- en: The next entry is the database version, and it is an integer, so we don’t have
    to change the parser mode because an integer is four bytes. Once the version has
    been read, the `readVersion` method switches to delimited mode to extract the
    database name. We then start looking for a key length, so we need a fixed-sized
    mode in `readName`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个条目是数据库版本，它是一个整数，所以我们不需要更改解析器模式，因为整数是四个字节。一旦读取了版本，`readVersion` 方法切换到分隔符模式以提取数据库名称。然后我们开始查找键长度，因此在
    `readName` 中需要一个固定大小的模式。
- en: The following listing reads the key name, the value length, and the proper value,
    and `finishEntry` sets the parser to look for an integer and delegates to `readKey`.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表读取键名、值长度和正确的值，`finishEntry` 将解析器设置为查找整数并委托给 `readKey`。
- en: Listing 4.25 Reading a database stream, step 3
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.25 读取数据库流，步骤 3
- en: '[PRE29]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The next listing shows some sample output when reading the database file with
    the parsing methods of listings 4.23 through 4.25.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了使用列表 4.23 到 4.25 中的解析方法读取数据库文件时的某些示例输出。
- en: Listing 4.26 Logs of reading the database stream
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.26 读取数据库流的日志
- en: '[PRE30]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: These on-the-fly parser mode and handler changes form a very simple yet effective
    way to parse complex streams.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这种即时解析模式和处理器更改形成了一种非常简单但有效的方法来解析复杂的流。
- en: Tip You may wonder how the parsing mode can be changed on the fly, while some
    further data is already available to the parser from the read stream. Remember
    that we are on an event loop, so parser handlers are processing parser records
    one at a time. When we switch from, say, delimiter mode to fixed-size mode, the
    next record is emitted by processing the remaining stream data based on a number
    of bytes rather than looking for a string. The same reasoning applies when switching
    from fixed-sized mode to delimiter mode.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士 你可能会想知道如何在解析器已经从读取流中获取了一些进一步数据的情况下，动态地更改解析模式。记住，我们处于事件循环中，因此解析器处理程序一次处理一个解析记录。当我们从，比如说，分隔符模式切换到固定大小模式时，下一个记录是通过基于字节数而不是查找字符串来处理剩余的流数据而发出的。同样的推理也适用于从固定大小模式切换到分隔符模式。
- en: 4.6 A quick note on the stream fetch mode
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.6 关于流获取模式的一则简短说明
- en: Before we wrap up this chapter, let’s go back to a detail of the `ReadStream`
    interface that I deliberately left aside.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束本章之前，让我们回到我故意留出的`ReadStream`接口的细节。
- en: Introduced in Vert.x 3.6, the *fetch* mode that I mentioned earlier in this
    chapter allows a stream consumer to request a number of data items, rather than
    the stream pushing data items to the consumer. This works by pausing the stream
    and then asking for a varying number of items to be fetched later on, as data
    is needed.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vert.x 3.6中引入的*获取*模式，我在本章前面提到，允许流消费者请求一定数量的数据项，而不是流将数据项推送到消费者。这是通过暂停流然后请求在需要时获取的变量数量的项目来实现的。
- en: We could rewrite the jukebox file-streaming code with the fetch mode, but we
    would still need a timer to dictate the pace. In this case, manually reading a
    buffer of 4096 bytes or requesting 4096 to be fetched is not that different.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用获取模式重写点唱机文件流代码，但仍然需要一个计时器来控制节奏。在这种情况下，手动读取一个4096字节的缓冲区或请求获取4096字节并没有太大的区别。
- en: Instead, let’s go back to the database reading example. The read stream pushed
    events in listings 4.23 through 4.25\. Switching to fetch mode and pulling data
    does not require many changes. The following listing shows the stream initialization
    code.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，让我们回到数据库读取示例。列表4.23至4.25中的读取流推送了事件。切换到获取模式并拉取数据不需要太多更改。以下列表显示了流初始化代码。
- en: Listing 4.27 Putting a read stream in fetch mode
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.27 将读取流置于获取模式
- en: '[PRE31]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ❶ The stream won’t push events.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 流不会推送事件。
- en: ❷ We ask for one element (here, a buffer).
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们请求一个元素（在这里，是一个缓冲区）。
- en: Remember that the `RecordParser` decorates the file stream. It is paused, and
    then the `fetch` method asks for one element. Since the parser emits buffers of
    parsed data, asking for one element in this example means asking for a buffer
    of four bytes (the magic number). Eventually, the parser handler will be called
    to process the requested buffer, and nothing else will happen until another call
    to the `fetch` method is made.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 记住`RecordParser`装饰了文件流。它被暂停，然后`fetch`方法请求一个元素。由于解析器会发出解析数据的缓冲区，在这个例子中请求一个元素意味着请求一个四字节的缓冲区（魔术数字）。最终，解析器处理程序将被调用以处理请求的缓冲区，直到再次调用`fetch`方法之前不会发生任何事情。
- en: The following listing shows two of the parsing handler methods and their adaptation
    to the fetch mode.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了两个解析处理方法及其对获取模式的适应。
- en: Listing 4.28 Fetching stream data as needed
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.28 按需获取流数据
- en: '[PRE32]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: ❶ Here one item is a parser record.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这里的一项是一个解析记录。
- en: The only difference between the two modes is that we need to request elements
    by calling `fetch`. You will not likely need to play with fetch mode while writing
    Vert.x applications, but if you ever need to manually control a read stream, it
    is a useful tool to have.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种模式之间的唯一区别是我们需要通过调用`fetch`来请求元素。在编写Vert.x应用程序时，你可能不太需要玩转获取模式，但如果你需要手动控制读取流，它是一个有用的工具。
- en: In many circumstances, having data being *pushed* is all you need, and the requester
    can manage the back-pressure by signaling when pausing is needed. If you have
    a case where it is easier for the requester to let the source know how many items
    it can handle, then *pulling* data is a better option for managing the back-pressure.
    Vert.x streams are quite flexible here.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，只需要数据被*推送*，请求者可以通过在需要暂停时发出信号来管理背压。如果你有一个请求者更容易让源知道它能处理多少项的情况，那么*拉取*数据是管理背压的更好选择。Vert.x流在这里非常灵活。
- en: The next chapter focuses on other models besides callbacks for asynchronous
    programming with Vert.x.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将重点介绍Vert.x异步编程中除了回调以外的其他模型。
- en: Summary
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Vert.x streams model asynchronous event and data flows, and they can be used
    in both *push* and *pull/fetch* modes.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vert.x流模型异步事件和数据流，并且可以在**推送**和**拉取/获取**模式下使用。
- en: Back-pressure management is essential for ensuring the coordinated exchange
    of events between asynchronous systems, and we illustrated this through MP3 audio
    streaming across multiple devices and direct downloads.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压力反馈管理对于确保异步系统之间事件协调交换至关重要，我们通过多设备MP3音频流和直接下载来阐述了这一点。
- en: Streams can be parsed for simple and complex data, illustrated here by a networked
    control interface for an audio streaming service.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流可以解析简单和复杂的数据，这里以音频流服务的网络控制界面为例。
