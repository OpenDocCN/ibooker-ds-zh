- en: 2 Creating a dataset
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 创建数据集
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Exploring R data structures
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 R 数据结构
- en: Using data entry
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数据输入
- en: Importing data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入数据
- en: Annotating datasets
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据集标注
- en: The first step in any data analysis is creating a dataset containing the information
    to be studied in a format that meets your needs. In R, this task involves
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 任何数据分析的第一步是创建一个包含所需研究信息的数据集，并以满足您需求的形式组织。在 R 中，这项任务涉及
- en: Selecting a data structure to hold your data
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择用于存储数据的数据结构
- en: Entering or importing your data into the data structure
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据输入或导入到数据结构中
- en: Sections 2.1 and 2.2 of this chapter describe the wealth of structures that
    R can use to hold data. In particular, section 2.2 describes vectors, factors,
    matrices, data frames, lists, and tibbles. Familiarizing yourself with these structures
    (and the notation used to access elements within them) will help you tremendously
    in understanding how R works. You might want to take your time working through
    this section.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的 2.1 和 2.2 节描述了 R 可以用来存储数据的丰富结构。特别是，2.2 节描述了向量、因子、矩阵、数据框、列表和 tibbles。熟悉这些结构（以及用于访问其中元素的符号）将极大地帮助您理解
    R 的工作原理。您可能需要花时间仔细研究这一节。
- en: Section 2.3 covers the many methods for importing data into R. Data can be entered
    manually or imported from an external source. These data sources can include text
    files, spreadsheets, statistical packages, and database-management systems. For
    example, the data that I work with typically comes as comma-delimited text files
    or Excel spreadsheets. On occasion, though, I receive data as SAS and SPSS datasets
    or through connections to SQL databases. It’s likely that you’ll only have to
    use one or two of the methods described in this section, so feel free to choose
    those that fit your situation.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 第 2.3 节涵盖了将数据导入 R 的许多方法。数据可以手动输入或从外部来源导入。这些数据源可以包括文本文件、电子表格、统计软件包和数据库管理系统。例如，我处理的数据通常以逗号分隔的文本文件或
    Excel 电子表格的形式出现。不过，有时我也会收到 SAS 和 SPSS 数据集或通过连接 SQL 数据库的数据。你很可能只需要使用本节中描述的方法中的一两种，因此请随意选择适合您情况的方法。
- en: Once a dataset is created, you’ll typically annotate it, adding descriptive
    labels for variables and variable codes. Section 2.4 of this chapter looks at
    annotating datasets, while section 2.5 reviews some useful functions for working
    with datasets. Let’s start with the basics.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 创建数据集后，您通常会对其进行标注，为变量和变量代码添加描述性标签。本章的 2.4 节探讨了数据集的标注，而 2.5 节回顾了一些用于处理数据集的有用函数。让我们从基础知识开始。
- en: 2.1 Understanding datasets
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 理解数据集
- en: A dataset is usually a rectangular array of data with rows representing observations
    and columns representing variables. Table 2.1 provides an example of a hypothetical
    patient dataset.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集通常是一个矩形数组，行代表观测值，列代表变量。表 2.1 提供了一个假设的患者数据集示例。
- en: Table 2.1 A patient dataset
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.1 患者数据集
- en: '| PatientID | AdmDate | Age | Diabetes | Status |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| PatientID | AdmDate | Age | Diabetes | Status |'
- en: '| 1 | 10/15/2018 | 25 | Type1 | Poor |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 10/15/2018 | 25 | Type1 | Poor |'
- en: '| 2 | 11/01/2018 | 34 | Type2 | Improved |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 11/01/2018 | 34 | Type2 | Improved |'
- en: '| 3 | 10/21/2018 | 28 | Type1 | Excellent |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 10/21/2018 | 28 | Type1 | Excellent |'
- en: '| 4 | 10/28/2018 | 52 | Type1 | Poor |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 10/28/2018 | 52 | Type1 | Poor |'
- en: Different traditions have different names for the rows and columns of a dataset.
    Statisticians refer to them as observations and variables, database analysts call
    them records and fields, and those from the data mining and machine learning disciplines
    call them examples and attributes. I use the terms *observations* and *variables*
    throughout this book.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的传统对数据集的行和列有不同的称呼。统计学家称它们为观测值和变量，数据库分析师称它们为记录和字段，而数据挖掘和机器学习领域的专家称它们为示例和属性。我在本书中使用了
    *观测值* 和 *变量* 这两个术语。
- en: You can distinguish between the structure of the dataset (in this case, a rectangular
    array) and the contents or data types included. In the dataset shown in table
    2.1, `PatientID` is a row or case identifier, `AdmDate` is a date variable, `Age`
    is a continuous (quantitative) variable, `Diabetes` is a nominal variable, and
    `Status` is an ordinal variable. Both nominal and ordinal variables are categorical,
    but the categories in an ordinal variable have a natural ordering.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以区分数据集的结构（在这种情况下，一个矩形数组）和包含的内容或数据类型。在表 2.1 所示的数据集中，`PatientID` 是行或案例标识符，`AdmDate`
    是日期变量，`Age` 是连续（定量）变量，`Diabetes` 是名义变量，而 `Status` 是有序变量。名义变量和有序变量都是分类变量，但有序变量中的类别具有自然顺序。
- en: R contains a wide variety of structures for holding data, including scalars,
    vectors, arrays, data frames, and lists. Table 2.1 corresponds to a data frame
    in R. This diversity of structures provides the R language with a great deal of
    flexibility in dealing with data.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: R拥有多种用于存储数据的结构，包括标量、向量、数组、数据框和列表。表2.1对应于R中的数据框。这种结构的多样性为R语言在处理数据方面提供了很大的灵活性。
- en: The data types that R can handle include numeric, character, logical (`TRUE`/`FALSE`),
    complex (imaginary numbers), and raw (bytes). In R, `PatientID`, `AdmDate`, and
    `Age` are numeric variables, whereas `Diabetes` and `Status` are character variables.
    Additionally, you need to tell R that `PatientID` is a case identifier, that `AdmDate`
    contains dates, and that `Diabetes` and `Status` are nominal and ordinal variables,
    respectively. R refers to case identifiers as `rownames` and categorical variables
    (nominal, ordinal) as `factors`. We’ll cover each of these in the next section.
    You’ll learn about dates in chapter 3.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: R可以处理的数据类型包括数值、字符、逻辑（`TRUE`/`FALSE`）、复数（虚数）和原始（字节）。在R中，`PatientID`、`AdmDate`和`Age`是数值变量，而`Diabetes`和`Status`是字符变量。此外，您需要告诉R
    `PatientID`是一个案例标识符，`AdmDate`包含日期，以及`Diabetes`和`Status`分别是名义变量和有序变量。R将案例标识符称为`rownames`，将分类变量（名义、有序）称为`factors`。我们将在下一节中介绍这些内容。您将在第3章中了解日期。
- en: 2.2 Data structures
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 数据结构
- en: R has a wide variety of objects for holding data, including scalars, vectors,
    matrices, arrays, data frames, and lists. They differ in terms of the type of
    data they can hold, how they’re created, their structural complexity, and the
    notation used to identify and access individual elements. Figure 2.1 shows a diagram
    of these data structures. Let’s look at each structure in turn, starting with
    vectors.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: R拥有多种用于存储数据的对象，包括标量、向量、矩阵、数组、数据框和列表。它们在可以存储的数据类型、创建方式、结构复杂性和用于标识和访问单个元素的符号方面有所不同。图2.1显示了这些数据结构的图解。让我们依次查看每个结构，从向量开始。
- en: '![](Images/CH02_F01_Kabacoff3.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH02_F01_Kabacoff3.png)'
- en: Figure 2.1 R data structures
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 R数据结构
- en: Some definitions
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一些定义
- en: Several terms are idiosyncratic to R and thus confusing to new users.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一些术语是R特有的，因此对新用户来说可能会感到困惑。
- en: In R, an object is anything that can be assigned to a variable. This includes
    constants, data structures, functions, and even graphs. An object has a mode (which
    describes how the object is stored) and a *class* (which tells generic functions
    like `print` how to handle it).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在R中，任何可以分配给变量的东西都是对象。这包括常量、数据结构、函数，甚至是图表。对象有一个模式（描述对象如何存储）和一个*类*（告诉通用函数如`print`如何处理它）。
- en: A data frame is a structure in R that holds data and is similar to the datasets
    found in standard statistical packages (for example, SAS, SPSS, and Stata). The
    columns are variables, and the rows are observations. You can have variables of
    different types (for example, numeric or character) in the same data frame. Data
    frames are the main structures you use to store datasets.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: R中的数据框是一种结构，用于存储数据，类似于标准统计软件包（例如SAS、SPSS和Stata）中找到的数据集。列是变量，行是观测值。你可以在同一个数据框中拥有不同类型的变量（例如，数值或字符）。数据框是您存储数据集的主要结构。
- en: '*Factors* are nominal or ordinal variables. They’re stored and treated specially
    in R. You’ll learn about factors in section 2.2.5.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*因子*是名义或有序变量。在R中，它们被存储和处理得特别。你将在2.2.5节中了解因子。'
- en: Most other terms used in R should be familiar to you and follow the terminology
    used in statistics and computing in general.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: R中使用的其他大多数术语都应该对你来说很熟悉，并且遵循统计学和计算中的一般术语。
- en: 2.2.1 Vectors
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.1 向量
- en: 'Vectors are one-dimensional arrays that can hold numeric data, character data,
    or logical data. The combine function c() is used to form the vector. Here are
    examples of each type of vector:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 向量是一维数组，可以存储数值数据、字符数据或逻辑数据。组合函数c()用于形成向量。以下是每种类型向量的示例：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, `a` is a numeric vector, `b` is a character vector, and `c` is a logical
    vector. Note that the data in a vector must be of only one type or mode (numeric,
    character, or logical). You can’t mix modes in the same vector.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`a`是数值向量，`b`是字符向量，`c`是逻辑向量。请注意，向量中的数据必须只属于一种类型或模式（数值、字符或逻辑）。你无法在同一个向量中混合模式。
- en: NOTE *Scalars* are one-element vectors. Examples include `f` `<-` `3`, `g` `<-`
    `"US"`, and `h` `<-` `TRUE`. They’re used to hold constants.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：*标量*是单元素向量。例如，`f <- 3`、`g <- "US"`和`h <- TRUE`。它们用于存储常量。
- en: 'You can refer to elements of a vector using a numeric vector of positions within
    square brackets. Unlike programming languages such as C++, Java, and Python, R
    position indices start with 1 rather than 0\. For example, `a[c(1,` `3)]` refers
    to the first and third elements of vector `a`. Here are additional examples:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用方括号内的位置数值向量来引用向量的元素。与 C++、Java 和 Python 等编程语言不同，R 的位置索引从 1 开始而不是从 0 开始。例如，`a[c(1,
    3)]` 指的是向量 `a` 的第一个和第三个元素。以下是一些额外的示例：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The colon operator used in the last statement generates a sequence of numbers.
    For example, `a` `<-` `c(2:6)` is equivalent to `a` `<-` `c(2,` `3,` `4,` `5,`
    `6)`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一条语句中使用的冒号运算符生成一个数字序列。例如，`a <- c(2:6)` 等同于 `a <- c(2, 3, 4, 5, 6)`。
- en: 2.2.2 Matrices
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.2 矩阵
- en: A *matrix* is a two-dimensional array in which each element has the same mode
    (numeric, character, or logical). Matrices are created with the `matrix` function.
    The general format is
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵是一个二维数组，其中每个元素具有相同的模式（数值、字符或逻辑）。矩阵使用 `matrix` 函数创建。一般格式为
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: where `vector` contains the elements for the matrix, `nrow` and `ncol` specify
    the row and column dimensions, and `dimnames` contains optional row and column
    labels stored in character vectors. The option `byrow` indicates whether the matrix
    should be filled in by row (`byrow=TRUE`) or by column `(byrow=FALSE`). The default
    is by column. The following listing demonstrates the `matrix` function.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `vector` 包含矩阵的元素，`nrow` 和 `ncol` 指定行和列的维度，而 `dimnames` 包含可选的行和列标签，这些标签存储在字符向量中。选项
    `byrow` 表示矩阵是按行填充（`byrow=TRUE`）还是按列填充（`byrow=FALSE`）。默认是按列填充。以下列表展示了 `matrix`
    函数的用法。
- en: Listing 2.1 Creating matrices
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.1 创建矩阵
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Creates a 5 × 4 matrix
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个 5 × 4 矩阵
- en: ❷ 2 × 2 matrix filled by rows
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 按行填充的 2 × 2 矩阵
- en: ❸ 2 × 2 matrix filled by columns
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 按列填充的 2 × 2 矩阵
- en: First, you create a 5 × 4 matrix ❶. Then you create a 2 × 2 matrix with labels
    and fill the matrix by rows ❷. Finally, you create a 2 × 2 matrix and fill the
    matrix by columns ❸.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你创建一个 5 × 4 矩阵 ❶。然后你创建一个带有标签的 2 × 2 矩阵并按行填充 ❷。最后，你创建一个 2 × 2 矩阵并按列填充 ❸。
- en: You can identify rows, columns, or elements of a matrix by using subscripts
    and brackets. `X[i,]` refers to the *i*th row of matrix X, `X[,j]` refers to the
    *j*th column, and `X[i,` `j]` refers to the *ij*th element, respectively. The
    subscripts *i* and *j* can be numeric vectors to select multiple rows or columns,
    as shown in the following listing.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用子脚本和方括号来识别矩阵的行、列或元素。`X[i,]` 指的是矩阵 X 的第 *i* 行，`X[,j]` 指的是第 *j* 列，而 `X[i,j]`
    分别指的是第 *ij* 个元素。子脚本 *i* 和 *j* 可以是数值向量，以选择多行或多列，如下面的列表所示。
- en: Listing 2.2 Using matrix subscripts
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.2 使用矩阵子脚本
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: First, you create a 2 x 5 matrix containing the numbers 1 to 10\. By default,
    the matrix is filled by column. Then the elements in the second row are selected,
    followed by the elements in the second column. Next, the element in the first
    row and fourth column is selected. Finally, the elements in the first row and
    the fourth and fifth columns are selected.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你创建一个包含数字 1 到 10 的 2 x 5 矩阵。默认情况下，矩阵是按列填充的。然后选择第二行的元素，接着选择第二列的元素。接下来，选择第一行和第四列的元素。最后，选择第一行和第四、第五列的元素。
- en: Matrices are two-dimensional and, like vectors, can contain only one data type.
    When there are more than two dimensions, you use arrays (see section 2.2.3). When
    there are multiple modes of data, you use data frames (see section 2.2.4).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵是二维的，并且像向量一样，只能包含一种数据类型。当维度超过两个时，你使用数组（参见 2.2.3 节）。当存在多种数据模式时，你使用数据框（参见 2.2.4
    节）。
- en: 2.2.3 Arrays
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.3 数组
- en: '*Arrays* are similar to matrices but can have more than two dimensions. They’re
    created with an `array` function of the following form:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 数组与矩阵类似，但可以具有超过两个维度。它们使用以下形式的 `array` 函数创建：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: where `vector` contains the data for the array, `dimensions` is a numeric vector
    giving the maximal index for each dimension, and `dimnames` is an optional list
    of dimension labels. The following listing gives an example of creating a three-dimensional
    (2 × 3 × 4) array of numbers.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `vector` 包含数组的元素，`dimensions` 是一个数值向量，给出每个维度的最大索引，而 `dimnames` 是一个可选的维度标签列表。以下列表给出了创建一个三维（2
    × 3 × 4）数字数组的示例。
- en: Listing 2.3 Creating an array
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.3 创建数组
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, arrays are a natural extension of matrices. They can be useful
    in creating functions that perform statistical calculations. Like matrices, they
    must be of a single mode. Identifying elements follows what you’ve seen for matrices.
    In the previous example, the `z[1,2,3]` element is 15.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，数组是矩阵的自然扩展。它们在创建执行统计计算的函数时可能很有用。像矩阵一样，它们必须是单一模式。识别元素遵循您之前看到的矩阵方法。在前面的例子中，`z[1,2,3]`元素是15。
- en: 2.2.4 Data frames
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.4 数据框
- en: A *data frame* is more general than a matrix in that different columns can contain
    different modes of data (numeric, character, and so on). It’s similar to the dataset
    you’d typically see in SAS, SPSS, and Stata. Data frames are the most common data
    structure you’ll deal with in R.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 与矩阵相比，*数据框*更通用，因为不同的列可以包含不同模式的数据（数值、字符等）。它类似于您通常在SAS、SPSS和Stata中看到的数据集。数据框是您在R中处理的最常见的数据结构。
- en: The patient dataset in table 2.1 consists of numeric and character data. Because
    there are multiple modes of data, you can’t contain the data in a matrix. In this
    case, a data frame is the structure of choice.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.1中的患者数据集包含数值和字符数据。由于存在多种数据模式，您不能将数据包含在矩阵中。在这种情况下，数据框是首选的结构。
- en: 'A data frame is created with the `data.frame()` function:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 数据框是通过`data.frame()`函数创建的：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: where `col1`, `col2`, `col3`, and so on are column vectors of any type (such
    as character, numeric, or logical). Names for each column can be provided with
    the `names` function. The following listing makes this clear.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`col1`、`col2`、`col3`等是任何类型的列向量（如字符、数值或逻辑）。可以使用`names`函数提供每列的名称。以下列表清楚地说明了这一点。
- en: Listing 2.4 Creating a data frame
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.4 创建数据框
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Each column must have only one mode (e.g., numeric, character, logical), but
    you can put columns of different modes together to form the data frame. Because
    data frames are close to what analysts typically think of as datasets, we’ll use
    the terms *columns* and *variables* interchangeably when discussing data frames.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 每列必须只包含一种模式（例如，数值、字符、逻辑），但您可以组合不同模式的列来形成数据框。因为数据框接近分析师通常认为的数据集，所以在讨论数据框时，我们将交替使用*列*和*变量*这两个术语。
- en: There are several ways to identify the elements of a data frame. You can use
    the subscript notation you used before (for example, with matrices), or you can
    specify column names. Using the `patientdata` data frame created earlier, the
    following listing demonstrates these approaches.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以识别数据框的元素。您可以使用之前使用的下标符号（例如，使用矩阵），或者指定列名。使用之前创建的`patientdata`数据框，以下列表演示了这些方法。
- en: Listing 2.5 Specifying elements of a data frame
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.5 指定数据框的元素
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Indicates the age variable in the patient data frame
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 表示患者数据框中的年龄变量
- en: 'The $ notation in the third example is new. It’s used to indicate a particular
    variable from a given data frame. For example, if you want to cross-tabulate diabetes
    type by status, you can use the following code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个例子中的`$`符号是新的。它用于指明给定数据框中的特定变量。例如，如果您想按状态交叉表糖尿病类型，可以使用以下代码：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It can get tiresome typing `patientdata$` at the beginning of every variable
    name, but shortcuts are available. For example, the `with()` function can simplify
    your code.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 每次在变量名开头输入`patientdata$`可能会感到繁琐，但有一些快捷方式可用。例如，`with()`函数可以简化您的代码。
- en: Using with
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用with
- en: Consider the built-in data frame `mtcars`, which contains fuel efficiency data
    on 32 automobiles. The code
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑内置的数据框`mtcars`，它包含32辆汽车的燃油效率数据。以下代码
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: provides a summary of the miles per gallon (`mpg`) variable, along with plots
    of mpg versus engine displacement and car weight. You can write this code mode
    concisely as
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了每加仑英里数(`mpg`)变量的摘要，以及mpg与发动机排量和汽车重量的图表。您可以将此代码简洁地写成
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The statements within the {} brackets are evaluated with reference to the `mtcars`
    data frame. If there’s only one statement (for example, `summary(mpg)`), the {}
    brackets are optional.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`{}`括号内的语句是相对于`mtcars`数据框进行评估的。如果只有一个语句（例如，`summary(mpg)`），则`{}`括号是可选的。'
- en: The limitation of the `with()` function is that assignments exist only within
    the function brackets. Consider
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`with()`函数的限制在于赋值仅存在于函数括号内。考虑'
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you need to create objects that will exist outside of the `with()` construct,
    use the special assignment operator (<<-) instead of the standard one (<-). It
    saves the object to the global environment outside of the `with()` call. This
    can be demonstrated with the following code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要创建在`with()`结构之外存在的对象，请使用特殊的赋值运算符（<<-）而不是标准的一个（<-）。它将对象保存到`with()`调用之外的全球环境中。这可以通过以下代码演示：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Case identifiers
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 案例标识符
- en: In the patient data example, `patientID` is used to identify observations in
    the dataset. In R, case identifiers can be specified with a `rowname` option in
    the `data .frame()` function. For example, the statement
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在患者数据示例中，`patientID`用于识别数据集中的观测值。在R中，案例标识符可以通过`data.frame()`函数中的`rowname`选项进行指定。例如，以下语句
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: specifies `patientID` as the variable to use in labeling cases on various printouts
    and graphs R produces.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 指定`patientID`为在R生成的各种打印输出和图表中用于标记案例的变量。
- en: 2.2.5 Factors
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.5 因素
- en: As you’ve seen, variables can be described as nominal, ordinal, or continuous.
    Nominal variables are categorical, without an implied order. `Diabetes` (`Type1`,
    `Type2`) is an example of a nominal variable. Even if `Type1` is coded as a 1
    and `Type2` is coded as a 2 in the data, no order is implied. Ordinal variables
    imply order, but not amount. `Status` (`poor`, `improved`, `excellent`) is a good
    example of an ordinal variable. You know that a patient with a poor status isn’t
    doing as well as a patient with an improved status, but not by how much. Continuous
    variables can take on any value within some range, and both order and amount are
    implied. `Age` in years is a continuous variable and can take on values such as
    `14.5` or `22.8` and any value in between. You know that someone who is 15 is
    1 year older than someone who is 14.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，变量可以被描述为名义的、有序的或连续的。名义变量是分类的，没有隐含的顺序。`Diabetes`（`Type1`，`Type2`）是一个名义变量的例子。即使`Type1`在数据中编码为1，`Type2`编码为2，也没有隐含的顺序。有序变量隐含着顺序，但没有数量。`Status`（`poor`，`improved`，`excellent`）是有序变量的一个好例子。你知道一个状况较差的患者不如状况改善的患者，但不知道差多少。连续变量可以取某个范围内的任何值，并且隐含着顺序和数量。`Age`（年）是一个连续变量，可以取如`14.5`或`22.8`以及介于两者之间的任何值。你知道15岁的人比14岁的人年长1岁。
- en: Categorical (nominal) and ordered categorical (ordinal) variables in R are called
    *factors*. Factors are crucial in R because they determine how data is analyzed
    and presented visually. You’ll see examples of this throughout the book.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在R中，分类（名义）和有序分类（有序）变量被称为*因子*。因子在R中至关重要，因为它们决定了数据如何被分析和以视觉方式呈现。你将在本书的各个部分看到这方面的例子。
- en: The function `factor()` stores the categorical values as a vector of integers
    in the range [1... *k*] (where *k* is the number of unique values in the nominal
    variable) and an internal vector of character strings (the original values) mapped
    to these integers.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`factor()`函数将分类值存储为范围在[1... *k*]（其中*k*是名义变量中唯一值的数量）的整数向量，以及一个映射到这些整数的字符字符串内部向量（原始值）。'
- en: 'For example, assume that you have this vector:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你有以下向量：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The statement `diabetes <- factor(diabetes)` stores this vector as `(1,` `2,`
    `1,` `1)` and associates it with `1=Type1` and `2=Type2` internally (the assignment
    is alphabetical). Any analyses performed on the vector `diabetes` will treat the
    variable as nominal and select the statistical methods that are appropriate for
    this level of measurement.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 语句`diabetes <- factor(diabetes)`将此向量存储为`(1,` `2,` `1,` `1)`，并将其与内部关联的`1=Type1`和`2=Type2`（赋值是按字母顺序的）相关联。对`diabetes`向量进行的任何分析都将将该变量视为名义变量，并选择适合此测量水平的统计方法。
- en: For vectors representing ordinal variables, you add the parameter `ordered=TRUE`
    to the `factor()` function. Given the vector
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于表示有序变量的向量，你需要在`factor()`函数中添加参数`ordered=TRUE`。给定以下向量
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: the statement `status` `<-` `factor(status,` `ordered=TRUE)` will encode the
    vector as `(3,` `2,` `1,` `3)` and associate these values internally as `1=Excellent`,
    `2=Improved`, and `3=Poor`. Additionally, any analyses performed on this vector
    will treat the variable as ordinal and select the statistical methods appropriately.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 语句`status` `<-` `factor(status,` `ordered=TRUE)`将向量编码为`(3,` `2,` `1,` `3)`，并将其内部关联的值设置为`1=Excellent`，`2=Improved`和`3=Poor`。此外，对这一向量进行的任何分析都将将该变量视为有序变量，并选择适当的统计方法。
- en: By default, factor levels for character vectors are created in alphabetical
    order. This worked for the `status` factor, because the order “Excellent,” “Improved,”
    “Poor” made sense. There would have been a problem if “Poor” had been coded as
    “Ailing” instead, because the order would have been “Ailing,” “Excellent,” “Improved.”
    A similar problem would exist if the desired order was “Poor,” “Improved,” “Excellent”.
    For ordered factors, the alphabetical default is rarely sufficient.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，字符向量的因子等级按字母顺序创建。这对于 `status` 因子来说有效，因为“Excellent”、“Improved”、“Poor”的顺序是有意义的。如果“Poor”被编码为“Ailing”，则会出现问题，因为顺序将是“Ailing”、“Excellent”、“Improved”。如果期望的顺序是“Poor”、“Improved”、“Excellent”，则也会存在类似的问题。对于有序因子，字母顺序的默认值很少足够。
- en: You can override the default by specifying a levels option. For example,
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过指定等级选项来覆盖默认设置。例如，
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: assigns the levels as `1=Poor`, `2=Improved`, and `3=Excellent`. Be sure the
    specified levels match your actual data values. Any data values not in the list
    will be set to `missing`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 将等级分配为 `1=Poor`、`2=Improved` 和 `3=Excellent`。确保指定的等级与您的实际数据值相匹配。任何不在列表中的数据值将被设置为
    `missing`。
- en: Numeric variables can be coded as factors using the `levels` and `labels` options.
    If sex was coded as `1` for male and `2` for female in the original data, then
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 数值变量可以使用 `levels` 和 `labels` 选项编码为因子。如果原始数据中将性别编码为 `1` 表示男性，`2` 表示女性，那么
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: would convert the variable to an unordered factor. Note that the order of the
    labels must match the order of the levels. In this example, sex would be treated
    as categorical, the labels `"Male"` and `"Female"` would appear in the output
    instead of `1` and `2`, and any sex value that wasn’t initially coded as a `1`
    or `2` would be set to `missing`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 将变量转换为无序因子。注意标签的顺序必须与等级的顺序相匹配。在这个例子中，性别将被视为分类变量，输出中将出现 `"Male"` 和 `"Female"`
    标签而不是 `1` 和 `2`，任何最初未编码为 `1` 或 `2` 的性别值将被设置为 `missing`。
- en: The following listing demonstrates how specifying factors and ordered factors
    impacts data analyses.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表演示了指定因子和有序因子如何影响数据分析。
- en: Listing 2.6 Using factors
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.6 使用因子
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ Enters data as vectors
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将数据作为向量输入
- en: ❷ Displays the object structure
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 显示对象结构
- en: ❸ Displays the object summary
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 显示对象摘要
- en: First, you enter the data as vectors ❶. Then you specify that `diabetes` is
    a factor and `status` is an ordered factor. Finally, you combine the data into
    a data frame. The function `str(object)` provides information about an object
    in R (the data frame, in this case) ❷. The output indicates that `diabetes` is
    a factor and `status` is an ordered factor, along with how they’re coded internally.
    Note that the `summary()` function treats the variables differently ❸. It provides
    the minimum, maximum, mean, and quartiles for the continuous variable `age` and
    frequency counts for the categorical variables `diabetes` and `status`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你将数据作为向量输入 ❶。然后指定 `diabetes` 是一个因子，`status` 是一个有序因子。最后，将数据组合到一个数据框中。函数 `str(object)`
    提供了有关 R 中对象（在这种情况下是数据框）的信息。输出表明 `diabetes` 是一个因子，`status` 是一个有序因子，以及它们是如何内部编码的。请注意，`summary()`
    函数对变量有不同的处理方式 ❸。它为连续变量 `age` 提供最小值、最大值、平均值和四分位数，为分类变量 `diabetes` 和 `status` 提供频率计数。
- en: 2.2.6 Lists
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.6 列表
- en: 'Lists are the most complex of the R data types. Basically, a list is an ordered
    collection of objects (components). A list allows you to gather a variety of (possibly
    unrelated) objects under one name. For example, a list may contain a combination
    of vectors, matrices, data frames, and even other lists. You create a list using
    the `list()` function:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是 R 数据类型中最复杂的。基本上，列表是有序对象（组件）的集合。列表允许你将各种（可能无关的）对象汇集在一个名称下。例如，列表可以包含向量、矩阵、数据框甚至其他列表的组合。你可以使用
    `list()` 函数创建列表：
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'where the objects are any of the structures seen so far. Optionally, you can
    name the objects in a list:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 其中对象是迄今为止看到的任何结构。可选地，你可以在列表中命名对象：
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The following listing shows an example.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了一个示例。
- en: Listing 2.7 Creating a list
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.7 创建列表
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ Creates a list
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建列表
- en: ❷ Prints the entire list
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 打印整个列表
- en: ❸ Prints the second component
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 打印第二个组件
- en: 'In this example, you create a list with four components: a string, a numeric
    vector, a matrix, and a character vector. You can combine any number of objects
    and save them as a list.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你创建了一个包含四个组件的列表：一个字符串、一个数值向量、一个矩阵和一个字符向量。你可以组合任意数量的对象并将它们保存为列表。
- en: You can also specify elements of the list by indicating a component number or
    a name within double brackets. In this example, `mylist[[2]]` and `mylist [["ages"]]`
    both refer to the same four-element numeric vector. For named components, `mylist$ages`
    would also work. Lists are important R structures for two reasons. First, they
    allow you to organize and recall disparate information in a simple way. Second,
    the results of many R functions return lists. It’s up to the analyst to pull out
    the components that are needed. You’ll see numerous examples of functions that
    return lists in later chapters.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过指定组件编号或双括号内的名称来指定列表的元素。在这个例子中，`mylist[[2]]` 和 `mylist [["ages"]]` 都指向同一个包含四个元素的数值向量。对于命名组件，`mylist$ages`
    也会起作用。列表是重要的 R 结构，原因有两个。首先，它们允许您以简单的方式组织和回忆不同的信息。其次，许多 R 函数的结果返回列表。分析员需要提取所需的组件。您将在后面的章节中看到许多返回列表的函数的例子。
- en: 2.2.7 Tibbles
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.7 Tibbles
- en: Before moving on, it is worth mentioning tibbles, which are data frames that
    have specialized behaviors that are designed to make them more useful. They’re
    created using either the `tibble()` or `as_tibble()` function from the `tibble`
    package. To install the `tibble` package, use `install.packages("tibble")`. Some
    of their attractive features are described below.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，值得提一下 tibbles，它们是具有专门行为的数据框，旨在使它们更有用。它们可以通过 `tibble()` 或 `as_tibble()`
    函数从 `tibble` 包中创建。要安装 `tibble` 包，请使用 `install.packages("tibble")`。以下是一些它们吸引人的特性描述。
- en: 'Tibbles print in a more compact format than standard data frames. Additionally,
    variable labels describe the data type of each column:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Tibbles 打印的格式比标准数据框更紧凑。此外，变量标签描述了每列的数据类型：
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Tibbles never convert character variables to factors. In older versions of R
    (prior to R 4.0), functions such as `read.table()`, `data.frame()` and `as.data.frame()`
    convert character data to factors by default. You would have to add the option
    `stringsAsFactors` `=` `FALSE` to these functions to suppress this behavior.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Tibbles 从不将字符变量转换为因子。在 R 的旧版本（R 4.0 之前），函数如 `read.table()`、`data.frame()` 和
    `as.data.frame()` 默认将字符数据转换为因子。您必须向这些函数添加 `stringsAsFactors` `=` `FALSE` 选项来抑制此行为。
- en: Tibbles never change the names of variables. If the dataset being imported has
    a variable called `Last` `Address`, base R functions would convert the name to
    `Last.Address`, since R variable names don’t use spaces. Tibbles would keep the
    name as is and use backticks (e.g., `` `Last `` `` Address` ``) to make the variable
    name syntactically correct.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Tibbles 从不更改变量的名称。如果正在导入的数据集有一个名为 `Last` `Address` 的变量，基础 R 函数会将名称转换为 `Last.Address`，因为
    R 变量名称不使用空格。Tibbles 会保持名称不变，并使用反引号（例如，`` `Last `` `` Address` ``）使变量名称在语法上正确。
- en: Subsetting a tibble always returns a tibble. For example, subsetting the `mtcars`
    data frame using `mtcars[,"mpg"]` would return a vector, rather than a one-column
    data frame. R automatically simplifies the results. To get a one-column data frame,
    you would have to include the `drop` `=` `FALSE` option (`mtcars[,` `"mpg",` `drop`
    `=` `FALSE]`). In contrast, if `mtcars` is a tibble, then `mtcars[,` `"mpg"]`
    would return a one-column tibble. The results are not simplified, allowing you
    to easily predict what the results of a subsetting operation will return.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 对 tibble 进行子集操作总是返回一个 tibble。例如，使用 `mtcars[,"mpg"]` 对 `mtcars` 数据框进行子集操作会返回一个向量，而不是一个单列数据框。R
    会自动简化结果。要获取一个单列数据框，您必须包含 `drop` `=` `FALSE` 选项（`mtcars[,` `"mpg",` `drop` `=`
    `FALSE]`）。相比之下，如果 `mtcars` 是一个 tibble，那么 `mtcars[,` `"mpg"]` 会返回一个单列的 tibble。结果不会被简化，这使得您可以轻松预测子集操作的结果。
- en: Finally, tibbles don’t support row names. The function `rownames_to_column()`
    can be used to convert the row names in a data frame to a variable in a tibble.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，tibbles 不支持行名。可以使用 `rownames_to_column()` 函数将数据框中的行名转换为 tibble 中的变量。
- en: Tibbles are important because many popular packages, such as `readr`, `tidyr`,
    `dplyr`, and `purr`, save data frames as tibbles. Although tibbles have been designed
    to be “a modern take on data frames,” note that they can be used interchangeably
    with data frames. Any function that requires a data frame can take a tibble and
    vice versa. To learn more, see [https://r4ds.had.co.nz/tibbles.html](https://r4ds.had.co.nz/tibbles.html).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Tibbles 很重要，因为许多流行的包，如 `readr`、`tidyr`、`dplyr` 和 `purr`，将数据框保存为 tibbles。虽然 tibbles
    被设计成“数据框的现代版本”，但请注意，它们可以与数据框互换使用。任何需要数据框的函数都可以接受 tibble，反之亦然。要了解更多信息，请参阅 [https://r4ds.had.co.nz/tibbles.html](https://r4ds.had.co.nz/tibbles.html)。
- en: A note for programmers
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员注意事项
- en: 'Experienced programmers typically find several aspects of the R language unusual.
    Here are some features of the language you should be aware of:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 经验丰富的程序员通常会发现 R 语言的一些方面很独特。以下是您应该注意的语言特性：
- en: The period (.) has no special significance in object names. The dollar sign
    ($) has a somewhat analogous meaning to the period in other object-oriented languages
    and can be used to identify the parts of a data frame or list. For example, `A$x`
    refers to variable `x` in data frame `A`.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逗号 (.) 在对象名称中没有特殊意义。美元符号 ($) 在其他面向对象的语言中与逗号有类似的意义，可以用来标识数据框或列表的部分。例如，`A$x` 指的是数据框
    `A` 中的变量 `x`。
- en: R doesn’t provide multiline or block comments. You must start each line of a
    multiline comment with `#`. For debugging purposes, you can also surround code
    that you want the interpreter to ignore with the statement `if(FALSE){...}`. Changing
    the `FALSE` to `TRUE` allows the code to be executed.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: R 不提供多行或块注释。您必须以 `#` 开头每一行多行注释。为了调试目的，您还可以用语句 `if(FALSE){...}` 将您希望解释器忽略的代码包围起来。将
    `FALSE` 改为 `TRUE` 允许代码执行。
- en: 'Assigning a value to a nonexistent element of a vector, matrix, array, or list
    expands that structure to accommodate the new value. For example, consider the
    following:'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将值分配给向量、矩阵、数组或列表中不存在的元素会扩展该结构以容纳新值。例如，考虑以下情况：
- en: '[PRE25]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The vector `x` has expanded from 3 to 7 elements through the assignment. `x
    <- x[1:3]` would shrink it back to 7 elements.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 向量 `x` 通过赋值从 3 个元素扩展到 7 个元素。`x <- x[1:3]` 会将其缩小回 7 个元素。
- en: R doesn’t have scalar values. Scalars are represented as one-element vectors.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: R 没有标量值。标量值表示为一元素向量。
- en: Indices in R start at 1, not at 0\. In the vector earlier, `x[1]` is 8.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: R 中的索引从 1 开始，而不是从 0 开始。在之前的向量中，`x[1]` 的值是 8。
- en: Variables can’t be declared. They come into existence on first assignment.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量不能声明。它们在第一次赋值时才会存在。
- en: To learn more, see John Cook’s excellent blog post, “R Language for Programmers”
    ([http://mng.bz/6NwQ](http://mng.bz/6NwQ)). Programmers looking for stylistic
    guidance may also want to check out Hadley Wickham’s The Tidyverse Style Guide
    ([https://style.tidyverse.org/](https://style.tidyverse.org/)).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多信息，请参阅 John Cook 的优秀博客文章，“R Language for Programmers” ([http://mng.bz/6NwQ](http://mng.bz/6NwQ))。寻找风格指导的程序员也可能想查看
    Hadley Wickham 的 The Tidyverse Style Guide ([https://style.tidyverse.org/](https://style.tidyverse.org/))。
- en: 2.3 Data input
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 数据输入
- en: Now that you have data structures, you need to put some data in them. As a data
    analyst, you’re typically faced with data that comes from a variety of sources
    and in a variety of formats. Your task is to import the data into your tools,
    analyze the data, and report on the results. R provides a wide range of tools
    for importing data. The definitive guide for importing data in R is the *R Data
    Import/Export* manual available at [http://mng.bz/urwn](http://mng.bz/urwn).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您有了数据结构，您需要将一些数据放入其中。作为一名数据分析师，您通常面临来自各种来源和格式的数据。您的任务是导入数据到您的工具中，分析数据，并报告结果。R
    提供了广泛的数据导入工具。R 中导入数据的 definitive guide 是可在 [http://mng.bz/urwn](http://mng.bz/urwn)
    获取的 *R Data Import/Export* 手册。
- en: As you can see in figure 2.2, R can import data from the keyboard, from text
    files, from Microsoft Excel and Access, from popular statistical packages, from
    a variety of relational database management systems, from specialty databases,
    and from websites and online services. Because you never know where your data
    will come from, we’ll cover each of them here. You only need to read about the
    ones you’re going to be using.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如图 2.2 所示，R 可以从键盘、文本文件、Microsoft Excel 和 Access、流行的统计软件包、各种关系型数据库管理系统、专用数据库、以及网站和在线服务导入数据。由于您永远不知道数据会从哪里来，我们将在这里介绍它们。您只需阅读您将要使用的内容。
- en: '![](Images/CH02_F02_Kabacoff3.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH02_F02_Kabacoff3.png)'
- en: Figure 2.2 Sources of data that can be imported into R
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 可以导入 R 的数据源
- en: 2.3.1 Entering data from the keyboard
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.1 从键盘输入数据
- en: 'Perhaps the simplest way to enter data is from the keyboard. There are two
    common methods: entering data through R’s built-in text editor and embedding data
    directly into your code. We’ll consider the editor first.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 输入数据最简单的方法可能是从键盘输入。有两种常见方法：通过 R 的内置文本编辑器输入数据和直接将数据嵌入到您的代码中。我们首先考虑编辑器。
- en: 'The `edit()` function in R invokes a text editor that lets you enter data manually.
    Here are the steps:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: R 中的 `edit()` 函数调用一个文本编辑器，允许您手动输入数据。以下是步骤：
- en: Create an empty data frame (or matrix) with the variable names and modes you
    want to have in the final dataset.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空的数据框（或矩阵），其中包含您希望在最终数据集中拥有的变量名称和模式。
- en: Invoke the text editor on this data object, enter your data, and save the results
    to the data object.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此数据对象上调用文本编辑器，输入您的数据，并将结果保存到数据对象中。
- en: 'The following example creates a data frame named `mydata` with three variables:
    `age` (numeric), `gender` (character), and `weight` (numeric). You then invoke
    the text editor, add your data, and save the results:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例创建了一个名为`mydata`的数据框，包含三个变量：`age`（数值）、`gender`（字符）和`weight`（数值）。然后您调用文本编辑器，添加您的数据，并保存结果：
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Assignments like `age=numeric(0)` create a variable of a specific mode, but
    without actual data. Note that the result of the editing is assigned back to the
    object itself. The `edit()` function operates on a copy of the object. If you
    don’t assign it a destination, all of your edits will be lost.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于`age=numeric(0)`的赋值创建了一个特定模式但无实际数据的变量。请注意，编辑的结果会赋值回对象本身。`edit()`函数在对象的副本上操作。如果您不指定目的地，您所做的所有编辑都将丢失。
- en: Figure 2.3 shows the results of invoking the `edit()` function on a Windows
    platform. In this figure, I’ve added some data. If you click a column title, the
    editor gives you the option of changing the variable name and type (numeric or
    character). You can add variables by clicking the titles of unused columns. When
    the text editor is closed, the results are saved to the object assigned (`mydata`,
    in this case). Invoking `mydata` `<-` `edit(mydata)` again allows you to edit
    the data you’ve entered and to add new data. A shortcut for `mydata` `<-` `edit(mydata)`
    is `fix(mydata)`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3展示了在Windows平台上调用`edit()`函数的结果。在此图中，我添加了一些数据。如果您点击列标题，编辑器会为您提供更改变量名称和类型的选项（数值或字符）。您可以通过点击未使用列的标题来添加变量。当文本编辑器关闭时，结果将保存到指定的对象中（在本例中为`mydata`）。再次调用`mydata`
    `<-` `edit(mydata)`允许您编辑已输入的数据并添加新数据。`mydata` `<-` `edit(mydata)`的快捷键是`fix(mydata)`。
- en: '![](Images/CH02_F03_Kabacoff3.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH02_F03_Kabacoff3.png)'
- en: Figure 2.3 Entering data via the built-in editor on a Windows platform
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3在Windows平台上通过内置编辑器输入数据
- en: 'Alternatively, you can embed the data directly in your program. For example,
    the following code creates the same data frame as that created with the `edit()`
    function:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以直接在程序中嵌入数据。例如，以下代码创建了一个与使用`edit()`函数创建的数据框相同的数据框：
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: A character string is created containing the raw data, and the `read.table()`
    function is used to process the string and return a data frame. The `read.table()`
    function is described more fully in the next section.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了一个包含原始数据的字符串，并使用`read.table()`函数处理该字符串，返回一个数据框。`read.table()`函数将在下一节中详细介绍。
- en: Keyboard data entry can be convenient when you’re working with small datasets.
    For larger datasets, you’ll want to use the methods described next for importing
    data from existing text files, Excel spreadsheets, statistical packages, or database-management
    systems.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当您处理小型数据集时，键盘数据输入可能很方便。对于大型数据集，您将想要使用下一节中描述的方法从现有的文本文件、Excel电子表格、统计软件包或数据库管理系统导入数据。
- en: 2.3.2 Importing data from a delimited text file
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.2 从分隔符文本文件导入数据
- en: You can import data from delimited text files using `read.table()`, a function
    that reads a file in table format and saves it as a data frame. Each row of the
    table appears as one line in the file. The syntax is
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`read.table()`函数从分隔符文本文件导入数据，该函数读取表格格式的文件并将其保存为数据框。表格的每一行在文件中表现为一行。语法是
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: where *`file`* is a delimited ASCII file and the *`options`* are parameters
    controlling how data is processed. Table 2.2 lists the most common options.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*`file`*是一个分隔符ASCII文件，而*`options`*是控制数据处理方式的参数。表2.2列出了最常见的选项。
- en: Table 2.2 `read.table()` options
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.2 `read.table()`选项
- en: '| Option | Description |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 描述 |'
- en: '| `header` | A logical value indicating whether the file contains the variable
    names in the first line. |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `header` | 一个逻辑值，指示文件是否在第一行包含变量名称。 |'
- en: '| `sep` | The delimiter separating data values. The default is `sep=""`, which
    denotes one or more spaces, tabs, new lines, or carriage returns. Use `sep=","`
    to read comma-delimited files, and `sep="\t"` to read tab-delimited files. |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `sep` | 分隔数据值的分隔符。默认为`sep=""`，表示一个或多个空格、制表符、换行符或回车符。使用`sep=","`读取逗号分隔的文件，使用`sep="\t"`读取制表符分隔的文件。
    |'
- en: '| `row.names` | An optional parameter specifying one or more variables to represent
    row identifiers. |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `row.names` | 一个可选参数，指定一个或多个变量作为行标识符。 |'
- en: '| `col.names` | If the first row of the data file doesn’t contain variable
    names (`header=FALSE`), you can use `col.names` to specify a character vector
    containing the variable names. If `header=FALSE` and the `col.names` option is
    omitted, variables will be named `V1`, `V2`, and so on. |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `col.names` | 如果数据文件的第一行不包含变量名（`header=FALSE`），可以使用 `col.names` 指定包含变量名的字符向量。如果
    `header=FALSE` 且省略了 `col.names` 选项，变量将被命名为 `V1`、`V2` 等等。 |'
- en: '| `na.strings` | An optional character vector indicating missing-values codes.
    For example, `na.strings=c("-9",` `"?")` converts each `-9` and `?` value to `NA`
    as the data is read. |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `na.strings` | 一个可选的字符向量，指示缺失值代码。例如，`na.strings=c("-9", "?")` 将读取数据时每个 `-9`
    和 `?` 值转换为 `NA`。 |'
- en: '| `colClasses` | An optional vector of classes to be assigned to the columns.
    For example, `colClasses=c("numeric",` `"numeric",` `"character",` `"NULL",` `"numeric")`
    reads the first two columns as numeric, reads the third column as character, skips
    the fourth column, and reads the fifth column as numeric. If there are more than
    five columns in the data, the values in `colClasses` are recycled. When you’re
    reading large text files, including the `colClasses` option can speed up processing
    considerably. |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `colClasses` | 一个可选的向量，用于指定列的类别。例如，`colClasses=c("numeric", "numeric", "character",
    "NULL", "numeric")` 将前两列读取为数值型，将第三列读取为字符型，跳过第四列，并将第五列读取为数值型。如果数据中有超过五列，`colClasses`
    中的值将循环使用。当你读取大型文本文件时，包括 `colClasses` 选项可以显著加快处理速度。 |'
- en: '| `quote` | Character(s) used to delimit strings that contain special characters.
    By default, this is either double (`"`) or single (`''`) quotes. |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `quote` | 用于分隔包含特殊字符的字符串的字符（或字符序列）。默认情况下，这是双引号（`"`）或单引号（`''`）。 |'
- en: '| `skip` | The number of lines in the data file to skip before beginning to
    read the data. This option is useful for skipping header comments in the file.
    |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `skip` | 在开始读取数据之前要跳过的数据文件中的行数。此选项对于跳过文件中的标题注释很有用。 |'
- en: '| `stringsAsFactors` | A logical value indicating whether character variables
    should be converted to factors. Before R 4.0, the default was `TRUE`. For more
    recent versions, the default is now `FALSE` unless it’s overridden by `colClasses`.
    When you’re processing large text files, setting `stringsAsFactors=FALSE` can
    speed up processing. |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `stringsAsFactors` | 一个逻辑值，指示字符变量是否应转换为因子。在 R 4.0 之前，默认值为 `TRUE`。对于更近期的版本，默认值现在是
    `FALSE`，除非被 `colClasses` 覆盖。当你处理大型文本文件时，设置 `stringsAsFactors=FALSE` 可以加快处理速度。
    |'
- en: '| `text` | A character string specifying a text string to process. If `text`
    is specified, leave `file` blank. Section 2.3.1 gives an example. |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `text` | 指定要处理的文本字符串的字符字符串。如果指定了 `text`，则留空 `file`。第 2.3.1 节提供了一个示例。 |'
- en: 'Consider a text file named studentgrades.csv containing students’ grades in
    math, science, and social studies. Each line of the file represents a student.
    The first line contains the variable names, separated with commas. Each subsequent
    line contains a student’s information, also separated with commas. The first few
    lines of the file are as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个名为 studentgrades.csv 的文本文件，其中包含学生的数学、科学和社会研究成绩。文件的每一行代表一个学生。第一行包含变量名，用逗号分隔。随后的每一行包含一个学生的信息，也用逗号分隔。文件的前几行如下所示：
- en: '[PRE29]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The file can be imported into a data frame using the following code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下代码将文件导入数据框：
- en: '[PRE30]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The results are
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是
- en: '[PRE31]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: There are several interesting things to note about how the data is imported.
    The variable name `Social` `Studies` is automatically renamed to follow R conventions.
    The `StudentID` column is now the row name, no longer has a label, and has lost
    its leading zero. The missing science grade for Jane is correctly read as missing.
    I had to put quotation marks around Dan’s last name to escape the comma between
    `Thornton` and `III`. Otherwise, R would have seen seven values on that line rather
    than six. I also had to put quotation marks around `O'Leary`. Otherwise, R would
    have read the single quote as a string delimiter, which isn’t what I want.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数据导入的几个有趣之处需要注意。变量名 `Social` `Studies` 会自动重命名为遵循 R 规范的名称。`StudentID` 列现在是行名，不再有标签，并且丢失了前导零。Jane
    缺失的科学成绩被正确地读取为缺失值。我不得不在 Dan 的姓氏 `Thornton` 和 `III` 之间的逗号周围加上引号以避免 R 将其视为七个值而不是六个。我还必须在
    `O'Leary` 周围加上引号。否则，R 会将单引号读取为字符串分隔符，这不是我想要的。
- en: The stringsAsFactors option
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: stringsAsFactors 选项
- en: ln the functions `read.table()`, `data.frame()`, and `as.data.frame()`, the
    `stringsAsFactors` option controls whether character variables are automatically
    converted to factors. Prior to R version 4.0.0, the default was `TRUE`. Starting
    with R 4.0.0, the default is `FALSE`. If you are using an older version of R,
    the variables `First` and `Last` in the previous example are now factors rather
    than character variables.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `read.table()`、`data.frame()` 和 `as.data.frame()` 函数中，`stringsAsFactors` 选项控制字符变量是否自动转换为因子。在
    R 版本 4.0.0 之前，默认值为 `TRUE`。从 R 4.0.0 开始，默认值为 `FALSE`。如果您使用的是 R 的较旧版本，则前一个示例中的 `First`
    和 `Last` 变量现在是因子而不是字符变量。
- en: Converting character variables to factors may not always be desirable. For example,
    there would be little reason to convert a character variable containing a respondent’s
    comments into a factor. Additionally, you may want to manipulate or mine the text
    in a variable, and this is hard to do once it has been converted to a factor.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 将字符变量转换为因子可能并不总是希望的。例如，将包含受访者评论的字符变量转换为因子几乎没有理由。此外，您可能想要操作或挖掘变量中的文本，一旦转换为因子，这就会变得很困难。
- en: You can suppress this behavior in several ways. Including the option `stringsAsFactors=FALSE`
    turns off this behavior for all character variables. Alternatively, you can use
    the `colClasses` option to specify a class (for example, logical, numeric, character,
    or factor) for each column.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过多种方式来抑制这种行为。包括 `stringsAsFactors=FALSE` 选项将关闭所有字符变量的此行为。或者，您可以使用 `colClasses`
    选项为每一列指定一个类（例如，逻辑、数值、字符或因子）。
- en: 'Let’s import the same data while specifying the class for each variable:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们指定每个变量的类来导入相同的数据：
- en: '[PRE32]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now the row names retain their leading zero, and `First` and `Last` are not
    factors (even in earlier versions of R). Additionally, the grades are stored as
    real values rather than integers.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在行名保留了前导零，并且 `First` 和 `Last` 不是因子（即使在 R 的早期版本中）。此外，成绩以实数值而不是整数值存储。
- en: The `read.table()` function has many options for fine-tuning data imports. See
    `help(read.table)` for details.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`read.table()` 函数提供了许多选项来微调数据导入。有关详细信息，请参阅 `help(read.table)`。'
- en: Importing data via connections
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 通过连接导入数据
- en: Many of the examples in this chapter import data from files that exist on your
    computer. R provides several mechanisms for accessing data via connections as
    well. For example, the functions `file(`), `gzfile()`, `bzfile()`, `xzfile()`,
    `unz()`, and `url()` can be used in place of the filename. The `file()` function
    allows you to access files, the clipboard, and C-level standard input. The `gzfile()`,
    `bzfile()`, `xzfile()`, and `unz()` functions let you read compressed files.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的许多示例都是从您计算机上存在的文件导入数据。R 还提供了几种机制来通过连接访问数据。例如，可以使用 `file()`、`gzfile()`、`bzfile()`、`xzfile()`、`unz()`
    和 `url()` 函数来代替文件名。`file()` 函数允许您访问文件、剪贴板和 C 级标准输入。`gzfile()`、`bzfile()`、`xzfile()`
    和 `unz()` 函数允许您读取压缩文件。
- en: The `url()` function lets you access internet files through a complete URL that
    includes http://, ftp://, or file://. For HTTP and FTP, proxies can be specified.
    For convenience, complete URLs (surrounded by double quotation marks) can usually
    be used directly in place of filenames as well. See `help(file)` for details.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`url()` 函数允许您通过包含 http://, ftp:// 或 file:// 的完整 URL 访问互联网文件。对于 HTTP 和 FTP，可以指定代理。为了方便，通常可以直接使用带双引号的完整
    URL 来代替文件名。有关详细信息，请参阅 `help(file)`。'
- en: Base R also provides the functions `read.csv()` and `read.delim()` for importing
    rectangular text files. These are simply wrapper functions that call `read.table()`
    with specific defaults. For example, `read.csv()` calls `read.table()` with `header
    =TRUE`, and `sep=","` while `read.delim()` calls `read.table()` with `header=TRUE`
    `and sep="\t`". Details are provided in the `read.table()` help.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 基础 R 还提供了 `read.csv()` 和 `read.delim()` 函数来导入矩形文本文件。这些函数只是调用 `read.table()`
    并使用特定默认值的包装函数。例如，`read.csv()` 使用 `header =TRUE` 和 `sep=","` 调用 `read.table()`，而
    `read.delim()` 使用 `header=TRUE` 和 `sep="\t"` 调用 `read.table()`。详细信息请参阅 `read.table()`
    帮助。
- en: 'The `readr` package provides a powerful alternative to base R functions for
    reading rectangular text files. The primary function is `read_delim()` with helper
    functions `read_csv()` and `read_tsv()` for reading comma-delimited and tab-delimited
    files, respectively. After installing the package, the previous data could have
    been read using this code:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`readr` 包为读取矩形文本文件提供了对基础 R 函数的强大替代。主要函数是 `read_delim()`，辅助函数 `read_csv()` 和
    `read_tsv()` 分别用于读取逗号分隔和制表符分隔的文件。安装该包后，可以使用以下代码读取之前的数据：'
- en: '[PRE33]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The package also provides for importing fixed-width files (where data appears
    in specific columns), tabular files (where columns are separated by whitespace),
    and web log files.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 该包还提供了导入固定宽度文件（数据出现在特定列中）、表格文件（列由空白字符分隔）和网页日志文件的功能。
- en: Functions in the `readr` package provide a number of advantages over those in
    base R. First and foremost, they are *significantly* faster. This can be a tremendous
    advantage when reading large data files. Additionally, they are very good at guessing
    the correct data type of each column (numeric, character, date, and date-time).
    Finally, unlike base R functions prior to R 4.0.0, they won’t convert character
    data to factors by default. Functions in the `readr` package return data as tibbles
    (data frames with some specialized features). To learn more, see [https://readr.tidyverse.org](https://readr.tidyverse.org).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`readr` 包中的函数在速度上比基础 R 的函数有显著优势。当读取大型数据文件时，这可以是一个巨大的优势。此外，它们非常擅长猜测每列的正确数据类型（数值、字符、日期和日期时间）。最后，与
    R 4.0.0 之前的 base R 函数不同，它们不会默认将字符数据转换为因子。`readr` 包中的函数将数据作为 tibbles（具有一些特殊功能的数据框）返回。要了解更多信息，请参阅
    [https://readr.tidyverse.org](https://readr.tidyverse.org)。'
- en: 2.3.3 Importing data from Excel
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.3 从 Excel 导入数据
- en: The best way to read an Excel file is to export it to a comma-delimited file
    from Excel and import it into R using the method described earlier. Alternatively,
    you can import Excel worksheets directly using the `readxl` package. Be sure to
    download and install it before you first use it.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 读取 Excel 文件的最佳方式是将它从 Excel 导出为逗号分隔的文件，然后使用前面描述的方法将其导入 R。或者，您可以直接使用 `readxl`
    包导入 Excel 工作表。在使用之前，请确保已下载并安装它。
- en: The `readxl` package can be used to read both .xls and .xlsx versions of Excel
    files. The `read_excel()` function imports a worksheet into a data frame as a
    tibble. The simplest format is `read_excel(file,` `n)`, where `file` is the path
    to an Excel workbook, `n` is the number of the worksheet to be imported, and the
    first line of the worksheet contains the variable names. For example, on a Windows
    platform, the code
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`readxl` 包可以用来读取 Excel 文件的 .xls 和 .xlsx 版本。`read_excel()` 函数将工作表导入数据框作为 tibble。最简单的格式是
    `read_excel(file,` `n)`，其中 `file` 是 Excel 工作簿的路径，`n` 是要导入的工作表编号，工作表的第一行包含变量名。例如，在
    Windows 平台上，代码'
- en: '[PRE34]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'imports the first worksheet from the workbook myworkbook.xlsx stored on the
    C: drive and saves it as the data frame `mydataframe`.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '从存储在 C: 驱动的 myworkbook.xlsx 工作簿中导入第一个工作表，并将其保存为数据框 `mydataframe`。'
- en: The `read_excel()` function has options that allow you to specify a specific
    cell range (e.g., `range` `=` `"Mysheet!B2:G14")`, along with the class of each
    column (`col_types`). See `help(read_excel)` for details.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`read_excel()` 函数提供了选项，允许您指定特定的单元格范围（例如，`range` `=` `"Mysheet!B2:G14"`），以及每列的类别（`col_types`）。有关详细信息，请参阅
    `help(read_excel)`。'
- en: Other packages that can help you work with Excel files include `xlsx`, `XLConnect`,
    and `openxlsx`. The `xlsx` and `XLConnect` packages depend on Java, while `openxlsx`
    doesn’t. Unlike `readxl`, these packages can do more than import worksheets—they
    can also create and manipulate Excel files. Programmers who need to develop an
    interface between R and Excel should check out one or more of these packages.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 其他可以帮助您处理 Excel 文件的包包括 `xlsx`、`XLConnect` 和 `openxlsx`。`xlsx` 和 `XLConnect`
    包依赖于 Java，而 `openxlsx` 不依赖。与 `readxl` 不同，这些包不仅可以导入工作表，还可以创建和操作 Excel 文件。需要开发 R
    与 Excel 之间接口的程序员应该检查这些包中的一个或多个。
- en: 2.3.4 Importing data from JSON
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.4 从 JSON 导入数据
- en: Increasingly, data are provided in JSON (JavaScript Object Notation) format.
    R has several packages for working with JSON. For example, the `jsonlite` package
    allows you to read, write, and manipulate JSON objects. Data can be imported from
    JSON files directly into R data frames. Coverage of JSON is beyond the scope of
    this text; if you’re interested, see the `jsonlite` vignettes ([https://cran.r-project.org/web/packages/jsonlite/](https://cran.r-project.org/web/packages/jsonlite/)).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 越来越多的数据以 JSON（JavaScript 对象表示法）格式提供。R 有几个用于处理 JSON 的包。例如，`jsonlite` 包允许您读取、写入和操作
    JSON 对象。数据可以直接从 JSON 文件导入到 R 数据框中。关于 JSON 的内容超出了本文的范围；如果您感兴趣，请参阅 `jsonlite` 的示例文档
    ([https://cran.r-project.org/web/packages/jsonlite/](https://cran.r-project.org/web/packages/jsonlite/))).
- en: 2.3.5 Importing data from the web
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.5 从网络导入数据
- en: Data can be obtained from the web via *web scraping* or by using *application
    programming interfaces* (APIs). Web scraping is used to extract the information
    embedded in specific web pages, whereas APIs allow you to interact with web services
    and online data stores.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 数据可以通过网络爬虫或使用应用程序编程接口 (APIs) 获取。网络爬虫用于提取特定网页中嵌入的信息，而 APIs 允许您与网络服务和在线数据存储进行交互。
- en: Typically, web scraping is used to extract data from a web page and save it
    into an R structure for further analysis. For example, the text on a web page
    can be downloaded into an R character vector using the `readLines()` function
    and manipulated with functions such as `grep()` and `gsub()`. The `rvest` package
    provides functions that can simplify extracting data from web pages. It was inspired
    by the Python library Beautiful Soup. The `RCurl` and `XML` packages can also
    be used to extract information. For more information, including examples, see
    “Examples of Web Scraping with R” on the website *ProgrammingR* ([www.programmingr.com](http://www.programmingr.com)).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，网络爬虫用于从网页中提取数据并将其保存到 R 结构中以便进一步分析。例如，网页上的文本可以使用 `readLines()` 函数下载到 R 字符向量，并使用
    `grep()` 和 `gsub()` 等函数进行操作。`rvest` 包提供了可以简化从网页中提取数据的函数。它受到了 Python 库 Beautiful
    Soup 的启发。`RCurl` 和 `XML` 包也可以用来提取信息。有关更多信息，包括示例，请参阅网站 *ProgrammingR* 上的“使用 R 进行网络爬虫的示例”（[www.programmingr.com](http://www.programmingr.com)）。
- en: APIs specify how software components should interact with each other. Several
    R packages use this approach to extract data from web-accessible resources. These
    include data sources in biology, medicine, earth sciences, physical science, economics
    and business, finance, literature, marketing, news, and sports.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: APIs 指定了软件组件之间应该如何交互。几个 R 包使用这种方法从可访问的 Web 资源中提取数据。这些数据源包括生物学、医学、地球科学、物理科学、经济学和商业、金融、文学、营销、新闻和体育。
- en: For example, if you’re interested in social media, you can access Twitter data
    via `twitteR`, Facebook data via `Rfacebook`, and Flickr data via `Rflickr`. Other
    packages allow you to access popular web services provide by Google, Amazon, Dropbox,
    Salesforce, and others. For a comprehensive list of R packages that can help you
    access web-based resources, see the CRAN Task View on “Web Technologies and Services”
    ([http://mng.bz/370r](http://mng.bz/370r)).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您对社交媒体感兴趣，可以通过 `twitteR` 访问 Twitter 数据，通过 `Rfacebook` 访问 Facebook 数据，通过
    `Rflickr` 访问 Flickr 数据。其他包允许您访问由 Google、Amazon、Dropbox、Salesforce 等提供的流行网络服务。有关可以帮助您访问基于
    Web 资源的 R 包的完整列表，请参阅 CRAN 任务视图“Web 技术和服务”（[http://mng.bz/370r](http://mng.bz/370r)）。
- en: 2.3.6 Importing data from SPSS
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.6 从 SPSS 导入数据
- en: 'IBM SPSS datasets can be imported into R via the `read_spss()` function in
    the `haven` package. First, download and install the package:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过 `haven` 包中的 `read_spss()` 函数将 IBM SPSS 数据集导入 R。首先，下载并安装该包：
- en: '[PRE35]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then use the following code to import the data:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用以下代码导入数据：
- en: '[PRE36]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The imported dataset is a data frame (as a tibble), and variables containing
    imported SPSS value labels are assigned the class `labelled`. You can convert
    these labeled variables to R factors using the following code:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 导入的数据集是一个数据框（作为 tibble），包含导入的 SPSS 值标签的变量被分配了 `labelled` 类。您可以使用以下代码将这些标记变量转换为
    R 因子：
- en: '[PRE37]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `haven` package has additional functions for reading SPSS files in compressed
    (.zsav) or transport (.por) format.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`haven` 包提供了读取压缩的 (.zsav) 或传输格式 (.por) 的 SPSS 文件的附加功能。'
- en: 2.3.7 Importing data from SAS
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.7 从 SAS 导入数据
- en: SAS datasets can be imported using `read_sas()` in the `haven` package. After
    installing the package, import that data using
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `haven` 包中的 `read_sas()` 函数导入 SAS 数据集。安装包后，使用以下命令导入数据：
- en: '[PRE38]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If the user also has a catalogue of variable formats, they can be imported and
    applied to the data as well using
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户还有一个变量格式的目录，它们也可以导入并应用于数据：
- en: '[PRE39]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In either case, the result is a data frame saved as a tibble.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，结果都是一个保存为 tibble 的数据框。
- en: Alternatively, there is a commercial product named Stat/Transfer (described
    in section 2.3.10) that does an excellent job of saving SAS datasets (including
    any existing variable formats) as R data frames.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，有一个名为 Stat/Transfer 的商业产品（在第 2.3.10 节中描述），它能够出色地将 SAS 数据集（包括任何现有的变量格式）保存为
    R 数据框。
- en: 2.3.8 Importing data from Stata
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.8 从 Stata 导入数据
- en: 'Importing data from Stata to R is straightforward. Again, use the `haven` package:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Stata 导入 R 数据非常直接。再次使用 `haven` 包：
- en: '[PRE40]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here, `mydata.dta` is the Stata dataset, and `mydataframe` is the resulting
    R data frame, saved as a tibble.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`mydata.dta`是Stata数据集，而`mydataframe`是结果R数据框，保存为tibble格式。
- en: 2.3.9 Accessing database management systems
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.9 访问数据库管理系统
- en: R can interface with a wide variety of relational database management systems
    (DBMSs), including Microsoft SQL Server, Microsoft Access, MySQL, Oracle, PostgreSQL,
    DB2, Sybase, Teradata, and SQLite. Some packages provide access through native
    database drivers, whereas others offer access via ODBC or JDBC. Using R to access
    data stored in external DBMSs can be an efficient way to analyze large datasets
    (see appendix F) and takes advantage of the power of both SQL and R.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: R可以与各种关系型数据库管理系统（DBMSs）接口，包括Microsoft SQL Server、Microsoft Access、MySQL、Oracle、PostgreSQL、DB2、Sybase、Teradata和SQLite。一些包通过本地数据库驱动程序提供访问，而其他包则通过ODBC或JDBC提供访问。使用R访问存储在外部DBMS中的数据可以是一种分析大型数据集的有效方法（参见附录F），并且可以利用SQL和R的双重力量。
- en: The ODBC interface
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: ODBC接口
- en: Perhaps the most popular method of accessing a DBMS in R is through the `RODBC`
    package, which allows R to connect to any DBMS that has an ODBC driver. This includes
    all the DBMSs listed earlier.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在R中访问DBMS最流行的方法可能是通过`RODBC`包，该包允许R连接到任何具有ODBC驱动程序的DBMS。这包括前面列出的所有DBMS。
- en: The first step is to install and configure the appropriate ODBC driver for your
    platform and database (these drivers aren’t part of R). If the requisite drivers
    aren’t already installed on your machine, an internet search should provide you
    with options (“Setting up ODBC Drivers” at [https://db.rstudio.com/best-practices/drivers/](https://db.rstudio.com/best-practices/drivers/)
    is a good place to start).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是安装并配置适合您平台和数据库的适当ODBC驱动程序（这些驱动程序不是R的一部分）。如果所需的驱动程序尚未安装到您的机器上，网络搜索应为您提供选项（可以从[https://db.rstudio.com/best-practices/drivers/](https://db.rstudio.com/best-practices/drivers/)开始）。
- en: Once the drivers are installed and configured for the database(s) of your choice,
    install the `RODBC` package. You can do so with the `install.packages("RODBC")`
    command. Table 2.3 lists the primary functions included with `RODBC`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦为所选数据库安装并配置了相应的驱动程序，请安装`RODBC`包。您可以使用`install.packages("RODBC")`命令进行安装。表2.3列出了`RODBC`包含的主要函数。
- en: Table 2.3 `RODBC` functions
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.3 `RODBC`函数
- en: '| Function | Description |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 |'
- en: '| `odbcConnect(*dsn*,uid="",pwd="")` | Opens a connection to an ODBC database
    |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| `odbcConnect(*dsn*,uid="",pwd="")` | 打开与ODBC数据库的连接 |'
- en: '| `sqlFetch(*channel,sqltable*)` | Reads a table from an ODBC database into
    a data frame |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| `sqlFetch(*channel,sqltable*)` | 从ODBC数据库读取表到数据框 |'
- en: '| `sqlQuery(*channel,query*)` | Submits a query to an ODBC database and returns
    the results |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| `sqlQuery(*channel,query*)` | 向ODBC数据库提交查询并返回结果 |'
- en: '| `sqlSave(*channel,mydf,*tablename = *sqltable*,append=FALSE)` | Writes or
    updates `(append=TRUE)` a data frame to a table in the ODBC database |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| `sqlSave(*channel,mydf,*tablename = *sqltable*,append=FALSE)` | 将数据框写入或更新到ODBC数据库中的表（如果`append=TRUE`）
    |'
- en: '| `sqlDrop(*channel,sqltable*)` | Removes a table from the ODBC database |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| `sqlDrop(*channel,sqltable*)` | 从ODBC数据库中删除表 |'
- en: '| `close(*channel*)` | Closes the connection |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| `close(*channel*)` | 关闭连接 |'
- en: 'The `RODBC` package allows two-way communication between R and an ODBC-connected
    SQL database. This means you can not only read data from a connected database
    into R, but you can also use R to alter the contents of the database itself. Assume
    that you want to import two tables (Crime and Punishment) from a DBMS into two
    R data frames called `crimedat` and `pundat`, respectively. You can accomplish
    this with code similar to this:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`RODBC`包允许R与ODBC连接的SQL数据库之间进行双向通信。这意味着您不仅可以从连接的数据库中读取数据到R，还可以使用R更改数据库本身的内容。假设您想从DBMS中导入两个表（Crime和Punishment）到两个名为`crimedat`和`pundat`的R数据框中。您可以使用类似以下代码来完成此操作：'
- en: '[PRE41]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here, you load the `RODBC` package and open a connection to the ODBC database
    through a registered data source name (`mydsn`) with a security UID (`rob`) and
    password (`aardvark`). The connection string is passed to `sqlFetch`, which copies
    the table Crime into the R data frame `crimedat`. You then run the SQL `select`
    statement against the table Punishment and save the results to the data frame
    `pundat`. Finally, you close the connection.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您加载`RODBC`包并通过注册的数据源名称（`mydsn`）、安全UID（`rob`）和密码（`aardvark`）打开与ODBC数据库的连接。连接字符串传递给`sqlFetch`，它将表Crime复制到R数据框`crimedat`中。然后，您对表Punishment运行SQL
    `select`语句并将结果保存到数据框`pundat`中。最后，您关闭连接。
- en: The `sqlQuery()` function is powerful because any valid SQL statement can be
    inserted. This flexibility allows you to select specific variables, subset the
    data, create new variables, and recode and rename existing variables.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqlQuery()` 函数功能强大，因为可以插入任何有效的SQL语句。这种灵活性允许你选择特定的变量，对数据进行子集化，创建新变量，以及重新编码和重命名现有变量。'
- en: DBI-related packages
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 与DBI相关的包
- en: The `DBI` package provides a general and consistent client-side interface to
    DBMS. Building on this framework, the `RJDBC` package provides access to DBMS
    via a JDBC driver. Be sure to install the necessary JDBC drivers for your platform
    and database. Other useful DBI-based packages include `RMySQL`, `ROracle`, `RPostgreSQL`,
    and `RSQLite`. These packages provide native database drivers for their respective
    databases but may not be available on all platforms. Check the documentation on
    CRAN ([https://cran.r-project.org](https://cran.r-project.org)) for details.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`DBI`包提供了一个通用的、一致的客户端接口到DBMS。在这个框架的基础上，`RJDBC`包通过JDBC驱动程序提供对DBMS的访问。请确保为你的平台和数据库安装必要的JDBC驱动程序。其他有用的基于DBI的包包括`RMySQL`、`ROracle`、`RPostgreSQL`和`RSQLite`。这些包为它们各自的数据库提供原生数据库驱动程序，但可能并非所有平台都可用。有关详细信息，请参阅CRAN上的文档([https://cran.r-project.org](https://cran.r-project.org))。'
- en: 2.3.10 Importing data via Stat/Transfer
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.10 通过Stat/Transfer导入数据
- en: Before we end our discussion of importing data, it’s worth mentioning a commercial
    product that can make the task significantly easier. Stat/Transfer ([https://www
    .stattransfer.com](https://www.stattransfer.com)) is a standalone application
    that can transfer data among 34 data formats, including R (see figure 2.4).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束对导入数据的讨论之前，值得提一下一个可以显著简化任务的商业产品。Stat/Transfer ([https://www.stattransfer.com](https://www.stattransfer.com))
    是一个独立的应用程序，可以在34种数据格式之间传输数据，包括R（见图2.4）。
- en: '![](Images/CH02_F04_Kabacoff3.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH02_F04_Kabacoff3.png)'
- en: Figure 2.4 Stat/Transfer’s main dialog in Windows
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 Stat/Transfer在Windows中的主对话框
- en: Stat/Transfer is available for Windows, Mac, and Unix platforms. It supports
    the latest versions of the statistical packages we’ve discussed so far, as well
    as ODBC-accessed DBMSs such as Oracle, Sybase, Informix, and DB/2.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: Stat/Transfer适用于Windows、Mac和Unix平台。它支持我们之前讨论过的统计软件的最新版本，以及通过ODBC访问的DBMS，如Oracle、Sybase、Informix和DB/2。
- en: 2.4 Annotating datasets
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4 数据集标注
- en: Data analysts typically annotate datasets to make the results easier to interpret.
    Annotating generally includes adding descriptive labels to variable names and
    value labels to the codes used for categorical variables. For example, for the
    variable `age`, you might want to attach the more descriptive label “Age at hospitalization
    (in years).” For the variable `gender`, coded 1 or 2, you might want to associate
    the labels “male” and “female.”
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 数据分析师通常会对数据集进行标注，以便更容易解释结果。标注通常包括向变量名添加描述性标签，以及对用于分类变量的代码添加值标签。例如，对于变量`age`，你可能希望附加更描述性的标签“Age
    at hospitalization (in years)。”对于变量`gender`，编码为1或2，你可能希望关联标签“male”和“female。”
- en: 2.4.1 Variable labels
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.1 变量标签
- en: Unfortunately, R’s ability to handle variable labels is limited. One approach
    is to use the variable label as the variable’s name and then refer to the variable
    by its position index. Consider the earlier example, where you have a data frame
    containing patient data. The second column, `age`, contains the ages at which
    individuals were first hospitalized. The code
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，R处理变量标签的能力有限。一种方法是将变量标签用作变量的名称，然后通过其位置索引来引用变量。考虑之前的例子，其中有一个包含患者数据的data
    frame。第二列，`age`，包含个人首次住院时的年龄。以下代码
- en: '[PRE42]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: renames `age` to `"Age` `at` `hospitalization` `(in years)".` Clearly this new
    name is too long to type repeatedly. Instead, you can refer to this variable as
    `patientdata[2]`, and the string `"Age` `at` `hospitalization` `(in` `years)"`
    will print wherever age would have originally. Obviously, this isn’t an ideal
    approach, and you may be better off trying to come up with better variable names
    (for example, `admissionAge`).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 将`age`重命名为`"Age at hospitalization (in years)"`。显然，这个新名字太长了，重复输入会很麻烦。相反，你可以将这个变量称为`patientdata[2]`，而字符串`"Age
    at hospitalization (in years)"`将打印在原本显示年龄的地方。显然，这不是一个理想的方法，你可能更愿意尝试想出更好的变量名（例如，`admissionAge`）。
- en: 2.4.2 Value labels
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.2 值标签
- en: The `factor()` function can be used to create value labels for categorical variables.
    Continuing the example, suppose you have a variable named `gender`, which is coded
    1 for male and 2 for female. You can create value labels with the code
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`factor()` 函数可以用来为分类变量创建值标签。继续上面的例子，假设你有一个名为 `gender` 的变量，男性编码为 1，女性编码为 2。你可以使用以下代码创建值标签'
- en: '[PRE43]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Here, `levels` indicates the actual values of the variable, and `labels` refers
    to a character vector containing the desired labels.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`levels` 表示变量的实际值，而 `labels` 指的是包含所需标签的字符向量。
- en: 2.5 Useful functions for working with data objects
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.5 用于处理数据对象的有用函数
- en: We’ll end this chapter with a brief summary of functions that are useful when
    you are working with data objects (see table 2.4).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将本章以对在处理数据对象时有用的函数的简要总结结束（见表 2.4）。
- en: Table 2.4 Functions for working with data objects
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.4 处理数据对象函数
- en: '| Function | Purpose |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 目的 |'
- en: '| `length(*object*)` | Gives the number of elements/components |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| `length(*object*)` | 返回元素/组件的数量 |'
- en: '| `dim(*object*)` | Gives the dimensions of an object |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| `dim(*object*)` | 返回对象的维度 |'
- en: '| `str(*object*)` | Gives the structure of an object. |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| `str(*object*)` | 返回对象的结构。 |'
- en: '| `class(*object*)` | Gives the class of an object |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| `class(*object*)` | 返回对象的类 |'
- en: '| `mode(*object*)` | Determines how an object is stored |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| `mode(*object*)` | 确定对象是如何存储的 |'
- en: '| `names(*object*)` | Gives the names of components in an object |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| `names(*object*)` | 返回对象中组件的名称 |'
- en: '| `c(*object, object,*...)` | Combines objects into a vector. |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| `c(*object, object,*...)` | 将对象组合成一个向量。 |'
- en: '| `cbind(*object, object,* ...)` | Combines objects as columns |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| `cbind(*object, object,* ...)` | 将对象作为列组合 |'
- en: '| `rbind(*object, object,*...)` | Combines objects as rows |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| `rbind(*object, object,*...)` | 将对象作为行组合'
- en: '| `object` | Prints an object |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| `object` | 打印对象 |'
- en: '| `head(*object*)` | Lists the first part of an object |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| `head(*object*)` | 列出对象的第一个部分'
- en: '| `tail(object)` | Lists the last part of an object |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| `tail(object)` | 列出对象的最后一个部分 |'
- en: '| `ls()` | Lists current objects |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| `ls()` | 列出当前对象 |'
- en: '| `rm(*object, object,* ...)` | Deletes one or more objects. The statement
    `rm(list = ls())` removes most objects from the working environment. |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| `rm(*object, object,* ...)` | 删除一个或多个对象。`rm(list = ls())` 语句从工作环境中删除大多数对象。
    |'
- en: '| `*newobject* <- edit(*object*)` | Edits `object` and saves it as `newobject`
    |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| `*newobject* <- edit(*object*)` | 编辑 `object` 并将其保存为 `newobject` |'
- en: '| `fix(*object*)` | Edits an object in place |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| `fix(*object*)` | 在原地编辑对象 |'
- en: We’ve already discussed most of these functions. `head()` and `tail()` are useful
    for quickly scanning large datasets. For example, `head(patientdata)` lists the
    first six rows of the data frame, whereas `tail(patientdata)` lists the last six.
    We’ll cover functions such as `length()`, `cbind()`, and `rbind()` in the next
    chapter; they’re gathered here as a reference.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了这些函数中的大部分。`head()` 和 `tail()` 对于快速扫描大型数据集非常有用。例如，`head(patientdata)`
    列出了数据框的前六行，而 `tail(patientdata)` 列出了最后六行。我们将在下一章中介绍 `length()`、`cbind()` 和 `rbind()`
    等函数；它们在这里作为参考。
- en: As you’ve seen, R offers a wealth of functions for accessing external data.
    Appendix C covers exporting data from R to other formats, and appendix F covers
    methods of working with large datasets (in the gigabyte-to-terabyte range).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，R 提供了丰富的函数来访问外部数据。附录 C 介绍了将数据从 R 导出为其他格式的方法，附录 F 介绍了处理大型数据集（千兆到太字节范围）的方法。
- en: Once you import your datasets into R, it’s likely that you’ll have to manipulate
    them into a more conducive format. In chapter 3, we’ll explore ways to create
    new variables, transform and recode existing variables, merge datasets, and select
    observations.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你将数据集导入 R，你很可能需要将它们转换成更便于使用的格式。在第 3 章中，我们将探讨创建新变量、转换和重新编码现有变量、合并数据集和选择观察值的方法。
- en: Summary
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: R provides various objects for holding data, including vectors, matrices, data
    frames, and lists.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: R 提供了各种用于存储数据的对象，包括向量、矩阵、数据框和列表。
- en: You can import data into R data frames from external sources, including text
    files, Excel worksheets, web APIs, statistical packages, and databases.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以从外部源导入数据到 R 数据框中，包括文本文件、Excel 工作表、Web API、统计软件包和数据库。
- en: There are extensive functions for describing, modifying, and combining data
    structures.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有大量的函数用于描述、修改和组合数据结构。
