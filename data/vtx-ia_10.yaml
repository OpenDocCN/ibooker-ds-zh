- en: 8 The web stack
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 网络堆栈
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: The construction of an edge service and a public API
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建边缘服务和公共API
- en: The Vert.x web client
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vert.x网络客户端
- en: JSON web tokens (JWT) and cross-origin resource sharing (CORS)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON Web令牌（JWT）和跨源资源共享（CORS）
- en: Serving and integrating a Vue.js reactive application with Vert.x
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Vert.x将Vue.js响应式应用程序提供和集成
- en: Testing an HTTP API with REST Assured
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用REST Assured测试HTTP API
- en: Reactive applications often use HTTP because it is such a versatile protocol,
    and Vert.x offers comprehensive support for web technologies. The Vert.x web stack
    provides many tools for building web application backends. These include advanced
    routing, authentication, an HTTP client, and more. This chapter will guide you
    through exposing an HTTP API with *JSON web tokens* (JWT) for access control,
    making HTTP requests to other services, and building a reactive single-page application
    that connects to the HTTP API.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式应用程序通常使用HTTP，因为它是一个非常通用的协议，而Vert.x提供了对Web技术的全面支持。Vert.x网络堆栈提供了许多用于构建Web应用程序后端的工具。这包括高级路由、身份验证、HTTP客户端等。本章将指导你如何公开使用*JSON
    Web令牌*（JWT）进行访问控制的HTTP API，向其他服务发出HTTP请求，并构建一个连接到HTTP API的响应式单页应用程序。
- en: 'Note This book does not cover the following noteworthy elements from the Vert.x
    web stack that are not needed to build the application in this part of the book:
    routing with regular expressions, cookies, server-side sessions, server-side template
    rendering, and cross-site request forgery protection. You can get more details
    about those topics in the official documentation at [https://vertx.io/](https://vertx.io/).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本书不涵盖以下从Vert.x网络堆栈中值得注意的元素，这些元素对于构建本书的这一部分的应用程序不是必需的：正则表达式路由、cookies、服务器端会话、服务器端模板渲染和跨站请求伪造保护。你可以在官方文档中了解更多关于这些主题的详细信息：[https://vertx.io/](https://vertx.io/)。
- en: 8.1 Exposing a public API
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1 公开公共API
- en: Let’s start with a reminder of what the public API service does, as illustrated
    in figure 8.1\. This service is an edge service (or service gateway, depending
    on how you prefer to name it) as it exposes an HTTP API, but it essentially composes
    functionality found in other services. In this case, the user profile and activity
    services are being used. These two services are internal to the application and
    are not publicly exposed. They also lack any form of authentication and access
    control, which is something the public API cannot afford for most operations.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先回顾一下公共API服务的作用，如图8.1所示。这个服务是一个边缘服务（或服务网关，取决于你更喜欢如何命名），因为它公开了一个HTTP API，但它本质上组合了其他服务中找到的功能。在这种情况下，使用了用户资料和活动服务。这两个服务是应用程序内部的，并且没有公开暴露。它们也没有任何形式的身份验证和访问控制，这是公共API在大多数操作中无法承担的。
- en: '![](../Images/CH08_F01_Ponge.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH08_F01_Ponge.png)'
- en: Figure 8.1 Public API overview
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 公共API概述
- en: 'The following Vert.x modules are needed to implement the public API:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下Vert.x模块需要实现公共API：
- en: '`vertx-web`, to provide advanced HTTP request-processing functionality'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vertx-web`，提供高级HTTP请求处理功能'
- en: '`vertx-web-client`, to issue HTTP requests to the user profile and activity
    services'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vertx-web-client`，用于向用户资料和活动服务发出HTTP请求'
- en: '`vertx-auth-jwt`, to generate and process JSON web tokens and perform access
    control'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vertx-auth-jwt`，用于生成和处理JSON Web令牌（JWT）以及执行访问控制'
- en: The complete source code of the public API service can be found in the part2-steps-challenge/public-api
    folder of the book’s source code repository.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 公共API服务的完整源代码可以在本书源代码仓库的part2-steps-challenge/public-api文件夹中找到。
- en: We’ll start with the Vert.x web router.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从Vert.x网络路由开始。
- en: 8.1.1 Routing HTTP requests
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.1 路由HTTP请求
- en: Vert.x core provides a very low-level HTTP server API, where you need to pass
    a request handler for all types of HTTP requests. If you just use Vert.x core,
    you need to manually check the requested path and method. This is fine for simple
    cases, and it’s what we did in some earlier chapters, but it can quickly become
    complicated.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Vert.x核心提供了一个非常底层的HTTP服务器API，其中你需要为所有类型的HTTP请求传递一个请求处理器。如果你只使用Vert.x核心，你需要手动检查请求的路径和方法。这在简单情况下是可以的，这也是我们在一些早期章节中做的事情，但它很快就会变得复杂。
- en: The `vertx-web` module provides a *router* that can act as a Vert.x HTTP server
    request handler, and that manages the dispatch of HTTP requests to suitable handlers
    based on request paths (e.g., `/foo`) and HTTP methods (e.g., `POST`). This is
    illustrated in figure 8.2.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`vertx-web`模块提供了一个可以作为Vert.x HTTP服务器请求处理器的`router`，并根据请求路径（例如，`/foo`）和HTTP方法（例如，`POST`）将HTTP请求调度到合适的处理器。这如图8.2所示。'
- en: '![](../Images/CH08_F02_Ponge.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F02_Ponge.png)'
- en: Figure 8.2 Routing HTTP requests
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 路由 HTTP 请求
- en: The following listing shows how to initialize and then set up a router as an
    HTTP request handler.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了如何初始化并设置路由作为 HTTP 请求处理程序。
- en: Listing 8.1 Initializing and using a router as an HTTP request handler
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.1 初始化和使用路由作为 HTTP 请求处理程序
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Define routes
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义路由
- en: ❷ A router is just another HTTP request handler.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 路由器只是另一个 HTTP 请求处理程序。
- en: The `Router` class provides a fluent API to describe *routes* based on HTTP
    methods and paths, as shown in the following listing.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`Router` 类提供了一个流畅的 API 来描述基于 HTTP 方法和路径的 *路由*，如下面的列表所示。'
- en: Listing 8.2 Defining routes
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.2 定义路由
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ BodyHandler is a predefined handler that extracts HTTP request body payloads.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ BodyHandler 是一个预定义的处理程序，用于提取 HTTP 请求体有效载荷。
- en: ❷ Here bodyHandler is called for all HTTP POST and PUT requests.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在这里，bodyHandler 被用于所有 HTTP POST 和 PUT 请求。
- en: ❸ The register method handles /api/v1/register POST requests.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 注册方法处理 /api/v1/register POST 请求。
- en: ❹ We can extract path parameters by prefixing elements with ":".
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 我们可以通过在元素前加上“:”来提取路径参数。
- en: ❺ Handlers can be chained.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 处理程序可以链式调用。
- en: An interesting property of the Vert.x router is that handlers can be chained.
    With the definitions from listing 8.2, a `POST` request to `/api/v1/register`
    first goes through a `BodyHandler` instance. This handler is useful for easily
    decoding an HTTP request body payload. The next handler is the `register` method.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Vert.x 路由器的一个有趣特性是处理程序可以链式调用。根据列表 8.2 中的定义，一个发往 `/api/v1/register` 的 `POST`
    请求首先通过一个 `BodyHandler` 实例。这个处理程序对于轻松解码 HTTP 请求体有效载荷很有用。下一个处理程序是 `register` 方法。
- en: 'Listing 8.2 also defines the route for `GET` requests to `monthlySteps`, where
    the request first goes through `jwtHandler`, and then `checkUser`, as illustrated
    in figure 8.3\. This is useful for decomposing an HTTP request, processing concerns
    in several steps: `jwtHandler` checks that a valid JWT token is in the request,
    `checkUser` checks that the JWT token grants permissions to access the resource,
    and `monthlySteps` checks how many steps a user has taken in a month.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.2 还定义了发往 `monthlySteps` 的 `GET` 请求的路由，其中请求首先通过 `jwtHandler`，然后是 `checkUser`，如图
    8.3 所示。这对于分解 HTTP 请求，分步骤处理关注点很有用：`jwtHandler` 检查请求中是否存在有效的 JWT 令牌，`checkUser`
    检查 JWT 令牌是否授予访问资源的权限，而 `monthlySteps` 检查用户一个月内走了多少步。
- en: '![](../Images/CH08_F03_Ponge.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F03_Ponge.png)'
- en: Figure 8.3 Routing chain for the monthly steps endpoint
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 每月步骤端点的路由链
- en: Note that both `checkUser` and `jwtHandler` will be discussed in section 8.2.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`checkUser` 和 `jwtHandler` 都将在第 8.2 节中讨论。
- en: tip The `io.vertx.ext.web.handler` package contains useful utility handlers
    including `BodyHandler`. It especially provides handlers for HTTP authentication,
    CORS, CSRF, favicon, HTTP sessions, static files serving, virtual hosts, and template
    rendering.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：`io.vertx.ext.web.handler` 包包含有用的实用处理程序，包括 `BodyHandler`。它特别提供了 HTTP 认证、CORS、CSRF、favicon、HTTP
    会话、静态文件服务、虚拟主机和模板渲染的处理程序。
- en: 8.1.2 Making HTTP requests
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.2 制作 HTTP 请求
- en: Let’s now dive into the implementation of a handler. Since the public API service
    forwards requests to the user profile and activity services, we need to use the
    Vert.x web client to make HTTP requests. As noted previously, the Vert.x core
    APIs offer a low-level HTTP client, whereas the `WebClient` class from the `vertx-web-client`
    module offers a richer API.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来深入了解处理程序的实现。由于公共 API 服务将请求转发到用户配置文件和活动服务，我们需要使用 Vert.x 网络客户端来执行 HTTP 请求。如前所述，Vert.x
    核心API提供了低级HTTP客户端，而 `vertx-web-client` 模块中的 `WebClient` 类提供了一个更丰富的API。
- en: 'Creating a web client instance is as simple as this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个网络客户端实例就像这样：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A `WebClient` instance is typically stored in a private field of a verticle
    class, as it can be used to perform multiple concurrent HTTP requests. The whole
    application uses the RxJava 2 bindings, so we can take advantage of them to compose
    asynchronous operations. As you will see in later examples, the RxJava bindings
    sometimes bring additional functionality for dealing with error management.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebClient` 实例通常存储在 verticle 类的私有字段中，因为它可以用来执行多个并发 HTTP 请求。整个应用程序使用 RxJava
    2 绑定，因此我们可以利用它们来组合异步操作。正如你将在后面的示例中看到的，RxJava 绑定有时会带来处理错误管理的附加功能。'
- en: The following listing shows the implementation of the `register` route handler.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了 `register` 路由处理程序的实现。
- en: Listing 8.3 Using the Vert.x web client in a route handler
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.3 在路由处理程序中使用 Vert.x 网络客户端
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Methods match the HTTP methods (GET, POST, etc.).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 方法与HTTP方法（GET、POST等）匹配。
- en: ❷ HTTP headers can be passed.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 可以传递HTTP头。
- en: ❸ This converts the request from a Vert.x Buffer to a JsonObject.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 这将请求从Vert.x Buffer转换为JsonObject。
- en: ❹ Subscription in RxJava triggers the request.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ RxJava的订阅触发请求。
- en: This example demonstrates both how to handle an HTTP request with a router,
    and how to use the web client. The `RoutingContext` class encapsulates details
    about the HTTP request and provides the HTTP response object via the `response`
    method. HTTP headers can be set in both requests and responses, and the response
    is sent once the `end` method has been called. A status code can be specified,
    although by default it will be `200` (OK).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子演示了如何使用路由器处理HTTP请求，以及如何使用Web客户端。`RoutingContext`类封装了关于HTTP请求的详细信息，并通过`response`方法提供HTTP响应对象。HTTP头可以在请求和响应中设置，一旦调用`end`方法，响应就会被发送。可以指定状态码，尽管默认情况下它将是`200`（OK）。
- en: You can see that `getBodyAsJson` transforms the HTTP request body to a `JsonObject`,
    while `rxSendJson` sends an HTTP request with a `JsonObject` as the body. By default,
    Vert.x `Buffer` objects carry bodies in both requests and responses, but there
    are helper methods to convert from or to `String`, `JsonObject`, and `JsonArray`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到`getBodyAsJson`将HTTP请求体转换为`JsonObject`，而`rxSendJson`则发送一个带有`JsonObject`作为体的HTTP请求。默认情况下，Vert.x
    `Buffer`对象在请求和响应中都携带体，但有一些辅助方法可以将它们转换为`String`、`JsonObject`和`JsonArray`。
- en: The next listing offers another router handler method for HTTP `GET` requests
    to `/api/v1/:username`, where `:username` is a path parameter.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表提供了一个用于HTTP `GET`请求到`/api/v1/:username`的路由处理器方法，其中`:username`是一个路径参数。
- en: Listing 8.4 Fetching and forwarding a user’s details
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.4 获取并转发用户详情
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Extracts a path parameter
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 提取路径参数
- en: ❷ Converts the response to a JsonObject
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将响应转换为JsonObject
- en: ❸ Ends the response with some content
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用一些内容结束响应
- en: 'This example shows the `as` method that converts HTTP responses to a type other
    than `Buffer` using a `BodyCodec`. You can also see that the HTTP response’s `end`
    method can take an argument that is the response content. It can be a `String`
    or a `Buffer`. While it is often the case that the response is sent in a single
    `end` method call, you can send intermediary fragments using the `write` method
    until a final `end` call closes the HTTP response, as shown here:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了`as`方法，它使用`BodyCodec`将HTTP响应转换为除`Buffer`之外的其他类型。你还可以看到HTTP响应的`end`方法可以接受一个参数，即响应内容。它可以是`String`或`Buffer`。虽然通常情况下响应是在单个`end`方法调用中发送的，但你可以在最终`end`调用关闭HTTP响应之前，使用`write`方法发送中间片段，如下所示：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 8.2 Access control with JWT tokens
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2 使用JWT令牌进行访问控制
- en: JSON Web Token (JWT) is an open specification for securely transmitting JSON-encoded
    data between parties ([https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519)).
    JWT tokens are signed with either a symmetric shared secret or an asymmetric public/private
    key pair, so it is always possible to verify that the information that they contain
    has not been modified. This is very interesting, as a JWT token can be used to
    hold claims such as identity and authorization grants. JWT tokens can be exchanged
    as part of HTTP requests using the `Authorization` HTTP header.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: JSON Web Token (JWT)是一个用于在各方之间安全传输JSON编码数据的开放规范([https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519))。JWT令牌使用对称共享密钥或非对称公钥/私钥对进行签名，因此始终可以验证它们包含的信息没有被修改。这非常有趣，因为JWT令牌可以用来持有诸如身份和授权许可之类的声明。JWT令牌可以作为HTTP请求的一部分通过`Authorization`
    HTTP头进行交换。
- en: Let’s look at how to use JWT tokens, what data they contain, and how to both
    validate and issue them with Vert.x.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用JWT令牌，它们包含哪些数据，以及如何使用Vert.x验证和颁发它们。
- en: tip JWT is only one protocol supported by Vert.x. Vert.x offers the `vertx-auth-oauth2`
    module for OAuth2, which is a popular protocol among public service providers
    like Google, GitHub, and Twitter. You will be interested in using it if your application
    needs to integrate with such services (such as when accessing a user’s Gmail account
    data), or when your application wants to grant third-party access through OAuth2.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 提示 JWT是Vert.x支持的一种协议。Vert.x提供了`vertx-auth-oauth2`模块用于OAuth2，这是Google、GitHub和Twitter等公共服务提供商中流行的协议。如果你需要将应用程序与这些服务集成（例如，在访问用户的Gmail账户数据时），或者当你的应用程序想要通过OAuth2授予第三方访问权限时，你将对此感兴趣。
- en: 8.2.1 Using JWT tokens
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.1 使用JWT令牌
- en: To illustrate using JWT tokens, let’s interact with the public API and authenticate
    as user `foo` with password `123`, and get a JWT token. The following listing
    shows the HTTP response.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明使用JWT令牌，让我们与公共API交互，并使用密码`123`作为用户`foo`进行认证，以获取JWT令牌。以下列表显示了HTTP响应。
- en: Listing 8.5 Getting a JWT token
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.5 获取JWT令牌
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Authenticating as user foo with password 123
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用密码123作为用户foo进行认证
- en: A JWT token has the MIME type `application/jwt`, which is plain text. We can
    pass the token to make a request as follows.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: JWT令牌的MIME类型为`application/jwt`，它是纯文本。我们可以传递令牌来发送请求，如下所示。
- en: Listing 8.6 Using a JWT token to access a resource
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.6 使用JWT令牌访问资源
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ We can access the resource, because we have a valid token for user foo.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们可以访问资源，因为我们有一个针对用户foo的有效令牌。
- en: tip The token value fits on a single line, and there is only a single space
    between `Bearer` and the token.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：令牌值适合单行，并且`Bearer`和令牌之间只有一个空格。
- en: The token is passed with the `Authorization` HTTP header, and the value is prefixed
    with `Bearer`. Here the token allows us to access the resource `/api/v1/foo`,
    since the token was generated for user `foo`. If we try to do the same thing without
    a token, or if we try to access the resource of another user, as in the following
    listing, we get denied.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌通过`Authorization` HTTP头部传递，并且其值以`Bearer`为前缀。在这里，令牌允许我们访问资源`/api/v1/foo`，因为令牌是为用户`foo`生成的。如果我们尝试不使用令牌，或者尝试访问其他用户的资源，如下列所示，我们将被拒绝访问。
- en: Listing 8.7 Accessing a resource without a matching JWT token
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.7 无匹配JWT令牌访问资源
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ We are denied access to a resource of user abc because we passed a (valid)
    token for user foo.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们因为传递了一个针对用户foo的（有效）令牌而被拒绝访问用户abc的资源。
- en: 8.2.2 What is in a JWT token?
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.2 JWT令牌中包含什么？
- en: So far so good, but what is in the token string?
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切顺利，但令牌字符串中包含什么呢？
- en: 'If you look closely, you will see that a JWT token string is a big line with
    three parts, each separated by a dot. The three parts are of the form `header.payload.signature`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细看，你会看到JWT令牌字符串是一行大文本，分为三部分，每部分之间由点分隔。这三部分的形式为`header.payload.signature`：
- en: '`header` is a JSON document specifying the type of token and the signature
    algorithm being used.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`header`是一个JSON文档，指定了令牌的类型和使用的签名算法。'
- en: '`payload` is a JSON document containing *claims*, which are JSON entries where
    some are part of the specification and some can be free-form.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`payload`是一个包含*声明*的JSON文档，这些声明是JSON条目，其中一些是规范的一部分，而另一些可以是自由形式的。'
- en: '`signature` is the signature of the header and payload with either a shared
    secret or a private key, depending on what algorithm you chose.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`signature`是头部和`payload`的签名，使用共享密钥或私钥，具体取决于你选择的算法。'
- en: 'The header and payload are encoded with the *Base64* algorithm. If you decode
    the JWT token obtained in listing 8.5, the header contains the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 头部和`payload`使用*Base64*算法进行编码。如果你解码列表8.5中获得的JWT令牌，头部包含以下内容：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is what the payload contains:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`payload`包含的内容：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, `deviceId` is the device identifier for user `foo`, `sub` is the *subject*
    (user `foo`), `iat` is the date when the token was issued, `exp` is the token
    expiration date, and `iss` is the token issuer (our service).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`deviceId`是用户`foo`的设备标识符，`sub`是*主题*（用户`foo`），`iat`是令牌签发日期，`exp`是令牌过期日期，而`iss`是令牌发行者（我们的服务）。
- en: The signature allows you to check that the content of both the header and payload
    have been signed by the issuer and have not been modified, as long as you know
    the public key. This makes JWT tokens a great option for authorization and access
    control in APIs; a token with all needed claims is self-contained and does not
    require you to make checks for each request against an identity management service
    like an LDAP/ OAuth server.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 签名允许你检查头部和`payload`的内容是否由发行者签名且未被修改，只要你知道公钥。这使得JWT令牌成为API中授权和访问控制的绝佳选择；包含所有所需声明的令牌是自包含的，无需对每个请求与身份管理服务（如LDAP/OAuth服务器）进行检查。
- en: It is important to understand that anyone with a JWT token can decode its content,
    because *Base64* is not an encryption algorithm. You must never put sensitive
    data like passwords in tokens, even if they are transmitted over secure channels
    like HTTPS. It is also important to set token expiration dates, so that a compromised
    token cannot be used indefinitely. There are various strategies for dealing with
    JWT token expiration, like maintaining a list of compromised tokens in the backend,
    and combining short expiration deadlines with frequent validity extension requests
    from clients, where the issuer resends the token, but with an extended `exp` claim.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，任何拥有JWT令牌的人都可以解码其内容，因为*Base64*不是一个加密算法。你绝不应该在令牌中放入敏感数据，如密码，即使它们通过像HTTPS这样的安全通道传输。同样重要的是设置令牌过期日期，以便受损的令牌不能无限期地使用。处理JWT令牌过期的策略有很多，比如在后台维护受损令牌列表，以及将短期过期期限与客户端频繁的有效性扩展请求相结合，其中发行者重新发送令牌，但带有扩展的`exp`声明。
- en: 8.2.3 Handling JWT tokens with Vert.x
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.3 使用Vert.x处理JWT令牌
- en: The first thing we need in order to issue and check tokens is a pair of public
    and private RSA keys, so we can sign JWT tokens. You can generate these using
    the shell script in the following listing.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了颁发和检查令牌，我们首先需要一对公钥和私钥，这样我们就可以签署JWT令牌。您可以使用以下列表中的shell脚本生成这些密钥。
- en: Listing 8.8 Generating RSA 2048 public and private keys
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.8 生成RSA 2048位公钥和私钥
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The next listing shows a helper class to read the PEM files as a string.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表展示了用于将PEM文件作为字符串读取的辅助类。
- en: Listing 8.9 Helper to read RSA keys
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.9 读取RSA密钥的辅助类
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ This allows us to run the service from either the service folder or the application
    project root.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这允许我们从服务文件夹或应用程序项目根目录运行服务。
- en: ❷ Joins all lines, separating them with a newline character
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将所有行连接起来，用换行符分隔
- en: Note that the code in `CryptoHelper` uses blocking APIs. Since this code is
    run once at initialization, and PEM files are small, we can afford a possible
    yet negligible blocking of the event loop.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`CryptoHelper`中的代码使用了阻塞API。由于此代码仅在初始化时运行一次，且PEM文件较小，我们可以承受对事件循环的潜在但可忽略的阻塞。
- en: We can then create a Vert.x JWT handler as follows.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以创建一个Vert.x JWT处理器，如下所示。
- en: Listing 8.10 Creating a JWT handler
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.10 创建JWT处理器
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ jwtAuth is a private field of type JWTAuth.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ jwtAuth是JWTAuth类型的一个私有字段。
- en: ❷ Vert.x router handler for JWT authentication
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ Vert.x路由处理器用于JWT认证
- en: The JWT handler can be used for routes that require JWT authentication, as it
    decodes the `Authorization` header to extract JWT data.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: JWT处理器可用于需要JWT认证的路由，因为它解码`Authorization`头以提取JWT数据。
- en: The following listing recalls a route with the handler in its handlers chain.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表回顾了一个具有处理器链中的处理器的路由。
- en: Listing 8.11 JWT handler in a route
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.11 路由中的JWT处理器
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ The JWT handler
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ JWT处理器
- en: The JWT handler supports the common authentication API from the `vertx-auth-common`
    module, which offers a unified view across different types of authentication mechanisms
    like databases, OAuth, or Apache `.htdigest` files. The handler puts authentication
    data in the routing context.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: JWT处理器支持来自`vertx-auth-common`模块的常用认证API，它为不同类型的认证机制（如数据库、OAuth或Apache `.htdigest`文件）提供了一个统一的视图。处理器将认证数据放入路由上下文中。
- en: The following listing shows the implementation of the `checkUser` method where
    we check that the user in the JWT token is the same as the one in the HTTP request
    path.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了`checkUser`方法的实现，其中我们检查JWT令牌中的用户是否与HTTP请求路径中的用户相同。
- en: Listing 8.12 Checking that a valid JWT token is present
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.12 检查是否存在有效的JWT令牌
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ User name from the JWT token
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从JWT令牌中获取用户名
- en: ❷ User name specified in the HTTP request path
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在HTTP请求路径中指定的用户名
- en: ❸ Pass to the next handler
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 传递给下一个处理器
- en: This provides a simple separation of concerns, as the `checkUser` handler focuses
    on access control and delegates to the next handler in the chain by calling `next`
    if access is granted, or ends the request with a 403 status code if the wrong
    user is trying to access a resource.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了一个简单的关注点分离，因为`checkUser`处理器专注于访问控制，并在授予访问权限时通过调用`next`将控制权委托给链中的下一个处理器，或者在错误的用户尝试访问资源时，以403状态码结束请求。
- en: Knowing that access control is correct, the `monthlySteps` method in the following
    listing can focus on making the request to the activity service.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 确认访问控制正确后，以下列表中的`monthlySteps`方法可以专注于向活动服务发送请求。
- en: Listing 8.13 Getting monthly steps data
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.13 获取月度步数数据
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ From the JWT token
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 来自JWT令牌
- en: The device identifier is extracted from the JWT token data and passed along
    to the web client request.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 设备标识符从JWT令牌数据中提取出来，并传递给Web客户端请求。
- en: 8.2.4 Issuing JWT tokens with Vert.x
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.4 使用Vert.x发行JWT令牌
- en: 'Last, but not least, we need to generate JWT tokens. To do that, we need to
    make two requests to the user profile service: first we need to check the credentials,
    and then we gather profile data to prepare a token.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，但同样重要的是，我们需要生成JWT令牌。为此，我们需要向用户配置文件服务发出两个请求：首先我们需要检查凭证，然后收集配置文件数据以准备令牌。
- en: The following listing shows the handler for the `/api/v1/token` route.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了`/api/v1/token`路由的处理程序。
- en: Listing 8.14 JWT token-creation router handler
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.14 JWT令牌创建路由处理程序
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ We extract the credentials from the request to /api/v1/token.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们从/api/v1/token请求中提取凭证。
- en: ❷ We first issue an authentication request.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们首先发起一个认证请求。
- en: ❸ On success, we make another request to get the profile data.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 成功后，我们再次请求以获取配置文件数据。
- en: ❹ We prepare the token.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 我们准备令牌。
- en: This is a typical RxJava composition of asynchronous operations with `flatMap`
    to chain requests. You can also see the declarative API of the Vert.x router,
    where we can specify that we expect the first request to be a success.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个典型的RxJava异步操作组合，使用`flatMap`来链式请求。您还可以看到Vert.x路由器的声明式API，其中我们可以指定我们期望第一个请求是成功的。
- en: The following listing shows the implementation of `fetchUserDetails`, which
    gets the user profile data after the authentication request has succeeded.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了`fetchUserDetails`的实现，该实现是在认证请求成功后获取用户配置文件数据。
- en: Listing 8.15 Fetching user details
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.15 获取用户详细信息
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ We expect a success.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们期望成功。
- en: Finally, the next listing shows how to prepare a JWT token.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，下一个列表展示了如何准备JWT令牌。
- en: Listing 8.16 Preparing a JWT token
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.16 准备JWT令牌
- en: '[PRE19]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Our custom claims
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们的定制声明
- en: ❷ A claim that is in the JWT specification
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 一个在JWT规范中的声明
- en: The `JWTOptions` class offers methods for the common claims from the JWT RFC,
    such as the issuer, expiration date, and subject. You can see that we did not
    specify when the token was issued, although there is a method for that in `JWTOptions`.
    The `jwtAuth` object does the right thing here and adds it on our behalf.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`JWTOptions`类提供了JWT RFC中常见声明的相关方法，例如发行者、过期日期和主题。您可以看到我们没有指定令牌的发行时间，尽管`JWTOptions`中有一个方法可以做到这一点。`jwtAuth`对象在这里做了正确的事情，并代表我们添加了它。'
- en: 8.3 Cross-origin resource sharing (CORS)
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3 跨源资源共享（CORS）
- en: 'We have a public API that forwards requests to internal services, and this
    API uses JWT tokens for authentication and access control. I also demonstrated
    on the command line that we can interact with the API. In fact, *any* third-party
    application can talk to our API over HTTP: a mobile phone application, another
    service, a desktop application, and so on. You might think that web applications
    could also talk to the API from JavaScript code running in web browsers, but it
    is (fortunately!) not that simple.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个公开的API，它将请求转发到内部服务，并且这个API使用JWT令牌进行身份验证和访问控制。我在命令行上也演示了我们可以与API交互。实际上，*任何*第三方应用程序都可以通过HTTP与我们的API通信：手机应用程序、另一个服务、桌面应用程序等等。您可能会认为Web应用程序也可以从运行在Web浏览器中的JavaScript代码中与API通信，但事实（幸运的是！）并非如此简单。
- en: 8.3.1 What is the problem?
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.1 问题是什么？
- en: 'Web browsers enforce security policies, and among them is the *same-origin
    policy*. Suppose we load app.js from https://my.tld:4000/js/app.js:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 网络浏览器强制执行安全策略，其中之一就是*同源策略*。假设我们从https://my.tld:4000/js/app.js加载app.js：
- en: app.js is allowed to make requests to https://my.tld:4000/api/foo/bar.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: app.js允许向https://my.tld:4000/api/foo/bar发出请求。
- en: app.js is not allowed to make requests to https://my.tld:4001/a/b/c because
    a different port is not the same origin.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: app.js不允许向https://my.tld:4001/a/b/c发出请求，因为不同的端口不是同一个源。
- en: app.js is not allowed to make requests to https://other.tld/123 because a different
    host is not the same origin.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: app.js不允许向https://other.tld/123发出请求，因为不同的主机不是同一个源。
- en: Cross-origin resource sharing (CORS) is a mechanism by which a service can allow
    incoming requests from other *origins* ([https://fetch.spec.whatwg.org/](https://fetch.spec.whatwg.org/)).
    For instance, the service exposing https://other.tld/123 can specify that cross-origin
    requests are allowed from code served from https://my.tld:4000, or even from *any*
    origin. This allows web browsers to proceed with a cross-origin request when the
    request origin allows it; otherwise it will deny it, which is the default behavior.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 跨源资源共享 (CORS) 是一种机制，允许服务允许来自其他 *源* 的传入请求 ([https://fetch.spec.whatwg.org/](https://fetch.spec.whatwg.org/))。例如，暴露
    https://other.tld/123 的服务可以指定允许来自 https://my.tld:4000 的代码或来自 *任何* 源的跨源请求。这允许当请求源允许时，网络浏览器可以继续执行跨源请求；否则，它将拒绝请求，这是默认行为。
- en: When a cross-origin request is triggered, such as to load some JSON data, an
    image, or a web font, the web browser sends a request to the server with the requested
    resource, and passes an `Origin` HTTP header. The server then responds with an
    `Access-Control-Allow-Origin` HTTP header with the allowed origin, as illustrated
    in figure 8.4.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当触发跨源请求时，例如加载一些 JSON 数据、图片或网络字体，网络浏览器会向服务器发送带有请求资源的请求，并传递一个 `Origin` HTTP 头部。然后服务器响应一个带有允许源的
    `Access-Control-Allow-Origin` HTTP 头部，如图 8.4 所示。
- en: '![](../Images/CH08_F04_Ponge.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH08_F04_Ponge.png)'
- en: Figure 8.4 Example CORS interaction
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 CORS 交互示例
- en: A value of `"*"` means that any origin can access the resource, whereas a value
    like `https://my.tld` means that only cross-origin requests from https://my.tld
    are allowed. In figure 8.4, the request succeeds with the JSON payload, but if
    the CORS policy forbids the call, the app.js code would get an error while attempting
    to make a cross-origin request.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`"*"` 的值表示任何源都可以访问资源，而像 `https://my.tld` 这样的值则表示只有来自 https://my.tld 的跨源请求被允许。在图
    8.4 中，请求成功并带有 JSON 有效负载，但如果 CORS 策略禁止调用，当尝试执行跨源请求时，app.js 代码将收到错误。'
- en: Depending on the type of cross-origin HTTP request, web browsers do *simple*
    or *preflighted* requests. The request in figure 8.4 is a simple one. By contrast,
    a `PUT` request would need a preflighted request, as it can potentially have side
    effects (`PUT` implies modifying a resource), so a preflight `OPTIONS` HTTP request
    to the resource must be made to check what the CORS policy is, followed by the
    actual `PUT` request when allowed. Preflighted requests provide more detail, such
    as the allowed HTTP headers and methods, because a server can, for example, have
    a CORS policy of forbidding doing `DELETE` requests or having an `ABC` header
    in the HTTP request. I recommend reading Mozilla’s “Cross-Origin Resource Sharing
    (CORS)” document ([http://mng .bz/X0Z6](http://mng.bz/X0Z6)), as it provides a
    detailed and approachable explanation of the interactions between browsers and
    servers with CORS.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 根据跨源 HTTP 请求的类型，网络浏览器会执行 *简单* 或 *预检* 请求。图 8.4 中的请求是一个简单的请求。相比之下，一个 `PUT` 请求需要预检请求，因为它可能产生副作用（`PUT`
    表示修改资源），因此必须向资源发送预检 `OPTIONS` HTTP 请求以检查 CORS 策略，然后允许时再执行实际的 `PUT` 请求。预检请求提供了更多细节，例如允许的
    HTTP 头部和方法，因为服务器可以，例如，有一个禁止执行 `DELETE` 请求或包含 `ABC` 头部的 CORS 策略。我建议阅读 Mozilla 的“跨源资源共享
    (CORS)”文档 ([http://mng.bz/X0Z6](http://mng.bz/X0Z6))，因为它提供了详细且易于理解的浏览器和服务器之间 CORS
    交互的解释。
- en: 8.3.2 Supporting CORS with Vert.x
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.2 使用 Vert.x 支持 CORS
- en: 'Vert.x comes with a ready-to-use CORS handler with the `CorsHandler` class.
    Creating a `CorsHandler` instance requires three settings:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Vert.x 随带一个可用的 CORS 处理器，名为 `CorsHandler` 类。创建 `CorsHandler` 实例需要三个设置：
- en: The allowed origin pattern
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许的源模式
- en: The allowed HTTP headers
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许的 HTTP 头部
- en: The allowed HTTP methods
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许的 HTTP 方法
- en: The following listing shows how to install CORS support in a Vert.x router.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表展示了如何在 Vert.x 路由器中安装 CORS 支持。
- en: Listing 8.17 Installing CORS support in a router
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.17 在路由器中安装 CORS 支持
- en: '[PRE20]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ The set of allowed HTTP headers
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 允许的 HTTP 头部集合
- en: ❷ The set of allowed HTTP methods
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 允许的 HTTP 方法集合
- en: ❸ A CORS handler for all origins
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 适用于所有源的 CORS 处理器
- en: The HTTP methods are those supported in our API. You can see that we don’t support
    `DELETE`, for instance. The CORS handler has been installed for all routes, since
    they are all part of the API and should be accessible from any kind of application,
    including web browsers. The allowed headers should match what your API needs,
    and also what clients may pass, like specifying a content type, or headers that
    could be injected by proxies and for distributed tracing purposes.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 方法是我们API所支持的。你可以看到，例如，我们不支持`DELETE`。由于所有路由都是API的一部分，并且应该可以从任何类型的应用程序（包括网页浏览器）访问，因此已经为所有路由安装了CORS处理器。允许的头部应该与你的API需求相匹配，同时也应该与客户端可能传递的内容类型或代理可能注入的头部相匹配，以及用于分布式跟踪目的的头部。
- en: We can check that CORS is properly supported by making an HTTP `OPTIONS` preflight
    request to one of the routes supported by the API.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过向API支持的某个路由发出HTTP `OPTIONS`预检请求来检查CORS是否得到适当的支持。
- en: Listing 8.18 Checking CORS support
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.18 检查CORS支持
- en: '[PRE21]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: By specifying an `origin` HTTP header, the CORS handler inserts an `access-control-allow-origin`
    HTTP header in the response. The HTTP status code is 405, since the `OPTION` HTTP
    method is not supported by the specific route, but this is not an issue as web
    browsers are only interested in the CORS-related headers when they do a preflight
    request.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 通过指定一个`origin` HTTP头部，CORS处理器会在响应中插入一个`access-control-allow-origin` HTTP头部。HTTP状态码是405，因为特定的路由不支持`OPTION`
    HTTP方法，但这不是问题，因为当网页浏览器进行预检请求时，它们只对与CORS相关的头部感兴趣。
- en: 8.4 A modern web frontend
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.4 现代网络前端
- en: 'We have discussed the interesting points in the public API: how to make HTTP
    requests with the Vert.x web client, how to use JWT tokens, and how to enable
    CORS support. It is now time to see how we can expose the user web application
    (defined in chapter 7), and how that application can connect to the public API.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了公共API中的有趣点：如何使用Vert.x网络客户端进行HTTP请求，如何使用JWT令牌，以及如何启用CORS支持。现在是时候看看我们如何公开用户网络应用程序（在第7章中定义），以及该应用程序如何连接到公共API。
- en: 'The application is written with the Vue.js JavaScript framework. Vert.x is
    used to serve the application’s compiled assets: HTML, CSS, and JavaScript.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序是用Vue.js JavaScript框架编写的。Vert.x用于提供应用程序的编译资源：HTML、CSS和JavaScript。
- en: The corresponding source code is located in the part2-steps-challenge/user-webapp
    folder of the book’s source code repository.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的源代码位于书籍源代码仓库的part2-steps-challenge/user-webapp文件夹中。
- en: 8.4.1 Vue.js
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4.1 Vue.js
- en: Vue.js deserves a book by itself, and we recommend that you read Erik Hanchett
    and Benjamin Listwon’s *Vue.js in Action* (Manning, 2018) if you are interested
    in learning this framework. I’ll provide a quick overview here, since we’re using
    Vue.js as the JavaScript framework for the two web applications developed as part
    of the larger 10k steps application.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js值得有一本书来专门介绍，如果你对这个框架感兴趣，我们建议你阅读Erik Hanchett和Benjamin Listwon的《Vue.js
    in Action》（Manning，2018）。由于我们正在使用Vue.js作为两个作为更大10k steps应用程序一部分开发的网络应用程序的JavaScript框架，所以我将在这里提供一个快速概述。
- en: Vue.js is a modern JavaScript frontend framework, like React or Angular, for
    building modern web applications, including single-page applications. It is *reactive*
    as changes in a component model trigger changes in the user interface. Suppose
    that we display a temperature in a web page. When the corresponding data changes,
    the temperature is updated, and Vue.js takes care of (most) of the plumbing for
    doing that.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js是一个现代JavaScript前端框架，类似于React或Angular，用于构建现代网络应用程序，包括单页应用程序。它是*响应式*的，因为组件模型的变化会触发用户界面的变化。假设我们在网页上显示温度。当相应的数据发生变化时，温度会更新，Vue.js会负责（大多数）完成这项工作的管道。
- en: Vue.js supports components, where an HTML template, CSS styling, and JavaScript
    code can be grouped together, as in the following listing.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js支持组件，其中可以将HTML模板、CSS样式和JavaScript代码组合在一起，如下面的列表所示。
- en: Listing 8.19 Canvas of a Vue.js component
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.19 Vue.js组件的画布
- en: '[PRE22]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ Replaced by the value of the hello property
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 被hello属性的值替换
- en: ❷ CSS rules local to the component
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 组件本地的CSS规则
- en: ❸ The initial definition of the hello property
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ hello属性的初始定义
- en: 'A Vue.js project can be created using the Vue.js command-line interface ([https://cli
    .vuejs.org/](https://cli.vuejs.org/)):'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用Vue.js命令行界面创建Vue.js项目([https://cli.vuejs.org/](https://cli.vuejs.org/))：
- en: '[PRE23]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `yarn` build tool can then be used to install dependencies (`yarn install`),
    serve the project for development with automatic live-reload (`yarn run serve`),
    and build a production version of the project HTML, CSS, and JavaScript assets
    (`yarn run build`).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，可以使用 `yarn` 构建工具安装依赖项（`yarn install`），以自动实时重新加载的方式开发项目（`yarn run serve`），以及构建项目的生产版本
    HTML、CSS 和 JavaScript 资产（`yarn run build`）。
- en: 8.4.2 Vue.js application structure and build integration
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4.2 Vue.js 应用程序结构和构建集成
- en: 'The user web application is a single-page application with three different
    screens: a login form, a page with user details, and a registration form.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 用户网络应用程序是一个单页应用程序，有三个不同的屏幕：登录表单、用户详情页面和注册表单。
- en: 'The key Vue.js files are the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 关键 Vue.js 文件如下：
- en: src/main.js--The entry point
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: src/main.js--入口点
- en: src/router.js--The Vue.js router that dispatches to the components of the three
    different screens
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: src/router.js--将分发到三个不同屏幕组件的 Vue.js 路由
- en: src/DataStore.js--An object to hold the application store using the web browser
    local storage API, shared among all screens
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: src/DataStore.js--一个使用网络浏览器本地存储 API 保存应用程序存储的对象，所有屏幕共享
- en: src/App.vue--The main component that mounts the Vue.js router
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: src/App.vue--挂载 Vue.js 路由的主组件
- en: 'src/views--Contains the three screen components: `Home.vue`, `Login.vue`, and
    `Register.vue`'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: src/views--包含三个屏幕组件：`Home.vue`、`Login.vue` 和 `Register.vue`
- en: The Vue.js router configuration is shown in the following listing.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js 路由配置如下所示。
- en: Listing 8.20 Vue.js router configuration
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.20 Vue.js 路由配置
- en: '[PRE24]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ Component path
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 组件路径
- en: ❷ Component name
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 组件名称
- en: ❸ Component reference
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 组件引用
- en: The application code is colocated in the same module as the Vert.x application
    that serves the user web application, so you will find the usual Java source files
    under src/main/java and a Gradle build.gradle.kts file. The Vue.js compiled assets
    (`yarn build`) must be copied to src/main/resources/webroot/assets for the Vert.x-based
    service to serve them.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序代码与为用户网络应用程序提供服务的 Vert.x 应用程序位于同一模块中，因此你将在 src/main/java 下找到常规的 Java 源文件，以及一个
    Gradle build.gradle.kts 文件。Vue.js 编译资源（`yarn build`）必须复制到 src/main/resources/webroot/assets，以便基于
    Vert.x 的服务提供它们。
- en: This makes for two build tools in a single project, and fortunately they can
    coexist peacefully. In fact, it is very easy to call `yarn` from Gradle, as the
    com.moowork.node Gradle plugin provides a self-contained Node environment. The
    following listing shows the Node-related configuration of the user web application
    Gradle build file.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得在单个项目中存在两个构建工具，幸运的是，它们可以和平共存。实际上，从 Gradle 中调用 `yarn` 非常容易，因为 com.moowork.node
    Gradle 插件提供了一个自包含的 Node 环境。以下列表显示了用户网络应用程序 Gradle 构建文件的 Node 相关配置。
- en: Listing 8.21 Using the com.moowork.node Gradle plugin
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.21 使用 com.moowork.node Gradle 插件
- en: '[PRE25]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ❶ Uses the Node plugin
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 Node 插件
- en: ❷ Creates a task to call yarn
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个调用 yarn 的任务
- en: ❸ Adds a dependency on running yarn install first
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 添加了对先运行 yarn install 的依赖
- en: ❹ Gradle caching instructions that you can find in the full source code
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 你可以在完整源代码中找到的 Gradle 缓存指令
- en: ❺ Calls yarn build
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 调用 yarn build
- en: ❻ Task to copy the compiled assets
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 复制编译资源的任务
- en: ❼ Make sure building the project also builds the Vue.js application.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 确保构建项目时也构建 Vue.js 应用程序。
- en: ❽ Extra clean task to be done for the Vue.js compiled assets
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 为 Vue.js 编译资源执行额外清理任务
- en: The `buildVueApp` and `copyVueDist` tasks are inserted as part of the regular
    project build tasks, so the project builds both the Java Vert.x code and the Vue.js
    code. We also customize the `clean` task to remove the generated assets.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`buildVueApp` 和 `copyVueDist` 任务作为常规项目构建任务的一部分被插入，因此项目构建了 Java Vert.x 代码和 Vue.js
    代码。我们还自定义了 `clean` 任务以删除生成的资源。'
- en: 8.4.3 Backend integration illustrated
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4.3 后端集成示例
- en: 'Let’s look at one of the Vue.js components: the login screen shown in figure
    8.5.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个 Vue.js 组件：如图 8.5 所示的登录屏幕。
- en: '![](../Images/CH08_F05_Ponge.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH08_F05_Ponge.png)'
- en: Figure 8.5 Screenshot of the login screen
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 登录屏幕截图
- en: The file for this component is src/views/Login.vue. The component shows the
    login form, and when submitted it must call the public API to get a JWT token.
    On success, it must store the JWT token locally and then switch the view to the
    `home` component. On error, it must stay on the login form and display an error
    message.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件的文件位于 src/views/Login.vue。该组件显示登录表单，提交时必须调用公共 API 获取 JWT 令牌。成功后，必须在本地存储 JWT
    令牌，然后切换视图到 `home` 组件。出错时，必须停留在登录表单并显示错误信息。
- en: The HTML template part of the component is shown in the following listing.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的HTML模板部分如下所示。
- en: Listing 8.22 Login component HTML template
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.22 登录组件HTML模板
- en: '[PRE26]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ Conditionally display the div block depending on the value of the alertMessage
    component data.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 根据alertMessage组件数据值有条件地显示div块。
- en: ❷ Template syntax to render the value of alertMessage
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 模板语法用于渲染alertMessage的值
- en: ❸ Call the login method on form submit.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在表单提交时调用登录方法。
- en: ❹ v-model binds the field value to the username component data.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ `v-model`将字段值绑定到用户名组件数据。
- en: ❺ <router-link> allows linking to another component.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ `<router-link>`允许链接到另一个组件。
- en: The JavaScript part of the component provides the component data declaration
    as well as the `login` method implementation. We use the Axios JavaScript library
    to make HTTP client calls to the public API. The following listing provides the
    component JavaScript code.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的JavaScript部分提供了组件数据声明以及`login`方法实现。我们使用Axios JavaScript库对公共API进行HTTP客户端调用。以下列表提供了组件JavaScript代码。
- en: Listing 8.23 Login component JavaScript code
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.23 登录组件JavaScript代码
- en: '[PRE27]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ❶ Component data declaration
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 组件数据声明
- en: ❷ Component methods declaration
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 组件方法声明
- en: ❸ If either of the fields is empty, there is no point in trying to authenticate
    against the public API.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果任一字段为空，尝试对公共API进行身份验证是没有意义的。
- en: ❹ Issue an authentication request with the credentials as a JSON payload.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 以JSON有效负载的形式使用凭证发出身份验证请求。
- en: ❺ In case of success, store the token and username from the response.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 如果成功，从响应中存储令牌和用户名。
- en: ❻ Tell the router to change component.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 告诉路由器更改组件。
- en: ❼ Triggers the error message to be reactively displayed when the value of alertMessage
    changes
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 当alertMessage的值改变时，触发错误消息的响应式显示
- en: The component data properties are updated as the user types text in the username
    and password fields, and the `login` method is called on form submit. If the call
    succeeds, the application moves to the `home` component.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在用户名和密码字段中输入文本时，组件数据属性会更新，并在表单提交时调用`login`方法。如果调用成功，应用程序将移动到`home`组件。
- en: The next listing is from the code of the Home.vue component, and it shows how
    you can use the JWT token to fetch the user’s total number of steps.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表来自Home.vue组件的代码，展示了如何使用JWT令牌获取用户的总步数。
- en: Listing 8.24 Using the JWT token with Axios
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.24 使用Axios与JWT令牌
- en: '[PRE28]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ❶ Pass the token from the value fetched by the login component.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从登录组件获取的值中传递令牌。
- en: ❷ Update the component data, triggering a view refresh.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 更新组件数据，触发视图刷新。
- en: Let’s now see how we can serve the web application assets with Vert.x.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何使用Vert.x提供Web应用程序资源。
- en: 8.4.4 Static content serving with Vert.x
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4.4 使用Vert.x提供静态内容
- en: The Vert.x code does not have much to do beyond starting an HTTP server and
    serving static content. The following listing shows the content of the `rxStart`
    method of the `UserWebAppVerticle` class.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Vert.x代码除了启动HTTP服务器和提供静态内容外，没有太多要做。以下列表显示了`UserWebAppVerticle`类的`rxStart`方法的内容。
- en: Listing 8.25 Serving static content with Vert.x
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.25 使用Vert.x提供静态内容
- en: '[PRE29]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ❶ Resolve static content against webroot/assets in the classpath.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在类路径中解析webroot/assets的静态内容。
- en: ❷ Alias /* to /index.html.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 别名 /* 到 /index.html.
- en: The `StaticHandler` caches files in memory, unless configured otherwise in the
    call to the `create` method. Disabling caching is useful in development mode,
    because you can modify static assets’ content and see changes by reloading in
    a web browser without having to restart the Vert.x server. By default, static
    files are resolved from the webroot folder in the classpath, but you can override
    it as we did by specifying webroot/assets.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`StaticHandler`在内存中缓存文件，除非在调用`create`方法时进行其他配置。在开发模式下禁用缓存很有用，因为你可以修改静态资源的内容，并通过在网页浏览器中重新加载来查看更改，而无需重新启动Vert.x服务器。默认情况下，静态文件是从类路径中的webroot文件夹解析的，但你可以通过指定webroot/assets来覆盖它，就像我们做的那样。'
- en: Now that we’ve discussed how to use the Vert.x web stack, it is time to focus
    on testing the services that compose the reactive application.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经讨论了如何使用Vert.x Web栈，现在是时候关注测试组成响应式应用程序的服务了。
- en: 8.5 Writing integration tests
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.5 编写集成测试
- en: Testing is a very important concern, especially as there are multiple services
    involved in the making of the 10k steps challenge reactive application. There
    is no point in testing that the user web application service delivers static content
    properly, but it is crucial to have tests covering interactions with the public
    API service. Let’s discuss how to write integration tests for this service.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是一个非常重要的关注点，尤其是在 10k 步挑战反应式应用程序的制作中涉及多个服务时。测试用户 Web 应用程序服务是否正确提供静态内容是没有意义的，但拥有涵盖与公共
    API 服务交互的测试至关重要。让我们讨论如何为该服务编写集成测试。
- en: 'The public API source code reveals an `IntegrationTest` class. It contains
    several ordered test methods that check the API behavior:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 公共 API 源代码揭示了一个 `IntegrationTest` 类。它包含几个按顺序排列的测试方法，用于检查 API 行为：
- en: Register some users.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册一些用户。
- en: Get a JWT token for each user.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个用户获取 JWT 令牌。
- en: Fetch a user’s data.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取用户数据。
- en: Try to fetch the data of another user.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试获取另一个用户的数据。
- en: Update a user’s data.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新用户数据。
- en: Check some activity stats for a user.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查用户的一些活动统计信息。
- en: Try to check the activity of another user.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试检查另一个用户的活动。
- en: Since the public API service depends on the activity and user profile services,
    we either need to mock them with *fake* services that we run during the tests’
    execution, or deploy them along with all their dependencies, like databases. Either
    approach is fine. In the chapters in this part we will sometimes create a fake
    service for running our integration tests, and sometimes we will just deploy the
    real services.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 由于公共 API 服务依赖于活动和用户配置文件服务，我们需要在测试执行期间使用 *fake* 服务来模拟它们，或者像数据库一样与所有依赖项一起部署。任何一种方法都可以。在本部分的章节中，我们有时会创建一个模拟服务来运行我们的集成测试，有时我们只是部署实际的服务。
- en: In this case, we are going to deploy the real services, and we need to make
    this from JUnit 5 in a self-contained and reproducible manner. We first need to
    add the project dependencies, as in the following listing.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将部署实际的服务，并且需要以自包含和可重复的方式从 JUnit 5 中进行。我们首先需要添加项目依赖项，如下所示。
- en: Listing 8.26 Test dependencies to run the integration tests
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.26 运行集成测试的测试依赖项
- en: '[PRE30]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ❶ Dependency on another project module
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 依赖另一个项目模块
- en: ❷ This is used to insert data in PostgreSQL. More on that later.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 这用于在 PostgreSQL 中插入数据。稍后会有更多介绍。
- en: ❸ This is to run Docker containers.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 这是运行 Docker 容器的。
- en: ❹ A nice DSL library for testing HTTP services
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 一个用于测试 HTTP 服务的优秀 DSL 库
- en: 'These dependencies bring us two useful tools for writing tests:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这些依赖项为我们提供了两个用于编写测试的有用工具：
- en: Testcontainers is a project for running Docker containers in JUnit tests, so
    we will be able to use infrastructure services like PostgreSQL or Kafka ([www.test
    containers.org](http://www.testcontainers.org)).
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Testcontainers 是一个在 JUnit 测试中运行 Docker 容器的项目，因此我们将能够使用像 PostgreSQL 或 Kafka 这样的基础设施服务（[www.testcontainers.org](http://www.testcontainers.org)）。
- en: REST Assured is a library focusing on testing HTTP services, providing a convenient
    fluent API for describing requests and response assertions ([http://rest-assured.io](http://rest-assured.io)).
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST Assured 是一个专注于测试 HTTP 服务的库，提供了一个方便的流畅 API 来描述请求和响应断言（[http://rest-assured.io](http://rest-assured.io)）。
- en: The preamble of the test class is shown in the following listing.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 测试类的序言如下所示。
- en: Listing 8.27 Preamble of the integration test class
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.27 集成测试类的序言
- en: '[PRE31]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ❶ Use the Vert.x JUnit 5 support.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 Vert.x JUnit 5 支持。
- en: ❷ Test methods must be run in order.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 测试方法必须按顺序运行。
- en: ❸ Use Testcontainers support.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用 Testcontainers 支持。
- en: ❹ Start containers from a Docker Compose file.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 从 Docker Compose 文件启动容器。
- en: Testcontainers gives lots of choices for starting one or many containers. It
    supports generic Docker images, specialized classes for common infrastructure
    (PostgreSQL, Apache Kafka, etc.), and Docker Compose. Here we reuse the Docker
    Compose descriptor for running the whole application (`docker-compose.yml`), and
    the containers described in the file are started before the first test is run.
    The containers are destroyed when all tests have executed. This is very interesting--we
    get to write integration tests against the real infrastructure services that would
    be used in production.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: Testcontainers 提供了启动一个或多个容器的大量选择。它支持通用的 Docker 镜像、针对常见基础设施（PostgreSQL、Apache
    Kafka 等）的专用类，以及 Docker Compose。在这里，我们重用 Docker Compose 描述符来运行整个应用程序（`docker-compose.yml`），在运行第一个测试之前启动文件中描述的容器。所有测试执行完毕后，容器将被销毁。这非常有趣——我们可以编写针对实际基础设施服务的集成测试，这些服务将在生产中使用。
- en: The `prepareSpec` method is annotated with `@BeforeAll` and is used to prepare
    the tests. It inserts some data in the PostgreSQL database for the activity service
    and then deploys the user profile and activity verticles. It also prepares a `RequestSpecification`
    object from REST Assured, as follows.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`prepareSpec` 方法被 `@BeforeAll` 注解，用于准备测试。它为活动服务在 PostgreSQL 数据库中插入一些数据，然后部署用户配置文件和活动垂直服务。它还从
    REST Assured 准备一个 `RequestSpecification` 对象，如下所示。'
- en: Listing 8.28 Preparing a REST Assured request specification
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.28 准备 REST Assured 请求规范
- en: '[PRE32]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: ❶ All requests and responses will be logged, which is useful for tracking errors.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 所有请求和响应都将被记录，这对于跟踪错误很有用。
- en: ❷ This avoids repeating the base path of all URLs in requests.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 这避免了在请求中重复所有 URL 的基本路径。
- en: This object is shared among all tests methods, as they all have to make requests
    to the API. We enable logging of all requests and responses for easier debugging,
    and we set `/api/v1` as the base path for all requests.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 此对象在所有测试方法之间共享，因为它们都必须向 API 发送请求。我们启用对所有请求和响应的记录，以便更容易调试，并将 `/api/v1` 设置为所有请求的基本路径。
- en: The test class maintains a hash map of users to register and later use in calls,
    as well as a hash map of JWT tokens.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 测试类维护一个用户注册的哈希表，稍后用于调用，以及一个 JWT 令牌的哈希表。
- en: Listing 8.29 Utility hash maps for the integration test
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.29 集成测试的实用哈希表
- en: '[PRE33]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: ❶ Users
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 用户
- en: ❷ JWT tokens, once retrieved
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 一旦检索到 JWT 令牌
- en: The following listing is the first test, where the users from the `registrations`
    hash map are registered.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表是第一个测试，其中注册了来自 `registrations` 哈希表的用户。
- en: Listing 8.30 Test for registering users
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.30 注册用户的测试
- en: '[PRE34]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: ❶ We encode the JSON data to a string.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们将 JSON 数据编码为字符串。
- en: ❷ HTTP POST to /api/v1/register
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 向 `/api/v1/register` 发送 HTTP POST 请求
- en: ❸ Assert that the status code is a 200.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 断言状态码是 200。
- en: The REST Assured fluent API allows us to express our request and then do an
    assertion on the response. It is possible to extract a response as text or JSON
    to perform further assertions, as in the next listing, which is extracted from
    the test method that retrieves JWT tokens.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: REST Assured 流畅 API 允许我们表达我们的请求，然后对响应进行断言。我们可以将响应作为文本或 JSON 提取以进行进一步的断言，如下所示，这是从检索
    JWT 令牌的测试方法中提取的。
- en: Listing 8.31 Test code for retrieving JWT tokens
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.31 获取 JWT 令牌的测试代码
- en: '[PRE35]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: ❶ Assert that the content-type header is in the response and matches that of
    JWT tokens.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 断言响应中的内容类型头与 JWT 令牌匹配。
- en: ❷ Extract the response.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 提取响应。
- en: ❸ AssertJ assertions on a String
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在字符串上使用 AssertJ 断言
- en: The test fetches a token and then asserts that the token is neither a `null`
    value or a blank string (empty or with spaces). Extracting JSON data is similar,
    as shown next.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 测试获取一个令牌，然后断言该令牌既不是 `null` 值也不是空白字符串（空或包含空格）。提取 JSON 数据的方式类似，如下所示。
- en: Listing 8.32 Extracting JSON with REST Assured
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.32 使用 REST Assured 提取 JSON
- en: '[PRE36]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: ❶ Pass a JWT token.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 传递 JWT 令牌。
- en: ❷ Work with a JSON representation.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 与 JSON 表示形式一起工作。
- en: The test fetches the total number of steps for user `Foo`, extracts the JSON
    response, and then checks that the step count (the `count` key in the JSON response)
    is equal to 6255.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 测试获取用户 `Foo` 的总步骤数，提取 JSON 响应，然后检查步骤数（JSON 响应中的 `count` 键）等于 6255。
- en: The integration test can be run with Gradle (`./gradlew :public-api:test`) or
    from a development environment, as shown in figure 8.6.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试可以使用 Gradle (`./gradlew :public-api:test`) 或从开发环境运行，如图 8.6 所示。
- en: '![](../Images/CH08_F06_Ponge.png)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F06_Ponge.png)'
- en: Figure 8.6 Running the integration tests from IntelliJ IDEA
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6 从 IntelliJ IDEA 运行集成测试
- en: You now have a good understanding of using the Vert.x web stack both for exposing
    endpoints and consuming other services. The next chapter focuses on the messaging
    and event streaming stack of Vert.x.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在对使用 Vert.x 网络堆栈来公开端点和消费其他服务有了很好的理解。下一章将重点介绍 Vert.x 的消息和事件流堆栈。
- en: Summary
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: The Vert.x web module makes it easy to build an edge service with CORS support
    and HTTP calls to other services.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vert.x 网络模块使得构建支持 CORS 和对其他服务进行 HTTP 调用的边缘服务变得简单。
- en: JSON web tokens are useful for authorization and access control in a public
    API.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON 网络令牌在公共 API 的授权和访问控制中非常有用。
- en: Vert.x does not have a preference regarding frontend application frameworks,
    but it is easy to integrate a Vue.js frontend application.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vert.x 对前端应用程序框架没有偏好，但它很容易集成 Vue.js 前端应用程序。
- en: By combining Docker containers managed from Testcontainers and the Rest Assured
    library, you can write integration tests for HTTP APIs.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过结合由 Testcontainers 管理的 Docker 容器和 Rest Assured 库，您可以编写针对 HTTP API 的集成测试。
