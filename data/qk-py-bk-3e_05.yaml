- en: Chapter 4\. The absolute basics
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第四章：绝对基础知识
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Indenting and block structuring
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缩进和块结构
- en: Differentiating comments
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区分注释
- en: Assigning variables
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量赋值
- en: Evaluating expressions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式求值
- en: Using common data types
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用常见的数据类型
- en: Getting user input
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取用户输入
- en: Using correct Pythonic style
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用正确的 Python 风格
- en: 'This chapter describes the absolute basics in Python: how to use assignments
    and expressions, how to type a number or a string, how to indicate comments in
    code, and so forth. It starts with a discussion of how Python block structures
    its code, which differs from every other major language.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了 Python 的绝对基础知识：如何使用赋值和表达式，如何输入数字或字符串，如何在代码中指示注释，等等。它从讨论 Python 如何组织代码块开始，这与其他所有主要语言都不同。
- en: 4.1\. Indentation and block structuring
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1\. 缩进和块结构
- en: 'Python differs from most other programming languages because it uses whitespace
    and indentation to determine block structure (that is, to determine what constitutes
    the body of a loop, the `else` clause of a conditional, and so on). Most languages
    use braces of some sort to do this. Here is C code that calculates the factorial
    of 9, leaving the result in the variable `r`:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Python 与大多数其他编程语言不同，因为它使用空白和缩进来确定块结构（即确定循环的主体、条件语句的 `else` 子句等）。大多数语言使用某种类型的括号来做这件事。以下是一个计算
    9 的阶乘并将结果存储在变量 `r` 中的 C 代码示例：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The braces delimit the body of the `while` loop, the code that is executed
    with each repetition of the loop. The code is usually indented more or less as
    shown, to make clear what’s going on, but it could also be written like this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 括号定义了 `while` 循环的主体，即每次循环重复时执行的代码。代码通常按照所示进行缩进，以清楚地表明正在发生什么，但它也可以写成这样：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The code still would execute correctly, even though it’s rather difficult to
    read.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 即使代码的可读性相当差，代码仍然可以正确执行。
- en: 'Here’s the Python equivalent:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 Python 的等效代码：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***1* Python also supports C-style r *= n**'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* Python 也支持 C 风格的 r *= n**'
- en: '***2* Python also supports n -= 1**'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* Python 也支持 n -= 1**'
- en: Python doesn’t use braces to indicate code structure; instead, the indentation
    itself is used. The last two lines of the previous code are the body of the `while`
    loop because they come immediately after the `while` statement and are indented
    one level further than the `while` statement. If those lines weren’t indented,
    they wouldn’t be part of the body of the `while`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Python 不使用花括号来表示代码结构；相反，缩进本身就被用来表示。上一段代码的最后两行是 `while` 循环的主体，因为它们紧随 `while`
    语句之后，并且比 `while` 语句多缩进一个级别。如果那些行没有缩进，它们就不会是 `while` 循环的主体部分。
- en: 'Using indentation to structure code rather than braces may take some getting
    used to, but there are significant benefits:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用缩进来结构化代码而不是使用括号可能需要一段时间来适应，但好处是显著的：
- en: It’s impossible to have missing or extra braces. You never need to hunt through
    your code for the brace near the bottom that matches the one a few lines from
    the top.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可能缺少或多余的括号。你永远不需要在代码中寻找与顶部几行匹配的括号。
- en: The visual structure of the code reflects its real structure, which makes it
    easy to grasp the skeleton of code just by looking at it.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码的视觉结构反映了其实际结构，这使得仅通过查看代码就能轻松地掌握代码的骨架。
- en: Python coding styles are mostly uniform. In other words, you’re unlikely to
    go crazy from dealing with someone’s idea of aesthetically pleasing code. Everyone’s
    code will look pretty much like yours.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 的编码风格大多是统一的。换句话说，你不太可能因为处理某人认为美观的代码而变得疯狂。每个人的代码看起来都会很相似。
- en: You probably use consistent indentation in your code already, so this won’t
    be a big step for you. If you’re using IDLE, it automatically indents lines. You
    just need to backspace out of levels of indentation when desired. Most programming
    editors and IDEs—Emacs, VIM, and Eclipse, to name a few—provide this functionality
    as well. One thing that may trip you up once or twice until you get used to it
    is the fact that the Python interpreter returns an error message if you have a
    space (or spaces) preceding the commands you enter at a prompt.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经在代码中使用了一致的缩进，所以这对你来说不会是一个很大的步骤。如果你使用的是 IDLE，它将自动缩进行。你只需要在需要时使用退格键退出缩进级别。大多数编程编辑器和
    IDE（例如 Emacs、VIM 和 Eclipse）也提供此功能。一旦你习惯了，可能会让你困惑一次或两次的事情是，Python 解释器如果命令前有空格（或多个空格），会返回错误信息。
- en: 4.2\. Differentiating comments
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2\. 区分注释
- en: 'For the most part, anything following a `#` symbol in a Python file is a comment
    and is disregarded by the language. The obvious exception is a `#` in a string,
    which is just a character of that string:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python文件中，大部分跟随`#`符号的内容都是注释，并被语言忽略。明显的例外是字符串中的`#`，它只是该字符串的一个字符：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You’ll put comments in Python code frequently.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在Python代码中频繁地添加注释。
- en: 4.3\. Variables and assignments
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3. 变量和赋值
- en: The most commonly used command in Python is assignment, which looks pretty close
    to what you might’ve used in other languages. Python code to create a variable
    called `x` and assign the value 5 to that variable is
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Python中最常用的命令是赋值，其外观与其他语言中可能使用过的类似。创建一个名为`x`的变量并将值5赋给该变量的Python代码如下：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In Python, unlike in many other computer languages, neither a variable type
    declaration nor an end-of-line delimiter is necessary. The line is ended by the
    end of the line. Variables are created automatically when they’re first assigned.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，与许多其他计算机语言不同，不需要变量类型声明或行结束分隔符。行以行尾结束。变量在首次赋值时自动创建。
- en: '|  |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Variables in Python: buckets or labels?**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python中的变量：桶还是标签？**'
- en: The name *variable* is somewhat misleading in Python; *name* or *label* would
    be more accurate. However, it seems that pretty much everyone calls variables
    *variables* at some time or another. Whatever you call them, you should know how
    they really work in Python.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，*变量*这个名字有些误导；*名称*或*标签*可能更准确。然而，似乎几乎每个人在某个时候都会把变量称为*变量*。无论你称它们为什么，你应该知道它们在Python中是如何真正工作的。
- en: A common, but inaccurate, explanation is that a variable is a container that
    stores a value, somewhat like a bucket. This would be reasonable for many programming
    languages (C, for example).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见但并不准确的解释是，变量是一个存储值的容器，有点像桶。这对于许多编程语言（例如C语言）来说是合理的。
- en: However, in Python variables aren’t buckets. Instead, they’re labels or tags
    that refer to objects in the Python interpreter’s namespace. Any number of labels
    (or variables) can refer to the same object, and when that object changes, the
    value referred to by *all* of those variables also changes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在Python中，变量不是桶。相反，它们是标签或标记，指向Python解释器命名空间中的对象。任意数量的标签（或变量）可以指向同一个对象，当该对象发生变化时，所有这些变量所引用的值也会发生变化。
- en: 'To see what this means, look at the following simple code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解这意味着什么，请看以下简单的代码：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you’re thinking of variables as containers, this result makes no sense. How
    could changing the contents of one container simultaneously change the other two?
    However, if variables are just labels referring to objects, it makes sense that
    changing the object that all three labels refer to would be reflected everywhere.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为变量是容器，这个结果就没有意义。如何改变一个容器的内容同时改变另外两个？然而，如果变量只是标签，指向对象，那么改变所有三个标签指向的对象在所有地方都有所反映是有意义的。
- en: 'If the variables are referring to constants or immutable values, this distinction
    isn’t quite as clear:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果变量引用的是常量或不可变值，这种区别就不那么明显了：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Because the objects they refer to can’t change, the behavior of the variables
    in this case is consistent with either explanation. In fact, in this case, after
    the third line a, b, and c all refer to the same unchangeable integer object with
    the value 1. The next line, b = 5, makes b refer to the integer object 5 but doesn’t
    change the references of a or c.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们所引用的对象不能改变，这种情况下变量的行为与任何一种解释都一致。实际上，在这种情况下，第三行之后，a、b和c都指向同一个不可变的整数对象，其值为1。下一行`b
    = 5`使b指向整数对象5，但不会改变a或c的引用。
- en: '|  |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Python variables can be set to any object, whereas in C and many other languages,
    variables can store only the type of value they’re declared as. The following
    is perfectly legal Python code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Python变量可以设置为任何对象，而C语言和许多其他语言中的变量只能存储它们声明为的类型。以下是完全合法的Python代码：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`x` starts out referring to the string object `"Hello"` and then refers to
    the integer object `5`. Of course, this feature can be abused, because arbitrarily
    assigning the same variable name to refer successively to different data types
    can make code confusing to understand.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`x`最初指向字符串对象`"Hello"`，然后指向整数对象`5`。当然，这个特性可能会被滥用，因为任意地将相同的变量名连续赋值给不同的数据类型可能会使代码难以理解。'
- en: 'A new assignment overrides any previous assignments. The `del` statement deletes
    the variable. Trying to print the variable’s contents after deleting it results
    in an error, as though the variable had never been created in the first place:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 新的赋值会覆盖任何之前的赋值。`del` 语句会删除变量。在删除变量后尝试打印其内容会导致错误，就像变量从一开始就没有被创建过一样：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here, you have your first look at a *traceback*, which is printed when an error,
    called an *exception*, has been detected. The last line tells you what exception
    was detected, which in this case is a `NameError` exception on `x`. After its
    deletion, `x` is no longer a valid variable name. In this example, the trace returns
    only `line 1, in <module>` because only the single line has been sent in the interactive
    mode. In general, the full dynamic call structure of the existing function at
    the time of the error’s occurrence is returned. If you’re using IDLE, you obtain
    the same information with some small differences. The code may look something
    like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，你第一次看到了一个 *traceback*，当检测到错误，即所谓的 *exception* 时，会打印出来。最后一行告诉你检测到了什么异常，在这个例子中是
    `x` 上的 `NameError` 异常。在其删除后，`x` 就不再是有效的变量名。在这个例子中，由于只有单行被发送到交互模式，所以 trace 只返回
    `line 1, in <module>`。一般来说，在错误发生时，会返回当时现有函数的完整动态调用结构。如果你使用 IDLE，你将获得相同的信息，但有一些小的差异。代码可能看起来像这样：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[Chapter 14](kindle_split_025.html#ch14) describes this mechanism in more detail.
    A full list of the possible exceptions and what causes them is in the Python standard
    library documentation. Use the index to find any specific exception (such as `NameError`)
    you receive.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 14 章](kindle_split_025.html#ch14)更详细地描述了这一机制。可能的异常及其原因的完整列表可以在 Python 标准库文档中找到。使用索引查找你收到的任何特定异常（如
    `NameError`）。'
- en: Variable names are case-sensitive and can include any alphanumeric character
    as well as underscores but must start with a letter or underscore. See [section
    4.10](#ch04lev1sec10) for more guidance on the Pythonic style for creating variable
    names.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 变量名是区分大小写的，可以包括任何字母数字字符以及下划线，但必须以字母或下划线开头。有关创建变量名的 Python 风格的更多指导，请参阅[第 4.10
    节](#ch04lev1sec10)。
- en: 4.4\. Expressions
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4\. 表达式
- en: 'Python supports arithmetic and similar expressions; these expressions will
    be familiar to most readers. The following code calculates the average of 3 and
    5, leaving the result in the variable `z`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Python 支持算术和类似的表达式；这些表达式对大多数读者来说都很熟悉。以下代码计算了 3 和 5 的平均值，并将结果存储在变量 `z` 中：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that arithmetic operators involving only integers do *not* always return
    an integer. Even though all the values are integers, division (starting with Python
    3) returns a floating-point number, so the fractional part isn’t truncated. If
    you want traditional integer division returning a truncated integer, you can use
    `//` instead.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，仅涉及整数的算术运算符并不总是返回整数。尽管所有值都是整数，但除法（从 Python 3 开始）返回一个浮点数，因此小数部分不会被截断。如果你想要传统的整数除法返回截断的整数，可以使用
    `//` 代替。
- en: Standard rules of arithmetic precedence apply. If you’d left out the parentheses
    in the last line, the code would’ve been calculated as `x + (y / 2)`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的算术优先级规则适用。如果你在上面的最后一行省略了括号，代码将被计算为 `x + (y / 2)`。
- en: Expressions don’t have to involve just numerical values; strings, Boolean values,
    and many other types of objects can be used in expressions in various ways. I
    discuss these objects in more detail as they’re used.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式不必仅涉及数值；字符串、布尔值和许多其他类型的对象可以用各种方式用在表达式中。我将更详细地讨论这些对象，当它们被使用时。
- en: '|  |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Try this: Variables and expressions'
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试以下内容：变量和表达式
- en: In the Python shell, create some variables. What happens when you try to put
    spaces, dashes, or other nonalphanumeric characters in the variable name? Play
    around with a few complex expressions, such as `x = 2 + 4 * 5 – 6 / 3`. Use parentheses
    to group the numbers in different ways and see how the result changes compared
    with the original ungrouped expression.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 命令行中创建一些变量。当你尝试在变量名中放入空格、连字符或其他非字母数字字符时会发生什么？尝试一些复杂的表达式，例如 `x = 2 +
    4 * 5 – 6 / 3`。使用括号以不同的方式分组数字，并查看结果与原始未分组表达式的变化。
- en: '|  |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 4.5\. Strings
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5\. 字符串
- en: You’ve already seen that Python, like most other programming languages, indicates
    strings through the use of double quotes. This line leaves the string `"Hello,
    World"` in the variable `x:`
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到，Python，像大多数其他编程语言一样，使用双引号来表示字符串。这一行将字符串 `"Hello, World"` 存储在变量 `x` 中：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Backslashes can be used to escape characters, to give them special meanings.
    `\n` means the newline character, `\t` means the tab character, `\\` means a single
    normal backslash character, and `\"` is a plain double-quote character. It doesn’t
    end the string:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 反斜杠可以用作转义字符，赋予它们特殊含义。`\n`表示换行符，`\t`表示制表符，`\\`表示一个普通的单个反斜杠字符，而`\"`是一个普通的双引号字符。它不会结束字符串：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can use single quotes instead of double quotes. The following two lines
    do the same thing:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用单引号代替双引号。以下两行做的是同一件事：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The only difference is that you don’t need to backslash `"` characters in single-quoted
    strings or `''` characters in double-quoted strings:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别是，你不需要在单引号字符串中使用反斜杠`"`字符，或者在双引号字符串中使用反斜杠`'`字符：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can’t split a normal string across lines. This code won’t work:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能将普通字符串拆分到多行。以下代码不会工作：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'But Python offers triple-quoted strings, which let you do this and include
    single and double quotes without backslashes:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 但Python提供了三引号字符串，这使得你可以这样做，并且包括单引号和双引号而不需要反斜杠：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now `x` is the entire sentence between the `"""` delimiters. (You can use triple
    single quotes—`'''`—instead of triple double quotes to do the same thing.)
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`x`是`"""`分隔符之间的整个句子。（你也可以使用三单引号——`'''`——来达到同样的效果。）
- en: Python offers enough string-related functionality that [chapter 6](kindle_split_017.html#ch06)
    is devoted to the topic.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了足够的字符串相关功能，以至于[第6章](kindle_split_017.html#ch06)专门讨论了该主题。
- en: 4.6\. Numbers
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.6\. 数字
- en: Because you’re probably familiar with standard numeric operations from other
    languages, this book doesn’t contain a separate chapter describing Python’s numeric
    abilities. This section describes the unique features of Python numbers, and the
    Python documentation lists the available functions.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你很可能熟悉来自其他语言的常规数值操作，这本书没有单独的章节来描述Python的数值能力。本节描述了Python数字的独特特性，而Python文档列出了可用的函数。
- en: 'Python offers four kinds of numbers: *integers*, *floats*, *complex* *numbers*,
    and *Booleans*. An integer constant is written as an integer—0, –11, +33, 123456—and
    has unlimited range, restricted only by the resources of your machine. A float
    can be written with a decimal point or in scientific notation: 3.14, –2E-8, 2.718281828\.
    The precision of these values is governed by the underlying machine but is typically
    equal to double (64-bit) types in C. Complex numbers are probably of limited interest
    and are discussed separately later in the section. Booleans are either `True`
    or `False` and behave identically to 1 and 0 except for their string representations.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了四种类型的数字：*整数*、*浮点数*、*复数*和*布尔值*。一个整数常量写作一个整数——0、–11、+33、123456，并且具有无限的范围，仅受限于你机器的资源。浮点数可以用小数点或科学记数法来写：3.14、–2E-8、2.718281828。这些值的精度由底层机器控制，但通常等于C中的双精度（64位）类型。复数可能不太有趣，将在本节稍后单独讨论。布尔值要么是`True`要么是`False`，除了它们的字符串表示外，它们的行为与1和0相同。
- en: 'Arithmetic is much like it is in C. Operations involving two integers produce
    an integer, except for division (`/`), which results in a float. If the `//` division
    symbol is used, the result is an integer, with truncation. Operations involving
    a float always produce a float. Here are a few examples:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 算术运算与C语言中的类似。涉及两个整数的运算会产生一个整数，除了除法（`/`），它会产生一个浮点数。如果使用`//`除法符号，结果是一个整数，并且会截断。涉及浮点数的运算总是产生一个浮点数。以下是一些示例：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: These are explicit conversions between types ***1***. `int` truncates float
    values.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是类型之间的显式转换 ***1***。`int`截断浮点数值。
- en: 'Numbers in Python have two advantages over C or Java: Integers can be arbitrarily
    large, and the division of two integers results in a float.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的数字比C或Java有两个优势：整数可以任意大，两个整数的除法结果是一个浮点数。
- en: 4.6.1\. Built-in numeric functions
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.6.1\. 内置数值函数
- en: 'Python provides the following number-related functions as part of its core:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Python作为其核心部分提供了以下与数字相关的函数：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: See the documentation for details.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅文档以获取详细信息。
- en: 4.6.2\. Advanced numeric functions
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.6.2\. 高级数值函数
- en: More advanced numeric functions such as the trig and hyperbolic trig functions,
    as well as a few useful constants, aren’t built into Python but are provided in
    a standard module called `math`. I explain modules in detail later. For now, it’s
    sufficient to know that you must make the math functions in this section available
    by starting your Python program or interactive session with the statement
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 更高级的数值函数，如三角函数和双曲三角函数，以及一些有用的常量，并没有内置到 Python 中，而是在一个名为 `math` 的标准模块中提供。我将在后面详细解释模块。现在，只需知道你必须通过在启动
    Python 程序或交互会话时使用以下语句来使本节中的数学函数可用：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `math` module provides the following functions and constants:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`math` 模块提供了以下函数和常量：'
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: See the documentation for details.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅文档以获取详细信息。
- en: 4.6.3\. Numeric computation
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.6.3\. 数值计算
- en: The core Python installation isn’t well suited to intensive numeric computation
    because of speed constraints. But the powerful Python extension `NumPy` provides
    highly efficient implementations of many advanced numeric operations. The emphasis
    is on array operations, including multidimensional matrices and more advanced
    functions such as the Fast Fourier Transform. You should be able to find `NumPy`
    (or links to it) at [www.scipy.org](http://www.scipy.org).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 由于速度限制，Python 的核心安装并不适合进行密集的数值计算。但强大的 Python 扩展 `NumPy` 提供了许多高级数值操作的高效实现。重点是数组操作，包括多维矩阵以及更高级的函数，如快速傅里叶变换。你应该能在
    [www.scipy.org](http://www.scipy.org) 找到 `NumPy`（或其链接）。
- en: 4.6.4\. Complex numbers
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.6.4\. 复数
- en: 'Complex numbers are created automatically whenever an expression of the form
    `nj` is encountered, with `n` having the same form as a Python integer or float.
    `j` is, of course, standard notation for the imaginary number equal to the square
    root of –1, for example:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 每当遇到形式为 `nj` 的表达式时，复数就会自动创建，其中 `n` 的形式与 Python 整数或浮点数相同。`j` 当然是表示等于 –1 的平方根的虚数的标准表示法，例如：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Note that Python expresses the resulting complex number in parentheses as a
    way of indicating that what’s printed to the screen represents the value of a
    single object:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Python 以括号的形式表示结果复数，以此表明打印到屏幕上的值代表单个对象的价值：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Calculating `j * j` gives the expected answer of –1, but the result remains
    a Python complex-number object. Complex numbers are never converted automatically
    to equivalent real or integer objects. But you can easily access their real and
    imaginary parts with `real` and `imag`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 计算 `j * j` 会得到预期的答案 –1，但结果仍然是一个 Python 复数对象。复数永远不会自动转换为等效的实数或整数对象。但你可以通过 `real`
    和 `imag` 容易地访问它们的实部和虚部：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note that real and imaginary parts of a complex number are always returned as
    floating-point numbers.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，复数的实部和虚部始终以浮点数的形式返回。
- en: 4.6.5\. Advanced complex-number functions
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.6.5\. 高级复数函数
- en: 'The functions in the `math` module don’t apply to complex numbers; the rationale
    is that most users want the square root of –1 to generate an error, not an answer!
    Instead, similar functions, which can operate on complex numbers, are provided
    in the `cmath` module:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`math` 模块中的函数不适用于复数；其理由是大多数用户希望 –1 的平方根产生一个错误，而不是一个答案！相反，`cmath` 模块提供了可以操作复数的类似函数：'
- en: '[PRE24]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: To make clear in the code that these functions are special-purpose complex-number
    functions and to avoid name conflicts with the more normal equivalents, it’s best
    to import the `cmath` module by saying
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在代码中明确指出这些函数是特殊用途的复数函数，并避免与更常见的等效函数的名称冲突，最好通过以下方式导入 `cmath` 模块：
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'and then to explicitly refer to the `cmath` package when using the function:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在使用函数时明确引用 `cmath` 包：
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '|  |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Minimizing from <module> import ***'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**最小化从 <module> 导入 ***'
- en: This is a good example of why it’s best to minimize the use of the `from <module>
    import *` form of the `import` statement. If you used it to import first the `math`
    module and then the `cmath` module, the commonly named functions in `cmath` would
    override those of `math`. It’s also more work for someone reading your code to
    figure out the source of the specific functions you use. Some modules are explicitly
    designed to use this form of import.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的例子，说明了为什么最好最小化使用 `from <module> import *` 形式的 `import` 语句。如果你首先导入了 `math`
    模块，然后导入了 `cmath` 模块，`cmath` 中的常用函数将覆盖 `math` 中的函数。对于阅读你代码的人来说，确定你使用的特定函数的来源也是一项额外的工作。一些模块明确设计为使用这种导入形式。
- en: See [chapter 10](kindle_split_021.html#ch10) for more details on how to use
    modules and module names.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何使用模块和模块名称的更多详细信息，请参阅[第 10 章](kindle_split_021.html#ch10)。
- en: '|  |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The important thing to keep in mind is that by importing the `cmath` module,
    you can do almost anything you can do with other numbers.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的重要一点是，通过导入 `cmath` 模块，你可以做几乎所有其他数字能做的事情。
- en: '|  |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Try this: Manipulating strings and numbers'
  id: totrans-121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：操作字符串和数字
- en: In the Python shell, create some string and number variables (integers, floats,
    *and* complex numbers). Experiment a bit with what happens when you do operations
    with them, including across types. Can you multiply a string by an integer, for
    example, or can you multiply it by a float or complex number? Also load the `math`
    module and try a few of the functions; then load the `cmath` module and do the
    same. What happens if you try to use one of those functions on an integer or float
    after loading the `cmath` module? How might you get the `math` module functions
    back?
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 命令行中，创建一些字符串和数字变量（整数、浮点数，*以及*复数）。尝试一下当你对这些变量进行操作时会发生什么，包括跨类型操作。例如，你能将一个字符串乘以一个整数吗？或者你能将它乘以一个浮点数或复数吗？然后加载
    `math` 模块并尝试几个函数；然后加载 `cmath` 模块并做同样的操作。如果你在加载 `cmath` 模块后尝试使用这些函数之一对整数或浮点数进行操作会发生什么？你如何获取
    `math` 模块函数？
- en: '|  |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 4.7\. The None value
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.7\. `None` 值
- en: In addition to standard types such as strings and numbers, Python has a special
    basic data type that defines a single special data object called `None`. As the
    name suggests, `None` is used to represent an empty value. It appears in various
    guises throughout Python. For example, a procedure in Python is just a function
    that doesn’t explicitly return a value, which means that by default, it returns
    `None`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 除了字符串和数字等标准类型之外，Python 还有一个特殊的基本数据类型，它定义了一个称为 `None` 的单个特殊数据对象。正如其名所示，`None`
    用于表示空值。它在 Python 的各个地方都有所体现。例如，Python 中的过程只是一个不显式返回值的函数，这意味着它默认返回 `None`。
- en: '`None` is often useful in day-to-day Python programming as a placeholder to
    indicate a point in a data structure where meaningful data will eventually be
    found, even though that data hasn’t yet been calculated. You can easily test for
    the presence of `None` because there’s only one instance of `None` in the entire
    Python system (all references to `None` point to the same object), and `None`
    is equivalent only to itself.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在日常 Python 编程中，`None` 经常很有用，作为一个占位符来指示数据结构中的一个点，最终将找到有意义的数据，即使这些数据尚未计算。你可以轻松地测试
    `None` 的存在，因为整个 Python 系统中只有一个 `None` 实例（所有对 `None` 的引用都指向同一个对象），并且 `None` 只等同于自身。
- en: 4.8\. Getting input from the user
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.8\. 从用户获取输入
- en: 'You can also use the `input()` function to get input from the user. Use the
    prompt string you want to display to the user as `input`’s parameter:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 `input()` 函数从用户获取输入。将你想显示给用户的提示字符串作为 `input` 的参数：
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '***1* Converts input from string to int**'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将输入从字符串转换为 int**'
- en: This is a fairly simple way to get user input. The one catch is that the input
    comes in as a string, so if you want to use it as a number, you have to use the
    `int()` or `float()` function to convert it.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种获取用户输入的相当简单的方法。唯一的缺点是输入以字符串的形式出现，所以如果你想将其用作数字，你必须使用 `int()` 或 `float()`
    函数将其转换。
- en: '|  |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Try this: Getting input'
  id: totrans-133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：获取输入
- en: Experiment with the `input()` function to get string and integer input. Using
    code similar to the previous code, what is the effect of not using `int()` around
    the call to `input()`for integer input? Can you modify that code to accept a float—say,
    28.5? What happens if you deliberately enter the wrong type of value? Examples
    include a float in which an integer is expected and a string in which a number
    is expected—and vice versa.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用 `input()` 函数获取字符串和整数输入。使用与之前代码类似的代码，不使用 `int()` 来调用 `input()` 对整数输入有什么影响？你能修改这段代码以接受浮点数——比如，28.5
    吗？如果你故意输入错误类型的值会发生什么？例如，一个期望整数但输入了浮点数的情况，以及一个期望数字但输入了字符串的情况——反之亦然。
- en: '|  |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 4.9\. Built-in operators
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.9\. 内置运算符
- en: Python provides various built-in operators, from the standard (`+`, `*`, and
    so on) to the more esoteric, such as operators for performing bit shifting, bitwise
    logical functions, and so forth. Most of these operators are no more unique to
    Python than to any other language; hence, I won’t explain them in the main text.
    You can find a complete list of the Python built-in operators in the documentation.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了各种内置运算符，从标准的（`+`, `*` 等）到更神秘的，例如执行位移位、位逻辑函数等运算符。这些运算符中的大多数并不比其他语言更独特，因此，我将在正文中不对其进行解释。你可以在文档中找到
    Python 内置运算符的完整列表。
- en: 4.10\. Basic Python style
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.10. 基本Python风格
- en: Python has relatively few limitations on coding style with the obvious exception
    of the requirement to use indentation to organize code into blocks. Even in that
    case, the amount of indentation and type of indentation (tabs versus spaces) isn’t
    mandated. However, there are preferred stylistic conventions for Python, which
    are contained in Python Enhancement Proposal (PEP) 8, which is summarized in [appendix
    A](kindle_split_039.html#app02) and available online at [www.python.org/dev/peps/pep-0008/](http://www.python.org/dev/peps/pep-0008/).
    A selection of Pythonic conventions is provided in [table 4.1](#ch04table01),
    but to fully absorb Pythonic style, periodically reread PEP 8.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Python 在编码风格上相对较少的限制，除了要求使用缩进来组织代码块之外。即使在那种情况下，缩进量以及缩进类型（制表符与空格）也没有强制规定。然而，Python
    有一些首选的样式约定，这些约定包含在 Python 增强提案（PEP）8 中，该提案在附录 A（kindle_split_039.html#app02）中总结，并在
    [www.python.org/dev/peps/pep-0008/](http://www.python.org/dev/peps/pep-0008/)
    上提供。Python 风格约定的选择在 [表 4.1](#ch04table01) 中提供，但要完全吸收 Python 风格，定期重读 PEP 8。
- en: Table 4.1\. Pythonic coding conventions
  id: totrans-140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 4.1. Python 风格编码约定
- en: '| Situation | Suggestion | Example |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 情况 | 建议 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Module/package names | Short, all lowercase, underscores only if needed |
    imp, sys |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 模块/包名 | 简短，全部小写，如果需要则使用下划线 | imp, sys |'
- en: '| Function names | All lowercase, underscores_for_readablitiy | foo(), my_func()
    |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 函数名 | 全部小写，使用下划线以提高可读性 | foo(), my_func() |'
- en: '| Variable names | All lowercase, underscores_for_readablitiy | my_var |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 变量名 | 全部小写，使用下划线以提高可读性 | my_var |'
- en: '| Class names | CapitalizeEachWord | MyClass |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 类名 | 每个单词首字母大写 | MyClass |'
- en: '| Constant names | ALL_CAPS_WITH_UNDERSCORES | PI, TAX_RATE |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 常量名 | 全大写，使用下划线分隔 | PI, TAX_RATE |'
- en: '| Indentation | Four spaces per level, no tabs |   |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 缩进 | 每级四个空格，不使用制表符 |   |'
- en: '| Comparisons | Don’t compare explicitly to True or False | if my_var: if not
    my_var: |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 比较 | 不要显式地与 True 或 False 进行比较 | if my_var: if not my_var: |'
- en: I strongly urge you to follow the conventions of PEP 8\. They’re wisely chosen
    and time-tested, and they’ll make your code easier for you and other Python programmers
    to understand.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议你遵循 PEP 8 的约定。这些约定是经过深思熟虑且经过时间考验的，它们会使你的代码对你和其他 Python 程序员来说更容易理解。
- en: '|  |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Quick Check: Pythonic style'
  id: totrans-152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：Python风格
- en: Which of the following variable and function names do you think are not good
    Pythonic style? Why?
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为以下哪些变量和函数名不符合 Python 风格？为什么？
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '|  |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Summary
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: The basic syntax summarized above is enough to start writing Python code.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上述基本语法足以开始编写 Python 代码。
- en: Python syntax is predictable and consistent.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 语法是可预测且一致的。
- en: Because the syntax offers few surprises, many programmers can get started writing
    code surprisingly quickly.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于语法提供的惊喜不多，许多程序员可以出人意料地快速开始编写代码。
