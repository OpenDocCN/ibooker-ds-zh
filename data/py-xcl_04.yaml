- en: Chapter 3\. Getting Started with Python
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 第三章。开始学习Python
- en: With Anaconda installed and Jupyter notebooks up and running, you have everything
    in place to get started with Python. Although this chapter doesn’t go much further
    than the basics, it still covers a lot of ground. If you are at the beginning
    of your coding career, there may be a lot to digest. However, most concepts will
    get clearer once you use them in later chapters as part of a practical example,
    so there’s no need to worry if you don’t understand something fully the first
    time around. Whenever Python and VBA differ significantly, I will point this out
    to make sure you can transition from VBA to Python smoothly and are aware of the
    obvious traps. If you haven’t done any VBA before, feel free to ignore these parts.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了Anaconda并且Jupyter笔记本已经运行起来后，你就准备好开始使用Python了。虽然本章不会深入探讨基础之外的内容，但它仍然涵盖了很多内容。如果你刚开始学习编程，可能需要消化的内容很多。然而，大多数概念在后面的章节中通过实际示例使用后会变得更加清晰，因此如果第一次理解不完全，也不用担心。每当Python和VBA有显著区别时，我会指出来，以确保你能够顺利从VBA过渡到Python，并了解显而易见的陷阱。如果你以前没有接触过VBA，可以忽略这些部分。
- en: I will start this chapter with Python’s basic data types, such as integers and
    strings. After that, I will introduce indexing and slicing, a core concept in
    Python that gives you access to specific elements of a sequence. Up next are data
    structures like lists and dictionaries that can hold multiple objects. I’ll continue
    with the `if` statement and the `for` and `while` loops before getting to an introduction
    of functions and modules that allow you to organize and structure your code. To
    wrap this chapter up, I will show you how to format your Python code properly.
    As you have probably guessed by now, this chapter is as technical as it can get.
    Running the examples for yourself in a Jupyter notebook is therefore a good idea
    to make everything a bit more interactive and playful. Either type the examples
    yourself or run them by using the provided notebooks in the companion repository.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从Python的基本数据类型开始，比如整数和字符串。接下来，我会介绍索引和切片，这是Python中的核心概念，它让你可以访问序列的特定元素。接着是像列表和字典这样可以容纳多个对象的数据结构。我会继续介绍`if`语句以及`for`和`while`循环，然后介绍允许你组织和结构化代码的函数和模块。最后，我会展示如何正确格式化你的Python代码。到目前为止，你可能已经猜到，这一章的技术性非常强。在Jupyter笔记本中运行示例对于使一切更加互动和有趣是个不错的主意。你可以自己输入示例，也可以使用伴随存储库中提供的笔记本来运行它们。
- en: Data Types
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型
- en: Python, like every other programming language, treats numbers, text, booleans,
    etc. differently by assigning them a different data type. The data types that
    we will use most often are integers, floats, booleans, and strings. In this section,
    I am going to introduce them one after another with a few examples. To be able
    to understand data types, though, I first need to explain what an object is.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Python和其他编程语言一样，通过为它们分配不同的数据类型来区分数字、文本、布尔值等。我们经常使用的数据类型包括整数、浮点数、布尔值和字符串。在这一部分，我将逐个介绍它们，并举几个例子。然而，要理解数据类型，首先需要解释对象是什么。
- en: Objects
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 对象
- en: In Python, everything is an object, including numbers, strings, functions, and
    everything else that we’ll meet in this chapter. Objects can make complex things
    easy and intuitive by giving you access to a set of variables and functions. So
    before anything else, let me say a few words about variables and functions!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，一切都是对象，包括数字、字符串、函数以及我们在本章中将遇到的所有内容。通过提供对一组变量和函数的访问，对象可以通过使复杂的事情变得简单和直观来帮助你。因此，在任何其他事情之前，让我先介绍一些关于变量和函数的内容！
- en: Variables
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 变量
- en: 'In Python, a variable is a name that you assign to an object by using the equal
    sign. In the first line of the following example, the name `a` is assigned to
    the object `3`:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，变量是通过使用等号将名称分配给对象来定义的。在以下示例的第一行中，名称`a`被分配给对象`3`：
- en: '`In``[``1``]:``a``=``3``b``=``4``a``+``b`'
  id: totrans-9
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``1``]:``a``=``3``b``=``4``a``+``b`'
- en: '`Out[1]: 7`'
  id: totrans-10
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[1]: 7`'
- en: 'This works the same for all objects, which is simpler compared to VBA, where
    you use the equal sign for data types like numbers and strings and the `Set` statement
    for objects like workbooks or worksheets. In Python, you change a variable’s type
    simply by assigning it to a new object. This is referred to as dynamic typing:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有对象来说，这在Python中都是相同的，相比之下，VBA更简单，你可以使用等号表示数字和字符串等数据类型，使用`Set`语句表示像工作簿或工作表这样的对象。在Python中，你可以通过将变量分配给一个新对象来简单地改变变量的类型。这被称为动态类型：
- en: '`In``[``2``]:``a``=``3``print``(``a``)``a``=``"three"``print``(``a``)`'
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``2``]:``a``=``3``print``(``a``)``a``=``"three"``print``(``a``)`'
- en: '`3 three`'
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`3 three`'
- en: 'Unlike VBA, Python is case-sensitive, so `a` and `A` are two different variables.
    Variable names must follow certain rules:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 与VBA不同，Python是区分大小写的，所以`a`和`A`是两个不同的变量。变量名必须遵循某些规则：
- en: They must start with either a letter or an underscore
  id: totrans-15
  prefs:
  - PREF_UL
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 它们必须以字母或下划线开头
- en: They must consist of letters, numbers, and underscores
  id: totrans-16
  prefs:
  - PREF_UL
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 它们必须由字母、数字和下划线组成
- en: After this short introduction to variables, let’s see how we can make function
    calls!
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个关于变量的简短介绍之后，让我们看看如何进行函数调用！
- en: Functions
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 函数
- en: 'I will introduce functions with a lot more detail later in this chapter. For
    now, you should simply know how to call built-in functions like `print` that we
    used in the previous code sample. To call a function, you add parentheses to the
    function name and provide the arguments within the parentheses, which is pretty
    much equivalent to the mathematical notation:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在本章后面更详细地介绍函数。现在，你只需要知道如何调用内置函数，比如我们在前面代码示例中使用的`print`。要调用函数，你需要在函数名后加上括号，并在括号内提供参数，这几乎相当于数学表示法：
- en: '`function_name``(``argument1``,``argument2``,``...``)`'
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`function_name``(``argument1``,``argument2``,``...``)`'
- en: Let’s now look at how variables and functions work in the context of objects!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看在对象的上下文中变量和函数是如何工作的！
- en: Attributes and methods
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 属性和方法
- en: 'In the context of objects, variables are called attributes and functions are
    called methods: attributes give you access to the data of an object, and methods
    allow you to perform an action. To access attributes and methods, you use the
    dot notation like this: `myobject.attribute` and `myobject.method()`.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象的上下文中，变量被称为属性，函数被称为方法：属性允许你访问对象的数据，而方法允许你执行操作。要访问属性和方法，你可以使用点号表示法，如`myobject.attribute`和`myobject.method()`。
- en: 'Let’s make this a bit more tangible: if you write a car racing game, you would
    most likely use an object that represents a car. The `car` object could have a
    `speed` attribute that allows you to get the current speed via `car.speed`, and
    you might be able to accelerate the car by calling the accelerate method `car.accelerate(10)`,
    which would increase the speed by ten miles per hour.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们具体化一下：如果你编写了一个汽车赛车游戏，你很可能会使用一个表示汽车的对象。`car`对象可能有一个`speed`属性，通过`car.speed`可以获取当前速度，并且你可以通过调用`car.accelerate(10)`方法来加速汽车，这将使速度增加十英里每小时。
- en: 'The type of an object and with that its behavior is defined by a class, so
    the previous example would require you to write a `Car` class. The process of
    getting a `car` object out of a `Car` class is called instantiation, and you instantiate
    an object by calling the class in the same way as you call a function: `car =
    Car()`. We won’t write our own classes in this book, but if you are interested
    in how this works, have a look at [Appendix C](index_split_031.html#filepos1832059).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的类型及其行为由类定义，因此前面的例子需要你编写一个`Car`类。从`Car`类获取一个`car`对象的过程称为实例化，你可以通过调用类来实例化对象，就像调用函数一样：`car
    = Car()`。我们不会在本书中编写自己的类，但如果你对其工作原理感兴趣，请查看[附录 C](index_split_031.html#filepos1832059)。
- en: We will use a first object method in the next section to make a text string
    uppercase, and we will get back to the topic of objects and classes when we talk
    about `datetime` objects toward the end of this chapter. Now, however, let’s move
    on with those objects that have a numeric data type!
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的一节中，我们将使用第一个对象方法使文本字符串变为大写，并且当我们讨论本章末尾关于`datetime`对象时，我们将回到对象和类的主题。现在，让我们继续讨论具有数值数据类型的对象！
- en: Numeric Types
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 数值类型
- en: 'The data types `int` and `float` represent integers and floating-point numbers,
    respectively. To find out the data type of a given object, use the built-in `type`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型`int`和`float`分别表示整数和浮点数。要找出给定对象的数据类型，使用内置的`type`函数：
- en: '`In``[``3``]:``type``(``4``)`'
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``3``]:``type``(``4``)`'
- en: '`Out[3]: int`'
  id: totrans-30
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[3]: int`'
- en: '`In``[``4``]:``type``(``4.4``)`'
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``4``]:``type``(``4.4``)`'
- en: '`Out[4]: float`'
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[4]: float`'
- en: 'If you want to force a number to be a `float` instead of an `int`, it’s good
    enough to use a trailing decimal point or the `float` constructor:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想将数字强制转换为`float`而不是`int`，只需使用尾部的小数点或`float`构造函数即可：
- en: '`In``[``5``]:``type``(``4.``)`'
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``5``]:``type``(``4.``)`'
- en: '`Out[5]: float`'
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[5]: float`'
- en: '`In``[``6``]:``float``(``4``)`'
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``6``]:``float``(``4``)`'
- en: '`Out[6]: 4.0`'
  id: totrans-37
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[6]: 4.0`'
- en: 'The last example can also be turned around: using the `int` constructor, you
    can turn a `float` into an `int`. If the fractional part is not zero, it will
    be truncated:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个示例也可以反过来使用：使用 `int` 构造函数，你可以将 `float` 转换为 `int`。如果小数部分不为零，它将被截断：
- en: '`In``[``7``]:``int``(``4.9``)`'
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``7``]:``int``(``4.9``)`'
- en: '`Out[7]: 4`'
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[7]: 4`'
- en: EXCEL CELLS ALWAYS STORE FLOATS
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: EXCEL 单元格始终存储浮点数
- en: You may need to convert a `float` to an `int` when you read in a number from
    an Excel cell and provide it as an argument to a Python function that expects
    an integer. The reason is that numbers in Excel cells are always stored as floats
    behind the scenes, even if Excel shows you what looks like an integer.
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当你需要从 Excel 单元格中读取一个数，并将其作为整数传递给 Python 函数时，可能需要将 `float` 转换为 `int`。原因是，Excel
    单元格中的数字始终以浮点数形式存储，即使 Excel 显示的是整数也是如此。
- en: 'Python has a few more numeric types that I won’t use or discuss in this book:
    there are the `decimal`, `fraction`, and `complex` data types. If floating-point
    inaccuracies are an issue (see sidebar), use the `decimal` type for exact results.
    These cases are very rare, though. As a rule of thumb: if Excel would be good
    enough for the calculations, use floats.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Python 还有一些数值类型，本书不会使用或讨论：有 `decimal`、`fraction` 和 `complex` 数据类型。如果浮点数不准确是个问题（参见侧边栏），可以使用
    `decimal` 类型获得精确的结果。不过，这类情况非常罕见。作为一个经验法则：如果 Excel 的计算结果已经足够，那就使用浮点数。
- en: FLOATING-POINT INACCURACIES
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 浮点数不准确
- en: 'By default, Excel often shows rounded numbers: type `=1.125-1.1` into a cell,
    and you will see `0.025`. While this might be what you expect, it is not what
    Excel stores internally. Change the display format to show at least 16 decimals,
    and it will change to `0.0249999999999999`. This is the effect of floating-point
    inaccuracy: computers live in a binary world, i.e., they calculate only with zeros
    and ones. Certain decimal fractions like `0.1` can’t be stored as a finite binary
    floating-point number, which explains the result from the subtraction. In Python,
    you will see the same effect, but Python doesn’t hide the decimals from you:'
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 默认情况下，Excel 经常显示四舍五入的数字：在单元格中输入 `=1.125-1.1`，你会看到 `0.025`。虽然这可能是你期望的结果，但这不是
    Excel 内部存储的内容。将显示格式更改为至少显示 16 位小数，结果将变为 `0.0249999999999999`。这是浮点数不准确的影响：计算机生活在一个二进制世界中，即它们只能使用
    0 和 1 进行计算。某些十进制分数如 `0.1` 无法作为有限的二进制浮点数存储，这解释了减法的结果。在 Python 中，你会看到相同的效果，但 Python
    不会隐藏小数部分：
- en: '`In``[``8``]:``1.125``-``1.1`'
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``8``]:``1.125``-``1.1`'
- en: '`Out[8]: 0.02499999999999991`'
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[8]: 0.02499999999999991`'
- en: Mathematical operators
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 数学运算符
- en: 'Calculating with numbers requires the use of mathematical operators like the
    plus or minus sign. Except for the power operator, there shouldn’t be any surprise
    if you come from Excel:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数值计算需要使用加号或减号等数学运算符。除了幂运算符外，如果你来自 Excel 的话，不应该有任何意外：
- en: '`In``[``9``]:``3``+``4``# Sum`'
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``9``]:``3``+``4``# 求和`'
- en: '`Out[9]: 7`'
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[9]: 7`'
- en: '`In``[``10``]:``3``-``4``# Subtraction`'
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``10``]:``3``-``4``# 减法`'
- en: '`Out[10]: -1`'
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[10]: -1`'
- en: '`In``[``11``]:``3``/``4``# Division`'
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``11``]:``3``/``4``# 除法`'
- en: '`Out[11]: 0.75`'
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[11]: 0.75`'
- en: '`In``[``12``]:``3``*``4``# Multiplication`'
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``12``]:``3``*``4``# 乘法`'
- en: '`Out[12]: 12`'
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[12]: 12`'
- en: '`In``[``13``]:``3``**``4``# The power operator (Excel uses 3^4)`'
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``13``]:``3``**``4``# 幂运算符（Excel 使用 3^4）`'
- en: '`Out[13]: 81`'
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[13]: 81`'
- en: '`In``[``14``]:``3``*``(``3``+``4``)``# Use of parentheses`'
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``14``]:``3``*``(``3``+``4``)``# 使用括号`'
- en: '`Out[14]: 21`'
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[14]: 21`'
- en: COMMENTS
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注释
- en: 'In the previous examples, I was describing the operation of the example by
    using comments (e.g., `# Sum`). Comments help other people (and yourself a few
    weeks after writing the code) to understand what’s going on in your program. It
    is good practice to only comment those things that are not already evident from
    reading the code: when in doubt, it’s better to have no comment than an outdated
    comment that contradicts the code. Anything starting with a hash sign is a comment
    in Python and is ignored when you run the code:'
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在前面的例子中，我用注释描述了示例的操作（例如 `# 求和`）。注释有助于其他人（以及你在编写代码后的几周内）理解程序中的运行情况。最好的做法是只注释那些从代码阅读中不明显的事物：如果不确定，最好不要有注释，而不是有一个过时的注释与代码相矛盾。在
    Python 中，任何以井号开头的内容都是注释，运行代码时会被忽略：
- en: '`In``[``15``]:``# This is a sample we''ve seen before.``# Every comment line
    has to start with a #``3``+``4`'
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``15``]:``# 这是我们之前见过的示例。``# 每行注释都必须以 # 开头``3``+``4`'
- en: '`Out[15]: 7`'
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[15]: 7`'
- en: '`In``[``16``]:``3``+``4``# This is an inline comment`'
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``16``]:``3``+``4``# 这是内联注释`'
- en: '`Out[16]: 7`'
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[16]: 7`'
- en: Most editors have a keyboard shortcut to comment/uncomment lines. In Jupyter
    notebooks and VS Code, it is Ctrl+/ (Windows) or Command-/ (macOS). Note that
    Markdown cells in Jupyter notebooks won’t accept comments—if you start a line
    with a `#` there, Markdown will interpret this as a heading.
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 大多数编辑器都有快捷键可以注释或取消注释行。在 Jupyter 笔记本和 VS Code 中，Windows 下是 Ctrl+/，macOS 下是 Command-/。请注意，在
    Jupyter 笔记本的 Markdown 单元格中不接受注释——如果您以 `#` 开头，Markdown 将把它解释为标题。
- en: Having integers and floats covered, let’s move straight to the next section
    about booleans!
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了整数和浮点数，让我们直接转到关于布尔值的下一节！
- en: Booleans
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值
- en: 'The boolean types in Python are `True` or `False`, exactly like in VBA. The
    boolean operators `and`, `or`, and `not`, however, are all lowercase, while VBA
    shows them capitalized. Boolean expressions are similar to how they work in Excel,
    except for equality and inequality operators:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的布尔类型为 `True` 或 `False`，与 VBA 完全相同。然而，布尔运算符 `and`、`or` 和 `not` 全部小写，而
    VBA 则大写显示。布尔表达式类似于 Excel 中的工作方式，但等式和不等式运算符有所不同：
- en: '`In``[``17``]:``3``==``4``# Equality (Excel uses 3 = 4)`'
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``17``]:``3``==``4``# Equality (Excel uses 3 = 4)`'
- en: '`Out[17]: False`'
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[17]: False`'
- en: '`In``[``18``]:``3``!=``4``# Inequality (Excel uses 3 <> 4)`'
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``18``]:``3``!=``4``# Inequality (Excel uses 3 <> 4)`'
- en: '`Out[18]: True`'
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[18]: True`'
- en: '`In``[``19``]:``3``<``4``# Smaller than. Use > for bigger than.`'
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``19``]:``3``<``4``# Smaller than. Use > for bigger than.`'
- en: '`Out[19]: True`'
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[19]: True`'
- en: '`In``[``20``]:``3``<=``4``# Smaller or equal. Use >= for bigger or equal.`'
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``20``]:``3``<=``4``# Smaller or equal. Use >= for bigger or equal.`'
- en: '`Out[20]: True`'
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[20]: True`'
- en: '`In``[``21``]:``# You can chain logical expressions``# In VBA, this would be:
    10 < 12 And 12 < 17``# In Excel formulas, this would be: =AND(10 < 12, 12 < 17)``10``<``12``<``17`'
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``21``]:``# You can chain logical expressions``# In VBA, this would be:
    10 < 12 And 12 < 17``# In Excel formulas, this would be: =AND(10 < 12, 12 < 17)``10``<``12``<``17`'
- en: '`Out[21]: True`'
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[21]: True`'
- en: '`In``[``22``]:``not``True``# "not" operator`'
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``22``]:``not``True``# "not" operator`'
- en: '`Out[22]: False`'
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[22]: False`'
- en: '`In``[``23``]:``False``and``True``# "and" operator`'
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``23``]:``False``and``True``# "and" operator`'
- en: '`Out[23]: False`'
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[23]: False`'
- en: '`In``[``24``]:``False``or``True``# "or" operator`'
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``24``]:``False``or``True``# "or" operator`'
- en: '`Out[24]: True`'
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[24]: True`'
- en: Every Python object evaluates to either `True` or `False`. The majority of objects
    are `True`, but there are some that evaluate to `False` including `None` (see
    sidebar), `False`, `0` or empty data types, e.g., an empty string (I’ll introduce
    strings in the next section).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Python 对象都会评估为 `True` 或 `False`。大多数对象为 `True`，但有一些会评估为 `False`，包括 `None`（见侧边栏），`False`，`0`
    或空数据类型，例如空字符串（我将在下一节介绍字符串）。
- en: NONE
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: NONE
- en: '`None` is a built-in constant and represents “the absence of a value” according
    to the official docs. For example, if a function does not explicitly return anything,
    it returns `None`. It is also a good choice to represent empty cells in Excel
    as we will see in [Part III](index_split_018.html#filepos863198) and [Part IV](index_split_023.html#filepos1235617).'
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`None` 是一个内置常量，代表“没有值”，根据官方文档。例如，如果函数没有显式返回任何内容，它将返回 `None`。它还是在 Excel 中表示空单元格的良好选择，我们将在
    [第 III 部分](index_split_018.html#filepos863198) 和 [第 IV 部分](index_split_023.html#filepos1235617)
    中看到。'
- en: 'To double-check if an object is `True` or `False`, use the `bool` constructor:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 若要双重检查对象是否为 `True` 或 `False`，请使用 `bool` 构造函数：
- en: '`In``[``25``]:``bool``(``2``)`'
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``25``]:``bool``(``2``)`'
- en: '`Out[25]: True`'
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[25]: True`'
- en: '`In``[``26``]:``bool``(``0``)`'
  id: totrans-94
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``26``]:``bool``(``0``)`'
- en: '`Out[26]: False`'
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[26]: False`'
- en: '`In``[``27``]:``bool``(``"some text"``)``# We''ll get to strings in a moment`'
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``27``]:``bool``(``"some text"``)``# We''ll get to strings in a moment`'
- en: '`Out[27]: True`'
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[27]: True`'
- en: '`In``[``28``]:``bool``(``""``)`'
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``28``]:``bool``(``""``)`'
- en: '`Out[28]: False`'
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[28]: False`'
- en: '`In``[``29``]:``bool``(``None``)`'
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``29``]:``bool``(``None``)`'
- en: '`Out[29]: False`'
  id: totrans-101
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[29]: False`'
- en: 'With booleans in our pocket, there is one more basic data type left: textual
    data, better known as strings.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 有了布尔值的支持，我们还剩下一种基本数据类型：文本数据，通常称为字符串。
- en: Strings
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: 'If you have ever worked with strings in VBA that are longer than one line and
    contain variables and literal quotes, you probably wished it was easier. Fortunately,
    this is an area where Python is particularly strong. Strings can be expressed
    by using either double quotes (`"`) or single quotes (`''`). The only condition
    is that you have to start and end the string with the same type of quotes. You
    can use `+` to concatenate strings or `*` to repeat strings. Since I showed you
    the repeating case already when trying out the Python REPL in the previous chapter,
    here is a sample using the plus sign:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经在VBA中使用过超过一行的字符串，并且包含变量和文字引号，你可能希望它更加简单。幸运的是，Python在这方面表现特别出色。字符串可以用双引号(`"`)或单引号(`'`)表示。唯一的条件是你必须用相同类型的引号开始和结束字符串。你可以使用
    `+` 连接字符串或 `*` 重复字符串。既然我已经在前一章节的Python REPL中展示了重复的情况，这里是使用加号的示例：
- en: '`In``[``30``]:``"A double quote string. "``+``''A single quote string.''`'
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``30``]:``"一个双引号字符串。 "``+``''一个单引号字符串。''`'
- en: '`Out[30]: ''A double quote string. A single quote string.''`'
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[30]: ''一个双引号字符串。一个单引号字符串。''`'
- en: 'Depending on what you want to write, using single or double quotes can help
    you to easily print literal quotes without the need to escape them. If you still
    need to escape a character, you precede it with a backslash:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你想要写的内容，使用单引号或双引号可以帮助你轻松地打印文字引号，而不需要转义它们。如果你仍然需要转义字符，可以在其前面加上反斜杠：
- en: '`In``[``31``]:``print``(``"Don''t wait! "``+``''Learn how to "speak" Python.''``)`'
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``31``]:``print``(``"不要等待！ "``+``''学习如何 "说" Python。''``)`'
- en: '`Don''t wait! Learn how to "speak" Python.`'
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Don''t wait! 学会如何 "说" Python。`'
- en: '`In``[``32``]:``print``(``"It''s easy to` `\"``escape``\"` `characters with
    a leading` `\\``."``)`'
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``32``]:``print``(``"It''s easy to` `\"``escape``\"` `characters with
    a leading` `\\``."``)`'
- en: '`It''s easy to "escape" characters with a leading \.`'
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`It''s easy to "escape" characters with a leading \.`'
- en: 'When you are mixing strings with variables, you usually work with f-strings,
    short for formatted string literal. Simply put an `f` in front of your string
    and use variables in between curly braces:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将字符串与变量混合使用时，通常使用格式化字符串字面量，即f字符串。只需在字符串前加上 `f`，并在大括号中使用变量：
- en: '`In``[``33``]:``# Note how Python allows you to conveniently assign multiple``#
    values to multiple variables in a single line``first_adjective``,``second_adjective``=``"free"``,``"open
    source"``f``"Python is {first_adjective} and {second_adjective}."`'
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``33``]:``# 请注意Python如何让你方便地在一行中为多个变量赋值``#``first_adjective``,``second_adjective``=``"free"``,``"开源的"`f``"Python是{first_adjective}和{second_adjective}。"`'
- en: '`Out[33]: ''Python is free and open source.''`'
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[33]: ''Python是免费和开源的。''`'
- en: 'As I mentioned at the beginning of this section, strings are objects like everything
    else, and they offer a few methods (i.e., functions) to perform an action on that
    string. For example, this is how you transform between upper and lowercase letters:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在本节开头提到的，字符串与其他一切一样，它们提供一些方法（即函数）来对字符串执行操作。例如，这是如何在大写和小写字母之间转换的示例：
- en: '`In``[``34``]:``"PYTHON"``.``lower``()`'
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``34``]:``"PYTHON"``.``lower``()`'
- en: '`Out[34]: ''python''`'
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[34]: ''python''`'
- en: '`In``[``35``]:``"python"``.``upper``()`'
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``35``]:``"python"``.``upper``()`'
- en: '`Out[35]: ''PYTHON''`'
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[35]: ''PYTHON''`'
- en: GETTING HELP
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 获取帮助
- en: 'How do you know what attributes certain objects like strings offer and what
    arguments their methods accept? The answer depends a bit on the tool you use:
    with Jupyter notebooks, hit the Tab key after typing the dot that follows an object,
    for example `"python".``<Tab>`. This will make a dropdown appear with all the
    attributes and methods that this object offers. If your cursor is in a method,
    for example within the parentheses of `"python".upper()`, hit Shift+Tab to get
    the description of that function. VS Code will display this information automatically
    as a tooltip. If you run a Python REPL on the Anaconda Prompt, use `dir("python")`
    to get the available attributes and `help("python".upper)` to print the description
    of the `upper` method. Other than that, it’s always a good idea to get back to
    Python’s [online documentation](https://docs.python.org). If you are looking for
    the documentation of third-party packages like pandas, it’s helpful to search
    for them on [PyPI](https://pypi.org), Python’s package index, where you will find
    the links to the respective home pages and documentation.'
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你如何知道某些对象（如字符串）提供哪些属性以及它们的方法接受什么参数？答案有点依赖于你使用的工具：在Jupyter笔记本中，在输入对象后面的点后按Tab键，例如`"python".`
    `<Tab>`。这将显示一个下拉菜单，其中包含此对象提供的所有属性和方法。如果你的光标在方法中，例如在`"python".upper()`的括号内部，按Shift+Tab可以获取该函数的描述。VS
    Code会自动显示此信息作为工具提示。如果在Anaconda Prompt上运行Python REPL，使用`dir("python")`获取可用属性，并使用`help("python".upper)`打印`upper`方法的描述。除此之外，随时查阅Python的[在线文档](https://docs.python.org)总是一个好主意。如果你正在寻找像pandas这样的第三方包的文档，建议在[PyPI](https://pypi.org)上搜索它们，Python的包索引，你将找到相应主页和文档的链接。
- en: 'When working with strings, a regular task is to select parts of a string: for
    example, you may want to get the `USD` part out of the `EURUSD` exchange rate
    notation. The next section shows you Python’s powerful indexing and slicing mechanism
    that allows you to do exactly this.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理字符串时，常见的任务是选择字符串的部分：例如，你可能想从`EURUSD`的汇率符号中提取`USD`部分。接下来的部分将展示Python强大的索引和切片机制，使你能够精确做到这一点。
- en: Indexing and Slicing
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 索引和切片
- en: Indexing and slicing give you access to specific elements of a sequence. Since
    strings are sequences of characters, we can use them to learn how it works. In
    the next section, we will meet additional sequences like lists and tuples that
    support indexing and slicing too.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 索引和切片让你可以访问序列的特定元素。由于字符串是字符序列，我们可以利用它们来学习它是如何工作的。在接下来的部分中，我们将遇到额外的序列，如列表和元组，它们也支持索引和切片。
- en: Indexing
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 索引
- en: '[Figure 3-1](#filepos228355) introduces the concept of indexing. Python is
    zero-based, which means that the first element in a sequence is referred to by
    index `0`. Negative indices from `-1` allow you to refer to elements from the
    end of the sequence.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-1](#filepos228355)介绍了索引的概念。Python是从零开始索引的，这意味着序列中的第一个元素由索引`0`引用。负索引从`-1`允许你从序列的末尾引用元素。'
- en: '![](images/00023.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00023.jpg)'
- en: Figure 3-1\. Indexing from the beginning and end of a sequence
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-1\. 从序列的开始和结尾进行索引
- en: COMMON ERROR TRAPS FOR VBA DEVELOPERS
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: VBA开发人员的常见错误陷阱
- en: If you are coming from VBA, indexing is a common error trap. VBA uses one-based
    indexing for most collections like sheets (`Sheets(1)`) but uses zero-based indexing
    for arrays (`MyArray(0)`), although that default can be changed. Another difference
    is that VBA uses parentheses for indexing while Python uses square brackets.
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你来自VBA，索引是一个常见的错误陷阱。VBA对于大多数集合（如`Sheets(1)`）使用基于一的索引，但对于数组（`MyArray(0)`）使用基于零的索引，尽管该默认值可以更改。另一个不同之处在于，VBA使用括号进行索引，而Python使用方括号。
- en: 'The syntax for indexing is as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 索引的语法如下：
- en: '`sequence``[``index``]`'
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`sequence``[``index``]`'
- en: 'Accordingly, you access specific elements from a string like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以像这样访问字符串的特定元素：
- en: '`In``[``36``]:``language``=``"PYTHON"`'
  id: totrans-134
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``36``]:``language``=``"PYTHON"`'
- en: '`In``[``37``]:``language``[``0``]`'
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``37``]:``language``[``0``]`'
- en: '`Out[37]: ''P''`'
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[37]: ''P''`'
- en: '`In``[``38``]:``language``[``1``]`'
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``38``]:``language``[``1``]`'
- en: '`Out[38]: ''Y''`'
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[38]: ''Y''`'
- en: '`In``[``39``]:``language``[``-``1``]`'
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``39``]:``language``[``-``1``]`'
- en: '`Out[39]: ''N''`'
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[39]: ''N''`'
- en: '`In``[``40``]:``language``[``-``2``]`'
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``40``]:``language``[``-``2``]`'
- en: '`Out[40]: ''O''`'
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[40]: ''O''`'
- en: You will often want to extract more than just a single character—this is where
    slicing comes in.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你经常需要提取不止一个字符——这就是切片发挥作用的地方。
- en: Slicing
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 切片
- en: 'If you want to get more than one element from a sequence, you use the slicing
    syntax, which works as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想从序列中获取多个元素，你可以使用切片语法，其工作方式如下：
- en: '`sequence``[``start``:``stop``:``step``]`'
  id: totrans-146
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`sequence``[``start``:``stop``:``step``]`'
- en: 'Python uses half-open intervals: the `start` index is included while the `stop`
    index is not. If you leave the `start` or `stop` arguments away, it will include
    everything from the beginning or to the end of the sequence, respectively. `step`
    determines the direction and the step size: for example, `2` will return every
    second element from left to right and `-3` will return every third element from
    right to left. The default step size is one:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Python使用半开区间：`start`索引包含在内，`stop`索引不包含在内。如果省略`start`或`stop`参数，它将分别包括从序列开始到结尾的所有内容。`step`确定方向和步长：例如，`2`将从左到右返回每第二个元素，`-3`将从右到左返回每第三个元素。默认步长为一：
- en: '`In``[``41``]:``language``[:``3``]``# Same as language[0:3]`'
  id: totrans-148
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``41``]:``language``[:``3``]``# 同`language[0:3]`'
- en: '`Out[41]: ''PYT''`'
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[41]: ''PYT''`'
- en: '`In``[``42``]:``language``[``1``:``3``]`'
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``42``]:``language``[``1``:``3``]`'
- en: '`Out[42]: ''YT''`'
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[42]: ''YT''`'
- en: '`In``[``43``]:``language``[``-``3``:]``# Same as language[-3:6]`'
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``43``]:``language``[``-``3``:]``# 同`language[-3:6]`'
- en: '`Out[43]: ''HON''`'
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[43]: ''HON''`'
- en: '`In``[``44``]:``language``[``-``3``:``-``1``]`'
  id: totrans-154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``44``]:``language``[``-``3``:``-``1``]`'
- en: '`Out[44]: ''HO''`'
  id: totrans-155
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[44]: ''HO''`'
- en: '`In``[``45``]:``language``[::``2``]``# Every second element`'
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``45``]:``language``[::``2``]``# 每第二个元素`'
- en: '`Out[45]: ''PTO''`'
  id: totrans-157
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[45]: ''PTO''`'
- en: '`In``[``46``]:``language``[``-``1``:``-``4``:``-``1``]``# Negative step goes
    from right to left`'
  id: totrans-158
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``46``]:``language``[``-``1``:``-``4``:``-``1``]``# 负步长从右向左移动`'
- en: '`Out[46]: ''NOH''`'
  id: totrans-159
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[46]: ''NOH''`'
- en: 'So far we’ve looked at just a single index or slice operation, but Python also
    allows you to chain multiple index and slice operations together. For example,
    if you want to get the second character out of the last three characters, you
    could do it like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只看过单个索引或切片操作，但Python还允许您将多个索引和切片操作链接在一起。例如，如果要从最后三个字符中获取第二个字符，可以像这样做：
- en: '`In``[``47``]:``language``[``-``3``:][``1``]`'
  id: totrans-161
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``47``]:``language``[``-``3``:][``1``]`'
- en: '`Out[47]: ''O''`'
  id: totrans-162
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[47]: ''O''`'
- en: This is the same as `language[-2]` so in this case, it wouldn’t make much sense
    to use chaining, but it will make more sense when we use indexing and slicing
    with lists, one of the data structures that I am going to introduce in the next
    section.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`language[-2]`相同，因此在这种情况下，使用链接并没有太多意义，但在下一节将介绍的列表中使用索引和切片将更有意义。
- en: Data Structures
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构
- en: Python offers powerful data structures that make working with a collection of
    objects really easy. In this section, I am going to introduce lists, dictionaries,
    tuples, and sets. While each of these data structures has slightly different characteristics,
    they are all able to hold multiple objects. In VBA, you may have used collections
    or arrays to hold multiple values. VBA even offers a data structure called dictionary
    that works conceptually the same as Python’s dictionary. It is, however, only
    available on the Windows version of Excel out of the box. Let’s get started with
    lists, the data structure that you will probably use most.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了强大的数据结构，使得处理对象集合非常容易。在本节中，我将介绍列表、字典、元组和集合。尽管这些数据结构各有些许不同的特性，但它们都能够容纳多个对象。在VBA中，您可能已经使用过集合或数组来保存多个值。VBA甚至提供了一个名为字典的数据结构，其概念上与Python的字典相同。但是，它仅在Excel的Windows版本中默认可用。让我们从列表开始，这是您可能会经常使用的数据结构。
- en: Lists
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 列表
- en: 'Lists are capable of holding multiple objects of different data types. They
    are so versatile that you will use them all the time. You create a list as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 列表能够容纳多个不同数据类型的对象。它们非常灵活，您会经常使用它们。您可以按以下方式创建列表：
- en: '`[``element1``,``element2``,``...``]`'
  id: totrans-168
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`[``element1``,``element2``,``...``]`'
- en: 'Here are two lists, one with the names of Excel files and the other one with
    a few numbers:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个列表，一个是Excel文件名，另一个是一些数字：
- en: '`In``[``48``]:``file_names``=``[``"one.xlsx"``,``"two.xlsx"``,``"three.xlsx"``]``numbers``=``[``1``,``2``,``3``]`'
  id: totrans-170
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``48``]:``file_names``=``[``"one.xlsx"``,``"two.xlsx"``,``"three.xlsx"``]``numbers``=``[``1``,``2``,``3``]`'
- en: 'Like strings, lists can easily be concatenated with the plus sign. This also
    shows you that lists can hold different types of objects:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 像字符串一样，列表可以使用加号轻松连接。这也表明列表可以容纳不同类型的对象：
- en: '`In``[``49``]:``file_names``+``numbers`'
  id: totrans-172
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``49``]:``file_names``+``numbers`'
- en: '`Out[49]: [''one.xlsx'', ''two.xlsx'', ''three.xlsx'', 1, 2, 3]`'
  id: totrans-173
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[49]: [''one.xlsx'', ''two.xlsx'', ''three.xlsx'', 1, 2, 3]`'
- en: 'As lists are objects like everything else, lists can also have other lists
    as their elements. I will refer to them as nested lists:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 由于列表和其他所有东西一样都是对象，列表也可以将其他列表作为它们的元素。我将它们称为嵌套列表：
- en: '`In``[``50``]:``nested_list``=``[[``1``,``2``,``3``],``[``4``,``5``,``6``],``[``7``,``8``,``9``]]`'
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``50``]:``nested_list``=``[[``1``,``2``,``3``],``[``4``,``5``,``6``],``[``7``,``8``,``9``]]`'
- en: 'If you rearrange this to span over multiple lines, you can easily recognize
    that this is a very nice representation of a matrix, or a range of spreadsheet
    cells. Note that the square brackets implicitly allow you to break the lines (see
    sidebar). Via indexing and slicing, you get the elements you want:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你重新排列它跨越多行，你可以轻松地识别出这是一个矩阵的非常好的表示，或者一个范围的电子表格单元格。请注意，方括号隐含允许你断开行（参见侧边栏）。通过索引和切片，你可以得到想要的元素：
- en: '`In``[``51``]:``cells``=``[[``1``,``2``,``3``],``[``4``,``5``,``6``],``[``7``,``8``,``9``]]`'
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``51``]:``cells``=``[[``1``,``2``,``3``],``[``4``,``5``,``6``],``[``7``,``8``,``9``]]`'
- en: '`In``[``52``]:``cells``[``1``]``# Second row`'
  id: totrans-178
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``52``]:``cells``[``1``]``# 第二行`'
- en: '`Out[52]: [4, 5, 6]`'
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[52]: [4, 5, 6]`'
- en: '`In``[``53``]:``cells``[``1``][``1``:]``# Second row, second and third column`'
  id: totrans-180
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``53``]:``cells``[``1``][``1``:]``# 第二行，第二和第三列`'
- en: '`Out[53]: [5, 6]`'
  id: totrans-181
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[53]: [5, 6]`'
- en: LINE CONTINUATION
  id: totrans-182
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: LINE CONTINUATION
- en: 'Sometimes, a line of code can get so long that you will need to break it up
    into two or more lines to keep your code readable. Technically, you can either
    use parentheses or a backslash to break up the line:'
  id: totrans-183
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 有时，一行代码可能会变得如此之长，以至于你需要将其分成两行或更多行以保持代码可读性。从技术上讲，你可以使用括号或反斜杠来断开行：
- en: '`In``[``54``]:``a``=``(``1``+``2``+``3``)`'
  id: totrans-184
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``54``]:``a``=``(``1``+``2``+``3``)`'
- en: '`In``[``55``]:``a``=``1``+``2` `\` `+``3`'
  id: totrans-185
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``55``]:``a``=``1``+``2` `\` `+``3`'
- en: 'Python’s style guide, however, prefers that you use implicit line breaks if
    possible: whenever you are using an expression that contains parentheses, square
    brackets, or curly braces, use them to introduce a line break without having to
    introduce an additional character. I will say more about Python’s style guide
    toward the end of this chapter.'
  id: totrans-186
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 然而，Python 的风格指南更喜欢你尽可能使用隐式换行：每当你使用包含括号、方括号或大括号的表达式时，使用它们来引入换行，而无需引入额外的字符。我将在本章末尾详细介绍
    Python 的风格指南。
- en: 'You can change elements in lists:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以更改列表中的元素：
- en: '`In``[``56``]:``users``=``[``"Linda"``,``"Brian"``]`'
  id: totrans-188
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``56``]:``users``=``[``"Linda"``,``"Brian"``]`'
- en: '`In``[``57``]:``users``.``append``(``"Jennifer"``)``# Most commonly you add
    to the end``users`'
  id: totrans-189
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``57``]:``users``.``append``(``"Jennifer"``)``# 通常在末尾添加``users`'
- en: '`Out[57]: [''Linda'', ''Brian'', ''Jennifer'']`'
  id: totrans-190
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[57]: [''Linda'', ''Brian'', ''Jennifer'']`'
- en: '`In``[``58``]:``users``.``insert``(``0``,``"Kim"``)``# Insert "Kim" at index
    0``users`'
  id: totrans-191
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``58``]:``users``.``insert``(``0``,``"Kim"``)``# 在索引 0 处插入 "Kim"``users`'
- en: '`Out[58]: [''Kim'', ''Linda'', ''Brian'', ''Jennifer'']`'
  id: totrans-192
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[58]: [''Kim'', ''Linda'', ''Brian'', ''Jennifer'']`'
- en: 'To delete an element, use either `pop` or `del`. While `pop` is a method, `del`
    is implemented as a statement in Python:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除一个元素，可以使用 `pop` 或 `del`。虽然 `pop` 是一个方法，但 `del` 在 Python 中实现为语句：
- en: '`In``[``59``]:``users``.``pop``()``# Removes and returns the last element by
    default`'
  id: totrans-194
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``59``]:``users``.``pop``()``# 默认移除并返回最后一个元素`'
- en: '`Out[59]: ''Jennifer''`'
  id: totrans-195
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[59]: ''Jennifer''`'
- en: '`In``[``60``]:``users`'
  id: totrans-196
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``60``]:``users`'
- en: '`Out[60]: [''Kim'', ''Linda'', ''Brian'']`'
  id: totrans-197
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[60]: [''Kim'', ''Linda'', ''Brian'']`'
- en: '`In``[``61``]:``del``users``[``0``]``# del removes an element at the given
    index`'
  id: totrans-198
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``61``]:``del``users``[``0``]``# del 删除指定索引处的元素`'
- en: 'Some other useful things you can do with lists are:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 其他一些你可以使用列表做的有用的事情是：
- en: '`In``[``62``]:``len``(``users``)``# Length`'
  id: totrans-200
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``62``]:``len``(``users``)``# 长度`'
- en: '`Out[62]: 2`'
  id: totrans-201
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[62]: 2`'
- en: '`In``[``63``]:``"Linda"``in``users``# Check if users contains "Linda"`'
  id: totrans-202
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``63``]:``"Linda"``in``users``# 检查 users 是否包含 "Linda"`'
- en: '`Out[63]: True`'
  id: totrans-203
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[63]: True`'
- en: '`In``[``64``]:``print``(``sorted``(``users``))``# Returns a new sorted list``print``(``users``)``#
    The original list is unchanged`'
  id: totrans-204
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``64``]:``print``(``sorted``(``users``))``# 返回一个新的排序列表``print``(``users``)``#
    原始列表不变`'
- en: '`[''Brian'', ''Linda''] [''Linda'', ''Brian'']`'
  id: totrans-205
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`[''Brian'', ''Linda''] [''Linda'', ''Brian'']`'
- en: '`In``[``65``]:``users``.``sort``()``# Sorts the original list``users`'
  id: totrans-206
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``65``]:``users``.``sort``()``# 对原始列表进行排序``users`'
- en: '`Out[65]: [''Brian'', ''Linda'']`'
  id: totrans-207
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[65]: [''Brian'', ''Linda'']`'
- en: 'Note that you can use `len` and `in` with strings as well:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你也可以在字符串中使用 `len` 和 `in`：
- en: '`In``[``66``]:``len``(``"Python"``)`'
  id: totrans-209
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``66``]:``len``(``"Python"``)`'
- en: '`Out[66]: 6`'
  id: totrans-210
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[66]: 6`'
- en: '`In``[``67``]:``"free"``in``"Python is free and open source."`'
  id: totrans-211
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``67``]:``"free"``in``"Python is free and open source."`'
- en: '`Out[67]: True`'
  id: totrans-212
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[67]: True`'
- en: To get access to elements in a list, you refer to them by their position or
    index—that’s not always practical. Dictionaries, the topic of the next section,
    allow you to get access to elements via a key (often a name).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问列表中的元素，你可以按它们的位置或索引引用它们——这并不总是实际可行的。下一节将讨论的字典允许你通过键（通常是名称）访问元素。
- en: Dictionaries
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 字典
- en: 'Dictionaries map keys to values. You will come across key/value combinations
    all the time. The easiest way to create a dictionary is as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 字典将键映射到值。您将经常遇到键/值组合。创建字典的最简单方法如下：
- en: '`{``key1``:``value1``,``key2``:``value2``,``...``}`'
  id: totrans-216
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`{``key1``:``value1``,``key2``:``value2``,``...``}`'
- en: 'While lists allow you to access elements by index, i.e., position, dictionaries
    allow you to access elements by key. As with indices, keys are accessed via square
    brackets. The following code samples will use a currency pair (key) that maps
    to the exchange rate (value):'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然列表允许您按索引，即位置，访问元素，但字典允许您按键访问元素。与索引一样，键是通过方括号访问的。以下代码示例将使用货币对（键）映射到汇率（值）：
- en: '`In``[``68``]:``exchange_rates``=``{``"EURUSD"``:``1.1152``,``"GBPUSD"``:``1.2454``,``"AUDUSD"``:``0.6161``}`'
  id: totrans-218
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``68``]:``exchange_rates``=``{``"EURUSD"``:``1.1152``,``"GBPUSD"``:``1.2454``,``"AUDUSD"``:``0.6161``}`'
- en: '`In``[``69``]:``exchange_rates``[``"EURUSD"``]``# Access the EURUSD exchange
    rate`'
  id: totrans-219
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``69``]:``exchange_rates``[``"EURUSD"``]``# 访问EURUSD汇率`'
- en: '`Out[69]: 1.1152`'
  id: totrans-220
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[69]: 1.1152`'
- en: 'The following samples show you how to change existing values and add new key/value
    pairs:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例向您展示如何更改现有值并添加新的键值对：
- en: '`In``[``70``]:``exchange_rates``[``"EURUSD"``]``=``1.2``# Change an existing
    value``exchange_rates`'
  id: totrans-222
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``70``]:``exchange_rates``[``"EURUSD"``]``=``1.2``# 更改现有值``exchange_rates`'
- en: '`Out[70]: {''EURUSD'': 1.2, ''GBPUSD'': 1.2454, ''AUDUSD'': 0.6161}`'
  id: totrans-223
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[70]: {''EURUSD'': 1.2, ''GBPUSD'': 1.2454, ''AUDUSD'': 0.6161}`'
- en: '`In``[``71``]:``exchange_rates``[``"CADUSD"``]``=``0.714``# Add a new key/value
    pair``exchange_rates`'
  id: totrans-224
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``71``]:``exchange_rates``[``"CADUSD"``]``=``0.714``# 添加一个新的键值对``exchange_rates`'
- en: '`Out[71]: {''EURUSD'': 1.2, ''GBPUSD'': 1.2454, ''AUDUSD'': 0.6161, ''CADUSD'':
    0.714}`'
  id: totrans-225
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[71]: {''EURUSD'': 1.2, ''GBPUSD'': 1.2454, ''AUDUSD'': 0.6161, ''CADUSD'':
    0.714}`'
- en: 'The easiest way to merge two or more dictionaries is by unpacking them into
    a new one. You unpack a dictionary by using two leading asterisks. If the second
    dictionary contains keys from the first one, the values from the first will be
    overridden. You can see this happening by looking at the `GBPUSD` exchange rate:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 合并两个或更多字典的最简单方法是将它们解压到一个新字典中。您通过使用两个前导星号来解压字典。如果第二个字典包含来自第一个字典的键，则将从第一个字典中覆盖值。您可以通过查看`GBPUSD`汇率来看到这种情况发生：
- en: '`In``[``72``]:``{``**``exchange_rates``,``**``{``"SGDUSD"``:``0.7004``,``"GBPUSD"``:``1.2222``}}`'
  id: totrans-227
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``72``]:``{``**``exchange_rates``,``**``{``"SGDUSD"``:``0.7004``,``"GBPUSD"``:``1.2222``}}`'
- en: '`Out[72]: {''EURUSD'': 1.2,           ''GBPUSD'': 1.2222,           ''AUDUSD'':
    0.6161,           ''CADUSD'': 0.714,           ''SGDUSD'': 0.7004}`'
  id: totrans-228
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[72]: {''EURUSD'': 1.2,           ''GBPUSD'': 1.2222,           ''AUDUSD'':
    0.6161,           ''CADUSD'': 0.714,           ''SGDUSD'': 0.7004}`'
- en: 'Python 3.9 introduced the pipe character as a dedicated merge operator for
    dictionaries, which allows you to simplify the previous expression to this:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.9引入了管道字符作为字典的专用合并操作符，这使得您可以简化先前的表达式为：
- en: '`exchange_rates``|``{``"SGDUSD"``:``0.7004``,``"GBPUSD"``:``1.2222``}`'
  id: totrans-230
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`exchange_rates``|``{``"SGDUSD"``:``0.7004``,``"GBPUSD"``:``1.2222``}`'
- en: 'Many objects can serve as keys; the following is an example with integers:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 许多对象都可以作为键；以下是一个带整数的示例：
- en: '`In``[``73``]:``currencies``=``{``1``:``"EUR"``,``2``:``"USD"``,``3``:``"AUD"``}`'
  id: totrans-232
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``73``]:``currencies``=``{``1``:``"EUR"``,``2``:``"USD"``,``3``:``"AUD"``}`'
- en: '`In``[``74``]:``currencies``[``1``]`'
  id: totrans-233
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``74``]:``currencies``[``1``]`'
- en: '`Out[74]: ''EUR''`'
  id: totrans-234
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[74]: ''EUR''`'
- en: 'By using the `get` method, dictionaries allow you to use a default value in
    case the key doesn’t exist:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`get`方法，字典允许您在键不存在的情况下使用默认值：
- en: '`In``[``75``]:``# currencies[100] would raise an exception. Instead of 100,``#
    you could use any other non-existing key, too.``currencies``.``get``(``100``,``"N/A"``)`'
  id: totrans-236
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``75``]:``# currencies[100]会引发异常。您可以使用任何其他不存在的键。``# 代替100，也是一样的。``currencies``.``get``(``100``,``"N/A"``)`'
- en: '`Out[75]: ''N/A''`'
  id: totrans-237
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[75]: ''N/A''`'
- en: 'Dictionaries can often be used when you would use a `Case` statement in VBA.
    The previous example could be written like this in VBA:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在VBA中，字典通常可以用作`Case`语句的替代。前面的示例可以在VBA中这样写：
- en: '`Select``Case``x``Case``1``Debug``.``Print``"EUR"``Case``2``Debug``.``Print``"USD"``Case``3``Debug``.``Print``"AUD"``Case``Else``Debug``.``Print``"N/A"``End``Select`'
  id: totrans-239
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Select``Case``x``Case``1``Debug``.``Print``"EUR"``Case``2``Debug``.``Print``"USD"``Case``3``Debug``.``Print``"AUD"``Case``Else``Debug``.``Print``"N/A"``End``Select`'
- en: 'Now that you know how to work with dictionaries, let’s move on to the next
    data structure: tuples. They are similar to lists with one big difference, as
    we will see in the next section.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何使用字典了，让我们继续下一个数据结构：元组。它们与列表类似，但有一个重大区别，我们将在下一节中看到。
- en: Tuples
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 元组
- en: 'Tuples are similar to lists with the difference that they are immutable: once
    created, their elements can’t be changed. While you can often use tuples and lists
    interchangeably, tuples are the obvious choice for a collection that never changes
    throughout the program. Tuples are created by separating values with commas:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 元组与列表类似，区别在于它们是不可变的：一旦创建，它们的元素就不能更改。虽然您通常可以互换使用元组和列表，但元组是在整个程序中从不更改的集合的明显选择。通过用逗号分隔值来创建元组：
- en: '`mytuple``=``element1``,``element2``,``...`'
  id: totrans-243
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`mytuple``=``element1``,``element2``,``...`'
- en: 'Using parentheses often makes it easier to read:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 使用括号通常使其更易读：
- en: '`In``[``76``]:``currencies``=``(``"EUR"``,``"GBP"``,``"AUD"``)`'
  id: totrans-245
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``76``]:``currencies``=``(``"EUR"``,``"GBP"``,``"AUD"``)`'
- en: 'Tuples allow you to access elements the same way as lists, but they won’t allow
    you to change elements. Instead, concatenating tuples will create a new tuple
    behind the scenes, then bind your variable to this new tuple:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 元组允许您以与列表相同的方式访问元素，但不允许更改元素。相反，连接元组将在幕后创建一个新元组，然后将您的变量绑定到此新元组：
- en: '`In``[``77``]:``currencies``[``0``]``# Accessing the first element`'
  id: totrans-247
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``77``]:``currencies``[``0``]``# 访问第一个元素`'
- en: '`Out[77]: ''EUR''`'
  id: totrans-248
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[77]: ''EUR''`'
- en: '`In``[``78``]:``# Concatenating tuples will return a new tuple.``currencies``+``(``"SGD"``,)`'
  id: totrans-249
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``78``]:``# 连接元组将返回一个新的元组。``currencies``+``(``"SGD"``,)`'
- en: '`Out[78]: (''EUR'', ''GBP'', ''AUD'', ''SGD'')`'
  id: totrans-250
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[78]: (''EUR'', ''GBP'', ''AUD'', ''SGD'')`'
- en: 'I explain the difference between mutable vs. immutable objects in detail in
    [Appendix C](index_split_031.html#filepos1832059), but for now, let’s have a look
    at the last data structure of this section: sets.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[附录 C](index_split_031.html#filepos1832059)中详细解释了可变对象与不可变对象的区别，但现在让我们来看看本节的最后一个数据结构：集合。
- en: Sets
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 集合
- en: 'Sets are collections that have no duplicate elements. While you can use them
    for set theory operations, in practice they often help you to get the unique values
    of a list or a tuple. You create sets by using curly braces:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是没有重复元素的集合。虽然您可以用它们进行集合理论运算，在实践中它们经常帮助您获取列表或元组的唯一值。通过使用大括号来创建集合：
- en: '`{``element1``,``element2``,``...``}`'
  id: totrans-254
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`{``element1``,``element2``,``...``}`'
- en: 'To get the unique objects in a list or a tuple, use the `set` constructor like
    so:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取列表或元组中的唯一对象，请使用`set`构造函数，如下所示：
- en: '`In``[``79``]:``set``([``"USD"``,``"USD"``,``"SGD"``,``"EUR"``,``"USD"``,``"EUR"``])`'
  id: totrans-256
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``79``]:``set``([``"USD"``,``"USD"``,``"SGD"``,``"EUR"``,``"USD"``,``"EUR"``])`'
- en: '`Out[79]: {''EUR'', ''SGD'', ''USD''}`'
  id: totrans-257
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[79]: {''EUR'', ''SGD'', ''USD''}`'
- en: 'Other than that, you can apply set theory operations like intersection and
    union:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，您还可以应用集合理论操作，如交集和并集：
- en: '`In``[``80``]:``portfolio1``=``{``"USD"``,``"EUR"``,``"SGD"``,``"CHF"``}``portfolio2``=``{``"EUR"``,``"SGD"``,``"CAD"``}`'
  id: totrans-259
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``80``]:``portfolio1``=``{``"USD"``,``"EUR"``,``"SGD"``,``"CHF"``}``portfolio2``=``{``"EUR"``,``"SGD"``,``"CAD"``}`'
- en: '`In``[``81``]:``# Same as portfolio2.union(portfolio1)``portfolio1``.``union``(``portfolio2``)`'
  id: totrans-260
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``81``]:``# 等同于 portfolio2.union(portfolio1)``portfolio1``.``union``(``portfolio2``)`'
- en: '`Out[81]: {''CAD'', ''CHF'', ''EUR'', ''SGD'', ''USD''}`'
  id: totrans-261
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[81]: {''CAD'', ''CHF'', ''EUR'', ''SGD'', ''USD''}`'
- en: '`In``[``82``]:``# Same as portfolio2.intersection(portfolio1)``portfolio1``.``intersection``(``portfolio2``)`'
  id: totrans-262
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``82``]:``# 等同于 portfolio2.intersection(portfolio1)``portfolio1``.``intersection``(``portfolio2``)`'
- en: '`Out[82]: {''EUR'', ''SGD''}`'
  id: totrans-263
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[82]: {''EUR'', ''SGD''}`'
- en: 'For a full overview of set operations, see the [official docs](https://oreil.ly/ju4ed).
    Before moving on, let’s quickly revise the four data structures we just met in
    [Table 3-1](#filepos299969). It shows a sample for each data structure in the
    notation I used in the previous paragraphs, the so-called literals. Additionally,
    I am also listing their constructors that offer an alternative to using the literals
    and are often used to convert from one data structure to another. For example,
    to convert a tuple to a list, do:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取有关集合操作的完整概述，请参阅[官方文档](https://oreil.ly/ju4ed)。在继续之前，让我们快速复习我们刚刚在[表 3-1](#filepos299969)中见过的四种数据结构。它展示了每种数据结构的一个示例，采用了我在前面段落中使用的符号，即所谓的字面量。此外，我还列出了它们的构造函数，这些构造函数提供了一种将一种数据结构转换为另一种的替代方法。例如，要将元组转换为列表，请执行以下操作：
- en: '`In``[``83``]:``currencies``=``"USD"``,``"EUR"``,``"CHF"``currencies`'
  id: totrans-265
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``83``]:``currencies``=``"USD"``,``"EUR"``,``"CHF"``currencies`'
- en: '`Out[83]: (''USD'', ''EUR'', ''CHF'')`'
  id: totrans-266
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[83]: (''USD'', ''EUR'', ''CHF'')`'
- en: '`In``[``84``]:``list``(``currencies``)`'
  id: totrans-267
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``84``]:``list``(``currencies``)`'
- en: '`Out[84]: [''USD'', ''EUR'', ''CHF'']`'
  id: totrans-268
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[84]: [''USD'', ''EUR'', ''CHF'']`'
- en: Table 3-1\. Data structures
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 3-1\. 数据结构
- en: '|  Data Structure  |  Literals  |  Constructor  |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '|  数据结构  |  字面量  |  构造函数  |'
- en: '|  List  |   `[1, 2, 3]` |   `list((1, 2, 3))` |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '|  列表  |   `[1, 2, 3]` |   `list((1, 2, 3))` |'
- en: '|  Dictionary  |   `{"a": 1, "b": 2}` |   `dict(a=1, b=2)` |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '|  字典  |   `{"a": 1, "b": 2}` |   `dict(a=1, b=2)` |'
- en: '|  Tuple  |   `(1, 2, 3)` |   `tuple([1, 2, 3])` |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '|  Tuple  |   `(1, 2, 3)` |   `tuple([1, 2, 3])` |'
- en: '|  Set  |   `{1, 2, 3}` |   `set((1, 2, 3))` |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '|  Set  |   `{1, 2, 3}` |   `set((1, 2, 3))` |'
- en: At this point, you know all important data types including basic ones like floats
    and strings, and data structures like lists and dictionaries. In the next section,
    we move on to control flow.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经了解了所有重要的数据类型，包括基本类型如浮点数和字符串，以及数据结构如列表和字典。在下一节中，我们将继续学习控制流。
- en: Control Flow
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 控制流
- en: 'This section presents the `if` statement as well as the `for` and `while` loops.
    The `if` statement allows you to execute certain lines of code only if a condition
    is met, and the `for` and `while` loops will execute a block of code repeatedly.
    At the end of the section, I will also introduce list comprehensions, which are
    a way to construct lists that can serve as an alternative to `for` loops. I will
    start this section with the definition of code blocks, for which I also need to
    introduce one of Python’s most noteworthy particularities: significant white space.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将介绍`if`语句以及`for`和`while`循环。`if`语句允许你仅在满足条件时执行某些代码行，而`for`和`while`循环将重复执行一段代码。在本节末尾，我还将介绍列表推导式，这是构建列表的一种方式，可以作为`for`循环的替代方式。我将从代码块的定义开始本节，这也是需要介绍Python最显著的特殊之一：显著的空白。
- en: Code Blocks and the pass Statement
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 代码块和`pass`语句
- en: 'A code block defines a section in your source code that is used for something
    special. For example, you use a code block to define the lines over which your
    program is looping or it makes up the definition of a function. In Python, you
    define code blocks by indenting them, not by using keywords like in VBA or curly
    braces like in most other languages. This is referred to as significant white
    space. The Python community has settled on four spaces as indentation, but you
    usually type them in by hitting the Tab key: both Jupyter notebooks and VS Code
    will automatically convert your Tab key into four spaces. Let me show you how
    code blocks are formally defined by using the `if` statement:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 代码块定义了你源代码中用于特殊用途的部分。例如，你可以使用代码块来定义程序循环的行或者它构成函数的定义。在Python中，你通过缩进而不是使用关键字（如VBA中）或者花括号（大多数其他语言中）来定义代码块。这被称为显著的空白。Python社区已经约定使用四个空格作为缩进，但你通常会通过按Tab键来输入它们：Jupyter笔记本和VS
    Code会自动将你的Tab键转换为四个空格。让我演示一下如何使用`if`语句来正式定义代码块：
- en: '`if``condition``:``pass``# Do nothing`'
  id: totrans-280
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`if``condition``:``pass``# 什么都不做`'
- en: 'The line preceding the code block always terminates with a colon. Since the
    end of the code block is reached when you no longer indent the line, you need
    to use the `pass` statement if you want to create a dummy code block that does
    nothing. In VBA, this would correspond to the following:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 代码块前面的行总是以冒号结束。当你不再缩进行时，代码块结束。如果你想创建一个什么都不做的虚拟代码块，你需要使用`pass`语句。在VBA中，这对应以下内容：
- en: '`If``condition``Then``'' Do nothing``End``If`'
  id: totrans-282
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`If``condition``Then``'' 什么都不做``End``If`'
- en: Now that you know how to define code blocks, let’s start using them in the next
    section, where I will properly introduce the `if` statement.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何定义代码块了，让我们在下一节开始使用它们，我将在那里适当地介绍`if`语句。
- en: The if Statement and Conditional Expressions
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句和条件表达式'
- en: 'To introduce the `if` statement, let me reproduce the example from [“Readability
    and Maintainability”](index_split_007.html#filepos64265) in [Chapter 1](index_split_007.html#filepos32075),
    but this time in Python:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 要介绍`if`语句，让我来重现[“可读性和可维护性”](index_split_007.html#filepos64265)中的示例，在[第1章](index_split_007.html#filepos32075)中，但这次是用Python：
- en: '`In``[``85``]:``i``=``20``if``i``<``5``:``print``(``"i is smaller than 5"``)``elif``i``<=``10``:``print``(``"i
    is between 5 and 10"``)``else``:``print``(``"i is bigger than 10"``)`'
  id: totrans-286
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``85``]:``i``=``20``if``i``<``5``:``print``(``"i is smaller than 5"``)``elif``i``<=``10``:``print``(``"i
    is between 5 and 10"``)``else``:``print``(``"i is bigger than 10"``)`'
- en: '`i is bigger than 10`'
  id: totrans-287
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`i is bigger than 10`'
- en: 'If you would do the same as we did in [Chapter 1](index_split_007.html#filepos32075),
    i.e., indent the `elif` and `else` statements, you would get a `SyntaxError`.
    Python won’t let you indent your code differently from the logic. Compared to
    VBA, the keywords are lowercase and instead of `ElseIf` in VBA, Python uses `elif`.
    `if` statements are an easy way to tell if a programmer is new to Python or if
    they have already adopted a Pythonic style: in Python, a simple `if` statement
    doesn’t require any parentheses around it and to test if a value is `True`, you
    don’t need to do that explicitly. Here is what I mean by that:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想做和我们在[第一章](index_split_007.html#filepos32075)里做的一样，即缩进`elif`和`else`语句，你会得到`SyntaxError`。Python不允许你的代码缩进与逻辑不同。与VBA不同的是，Python的关键词是小写的，而不是VBA中的`ElseIf`，Python使用`elif`。`if`语句是判断一个程序员是否新手或者已经采用Python风格的简单方法：在Python中，一个简单的`if`语句不需要括号，而测试一个值是否为`True`，你不需要显式地这样做。这就是我的意思：
- en: '`In``[``86``]:``is_important``=``True``if``is_important``:``print``(``"This
    is important."``)``else``:``print``(``"This is not important."``)`'
  id: totrans-289
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``86``]:``is_important``=``True``if``is_important``:``print``(``"这很重要。"``)``else``:``print``(``"这不重要。"``)`'
- en: '`This is important.`'
  id: totrans-290
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`这很重要。`'
- en: 'The same works if you want to check if a sequence like a list is empty or not:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查类似列表这样的序列是否为空，使用相同的方法：
- en: '`In``[``87``]:``values``=``[]``if``values``:``print``(``f``"The following values
    were provided: {values}"``)``else``:``print``(``"There were no values provided."``)`'
  id: totrans-292
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``87``]:``values``=``[]``如果``values``:``print``(``f``"提供了以下数值：{values}"``)``else``:``print``(``"未提供数值。"``)`'
- en: '`There were no values provided.`'
  id: totrans-293
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`未提供数值。`'
- en: Programmers coming from other languages would often write something like `if
    (is_important == True)` or `if len(values) > 0` instead.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 来自其他语言的程序员通常会写类似`if (is_important == True)`或者`if len(values) > 0`的代码。
- en: 'Conditional expressions, also called ternary operators, allow you to use a
    more compact style for simple `if`/`else` statements:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 条件表达式，也称为三元运算符，允许你在简单的`if`/`else`语句中使用更紧凑的风格：
- en: '`In``[``88``]:``is_important``=``False``print``(``"important"``)``if``is_important``else``print``(``"not
    important"``)`'
  id: totrans-296
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``88``]:``is_important``=``False``print``(``"重要"``)``if``is_important``else``print``(``"不重要"``)`'
- en: '`not important`'
  id: totrans-297
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`不重要`'
- en: With `if` statements and conditional expressions in our pocket, let’s turn our
    attention to `for` and `while` loops in the next section.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 有了`if`语句和条件表达式，让我们在下一节转向`for`和`while`循环。
- en: The for and while Loops
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`和`while`循环'
- en: 'If you need to do something repeatedly like printing the value of ten different
    variables, you are doing yourself a big favor by not copy/pasting the print statement
    ten times. Instead, use a `for` loop to do the work for you. `for` loops iterate
    over the items of a sequence like a list, a tuple, or a string (remember, strings
    are sequences of characters). As an introductory example, let’s create a `for`
    loop that takes each element of the `currencies` list, assigns it to the variable
    `currency` and prints it—one after another until there are no more elements in
    the list:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要重复做一些像打印十个不同变量的值这样的事情，最好不要把打印语句复制/粘贴十次。而是使用`for`循环为你做这些工作。`for`循环遍历序列的项目，比如列表、元组或者字符串（记住，字符串是字符序列）。作为一个介绍性的例子，让我们创建一个`for`循环，它将`currencies`列表的每个元素赋值给变量`currency`，然后逐个打印出来，直到列表中没有更多的元素：
- en: '`In``[``89``]:``currencies``=``[``"USD"``,``"HKD"``,``"AUD"``]``for``currency``in``currencies``:``print``(``currency``)`'
  id: totrans-301
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``89``]:``currencies``=``[``"USD"``,``"HKD"``,``"AUD"``]``for``currency``in``currencies``:``print``(``currency``)`'
- en: '`USD HKD AUD`'
  id: totrans-302
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`USD HKD AUD`'
- en: 'As a side note, VBA’s `For Each` statement is close to how Python’s `for` loop
    works. The previous example could be written like this in VBA:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，VBA的`For Each`语句与Python的`for`循环工作方式相似。前面的例子在VBA中可以这样写：
- en: '`Dim``currencies``As``Variant``Dim``curr``As``Variant``''currency is a reserved
    word in VBA``currencies``=``Array``(``"USD"``,``"HKD"``,``"AUD"``)`'
  id: totrans-304
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Dim``currencies``As``Variant``Dim``curr``As``Variant``''currency is a reserved
    word in VBA``currencies``=``Array``(``"USD"``,``"HKD"``,``"AUD"``)`'
- en: '`For``Each``curr``In``currencies``Debug``.``Print``curr``Next`'
  id: totrans-305
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`For``Each``curr``In``currencies``Debug``.``Print``curr``Next`'
- en: 'In Python, if you need a counter variable in a `for` loop, the `range` or `enumerate`
    built-ins can help you with that. Let’s first look at `range`, which provides
    a sequence of numbers: you call it by either providing a single `stop` argument
    or by providing a `start` and `stop` argument, with an optional `step` argument.
    Like with slicing, `start` is inclusive, `stop` is exclusive, and `step` determines
    the step size, with `1` being the default:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，如果你需要在 `for` 循环中一个计数变量，`range` 或 `enumerate` 内置函数可以帮助你。让我们先看看 `range`，它提供一系列数字：你可以通过提供单个
    `stop` 参数或提供 `start` 和 `stop` 参数（带有可选的 `step` 参数）来调用它。与切片一样，`start` 包含在内，`stop`
    是排外的，`step` 决定步长，其中 `1` 是默认值：
- en: '`range``(``stop``)``range``(``start``,``stop``,``step``)`'
  id: totrans-307
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`range``(``stop``)``range``(``start``,``stop``,``step``)`'
- en: '`range` evaluates lazily, which means that without explicitly asking for it,
    you won’t see the sequence it generates:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`range` 评估是懒惰的，这意味着如果不明确要求，你看不到它生成的序列：'
- en: '`In``[``90``]:``range``(``5``)`'
  id: totrans-309
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``90``]:``range``(``5``)`'
- en: '`Out[90]: range(0, 5)`'
  id: totrans-310
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[90]: range(0, 5)`'
- en: 'Converting the range to a list solves this issue:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 将 range 转换为列表可以解决这个问题：
- en: '`In``[``91``]:``list``(``range``(``5``))``# stop argument`'
  id: totrans-312
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``91``]:``list``(``range``(``5``))``# stop argument`'
- en: '`Out[91]: [0, 1, 2, 3, 4]`'
  id: totrans-313
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[91]: [0, 1, 2, 3, 4]`'
- en: '`In``[``92``]:``list``(``range``(``2``,``5``,``2``))``# start, stop, step arguments`'
  id: totrans-314
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``92``]:``list``(``range``(``2``,``5``,``2``))``# start, stop, step arguments`'
- en: '`Out[92]: [2, 4]`'
  id: totrans-315
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[92]: [2, 4]`'
- en: 'Most of the time, there’s no need to wrap `range` with a `list`, though:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，不需要用 `list` 包装 `range`：
- en: '`In``[``93``]:``for``i``in``range``(``3``):``print``(``i``)`'
  id: totrans-317
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``93``]:``for``i``in``range``(``3``):``print``(``i``)`'
- en: '`0 1 2`'
  id: totrans-318
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`0 1 2`'
- en: 'If you need a counter variable while looping over a sequence, use `enumerate`.
    It returns a sequence of `(index, element)` tuples. By default, the index starts
    at zero and increments by one. You can use `enumarate` in a loop like this:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在遍历序列时需要一个计数器变量，请使用 `enumerate`。它返回一个 `(索引, 元素)` 元组序列。默认情况下，索引从零开始，逐一递增。你可以像这样在循环中使用
    `enumerate`：
- en: '`In``[``94``]:``for``i``,``currency``in``enumerate``(``currencies``):``print``(``i``,``currency``)`'
  id: totrans-320
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``94``]:``for``i``,``currency``in``enumerate``(``currencies``):``print``(``i``,``currency``)`'
- en: '`0 USD 1 HKD 2 AUD`'
  id: totrans-321
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`0 美元 1 港币 2 澳大利亚元`'
- en: 'Looping over tuples and sets works the same as with lists. When you loop over
    dictionaries, Python will loop over the keys:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历元组和集合的方式与列表相同。当你遍历字典时，Python 会遍历键：
- en: '`In``[``95``]:``exchange_rates``=``{``"EURUSD"``:``1.1152``,``"GBPUSD"``:``1.2454``,``"AUDUSD"``:``0.6161``}``for``currency_pair``in``exchange_rates``:``print``(``currency_pair``)`'
  id: totrans-323
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``95``]:``exchange_rates``=``{``"EURUSD"``:``1.1152``,``"GBPUSD"``:``1.2454``,``"AUDUSD"``:``0.6161``}``for``currency_pair``in``exchange_rates``:``print``(``currency_pair``)`'
- en: '`EURUSD GBPUSD AUDUSD`'
  id: totrans-324
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`EURUSD GBPUSD AUDUSD`'
- en: 'By using the `items` method, you get the key and the value at the same time
    as tuple:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `items` 方法，你可以同时获取键和值作为元组：
- en: '`In``[``96``]:``for``currency_pair``,``exchange_rate``in``exchange_rates``.``items``():``print``(``currency_pair``,``exchange_rate``)`'
  id: totrans-326
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``96``]:``for``currency_pair``,``exchange_rate``in``exchange_rates``.``items``():``print``(``currency_pair``,``exchange_rate``)`'
- en: '`EURUSD 1.1152 GBPUSD 1.2454 AUDUSD 0.6161`'
  id: totrans-327
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`EURUSD 1.1152 GBPUSD 1.2454 AUDUSD 0.6161`'
- en: 'To exit a loop, use the `break` statement:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 要退出循环，使用 `break` 语句：
- en: '`In``[``97``]:``for``i``in``range``(``15``):``if``i``==``2``:``break``else``:``print``(``i``)`'
  id: totrans-329
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``97``]:``for``i``in``range``(``15``):``if``i``==``2``:``break``else``:``print``(``i``)`'
- en: '`0 1`'
  id: totrans-330
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`0 1`'
- en: 'You skip the remainder of a loop with the `continue` statement, which means
    that execution continues with a new loop and the next element:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `continue` 语句跳过循环的剩余部分，这意味着执行将继续新的循环和下一个元素：
- en: '`In``[``98``]:``for``i``in``range``(``4``):``if``i``==``2``:``continue``else``:``print``(``i``)`'
  id: totrans-332
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``98``]:``for``i``in``range``(``4``):``if``i``==``2``:``continue``else``:``print``(``i``)`'
- en: '`0 1 3`'
  id: totrans-333
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`0 1 3`'
- en: 'When comparing for loops in VBA with Python, there is a subtle difference:
    in VBA, the counter variable increases beyond your upper limit after finishing
    the loop:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在比较 VBA 中的 for 循环与 Python 时，有一个微妙的区别：在 VBA 中，计数器变量在完成循环后会超出你的上限：
- en: '`For``i``=``1``To``3``Debug``.``Print``i``Next``i``Debug``.``Print``i`'
  id: totrans-335
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`For``i``=``1``To``3``Debug``.``Print``i``Next``i``Debug``.``Print``i`'
- en: 'This prints:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这会打印：
- en: '`1 2 3 4`'
  id: totrans-337
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`1 2 3 4`'
- en: 'In Python, it behaves like you would probably expect it to:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，它的行为就像你可能期望的那样：
- en: '`In``[``99``]:``for``i``in``range``(``1``,``4``):``print``(``i``)``print``(``i``)`'
  id: totrans-339
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``99``]:``for``i``in``range``(``1``,``4``):``print``(``i``)``print``(``i``)`'
- en: '`1 2 3 3`'
  id: totrans-340
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`1 2 3 3`'
- en: 'Instead of looping over a sequence, you can also use while loops to run a loop
    while a certain condition is true:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 要遍历序列而不是使用 `for` 循环，你也可以使用 while 循环在满足某个条件时运行循环：
- en: '`In``[``100``]:``n``=``0``while``n``<=``2``:``print``(``n``)``n``+=``1`'
  id: totrans-342
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``100``]:``n``=``0``while``n``<=``2``:``print``(``n``)``n``+=``1`'
- en: '`0 1 2`'
  id: totrans-343
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`0 1 2`'
- en: AUGMENTED ASSIGNMENT
  id: totrans-344
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 增强赋值
- en: 'I have used the augmented assignment notation in the last example: `n += 1`.
    This is the same as if you would write `n = n + 1`. It also works with all the
    other mathematical operators that I’ve introduced earlier on; for example, for
    minus you could write `n -= 1`.'
  id: totrans-345
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在上一个例子中，我使用了增强赋值符号：`n += 1`。这与您写`n = n + 1`是一样的。它也适用于我之前介绍的所有其他数学运算符；例如，减法您可以写`n
    -= 1`。
- en: 'Quite often, you will need to collect certain elements in a list for further
    processing. In this case, Python offers an alternative to writing loops: list,
    dictionary, and set comprehensions.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 经常需要收集列表中的某些元素进行进一步处理。在这种情况下，Python 提供了一种替代循环的方式：列表、字典和集合推导式。
- en: List, Dictionary, and Set Comprehensions
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 列表、字典和集合推导式
- en: 'List, dictionary, and set comprehensions are technically a way to create the
    respective data structure, but they often replace a `for` loop, which is why I
    am introducing them here. Assume that in the following list of USD currency pairs,
    you’d like to pick out those currencies where USD is quoted as the second currency.
    You could write the following `for` loop:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 列表、字典和集合推导式技术上是创建相应数据结构的一种方式，但它们经常替代`for`循环，这就是我在这里介绍它们的原因。假设在以下USD货币对的列表中，您想挑选出USD作为第二个货币报价的那些货币。您可以写以下`for`循环：
- en: '`In``[``101``]:``currency_pairs``=``[``"USDJPY"``,``"USDGBP"``,``"USDCHF"``,``"USDCAD"``,``"AUDUSD"``,``"NZDUSD"``]`'
  id: totrans-349
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``101``]:``currency_pairs``=``[``"USDJPY"``,``"USDGBP"``,``"USDCHF"``,``"USDCAD"``,``"AUDUSD"``,``"NZDUSD"``]`'
- en: '`In``[``102``]:``usd_quote``=``[]``for``pair``in``currency_pairs``:``if``pair``[``3``:]``==``"USD"``:``usd_quote``.``append``(``pair``[:``3``])``usd_quote`'
  id: totrans-350
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``102``]:``usd_quote``=``[]``for``pair``in``currency_pairs``:``if``pair``[``3``:]``==``"USD"``:``usd_quote``.``append``(``pair``[:``3``])``usd_quote`'
- en: '`Out[102]: [''AUD'', ''NZD'']`'
  id: totrans-351
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[102]: [''AUD'', ''NZD'']`'
- en: 'This is often easier to write with a list comprehension. A list comprehension
    is a concise way of creating a list. You can grab its syntax from this example,
    which does the same as the previous `for` loop:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 使用列表推导式通常更容易编写。列表推导式是创建列表的简洁方式。您可以从这个示例中获取其语法，它与前面的`for`循环做的事情是一样的：
- en: '`In``[``103``]:``[``pair``[:``3``]``for``pair``in``currency_pairs``if``pair``[``3``:]``==``"USD"``]`'
  id: totrans-353
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``103``]:``[``pair``[:``3``]``for``pair``in``currency_pairs``if``pair``[``3``:]``==``"USD"``]`'
- en: '`Out[103]: [''AUD'', ''NZD'']`'
  id: totrans-354
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[103]: [''AUD'', ''NZD'']`'
- en: 'If you don’t have any condition to satisfy, simply leave the `if` part away.
    For example, to invert all the currency pairs so that the first currency comes
    second and vice versa, you would do:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有任何条件需要满足，可以简单地省略`if`部分。例如，要颠倒所有货币对，使第一个货币变成第二个货币，反之亦然，可以这样做：
- en: '`In``[``104``]:``[``pair``[``3``:]``+``pair``[:``3``]``for``pair``in``currency_pairs``]`'
  id: totrans-356
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``104``]:``[``pair``[``3``:]``+``pair``[:``3``]``for``pair``in``currency_pairs``]`'
- en: '`Out[104]: [''JPYUSD'', ''GBPUSD'', ''CHFUSD'', ''CADUSD'', ''USDAUD'', ''USDNZD'']`'
  id: totrans-357
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[104]: [''JPYUSD'', ''GBPUSD'', ''CHFUSD'', ''CADUSD'', ''USDAUD'', ''USDNZD'']`'
- en: 'With dictionaries, there are dictionary comprehensions:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 对于字典，还有字典推导式：
- en: '`In``[``105``]:``exchange_rates``=``{``"EURUSD"``:``1.1152``,``"GBPUSD"``:``1.2454``,``"AUDUSD"``:``0.6161``}``{``k``:``v``*``100``for``(``k``,``v``)``in``exchange_rates``.``items``()}`'
  id: totrans-359
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``105``]:``exchange_rates``=``{``"EURUSD"``:``1.1152``,``"GBPUSD"``:``1.2454``,``"AUDUSD"``:``0.6161``}``{``k``:``v``*``100``for``(``k``,``v``)``in``exchange_rates``.``items``()}`'
- en: '`Out[105]: {''EURUSD'': 111.52, ''GBPUSD'': 124.54, ''AUDUSD'': 61.61}`'
  id: totrans-360
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[105]: {''EURUSD'': 111.52, ''GBPUSD'': 124.54, ''AUDUSD'': 61.61}`'
- en: 'And with sets, there are set comprehensions:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 而对于集合，有集合推导式：
- en: '`In``[``106``]:``{``s``+``"USD"``for``s``in``[``"EUR"``,``"GBP"``,``"EUR"``,``"HKD"``,``"HKD"``]}`'
  id: totrans-362
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``106``]:``{``s``+``"USD"``for``s``in``[``"EUR"``,``"GBP"``,``"EUR"``,``"HKD"``,``"HKD"``]}`'
- en: '`Out[106]: {''EURUSD'', ''GBPUSD'', ''HKDUSD''}`'
  id: totrans-363
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[106]: {''EURUSD'', ''GBPUSD'', ''HKDUSD''}`'
- en: At this point, you are already able to write simple scripts, as you know most
    of the basic building blocks of Python. In the next section, you will learn how
    to organize your code to keep it maintainable when your scripts start to get bigger.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经能够编写简单的脚本，因为您已经了解了大多数Python的基本构建块。在下一节中，当您的脚本开始变得更大时，您将学习如何组织您的代码以保持可维护性。
- en: Code Organization
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 代码组织
- en: 'In this section, we’ll look into how to bring code into a maintainable structure:
    I’ll start by introducing functions with all the details that you will commonly
    need before I’ll show you how to split your code into different Python modules.
    The knowledge about modules will allow us to finish this section by looking into
    the `datetime` module that is part of the standard library.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解如何将代码组织成可维护的结构：我将首先介绍你通常需要的所有函数细节，然后展示如何将代码分割成不同的Python模块。关于模块的知识将使我们能够在本节结束时研究标准库中的`datetime`模块。
- en: Functions
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 函数
- en: 'Even if you will use Python for simple scripts only, you are still going to
    write functions regularly: they are one of the most important constructs of every
    programming language and allow you to reuse the same lines of code from anywhere
    in your program. We’ll start this section by defining a function before we see
    how to call it!'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你只会在Python中写简单脚本，你仍然会经常编写函数：它们是每种编程语言中最重要的结构之一，允许你从程序的任何地方重用相同的代码行。在我们看如何调用它之前，我们将在本节开始时定义一个函数！
- en: Defining functions
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 定义函数
- en: 'To write your own function in Python, you have to use the keyword `def`, which
    stands for function definition. Unlike VBA, Python doesn’t differentiate between
    a function and a Sub procedure. In Python, the equivalent of a Sub procedure is
    simply a function that doesn’t return anything. Functions in Python follow the
    syntax for code blocks, i.e., you end the first line with a colon and indent the
    body of the function:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Python中编写自己的函数，你必须使用关键字`def`，它代表函数定义。与VBA不同，Python不区分函数和子程序。在Python中，子程序的等价物就是一个不返回任何东西的函数。Python中的函数遵循代码块的语法，即你用冒号结束第一行，然后缩进函数体：
- en: '`def``function_name``(``required_argument``,``optional_argument``=``default_value``,``...``):``return``value1``,``value2``,``...`'
  id: totrans-371
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`def``function_name``(``required_argument``,``optional_argument``=``default_value``,``...``):``return``value1``,``value2``,``...`'
- en: Required arguments
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 必需参数
- en: Required arguments do not have a default value. Multiple arguments are separated
    by commas.
  id: totrans-373
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 必需参数没有默认值。多个参数用逗号分隔。
- en: Optional arguments
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 可选参数
- en: You make an argument optional by supplying a default value. `None` is often
    used to make an argument optional if there is no meaningful default.
  id: totrans-375
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通过提供默认值来使参数可选。如果没有有意义的默认值，通常使用`None`来使参数可选。
- en: Return value
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值
- en: The `return` statement defines the value that the function returns. If you leave
    it away, the function automatically returns `None`. Python conveniently allows
    you to return multiple values separated by commas.
  id: totrans-377
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`return`语句定义函数返回的值。如果省略它，函数将自动返回`None`。Python方便地允许你返回多个用逗号分隔的值。'
- en: 'To be able to play around with a function, let’s define one that is able to
    convert the temperature from Fahrenheit or Kelvin to degrees Celsius:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够操作一个函数，让我们定义一个能够将温度从华氏度或开尔文转换为摄氏度的函数：
- en: '`In``[``107``]:``def``convert_to_celsius``(``degrees``,``source``=``"fahrenheit"``):``if``source``.``lower``()``==``"fahrenheit"``:``return``(``degrees``-``32``)``*``(``5``/``9``)``elif``source``.``lower``()``==``"kelvin"``:``return``degrees``-``273.15``else``:``return``f``"Don''t
    know how to convert from {source}"`'
  id: totrans-379
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``107``]:``def``convert_to_celsius``(``degrees``,``source``=``"fahrenheit"``):``if``source``.``lower``()``==``"fahrenheit"``:``return``(``degrees``-``32``)``*``(``5``/``9``)``elif``source``.``lower``()``==``"kelvin"``:``return``degrees``-``273.15``else``:``return``f``"不知道如何从
    {source} 转换"`'
- en: I am using the string method `lower`, which transforms the provided strings
    to lowercase. This allows us to accept the `source` string with any capitalization
    while the comparison will still work. With the `convert_to_celsius` function defined,
    let’s see how we can call it!
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了字符串方法`lower`，它将提供的字符串转换为小写。这允许我们接受带有任何大小写的`source`字符串，而比较仍然有效。有了`convert_to_celsius`函数的定义，让我们看看如何调用它！
- en: Calling functions
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 调用函数
- en: 'As briefly mentioned at the beginning of this chapter, you call a function
    by adding parentheses to the function name, enclosing the function arguments:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章开头简要提到的，通过在函数名后面添加括号并包围函数参数来调用函数：
- en: '`value1``,``value2``,``...``=``function_name``(``positional_arg``,``arg_name``=``value``,``...``)`'
  id: totrans-383
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`value1``,``value2``,``...``=``function_name``(``positional_arg``,``arg_name``=``value``,``...``)`'
- en: Positional arguments
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 位置参数
- en: If you provide a value as a positional argument (`positional_arg`), the values
    are matched to the arguments according to their position in the function definition.
  id: totrans-385
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你把一个值作为位置参数（`positional_arg`）提供，这些值将根据它们在函数定义中的位置进行匹配。
- en: Keyword arguments
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字参数
- en: 'By providing the argument in the form `arg_name=value`, you’re providing a
    keyword argument. This has the advantage that you can provide the arguments in
    any order. It is also more explicit to the reader and can make it easier to understand.
    For example, if the function is defined as `f(a, b)`, you could call the function
    like this: `f(b=1, a=2)`. This concept also exists in VBA, where you could use
    keyword arguments by calling a function like this: `f(b:=1, a:=1)`.'
  id: totrans-387
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通过以`arg_name=value`的形式提供参数，您提供了一个关键字参数。这样做的好处是可以任意顺序提供参数。对于读者来说更加明确，有助于理解。例如，如果函数定义为`f(a,
    b)`，您可以像这样调用函数：`f(b=1, a=2)`。这个概念在VBA中也存在，您可以通过像这样调用函数来使用关键字参数：`f(b:=1, a:=1)`。
- en: 'Let’s play around with the `convert_to_celsius` function to see how this all
    works in practice:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们玩转`convert_to_celsius`函数，看看实际操作中的运作方式：
- en: '`In``[``108``]:``convert_to_celsius``(``100``,``"fahrenheit"``)``# Positional
    arguments`'
  id: totrans-389
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``108``]:``convert_to_celsius``(``100``,``"fahrenheit"``)``# 位置参数`'
- en: '`Out[108]: 37.77777777777778`'
  id: totrans-390
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[108]: 37.77777777777778`'
- en: '`In``[``109``]:``convert_to_celsius``(``50``)``# Will use the default source
    (fahrenheit)`'
  id: totrans-391
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``109``]:``convert_to_celsius``(``50``)``# 将使用默认来源（fahrenheit）`'
- en: '`Out[109]: 10.0`'
  id: totrans-392
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[109]: 10.0`'
- en: '`In``[``110``]:``convert_to_celsius``(``source``=``"kelvin"``,``degrees``=``0``)``#
    Keyword arguments`'
  id: totrans-393
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``110``]:``convert_to_celsius``(``source``=``"kelvin"``,``degrees``=``0``)``#
    关键字参数`'
- en: '`Out[110]: -273.15`'
  id: totrans-394
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[110]: -273.15`'
- en: Now that you know how to define and call functions, let’s see how to organize
    them with the help of modules.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经知道如何定义和调用函数，让我们看看如何借助模块组织它们。
- en: Modules and the import Statement
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 模块和导入语句
- en: When you write code for bigger projects, you will have to split it into different
    files at some point to be able to bring it into a maintainable structure. As we
    have already seen in the previous chapter, Python files have the extension .py
    and you usually refer to your main file as a script. If you now want your main
    script to access functionality from other files, you need to import that functionality
    first. In this context, Python source files are called modules. To get a better
    feeling for how this works and what the different import options are, have a look
    at the file temperature.py in the companion repository by opening it with VS Code
    ([Example 3-1](#filepos377335)). If you need a refresher on how to open files
    in VS Code, have another look at [Chapter 2](index_split_008.html#filepos96824).
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 当您为更大的项目编写代码时，最终必须将其拆分为不同的文件，以便能够将其组织成可维护的结构。正如我们在前一章中已经看到的，Python文件的扩展名为`.py`，通常将主文件称为脚本。如果您现在希望您的主脚本能够访问其他文件中的功能，首先需要导入该功能。在此上下文中，Python源文件称为模块。要更好地了解其工作原理以及不同的导入选项，请查看伴随存储库中的文件temperature.py，并使用VS
    Code打开它（[示例 3-1](#filepos377335)）。如果您需要再次了解如何在VS Code中打开文件，请再次查看[第2章](index_split_008.html#filepos96824)。
- en: Example 3-1\. temperature.py
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3-1\. temperature.py
- en: '`TEMPERATURE_SCALES``=``(``"fahrenheit"``,``"kelvin"``,``"celsius"``)``def``convert_to_celsius``(``degrees``,``source``=``"fahrenheit"``):``if``source``.``lower``()``==``"fahrenheit"``:``return``(``degrees``-``32``)``*``(``5``/``9``)``elif``source``.``lower``()``==``"kelvin"``:``return``degrees``-``273.15``else``:``return``f``"Don''t
    know how to convert from {source}"``print``(``"This is the temperature module."``)`'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '`TEMPERATURE_SCALES``=``(``"fahrenheit"``,``"kelvin"``,``"celsius"``)``def``convert_to_celsius``(``degrees``,``source``=``"fahrenheit"``):``if``source``.``lower``()``==``"fahrenheit"``:``return``(``degrees``-``32``)``*``(``5``/``9``)``elif``source``.``lower``()``==``"kelvin"``:``return``degrees``-``273.15``else``:``return``f``"无法从
    {source} 转换"``print``(``"这是温度模块。"``)`'
- en: 'To be able to import the `temperature` module from your Jupyter notebook, you
    will need the Jupyter notebook and the `temperature` module to be in the same
    directory—as it is in the case of the companion repository. To import, you only
    use the name of the module, without the .py ending. After running the `import`
    statement, you will have access to all the objects in that Python module via the
    dot notation. For example, use `temperature.convert_to_celsius()` to perform your
    conversion:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够从您的Jupyter笔记本中导入`temperature`模块，您需要确保Jupyter笔记本和`temperature`模块在同一个目录中——就像伴随存储库的情况一样。要导入，只需使用模块的名称，不需要`.py`扩展名。运行`import`语句后，您将能够通过点符号访问该Python模块中的所有对象。例如，使用`temperature.convert_to_celsius()`执行您的转换操作：
- en: '`In``[``111``]:``import``temperature`'
  id: totrans-401
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``111``]:``import``temperature'
- en: '`This is the temperature module.`'
  id: totrans-402
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`这是温度模块。`'
- en: '`In``[``112``]:``temperature``.``TEMPERATURE_SCALES`'
  id: totrans-403
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``112``]:``temperature``.``TEMPERATURE_SCALES`'
- en: '`Out[112]: (''fahrenheit'', ''kelvin'', ''celsius'')`'
  id: totrans-404
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[112]: (''fahrenheit'', ''kelvin'', ''celsius'')`'
- en: '`In``[``113``]:``temperature``.``convert_to_celsius``(``120``,``"fahrenheit"``)`'
  id: totrans-405
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``113``]:` `temperature``.``convert_to_celsius``(``120``,``"fahrenheit"``)`'
- en: '`Out[113]: 48.88888888888889`'
  id: totrans-406
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[113]:` `48.88888888888889`'
- en: Note that I used uppercase letters for `TEMPERATURE_SCALES` to express that
    it is a constant—I will say more about that toward the end of this chapter. When
    you execute the cell with `import temperature`, Python will run the temperature.py
    file from top to bottom. You can easily see this happening since importing the
    module will fire the print function at the bottom of temperature.py.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我在`TEMPERATURE_SCALES`中使用了大写字母来表示它是一个常量——我将在本章末尾进一步讨论这一点。当你执行带有`import temperature`的单元格时，Python将从上到下运行temperature.py文件。你可以很容易地看到这一点，因为导入模块将触发temperature.py底部的打印函数。
- en: MODULES ARE ONLY IMPORTED ONCE
  id: totrans-408
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块只被导入一次
- en: If you run the `import temperature` cell again, you will notice that it does
    not print anything anymore. This is because Python modules are only imported once
    per session. If you change code in a module that you import, you need to restart
    your Python interpreter to pick up all the changes, i.e., in a Jupyter notebook,
    you’d have to click on Kernel > Restart.
  id: totrans-409
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你再次运行`import temperature`单元格，你会注意到它不再打印任何东西。这是因为Python模块在会话中只被导入一次。如果你更改了导入模块中的代码，你需要重新启动Python解释器才能应用所有更改，即在Jupyter笔记本中，你需要点击Kernel
    > Restart。
- en: 'In reality, you usually don’t print anything in modules. This was only to show
    you the effect of importing a module more than once. Most commonly, you put functions
    and classes in your modules (for more on classes, see [Appendix C](index_split_031.html#filepos1832059)).
    If you don’t want to type `temperature` every time you use an object from the
    temperature module, change the `import` statement like this:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，通常你不会在模块中打印任何东西。这只是为了向你展示多次导入模块的效果。通常情况下，你会在模块中放置函数和类（有关类的更多信息，请参见[附录 C](index_split_031.html#filepos1832059)）。如果你不想每次使用`temperature`模块中的对象时都输入`temperature`，可以像这样更改`import`语句：
- en: '`In``[``114``]:``import``temperature``as``tp`'
  id: totrans-411
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``114``]:` `import``temperature``as``tp`'
- en: '`In``[``115``]:``tp``.``TEMPERATURE_SCALES`'
  id: totrans-412
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``115``]:` `tp``.``TEMPERATURE_SCALES`'
- en: '`Out[115]: (''fahrenheit'', ''kelvin'', ''celsius'')`'
  id: totrans-413
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[115]:` (`fahrenheit`, `kelvin`, `celsius`)`'
- en: 'Assigning a short alias `tp` to your module can make it easier to use while
    it’s still always clear where an object comes from. Many third-party packages
    suggest a specific convention when using an alias. For example, pandas is using
    `import pandas as pd`. There is one more option to import objects from another
    module:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 给你的模块分配一个短的别名`tp`可以使其在使用时更容易，但仍然清楚对象来自哪里。许多第三方包在使用别名时建议使用特定的约定。例如，pandas使用`import
    pandas as pd`。还有一种从另一个模块导入对象的选项：
- en: '`In``[``116``]:``from``temperature``import``TEMPERATURE_SCALES``,``convert_to_celsius`'
  id: totrans-415
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``116``]:` `from``temperature``import``TEMPERATURE_SCALES`,``convert_to_celsius`'
- en: '`In``[``117``]:``TEMPERATURE_SCALES`'
  id: totrans-416
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``117``]:` `TEMPERATURE_SCALES`'
- en: '`Out[117]: (''fahrenheit'', ''kelvin'', ''celsius'')`'
  id: totrans-417
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[117]:` (`fahrenheit`, `kelvin`, `celsius`)`'
- en: THE __PYCACHE__ FOLDER
  id: totrans-418
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`__PYCACHE__`文件夹'
- en: When you import the `temperature` module, you will see that Python creates a
    folder called __pycache__ with files that have the .pyc extension. These are bytecode-compiled
    files that the Python interpreter creates when you import a module. For our purposes,
    we can simply ignore this folder, as it is a technical detail of how Python runs
    your code.
  id: totrans-419
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当你导入`temperature`模块时，你会发现Python创建了一个名为`__pycache__`的文件夹，其中的文件扩展名为`.pyc`。这些是Python解释器在导入模块时创建的字节编译文件。对于我们的目的，我们可以简单地忽略这个文件夹，因为这是Python运行代码的技术细节。
- en: 'When using the `from x import y` syntax, you import specific objects only.
    By doing this, you are importing them directly into the namespace of your main
    script: that is, without looking at the `import` statements, you won’t be able
    to tell whether the imported objects were defined in your current Python script
    or Jupyter notebook or if they come from another module. This could cause conflicts:
    if your main script has a function called `convert_to_celsius`, it would override
    the one that you are importing from the `temperature` module. If, however, you
    use one of the two previous methods, your local function and the one from the
    imported module could live next to each other as `convert_to_celsius` and `temperature.convert_to_celsius`.'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`from x import y`语法时，你仅导入特定的对象。通过这样做，你将它们直接导入到你主脚本的命名空间中：也就是说，如果没有查看`import`语句，你无法知道导入的对象是在你当前的Python脚本还是Jupyter笔记本中定义的，还是来自另一个模块。这可能会导致冲突：如果你的主脚本有一个名为`convert_to_celsius`的函数，它会覆盖从`temperature`模块导入的函数。然而，如果你使用前面两种方法之一，你的本地函数和导入模块中的函数可以像`convert_to_celsius`和`temperature.convert_to_celsius`这样共存。
- en: DON’T NAME YOUR SCRIPTS LIKE EXISTING PACKAGES
  id: totrans-421
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 不要将脚本命名为现有的包名
- en: A common source for errors is to name your Python file the same as an existing
    Python package or module. If you create a file to test out some pandas functionality,
    don’t call that file pandas.py, as this can cause conflicts.
  id: totrans-422
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 命名Python文件与现有的Python包或模块相同是常见的错误源。如果你创建一个文件来测试一些pandas功能，请不要将该文件命名为pandas.py，因为这可能会导致冲突。
- en: Now that you know how the import mechanism works, let’s use it right away to
    import the `datetime` module! This will also allow you to learn a few more things
    about objects and classes.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你了解了导入机制的工作原理，让我们立即使用它来导入`datetime`模块！这也将使你能够学习关于对象和类的一些更多内容。
- en: The datetime Class
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: datetime类
- en: 'Working with date and time is a common operation in Excel, but it comes with
    limitations: for example, Excel’s cell format for time doesn’t support smaller
    units than milliseconds and time zones are not supported at all. In Excel, date
    and time are stored as a simple float called the date serial number. The Excel
    cell is then formatted to display it as date and/or time. For example, January
    1, 1900 has the date serial number of 1, which means that this is also the earliest
    date that you can work with in Excel. Time gets translated into the decimal part
    of the float, e.g., `01/01/1900 10:10:00` is represented by `1.4236111111`.'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在Excel中，处理日期和时间是一种常见的操作，但它带有一些限制：例如，Excel的时间单元格格式不支持比毫秒更小的单位，时间区域也完全不支持。在Excel中，日期和时间存储为称为日期序列号的简单浮点数。然后，Excel单元格被格式化为显示日期和/或时间。例如，1900年1月1日的日期序列号为1，这意味着这也是你可以在Excel中使用的最早日期。时间被转换为浮点数的小数部分，例如，`01/01/1900
    10:10:00`被表示为`1.4236111111`。
- en: 'In Python, to work with date and time, you import the `datetime` module, which
    is part of the standard library. The `datetime` module contains a class with the
    same name that allows us to create `datetime` objects. Since having the same name
    for the module and the class can be confusing, I will use the following import
    convention throughout this book: `import datetime as dt`. This makes it easy to
    differentiate between the module (`dt`) and the class (`datetime`).'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，要处理日期和时间，你需要导入标准库中的`datetime`模块。`datetime`模块包含同名的类，允许我们创建`datetime`对象。由于模块和类的名称相同可能会导致混淆，我将在本书中使用以下导入约定：`import
    datetime as dt`。这样可以很容易区分模块（`dt`）和类（`datetime`）。
- en: 'Up to this point, we were most of the time using literals to create objects
    like lists or dictionaries. Literals refer to the syntax that Python recognizes
    as a specific object type—in the case of a list, this would be something like
    `[1, 2, 3]`. However, most of the objects have to be created by calling their
    class: this process is called instantiation, and objects are therefore also called
    class instances. Calling a class works the same way as calling a function, i.e.,
    you add parentheses to the class name and provide the arguments in the same way
    we did with functions. To instantiate a `datetime` object, you need to call the
    class like this:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们大部分时间都在使用字面值来创建列表或字典等对象。字面值是指Python识别为特定对象类型的语法—例如列表的情况下，这可能是像`[1, 2,
    3]`这样的东西。然而，大多数对象必须通过调用它们的类来创建：这个过程称为实例化，因此对象也称为类实例。调用一个类的方式与调用函数的方式相同，即你需要在类名后加上括号，并以与我们在函数中所做的方式相同的方式提供参数。要实例化一个`datetime`对象，你需要像这样调用类：
- en: '`import``datetime``as``dt``dt``.``datetime``(``year``,``month``,``day``,``hour``,``minute``,``second``,``microsecond``,``timezone``)`'
  id: totrans-428
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`import``datetime``as``dt``dt``.``datetime``(``year``,``month``,``day``,``hour``,``minute``,``second``,``microsecond``,``timezone``)`'
- en: 'Let’s go through a couple of examples to see how you work with `datetime` objects
    in Python. For the purpose of this introduction, let’s ignore time zones and work
    with time-zone-naive `datetime` objects:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过几个例子看看如何在 Python 中处理 `datetime` 对象。为了本次介绍的目的，让我们忽略时区并使用没有时区信息的 `datetime`
    对象工作：
- en: '`In``[``118``]:``# Import the datetime module as "dt"``import``datetime``as``dt`'
  id: totrans-430
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``118``]:``# 将 datetime 模块导入为 "dt"``import``datetime``as``dt`'
- en: '`In``[``119``]:``# Instantiate a datetime object called "timestamp"``timestamp``=``dt``.``datetime``(``2020``,``1``,``31``,``14``,``30``)``timestamp`'
  id: totrans-431
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``119``]:``# 实例化一个名为 "timestamp" 的 datetime 对象``timestamp``=``dt``.``datetime``(``2020``,``1``,``31``,``14``,``30``)``timestamp`'
- en: '`Out[119]: datetime.datetime(2020, 1, 31, 14, 30)`'
  id: totrans-432
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[119]: datetime.datetime(2020, 1, 31, 14, 30)`'
- en: '`In``[``120``]:``# Datetime objects offer various attributes, e.g., to get
    the day``timestamp``.``day`'
  id: totrans-433
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``120``]:``# Datetime objects offer various attributes, e.g., to get
    the day``timestamp``.``day`'
- en: '`Out[120]: 31`'
  id: totrans-434
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[120]: 31`'
- en: '`In``[``121``]:``# The difference of two datetime objects returns a timedelta
    object``timestamp``-``dt``.``datetime``(``2020``,``1``,``14``,``12``,``0``)`'
  id: totrans-435
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``121``]:``# 两个 datetime 对象的差返回一个 timedelta 对象``timestamp``-``dt``.``datetime``(``2020``,``1``,``14``,``12``,``0``)`'
- en: '`Out[121]: datetime.timedelta(days=17, seconds=9000)`'
  id: totrans-436
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[121]: datetime.timedelta(days=17, seconds=9000)`'
- en: '`In``[``122``]:``# Accordingly, you can also work with timedelta objects``timestamp``+``dt``.``timedelta``(``days``=``1``,``hours``=``4``,``minutes``=``11``)`'
  id: totrans-437
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``122``]:``# 相应地，您还可以使用 timedelta 对象``timestamp``+``dt``.``timedelta``(``days``=``1``,``hours``=``4``,``minutes``=``11``)`'
- en: '`Out[122]: datetime.datetime(2020, 2, 1, 18, 41)`'
  id: totrans-438
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[122]: datetime.datetime(2020, 2, 1, 18, 41)`'
- en: 'To format `datetime` objects into strings, use the `strftime` method, and to
    parse a string and convert it into a `datetime` object, use the `strptime` function
    (you can find an overview of the accepted format codes in the [datetime docs](https://oreil.ly/gXOts)):'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 `datetime` 对象格式化为字符串，请使用 `strftime` 方法；要解析字符串并将其转换为 `datetime` 对象，请使用 `strptime`
    函数（您可以在 [datetime 文档](https://oreil.ly/gXOts) 中找到接受的格式代码的概述）：
- en: '`In``[``123``]:``# Format a datetime object in a specific way``# You could
    also use an f-string: f"{timestamp:%d/%m/%Y %H:%M}"``timestamp``.``strftime``(``"``%d``/``%m``/``%Y``%H``:``%M``"``)`'
  id: totrans-440
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``123``]:``# 以特定方式格式化 datetime 对象``# 您也可以使用 f-string：f"{timestamp:%d/%m/%Y
    %H:%M}"``timestamp``.``strftime``(``"``%d``/``%m``/``%Y``%H``:``%M``"``)`'
- en: '`Out[123]: ''31/01/2020 14:30''`'
  id: totrans-441
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[123]: ''31/01/2020 14:30''`'
- en: '`In``[``124``]:``# Parse a string into a datetime object``dt``.``datetime``.``strptime``(``"12.1.2020"``,``"``%d``.``%m``.``%Y``"``)`'
  id: totrans-442
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``124``]:``# 将字符串解析为 datetime 对象``dt``.``datetime``.``strptime``(``"12.1.2020"``,``"``%d``.``%m``.``%Y``"``)`'
- en: '`Out[124]: datetime.datetime(2020, 1, 12, 0, 0)`'
  id: totrans-443
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[124]: datetime.datetime(2020, 1, 12, 0, 0)`'
- en: After this short introduction to the `datetime` module, let’s move on to the
    last topic of this chapter, which is about formatting your code properly.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个对 `datetime` 模块的简短介绍之后，让我们继续本章的最后一个主题，即如何正确格式化代码。
- en: 'PEP 8: Style Guide for Python Code'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: PEP 8：Python 代码风格指南
- en: 'You may have been wondering why I was sometimes using variable names with underscores
    or in all caps. This section will explain my formatting choices by introducing
    you to Python’s official style guide. Python uses so-called Python Enhancement
    Proposals (PEP) to discuss the introduction of new language features. One of these,
    the Style Guide for Python Code, is usually referred to by its number: PEP 8\.
    PEP 8 is a set of style recommendations for the Python community; if everybody
    who works on the same code adheres to the same style guide, the code becomes much
    more readable. This is especially important in the world of open source where
    many programmers work on the same project, often without knowing each other personally.
    [Example 3-2](#filepos410016) shows a short Python file that introduces the most
    important conventions.'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你一直在想，为什么有时我会用带有下划线或全大写的变量名。这一节将通过介绍 Python 的官方风格指南来解释我的格式选择。Python 使用所谓的
    Python Enhancement Proposals（PEP）来讨论引入新语言特性。其中之一，Python 代码风格指南通常用其编号来指代：PEP 8\.
    PEP 8 是 Python 社区的一套风格建议；如果所有在同一代码上工作的人都遵循相同的风格指南，代码会变得更加可读。在开源世界尤为重要，因为许多程序员在同一项目上工作，通常彼此并不认识。[Example 3-2](#filepos410016)
    展示了一个简短的 Python 文件，介绍了最重要的惯例。
- en: Example 3-2\. pep8_sample.py
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: Example 3-2\. pep8_sample.py
- en: '`"""This script shows a few PEP 8 rules.` ![](images/00031.jpg) `"""``import``datetime``as``dt`![](images/00039.jpg)`TEMPERATURE_SCALES``=``(``"fahrenheit"``,``"kelvin"``,``"celsius"``)`![](images/00050.jpg)![](images/00067.jpg)`class``TemperatureConverter``:`![](images/00058.jpg)`pass``#
    Doesn''t do anything at the moment` ![](images/00082.jpg)`def``convert_to_celsius``(``degrees``,``source``=``"fahrenheit"``):`![](images/00076.jpg)`"""This
    function converts degrees Fahrenheit or Kelvin     into degrees Celsius.` ![](images/00007.jpg)
    `"""``if``source``.``lower``()``==``"fahrenheit"``:`![](images/00015.jpg)`return``(``degrees``-``32``)``*``(``5``/``9``)`![](images/00020.jpg)`elif``source``.``lower``()``==``"kelvin"``:``return``degrees``-``273.15``else``:``return``f``"Don''t
    know how to convert from {source}"``celsius``=``convert_to_celsius``(``44``,``source``=``"fahrenheit"``)`![](images/00025.jpg)`non_celsius_scales``=``TEMPERATURE_SCALES``[:``-``1``]`![](images/00034.jpg)`print``(``"Current
    time: "``+``dt``.``datetime``.``now``()``.``isoformat``())``print``(``f``"The
    temperature in Celsius is: {celsius}"``)`'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '`"""这个脚本展示了一些 PEP 8 规则。` ![](images/00031.jpg) `"""``import``datetime``as``dt`![](images/00039.jpg)`TEMPERATURE_SCALES``=``(``"fahrenheit"``,``"kelvin"``,``"celsius"``)`![](images/00050.jpg)![](images/00067.jpg)`class``TemperatureConverter``:`![](images/00058.jpg)`pass``#
    目前什么也不做` ![](images/00082.jpg)`def``convert_to_celsius``(``degrees``,``source``=``"fahrenheit"``):`![](images/00076.jpg)`"""这个函数将华氏度或开尔文转换为摄氏度。`
    ![](images/00007.jpg) `"""``if``source``.``lower``()``==``"fahrenheit"``:`![](images/00015.jpg)`return``(``degrees``-``32``)``*``(``5``/``9``)`![](images/00020.jpg)`elif``source``.``lower``()``==``"kelvin"``:``return``degrees``-``273.15``else``:``return``f``"不知道如何从
    {source} 转换"`celsius``=``convert_to_celsius``(``44``,``source``=``"fahrenheit"``)`![](images/00025.jpg)`non_celsius_scales``=``TEMPERATURE_SCALES``[:``-``1``]`![](images/00034.jpg)`print``(``"当前时间：
    "``+``dt``.``datetime``.``now``()``.``isoformat``())``print``(``f``"摄氏度温度为： {celsius}"``)`'
- en: '![](images/00031.jpg)'
  id: totrans-449
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00031.jpg)'
- en: Explain what the script/module does with a docstring at the top. A docstring
    is a special type of string, enclosed with triple quotes. Apart from serving as
    a string for documenting your code, a docstring also makes it easy to write strings
    over multiple lines and is useful if your text contains a lot of double-quotes
    or single-quotes, as you won’t need to escape them. They are also useful to write
    multiline SQL queries, as we will see in [Chapter 11](index_split_027.html#filepos1487255).
  id: totrans-450
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用顶部的文档字符串解释脚本/模块的功能。文档字符串是一种特殊类型的字符串，用三个引号括起来。除了作为代码文档的字符串外，文档字符串还使得可以轻松地编写多行字符串，特别是在文本包含大量双引号或单引号时，不需要转义它们。如果您的文本包含大量的多行
    SQL 查询，文档字符串非常有用，正如我们将在 [第 11 章](index_split_027.html#filepos1487255) 中看到的。
- en: '![](images/00039.jpg)'
  id: totrans-451
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00039.jpg)'
- en: All imports are at the top of the file, one per line. List the imports of the
    standard library first, then those of third-party packages, and finally those
    from your own modules. This sample only makes use of the standard library.
  id: totrans-452
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 所有导入语句都位于文件顶部，每行一个。首先列出标准库的导入，然后是第三方包的导入，最后是自己模块的导入。本示例仅使用标准库。
- en: '![](images/00050.jpg)'
  id: totrans-453
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00050.jpg)'
- en: Use capital letters with underscores for constants. Use a maximum line length
    of 79 characters. If possible, take advantage of parentheses, square brackets,
    or curly braces for implicit line breaks.
  id: totrans-454
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用大写字母和下划线表示常量。每行最大长度为 79 个字符。如果可能，利用括号、方括号或大括号进行隐式换行。
- en: '![](images/00067.jpg)'
  id: totrans-455
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00067.jpg)'
- en: Separate classes and functions with two empty lines from the rest of the code.
  id: totrans-456
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将类和函数与代码其余部分用两个空行分开。
- en: '![](images/00058.jpg)'
  id: totrans-457
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00058.jpg)'
- en: Despite the fact that many classes like `datetime` are all lowercase, your own
    classes should use `CapitalizedWords` as names. For more on classes, see [Appendix C](index_split_031.html#filepos1832059).
  id: totrans-458
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尽管像 `datetime` 这样的许多类都是小写的，但您自己的类应使用 `CapitalizedWords` 作为名称。有关类的更多信息，请参阅 [附录 C](index_split_031.html#filepos1832059)。
- en: '![](images/00082.jpg)'
  id: totrans-459
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00082.jpg)'
- en: Inline comments should be separated by at least two spaces from the code. Code
    blocks should be indented by four spaces.
  id: totrans-460
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 行内注释应与代码至少用两个空格分开。代码块应缩进四个空格。
- en: '![](images/00076.jpg)'
  id: totrans-461
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00076.jpg)'
- en: Functions and function arguments should use lowercase names with underscores
    if they improve readability. Don’t use spaces between the argument name and its
    default value.
  id: totrans-462
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 函数和函数参数应使用小写名称，并在提高可读性时使用下划线。不要在参数名和其默认值之间使用空格。
- en: '![](images/00007.jpg)'
  id: totrans-463
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00007.jpg)'
- en: A function’s docstring should also list and explain the function arguments.
    I haven’t done this here to keep the sample short, but you will find complete
    docstrings in the excel.py file that is included in the companion repository and
    that we will meet in [Chapter 8](index_split_020.html#filepos959867).
  id: totrans-464
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 函数的文档字符串还应列出并解释函数参数。为了使示例简短，我没有在此处执行此操作，但在伴随存储库中包含的 excel.py 文件中，您将找到完整的文档字符串，并且我们将在[第
    8 章](index_split_020.html#filepos959867)中遇到它。
- en: '![](images/00015.jpg)'
  id: totrans-465
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00015.jpg)'
- en: Don’t use spaces around the colon.
  id: totrans-466
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在冒号周围不要使用空格。
- en: '![](images/00020.jpg)'
  id: totrans-467
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00020.jpg)'
- en: Use spaces around mathematical operators. If operators with different priorities
    are used, you may consider adding spaces around those with the lowest priority
    only. Since the multiplication in this example has the lowest priority, I have
    added spaces around it.
  id: totrans-468
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在数学运算符周围使用空格。如果使用不同优先级的运算符，可以考虑只在优先级最低的运算符周围添加空格。因为本例中的乘法优先级最低，所以我已经在其周围添加了空格。
- en: '![](images/00025.jpg)'
  id: totrans-469
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00025.jpg)'
- en: Use lowercase names for variables. Make use of underscores if they improve readability.
    When assigning a variable name, use spaces around the equal sign. However, when
    calling a function, don’t use spaces around the equal sign used with keyword arguments.
  id: totrans-470
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对变量使用小写名称。如果使用下划线可以提高可读性，则使用下划线。在赋值变量名时，使用等号周围的空格。但是，在调用带有关键字参数的函数时，不要在等号周围使用空格。
- en: '![](images/00034.jpg)'
  id: totrans-471
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00034.jpg)'
- en: With indexing and slicing, don’t use spaces around the square brackets.
  id: totrans-472
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在索引和切片时，不要在方括号周围使用空格。
- en: This is a simplified summary of PEP 8, so it’s a good idea to have a look at
    the original [PEP 8](https://oreil.ly/3fTTZ) once you start to get more serious
    with Python. PEP 8 clearly states that it is a recommendation and that your own
    style guides will take precedence. After all, consistency is the most important
    factor. If you are interested in other publicly available guidelines, you may
    want to have a look at [Google’s style guide for Python](https://oreil.ly/6sYSa),
    which is reasonably close to PEP 8\. In practice, most Python programmers loosely
    adhere to PEP 8, and ignoring the maximum line length of 79 characters is probably
    the most common sin.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对 PEP 8 的简化总结，因此当你开始更认真地学习 Python 时，建议查看原始的 [PEP 8](https://oreil.ly/3fTTZ)。PEP
    8 明确指出它是一种推荐，并且你自己的风格指南将优先。毕竟，一致性是最重要的因素。如果你对其他公开可用的指南感兴趣，可以看一下 [Google 的 Python
    风格指南](https://oreil.ly/6sYSa)，它与 PEP 8 非常接近。在实践中，大多数 Python 程序员宽松遵守 PEP 8，而忽略最大行长度
    79 字符可能是最常见的错误。
- en: Since it might be difficult to format your code properly while writing it, you
    can have your style checked automatically. The next section shows you how this
    works with VS Code.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在编写代码时可能难以正确格式化代码，因此可以自动检查代码风格。下一节将向您展示如何在 VS Code 中进行此操作。
- en: PEP 8 and VS Code
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: PEP 8 和 VS Code
- en: 'When working with VS Code, there is an easy way to make sure your code sticks
    to PEP 8: use a linter. A linter checks your source code for syntax and style
    errors. Fire up the command palette (Ctrl+Shift+P on Windows or Command-Shift-P
    on macOS) and search for Python: Select Linter. A popular option is flake8, a
    package that comes preinstalled with Anaconda. If enabled, VS Code will underline
    issues with squiggly lines every time you save your file. Hovering over such a
    squiggly line will give you an explanation in a tooltip. You switch a linter off
    again by searching for “Python: Enable Linting” in the command palette and choosing
    “Disable Linting.” If you prefer, you can also run `flake8` on an Anaconda Prompt
    to have a report printed (the command only prints something if there is a violation
    of PEP 8, so running this on pep8_sample.py won’t print anything unless you introduce
    a violation):'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '当使用 VS Code 时，确保你的代码符合 PEP 8 的一种简单方法是使用代码检查工具（linter）。代码检查工具会检查你的源代码是否存在语法和风格错误。在命令面板中启动（Windows
    上为 Ctrl+Shift+P，macOS 上为 Command-Shift-P），搜索 Python: Select Linter。一个常用的选项是 flake8，这是
    Anaconda 预装的一个包。如果启用了代码检查工具，在保存文件时，VS Code 会用波浪线下划线标出问题。将鼠标悬停在波浪线下划线上时，会显示工具提示来解释问题。你可以通过在命令面板中搜索
    “Python: Enable Linting”，选择 “Disable Linting” 来关闭代码检查工具。如果你愿意，也可以在 Anaconda Prompt
    上运行 `flake8` 命令以获取打印的报告（该命令仅在违反 PEP 8 规范时才会打印输出，因此在 pep8_sample.py 上运行时除非引入违规，否则不会打印任何内容）：'
- en: '`(base)>` `cd C:\Users\``username``\python-for-excel` `(base)>` `flake8 pep8_sample.py`'
  id: totrans-477
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`(base)>` `cd C:\Users\``username``\python-for-excel` `(base)>` `flake8 pep8_sample.py`'
- en: Python has recently taken static code analysis a step further by adding support
    for type hints. The next section explains how they work.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: Python最近通过添加对类型提示的支持，将静态代码分析推进了一步。接下来的部分将解释它们是如何工作的。
- en: Type Hints
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提示
- en: 'In VBA, you often see code that prefixes each variable with an abbreviation
    for the data type, like `strEmployeeName` or `wbWorkbookName`. While nobody will
    stop you from doing this in Python, it isn’t commonly done. You also won’t find
    an equivalent to VBA’s `Option Explicit` or `Dim` statement to declare the type
    of a variable. Instead, Python 3.5 introduced a feature called type hints. Type
    hints are also referred to as type annotations and allow you to declare the data
    type of a variable. They are completely optional and have no effect on how the
    code is run by the Python interpreter (there are, however, third-party packages
    like [pydantic](https://oreil.ly/J9W8h) that can enforce type hints at runtime).
    The main purpose of type hints is to allow text editors like VS Code to catch
    more errors before running the code, but they can also improve code autocompletion
    of VS Code and other editors. The most popular type checker for type annotated
    code is mypy, which VS Code offers as a linter. To get a feeling of how type annotations
    work in Python, here is a short sample without type hints:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 在VBA中，你经常会看到每个变量都用数据类型的缩写作为前缀，比如`strEmployeeName`或`wbWorkbookName`。虽然在Python中没有人会阻止你这样做，但这并不常见。你也不会找到类似于VBA的`Option
    Explicit`或`Dim`语句来声明变量的类型。相反，Python 3.5引入了一种称为类型提示的功能。类型提示也被称为类型注解，允许你声明变量的数据类型。它们是完全可选的，并不影响Python解释器运行代码的方式（不过，有第三方包如[pydantic](https://oreil.ly/J9W8h)可以在运行时强制执行类型提示）。类型提示的主要目的是允许像VS
    Code这样的文本编辑器在运行代码之前捕捉更多的错误，而且还可以改善VS Code和其他编辑器的代码自动完成功能。用于类型注解代码的最流行类型检查器是mypy，它作为VS
    Code的一个代码检查工具提供。为了感受类型注解在Python中的工作原理，这里有一个短小的示例，没有类型提示：
- en: '`x``=``1``def``hello``(``name``):``return``f``"Hello {name}!"`'
  id: totrans-481
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`x``=``1``def``hello``(``name``):``return``f``"Hello {name}!"`'
- en: 'And again with type hints:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 再次来看类型提示：
- en: '`x``:``int``=``1``def``hello``(``name``:``str``)``->``str``:``return``f``"Hello
    {name}!"`'
  id: totrans-483
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`x``:``int``=``1``def``hello``(``name``:``str``)``->``str``:``return``f``"Hello
    {name}!"`'
- en: As type hints generally make more sense in bigger codebases, I am not going
    to use them in the remainder of this book.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提示通常在更大的代码库中更有意义，因此在本书的剩余部分我将不会使用它们。
- en: Conclusion
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 结论
- en: 'This chapter was a packed introduction to Python. We met the most important
    building blocks of the language, including data structures, functions, and modules.
    We also touched on some of Python’s particularities like meaningful white space
    and code formatting guidelines, better known as PEP 8\. To continue with this
    book, you won’t need to know all the details: as a beginner, just knowing about
    lists and dictionaries, indexing and slicing, as well as how to work with functions,
    modules, `for` loops, and `if` statements will get you far already.'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是对Python的一个紧凑介绍。我们了解了语言的最重要的构建块，包括数据结构、函数和模块。我们还触及了Python的一些特殊之处，如有意义的空白和代码格式化准则，更为人熟知的是PEP
    8。作为初学者，为了继续学习这本书，你不需要了解所有细节：只需了解列表和字典、索引和切片，以及如何使用函数、模块、`for`循环和`if`语句就可以走得很远。
- en: 'Compared to VBA, I find Python more consistent and powerful but at the same
    time easier to learn. If you are a VBA die-hard fan and this chapter didn’t convince
    you just yet, I am pretty sure the next part will: there, I will give you an introduction
    to array-based calculations before starting our data analysis journey with the
    pandas library. Let’s get started with [Part II](index_split_013.html#filepos433190)
    by learning a few basics about NumPy!'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 与VBA相比，我发现Python更一致和更强大，但同时也更容易学习。如果你是VBA的铁杆粉丝，并且这一章还没能说服你，那么下一部分肯定会：在那里，我将为你介绍基于数组的计算，在我们开始使用pandas库进行数据分析之前。让我们通过学习关于NumPy的一些基础知识来开始[第二部分](index_split_013.html#filepos433190)！
