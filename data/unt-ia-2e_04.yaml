- en: 3 Adding enemies and projectiles to the 3D game
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 向3D游戏添加敌人和弹丸
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Taking aim and firing, both for the player and for enemies
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对准和射击，包括玩家和敌人的射击
- en: Detecting and responding to hits
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测并响应击中
- en: Making enemies that wander around
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制作四处游荡的敌人
- en: Spawning new objects in the scene
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在场景中生成新对象
- en: The movement demo from the previous chapter was pretty cool but still not really
    a game. Let’s turn that movement demo into a first-person shooter. If you think
    about what else we need now, it boils down to the ability to shoot and having
    things to shoot at.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章中的移动演示相当酷，但仍然不是一个真正的游戏。让我们将这个移动演示变成一个第一人称射击游戏。如果你现在考虑我们还需要什么，归结起来就是射击的能力和射击的目标。
- en: First, we’re going to write scripts that enable the player to shoot objects
    in the scene. Then, we’re going to build enemies to populate the scene, including
    code to both wander around aimlessly and react to being hit. Finally, we’re going
    to enable the enemies to fight back, emitting fireballs at the player. None of
    the scripts from chapter 2 need to change; instead, we’ll add scripts to the project—scripts
    that handle the additional features.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将编写脚本，使玩家能够向场景中的对象射击。然后，我们将构建敌人来填充场景，包括四处游荡和被击中时做出反应的代码。最后，我们将使敌人能够反击，向玩家发射火球。第2章中的任何脚本都不需要更改；相反，我们将向项目中添加脚本——处理额外功能的脚本。
- en: 'I’ve chosen a first-person shooter for this project for a couple of reasons.
    One is simply that FPS games are popular: people like shooting games, so let’s
    make a shooting game. A subtler reason has to do with the techniques you’ll learn;
    this project is a great way to learn about several fundamental concepts in 3D
    simulations. For example, shooting games are a great way to teach raycasting.
    In a bit, we’ll get into the specifics of what that is, but for now, you need
    to know only that it’s a useful concept for many tasks in 3D simulations. Although
    raycasting is useful in a wide variety of situations, it just so happens that
    using raycasting makes the most intuitive sense for shooting.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择第一人称射击游戏作为这个项目的几个原因之一。一个简单的原因是FPS游戏很受欢迎：人们喜欢射击游戏，所以让我们做一个射击游戏。一个更微妙的原因与你会学到的技术有关；这个项目是学习3D模拟中几个基本概念的好方法。例如，射击游戏是教授光线投射的绝佳方式。稍后我们将深入了解这是什么，但就现在而言，你需要知道的是，它是一个在3D模拟中许多任务中非常有用的概念。尽管光线投射在许多情况下都很有用，但使用光线投射对于射击来说最直观。
- en: Creating wandering targets to shoot at gives us a great excuse to explore code
    for computer-controlled characters, as well as to use techniques for sending messages
    and spawning objects. In fact, this wandering behavior is another place that raycasting
    is valuable, so we’re already going to be looking at a different application of
    the technique after having first learned about it with shooting. Similarly, the
    approach to sending messages that’s demonstrated in this project is also useful
    elsewhere. In future chapters, you’ll see other applications for these techniques,
    and even within this one project we’ll go over alternative situations.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 创建游荡的目标进行射击为我们提供了一个很好的理由来探索计算机控制角色的代码，以及使用发送消息和生成对象的技巧。实际上，这种游荡行为是光线投射有价值的另一个地方，所以我们将在学习射击后立即查看技术的另一种应用。同样，在这个项目中展示的消息发送方法在其他地方也很有用。在未来的章节中，你将看到这些技术的其他应用，甚至在这个项目中我们也会探讨不同的情境。
- en: 'Ultimately, we’ll approach this project one new feature at a time, with the
    game always playable at every step, but also always feeling like there’s a missing
    part to work on next. This road map breaks the steps into small, understandable
    changes, with only one new feature added at a time:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们将一次添加一个新功能来处理这个项目，游戏在每一步都是可玩的，但同时也总感觉下一部分还有缺失的部分要工作。这个路线图将步骤分解成小而可理解的变化，每次只添加一个新功能：
- en: Write code enabling the player to shoot into the scene.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码使玩家能够向场景中射击。
- en: Create static targets that react to being hit.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建对击中做出反应的静态目标。
- en: Make the targets wander around.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让目标四处游荡。
- en: Spawn the wandering targets automatically.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自动生成游荡的目标。
- en: Enable the targets/enemies to shoot fireballs at the player.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 允许目标/敌人向玩家发射火球。
- en: NOTE This chapter’s project assumes you already have a first-person movement
    demo to build on. We created a movement demo in chapter 2, but if you skipped
    straight to this chapter, you will need to download the sample files for chapter
    2.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本章的项目假设你已经有一个可以在此基础上构建的第一人称移动演示。我们在第 2 章中创建了一个移动演示，但如果你直接跳到了这一章，你需要下载第 2
    章的示例文件。
- en: 3.1 Shooting via raycasts
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 通过射线投射射击
- en: The first new feature to introduce into the 3D demo is shooting. Looking around
    and moving are certainly crucial features for a first-person shooter, but it’s
    not a game until players can affect the simulation and apply their skills. Shooting
    in 3D games can be implemented with a few approaches, and one of the most important
    approaches is raycasting.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在 3D 演示中引入的第一个新功能是射击。环顾四周和移动对于第一人称射击游戏当然是关键功能，但直到玩家可以影响模拟并应用他们的技能之前，这还不是一款游戏。在
    3D 游戏中，射击可以通过几种方法实现，其中最重要的方法之一是射线投射。
- en: 3.1.1 What is raycasting?
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.1 什么是射线投射？
- en: As the name indicates, *raycasting* casts a ray into the scene. Clear, right?
    Well, okay, so what exactly is a ray?
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，*射线投射* 是将射线投射到场景中。清楚了吗？好吧，那么射线究竟是什么？
- en: DEFINITION A *ray* is an imaginary or invisible line in the scene that starts
    at a point of origin and extends out in a specific direction.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 定义：*射线* 是场景中从某一点出发并沿特定方向延伸的想象或不可见线。
- en: 'In raycasting, you create a ray and then determine what intersects it. Figure
    3.1 illustrates the concept. Consider what happens when you fire a bullet from
    a gun: the bullet starts at the position of the gun and then flies forward in
    a straight line until it hits something. A ray is analogous to the path of the
    bullet, and raycasting is analogous to firing the bullet and seeing what it hits.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在射线投射中，你创建一个射线，然后确定它与什么相交。图 3.1 阐述了这一概念。考虑当你从枪中发射子弹时会发生什么：子弹从枪的位置开始，然后沿直线向前飞行，直到击中某个物体。射线与子弹的路径类似，射线投射与发射子弹并查看它击中了什么类似。
- en: '![CH03_F01_Hocking3](../Images/CH03_F01_Hocking3.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![CH03_F01_Hocking3](../Images/CH03_F01_Hocking3.png)'
- en: Figure 3.1 A ray is an imaginary line, and raycasting is finding where that
    line intersects.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 射线是一个想象中的线，射线投射是找到这条线与什么相交。
- en: As you can imagine, the math behind raycasting often gets complicated. Not only
    is it tricky to calculate the intersection of a line with a 3D plane, but you
    need to do that for all polygons of all mesh objects in the scene (remember, a
    *mesh object* is a 3D visual constructed from lots of connected lines and shapes).
    Fortunately, Unity handles the difficult math behind raycasting, but you still
    have to worry about higher-level concerns such as where the ray is being cast
    from and why.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想，射线投射背后的数学通常很复杂。不仅计算一条线与 3D 平面的交点很棘手，而且你还需要对场景中所有网格对象的全部多边形都这样做（记住，*网格对象*
    是由许多连接的线和形状构成的 3D 可视化）。幸运的是，Unity 处理了射线投射背后的困难数学，但你仍然需要担心更高级的问题，比如射线从哪里投射以及为什么。
- en: In this project, the answer to the latter question (why) is to simulate a bullet
    being fired into the scene. For a first-person shooter, the ray generally starts
    at the camera position and then extends out through the center of the camera view.
    In other words, you’re checking for objects straight in front of the camera; Unity
    provides commands to make that task simple. Let’s look at these commands.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，对于后一个问题（为什么）的答案是模拟子弹射入场景。对于第一人称射击游戏，射线通常从摄像机位置开始，然后穿过摄像机视场的中心。换句话说，你正在检查摄像机正前方的物体；Unity
    提供了使这项任务变得简单的命令。让我们看看这些命令。
- en: 3.1.2 Using the ScreenPointToRay command for shooting
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.2 使用 ScreenPointToRay 命令进行射击
- en: You’ll implement shooting by projecting a ray that starts at the camera and
    extends forward through the center of the view. Unity provides the ScreenPointToRay()
    method to perform this action.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你将通过投射从摄像机开始并延伸到视场中心的射线来实现射击。Unity 提供了 ScreenPointToRay() 方法来执行此操作。
- en: Figure 3.2 illustrates what happens when this method is invoked. It creates
    a ray that starts at the camera and projects at an angle, passing through the
    given screen coordinates. Usually, the coordinates of the mouse position are used
    for *mouse picking* (selecting the object under the mouse), but for first-person
    shooting, the center of the screen is used. Once you have a ray, it can be passed
    to the Physics.Raycast() method to perform raycasting using that ray.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 展示了调用此方法时发生的情况。它创建了一个从摄像头开始并投射到角度的射线，通过给定的屏幕坐标。通常，鼠标位置坐标用于 *鼠标拾取*（选择鼠标下的对象），但对于第一人称射击，使用屏幕中心。一旦有了射线，就可以将其传递给
    Physics.Raycast() 方法，使用该射线进行射线投射。
- en: '![CH03_F02_Hocking3](../Images/CH03_F02_Hocking3.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![CH03_F02_Hocking3](../Images/CH03_F02_Hocking3.png)'
- en: Figure 3.2 ScreenPointToRay() projects a ray from the camera through the given
    screen coordinates.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 ScreenPointToRay() 方法从摄像头通过给定的屏幕坐标投射射线。
- en: Let’s write code that uses the methods we just discussed. In Unity, create a
    new C# script, call it RayShooter, attach that script to the camera (not the player
    object), and then write the code from this listing in it.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写使用我们刚才讨论的方法的代码。在 Unity 中，创建一个新的 C# 脚本，命名为 RayShooter，将其附加到摄像头（而不是玩家对象），然后在此列表中编写代码。
- en: Listing 3.1 RayShooter script to attach to the camera
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.1 将附加到摄像头的 RayShooter 脚本
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Access other components attached to the same object.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 访问附加到同一对象的其他组件。
- en: ❷ Respond to the left (first) mouse button.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 响应左（第一个）鼠标按钮。
- en: ❸ The middle of the screen is half its width and height.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 屏幕的中间是其宽度和高度的一半。
- en: ❹ Create the ray at that position by using ScreenPointToRay().
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用 ScreenPointToRay() 在该位置创建射线。
- en: ❺ The raycast fills a referenced variable with information.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 射线投射将信息填充到引用变量中。
- en: ❻ Retrieve coordinates where the ray hit.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 获取射线击中的坐标。
- en: You should note several things in this code listing. First, the Camera component
    is retrieved in Start(), just like the CharacterController in the previous chapter.
    Then, the rest of the code is put in Update() because it needs to check the mouse
    repeatedly, as opposed to just one time. The Input.GetMouseButtonDown() method
    returns true or false, depending on whether the mouse has been clicked, so putting
    that command in a conditional means the enclosed code runs only when the mouse
    has been clicked. You want to shoot when the player clicks the mouse—hence the
    conditional check of the mouse button.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码列表中，你应该注意几个要点。首先，在 Start() 中检索了 Camera 组件，就像上一章中的 CharacterController 一样。然后，将剩余的代码放在
    Update() 中，因为它需要反复检查鼠标，而不是只检查一次。Input.GetMouseButtonDown() 方法返回 true 或 false，取决于鼠标是否被点击，因此将此命令放在条件语句中意味着只有当鼠标被点击时，包含的代码才会运行。你希望在玩家点击鼠标时射击，因此对鼠标按钮进行了条件检查。
- en: A vector is created to define the screen coordinates for the ray (remember that
    a vector is several related numbers stored together). The camera’s pixelWidth
    and pixelHeight values give you the size of the screen, so dividing those values
    in half gives you the center of the screen. Although screen coordinates are 2D,
    with only horizontal and vertical components and no depth, a Vector3 was created
    because ScreenPointToRay() requires that data type (presumably because calculating
    the ray involves arithmetic on 3D vectors). ScreenPointToRay() was called with
    this set of coordinates, resulting in a Ray object (a code object, not a game
    object; the two can be confused sometimes).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了一个向量来定义射线的屏幕坐标（记住向量是一组相关数字存储在一起）。摄像头的 pixelWidth 和 pixelHeight 值给出了屏幕的大小，所以将这些值除以二就得到了屏幕中心。尽管屏幕坐标是二维的，只有水平和垂直分量，没有深度，但创建了一个
    Vector3，因为 ScreenPointToRay() 需要这种数据类型（可能是因为计算射线涉及到 3D 向量的算术）。使用这组坐标调用了 ScreenPointToRay()，结果得到一个
    Ray 对象（一个代码对象，而不是游戏对象；两者有时可能会混淆）。
- en: The ray is then passed to the Raycast() method, but it’s not the only object
    passed in. There’s also a RaycastHit data structure; RaycastHit is a bundle of
    information about the intersection of the ray, including where the intersection
    happened and what object was intersected. The C# syntax out ensures that the data
    structure manipulated within the command is the same object that exists outside
    the command, as opposed to the objects being separate copies in the different
    function scopes.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，射线被传递到 Raycast() 方法，但传递的不仅仅是这个对象。还有一个 RaycastHit 数据结构；RaycastHit 是关于射线交点的信息集合，包括交点发生的位置和被交对象。C#
    语法中的 out 确保在命令中操作的数据结构与命令外存在的对象是相同的，而不是在不同函数作用域中的分离副本。
- en: With those parameters in place, the Physics.Raycast() method can do its work.
    This method checks for intersections with the given ray, fills in data about the
    intersection, and returns true if the ray hit anything. Because a Boolean value
    is returned, this method can be put in a conditional check, just as you used Input.GetMouseButtonDown()
    earlier.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好这些参数后，Physics.Raycast() 方法可以执行其工作。此方法检查给定射线的交点，填充关于交点的数据，并在射线击中任何物体时返回 true。因为返回的是一个布尔值，所以这个方法可以被放入条件检查中，就像你之前使用的
    Input.GetMouseButtonDown() 一样。
- en: For now, the code emits a console message to indicate when an intersection occurred.
    This console message displays the 3D coordinates of the point where the ray hit
    (the x, y, z values we discussed in chapter 2). But it can be hard to visualize
    where exactly the ray hit; similarly, it can be hard to tell where the center
    of the screen is (the location where the ray shoots through). Let’s add visual
    indicators to address both problems.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，代码会发出一个控制台消息来指示何时发生交点。这个控制台消息显示了射线击中的点的 3D 坐标（我们在第 2 章讨论的 x、y、z 值）。但可能很难可视化射线击中的确切位置；同样，也可能很难确定屏幕中心的位置（射线射击通过的位置）。让我们添加视觉指示器来解决这两个问题。
- en: 3.1.3 Adding visual indicators for aiming and hits
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.3 添加瞄准和击中的视觉指示器
- en: 'Our next step is to add two kinds of visual indicators: an aiming spot at the
    center of the screen and a mark in the scene where the ray hit. For a first-person
    shooter, the latter is usually bullet holes, but for now, you’re going to put
    a blank sphere on the spot (and use a coroutine to remove the sphere after 1 second).
    Figure 3.3 shows what you’ll see.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一步是添加两种视觉指示器：屏幕中心的瞄准点和场景中射线击中的标记。对于第一人称射击游戏，后者通常是弹孔，但现在你将在该位置放置一个空白球体（并在
    1 秒后使用协程移除球体）。图 3.3 显示了你将看到的内容。
- en: DEFINITION *Coroutines* are a way of handling tasks that execute incrementally
    over time. In contrast, most functions make the program wait until they finish.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *协程* 是一种处理随时间增量执行的任务的方式。相比之下，大多数函数会让程序等待它们完成。
- en: First, let’s add indicators to mark where the ray hits. Listing 3.2 shows the
    script after making this addition. Run around the scene, shooting; it’s pretty
    fun seeing the sphere indicators!
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们添加指示器来标记射线击中的位置。列表 3.2 显示了添加此功能后的脚本。在场景中四处走动，射击；看到球体指示器非常有趣！
- en: '![CH03_F03_Hocking3](../Images/CH03_F03_Hocking3.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![CH03_F03_Hocking3](../Images/CH03_F03_Hocking3.png)'
- en: Figure 3.3 Shooting repeatedly after adding visual indicators for aiming and
    hits
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 在添加瞄准和击中视觉指示器后重复射击
- en: Listing 3.2 RayShooter script with sphere indicators added
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.2 添加了球体指示器的 RayShooter 脚本
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ This function is mostly the same raycasting code from listing 3.1.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 此函数主要与列表 3.1 中的射线投射代码相同。
- en: ❷ Launch a coroutine in response to a hit.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在击中时启动一个协程。
- en: ❸ Coroutines use IEnumerator functions.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 协程使用 IEnumerator 函数。
- en: ❹ The yield keyword tells coroutines where to pause.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ yield 关键字告诉协程在哪里暂停。
- en: ❺ Remove this GameObject and clear its memory.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 删除此 GameObject 并清除其内存。
- en: The new method is SphereIndicator(), plus a one-line modification in the existing
    Update() method. This method creates a sphere at a point in the scene and then
    removes that sphere a second later. Calling SphereIndicator() from the raycasting
    code ensures that there will be visual indicators showing exactly where the ray
    hit. This function is defined with IEnumerator, and that type is tied in with
    the concept of coroutines.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 新的方法是 SphereIndicator()，以及在现有的 Update() 方法中的一行修改。此方法在场景中的某个点创建一个球体，然后在第二秒后移除该球体。从射线投射代码中调用
    SphereIndicator() 确保会有视觉指示器显示射线击中的确切位置。此函数使用 IEnumerator 定义，该类型与协程的概念相关联。
- en: Technically, coroutines aren’t asynchronous (asynchronous operations don’t stop
    the rest of the code from running; think of downloading an image in the script
    of a website), but through clever use of enumerators, Unity makes coroutines behave
    similarly to asynchronous functions. The secret sauce in coroutines is the yield
    keyword; that keyword causes the coroutine to temporarily pause, handing back
    the program flow and picking up again from that point in the next frame. In this
    way, coroutines seemingly run in the background of a program, through a repeated
    cycle of running partway and then returning to the rest of the program.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，协程不是异步的（异步操作不会停止其他代码的运行；想想在网站脚本的下载图像），但通过巧妙地使用枚举器，Unity使协程的行为类似于异步函数。协程的秘密在于yield关键字；该关键字使协程暂时暂停，将程序流程交回，并在下一帧从该点继续。这样，协程似乎在程序的背景中运行，通过部分运行然后返回到程序其余部分的重复循环。
- en: 'As the name indicates, StartCoroutine() sets a coroutine in motion. Once a
    coroutine is started, it keeps running until the function is finished; it pauses
    along the way. Note the subtle but significant point that the method passed to
    StartCoroutine() has a set of parentheses following the name: this syntax means
    you’re calling that function, as opposed to passing its name. The called function
    runs until it hits a yield command, at which point the function pauses.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，StartCoroutine()使协程开始运行。一旦协程开始，它就会一直运行直到函数完成；在运行过程中会暂停。注意一个微妙但重要的点，即传递给StartCoroutine()的方法名后有括号：这种语法意味着你正在调用该函数，而不是传递其名称。被调用的函数会一直运行，直到遇到yield命令，此时函数会暂停。
- en: 'SphereIndicator() creates a sphere at a specific point, pauses for the yield
    statement, and then destroys the sphere after the coroutine resumes. The length
    of the pause is controlled by the value returned at yield. A few types of return
    values work in coroutines, but the most straightforward is to return a specific
    length of time to wait. Returning WaitForSeconds(1) causes the coroutine to pause
    for 1 second. Create a sphere, pause for 1 second, and then destroy the sphere:
    that sequence sets up a temporary visual indicator.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: SphereIndicator() 在特定位置创建一个球体，暂停以等待yield语句，然后在协程恢复后销毁球体。暂停的长度由yield返回的值控制。在协程中有几种类型的返回值可以工作，但最直接的是返回要等待的具体时间长度。返回WaitForSeconds(1)会使协程暂停1秒。创建一个球体，暂停1秒，然后销毁球体：这个序列设置了一个临时的视觉指示器。
- en: Listing 3.2 gave you indicators to mark where the ray hits. But you also want
    an aiming spot in the center of the screen.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.2 给了你标记射线击中位置的指示器。但你还需要在屏幕中央有一个瞄准点。
- en: Listing 3.3 Visual indicator for aiming
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.3 瞄准视觉指示器
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Hide the mouse cursor at the center of the screen.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将鼠标光标隐藏在屏幕中央。
- en: ❷ This is just the rough size of this font.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 这只是这个字体的大致大小。
- en: ❸ The GUI.Label() command displays text onscreen.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ GUI.Label()命令在屏幕上显示文本。
- en: Another new method has been added to the RayShooter class, called OnGUI(). Unity
    comes with both a basic and more advanced UI system. Because the basic system
    has a lot of limitations, we’ll build a more flexible advanced UI in future chapters,
    but for now, it’s much easier to display a point in the center of the screen by
    using the basic UI. Much like Start() and Update(), every MonoBehaviour automatically
    responds to an OnGUI() method. That function runs every frame right after the
    3D scene is rendered, resulting in everything drawn during OnGUI() appearing on
    top of the 3D scene (imagine stickers applied to a painting of a landscape).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: RayShooter类中已添加了一种新的方法，称为OnGUI()。Unity自带了一个基本的和更高级的UI系统。由于基本系统有很多限制，我们将在未来的章节中构建一个更灵活的高级UI，但到目前为止，使用基本UI在屏幕中央显示一个点要容易得多。与Start()和Update()类似，每个MonoBehaviour都会自动响应OnGUI()方法。该函数在3D场景渲染后每帧运行一次，导致在OnGUI()期间绘制的所有内容都显示在3D场景之上（想象在风景画上贴上贴纸）。
- en: DEFINITION *Render* is the action of the computer drawing the pixels of the
    3D scene. Although the scene is defined using x-, y-, and z-coordinates, the actual
    display on your monitor is a 2D grid of colored pixels. To display the 3D scene,
    the computer needs to calculate the color of all the pixels in the 2D grid; running
    that algorithm is referred to as *rendering*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *渲染* 是计算机绘制3D场景像素的动作。尽管场景是用x、y和z坐标定义的，但你在显示器上实际看到的是彩色像素的二维网格。为了显示3D场景，计算机需要计算二维网格中所有像素的颜色；运行该算法被称为
    *渲染*。
- en: Inside OnGUI(), the code defines 2D coordinates for the display (shifted slightly
    to account for the size of the label) and then calls GUI.Label(). That method
    displays a text label. Because the string passed to the label is an asterisk (*),
    you end up with that character displayed in the center of the screen. Now it’s
    much easier to aim in our nascent FPS game!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在OnGUI()内部，代码定义了显示的2D坐标（稍微调整以考虑标签的大小），然后调用GUI.Label()。该方法显示一个文本标签。因为传递给标签的字符串是一个星号(*)，所以你会在屏幕中央看到这个字符。现在在我们的初生FPS游戏中瞄准要容易得多！
- en: Listing 3.3 also adds cursor settings to the Start() method. All that’s happening
    is that the values are being set for cursor visibility and locking. The script
    will work perfectly fine if you omit the cursor values, but these settings make
    first-person controls work a bit more smoothly. The mouse cursor will stay in
    the center of the screen, and to avoid cluttering the view, will turn invisible
    and will reappear only when you press Esc.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.3 还将光标设置添加到Start()方法中。所发生的一切只是设置了光标可见性和锁定状态的值。如果你省略光标值，脚本仍然可以完美工作，但这些设置使得第一人称控制工作得更加顺畅。鼠标光标将保持在屏幕中央，为了避免视图杂乱，光标将变为不可见，并且只有在按下Esc键时才会重新出现。
- en: WARNING Always remember that you can press Esc to unlock the mouse cursor in
    order to move it away from the middle of the Game view. While the mouse cursor
    is locked, it’s impossible to click the Play button and stop the game.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：始终记住，你可以按Esc键解锁鼠标光标，以便将其从游戏视图的中间移开。当鼠标光标被锁定时，无法点击播放按钮并停止游戏。
- en: That wraps up the first-person shooting code . . . well, that wraps up the player’s
    end of the interaction, anyway, but we still need to take care of targets.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了第一人称射击代码……好吧，至少完成了交互的玩家端，但我们仍然需要处理目标。
- en: 3.2 Scripting reactive targets
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 编写响应式目标脚本
- en: Being able to shoot is all well and good, but at the moment, players don’t have
    anything to shoot at. We’re going to create a target object and give it a script
    that will respond to being hit. Or rather, we’ll slightly modify the shooting
    code to notify the target when hit, and then the script on the target will react
    when notified.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 能够射击固然很好，但截至目前，玩家没有任何东西可以射击。我们将创建一个目标物体，并给它一个响应被击中的脚本。或者更确切地说，我们将稍微修改射击代码，以便在击中目标时通知目标，然后目标上的脚本会在收到通知时做出反应。
- en: 3.2.1 Determining what was hit
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.1 确定被击中的物体
- en: First, you need to create a new object to shoot at. Create a new cube object
    (GameObject > 3D Object > Cube) and then scale it up vertically by setting the
    Y scale to 2 and leaving X and Z at 1. Position the new object at 0, 1, 0 to put
    it on the floor in the middle of the room, and name the object Enemy.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要创建一个新的射击目标。创建一个新的立方体对象（GameObject > 3D Object > Cube），然后将Y缩放设置为2，将X和Z保持为1。将新物体放置在0,
    1, 0的位置，使其位于房间中央的地板上，并将物体命名为Enemy。
- en: Create a new script called ReactiveTarget and attach that to the newly created
    box. Soon, you’ll write code for this script, but leave it as the default for
    now; you’re creating this script file ahead of time because the next code listing
    requires it to exist in order to compile.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为ReactiveTarget的新脚本，并将其附加到新创建的盒子。很快，你将为这个脚本编写代码，但现在先让它保持默认设置；你提前创建这个脚本文件，因为下一个代码列表需要它存在才能编译。
- en: Go back to RayShooter and modify the raycasting code according to the following
    listing. Run the new code and shoot the new target; debug messages appear in the
    console instead of sphere indicators in the scene.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 返回RayShooter并按照以下列表修改射线投射代码。运行新代码并射击新目标；调试信息将出现在控制台而不是场景中的球体指示器。
- en: Listing 3.4 Detecting whether the target object was hit
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.4 检测目标物体是否被击中
- en: '[PRE3]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Retrieve the object the ray hit.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 检索射线击中的物体。
- en: ❷ Check for the ReactiveTarget component on the object.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 检查物体上的ReactiveTarget组件。
- en: Notice that you retrieve the object from RaycastHit, just as the coordinates
    were retrieved for the sphere indicators. Technically, the hit information doesn’t
    return the game object hit; it indicates the Transform component hit. You can
    then access gameObject as a property of transform.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你从RaycastHit中检索物体，就像检索球体指示器的坐标一样。技术上，击中信息并不返回被击中的游戏对象；它指示被击中的Transform组件。然后你可以通过transform属性访问gameObject。
- en: Then, you use the GetComponent()method on the object to check whether it’s a
    reactive target (that is, whether it has the ReactiveTarget script attached).
    As you saw previously, that method returns components of a specific type that
    are attached to the GameObject. If no component of that type is attached to the
    object, GetComponent() won’t return anything. You check whether null was returned
    and run different code in each case.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你使用GetComponent()方法在对象上检查它是否是反应性目标（即是否附加了ReactiveTarget脚本）。正如你之前看到的，该方法返回附加到GameObject上的特定类型的组件。如果没有附加该类型的组件，GetComponent()不会返回任何内容。你检查是否返回了null，并在每种情况下运行不同的代码。
- en: If the hit object is a reactive target, the code emits a debug message instead
    of starting the coroutine for sphere indicators. Now let’s inform the target object
    about the hit so it can react.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果被击中的物体是反应性目标，代码将发出调试信息而不是启动球体指示器的协程。现在让我们通知目标物体它被击中，以便它能够做出反应。
- en: 3.2.2 Alerting the target that it was hit
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.2 通知目标它被击中
- en: All that’s needed in the code is a one-line change, as shown next.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中只需要一行更改，如下所示。
- en: Listing 3.5 Sending a message to the target object
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.5 向目标对象发送消息
- en: '[PRE4]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Call a method of the target instead of just emitting the debug message.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 调用目标的方法而不是仅仅发出调试信息。
- en: Now the shooting code calls a method of the target, so let’s write that target
    method. In the ReactiveTarget script, write in the code from the next listing.
    The target object will fall over and disappear when you shoot it; refer to figure
    3.4.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，射击代码调用目标的方法，因此让我们编写那个目标方法。在ReactiveTarget脚本中，编写下一列表中的代码。当你射击目标物体时，目标物体会倾倒并消失；参见图3.4。
- en: Listing 3.6 ReactiveTarget script that dies when hit
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.6 当被击中时死亡的ReactiveTarget脚本
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Method called by the shooting script
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 被射击脚本调用的方法
- en: ❷ Topple the enemy, wait 1.5 seconds, and then destroy the enemy.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 推倒敌人，等待1.5秒，然后摧毁敌人。
- en: ❸ A script can destroy itself (just as it could a separate object).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 一个脚本可以销毁自己（就像它可以销毁一个单独的对象一样）。
- en: Most of this code should be familiar to you from previous scripts, so we’ll
    go over it only briefly. First, you define the ReactToHit()method, because that’s
    the method name called in the shooting script. This method starts a coroutine
    that’s similar to the sphere indicator code from earlier; the main difference
    is that it operates on the object of this script rather than creating a separate
    object. Expressions like this.gameObject refer to the GameObject that this script
    is attached to (and the this keyword is optional, so code could refer to gameObject
    without anything in front of it).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的大部分内容你应该已经从之前的脚本中熟悉了，所以我们只会简要地介绍它。首先，你定义ReactToHit()方法，因为这是射击脚本中调用的方法名。这个方法启动一个与之前球体指示器代码相似的协程；主要区别在于它操作的是这个脚本的对象，而不是创建一个单独的对象。像this.gameObject这样的表达式指的是这个脚本附加到的GameObject（this关键字是可选的，因此代码可以不带有任何内容地引用gameObject）。
- en: The first line of the coroutine function makes the object tip over. As discussed
    in chapter 2, rotations can be defined as an angle around each of the three coordinate
    axes, x, y, and z. Because we don’t want the object to rotate side to side, leave
    Y and Z as 0 and assign an angle to the X rotation.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 协程函数的第一行使物体倾倒。正如在第2章中讨论的那样，旋转可以定义为围绕每个坐标轴x、y和z的角度。因为我们不希望物体左右旋转，所以将Y和Z设置为0，并给X旋转分配一个角度。
- en: '![CH03_F04_Hocking3](../Images/CH03_F04_Hocking3.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![CH03_F04_Hocking3](../Images/CH03_F04_Hocking3.png)'
- en: Figure 3.4 The target object falling over when hit
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 目标物体被击中后倾倒
- en: NOTE The transform is applied instantly, but you may prefer seeing the movement
    when objects topple over. Once you start looking beyond this book for more advanced
    topics, you might want to look up *tweens*, systems used to make objects move
    smoothly over time.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：变换是即时应用的，但你可能更喜欢看到物体倾倒时的移动。一旦你开始寻找这本书之外的更高级主题，你可能想查找*tweens*，这是一种用于使物体在一段时间内平滑移动的系统。
- en: The second line of the method uses the yield keyword that’s so significant to
    coroutines, pausing the function there and returning the number of seconds to
    wait before resuming. Finally, the game object destroys itself in the last line
    of the function. Destroy(this.gameObject) is called after the wait time, just
    as the code called Destroy(sphere) before.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 方法中的第二行使用了协程至关重要的yield关键字，暂停函数在此处并返回在恢复之前需要等待的秒数。最后，游戏对象在函数的最后一行销毁自己。Destroy(this.gameObject)在等待时间后调用，就像代码在之前调用Destroy(sphere)一样。
- en: WARNING Be sure to call Destroy() on this.gameObject and not simply this! Don’t
    get confused between the two; this refers only to this script component, whereas
    this.gameObject refers to the object the script is attached to.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：务必在this.gameObject上调用Destroy()，而不是简单地调用this！不要混淆这两个；this仅指代此脚本组件，而this.gameObject指代脚本附加到的对象。
- en: The target now reacts to being shot—great! But it doesn’t do anything else on
    its own, so let’s add more behavior to make this target a proper enemy character.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 目标现在对被射击做出反应——太好了！但它自己不做任何事情，所以让我们添加更多行为，使这个目标成为一个合适的敌人角色。
- en: 3.3 Basic wandering AI
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 基本游荡型AI
- en: A static target isn’t terribly interesting, so let’s write code that’ll make
    the enemy wander around. Code for wandering around is pretty much the simplest
    example of artificial intelligence (AI), or computer-controlled entities. In this
    case, the entity is an enemy in a game, but it could also be a robot in the real
    world or a voice that plays chess, for example.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一个静态目标并不特别有趣，所以让我们编写代码让敌人四处游荡。游荡的代码几乎是人工智能（AI）或计算机控制实体的最简单例子。在这种情况下，实体是游戏中的敌人，但它也可能是现实世界中的机器人，或者是一个下棋的声音，例如。
- en: 3.3.1 Diagramming how basic AI works
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.1 绘制基本AI的工作原理图
- en: Multiple approaches to AI exist (seriously, AI is a major area of research for
    computer scientists). For our purposes, we’ll stick with a simple one. As you
    become more experienced and your games get more sophisticated, you’ll probably
    want to explore the various approaches to AI.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 存在多种AI实现方法（实际上，AI是计算机科学家研究的主要领域）。就我们的目的而言，我们将坚持使用一种简单的方法。随着你变得更加熟练，你的游戏变得更加复杂，你可能想要探索各种AI实现方法。
- en: Figure 3.5 depicts the basic process. In every frame, the AI code will scan
    around its environment to determine whether it needs to react. If an obstacle
    appears in its way, the enemy turns to face a different direction. Regardless
    of whether the enemy needs to turn, it will always move forward steadily. As such,
    the enemy will ping-pong around the room, always moving forward and turning to
    avoid walls.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5展示了基本过程。在每一帧中，AI代码将扫描其环境以确定是否需要做出反应。如果出现障碍物，敌人会转向面对不同的方向。无论敌人是否需要转向，它都会始终稳步前进。因此，敌人会在房间内来回弹跳，始终前进并转向以避开墙壁。
- en: '![CH03_F05_Hocking3](../Images/CH03_F05_Hocking3.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![CH03_F05_Hocking3](../Images/CH03_F05_Hocking3.png)'
- en: 'Figure 3.5 Basic AI: cyclical process of moving forward and avoiding obstacles'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 基本AI：前进和避开障碍物的循环过程
- en: The code will look pretty familiar, because it moves enemies forward by using
    the same commands as moving the player forward. The AI code will also use raycasting,
    similar to, but in a different context from, shooting.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 代码看起来相当熟悉，因为它通过使用与移动玩家前进相同的命令来推动敌人前进。AI代码也将使用射线投射，类似于射击，但应用在不同的上下文中。
- en: 3.3.2 “Seeing” obstacles with a raycast
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.2 使用射线投射“看到”障碍物
- en: As you saw in the introduction to this chapter, raycasting is a technique that’s
    useful for multiple tasks within 3D simulations. One easily grasped task is shooting,
    but another task raycasting can be useful for is scanning around the scene. Given
    that scanning around the scene is a step in AI code, that means raycasting is
    used in AI code.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在本章引言中看到的，射线投射是3D模拟中用于多个任务的技术。一个容易理解的任务是射击，但射线投射还可以用于另一个任务，即扫描场景。鉴于扫描场景是AI代码中的一步，这意味着射线投射被用于AI代码中。
- en: Earlier, you created a ray that originated from the camera, because that’s where
    the player was looking from. This time, you’ll create a ray that originates from
    the enemy. The first ray shot out through the center of the screen, but this time
    the ray will shoot forward in front of the character; figure 3.6 illustrates this.
    Then, just as the shooting code used RaycastHit information to determine whether
    anything was hit and where, the AI code will use RaycastHit information to determine
    whether anything is in front of the enemy and, if so, how far away.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，你创建了一个从摄像机出发的射线，因为玩家就是从那里看的。这次，你将创建一个从敌人出发的射线。第一个射线从屏幕中心射出，但这次射线将在角色前方射出；图3.6展示了这一点。然后，就像射击代码使用RaycastHit信息来确定是否击中了什么以及在哪里一样，AI代码将使用RaycastHit信息来确定敌人前方是否有物体，如果有，距离有多远。
- en: '![CH03_F06_Hocking3](../Images/CH03_F06_Hocking3.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![CH03_F06_Hocking3](../Images/CH03_F06_Hocking3.png)'
- en: Figure 3.6 Using raycasting to “see” obstacles
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 使用射线投射“看到”障碍物
- en: One difference between raycasting for shooting and raycasting for AI is the
    radius of the ray. For shooting, the ray was treated as infinitely thin, but for
    AI, the ray will be treated as having a large cross section. In terms of the code,
    this means using the SphereCast()method instead of Raycast(). The reason for this
    difference is that bullets are tiny, whereas checking for obstacles in front of
    the character requires us to account for the width of the character.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 射线追踪用于射击和用于AI的射线追踪之间的一个区别是射线的半径。对于射击，射线被视为无限薄的，但对于AI，射线将被视为具有很大的横截面积。从代码的角度来看，这意味着使用SphereCast()方法而不是Raycast()方法。这种差异的原因是子弹很小，而检查角色前方是否有障碍物需要我们考虑角色的宽度。
- en: Create a new script called WanderingAI, attach that to the target object (alongside
    the ReactiveTarget script), and write the code from the next listing. Play the
    scene now and you should see the enemy wandering around the room; you can still
    shoot the target, and it will react the same way as before.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的脚本名为WanderingAI，将其附加到目标对象（与ReactiveTarget脚本一起），并编写下一列表中的代码。现在播放场景，你应该看到敌人正在房间内徘徊；你仍然可以射击目标，它将以与之前相同的方式做出反应。
- en: Listing 3.7 Basic WanderingAI script
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.7基本WanderingAI脚本
- en: '[PRE6]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Values for the speed of movement and the distance at which to react to obstacles
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 移动速度和反应障碍物的距离的值
- en: ❷ Move forward continuously every frame, regardless of turning.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 每一帧都持续向前移动，无论转向与否。
- en: ❸ A ray at the same position and pointing in the same direction as the character
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 与角色在同一位置且指向同一方向的射线
- en: ❹ Perform raycasting with a circular volume around the ray.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在射线周围进行圆形体积的射线追踪。
- en: ❺ Turn toward a semi-random new direction.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 向一个半随机的新方向转向。
- en: This listing adds a couple of variables to represent the speed of movement and
    the distance at which the AI reacts to obstacles. Then, transform.Translate()
    is added in the Update() method to move forward continuously (including the use
    of deltaTime for frame rate-independent movement). In Update(), you’ll also see
    raycasting code that looks a lot like the shooting script from earlier; again,
    the same technique of raycasting is being used here to see instead of shoot. The
    ray is created using the enemy’s position and direction, instead of using the
    camera.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表添加了几个变量来表示移动速度和AI对障碍物做出反应的距离。然后，在Update()方法中添加transform.Translate()以实现持续向前移动（包括使用deltaTime进行帧率无关的运动）。在Update()中，你还会看到与之前射击脚本非常相似的射线追踪代码；再次，这里使用相同的射线追踪技术来观察而不是射击。射线是通过使用敌人的位置和方向创建的，而不是使用相机。
- en: As explained earlier, the raycasting calculation is done using the Physics.SphereCast()
    method. This method takes a radius parameter to determine how far around the ray
    to detect intersections, but in every other respect, it’s exactly the same as
    Physics.Raycast(). This similarity includes how the command fills in hit information,
    checks for intersections just as before, and uses the distance property to be
    sure to react only when the enemy gets near an obstacle (as opposed to a wall
    across the room).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，射线追踪计算是通过Physics.SphereCast()方法完成的。此方法使用半径参数来确定要检测射线周围多远处的交点，但在其他所有方面，它与Physics.Raycast()方法完全相同。这种相似性包括命令如何填充击中信息，如何检查交点，以及如何使用距离属性确保只有在敌人接近障碍物时才做出反应（而不是房间对面的墙壁）。
- en: When the enemy has a nearby obstacle right in front of it, the code rotates
    the character a semi-random amount toward a new direction. I say *semi-random*
    because the values are constrained to the minimum and maximum values that make
    sense for this situation. Specifically, we use the Random.Range() method, which
    Unity provides for obtaining a random value between constraints. In this case,
    the constraints were just slightly beyond an exact left or right turn, allowing
    the character to turn sufficiently to avoid obstacles.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当敌人前方有障碍物时，代码会以半随机的方式旋转角色到一个新的方向。我说“半随机”是因为这些值被限制在这个情况下有意义的最大和最小值。具体来说，我们使用了Unity提供的Random.Range()方法来获取一个在约束之间的随机值。在这种情况下，约束略超过一个精确的左转或右转，允许角色足够地转向以避开障碍物。
- en: 3.3.3 Tracking the character’s state
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.3 跟踪角色的状态
- en: One oddity of the current behavior is that the enemy keeps moving forward after
    falling over from being hit. That’s because, right now, the Translate() method
    runs every frame no matter what. Let’s make small adjustments to the code to keep
    track of whether the character is alive—or to put it in another (more technical)
    way, we want to track the alive state of the character.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当前行为的一个奇怪之处在于，敌人被击中后倒下后仍然继续向前移动。这是因为，目前，Translate()方法每帧都会运行，无论发生什么。让我们对代码进行一些小的调整，以跟踪角色是否存活——或者用另一种（更技术性的）方式来说，我们想要跟踪角色的存活状态。
- en: Having the code keep track of and respond differently to the current state of
    the object is a common code pattern in many areas of programming, not just AI.
    More sophisticated implementations of this approach are referred to as *state
    machines*, or possibly even *finite-state machines*.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让代码跟踪并针对对象的当前状态做出不同的响应是编程许多领域的常见代码模式，而不仅仅是AI。这种方法的更复杂实现被称为*状态机*，甚至可能是*有限状态机*。
- en: DEFINITION A *finite-state machine* (*FSM*) is a code structure in which the
    current state of the object is tracked, well-defined transitions exist between
    states, and the code behaves differently based on the state.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 定义：一个*有限状态机*（FSM）是一种代码结构，其中跟踪对象的当前状态，状态之间存在明确的转换，并且代码根据状态的不同而表现不同。
- en: We’re not going to implement a full FSM, but it’s no coincidence that a common
    place to see the initials *FSM* is in discussions of AI. A full FSM would have
    many states for the many behaviors of a sophisticated AI application, but in this
    basic AI, we need to track only whether the character is alive. The next listing
    adds a Boolean value, isAlive, toward the top of the script, and the code needs
    occasional conditional checks of that value. With those checks in place, the movement
    code runs only while the enemy is alive.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会实现完整的FSM，但也不是巧合，*FSM*的缩写经常出现在AI讨论中。完整的FSM会有许多状态，对应于复杂AI应用的各种行为，但在这个基本的AI中，我们只需要跟踪角色是否存活。接下来的列表在脚本顶部添加了一个布尔值isAlive，并且代码需要偶尔对该值进行条件检查。有了这些检查，只有当敌人存活时，移动代码才会运行。
- en: Listing 3.8 WanderingAI script with alive state added
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.8 添加了存活状态的WanderingAI脚本
- en: '[PRE7]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Boolean value to track whether the enemy is alive
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 跟踪敌人是否存活的布尔值
- en: ❷ Initialize that value.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 初始化该值。
- en: ❸ Move only if the character is alive.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 只有当角色存活时才移动。
- en: ❹ Public method allowing outside code to affect the “alive” state
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 公共方法，允许外部代码影响“存活”状态
- en: The ReactiveTarget script can now tell the WanderingAI script whether the enemy
    is alive.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ReactiveTarget脚本现在可以告诉WanderingAI脚本敌人是否存活。
- en: Listing 3.9 ReactiveTarget tells WanderingAI when it dies
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.9 ReactiveTarget在死亡时通知WanderingAI
- en: '[PRE8]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Check if this character has a WanderingAI script; it might not.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 检查这个角色是否有WanderingAI脚本；可能没有。
- en: AI code structure
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: AI代码结构
- en: The AI code in this chapter is contained within a single class so that learning
    and understanding it is straightforward. This code structure is perfectly fine
    for simple AI needs, so don’t be afraid that you’ve done something wrong and that
    a more complex code structure is an absolute requirement. For more complex AI
    needs (such as a game with a wide variety of highly intelligent characters), a
    more robust code structure can help facilitate developing the AI.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的AI代码包含在一个单独的类中，这样学习和理解它就变得简单直接。这种代码结构对于简单的AI需求来说非常合适，所以不要担心你做错了什么，或者更复杂的代码结构是绝对必要的。对于更复杂的AI需求（例如具有多种高度智能角色的游戏），更健壮的代码结构可以帮助促进AI的开发。
- en: As alluded to in chapter 1’s example for composition versus inheritance, sometimes
    you’ll want to split chunks of the AI into separate scripts. Doing so will enable
    you to mix and match components, generating unique behavior for each character.
    Think about the similarities and differences among your characters, and those
    differences will guide you as you design your code architecture. For example,
    if your game has some enemies that move by charging headlong at the player and
    some that slink around in the shadows, you may want to make Locomotion a separate
    component. Then you can create scripts for both LocomotionCharge and LocomotionSlink,
    and use different Locomotion components on different enemies.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 正如第一章中关于组合与继承的例子所暗示的，有时你可能想要将 AI 的某些部分拆分到单独的脚本中。这样做将使你能够混合和匹配组件，为每个角色生成独特的行为。考虑一下你角色之间的相似性和差异性，这些差异将指导你设计代码架构。例如，如果你的游戏中有一些敌人会冲向玩家移动，而另一些则会在阴影中潜行，你可能想要将移动（Locomotion）作为一个独立的组件。然后你可以为
    LocomotionCharge 和 LocomotionSlink 创建脚本，并在不同的敌人上使用不同的移动组件。
- en: The exact AI code structure you want depends on the design of your specific
    game; there’s no one right way to do it. Unity makes it easy to design flexible
    code architectures like this.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要的精确 AI 代码结构取决于你特定游戏的设计；没有一种正确的方法来做这件事。Unity 使设计这种灵活的代码架构变得容易。
- en: 3.4 Spawning enemy prefabs
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 生成敌人预制件
- en: At the moment, only one enemy is in the scene, and when it dies, the scene is
    empty. Let’s make the game spawn enemies so that whenever the enemy dies, a new
    one appears. This is easily done in Unity by using prefabs.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 目前场景中只有一个敌人，当它死亡时，场景为空。让我们让游戏生成敌人，以便每当敌人死亡时，就会有一个新的敌人出现。在 Unity 中，这可以通过使用预制件轻松完成。
- en: 3.4.1 What is a prefab?
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.1 什么是预制件？
- en: Prefabs are a flexible approach to visually defining interactive objects. In
    a nutshell, a *prefab* is a fully fleshed-out game object (with components already
    attached and set up) that doesn’t exist in any specific scene but rather exists
    as an asset that can be copied into any scene.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 预制件是一种灵活的方法来视觉化定义交互对象。简而言之，一个*预制件*是一个完全 fleshed-out 游戏对象（已附加并设置好组件），它并不存在于任何特定的场景中，而是作为一个可以复制到任何场景的资产。
- en: This copying can be done manually, to ensure that the enemy object (or other
    prefab) is the same in every scene. More importantly, though, prefabs can also
    be spawned from code; you can place copies of the object into the scene by using
    commands in scripts and not only by doing so manually in the visual editor.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这种复制可以手动完成，以确保敌人对象（或其他预制件）在每一个场景中都是相同的。更重要的是，预制件也可以从代码中生成；你可以通过在脚本中使用命令将对象的副本放置到场景中，而不仅仅是通过在视觉编辑器中手动操作。
- en: DEFINITION An *asset* is any file that shows up in the Project view; these could
    be 2D images, 3D models, code files, scenes, and so on. I mentioned this term
    briefly in chapter 1 but didn’t emphasize it until now.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 定义：*资产*是任何在项目视图中出现的文件；这些可以是 2D 图像、3D 模型、代码文件、场景等等。我在第一章中简要提到了这个术语，但直到现在才强调它。
- en: 'A copy of a prefab is called an *instance*, analogous to *instance* referring
    to a specific code object created from a class. Try to keep the terminology straight:
    *prefab* refers to the game object existing outside of any scene; *instance* refers
    to a copy of the object that’s placed in a scene.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 预制件的副本称为*实例*，类似于*实例*指的是从类中创建的特定代码对象。尽量保持术语的一致性：*预制件*指的是存在于任何场景之外的游戏对象；*实例*指的是放置在场景中的对象的副本。
- en: DEFINITION Also analogous to object-oriented terminology, *instantiate* is the
    action of creating an instance.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 定义：与面向对象术语类似，*实例化*是指创建一个实例的动作。
- en: 3.4.2 Creating the enemy prefab
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.2 创建敌人预制件
- en: To create a prefab, first create an object in the scene that will become the
    prefab. Because our enemy object will become a prefab, we’ve already done this
    first step. Now all we do is drag the object down from the Hierarchy view and
    drop it in the Project view; this will automatically save the object as a prefab
    (see figure 3.7).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建预制件，首先在场景中创建一个将成为预制件的对象。因为我们的敌人对象将成为预制件，所以我们已经完成了第一步。现在我们只需将对象从层次结构视图拖动下来，并将其放入项目视图中；这将自动将该对象保存为预制件（见图
    3.7）。
- en: '![CH03_F07_Hocking3](../Images/CH03_F07_Hocking3.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![CH03_F07_Hocking3](../Images/CH03_F07_Hocking3.png)'
- en: Figure 3.7 Drag objects from Hierarchy to Project to create prefabs.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 从层次结构拖动对象到项目以创建预制件。
- en: Back in the Hierarchy view, the original object’s name will turn blue to signify
    that it’s now linked to a prefab. We don’t actually want the object in the scene
    anymore (we’re going to spawn the prefab, not use the instance already in the
    scene), so delete the enemy object now. If you want to edit the prefab further,
    just double-click the prefab in the Project view to open it and then click the
    back arrow at the top left of the Hierarchy view to close it again.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在层次结构视图中，原始对象的名称将变为蓝色，以表示它现在已链接到预制件。我们实际上不再需要场景中的对象（我们将生成预制件，而不是使用场景中已经存在的实例），所以现在删除敌人对象。如果你想进一步编辑预制件，只需在项目视图中双击预制件以打开它，然后点击层次结构视图左上角的返回箭头再次关闭它。
- en: WARNING The interface for working with prefabs has improved a lot since earlier
    versions of Unity, but editing prefabs can still cause confusion. For example,
    you are not technically in any scene after you double-click a prefab, so remember
    to click the back arrow in the Hierarchy view when you are done editing the prefab.
    In addition, if you nest prefabs (so that one prefab contains other prefabs),
    working with them can get confusing.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: WARNING 自从Unity的早期版本以来，处理预制件的接口已经得到了很大的改进，但编辑预制件仍然可能引起混淆。例如，当你双击一个预制件后，你实际上并不在任何一个场景中，所以当你完成编辑预制件后，记得在层次结构视图中点击返回箭头。此外，如果你嵌套预制件（即一个预制件包含其他预制件），使用它们可能会变得令人困惑。
- en: Now we have the actual prefab object to spawn in the scene, so let’s write code
    to create instances of the prefab.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了实际要生成到场景中的预制件对象，所以让我们编写代码来创建预制件的实例。
- en: 3.4.3 Instantiating from an invisible SceneController
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.3 从不可见的SceneController实例化
- en: Although the prefab itself doesn’t exist in the scene, an object must be in
    the scene for the enemy spawning code to attach to. We’ll create an empty game
    object and can attach the script to that, but the object won’t be visible in the
    scene.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管预制件本身在场景中不存在，但必须有一个对象存在于场景中，以便敌人生成代码可以附加到它。我们将创建一个空的游戏对象并将脚本附加到该对象，但该对象在场景中是不可见的。
- en: TIP The use of empty GameObjects for attaching script components is a common
    pattern in Unity development. This trick is used for abstract tasks that don’t
    apply to any specific object in the scene. Unity scripts are intended to be attached
    to visible objects, but not every task makes sense that way.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: TIP 在Unity开发中，使用空GameObject来附加脚本组件是一种常见的模式。这个技巧用于抽象任务，这些任务不适用于场景中的任何特定对象。Unity脚本旨在附加到可见对象，但并非每个任务都适合这种方式。
- en: Choose GameObject > Create Empty, rename the new object Controller, and ensure
    that its position is 0, 0, 0. (Technically, the position doesn’t matter because
    the object isn’t visible, but putting it at the origin will make life simpler
    if you ever parent anything to it.) Create a script called SceneController.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 选择GameObject > 创建空对象，将新对象重命名为Controller，并确保其位置为0, 0, 0。（技术上，位置并不重要，因为对象是不可见的，但如果你将来要将任何对象作为其父对象，将其放置在原点会使生活更简单。）创建一个名为SceneController的脚本。
- en: Listing 3.10 SceneController that spawns the enemy prefab
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.10 SceneController生成敌人预制件
- en: '[PRE9]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Serialized variable for linking to the prefab object
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 用于链接到预制件对象的序列化变量
- en: ❷ Private variable to keep track of the enemy instance in the scene
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 用于跟踪场景中敌人实例的私有变量
- en: ❸ Spawn a new enemy only if one isn’t already in the scene.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 仅当场景中不存在其他敌人时才生成新的敌人。
- en: ❹ Method that copies the prefab object
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 复制预制件对象的函数
- en: Attach this script to the controller object, and in the Inspector you’ll see
    a variable slot for the enemy prefab. This works similarly to public variables,
    but there’s an important difference.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 将此脚本附加到控制器对象，然后在检查器中你会看到一个敌人预制件的变量槽位。这与公共变量类似，但有一个重要的区别。
- en: TIP To reference objects in Unity’s editor, I recommend decorating variables
    with SerializeField instead of declaring them to be public. As explained in chapter
    2, public variables show up in the Inspector (in other words, they’re serialized
    by Unity), so most tutorials and sample code you’ll see use public variables for
    all serialized values. But these variables can also be modified by other scripts
    (these are public variables, after all), whereas the SerializeField attribute
    allows you to keep the variables private. C# defaults to private if a variable
    isn’t explicitly made public, and that’s better in most cases because you want
    to expose that variable in the Inspector but don’t want the value to be changed
    by other scripts.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：为了在Unity编辑器中引用对象，我建议用SerializeField装饰变量，而不是将它们声明为public。如第2章所述，public变量会出现在检查器中（换句话说，它们会被Unity序列化），所以大多数教程和示例代码都会使用public变量来序列化所有值。但是，这些变量也可以被其他脚本修改（毕竟，它们是public变量），而SerializeField属性允许你保持变量私有。C#默认将变量设置为private，除非明确将其设置为public，这在大多数情况下更好，因为你想在检查器中公开该变量，但不想让其他脚本更改其值。
- en: WARNING Prior to version 2019.4, Unity had a bug in which SerializeField would
    cause the compiler to emit a warning about that field not being initialized. If
    you ever encounter this bug, the script still functions fine, so technically you
    can just ignore those warnings or get rid of them by adding = null to those fields.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：在版本2019.4之前，Unity存在一个bug，即SerializeField会导致编译器发出警告，指出该字段未初始化。如果你遇到这个bug，脚本仍然可以正常工作，所以技术上你可以忽略这些警告或者通过在这些字段中添加=
    null来消除它们。
- en: Drag the prefab asset up from Project to the empty variable slot. When the mouse
    gets near, you should see the slot highlight to indicate that the object can be
    linked there (see figure 3.8). Once the enemy prefab is linked to the SceneController
    script, play the scene to see the code in action. An enemy will appear in the
    middle of the room just as before, but now if you shoot the enemy, it will be
    replaced by a new enemy. That’s much better than just one enemy that’s gone forever!
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 将预制体资产从项目拖动到空变量槽位。当鼠标靠近时，你应该会看到槽位高亮显示，以指示可以在此处链接对象（见图3.8）。一旦敌人预制体被链接到SceneController脚本，播放场景以查看代码的实际效果。敌人将像之前一样出现在房间中央，但现在如果你射击敌人，它将被一个新的敌人替换。这比只有一个永远消失的敌人要好得多！
- en: '![CH03_F08_Hocking3](../Images/CH03_F08_Hocking3.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![CH03_F08_Hocking3](../Images/CH03_F08_Hocking3.png)'
- en: Figure 3.8 Link the enemy prefab to the script’s prefab slot.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 将敌人预制体链接到脚本的预制体槽位。
- en: TIP This approach of dragging objects onto the Inspector’s variable slots is
    a handy technique that comes up in a lot of scripts. Here we linked a prefab to
    the script, but you can also link to objects in the scene and can even link to
    specific components (rather than the overall GameObject). In future chapters,
    we’ll use this technique often.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：将对象拖放到检查器的变量槽位中的这种方法是许多脚本中常见的一种实用技巧。在这里，我们将预制体链接到脚本，但你也可以链接场景中的对象，甚至可以链接到特定的组件（而不是整个GameObject）。在未来的章节中，我们将经常使用这种技巧。
- en: The core of this script is the Instantiate() method, so take note of that line.
    When we instantiate the prefab, that creates a copy in the scene. By default,
    Instantiate() returns the new object as a generic Object type, but Object is pretty
    useless directly, and we need to handle it as a GameObject. In C#, use the as
    keyword for typecasting to convert from one type of code object into another type
    (written with the syntax original-object as new-type).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本的核心理法是Instantiate()方法，所以请注意那行代码。当我们实例化预制体时，就在场景中创建了一个副本。默认情况下，Instantiate()返回一个通用的Object类型的新对象，但Object直接使用相当无用的，我们需要将其处理为GameObject。在C#中，使用as关键字进行类型转换，将一个类型的代码对象转换为另一个类型（使用语法original-object
    as new-type）。
- en: 'The instantiated object is stored in enemy, a private variable of the GameObject
    type. (Keep the distinction between a prefab and an instance of the prefab straight:
    enemyPrefab stores the prefab; enemy stores the instance.) The if statement that
    checks the stored object ensures that Instantiate() is called only when enemy
    is empty (or null, in coder-speak). The variable starts out empty, so the instantiating
    code runs once right from the beginning of the session. The object returned by
    Instantiate() is then stored in enemy so that the instantiating code won’t run
    again.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化的对象存储在 enemy 中，这是 GameObject 类的一个私有变量。（保持预制体和预制体实例之间的区别清晰：enemyPrefab 存储预制体；enemy
    存储实例。）检查存储对象的 if 语句确保 Instantiate() 只在 enemy 为空（或用代码员的话说 null）时调用。变量一开始是空的，所以实例化代码在会话一开始就运行了一次。然后，Instantiate()
    返回的对象存储在 enemy 中，这样实例化代码就不会再次运行。
- en: Because the enemy destroys itself when shot, that empties the enemy variable
    and causes Instantiate() to be run again. In this way, an enemy is always in the
    scene.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 因为敌人被射击后会自我销毁，这会导致敌人变量清空并再次运行 Instantiate()。这样，敌人就始终存在于场景中。
- en: Destroying GameObjects and memory management
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 销毁 GameObject 和内存管理
- en: It’s somewhat unexpected for existing references to become null when an object
    destroys itself. In a memory-managed programming language like C#, normally you
    aren’t able to directly destroy objects; you can only dereference them so that
    they can be destroyed automatically. This is still true within Unity, but the
    way GameObjects are handled behind the scenes makes it look like they were destroyed
    directly.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个对象自我销毁时，现有的引用变为 null 是有些意外的。在像 C# 这样的内存管理编程语言中，通常你不能直接销毁对象；你只能解除引用，这样它们就可以自动销毁。在
    Unity 中这仍然成立，但 GameObject 在幕后处理的方式使得它们看起来是直接被销毁的。
- en: To display objects in the scene, Unity has to have a reference to all objects
    in its scene graph. As such, even if you removed all references to the GameObject
    in your code, this scene graph reference would still prevent the object from being
    destroyed automatically. Because of this, Unity provides the Destroy()method to
    tell the game engine, “Remove this object from the scene graph.” As part of that
    behind-the-scenes functionality, Unity also overloads the == operator to return
    true when checking for null. Technically, that object still exists in memory,
    but it may as well not exist any longer, so Unity has it appearing as null. You
    could confirm this by calling GetInstanceID()on the destroyed object.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要在场景中显示对象，Unity 必须引用其场景图中的所有对象。因此，即使你在代码中移除了对 GameObject 的所有引用，这个场景图引用仍然会阻止对象被自动销毁。正因为如此，Unity
    提供了 Destroy() 方法来告诉游戏引擎，“从场景图中移除此对象。”作为幕后功能的一部分，Unity 还重载了 == 操作符，在检查 null 时返回
    true。技术上，该对象仍然存在于内存中，但它可能已经不再存在，所以 Unity 让它看起来像 null。你可以通过在销毁的对象上调用 GetInstanceID()
    来确认这一点。
- en: Note that the developers of Unity have considered changing this behavior to
    more standard memory management. If they do, this spawning code will need to change
    as well, probably by swapping the (enemy==null) check with a new parameter like
    (enemy.isDestroyed).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Unity 的开发者已经考虑过将这种行为更改为更标准的内存管理。如果他们这样做，这个生成代码也需要相应地更改，可能需要将 (enemy==null)
    检查与一个新的参数（如 (enemy.isDestroyed)）交换。
- en: (If most of this discussion was Greek to you, just don’t worry about it; this
    was a tangential technical discussion for people interested in these obscure details.)
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: （如果大部分讨论对你来说都是希腊语，那么就不用担心；这是一个针对对这些晦涩细节感兴趣的人的旁征博引的技术讨论。）
- en: 3.5 Shooting by instantiating objects
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5 通过实例化对象进行射击
- en: All right, let’s add another bit of functionality to the enemies. Much as we
    did with the player, first we made them move—now let’s make them shoot! As I mentioned
    back when introducing raycasting, that was just one of the approaches to implementing
    shooting. Another approach involves instantiating prefabs, so let’s take that
    approach to making the enemies shoot back. The goal of this section is to see
    figure 3.9 when playing.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，让我们给敌人添加一些更多的功能。就像我们对玩家所做的那样，首先我们让它们移动——现在让我们让它们射击！正如我在介绍射线投射时提到的，那只是实现射击的一种方法。另一种方法涉及实例化预制体，所以让我们采用这种方法来让敌人射击。本节的目标是在游戏时看到图
    3.9。
- en: '![CH03_F09_Hocking3](../Images/CH03_F09_Hocking3.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![CH03_F09_Hocking3](../Images/CH03_F09_Hocking3.png)'
- en: Figure 3.9 Enemy shooting a fireball at the player.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9 敌人向玩家射击火球。
- en: 3.5.1 Creating the projectile prefab
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5.1 创建投射物预制体
- en: This time, shooting will involve a projectile in the scene. Shooting with raycasting
    was basically instantaneous, registering a hit the moment the mouse was clicked,
    but this time enemies are going to emit fireballs that fly through the air. Admittedly,
    they’ll be moving pretty fast, but not instantaneously, giving the player a chance
    to dodge out of the way. Instead of using raycasting to detect hits, we’ll use
    collision detection (the same collision system that keeps the moving player from
    passing through walls).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，射击将涉及场景中的弹体。使用射线投射进行射击基本上是瞬时的，鼠标点击的瞬间就会记录击中。但这次敌人将发射飞球穿过空气。诚然，它们会移动得相当快，但不是瞬间的，这给了玩家躲避的机会。我们不会使用射线投射来检测击中，而是使用碰撞检测（与防止移动玩家穿过墙壁的相同碰撞系统）。
- en: 'The code will spawn fireballs in the same way that enemies spawn: by instantiating
    a prefab. As explained in the previous section, the first step when creating a
    prefab is to create an object in the scene that will become the prefab, so let’s
    create a fireball.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将以与敌人相同的方式生成飞球：通过实例化一个预制体。正如前一小节所述，创建预制体的第一步是在场景中创建一个将成为预制体的对象，因此让我们创建一个飞球。
- en: To start, choose GameObject > 3D Object > Sphere. Rename the new object Fireball.
    Now create a new script, also called Fireball, and attach that script to this
    object. Eventually, we’ll write code in this script, but leave it as the default
    for now while we work on a few other parts of the Fireball object. So that it
    appears like a fireball and not just a gray sphere, we’re going to give the object
    a bright orange color. Surface properties such as color are controlled using materials.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，选择“游戏对象”>“3D对象”>“球体”。将新对象重命名为Fireball。现在创建一个新的脚本，也称为Fireball，并将其附加到该对象上。我们将在该脚本中编写代码，但暂时将其保留为默认设置，同时我们处理火球对象的几个其他部分。为了使其看起来像火球而不是一个灰色的球体，我们将给对象一个明亮的橙色。表面属性，如颜色，是通过材料控制的。
- en: DEFINITION A *material* is a packet of information that defines the surface
    properties of any 3D object that the material is attached to. These surface properties
    can include color, shininess, and even subtle roughness.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义** 一种**材料**是一组信息，它定义了任何3D对象（该材料附加到的对象）的表面属性。这些表面属性可以包括颜色、光泽度，甚至细微的粗糙度。'
- en: Choose Assets > Create > Material. Name the new material something like Flame
    and drag it onto the object in the scene. Select the material in the Project view
    in order to see the material’s properties in the Inspector. As figure 3.10 shows,
    click the color swatch labeled Albedo (that’s a technical term that refers to
    the main color of a surface). Clicking that will bring up a color picker in its
    own window; slide both the rainbow-colored ring and the main picking area to set
    the color to orange.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 选择“资产”>“创建”>“材料”。将新材料命名为火焰并将其拖放到场景中的对象上。在项目视图中选择材料，以便在检查器中查看材料的属性。如图3.10所示，单击标签为Albedo的颜色块（这是一个技术术语，指的是表面的主要颜色）。单击它将在自己的窗口中弹出一个颜色选择器；滑动彩虹色的环和主要选择区域以将颜色设置为橙色。
- en: '![CH03_F10_Hocking3](../Images/CH03_F10_Hocking3.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![CH03_F10_Hocking3](../Images/CH03_F10_Hocking3.png)'
- en: Figure 3.10 Setting the color of a material
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10 设置材料的颜色
- en: We’re also going to brighten the material to make it look more like fire. Adjust
    the Emission value (one of the other attributes in the Inspector). The check box
    is off by default, so turn it on to brighten up the material.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使材料变得更亮，使其看起来更像火焰。调整Emission值（检查器中的其他属性之一）。复选框默认关闭，因此请将其打开以使材料变亮。
- en: Now you can turn the fireball object into a prefab by dragging the object down
    from Hierarchy into Project, just as you did with the enemy prefab. As with the
    enemy, we need only the prefab now, so delete the instance in the Hierarchy. Great—we
    have a new prefab to use as a projectile! Next up is writing code to shoot using
    that projectile.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以通过将对象从层次结构拖动到项目来将火球对象转换为预制体，就像您处理敌人预制体时做的那样。与敌人一样，我们现在只需要预制体，因此请删除层次结构中的实例。太好了——我们有一个新的预制体可以用作弹体！接下来是编写使用该弹体射击的代码。
- en: 3.5.2 Shooting the projectile and colliding with a target
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5.2 射击弹体并与目标碰撞
- en: Let’s make adjustments to the enemy in order to emit fireballs. Because code
    to recognize the player will require a new script (just like ReactiveTarget was
    required by the code to recognize the target), first create a new script and name
    it PlayerCharacter. Attach this script to the player object in the scene. Now
    open up WanderingAI and add to the code from this listing.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对敌人进行调整，以便发射火球。因为识别玩家的代码需要一个新的脚本（就像识别目标的代码需要ReactiveTarget一样），首先创建一个新的脚本，并将其命名为PlayerCharacter。将此脚本附加到场景中的玩家对象上。现在打开WanderingAI，并将此列表中的代码添加进去。
- en: Listing 3.11 WanderingAI additions for emitting fireballs
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.11 为发射火球添加的WanderingAI修改
- en: '[PRE10]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Add these two fields before any methods, just as in SceneController.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在任何方法之前添加这两个字段，就像在SceneController中一样。
- en: ❷ Player is detected in the same way as the target object in RayShooter.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 玩家被检测的方式与RayShooter中的目标对象相同。
- en: ❸ Same null Game-Object logic as SceneController
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 与SceneController相同的空GameObject逻辑
- en: ❹ Instantiate() method here is just as it was in SceneController.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ Instantiate()方法在这里与SceneController中的用法相同。
- en: ❺ Place the fireball in front of the enemy and point in the same direction.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将火球放置在敌人前方，并指向相同的方向。
- en: You’ll notice that all the annotations in this listing refer to similar (or
    the same) bits in previous scripts. Previous code listings showed everything needed
    for emitting fireballs; now we’re mashing together and remixing bits of code to
    fit in the new context.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，这个列表中的所有注释都指的是之前脚本中类似（或相同）的部分。之前的代码列表显示了发射火球所需的所有内容；现在我们正在将代码的片段混合和重新组合以适应新的上下文。
- en: 'Just as in SceneController, you need to add two GameObject fields toward the
    top of the script: a serialized variable for linking the prefab to, and a private
    variable for keeping track of the instance created by the code. After doing a
    raycast, the code checks for the PlayerCharacter on the object hit; this works
    just as the shooting code checking for ReactiveTarget on the object hit. The code
    that instantiates a fireball when there isn’t already one in the scene works like
    the code that instantiates an enemy. The positioning and rotation are different,
    though; this time, you place the instance just in front of the enemy and point
    it in the same direction.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在SceneController中一样，你需要在脚本顶部添加两个GameObject字段：一个序列化变量用于链接预制件，一个私有变量用于跟踪代码创建的实例。在执行射线投射后，代码会检查被击中的对象上的PlayerCharacter；这与射击代码检查被击中的对象上的ReactiveTarget的方式相同。当场景中还没有火球时，实例化火球的代码与实例化敌人的代码类似。不过，这次放置实例的位置是在敌人前方，并指向相同的方向。
- en: Once all the new code is in place, a new Fireball Prefab slot will appear in
    the Inspector when you select the Enemy prefab, like the Enemy Prefab slot in
    the Scene-Controller component. Click the Enemy prefab in the Project view (double-click
    to actually open the prefab, but just a single click selects it), and the Inspector
    will show that object’s components, as if you’d selected an object in the scene.
    Although the earlier warning about interface awkwardness often applies when editing
    prefabs, the interface makes it easy to adjust the components on a prefab without
    opening it, and that’s all we’re doing. As shown in figure 3.11, drag the Fireball
    prefab from Project onto the Fireball Prefab slot in the Inspector (again, just
    as you did with SceneController).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有新的代码都到位，当你选择敌人预制件时，检查器中会出现一个新的Fireball Prefab槽位，就像Scene-Controller组件中的敌人预制件槽位一样。在项目视图中单击敌人预制件（双击实际上打开预制件，但只需单击一次即可选择它），检查器将显示该对象的组件，就像你在场景中选择了对象一样。尽管在编辑预制件时，关于界面不灵活的警告通常适用，但界面使得在不打开预制件的情况下调整预制件上的组件变得容易，这正是我们所做的。如图3.11所示，将Fireball预制件从项目拖动到检查器中的Fireball
    Prefab槽位（再次，就像你处理SceneController一样）。
- en: '![CH03_F11_Hocking3](../Images/CH03_F11_Hocking3.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![CH03_F11_Hocking3](../Images/CH03_F11_Hocking3.png)'
- en: Figure 3.11 Link the fireball prefab to the script’s prefab slot.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11 将火球预制件链接到脚本的预制件槽位。
- en: Now the enemy will fire at the player when the player is directly ahead of it
    . . . well, try to fire. The bright orange sphere appears in front of the enemy
    but just sits there because we haven’t written its script yet. Let’s do that now.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当玩家直接在敌人前方时，敌人将会向玩家开火……嗯，尝试开火。明亮的橙色球体出现在敌人前方，但只是静静地在那里，因为我们还没有为其编写脚本。现在让我们来做这件事。
- en: Listing 3.12 Fireball script that reacts to collisions
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.12 反应碰撞的火球脚本
- en: '[PRE11]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Move forward in the direction it faces.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 向其面向的方向前进。
- en: ❷ Called when another object collides with this trigger
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 当另一个对象与此触发器碰撞时调用
- en: ❸ Check if the other object is a PlayerCharacter.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 检查其他对象是否为 PlayerCharacter。
- en: The crucial new bit to this code is the OnTriggerEnter() method, called automatically
    when the object has a collision, such as with the walls or with the player. At
    the moment, this code won’t work entirely; if you run it, the fireball will fly
    forward thanks to the Translate() line, but the trigger won’t run, queuing up
    a new fireball by destroying the current one. A couple of other adjustments need
    to be made to components on the Fireball object. The first change is making the
    collider a trigger. To adjust that, go to the Inspector and click the Is Trigger
    check box in the Sphere Collider component.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的关键新部分是 OnTriggerEnter() 方法，当对象发生碰撞时（例如与墙壁或玩家碰撞）会自动调用。目前，这段代码还不能完全工作；如果你运行它，火球会由于
    Translate() 行而向前飞行，但触发器不会运行，通过销毁当前火球来排队生成新的火球。还需要对火球对象上的组件进行一些其他调整。第一个更改是将碰撞器设置为触发器。要调整这一点，请转到检查器并点击
    Sphere Collider 组件中的 Is Trigger 复选框。
- en: TIP A collider component set as a trigger will still react to touching/overlapping
    other objects but will no longer stop other objects from physically passing through.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示** 设置为触发器的碰撞器组件仍然会响应接触/重叠其他对象，但将不再阻止其他对象物理上穿过。'
- en: The fireball also needs a Rigidbody, a component used by the physics system
    in Unity. By giving the fireball a Rigidbody component, you ensure that the physics
    system is able to register collision triggers for that object. Click Add Component
    at the bottom of the Inspector and choose Physics > Rigidbody. In the component
    that’s added, deselect Use Gravity (see figure 3.12) so that the fireball won’t
    be pulled down by gravity.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 火球还需要一个 Rigidbody 组件，这是 Unity 中物理系统使用的组件。通过给火球添加 Rigidbody 组件，你可以确保物理系统能够为该对象注册碰撞触发器。在检查器的底部点击添加组件，并选择
    Physics > Rigidbody。在添加的组件中，取消选择 Use Gravity（见图 3.12），这样火球就不会被重力拉下。
- en: '![CH03_F12_Hocking3](../Images/CH03_F12_Hocking3.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![CH03_F12_Hocking3](../Images/CH03_F12_Hocking3.png)'
- en: Figure 3.12 Turn off gravity in the Rigidbody component.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.12 在 Rigidbody 组件中关闭重力。
- en: 'Play now, and fireballs are destroyed when they hit something. Because the
    fireball-emitting code runs whenever a fireball isn’t already in the scene, the
    enemy will shoot more fireballs at the player. Now just one more thing remains
    for shooting at the player: making the player react to being hit.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在开始游戏，当火球击中物体时，火球会被销毁。因为火球发射代码在场景中没有火球时运行，敌人会向玩家发射更多的火球。现在只剩下最后一件事要做：让玩家对被击中做出反应。
- en: 3.5.3 Damaging the player
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5.3 玩家受伤
- en: Earlier, you created a PlayerCharacter script but left it empty. Now you’ll
    write code to have the player react to being hit.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，你创建了一个 PlayerCharacter 脚本，但留空了。现在，你将编写代码让玩家对被击中做出反应。
- en: Listing 3.13 Player that can take damage
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.13 可受伤害的玩家
- en: '[PRE12]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Initialize the health value.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 初始化健康值。
- en: ❷ Decrement the player’s health.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 减少玩家的健康值。
- en: ❸ Construct the message by using string interpolation.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用字符串插值构造消息。
- en: The listing defines a field for the player’s health and reduces the health on
    command. In later chapters, we’ll go over text displays to show information on
    the screen, but for now, we can display information about the player’s health
    only by using debug messages.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 列表定义了一个玩家的健康字段，并按命令减少健康值。在后面的章节中，我们将介绍文本显示，以在屏幕上显示信息，但到目前为止，我们只能通过调试消息来显示有关玩家健康的信息。
- en: DEFINITION *String interpolation* is a mechanism to insert the evaluation of
    code (for example, the value of a variable) into a string. Several programming
    languages support string interpolation, including C#. For example, look at the
    health message in listing 3.13.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义** 字符串插值是一种将代码的评估（例如，变量的值）插入到字符串中的机制。包括 C# 在内的几种编程语言支持字符串插值。例如，看看列表 3.13
    中的健康信息。'
- en: Now you need to go back to the Fireball script to call the player’s Hurt() method.
    Replace the debug line in the Fireball script with player.Hurt(damage) to tell
    the player they’ve been hit. And that’s the final bit of code we need!
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你需要回到火球脚本中调用玩家的 Hurt() 方法。将火球脚本中的调试行替换为 player.Hurt(damage)，以告知玩家他们被击中。这就是我们需要的最后一部分代码！
- en: Whew! That was a pretty intense chapter, with lots of code introduced. Combining
    the previous chapter with this one, you now have most of the functionality in
    place for a first-person shooter.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！这一章内容相当紧凑，引入了大量的代码。将前一章与这一章结合起来，你现在已经拥有了第一人称射击游戏的大部分功能。
- en: Summary
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: A ray is an imaginary line projected into the scene.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 射线是投射到场景中的想象中的线。
- en: Raycasting operations are useful for both shooting and sensing obstacles.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 光线投射操作对射击和感知障碍物都很有用。
- en: Making a character wander around involves basic AI.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使角色四处游荡涉及到基本的AI。
- en: New objects are spawned by instantiating prefabs.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过实例化预制件来创建新对象。
- en: Coroutines are used to spread out functions over time.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协程用于在时间上分散函数。
