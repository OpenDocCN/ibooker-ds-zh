- en: 10 Styling forms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 表单样式
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Styling input fields
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 样式输入字段
- en: Styling radio buttons and check boxes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 样式单选按钮和复选框
- en: Styling drop-down menus
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 样式下拉菜单
- en: Considering accessibility
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑可访问性
- en: Comparing `:focus` and `:focus-visible`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较 `:focus` 和 `:focus-visible`
- en: Using the `:where` and `:is` pseudo-classes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `:where` 和 `:is` 伪类
- en: Working with the `accent-color` property
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `accent-color` 属性
- en: Forms are everywhere in our applications. Whether they’re contact forms or login
    screens, whether or not they’re core to an application’s functionality, they’re
    truly omnipresent. The design of a form, however, can easily make or break the
    user’s experience. In this chapter, we’ll style a form and look at some of the
    accessibility considerations we need to make sure to address. We’ll look at some
    of the challenges that come with styling some radio and check-box inputs and drop-down
    menus, and we’ll cover some options for styling error messaging.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 表单在我们的应用程序中无处不在。无论是联系表单还是登录屏幕，无论它们是否是应用程序功能的核心，它们确实无处不在。然而，表单的设计可以轻易地使用户体验变得更好或更差。在本章中，我们将对表单进行样式化，并查看我们需要确保解决的某些可访问性考虑因素。我们将探讨一些与样式化某些单选按钮和复选框输入以及下拉菜单相关的挑战，并介绍一些样式化错误消息的选项。
- en: A *form* in this context is a section of code in an HTML `<form>` element containing
    controls (form fields) that the user interacts with to submit data to a website
    or application. Because contact forms are so prevalent across applications and
    websites, we’ll use a contact form as the basis for our project.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中，*表单*是一个HTML `<form>`元素中的代码部分，包含用户与之交互以向网站或应用程序提交数据的控件（表单字段）。由于联系表单在应用程序和网站中非常普遍，我们将使用联系表单作为我们项目的基准。
- en: 10.1 Setting up
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1 设置
- en: Our form contains two input fields, a drop-down menu, radio buttons, a check
    box, and a text area. We also have a header at the top and a Send button at the
    end of the form. Figure 10.1 shows our starting point—the raw HTML without any
    styles applied—and what we aim to accomplish.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的形式包含两个输入字段、一个下拉菜单、单选按钮、复选框和一个文本区域。我们还在表单顶部有一个标题，并在表单末尾有一个发送按钮。图10.1显示了我们的起点——未应用任何样式的原始HTML，以及我们想要实现的目标。
- en: '![](../Images/10-01.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10-01.png)'
- en: Figure 10.1 Starting point and finished product
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 起始点和成品
- en: Our starting HTML is fairly simple; it contains our form, inside which our labels,
    fields, error messages, and buttons are placed. The starting and final code are
    on GitHub ([http://mng.bz/rWYZ](http://mng.bz/rWYZ)), on CodePen ([https://codepen.io/michaelgearon/pen/poeoNbj](https://codepen.io/michaelgearon/pen/poeoNbj)),
    and in the following listing.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的起始HTML相当简单；它包含我们的表单，其中放置了我们的标签、字段、错误消息和按钮。起始和最终代码在GitHub（[http://mng.bz/rWYZ](http://mng.bz/rWYZ)）、CodePen（[https://codepen.io/michaelgearon/pen/poeoNbj](https://codepen.io/michaelgearon/pen/poeoNbj)）和以下列表中。
- en: Listing 10.1 Starting HTML
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.1 起始HTML
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ① Left image
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: ① 左侧图像
- en: ② Name input with associated label and error message
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ② 与相关标签和错误消息关联的名称输入
- en: ③ Email input with associated label and error message
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 与相关标签和错误消息关联的电子邮件输入
- en: ④ Reason for Contact drop-down menu and associated label
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 联系原因下拉菜单和相关标签
- en: ⑤ Fieldset containing subscription radio buttons
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 包含订阅单选按钮的Fieldset
- en: ⑥ Message textarea
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 消息文本区域
- en: ⑦ Subscription check mark
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 订阅勾选标记
- en: ⑧ JavaScript that handles errors
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 处理错误的JavaScript
- en: You may have noticed that a JavaScript file is included. We’ll use this file
    to show and hide errors later in the chapter (section 10.8).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到包含了一个JavaScript文件。我们将使用这个文件在章节的后面部分（10.8节）展示和隐藏错误。
- en: So that we can focus specifically on styling form elements, the CSS to lay out
    the page is provided in the starting project. We use `grid` to place the image
    and form side by side. We also use a gradient to create the dots in the background.
    Our theme colors have been set up with CSS custom properties and some basic typography
    settings, including using a sans-serif font and changing the default text size
    for our project to `12pt`. The following listing shows our starting CSS.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们能够专注于样式化表单元素，页面布局的CSS在起始项目中提供。我们使用 `grid` 将图像和表单并排放置。我们还使用渐变在背景中创建点。我们的主题颜色已通过CSS自定义属性和一些基本的排版设置设置，包括使用无衬线字体并将我们项目的默认文本大小更改为
    `12pt`。以下列表显示了我们的起始CSS。
- en: Listing 10.2 Starting CSS
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.2 起始CSS
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ① Sets up our theme colors using custom properties
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ① 使用自定义属性设置我们的主题颜色
- en: ② Adds the polka-dotted background
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ② 添加点状背景
- en: ③ Grid to place the two sections side by side
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 将两个部分并排放置的网格
- en: ④ Prevents our design from getting too wide and centers it horizontally on the
    page
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 防止我们的设计太宽，并在页面上水平居中
- en: ⑤ Adds the image to the left side
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 将图像添加到左侧
- en: 10.2 Resetting fieldset styles
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2 重置字段集样式
- en: Fieldsets are purpose-built to group controls and labels. Radio groups are a
    perfect use case for fieldsets, as they allow us to identify the controls effectively
    and explicitly as belonging together. They also give us a ready-built way of labeling
    the group of controls via the `<legend>`. Stylistically, however, we can agree
    that they’re rather unsightly.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 字段集是专门设计来分组控件和标签的。单选按钮组是字段集的一个完美用例，因为它们使我们能够有效地明确地将控件分组。它们还为我们提供了一个通过 `<legend>`
    标签为控件组添加标签的现成方式。然而，从风格上讲，我们可以同意它们相当不美观。
- en: 'Let’s reset the styles on the group to make it disappear visually. Programmatically,
    we want to keep the group, as it’s helpful for users of assistive technology,
    but we’re going to make it blend in a little more. To make the `<fieldset>` styles
    disappear, we need to reset three properties: `border`, `margin`, and `padding`.
    The following listing shows our rule.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重置该组的样式以使其在视觉上消失。从程序的角度来看，我们想要保留该组，因为它对辅助技术用户很有帮助，但我们将使其更好地融合。为了使 `<fieldset>`
    样式消失，我们需要重置三个属性：`border`、`margin` 和 `padding`。以下列表显示了我们的规则。
- en: Listing 10.3 Resetting fieldset styles
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.3 重置字段集样式
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With browser default styles on the `<fieldset>` removed (figure 10.2), let’s
    turn our attention to our input fields.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在移除 `<fieldset>` 的浏览器默认样式（图 10.2）后，让我们将注意力转向我们的输入字段。
- en: '![](../Images/10-02.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10-02.png)'
- en: Figure 10.2 Reset fieldset
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 重置字段集
- en: 10.3 Styling input fields
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3 输入字段样式化
- en: 'We have four types of input fields in our form, broken down as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在表单中有四种类型的输入字段，具体如下：
- en: '*Your Name*—`text`'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*您的姓名*—`text`'
- en: '*Your Email Address*—`email`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*您的电子邮件地址*—`email`'
- en: '*Yes/No*—`radio`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*是/否*—`radio`'
- en: '*Subscribe to our newsletter*—`checkbox`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*订阅我们的通讯*—`checkbox`'
- en: HTML has many more types of fields, including `date`, `time`, `number`, and
    `color`, each with its own semantic meaning and styling considerations. We chose
    the preceding four types because they’re commonly used on the web today.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 有更多类型的字段，包括 `date`、`time`、`number` 和 `color`，每种类型都有自己的语义意义和样式考虑。我们选择了前面的四种类型，因为它们在当今网络上被广泛使用。
- en: The unstyled appearance of these fields dictates what we’ll do to style them.
    We’ll treat the radio buttons and check box differently from the text input, for
    example, but we can reuse code across multiple types. We’ll group them by how
    the unstyled controls look, so we’ll handle the text and email together and then
    handle the radio buttons and check box together. Let’s start with the text and
    email inputs.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字段的未样式化外观决定了我们将如何对它们进行样式化。例如，我们将单选按钮和复选框与文本输入区分对待，但我们可以在多个类型之间重用代码。我们将根据未样式化控件的外观对它们进行分组，因此我们将文本和电子邮件一起处理，然后一起处理单选按钮和复选框。让我们从文本和电子邮件输入开始。
- en: 10.3.1 Styling text and email inputs
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.1 文本和电子邮件输入字段样式化
- en: The first thing we want to figure out is how to select only the text and email
    input fields—rather, all input fields that aren’t a radio button or check box.
    One solution would be to add a class to each input we want to handle. This approach
    is hard to maintain and will get quite noisy, however, especially in a form-heavy
    application or complex form. Therefore, we’ll use the pseudo-class `:not()` in
    conjunction with the type selector `selector[type="value"]`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先想弄清楚如何仅选择文本和电子邮件输入字段——更确切地说，所有不是单选按钮或复选框的输入字段。一个解决方案是为我们想要处理的每个输入添加一个类。然而，这种方法难以维护，并且会变得相当嘈杂，尤其是在表单密集型应用程序或复杂表单中。因此，我们将使用伪类
    `:not()` 与类型选择器 `selector[type="value"]` 结合使用。
- en: The `:not()` pseudo-class allows us to select elements that don’t meet a particular
    criterion. In our case, we want to select all input fields that don’t have a type
    of `radio` or `checkbox`. Our selector, therefore, will be `input:not([type="radio"],`
    `[type="checkbox"])`. Now we can start styling the input fields, which currently
    look like figure 10.3.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`:not()` 伪类允许我们选择不符合特定标准的元素。在我们的情况下，我们想要选择所有没有 `radio` 或 `checkbox` 类型的输入字段。因此，我们的选择器将是
    `input:not([type="radio"], [type="checkbox"])`。现在我们可以开始样式化输入字段，这些字段目前看起来如图 10.3
    所示。'
- en: '![](../Images/10-03.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10-03.png)'
- en: Figure 10.3 Input type `text` and type `email`
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 输入类型 `text` 和类型 `email`
- en: We see in figure 10.3 that the font is smaller than the `12pt` size we set on
    the body. Small font sizes are difficult to read on mobile devices; they’re also
    hard to read for many users, especially young children and the elderly. If we
    want our form to be easily usable across a wide population and across devices,
    we’ll need to increase it, so we’ll set it to `1rem` to match the rest of our
    application. Inputs don’t inherit font styles by default, so we’ll also explicitly
    set `color` and `font-family` to `inherit`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在图 10.3 中看到字体大小小于我们在 `body` 上设置的 `12pt` 大小。小字体在移动设备上难以阅读；对于许多用户来说也很困难，尤其是年轻人和老年人。如果我们希望我们的表单易于在广泛的人群和设备上使用，我们需要将其增加，因此我们将它设置为
    `1rem` 以匹配我们的应用程序的其余部分。输入默认不继承字体样式，因此我们还将显式设置 `color` 和 `font-family` 为 `inherit`。
- en: NOTE `inherit` is a handy property value. It allows an element to inherit a
    property value from the parent forcibly when inheritance doesn’t happen by default.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `inherit` 是一个实用的属性值。它允许一个元素在默认情况下不发生继承时强制从父元素继承属性值。
- en: Next, we’re going to give the inputs some padding and custom borders, as well
    as curve their corners. In this case, we’ll make these changes for stylistic purposes.
    Most applications have a general style (look and feel). The styles we choose to
    apply to our fields should be in the same vein as the rest of our application’s
    general theme to help the form blend with the page and look as though it belongs.
    From a marketing perspective, sticking with our theme also helps reinforce brand
    recognition.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为输入添加一些填充和自定义边框，以及使它们的角落圆滑。在这种情况下，我们将出于风格目的进行这些更改。大多数应用程序都有一个通用样式（外观和感觉）。我们选择应用于字段样式应该与我们的应用程序的其余通用主题保持一致，以帮助表单与页面融合，看起来像是属于那里的。从营销角度来看，坚持我们的主题也有助于加强品牌认知。
- en: To create the bottom border gradient effect, we’ll use a linear gradient that
    goes from our primary color to our accent color. Because a gradient is an image
    we can’t assign to the `border-bottom` property, we need to use `border-image`,
    which allows us to style our borders with images. We’ll still provide a color
    in the `border-bottom` property as a fallback. Our code looks like the following
    listing.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建底部边框渐变效果，我们将使用从我们的主色调到辅助色调的线性渐变。因为渐变是一个我们不能分配给 `border-bottom` 属性的图像，我们需要使用
    `border-image`，这允许我们使用图像来样式化我们的边框。我们仍然会在 `border-bottom` 属性中提供一个颜色作为后备。我们的代码如下所示。
- en: Listing 10.4 Styling input fields that aren’t of type `radio` or `checkbox`
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.4 为非 `radio` 或 `checkbox` 类型的输入字段设置样式
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ① Removes all borders from the field
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ① 从字段中移除所有边框
- en: ② Adds the border back in, but only on the bottom, with our primary color as
    a fallback color
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ② 恢复边框，但仅底部，使用我们的主色调作为后备颜色
- en: ③ Adds the gradient for our border
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 为我们的边框添加渐变
- en: Pixels and rems
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 像素和rem
- en: Notice that our border uses pixels whereas the rest of our declarations use
    rems. In some instances, we want some elements of our design to be relative to
    the text size. In other words, if the text size increased or decreased, we’d want
    those elements to scale accordingly. Our padding and margin in this case use rems
    because if the text size increases, we don’t want the design to start looking
    cramped; on the flip side, if the text size decreases, we want to shrink that
    space accordingly. For these cases, we want to use a relative unit such as rems.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到我们的边框使用像素，而其余的声明使用rem。在某些情况下，我们希望设计中的某些元素相对于文本大小。换句话说，如果文本大小增加或减少，我们希望这些元素相应地缩放。在这种情况下，我们的填充和边距使用rem，因为如果文本大小增加，我们不希望设计开始看起来拥挤；另一方面，如果文本大小减少，我们希望相应地缩小那个空间。对于这些情况，我们希望使用一个相对单位，如rem。
- en: We want to keep the border at 1 pixel, however, regardless of the text size.
    Therefore, we use a fixed unit.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望边框保持 1 像素，然而，无论文本大小如何。因此，我们使用一个固定单位。
- en: We have some basic styles set for our text and email inputs, as shown in figure
    10.4\. We’ve started to develop a theme for our form controls.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为文本和电子邮件输入设置了一些基本样式，如图 10.4 所示。我们已经开始为我们的表单控件开发一个主题。
- en: '![](../Images/10-04.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10-04.png)'
- en: Figure 10.4 Text and email input styles
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4 文本和电子邮件输入样式
- en: 10.3.2 Making selects and textareas match the input styles
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.2 使选择框和文本区域与输入样式匹配
- en: To make sure that the look and feel are consistent across our controls, let’s
    apply the same styles we applied to the input field to the `<textarea>` and `<select>`
    elements. We’re not going to create new rules or copy and paste the code. To keep
    our styles consistent and maintainable, we’ll add `select` and `textarea` as selectors
    to our existing rules, as shown in the following listing.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们的控件在视觉和感觉上保持一致，让我们将应用于输入字段的相同样式应用到`<textarea>`和`<select>`元素上。我们不会创建新的规则或复制粘贴代码。为了保持我们的样式一致和可维护，我们将添加`select`和`textarea`作为选择器到我们现有的规则中，如下面的列表所示。
- en: Listing 10.5 Adding `textarea` and `select` to existing rule
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.5 将`textarea`和`select`添加到现有规则
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ① Adds textarea and select to our rule
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ① 将文本区域和选择框添加到我们的规则中
- en: ② Adds the border back in, but only on the bottom, with our primary color as
    a fallback color
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ② 将边框重新添加，但只在底部，以我们的主要颜色作为后备颜色
- en: ③ Adds the gradient for our border
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 为我们的边框添加渐变
- en: When the rule is applied, we notice that both fields still need a little bit
    of extra styling. Let’s focus on the `<textarea>` first. Figure 10.5 shows our
    updated `<textarea>`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当规则应用后，我们注意到这两个字段仍然需要一点额外的样式。让我们首先关注`<textarea>`。图10.5显示了我们的更新后的`<textarea>`。
- en: '![](../Images/10-05.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10-05.png)'
- en: Figure 10.5 Updated `<textarea>` styles
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 更新`<textarea>`样式
- en: By default on the web, users can resize the width and height of `<textarea>`s
    by clicking and dragging the bottom-right corner. In our layout, increasing or
    decreasing the height doesn’t cause any layout issues. Changing the width, however,
    hides our image and eventually makes our form uncentered, as we can observe in
    figure 10.6.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在默认的网页中，用户可以通过点击并拖动右下角来调整`<textarea>`的宽度和高度。在我们的布局中，增加或减少高度不会引起任何布局问题。然而，改变宽度会隐藏我们的图片，并最终使我们的表单失去居中，正如我们可以在图10.6中观察到的。
- en: '![](../Images/10-06.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10-06.png)'
- en: Figure 10.6 `<textarea>` resize issue
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 `<textarea>`调整大小问题
- en: The `<textarea>` extends outside the container in an unsightly fashion. When
    we resize vertically, the container resizes appropriately, but this isn’t the
    case horizontally. By changing the value of the `<textarea>`’s `resize` property
    from its default setting (`both`) to `vertical`, we limit users’ ability to resize
    the element. Users will continue to be able to change its height but not the width,
    as shown in the following listing.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`<textarea>`以一种不美观的方式延伸到容器之外。当我们垂直调整大小时，容器会相应地调整大小，但水平方向并不是这样。通过将`<textarea>`的`resize`属性值从默认设置（`both`）更改为`vertical`，我们限制了用户调整元素大小的能力。用户将继续能够改变其高度，但不能改变宽度，如下面的列表所示。'
- en: Listing 10.6 Updated styles for `textarea`
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.6 更新`textarea`的样式
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Visually, the text box looks the same and still has the resize control in the
    bottom-right corner (figure 10.7). When the user interacts with the resize control,
    however, they’ll be constrained to resizing vertically.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 从视觉上看，文本框看起来相同，并且在右下角仍然有调整大小的控制（图10.7）。然而，当用户与调整大小的控制交互时，他们将被限制在垂直调整大小。
- en: '![](../Images/10-07.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10-07.png)'
- en: Figure 10.7 `<textarea>` vertical resize only
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7 `<textarea>`仅垂直调整大小
- en: We still need to address the `<select>`, but this process will be a bit more
    complicated than editing the `<textarea>`. So let’s finish styling the input fields
    first and then circle back to finish styling the `<select>` control.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要处理`<select>`，但这个过程将比编辑`<textarea>`复杂得多。所以让我们先完成输入字段的样式设计，然后再回到完成`<select>`控件的样式设计。
- en: 10.3.3 Styling radio inputs and check boxes
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.3 样式化单选输入和复选框
- en: Some form controls are notoriously difficult to style because the number of
    styles that can be applied to them are incredibly limited. Radio buttons and check
    boxes fall squarely into that category. Until recently, no properties whatsoever
    affected the radio-button circle or the check-box square. Our only option was
    to replace the native control styles with our own.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一些表单控件因其可应用样式数量极其有限而闻名，难以进行样式设计。单选按钮和复选框正好属于这一类。直到最近，没有任何属性会影响单选按钮的圆圈或复选框的方块。我们唯一的选择是用我们自己的样式替换原生的控件样式。
- en: Why are some form fields so hard to style?
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么一些表单字段如此难以进行样式设计？
- en: Some form fields, radio buttons and check boxes included, have a reputation
    for being hard to style. This reputation stems from the limited number of CSS
    properties we have to alter how they look. The reason we have only limited properties
    is that the bulk of their appearance is driven by the operating system, not the
    browser.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一些表单字段，包括单选按钮和复选框，因其难以样式化而享有声誉。这种声誉源于我们可以更改其外观的 CSS 属性数量有限。我们之所以只有有限的属性，是因为它们的外观大部分是由操作系统驱动的，而不是浏览器。
- en: Now we have the ability to change the native control’s color. The `accent-color`
    property allows us to replace the user agent’s chosen color with the color we
    specify. Applying `accent-color:` `var(--accent);` to our check box and radio
    buttons (listing 10.7) yields the results shown in figure 10.8.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了更改原生控件颜色的能力。`accent-color` 属性允许我们用我们指定的颜色替换用户代理选择的颜色。将 `accent-color:`
    `var(--accent);` 应用到我们的复选框和单选按钮（列表 10.7）会产生图 10.8 中显示的结果。
- en: '![](../Images/10-08.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10-08.png)'
- en: Figure 10.8 Accent color applied to radio buttons and check boxes
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.8 应用于单选按钮和复选框的强调颜色
- en: Listing 10.7 Updated styles for `textarea`
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.7 更新 `textarea` 的样式
- en: '[PRE6]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ① Styles are being applied only to inputs that have a type of radio or checkbox.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ① 样式仅应用于类型为单选或复选的输入。
- en: The elements have taken our set accent color instead of the light blue default
    color they used before. If we increase the `font-size` in the application, however,
    the controls don’t increase in size (figure 10.9).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 元素已采用我们设置的强调颜色，而不是之前使用的默认浅蓝色。然而，如果我们增加应用程序中的 `font-size`，控件的大小并不会增加（见图 10.9）。
- en: '![](../Images/10-09.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10-09.png)'
- en: Figure 10.9 Increasing font size on radio buttons and check boxes
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.9 增加单选按钮和复选框的字体大小
- en: Although we can change the color of the element (which is an effective way to
    style the control quickly and efficiently to fit our styles better), if we want
    to allow a control to scale with our font size or make any further customizations,
    we’ll need to replace the control’s styles with our own. Because we want to keep
    the functionality of the control and replace only its visual aspect, our HTML
    stays the same. We’re going to hide the native control provided by the browser
    and replace the visual portion with our own custom styles. To hide the native
    control, we’ll use the `appearance` property and give it a value of `none`. This
    property allows us to control the native appearance of the control. By setting
    its property to `none`, we’re saying that we don’t want it to display the styles
    provided by the operating system. We’ll also set the `background-color` to our
    own background color (because some operating systems include a background for
    the controls) and then reset our margins.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以更改元素的颜色（这是一种快速有效地调整控件样式以更好地适应我们样式的有效方法），但如果我们想允许控件随着字体大小缩放或进行任何进一步的定制，我们需要用我们自己的样式替换控件的样式。因为我们想保持控件的功能，只替换其视觉方面，所以我们的
    HTML 保持不变。我们将隐藏浏览器提供的原生控件，并用我们自己的自定义样式替换其视觉部分。为了隐藏原生控件，我们将使用 `appearance` 属性并将其值设置为
    `none`。这个属性允许我们控制控件的原生外观。通过将其属性设置为 `none`，我们表示我们不希望它显示操作系统提供的样式。我们还将设置 `background-color`
    为我们自己的背景颜色（因为一些操作系统为控件提供了背景），然后重置我们的边距。
- en: We can remove the `accent-color` declaration we created earlier; we’re re-creating
    the visual aspect of the control from scratch, so the declaration will have no
    effect. The following listing shows the completed reset.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以移除之前创建的 `accent-color` 声明；我们正在从头开始重新创建控件的视觉方面，因此该声明将没有任何效果。以下列表显示了完成的重置。
- en: Listing 10.8 Reset of `radio` and `checkbox` inputs
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.8 重置 `radio` 和 `checkbox` 输入
- en: '[PRE7]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Figure 10.10 shows that the radio buttons have disappeared. We can start creating
    our own styles for those controls.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.10 显示单选按钮已消失。我们可以开始为这些控件创建自己的样式。
- en: '![](../Images/10-10.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10-10.png)'
- en: Figure 10.10 Reset radio and check box styles
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.10 重置单选按钮和复选框的样式
- en: To start, we want to create a box. For radio-button inputs, we’ll give that
    box a `border-radius` to make it round. At the core, whether an input element
    is a check box or group of radio buttons, an input needs a box. We’ll create one
    by giving the input a `height` and a `width` of `1.75em`. We use `em` units because
    they’re a percentage of the parent’s font size. By setting our height and width
    to `1.75em`, we’re setting them to equal 1 3/4 times the value of the parent’s
    font size. If our label—the container and therefore the parent of our input—has
    a `font-size` of `16px`, our box will be 28 pixels wide by 28 pixels tall (`16`
    `x` `1.75` `=` `28`).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们想要创建一个框。对于单选按钮输入，我们将给这个框一个 `border-radius` 使其呈圆形。本质上，无论输入元素是复选框还是一组单选按钮，输入都需要一个框。我们将通过给输入设置
    `height` 和 `width` 为 `1.75em` 来创建一个框。我们使用 `em` 单位，因为它们是父字体大小的百分比。通过将我们的高度和宽度设置为
    `1.75em`，我们使它们等于父字体大小的 1 3/4 倍。如果我们的标签——容器以及因此也是我们的输入的父元素——的 `font-size` 为 `16px`，我们的框将是
    28 像素宽和 28 像素高（`16` `x` `1.75` `=` `28`）。
- en: 'Next, we’ll add a border that inherits our label’s font color. This step may
    sound a little weird: how are we going to make `border-color` inherit from `font-color`?
    We’re going to use the keyword value `currentcolor`, which allows properties to
    inherit font color when they otherwise could not. We’re going to set the border
    color to `currentcolor` to make the border color match the font color. To set
    our border width, we’ll use `em` to allow the width of our border to scale with
    the size of our radio buttons.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个继承自标签字体颜色的边框。这一步可能听起来有点奇怪：我们如何使 `border-color` 从 `font-color` 继承？我们将使用关键字值
    `currentcolor`，它允许属性在它们通常不能继承的情况下继承字体颜色。我们将边框颜色设置为 `currentcolor` 以使边框颜色与字体颜色匹配。为了设置我们的边框宽度，我们将使用
    `em` 以允许边框宽度与单选按钮的大小成比例。
- en: Because inputs are inline elements by default, to apply our height and width,
    we’ll also need to change the `display` property. We’ll set it to `inline-grid`
    because when we handle the `checked` state for our inputs, we need to center the
    inner disk or check mark. Grid allows us to do so easily by means of the `place-content`
    property.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于输入默认是内联元素，为了应用我们的高度和宽度，我们还需要更改 `display` 属性。我们将将其设置为 `inline-grid`，因为我们处理输入的
    `checked` 状态时，需要将内部圆盘或勾选标记居中。网格允许我们通过 `place-content` 属性轻松实现这一点。
- en: '`inline-grid` is to `grid` as `inline-block` is to `block`. `inline-block`
    has all the same characteristics as `block` but places itself inline in the page
    flow. `inline-grid` works the same way. We have access to all the features of
    `grid`, but the element places itself inline in the page flow rather than below
    the previous content. For our purposes, this fact means that the input will place
    itself with the text label without our having to create special rules for labels
    containing radio-button inputs or check boxes.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`inline-grid` 相对于 `grid`，就像 `inline-block` 相对于 `block`。`inline-block` 具有与 `block`
    相同的所有特性，但将其自身放置在页面流中。`inline-grid` 以相同的方式工作。我们可以访问 `grid` 的所有功能，但元素将自身放置在页面流中，而不是在上一内容下方。就我们的目的而言，这意味着输入将与文本标签一起放置，而无需为我们必须为包含单选按钮输入或复选框的标签创建特殊规则。'
- en: Finally, we need to handle `border-radius`. This step is where the check box
    and the radio buttons diverge, because the check box is square and the radio buttons
    are circular. Because our fields have rounded edges, we’re going to add a small
    `border-radius` (`4px`) to the check box. To make the radio buttons circular,
    we’ll add a `border-radius` of `50%`. Our updated rule is shown in the following
    listing.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要处理 `border-radius`。这一步是复选框和单选按钮开始分叉的地方，因为复选框是方形的，而单选按钮是圆形的。由于我们的字段有圆角，我们将为复选框添加一个小的
    `border-radius` (`4px`)。为了使单选按钮呈圆形，我们将添加一个 `border-radius` 为 `50%`。我们的更新规则如下所示。
- en: Listing 10.9 Styled `radio` and `checkbox` inputs
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.9 样式化的 `radio` 和 `checkbox` 输入
- en: '[PRE8]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ① Sets the border to the same color as the parent element’s text color
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ① 将边框设置为与父元素文本颜色相同的颜色
- en: ② Sets up to center the inner disk or check mark when the element is checked
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ② 当元素被选中时，设置以居中内部圆盘或勾选标记
- en: Our unchecked inputs are styled. Now we need to address the styles to use when
    those inputs are selected. In figure 10.11, selected (`checked`) and unselected
    elements look identical.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们未选中的输入已经进行了样式化。现在我们需要处理当这些输入被选中时使用的样式。在图 10.11 中，选中的（已选中）和未选中的元素看起来是相同的。
- en: '![](../Images/10-11.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/10-11.png)'
- en: Figure 10.11 Unselected `radio` and `checkbox` styles
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.11 未选中的 `radio` 和 `checkbox` 样式
- en: 10.3.4 Using the :where() and :is() pseudo-classes
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.4 使用 :where() 和 :is() 伪类
- en: 'At this junction, we’re going to look at two pseudo-classes that will help
    us keep our code clean and concise: `:is``()` and `:where``()`. Both pseudo-classes
    work similarly in that they take a list of selectors and apply the rule if any
    of the selectors within the list matches. Both are incredibly helpful for writing
    long lists of selectors. Instead of writing'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个节点上，我们将查看两个将帮助我们保持代码干净和简洁的伪类：`:is()`和`:where()`。这两个伪类在功能上相似，因为它们接受一个选择器列表，并在列表中的任何选择器匹配时应用规则。这两个都非常有助于编写长的选择器列表。我们不必像这样写
- en: '[PRE9]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: we can use `:where` or `:is` and write an equivalent like so`:`
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`:where`或`:is`并写出等效的如下`:`
- en: '[PRE10]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `:is()` pseudo-class would be applied in the same manner. The difference
    between `:is``()` and `:where``()` is in their level of specificity. `:where()`
    is less specific and therefore easy to override. `:is()`, on the other hand, takes
    the specificity value of the most specific selector in the list.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`:is()`伪类将以相同的方式应用。`:is()`和`:where()`之间的区别在于它们的特定性级别。`:where()`不太特定，因此容易覆盖。另一方面，`:is()`采用列表中最特定选择器的特定性值。'
- en: Note To see how specificity is calculated, check out chapter 1\. We’ll go into
    a bit more depth on calculating specificity with `:where()` and `:is()` in section
    10.3.9.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：要了解如何计算特定性，请查看第1章。在第10.3.9节中，我们将更深入地探讨使用`:where()`和`:is()`计算特定性的方法。
- en: WARNING Use caution in using `:is``()`, because if we have an `id` selector
    in our list of selectors (`id` selectors are most specific), we can create rules
    that are difficult to override.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：在使用`:is()`时要小心，因为如果我们列表中的选择器有`id`选择器（`id`选择器是最特定的），我们可以创建难以覆盖的规则。
- en: We’ll use `:where``()` and `:is``()` in conjunction with pseudo-classes such
    as `:checked`, `:hover`, and `:focus`, and with the `::before` pseudo-element
    to finish styling our `checkbox` and radio inputs.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`:where()`和`:is()`与伪类如`:checked`、`:hover`和`:focus`以及`::before`伪元素一起完成复选框和单选输入的样式。
- en: 10.3.5 Styling selected radio and checkbox inputs
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.5 样式选定的单选和复选输入
- en: To add the inner disk of the selected radio button and the check mark for the
    check box, we’ll apply a method similar to the one we used for unselected inputs.
    We created some base styles that applied to both types of inputs and then added
    the finishing touches to each element individually when the styles diverged. As
    before, we’ll start by creating a box. Next, we’ll place that box in the center
    of the existing styles, and then we’ll shape it to be a disk or check mark.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加选定的单选按钮的内部圆盘和复选框的勾选标记，我们将应用与用于未选中输入类似的方法。我们创建了一些适用于两种输入类型的基本样式，然后在样式分离时为每个元素单独添加了完成细节。像以前一样，我们首先创建一个框。接下来，我们将该框放置在现有样式的中心，然后将其塑造成圆盘或勾选标记的形状。
- en: 'To create this second box to be placed inside our current element, we’ll use
    the `::before` pseudo-element. At this point, the `:where()` pseudo class (introduced
    in section 10.3.4) comes into play; we’ll use it to select both of our input types
    and then add the `::before` pseudo-elements. Our selector will look like this:
    `:where(input[type= "radio"],` `input[type="checkbox"])::before` `{` `}`.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建这个要放置在我们当前元素内部的第二个框，我们将使用`::before`伪元素。在这个时候，`:where()`伪类（在第10.3.4节中介绍）开始发挥作用；我们将使用它来选择我们的两种输入类型，然后添加`::before`伪元素。我们的选择器将看起来像这样：`:where(input[type=
    "radio"], input[type="checkbox"])::before` `{}`.
- en: Our content will be empty, so we’ll use a `content` property value of `""` (empty
    quotes), and we’ll give it a `display` value of `block` so that we can assign
    a `width` and a `height`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的内容将是空的，因此我们将使用`content`属性值为`""`（空引号），并给它一个`display`值为`block`，这样我们就可以分配一个`width`和`height`。
- en: When we created the outer box earlier, we gave it a height and width of `1.75em`.
    We used an `em` unit so that control would scale relative to the text size. We’ll
    do the same thing here. We want the inner disks and check mark to be smaller than
    their containers, so we’ll set the `height` and `width` to `1em`. Assuming that
    the `font-size` applied to the input is `16px`, our box will be `16px` by `16px`
    (`16` `x` `1` `=` `16`) .
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们之前创建外部框时，我们给了它一个高度和宽度为`1.75em`。我们使用`em`单位，以便控制相对于文本大小进行缩放。我们在这里也将做同样的事情。我们希望内部圆盘和勾选标记比它们的容器小，所以我们将`height`和`width`设置为`1em`。假设应用于输入的`font-size`是`16px`，我们的框将是`16px`乘以`1`等于`16`。
- en: We don’t need to do anything to position our inner box. Remember that earlier,
    we set the input display to `inline-grid` and then added the `place-content` property
    with a value of `center` in listing 10.8\. The grid layout automatically places
    the inner box in the center of the input. The CSS for our inner disk and check
    mark looks like the following listing.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要做任何事情来定位我们的内部框。记住，之前我们设置了输入显示为 `inline-grid`，然后在列表 10.8 中添加了 `place-content`
    属性，其值为 `center`。网格布局自动将内部框放置在输入的中心。我们的内部圆盘和勾选标记的 CSS 如下所示。
- en: Listing 10.10 Centering the inner box
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.10 内部框居中
- en: '[PRE11]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When we apply this code, we see no changes, as demonstrated in figure 10.12\.
    Our inner box does exist but isn’t visible yet.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们应用此代码时，我们没有看到任何变化，如图 10.12 所示。我们的内部框确实存在，但目前还不可见。
- en: '![](../Images/10-12.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10-12.png)'
- en: Figure 10.12 Invisible inner box
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.12 不可见的内部框
- en: The box isn’t visible because it doesn’t have any content or background color.
    We’ll add a background color next.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 该框不可见，因为它没有任何内容或背景颜色。我们将添加一个背景颜色。
- en: 10.3.6 Using the :checked pseudo-class
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.6 使用 :checked 伪类
- en: We’re not going to apply the same background color to our element all the time.
    We’re going to use our accent color when the element is selected and our hover
    color when the element is being hovered over.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会一直将相同的背景颜色应用到我们的元素上。当元素被选中时，我们将使用我们的强调颜色，而当元素被悬停时，我们将使用悬停颜色。
- en: The `:checked` pseudo-class selector can be used on an input of type `radio`
    or `checkbox`, or on the option element (`<option>`) in a drop-down menu (`<select>`)
    to apply styles when the element is selected. The ability to use it on `<option>`
    is browser-dependent.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`:checked` 伪类选择器可以用于类型为 `radio` 或 `checkbox` 的输入，或者用于下拉菜单 (`<select>`) 中的 `<option>`
    元素，以在元素被选中时应用样式。在 `<option>` 上使用它的能力取决于浏览器。'
- en: When we apply the `background-color` for the `checked` and `hover` states, if
    the selectors have the same level of specificity (as our example will), the order
    in which we write these rules matters. If we write the checked state rule first
    and the hover state rule second, the hover color will be applied to a selected
    input on hover; the hover state rule will override the checked state rule because
    it appears later in the CSS file. Therefore, we want to make sure that the hover
    state rule is placed before the checked state rule in the CSS file. Figure 10.13
    illustrates these two scenarios.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们为 `checked` 和 `hover` 状态应用 `background-color` 时，如果选择器具有相同的具体性级别（如我们的示例所示），则这些规则的编写顺序很重要。如果我们首先编写
    `checked` 状态规则，然后编写 `hover` 状态规则，则悬停颜色将在悬停时应用于选中的输入；由于它出现在 CSS 文件中较后，悬停状态规则将覆盖
    `checked` 状态规则。因此，我们想要确保在 CSS 文件中将悬停状态规则放置在 `checked` 状态规则之前。图 10.13 阐述了这两种情况。
- en: '![](../Images/10-13.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10-13.png)'
- en: Figure 10.13 Rule order regarding the background for a selected check box on
    hover
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.13 关于悬停选中复选框背景的规则顺序
- en: Let’s see how we’d go about applying our background colors in our CSS file.
    The following listing shows our `hover` and `checked` code so far.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何在 CSS 文件中应用我们的背景颜色。以下列表显示了我们的 `hover` 和 `checked` 代码到目前为止的情况。
- en: Listing 10.11 Inner element background color
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.11 内部元素背景颜色
- en: '[PRE12]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ① Adds a background color to the inner box on hover
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ① 在悬停时为内部框添加背景颜色
- en: ② Adds a background color to the inner box when input is selected
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ② 在输入被选中时为内部框添加背景颜色
- en: Figure 10.14 shows that we have a box we can shape inside our elements. The
    box is displayed in our accent color when the element is selected, and when a
    user hovers over unselected radio-button or check-box inputs, we see a gray box.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.14 显示，我们可以在元素内部塑造一个框。当元素被选中时，该框以强调颜色显示，当用户悬停在未选中的单选按钮或复选框输入上时，我们看到一个灰色框。
- en: '![](../Images/10-14.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10-14.png)'
- en: Figure 10.14 Setting up for the selected state
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.14 设置选中状态
- en: Next, we need to shape the inner box, where our code will diverge to create
    disks and a check mark for the radio buttons and check box, respectively.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要塑造内部框，我们的代码将分叉以创建单选按钮和复选框的圆盘和勾选标记。
- en: 10.3.7  Shaping the selected radio buttons’ inner disk
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.7  塑造选中单选按钮的内部圆盘
- en: Starting with the radio-button inputs, we turn our inner box into a circle by
    adding a `border-radius` of `50%`, as shown in listing 10.12\. We don’t differentiate
    between the `hover` and `checked` states because we want the shape to be a disk
    regardless of the state of the element.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 从单选按钮输入开始，我们通过添加 `border-radius` 为 `50%` 将内部框变成圆形，如列表 10.12 所示。我们不区分 `hover`
    和 `checked` 状态，因为我们希望形状无论元素状态如何都为圆盘。
- en: Listing 10.12 Radio-button inner disk
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.12 单选按钮内部圆盘
- en: '[PRE13]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now we have traditional-looking radio buttons that scale nicely regardless of
    text size (figure 10.15). With our radio buttons styled, we’ll turn our attention
    to shaping the check mark inside our check box.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了看起来传统的单选按钮，无论文本大小如何都能很好地缩放（图 10.15）。在样式化单选按钮后，我们将注意力转向复选框内部的勾选标记形状。
- en: '![](../Images/10-15.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图片 10-15](../Images/10-15.png)'
- en: Figure 10.15 Styled `radio` inputs
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.15 样式化的 `radio` 输入
- en: 10.3.8 Using CSS shapes to create the check mark
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.8 使用 CSS 形状创建勾选标记
- en: 'Shaping our radio inputs was simple: we used `border-radius` to achieve a disk
    shape. Creating a check mark isn’t quite as simple. To do that, we’ll use `clip-path`.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使我们的单选输入形状变得简单：我们使用 `border-radius` 实现圆盘形状。创建勾选标记并不那么简单。为此，我们将使用 `clip-path`。
- en: Note `clip-path` allows us to create shapes by creating a clipping region that
    defines which parts of the element should be displayed and which parts should
    be hidden. We used `clip-path` in chapter 7.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：`clip-path` 允许我们通过创建一个定义了元素哪些部分应该显示和哪些部分应该隐藏的剪切区域来创建形状。我们在第 7 章中使用了 `clip-path`。
- en: The shape we’ll apply to the `clip-path` to create our check mark is a polygon.
    Polygons are created by setting a series of `X` and `Y` percentage-based coordinates
    between which a line is created. The `(0,0)` coordinate is the top-left corner
    of the shape. If the shape isn’t explicitly closed, it automatically joins the
    first and last points. Our `polygon()` function will be `polygon(14%` `44%,` `0%`
    `65%,` `50%` `100%,` `100%` `16%,` `80%` `0%,` `43%` `62%)`. Figure 10.16 explains
    the point-by-point construction of the shape.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将应用于 `clip-path` 以创建勾选标记的形状是一个多边形。多边形是通过设置一系列基于 `X` 和 `Y` 百分比坐标来创建的，这些坐标之间创建了一条线。`(0,0)`
    坐标是形状的左上角。如果形状没有明确关闭，它将自动连接第一个和最后一个点。我们的 `polygon()` 函数将是 `polygon(14% 44%, 0%
    65%, 50% 100%, 100% 16%, 80% 0%, 43% 62%)`。图 10.16 解释了形状的点对点构建。
- en: '![](../Images/10-16.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图片 10-16.png]'
- en: Figure 10.16 Polygon check-mark shape coordinates
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.16 多边形勾选标记形状坐标
- en: Note The coordinates for simple shapes are easy enough to figure out. But as
    shapes get more complex, determining the coordinates manually can be cumbersome.
    In those situations, we can turn to vector-graphic drawing programs such as Inkscape
    and Illustrator, or to one of the many CSS shape-generator websites, including
    [https://bennettfeely.com/clippy](https://bennettfeely.com/clippy/).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：简单形状的坐标很容易确定。但是，当形状变得更加复杂时，手动确定坐标可能会很繁琐。在这些情况下，我们可以求助于矢量图形绘制程序，如 Inkscape
    和 Illustrator，或者许多 CSS 形状生成网站之一，包括 [https://bennettfeely.com/clippy](https://bennettfeely.com/clippy/)。
- en: With our shape created, we can create our `clip-path` and apply it to the inner
    portion of our check box, as shown in the following listing.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建形状后，我们可以创建我们的 `clip-path` 并将其应用于复选框的内部部分，如下列所示。
- en: Listing 10.13 Check mark in our check box
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.13 检查框中的勾选标记
- en: '[PRE14]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With the `clip-path` added, we have a fully functional check box. Next, let’s
    add some finishing touches. Notice in figure 10.17 that the outlines of the selected
    radio buttons and check box are still in our font color rather than the accent
    color.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了 `clip-path` 之后，我们就有了功能齐全的复选框。接下来，让我们添加一些收尾工作。注意图 10.17 中选中的单选按钮和复选框的轮廓仍然是我们字体颜色，而不是强调色。
- en: '![](../Images/10-17.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图片 10-17.png]'
- en: Figure 10.17 Styled check mark in the check box
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.17 复选框中的样式化勾选标记
- en: To add the outline color to both the radio buttons and the check box when they’re
    selected, we’re going to use the `:checked` pseudo-class again to change the border
    color to our accent color only when the control is selected. This procedure translates
    to the code shown in listing 10.14\. We use `:is()` instead of `:where()` for
    reasons of specificity.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要在单选按钮和复选框被选中时为它们添加轮廓颜色，我们将再次使用 `:checked` 伪类，仅在控件被选中时将边框颜色更改为我们的强调色。这个过程对应于列表
    10.14 中的代码。我们使用 `:is()` 而不是 `:where()` 是出于特定性的考虑。
- en: Listing 10.14 Accent-color outline for selected inputs
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.14 选中输入项的强调色轮廓
- en: '[PRE15]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 10.3.9 Calculating specificity with :is() and :where()
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.9 使用 :is() 和 :where() 计算特定性
- en: We mentioned earlier that `:where()` has a specificity of `0`, meaning that
    it’s the least specific selector available to us. We set our default border color
    in the selector `input[type="radio"],` `input[type="checkbox"]` `{` `...` `}`,
    which has a specificity of `11`, calculated according to table 10.1\. In each
    column, we count the number of each type of selector, with columns A, B, and C
    forming the specificity value.[¹](#pgfId-1111135)
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到`:where()`具有`0`的特定性，这意味着它是我们可用的最不特定选择器。我们在选择器`input[type="radio"], input[type="checkbox"]
    `{` `...` `}`中设置了默认边框颜色，其特定性为`11`，根据表10.1计算得出。在每一列中，我们计算每种类型选择器的数量，列A、B和C形成特定性值。[¹](#pgfId-1111135)
- en: Table 10.1 Calculating specificity
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 表10.1 计算特定性
- en: '| Selector | AID selectors (×100) | BClass selectors, attribute selectors,
    & pseudo-classes(×10) | CType selectors, pseudo-elements(×1) | Specificity |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| 选择器 | AID选择器（×100） | BClass选择器、属性选择器和伪类（×10） | CType选择器、伪元素（×1） | 特定性 |'
- en: '| `:where(input[type="radio"], input[type="checkbox"])` | Ignores specificity
    rules and always equals 0 | `000` |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `:where(input[type="radio"], input[type="checkbox"])` | 忽略特定性规则，始终等于0 | `000`
    |'
- en: '| `:where(input[type="radio"], input[type="checkbox"]):checked` | Ignores specificity
    rules and always equals 0 | `000` |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `:where(input[type="radio"], input[type="checkbox"]):checked` | 忽略特定性规则，始终等于0
    | `000` |'
- en: '| `input[type="radio"]` | `0` | `1` | `1` | `011` |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `input[type="radio"]` | `0` | `1` | `1` | `011` |'
- en: '| `input[type="radio"]:checked` | `0` | `2` | `1` | `021` |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `input[type="radio"]:checked` | `0` | `2` | `1` | `021` |'
- en: '| `:is(input[type="radio"], input[type="checkbox"]):checked` | `0` | `2` |
    `1` | `021` |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `:is(input[type="radio"], input[type="checkbox"]):checked` | `0` | `2` |
    `1` | `021` |'
- en: Because `:is()` bases its specificity value on the value of the most specific
    selector within it, in this case the specificity will be `11` plus another `10`
    for the :`checked` state, giving us a specificity of `21`. Because `21` is greater
    than `0`, we override the styles, and our border becomes our accent color.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`:is()`基于其内部最特定选择器的值来确定特定性值，在这种情况下，特定性将是`11`加上`:checked`状态的另一个`10`，因此特定性为`21`。因为`21`大于`0`，我们覆盖了样式，我们的边框变成了我们的强调颜色。
- en: Now our radio buttons and check box are styled both when they’re selected and
    unselected, and on hover for both states. Figure 10.18 shows our progress so far.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对单选按钮和复选框进行了样式化，无论是选中还是未选中，以及悬停状态下的两种状态。图10.18显示了我们的进展情况。
- en: Let’s turn our attention to the drop-down menu next.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把注意力转向下一个下拉菜单。
- en: '![](../Images/10-18.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10-18.png)'
- en: Figure 10.18 Styled check box and radio-button inputs
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.18 样式化的复选框和单选按钮输入
- en: 10.4 Styling drop-down menus
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.4 样式化下拉菜单
- en: Although we applied the same default styles to `<select>` elements as we did
    for the text-based `<input>`s and `<textarea>s` (listing 10.5), we see in figure
    10.19 that the drop-down menu (`<select>`) is still rough. We also see in the
    expanded view that our options list doesn’t match our theme.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们为`<select>`元素应用了与基于文本的`<input>`和`<textarea>`相同的默认样式（列表10.5），但我们看到图10.19中下拉菜单（`<select>`）仍然很粗糙。在扩展视图中，我们还看到我们的选项列表与我们的主题不匹配。
- en: '![](../Images/10-19.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10-19.png)'
- en: Figure 10.19 Drop-down menu closed and expanded
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.19 下拉菜单关闭和展开
- en: Let’s start by fixing the background color. Although it’s not obvious because
    the background behind our form is white, the input fields have a white background
    by default. We’re going to add a rule to the existing declaration that affects
    the `<input>`s, `<textarea>`, and `<select>` elements to set the background color
    to the card background (listing 10.15). That way, should the card background change,
    our form controls will have the appropriate background color.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从修复背景颜色开始。虽然因为我们的表单背景是白色，所以不明显，但输入字段默认情况下有白色背景。我们将向现有的声明中添加一个规则，该规则影响`<input>`、`<textarea>`和`<select>`元素，将背景颜色设置为卡片背景（列表10.15）。这样，如果卡片背景发生变化，我们的表单控件将具有适当的背景颜色。
- en: Listing 10.15 Default styles applied to `select`
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.15 应用到`select`的默认样式
- en: '[PRE16]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ① Adds background-color declaration
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ① 添加背景颜色声明
- en: With the background color added, we see that the input and options have a white
    background (figure 10.20).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了背景颜色后，我们看到输入和选项都有白色背景（图10.20）。
- en: '![](../Images/10-20.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10-20.png)'
- en: Figure 10.20 `select` element styled
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.20 `select`元素样式化
- en: Although it would be nice to update the drop-down menu options to match our
    theme better, these menus, like the radio inputs and check boxes, get a lot of
    their styles and functionality from the operating system itself. Therefore, we’re
    limited in what we can style with CSS alone, and for this design, these changes
    are about as far as we can go. We can use JavaScript and ARIA to replace the entire
    control, but because this book is about CSS, we’re going to style as much as we
    can with CSS alone.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然将下拉菜单选项更新为更好地匹配我们的主题会很不错，但这些菜单，就像单选输入和复选框一样，从操作系统本身那里获得了许多样式和功能。因此，我们只能通过CSS进行样式化，对于这个设计，这些更改就是我们能够做到的极限。我们可以使用JavaScript和ARIA来替换整个控件，但由于这本书是关于CSS的，我们将尽可能只用CSS进行样式化。
- en: What is ARIA?
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ARIA是什么？
- en: ARIA (which stands for Accessible Rich Internet Applications) is a set of roles
    and attributes that can be added to HTML elements to supplement missing information
    about the use, state, and functionality of an element that otherwise isn’t available
    to the user. For more information, check out [https://www.w3.org/WAI/standards-guidelines/aria](https://www.w3.org/WAI/standards-guidelines/aria/).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ARIA（代表可访问的丰富互联网应用程序）是一组可以添加到HTML元素中的角色和属性，可以补充有关元素使用、状态和功能的信息，否则这些信息对用户不可用。更多信息，请参阅[https://www.w3.org/WAI/standards-guidelines/aria](https://www.w3.org/WAI/standards-guidelines/aria/)。
- en: Note When creating a custom control, it’s important to be mindful of the underlying
    accessibility information and functionality that the browser provides automatically
    and to make sure we’re re-creating that functionality along with the visual aspects
    of the control. Libraries or frameworks can be helpful when a custom control is
    needed, assuming that the library or framework was built with accessibility in
    mind. Usually, the best place to find out is the documentation.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在创建自定义控件时，重要的是要关注浏览器自动提供的底层可访问性信息和功能，并确保我们正在重新创建这些功能以及控件的外观方面。当需要自定义控件时，库或框架可能会有所帮助，前提是库或框架是在考虑可访问性的情况下构建的。通常，了解的最佳地方是文档。
- en: 10.5 Styling labels and legends
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.5 样式化标签和图例
- en: To style our labels and the legend, we’re going to start by giving them a vertical
    margin for breathing room between the label and the control. We’ll also use Flexbox
    to align the text and the icons, radio inputs, and check box. Finally, we’ll decrease
    their font size and change their color. Most important here are the values entered
    by the user, not the labels. By decreasing their size, we diminish their importance
    in the visual hierarchy. We end up with the code displayed in the following listing.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了样式化我们的标签和图例，我们将首先为标签和控制之间提供垂直边距以留出空间。我们还将使用Flexbox来对齐文本和图标、单选输入和复选框。最后，我们将减小它们的字体大小并更改它们的颜色。在这里最重要的是用户输入的值，而不是标签。通过减小它们的大小，我们降低了它们在视觉层次结构中的重要性。我们最终得到的代码如下所示。
- en: Listing 10.16 Added margin and updated font size
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.16 添加边距并更新字体大小
- en: '[PRE17]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ① Aligns the label text and the icon
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ① 对齐标签文本和图标
- en: With our labels and legend styled (figure 10.21), let’s turn our attention to
    the placeholders.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的标签和图例样式化（图10.21）之后，让我们将注意力转向占位符。
- en: '![](../Images/10-21.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10-21.png)'
- en: Figure 10.21 Styled labels and legend
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.21 样式化的标签和图例
- en: 10.6 Styling the placeholder text
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.6 样式化占位文本
- en: In our form, it’s difficult to distinguish what fields are user filled from
    what is placeholder text. As we did for our labels, we’re going to deemphasize
    the placeholder text to make it easier to distinguish from user responses.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的表单中，很难区分哪些字段是用户填写的，哪些是占位文本。正如我们为标签所做的那样，我们将降低占位文本的强调程度，使其更容易与用户响应区分开来。
- en: Labels and placeholder text
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 标签和占位文本
- en: Our project has both labels and placeholder text. Although placeholder text
    can be helpful to guide the user, it doesn’t replace labels. In fact, the Web
    Content Accessibility Guidelines (WCAG) accessibility standards specifically require
    form fields to have a label ([http://mng.bz/mVzW](http://mng.bz/mVzW)).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目既有标签也有占位文本。尽管占位文本可以有助于指导用户，但它不能替代标签。实际上，网络内容可访问性指南（WCAG）的可访问性标准特别要求表单字段要有标签([http://mng.bz/mVzW](http://mng.bz/mVzW))。
- en: Placeholder text disappears after the user enters a value in the field. This
    arrangement is problematic because the user doesn’t have a way to reference the
    instructions after they enter a value.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 用户在字段中输入值后，占位文本会消失。这种安排是有问题的，因为用户在输入值后没有参考说明的方法。
- en: Furthermore, labels are required for assistive technologies such as screen readers,
    which rely on this information to indicate to the user what is expected in the
    field.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，标签对于辅助技术（如屏幕阅读器）是必需的，这些技术依赖于这些信息来向用户指示字段中预期的内容。
- en: To style our placeholder text, we’re going to use the `::placeholder` pseudo-element.
    Because we want the placeholder to be styled the same way regardless of the type,
    we’ll write one rule that targets all placeholder text regardless of element type.
    In this new rule, we’ll decrease the size of the placeholder text and lighten
    its color, as shown in the following listing.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 为了样式化我们的占位文本，我们将使用 `::placeholder` 伪元素。因为我们希望占位符以相同的方式样式化，无论元素类型如何，我们将编写一个规则，针对所有占位文本，无论元素类型如何。在这个新规则中，我们将减小占位文本的大小并使其颜色变浅，如下列所示。
- en: Listing 10.17 Styling the placeholder text
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.17 样式化占位文本
- en: '[PRE18]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ① Targets any placeholder text regardless of element type
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ① 针对任何占位文本，无论元素类型如何
- en: Figure 10.22 shows our updated fields.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.22 显示了我们的更新字段。
- en: '![](../Images/10-22.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10-22.png)'
- en: Figure 10.22 Styled placeholder text
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.22 样式化的占位文本
- en: Next, let’s style the button at the bottom of the form.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们样式化表单底部的按钮。
- en: 10.7 Styling the Send button
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.7 样式化发送按钮
- en: We have a Send button at the bottom of our form. Let’s make it a bit more prominent
    and make it match the rest of our form. We’ll create a rule that targets this
    button.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在表单底部有一个发送按钮。让我们让它更加突出，并使其与我们的表单匹配。我们将创建一个针对此按钮的规则。
- en: Next, we’ll remove the border, curve the corners, and edit the text and background
    colors. In the “before” part of figure 10.23, the button text is smaller than
    our default font size, so we also change `font-size` to `1rem`. Finally, we set
    our button padding.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将移除边框，使角落圆滑，并编辑文本和背景颜色。在图 10.23 的“之前”部分，按钮文本的大小小于我们的默认字体大小，因此我们也将其 `font-size`
    改为 `1rem`。最后，我们设置了按钮的内边距。
- en: '![](../Images/10-23.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10-23.png)'
- en: Figure 10.23 Styled Send button
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.23 样式化的发送按钮
- en: To make our button stand out even more, we’ll separate it a little bit from
    the rest of our fields. The button is located inside a `<div>` with a class of
    `actions`. We’ll give this `<div>` a top margin of `2rem`, which will move the
    button down a little farther from the Subscribe check box. The following listing
    shows our new rules, and figure 10.23 shows our progress.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的按钮更加突出，我们将将其与我们的其他字段稍微分开。按钮位于一个具有 `actions` 类的 `<div>` 中。我们将为此 `<div>`
    设置 `2rem` 的上边距，这将使按钮从订阅复选框下移得更远。以下列表显示了我们的新规则，图 10.23 展示了我们的进度。
- en: Listing 10.18 Resetting button styles
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.18 重置按钮样式
- en: '[PRE19]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Next, let’s style the error messages.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们样式化错误信息。
- en: 10.8 Error handling
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.8 错误处理
- en: Below the Name, Email, and Message controls are error messages. Currently, they’re
    un-styled, so they aren’t easy to identify as error messages or to match them
    with the fields that the errors describe. Furthermore, we don’t want to show this
    error message until the user has interacted with the control. Nobody wants an
    error message yelling at them before they’ve even started.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在姓名、电子邮件和消息控件下方是错误信息。目前，它们未进行样式化，因此不容易识别为错误信息，或者将它们与描述的错误字段匹配。此外，我们希望在用户与控件交互之前不显示此错误信息。没有人希望在开始之前就看到一个错误信息大声呼喊。
- en: We’re going to style the error messages to look like error messages; then we’ll
    hide them by default and show them only when appropriate. This task is where our
    JavaScript file comes into play.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将样式化错误信息，使其看起来像错误信息；然后我们将默认隐藏它们，仅在适当的时候显示。这项任务就是我们的 JavaScript 文件发挥作用的地方。
- en: We’re going to make our text red, like most error messages on the web, by setting
    that color in our `--error` custom property. We’ll also make the text bold and
    preface our error with an error icon to present it clearly as such; we don’t want
    to use color alone to convey meaning or intent.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过设置 `--error` 自定义属性将文本颜色设置为红色，就像大多数网页上的错误信息一样。我们还将使文本加粗，并在错误前加上错误图标以清晰地呈现它；我们不想仅使用颜色来传达意义或意图。
- en: Note Color is a great way to differentiate content types. But we should always
    use something else with it—such as an icon; text; or a change in size, weight,
    or shape—because people who are color-blind may not be able to differentiate between
    colors. Furthermore, some colors don’t have the same meaning across cultures.
    For reasons of accessibility and clarity, it’s best practice to use more than
    color alone to convey a message.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 注意颜色是区分内容类型的好方法。但我们应该始终与它一起使用其他元素——例如图标；文本；或大小、粗细或形状的改变——因为色盲的人可能无法区分颜色。此外，某些颜色在不同文化中不具有相同的意义。出于可访问性和清晰性的考虑，最佳实践是使用除了颜色之外的其他方式来传达信息。
- en: 'So that we can keep our error icon consistent instead of adding it before each
    error, we’ll add it programmatically via CSS, using the `::before` pseudo-element.
    To size and position the icon, we’ll use two relative units: the character unit
    (`ch`), which we used in chapter 7 and which is based on the font’s width; and
    `ex`, which is relative to the font’s X-height, which is the distance between
    the baseline and meanline of a font (figure 10.24). We use these particular units
    because they’re relative to not only the font size, but also the characteristics
    of the typeface being used. Using `ch` and `ex` units helps make the size and
    spacing between the icon and the text seem like an extension of the font that’s
    being used.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了保持我们的错误图标一致，而不是在每个错误前添加它，我们将通过 CSS 以编程方式添加它，使用 `::before` 伪元素。为了调整图标的大小和位置，我们将使用两个相对单位：字符单位（`ch`），我们在第
    7 章中使用过，它基于字体宽度；以及 `ex`，它相对于字体的 X 高度，即字体基线与平均线之间的距离（图 10.24）。我们使用这些特定的单位是因为它们不仅相对于字体大小，还相对于所使用的字体的特征。使用
    `ch` 和 `ex` 单位有助于使图标与文本之间的尺寸和间距看起来像是所用字体的延伸。
- en: '![](../Images/10-24.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10-24.png)'
- en: Figure 10.24 A visual representation of typography terms
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.24 字体术语的视觉表示
- en: We’ll also add some margin to our error `<div>` to give our input fields some
    breathing room. Our rules to style errors look like the following listing.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将为错误 `<div>` 添加一些边距，为输入字段留出一些空间。我们的错误样式规则如下所示。
- en: Listing 10.19 Error styles
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.19 错误样式
- en: '[PRE20]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ① Makes the text red
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: ① 使文本变为红色
- en: ② Makes the icon 1.25ex by 1.25ex
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: ② 使图标为 1.25ex 高和 1.25ex 宽
- en: ③ Aligns the icon to the text’s baseline
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 将图标与文本的基线对齐
- en: Notice that when we added the icon before the text, we added it to the `span`,
    not the error `<div>` itself, because we’re going to be showing and hiding the
    `span` inside the error and the entire error `<div>`. Let’s take a closer look
    at the HTML to understand why.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们将图标添加到文本之前时，我们将其添加到 `span` 中，而不是错误 `<div>` 本身，因为我们将在错误内部显示和隐藏 `span` 和整个错误
    `<div>`。让我们更仔细地看看 HTML，以了解原因。
- en: Listing 10.20 shows the complete control for the Name field, including its label
    and error message. Notice that the error `<div>` has an `id` of `nameError`, which
    is referenced by the `aria-describedby` attribute on the input field. The `aria-describedby`
    attribute tells screen readers and assistive technologies that the element whose
    `id` it references contains extra information pertaining to the input field.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.20 展示了名称字段的完整控制，包括其标签和错误信息。请注意，错误 `<div>` 有一个 `id` 为 `nameError`，它被输入字段的
    `aria-describedby` 属性引用。`aria-describedby` 属性告诉屏幕阅读器和辅助技术，它引用的元素包含与输入字段相关的额外信息。
- en: If we hide the error `<div>` in its entirety by using `display:none`, the element
    to which the `aria-describedby` is pointing won’t exist. Therefore, we hide only
    the contents (the `span`) so as not to break the programmatic connection between
    the element and its error. Because we’ll be hiding only the `span`, we need to
    apply the icon to the `span` so that it can be hidden when we hide the error message.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们通过使用 `display:none` 完全隐藏错误 `<div>`，则 `aria-describedby` 所指向的元素将不存在。因此，我们只隐藏内容（`span`），这样就不会破坏元素与其错误之间的编程连接。因为我们只隐藏
    `span`，所以我们需要将图标应用到 `span` 上，这样我们就可以在隐藏错误信息时隐藏图标。
- en: Listing 10.20 Name-field HTML
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.20 名称字段 HTML
- en: '[PRE21]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ① Indicates which <div> provides extra information about the input (referenced
    by id)
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: ① 指出哪个 <div> 提供了关于输入的额外信息（通过 id 引用）
- en: ② The ID referenced by the aria-describedby attribute
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: ② 由 aria-describedby 属性引用的 ID
- en: Figure 10.25 shows our styled error messages.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.25 展示了我们的样式化错误信息。
- en: '![](../Images/10-25.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10-25.png)'
- en: Figure 10.25 Styled error messages
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.25 样式化错误信息
- en: With our error messages styled, we can handle showing them only when appropriate.
    In figure 10.25, we see that the inputs have valid values, yet the error messages
    still appear. To show the error message only when the field is invalid, we’ll
    start by hiding the error message by default. We apply a `display` property value
    of `none` to the `span` contained in the error `<div>`; then we use the `:invalid`
    pseudo-class to show it conditionally (only when the field is invalid).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们格式化错误信息后，我们可以只在不适当的时候显示它们。在图10.25中，我们看到输入值是有效的，但错误信息仍然出现。为了仅在字段无效时显示错误信息，我们首先将错误信息默认隐藏。我们将`display`属性值设置为`none`应用于包含在错误`<div>`中的`span`元素；然后我们使用`:invalid`伪类有条件地显示它（仅当字段无效时）。
- en: 'The validity of the field in this case is determined by the properties we set
    on the field itself. Let’s look at the Name input HTML again: `<input` `type="text"`
    `id="name"` `name="name"` `maxlength="250"` `required` `aria-describedby="nameError">`.
    We included `required` and `maxlength` attributes; therefore, if there’s no value
    in the field or if the value’s length is greater than 250 characters, the field
    value will be invalid, and styles in the `:invalid` pseudo-class will be applied.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，字段的验证性是由我们设置在字段本身的属性决定的。让我们再次查看名称输入的HTML：`<input type="text" id="name"
    name="name" maxlength="250" required aria-describedby="nameError">`。我们包含了`required`和`maxlength`属性；因此，如果字段中没有值或者值的长度超过250个字符，字段值将无效，并且`:invalid`伪类中的样式将被应用。
- en: The Email element (`<input` `type="email"` `id="email"` `name="email"` `maxlength="250"`
    `required` `aria-describedby="emailError">`) also has a `maxlength` and a `required`
    attribute, so it would be invalid under the same conditions as the Name field.
    It also has a type of `email`. In HTML, some field types have validation built
    in, and `email` is one of them. If we were to enter an email address value of
    `"myEmail"`, it would be invalid.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 电子邮件元素（`<input type="email" id="email" name="email" maxlength="250" required
    aria-describedby="emailError">`）也有`maxlength`和`required`属性，所以在与名称字段相同的条件下它将是无效的。它还有一个`email`类型。在HTML中，一些字段类型有内置的验证，`email`就是其中之一。如果我们输入一个电子邮件地址值`"myEmail"`，它将是无效的。
- en: Using the `:invalid` pseudo-class helps us prevent errors from being displayed
    when the field is valid, but it doesn’t prevent errors from showing up if the
    user hasn’t interacted with the field yet. We could use the `:user-invalid` pseudo-class
    instead of `:invalid`, which would trigger one time and only after the user interacted
    with the field, but at this writing, Mozilla Firefox is the only browser that
    supports this property. So we turn to JavaScript due to the current lack of cross-browser
    support. In the future, when the `:user-invalid` property is better supported,
    we’ll no longer need to use JavaScript to show/hide our error messages based on
    user interaction. The script included in the project listens for blur events,
    which happen when an element loses focus. When we click or tab away from a field,
    a blur event occurs. Our script listens for these events and adds a class of `dirty`
    to the field that we’ve navigated away from, letting us know which fields have
    been interacted with and which haven’t. Those with a class of `dirty` have; without
    a class of `dirty` have not.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`:invalid`伪类可以帮助我们在字段有效时防止错误显示，但它不能防止在用户尚未与字段交互时错误显示。我们可以使用`:user-invalid`伪类代替`:invalid`，这将触发一次，并且仅在用户与字段交互后，但在此写作时，只有Mozilla
    Firefox浏览器支持这个属性。因此，由于当前缺乏跨浏览器支持，我们转向使用JavaScript。在未来，当`:user-invalid`属性得到更好的支持时，我们就不再需要使用JavaScript根据用户交互来显示/隐藏我们的错误信息。项目中包含的脚本监听blur事件，这发生在元素失去焦点时。当我们点击或切换到字段之外时，就会发生blur事件。我们的脚本监听这些事件，并给离开的字段添加一个`dirty`类，让我们知道哪些字段已被交互，哪些尚未。带有`dirty`类的字段已被交互；没有`dirty`类的字段尚未交互。
- en: Because we have this `dirty` class, in conjunction with the `:invalid` pseudo-class,
    we’ll show the error message only below controls that are invalid and that the
    user has touched, preventing us from showing error messages before the user has
    had a chance to fill out the form. We use the selector `.dirty:invalid` `+` `.error`
    `span`. We select the `span` contained in an element that has a class of `error`
    located immediately after an element that is both invalid and has a class of `dirty`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们有这个“脏”类，结合`:invalid`伪类，我们只会在无效且用户已触摸的控件下方显示错误信息，从而防止我们在用户有机会填写表单之前显示错误信息。我们使用选择器`.dirty:invalid`
    `+` `.error` `span`。我们选择包含在具有`error`类的元素中的`span`，该元素紧接在一个既无效又具有`dirty`类的元素之后。
- en: Last, we’ll change the border color of the field to our error color when it’s
    both invalid and `dirty`. Because we used a border image to create the gradient
    effect, we need to remove it. The following listing shows the full rules for showing
    and hiding the error messages.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当字段既无效又“脏”时，我们将字段的边框颜色更改为我们的错误颜色。因为我们使用边框图像创建渐变效果，所以需要移除它。以下列表显示了显示和隐藏错误信息的完整规则。
- en: Listing 10.21 Error-handling CSS
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.21 错误处理CSS
- en: '[PRE22]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ① Hides the error message by default
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: ① 默认隐藏错误信息
- en: ② Shows the error message when the field immediately before it in the HTML is
    dirty and invalid
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: ② 当HTML中紧接其前的字段脏且无效时显示错误信息
- en: ③ Changes input and textarea border color to red when invalid and dirty
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 当输入和文本区域无效且脏时，更改其边框颜色为红色
- en: 'Figure 10.26 shows fields in their three possible states: invalid and dirty,
    valid, and invalid but not yet touched.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.26显示了字段的三种可能状态：无效和脏，有效，以及无效但尚未触摸。
- en: '![](../Images/10-26.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10-26.png)'
- en: Figure 10.26 Error-handling and field states
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.26 错误处理和字段状态
- en: On the surface, our form seems to be finished, but we still have some finishing
    touches to add.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上，我们的表单似乎已经完成，但我们仍然需要添加一些收尾工作。
- en: 10.9 Adding hover and focus styles to form elements
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.9 向表单元素添加悬停和焦点样式
- en: Because we want our form to be accessible, we need to make sure to include hover
    styles and to update the default focus styles to match our theme for our controls
    and buttons. We’ve already handled the hover styles for radio buttons and check
    boxes but not the focus. For the other elements, we haven’t considered the hover
    and focus states.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们希望我们的表单易于访问，所以我们需要确保包括悬停样式，并更新控件和按钮的默认焦点样式以匹配我们的主题。我们已经处理了单选按钮和复选框的悬停样式，但还没有处理焦点样式。对于其他元素，我们还没有考虑悬停和焦点状态。
- en: Let’s start with focus because we still need to apply it to everything on our
    form. Focus is important for users who navigate the web via the keyboard rather
    than clicking elements with a mouse. It gives the user a visual indicator of which
    element currently has focus. Therefore, if we don’t like the default focus styles,
    it’s fine to restyle them but not remove them.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从焦点开始，因为我们仍然需要将焦点应用到我们表单上的所有元素。对于通过键盘而不是用鼠标点击元素来导航网页的用户来说，焦点很重要。它为用户提供了一个视觉指示器，显示哪个元素当前具有焦点。因此，如果我们不喜欢默认的焦点样式，可以重新设计它们，但不能移除它们。
- en: 10.9.1 Using :focus versus :focus-visible
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.9.1 使用 :focus 与 :focus-visible
- en: 'Because showing the focus styles all the time regardless of how the user is
    navigating the web can be overwhelming depending on the design, a new property
    was recently added to the CSS specification to apply focus styles based on the
    user’s modality: keyboard or mouse. The pseudo-class :`focus-visible` allows us
    to add styles when the user is interacting with the keyboard but won’t apply it
    when the user is using a mouse. By contrast, `:focus` always applies regardless
    of the user’s method of interacting with the element.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 由于无论用户如何导航网页，始终显示焦点样式可能会根据设计而显得过于繁重，CSS规范最近增加了一个新属性，根据用户的交互模式（键盘或鼠标）应用焦点样式：`:focus-visible`伪类允许我们在用户使用键盘交互时添加样式，但不会在用户使用鼠标时应用它。相比之下，`:focus`始终应用，无论用户与元素的交互方式如何。
- en: For our text and email input fields, drop-down menu, and text area, we’ll remove
    the default outline and change the border’s color from the gradient to a solid
    color. Because (as we mentioned earlier in this chapter) we don’t want to rely
    on color alone for differentiation, we’ll also change the border style from solid
    to dashed, as shown in listing 10.22\. We also need to consider what to do with
    our fields when they’re dirty and invalid (show the error message and have a red
    border). We want to keep the color differentiation between the fields in an error
    state, so we write a second rule to maintain the red border color.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的文本和电子邮件输入字段、下拉菜单和文本区域，我们将移除默认轮廓并将边框颜色从渐变更改为纯色。因为（正如我们在本章前面提到的）我们不想仅依靠颜色来区分，所以我们将边框样式从实线更改为虚线，如列表
    10.22 所示。我们还需要考虑当字段被污染且无效时（显示错误消息并带有红色边框）应该做什么。我们希望保持错误状态下字段之间的颜色区分，因此我们编写了第二个规则以保持红色边框颜色。
- en: Listing 10.22 Styling text fields and drop-down menu when focused
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.22 当文本字段和下拉菜单获得焦点时的样式
- en: '[PRE23]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ① Removes the default outline
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: ① 移除默认轮廓
- en: ② Removes the gradient image
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: ② 移除渐变图像
- en: ③ Maintains the border color when the field has been interacted with and its
    value is invalid
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 当字段已被交互且其值无效时保持边框颜色
- en: Figure 10.27 shows our updated fields when in focus.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.27 展示了我们的更新字段在获得焦点时的样子。
- en: '![](../Images/10-27.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10-27.png)'
- en: Figure 10.27 Text fields and drop-down menu when focused
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.27 当文本字段和下拉菜单获得焦点时的样子
- en: Next, we need to handle the focus state for our radio buttons and check boxes.
    For those elements, we’ll keep the outline but edit its appearance. As we did
    for our other fields, we’ll use a dashed line and the primary color. We also offset
    the outline to create separation between the border and the outline, as shown
    in listing 10.23.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要处理单选按钮和复选框的焦点状态。对于这些元素，我们将保持轮廓但编辑其外观。就像我们处理其他字段一样，我们将使用虚线和主要颜色。我们还将偏移轮廓以在边框和轮廓之间创建分隔，如列表
    10.23 所示。
- en: Listing 10.23 Styling radio buttons and check boxes when focused
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.23 当文本框和复选框获得焦点时的样式
- en: '[PRE24]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ① Moves the outline out 2 pixels so that it isn’t right up against the border
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: ① 将轮廓向外移动 2 像素，使其不紧挨着边框
- en: Figure 10.28 shows our radio buttons and check box when focused.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.28 展示了我们的单选按钮和复选框在获得焦点时的样子。
- en: '![](../Images/10-28.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10-28.png)'
- en: Figure 10.28 Focus styles for radio buttons and check box
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.28 单选按钮和复选框的焦点样式
- en: With focus handled, let’s turn our attention to hover.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 当焦点问题处理完毕后，让我们将注意力转向悬停。
- en: 10.9.2 Adding hover styles
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.9.2 添加悬停样式
- en: Fields in which the user inputs text, such as inputs with a type of `text` and
    `email` or `<textarea>`s, already change the cursor type from the default to text
    on hover. Figure 10.29 shows what each cursor type looks like. Note that cursors
    may look slightly different depending on the operating system, browser, and user
    settings.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 用户输入文本的字段，例如类型为 `text` 和 `email` 的输入或 `<textarea>`，在悬停时已经将光标类型从默认更改为文本。图 10.29
    展示了每种光标类型的外观。请注意，根据操作系统、浏览器和用户设置，光标可能看起来略有不同。
- en: '![](../Images/10-29.png)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10-29.png)'
- en: Figure 10.29 Cursors in Chrome
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.29 Chrome 中的光标
- en: Although our text and email inputs and text area already have some differentiation
    on hover, our drop-down menu doesn’t. Let’s change its cursor to a pointer to
    emphasize that the field is clickable, as shown in the following listing.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的文本和电子邮件输入以及文本区域在悬停时已经有一些区分，但我们的下拉菜单没有。让我们将其光标更改为指针以强调该字段是可点击的，如以下列表所示。
- en: Listing 10.24 Selecting hover styles
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.24 选择悬停样式
- en: '[PRE25]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: With focus and hover handled, the last thing we need to worry about is making
    sure that our styles work for users who have `forced-colors:` `active` enabled.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理了焦点和悬停之后，我们最后需要担心的是确保我们的样式对那些启用了 `forced-colors:` `active` 的用户也是有效的。
- en: 10.10 Handling forced-colors mode
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.10 处理 forced-colors 模式
- en: The `forced-colors` mode is a high-contrast setting that allows a user to limit
    the color palette to a series of colors that they set on their device. Windows’
    High Contrast mode is an example of this use case. When this mode is enabled,
    it affects many CSS properties, including some that we’ve used in this project,
    most notably `background-color`. We used `background-color` to determine whether
    the inner portion of the `radio` and `checkbox` inputs were visible for selected
    versus unselected elements. We also used it to restyle the arrow for the `select`
    control.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`forced-colors` 模式是一种高对比度设置，允许用户将调色板限制为他们在其设备上设置的系列颜色。Windows 的高对比度模式是这种用例的一个例子。当此模式启用时，它会影响许多
    CSS 属性，包括我们在本项目中使用的一些属性，最值得注意的是 `background-color`。我们使用 `background-color` 来确定
    `radio` 和 `checkbox` 输入的内侧部分在选中与未选中元素时是否可见。我们还用它来重新设计 `select` 控件的箭头。'
- en: 'In Chrome, we can use DevTools to emulate enabling `forced-colors` mode on
    our machine without having to edit our computer settings. In the console of our
    DevTools, choose the rendering tab. If it isn’t already displayed, we can click
    the ellipsis button to display the possible tabs and choose it from the drop-down
    menu. On the tab, we look for the `forced-colors` emulation drop-down menu and
    set it to `forced-colors:` `active`. This setting updates the page’s styles to
    act as though we had `forced-colors` set to `active` on our machine. Figure 10.30
    shows the Chrome DevTools settings that enable the emulation. (Note: Browsers
    other than Chrome may not have this functionality, or the technique for enabling
    it may be different.)'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Chrome 中，我们可以使用 DevTools 来模拟在我们的机器上启用 `forced-colors` 模式，而无需编辑我们的计算机设置。在我们的
    DevTools 控制台中，选择渲染选项卡。如果它尚未显示，我们可以点击省略号按钮以显示可能的选项卡并从下拉菜单中选择它。在选项卡上，我们寻找 `forced-colors`
    模拟下拉菜单并将其设置为 `forced-colors:` `active`。此设置更新页面样式，使其看起来就像我们在机器上设置了 `forced-colors`
    为 `active`。图 10.30 显示了启用模拟的 Chrome DevTools 设置。（注意：除了 Chrome 之外的其他浏览器可能没有此功能，或者启用它的技术可能不同。）
- en: '![](../Images/10-30.png)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/10-30.png)'
- en: Figure 10.30 A `forced-colors:active` emulation setup in Chrome DevTools
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.30 Chrome DevTools 中的 `forced-colors:active` 模拟设置
- en: When the emulation is applied, our page styles change (figure 10.31). We can’t
    tell which radio button is selected or whether the check box is checked. This
    example demonstrates the importance of using more than color to differentiate
    meaning, because our error message is no longer red.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用模拟时，我们的页面样式会改变（图 10.31）。我们无法判断哪个单选按钮被选中或复选框是否被勾选。这个例子说明了使用不仅仅是颜色来区分意义的重要性，因为我们的错误信息不再为红色。
- en: '![](../Images/10-31.png)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/10-31.png)'
- en: Figure 10.31 Emulated `forced-colors:` `active`
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.31 模拟的 `forced-colors:` `active`
- en: We won’t try to reinstate our colors in this mode, because we want to respect
    the user’s settings. But we need to make sure that selected inputs are distinguishable
    from those that aren’t selected.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会尝试在这个模式下恢复我们的颜色，因为我们想尊重用户的设置。但我们需要确保选中的输入与未选中的输入可区分。
- en: To create rules that apply only when users have `forced-colors` set to `active`,
    we’ll use the media query `@media` `(forced-colors:` `active)` `{` `}`. Rules
    created inside the media query will take effect only when users have `forced-colors`
    enabled.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建仅当用户将 `forced-colors` 设置为 `active` 时才应用的规则，我们将使用媒体查询 `@media` `(forced-colors:`
    `active`) `{}`。在媒体查询内创建的规则将仅在用户启用了 `forced-colors` 时生效。
- en: The reason why our check box and radio buttons are no longer visible is that
    the system-defined background color (in this case, white) is being applied to
    them. So we’ll change our background to use a system color rather than our accent
    color. The CSS Color Module Level 4 specification ([http://mng.bz/o1Vy](http://mng.bz/o1Vy))
    lists the colors available to us. We’re going to use `CanvasText`, meaning that
    the color we’ll apply will be the same as the color being used for the text. The
    following listing shows our full media query.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们复选框和单选按钮不再可见的原因是系统定义的背景颜色（在这种情况下，为白色）正在应用于它们。因此，我们将更改我们的背景以使用系统颜色而不是我们的强调颜色。CSS
    颜色模块第 4 级规范（[http://mng.bz/o1Vy](http://mng.bz/o1Vy)）列出了我们可用的颜色。我们将使用 `CanvasText`，这意味着我们将应用的颜色将与用于文本的颜色相同。以下列表显示了我们的完整媒体查询。
- en: Listing 10.25 `forced-colors:` `active` media query
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.25 `forced-colors:` `active` 媒体查询
- en: '[PRE26]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Figure 10.32 shows our page in `forced-colors` mode with our media query applied,
    fixing the styles that were creating problems for our users.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.32 显示了应用媒体查询后的 `forced-colors` 模式下的我们的页面，修复了为我们的用户创建问题的样式。
- en: '![](../Images/10-32.png)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/10-32.png)'
- en: Figure 10.32 `forced-colors:` `active` styles fixed
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.32 `forced-colors:` `active`样式固定
- en: When we turn the emulation off, our previously set styles remain as they were;
    they’re not affected by those set inside the media query (figure 10.33).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们关闭模拟时，之前设置的样式保持不变；它们不受媒体查询内设置的样式的影响（图10.33）。
- en: '![](../Images/10-33.png)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10-33.png)'
- en: Figure 10.33 Finished product
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.33 完成产品
- en: With this last task complete, we’ve finished styling our form.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个最后的任务后，我们已经完成了表单的样式设计。
- en: Summary
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Form controls whose functionality is tightly coupled with the operating system,
    such as drop-down menus, are harder to style than those that lack this coupling.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与操作系统紧密耦合的功能表单控件，如下拉菜单，比那些缺乏这种耦合的控件更难样式化。
- en: We can create shapes by using gradients.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过使用渐变来创建形状。
- en: By using `em`, we can size elements to scale with text size.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用`em`，我们可以根据文本大小调整元素的大小。
- en: To inherit `font-color` when doing so isn’t possible otherwise, we can use the
    keyword value `currentcolor`.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当无法以其他方式继承`font-color`时，我们可以使用关键字值`currentcolor`。
- en: The :`where()` and `:is()` pseudo-classes work similarly but have different
    levels of specificity.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:where()`和`:is()`伪类的工作方式类似，但具有不同的特定性级别。'
- en: The `:checked` pseudo-class allows us to target form elements when they’re selected.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:checked`伪类允许我们在元素被选中时定位表单元素。'
- en: The `:invalid` pseudo-class can be used to format fields conditionally when
    they’re invalid.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:invalid`伪类可以在字段无效时有条件地格式化字段。'
- en: The validity of a field’s value is determined by the attributes set on the field
    in the HTML.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字段值的有效性由在HTML中设置的字段属性决定。
- en: '`:focus` styles are necessary to make our designs accessible.'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:focus`样式对于使我们的设计可访问是必要的。'
- en: We can use `:focus-visible` to make focus style show only for keyboard users.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`:focus-visible`使焦点样式仅对键盘用户显示。
- en: In some browsers, we can forcibly make the browser apply hover and focus styles.
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某些浏览器中，我们可以强制浏览器应用悬停和焦点样式。
- en: It’s important to use more than color alone to convey meaning, as demonstrated
    by the error messages in this project.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅使用颜色来传达意义是不够的，正如本项目中的错误信息所展示的那样。
- en: '`forced-colors` mode changes how some properties behave and the colors we can
    apply to the user interface.'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forced-colors`模式改变了某些属性的行为以及我们可以应用于用户界面的颜色。'
- en: Media queries can be used to apply styles conditionally when `forced-colors`
    is set to `active`.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`forced-colors`设置为`active`时，可以使用媒体查询有条件地应用样式。
- en: In some browsers, we can emulate `forced-colors` mode to check our designs.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某些浏览器中，我们可以模拟`forced-colors`模式来检查我们的设计。
- en: '* * *'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '¹  *Architecting CSS: The Programmer’s Guide to Effective Style Sheets*, by
    Martine Dowden and Michael Dowden (2020, Apress).'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: ¹  《架构CSS：程序员的样式表指南》，作者：Martine Dowden 和 Michael Dowden（2020年，Apress出版社）。
