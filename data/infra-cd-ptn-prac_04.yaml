- en: 3 Patterns for infrastructure modules
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3种基础设施模块的模式
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Grouping infrastructure resources into composable modules based on function
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据功能将基础设施资源分组为可组合的模块
- en: Building infrastructure modules with software development design patterns
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用软件开发设计模式构建基础设施模块
- en: Applying module patterns to common infrastructure use cases
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将模块模式应用于常见的基础设施用例
- en: In the preceding chapter, I covered the fundamental practices for infrastructure
    as code. Even though I knew the fundamental practices, my first Python automation
    script grouped code into one file with messy functions. Years later, I learned
    software design patterns. They provided a standard set of patterns that made it
    easier for me to change the script and hand it over to another teammate for maintenance.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我介绍了基础设施即代码的基本实践。尽管我知道这些基本实践，但我的第一个Python自动化脚本将代码分组到一个文件中，其中包含混乱的函数。多年以后，我学习了软件设计模式。它们提供了一套标准的模式，使我更容易修改脚本并将其转交给另一位队友进行维护。
- en: In the following two chapters, I show how to apply design patterns to IaC configuration
    and dependencies. Software *design patterns* help you identify common problems
    and build reusable, object-oriented solutions.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两个章节中，我将展示如何将设计模式应用于IaC配置和依赖关系。软件*设计模式*可以帮助您识别常见问题并构建可重用、面向对象的解决方案。
- en: Definition A *design pattern* is a repeatable solution to a common problem in
    software.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 A *设计模式*是针对软件中常见问题的可重复解决方案。
- en: Applying software design patterns to IaC has its pitfalls. IaC has reusable
    objects (as infrastructure resources). However, its opinionated behaviors and
    DSLs do not map directly to software design patterns.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 将软件设计模式应用于IaC有其陷阱。IaC有可重用对象（作为基础设施资源）。然而，其有偏见的特性和DSL并不直接映射到软件设计模式。
- en: IaC offers an immutable layer of abstraction, which is why this chapter borrows
    both *creational* (used for creating objects) and *structural* (for structuring
    objects) design patterns to make approximations to infrastructure. Most IaC focuses
    on immutability, which automatically creates a new resource upon changes. As a
    result, the design patterns that rely on mutability do not apply.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: IaC提供了一层不可变的抽象层，这就是为什么本章借鉴了*创建型*（用于创建对象）和*结构型*（用于结构化对象）设计模式来对基础设施进行近似。大多数IaC都关注不可变性，这会在更改时自动创建新的资源。因此，依赖于可变性的设计模式不适用。
- en: 'Note I adapted many patterns from *Design Patterns: Elements of Reusable Object-Oriented
    Software* by Erich Gamma et al. (Addison-Wesley Professional, 1994) to IaC. If
    you would like to learn more about the original software design patterns, I recommend
    referencing that book.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我改编了许多来自Erich Gamma等人所著的《设计模式：可复用面向对象软件元素》（Addison-Wesley Professional，1994年）的图案应用到IaC中。如果您想了解更多关于原始软件设计模式的信息，我建议您参考那本书。
- en: I include Python code listings that create Terraform JSON files. They reference
    GCP resources. You can extend the patterns to DSLs, such as Terraform, CloudFormation,
    or Bicep. Depending on the DSL and tool you choose, it might use different mechanisms
    or features. When possible, I note limitations for DSLs and equivalents for AWS
    and Azure.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我包括创建Terraform JSON文件的Python代码示例。它们引用了GCP资源。您可以将这些模式扩展到DSL，如Terraform、CloudFormation或Bicep。根据您选择的DSL和工具，它可能使用不同的机制或功能。在可能的情况下，我会指出DSL的限制以及AWS和Azure的等效功能。
- en: 3.1 Singleton
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 单例
- en: Imagine you need to create a set of database servers in GCP from scratch. The
    database system needs a GCP project, custom database network, server template,
    and server group. The server template installs the packages on each server, while
    the server group describes the number of database servers you need.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您需要从头开始在GCP中创建一组数据库服务器。数据库系统需要一个GCP项目、自定义数据库网络、服务器模板和服务器组。服务器模板会在每个服务器上安装软件包，而服务器组描述了您需要的数据库服务器数量。
- en: Figure 3.1 shows how to add the project, database network, server template,
    and server group to one directory. You determine the attributes for the GCP project
    name and its organization. Next, you figure out the network should have the name
    `development-database-network` with an IP address range of 10.0.3.0/16\. Finally,
    you express that the database should have three servers that use templates for
    MySQL. You write all these attributes as code into one configuration file.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1显示了如何将项目、数据库网络、服务器模板和服务器组添加到一个目录中。您确定GCP项目名称及其组织的属性。接下来，您确定网络应具有名为`development-database-network`的名称，其IP地址范围为10.0.3.0/16。最后，您表达数据库应具有三个使用MySQL模板的服务器。您将这些属性作为代码写入一个配置文件中。
- en: The database system configuration uses the *singleton pattern*, which declares
    a set of resources as singular instances in a system.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库系统配置使用单例模式，该模式将一组资源声明为系统中的单个实例。
- en: Definition The *singleton pattern* declares a set of resources as singular instances
    in a system. It deploys all the resources with a single command.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 单例模式将一组资源声明为系统中的单个实例。它使用单个命令部署所有资源。
- en: Why do we call it a *singleton* pattern? You create one file or directory with
    a static configuration. Furthermore, you define several parameters inline to create
    all infrastructure resources with a single command. That configuration expresses
    resources unique and specific to the environment created by the configuration.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么称之为单例模式？您创建一个具有静态配置的单个文件或目录。此外，您定义几个参数以单行方式创建所有基础设施资源。该配置表达了资源在由配置创建的环境中的独特性和特定性。
- en: '![](../../OEBPS/Images/CH03_F01_Wang.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH03_F01_Wang.png)'
- en: Figure 3.1 A singleton pattern expresses the configuration of an initial set
    of resources—such as a project, network, and database—in one file. This pattern
    captures the relationships among resources in one place.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 单例模式表达了一组初始资源（如项目、网络和数据库）的配置，这些资源在一个文件中。这种模式捕捉了资源之间的关系。
- en: The singleton pattern simplifies writing IaC because you put everything in one
    configuration. When you express every infrastructure resource in a single configuration,
    you get a single reference to debug and troubleshoot the provisioning order and
    required parameters.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式简化了IaC（基础设施即代码）的编写，因为您将所有内容放入一个配置中。当您在一个配置中表达每个基础设施资源时，您将获得一个单独的引用来调试和解决供应顺序和所需参数。
- en: However, starting with the singleton pattern often leads to challenges later.
    When I started using the singleton pattern, I treated infrastructure configuration
    like a junk drawer—storage for random items that don’t have a place otherwise.
    The drawer becomes the first place you look if you cannot find something (figure
    3.2).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从单例模式开始通常会导致后续的挑战。当我开始使用单例模式时，我把基础设施配置当作一个杂物抽屉——存放那些没有其他地方可放的随机物品。如果您找不到某物，抽屉将成为您首先查看的地方（图3.2）。
- en: '![](../../OEBPS/Images/CH03_F02_Wang.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH03_F02_Wang.png)'
- en: Figure 3.2 If you do not know where to put an object, add it to the junk drawer,
    which uses the singleton pattern to aggregate all resources.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 如果您不知道将对象放在哪里，请将其添加到杂物抽屉中，该抽屉使用单例模式来聚合所有资源。
- en: Because I didn’t know where else to configure infrastructure resources, I just
    added them to one file. Eventually, the singleton pattern became messy like a
    junk drawer! I had to search the singleton for an infrastructure resource. In
    addition, the number of infrastructure resources in the singleton means it takes
    time to identify, change, and create resources.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我不知道其他地方可以配置基础设施资源，所以我只是将它们添加到一个文件中。最终，单例模式变得像杂物抽屉一样混乱！我不得不在单例中搜索基础设施资源。此外，单例中的基础设施资源数量意味着识别、更改和创建资源需要花费时间。
- en: The singleton pattern challenges reproducibility as your system grows with more
    resources. Producing the configuration for production means copying and pasting
    it into a new file. Copying and pasting configuration does not scale when you
    have more resources to update! Singletons come at the cost of scalability and
    composability. It works for a few infrastructure resources but doesn’t scale with
    complex systems.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 随着系统随着更多资源的增长而扩展，单例模式对可重复性提出了挑战。为生产环境生成配置意味着将其复制并粘贴到新文件中。当您有更多资源需要更新时，复制和粘贴配置无法扩展！单例以可扩展性和可组合性为代价。它适用于少量基础设施资源，但不能与复杂系统一起扩展。
- en: When should you use a singleton? It works best when you have a resource that
    requires only a single instance and rarely changes, such as the GCP project. The
    network, database server template, and server group must go into another configuration.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在何时使用单例？当您有一个只需要单个实例且很少更改的资源时，它效果最好，例如GCP项目。网络、数据库服务器模板和服务器组必须放入另一个配置中。
- en: All GCP projects must have a unique identifier, which makes it ideal for the
    singleton pattern. The project can have only a single instance. For example, you
    could create a project named *databases* and generate a unique identifier based
    on your current system username. The following listing shows the code to implement
    the singleton pattern for creating a GCP project with your system username.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 GCP 项目都必须有一个唯一的标识符，这使得单例模式非常理想。项目只能有一个实例。例如，你可以创建一个名为 *databases* 的项目，并根据当前系统用户名生成一个唯一标识符。以下列表显示了实现使用系统用户名创建
    GCP 项目的单例模式的代码。
- en: Listing 3.1 Creating a project in GCP by using a singleton pattern
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.1 使用单例模式在 GCP 中创建项目
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Creates an object for the database Google project
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 为数据库 Google 项目创建一个对象
- en: ❷ Sets up the Google project using a Terraform resource with the name “databases”
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用名为“databases”的 Terraform 资源设置 Google 项目
- en: ❸ Gets the operating system user and sets it to the organization variable
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 获取操作系统用户并将其设置为组织变量
- en: ❹ Makes a unique project ID based on the project name and operating system user
    so GCP can create the project
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 根据项目名称和操作系统用户创建一个唯一的项目 ID，以便 GCP 可以创建项目
- en: ❺ Creates a DatabaseGoogleProject to generate the JSON configuration for the
    project
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 创建一个 `DatabaseGoogleProject` 来生成项目的 JSON 配置
- en: ❻ Writes the Python dictionary to a JSON file to be executed by Terraform later
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 将 Python 字典写入 JSON 文件，以便 Terraform 以后执行
- en: AWS and Azure equivalents
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: AWS 和 Azure 等效
- en: You can equate a GCP project to an AWS account. To automate the creation of
    AWS accounts, you need to use AWS Organizations ([https://aws.amazon.com/organizations/](https://aws.amazon.com/organizations/)).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 GCP 项目等同于 AWS 账户。为了自动化 AWS 账户的创建，你需要使用 AWS Organizations ([https://aws.amazon.com/organizations/](https://aws.amazon.com/organizations/))。
- en: In Azure, you would create a subscription and a resource group. You can create
    a resource group by using the `azurerm_resource_group` Terraform resource ([http://mng.bz/1orq](http://mng.bz/1orq)).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Azure 中，你会创建一个订阅和一个资源组。你可以通过使用 `azurerm_resource_group` Terraform 资源来创建资源组
    ([http://mng.bz/1orq](http://mng.bz/1orq))。
- en: Imagine you want to create a server in your database project. You can call the
    `DatabaseGoogleProject` singleton and extract the project identifier from the
    JSON configuration. A singleton contains unique resources that you can reference
    with a call to the module. For example, if you reference the `database` project,
    you will always get the correct project and not a different one.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要在你的数据库项目中创建一个服务器。你可以调用 `DatabaseGoogleProject` 单例并从 JSON 配置中提取项目标识符。单例包含独特的资源，你可以通过模块的调用来引用它们。例如，如果你引用
    `database` 项目，你将始终得到正确的项目，而不会是另一个项目。
- en: You use a singleton for a GCP project because you create it *once* and change
    it *infrequently*. You can apply the singleton pattern to rarely changed *global*
    resources such as provider accounts, projects, domain name registrations, or root
    SSL certificates. It also works for static environments, such as low-use data
    center environments.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用一个单例来表示 GCP 项目，因为你只创建它一次，并且很少更改。你可以将单例模式应用于很少更改的 *全局* 资源，例如提供者账户、项目、域名注册或根
    SSL 证书。它也适用于静态环境，例如低使用率的数据中心环境。
- en: 3.2 Composite
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 组合
- en: Instead of expressing the database system in one singleton, you can organize
    the components into modules. A *module* groups infrastructure resources that share
    a function or business domain. Modules allow you to change the automation of the
    parts without affecting the whole.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将数据库系统组织到单个单例中，而不是用模块来组织组件。*模块* 将具有相同功能或业务领域的基础设施资源分组在一起。模块允许你更改部分自动化，而不会影响整体。
- en: Definition A *module* organizes infrastructure resources by function or business
    domain. Other tools or resources may refer to them as *infrastructure stacks*
    or *sets*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 A *模块* 通过功能或业务领域组织基础设施资源。其他工具或资源可能将它们称为 *基础设施堆栈* 或 *集合*。
- en: You can use modules as building blocks to construct your system. Other teams
    can use modules as building blocks for their unique infrastructure system.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用模块作为构建块来构建你的系统。其他团队可以将模块作为构建块来构建他们独特的基础设施系统。
- en: Figure 3.3 shows how your company might organize itself into teams and create
    a reporting structure. Each team or manager reports to another manager, leading
    to the executive level. The company uses composition of teams to achieve a common
    objective.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 展示了你的公司如何组织团队并创建报告结构。每个团队或经理向另一个经理报告，最终达到管理层。公司使用团队的组合来实现共同目标。
- en: Why would your company break reporting structures into modules? The pattern
    ensures that new initiatives or business opportunities have a team to support
    them. It promotes composability and evolvability as the company grows.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么您的公司会将报告结构分解为模块？这种模式确保了新的倡议或商业机会有一个团队来支持它们。随着公司的发展，它促进了可组合性和可扩展性。
- en: '![](../../OEBPS/Images/CH03_F03_Wang.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH03_F03_Wang.png)'
- en: Figure 3.3 Your company might use the composite pattern to group employees into
    a reporting structure, thus allowing managers to organize teams and their goals.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 您的公司可能会使用组合模式将员工分组到报告结构中，从而允许管理者组织团队及其目标。
- en: In a similar manner, most IaC depends on the *composite pattern* to group, rank,
    and structure a set of modules. You’ll often find the composite pattern classified
    as a structural pattern because it structures objects in a hierarchy.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，大多数IaC都依赖于*组合模式*来分组、排序和结构化一组模块。您通常会找到组合模式被归类为结构模式，因为它以层次结构结构化对象。
- en: Definition The *composite pattern* treats an infrastructure module as a single
    instance and allows you to assemble, group, and rank modules in a system.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *组合模式* 将基础设施模块视为单个实例，并允许您在系统中组装、分组和排序模块。
- en: Tools usually have their own modularization feature. Terraform and Bicep use
    their own module frameworks to nest and organize modules. You can use nested stacks
    or StackSets in CloudFormation to reuse templates (modules) or create stacks across
    regions. A configuration management tool like Ansible lets you build top-level
    playbooks that import other tasks.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 工具通常都有自己的模块化功能。Terraform和Bicep使用它们自己的模块框架来嵌套和组织模块。您可以在CloudFormation中使用嵌套堆栈或StackSets来重用模板（模块）或跨区域创建堆栈。像Ansible这样的配置管理工具可以让您构建顶层剧本，导入其他任务。
- en: How do you implement a module? Imagine you need to set up a network for the
    database servers. However, the server needs a subnetwork (subnet). You composite
    the network and subnet into a module, as shown in figure 3.4\. You determine how
    to set up the network first and write that into your module. Then you write down
    the configuration for the subnetwork and add it to the module.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您如何实现一个模块？想象一下，您需要为数据库服务器设置网络。然而，服务器需要一个子网络（子网）。您将网络和子网络组合到一个模块中，如图3.4所示。您首先确定如何设置网络，并将其写入模块中。然后，您写下子网络的配置并将其添加到模块中。
- en: '![](../../OEBPS/Images/CH03_F04_Wang.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH03_F04_Wang.png)'
- en: Figure 3.4 A network module can use the composite pattern to group the network
    and subnetwork resources.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 网络模块可以使用组合模式将网络和子网络资源分组。
- en: The module contains the configuration for both the network and the subnetwork.
    If you need to reproduce the network system in your production environment, you
    can always copy and paste the entire module to create a new network and subnetwork.
    A composite pattern for the network ensures that you can always reproduce a group
    of resources that depend on one another.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 模块包含网络和子网络的配置。如果您需要在生产环境中重现网络系统，您始终可以复制并粘贴整个模块来创建新的网络和子网络。网络组合模式确保您可以始终重现一组相互依赖的资源。
- en: You can implement the composite pattern for the network configuration in a module.
    As the following listing shows, the module creates a network and subnet. You pass
    the CIDR ranges for the network and subnet, and the module generates a standardized
    name for the network.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在模块中实现网络配置的组合模式。如下所示，模块创建了一个网络和子网络。您传递网络和子网络的CIDR范围，模块为网络生成一个标准化的名称。
- en: Listing 3.2 Creating a network and subnetwork
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.2 创建网络和子网络
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Creates a module for the network, which uses the composition pattern to bundle
    the network and subnet together
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个网络模块，该模块使用组合模式将网络和子网络捆绑在一起
- en: ❷ Sets the region to the default region, us-central1
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将区域设置为默认区域，us-central1
- en: ❸ Sets up the Google network using a Terraform resource with the name “my-network”.
    GCP does not require a network CIDR block to be defined.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用名为“my-network”的Terraform资源设置Google网络。GCP不需要定义网络CIDR块。
- en: ❹ Sets up the Google subnetwork using a Terraform resource with the name “my-network-subnet”
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用名为“my-network-subnet”的Terraform资源设置Google子网络
- en: ❺ Sets the subnet’s CIDR block as 10.0.0.0/28
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将子网的CIDR块设置为10.0.0.0/28
- en: ❻ Uses the module to create the JSON configuration for the network and subnetwork
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 使用模块创建网络和子网络的JSON配置
- en: ❼ Creates the Google subnetwork on the network by using a Terraform variable.
    Terraform dynamically references the network ID and inserts it to the subnetwork’s
    configuration for you.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 通过使用Terraform变量在网络上创建Google子网。Terraform会动态引用网络ID，并将其插入到子网配置中，供您使用。
- en: ❽ Sets up the Google subnetwork using a Terraform resource with the name “my-network-subnet”
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 使用名为“my-network-subnet”的Terraform资源设置Google子网
- en: ❾ Sets the subnet’s CIDR block as 10.0.0.0/28
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 将子网的CIDR块设置为10.0.0.0/28
- en: ❿ Uses the module to create the JSON configuration for the network and subnetwork
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ 使用模块创建网络的JSON配置和子网
- en: ⓫ Writes the Python dictionary to a JSON file to be executed by Terraform later
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ⓫ 将Python字典写入JSON文件，以便稍后由Terraform执行
- en: AWS and Azure equivalents
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: AWS和Azure的等效模式
- en: You can equate a GCP network and subnets to an AWS VPC and subnets, or to an
    Azure virtual network and subnets. However, in AWS and Azure, you need to define
    gateways and routing tables in each subnet. GCP automatically defines these for
    you when you create the network.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将GCP网络和子网等同于AWS VPC和子网，或者等同于Azure虚拟网络和子网。然而，在AWS和Azure中，您需要在每个子网中定义网关和路由表。当您创建网络时，GCP会自动为您定义这些。
- en: Why compose the module with the network and subnetwork? You can’t use the GCP
    network unless you have a subnet! Composition allows you to create a set of resources
    together. Bundling the required resources together helps your teammate who might
    not know much about networking. The composite pattern improves the principle of
    composability because it groups and organizes common resources that you must deploy
    as one unit.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么需要将模块与网络和子网组合？除非您有一个子网，否则您无法使用GCP网络！组合允许您一起创建一组资源。将所需的资源捆绑在一起可以帮助您的队友，他们可能不太了解网络。组合模式改进了可组合性原则，因为它将必须作为一个单元部署的常见资源分组和组织。
- en: The composite pattern works well for infrastructure because infrastructure resources
    have a hierarchy. A module following this pattern reflects relationships among
    resources and facilitates their management. If you need to update routing, you
    update the network composite configuration. You can refer to the network configuration
    to determine subnet CIDR ranges and calculate network address space.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 组合模式对于基础设施来说效果很好，因为基础设施资源具有层次结构。遵循此模式的模块反映了资源之间的关系，并促进了它们的管理。如果您需要更新路由，您将更新网络组合配置。您可以通过参考网络配置来确定子网CIDR范围并计算网络地址空间。
- en: You apply the composite pattern by grouping resources based on function, business
    unit, or operational responsibility. As you draft the initial module, you may
    add variables to allow more flexible parameters or distribute the configuration
    to other teams. I discuss how to share modules in chapter 5\. However, you can
    apply other patterns outside of a general composite pattern to further improve
    the reproducibility of IaC.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过根据功能、业务单元或运营责任对资源进行分组来应用组合模式。在您起草初始模块时，您可能需要添加变量以允许更灵活的参数或分发配置给其他团队。我在第5章中讨论了如何共享模块。然而，您可以在通用组合模式之外应用其他模式，以进一步提高IaC的可重复性。
- en: 3.3 Factory
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 工厂
- en: Previously, you used the singleton pattern to create a GCP project for the database
    system. Then you applied the composite pattern and built the network in a different
    module. However, now you realize you need a database network divided into three
    subnets. Rather than copying and pasting three subnets, you want to create a configuration
    that accepts inputs with the subnet name and IP address range.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，您使用单例模式为数据库系统创建了一个GCP项目。然后您应用了组合模式，并在不同的模块中构建了网络。然而，现在您意识到您需要一个分为三个子网的数据库网络。与其复制和粘贴三个子网，您希望创建一个接受子网名称和IP地址范围输入的配置。
- en: A configuration to create three subnets and a network requires many parameters,
    which can be tedious to include and maintain. What if you had something like a
    factory to manufacture all of the resources with opinionated defaults? Figure
    3.5 shows that you can create a network factory to stamp out similar networks.
    You can reduce the required parameters to two inputs and other configurations
    to default values.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 创建三个子网和一个网络配置需要许多参数，这些参数可能很繁琐，难以包含和维护。如果有一个类似工厂的设施来制造所有具有默认意见的资源会怎样？图3.5显示，您可以创建一个网络工厂来批量生产类似网络。您可以将所需的参数减少到两个输入，并将其他配置设置为默认值。
- en: '![](../../OEBPS/Images/CH03_F05_Wang.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH03_F05_Wang.png)'
- en: Figure 3.5 A factory pattern module includes a set of defaults for a minimal
    resource configuration and enables customization by accepting input variables.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 工厂模式模块包含一组最小资源配置的默认值，并通过接受输入变量来启用定制。
- en: When you know the network has specific default attributes, you can minimize
    the inputs and produce multiple resources with less effort. I call this approach
    the *factory pattern*. A module that uses the factory pattern takes a set of inputs,
    such as name and IP address range, and creates a set of infrastructure resources
    based on the inputs.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当你知道网络有特定的默认属性时，你可以最小化输入，并更轻松地生成多个资源。我称这种方法为*工厂模式*。使用工厂模式的模块接受一组输入，例如名称和IP地址范围，并根据输入创建一组基础设施资源。
- en: Definition The *factory pattern* takes a set of input variables and creates
    a set of infrastructure resources based on input variables and default constants.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 定义：*工厂模式*接受一组输入变量，并根据输入变量和默认常量创建一组基础设施资源。
- en: You want to offer just enough flexibility to make changes, such as the subnet’s
    IP address and name. In general, you need to find a balance in your module between
    offering just enough customization and using opinionated default attributes. After
    all, you want to promote the principle of reproducibility but maintain the resource’s
    evolvability. We’ll discuss more about sharing resources such as modules in chapter
    5, and standardizing secure practices for modules in chapter 8.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望提供足够的灵活性以进行更改，例如子网的IP地址和名称。通常，你需要在模块中在提供足够的定制和使用有偏见的默认属性之间找到平衡。毕竟，你希望促进可重复性原则，同时保持资源的可发展性。我们将在第5章中讨论更多关于共享资源，如模块的内容，并在第8章中标准化模块的安全实践。
- en: Let’s return to our example. How do you create three subnets without passing
    a list of names? The module can automatically name the subnets so you avoid hardcoding
    them. Figure 3.6 shows how to add some logic into the network factory module to
    standardize the name of the subnet based on the network address.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的例子。如何在不传递名称列表的情况下创建三个子网？模块可以自动命名子网，这样你就可以避免硬编码它们。图3.6显示了如何将一些逻辑添加到网络工厂模块中，以根据网络地址标准化子网的名称。
- en: '![](../../OEBPS/Images/CH03_F06_Wang.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH03_F06_Wang.png)'
- en: Figure 3.6 A network factory module can include transformations that calculate
    subnet addressing and create multiple subnet resources for a network.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 网络工厂模块可以包括计算子网寻址并创建网络多个子网资源的转换。
- en: Modules using factory patterns can transform input variables into standardized
    templates, a common practice to generate names or identifiers. When you implement
    the network module with the factory pattern in code, you add a `SubnetFactory`
    module. Listing 3.3 builds a factory module to generate names for the subnets.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用工厂模式的模块可以将输入变量转换为标准模板，这是一种常见的生成名称或标识符的做法。当你在代码中实现使用工厂模式的网络模块时，你会添加一个`SubnetFactory`模块。列表3.3构建了一个工厂模块来生成子网的名称。
- en: Listing 3.3 Creating three subnets in GCP by using a factory pattern
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.3 使用工厂模式在GCP中创建三个子网
- en: '[PRE2]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ For a given subnet, generates the subnet name by dash-delimiting the IP address
    range and appending it to the “network”
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 对于给定的子网，通过用短横线分隔IP地址范围并将其附加到“网络”来生成子网名称
- en: ❷ Creates a module for the subnet, which uses the factory pattern to generate
    any number of subnets
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 为子网创建一个模块，该模块使用工厂模式生成任意数量的子网
- en: ❸ Passes the subnet’s address to the factory
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将子网的地址传递给工厂
- en: ❹ Passes the subnet’s region to the factory
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将子网的区域传递给工厂
- en: ❺ Creates the subnets on the “default” network in this example
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 在此示例中，在“默认”网络上创建子网
- en: ❻ Uses the module to create the JSON configuration for the network and subnetwork
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 使用该模块创建网络和子网络的JSON配置
- en: ❼ Creates the Google subnetwork using a Terraform resource based on the name,
    address, region, and network
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 使用基于名称、地址、区域和网络的基础设施资源创建Google子网
- en: ❽ For each subnet defined with its IP address range and region, creates a subnet
    using the factory module
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 对于每个使用其IP地址范围和区域定义的子网，使用工厂模块创建子网
- en: ❾ Writes the Python dictionary to a JSON file to be executed by Terraform later
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 将Python字典写入JSON文件，以便Terraform稍后执行
- en: Why do I separate the subnets into their own factory module? Creating a separate
    module for subnets promotes the principle of evolvability. I can change the logic
    to generate names for any number of subnets. I can also update the name format
    without affecting the network.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我会将子网分离到自己的工厂模块中？为子网创建单独的模块促进了可扩展性的原则。我可以更改生成任何数量子网名称的逻辑。我还可以更新名称格式，而不会影响网络。
- en: Most factory modules include *transformation or dynamic generation* of attributes.
    For example, you can modify the network factory module to calculate the IP address
    ranges for subnets. The calculations automatically build the correct number of
    private or public subnets.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数工厂模块包括*转换或动态生成*属性。例如，你可以修改网络工厂模块以计算子网的IP地址范围。计算自动构建正确数量的私有或公共子网。
- en: However, I recommend minimizing the transformations you add to factory modules
    when possible. They can add complexity to resource configuration. The more complex
    the logic for your transformation, the more you need tests to check for transformations.
    I’ll cover how to test modules and infrastructure configuration in chapter 6.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我建议尽可能减少添加到工厂模块中的转换。它们可能会增加资源配置的复杂性。你的转换逻辑越复杂，你需要进行测试以检查转换的情况就越多。在第6章中，我将介绍如何测试模块和基础设施配置。
- en: The factory pattern balances reproducibility and evolvability of infrastructure
    resources. It manufactures similar infrastructure with minor differences for names,
    sizes, or other attributes. You’ll want to build a factory module if the configuration
    applies to commonly built resources, such as networks or servers.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂模式平衡了基础设施资源的可重复性和可扩展性。它通过名称、大小或其他属性上的微小差异制造出相似的基础设施。如果你需要构建适用于常见资源（如网络或服务器）的配置模块，你将想要构建一个工厂模块。
- en: Anytime you run a factory module, you can expect to get the specific set of
    resources you request. The module does not contain much logic to determine *which*
    resources to build. Instead, a factory module focuses on setting attributes for
    resources.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 每次运行工厂模块时，你都可以期待获得你请求的具体资源集合。该模块不包含很多逻辑来确定*哪些*资源要构建。相反，工厂模块专注于设置资源的属性。
- en: I frequently write factory modules with *many default constants* and *few input
    variables*. This way, I reduce the overhead of maintaining and validating the
    inputs. Infrastructure that commonly uses factory modules includes networks and
    subnetworks, clusters of servers, managed databases, managed queues, or managed
    caches, and more.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常编写具有*许多默认常量*和*少量输入变量*的工厂模块。这样，我减少了维护和验证输入的开销。通常使用工厂模块的基础设施包括网络和子网络、服务器集群、托管数据库、托管队列或托管缓存等。
- en: 3.4 Prototype
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 原型
- en: You can create the database servers now that you have created a module to build
    database networks. However, you must tag all resources in the database system
    with customer name, business unit, and cost center. The auditing team also asks
    you to include `automated=true` to identify the automated resources.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建了一个构建数据库网络的模块，你可以创建数据库服务器。但是，你必须使用客户名称、业务单元和成本中心对数据库系统中的所有资源进行标记。审计团队还要求你包含`automated=true`以标识自动化资源。
- en: Ideally, tags (or labels in GCP) must be consistent across all your resources.
    Your automation should copy them to every resource if you update the tags. You’ll
    learn more about the importance of tagging in chapter 8.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，标签（或在GCP中的标签）必须在所有资源上保持一致。如果你更新了标签，你的自动化应该将它们复制到每个资源上。你将在第8章中了解更多关于标签重要性的内容。
- en: What if you could put all the tags in one place and update them at once? Figure
    3.7 shows that you can put all of your tags into a module. The database server
    references the common module for tags and applies the static values to the server.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能将所有标签放在一个地方并一次性更新会怎样？图3.7显示你可以将所有标签放入一个模块中。数据库服务器引用标签的通用模块，并将静态值应用于服务器。
- en: '![](../../OEBPS/Images/CH03_F07_Wang.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH03_F07_Wang.png)'
- en: Figure 3.7 A module with the prototype pattern returns a copy of static values,
    such as tags, for consumption by other infrastructure resources.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 使用原型模式的模块返回静态值（如标签）的副本，供其他基础设施资源使用。
- en: Rather than hardcoding every tag, you created a module implementing the *prototype
    pattern* to express a set of static defaults for consumption by other modules.
    Prototype modules produce a copy of the configuration to append to other resources.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是为每个标签硬编码，你创建了一个实现*原型模式*的模块，以表达一组供其他模块使用的静态默认值。原型模块生成配置的副本，以附加到其他资源。
- en: Definition The *prototype pattern* takes a set of input variables to build a
    set of static defaults for consumption by other modules. They usually do not directly
    create infrastructure resources but export configuration values.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 原型模式使用一组输入变量来构建一组静态默认值，供其他模块消费。它们通常不会直接创建基础设施资源，而是导出配置值。
- en: You can think of a prototype as a dictionary that stores words and definitions
    (figure 3.8). The dictionary’s creators change the words and definitions. You
    can reference it and update your text or vocabulary.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将原型视为一个存储单词和定义的字典（图 3.8）。字典的创建者会更改单词和定义。您可以引用它并更新您的文本或词汇。
- en: '![](../../OEBPS/Images/CH03_F08_Wang.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH03_F08_Wang.png)'
- en: Figure 3.8 You use the dictionary as a prototype to reference words and definitions
    and update them in your writing.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 您使用字典作为原型来引用单词和定义，并在您的写作中更新它们。
- en: Why use a prototype module to reference common metadata? The prototype pattern
    promotes the principle of evolvability and reproducibility. It ensures consistent
    configuration across resources and eases the evolution of common configuration.
    You don’t have to find and replace strings in your files!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么使用原型模块来引用常用元数据？原型模式促进了可扩展性和可重复性原则。它确保资源之间配置的一致性，并简化了常用配置的演变。您不需要在文件中查找和替换字符串！
- en: Let’s implement the tag module with the prototype pattern. Listing 3.4 creates
    a module using the prototype pattern that returns a set of standard tags. In subsequent
    infrastructure resources, you reference the module for `StandardTags` for any
    tags that you need to include. The module does not create tag resources. Instead,
    it returns a copy of predefined tags.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用原型模式实现标签模块。列表 3.4 创建了一个使用原型模式返回一组标准标签的模块。在后续的基础设施资源中，您可以通过引用模块中的 `StandardTags`
    来包含所需的任何标签。该模块不会创建标签资源。相反，它返回预定义标签的副本。
- en: Listing 3.4 Creating a tagging module using the prototype pattern
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.4 使用原型模式创建标签模块
- en: '[PRE3]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Creates a module using the prototype pattern that returns a copy of standard
    tags, such as customer, cost center, and business unit
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用原型模式创建一个返回标准标签副本的模块，例如客户、成本中心和业务单元
- en: ❷ Creates a module using the factory pattern to create a Google computer instance
    (server) based on name, network, and tags
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用工厂模式创建一个基于名称、网络和标签的 Google 计算实例（服务器）模块
- en: ❸ Passes tags as a variable to the server module
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将标签作为变量传递给服务器模块
- en: ❹ Uses the module to create the JSON configuration for a server on the “default”
    network
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用模块创建“默认”网络上的服务器 JSON 配置
- en: ❺ Creates the Google compute instance (server) using a Terraform resource
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 使用 Terraform 资源创建 Google 计算实例（服务器）
- en: ❻ Adds the tags stored in the variable to the Google compute instance resource
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 将存储在变量中的标签添加到 Google 计算实例资源
- en: ❼ Uses the module to create the JSON configuration for a server on the “default”
    network
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 使用模块创建“默认”网络上的服务器 JSON 配置
- en: ❽ Uses the standard tags module to add tags to the server
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 使用标准标签模块向服务器添加标签
- en: ❾ Writes the Python dictionary to a JSON file to be executed by Terraform later
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 将 Python 字典写入 JSON 文件，供 Terraform 后续执行
- en: AWS and Azure equivalents
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: AWS 和 Azure 等效
- en: To convert listing 3.4 to another cloud provider, change the resource to an
    Amazon EC2 instance or Azure Linux virtual machine. Then, pass `self.tags` to
    the `tags` attribute for the AWS or Azure resource.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要将列表 3.4 转换为其他云提供商，将资源更改为 Amazon EC2 实例或 Azure Linux 虚拟机。然后，将 `self.tags` 传递给
    AWS 或 Azure 资源的 `tags` 属性。
- en: Let’s run the Python script to create the server configuration, as shown in
    the listing 3.5\. When you examine the JSON output for the server, you’ll notice
    that the server includes a set of labels. Those labels match the standard tags
    from your prototype module!
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行 Python 脚本以创建服务器配置，如列表 3.5 所示。当您检查服务器的 JSON 输出时，您会注意到服务器包含一组标签。这些标签与您的原型模块中的标准标签相匹配！
- en: Listing 3.5 Creating the server configuration with tags from the module
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.5 使用模块中的标签创建服务器配置
- en: '[PRE4]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ The JSON file defines a Google compute instance using a Terraform resource.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ JSON 文件使用 Terraform 资源定义了一个 Google 计算实例。
- en: ❷ Terraform identifies the resource as a database server. The JSON configuration
    matches what you defined in the server factory module using Python.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ Terraform 将资源识别为数据库服务器。JSON 配置与您在服务器工厂模块中使用 Python 定义的配置相匹配。
- en: ❸ Adds tags from the standard tags prototype module to the labels field in the
    server configuration
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将标准标签原型模块中的标签添加到服务器配置中的标签字段
- en: ❹ The JSON configuration retrieves the zone variable and populates it into the
    JSON file.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ JSON配置检索区域变量并将其填充到JSON文件中。
- en: You’ll notice that your server configuration contains a lot of hardcoded values,
    like operating system and machine type. The values behave as global defaults.
    Over time, you’ll keep adding global defaults to your factory module and find
    that they overrun the module!
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到你的服务器配置中包含了很多硬编码的值，比如操作系统和机器类型。这些值作为全局默认值存在。随着时间的推移，你会在你的工厂模块中不断增加全局默认值，并发现它们已经超出了模块的容量！
- en: To detangle and organize the global defaults, you can define them in a prototype
    module. The module makes it easier to evolve the default over time and compose
    it with other values. The prototype becomes the static, well-defined default for
    a resource.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理清和整理全局默认值，你可以在原型模块中定义它们。该模块使得随着时间的推移演变默认值并与其他值组合变得更加容易。原型成为资源的静态、明确定义的默认值。
- en: In one such situation, I started by writing a factory module to create a set
    of alerts on infrastructure. Initially, I passed the environment names and metrics
    thresholds to parametrize the alerts and their configuration. I discovered alerts
    did not need the environment names, and the metrics thresholds did not change
    across environments.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样的情况中，我开始编写一个工厂模块来在基础设施上创建一组警报。最初，我传递环境名称和指标阈值来参数化警报及其配置。我发现警报不需要环境名称，并且指标阈值在各个环境中没有变化。
- en: As a result, I converted this module into a prototype. Teams that needed to
    add metrics into their systems imported the module. The module added predefined
    alert resources to their configuration.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我将这个模块转换成了原型。需要将指标添加到他们系统的团队导入了这个模块。该模块向他们的配置中添加了预定义的警报资源。
- en: Domain-specific languages
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 领域特定语言
- en: DSLs for tools like Terraform, Kubernetes, CloudFormation, and Bicep do not
    have global constants as programming languages do. However, they do support module
    referencing and object structures. You can use the same pattern for DSLs and programming
    languages by creating the prototype as an object.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform、Kubernetes、CloudFormation和Bicep等工具的领域特定语言没有像编程语言那样的全局常量。然而，它们确实支持模块引用和对象结构。你可以通过创建一个作为对象的原型来使用与编程语言相同的模式。
- en: A prototype makes creating a standard set of resources or configurations easier.
    It eliminates the uncertainty in setting input values. However, you will have
    exceptions to standard values. As a solution, you can override or add configurations
    based on the resource. For example, I usually merge custom tags unique to a resource
    with the list of standard tags.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 原型使得创建一组标准的资源或配置变得更容易。它消除了设置输入值的不确定性。然而，你会有一些标准值之外的例外。作为解决方案，你可以根据资源覆盖或添加配置。例如，我通常将特定于资源的自定义标签与标准标签列表合并。
- en: Besides tags, I commonly use prototype modules for regions, availability zones,
    or account identifiers. I create modules with the prototype pattern when I have
    *static configurations with many global defaults or complex transformations*.
    For example, you might have a server initialization script that runs when you
    use SSL. You can create a prototype module to template the script based on whether
    you use SSL.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 除了标签之外，我通常还会使用原型模块来处理区域、可用区域或账户标识符。当我需要具有许多全局默认值或复杂转换的**静态配置**时，我会使用原型模式来创建模块。例如，你可能有一个在启用SSL时运行的服务器初始化脚本。你可以创建一个原型模块来根据是否使用SSL来模板化脚本。
- en: 3.5 Builder
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5 构建器
- en: You learned to apply the singleton pattern to create a project, the factory
    to create the networks, and the prototype to set the tags for the database server.
    Next, you’ll build a load balancer that connects you to the database.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你学习了如何应用单例模式来创建项目，工厂来创建网络，原型来设置数据库服务器的标签。接下来，你将构建一个连接到数据库的负载均衡器。
- en: But first, you run into a challenging requirement. The module must allow you
    to create private or public load balancers! A private load balancer requires different
    server and network configuration. You must build a module that offers the flexibility
    to choose a private or public load balancer and configures the server and networks
    based on your choice.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，你会遇到一个具有挑战性的需求。该模块必须允许你创建私有或公共负载均衡器！私有负载均衡器需要不同的服务器和网络配置。你必须构建一个模块，它能够提供选择私有或公共负载均衡器的灵活性，并根据你的选择配置服务器和网络。
- en: Figure 3.9 demonstrates a module that chooses a firewall and server configuration
    based on your load balancer type. You can use the same module to create an external
    or internal load balancer. The module handles the correct configuration for the
    load balancer and its required firewall rules.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9演示了一个模块，该模块根据您的负载均衡器类型选择防火墙和服务器配置。您可以使用相同的模块创建外部或内部负载均衡器。该模块处理负载均衡器及其所需防火墙规则的正确配置。
- en: '![](../../OEBPS/Images/CH03_F09_Wang.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH03_F09_Wang.png)'
- en: Figure 3.9 A builder module for the database would include parameters to select
    the type of load balancer and firewall rules that the module must create.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9 数据库的构建器模块将包括参数以选择模块必须创建的负载均衡器类型和防火墙规则。
- en: The module gives you the choice to build the system you want, helping with evolvability
    and composability. The module follows the *builder pattern*, which captures some
    default values but allows you to compose the system you need. The builder pattern
    organizes a set of related resources you enable or disable for your desired system.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块为您提供了选择构建所需系统的选项，有助于系统的可扩展性和可组合性。该模块遵循*构建器模式*，它捕获一些默认值，但允许您组合所需的系统。构建器模式组织了一组相关的资源，您可以根据所需的系统启用或禁用这些资源。
- en: Definition The *builder pattern* assembles a set of infrastructure resources
    that you can enable or disable to achieve your desired configuration.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *构建器模式* 组装一组您可以选择启用或禁用以实现所需配置的基础设施资源。
- en: Implementing the builder pattern in your database module allows you to generate
    a combination of resources based on your selection. A builder pattern uses inputs
    to decide *which* resources it needs to build, while a factory module configures
    resource attributes based on input variables. The pattern works like building
    houses for a real estate development. You choose from preset blueprints and tell
    the builder which changes you want for the layout (figure 3.10). For example,
    some builders might add an extra room by removing the garage.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库模块中实现构建器模式允许您根据选择生成资源组合。构建器模式使用输入来决定需要构建哪些资源，而工厂模块根据输入变量配置资源属性。该模式就像为房地产开发建造房屋。您从预设的蓝图中选择，并告诉构建者您想要的布局更改（图3.10）。例如，一些构建者可能会通过移除车库来增加一个额外的房间。
- en: '![](../../OEBPS/Images/CH03_F10_Wang.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH03_F10_Wang.png)'
- en: Figure 3.10 A builder module constructs a house with a preset blueprint that
    allows for layout changes, such as an extra room.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10 一个构建器模块使用预设蓝图构建房屋，允许进行布局更改，例如增加一个房间。
- en: Let’s start implementing the builder pattern, as in the following listing. First,
    you define a load balancer module by using the factory pattern. You use the factory
    pattern to customize the load balancer (also known as the *compute forwarding
    rule* in GCP). The module sets the scheme for the load balancer as external or
    internal.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始实现构建器模式，如下所示列表。首先，您通过使用工厂模式定义一个负载均衡器模块。您使用工厂模式来自定义负载均衡器（在GCP中也称为*计算转发规则*）。该模块将负载均衡器的方案设置为外部或内部。
- en: Listing 3.6 Using the factory module for the load balancer
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.6 使用工厂模块为负载均衡器
- en: '[PRE5]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Creates a module for the load balancer, which uses the factory pattern to
    generate an internal or external load balancer
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个负载均衡器模块，该模块使用工厂模式生成内部或外部负载均衡器
- en: ❷ Uses the module to create the JSON configuration for the load balancer
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用该模块创建负载均衡器的JSON配置
- en: ❸ Sets the scheme to internal or external load balancing. The load balancer
    defaults to an internal configuration.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将方案设置为内部或外部负载均衡。负载均衡器默认为内部配置。
- en: ❹ Creates the Google compute forwarding rule using a Terraform resource. This
    is GCP’s equivalent of load balancing.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用Terraform资源创建Google计算转发规则。这是GCP中负载均衡的等效功能。
- en: ❺ Sets the load balancer’s target to the database server group. This uses Terraform’s
    built-in variable interpolation feature to dynamically resolve the database server
    group’s ID.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将负载均衡器的目标设置为数据库服务器组。这使用Terraform内置的变量插值功能来动态解析数据库服务器组的ID。
- en: ❻ Allows traffic to port 3306, the MySQL database port
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 允许流量通过3306端口，这是MySQL数据库端口
- en: AWS and Azure equivalents
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: AWS和Azure等效功能
- en: You can equate a GCP compute forwarding rule to AWS Elastic Load Balancing (ELB)
    or Azure Load Balancer. Similarly, an AWS security group or Azure network security
    group roughly equals a GCP firewall rule. For an example with AWS, refer to the
    code repository at [https://github.com/joatmon08/manning-book](https://github.com/joatmon08/manning-book).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将 GCP 计算转发规则等同于 AWS 弹性负载均衡器 (ELB) 或 Azure 负载均衡器。同样，AWS 安全组或 Azure 网络安全组大致等同于
    GCP 防火墙规则。有关 AWS 的示例，请参阅代码仓库[https://github.com/joatmon08/manning-book](https://github.com/joatmon08/manning-book)。
- en: However, an external load balancer requires additional configuration in the
    form of a firewall rule. You must allow traffic from external sources to the database
    ports. Let’s define a module using the factory pattern for another firewall rule
    to allow traffic from external sources, as in the following listing.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，外部负载均衡器需要额外的防火墙规则配置。您必须允许外部源流量访问数据库端口。让我们定义一个使用工厂模式的模块，以允许外部源流量，如下面的列表所示。
- en: Listing 3.7 Using the factory module for the firewall rule
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.7 使用工厂模块创建防火墙规则
- en: '[PRE6]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Creates a module for the firewall, which uses the factory pattern to generate
    a firewall rule
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建了一个使用工厂模式生成防火墙规则的防火墙模块
- en: ❷ Uses the module to create the JSON configuration for the load balancer
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用该模块创建负载均衡器的 JSON 配置
- en: ❸ Creates the Google compute firewall using a Terraform resource. This is GCP’s
    equivalent of a firewall rule.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用 Terraform 资源创建 Google 计算防火墙。这是 GCP 中防火墙规则的等效物。
- en: ❹ The firewall rule should allow TCP traffic to port 3306 by default.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 防火墙规则应默认允许 TCP 流量访问端口 3306。
- en: Thanks to the principle of composability, you put the load balancer and factory
    module into the database builder module. The module needs a variable that helps
    you choose the type of load balancer and whether you should include a firewall
    rule to allow traffic to the load balancer.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了可组合性原则，您将负载均衡器和工厂模块放入数据库构建器模块中。该模块需要一个变量，帮助您选择负载均衡器的类型以及是否应包含防火墙规则以允许流量访问负载均衡器。
- en: 'When you implement the database builder module in listing 3.8, you set it to
    create the database server group and networks by default. Then the builder accepts
    two options: an internal or external load balancer and the extra firewall rule.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在列表 3.8 中实现数据库构建器模块时，您将其设置为默认创建数据库服务器组和网络。然后构建器接受两个选项：内部或外部负载均衡器以及额外的防火墙规则。
- en: Listing 3.8 Constructing a database with the builder pattern
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.8 使用构建器模式构建数据库
- en: '[PRE7]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Imports factory modules to create the database server group, load balancer,
    and firewall
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入工厂模块以创建数据库服务器组、负载均衡器和防火墙
- en: ❷ Creates a module for the database, which uses the builder pattern to generate
    the required database server group, networks, load balancers, and firewalls
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 为数据库创建了一个模块，该模块使用构建器模式生成所需的数据库服务器组、网络、负载均衡器和防火墙
- en: ❸ Always create a database server group and networks by using the factory module.
    The builder module needs the database server group.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 总是通过使用工厂模块创建数据库服务器组和网络。构建器模块需要数据库服务器组。
- en: ❹ Adds a method so you can choose to build an internal load balancer
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 添加了一个方法，以便您可以选择构建内部负载均衡器
- en: ❺ Adds a method so you can choose to build an external load balancer
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 添加了一个方法，以便您可以选择构建外部负载均衡器
- en: ❻ Adds a method so you can choose to build a firewall rule to allow traffic
    to the databases
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 添加了一个方法，以便您可以选择构建防火墙规则以允许流量访问数据库
- en: ❼ Uses the builder module to return the JSON configuration for your customized
    database resources
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 使用构建器模块返回您自定义数据库资源的 JSON 配置
- en: ❽ Uses the database builder module to create a database server group with external
    access (load balancer and firewall rule)
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 使用数据库构建器模块创建具有外部访问（负载均衡器和防火墙规则）的数据库服务器组
- en: ❾ Writes the Python dictionary to a JSON file to be executed by Terraform later
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 将 Python 字典写入 JSON 文件，以便 Terraform 后续执行
- en: After running the Python script, you will find a lengthy JSON configuration
    with the instance templates, server group, server group manager, external load
    balancer, and firewall rule. The builder generates all of the resources you need
    to build an externally accessible database. Note that the listing omits the other
    components for clarity.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 Python 脚本后，您将找到一个包含实例模板、服务器组、服务器组管理器、外部负载均衡器和防火墙规则的冗长 JSON 配置。构建器生成了构建外部可访问数据库所需的所有资源。请注意，列表为了清晰起见省略了其他组件。
- en: Listing 3.9 Truncated database system configuration
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.9 截断的数据库系统配置
- en: '[PRE8]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ The JSON file defines a Google compute forwarding rule and firewall using
    a Terraform resource. The file omits the instance templates, server group, and
    server group for clarity.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ JSON 文件使用 Terraform 资源定义了一个 Google 计算转发规则和防火墙，为了清晰起见，文件省略了实例模板、服务器组和服务器组。
- en: ❷ Creates a load balancer with the EXTERNAL scheme, which makes it accessible
    from external source
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用 EXTERNAL 方案创建一个负载均衡器，使其可以从外部源访问
- en: ❸ Creates a firewall that allows TCP traffic on port 3306, the MySQL database
    ports
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 创建一个防火墙，允许在端口 3306 上进行 TCP 流量，这是 MySQL 数据库端口
- en: ❹ Sets the load balancer’s target to the database server group. This uses Terraform’s
    built-in variable interpolation feature to dynamically resolve the database server
    group’s ID.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将负载均衡器的目标设置为数据库服务器组。这使用 Terraform 内置的变量插值功能来动态解析数据库服务器组的 ID。
- en: ❺ The JSON file defines a Google compute forwarding rule and firewall using
    a Terraform resource. The file omits the instance templates and server group for
    clarity.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ JSON 文件使用 Terraform 资源定义了一个 Google 计算转发规则和防火墙，为了清晰起见，文件省略了实例模板和服务器组。
- en: The builder pattern helps you adhere to the principle of evolvability. You get
    to choose the set of resources you need. A module with this pattern takes away
    the challenge of configuring the right combination of attributes and resources.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 构建者模式帮助你遵循可扩展性原则。你可以选择你需要的一组资源。采用这种模式的模块可以消除配置正确属性和资源组合的挑战。
- en: Furthermore, you can use the builder pattern to wrap a generic interface around
    a cloud provider’s resources. The Python example offers builder methods to `add_external_load_balancer`,
    which wraps around the GCP compute forwarding rule. When you use the module, the
    option describes the intent of creating a generic load balancer and not a GCP
    forwarding rule.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以使用构建者模式在云提供商的资源周围包装一个通用接口。Python 示例提供了 `add_external_load_balancer` 构建方法，它围绕
    GCP 计算转发规则进行包装。当你使用该模块时，该选项描述了创建通用负载均衡器的意图，而不是 GCP 转发规则。
- en: Domain-specific languages
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 领域特定语言
- en: Some DSLs offer an if-else (conditional) statement or loop (iteration) that
    you can use for the builder pattern. Terraform offers the `count` argument to
    create a set number of resources based on a conditional statement. CloudFormation
    supports conditionals for user inputs that can select stacks. Bicep uses deploy
    conditions. For Ansible, you can use conditional imports to select tasks or playbooks.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 DSL 提供了 if-else（条件）语句或循环（迭代），你可以用于构建者模式。Terraform 提供了 `count` 参数，可以根据条件语句创建一定数量的资源。CloudFormation
    支持用户输入的条件，可以用于选择堆栈。Bicep 使用部署条件。对于 Ansible，你可以使用条件导入来选择任务或剧本。
- en: For example, you could set up a Boolean variable called `add_external_load_balancer`.
    If you pass `true` to the variable, the DSL adds a conditional statement to build
    an external load balancer resource. Otherwise, it creates an internal load balancer.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以设置一个名为 `add_external_load_balancer` 的布尔变量。如果你将 `true` 传递给该变量，DSL 将添加一个条件语句来构建外部负载均衡器资源。否则，它将创建一个内部负载均衡器。
- en: Some DSLs do not offer conditional statements. You will need some code similar
    to the code examples in this book that template the DSL. For example, you can
    use Helm to template and release Kubernetes YAML files.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 一些领域特定语言（DSL）不提供条件语句。你可能需要一些类似于本书中代码示例的代码，以模板化 DSL。例如，你可以使用 Helm 来模板化和发布 Kubernetes
    YAML 文件。
- en: The builder pattern best applies to modules that create multiple resources.
    These use cases include configuration for container orchestrators such as Kubernetes,
    platforms with cluster architectures, dashboards for application and system metrics,
    and more. A builder module for these use cases allows you to select the resource
    you want without passing specific input attributes.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 构建者模式最适合创建多个资源的模块。这些用例包括 Kubernetes 等容器编排器的配置、具有集群架构的平台、应用程序和系统指标的仪表板等。这些用例的构建者模块允许你选择你想要的资源，而无需传递特定的输入属性。
- en: However, builder modules can be complex because they reference other modules
    and multiple resources. The risk of module misconfiguration can be very high.
    Chapter 6 covers testing strategies to ensure a builder module’s functionality
    and stability.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，构建者模块可能很复杂，因为它们引用其他模块和多个资源。模块配置错误的风险可能非常高。第 6 章涵盖了测试策略，以确保构建者模块的功能性和稳定性。
- en: 3.6 Choosing a pattern
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.6 选择一个模式
- en: Throughout this chapter, I’ve showed how to group some resources for a database
    system into various module patterns. How do you choose which module pattern to
    use? What about the other resources in the database system I did not mention?
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我展示了如何将一些资源分组到数据库系统的各种模块模式中。你如何选择使用哪种模块模式？关于我未提及的数据库系统中的其他资源呢？
- en: You can create separate modules for new infrastructure resources with different
    business functions and purposes. The database example throughout this chapter
    separated the configuration of the Google project (singleton), network (factory),
    and database cluster (factory) into modules. Each evolves as different resources
    with different input variables and defaults.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为具有不同业务功能和目的的新基础设施资源创建单独的模块。本章中的数据库示例将Google项目的配置（单例）、网络（工厂）和数据库集群（工厂）分离成模块。每个模块作为不同的资源独立发展，具有不同的输入变量和默认值。
- en: The example uses the composite pattern to combine all of the module patterns
    in the system. It uses the factory pattern for network, load balancer, and database
    cluster modules to pass attributes and customize each resource. Tags often use
    the prototype pattern because they involve consistent metadata copied to other
    resources. You will use the factory and prototype patterns for most of the modules
    you write because they offer composability, reproducibility, and evolvability.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 示例使用组合模式来组合系统中所有的模块模式。它使用工厂模式来处理网络、负载均衡器和数据库集群模块，以传递属性并定制每个资源。标签通常使用原型模式，因为它们涉及将一致的元数据复制到其他资源。你将使用工厂和原型模式来编写大多数模块，因为它们提供了可组合性、可复制性和可扩展性。
- en: By contrast, you build the Google project as a singleton because no one else
    will change attributes for the single instance of my project. The project does
    not change much, so you use a less complex pattern. However, you solved the complex
    problem of creating a database system with the builder pattern. The builder module
    allows you to select the specific resources to create.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，你将Google项目作为一个单例来构建，因为没有其他人会更改我项目单例的属性。项目变化不大，所以你使用了一个更简单的模式。然而，你解决了使用构建器模式创建数据库系统的复杂问题。构建器模块允许你选择要创建的特定资源。
- en: '![](../../OEBPS/Images/CH03_F11_Wang.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图3.11](../../OEBPS/Images/CH03_F11_Wang.png)'
- en: Figure 3.11 To decide which module pattern you want to use, you must assess
    how you use the resource and its behavior.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11 为了决定你想使用哪种模块模式，你必须评估你如何使用资源及其行为。
- en: Figure 3.11 offers a decision tree for identifying which pattern to use. You
    ask yourself a series of questions on the purpose, reuse and update frequency,
    and composition of multiple resources. Based on these criteria, you create a module
    with a specific pattern.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11提供了一个决策树，用于确定使用哪种模式。你将针对目的、重用和更新频率以及多个资源的组合提出一系列问题。基于这些标准，你创建一个具有特定模式的模块。
- en: Following the decision tree helps build more composable and evolvable modules.
    You want to balance the predictability of standard attributes with the flexibility
    to override configuration for specific resources. However, keep an open mind.
    Modules can outgrow and change in function. Just because you build a module with
    one pattern doesn’t mean you won’t convert it to a different one in the future!
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循决策树可以帮助构建更可组合和可扩展的模块。你希望平衡标准属性的预测性与覆盖特定资源配置的灵活性。然而，保持开放的心态。模块可能会超出其功能并发生变化。仅仅因为你用一种模式构建了一个模块，并不意味着你未来不会将其转换为另一种模式！
- en: Exercise 3.1
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 练习3.1
- en: To which module pattern(s) does the following IaC apply? (Choose all that apply.)
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 以下IaC（基础设施即代码）适用于哪些模块模式？（选择所有适用的。）
- en: '[PRE9]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: A) Factory
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: A) 工厂
- en: B) Singleton
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: B) 单例
- en: C) Prototype
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: C) 原型
- en: D) Builder
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: D) 构建器
- en: E) Composite
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: E) 组合
- en: See appendix B for answers to exercises.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅附录B以获取练习题的答案。
- en: Note that many of the patterns in this chapter focus on building modules with
    IaC tooling. Sometimes you might write automation in a programming language because
    you cannot find IaC support. This situation happens most with legacy infrastructure.
    For example, imagine you need to create a database system in GCP. However, you
    do not have an IaC tool and can access the GCP API only directly.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，本章中的许多模式都侧重于使用IaC工具构建模块。有时你可能需要在编程语言中编写自动化脚本，因为你找不到IaC支持。这种情况在遗留基础设施中最为常见。例如，想象你需要创建一个GCP中的数据库系统。然而，你没有IaC工具，只能直接访问GCP
    API。
- en: 'To create the database system using the GCP API, you separate each infrastructure
    resource into a factory module with four functions: create, read, update, and
    delete. Changes to the resource use the composition of these functions. You can
    check for errors in each function depending on the action you want to execute
    for each resource.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 GCP API 创建数据库系统，您将每个基础设施资源分离成具有四个函数（创建、读取、更新和删除）的工厂模块。对资源的更改使用这些函数的组合。您可以根据您想要对每个资源执行的操作检查每个函数中的错误。
- en: Figure 3.12 implements factory modules for the server, network, and load balancer.
    You can create, read, update, and delete each module. A builder module for the
    database uses the composite pattern to create, read, update, and delete the network,
    server, and load balancer.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.12 实现了服务器、网络和负载均衡器的工厂模块。您可以创建、读取、更新和删除每个模块。数据库的构建者模块使用组合模式来创建、读取、更新和删除网络、服务器和负载均衡器。
- en: '![](../../OEBPS/Images/CH03_F12_Wang.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.12](../../OEBPS/Images/CH03_F12_Wang.png)'
- en: Figure 3.12 To write scripts for automation, create factory modules for individual
    resources, and then build functions to create, read, update, and delete resources.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.12 要编写自动化脚本，为单个资源创建工厂模块，然后构建创建、读取、更新和删除资源的函数。
- en: Breaking down the updates you’ll make to resources into four functions organizes
    the automation. Even the builder pattern uses the create, read, update, and delete
    functions. The functions define the automation behavior you want to use to configure
    resources. However, you should test each function for idempotency. Anytime you
    run the function, it should result in the same configuration.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 将对资源的更新拆分为四个函数可以组织自动化流程。即使是构建者模式也使用创建、读取、更新和删除函数。这些函数定义了您想要用于配置资源的自动化行为。然而，您应该测试每个函数以确保幂等性。每次运行函数时，它都应该导致相同的配置。
- en: 'You can apply the module patterns in this chapter to automating and implementing
    IaC on any infrastructure. As you develop IaC, identify where you can break your
    infrastructure system into modules. When deciding when and what to modularize,
    consider the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将本章中的模块模式应用于任何基础设施的自动化和实施基础设施即代码（IaC）。随着您开发 IaC，确定您可以将基础设施系统拆分为模块的地方。在决定何时以及如何模块化时，请考虑以下因素：
- en: Is the resource shared?
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源是否已共享？
- en: What business domain does it serve?
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它服务于哪个业务领域？
- en: Which environment uses the resource?
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪个环境使用该资源？
- en: Which team manages the infrastructure?
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪个团队管理基础设施？
- en: Does the resource use a different tool?
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源是否使用不同的工具？
- en: How do you change a resource without affecting something else in the module?
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您如何更改资源而不影响模块中的其他内容？
- en: By assessing which resources align with different business units, teams, or
    functions, you build smaller sets of infrastructure. As a general practice, write
    modules with as few resources as possible. Modules with fewer resources speed
    up the provisioning and minimize the blast radius of a failure. More important,
    you can deploy, test, and debug smaller modules before applying them to a more
    extensive system.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 通过评估哪些资源与不同的业务单元、团队或功能相匹配，您可以构建更小的基础设施集合。作为一般做法，尽可能少地编写模块。资源较少的模块可以加快供应速度并最小化故障的影响范围。更重要的是，您可以在将它们应用于更广泛的系统之前，对较小的模块进行部署、测试和调试。
- en: Grouping resources into modules offers a few benefits for you, your team, and
    your company. For you, modules improve the scalability and resiliency of infrastructure
    resources. You minimize the blast radius of changes to modules to improve the
    resiliency of the overall system.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 将资源分组到模块中为您、您的团队和您的公司带来了一些好处。对于您来说，模块可以提高基础设施资源的可扩展性和弹性。您通过最小化模块更改的影响范围来提高整体系统的弹性。
- en: For your team, a module provides the benefit of a self-service mechanism for
    other team members to reproduce your module and create infrastructure. Your teammate
    can use the module and pass the variables they want to customize instead of finding
    and replacing attributes. You’ll learn more about sharing modules in chapter 5.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 对于您的团队来说，模块为其他团队成员提供了一个自助机制，以便复制您的模块并创建基础设施。您的队友可以使用模块并传递他们想要定制的变量，而不是寻找和替换属性。您将在第
    5 章中了解更多关于模块共享的内容。
- en: For your organization, a module helps you standardize better infrastructure
    and security practices across resources. You can use the same configurations to
    stamp out similar load balancers and restricted firewall rules. Modules also help
    your security team audit and enforce these practices across different teams, as
    covered in chapter 8.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你的组织来说，模块可以帮助你在资源之间标准化更好的基础设施和安全实践。你可以使用相同的配置来批量生成类似的负载均衡器和受限防火墙规则。模块还有助于你的安全团队审核和强制执行这些实践，如第8章所述。
- en: Summary
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Apply module patterns such as singleton, factory, prototype, and builder so
    you can construct composable infrastructure configurations.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用模块模式，如单例、工厂、原型和构建器，以便你可以构建可组合的基础设施配置。
- en: Use the composite pattern to group infrastructure resources into a hierarchy
    and structure them for automation.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用组合模式将基础设施资源分组到层次结构中，并为自动化对其进行结构化。
- en: You can use the singleton pattern to manage single instances of infrastructure,
    which applies to rarely changed infrastructure resources.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用单例模式来管理基础设施的单个实例，这适用于很少更改的基础设施资源。
- en: Use the prototype pattern for copying and applying global configuration parameters,
    such as tags or common configuration.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原型模式来复制和应用全局配置参数，例如标签或通用配置。
- en: Factory modules take inputs to construct infrastructure resources with a specific
    configuration.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂模块接收输入以使用特定配置构建基础设施资源。
- en: Builder modules take inputs to decide which resources to create. Builder modules
    can be composed of factory modules.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建模块接收输入以决定要创建哪些资源。构建模块可以由工厂模块组成。
- en: When deciding what and how to modularize, assess which functions or business
    domain the infrastructure configuration serves.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在决定如何模块化以及如何模块化时，评估基础设施配置服务于哪些功能或业务领域。
- en: If you write scripts to automate infrastructure, construct factory modules with
    capabilities to create, read, update, and delete. Reference them in builder modules.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你编写脚本来自动化基础设施，构建具有创建、读取、更新和删除功能的工厂模块，并在构建模块中引用它们。
