- en: 21 Using regular expressions to parse text files
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 21 使用正则表达式解析文本文件
- en: 'Regular expressions are one of those awkward topics. We often have students
    ask us to explain them, only to realize—halfway through the conversation—that
    they didn’t need regular expressions at all. A *regex*, as a regular expression
    is sometimes known, is useful in text parsing, which is something you end up doing
    a lot of in UNIX and Linux operating systems. In PowerShell, you tend to do less
    text parsing—and you tend to need regexes less often. That said, we certainly
    know of times when, in PowerShell, you need to parse textual content such as a
    log file. That’s how we cover regular expressions in this chapter: as a tool to
    parse text files.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式是那些尴尬的话题之一。我们经常有学生要求我们解释它们，结果发现——在谈话进行到一半时——他们根本不需要正则表达式。正则表达式，有时也称为正则表达式，在文本解析中很有用，这是您在
    UNIX 和 Linux 操作系统中经常会做的事情。在 PowerShell 中，您通常进行较少的文本解析——您通常不太需要正则表达式。话虽如此，我们当然知道在
    PowerShell 中，您需要解析文本内容，例如日志文件的情况。这就是我们本章介绍正则表达式的方式：作为一个解析文本文件的工具。
- en: 'Don’t get us wrong: there’s much more you can do with regular expressions,
    and we cover a few of those things at the end of this chapter. But to make sure
    you have a good expectation up front, let’s be clear that we don’t cover regular
    expressions comprehensively or exhaustively in this book. Regular expressions
    can get *incredibly* complicated. They’re an entire technology unto themselves.
    We’ll get you started, and try to do so in a way that’s immediately applicable
    to many production environments, and then we’ll give you some pointers for digging
    deeper on your own, if that’s your need.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 请不要误解：您可以用正则表达式做很多事情，我们将在本章末尾介绍其中的一些。但为了确保您有一个良好的预期，让我们明确指出，我们在这本书中并没有全面或详尽地介绍正则表达式。正则表达式可以变得非常复杂。它们是一项完整的技术。我们将帮助您入门，并尝试以立即适用于许多生产环境的方式做到这一点，然后如果您需要，我们将为您提供一些深入学习的指导。
- en: Our goal with this chapter is to introduce you to regex syntax in a simplified
    fashion and show you how PowerShell can use regular expressions. If you want to
    move on to more-complicated expressions on your own, you’re welcome to, and you’ll
    know how to use those within the shell.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写本章的目的是以简化的方式向您介绍正则表达式语法，并展示 PowerShell 如何使用正则表达式。如果您想自己学习更复杂的表达式，欢迎您这样做，您将知道如何在
    shell 中使用它们。
- en: 21.1 The purpose of regular expressions
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 21.1 正则表达式的作用
- en: A regular expression is written in a specific language, and its purpose is to
    define a text pattern. For example, an IPv4 address consists of one to three digits,
    a period, one to three more digits, a period, and so forth. A regex can define
    that pattern, although it would accept an invalid address like 211.193.299.299\.
    That’s the difference between recognizing a text pattern and checking for the
    validity of the data.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式是用一种特定的语言编写的，其目的是定义文本模式。例如，IPv4 地址由一到三个数字、一个点、一到三个更多的数字、一个点等等组成。正则表达式可以定义这种模式，尽管它也会接受一个无效的地址，如
    211.193.299.299。这就是识别文本模式和检查数据有效性的区别。
- en: One of the biggest uses of regular expressions—and the use we cover in this
    chapter—is to detect specific text patterns within a larger text file, such as
    a log file. For example, you might write a regex to look for the specific text
    that represents an HTTP 500 error in a web server log file, or to look for email
    addresses in an SMTP server log file. In addition to detecting the text pattern,
    you might use the regex to capture the matched text, enabling you to extract those
    email addresses from the log file.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式最大的用途之一——我们本章要介绍的就是在较大的文本文件中检测特定的文本模式，例如日志文件。例如，您可能编写一个正则表达式来查找表示 Web 服务器日志文件中
    HTTP 500 错误的特定文本，或者查找 SMTP 服务器日志文件中的电子邮件地址。除了检测文本模式外，您可能还会使用正则表达式来捕获匹配的文本，从而让您能够从日志文件中提取这些电子邮件地址。
- en: 21.2 A regex syntax primer
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 21.2 正则表达式语法入门
- en: The simplest regex is an exact string of text that you want to match. `Car`,
    for example, is technically a regex, and in PowerShell it’ll match `CAR`, `car`,
    `Car`, `CaR`, and so on; PowerShell’s default matching is case insensitive.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的正则表达式是您想要匹配的确切文本字符串。例如，“Car”在技术上是一个正则表达式，在 PowerShell 中它将匹配“CAR”、“car”、“Car”、“CaR”等等；PowerShell
    的默认匹配是不区分大小写的。
- en: 'Certain characters, however, have special meaning within a regex, and they
    enable you to detect patterns of variable text. Here are some examples:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，某些字符在正则表达式中具有特殊含义，它们使您能够检测可变文本的模式。以下是一些示例：
- en: '`\w` matches “word characters,” which means letters, numbers, and underscores,
    but no punctuation and no whitespace. The regex `\won` would match `Don`, `Ron`,
    and `ton`, with the `\w` standing in for any single letter, number, or underscore.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\w` 匹配“单词字符”，意味着字母、数字和下划线，但不包括标点符号和空白。正则表达式 `\won` 会匹配 `Don`、`Ron` 和 `ton`，其中
    `\w` 代表任何单个字母、数字或下划线。'
- en: '`\W` matches the opposite of `\w` (so this is one example where PowerShell
    is sensitive to case), meaning it matches whitespace and punctuation—“nonword
    characters,” in the parlance.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\W` 匹配 `\w` 的对立面（因此这是 PowerShell 对大小写敏感的一个例子），意味着它匹配空白和标点符号——“非单词字符”。'
- en: '`\d` matches any digit from `0` through `9` inclusive.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\d` 匹配从 `0` 到 `9` 的任何数字。'
- en: '`\D` matches any nondigit.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\D` 匹配任何非数字。'
- en: '`\s` matches any whitespace character, including a tab, space, or carriage
    return.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\s` 匹配任何空白字符，包括制表符、空格或换行符。'
- en: '`\S` matches any nonwhitespace character.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\S` 匹配任何非空白字符。'
- en: '`.` (a period) stands in for any single character.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.`（一个点）代表任何单个字符。'
- en: '`[abcde]` matches any character in that set. The regex `c[aeiou]r` would match
    `car` and `cur`, but not `caun` or `coir`.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[abcde]` 匹配该集合中的任何字符。正则表达式 `c[aeiou]r` 会匹配 `car` 和 `cur`，但不会匹配 `caun` 或 `coir`。'
- en: '`[a-z]` matches one or more characters in that range. You can specify multiple
    ranges as comma-separated lists, such as `[a-f,m-z]`.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[a-z]` 匹配该范围内的一个或多个字符。你可以指定多个范围，用逗号分隔的列表，例如 `[a-f,m-z]`。'
- en: '`[^abcde]` matches one or more characters that are not in that set, meaning
    the regex `d[^aeiou]` would match `dns` but not `don`.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[^abcde]` 匹配不在该集合中的一个或多个字符，意味着正则表达式 `d[^aeiou]` 会匹配 `dns` 但不会匹配 `don`。'
- en: '`?` follows another literal or special character and matches exactly one instance
    of that character. So, the regex `ca?r` would match `car` but would not match
    `coir`. It would also match `ca` because `?` can also match zero instances of
    the preceding character.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`?` 后跟另一个字面量或特殊字符，并匹配该字符的精确一个实例。因此，正则表达式 `ca?r` 会匹配 `car` 但不会匹配 `coir`。它也会匹配
    `ca`，因为 `?` 也可以匹配前面字符的零个实例。'
- en: '`*` matches any number of instances of the preceding character. The regex `ca*r`
    would match both `cair` and `car`. It would also match `ca` because `*` also matches
    zero instances of the preceding character.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*` 匹配前面字符的任意数量实例。正则表达式 `ca*r` 会匹配 `cair` 和 `car`。它也会匹配 `ca`，因为 `*` 也可以匹配前面字符的零个实例。'
- en: '`+` matches one or more instances of the preceding character. You’ll see this
    used a lot with parentheses, which create a sort of subexpression. For example,
    the regex `(ca)+r` would match `cacacacar` because it matches repeating instances
    of the `ca` subexpression.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+` 匹配前面字符的一个或多个实例。你会在括号中看到很多这种用法，括号创建了一种子表达式。例如，正则表达式 `(ca)+r` 会匹配 `cacacacar`，因为它匹配
    `ca` 子表达式的重复实例。'
- en: '`\` (backslash) is the regex escape character. Use it in front of a character
    that normally has special meaning in the regex syntax, to make that character
    a literal. For example, the regex `\.` would match a literal period character,
    rather than allowing the period to stand in for any single character, as it normally
    does. To match a literal backslash, escape it with a backslash: `\\`.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\`（反斜杠）是正则表达式的转义字符。在正则表达式语法中通常有特殊意义的字符之前使用它，使该字符成为字面量。例如，正则表达式 `\.` 会匹配一个字面量的点字符，而不是像通常那样允许点代表任何单个字符。要匹配字面量的反斜杠，用反斜杠转义它：`\\`。'
- en: '`{2}` matches exactly that many instances of the preceding character. For example,
    `\d{1}` matches exactly one digit. Use `{2,}` to match two or more, and use `{1,3}`
    to match at least one, but no more than three.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{2}` 匹配前面字符的精确数量。例如，`\d{1}` 会匹配一个数字。使用 `{2,}` 来匹配两个或更多，使用 `{1,3}` 来匹配至少一个但不超过三个。'
- en: '`^` matches the beginning of the string. For example, the regex `c.r` would
    match `car` as well as `pteranocar`. But the regex `^c.r` would match `car` but
    would not match `pteranocar` because the `^` makes the matching occur at the beginning
    of the string. This is a different use of `^` than in the previous example, where
    it was used with square brackets, `[]`, to indicate a negative match.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`^` 匹配字符串的开始。例如，正则表达式 `c.r` 会匹配 `car` 以及 `pteranocar`。但正则表达式 `^c.r` 只会匹配 `car`，而不会匹配
    `pteranocar`，因为 `^` 使得匹配发生在字符串的开始处。这与前一个示例中的用法不同，在那里它和方括号 `[]` 一起使用，表示负匹配。'
- en: '`$` matches the end of the string. For example, the regex `.icks` would match
    `hicks` and `sticks` (the match would technically be on `ticks` in that example),
    and would also match `Dickson`. But the regex `.icks$` would not match `Dickson`
    because the `$` indicates that the string should reach its end after the `s`.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$` 匹配字符串的末尾。例如，正则表达式 `.icks` 会匹配 `hicks` 和 `sticks`（在这个例子中，匹配实际上是 `ticks`），还会匹配
    `Dickson`。但正则表达式 `.icks$` 不会匹配 `Dickson`，因为 `$` 表示字符串应该在 `s` 之后结束。'
- en: 'There you have it—a whirlwind look at the basic regex syntax. As we wrote earlier,
    there’s a lot more where that came from, but this is enough to get some basic
    work done. Let’s look at some example regular expressions:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们所看到的——对基本正则表达式语法的快速浏览。正如我们之前所写的，还有很多其他内容，但这已经足够做一些基本工作了。让我们看看一些示例正则表达式：
- en: '`\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}` matches the pattern of an IPv4 address,
    although it’ll accept illegal data like `432.567.875.000`, as well as legal data
    like `192.169.15.12`.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}` 匹配 IPv4 地址的模式，尽管它会接受非法数据，如 `432.567.875.000`，以及合法数据，如
    `192.169.15.12`。'
- en: '`\\\\\w+(\\\w+)+` matches a Universal Naming Convention (UNC) path. All the
    backslashes make that regex hard to read—which is one reason it’s important to
    test and tweak your regular expressions before you rely on them in a production
    task.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\\\\\w+(\\\w+)+` 匹配通用命名约定（UNC）路径。所有的反斜杠使得这个正则表达式难以阅读——这也是为什么在将正则表达式用于生产任务之前测试和调整它们很重要的原因之一。'
- en: '`\w{1}\.\w+@company\.com` matches a specific type of email address: first initial,
    a period, last name, and then `@company.com`. For example, `sam.smith@company
    .com` would be a valid match. You do have to be a bit careful with these. For
    example, `Samuel.smith@company.com.org` or `Smith@company.com.net` would also
    be a valid match. The regex is fine with there being extra text before and after
    the matched portion. That’s where the `^` and `$` anchors come into play in many
    situations.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\w{1}\.\w+@company\.com` 匹配特定类型的电子邮件地址：首字母，一个点，姓氏，然后是 `@company.com`。例如，`sam.smith@company
    .com` 将是一个有效的匹配。在使用这些时确实需要小心。例如，`Samuel.smith@company.com.org` 或 `Smith@company.com.net`
    也会是有效的匹配。正则表达式对匹配部分前后有额外文本的情况没有问题。这就是在许多情况下 `^` 和 `$` 锚点发挥作用的地方。'
- en: Note You’ll find more about basic regex syntax by running `help` `about_regular
    _expressions` in PowerShell. At the end of this chapter, we provide some additional
    resources for further exploration.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 你可以通过在 PowerShell 中运行 `help` `about_regular _expressions` 来了解更多关于基本正则表达式语法的信息。在本章末尾，我们提供了一些额外的资源，供进一步探索。
- en: 21.3 Using regex with -Match
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 21.3 使用 -Match 与正则表达式
- en: 'PowerShell includes a comparison operator, `-Match`, and a case-sensitive cousin,
    `-CMatch`, that work with regular expressions. Here are some examples:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 包含一个比较运算符 `-Match` 和一个大小写敏感的类似项 `-CMatch`，它们与正则表达式一起工作。以下是一些示例：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Although it has many uses, we’re primarily going to rely on `-Match` to test
    regular expressions and make sure they’re working properly. As you can see, its
    left-hand operand is whatever string you’re testing, and the right-hand operand
    is the regular expression. If there’s a match, it outputs `True`; if not, you
    get `False`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它有很多用途，但我们主要将依赖于 `-Match` 来测试正则表达式并确保它们工作正常。正如你所看到的，它的左操作数是你正在测试的字符串，右操作数是正则表达式。如果存在匹配，它输出
    `True`；如果没有，你得到 `False`。
- en: Try it Now This is a good time to take a break from reading and try using the
    `-Match` operator. Run through some of the examples we just mentioned, and make
    sure you’re comfortable using the `-Match` operator in the shell.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看 这是一个从阅读中休息一下并尝试使用 `-Match` 操作符的好时机。运行我们刚才提到的几个示例，并确保你在 shell 中使用 `-Match`
    操作符时感到舒适。
- en: 21.4 Using regex with Select-String
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 21.4 使用 Select-String 与正则表达式
- en: Now we reach the real meat of this chapter. We’re going to use some web server
    log files as examples, because they’re exactly the kind of pure-text file that
    a regex is designed to deal with. It’d be nice if we could read these logs into
    PowerShell in a more object-oriented fashion but, well, we can’t. So a regex it
    is.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来到了本章的真正重点。我们将使用一些网络服务器日志文件作为示例，因为它们正是正则表达式设计用来处理的那种纯文本文件。如果我们能够以面向对象的方式将这些日志读入
    PowerShell 那将很棒，但，嗯，我们做不到。所以我们就用正则表达式吧。
- en: 'Let’s start by scanning through the log files to look for any 40*x* errors.
    These are often File Not Found and similar, and we want to be able to generate
    a report of the bad files for our organization’s web developers. The log files
    contain a single line for each HTTP request, and each line is broken into space-delimited
    fields. We have some files that contain 401 and so forth as part of their filename—for
    example, error401.html—and we don’t want those to be included in our results.
    We specify a regex such as `\s40[0-9]\s` because that specifies a space on either
    side of the 40*x* error code. It should find all errors from 400 through 409 inclusive.
    Here’s our command:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先扫描日志文件，寻找任何40*x*错误。这些错误通常是文件未找到等，我们希望能够为我们组织的网络开发者生成一个坏文件的报告。日志文件包含每个HTTP请求的单行，并且每行被分割成空格分隔的字段。我们有一些文件，它们的文件名中包含401等，例如，error401.html，我们不希望这些文件包含在我们的结果中。我们指定一个正则表达式，如`\s40[0-9]\s`，因为它指定了40*x*错误代码两边的空格。它应该找到从400到409的所有错误。以下是我们的命令：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice that we change to the C:\LogFiles directory to run this command. We start
    by asking PowerShell to get all files matching the *.log filename pattern and
    to recurse subdirectories. That ensures that all of our log files are included
    in the output. Then we use `Select-String` and give it our regex as a pattern.
    The result of the command is a `MatchInfo` object; we use `Format-Table` to create
    a display that includes the filename, the line number, and the line of text that
    contains our match. This can be easily redirected to a file and given to our web
    developers.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们切换到C:\LogFiles目录来运行这个命令。我们首先让PowerShell获取所有匹配*.log文件名模式的文件，并递归子目录。这确保了所有日志文件都包含在输出中。然后我们使用`Select-String`并给它我们的正则表达式作为模式。命令的结果是一个`MatchInfo`对象；我们使用`Format-Table`创建一个显示，包括文件名、行号和包含匹配的文本行。这可以很容易地重定向到文件并交给我们的网络开发者。
- en: NOTE You may have noticed that we used `Format-Table`. We did this for two reasons.
    The first is because we wanted to wrap the text on the screen, and the second
    is because we are simply making the screen look cleaner, and we aren’t outputting
    any of the information.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你可能已经注意到我们使用了`Format-Table`。我们这样做有两个原因。第一个原因是我们想将屏幕上的文本换行，第二个原因是我们只是让屏幕看起来更整洁，并且我们没有输出任何信息。
- en: 'Next, we want to scan the files for all access by Gecko-based web browsers.
    Our developers tell us they’ve been having some problems with customers accessing
    the sites using those browsers, and they want to see which files in particular
    are being requested. They think they’ve narrowed the problem down to browsers
    running under Windows NT 10.0, meaning we’re looking for user-agent strings that
    look something like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要扫描所有基于Gecko的Web浏览器的访问文件。我们的开发人员告诉我们，他们的一些客户在使用这些浏览器访问网站时遇到了一些问题，他们想查看哪些特定的文件被请求。他们认为问题已经缩小到在Windows
    NT 10.0下运行的浏览器，这意味着我们正在寻找看起来像这样的用户代理字符串：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Our developers have stressed that the 64-bit thing isn’t specific, so they
    don’t want the log results limited to just `WOW64` user-agent strings. We come
    up with this regex: `10\.0;[\w\W]+\+Gecko`. Let’s break that down:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的开发人员强调，64位不是特定的，所以他们不希望日志结果仅限于`WOW64`用户代理字符串。我们提出了这个正则表达式：`10.0;[\w\W]+\+Gecko`。让我们分解一下：
- en: '`10\.0;`—This is 10.0\. Notice that we escaped the period to make it a literal
    character rather than the single-character wildcard that a period normally indicates.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`10.0;`—这是一个10.0。请注意，我们转义了点号，使其成为一个字面字符，而不是点号通常表示的单字符通配符。'
- en: '`[\w\W]+`—This is one or more word or nonword characters (in other words, anything).'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[\w\W]+`—这是一个或多个单词或非单词字符（换句话说，任何东西）。'
- en: '`\+Gecko`—This is a literal `+`, then *Gecko*.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\+Gecko`—这是一个字面的`+`，然后是*Gecko*。'
- en: 'Here’s the command to find matching lines from the log files, along with the
    first couple of lines of output:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从日志文件中查找匹配行的命令，以及输出的前几行：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We left the output in its default format this time, rather than sending it to
    a format cmdlet.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这次保留了输出的默认格式，而没有将其发送到格式化命令。
- en: 'As a final example, let’s turn from IIS log files to the Windows Security log.
    Event log entries include a `Message` property, which contains detailed information
    about the event. Unfortunately, this information is formatted for easy human reading,
    not for easy computer-based parsing. We’d like to look for all events with ID
    4624, which indicates an account logon (that number may differ in different versions
    of Windows; our example is from Windows Server 2008 R2). But we want to see only
    those events related to logons for accounts starting with WIN, which relates to
    computer accounts in our domain and whose account names end in TM20$ through TM40$,
    which are the specific computers we’re interested in. A regex for this might look
    something like `WIN[\W\w]+TM[234][0-9]\$`. Notice how we need to escape the final
    dollar sign so that it isn’t interpreted as an end-of-string anchor. We need to
    include `[\W\w]` (nonword and word characters) because it’s possible for our account
    names to include a hyphen, which wouldn’t match the `\w` word character class.
    Here’s our command:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后的例子，让我们从 IIS 日志文件转换到 Windows 安全日志。事件日志条目包括一个 `Message` 属性，其中包含有关事件的详细信息。不幸的是，这些信息是为方便人类阅读而格式化的，而不是为方便基于计算机的解析。我们希望查找所有
    ID 为 4624 的事件，这表示账户登录（这个数字在不同的 Windows 版本中可能不同；我们的例子来自 Windows Server 2008 R2）。但我们只想看到与以
    WIN 开头的账户登录相关的事件，这关系到我们域中的计算机账户，并且账户名称以 TM20$ 通过 TM40$ 结尾，这是我们感兴趣的特定计算机。这个正则表达式可能看起来像
    `WIN[\W\w]+TM[234][0-9]\$`。注意我们为什么需要转义最后的美元符号，以免它被解释为字符串结束锚点。我们需要包含 `[\W\w]`（非单词和单词字符），因为我们的账户名称可能包含连字符，这不会与
    `\w` 单词字符类匹配。以下是我们的命令：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We start by using `Where-Object` to keep only events with ID 4624\. We then
    expand the contents of the `Message` property into a plain string and pipe it
    to `Select-String`. Note that this will output the matching message text; if our
    goal was to output the entire matching event, we would have taken a different
    approach:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用 `Where-Object` 来保留具有 ID 4624 的事件。然后我们将 `Message` 属性的内容展开为普通字符串，并将其管道到
    `Select-String`。请注意，这将输出匹配的消息文本；如果我们的目标是输出整个匹配的事件，我们将采取不同的方法：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, rather than outputting the contents of the `Message` property, we simply
    look for records where the `Message` property contains text matching our regex—and
    then output the entire event object. It’s all about what you’re after in terms
    of output.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们不是输出 `Message` 属性的内容，而是简单地查找 `Message` 属性包含与我们的正则表达式匹配的文本的记录，然后输出整个事件对象。这完全取决于你想要的输出内容。
- en: 21.5 Lab
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 21.5 实验答案
- en: Note For this lab, you need any computer running PowerShell v7 or later.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：对于这个实验，你需要任何运行 PowerShell v7 或更高版本的计算机。
- en: 'Make no mistake about it, regular expressions can make your head spin, so don’t
    try to create complex regexes right off the bat—start simple. Here are a few exercises
    to ease you into it. Use regular expressions and operators to complete the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 不要误解，正则表达式可能会让你头晕，所以不要一开始就尝试创建复杂的正则表达式——从简单开始。这里有一些练习可以帮助你入门。使用正则表达式和运算符来完成以下任务：
- en: Get all files in your Windows or /usr directory that have a two-digit number
    as part of the name.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取你 Windows 或 /usr 目录下所有名称中包含两位数字的文件。
- en: 'Find all modules loaded on your computer that are from Microsoft, and display
    the name, version number, author, and company name. (Hint: Pipe `Get-module` to
    `Get-Member` to discover property names.)'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的计算机上查找所有来自微软的已加载模块，并显示名称、版本号、作者和公司名称。（提示：将 `Get-module` 管道到 `Get-Member`
    以发现属性名称。）
- en: In the Windows Update log, you want to display only the lines where the agent
    began installing files. You may need to open the file in Notepad to figure out
    what string you need to select. You may need to run `Get-WindowsUpdateLog`, and
    the corresponding log will be placed on your desktop.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Windows 更新日志中，你只想显示代理开始安装文件的行。你可能需要打开记事本来找出你需要选择的字符串。你可能需要运行 `Get-WindowsUpdateLog`，相应的日志将被放置在你的桌面上。
- en: For Linux, find your history log and display the lines where you installed packages.
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于 Linux，找到你的历史记录日志并显示你安装软件包的行。
- en: Using the `Get-DNSClientCache` cmdlet, display all listings in which the `Data`
    property is an IPv4 address.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Get-DNSClientCache` 命令，显示所有 `Data` 属性是 IPv4 地址的列表。
- en: If you are on a Linux (or Windows) machine, find the lines of the HOSTS file
    that contain IPV4 addresses.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你在一台 Linux（或 Windows）机器上，找到包含 IPV4 地址的 HOSTS 文件中的行。
- en: 21.6 Lab answers
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 21.6 实验答案
- en: '`Get-ChildItem c:\windows | where {$_.name -match "\d{2}"}`'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Get-ChildItem c:\windows | where {$_.name -match "\d{2}"}`'
- en: '`Get-ChildItem /usr | where {$_.name -match "\d{2}"}`'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Get-ChildItem /usr | where {$_.name -match "\d{2}"}`'
- en: '`get-module | where {$_.companyname -match "^Microsoft"} |`'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`get-module | where {$_.companyname -match "^Microsoft"} |`'
- en: '`Select Name,Version,Author,Company`'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Select Name,Version,Author,Company`'
- en: '`get-content C:\Windows\WindowsUpdate.log |`'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`get-content C:\Windows\WindowsUpdate.log |`'
- en: '`Select-string "[\w+\W+]Installing Update"`'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Select-string "[\w+\W+]Installing Update"`'
- en: '`Get-content ./apt/history.log | select-string "[\w+\W+]Installing"`'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Get-content ./apt/history.log | select-string "[\w+\W+]Installing"`'
- en: 'You could get by with a pattern that starts with one to three numbers followed
    by a literal period, like this:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用一个以一到三个数字开头，后跟一个实际点的模式来开始，例如：
- en: '`get-dnsclientcache | where { $_.data -match "^\d{1,3}\."}`'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`get-dnsclientcache | where { $_.data -match "^\d{1,3}\."}`'
- en: 'Or you could match an entire IPv4 address string:'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，你可以匹配整个IPv4地址字符串：
- en: '`get-dnsclientcache | where`'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`get-dnsclientcache | where`'
- en: '`{ $_.data -match "^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}"}`'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`{ $_.data -match "^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}"}`'
- en: '`gc /etc/hosts | where {$_ -match "^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}"}`'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`gc /etc/hosts | where {$_ -match "^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}"}`'
- en: 21.7 Further exploration
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 21.7 进一步探索
- en: 'You’ll find regular expressions used in other places in PowerShell, and many
    of them involve shell elements that we don’t cover in this book. Here are some
    examples:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在 PowerShell 的其他地方找到正则表达式，其中许多涉及我们在本书中没有涵盖的shell元素。以下是一些示例：
- en: The `Switch` scripting construct includes a parameter that lets it compare a
    value to one or more regular expressions.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Switch` 脚本结构包括一个参数，允许它将一个值与一个或多个正则表达式进行比较。'
- en: Advanced scripts and functions (script cmdlets) can utilize a regular expression–based
    input-validation tool to help prevent invalid parameter values.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级脚本和函数（脚本命令）可以利用基于正则表达式的输入验证工具来帮助防止无效的参数值。
- en: The `-Match` operator (which we covered briefly in this chapter) tests for string
    matches against a regular expression, and—something we didn’t share earlier—captures
    matched strings to an automatic `$matches` collection.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Match` 操作符（我们在本章中简要介绍过）用于测试字符串与正则表达式的匹配，并且——我们之前没有分享过——将匹配的字符串捕获到自动的 `$matches`
    集合中。'
- en: PowerShell utilizes industry-standard regex syntax, and if you’re interested
    in learning more, we recommend *Mastering Regular Expressions* by Jeffrey E. F.
    Friedl (O’Reilly, 2006). A gazillion other regex books are out there, some of
    which are specific to Windows and .NET (and thus PowerShell), some of which focus
    on building a regex for specific situations, and so forth. Browse your favorite
    online bookstore and see if any books look appealing to you and your specific
    needs.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 使用行业标准正则表达式语法，如果你有兴趣了解更多，我们推荐 Jeffrey E. F. Friedl 的《精通正则表达式》（O’Reilly，2006年）。市面上还有无数的正则表达式书籍，其中一些是针对Windows和.NET（以及PowerShell）的，有些专注于为特定情况构建正则表达式，等等。浏览你最喜欢的在线书店，看看是否有任何书籍看起来适合你和你特定的需求。
- en: We also use a free online regex repository, [http://RegExLib.com](http://RegExLib.com),
    which has numerous regex examples for a variety of purposes (phone numbers, email
    addresses, IP addresses, you name it). We’ve also found ourselves using [http://RegExTester.com](http://RegExTester.com),
    a website that lets you interactively test regular expressions to get them dialed
    in exactly the way you need.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了一个免费的在线正则表达式存储库，[http://RegExLib.com](http://RegExLib.com)，它包含各种目的的正则表达式示例（电话号码、电子邮件地址、IP地址等）。我们还发现自己在使用
    [http://RegExTester.com](http://RegExTester.com)，这是一个允许你交互式测试正则表达式的网站，以精确地得到你需要的方式。
