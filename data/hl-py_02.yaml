- en: Chapter 3\. Interacting with the world
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 3 章\. 与世界交互
- en: '|  |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**This chapter covers**'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: '*What libraries are*'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*有哪些库*'
- en: '*How to use libraries, including Python’s standard library*'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*如何使用库，包括 Python 的标准库*'
- en: '*An example program that uses Python’s `os` and `sys` libraries*'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Python 的 `os` 和 `sys` 库的示例程序*'
- en: '*Python’s dictionary data type*'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Python 的字典数据类型*'
- en: '|  |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: One of the key strengths of Python is its standard library. Installed along
    with Python, the standard library is a large suite of program code that covers
    common tasks like finding and iterating over files, handling user input, downloading
    and parsing pages from the web, and accessing databases. If you make good use
    of the standard library, you can often write programs in a fraction of the time
    that it would take you otherwise, with less typing and far fewer bugs.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的一个关键优势是其标准库。与 Python 一起安装的标准库是一个庞大的程序代码套件，涵盖了常见的任务，如查找和迭代文件、处理用户输入、从网络下载和解析页面，以及访问数据库。如果你充分利用标准库，你通常可以以比其他方式少得多的时间编写程序，打字更少，错误更少。
- en: '|  |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Guido’s Time Machine
  id: totrans-10
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Guido 的时光机
- en: The standard library is so extensive that one of the running jokes in the Python
    community is that Guido (the inventor of Python) owns a time machine. When someone
    asks for a module that performs a particular task, Guido hops in his time machine,
    travels back to the beginning of Python, and— “poof!”—it’s already there.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库非常庞大，以至于在 Python 社区中有一个流行的笑话是，Guido（Python 的发明者）拥有一台时光机。当有人请求一个执行特定任务的模块时，Guido
    就跳进他的时光机，回到 Python 的起点，然后——“噗！”——它就已经在那里了。
- en: '|  |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: In [chapter 2](kindle_split_010.html#ch02), you used the *choice* function in
    Python’s random module to pick something from a list, so you’ve already used a
    library. In this chapter, we’ll go in depth and find out more about how to use
    libraries, what other libraries exist, and how to use Python’s documentation to
    learn about specific libraries. In the process, you’ll also pick up a few other
    missing pieces of Python, such as how you can read files, and you’ll discover
    another of Python’s data types—the dictionary.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 2 章（[kindle_split_010.html#ch02](https://example.org/kindle_split_010.html#ch02)）中，你使用了
    Python 随机模块中的 *choice* 函数从列表中选择某个元素，所以你已经使用了一个库。在本章中，我们将深入探讨如何使用库，有哪些其他库，以及如何使用
    Python 的文档来了解特定的库。在这个过程中，你还将学会一些 Python 的其他缺失部分，比如如何读取文件，你还将发现 Python 的另一种数据类型——字典。
- en: 'The program in this chapter solves a common problem that you’ve probably faced
    before: you have two similar folders (perhaps one’s a backup of your holiday photos),
    and you’d like to know which files differ between the two of them. You’ll be tackling
    this program from a different angle than in [chapter 2](kindle_split_010.html#ch02),
    though. Rather than write most of your own code, you’ll be using Python to glue
    together several standard libraries to get the job done.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的程序解决了一个你可能之前遇到过的问题：你有两个相似的文件夹（可能一个是你的假日照片的备份），你想要知道这两个文件夹之间有哪些文件不同。你将从这个程序的不同角度来处理这个问题，而不是像在第
    2 章（[kindle_split_010.html#ch02](https://example.org/kindle_split_010.html#ch02)）中那样，写大部分自己的代码。相反，你将使用
    Python 将几个标准库粘合在一起来完成这项工作。
- en: Let’s start by learning more about Python libraries.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从了解 Python 库开始。
- en: '“Batteries included”: Python’s libraries'
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “内置电池”：Python 的库
- en: What are libraries used for? Normally, they’re geared toward a single purpose,
    such as sending data via a network, writing CSV or Excel files, displaying graphics,
    or handling user input. But libraries can grow to cover a large number of related
    functions; there’s no hard or fast rule.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 库通常用于什么？通常，它们针对单一目的，比如通过网络发送数据，写入 CSV 或 Excel 文件，显示图形，或处理用户输入。但库可以扩展以涵盖大量相关功能；没有硬性或固定的规则。
- en: '|  |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Library
  id: totrans-19
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 库
- en: Program code that is written so that it can be used by other programs.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 编写的程序代码，以便其他程序可以使用。
- en: '|  |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Python libraries can do anything that Python can, and more. In some (rare) cases,
    like intensive number crunching or graphics processing, Python can be too slow
    to do what you need; but it’s possible to extend Python to use libraries written
    in C.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Python 库可以做 Python 能做的任何事情，甚至更多。在某些（罕见）情况下，比如密集的数值计算或图形处理，Python 可能太慢而无法完成你需要的工作；但你可以扩展
    Python 来使用用 C 语言编写的库。
- en: In this section, you’ll learn about Python’s standard library, see which other
    libraries you can add, try them out, and get a handle on exploring a single library.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将了解 Python 的标准库，了解你可以添加哪些其他库，尝试它们，并掌握探索单个库的方法。
- en: Python’s standard library
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Python 的标准库
- en: Python installs with a large number of libraries that cover most of the common
    tasks that you’ll need to handle when programming.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Python 安装时附带了许多库，这些库涵盖了编程时你需要处理的几乎所有常见任务。
- en: '![](f0072-01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](f0072-01.jpg)'
- en: If you find yourself facing a tricky problem, it’s a good habit to read through
    the modules in Python’s standard library to see if something covers what you need
    to do. The Python manuals are installed with the standard Windows installer, and
    there’s normally a documentation package when installing under Linux. The latest
    versions are also available at [http://docs.python.org](http://docs.python.org)
    if you’re connected to the internet. Being able to use a good library can save
    you hours of programming, so 5 or 10 minutes up front can pay big dividends.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己面临一个棘手的问题，阅读 Python 标准库中的模块以查看是否有东西覆盖了你需要做的，这是一个好习惯。Python 手册与标准 Windows
    安装程序一起安装，在 Linux 下安装时通常会有文档包。如果你连接到互联网，最新版本也可在 [http://docs.python.org](http://docs.python.org)
    找到。能够使用一个好的库可以节省你数小时的编程时间，所以前期花上 5 或 10 分钟可以带来巨大的回报。
- en: The Python standard library is large enough that it can be hard to find what
    you need. Another way to learn it is to take it one piece at a time. The Python
    Module of the Week blog ([www.doughellmann.com/PyMOTW/](http://www.doughellmann.com/PyMOTW/))
    covers most of Python’s standard library and is an excellent way to familiarize
    yourself with what’s available, because it often contains far more explanation
    than the standard Python documentation.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的标准库足够大，以至于很难找到你需要的东西。另一种学习方法是逐个学习。Python 模块每周博客 ([www.doughellmann.com/PyMOTW/](http://www.doughellmann.com/PyMOTW/))
    涵盖了 Python 的标准库的大部分内容，是熟悉可用的内容的极好方式，因为它通常包含比标准 Python 文档更多的解释。
- en: Other libraries
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 其他库
- en: You’re not limited to the libraries that Python installs. It’s easy to download
    and install extra libraries to add the additional functionality that you need.
    Most add-on libraries come with their own installers or installation script; those
    that don’t can normally be copied into the library folder of your Python directory.
    You’ll find out how to install libraries in later chapters, Once the extra libraries
    are installed, they behave like Python’s built-in ones; there’s no special syntax
    that you need to know.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅限于 Python 安装的库。很容易下载和安装额外的库来添加你需要的额外功能。大多数附加库都附带自己的安装程序或安装脚本；那些没有的通常可以复制到你的
    Python 目录的库文件夹中。你将在后面的章节中了解到如何安装库，一旦安装了额外的库，它们的行为就像 Python 的内置库一样；你不需要知道任何特殊的语法。
- en: Using libraries
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用库
- en: 'Once installed, using a library is straightforward: just add an import line
    at the top of the script. There are several ways to do it, but here are the three
    most common.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装，使用库就很简单：只需在脚本顶部添加一行导入语句。有几种方法可以做到这一点，但这里介绍三种最常见的方法。
- en: Include Everything
  id: totrans-33
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 包含一切
- en: You can include everything from a library into your script by using a line like
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用类似以下行的方式将库中的所有内容包含到脚本中
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![](f0073-01.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](f0073-01.jpg)'
- en: 'This will read everything from the *os* module and drop it straight into your
    script. If you want to use the *access* function from *os*, you can use it directly,
    like *access("myfile.txt")*. This has the advantage of saving some typing, but
    with serious downsides:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将 *os* 模块中的所有内容直接读入你的脚本。如果你想使用 *os* 中的 *access* 函数，你可以直接使用，例如 *access("myfile.txt")*。这的优点是节省了一些输入，但缺点也很严重：
- en: You now have a lot of strange functions in your script.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，你的脚本中有很多奇怪的函数。
- en: Worse, if you include more than one module in this way, then you run the risk
    of functions in the later module overwriting the functions from the first module—ouch!
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更糟糕的是，如果你以这种方式包含多个模块，那么你面临的风险是后续模块中的函数会覆盖第一个模块中的函数——哎呀！
- en: Finally, it’s much harder to remember which module a particular function came
    from, which makes your program difficult to maintain.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，记住特定函数来自哪个模块要困难得多，这使得你的程序难以维护。
- en: Fortunately, there are much better ways to import modules.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有更好的方法来导入模块。
- en: Include the Module
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 包含模块
- en: 'A better way to handle things is with a line like *import os*. This will import
    everything in *os* but make it available only through an *os* object. Now, if
    you want to use the access function, you need to use it like this: *os.access("myfile.txt")*.
    It’s a bit more typing, but you won’t run the risk of overwriting any other functions.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 处理事情的一个更好的方法是使用类似 *import os* 的行。这将导入 *os* 中的所有内容，但只通过 *os* 对象使其可用。现在，如果你想使用
    access 函数，你需要这样使用它：*os.access("myfile.txt")*。这需要多打一些字，但你不会冒覆盖其他函数的风险。
- en: Include Only the Bits That You Want
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 只包含你需要的部分
- en: 'If you’re using the functions from a module a lot, you might find that your
    code becomes hard to read, particularly if the module has a long name. There’s
    a third option in this case: you can use a line like *from os* *import access*.
    This will import directly so that you can use *access ("myfile.txt")* without
    the module name, but only include the access function, not the entire *os* module.
    You still run the risk of overwriting with a later module, but, because you have
    to specify the functions and there are fewer of them, it’s much less likely.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你经常使用模块中的函数，你可能会发现你的代码难以阅读，尤其是如果模块有一个很长的名字。在这种情况下，还有一个第三种选择：你可以使用类似 *from
    os import access* 的行。这将直接导入，这样你就可以使用 *access("myfile.txt")* 而不需要模块名，但只包含 access
    函数，而不是整个 *os* 模块。你仍然存在后来模块覆盖的风险，但由于你必须指定函数，而且函数较少，所以这种情况发生的可能性要小得多。
- en: What’s in a library, anyway?
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 库中到底有什么呢？
- en: Libraries can include anything that comes with standard Python— variables, functions,
    and classes, as well as Python code that should be run when the library is loaded.
    You’re not limited in any way; anything that’s legal in Python is fine to put
    in a library. When using a library for the first time, it helps to know what’s
    in it, and what it does. There are two main ways to find out.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 库可以包含标准 Python 中包含的任何内容——变量、函数和类，以及当库被加载时应运行的 Python 代码。你没有任何限制；任何在 Python 中合法的内容都可以放入库中。当第一次使用库时，了解其中包含的内容和它做什么是有帮助的。有两种主要的方法可以找到这些信息。
- en: '|  |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: '*dir* and *help* aren’t only useful for libraries. You can try them on all
    of the Python objects, such as classes and functions. They even support strings
    and numbers.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*dir* 和 *help* 不仅对库有用。你可以在所有 Python 对象上尝试它们，例如类和函数。它们甚至支持字符串和数字。'
- en: '|  |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Read the Fine Manual
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 阅读详细手册
- en: Python comes with a detailed manual on every aspect of its use, syntax, standard
    libraries—pretty much everything you might need to reference when writing programs.
    It doesn’t cover every possible use, but the majority of the standard library
    is there. If you have internet access, you can view it at [http://docs.python.org](http://docs.python.org),
    and it’s normally installed alongside Python, too.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了关于其使用、语法、标准库等各个方面的详细手册——几乎是你编写程序时可能需要参考的所有内容。它不涵盖所有可能的使用情况，但大多数标准库都在其中。如果你有互联网访问权限，你可以在
    [http://docs.python.org](http://docs.python.org) 上查看它，它通常也与 Python 一起安装。
- en: Exploration
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 探索
- en: One useful function for finding out what a library contains is *dir()*. You
    can call it on any object to find out what methods it supports, but it’s particularly
    useful with libraries. You can combine it with the *__doc__* special variable,
    which is set to the doc-string defined for a function or method, to get a quick
    overview of a library’s or class’s methods and what they do. This combination
    is so useful that there’s a shortcut called *help()* that is defined as one of
    Python’s built-in functions.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 用于查找库包含内容的实用函数是 *dir()*. 你可以对其任何对象进行调用以了解它支持哪些方法，但它在库中特别有用。你可以将其与 *__doc__*
    特殊变量结合使用，该变量设置为函数或方法定义的 doc-string，以快速了解库或类的方方法和它们的作用。这种组合非常有用，以至于有一个名为 *help()*
    的快捷方式，它被定义为 Python 的内置函数之一。
- en: '![](f0074-01.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](f0074-01.jpg)'
- en: For the details, you’re often better off looking at the documentation; but if
    you only need to jog your memory, or if the documentation is patchy or confusing,
    *dir()*, *__doc__*, and *help()* are much faster. The following listing is an
    example of looking up some information about the *os* library.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对于详细信息，查看文档通常更好；但如果只是需要唤醒记忆，或者文档不完整或令人困惑，那么使用 *dir()*, *__doc__*, 和 *help()*
    会更快。以下列表是一个查找有关 *os* 库信息的示例。
- en: Listing 3.1\. Finding out more about the os.path library
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.1\. 了解更多关于 os.path 库的信息
- en: '![](ch03list1-0.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](ch03list1-0.jpg)'
- en: '![](ch03list1-1.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](ch03list1-1.jpg)'
- en: First, you need to import the *os* module ![](one.jpg). You can import *os.path*
    directly, but this is the way that it’s normally done, so you’ll have fewer surprises
    later. Next, you call the *dir()* function on *os.path*, to see what’s in it ![](two.jpg).
    The function will return a big list of function and variable names, including
    some built-in Python ones like *__doc__* and *__name__*.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要导入 *os* 模块 ![one.jpg](one.jpg)。你可以直接导入 *os.path*，但这是通常的做法，所以你以后会有更少的意外。接下来，你在
    *os.path* 上调用 *dir()* 函数，以查看其中包含的内容 ![two.jpg](two.jpg)。该函数将返回一个包含函数和变量名称的大列表，包括一些内置的
    Python 名称，如 *__doc__* 和 *__name__*。
- en: Because you can see a *__doc__* variable in *os.path*, print it and see what
    it contains ![](three.jpg). It’s a general description of the *os.path* module
    and how it’s supposed to be used.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你在 *os.path* 中可以看到一个 *__doc__* 变量，所以打印它并查看它包含的内容 ![three.jpg](three.jpg)。这是对
    *os.path* 模块及其预期用途的一般描述。
- en: If you look at the *__doc__* variable for a function in *os.path* ![](four.jpg),
    it shows much the same thing—a short description of what the function is supposed
    to do.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 *os.path* 中一个函数的 *__doc__* 变量 ![four.jpg](four.jpg)，它会显示几乎相同的内容——该函数预期要做的简短描述。
- en: Once you’ve found a function that you think does what you need, you can try
    it out to make sure ![](five.jpg). Here, you’re calling *os.path.isdir()* on a
    couple of different files and directories to see what it returns. For more complicated
    libraries, you might find it easier to write a short program rather than type
    it all in at the command line.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你找到一个你认为可以满足你需求的函数，你可以尝试它来确保 ![five.jpg](five.jpg)。在这里，你正在对几个不同的文件和目录调用 *os.path.isdir()*
    来查看它返回的内容。对于更复杂的库，你可能发现编写一个简短的程序比在命令行中输入所有内容更容易。
- en: Finally, the output of the *help()*function ![](six.jpg) contains all the same
    information that *__doc__* and *dir()* do, but printed nicely. It also looks through
    the whole object and returns all of its variables and methods without you having
    to look for them. You can press space or page up and down to read the output,
    and Q when you want to go back to the interpreter.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，*help()* 函数的输出 ![six.jpg](six.jpg) 包含了与 *__doc__* 和 *dir()* 相同的所有信息，但打印得更加美观。它还会遍历整个对象，并返回所有变量和方法，而无需你亲自寻找。你可以按空格键或翻页键上下浏览输出，当你想返回到解释器时按
    Q 键。
- en: In practice, it can often take a combination of these methods before you understand
    enough about the library for it to be useful. A quick overview of the library
    documentation, followed by some experimenting at the command line and a further
    read of the documentation, will provide you with some of the finer points once
    you understand how it all fits together. Also, bear in mind that you don’t necessarily
    have to understand the entire library at once, as long as you can pick and choose
    the pieces you need.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，在理解足够关于库以使其有用之前，你通常需要结合使用这些方法。快速浏览库文档，然后在命令行进行一些实验，并进一步阅读文档，一旦你理解了所有这些是如何结合在一起的，你将获得一些更细微的要点。此外，请记住，你不必一次性理解整个库，只要你能挑选出你需要的部分即可。
- en: Now that you know the basics of Python libraries, let’s see what you can do
    with them.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了 Python 库的基础知识，让我们看看你可以用它们做什么。
- en: Another way to ask questions
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 另一种提问方式
- en: 'There’s one thing that you need to know before you can start putting your program
    together. Actually, there are a couple of other things, but you can pick those
    up on the way. What you’d like to be able to do in order to begin is tell the
    computer which directories you want to compare. If this were a normal program,
    you’d probably have a graphical interface where you could click the relevant directories.
    But that sounds hard, so you’ll pick something simpler to write: a command-line
    interface.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始组合你的程序之前，有一件事你需要知道。实际上，还有其他几件事，但你可以在路上学到它们。为了开始，你想要能够告诉计算机你想要比较哪些目录。如果这是一个正常的程序，你可能会有一个图形界面，你可以点击相关的目录。但那听起来很复杂，所以你将选择一个更简单的方式来编写：命令行界面。
- en: Using command-line arguments
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用命令行参数
- en: 'Command-line arguments are often used in system-level programs. When you run
    a program from the command line, you can specify additional parameters by typing
    them after the program’s name. In this case, you’ll be typing in the names of
    the two directories that you want to compare; something like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行参数常用于系统级程序中。当你从命令行运行程序时，你可以在程序名称后输入额外的参数来指定它们。在这种情况下，你将输入你想比较的两个目录的名称；类似于这样：
- en: '[PRE1]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![](f0077-01.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![f0077-01.jpg](f0077-01.jpg)'
- en: 'If you have spaces in your directory name, you can surround the parameters
    with quotation marks; otherwise, your operating system will interpret it as two
    different parameters:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的目录名中包含空格，你可以用引号将参数括起来；否则，你的操作系统会将其解释为两个不同的参数：
- en: '[PRE2]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now that you have your parameters, what are you going to do with them?
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了你的参数，你打算如何使用它们？
- en: Using the sys module
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 sys 模块
- en: In order to read the parameters you’ve fed in, you’ll need to use the *sys*
    module that comes with Python’s standard library. *sys* deals with all sorts of
    system-related functionality, such as finding out which version of Python a script
    is running on, information about the script, paths, and so on. You’ll be using
    *sys.argv*, which is an array containing the script’s name and any parameters
    that it was called with. Your initial program is [listing 3.2](#ch03list2), which
    will be the starting point for the comparison script.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了读取你输入的参数，你需要使用 Python 标准库中提供的 *sys* 模块。*sys* 处理所有与系统相关的功能，例如找出脚本正在运行的 Python
    版本、有关脚本的信息、路径等等。你将使用 *sys.argv*，它是一个包含脚本名称和任何调用时传递的参数的数组。你的初始程序是 [列表 3.2](#ch03list2)，它将是比较脚本的起点。
- en: Listing 3.2\. Reading parameters using `sys`
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.2\. 使用 `sys` 读取参数
- en: '![](03list02_alt.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](03list02_alt.jpg)'
- en: First, you check to make sure that the script has been called with enough parameters
    ![](one.jpg). If there are too few, then you return an error to the user. Note
    also that you’re using *sys.argv[0]* to find out what the name of your script
    is and *sys.exit* to end the program early.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要检查脚本是否已经用足够的参数调用！[](one.jpg)。如果参数太少，那么你将向用户返回一个错误。注意，你正在使用 *sys.argv[0]*
    来找出脚本的名称，以及使用 *sys.exit* 来提前结束程序。
- en: Because you know now that there are at least two other values, you can store
    them for later use ![](two.jpg). You could use *sys.argv* directly, but this way,
    you’ve got a nice variable name, which makes the program easier to understand.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 因为现在你知道至少还有两个其他值，你可以将它们存储起来以供以后使用！[](two.jpg)。你可以直接使用 *sys.argv*，但这样你就有了一个很好的变量名，这使得程序更容易理解。
- en: Once you have the variables set, you can print them out ![](three.jpg) to make
    sure they’re what you’re expecting. You can test it out by trying the commands
    from the section “Using command-line arguments.” The script should respond back
    with whatever you’ve specified.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了变量，你可以将它们打印出来！[](three.jpg) 以确保它们是你所期望的。你可以通过尝试“使用命令行参数”部分中的命令来测试它。脚本应该会回应你所指定的内容。
- en: '|  |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: File objects are an important part of Python. Quite a few libraries use file-like
    objects to access other things, like web pages, strings, and the output returned
    from other programs.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 文件对象是 Python 的重要组成部分。许多库使用类似文件的对象来访问其他事物，如网页、字符串以及其他程序返回的输出。
- en: '|  |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: If you’re happy with the results, it’s time to start building the program in
    the next section.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对自己的结果满意，那么现在是时候开始构建下一节中的程序了。
- en: Reading and writing files
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读取和写入文件
- en: The next thing you’ll need to do in your duplicate checker is to find your files
    and directories and open them to see if they’re the same. Python has built-in
    support for handling files as well as good cross platform file and directory support
    via the *os* module. You’ll be using both of these in your program.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的重复检查器中，接下来你需要做的是找到你的文件和目录，并打开它们以查看它们是否相同。Python 内置了对文件的处理支持，以及通过 *os* 模块提供的良好的跨平台文件和目录支持。你将在你的程序中使用这两个模块。
- en: Paths and directories (a.k.a. dude, where’s my file?)
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 路径和目录（也就是，我的文件在哪里？）
- en: Before you open your file, you need to know where to find it. You want to find
    all of the files in a directory and open them, as well as any files in directories
    within that directory, and so on. That’s pretty tricky if you’re writing it yourself;
    fortunately, the *os* module has a function called *os.walk()* that does exactly
    what you want. The *os.walk()* function returns a list of all of the directories
    and files for a path. If you append [listing 3.3](#ch03list3) to the end of [listing
    3.2](#ch03list2), it will call *os.walk()* on the directories that you’ve specified.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在你打开文件之前，你需要知道它在哪。你想要找到目录中的所有文件并将它们打开，以及在该目录中的任何子目录中的文件，依此类推。如果你自己编写它，这相当棘手；幸运的是，*os*
    模块有一个名为 *os.walk()* 的函数，它正好能完成你想要的功能。*os.walk()* 函数返回一个包含路径中所有目录和文件的列表。如果你将 [列表
    3.3](#ch03list3) 添加到 [列表 3.2](#ch03list2) 的末尾，它将在你指定的目录上调用 *os.walk()*。
- en: Listing 3.3\. Using `os.walk()`
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.3\. 使用 `os.walk()`
- en: '![](03list03_alt.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](03list03_alt.jpg)'
- en: You’re going to be doing the same thing for both *directory1* and *directory2*
    ![](one.jpg). You could repeat your code over again for *directory2*, but if you
    want to change it later, you’ll have to change it in two places. Worse, you could
    accidentally change one but not the other, or change it slightly differently.
    A better way is to use the directory names in a *for* loop like this, so you can
    reuse the code within the loop.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你将对*directory1*和*directory2*都做同样的事情！[](one.jpg)。你可以为*directory2*重复你的代码，但如果你以后想修改它，你将不得不在两个地方进行修改。更糟糕的是，你可能会不小心只修改了一个，而没有修改另一个，或者修改的方式略有不同。更好的方法是使用*for*循环中的目录名，这样你就可以在循环中重用代码。
- en: '![](f0080-01.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](f0080-01.jpg)'
- en: It’s good idea to check the input that your script’s been given ![](two.jpg).
    If there’s something amiss, then exit with a reasonable error message to let the
    user know what’s gone wrong.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 检查你的脚本输入是个好主意！[](two.jpg)。如果有问题，那么退出并给出一个合理的错误信息，让用户知道出了什么问题。
- en: '![](three.jpg) is the part where you walk over the directory. For now, you’re
    printing the raw output that’s returned from *os.walk()*, but in a minute you’ll
    do something with it.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '![](three.jpg)是遍历目录的部分。现在，你正在打印由*os.walk()*返回的原始输出，但很快你将对它做些处理。'
- en: I’ve set up two test directories on my computer with a few directories that
    I found lying around. It’s probably a good idea for you to do the same, so you
    can test your program and know you’re making progress.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我在我的电脑上设置了两个测试目录，里面有一些我找到的目录。你可能也这样做是个好主意，这样你可以测试你的程序，并知道你在取得进步。
- en: 'If you run the program so far, you should see something like the following
    output:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行到目前为止的程序，你应该会看到以下类似的输出：
- en: '[PRE3]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In Python strings, some special characters can be created by using a backslash
    in front of another character. If you want a tab character, for example, you can
    put *\t* into your string. When Python prints it, it will be replaced with a literal
    tab character. If you do want a backslash, though—as you do here—then you’ll need
    to use two backslashes, one after the other.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python字符串中，可以通过在另一个字符前使用反斜杠来创建一些特殊字符。例如，如果你想有一个制表符字符，你可以在你的字符串中放入*\t*。当Python打印它时，它将被替换为一个实际的制表符字符。不过，如果你确实需要使用反斜杠——就像你在这里做的那样——那么你需要使用两个连续的反斜杠。
- en: The output for each line gives you the name of a directory within your path,
    then a list of directories within that directory, then a list of the files ...
    handy, and definitely beats writing your own version.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行的输出都会给你路径中目录的名称，然后是那个目录内的目录列表，然后是文件列表……这很方便，而且绝对比编写你自己的版本要好。
- en: '![](f0081-01.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](f0081-01.jpg)'
- en: Paths
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 路径
- en: If you want to use a file or directory, you’ll need what’s called a *path*.
    A path is a string that gives the exact location of a file, including any directories
    that contain it. For example, the path to Python on my computer is C:\python26\python.exe,
    which looks like *"C:\\python26\\python.exe"* when expressed as a Python string.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要使用一个文件或目录，你需要一个所谓的*路径*。路径是一个字符串，它给出了文件的精确位置，包括包含它的任何目录。例如，我电脑上Python的路径是C:\python26\python.exe，当它作为一个Python字符串表达时，看起来像*"C:\\python26\\python.exe"*。
- en: If you wanted a path for foo2.py in the last line of the previous listing, you
    can use *os.path.join('C:\\test2\\test', 'foo2.py')*, to get a path that looks
    like *'C:\\test2\\test\\foo2.py'*. You’ll see more of the details when you start
    putting your program together in a minute.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在上一列表的最后一行为foo2.py设置一个路径，你可以使用*os.path.join('C:\\test2\\test', 'foo2.py')*，以得到看起来像*'C:\\test2\\test\\foo2.py'*的路径。当你开始组装你的程序时，你将看到更多细节。
- en: '|  |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: One thing to keep in mind when using paths is that the separator will be different
    depending on which platform you’re using. Windows uses a backslash (\) character,
    and Linux and Macintosh use a forward slash (/). To make sure your programs work
    on all three systems, it’s a good idea to get in the habit of using the *os.path.join()*
    function, which takes a list of strings and joins them with whatever the path
    separator is on the current computer.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用路径时，需要注意的一点是，分隔符将根据你使用的平台而有所不同。Windows使用反斜杠（\）字符，而Linux和Macintosh使用正斜杠（/）。为了确保你的程序在所有三个系统上都能工作，养成使用*os.path.join()*函数的习惯是个好主意，它接受一个字符串列表，并将它们与当前计算机上的路径分隔符连接起来。
- en: '|  |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Once you have the location of your file, the next step is opening it.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你找到了你的文件位置，下一步就是打开它。
- en: File, open!
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 文件，打开！
- en: 'To open a file in Python, you can use the *file()* or *open()* built-in function.
    They’re exactly the same behind the scenes, so it doesn’t matter which one you
    use. If the file exists and you can open it, you’ll get back a file object, which
    you can read using the *read()* or *readlines()* method. The only difference between
    *read()* and *readlines()* is that *readlines()* will split the file into strings,
    but *read()* will return the file as one big string. This code shows how you can
    open a file and read its contents:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中打开文件，你可以使用 *file()* 或 *open()* 内置函数。它们在幕后是完全相同的，所以使用哪一个都无关紧要。如果文件存在并且你可以打开它，你会得到一个文件对象，你可以使用
    *read()* 或 *readlines()* 方法来读取它。*read()* 和 *readlines()* 之间的唯一区别是 *readlines()*
    会将文件分割成字符串，而 *read()* 会返回一个大的字符串。此代码展示了如何打开文件并读取其内容：
- en: '[PRE4]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: First, create a path using *os.path.join()*, and then use it to open the file
    at that location. You’ll want to put in the path to a text file that exists on
    your computer. *read_file* will now be a file object, so you can use the *readlines()*
    method to read the entire contents of the file. You’re also turning the file contents
    into a list using the *list()* function. You don’t normally treat files like this,
    but it helps to show you what’s going on. *file_contents* is a list now, so you
    can use the *len()* function to see how many lines it has, and print the first
    line by using an index of 0.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用 *os.path.join()* 创建一个路径，然后使用它来打开该位置上的文件。你需要输入你电脑上存在的文本文件的路径。现在 *read_file*
    将成为一个文件对象，因此你可以使用 *readlines()* 方法来读取文件的全部内容。你还将使用 *list()* 函数将文件内容转换为列表。你通常不会这样处理文件，但这有助于展示正在发生的事情。*file_contents*
    现在是一个列表，因此你可以使用 *len()* 函数来查看它有多少行，并通过使用索引 0 来打印第一行。
- en: 'Although you won’t be using it in your program, it’s also possible to write
    text into a file as well as read from it. To do this, you’ll need to open the
    file with a write mode instead of the default read-only mode, and use the *write()*
    or *writelines()* function of the file object. Here’s a quick example:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你不会在程序中使用它，但也可以将文本写入文件，以及从文件中读取。为此，你需要以写入模式而不是默认的只读模式打开文件，并使用文件对象的 *write()*
    或 *writelines()* 函数。这里有一个快速示例：
- en: '![](f0082-01_alt.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](f0082-01_alt.jpg)'
- en: You’re using the same *file()* function you used before, but here you’re feeding
    it an extra parameter, the string *"w"*, to tell Python that you want to open
    it for writing ![](one.jpg).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用的是之前使用的相同的 *file()* 函数，但在这里你给它提供了一个额外的参数，字符串 *"w"*, 来告诉 Python 你想要以写入模式打开它
    ![](one.jpg)。
- en: Once you have the file object back, you can write to it by using the *.write()*
    method, with the string you want to write as a parameter ![](two.jpg). The *"\n"*
    at the end is a special character for a new line; without it, all of the output
    would be on one line. You can also write multiple lines at once, by putting them
    into a list and using the *.writelines()* method instead ![](three.jpg).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你得到了文件对象，你可以通过使用 *.write()* 方法并传入要写入的字符串作为参数来向它写入内容 ![](two.jpg)。末尾的 *"\n"*
    是一个特殊字符，表示换行；如果没有它，所有的输出都会在同一行上。你也可以一次性写入多行，通过将它们放入一个列表并使用 *.writelines()* 方法来实现
    ![](three.jpg)。
- en: Once you’re done with a file, it’s normally a good idea to close it ![](four.jpg),
    particularly if you’re writing to it. Files can sometimes be buffered, which means
    they’re not written onto the disk straight away—if your computer crashes, it might
    not be saved.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成文件操作后，通常一个好的做法是关闭它 ![](four.jpg)，尤其是如果你正在写入文件。文件有时可能会被缓冲，这意味着它们不会立即写入磁盘——如果你的电脑崩溃，它可能不会被保存。
- en: That’s not all you can do with files, but it’s enough to get started. For your
    difference engine you won’t need to write files, but it will help for future programs.
    For now, let’s turn our attention to the last major feature you’ll add to your
    program.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是你可以对文件做的所有事情，但这足以开始。对于你的差分机，你不需要编写文件，但这将有助于未来的程序。现在，让我们将注意力转向你将在程序中添加的最后一个主要功能。
- en: Comparing files
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较文件
- en: We’re almost there, but there’s one last hurdle. When you’re running your program,
    you need to know whether you’ve seen a particular file in the other directory,
    and if so, whether it has the same content, too. You could read in all the files
    in and compare their content line by line, but what if you have a large directory
    with big images? That’s a lot of storage, which means Python is likely to run
    slowly.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了，但还有一个最后的障碍。当你运行程序时，你需要知道你是否在其他目录中看到过特定的文件，以及如果有的话，它是否有相同的内容。你可以读取所有文件并逐行比较它们的内容，但如果你有一个包含大图像的大目录呢？这将占用大量存储空间，这意味着
    Python 可能会运行得较慢。
- en: '|  |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: It’s often important to consider how fast your program will run, or how much
    data it will need to store, particularly if the problem that you’re working on
    is open ended—that is, if it might be run on a large amount of data.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，考虑你的程序将运行得多快，或者它需要存储多少数据，尤其是如果你正在解决的问题没有明确的结束——也就是说，它可能在大量的数据上运行。
- en: '|  |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Fingerprinting a file
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 文件指纹
- en: 'Fortunately, there’s another library to help you, called *hashlib*, which is
    used to generate a hash for a particular piece of data. A hash is like a fingerprint
    for a file: from the data it’s given, it will generate a list of numbers and letters
    that’s virtually guaranteed to be unique for that data. If even a small part of
    the file changes, the hash will be completely different, and you’ll be able to
    detect the change. Best of all, the hashes are relatively small, so they won’t
    take up much space. The following listing features a small script that shows how
    you might generate a hash for one file.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，还有一个名为*hashlib*的库可以帮助你，它用于为特定数据生成哈希。哈希就像文件的指纹：从它提供的数据中，它会生成一个数字和字母列表，对于该数据几乎可以保证是唯一的。如果文件的一小部分发生变化，哈希将完全不同，你将能够检测到变化。最好的是，哈希相对较小，所以它们不会占用太多空间。下面的列表展示了如何为单个文件生成哈希的小脚本。
- en: Listing 3.4\. Generating a hash for a file
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.4\. 为文件生成哈希
- en: '![](03list04.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![03list04.jpg](03list04.jpg)'
- en: After importing your libraries, you read a file name from the command line and
    open it ![](one.jpg). Next, you create a hash object here ![](two.jpg), which
    will handle all of the hash generation. I’m using md5, but there are many others
    in *hashlib*.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入你的库之后，你从命令行读取一个文件名并打开它 ![one.jpg](one.jpg)。接下来，你在这里创建一个哈希对象 ![two.jpg](two.jpg)，它将处理所有的哈希生成。我正在使用md5，但在*hashlib*中还有很多其他的选项。
- en: Once you have an open file and a hash object, you feed each line of the file
    into the hash with the *update()* method ![](three.jpg).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有一个打开的文件和一个哈希对象，你可以通过*update()*方法 ![three.jpg](three.jpg) 将文件的每一行输入到哈希中。
- en: After you’ve fed all the lines into the hash, you can get the final hash in
    *hexdigest* form ![](four.jpg). It uses only numbers and the letters *a*–*f*,
    so it’s easy to display on screen or paste into an email.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在你将所有行输入到哈希之后，你可以以*hexdigest*形式获取最终的哈希 ![four.jpg](four.jpg)。它只使用数字和字母*a*–*f*，所以它很容易在屏幕上显示或粘贴到电子邮件中。
- en: An easy way to test the script is to run it on itself. After you’ve run it once,
    try making a minor change to the script, such as adding an extra blank line at
    the end of the file. If you run the script again, the output should be completely
    different.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 测试脚本的一个简单方法是将它运行在自身上。在运行一次之后，尝试对脚本进行一些小的修改，比如在文件末尾添加一个额外的空白行。如果你再次运行脚本，输出应该是完全不同的。
- en: 'Here, I’m running the hash-generating script on itself. For the same content,
    it will always generate the same output:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我正在运行哈希生成脚本本身。对于相同的内容，它总是会生成相同的输出：
- en: '[PRE5]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'These are the results of adding one blank line to the end of the hash.py file.
    It’s a minor change (most people wouldn’t notice it), but now the hash is completely
    different:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是在hash.py文件末尾添加一个空白行后的结果。这是一个微小的变化（大多数人不会注意到），但现在哈希已经完全不同了：
- en: '[PRE6]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now that your hashes are working, let’s see how you can use them in your program.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在既然你的哈希已经工作，让我们看看你如何在程序中使用它们。
- en: 'Mugshots: storing your files’ fingerprints in a dictionary'
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Mugshots：在字典中存储你的文件的指纹
- en: 'Now that you can generate a hash for any given file, you need somewhere to
    put it. One option is to put the hashes into a list, but searching over a list
    every time you want to find a particular file is slow, particularly if you have
    a large directory with lots of files. There’s a better way to do it, by using
    Python’s other main data type: the dictionary.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以为任何给定的文件生成哈希，但你需要有一个地方来存放它。一个选项是将哈希放入一个列表中，但每次你想找到特定的文件时都要在列表中进行搜索，这会很慢，尤其是如果你有一个包含大量文件的目录。有一个更好的方法来做这件事，那就是使用Python的另一个主要数据类型：字典。
- en: '![](f0085-01.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![f0085-01.jpg](f0085-01.jpg)'
- en: You can think of dictionaries as a bag of data. You put data in, give it a name,
    and then, later, when you want the data back, you give the dictionary its name,
    and the dictionary will return the data. In Python’s terminology, the name is
    called a *key* and the data is called the *value* for that key. Let’s see how
    you use a dictionary by taking a look at the following listing.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把字典想象成一个数据包。你把数据放进去，给它一个名字，然后，稍后，当你想要数据时，你给出字典的名字，字典就会返回数据。在Python的术语中，这个名字被称为*键*，而数据是该键的*值*。让我们通过查看以下列表来了解如何使用字典。
- en: Listing 3.5\. How to use a dictionary
  id: totrans-146
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.5\. 如何使用字典
- en: '![](03list05_alt.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](03list05_alt.jpg)'
- en: Dictionaries are fairly similar to lists, except that you use curly braces instead
    of square brackets, and you separate keys and their values with a colon.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与列表相当相似，只是你使用花括号而不是方括号，并且用冒号分隔键和它们的值。
- en: 'The other similarity to lists is that you can include anything that you like
    as a value ![](one.jpg), including lists, dictionaries, and other objects. You’re
    not limited to storing simple types like strings or numbers, or one type of thing.
    The only constraint is on the key: it can only be something that isn’t modifiable,
    like a string or number.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 列表的其他相似之处在于，你可以将任何你喜欢的作为值包含在内！[](one.jpg)，包括列表、字典和其他对象。你不仅限于存储简单的类型，如字符串或数字，或一种类型的东西。唯一的限制是键：它只能是不可以修改的东西，如字符串或数字。
- en: '![](f0086-01.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](f0086-01.jpg)'
- en: To get your value back once you’ve put it in the dictionary, use the dictionary’s
    name with the key after it in square brackets ![](two.jpg). If you’re finished
    with a value, it’s easy to remove it by using *del* followed by the dictionary
    and the key that you want to delete ![](three.jpg).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在字典中添加了值，想要取回它，可以使用字典的名称，后面跟着方括号中的键！[](two.jpg)。如果你完成了一个值，使用*del*后跟字典和要删除的键就可以轻松地移除它！[](three.jpg)。
- en: 'Dictionaries are objects, so they have some useful methods ![](four.jpg) as
    well as direct access. *keys()* returns all of the keys in a dictionary, *values()*
    will return its values, and *items()* returns both the keys and values. Typically,
    you’ll use it in a *for* loop, like this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 字典是对象，因此它们有一些有用的方法！[](four.jpg)以及直接访问。*keys()* 返回字典中的所有键，*values()* 将返回其值，而
    *items()* 返回键和值。通常，你会在 *for* 循环中使用它，如下所示：
- en: '[PRE7]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When deciding what keys and values to use for a dictionary, the best option
    is to use something unique for the key, and the data you’ll need in your program
    as the value. You might need to convert the data somehow when building your dictionary,
    but it normally makes your code easier to write and easier to understand. For
    your dictionary, you’ll use the path to the file as the key, and the checksum
    you’ve generated as the value.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定为字典使用哪些键和值时，最佳选项是使用对键唯一的值，以及你程序中需要的数据作为值。你可能需要在构建字典时以某种方式转换数据，但这通常会使你的代码更容易编写和理解。对于你的字典，你将使用文件的路径作为键，以及你生成的校验和作为值。
- en: Now that you know about hashes and dictionaries, let’s put your program together.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了哈希和字典，让我们把你的程序组合起来。
- en: Putting it all together
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 整合所有内容
- en: “Measure twice, cut once” is an old adage that often holds true. When programming,
    you always have your undo key, but you can’t undo the time you spent writing the
    code you end up throwing away.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: “量两次，切一次”是一个古老的谚语，通常情况下是正确的。在编程时，你总是有撤销键，但你无法撤销你用来编写最终丢弃的代码所花费的时间。
- en: When developing a program, it often helps to have some sort of plan in place
    as to how you’ll proceed. Your plan doesn’t have to be terribly detailed; but
    it can help you to avoid potential roadblocks or trouble spots if you can foresee
    them. Now that you think you have all of the parts you’ll need, let’s plan out
    the overall design of your program at a high level. It should go something like
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发程序时，制定一个如何进行的计划往往很有帮助。你的计划不必非常详细；但它可以帮助你预见潜在的障碍或问题点，从而避免它们。现在你认为你已经拥有了所有需要的部分，让我们从高层次上规划一下程序的整体设计。它应该类似于
- en: Read in and sanity-check the directories you want to compare.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取并检查你想要比较的目录。
- en: Build a dictionary containing all the files in the first directory.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建包含第一个目录中所有文件的字典。
- en: For each file in the second directory, compare it to the same file in the first
    dictionary.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于第二个目录中的每个文件，将其与第一个字典中的相同文件进行比较。
- en: That seems pretty straightforward. In addition to having this overall structure,
    it can help to think about the four different possibilities for each file, as
    shown in the following figure.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来相当直接。除了有这个整体结构外，考虑每个文件的四种不同可能性也有帮助，如下面的图所示。
- en: Figure 3.1\. The four possibilities for differences between files
  id: totrans-163
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.1\. 文件之间差异的四种可能性
- en: '| **Case 1** | **The file doesn’t exist in directory 2.** | **Case 2** | **The
    file exists, but is different in each directory.** |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| **情况 1** | **文件不存在于目录 2 中。** | **情况 2** | **文件存在，但在每个目录中都不相同。** |'
- en: '| **Case 3** | **The files are identical in both.** | **Case 4** | **The file
    exists in directory 2, but not in your first directory.** |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| **情况 3** | **两个目录中的文件完全相同。** | **情况 4** | **文件存在于目录 2 中，但不在你的第一个目录中。** |'
- en: Given this rough approach, a couple of issues should stand out. First, your
    initial plan of building all the checksums right away may not be such a good idea
    after all. If the file isn’t in the second directory, then you’ll have gone to
    all the trouble of building a checksum that you’ll never use. For small files
    and directories it might not make much difference, but for larger ones (for example,
    photos from a digital camera or MP3s), the extra time might be significant. The
    solution to this is to put a placeholder into the dictionary that you build and
    only generate the checksum once you know you have both files.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这种粗略的方法，应该有几个问题应该引起注意。首先，你一开始就构建所有校验和的计划可能最终并不好。如果文件不在第二个目录中，那么你将经历所有构建校验和的麻烦，但你永远不会使用它。对于小型文件和目录，这可能没有太大区别，但对于较大的文件（例如，数码相机的照片或MP3文件），额外的时间可能很重要。这个问题的解决方案是在你构建的字典中放入一个占位符，并且只有在你知道你有这两个文件时才生成校验和。
- en: '|  |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Can’t You Use A List?
  id: totrans-168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 你不能使用列表吗？
- en: If you’re putting a placeholder into your dictionary instead of a checksum,
    you’d normally start by using a list. Looking up a value in a dictionary is typically
    much faster, though; for large lists, Python needs to check each value in turn,
    whereas a dictionary needs a single lookup. Another good reason is that dictionaries
    are more flexible and easier to use than lists if you’re comparing independent
    objects.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将占位符放入字典而不是校验和，你通常会从使用列表开始。在字典中查找值通常要快得多；对于大型列表，Python 需要逐个检查每个值，而字典只需要一次查找。另一个好理由是，如果你正在比较独立对象，字典比列表更灵活且更容易使用。
- en: '|  |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Second, what happens if a file is in the first directory but not the second?
    Given the rough plan we just discussed, you’re only comparing the second directory
    to the first one, not vice versa. You won’t notice a file if it’s not in the second
    directory. One solution to this is to delete the files from the dictionary as
    you compare them. Once you’ve finished the comparisons, you know that anything
    left over is missing from the second directory.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，如果一个文件在第一个目录中但不在第二个目录中会发生什么？根据我们刚才讨论的粗略计划，你只是在比较第二个目录和第一个目录，而不是反过来。如果你不在第二个目录中，你不会注意到文件。一个解决方案是在比较文件时从字典中删除文件。一旦你完成了比较，你就知道剩下的任何东西都是第二个目录中缺失的。
- en: 'Planning like this can take time, but it’s often faster to spend a little time
    up front working out potential problems. What’s better to throw away when you
    change your mind: five minutes of design or half an hour of writing code? [Listings
    3.6](#ch03list6) and [3.7](#ch03list7) show the last two parts of your program
    based on the updated plan. You can join these together with [listings 3.2](#ch03list2)
    and [3.3](#ch03list3) to get a working program.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的规划可能需要时间，但通常在前期花点时间解决潜在问题会更快。当你改变主意时，什么更容易丢弃：五分钟的设计还是半小时的编码？[列表 3.6](#ch03list6)
    和 [3.7](#ch03list7) 展示了基于更新计划的程序的最后两部分。你可以将它们与 [列表 3.2](#ch03list2) 和 [3.3](#ch03list3)
    结合起来，得到一个可工作的程序。
- en: '![](f0088-01.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图片](f0088-01.jpg)'
- en: Listing 3.6\. Utility functions for your difference program
  id: totrans-174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.6\. 差异程序实用函数
- en: '![](ch03list6-0.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch03list6-0.jpg)'
- en: '![](ch03list6-1.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch03list6-1.jpg)'
- en: This is the program from [listing 3.5](#ch03list5), rolled up into a function.
    Notice how a docstring has been added as the second line ![](one.jpg) so it’s
    easy to remember what the function does.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从 [列表 3.5](#ch03list5) 中的程序，封装成一个函数。注意，第二行添加了一个文档字符串，这样就可以很容易地记住函数的作用。[图片](one.jpg)
- en: Because you’ll be building a list of files for two directories, it makes sense
    to have a function that returns all the information you need about a directory
    ![](two.jpg), so you can reuse it each time. The two things you need are the *root*,
    or lowest-level directory (the one typed in at the command line) and a list of
    all the files relative to that root so you can compare the two directories easily.
    For example, *C*:\test\test_dir\file.txt and C:\test2\test_dir\file.txt should
    both be entered into their respective dictionaries as \test_dir\file.txt.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你会为两个目录构建一个文件列表，所以有一个函数返回你需要的所有关于目录的信息是有意义的，这样你就可以每次重用它。你需要的是 *root*，即最低级别的目录（在命令行中输入的目录）以及相对于该根目录的所有文件列表，这样你可以轻松地比较两个目录。例如，*C*:\test\test_dir\file.txt
    和 C:\test2\test_dir\file.txt 都应该分别输入到它们各自的字典中作为 \test_dir\file.txt。
- en: Because *os.walk()* starts at the root of a directory by default, all you need
    to do is remember the first directory that it returns ![](three.jpg). You do that
    by setting *dir_root* to *None* before you enter the *for* loop. *None* is a special
    value in Python that means “not set” or “value unknown.” It’s what you use if
    you need to define a variable but don’t know its value yet. Inside the loop, if
    *dir_root* is *None*, you know it’s the first time through the loop and you have
    to set it. You’re setting a *dir_trim* variable too, so that later you can easily
    trim the first part of each directory that’s returned.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 *os.walk()* 默认从目录的根目录开始，你只需要记住它返回的第一个目录 ![三](three.jpg)。你通过在进入 *for* 循环之前将
    *dir_root* 设置为 *None* 来做到这一点。*None* 是Python中的一个特殊值，表示“未设置”或“值未知”。如果你需要定义一个变量但不知道它的值，你会使用它。在循环内部，如果
    *dir_root* 是 *None*，你知道这是第一次进入循环，你必须设置它。你还设置了一个 *dir_trim* 变量，这样你就可以在之后轻松地修剪每个返回的目录的前一部分。
- en: '![](f0089-01.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![f0089-01.jpg]'
- en: Once you have your directory root, you can chop off the common part of your
    directories and path separators from the front of the path returned by *os.walk()*
    ![](four.jpg). You do that by using string slices, which will return a subsection
    of a string. It works in exactly the same way as a list index, so it starts at
    0 and can go up to the length of the string.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了目录根，你可以从 *os.walk()* 返回的路径的前面切掉目录和路径分隔符的公共部分 ![四](four.jpg)。你通过使用字符串切片来完成这个操作，它将返回字符串的一个子串。它的工作方式与列表索引完全相同，因此它从0开始，可以到字符串的长度。
- en: When you’re done, you return both the directory listing and the root of the
    directory ![](five.jpg) using a special Python data type called a *tuple*. Tuples
    are similar to lists, except that they’re immutable—you can’t change them after
    they’ve been created.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成时，你需要返回目录列表和目录的根目录 ![五](five.jpg)，使用一种特殊的Python数据类型，称为 *元组*。元组与列表类似，但它们是不可变的——一旦创建后就不能更改。
- en: Now that you’ve checked your inputs and set up all of your program’s data, you
    can start making use of it. As in [chapter 2](kindle_split_010.html#ch02), when
    you simplified Hunt the Wumpus, the part of the program that does stuff is fairly
    short, clear, and easy to understand. All the tricky details have been hidden
    away inside functions, as you can see in the next listing.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经检查了输入并设置了程序的所有数据，你可以开始使用它们了。正如 [第2章](kindle_split_010.html#ch02) 中所描述的，当你简化“抓捕Wumpus”时，执行任务的程序部分相当短，清晰且易于理解。所有棘手细节都隐藏在函数内部，正如你在下一个列表中可以看到的那样。
- en: Listing 3.7\. Finding the differences between directories
  id: totrans-184
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.7\. 查找目录之间的差异
- en: '![](03list07_alt.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![03list07_alt.jpg]'
- en: To assign both of the variables you get back from your function, you separate
    them with a comma ![](one.jpg). You’ve already seen this when using *dictionary.items()*
    in a *for* loop.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要分配从你的函数返回的两个变量，你用逗号将它们分开 ![一](one.jpg)。你已经在使用 *dictionary.items()* 在 *for*
    循环中看到过这个。
- en: 'Here’s the first comparison ![](two.jpg): if the file isn’t in directory 1,
    then you warn the user. You can use *in* with a dictionary in the same way that
    you would for a list, and Python will return *True* if the object is in the dictionaries’
    keys.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一次比较 ![二](two.jpg)：如果文件不在目录1中，那么你警告用户。你可以像使用列表一样使用字典中的 *in*，Python会在对象是字典键时返回
    *True*。
- en: If the file exists in both directories, then you build a checksum for each file
    and compare them ![](three.jpg). If they’re different, then you know the files
    are different and you again warn the user. If the checksums are the same then
    you keep quiet, because you don’t want to overwhelm people with screens and screens
    of output—they want to know the differences.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件在两个目录中都存在，那么你将为每个文件构建校验和并比较它们 ![三](three.jpg)。如果它们不同，你知道文件是不同的，你再次警告用户。如果校验和相同，那么你保持安静，因为你不想用屏幕和屏幕的输出压倒人们——他们想知道差异。
- en: Once you’ve compared the files in section 3, you delete them from the dictionary.
    Any that are left over you know aren’t in directory 2 and you tell the user about
    them ![](four.jpg).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你比较了第3节中的文件，你就从字典中删除它们。任何剩下的你知道都不在目录2中，你告诉用户关于它们 ![四](four.jpg)。
- en: That seems to about do it for your program, but are you sure it’s working? Time
    to test it.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你的程序似乎已经完成了，但你确定它正在正常工作吗？是时候测试它了。
- en: '![](f0091-01.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![f0091-01.jpg]'
- en: Testing your program
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试你的程序
- en: If you haven’t already, now’s probably a good time to create some test directories
    so you can try your script and make sure it’s working. It’s especially important
    as you start working on problems that have real-world consequences. For example,
    if you’re backing up some family photos and your program doesn’t report that a
    file has changed (or doesn’t exist), you won’t know to back it up and might lose
    it if your hard drive crashes. Or it might report two files as the same when they’re
    actually different.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有创建测试目录，现在可能是创建一些测试目录的好时机，这样你可以尝试你的脚本并确保它正在工作。当你开始处理具有实际后果的问题时，这尤其重要。例如，如果你正在备份一些家庭照片，而你的程序没有报告文件已更改（或不存在），你将不知道要备份它，如果硬盘崩溃，你可能会丢失它。或者它可能报告两个文件是相同的，而实际上它们是不同的。
- en: You can test your script on directories that you already have, but specific
    test directories are a good idea, mainly because you can exercise all the features
    you’re expecting. At a minimum, I’d suggest
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在已有的目录上测试你的脚本，但特定的测试目录是个好主意，主要是因为你可以练习你期望的所有功能。至少，我建议
- en: Adding at least two directory levels, to make sure paths are handled properly
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少添加两个目录层级，以确保正确处理路径
- en: Creating a directory with at least one space in its name
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名称中至少包含一个空格的目录
- en: Using both text and binary files (for example, images)
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用文本和二进制文件（例如，图像）
- en: Setting up all the cases you’re expecting (files missing, file differences,
    files that are the same)
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置你期望的所有情况（文件缺失、文件差异、文件相同）
- en: By thinking about all the possible cases, you can catch bugs in your program
    before you run it over a real directory and miss something or, worse, lose important
    data. The following figure shows the initial test directory (called test) that
    I set up on my computer.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 通过考虑所有可能的情况，你可以在实际目录上运行程序之前捕捉到程序中的错误，避免遗漏某些内容，或者更糟糕的是，丢失重要数据。以下图显示了我在电脑上设置的初始测试目录（称为test）。
- en: Figure 3.2\. A test directory for the difference engine
  id: totrans-200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.2\. 差分引擎的测试目录
- en: '![](03fig02.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig02.jpg)'
- en: This test directory doesn’t get all the possible failures, but it does check
    for most of them. The next step was to copy that directory (I called it test2)
    and make some changes for the difference engine to work on, as shown in [figure
    3.3](#ch03fig03). I’ve used the numbers 1 to 4 within the files to represent each
    of the possible cases, with 1 and 4 being missing files, 2 for files that have
    some differences, and 3 for files that are identical in both directories.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试目录并没有涵盖所有可能的失败情况，但它确实检查了大多数情况。下一步是将该目录（我将其称为test2）复制，并对差分引擎进行一些修改，如图[图3.3](#ch03fig03)所示。我在文件中使用数字1到4来表示每种可能的情况，其中1和4是缺失的文件，2是有些差异的文件，3是两个目录中相同的文件。
- en: Figure 3.3\. test2, an almost identical copy of the first test directory
  id: totrans-203
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.3\. test2，第一个测试目录的几乎相同副本
- en: '![](03fig03_alt.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig03_alt.jpg)'
- en: 'You can see the output of running your script over these directories:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到运行脚本在这些目录上的输出：
- en: '[PRE8]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: That seems to be pretty much what you were expecting. The script is descending
    into the test 2 directory in each case and is picking up the differences between
    the files—1 and 4 are missing, 2 is different, and 3 isn’t reported because the
    files are identical.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎正是你所期望的。在每种情况下，脚本都在进入测试2目录，并正在获取文件之间的差异——1和4缺失，2不同，3没有报告，因为文件在两个目录中都是相同的。
- en: Now that you’ve tested out your script, let’s see what you can do to improve
    it.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经测试了你的脚本，让我们看看你可以做些什么来改进它。
- en: Improving your script
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 改进你的脚本
- en: Your script so far works, but it could do with a few improvements. For a start,
    the results it returns are out of order. The files that are missing from the second
    directory appear right at the end. Ideally, you’d have them appear next to the
    other entries for that directory, to make it easier to see what the differences
    are.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你目前的脚本已经可以工作，但还可以进行一些改进。首先，它返回的结果顺序不对。第二目录中缺失的文件出现在最后。理想情况下，你希望它们出现在该目录其他条目旁边，这样更容易看出差异。
- en: '|  |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-212
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Does this strategy look familiar? It’s exactly what you did when developing
    Hunt the Wumpus. You start by writing a program that’s as simple as you can make
    it and then build on the extra features that you need.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这种策略看起来熟悉吗？这正是你在开发Hunt the Wumpus时所做的。你首先编写尽可能简单的程序，然后在此基础上添加你需要的功能。
- en: '|  |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Putting results in order
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 按顺序排列结果
- en: 'It initially might be difficult to see how you might go about ordering the
    results, but if you think back to [chapter 2](kindle_split_010.html#ch02), one
    of the strategies that you used with Hunt the Wumpus was to separate the program
    from its interface. In your difference engine, you haven’t done so much of that
    so far—now might be a good time to start. You need two parts to your program:
    one part that does the work and stores the data it generates, and another to display
    that data. The following listing shows how you generate your results and store
    them.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时可能难以看到如何对结果进行排序，但如果你回想一下[第2章](kindle_split_010.html#ch02)，你使用Hunt the Wumpus时采用的一个策略是将程序与其界面分离。在你的差异引擎中，你还没有做很多这样的事情——现在可能是一个开始的好时机。你的程序需要两个部分：一个部分执行工作并存储它生成的数据，另一个部分用于显示这些数据。下面的列表显示了如何生成结果并存储它们。
- en: Listing 3.8\. Separating generated results from display
  id: totrans-217
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.8\. 将生成的结果与显示分离
- en: '![](03list08_alt.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](03list08_alt.jpg)'
- en: Here’s the trick. Rather than try to display the results as soon as you get
    them, which means you’re trying to shoehorn your program structure into your display
    structure, you store the results in a dictionary to display later ![](one.jpg).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这是个技巧。而不是一得到结果就尝试显示，这意味着你试图将你的程序结构塞入你的显示结构中，你将结果存储在字典中以供稍后显示！![one.jpg](one.jpg)。
- en: The result of each comparison is stored in *result* ![](two.jpg), with the file
    path as the key and a description of the result of the comparison as the value.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 每次比较的结果都存储在 *result* 中！![two.jpg](two.jpg)，文件路径作为键，比较结果的描述作为值。
- en: 'That should take care of storing the results; let’s take a look at how you
    display them:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 应该可以处理存储结果的问题；让我们看看你是如何显示它们的：
- en: '![](f0094-01_alt.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](f0094-01_alt.jpg)'
- en: '*sorted()* is a built-in Python function that sorts groups of items ![](one.jpg).
    You can give it lists, dictionary keys, values or items, strings, and all sorts
    of other things. In this case, you’re using it to sort *result.items()* by *file_path*,
    the first part of *result.items()*.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '*sorted()* 是一个内置的Python函数，用于对项目组进行排序！![one.jpg](one.jpg)。你可以给它列表、字典键、值或项、字符串以及各种其他东西。在这种情况下，你正在使用它来按*file_path*对*result.items()*进行排序，这是*result.items()*的第一部分。'
- en: Within the body of the loop, you’re using *in* to check the contents of the
    strings ![](two.jpg). You want to know whether this path is part of a directory,
    in which case it will have *os.path.sep* somewhere within it, and you also want
    to know whether the result shows that the files are the same.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环体中，你使用 *in* 来检查字符串的内容！![two.jpg](two.jpg)。你想要知道这个路径是否是目录的一部分，在这种情况下，它将在其中包含
    *os.path.sep*，你还想了解结果是否显示文件是相同的。
- en: '![](f0095-01.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](f0095-01.jpg)'
- en: Now that you’ve displayed everything within the root of the directory, you can
    go ahead and show everything within the subdirectories ![](three.jpg). You’re
    reversing the sense of the *if* statement to show everything that wasn’t shown
    the first time around.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经显示了目录根下的所有内容，你可以继续显示子目录中的所有内容！![three.jpg](three.jpg)。你正在反转*if*语句的感念，以显示第一次没有显示的内容。
- en: In hindsight, that was relatively easy. Following the pattern you established
    in Hunt the Wumpus, separating data from its display is a powerful tactic that
    can make complicated problems easy to understand and program.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 事后看来，这相对简单。遵循你在Hunt the Wumpus中建立的模式，将数据与其显示分离是一种强大的策略，可以使复杂的问题易于理解和编程。
- en: Comparing directories
  id: totrans-228
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 比较目录
- en: The other thing your program should probably handle is the case where you have
    empty directories. Currently it only looks for files, and any empty directories
    will be skipped. Although unnecessary for your initial use case (checking for
    missing images before you back up), it will almost certainly be useful somewhere
    down the track. Once you’ve added this feature, you’ll be able to spot any change
    in the directories, short of permission changes to the files—and it requires surprisingly
    little code. The next listing shows how I did it.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你的程序可能还需要处理的情况是空目录。目前它只查找文件，任何空目录都会被跳过。虽然对于你的初始用例（在备份之前检查缺失的图像）来说是不必要的，但它将来几乎肯定是有用的。一旦你添加了这个功能，你将能够发现目录中的任何变化，除了文件权限的变化——而且这需要出人意料地少的代码。下一个列表显示了我是如何做到这一点的。
- en: Listing 3.9\. Comparing directories, too
  id: totrans-230
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.9\. 比较目录
- en: '![](03list09_alt.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](03list09_alt.jpg)'
- en: The first thing to do is to include directory paths as well as files when generating
    a listing ![](three.jpg). To do that, you join the *dirs* and *files* lists with
    the *+* operator.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 第一件事是在生成列表时包括目录路径以及文件 ![列表](three.jpg)。要做到这一点，你需要使用 `+` 运算符将 `dirs` 和 `files`
    列表连接起来。
- en: '![](f0096-01.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![图片](f0096-01.jpg)'
- en: If you try to open a directory to read its contents, you’ll get an error ![](one.jpg);
    this is because directories don’t have contents the same way files do. To get
    around that, it’s ok to cheat a little bit. You alter the md5 function and use
    *os.path.isdir()* to find out whether it’s a directory. If it is, you return a
    dummy value of *'1'*. It doesn’t matter what the contents of a directory are,
    because the files will be checked in turn, and you only care whether a directory
    exists (or not).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试打开一个目录来读取其内容，你会得到一个错误 ![错误](one.jpg)；这是因为目录不像文件那样有内容。为了解决这个问题，稍微作弊一下是可以的。你修改了md5函数，并使用
    `os.path.isdir()` 来找出它是否是一个目录。如果是，你返回一个虚拟值 `'1'`。目录的内容并不重要，因为文件将依次检查，你只关心目录是否存在（或不存在）。
- en: Once you’ve made those changes, you’re done. Because the directories follow
    the same data structure as the files, you don’t need to make any changes to the
    comparison or display parts of your program. You’ll probably want to add some
    directories to both your test directories to make sure the program is working
    properly.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你做了这些更改，你就完成了。因为目录遵循与文件相同的数据结构，所以你不需要对你的程序的比较或显示部分做任何更改。你可能想要添加一些目录到你的测试目录中，以确保程序运行正常。
- en: You’ve improved your script, but that doesn’t mean there isn’t more you can
    do.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经改进了你的脚本，但这并不意味着你没有更多可以做的事情。
- en: Where to from here?
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接下来该做什么？
- en: 'The program as it stands now is feature-complete based on your initial need,
    but you can use the code you’ve written so far for other purposes. Here are some
    ideas:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的程序根据你的初始需求已经功能完善，但你也可以使用你迄今为止编写的代码来实现其他目的。以下是一些想法：
- en: If you’re sure you won’t have any different files, you can extend the program
    to create a merged directory from multiple sources. Given a number of directories,
    consolidate their contents into a third, separate location.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你确定不会有不同的文件，你可以扩展程序来创建一个来自多个来源的合并目录。给定多个目录，将它们的目录内容合并到第三个单独的位置。
- en: A related task would be to find all the identical copies of a file in a directory—you
    might have several old backups and want to know whether there are any sneaky extra
    files you’ve put in one of them.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个相关的任务是在目录中找到所有相同的文件副本——你可能有几个旧的备份，并想知道是否在其中一个中不小心添加了额外的文件。
- en: You could create a change monitor—a script that notifies you of changes in one
    directory. One script would look at a directory and store the results in a file.
    The second script would look at that file and directory and tell you if any of
    the output has changed. Your storage file doesn’t have to be complicated—a text
    file containing a path and checksum for each file should be all you need.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以创建一个变更监控器——一个脚本，它会通知你某个目录中的变更。一个脚本会检查一个目录并将结果存储在一个文件中。第二个脚本会查看那个文件和目录，并告诉你是否有任何输出已经改变。你的存储文件不需要很复杂——一个包含每个文件的路径和校验和的文本文件就足够了。
- en: You can also use your *os.walk* functions as a template to do something other
    than check file contents. A script to check directory sizes could be useful. Your
    operating system will probably give you information about how much space a particular
    directory takes up, but what if you want to graph usage over time, or break your
    results down by file type? A script is much more flexible, and you can make it
    do whatever you need.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你也可以将你的 `os.walk` 函数作为一个模板，来做一些除了检查文件内容之外的事情。一个检查目录大小的脚本可能很有用。你的操作系统可能会给你提供关于特定目录占用多少空间的信息，但如果你想要绘制随时间变化的用量图，或者按文件类型分解你的结果呢？一个脚本会更加灵活，你可以让它做你需要的一切。
- en: You’ll need to avoid the temptation of reinventing the wheel. If a tool has
    already been written that solves your problem, it’s generally better to use that,
    or at least include it in your script if possible. For example, you might consider
    writing a program that shows you the changes between different versions of files
    as well as whether they’re different—but that program’s already been written;
    it’s called *diff*. It’s widely available as a command-line program under Linux,
    but it’s also available for Windows and comes in graphical versions, too.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要避免重造轮子的诱惑。如果已经有工具可以解决你的问题，通常最好使用它，或者如果可能的话，至少将其包含在你的脚本中。例如，你可能考虑编写一个程序来显示不同版本文件之间的变化以及它们是否不同——但这样的程序已经存在；它被称为
    *diff*。它在Linux下广泛可用作为命令行程序，但Windows上也有可用，并且还有图形版本。
- en: One of the other programming tricks is knowing when to stop. Gold-plating your
    program can be fun, but you could always be working on your next project instead!
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个编程技巧是知道何时停止。过度优化你的程序可能很有趣，但你总是可以选择开始你的下一个项目！
- en: Summary
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about some of the standard library packages available
    with every installation of Python, as well as how to include and use them and
    how to learn about unfamiliar ones. You built what would normally be a fairly
    complex application, but, because you made good use of several Python libraries,
    the amount of code you had to write was minimal.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了一些与Python每个安装一起提供的标准库包，以及如何包含和使用它们以及如何了解不熟悉的包。你构建了一个通常相当复杂的应用程序，但由于你很好地使用了几个Python库，你不得不编写的代码量是最小的。
- en: In the next chapter, we’ll look at another way of organizing programs, as well
    as other uses for functions and some other Python techniques that can help you
    to write clearer, more concise code. The program in this chapter was fairly easy
    to test, but not all programs will be that straightforward, so we’ll also look
    at another way of testing programs to make sure they work.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨另一种组织程序的方法，以及函数的其他用途和一些其他可以帮助你编写更清晰、更简洁代码的Python技巧。本章的程序测试起来相当容易，但并非所有程序都会那么简单，因此我们还将探讨另一种测试程序的方法，以确保它们能够正常工作。
