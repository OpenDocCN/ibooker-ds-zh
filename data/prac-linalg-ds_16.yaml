- en: Chapter 16\. Python Tutorial
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第16章 Python教程
- en: As I explained in [Chapter 1](ch01.xhtml#Chapter_1), this chapter is a crash
    course on Python programming. It is designed to get you up to speed quickly to
    follow along with the code in the rest of the book, but it is not designed to
    be a complete source for Python mastery. If you’re looking for a dedicated Python
    book, then I recommend [*Learning Python*](https://oreil.ly/learning-python) by
    Mark Lutz (O’Reilly).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如我在[第1章](ch01.xhtml#Chapter_1)中所解释的，这一章节是关于Python编程的速成课程。它旨在让你迅速掌握基础知识，以便跟上本书其余部分的代码，但并不旨在成为Python掌握的完整来源。如果你正在寻找一本专门的Python书籍，我推荐[*Learning
    Python*](https://oreil.ly/learning-python)（由Mark Lutz（O’Reilly）著）。
- en: While working through this chapter, please have a Python session open. (I’ll
    explain how to do that later.) You are not going to learn Python just by *reading*
    the chapter; you need to read, type into Python, change and test the code, and
    so on.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章节时，请打开一个Python会话。（稍后我会解释如何操作。）你不仅仅通过*阅读*本章节来学习Python；你需要阅读、在Python中输入代码、修改和测试代码等等。
- en: Also, in this chapter you should manually key in all the code you see printed
    here. The code for all other chapters in this book is available online, but I
    want you to type in the code for this chapter manually. Once you are more familiar
    with Python coding, then manually typing in lots of code is a tedious waste of
    time. But when you are first learning to code, you need to *code*—that is, use
    your fingers to type in everything. Don’t just look at code on a page.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在本章中，你应该手动键入所有在此处打印的代码。本书的所有其他章节的代码都可以在网上找到，但我希望你手动输入本章的代码。一旦你更熟悉Python编码，手动输入大量代码会显得乏味且浪费时间。但当你初学编程时，你需要*编码*——也就是用手指键入所有内容。不要只是看页面上的代码。
- en: Why Python, and What Are the Alternatives?
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择Python，以及有哪些替代方案？
- en: Python is designed to be a general-purpose programming language. You can use
    Python to do text analysis, process web forms, create algorithms, and myriad other
    applications. Python is also widely used in data science and machine learning;
    for these applications, Python is basically just a calculator. Well, it’s an extremely
    powerful and versatile calculator, but we use Python because we (humans) are not
    quite smart enough to do all of the numerical calculations in our heads or with
    pen and paper.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Python被设计成一种通用编程语言。你可以使用Python进行文本分析、处理Web表单、创建算法以及无数其他应用。Python在数据科学和机器学习中也被广泛使用；对于这些应用程序，Python基本上只是一个计算器。嗯，它是一个非常强大和多功能的计算器，但我们（人类）还不够聪明，不能用头脑或纸和笔完成所有数值计算。
- en: Python is currently (in the year 2022) the most commonly used numerical processing
    program for data science (other contenders include R, MATLAB, Julia, JavaScript,
    SQL, and C). Will Python remain the dominant language for data science? I have
    no idea, but I doubt it. The history of computer science is ripe with “final languages”
    that purportedly would last forever. (Have you ever programmed in FORTRAN, COBOL,
    IDL, Pascal, etc?) But Python is very popular *now*, and you are learning applied
    linear algebra *now*. Anyway, the good news is that programming languages have
    strong transfer learning, which means that building Python proficiency will help
    you learn other languages. In other words, time spent learning Python is invested,
    not wasted.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Python目前（2022年）是数据科学中最常用的数值处理程序（其他竞争者包括R、MATLAB、Julia、JavaScript、SQL和C）。Python是否会继续保持数据科学的主导语言？我不知道，但我表示怀疑。计算机科学的历史充满了声称将永存的“最终语言”。（你有没有编写过FORTRAN、COBOL、IDL、Pascal等？）但Python目前非常流行，*现在*你正在学习应用线性代数。无论如何，好消息是编程语言具有强大的迁移学习能力，这意味着建立Python熟练度将有助于你学习其他语言。换句话说，学习Python的时间是投资，而不是浪费。
- en: IDEs (Interactive Development Environments)
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IDE（交互式开发环境）
- en: Python is the programming language, and you can run Python in many different
    applications, which are called *environments*. Different environments are created
    by different developers with different preferences and needs. Some common IDEs
    that you might encounter include Visual Studio, Spyder, PyCharm, and Eclipse.
    Perhaps the most commonly used IDE for learning Python is called Jupyter notebooks.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一种编程语言，你可以在许多不同的应用程序中运行Python，这些应用程序被称为*环境*。不同的环境由不同的开发者按照不同的偏好和需求创建。你可能会遇到的一些常见IDE包括Visual
    Studio、Spyder、PyCharm和Eclipse。也许最常用于学习Python的IDE称为Jupyter笔记本。
- en: I wrote the code for this book using Google’s Colab Jupyter environment (more
    on this in the next section). Once you gain familiarity with Python via Jupyter,
    you can spend some time trying out other IDEs to see if they better suit your
    needs and preferences. However, I recommend using Jupyter here, because it will
    help you follow along and reproduce the figures.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用Google的Colab Jupyter环境为本书编写了代码（下一节将详述）。一旦您熟悉了Jupyter，可以花些时间尝试其他IDE，看看它们是否更适合您的需求和偏好。然而，在这里我建议使用Jupyter，因为它将帮助您跟随并重现图表。
- en: Using Python Locally and Online
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地和在线使用Python
- en: 'Because Python is free and lightweight, it can be run on a variety of operating
    systems, either on your computer or in a cloud server:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Python是免费且轻量级的，可以在各种操作系统上运行，无论是在您的计算机上还是在云服务器上：
- en: Running Python locally
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地运行Python
- en: You can install Python on any major operating system (Windows, Mac, Linux).
    If you are comfortable with installing programs and packages, then you can install
    libraries as you need them. For this book, you will mostly need NumPy, matplotlib,
    SciPy, and sympy.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在任何主要操作系统上安装Python（Windows、Mac、Linux）。如果您习惯于安装程序和软件包，那么您可以根据需要安装库。对于本书，您主要需要NumPy、matplotlib、SciPy和sympy。
- en: But if you are reading this, then your Python skills are probably limited. In
    that case, I recommend installing Python via the [Anaconda software package](https://www.anaconda.com).
    It is free and easy to install, and Anaconda will automatically install all of
    the libraries you’ll need for this book.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果您正在阅读这篇文章，那么您的Python技能可能有限。在这种情况下，我建议通过[Anaconda软件包](https://www.anaconda.com)安装Python。它是免费且易于安装，Anaconda将自动安装您在本书中所需的所有库。
- en: Running Python online
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在线运行Python
- en: While going through this book, I recommend running Python on the web. Advantages
    of cloud-located Python include that you don’t need to install anything locally,
    you don’t need to use your own computing resources, and you can access your code
    from any browser on any computer and any operating system. I have grown to prefer
    Google’s Colaboratory environment because it syncs with my Google Drive. That
    allows me to keep my Python code files on my Google Drive and then open them from
    [*https://colab.research.google.com*](https://colab.research.google.com). There
    are several other cloud-based Python environments that you can use if you are
    avoiding Google services (although I’m not sure that’s even possible).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本书时，我建议在网络上运行Python。云端Python的优势在于您无需在本地安装任何内容，也无需使用自己的计算资源，您可以从任何浏览器、任何计算机和任何操作系统访问您的代码。我更喜欢使用Google的Colaboratory环境，因为它与我的Google
    Drive同步。这使我可以将Python代码文件保存在我的Google Drive上，然后从[*https://colab.research.google.com*](https://colab.research.google.com)打开它们。如果您希望避免使用Google服务，还有其他几个基于云的Python环境可供选择（尽管我不确定是否真的可能）。
- en: Google Colab is free to use. You’ll need a Google account to access it, but
    that’s also free. Then you can simply upload the code files to your Google Drive
    and open them in Colab.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Google Colab可免费使用。您需要一个Google账号来访问它，但这也是免费的。然后您可以简单地将代码文件上传到您的Google Drive，并在Colab中打开它们。
- en: Working with Code Files in Google Colab
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Google Colab中使用代码文件
- en: I will now explain how to download and access the Python notebook files for
    this book. As I wrote earlier, there are no code files for this chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我将解释如何下载和访问本书的Python笔记本文件。如我之前所述，本章节没有代码文件。
- en: 'There are two ways to get the book code onto your Google Drive:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以将书中的代码放到您的Google Drive上：
- en: Go to [*https://github.com/mikexcohen/LinAlg4DataScience*](https://github.com/mikexcohen/LinAlg4DataScience),
    click on the green button that says “Code,” and then click on “Download ZIP” ([Figure 16-1](#fig_16_1)).
    This will download the code repository, and you can then upload those files onto
    your Google Drive. Now, from your Google Drive, you can double-click on a file,
    or you can right-click and select “Open With” and then “Google Colaboratory.”
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前往[*https://github.com/mikexcohen/LinAlg4DataScience*](https://github.com/mikexcohen/LinAlg4DataScience)，点击上面标有“Code”的绿色按钮，然后点击“Download
    ZIP”（见[图 16-1](#fig_16_1)）。这将下载代码仓库，然后您可以将这些文件上传到您的Google Drive上。现在，从您的Google
    Drive上，您可以双击文件，或者右键点击并选择“使用Google Colaboratory”进行打开。
- en: Go directly to [*https://colab.research.google.com*](https://colab.research.google.com),
    select the “GitHub” tab, and search for “mikexcohen” in the search bar. You’ll
    find all of my public GitHub repositories; you want the one called “LinAlg4DataScience.”
    From there, you can click on one of the files to open the notebook.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接转到[*https://colab.research.google.com*](https://colab.research.google.com)，选择“GitHub”选项卡，并在搜索栏中搜索“mikexcohen”。您将找到我所有的公共GitHub存储库；您需要选择名为“LinAlg4DataScience”的那一个。从那里，您可以点击其中一个文件来打开笔记本。
- en: Note that this is a read-only copy of this notebook; any changes you make will
    not be saved. Therefore, I recommend copying that file into your Google Drive.
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，这是此笔记本的只读副本；您所做的任何更改都不会被保存。因此，建议将该文件复制到您的Google Drive中。
- en: '![GithubColab.](assets/plad_1601.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![GithubColab.](assets/plad_1601.png)'
- en: Figure 16-1\. Getting the code from GitHub (left) into Colab (right)
  id: totrans-25
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图16-1\. 从GitHub（左）获取代码到Colab（右）
- en: Now that you know how to import the book’s code files into Google Colab, it’s
    time to start with a fresh notebook to begin working on this chapter. Click on
    the menu option “File” and then “New Notebook” to create a new notebook. It will
    be called “Untitled1.ipynb” or something similar. (The extension *ipynb* stands
    for “interactive Python notebook.”) I recommend changing the name of the file
    by clicking on the filename at the top-left of the screen. By default, new files
    are placed in your Google Drive in the “Colab Notebooks” folder.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经知道如何将书中的代码文件导入Google Colab，是时候开始使用一个全新的笔记本来开始本章的工作了。点击菜单选项“文件”，然后选择“新笔记本”以创建一个新的笔记本。它将被称为“Untitled1.ipynb”或类似的名称。（扩展名*ipynb*代表“交互式Python笔记本”。）建议通过点击屏幕左上角的文件名来更改文件名。默认情况下，新文件会被放置在您的Google
    Drive的“Colab Notebooks”文件夹中。
- en: Variables
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量
- en: 'You can use Python as a calculator. Let’s try it; type the following into a
    code cell:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将Python用作计算器。让我们试试；在代码单元格中键入以下内容：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Nothing happens when you type that code into a cell. You need to tell Python
    to run that code. You do that by pressing Ctrl-Enter (Command-Enter on a Mac)
    on your keyboard while that cell is *active* (a code cell is active if you see
    the cursor blinking inside the cell). There are also menu options for running
    the code in a cell, but coding is easier and faster when using keyboard shortcuts.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 输入该代码单元格时，什么都不会发生。您需要告诉Python运行该代码。在单元格处*激活*（如果在单元格内看到光标闪烁，则表示代码单元格处于活动状态），通过按下键盘上的Ctrl-Enter（Mac上为Command-Enter）来执行此操作。还有用于在单元格中运行代码的菜单选项，但是使用键盘快捷键编码更容易和更快。
- en: 'Take a moment to explore the arithmetic. You can use different numbers, parentheses
    for grouping, and different operations like `-`, `/`, and `*`. Also notice that
    the spacing does not affect the result: `2*3` is the same thing as `2 * 3`. (Spacing
    is important for other aspects of Python coding; we’ll get to that later.)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 请花点时间来探索算术运算。您可以使用不同的数字、括号进行分组以及像`-`、`/`和`*`等不同的操作。还要注意，间距不会影响结果：`2*3`与`2 *
    3`是相同的。（对于Python编码的其他方面，间距很重要；我们稍后会详细介绍。）
- en: Working with individual numbers is not scalable for applications. That’s why
    we have *variables*. A variable is a name that refers to data stored in memory.
    It’s analogous to how languages use words to refer to objects in the real world.
    For example, my name is Mike, but I am not *Mike*; I am a human being composed
    of trillions of cells that somehow are capable of walking, talking, eating, dreaming,
    telling bad jokes, and myriad other things. But that’s way too complicated to
    explain, so for convenience people call me “Mike X Cohen.” So, a variable in Python
    is simply a convenient reference to stored data such as a number, an image, a
    database, etc.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于处理单个数字来说，这种方法并不适用于应用程序。这就是为什么我们需要*变量*。变量是指向存储在内存中的数据的名称。这类似于语言如何使用单词来指代现实世界中的对象。例如，我的名字是Mike，但我不是*Mike*；我是由数以万亿计的细胞组成的人类，这些细胞以某种方式能够行走、说话、进食、做梦、讲冷笑话以及做其他无数的事情。但这太复杂了，无法解释，因此为了方便，人们称我为“Mike
    X Cohen”。因此，在Python中，变量只是对存储的数据（如数字、图像、数据库等）的便捷引用。
- en: 'We create variables in Python by assigning a value to them. Type in the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过为变量分配一个值来在Python中创建变量。键入以下内容：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Running that cell will create the variables. Now you can start to use them!
    For example, in a new cell, run the following code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 运行该单元格将创建变量。现在您可以开始使用它们了！例如，在新单元格中运行以下代码：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Outputs
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输出
- en: The `>>` you see in code blocks is the result of running the code cell. The
    text thereafter is what you see on your screen when you evaluate the code in a
    cell.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码块中看到的`>>`是运行代码单元格的结果。之后的文本是在评估单元格中的代码时在屏幕上看到的内容。
- en: 'Now try this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试这个：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Ahh, you just got your first Python error! Welcome to the club :) Don’t worry,
    coding errors are extremely common. In fact, *the difference between a good coder
    and a bad coder is that good coders learn from their mistakes whereas bad coders
    think that good coders never make mistakes*.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 啊，你刚刚遇到了你的第一个Python错误！欢迎加入俱乐部 :) 别担心，编码错误非常常见。实际上，*优秀程序员和糟糕程序员的区别在于，优秀程序员从错误中学习，而糟糕程序员认为优秀程序员从不犯错*。
- en: 'Errors in Python can be difficult to make sense of. Below is the error message
    on my screen:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的错误可能很难理解。以下是我屏幕上的错误消息：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Python indicates the offending line with an arrow. The error message, which
    will hopefully help us understand what went wrong and how to fix it, is printed
    at the bottom. In this case, the error message is a `TypeError`. What does that
    mean, and what are “types”?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Python用箭头指示错误行。希望这个错误消息能帮助我们理解出了什么问题以及如何解决它，错误消息会打印在底部。在这种情况下，错误消息是`TypeError`。那是什么意思，以及什么是“类型”？
- en: Data Types
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据类型
- en: It turns out that variables have *types* that describe the kind of data those
    variables store. Having different types makes computing more efficient, because
    operations work differently on different kinds of data.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明变量有*类型*，描述变量存储的数据种类。不同的类型使得计算更高效，因为操作在不同类型的数据上表现不同。
- en: 'There are many data types in Python. I will introduce four here, and you’ll
    learn more data types as you progress through the book:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Python中有许多数据类型。我将在这里介绍四种，并在你通过本书时学习更多数据类型：
- en: Integers
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 整数
- en: These are called `int` and are whole numbers, like −3, 0, 10, and 1,234.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这些被称为`int`，是整数，如−3、0、10和1,234。
- en: Floating-point numbers
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数
- en: These are called `float`, but that’s just a fancy term for a number with a decimal
    point, like −3.1, 0.12345, and 12.34\. Be mindful that `floats` and `ints` may
    look the same to us humans, but they are treated differently by Python functions.
    For example, 3 is an `int`, whereas 3.0 is a `float`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这些被称为`float`，但这只是一个带有小数点的数字的术语，如−3.1、0.12345和12.34。请注意，`floats`和`ints`在视觉上可能相同，但它们在Python函数中的处理方式是不同的。例如，3是一个`int`，而3.0是一个`float`。
- en: Strings
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: These are called `str` and are text. Here, too, be mindful of the distinction
    between `*5*` (a string corresponding to the *character* 5) and `5` (an `int`
    corresponding to the *number* 5).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这些被称为`str`，是文本。在这里，也要注意`*5*`（对应于字符5的字符串）和`5`（对应于数字5的`int`）之间的区别。
- en: Lists
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 列表
- en: A list is a collection of items, each of which can have a different data type.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是一组项目的集合，每个项目可以有不同的数据类型。
- en: 'Lists are quite handy, and are ubiquitous in Python programming. The following
    code illustrates three important features of lists: (1) they are indicated using
    square brackets [ ], (2) commas separate list items, and (3) individual list items
    can have different data types:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 列表在Python编程中非常方便且无处不在。以下代码展示了列表的三个重要特征：(1) 用方括号[ ]表示，(2) 逗号分隔列表项，(3) 单个列表项可以有不同的数据类型：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The second list shows that lists may contain other lists. In other words, the
    third element of `list2` is itself a list.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个列表显示列表可能包含其他列表。换句话说，`list2`的第三个元素本身就是一个列表。
- en: What if you want to access only the second element of `list2`? Individual list
    elements are extracted using *indexing*, which I will teach you about in the next
    section.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想访问`list2`的第二个元素怎么办？可以使用*索引*提取单独的列表元素，下一节我将教你如何操作。
- en: 'You can determine the data type using the function `type`. For example, evaluate
    the following in a new cell:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用函数`type`来确定数据类型。例如，在一个新的单元格中评估以下内容：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Hey, wait, what is a “function”? You can look forward to learning about using
    and creating functions in the next-next section; first I want to return to the
    topic of indexing.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿，等等，什么是“函数”？你可以期待在下下节中学习如何使用和创建函数；首先我想回到索引的话题。
- en: What to Call My Variables?
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我的变量应该叫什么？
- en: There are a few hard rules about naming variables. Variable names cannot start
    with numbers (though they may contain numbers), nor can they include spaces or
    nonalphanumeric characters like !@#$%^&*(). Underscores _ are allowed.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 变量命名有一些严格的规则。变量名不能以数字开头（尽管可以包含数字），也不能包含空格或类似!@#$%^&*()的非字母数字字符。下划线_是允许的。
- en: There are also guidelines for naming variables. The most important guideline
    is to make variable names meaningful and interpretable. For example, `rawDataMatrix`
    is a much better variable name than `q`. You might end up creating dozens of variables
    in your code, and you want to be able to infer the data referenced by a variable
    from the variable name.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 变量命名也有一些指导方针。最重要的指导方针是使变量名有意义且可解释。例如，`rawDataMatrix`比`q`要好得多作为变量名。在代码中可能会创建数十个变量，你希望能够从变量名推断出变量所引用的数据。
- en: Indexing
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 索引
- en: '*Indexing* means accessing a specific element in a list (and related data types,
    including vectors and matrices). Here’s how you extract the second element of
    a list:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*索引*意味着访问列表（以及相关数据类型，包括向量和矩阵）中的特定元素。这是如何提取列表的第二个元素：'
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice that indexing is done using square brackets after the variable name,
    and then the number you want to index.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，索引是在变量名后面使用方括号进行的，然后是你想要索引的数字。
- en: But wait a minute—I wrote that we want the *second* element; why does the code
    access element `1`? That’s not a typo! Python is a 0-based indexing language,
    which means that index `0` is the first element (in this case, the number 19),
    index `1` is the second element, and so on.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 但等一下 —— 我写道我们想要*第二个*元素；为什么代码访问元素`1`呢？这不是打字错误！Python是一种从0开始索引的语言，这意味着索引`0`是第一个元素（在本例中是数字19），索引`1`是第二个元素，依此类推。
- en: If you are new to 0-based coding languages, then this will seem weird and confusing.
    I completely sympathize. I wish I could write that it will become second nature
    after some practice, but the truth is that 0-based indexing will always be a source
    of confusion and errors. It’s just something you have to be mindful of.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对从0开始的编程语言感到陌生，那么这似乎很奇怪和令人困惑。我完全理解。我希望能说练习一段时间后就能变得很熟练，但事实是从0开始的索引总是会引起困惑和错误。这只是你必须注意的一点。
- en: How do you access the number 4 in `aList`? You could index it directly as `aList[2]`.
    But Python indexing has a neat feature whereby you can index list elements *backward*.
    To access the last element of a list, you type `aList[-1]`. You can think of `-1`
    as wrapping around to the end of the list. Likewise, the penultimate list element
    is `aList[-2]`, and so on.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如何访问`aList`中的数字4？你可以直接索引为`aList[2]`。但是Python的索引具有一个巧妙的特性，你可以*反向*索引列表元素。要访问列表的最后一个元素，你可以输入`aList[-1]`。你可以将`-1`视为环绕到列表末尾。同样，倒数第二个列表元素是`aList[-2]`，依此类推。
- en: Functions
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: A *function* is a collection of code that you can run without having to type
    in all the individual pieces of code over and over again. Some functions are short
    and comprise only a few lines of code, while others have hundreds or thousands
    of lines of code.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数*是一个可以多次运行而无需重复键入所有单独代码片段的代码集合。有些函数很短，只包含几行代码，而其他函数可能有数百或数千行代码。'
- en: 'Functions are indicated in Python using parentheses immediately after the function
    name. Here are a few common functions:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中使用括号紧跟在函数名后面表示函数。以下是一些常见的函数：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Functions may take inputs and may provide outputs. The general anatomy of a
    Python function looks like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以接受输入并可能提供输出。Python函数的一般结构如下：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Going back to the previous functions:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 回到以前的函数：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`print()` is a very useful function. Python only prints output of the final
    line in a cell, and only when that line does not involve a variable assignment.
    For example, write the following code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`print()`是一个非常有用的函数。Python仅打印单元格中最后一行的输出，而且只有当该行不涉及变量赋值时才会这样做。例如，写下以下代码：'
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There are four lines of code, so you might have expected Python to give four
    outputs. But only one output is given, corresponding to the `print()` function.
    The first two lines do not print their output because they are not the final line,
    while the final line does not print its output because it is a variable assignment.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有四行代码，所以你可能期望Python给出四个输出。但只给出一个输出，对应于`print()`函数。前两行不打印其输出，因为它们不是最终行，而最后一行不打印其输出，因为它是变量赋值。
- en: Methods as Functions
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法作为函数
- en: A *method* is a function that is called directly on a variable. Different data
    types have different methods, meaning that a method that works on lists may not
    work on strings.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*方法*是直接在变量上调用的函数。不同的数据类型有不同的方法，这意味着适用于列表的方法可能不适用于字符串。'
- en: 'The list data type, for example, has a method called `append` that adds an
    extra element to an existing list. Here’s an example:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，列表数据类型有一个称为`append`的方法，可以向现有列表添加额外的元素。这里有一个例子：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Note the syntax formatting: methods are similar to functions in that they have
    parentheses and (for some methods) input arguments. But methods are attached to
    the variable name with a period, and can directly change the variable without
    an explicit output.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意语法格式：方法与函数类似，都有括号和（对于某些方法）输入参数。但是方法与变量名用句点连接，并且可以直接修改变量而无需显式输出。
- en: 'Take a moment to change the code to use a different data type—for example,
    a string instead of a list. Rerunning the code will generate the following error
    message:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 请稍等片刻，更改代码以使用不同的数据类型——例如，使用字符串而不是列表。重新运行代码将生成以下错误消息：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This error message means that the string data type does recognize the `append`
    function (an *attribute* is a property of a variable; a method is one such attribute).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此错误消息意味着字符串数据类型不识别`append`函数（*属性*是变量的属性；方法是其中一种属性）。
- en: Methods are a core part of object-oriented programming and classes. These are
    aspects of Python that would be covered in a dedicated Python book, but don’t
    worry—you don’t need a full understanding of object-oriented programming to learn
    linear algebra with this book.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 方法是面向对象编程和类的核心部分。这些是Python的方面，应在专门的Python书籍中讨论，但不用担心——你不需要完全理解面向对象编程就能学习本书的线性代数部分。
- en: Writing Your Own Functions
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写自定义函数
- en: There are *many* functions available in Python. Too many to count. But there
    will never be that perfect function that does exactly what you need. So you will
    end up writing your own functions.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中有*许多*可用的函数。太多了，数不胜数。但永远不会有完美的函数能够完全满足你的需求。因此，你最终会编写自己的函数。
- en: Creating your own functions is easy and convenient; you use the built-in keyword
    `def` to define the function (a *keyword* is a reserved name that cannot be redefined
    as a variable or function), then state the function name and any possible inputs,
    and end the line with a colon. Any lines thereafter are included in the function
    *if they are indented with two spaces*.^([1](ch16.xhtml#idm45733289514672)) Python
    is *very* particular about spacing at the beginning of the line (but not particular
    about spacing elsewhere in the line). Any outputs are indicated by the `return`
    keyword.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自己的函数既简单又方便；您使用内置关键字`def`定义函数（*关键字*是保留名称，不能重新定义为变量或函数），然后指定函数名和可能的输入，并以冒号结束该行。之后的任何行，如果缩进两个空格，则包括在函数中。^([1](ch16.xhtml#idm45733289514672))
    Python 对行首的空格要求非常严格（但对行内其他地方的空格则不那么严格）。任何输出都由`return`关键字指示。
- en: 'Let’s start with a simple example:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的例子开始：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This function takes two inputs and computes, prints, and outputs their sum.
    Now it’s time to call the function:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受两个输入并计算、打印和输出它们的总和。现在是调用函数的时候了：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Why did the number `9` appear twice? It was printed once because the `print()`
    function was called inside the function, and then it was printed a second time
    when I called `print(s)` after the function. To confirm this, try changing the
    line after calling the function to `print(s+1)`. (Modifying code to see the effect
    on the output is a great way to learn Python; just make sure to undo your changes.)
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么数字`9`会出现两次？它被打印一次是因为在函数内部调用了`print()`函数，然后当我在函数后调用`print(s)`时，它第二次被打印出来了。要确认这一点，请尝试更改调用函数后的行为`print(s+1)`。
    （修改代码以查看输出效果是学习Python的好方法；只需确保撤销您的更改。）
- en: Notice that the variable name assigned to be the output inside the function
    (`total`) can be different from the variable name I used when calling the function
    (`s`).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在函数内部分配给输出的变量名（`total`）可以与我调用函数时使用的变量名（`s`）不同。
- en: Writing custom functions allows for a lot of flexibility—for example, setting
    optional inputs and default parameters, checking inputs for data type and consistency,
    and so on. But a basic understanding of functions will suffice for this book.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 编写自定义函数允许灵活性很高——例如，设置可选输入和默认参数，检查数据类型和一致性等。但是对函数的基本理解对本书已经足够。
- en: Libraries
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 库
- en: Python is designed to be easy and fast to install and run. But the downside
    is that the basic install of Python comes with a small number of built-in functions.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Python 设计为安装和运行都简单快速。但缺点是Python的基本安装只带有少量内置函数。
- en: Developers therefore create collections of functions focused on a specific topic,
    which are called *libraries*. Once you import a library into Python, you can access
    all the functions, variable types, and methods that are available in that library.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，开发人员创建了专注于特定主题的函数集合，称为*库*。一旦将库导入Python，你就可以访问该库中所有可用的函数、变量类型和方法。
- en: According to a Google search, there are over 130,000 libraries for Python. Don’t
    worry, you won’t need to memorize all of them! In this book, we will use only
    a few libraries that are designed for numerical processing and data visualization.
    The most important library for linear algebra is called *NumPy*, which is a pormanteau
    of “numerical Python.”
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Google搜索，Python有超过130,000个库。别担心，你不需要记住它们所有！在本书中，我们将只使用一些专门用于数值处理和数据可视化的库。线性代数最重要的库称为*NumPy*，这是“numerical
    Python”的合成词。
- en: Python libraries are separate from the basic Python installation, which means
    you need to download them from the web and then import them into Python. That
    makes them available to use inside Python. You need to download them only once,
    but you need to reimport them into Python in each Python session.^([2](ch16.xhtml#idm45733289405568))
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Python库与基本的Python安装分开，这意味着你需要从网上下载它们，然后导入到Python中。这使得它们可以在Python内部使用。你只需要下载它们一次，但在每个Python会话中都需要重新导入它们。^([2](ch16.xhtml#idm45733289405568))
- en: NumPy
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NumPy
- en: 'To import the NumPy library into Python, type:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要将NumPy库导入Python，输入：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Notice the general formulation of importing libraries: `import libraryname
    as abbreviation`. The abbreviation is a convenient shortcut. To access functions
    in a library, you write the abbreviated name of the library, a period, and the
    name of the function. For example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意导入库的一般公式：`import libraryname as abbreviation`。缩写是一个便捷的快捷方式。要访问库中的函数，你写下库的缩写名称、一个点，和函数的名称。例如：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The third line of code shows that libraries can have sublibraries, or *modules*,
    nested inside them. In this case, NumPy has many functions, and then there is
    a library inside NumPy called `linalg`, which contains many more functions specifically
    related to linear algebra.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的第三行显示，库可以有子库，或者*模块*，嵌套在其中。在这种情况下，NumPy有许多函数，然后在NumPy内部有一个名为`linalg`的库，其中包含更多特别与线性代数相关的函数。
- en: 'NumPy has its own data type called a *NumPy array*. NumPy arrays initially
    seem similar to lists in that they both store collections of information. But
    NumPy arrays store only numbers and have attributes that are useful for mathematical
    coding. The following code shows how to create a NumPy array:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy有自己的数据类型称为*NumPy数组*。NumPy数组最初看起来类似于列表，因为它们都存储信息的集合。但NumPy数组只存储数字，并且具有对数学编码有用的属性。以下代码显示如何创建一个NumPy数组：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Indexing and Slicing in NumPy
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NumPy中的索引和切片
- en: 'I’d like to return to the discussion of accessing a single element within a
    variable. You can access one element of a NumPy array using indexing, exactly
    the same as how you index a list. In the following code block, I’m using the function
    `np.arange` to create an array of integers from −4 to `4\. That’s not a typo in
    the code—the second input is +5`, but the returned values end at 4\. Python often
    uses *exclusive* upper bounds, meaning that Python counts up to—but *not* including—the
    final number you specify:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我想回到讨论如何访问变量内的单个元素。你可以使用索引来访问NumPy数组的一个元素，方法与索引列表完全相同。在以下代码块中，我使用`np.arange`函数创建了一个整数数组从-4到`4。在代码中没有错误，第二个输入是+5`，但返回的值结束于4。Python通常使用*排除*上界，这意味着Python计数直到但*不包括*你指定的最后一个数字：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: That’s all well and good, but what if you want to access, for example, the first
    three elements? Or every second element? It’s time to proceed from *indexing*
    to *slicing*.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都很好，但如果你想访问前三个元素呢？或者每隔一个元素呢？现在是从*索引*进入*切片*的时候了。
- en: 'Slicing is simple: specify the start and end indices with a colon in between.
    Just remember that Python ranges have exclusive upper bounds. Thus, to get the
    first three elements of our array, we slice up to index 3 + 1 = 4, but then we
    need to account for the 0-based indexing, which means the first three elements
    have indices 0, 1, and 2, and we slice them using `0:3`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 切片很简单：用冒号指定起始和结束索引。只需记住Python的范围有排除上界。因此，要获取数组的前三个元素，我们切片到索引3 + 1 = 4，但我们需要考虑基于0的索引，这意味着前三个元素的索引是0、1和2，我们使用`0:3`来切片：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You can index every second element using the skip operator:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用跳过操作符索引每个第二个元素：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The formulation of indexing with skipping is `[start:stop:skip]`. You can run
    through the entire array backward by skipping by −1, like this: `ary[::-1]`.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 索引与跳过的形式是`[start:stop:skip]`。你可以通过跳过-1来反向运行整个数组，就像这样：`ary[::-1]`。
- en: I know, it’s a bit confusing. I promise it will get easier with practice.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道，有点令人困惑。我保证通过实践，这将变得更容易。
- en: Visualization
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可视化
- en: Many concepts in linear algebra—and most other areas of mathematics—are best
    understood by seeing them on your computer screen.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 线性代数中的许多概念——以及数学的大多数其他领域——最好通过计算机屏幕来理解。
- en: Most data visualization in Python is handled by the matplotlib library. Some
    aspects of graphical displays are IDE dependent. However, all the code in this
    book works as-is in any Jupyter environment (via Google Colab, another cloud server,
    or a local installation). If you use a different IDE, then you might need to make
    a few minor adjustments.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的大多数数据可视化由matplotlib库处理。图形显示的某些方面取决于IDE。然而，本书中的所有代码在任何Jupyter环境下（通过Google
    Colab、另一个云服务器或本地安装）都可以直接使用。如果你使用不同的IDE，可能需要进行一些微调。
- en: Typing `matplotlib.pyplot` gets really tedious, and so it’s common to abbreviate
    this library as `plt`. You can see that in the next code block.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 打`matplotlib.pyplot`真的很繁琐，所以通常将这个库缩写为`plt`。你可以在下一个代码块中看到这一点。
- en: 'Let’s begin with plotting dots and lines. See if you can understand how the
    following code maps onto [Figure 16-2](#fig_16_2):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从绘制点和线开始。看看你能否理解以下代码如何映射到[图16-2](#fig_16_2)：
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '![visdat1.](assets/plad_1602.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![visdat1.](assets/plad_1602.png)'
- en: Figure 16-2\. Visualizing data, part 1
  id: totrans-133
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图16-2\. 数据可视化，第1部分
- en: 'Did you manage to decode the code? Code line #1 says to plot a black circle
    (`ko`—the `k` is for black and the `o` is for circle) at XY location `1,2`. Code
    line #2 provides lists of numbers instead of individual numbers. This specifies
    a line that starts at XY coordinate (0, 0) and ends at coordinate (2, 4). The
    `r--` specifies a red dashed line. Code lines #3 and #4 set the *x*-axis and *y*-axis
    limits, and, of course, line #5 creates a title.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你成功解码了这段代码吗？代码行＃1表示在XY位置`1,2`处绘制一个黑色圆圈（`ko`中的`k`是黑色，`o`是圆圈）。代码行＃2提供的是数字列表而不是单个数字。这指定了一条从XY坐标（0,
    0）开始并以坐标（2, 4）结束的线条。`r--`表示红色虚线。代码行＃3和＃4设置了*x*轴和*y*轴的限制，当然，线＃5创建了一个标题。
- en: 'Before moving forward, take a moment to explore this code. Draw some additional
    dots and lines, try different markers (hint: explore the letters `o`, `s`, and
    `p`) and different colors (try `r`, `k`, `b`, `y`, `g`, and `m`).'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，花点时间探索这段代码。画一些额外的点和线，尝试不同的标记（提示：探索字母`o`、`s`和`p`）和不同的颜色（尝试`r`、`k`、`b`、`y`、`g`和`m`）。
- en: 'The next code block introduces subplots and images. A *subplot* is a way of
    dividing the graphics area (called the *figure*) into a grid of separate axes
    into which you can draw different visualizations. As with the previous code block,
    see if you can understand how this code produces [Figure 16-3](#fig_16_3) before
    reading my description:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个代码块介绍了子图和图像。*子图*是将图形区域（称为*图*）分割成一个网格，可以在其中绘制不同的可视化方式。与前一个代码块类似，请在阅读我的描述之前看看你能否理解这段代码是如何生成[图16-3](#fig_16_3)的：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![visdat2.](assets/plad_1603.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![visdat2.](assets/plad_1603.png)'
- en: Figure 16-3\. Visualizing data, part 2
  id: totrans-139
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图16-3\. 数据可视化，第2部分
- en: 'Code line #1 creates the subplots. The first two inputs into the `plt.subplots`
    function specify the grid geometry—in this case, a <math alttext="1 times 2"><mrow><mn>1</mn>
    <mo>×</mo> <mn>2</mn></mrow></math> matrix of subplots, which means one row and
    two columns, which means two plots next to each other. The first input specifies
    the total size of the figure, with the two elements in that tuple corresponding
    to width and then height in inches. (The sizes are always listed as width,height.
    A mnemonic for remembering the order is WH for “White House.”) The `plt.subplots`
    function provides two outputs. The first is a handle to the entire figure, which
    we don’t need, so I used an underscore in lieu of a variable name. The second
    output is a NumPy array that contains handles to each axis. A *handle* is a special
    type of variable that points to an object in the figure.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 'Code line #1 创建子图。`plt.subplots` 函数的前两个输入指定了网格的几何结构——在这种情况下，是一个<math alttext="1
    times 2"><mrow><mn>1</mn> <mo>×</mo> <mn>2</mn></mrow></math>子图矩阵，意味着一行两列，也就是两个并排的图。第一个输入指定了图的总尺寸，元组中的两个元素分别对应宽度和高度（尺寸总是以宽度、高度列出，记忆顺序的助记法是
    WH，代表“白宫”）。`plt.subplots` 函数提供了两个输出。第一个是整个图形的句柄，我们不需要，所以使用下划线代替变量名。第二个输出是一个包含每个轴句柄的
    NumPy 数组。*句柄* 是指向图中对象的特殊类型变量。'
- en: 'Now for code line #2\. This should look familiar to the previous code block;
    the two new concepts are plotting to the specific axis instead of the entire figure
    (using `plt.`) and inputting a matrix instead of individual numbers. Python creates
    a separate line for each column of the matrix, which is why you see five lines
    in [Figure 16-3](#fig_16_3).'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '现在来看代码行 #2。这应该看起来很熟悉，与前一个代码块相似；两个新概念是绘制到特定轴而不是整个图形（使用 `plt.`）以及输入矩阵而不是单个数字。Python
    为矩阵的每一列创建一个单独的线条，这就是为什么在 [图 16-3](#fig_16_3) 中看到五条线的原因。'
- en: 'Finally, code line #3 shows how to create an image. Matrices are often visualized
    as images, as you learned in [Chapter 5](ch05.xhtml#Chapter_5). The color of each
    little block in the image is mapped onto a numerical value in the matrix.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，代码行 #3 显示了如何创建图像。矩阵经常被视为图像，正如你在 [第 5 章](ch05.xhtml#Chapter_5) 中学到的那样。图像中每个小块的颜色映射到矩阵中的一个数值。'
- en: Well, there’s *a lot* more that could be said about creating graphics in Python.
    But I hope this introduction is enough to get you started.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，关于在 Python 中创建图形，还有*很多*可以说的。但我希望这个介绍足以让你入门。
- en: Translating Formulas to Code
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将公式翻译成代码
- en: Translating mathematical equations into Python code is sometimes straightforward
    and sometimes difficult. But it is an important skill, and you will improve with
    practice. Let’s start with a simple example in [Equation 16-1](#equation1601).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 将数学方程转换为 Python 代码有时简单，有时困难。但这是一项重要的技能，通过练习你会有所进步。让我们从简单的例子开始，如 [方程式 16-1](#equation1601)。
- en: Equation 16-1\. An equation
  id: totrans-146
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 方程式 16-1\. 一个方程
- en: <math alttext="y equals x squared" display="block"><mrow><mi>y</mi> <mo>=</mo>
    <msup><mi>x</mi> <mn>2</mn></msup></mrow></math>
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="y equals x squared" display="block"><mrow><mi>y</mi> <mo>=</mo>
    <msup><mi>x</mi> <mn>2</mn></msup></mrow></math>
- en: 'You might think that the following code would work:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为以下代码会起作用：
- en: '[PRE24]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'But you’d get an error message (`NameError: name *x* is not defined`). The
    problem is that we are trying to use a variable `x` before defining it. So how
    do we define `x`? In fact, when you look at the mathematical equation, you defined
    *x* without really thinking about it: *x* goes from negative infinity to positive
    infinity. But you don’t draw the function out that far—you would probably choose
    a limited range to draw that function, perhaps −4 to +4\. That range is what we
    to specify in Python:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '但你会收到一个错误消息 (`NameError: name *x* is not defined`)。问题在于我们在定义变量 `x` 之前尝试使用它。那么如何定义
    `x` 呢？实际上，当你看数学方程时，你定义了 *x* 而并没有真正考虑它：*x* 的范围从负无穷到正无穷。但你不会画出那么远的函数 —— 你可能会选择一个有限的范围来绘制该函数，也许是
    −4 到 +4。这个范围是我们在 Python 中要指定的：'
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[Figure 16-4](#fig_16_4) shows the plot of the function, created using `plt.plot(x,y,''s-'')`.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 16-4](#fig_16_4) 展示了使用 `plt.plot(x,y,''s-'')` 创建的函数图。'
- en: '![Oh the fun.](assets/plad_1604.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![哦，真有趣。](assets/plad_1604.png)'
- en: Figure 16-4\. Visualizing data, part 3
  id: totrans-154
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 16-4\. 数据可视化，第三部分
- en: 'It looks OK, but I think it’s too choppy; I would like the line to look smoother.
    We can accomplish this by increasing the resolution, which means having more points
    between −4 and +4\. I’ll use the function `np.linspace()`, which takes three inputs:
    the start value, the stop value, and the number of points in between:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来还行，但我觉得它有些粗糙；我希望线条更平滑。我们可以通过增加分辨率来实现这一点，这意味着在−4到+4之间有更多的点。我将使用函数 `np.linspace()`，它接受三个输入：起始值、终止值和中间点数：
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now we have 42 points linearly (evenly) spaced between −4 and +4\. That makes
    the plot smoother ([Figure 16-5](#fig_16_5)). Note that `np.linspace` outputs
    a vector that ends at +4\. This function has inclusive bounds. It is a little
    confusing to know which functions have inclusive and which have exclusive bounds.
    Don’t worry, you’ll get the hang of it.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在−4和+4之间均匀分布的42个点。这使得绘图更平滑（[图 16-5](#fig_16_5)）。注意，`np.linspace`输出的向量以+4结束。这个函数具有包含边界。有些函数是包含边界的，有些是排除边界的，这有点令人困惑。别担心，你会掌握的。
- en: '![visdat3.](assets/plad_1605.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![visdat3.](assets/plad_1605.png)'
- en: Figure 16-5\. Visualizing data, part 4
  id: totrans-159
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 16-5\. 数据可视化，第4部分
- en: Let’s try another function-to-code translation. I will also use this opportunity
    to introduce you to a concept called *soft coding*, which means creating variables
    for parameters that you might want to change later.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试另一个函数到代码的转换。我还要借此机会向你介绍一个叫做*软编码*的概念，这意味着为可能稍后更改的参数创建变量。
- en: 'Please translate the following mathematical function into code and generate
    a plot before looking at my code that follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看我接下来的代码之前，请将以下数学函数翻译成代码并生成绘图：
- en: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>f</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mfrac><mi>α</mi> <mrow><mn>1</mn><mo>+</mo><msup><mi>e</mi> <mrow><mo>-</mo><mi>β</mi><mi>x</mi></mrow></msup></mrow></mfrac></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mi>α</mi></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mn>1.4</mn></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mi>β</mi></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mn>2</mn></mrow></mtd></mtr></mtable></math>
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>f</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mfrac><mi>α</mi> <mrow><mn>1</mn><mo>+</mo><msup><mi>e</mi> <mrow><mo>-</mo><mi>β</mi><mi>x</mi></mrow></msup></mrow></mfrac></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mi>α</mi></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mn>1.4</mn></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mi>β</mi></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mn>2</mn></mrow></mtd></mtr></mtable></math>
- en: This function is called a *sigmoid* and is used often in applied math, for example
    as a nonlinear activation function in deep learning models. <math alttext="alpha"><mi>α</mi></math>
    and <math alttext="beta"><mi>β</mi></math> are parameters of the equation. Here
    I’ve set them to specific values. But once you have the code working, you can
    explore the effects of changing those parameters on the resulting graph. In fact,
    using code to understand math is, IMHO,^([3](ch16.xhtml#idm45733288741952)) the
    absolute best way to learn mathematics.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数称为*S型函数*，在应用数学中经常用作非线性激活函数，例如在深度学习模型中。<math alttext="alpha"><mi>α</mi></math>和<math
    alttext="beta"><mi>β</mi></math>是该方程的参数。在这里，我已经为它们设置了具体的值。但一旦你的代码运行起来，你可以探索改变这些参数对生成图表的影响。实际上，使用代码理解数学，我个人认为，^([3](ch16.xhtml#idm45733288741952))
    是学习数学的绝佳方式。
- en: There are two ways you can code this function. One is to put the numerical values
    for <math alttext="alpha"><mi>α</mi></math> and <math alttext="beta"><mi>β</mi></math>
    directly into the function. This is an example of *hard coding* because the parameter
    values are directly implemented in the function.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以编写此函数。一种是直接将<math alttext="alpha"><mi>α</mi></math>和<math alttext="beta"><mi>β</mi></math>的数值放入函数中。这是*硬编码*的一个例子，因为参数数值直接实现在函数中。
- en: 'An alternative is to set Python variables to the two parameters, and then use
    those parameters when creating the mathematical function. This is *soft coding*,
    and it makes your code easier to read, modify, and debug:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是将Python变量设置为这两个参数，然后在创建数学函数时使用这些参数。这就是*软编码*，它使得你的代码更易于阅读、修改和调试：
- en: '[PRE27]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Notice that I’ve split up the function creation into three lines of code that
    specify the numerator and denominator, and then their ratio. This makes your code
    cleaner and easier to read. Always strive to make your code easy to read, because
    it (1) reduces the risk of errors and (2) facilitates debugging.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我已经将函数创建分成了三行代码，分别指定了分子和分母，然后它们的比率。这使得你的代码更清晰、更易读。始终努力使你的代码易于阅读，因为这样做（1）减少错误的风险，（2）便于调试。
- en: '[Figure 16-6](#fig_16_6) shows the resulting sigmoid. Take a few moments to
    play with the code: change the `x` variable limits and resolution, change the
    `alpha` and `beta` parameter values, maybe even change the function itself. *Mathematics
    is beautiful, Python is your canvas, and code is your paintbrush!*'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 16-6](#fig_16_6)显示了生成的S型曲线。花点时间玩玩代码：改变`x`变量的限制和分辨率，改变`alpha`和`beta`参数的值，甚至可能改变函数本身。*数学是美丽的，Python是你的画布，代码是你的画笔！*'
- en: '![visdat4.](assets/plad_1606.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![visdat4.](assets/plad_1606.png)'
- en: Figure 16-6\. Visualizing data, part 5
  id: totrans-170
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 16-6\. 数据可视化，第5部分
- en: Print Formatting and F-Strings
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打印格式化和F-Strings
- en: 'You already know how to print out variables using the `print()` function. But
    that’s just for printing out one variable with no other text. F-strings give you
    more control over the output format. Observe:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道如何使用`print()`函数打印出变量。但那只是打印一个变量而没有其他文本。F-Strings允许你更好地控制输出格式。观察：
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Note the two key features of the f-string: the initial `f` before the first
    quote mark and the curly brackets {} encasing variable names that get replaced
    with variable values.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 注意f-string的两个关键特征：在第一个引号之前的`f`和用花括号{}包围的变量名称，这些变量名称会被替换为变量值。
- en: 'The next code block further highlights the flexibility of f-strings:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个代码块进一步突显了f-strings的灵活性：
- en: '[PRE29]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Two key points to learn from this example: (1) don’t worry, I don’t actually
    eat that much chocolate (well, not every day), and (2) you can use indexing and
    code inside the curly brackets, and Python will print out the result of the computation.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中学到的两个关键点：（1）别担心，我实际上不会每天吃那么多巧克力（嗯，并不是每天），以及（2）你可以使用索引和大括号内的代码，Python会输出计算结果。
- en: 'One final feature of f-string formatting:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: f-string 格式化的最后一个特性：
- en: '[PRE30]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The key addition in that code is the `:.3f`, which controls the formatting of
    the output. This code tells Python to print out three numbers after the decimal
    point. See what happens when you change the `3` to another integer and what happens
    when you include an integer before the colon.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码中的关键添加是`:.3f`，它控制输出的格式。这段代码告诉Python在小数点后打印三个数字。看看当你将`3`改成其他整数时会发生什么，以及在冒号前包含一个整数时会发生什么。
- en: There are many other formatting options—and other ways to have flexible text
    outputs—but the basic implementation of f-strings is all you need to know for
    this book.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他的格式选项——以及其他灵活的文本输出方式——但是对于本书而言，f-strings的基本实现就是你需要知道的全部。
- en: Control Flow
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制流
- en: The power and flexibility of programming come from endowing your code with the
    ability to adapt its behavior depending on the state of certain variables or user
    inputs. Dynamism in code comes from *control flow* statements.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 编程的力量和灵活性来自于赋予代码根据某些变量或用户输入状态调整其行为的能力。代码中的动态性来自于*控制流*语句。
- en: Comparators
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较器
- en: '*Comparators* are special characters that allow you to compare different values.
    The outcome of a comparator is a data type called a *Boolean*, which takes one
    of two values: `True` or `False`. Here are a few examples:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*比较器*是特殊字符，允许您比较不同的值。比较器的结果是一种称为*布尔*的数据类型，它取两个值之一：`True`或`False`。以下是几个例子：'
- en: '[PRE31]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The outputs of these lines are `True` for #1 and `False` for #2 and #3.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行的输出分别是#1为`True`，#2和#3为`False`。
- en: That third statement contains a double-equals sign. It’s very different from
    a single equals sign, which you already know is used to assign values to a variable.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 那第三个语句包含一个双等号符号。它与单等号符号非常不同，你已经知道它用于给变量赋值。
- en: Two more comparators are `<=` (less than or equal to) and `>=` (greater than
    or equal to).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个比较器是`<=`（小于或等于）和`>=`（大于或等于）。
- en: If Statements
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如果语句
- en: '`If` statements are intuitive because you use them all the time: *If I’m tired,
    then I will rest my eyes.*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`If`语句很直观，因为你经常使用它们：*如果我累了，那么我会休息一下眼睛*。'
- en: 'The basic `if` statement has three parts: the `if` keyword, the *conditional
    statement*, and the *code content*. A conditional statement is a piece of code
    that evaluates to true or false, followed by a colon (:). If the conditional is
    true, then all the code beneath and indented is run; if the conditional is false,
    none of the indented code is run, and Python will continue running code that is
    not indented.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的`if`语句有三部分：`if`关键字、*条件语句*和*代码内容*。条件语句是一个评估为真或假的代码片段，后面跟着一个冒号（:）。如果条件为真，则运行所有缩进的代码；如果条件为假，则不运行任何缩进的代码，并且Python将继续运行未缩进的代码。
- en: 'Here is an example:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子：
- en: '[PRE32]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'And here is another example:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个例子：
- en: '[PRE33]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The first message is skipped because 4 does not equal 5; therefore, the conditional
    statement is false, and therefore Python ignores all of the indented code.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一条消息被跳过，因为4不等于5；因此，条件语句为假，因此Python忽略所有缩进的代码。
- en: elif and else
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: elif 和 else
- en: 'Those two examples show the basic `if` statement form. `If` statements can
    include additional conditionals to increase the sophistication of the flow of
    information. Before reading my explanation of the following code and before typing
    this into Python on your computer, try to understand the code and make a prediction
    about what messages will print out:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个例子展示了基本的`if`语句形式。`If`语句可以包含额外的条件，以增加信息流的复杂性。在阅读我的下面对以下代码的解释和在您的计算机上输入之前，请尝试理解代码，并对打印出的消息做出预测：
- en: '[PRE34]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: When Python encounters a code statement like this, it proceeds from top to bottom.
    So, Python will start with the first conditional after the `if`. If that conditional
    is true, Python will run code 1 and then *skip all following conditionals*. That
    is, as soon as Python encounters a true conditional, the indented code is run
    and the `if` statement ends. It doesn’t matter if subsequent conditionals are
    also true; Python won’t check them or run their indented code.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当Python遇到这样的代码语句时，它会从上到下进行处理。因此，Python将从`if`后的第一个条件开始。如果该条件为真，则Python将运行代码1，然后*跳过所有后续的条件*。也就是说，一旦Python遇到真条件，就会运行缩进的代码，并且`if`语句结束。如果后续条件也为真，Python不会检查它们或运行它们的缩进代码。
- en: If the first conditional is false, Python will proceed to the next conditional,
    which is `elif` (short for “else if”). Again, Python will run the subsequent indented
    code if the conditional is true, or it will skip the indented code if the conditional
    is false. This code example shows one `elif` statement, but you can have multiple
    such statements.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一个条件为假，Python将继续下一个条件，即`elif`（短为“else if”）。同样，如果条件为真，则Python将运行缩进的代码，否则将跳过缩进的代码。此代码示例显示了一个`elif`语句，但您可以有多个这样的语句。
- en: 'The final `else` statement has no conditional. This is like the “plan B” of
    the `if` statement: it is run if all the previous conditionals are false. If at
    least one of the conditionals is true, then the `else` code is not evaluated.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`else`语句最终没有条件。这就像`if`语句的“备选方案”：如果所有前面的条件都为假，则运行它。如果至少一个条件为真，则不会评估`else`代码。'
- en: 'The output of this code example is:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码示例的输出是：
- en: '[PRE35]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Multiple conditions
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多个条件
- en: 'You can combine conditionals using `and` and `or`. It’s the coding analog to
    “If it rains *and* I need to walk, then I’ll bring an umbrella.” Here are a few
    examples:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`and`和`or`组合条件。这是“如果下雨*并且*我需要步行，则我会带上雨伞”的编码类比。以下是几个示例：
- en: '[PRE36]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The text `Code example 2` did not print because 4 does not equal 5\. However,
    when using `or`, then *at least one* of the conditionals is true, so the subsequent
    code was run.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 文本`Code example 2`没有打印，因为4不等于5。然而，使用`or`时，*至少一个*条件为真，因此运行了后续代码。
- en: For Loops
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`For`循环'
- en: 'Your Python skills are now sufficient to print out the numbers 1–10\. You could
    use the following code:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的Python技能已经足以打印出1–10的数字。你可以使用以下代码：
- en: '[PRE37]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: And so on. But that is not a scalable strategy—what if I asked you to print
    out numbers up to a million?
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 等等。但这不是一种可扩展的策略——如果我让你打印出一百万以内的数字呢？
- en: 'Repeating code in Python is done through *loops*. The most important kind of
    loop is called a *`for` loop*. To create a `for` loop, you specify an iterable
    (an *iterable* is a variable used to iterate over each element in that variable;
    a list can be used as an iterable) and then any number of lines of code that should
    be run inside the `for` loop. I’ll start with a very simple example, and then
    we’ll build on that:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中重复代码是通过*循环*来完成的。最重要的一种循环称为*`for`循环*。要创建一个`for`循环，您指定一个可迭代对象（*iterable*是一个用于迭代变量中的每个元素的变量；列表可以用作可迭代对象），然后指定在`for`循环内运行的任意数量的代码行。我将从一个非常简单的示例开始，然后我们将进一步构建：
- en: '[PRE38]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Running that code will output the numbers 0 through 10\. The function `range()`
    creates an iterable object with its own data type called *range*, which is often
    used in `for` loops. The range variable contains integers from 0 through 9\. (Exclusive
    upper bound! Also, if you start counting at 0, then you don’t need the first input,
    so `range(10)` is the same as `range(0,10)`). But my instructions were to print
    the numbers 1 through 10, so we need to add 1 inside the `print` function. This
    example also highlights that you can use the iteration variable as a regular numerical
    variable.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 运行该代码将输出0到10的数字。函数`range()`创建一个具有自己的数据类型*range*的可迭代对象，通常用于`for`循环。范围变量包含从0到9的整数。（不包括上限！另外，如果从0开始计数，则不需要第一个输入，因此`range(10)`与`range(0,10)`相同）。但我的指令是打印1到10的数字，因此我们需要在`print`函数内添加1。此示例还突出显示您可以将迭代变量用作常规数值变量。
- en: '`for` loops can iterate over other data types. Consider the following example:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环可以迭代其他数据类型。考虑以下示例：'
- en: '[PRE39]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now we’re iterating over a list, and the looping variable `item` is set to each
    item in the list at each iteration.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在对列表进行迭代，循环变量`item`在每次迭代时设置为列表中的每个项目。
- en: Nested Control Statements
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套控制语句
- en: 'Nesting flow-control statements inside other flow-control statements gives
    your code an additional layer of flexibility. Try to figure out what the code
    does and make a prediction for its output. Then type it into Python and test your
    hypothesis:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 将流程控制语句嵌套在其他流程控制语句中可以为您的代码增加额外的灵活性。试着弄清楚代码的作用并对其输出进行预测。然后将其输入Python并测试您的假设：
- en: '[PRE40]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: I haven’t yet taught you about the `%` operator. That’s called the *modulus
    operator*, and it returns the remainder after division. So 7%3 = 1, because 3
    goes into 7 twice with a remainder of 1\. Likewise, 6%2 = 0 because 2 goes into
    6 three times with a remainder of 0\. In fact, k%2 = 0 for *all* even numbers
    and k%2 = 1 for *all* odd numbers. Therefore, a statement like `i%2==0` is a way
    to test whether the numeric variable `i` is even or odd.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我还没有教你关于`%`运算符。这被称为*模运算符*，它返回除法后的余数。因此，7%3 = 1，因为3可以整除7两次，余数为1。同样，6%2 = 0，因为2可以整除6三次，余数为0。事实上，对于*所有*偶数，k%2
    = 0；对于*所有*奇数，k%2 = 1。因此，类似于`i%2==0`的语句是测试数值变量`i`是偶数还是奇数的一种方法。
- en: Measuring Computation Time
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测量计算时间
- en: 'When writing and evaluating code, you will often want to know how long the
    computer takes to run certain pieces of code. There are several ways to measure
    elapsed time in Python; one simple method is shown here, using the time library:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写和评估代码时，您通常会想知道计算机运行某些代码需要多长时间。在Python中，有几种测量经过时间的方法；这里展示了一种简单的方法，使用时间库：
- en: '[PRE41]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The idea is to query the operating system’s local time twice (this is the output
    of the function `time.time()`): once before running some code or functions, and
    once after running the code. The difference in clock times is the computation
    time. The result is the elapsed time in seconds. It’s often handy to multiply
    the result by 1,000 to print the results in milliseconds (ms).'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是查询操作系统的本地时间两次（这是函数`time.time()`的输出）：一次是在运行某些代码或函数之前，一次是在运行代码之后。时钟时间的差异就是计算时间。结果是以秒为单位的经过时间。通常可以将结果乘以1,000以将结果以毫秒（ms）打印出来。
- en: Getting Help and Learning More
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取帮助和进一步学习
- en: 'I’m sure you’ve heard the phrase “Math is not a spectator sport.” Same goes
    for coding: the only way to learn to code is by coding. You will make lots of
    mistakes, get frustrated because you can’t figure out how to get Python to do
    what you want, see lots of errors and warning messages that you can’t decipher,
    and just get really irritated at the universe and everything in it. (Yeah, you
    know the feeling I’m referring to.)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你听过这句话“数学不是一项旁观运动”。编程也是如此：学习编程的唯一方法就是编程。你会犯很多错误，会因为无法弄清楚如何让Python按照你的意愿运行而感到沮丧，会看到很多你无法解释的错误和警告信息，只会对宇宙和其中的一切感到非常恼火。（是的，你知道我指的是什么感觉。）
- en: What to Do When Things Go Awry
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当事情出现问题时该怎么办
- en: 'Please allow me the indulgence to tell a joke: four engineers get into a car,
    but the car won’t start. The mechanical engineer says, “It’s probably a problem
    with the timing belt.” The chemical engineer says, “No, I think the problem is
    the gas/air mixture.” The electrical engineer says, “It sounds to me like the
    spark plugs are faulty.” Finally, the software engineer says, “Let’s just get
    out of the car and get back in again.”'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 请允许我自我放纵地讲个笑话：四个工程师上了一辆车，但车发动不了。机械工程师说：“这可能是正时皮带的问题。”化学工程师说：“不，我认为问题在于气体/空气混合物。”电气工程师说：“听起来像是火花塞有问题。”最后，软件工程师说：“我们只需下车再上车。”
- en: The moral of the story is that when you encounter some unexplainable issues
    in your code, you can try restarting the *kernel*, which is the engine running
    Python. That won’t fix coding errors, but it may resolve errors due to variables
    being overwritten or renamed, memory overloads, or system failures. In Jupyter
    notebooks, you can restart the kernel through the menu options. Be aware that
    restarting the kernel clears out all of the variables and environment settings.
    You may need to rerun the code from the beginning.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 故事的寓意是，当你在代码中遇到一些无法解释的问题时，可以尝试重新启动*内核*，这是运行Python的引擎。这不会修复编程错误，但可能会解决由于变量被覆盖或重命名、内存超载或系统故障而引起的错误。在Jupyter笔记本中，您可以通过菜单选项重新启动内核。请注意，重新启动内核会清除所有变量和环境设置。您可能需要重新从头运行代码。
- en: If the error persists, then search the internet for the error message, the name
    of the function you’re using, or a brief description of the problem you’re trying
    to solve. Python has a huge international community, and there is a multitude
    of online forums where people discuss and resolve Python coding issues and confusions.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果错误持续存在，那么搜索互联网上的错误消息、你正在使用的函数名称或问题描述的简要说明。Python 拥有庞大的国际社区，有许多在线论坛讨论和解决 Python
    编程问题和困惑。
- en: Summary
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Mastering a programming language like Python takes years of dedicated study
    and practice. Even achieving a good beginner’s level takes weeks to months. I
    hope this chapter provided you with enough skills to complete this book. But as
    I wrote in [Chapter 1](ch01.xhtml#Chapter_1), if you find that you understand
    the math but struggle with the code, then you might want to put this book down,
    get some more Python training, and then come back.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握像 Python 这样的编程语言需要多年的专注学习和实践。即使达到一个良好的初学者水平也需要几周甚至几个月的时间。希望本章为你提供了足够的技能来完成这本书。但正如我在[第1章](ch01.xhtml#Chapter_1)中所写的，如果你发现自己理解数学但在代码上苦苦挣扎，那么你可能需要放下这本书，进行更多的
    Python 训练，然后再回来。
- en: On the other hand, you should also see this book as a way to improve your Python
    coding skills. So if you don’t understand some code in the book, then learning
    linear algebra is the perfect excuse to learn more Python!
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，你也应该把这本书看作是提高你的 Python 编程技能的一种方式。所以如果你不理解书中的某些代码，学习线性代数就是学习更多 Python 的完美借口！
- en: ^([1](ch16.xhtml#idm45733289514672-marker)) Some IDEs accept two or four spaces;
    others accept only four spaces. I think two spaces looks cleaner.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch16.xhtml#idm45733289514672-marker)) 一些集成开发环境接受两个或四个空格；其他只接受四个空格。我认为两个空格看起来更清晰。
- en: ^([2](ch16.xhtml#idm45733289405568-marker)) If you installed Python via Anaconda
    or if you are using Google’s Colab environment, you won’t need to download any
    libraries for this book, but you will need to import them.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch16.xhtml#idm45733289405568-marker)) 如果你通过 Anaconda 安装了 Python，或者你正在使用
    Google 的 Colab 环境，你不需要为本书下载任何库，但你需要导入它们。
- en: ^([3](ch16.xhtml#idm45733288741952-marker)) I’m told that this is millenial
    lingo for “in my humble opinion.”
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch16.xhtml#idm45733288741952-marker)) 据说这是千禧一代的术语，意思是“依我拙见”。
