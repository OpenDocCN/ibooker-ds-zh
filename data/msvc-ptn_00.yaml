- en: Chapter 1\. Escaping monolithic hell
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第1章\. 逃离单体地狱
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: The symptoms of monolithic hell and how to escape it by adopting the microservice
    architecture
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单体地狱的症状以及如何通过采用微服务架构来逃离它
- en: The essential characteristics of the microservice architecture and its benefits
    and drawbacks
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务架构的基本特征及其优缺点
- en: How microservices enable the DevOps style of development of large, complex applications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务如何使大型、复杂应用程序的DevOps开发风格成为可能
- en: The microservice architecture pattern language and why you should use it
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务架构模式语言及其为什么应该使用它的原因
- en: It was only Monday lunchtime, but Mary, the CTO of Food to Go, Inc. (FTGO),
    was already feeling frustrated. Her day had started off really well. She had spent
    the previous week with other software architects and developers at an excellent
    conference learning about the latest software development techniques, including
    continuous deployment and the microservice architecture. Mary had also met up
    with her former computer science classmates from North Carolina A&T State and
    shared technology leadership war stories. The conference had left her feeling
    empowered and eager to improve how FTGO develops software.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 那天只是周一的中午，但Mary，Food to Go，Inc.（FTGO）的首席技术官，已经感到沮丧。她的这一天开始得很顺利。上周，她与其他软件架构师和开发者参加了一个优秀的会议，学习了最新的软件开发技术，包括持续部署和微服务架构。Mary还遇到了她从北卡罗来纳州A&T州立大学的计算机科学同学，分享了技术领导力的故事。会议让她感到充满力量，渴望改善FTGO的软件开发方式。
- en: Unfortunately, that feeling had quickly evaporated. She had just spent the first
    morning back in the office in yet another painful meeting with senior engineering
    and business people. They had spent two hours discussing why the development team
    was going to miss another critical release date. Sadly, this kind of meeting had
    become increasingly common over the past few years. Despite adopting agile, the
    pace of development was slowing down, making it next to impossible to meet the
    business’s goals. And, to make matters worse, there didn’t seem to be a simple
    solution.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这种感觉很快就消失了。她刚刚在办公室里又经历了一次痛苦的会议，与高级工程和业务人员进行讨论。他们花了两个小时讨论为什么开发团队将错过另一个关键发布日期。遗憾的是，这类会议在过去几年中变得越来越常见。尽管采用了敏捷开发，但开发速度却在放缓，几乎不可能达到业务目标。更糟糕的是，似乎没有简单的解决方案。
- en: The conference had made Mary realize that FTGO was suffering from a case of
    *monolithic hell* and that the cure was to adopt the microservice architecture.
    But the microservice architecture and the associated state-of-the-art software
    development practices described at the conference felt like an elusive dream.
    It was unclear to Mary how she could fight today’s fires while simultaneously
    improving the way software was developed at FTGO.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 会议让Mary意识到FTGO正遭受“单体地狱”的困扰，而治愈的方法是采用微服务架构。但会议中描述的微服务架构和相关最先进的软件开发实践似乎是一个遥不可及的梦想。Mary不清楚她如何在应对当前的问题的同时，同时改善FTGO的软件开发方式。
- en: Fortunately, as you will learn in this book, there is a way. But first, let’s
    look at the problems that FTGO is facing and how they got there.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，正如你将在本书中学到的，有一个方法。但首先，让我们看看FTGO面临的问题以及他们是如何走到这一步的。
- en: 1.1\. The slow march toward monolithic hell
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1\. 向单体地狱缓慢迈进
- en: Since its launch in late 2005, FTGO had grown by leaps and bounds. Today, it’s
    one of the leading online food delivery companies in the United States. The business
    even plans to expand overseas, although those plans are in jeopardy because of
    delays in implementing the necessary features.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 自从2005年底推出以来，FTGO发展迅速。如今，它是美国领先的在线食品配送公司之一。业务甚至计划拓展海外市场，尽管由于实施必要功能的延误，这些计划处于危险之中。
- en: At its core, the FTGO application is quite simple. Consumers use the FTGO website
    or mobile application to place food orders at local restaurants. FTGO coordinates
    a network of couriers who deliver the orders. It’s also responsible for paying
    couriers and restaurants. Restaurants use the FTGO website to edit their menus
    and manage orders. The application uses various web services, including Stripe
    for payments, Twilio for messaging, and Amazon Simple Email Service (SES) for
    email.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本质上，FTGO应用程序相当简单。消费者使用FTGO网站或移动应用程序在本地餐厅下订单。FTGO协调一个快递网络，负责递送订单。它还负责支付快递和餐厅的费用。餐厅使用FTGO网站编辑他们的菜单和管理订单。该应用程序使用各种网络服务，包括Stripe支付、Twilio消息传递和Amazon
    Simple Email Service（SES）电子邮件服务。
- en: Like many other aging enterprise applications, the FTGO application is a monolith,
    consisting of a single Java Web Application Archive (WAR) file. Over the years,
    it has become a large, complex application. Despite the best efforts of the FTGO
    development team, it’s become an example of the Big Ball of Mud pattern ([www.laputan.org/mud/](http://www.laputan.org/mud/)).
    To quote Foote and Yoder, the authors of that pattern, it’s a “haphazardly structured,
    sprawling, sloppy, duct-tape and bailing wire, spaghetti code jungle.” The pace
    of software delivery has slowed. To make matters worse, the FTGO application has
    been written using some increasingly obsolete frameworks. The FTGO application
    is exhibiting all the symptoms of monolithic hell.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多其他老化的企业应用程序一样，FTGO应用程序是一个单体，由一个单一的Java Web应用程序存档（WAR）文件组成。多年来，它已经变成一个庞大而复杂的应用程序。尽管FTGO开发团队做出了最大的努力，但它已经成为Big
    Ball of Mud模式的例子([www.laputan.org/mud/](http://www.laputan.org/mud/))。引用该模式的作者Foote和Yoder的话，它是一个“随意结构、蔓延、混乱、胶带和铁丝、意大利面代码丛林”。软件交付的速度已经放缓。更糟糕的是，FTGO应用程序使用了某些越来越过时的框架。FTGO应用程序正显示出单体地狱的所有症状。
- en: The next section describes the architecture of the FTGO application. Then it
    talks about why the monolithic architecture worked well initially. We’ll get into
    how the FTGO application has outgrown its architecture and how that has resulted
    in monolithic hell.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将描述FTGO应用程序的架构。然后它将讨论为什么单体架构最初工作得很好。我们将探讨FTGO应用程序是如何超出其架构的，以及这是如何导致单体地狱的。
- en: 1.1.1\. The architecture of the FTGO application
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.1\. FTGO应用程序的架构
- en: FTGO is a typical enterprise Java application. [Figure 1.1](#ch01fig01) shows
    its architecture. The FTGO application has a hexagonal architecture, which is
    an architectural style described in more detail in [chapter 2](kindle_split_010.xhtml#ch02).
    In a hexagonal architecture, the core of the application consists of the business
    logic. Surrounding the business logic are various adapters that implement UIs
    and integrate with external systems.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: FTGO是一个典型的企业Java应用程序。[图1.1](#ch01fig01)显示了其架构。FTGO应用程序具有六边形架构，这在[第2章](kindle_split_010.xhtml#ch02)中描述得更为详细。在六边形架构中，应用程序的核心是业务逻辑。围绕业务逻辑的是各种适配器，它们实现UI并与外部系统集成。
- en: Figure 1.1\. The FTGO application has a hexagonal architecture. It consists
    of business logic surrounded by adapters that implement UIs and interface with
    external systems, such as mobile applications and cloud services for payments,
    messaging, and email.
  id: totrans-17
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.1\. FTGO应用程序具有六边形架构。它由业务逻辑组成，周围是实现UI并与外部系统（如移动应用程序和支付、消息和电子邮件的云服务）接口的适配器。
- en: '![](Images/01fig01_alt.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片 01fig01](Images/01fig01_alt.jpg)'
- en: The business logic consists of modules, each of which is a collection of domain
    objects. Examples of the modules include `Order Management`, `Delivery Management`,
    `Billing`, and `Payments`. There are several adapters that interface with the
    external systems. Some are *inbound* adapters, which handle requests by invoking
    the business logic, including the `REST API` and `Web UI` adapters. Others are
    *outbound* adapters, which enable the business logic to access the MySQL database
    and invoke cloud services such as Twilio and Stripe.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 业务逻辑由模块组成，每个模块都是一组领域对象。模块的例子包括`订单管理`、`配送管理`、`计费`和`支付`。有几个适配器与外部系统接口。一些是*入站*适配器，通过调用业务逻辑处理请求，包括`REST
    API`和`Web UI`适配器。其他是*出站*适配器，使业务逻辑能够访问MySQL数据库并调用Twilio和Stripe等云服务。
- en: Despite having a logically modular architecture, the FTGO application is packaged
    as a single WAR file. The application is an example of the widely used *monolithic*
    style of software architecture, which structures a system as a single executable
    or deployable component. If the FTGO application were written in the Go language
    (GoLang), it would be a single executable. A Ruby or NodeJS version of the application
    would be a single directory hierarchy of source code. The monolithic architecture
    isn’t inherently bad. The FTGO developers made a good decision when they picked
    monolithic architecture for their application.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管逻辑上具有模块化架构，FTGO应用程序仍然被打包成一个单一的WAR文件。该应用程序是广泛使用的*单体*软件架构风格的例子，它将系统结构为一个单一的可执行或可部署组件。如果FTGO应用程序是用Go语言（GoLang）编写的，它将是一个单一的执行文件。Ruby或NodeJS版本的该应用程序将是一个单一的源代码目录层次结构。单体架构本身并不坏。FTGO开发者在为应用程序选择单体架构时做出了明智的决定。
- en: 1.1.2\. The benefits of the monolithic architecture
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.2\. 单体架构的好处
- en: 'In the early days of FTGO, when the application was relatively small, the application’s
    monolithic architecture had lots of benefits:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在FTGO的早期，当应用程序相对较小的时候，其单体架构有很多好处：
- en: '***Simple to develop*—** IDEs and other developer tools are focused on building
    a single application.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***易于开发*—** 集成开发环境（IDE）和其他开发者工具专注于构建单个应用程序。'
- en: '***Easy to make radical changes to the application*—** You can change the code
    and the database schema, build, and deploy.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***易于对应用程序进行重大更改*—** 你可以更改代码和数据库模式，构建和部署。'
- en: '***Straightforward to test*—** The developers wrote end-to-end tests that launched
    the application, invoked the REST API, and tested the UI with Selenium.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***测试简单*—** 开发者编写了端到端测试，启动应用程序，调用REST API，并使用Selenium测试UI。'
- en: '***Straightforward to deploy*—** All a developer had to do was copy the WAR
    file to a server that had Tomcat installed.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***部署简单*—** 开发者只需将WAR文件复制到已安装Tomcat的服务器上。'
- en: '***Easy to scale*—** FTGO ran multiple instances of the application behind
    a load balancer.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***易于扩展*—** FTGO在负载均衡器后面运行了多个应用程序实例。'
- en: Over time, though, development, testing, deployment, and scaling became much
    more difficult. Let’s look at why.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着时间的推移，开发、测试、部署和扩展变得更加困难。让我们看看原因。
- en: 1.1.3\. Living in monolithic hell
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.3\. 活在单体地狱中
- en: Unfortunately, as the FTGO developers have discovered, the monolithic architecture
    has a huge limitation. Successful applications like the FTGO application have
    a habit of outgrowing the monolithic architecture. Each sprint, the FTGO development
    team implemented a few more stories, which made the code base larger. Moreover,
    as the company became more successful, the size of the development team steadily
    grew. Not only did this increase the growth rate of the code base, it also increased
    the management overhead.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，正如FTGO的开发者所发现的，单体架构有一个巨大的限制。像FTGO这样的成功应用程序往往会长得超出单体架构的范畴。每个冲刺，FTGO的开发团队实施了更多的故事，这使得代码库变得更大。此外，随着公司的日益成功，开发团队的大小稳步增长。这不仅增加了代码库的增长速度，还增加了管理成本。
- en: As [figure 1.2](#ch01fig02) shows, the once small, simple FTGO application has
    grown over the years into a monstrous monolith. Similarly, the small development
    team has now become multiple Scrum teams, each of which works on a particular
    functional area. As a result of outgrowing its architecture, FTGO is in monolithic
    hell. Development is slow and painful. Agile development and deployment is impossible.
    Let’s look at why this has happened.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图1.2](#ch01fig02)所示，曾经小巧、简单的FTGO应用程序在多年后已经成长为一个庞大的单体。同样，小型开发团队现在已成为多个Scrum团队，每个团队负责特定的功能区域。由于超出其架构，FTGO陷入了单体地狱。开发缓慢且痛苦。敏捷开发和部署变得不可能。让我们看看这是为什么发生了。
- en: Figure 1.2\. A case of monolithic hell. The large FTGO developer team commits
    their changes to a single source code repository. The path from code commit to
    production is long and arduous and involves manual testing. The FTGO application
    is large, complex, unreliable, and difficult to maintain.
  id: totrans-32
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.2\. 单体地狱的一个案例。庞大的FTGO开发团队将他们的更改提交到一个单一源代码仓库。从代码提交到生产的路径漫长而艰难，涉及手动测试。FTGO应用程序庞大、复杂、不可靠，难以维护。
- en: '![](Images/01fig02_alt.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/01fig02_alt.jpg)'
- en: Complexity intimidates developers
  id: totrans-34
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 复杂性令开发者感到畏惧
- en: A major problem with the FTGO application is that it’s too complex. It’s too
    large for any developer to fully understand. As a result, fixing bugs and correctly
    implementing new features have become difficult and time consuming. Deadlines
    are missed.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: FTGO应用程序的一个主要问题是它过于复杂。它太大，以至于任何开发者都无法完全理解。因此，修复错误和正确实现新功能变得困难且耗时。截止日期被延误。
- en: To make matters worse, this overwhelming complexity tends to be a downward spiral.
    If the code base is difficult to understand, a developer won’t make changes correctly.
    Each change makes the code base incrementally more complex and harder to understand.
    The clean, modular architecture shown earlier in [figure 1.1](#ch01fig01) doesn’t
    reflect reality. FTGO is gradually becoming a monstrous, incomprehensible, big
    ball of mud.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 更糟糕的是，这种压倒性的复杂性往往会导致一个恶性循环。如果代码库难以理解，开发者就不会正确地做出更改。每次更改都会使代码库逐渐变得更加复杂，更难以理解。前面[图1.1](#ch01fig01)中展示的干净、模块化的架构并不反映现实。FTGO正逐渐变成一个庞大、难以理解的“泥球”。
- en: 'Mary remembers recently attending a conference where she met a developer who
    was writing a tool to analyze the dependencies between the thousands of JARs in
    their multimillion lines-of-code (LOC) application. At the time, that tool seemed
    like something FTGO could use. Now she’s not so sure. Mary suspects a better approach
    is to migrate to an architecture that is better suited to a complex application:
    microservices.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 玛丽记得最近参加了一个会议，在那里她遇到了一个正在编写工具来分析他们数百万行代码（LOC）应用程序中数千个 JAR 之间依赖关系的开发者。当时，那个工具看起来像是
    FTGO 可以使用的工具。现在她不太确定了。玛丽怀疑更好的方法是将架构迁移到更适合复杂应用程序的架构：微服务。
- en: Development is slow
  id: totrans-38
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 开发缓慢
- en: As well as having to fight overwhelming complexity, FTGO developers find day-to-day
    development tasks slow. The large application overloads and slows down a developer’s
    IDE. Building the FTGO application takes a long time. Moreover, because it’s so
    large, the application takes a long time to start up. As a result, the edit-build-run-test
    loop takes a long time, which badly impacts productivity.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 除了要应对压倒性的复杂性，FTGO 开发者发现日常开发任务也缓慢。大型应用程序超载并减慢了开发者的 IDE。构建 FTGO 应用程序需要很长时间。此外，由于它如此庞大，应用程序启动也需要很长时间。因此，编辑-构建-运行-测试循环需要很长时间，这对生产力产生了严重影响。
- en: Path from commit to deployment is long and arduous
  id: totrans-40
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 从提交到部署的路径漫长且艰巨
- en: 'Another problem with the FTGO application is that deploying changes into production
    is a long and painful process. The team typically deploys updates to production
    once a month, usually late on a Friday or Saturday night. Mary keeps reading that
    the state-of-the-art for Software-as-a-Service (SaaS) applications is *continuous
    deployment*: deploying changes to production many times a day during business
    hours. Apparently, as of 2011, Amazon.com deployed a change into production every
    11.6 seconds without ever impacting the user! For the FTGO developers, updating
    production more than once a month seems like a distant dream. And adopting continuous
    deployment seems next to impossible.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: FTGO 应用程序的另一个问题是将更改部署到生产是一个漫长且痛苦的过程。团队通常每月一次将更新部署到生产环境，通常是在周五或周六晚上。玛丽一直在阅读关于软件即服务（SaaS）应用程序的最新技术是*持续部署*：在办公时间内多次将更改部署到生产环境。显然，截至
    2011 年，Amazon.com 每隔 11.6 秒就将一个更改部署到生产环境，而从未影响过用户！对于 FTGO 开发者来说，每月更新一次生产环境似乎是一个遥远的梦想。而且采用持续部署似乎几乎不可能。
- en: FTGO has partially adopted agile. The engineering team is divided into squads
    and uses two-week sprints. Unfortunately, the journey from code complete to running
    in production is long and arduous. One problem with so many developers committing
    to the same code base is that the build is frequently in an unreleasable state.
    When the FTGO developers tried to solve this problem by using feature branches,
    their attempt resulted in lengthy, painful merges. Consequently, once a team completes
    its sprint, a long period of testing and code stabilization follows.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: FTGO 部分采用了敏捷开发。工程团队分为小队，并使用两周冲刺。不幸的是，从代码完成到在生产环境中运行的过程漫长且艰巨。这么多开发者提交到同一个代码库的一个问题是构建经常处于不可发布的状态。当
    FTGO 开发者试图通过使用功能分支来解决这个问题时，他们的尝试导致了漫长而痛苦的合并。因此，一旦团队完成其冲刺，就会跟随一段长时间的测试和代码稳定期。
- en: Another reason it takes so long to get changes into production is that testing
    takes a long time. Because the code base is so complex and the impact of a change
    isn’t well understood, developers and the Continuous Integration (CI) server must
    run the entire test suite. Some parts of the system even require manual testing.
    It also takes a while to diagnose and fix the cause of a test failure. As a result,
    it takes a couple of days to complete a testing cycle.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个原因是将更改部署到生产环境需要很长时间的原因是测试需要很长时间。由于代码库非常复杂，并且对更改的影响理解不充分，开发者和持续集成（CI）服务器必须运行整个测试套件。系统的一些部分甚至需要手动测试。诊断和修复测试失败的原因也需要一段时间。因此，完成一个测试周期需要几天时间。
- en: Scaling is difficult
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 扩展很困难
- en: The FTGO team also has problems scaling its application. That’s because different
    application modules have conflicting resource requirements. The restaurant data,
    for example, is stored in a large, in-memory database, which is ideally deployed
    on servers with lots of memory. In contrast, the image processing module is CPU
    intensive and best deployed on servers with lots of CPU. Because these modules
    are part of the same application, FTGO must compromise on the server configuration.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: FTGO团队在扩展其应用程序时也遇到了问题。这是因为不同的应用程序模块有不同的资源需求。例如，餐厅数据存储在一个大型的内存数据库中，理想情况下应该部署在拥有大量内存的服务器上。相比之下，图像处理模块对CPU资源需求较高，最好部署在拥有大量CPU的服务器上。由于这些模块是同一应用程序的一部分，FTGO必须在服务器配置上做出妥协。
- en: Delivering a reliable monolith is challenging
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提供一个可靠的单体应用具有挑战性
- en: Another problem with the FTGO application is the lack of reliability. As a result,
    there are frequent production outages. One reason it’s unreliable is that testing
    the application thoroughly is difficult, due to its large size. This lack of testability
    means bugs make their way into production. To make matters worse, the application
    lacks *fault isolation*, because all modules are running within the same process.
    Every so often, a bug in one module—for example, a memory leak—crashes all instances
    of the application, one by one. The FTGO developers don’t enjoy being paged in
    the middle of the night because of a production outage. The business people like
    the loss of revenue and trust even less.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: FTGO应用程序的另一个问题是可靠性不足。因此，经常出现生产中断。它不可靠的一个原因是由于其规模庞大，彻底测试应用程序很困难。这种不可测试性意味着错误会进入生产环境。更糟糕的是，应用程序缺乏*故障隔离*，因为所有模块都在同一个进程中运行。每隔一段时间，一个模块中的错误——例如内存泄漏——会逐一崩溃所有应用程序实例。FTGO开发者不喜欢因为生产中断而在半夜被叫醒。商界人士对收入和信任的损失更是感到不满。
- en: Locked into increasingly obsolete technology stack
  id: totrans-48
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 被锁定在越来越过时的技术堆栈中
- en: The final aspect of monolithic hell experienced by the FTGO team is that the
    architecture forces them to use a technology stack that’s becoming increasingly
    obsolete. The monolithic architecture makes it difficult to adopt new frameworks
    and languages. It would be extremely expensive and risky to rewrite the entire
    monolithic application so that it would use a new and presumably better technology.
    Consequently, developers are stuck with the technology choices they made at the
    start of the project. Quite often, they must maintain an application written using
    an increasingly obsolete technology stack.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: FTGO团队经历的最后一个单体地狱方面的问题是，该架构迫使他们使用一个变得越来越过时的技术堆栈。单体架构使得采用新框架和语言变得困难。重写整个单体应用程序以使用新的、可能更好的技术将极其昂贵且风险极高。因此，开发者被困在项目开始时所做的技术选择中。很多时候，他们必须维护使用越来越过时的技术堆栈编写的应用程序。
- en: The Spring framework has continued to evolve while being backward compatible,
    so in theory FTGO might have been able to upgrade. Unfortunately, the FTGO application
    uses versions of frameworks that are incompatible with newer versions of Spring.
    The development team has never found the time to upgrade those frameworks. As
    a result, major parts of the application are written using increasingly out-of-date
    frameworks. What’s more, the FTGO developers would like to experiment with non-JVM
    languages such as GoLang and NodeJS. Sadly, that’s not possible with a monolithic
    application.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Spring框架在保持向后兼容的同时持续发展，因此在理论上FTGO可能已经能够升级。不幸的是，FTGO应用程序使用的框架版本与Spring的新版本不兼容。开发团队从未找到时间升级这些框架。因此，应用程序的主要部分是使用越来越过时的框架编写的。更重要的是，FTGO开发者希望尝试使用GoLang和NodeJS等非JVM语言。遗憾的是，在单体应用程序中这是不可能的。
- en: 1.2\. Why this book is relevant to you
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2. 为什么这本书对你很重要
- en: It’s likely that you’re a developer, architect, CTO, or VP of engineering. You’re
    responsible for an application that has outgrown its monolithic architecture.
    Like Mary at FTGO, you’re struggling with software delivery and want to know how
    to escape monolith hell. Or perhaps you fear that your organization is on the
    path to monolithic hell and you want to know how to change direction before it’s
    too late. If you need to escape or avoid monolithic hell, this is the book for
    you.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能你是一名开发者、架构师、CTO或工程副总裁。你负责的应用程序已经超出了其单体架构的范畴。像FTGO的玛丽一样，你在软件交付方面遇到了困难，并想知道如何逃离单体地狱。或者，也许你担心你的组织正在走向单体地狱，你希望在为时已晚之前改变方向。如果你需要逃离或避免单体地狱，这本书就是为你准备的。
- en: 'This book spends a lot of time explaining microservice architecture concepts.
    My goal is for you to find this material accessible, regardless of the technology
    stack you use. All you need is to be familiar with the basics of enterprise application
    architecture and design. In particular, you need to know the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 本书花费了大量时间解释微服务架构的概念。我的目标是让你无论使用什么技术栈都能轻松理解这些材料。你所需要的只是熟悉企业应用程序架构和设计的基础知识。特别是，你需要了解以下内容：
- en: Three-tier architecture
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三层架构
- en: Web application design
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络应用程序设计
- en: How to develop business logic using object-oriented design
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用面向对象设计开发业务逻辑
- en: 'How to use an RDBMS: SQL and ACID transactions'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用关系型数据库管理系统：SQL和ACID事务
- en: How to use interprocess communication using a message broker and REST APIs
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用消息代理和REST API进行进程间通信
- en: Security, including authentication and authorization
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全性，包括身份验证和授权
- en: The code examples in this book are written using Java and the Spring framework.
    That means in order to get the most out of the examples, you need to be familiar
    with the Spring framework too.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的代码示例使用Java和Spring框架编写。这意味着为了充分利用示例，你需要熟悉Spring框架。
- en: 1.3\. What you’ll learn in this book
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3. 本书你将学到什么
- en: 'By the time you finish reading this book you’ll understand the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在你完成阅读这本书的时候，你将理解以下内容：
- en: The essential characteristics of the microservice architecture, its benefits
    and drawbacks, and when to use it
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务架构的基本特征、其优势和劣势，以及何时使用它
- en: Distributed data management patterns
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布式数据管理模式
- en: Effective microservice testing strategies
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效的微服务测试策略
- en: Deployment options for microservices
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务的部署选项
- en: Strategies for refactoring a monolithic application into a microservice architecture
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将单体应用程序重构为微服务架构的策略
- en: 'You’ll also be able to do the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将能够做以下事情：
- en: Architect an application using the microservice architecture pattern
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用微服务架构模式设计应用程序
- en: Develop the business logic for a service
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为服务开发业务逻辑
- en: Use sagas to maintain data consistency across services
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用传奇（sagas）来维护服务之间的数据一致性
- en: Implement queries that span services
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现跨服务的查询
- en: Effectively test microservices
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效测试微服务
- en: Develop production-ready services that are secure, configurable, and observable
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发安全、可配置和可观察的生产就绪服务
- en: Refactor an existing monolithic application to services
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将现有的单体应用程序重构为服务
- en: 1.4\. Microservice architecture to the rescue
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4. 微服务架构的拯救
- en: Mary has come to the conclusion that FTGO must migrate to the microservice architecture.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 玛丽得出结论，FTGO必须迁移到微服务架构。
- en: Interestingly, software architecture has very little to do with functional requirements.
    You can implement a set of *use cases*—an application’s functional requirements—with
    any architecture. In fact, it’s common for successful applications, such as the
    FTGO application, to be big balls of mud.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，软件架构与功能需求几乎没有关系。你可以使用任何架构来实现一组*用例*——应用程序的功能需求。实际上，对于像FTGO应用程序这样的成功应用，通常都是一团糟。
- en: 'Architecture matters, however, because of how it affects the so-called *quality
    of service* requirements, also called *nonfunctional requirements*, *quality attributes*,
    or *ilities*. As the FTGO application has grown, various quality attributes have
    suffered, most notably those that impact the velocity of software delivery: maintainability,
    extensibility, and testability.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，架构很重要，因为它影响所谓的*服务质量*需求，也称为*非功能性需求*、*质量属性*或*能力*。随着FTGO应用程序的增长，各种质量属性都受到了影响，最值得注意的是那些影响软件交付速度的属性：可维护性、可扩展性和可测试性。
- en: 'On the one hand, a disciplined team can slow down the pace of its descent toward
    monolithic hell. Team members can work hard to maintain the modularity of their
    application. They can write comprehensive automated tests. On the other hand,
    they can’t avoid the issues of a large team working on a single monolithic application.
    Nor can they solve the problem of an increasingly obsolete technology stack. The
    best a team can do is delay the inevitable. To escape monolithic hell, they must
    migrate to a new architecture: the Microservice architecture.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，一个有纪律的团队能够减缓其走向单体地狱的步伐。团队成员可以努力保持其应用程序的模块化。他们可以编写全面的自动化测试。另一方面，他们无法避免一个大型团队在单个单体应用程序上工作的问题。他们也无法解决日益过时的技术堆栈问题。团队所能做的最好的事情就是推迟不可避免的事情。为了逃离单体地狱，他们必须迁移到新的架构：微服务架构。
- en: Today, the growing consensus is that if you’re building a large, complex application,
    you should consider using the microservice architecture. But what are *microservices*
    exactly? Unfortunately, the name doesn’t help because it overemphasizes size.
    There are numerous definitions of the microservice architecture. Some take the
    name too literally and claim that a service should be tiny—for example, 100 LOC.
    Others claim that a service should only take two weeks to develop. Adrian Cockcroft,
    formerly of Netflix, defines a microservice architecture as a service-oriented
    architecture composed of loosely coupled elements that have bounded contexts.
    That’s not a bad definition, but it is a little dense. Let’s see if we can do
    better.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，越来越多的人达成共识，如果你正在构建一个大型、复杂的应用程序，你应该考虑使用微服务架构。但微服务究竟是什么呢？不幸的是，这个名字并没有帮助，因为它过分强调了大小。微服务架构有众多定义。有些人过于字面地理解这个名字，声称服务应该是微小的——例如，100
    行代码。其他人声称服务应该只花两周时间开发。前 Netflix 的阿德里安·科克罗斯（Adrian Cockcroft）将微服务架构定义为由松散耦合的元素组成的面向服务的架构，这些元素具有边界上下文。这不是一个坏的定义，但它有点复杂。让我们看看我们是否能做得更好。
- en: 1.4.1\. Scale cube and microservices
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.4.1. 规模立方体和微服务
- en: 'My definition of the microservice architecture is inspired by Martin Abbott
    and Michael Fisher’s excellent book, *The Art of Scalability* (Addison-Wesley,
    2015). This book describes a useful, three-dimensional scalability model: the
    *scale cube*, shown in [figure 1.3](#ch01fig03).'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我对微服务架构的定义受到了马丁·艾布特（Martin Abbott）和迈克尔·费舍尔（Michael Fisher）的优秀著作《扩展的艺术》（The Art
    of Scalability，Addison-Wesley，2015）的启发。这本书描述了一个有用的三维扩展模型：*规模立方体*，如图 1.3 所示。
- en: 'Figure 1.3\. The scale cube defines three separate ways to scale an application:
    X-axis scaling load balances requests across multiple, identical instances; Z-axis
    scaling routes requests based on an attribute of the request; Y-axis functionally
    decomposes an application into services.'
  id: totrans-84
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.3\. 规模立方体定义了三种独立的应用程序扩展方法：X 轴扩展在多个相同实例之间平衡请求；Z 轴扩展根据请求的属性路由请求；Y 轴在功能上将应用程序分解为服务。
- en: '![](Images/01fig03_alt.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/01fig03_alt.jpg)'
- en: 'The model defines three ways to scale an application: X, Y, and Z.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 该模型定义了三种扩展应用程序的方法：X、Y 和 Z。
- en: X-axis scaling load balances requests across multiple instances
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: X 轴扩展通过负载均衡器在多个实例之间平衡请求
- en: '*X-axis* scaling is a common way to scale a monolithic application. [Figure
    1.4](#ch01fig04) shows how X-axis scaling works. You run multiple instances of
    the application behind a load balancer. The load balancer distributes requests
    among the *N* identical instances of the application. This is a great way of improving
    the capacity and availability of an application.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*X 轴* 扩展是扩展单体应用程序的常见方法。[图 1.4](#ch01fig04) 展示了 X 轴扩展的工作原理。你运行多个应用程序实例，并在负载均衡器后面。负载均衡器将请求分配给应用程序的
    *N* 个相同实例。这是一种提高应用程序容量和可用性的极好方法。'
- en: Figure 1.4\. X-axis scaling runs multiple, identical instances of the monolithic
    application behind a load balancer.
  id: totrans-89
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.4\. X 轴扩展在负载均衡器后面运行单体应用程序的多个、相同实例。
- en: '![](Images/01fig04_alt.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/01fig04_alt.jpg)'
- en: Z-axis scaling routes requests based on an attribute of the request
  id: totrans-91
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Z 轴扩展根据请求的属性路由请求
- en: '*Z-axis* scaling also runs multiple instances of the monolith application,
    but unlike X-axis scaling, each instance is responsible for only a subset of the
    data. [Figure 1.5](#ch01fig05) shows how Z-axis scaling works. The router in front
    of the instances uses a request attribute to route it to the appropriate instance.
    An application might, for example, route requests using `userId`.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*Z-axis* 缩放也会运行单体应用的多个实例，但与 X-axis 缩放不同，每个实例只负责数据的一个子集。[图 1.5](#ch01fig05)
    展示了 Z-axis 缩放的工作原理。实例前面的路由器使用请求属性将其路由到适当的实例。例如，一个应用程序可能会使用 `userId` 来路由请求。'
- en: Figure 1.5\. Z-axis scaling runs multiple identical instances of the monolithic
    application behind a router, which routes based on a `request` attribute. Each
    instance is responsible for a subset of the data.
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.5\. Z-axis 缩放在路由器后面运行单体应用程序的多个相同实例，路由器根据 `request` 属性进行路由。每个实例只负责数据的一个子集。
- en: '![](Images/01fig05_alt.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/01fig05_alt.jpg)'
- en: In this example, each application instance is responsible for a subset of users.
    The router uses the `userId` specified by the request `Authorization` header to
    select one of the *N* identical instances of the application. Z-axis scaling is
    a great way to scale an application to handle increasing transaction and data
    volumes.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，每个应用程序实例只负责用户的一个子集。路由器使用请求 `Authorization` 标头中指定的 `userId` 来选择应用程序的 *N*
    个相同实例中的一个。Z-axis 缩放是扩展应用程序以处理增加的交易和数据量的绝佳方式。
- en: Y-axis scaling functionally decomposes an application into services
  id: totrans-96
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Y-axis 缩放在功能上将应用程序分解为服务
- en: 'X- and Z-axis scaling improve the application’s capacity and availability.
    But neither approach solves the problem of increasing development and application
    complexity. To solve those, you need to apply *Y-axis* scaling, or *functional
    decomposition*. [Figure 1.6](#ch01fig06) shows how Y-axis scaling works: by splitting
    a monolithic application into a set of services.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: X-和 Z-axis 缩放提高了应用程序的容量和可用性。但这两种方法都不能解决开发和应用复杂性增加的问题。要解决这些问题，你需要应用 *Y-axis*
    缩放，或 *功能分解*。[图 1.6](#ch01fig06) 展示了 Y-axis 缩放的工作原理：通过将单体应用程序拆分为一组服务。
- en: Figure 1.6\. Y-axis scaling splits the application into a set of services. Each
    service is responsible for a particular function. A service is scaled using X-axis
    scaling and, possibly, Z-axis scaling.
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.6\. Y-axis 缩放将应用程序拆分为一组服务。每个服务负责特定的功能。服务使用 X-axis 缩放进行扩展，并且可能还使用 Z-axis
    缩放。
- en: '![](Images/01fig06_alt.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/01fig06_alt.jpg)'
- en: A *service* is a mini application that implements narrowly focused functionality,
    such as order management, customer management, and so on. A service is scaled
    using X-axis scaling, though some services may also use Z-axis scaling. For example,
    the Order service consists of a set of load-balanced service instances.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*服务* 是一个实现狭窄关注功能的迷你应用程序，例如订单管理、客户管理等。服务使用 X-axis 缩放进行扩展，尽管一些服务也可能使用 Z-axis
    缩放。例如，订单服务由一组负载均衡的服务实例组成。'
- en: The high-level definition of microservice architecture (microservices) is an
    architectural style that functionally decomposes an application into a set of
    services. Note that this definition doesn’t say anything about size. Instead,
    what matters is that each service has a focused, cohesive set of responsibilities.
    Later in the book I discuss what that means.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构（微服务）的高级定义是一种将应用程序功能分解成一组服务的架构风格。请注意，这个定义并没有说任何关于大小的事情。相反，重要的是每个服务都有一组专注且连贯的责任。在本书的后面部分，我将讨论这意味着什么。
- en: Now let’s look at how the microservice architecture is a form of modularity.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看微服务架构是如何成为模块化的一种形式的。
- en: 1.4.2\. Microservices as a form of modularity
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.4.2\. 微服务作为模块化的一种形式
- en: '*Modularity* is essential when developing large, complex applications. A modern
    application like FTGO is too large to be developed by an individual. It’s also
    too complex to be understood by a single person. Applications must be decomposed
    into modules that are developed and understood by different people. In a monolithic
    application, modules are defined using a combination of programming language constructs
    (such as Java packages) and build artifacts (such as Java JAR files). However,
    as the FTGO developers have discovered, this approach tends not to work well in
    practice. Long-lived, monolithic applications usually degenerate into big balls
    of mud.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*模块化*在开发大型、复杂应用程序时至关重要。像FTGO这样的现代应用程序太大，无法由个人开发。它也太复杂，无法由单一个人理解。应用程序必须分解成由不同的人开发和理解的模块。在单体应用程序中，模块是通过编程语言构造（如Java包）和构建工件（如Java
    JAR文件）的组合来定义的。然而，正如FTGO开发者所发现的那样，这种方法在实践中往往效果不佳。长期存在的单体应用程序通常会退化成大泥球。'
- en: The microservice architecture uses services as the unit of modularity. A service
    has an API, which is an impermeable boundary that is difficult to violate. You
    can’t bypass the API and access an internal class as you can with a Java package.
    As a result, it’s much easier to preserve the modularity of the application over
    time. There are other benefits of using services as building blocks, including
    the ability to deploy and scale them independently.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构使用服务作为模块化的单元。一个服务有一个API，这是一个难以违反的不透水边界。你不能像使用Java包那样绕过API访问内部类。因此，随着时间的推移，更容易保持应用程序的模块化。使用服务作为构建块还有其他好处，包括能够独立部署和扩展它们。
- en: 1.4.3\. Each service has its own database
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.4.3\. 每个服务都有自己的数据库
- en: A key characteristic of the microservice architecture is that the services are
    loosely coupled and communicate only via APIs. One way to achieve loose coupling
    is by each service having its own datastore. In the online store, for example,
    `Order Service` has a database that includes the `ORDERS` table, and `Customer
    Service` has its database, which includes the `CUSTOMERS` table. At development
    time, developers can change a service’s schema without having to coordinate with
    developers working on other services. At runtime, the services are isolated from
    each other—for example, one service will never be blocked because another service
    holds a database lock.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构的一个关键特征是服务之间松散耦合，并且仅通过API进行通信。实现松散耦合的一种方式是每个服务都有自己的数据存储。例如，在在线商店中，`订单服务`有一个包含`ORDERS`表的数据库，而`客户服务`有自己的数据库，其中包含`CUSTOMERS`表。在开发时，开发者可以更改服务的模式，而无需与其他服务的开发者协调。在运行时，服务之间是隔离的——例如，一个服务永远不会因为另一个服务持有数据库锁而被阻塞。
- en: '|  |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Don’t worry: Loose coupling doesn’t make Larry Ellison richer**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**不要担心：松散耦合不会让拉里·埃里森更富有**'
- en: The requirement for each service to have its own database doesn’t mean it has
    its own database server. You don’t, for example, have to spend 10 times more on
    Oracle RDBMS licenses. [Chapter 2](kindle_split_010.xhtml#ch02) explores this
    topic in depth.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 每个服务需要有自己的数据库的要求并不意味着它有自己的数据库服务器。例如，你不必在Oracle RDBMS许可证上花费10倍的费用。[第2章](kindle_split_010.xhtml#ch02)深入探讨了这一主题。
- en: '|  |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Now that we’ve defined the microservice architecture and described some of its
    essential characteristics, let’s look at how this applies to the FTGO application.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了微服务架构并描述了其一些基本特征，让我们看看这如何应用于FTGO应用程序。
- en: 1.4.4\. The FTGO microservice architecture
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.4.4\. FTGO微服务架构
- en: The rest of this book discusses the FTGO application’s microservice architecture
    in depth. But first let’s quickly look at what it means to apply Y-axis scaling
    to this application. If we apply Y-axis decomposition to the FTGO application,
    we get the architecture shown in [figure 1.7](#ch01fig07). The decomposed application
    consists of numerous frontend and backend services. We would also apply X-axis
    and, possibly Z-axis scaling, so that at runtime there would be multiple instances
    of each service.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 本书剩余部分将深入讨论FTGO应用程序的微服务架构。但首先让我们快速看一下将Y轴扩展应用于此应用程序意味着什么。如果我们对FTGO应用程序应用Y轴分解，我们得到[图1.7](#ch01fig07)所示的架构。分解后的应用程序由众多前端和后端服务组成。我们还会应用X轴和可能的Z轴扩展，以便在运行时每个服务都会有多个实例。
- en: Figure 1.7\. Some of the services of the microservice architecture-based version
    of the FTGO application. An API Gateway routes requests from the mobile applications
    to services. The services collaborate via APIs.
  id: totrans-115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.7. 基于微服务架构的FTGO应用程序的一些服务。API网关将来自移动应用程序的请求路由到服务。服务通过API进行协作。
- en: '![](Images/01fig07_alt.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/01fig07_alt.jpg)'
- en: The frontend services include an API gateway and the Restaurant Web UI. The
    API gateway, which plays the role of a facade and is described in detail in [chapter
    8](kindle_split_016.xhtml#ch08), provides the REST APIs that are used by the consumers’
    and couriers’ mobile applications. The Restaurant Web UI implements the web interface
    that’s used by the restaurants to manage menus and process orders.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 前端服务包括API网关和餐厅Web UI。API网关扮演门面角色，在[第8章](kindle_split_016.xhtml#ch08)中详细描述，为消费者和快递员的移动应用程序提供REST
    API。餐厅Web UI实现了餐厅用于管理菜单和处理订单的Web界面。
- en: 'The FTGO application’s business logic consists of numerous backend services.
    Each backend service has a REST API and its own private datastore. The backend
    services include the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: FTGO应用程序的业务逻辑由多个后端服务组成。每个后端服务都有一个REST API和自己的私有数据存储。后端服务包括以下内容：
- en: '**`Order Service`—** Manages orders'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`订单服务`—** 管理订单'
- en: '**`Delivery Service`—** Manages delivery of orders from restaurants to consumers'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`配送服务`—** 管理从餐厅到消费者的订单配送'
- en: '**`Restaurant Service`—** Maintains information about restaurants'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`餐厅服务`—** 维护餐厅信息'
- en: '**`Kitchen Service`—** Manages the preparation of orders'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`厨房服务`—** 管理订单的准备'
- en: '**`Accounting Service`—** Handles billing and payments'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`会计服务`—** 处理账单和支付'
- en: Many services correspond to the modules described earlier in this chapter. What’s
    different is that each service and its API are very clearly defined. Each one
    can be independently developed, tested, deployed, and scaled. Also, this architecture
    does a good job of preserving modularity. A developer can’t bypass a service’s
    API and access its internal components. [Chapter 13](kindle_split_021.xhtml#ch13)
    describes how to transform an existing monolithic application into microservices.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 许多服务对应于本章前面描述的模块。不同之处在于每个服务及其API都定义得非常清晰。每个服务都可以独立开发、测试、部署和扩展。此外，这种架构很好地保持了模块化。开发者不能绕过服务的API来访问其内部组件。[第13章](kindle_split_021.xhtml#ch13)描述了如何将现有的单体应用程序转换为微服务。
- en: 1.4.5\. Comparing the microservice architecture and SOA
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.4.5. 比较微服务架构和SOA
- en: Some critics of the microservice architecture claim it’s nothing new—it’s service-oriented
    architecture (SOA). At a very high level, there are some similarities. SOA and
    the microservice architecture are architectural styles that structure a system
    as a set of services. But as [table 1.1](#ch01table01) shows, once you dig deep,
    you encounter significant differences.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一些微服务架构的批评者声称这并不是什么新东西——它是面向服务的架构（SOA）。在非常高的层面上，有一些相似之处。SOA和微服务架构都是将系统结构化为服务集的架构风格。但正如[表1.1](#ch01table01)所示，一旦深入挖掘，就会遇到显著的不同。
- en: Table 1.1\. Comparing SOA with microservices
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表1.1. 比较SOA与微服务
- en: '|   | SOA | Microservices |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '|   | SOA | 微服务 |'
- en: '| --- | --- | --- |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Inter-service communication | Smart pipes, such as Enterprise Service Bus,
    using heavyweight protocols, such as SOAP and the other WS* standards. | Dumb
    pipes, such as a message broker, or direct service-to-service communication, using
    lightweight protocols such as REST or gRPC |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 服务间通信 | 使用重量级协议，如企业服务总线（ESB）的智能管道。 | 使用轻量级协议，如REST或gRPC的消息代理或直接服务到服务的通信的哑管道
    |'
- en: '| Data | Global data model and shared databases | Data model and database per
    service |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 数据 | 全局数据模型和共享数据库 | 每个服务的独立数据模型和数据库 |'
- en: '| Typical service | Larger monolithic application | Smaller service |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 典型服务 | 较大的单体应用程序 | 较小的服务 |'
- en: SOA and the microservice architecture usually use different technology stacks.
    SOA applications typically use heavyweight technologies such as SOAP and other
    WS* standards. They often use an ESB, a *smart pipe* that contains business and
    message-processing logic to integrate the services. Applications built using the
    microservice architecture tend to use lightweight, open source technologies. The
    services communicate via *dumb pipes*, such as message brokers or lightweight
    protocols like REST or gRPC.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: SOA 和微服务架构通常使用不同的技术栈。SOA 应用通常使用重量级技术，如SOAP和其他WS*标准。它们经常使用ESB，一种包含业务和消息处理逻辑的*智能管道*来集成服务。使用微服务架构构建的应用程序倾向于使用轻量级、开源技术。服务通过*哑管道*进行通信，例如消息代理或轻量级协议如REST或gRPC。
- en: SOA and the microservice architecture also differ in how they treat data. SOA
    applications typically have a global data model and share databases. In contrast,
    as mentioned earlier, in the microservice architecture each service has its own
    database. Moreover, as described in [chapter 2](kindle_split_010.xhtml#ch02),
    each service is usually considered to have its own domain model.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: SOA 和微服务架构在处理数据的方式上也存在差异。SOA 应用通常具有全局数据模型并共享数据库。相比之下，如前所述，在微服务架构中，每个服务都有自己的数据库。此外，正如[第2章](kindle_split_010.xhtml#ch02)所述，每个服务通常被认为有自己的领域模型。
- en: Another key difference between SOA and the microservice architecture is the
    size of the services. SOA is typically used to integrate large, complex, monolithic
    applications. Although services in a microservice architecture aren’t always tiny,
    they’re almost always much smaller. As a result, a SOA application usually consists
    of a few large services, whereas a microservices-based application typically consists
    of dozens or hundreds of smaller services.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: SOA 和微服务架构之间的另一个关键区别是服务的大小。SOA 通常用于集成大型、复杂、单体应用程序。尽管微服务架构中的服务并不总是微小的，但它们几乎总是比SOA中的服务小得多。因此，SOA
    应用通常由几个大型服务组成，而基于微服务的应用程序通常由数十或数百个较小的服务组成。
- en: 1.5\. Benefits and drawbacks of the microservice architecture
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.5\. 微服务架构的优点和缺点
- en: Let’s first consider the benefits and then we’ll look at the drawbacks.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先考虑其优点，然后再看看其缺点。
- en: 1.5.1\. Benefits of the microservice architecture
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.5.1\. 微服务架构的优点
- en: 'The microservice architecture has the following benefits:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构有以下优点：
- en: It enables the continuous delivery and deployment of large, complex applications.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使得大型、复杂的应用程序能够持续交付和部署。
- en: Services are small and easily maintained.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务规模小且易于维护。
- en: Services are independently deployable.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务可以独立部署。
- en: Services are independently scalable.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务可以独立扩展。
- en: The microservice architecture enables teams to be autonomous.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务架构使团队能够实现自治。
- en: It allows easy experimenting and adoption of new technologies.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许轻松实验和采用新技术。
- en: It has better fault isolation.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它具有更好的故障隔离性。
- en: Let’s look at each benefit.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看每个优点。
- en: Enables the continuous delivery and deployment of large, complex applications
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使大型、复杂的应用程序能够持续交付和部署
- en: The most important benefit of the microservice architecture is that it enables
    continuous delivery and deployment of large, complex applications. As described
    later in [section 1.7](#ch01lev1sec7), continuous delivery/deployment is part
    of *DevOps*, a set of practices for the rapid, frequent, and reliable delivery
    of software. High-performing DevOps organizations typically deploy changes into
    production with very few production issues.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构最重要的好处是它使得大型、复杂的应用程序能够持续交付和部署。如后文[1.7节](#ch01lev1sec7)所述，持续交付/部署是*DevOps*的一部分，是一套旨在快速、频繁且可靠地交付软件的实践。表现优异的DevOps组织通常在生产中部署更改时遇到的生产问题非常少。
- en: 'There are three ways that the microservice architecture enables continuous
    delivery/deployment:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构实现持续交付/部署的三个方式如下：
- en: '***It has the testability required by continuous delivery/deployment*—** Automated
    testing is a key practice of continuous delivery/deployment. Because each service
    in a microservice architecture is relatively small, automated tests are much easier
    to write and faster to execute. As a result, the application will have fewer bugs.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***它具有持续交付/部署所需的可测试性——** 自动化测试是持续交付/部署的关键实践。由于微服务架构中的每个服务相对较小，自动化测试编写起来更容易，执行速度更快。因此，应用程序将具有更少的错误。'
- en: '***It has the deployability required by continuous delivery/deployment*—**
    Each service can be deployed independently of other services. If the developers
    responsible for a service need to deploy a change that’s local to that service,
    they don’t need to coordinate with other developers. They can deploy their changes.
    As a result, it’s much easier to deploy changes frequently into production.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***它具有持续交付/部署所需的部署能力**——**每个服务可以独立于其他服务进行部署。如果负责某个服务的开发者需要部署针对该服务的本地更改，他们不需要与其他开发者协调。他们可以部署他们的更改。因此，将更改频繁部署到生产中要容易得多。'
- en: '***It enables development teams to be autonomous and loosely coupled*—** You
    can structure the engineering organization as a collection of small (for example,
    two-pizza) teams. Each team is solely responsible for the development and deployment
    of one or more related services. As [figure 1.8](#ch01fig08) shows, each team
    can develop, deploy, and scale their services independently of all the other teams.
    As a result, the development velocity is much higher.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***它使开发团队能够实现自治和松散耦合**——**你可以将工程组织结构构建为一系列小型团队（例如，两个披萨大小的团队）。每个团队仅负责一个或多个相关服务的开发和部署。如图1.8所示，每个团队可以独立于其他团队开发、部署和扩展他们的服务。因此，开发速度要高得多。'
- en: Figure 1.8\. The microservices-based FTGO application consists of a set of loosely
    coupled services. Each team develops, tests, and deploys their services independently.
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.8。基于微服务的FTGO应用程序由一系列松散耦合的服务组成。每个团队独立开发、测试和部署他们的服务。
- en: '![](Images/01fig08_alt.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/01fig08_alt.jpg)'
- en: 'The ability to do continuous delivery and deployment has several business benefits:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 能够进行持续交付和部署具有以下几项商业优势：
- en: It reduces the time to market, which enables the business to rapidly react to
    feedback from customers.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它缩短了上市时间，使企业能够快速响应客户的反馈。
- en: It enables the business to provide the kind of reliable service today’s customers
    have come to expect.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使企业能够提供今天客户期望的可靠服务。
- en: Employee satisfaction is higher because more time is spent delivering valuable
    features instead of fighting fires.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于更多时间用于交付有价值的功能而不是灭火，员工满意度更高。
- en: As a result, the microservice architecture has become the table stakes of any
    business that depends upon software technology.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，微服务架构已成为任何依赖软件技术的企业的基本要求。
- en: Each service is small and easily maintained
  id: totrans-161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 每个服务都是小型且易于维护的
- en: Another benefit of the microservice architecture is that each service is relatively
    small. The code is easier for a developer to understand. The small code base doesn’t
    slow down the IDE, making developers more productive. And each service typically
    starts a lot faster than a large monolith does, which also makes developers more
    productive and speeds up deployments.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构的另一个好处是每个服务相对较小。代码更容易让开发者理解。小型代码库不会减慢集成开发环境（IDE），使开发者更加高效。而且每个服务通常启动得比大型单体应用快得多，这也使得开发者更加高效，并加快了部署速度。
- en: Services are independently scalable
  id: totrans-163
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 服务可以独立扩展
- en: Each service in a microservice architecture can be scaled independently of other
    services using X-axis cloning and Z-axis partitioning. Moreover, each service
    can be deployed on hardware that’s best suited to its resource requirements. This
    is quite different than when using a monolithic architecture, where components
    with wildly different resource requirements—for example, CPU-intensive vs. memory-intensive—must
    be deployed together.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，每个服务都可以使用X轴克隆和Z轴分区独立于其他服务进行扩展。此外，每个服务都可以部署在最适合其资源需求硬件上。这与使用单体架构时大不相同，在单体架构中，具有截然不同资源需求（例如，CPU密集型与内存密集型）的组件必须一起部署。
- en: Better fault isolation
  id: totrans-165
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 更好的故障隔离
- en: The microservice architecture has better fault isolation. For example, a memory
    leak in one service only affects that service. Other services will continue to
    handle requests normally. In comparison, one misbehaving component of a monolithic
    architecture will bring down the entire system.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构具有更好的故障隔离。例如，一个服务中的内存泄漏只会影响该服务。其他服务将继续正常处理请求。相比之下，单体架构中一个行为异常的组件可能会使整个系统崩溃。
- en: Easily experiment with and adopt new technologies
  id: totrans-167
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 轻松实验和采用新技术
- en: Last but not least, the microservice architecture eliminates any long-term commitment
    to a technology stack. In principle, when developing a new service, the developers
    are free to pick whatever language and frameworks are best suited for that service.
    In many organizations, it makes sense to restrict the choices, but the key point
    is that you aren’t constrained by past decisions.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，微服务架构消除了对技术栈的长期承诺。原则上，当开发新服务时，开发者可以自由选择最适合该服务的语言和框架。在许多组织中，限制选择是有意义的，但关键点是你不受过去决策的限制。
- en: Moreover, because the services are small, rewriting them using better languages
    and technologies becomes practical. If the trial of a new technology fails, you
    can throw away that work without risking the entire project. This is quite different
    than when using a monolithic architecture, where your initial technology choices
    severely constrain your ability to use different languages and frameworks in the
    future.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于服务规模较小，使用更好的语言和技术重写它们变得可行。如果新技术的试验失败，你可以丢弃这项工作而不会危及整个项目。这与使用单体架构时大不相同，在单体架构中，你的初始技术选择会严重限制你未来使用不同语言和框架的能力。
- en: 1.5.2\. Drawbacks of the microservice architecture
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.5.2. 微服务架构的缺点
- en: Certainly, no technology is a silver bullet, and the microservice architecture
    has a number of significant drawbacks and issues. Indeed most of this book is
    about how to address these drawbacks and issues. As you read about the challenges,
    don’t worry. Later in this book I describe ways to address them.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，没有哪种技术是万能的，微服务架构有许多显著的缺点和问题。实际上，本书的大部分内容都是关于如何解决这些缺点和问题。当你阅读关于挑战的内容时，不要担心。在这本书的后面部分，我将描述解决这些问题的方法。
- en: 'Here are the major drawbacks and issues of the microservice architecture:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是微服务架构的主要缺点和问题：
- en: Finding the right set of services is challenging.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到合适的服务集是一项挑战。
- en: Distributed systems are complex, which makes development, testing, and deployment
    difficult.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布式系统很复杂，这使得开发、测试和部署变得困难。
- en: Deploying features that span multiple services requires careful coordination.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署跨越多个服务的功能需要仔细的协调。
- en: Deciding when to adopt the microservice architecture is difficult.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决定何时采用微服务架构是困难的。
- en: Let’s look at each one in turn.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一来看。
- en: Finding the right services is challenging
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 找到合适的服务是一项挑战
- en: One challenge with using the microservice architecture is that there isn’t a
    concrete, well-defined algorithm for decomposing a system into services. As with
    much of software development, it’s something of an art. To make matters worse,
    if you decompose a system incorrectly, you’ll build a *distributed monolith*,
    a system consisting of coupled services that must be deployed together. A distributed
    monolith has the drawbacks of both the monolithic architecture and the microservice
    architecture.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用微服务架构的一个挑战是没有一个具体、明确地将系统分解为服务的算法。就像软件开发中的许多事情一样，这更像是一门艺术。更糟糕的是，如果你错误地分解了一个系统，你会构建一个*分布式单体*，这是一个由必须一起部署的耦合服务组成的系统。分布式单体既有单体架构的缺点，也有微服务架构的缺点。
- en: Distributed systems are complex
  id: totrans-180
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 分布式系统很复杂
- en: Another issue with using the microservice architecture is that developers must
    deal with the additional complexity of creating a distributed system. Services
    must use an interprocess communication mechanism. This is more complex than a
    simple method call. Moreover, a service must be designed to handle partial failure
    and deal with the remote service either being unavailable or exhibiting high latency.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用微服务架构的另一个问题是开发者必须处理创建分布式系统带来的额外复杂性。服务必须使用进程间通信机制。这比简单的函数调用要复杂。此外，服务必须设计成能够处理部分故障，并处理远程服务不可用或延迟过高的情况。
- en: Implementing use cases that span multiple services requires the use of unfamiliar
    techniques. Each service has its own database, which makes it a challenge to implement
    transactions and queries that span services. As described in [chapter 4](kindle_split_012.xhtml#ch04),
    a microservices-based application must use what are known as *sagas* to maintain
    data consistency across services. [Chapter 7](kindle_split_015.xhtml#ch07) explains
    that a microservices-based application can’t retrieve data from multiple services
    using simple queries. Instead, it must implement queries using either API composition
    or CQRS views.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 实现跨越多个服务的用例需要使用不熟悉的技巧。每个服务都有自己的数据库，这使得实现跨越服务的交易和查询成为一项挑战。正如[第4章](kindle_split_012.xhtml#ch04)所述，基于微服务的应用程序必须使用所谓的*叙事*来维护服务之间的数据一致性。[第7章](kindle_split_015.xhtml#ch07)解释说，基于微服务的应用程序不能使用简单的查询从多个服务中检索数据。相反，它必须使用API组合或CQRS视图来实现查询。
- en: IDEs and other development tools are focused on building monolithic applications
    and don’t provide explicit support for developing distributed applications. Writing
    automated tests that involve multiple services is challenging. These are all issues
    that are specific to the microservice architecture. Consequently, your organization’s
    developers must have sophisticated software development and delivery skills in
    order to successfully use microservices.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 集成开发环境（IDE）和其他开发工具专注于构建单体应用程序，并且不提供开发分布式应用程序的明确支持。编写涉及多个服务的自动化测试具有挑战性。这些都是特定于微服务架构的问题。因此，您的组织开发人员必须具备复杂的软件开发和交付技能，才能成功使用微服务。
- en: 'The microservice architecture also introduces significant operational complexity.
    Many more moving parts—multiple instances of different types of service—must be
    managed in production. To successfully deploy microservices, you need a high level
    of automation. You must use technologies such as the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构还引入了显著的操作复杂性。在生产中必须管理更多的移动部件——不同类型服务的多个实例。要成功部署微服务，您需要高度的自动化。您必须使用以下技术：
- en: Automated deployment tooling, like Netflix Spinnaker
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动部署工具，例如Netflix Spinnaker
- en: An off-the-shelf PaaS, like Pivotal Cloud Foundry or Red Hat OpenShift
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个现成的PaaS，例如Pivotal Cloud Foundry或Red Hat OpenShift
- en: A Docker orchestration platform, like Docker Swarm or Kubernetes
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Docker编排平台，例如Docker Swarm或Kubernetes
- en: I describe the deployment options in more detail in [chapter 12](kindle_split_020.xhtml#ch12).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[第12章](kindle_split_020.xhtml#ch12)中更详细地描述了部署选项。
- en: Deploying features spanning multiple services needs careful coordination
  id: totrans-189
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 部署跨越多个服务的功能需要仔细协调
- en: Another challenge with using the microservice architecture is that deploying
    features that span multiple services requires careful coordination between the
    various development teams. You have to create a rollout plan that orders service
    deployments based on the dependencies between services. That’s quite different
    than a monolithic architecture, where you can easily deploy updates to multiple
    components atomically.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 使用微服务架构的另一个挑战是，部署跨越多个服务的功能需要在各个开发团队之间进行仔细的协调。您必须创建一个部署计划，该计划根据服务之间的依赖关系对服务部署进行排序。这与单体架构大不相同，在单体架构中，您可以轻松原子性地部署多个组件的更新。
- en: Deciding when to adopt is difficult
  id: totrans-191
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 决定何时采用是困难的
- en: Another issue with using the microservice architecture is deciding at what point
    during the lifecycle of the application you should use this architecture. When
    developing the first version of an application, you often don’t have the problems
    that this architecture solves. Moreover, using an elaborate, distributed architecture
    will slow down development. That can be a major dilemma for startups, where the
    biggest problem is usually how to rapidly evolve the business model and accompanying
    application. Using the microservice architecture makes it much more difficult
    to iterate rapidly. A startup should almost certainly begin with a monolithic
    application.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 使用微服务架构的另一个问题是确定在应用程序的生命周期中何时应该使用这种架构。在开发应用程序的第一个版本时，您通常不会遇到这种架构解决的问题。此外，使用复杂的分布式架构会减慢开发速度。这对初创公司来说可能是一个重大的困境，因为最大的问题通常是如何快速演变商业模式和相应的应用程序。使用微服务架构会使快速迭代变得更加困难。初创公司几乎肯定应该从单体应用程序开始。
- en: Later on, though, when the problem is how to handle complexity, that’s when
    it makes sense to functionally decompose the application into a set of microservices.
    You may find refactoring difficult because of tangled dependencies. [Chapter 13](kindle_split_021.xhtml#ch13)
    goes over strategies for refactoring a monolithic application into microservices.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，后来当问题是如何处理复杂性时，那时将应用程序功能分解成一组微服务是有意义的。您可能会发现由于复杂的依赖关系而难以重构。[第13章](kindle_split_021.xhtml#ch13)介绍了将单体应用重构为微服务的方法。
- en: As you can see, the microservice architecture offer many benefits, but also
    has some significant drawbacks. Because of these issues, adopting a microservice
    architecture should not be undertaken lightly. But for complex applications, such
    as a consumer-facing web application or SaaS application, it’s usually the right
    choice. Well-known sites like eBay ([www.slideshare.net/RandyShoup/the-ebay-architecture-striking-a-balance-between-site-stability-feature-velocity-performance-and-cost](http://www.slideshare.net/RandyShoup/the-ebay-architecture-striking-a-balance-between-site-stability-feature-velocity-performance-and-cost)),
    Amazon.com, Groupon, and Gilt have all evolved from a monolithic architecture
    to a microservice architecture.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，微服务架构提供了许多好处，但也存在一些显著的缺点。正因为这些问题，采用微服务架构不应轻率行事。但对于面向消费者的Web应用或SaaS应用等复杂应用来说，这通常是一个正确的选择。像eBay([www.slideshare.net/RandyShoup/the-ebay-architecture-striking-a-balance-between-site-stability-feature-velocity-performance-and-cost](http://www.slideshare.net/RandyShoup/the-ebay-architecture-striking-a-balance-between-site-stability-feature-velocity-performance-and-cost))、Amazon.com、Groupon和Gilt等知名网站都已经从单体架构演变为微服务架构。
- en: You must address numerous design and architectural issues when using the microservice
    architecture. What’s more, many of these issues have multiple solutions, each
    with a different set of trade-offs. There is no one single perfect solution. To
    help guide your decision making, I’ve created the Microservice architecture pattern
    language. I reference this pattern language throughout the rest of the book as
    I teach you about the microservice architecture. Let’s look at what a pattern
    language is and why it’s helpful.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用微服务架构时，您必须解决许多设计和架构问题。更重要的是，许多这些问题都有多个解决方案，每个解决方案都有一套不同的权衡。没有一种单一的完美解决方案。为了帮助您做出决策，我创建了微服务架构模式语言。我在本书的其余部分引用这个模式语言，向您介绍微服务架构。让我们看看模式语言是什么以及为什么它有帮助。
- en: 1.6\. The Microservice architecture pattern language
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.6. 微服务架构模式语言
- en: Architecture and design are all about making decisions. You need to decide whether
    the monolithic or microservice architecture is the best fit for your application.
    When making these decisions you have lots of trade-offs to consider. If you pick
    the microservice architecture, you’ll need to address lots of issues.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 架构和设计都是关于做决定。您需要决定单体架构或微服务架构最适合您的应用。在做出这些决定时，您需要考虑许多权衡。如果您选择微服务架构，您将需要解决许多问题。
- en: A good way to describe the various architectural and design options and improve
    decision making is to use a pattern language. Let’s first look at why we need
    patterns and a pattern language, and then we’ll take a tour of the Microservice
    architecture pattern language.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 描述各种架构和设计选项并提高决策质量的一个好方法是使用模式语言。让我们首先看看为什么我们需要模式和模式语言，然后我们将游览微服务架构模式语言。
- en: 1.6.1\. Microservice architecture is not a silver bullet
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.6.1. 微服务架构并非万能药
- en: Back in 1986, Fred Brooks, author of *The Mythical Man-Month* (Addison-Wesley
    Professional, 1995), said that in software engineering, there are no silver bullets.
    That means there are no techniques or technologies that if adopted would give
    you a tenfold boost in productivity. Yet decades years later, developers are still
    arguing passionately about their favorite silver bullets, absolutely convinced
    that their favorite technology will give them a massive boost in productivity.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 回到1986年，*《人月神话》*（Addison-Wesley Professional，1995年）的作者Fred Brooks说，在软件工程中，没有万能药。这意味着没有技术或技术如果采用就会给您带来十倍的生产力提升。然而，几十年后，开发者们仍然激烈地争论他们最喜欢的万能药，坚信他们最喜欢的技术将给他们带来巨大的生产力提升。
- en: 'A lot of arguments follow the *suck/rock dichotomy* ([http://nealford.com/memeagora/2009/08/05/suck-rock-dichotomy.html](http://nealford.com/memeagora/2009/08/05/suck-rock-dichotomy.html)),
    a term coined by Neal Ford that describes how everything in the software world
    either sucks or rocks, with no middle ground. These arguments have this structure:
    if you do X, then a puppy will die, so therefore you must do Y. For example, synchronous
    versus reactive programming, object-oriented versus functional, Java versus JavaScript,
    REST versus messaging. Of course, reality is much more nuanced. Every technology
    has drawbacks and limitations that are often overlooked by its advocates. As a
    result, the adoption of a technology usually follows the *Gartner hype cycle*
    ([https://en.wikipedia.org/wiki/Hype_cycle](https://en.wikipedia.org/wiki/Hype_cycle)),
    in which an emerging technology goes through five phases, including the *peak
    of inflated expectations* (it rocks), followed by the *trough of disillusionment*
    (it sucks), and ending with the *plateau of productivity* (we now understand the
    trade-offs and when to use it).'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 许多争论遵循*好/坏二分法*（[http://nealford.com/memeagora/2009/08/05/suck-rock-dichotomy.html](http://nealford.com/memeagora/2009/08/05/suck-rock-dichotomy.html)），这是尼尔·福特创造的术语，用来描述软件世界中的每一件事要么很糟糕要么很棒，没有中间地带。这些争论具有以下结构：如果你做X，那么一只小狗会死，所以你必须做Y。例如，同步编程与反应式编程，面向对象与函数式，Java与JavaScript，REST与消息传递。当然，现实要复杂得多。每种技术都有其倡导者经常忽视的缺点和局限性。因此，技术的采用通常遵循*Gartner炒作周期*（[https://en.wikipedia.org/wiki/Hype_cycle](https://en.wikipedia.org/wiki/Hype_cycle)），其中一种新兴技术要经历五个阶段，包括*期望过高的顶峰*（它很棒），接着是*幻灭的低谷*（它很糟糕），最后是*生产力的平台期*（我们现在理解了权衡和何时使用它）。
- en: Microservices are not immune to the silver bullet phenomenon. Whether this architecture
    is appropriate for your application depends on many factors. Consequently, it’s
    bad advice to advise always using the microservice architecture, but it’s equally
    bad advice to advise never using it. As with many things, it depends.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务并非对银弹现象免疫。这种架构是否适合你的应用程序取决于许多因素。因此，总是建议使用微服务架构是不良的建议，但同样，不建议永远不使用它。就像许多事情一样，这取决于具体情况。
- en: 'The underlying reason for these polarized and hyped arguments about technology
    is that humans are primarily driven by their emotions. Jonathan Haidt, in his
    excellent book *The Righteous Mind: Why Good People Are Divided by Politics and
    Religion* (Vintage, 2013), uses the metaphor of an elephant and its rider to describe
    how the human mind works. The elephant represents the emotion part of the human
    brain. It makes most of the decisions. The rider represents the rational part
    of the brain. It can sometimes influence the elephant, but it mostly provides
    justifications for the elephant’s decisions.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这些关于技术的极端和夸张争论的潜在原因是人类主要受情感驱动。乔纳森·海蒂在他的优秀著作《正义之心：为什么好人会被政治和宗教分裂》（Vintage，2013年）中，用大象和骑手的比喻来描述人类思维的工作方式。大象代表人类大脑的情感部分。它做出了大部分决定。骑手代表大脑的理性部分。它有时可以影响大象，但大多数时候只是为大象的决定提供正当理由。
- en: We—the software development community—need to overcome our emotional nature
    and find a better way of discussing and applying technology. A great way to discuss
    and describe technology is to use the *pattern* format, because it’s objective.
    When describing a technology in the pattern format, you must, for example, describe
    the drawbacks. Let’s take a look at the pattern format.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们——软件开发社区——需要克服我们的情感天性，找到更好的讨论和应用技术的方法。讨论和描述技术的一个好方法是使用*模式*格式，因为它客观。例如，在模式格式中描述一项技术时，你必须描述其缺点。让我们看看模式格式。
- en: 1.6.2\. Patterns and pattern languages
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.6.2. 模式和模式语言
- en: 'A *pattern* is a reusable solution to a problem that occurs in a particular
    context. It’s an idea that has its origins in real-world architecture and that
    has proven to be useful in software architecture and design. The concept of a
    pattern was created by Christopher Alexander, a real-world architect. He also
    created the concept of a *pattern language*, a collection of related patterns
    that solve problems within a particular domain. His book *A Pattern Language:
    Towns, Buildings, Construction* (Oxford University Press, 1977) describes a pattern
    language for architecture that consists of 253 patterns. The patterns range from
    solutions to high-level problems, such as where to locate a city (“Access to water”),
    to low-level problems, such as how to design a room (“Light on two sides of every
    room”). Each of these patterns solves a problem by arranging physical objects
    that range in scope from cities to windows.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**模式**是针对特定情境中出现的问题的可重用解决方案。它是一个源于现实世界建筑的思想，并在软件架构和设计中被证明是有用的。模式的概念是由现实世界建筑师克里斯托弗·亚历山大提出的。他还创造了**模式语言**的概念，这是一组相关的模式，用于解决特定领域内的问题。他的著作《模式语言：城镇、建筑、建造》（牛津大学出版社，1977年）描述了一种建筑模式语言，包含253个模式。这些模式从解决高层次问题，如城市的位置（“水源接入”），到解决低层次问题，如如何设计房间（“每个房间两面都有光”）。每个模式通过安排从城市到窗户等不同范围的物理对象来解决问题。'
- en: 'Christopher Alexander’s writings inspired the software community to adopt the
    concept of patterns and pattern languages. The book *Design Patterns: Elements
    of Reusable Object-Oriented Software* (Addison-Wesley Professional, 1994), by
    Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides is a collection of
    object-oriented design patterns. The book popularized patterns among software
    developers. Since the mid-1990s, software developers have documented numerous
    software patterns. A *software pattern* solves a software architecture or design
    problem by defining a set of collaborating software elements.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 克里斯托弗·亚历山大的著作启发了软件社区采用模式及其模式语言的概念。《设计模式：可复用面向对象软件元素》（Addison-Wesley Professional，1994年），由Erich
    Gamma、Richard Helm、Ralph Johnson和John Vlissides所著，是一本面向对象设计模式的集合。这本书在软件开发者中普及了模式。自1995年代中期以来，软件开发者已经记录了大量的软件模式。**软件模式**通过定义一组协作的软件元素来解决软件架构或设计问题。
- en: 'Let’s imagine, for example, that you’re building a banking application that
    must support a variety of overdraft policies. Each policy defines limits on the
    balance of an account and the fees charged for an overdrawn account. You can solve
    this problem using the Strategy pattern, which is a well-known pattern from the
    classic *Design Patterns* book. The solution defined by the Strategy pattern consists
    of three parts:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们想象你正在构建一个必须支持各种透支政策的银行应用程序。每个政策定义了账户余额的限制以及透支账户的收费。你可以使用策略模式解决这个问题，这是经典《设计模式》书中一个众所周知的设计模式。策略模式定义的解决方案由三个部分组成：
- en: A strategy interface called `Overdraft` that encapsulates the overdraft algorithm
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`Overdraft`的策略接口，它封装了透支算法
- en: One or more concrete strategy classes, one for each particular context
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个或多个具体的策略类，每个类对应一个特定的情境
- en: The `Account` class that uses the algorithm
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用算法的`Account`类
- en: The Strategy pattern is an *object-oriented* design pattern, so the elements
    of the solution are classes. Later in this section, I describe *high-level* design
    patterns, where the solution consists of collaborating services.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式是一种**面向对象**的设计模式，因此解决方案的元素是类。在本节的后半部分，我将描述**高级**设计模式，其中解决方案由协作服务组成。
- en: One reason why patterns are valuable is because a pattern must describe the
    context within which it applies. The idea that a solution is specific to a particular
    context and might not work well in other contexts is an improvement over how technology
    used to typically be discussed. For example, a solution that solves the problem
    at the scale of Netflix might not be the best approach for an application with
    fewer users.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 模式有价值的一个原因是，模式必须描述其应用的上下文。一个解决方案是特定于某个特定上下文，可能在其他上下文中效果不佳的想法，是技术通常讨论方式的一种改进。例如，解决Netflix规模问题的解决方案可能不适合用户较少的应用程序。
- en: 'The value of a pattern, however, goes far beyond requiring you to consider
    the context of a problem. It forces you to describe other critical yet frequently
    overlooked aspects of a solution. A commonly used pattern structure includes three
    especially valuable sections:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，模式的价值远远超出了要求你考虑问题情境的需要。它迫使你描述其他关键但经常被忽视的解决方案方面。常用的模式结构包括三个特别有价值的部分：
- en: Forces
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 力量
- en: Resulting context
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果情境
- en: Related patterns
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相关模式
- en: Let’s look at each of these, starting with forces.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一查看这些内容，从力量开始。
- en: 'Forces: The issues that you must address when solving a problem'
  id: totrans-219
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 力量：解决问题时必须解决的问题
- en: The *forces* section of a pattern describes the forces (issues) that you must
    address when solving a problem in a given context. Forces can conflict, so it
    might not be possible to solve all of them. Which forces are more important depends
    on the context. You have to prioritize solving some forces over others. For example,
    code must be easy to understand and have good performance. Code written in a reactive
    style has better performance than synchronous code, yet is often more difficult
    to understand. Explicitly listing the forces is useful because it makes clear
    which issues need to be solved.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 模式的“力量”部分描述了在特定情境中解决问题时必须处理的力（问题）。力量可能存在冲突，因此可能无法解决所有问题。哪些力量更重要取决于情境。你必须优先解决某些力量而不是其他力量。例如，代码必须易于理解并且性能良好。以响应式风格编写的代码比同步代码性能更好，但通常更难以理解。明确列出力量是有用的，因为它清楚地表明哪些问题需要解决。
- en: 'Resulting context: The consequences of applying a pattern'
  id: totrans-221
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 结果情境：应用模式的结果
- en: 'The *resulting context* section of a pattern describes the consequences of
    applying the pattern. It consists of three parts:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 模式的“结果情境”部分描述了应用模式的结果。它包括三个部分：
- en: '***Benefits*—** The benefits of the pattern, including the forces that have
    been resolved'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***好处***—**模式的好处，包括已解决的力**'
- en: '***Drawbacks*—** The drawbacks of the pattern, including the unresolved forces'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***缺点***—**模式的缺点，包括未解决的力**'
- en: '***Issues*—** The new problems that have been introduced by applying the pattern'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***问题***—**应用模式所引入的新问题**'
- en: The resulting context provides a more complete and less biased view of the solution,
    which enables better design decisions.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 结果情境提供了更完整且更少偏见的解决方案视角，这有助于做出更好的设计决策。
- en: 'Related patterns: The five different types of relationships'
  id: totrans-227
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 相关模式：五种不同类型的关系
- en: 'The *related patterns* section of a pattern describes the relationship between
    the pattern and other patterns. There are five types of relationships between
    patterns:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 模式的“相关模式”部分描述了模式与其他模式之间的关系。模式之间存在五种类型的关系：
- en: '***Predecessor*—** A predecessor pattern is a pattern that motivates the need
    for this pattern. For example, the Microservice architecture pattern is the predecessor
    to the rest of the patterns in the pattern language, except the monolithic architecture
    pattern.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***前驱模式***—**前驱模式是激发对这种模式需求的前驱模式。例如，微服务架构模式是模式语言中除单体架构模式之外所有模式的先导模式。**'
- en: '***Successor*—** A pattern that solves an issue that has been introduced by
    this pattern. For example, if you apply the Microservice architecture pattern,
    you must then apply numerous successor patterns, including service discovery patterns
    and the Circuit breaker pattern.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***后续模式***—**解决由该模式引入的问题的模式。例如，如果你应用了微服务架构模式，你必须随后应用许多后续模式，包括服务发现模式和断路器模式。**'
- en: '***Alternative*—** A pattern that provides an alternative solution to this
    pattern. For example, the Monolithic architecture pattern and the Microservice
    architecture pattern are alternative ways of architecting an application. You
    pick one or the other.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***替代方案***—**提供替代解决方案的模式。例如，单体架构模式和微服务架构模式是构建应用程序的替代架构方式。你选择其中一个或另一个。**'
- en: '***Generalization*—** A pattern that is a general solution to a problem. For
    example, in [chapter 12](kindle_split_020.xhtml#ch12) you’ll learn about the different
    implementations of the Single service per host pattern.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***泛化***—**一个通用于解决问题的模式。例如，在第12章中，你将了解单服务每主机模式的不同实现。**'
- en: '***Specialization*—** A specialized form of a particular pattern. For example,
    in [chapter 12](kindle_split_020.xhtml#ch12) you’ll learn that the Deploy a service
    as a container pattern is a specialization of Single service per host.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***专业化*—** 某个特定模式的特殊形式。例如，在第 12 章 [chapter 12](kindle_split_020.xhtml#ch12)
    中，您将了解到将服务作为容器部署模式是单机单服务模式的特殊形式。'
- en: In addition, you can organize patterns that tackle issues in a particular problem
    area into groups. The explicit description of related patterns provides valuable
    guidance on how to effectively solve a particular problem. [Figure 1.9](#ch01fig09)
    shows how the relationships between patterns is visually represented.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还可以将解决特定问题领域的模式组织成组。相关模式的明确描述为如何有效地解决特定问题提供了宝贵的指导。[图 1.9](#ch01fig09) 展示了模式之间关系的视觉表示。
- en: 'Figure 1.9\. The visual representation of different types of relationships
    between the patterns: a *successor* pattern solves a problem created by applying
    the *predecessor* pattern; two or more patterns can be *alternative* solutions
    to the same problem; one pattern can be a *specialization* of another pattern;
    and patterns that solve problems in the same area can be grouped, or *generalized*.'
  id: totrans-235
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.9\. 模式之间不同类型关系的视觉表示：一个 *后继* 模式解决由 *前驱* 模式应用而产生的问题；两个或更多模式可以是同一问题的 *替代* 解决方案；一个模式可以是另一个模式的
    *专业化*；并且解决同一领域问题的模式可以分组，或 *泛化*。
- en: '![](Images/01fig09_alt.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/01fig09_alt.jpg)'
- en: 'The different kinds of relationships between patterns shown in [figure 1.9](#ch01fig09)
    are represented as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1.9](#ch01fig09) 中展示的模式之间的不同关系如下所示：'
- en: Represents the predecessor-successor relationship
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示前驱-后继关系
- en: Patterns that are alternative solutions to the same problem
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相同问题的替代解决方案
- en: Indicates that one pattern is a specialization of another pattern
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示一个模式是另一个模式的特殊形式
- en: Patterns that apply to a particular problem area
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用于特定问题领域的模式
- en: A collection of patterns related through these relationships sometimes form
    what is known as a pattern language. The patterns in a pattern language work together
    to solve problems in a particular domain. In particular, I’ve created the Microservice
    architecture pattern language. It’s a collection of interrelated software architecture
    and design patterns for microservices. Let’s take a look at this pattern language.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些关系相关联的模式集合有时形成所谓的模式语言。模式语言中的模式共同工作，以解决特定领域的问题。特别是，我创建了微服务架构模式语言。它是一系列相互关联的微服务软件架构和设计模式。让我们来看看这个模式语言。
- en: 1.6.3\. Overview of the Microservice architecture pattern language
  id: totrans-243
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.6.3\. 微服务架构模式语言概述
- en: The Microservice architecture pattern language is a collection of patterns that
    help you architect an application using the microservice architecture. [Figure
    1.10](#ch01fig10) shows the high-level structure of the pattern language. The
    pattern language first helps you decide whether to use the microservice architecture.
    It describes the monolithic architecture and the microservice architecture, along
    with their benefits and drawbacks. Then, if the microservice architecture is a
    good fit for your application, the pattern language helps you use it effectively
    by solving various architecture and design issues.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构模式语言是一系列模式，帮助您使用微服务架构来构建应用程序。[图 1.10](#ch01fig10) 展示了模式语言的高级结构。模式语言首先帮助您决定是否使用微服务架构。它描述了单体架构和微服务架构，以及它们的优缺点。然后，如果微服务架构适合您的应用程序，模式语言通过解决各种架构和设计问题，帮助您有效地使用它。
- en: 'Figure 1.10\. A high-level view of the Microservice architecture pattern language
    showing the different problem areas that the patterns solve. On the left are the
    application architecture patterns: Monolithic architecture and Microservice architecture.
    All the other groups of patterns solve problems that result from choosing the
    Microservice architecture pattern.'
  id: totrans-245
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.10\. 微服务架构模式语言的概览，展示了这些模式解决的不同问题领域。左侧是应用架构模式：单体架构和微服务架构。所有其他模式组解决的是选择微服务架构模式所带来的问题。
- en: '![](Images/01fig10_alt.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/01fig10_alt.jpg)'
- en: The pattern language consists of several groups of patterns. On the left in
    [figure 1.10](#ch01fig10) is the application architecture patterns group, the
    Monolithic architecture pattern and the Microservice architecture pattern. Those
    are the patterns we’ve been discussing in this chapter. The rest of the pattern
    language consists of groups of patterns that are solutions to issues that are
    introduced by using the Microservice architecture pattern.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 模式语言由几个模式组组成。在 [图 1.10](#ch01fig10) 的左侧是应用架构模式组，包括单体架构模式和微服务架构模式。这些就是本章讨论的模式。模式语言的其余部分由解决使用微服务架构模式引入的问题的模式组组成。
- en: 'The patterns are also divided into three layers:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 模式还被分为三层：
- en: '***Infrastructure patterns*—** These solve problems that are mostly infrastructure
    issues outside of development.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***基础设施模式*—** 这些解决大多数是开发之外的基础设施问题。'
- en: '***Application infrastructure*—** These are for infrastructure issues that
    also impact development.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***应用基础设施*—** 这些是影响开发的基础设施问题。'
- en: '***Application patterns*—** These solve problems faced by developers.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***应用模式*—** 这些解决开发者面临的问题。'
- en: These patterns are grouped together based on the kind of problem they solve.
    Let’s look at the main groups of patterns.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模式根据它们解决的问题类型分组。让我们看看主要模式组。
- en: Patterns for decomposing an application into services
  id: totrans-253
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将应用程序分解为服务的模式
- en: Deciding how to decompose a system into a set of services is very much an art,
    but there are a number of strategies that can help. The two decomposition patterns
    shown in [figure 1.11](#ch01fig11) are different strategies you can use to define
    your application’s architecture.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 决定如何将系统分解为一系列服务在很大程度上是一种艺术，但有一些策略可以帮助。在 [图 1.11](#ch01fig11) 中显示的两个分解模式是您可以用来定义应用程序架构的不同策略。
- en: 'Figure 1.11\. There are two decomposition patterns: Decompose by business capability,
    which organizes services around business capabilities, and Decompose by subdomain,
    which organizes services around domain-driven design (DDD) subdomains.'
  id: totrans-255
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.11\. 有两种分解模式：按业务能力分解，它围绕业务能力组织服务，以及按子域分解，它围绕领域驱动设计 (DDD) 子域组织服务。
- en: '![](Images/01fig11.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/01fig11.jpg)'
- en: '[Chapter 2](kindle_split_010.xhtml#ch02) describes these patterns in detail.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '[第二章](kindle_split_010.xhtml#ch02) 详细描述了这些模式。'
- en: Communication patterns
  id: totrans-258
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 通信模式
- en: 'An application built using the microservice architecture is a distributed system.
    Consequently, interprocess communication (IPC) is an important part of the microservice
    architecture. You must make a variety of architectural and design decisions about
    how your services communicate with one another and the outside world. [Figure
    1.12](#ch01fig12) shows the communication patterns, which are organized into five
    groups:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 使用微服务架构构建的应用程序是一个分布式系统。因此，进程间通信 (IPC) 是微服务架构的一个重要部分。您必须就您的服务如何相互通信以及与外部世界的通信做出各种架构和设计决策。[图
    1.12](#ch01fig12) 显示了通信模式，这些模式被组织成五个组：
- en: '***Communication style*—** What kind of IPC mechanism should you use?'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***通信风格*—** 应该使用哪种 IPC 机制？'
- en: '***Discovery*—** How does a client of a service determine the IP address of
    a service instance so that, for example, it makes an HTTP request?'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***发现*—** 服务客户端如何确定服务实例的 IP 地址，例如，以便进行 HTTP 请求？'
- en: '***Reliability*—** How can you ensure that communication between services is
    reliable even though services can be unavailable?'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***可靠性*—** 即使服务可能不可用，您如何确保服务之间的通信是可靠的？'
- en: '***Transactional messaging*—** How should you integrate the sending of messages
    and publishing of events with database transactions that update business data?'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***事务消息*—** 如何将消息发送和事件发布的集成与更新业务数据的数据库事务相结合？'
- en: '***External API*—** How do clients of your application communicate with the
    services?'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***外部 API*—** 您的应用程序客户端如何与服务通信？'
- en: Figure 1.12\. The five groups of communication patterns
  id: totrans-265
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.12\. 五种通信模式组
- en: '![](Images/01fig12_alt.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/01fig12_alt.jpg)'
- en: '[Chapter 3](kindle_split_011.xhtml#ch03) looks at the first four groups of
    patterns: communication style, discovery, reliability, and transaction messaging.
    [Chapter 8](kindle_split_016.xhtml#ch08) looks at the external API patterns.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '[第三章](kindle_split_011.xhtml#ch03) 探讨了前四个模式组：通信风格、发现、可靠性和事务消息。[第八章](kindle_split_016.xhtml#ch08)
    探讨外部 API 模式。'
- en: Data consistency patterns for implementing transaction management
  id: totrans-268
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实现事务管理的数据一致性模式
- en: As mentioned earlier, in order to ensure loose coupling, each service has its
    own database. Unfortunately, having a database per service introduces some significant
    issues. I describe in [chapter 4](kindle_split_012.xhtml#ch04) that the traditional
    approach of using distributed transactions (2PC) isn’t a viable option for a modern
    application. Instead, an application needs to maintain data consistency by using
    the Saga pattern. [Figure 1.13](#ch01fig13) shows data-related patterns.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，为了确保松耦合，每个服务都有自己的数据库。不幸的是，每个服务拥有自己的数据库引入了一些重大问题。我在[第4章](kindle_split_012.xhtml#ch04)中描述了传统的使用分布式事务（2PC）的方法对于现代应用来说不是一个可行的选项。相反，应用程序需要通过使用
    Saga 模式来维护数据一致性。[图1.13](#ch01fig13)展示了与数据相关的模式。
- en: Figure 1.13\. Because each service has its own database, you must use the Saga
    pattern to maintain data consistency across services.
  id: totrans-270
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.13。由于每个服务都有自己的数据库，你必须使用 Saga 模式来维护服务之间的数据一致性。
- en: '![](Images/01fig13_alt.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![图片1.14](Images/01fig14_alt.jpg)'
- en: '[Chapters 4](kindle_split_012.xhtml#ch04), [5](kindle_split_013.xhtml#ch05),
    and [6](kindle_split_014.xhtml#ch06) describe these patterns in more detail.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '[第4章](kindle_split_012.xhtml#ch04)、[第5章](kindle_split_013.xhtml#ch05)和[第6章](kindle_split_014.xhtml#ch06)更详细地描述了这些模式。'
- en: Patterns for querying data in a microservice architecture
  id: totrans-273
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 微服务架构中查询数据的模式
- en: The other issue with using a database per service is that some queries need
    to join data that’s owned by multiple services. A service’s data is only accessible
    via its API, so you can’t use distributed queries against its database. [Figure
    1.14](#ch01fig14) shows a couple of patterns you can use to implement queries.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 使用每个服务一个数据库的另一个问题是，某些查询需要连接多个服务拥有的数据。服务的数据只能通过其 API 访问，因此你不能对其数据库执行分布式查询。[图1.14](#ch01fig14)展示了你可以用来实现查询的几个模式。
- en: Figure 1.14\. Because each service has its own database, you must use one of
    the querying patterns to retrieve data scattered across multiple services.
  id: totrans-275
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.14。由于每个服务都有自己的数据库，你必须使用查询模式之一来检索分散在多个服务中的数据。
- en: '![](Images/01fig14_alt.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![图片1.13](Images/01fig13_alt.jpg)'
- en: Sometimes you can use the API composition pattern, which invokes the APIs of
    one or more services and aggregates results. Other times, you must use the Command
    query responsibility segregation (CQRS) pattern, which maintains one or more easily
    queried replicas of the data. [Chapter 7](kindle_split_015.xhtml#ch07) looks at
    the different ways of implementing queries.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可以使用 API 组合模式，该模式调用一个或多个服务的 API 并聚合结果。其他时候，你必须使用命令查询责任分离（CQRS）模式，该模式维护一个或多个易于查询的数据副本。[第7章](kindle_split_015.xhtml#ch07)探讨了实现查询的不同方法。
- en: Service deployment patterns
  id: totrans-278
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 服务部署模式
- en: Deploying a monolithic application isn’t always easy, but it is straightforward
    in the sense that there is a single application to deploy. You have to run multiple
    instances of the application behind a load balancer.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 部署单体应用并不总是容易，但从某种意义上说，它很简单，因为只有一个应用需要部署。你必须在负载均衡器后面运行应用程序的多个实例。
- en: In comparison, deploying a microservices-based application is much more complex.
    There may be tens or hundreds of services that are written in a variety of languages
    and frameworks. There are many more moving parts that need to be managed. [Figure
    1.15](#ch01fig15) shows the deployment patterns.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，部署基于微服务的应用要复杂得多。可能有成十或上百个服务，它们是用各种语言和框架编写的。有许多更多的移动部件需要管理。[图1.15](#ch01fig15)展示了部署模式。
- en: Figure 1.15\. Several patterns for deploying microservices. The traditional
    approach is to deploy services in a language-specific packaging format. There
    are two modern approaches to deploying services. The first deploys services as
    VM or containers. The second is the serverless approach. You simply upload the
    service’s code and the serverless platform runs it. You should use a service deployment
    platform, which is an automated, self-service platform for deploying and managing
    services.
  id: totrans-281
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.15。部署微服务的几种模式。传统的方法是将服务部署在特定语言的打包格式中。有两种现代的服务部署方法。第一种是将服务作为虚拟机或容器部署。第二种是无服务器方法。你只需上传服务的代码，无服务器平台就会运行它。你应该使用服务部署平台，这是一个自动的、自助的平台，用于部署和管理服务。
- en: '![](Images/01fig15_alt.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![图片1.15](Images/01fig15_alt.jpg)'
- en: The traditional, and often manual, way of deploying applications in a language-specific
    packaging format, for example WAR files, doesn’t scale to support a microservice
    architecture. You need a highly automated deployment infrastructure. Ideally,
    you should use a deployment platform that provides the developer with a simple
    UI (command-line or GUI) for deploying and managing their services. The deployment
    platform will typically be based on virtual machines (VMs), containers, or serverless
    technology. [Chapter 12](kindle_split_020.xhtml#ch12) looks at the different deployment
    options.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的、通常是手动的方式在特定语言的打包格式中部署应用程序，例如WAR文件，无法扩展以支持微服务架构。您需要一个高度自动化的部署基础设施。理想情况下，您应该使用提供开发者简单UI（命令行或GUI）以部署和管理其服务的部署平台。部署平台通常基于虚拟机（VM）、容器或无服务器技术。[第12章](kindle_split_020.xhtml#ch12)探讨了不同的部署选项。
- en: Observability patterns provide insight into application behavior
  id: totrans-284
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 可观察性模式提供对应用程序行为的洞察
- en: A key part of operating an application is understanding its runtime behavior
    and troubleshooting problems such as failed requests and high latency. Though
    understanding and troubleshooting a monolithic application isn’t always easy,
    it helps that requests are handled in a simple, straightforward way. Each incoming
    request is load balanced to a particular application instance, which makes a few
    calls to the database and returns a response. For example, if you need to understand
    how a particular request was handled, you look at the log file of the application
    instance that handled the request.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 运营应用程序的关键部分是理解其运行时行为和诊断问题，如失败的请求和高延迟。虽然理解和诊断单体应用程序并不总是容易，但请求以简单直接的方式处理是有帮助的。每个传入的请求都会被负载均衡到特定的应用程序实例，该实例对数据库进行少量调用并返回响应。例如，如果您需要了解特定请求的处理方式，您会查看处理该请求的应用程序实例的日志文件。
- en: In contrast, understanding and diagnosing problems in a microservice architecture
    is much more complicated. A request can bounce around between multiple services
    before a response is finally returned to a client. Consequently, there isn’t one
    log file to examine. Similarly, problems with latency are more difficult to diagnose
    because there are multiple suspects.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，理解和诊断微服务架构中的问题要复杂得多。在最终将响应返回给客户端之前，一个请求可以在多个服务之间弹跳。因此，没有单一的日志文件可以检查。同样，由于存在多个嫌疑人，延迟问题也更难以诊断。
- en: 'You can use the following patterns to design observable services:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下模式来设计可观察的服务：
- en: '***Health check API*—** Expose an endpoint that returns the health of the service.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***健康检查API*—** 暴露一个返回服务健康状况的端点。'
- en: '***Log aggregation*—** Log service activity and write logs into a centralized
    logging server, which provides searching and alerting.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***日志聚合*—** 记录服务活动并将日志写入集中式日志服务器，该服务器提供搜索和警报功能。'
- en: '***Distributed tracing*—** Assign each external request a unique ID and trace
    requests as they flow between services.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***分布式跟踪*—** 为每个外部请求分配一个唯一的ID，并跟踪请求在服务之间的流动。'
- en: '***Exception tracking*—** Report exceptions to an exception tracking service,
    which deduplicates exceptions, alerts developers, and tracks the resolution of
    each exception.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***异常跟踪*—** 将异常报告给异常跟踪服务，该服务去重异常、提醒开发者并跟踪每个异常的解决情况。'
- en: '***Application metrics*—** Maintain metrics, such as counters and gauges, and
    expose them to a metrics server.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***应用指标*—** 维护指标，例如计数器和仪表，并将它们暴露给指标服务器。'
- en: '***Audit logging*—** Log user actions.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***审计日志*—** 记录用户操作。'
- en: '[Chapter 11](kindle_split_019.xhtml#ch11) describes these patterns in more
    detail.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '[第11章](kindle_split_019.xhtml#ch11)更详细地描述了这些模式。'
- en: Patterns for the automated testing of services
  id: totrans-295
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 服务自动化测试模式
- en: 'The microservice architecture makes individual services easier to test because
    they’re much smaller than the monolithic application. At the same time, though,
    it’s important to test that the different services work together while avoiding
    using complex, slow, and brittle end-to-end tests that test multiple services
    together. Here are patterns for simplifying testing by testing services in isolation:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构使得单个服务更容易测试，因为它们比单体应用程序小得多。同时，尽管如此，测试不同服务协同工作而避免使用复杂、缓慢且脆弱的端到端测试（这些测试多个服务一起）也很重要。以下是在隔离测试服务中简化测试的模式：
- en: '***Consumer-driven contract test*—** Verify that a service meets the expectations
    of its clients.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***消费者驱动的合同测试*—** 验证服务是否满足其客户端的期望。'
- en: '***Consumer-side contract test*—** Verify that the client of a service can
    communicate with the service.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***客户端合同测试*—** 验证服务客户端能否与服务通信。'
- en: '***Service component test*—** Test a service in isolation.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***服务组件测试*—** 在隔离状态下测试服务。'
- en: '[Chapters 9](kindle_split_017.xhtml#ch09) and [10](kindle_split_018.xhtml#ch10)
    describe these testing patterns in more detail.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '[第9章](kindle_split_017.xhtml#ch09)和[第10章](kindle_split_018.xhtml#ch10)更详细地描述了这些测试模式。'
- en: Patterns for handling cross-cutting concerns
  id: totrans-301
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 处理横切关注点的模式
- en: In a microservice architecture, there are numerous concerns that every service
    must implement, including the observability patterns and discovery patterns. It
    must also implement the Externalized Configuration pattern, which supplies configuration
    parameters such as database credentials to a service at runtime. When developing
    a new service, it would be too time consuming to reimplement these concerns from
    scratch. A much better approach is to apply the Microservice Chassis pattern and
    build services on top of a framework that handles these concerns. [Chapter 11](kindle_split_019.xhtml#ch11)
    describes these patterns in more detail.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，每个服务都必须实现许多关注点，包括可观察性模式和发现模式。它还必须实现外部化配置模式，该模式在运行时向服务提供配置参数，例如数据库凭证。当开发新的服务时，从头开始重新实现这些关注点将非常耗时。一个更好的方法是应用微服务底盘模式，并在处理这些关注点的框架之上构建服务。[第11章](kindle_split_019.xhtml#ch11)更详细地描述了这些模式。
- en: Security patterns
  id: totrans-303
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 安全模式
- en: In a microservice architecture, users are typically authenticated by the API
    gateway. It must then pass information about the user, such as identity and roles,
    to the services it invokes. A common solution is to apply the Access token pattern.
    The API gateway passes an access token, such as JWT (JSON Web Token), to the services,
    which can validate the token and obtain information about the user. [Chapter 11](kindle_split_019.xhtml#ch11)
    discusses the Access token pattern in more detail.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，用户通常由API网关进行身份验证。然后它必须将有关用户的信息，例如身份和角色，传递给它调用的服务。一个常见的解决方案是应用访问令牌模式。API网关传递一个访问令牌，例如JWT（JSON
    Web Token），到服务，这些服务可以验证令牌并获取有关用户的信息。[第11章](kindle_split_019.xhtml#ch11)更详细地讨论了访问令牌模式。
- en: Not surprisingly, the patterns in the Microservice architecture pattern language
    are focused on solving architect and design problems. You certainly need the right
    architecture in order to successfully develop software, but it’s not the only
    concern. You must also consider process and organization.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，微服务架构模式语言中的模式主要集中在解决架构和设计问题上。你当然需要正确的架构才能成功开发软件，但这并非唯一关注点。你还必须考虑流程和组织。
- en: '1.7\. Beyond microservices: Process and organization'
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.7. 超越微服务：流程和组织
- en: For a large, complex application, the microservice architecture is usually the
    best choice. But in addition to having the right architecture, successful software
    development requires you to also have organization, and development and delivery
    processes. [Figure 1.16](#ch01fig16) shows the relationships between process,
    organization, and architecture.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大型、复杂的应用程序，微服务架构通常是最佳选择。但除了拥有正确的架构外，成功的软件开发还需要你有组织，以及开发和交付流程。[图1.16](#ch01fig16)展示了流程、组织和架构之间的关系。
- en: Figure 1.16\. The rapid, frequent, and reliable delivery of large, complex applications
    requires a combination of DevOps, which includes continuous delivery/deployment,
    small, autonomous teams, and the microservice architecture.
  id: totrans-308
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.16。快速、频繁和可靠地交付大型、复杂应用程序需要DevOps的组合，包括持续交付/部署、小型、自主团队和微服务架构。
- en: '![](Images/01fig16_alt.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![图1.16的替代文本](Images/01fig16_alt.jpg)'
- en: I’ve already described the microservice architecture. Let’s look at organization
    and process.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经描述了微服务架构。让我们看看组织和流程。
- en: 1.7.1\. Software development and delivery organization
  id: totrans-311
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.7.1. 软件开发和交付组织
- en: Success inevitably means that the engineering team will grow. On the one hand,
    that’s a good thing because more developers can get more done. The trouble with
    large teams is, as Fred Brooks wrote in *The Mythical Man-Month*, the communication
    overhead of a team of size *N* is *O*(*N*²). If the team gets too large, it will
    become inefficient, due to the communication overhead. Imagine, for example, trying
    to do a daily standup with 20 people.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 成功不可避免地意味着工程团队将扩大。一方面，这很好，因为更多的开发者可以完成更多的工作。大型团队的问题，正如弗雷德·布鲁克斯在*《人月神话》*中所写，团队规模为*N*的沟通开销是*O*(*N*²)。如果团队规模过大，由于沟通开销，它将变得低效。例如，想象一下试图与20人进行每日站立会议。
- en: 'The solution is to refactor a large single team into a team of teams. Each
    team is small, consisting of no more than 8–12 people. It has a clearly defined
    business-oriented mission: developing and possibly operating one or more services
    that implement a feature or a business capability. The team is cross-functional
    and can develop, test, and deploy its services without having to frequently communicate
    or coordinate with other teams.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是将一个大型单一团队重构为多个团队。每个团队规模较小，由不超过8-12人组成。它有一个明确以业务为导向的使命：开发和可能运营一个或多个实现功能或业务能力的服务。团队是跨职能的，可以在不经常与其他团队沟通或协调的情况下开发、测试和部署其服务。
- en: '|  |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**The reverse Conway maneuver**'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '**逆向康威行动**'
- en: 'In order to effectively deliver software when using the microservice architecture,
    you need to take into account Conway’s law ([https://en.wikipedia.org/wiki/Conway%27s_law](https://en.wikipedia.org/wiki/Conway%27s_law)),
    which states the following:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在使用微服务架构有效交付软件时，你需要考虑康威定律([https://en.wikipedia.org/wiki/Conway%27s_law](https://en.wikipedia.org/wiki/Conway%27s_law))，该定律如下所述：
- en: '*Organizations which design systems ... are constrained to produce designs
    which are copies of the communication structures of these organizations.*'
  id: totrans-317
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*组织在设计和构建系统时...会受到限制，只能产生与这些组织的沟通结构相匹配的设计。*'
- en: ''
  id: totrans-318
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Melvin Conway*'
  id: totrans-319
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*梅尔文·康威*'
- en: In other words, your application’s architecture mirrors the structure of the
    organization that developed it. It’s important, therefore, to apply Conway’s law
    in reverse ([www.thoughtworks.com/radar/techniques/inverse-conway-maneuver](http://www.thoughtworks.com/radar/techniques/inverse-conway-maneuver))
    and design your organization so that its structure mirrors your microservice architecture.
    By doing so, you ensure that your development teams are as loosely coupled as
    the services.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，你的应用程序的架构反映了开发它的组织的结构。因此，逆向应用康威定律([www.thoughtworks.com/radar/techniques/inverse-conway-maneuver](http://www.thoughtworks.com/radar/techniques/inverse-conway-maneuver))并设计你的组织，使其结构反映你的微服务架构是非常重要的。通过这样做，你确保你的开发团队与服务的耦合性一样松散。
- en: '|  |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The velocity of the team of teams is significantly higher than that of a single
    large team. As described earlier in [section 1.5.1](#ch01lev2sec9), the microservice
    architecture plays a key role in enabling the teams to be autonomous. Each team
    can develop, deploy, and scale their services without coordinating with other
    teams. Moreover, it’s very clear who to contact when a service isn’t meeting its
    SLA.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 多个团队的速度显著高于单个大型团队的速度。如前所述在[第1.5.1节](#ch01lev2sec9)，微服务架构在使团队实现自治方面发挥着关键作用。每个团队可以开发、部署和扩展其服务，而无需与其他团队协调。此外，当服务未满足其服务级别协议(SLA)时，非常清楚应该联系谁。
- en: What’s more, the development organization is much more scalable. You grow the
    organization by adding teams. If a single team becomes too large, you split it
    and its associated service or services. Because the teams are loosely coupled,
    you avoid the communication overhead of a large team. As a result, you can add
    people without impacting productivity.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，开发组织具有更高的可扩展性。你通过添加团队来扩大组织。如果一个单一团队变得过大，你可以将其及其相关的服务或服务拆分。由于团队松散耦合，你可以避免大型团队的沟通开销。因此，你可以添加人员而不影响生产力。
- en: 1.7.2\. Software development and delivery process
  id: totrans-324
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.7.2\. 软件开发和交付流程
- en: Using the microservice architecture with a waterfall development process is
    like driving a horse-drawn Ferrari—you squander most of the benefit of using microservices.
    If you want to develop an application with the microservice architecture, it’s
    essential that you adopt agile development and deployment practices such as Scrum
    or Kanban. Better yet, you should practice continuous delivery/deployment, which
    is a part of DevOps.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 使用瀑布式开发流程的微服务架构就像驾驶一辆马拉的法拉利——你浪费了使用微服务的大部分好处。如果你想使用微服务架构开发应用程序，采用敏捷开发和部署实践，如Scrum或Kanban，是至关重要的。更好的是，你应该实践持续交付/部署，这是DevOps的一部分。
- en: 'Jez Humble ([https://continuousdelivery.com/](https://continuousdelivery.com/))
    defines continuous delivery as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: Jez Humble 在 [https://continuousdelivery.com/](https://continuousdelivery.com/)
    将持续交付定义为如下：
- en: '*Continuous Delivery is the ability to get changes of all types—including new
    features, configuration changes, bug fixes and experiments—into production, or
    into the hands of users, safely and quickly in a sustainable way.*'
  id: totrans-327
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*持续交付是能够以安全、快速且可持续的方式将所有类型的更改（包括新功能、配置更改、错误修复和实验）投入生产或用户手中的能力。*'
- en: A key characteristic of continuous delivery is that software is always releasable.
    It relies on a high level of automation, including automated testing. Continuous
    deployment takes continuous delivery one step further in the practice of automatically
    deploying releasable code into production. High-performing organizations that
    practice continuous deployment deploy multiple times per day into production,
    have far fewer production outages, and recover quickly from any that do occur
    ([https://puppet.com/resources/whitepaper/state-of-devops-report](https://puppet.com/resources/whitepaper/state-of-devops-report)).
    As described earlier in [section 1.5.1](#ch01lev2sec9), the microservice architecture
    directly supports continuous delivery/deployment.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 持续交付的一个关键特征是软件始终可发布。它依赖于高度自动化，包括自动化测试。持续部署在自动将可发布代码部署到生产环境中进一步推进了持续交付的实践。实践持续部署的高性能组织每天多次将代码部署到生产中，生产中断事件远少，并且能够快速从任何发生的事件中恢复。[如前所述](#ch01lev2sec9)，微服务架构直接支持持续交付/部署。
- en: '|  |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Move fast without breaking things**'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速行动，不破坏事物**'
- en: 'The goal of continuous delivery/deployment (and, more generally, DevOps) is
    to rapidly yet reliably deliver software. Four useful metrics for assessing software
    development are as follows:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 持续交付/部署（以及更广泛的DevOps）的目标是快速且可靠地交付软件。以下四个用于评估软件开发的有用指标如下：
- en: '***Deployment frequency*—** How often software is deployed into production'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***部署频率*—** 软件被部署到生产环境的频率'
- en: '***Lead time*—** Time from a developer checking in a change to that change
    being deployed'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***平均恢复时间*—** 从生产问题恢复所需的时间'
- en: '***Mean time to recover*—** Time to recover from a production problem'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***平均恢复时间*—** 从生产问题恢复所需的时间'
- en: '***Change failure rate*—** Percentage of changes that result in a production
    problem'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***变更失败率*—** 导致生产问题的变更的百分比'
- en: In a traditional organization, the deployment frequency is low, and the lead
    time is high. Stressed-out developers and operations people typically stay up
    late into the night fixing last-minute issues during the maintenance window. In
    contrast, a DevOps organization releases software frequently, often multiple times
    per day, with far fewer production issues. Amazon, for example, deployed changes
    into production every 11.6 seconds in 2014 ([www.youtube.com/watch?v=dxk8b9rSKOo](http://www.youtube.com/watch?v=dxk8b9rSKOo)),
    and Netflix had a lead time of 16 minutes for one software component ([https://medium.com/netflix-techblog/how-we-build-code-at-netflix-c5d9bd727f15](https://medium.com/netflix-techblog/how-we-build-code-at-netflix-c5d9bd727f15)).
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个传统组织中，部署频率低，平均恢复时间长。压力山大的开发人员和运维人员通常会在维护窗口期间熬夜修复最后一刻的问题。相比之下，DevOps组织频繁发布软件，通常每天发布多次，生产问题远少。例如，亚马逊在2014年每11.6秒就将更改部署到生产环境中
    ([www.youtube.com/watch?v=dxk8b9rSKOo](http://www.youtube.com/watch?v=dxk8b9rSKOo))，Netflix一个软件组件的平均恢复时间为16分钟
    ([https://medium.com/netflix-techblog/how-we-build-code-at-netflix-c5d9bd727f15](https://medium.com/netflix-techblog/how-we-build-code-at-netflix-c5d9bd727f15))。
- en: '|  |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 1.7.3\. The human side of adopting microservices
  id: totrans-338
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.7.3\. 采用微服务的“人”的方面
- en: Adopting the microservice architecture changes your architecture, your organization,
    and your development processes. Ultimately, though, it changes the working environment
    of people, who are, as mentioned earlier, emotional creatures. If ignored, their
    emotions can make the adoption of microservices a bumpy ride. Mary and the other
    FTGO leaders will struggle to change how FTGO develops software.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 采用微服务架构会改变你的架构、组织和开发流程。然而，最终，它改变了人们的办公环境，正如前面提到的，人们是情感动物。如果忽视他们的情绪，他们的情绪可能会使微服务的采用变得崎岖不平。玛丽和其他FTGO领导者将努力改变FTGO开发软件的方式。
- en: 'The best-selling book *Managing Transitions* (Da Capo Lifelong Books, 2017,
    [https://wmbridges.com/books](https://wmbridges.com/books)) by William and Susan
    Bridges introduces the concept of a *transition*, which refers to the process
    of how people respond emotionally to a change. It describes a three-stage Transition
    Model:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 畅销书《管理过渡》（Da Capo Lifelong Books，2017年，[https://wmbridges.com/books](https://wmbridges.com/books)）的作者威廉和苏珊·布里奇斯介绍了“过渡”的概念，它指的是人们如何情感上对变革做出反应的过程。它描述了一个三阶段的过渡模型：
- en: '***Ending, Losing, and Letting Go*—** The period of emotional upheaval and
    resistance when people are presented with a change that forces them out of their
    comfort zone. They often mourn the loss of the old way of doing things. For example,
    when people reorganize into cross-functional teams, they miss their former teammates.
    Similarly, a data modeling group that owns the global data model will be threatened
    by the idea of each service having its own data model.'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***结束、失去和放手*—** 当人们面临一个迫使他们走出舒适区的变革时，会出现情感动荡和抵抗的时期。他们常常哀悼失去旧做事方式。例如，当人们重组为跨职能团队时，他们会怀念他们以前的同学。同样，拥有全球数据模型的数据建模组可能会受到每个服务都有自己的数据模型这一想法的威胁。'
- en: '***The Neutral Zone*—** The intermediate stage between the old and new ways
    of doing things, where people are often confused. They are often struggling to
    learn the new way of doing things.'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***中立区*—** 在旧方式和新方式之间的中间阶段，人们常常感到困惑。他们经常努力学习新做事的方式。'
- en: '***The New Beginning*—** The final stage where people have enthusiastically
    embraced the new way of doing things and are starting to experience the benefits.'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***新的开始*—** 这是人们热情拥抱新做事方式并开始体验其益处的最终阶段。'
- en: The book describes how best to manage each stage of the transition and increase
    the likelihood of successfully implementing the change. FTGO is certainly suffering
    from monolithic hell and needs to migrate to a microservice architecture. It must
    also change its organization and development processes. In order for FTGO to successfully
    accomplish this, however, it must take into account the transition model and consider
    people’s emotions.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 本书描述了如何最好地管理过渡的每个阶段并提高成功实施变革的可能性。FTGO当然正遭受单体地狱的困扰，需要迁移到微服务架构。它还必须改变其组织和开发流程。然而，为了使FTGO能够成功完成这一任务，它必须考虑过渡模型并考虑人们的情绪。
- en: In the next chapter, you’ll learn about the goal of software architecture and
    how to decompose an application into services.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将了解软件架构的目标以及如何将应用程序分解为服务。
- en: Summary
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: The Monolithic architecture pattern structures the application as a single deployable
    unit.
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单体架构模式将应用程序结构化为一个单一的部署单元。
- en: The Microservice architecture pattern decomposes a system into a set of independently
    deployable services, each with its own database.
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务架构模式将系统分解为一系列独立可部署的服务，每个服务都有自己的数据库。
- en: The monolithic architecture is a good choice for simple applications, but microservice
    architecture is usually a better choice for large, complex applications.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单体架构对于简单应用来说是一个不错的选择，但对于大型、复杂的应用程序，微服务架构通常是更好的选择。
- en: The microservice architecture accelerates the velocity of software development
    by enabling small, autonomous teams to work in parallel.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务架构通过允许小型、自主团队并行工作，加速了软件开发的速度。
- en: The microservice architecture isn’t a silver bullet—there are significant drawbacks,
    including complexity.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务架构并不是万能的银弹——存在显著的缺点，包括复杂性。
- en: The Microservice architecture pattern language is a collection of patterns that
    help you architect an application using the microservice architecture. It helps
    you decide whether to use the microservice architecture, and if you pick the microservice
    architecture, the pattern language helps you apply it effectively.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务架构模式语言是一系列帮助您使用微服务架构来构建应用程序的模式。它帮助您决定是否使用微服务架构，如果您选择了微服务架构，模式语言将帮助您有效地应用它。
- en: You need more than just the microservice architecture to accelerate software
    delivery. Successful software development also requires DevOps and small, autonomous
    teams.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅靠微服务架构并不能加速软件交付。成功的软件开发还需要DevOps和小型、自主的团队。
- en: Don’t forget about the human side of adopting microservices. You need to consider
    employees’ emotions in order to successfully transition to a microservice architecture.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要忘记采用微服务的“人”的一面。为了成功过渡到微服务架构，您需要考虑员工的情绪。
