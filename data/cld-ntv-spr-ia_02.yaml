- en: 1 Introduction to cloud native
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1 云原生简介
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了
- en: What the cloud and cloud computing model are
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云和云计算模型是什么
- en: The definition of cloud native
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云原生的定义
- en: Characteristics of cloud native applications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云原生应用程序的特点
- en: Culture and practices supporting cloud native
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持云原生的文化和实践
- en: When and why you might consider the cloud native approach
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时以及为何考虑采用云原生方法
- en: Topologies and architectures for cloud native applications
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云原生应用程序的拓扑和架构
- en: Cloud native applications are highly distributed systems that live in the cloud
    and are resilient to change. Systems are made up of several services that communicate
    through a network and are deployed in a dynamic environment where everything keeps
    changing.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生应用程序是高度分布的系统，它们生活在云中，并且对变化具有弹性。系统由多个服务组成，这些服务通过网络进行通信，并在一个动态环境中部署，其中一切都在不断变化。
- en: Before diving into the technologies, it’s fundamental to define what cloud native
    is. Like other buzzwords in our field (such as *agile*, *DevOps*, or *microservices*),
    *cloud native* is sometimes misunderstood and can be a source of confusion because
    it means different things to different people.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨技术之前，定义什么是云原生是至关重要的。像我们领域中的其他流行词汇（如 *敏捷*、*DevOps* 或 *微服务*）一样，*云原生* 有时会被误解，并可能成为混淆的来源，因为它对不同的人意味着不同的事情。
- en: In this chapter, I’ll provide you with the conceptual tools you’ll need for
    the rest of the book. I’ll start by defining what cloud native means and what
    it takes for an application to be identified as such. I’ll explain the properties
    of cloud native applications, examine the characteristics of the cloud computing
    model, and discuss when and why you might want to move to the cloud. I’ll also
    present some fundamental concepts of cloud native topologies and architectures.
    Figure 1.1 shows an overview of the different elements I’ll cover in this chapter
    as I define and qualify cloud native systems. At the end of this chapter, you’ll
    be ready to start your journey building cloud native applications with Spring
    and deploying them to Kubernetes.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将为您提供本书其余部分所需的概念性工具。我将首先定义云原生意味着什么，以及一个应用程序如何被认定为云原生。我将解释云原生应用程序的特性，检查云计算模型的特性，并讨论何时以及为何你可能想要迁移到云。我还会介绍云原生拓扑和架构的一些基本概念。图
    1.1 展示了在本章中我将定义和验证的不同元素概览。在本章结束时，你将准备好开始使用 Spring 构建云原生应用程序并部署到 Kubernetes 的旅程。
- en: '![01-01](../Images/01-01.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![01-01](../Images/01-01.png)'
- en: Figure 1.1 Cloud native is an approach to application development aiming at
    leveraging cloud technologies.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 云原生是一种旨在利用云技术进行应用程序开发的方法。
- en: 1.1 What is cloud native?
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1 什么是云原生？
- en: On May 25, 2010, Paul Fremantle, a veteran of the cloud industry, wrote a post
    on his blog titled “Cloud Native.”[¹](#pgfId-1011921) He was among the first to
    use the term *cloud native*. At a time when concepts and technologies like microservices,
    Docker, DevOps, Kubernetes, and Spring Boot didn’t yet exist, Fremantle discussed
    what it takes for “applications and middleware to work well in a cloud environment”—to
    be *cloud native*—with his team at WSO2.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 2010 年 5 月 25 日，云行业的老将 Paul Fremantle 在他的博客上发布了一篇题为“Cloud Native”的文章。[¹](#pgfId-1011921)
    他是最早使用 *cloud native* 这个术语的人之一。在微服务、Docker、DevOps、Kubernetes 和 Spring Boot 等概念和技术还不存在的时候，Fremantle
    与他在 WSO2 的团队讨论了“应用程序和中间件在云环境中良好工作所需的条件”——即成为 *cloud native*。
- en: The key concept explained by Fremantle is that cloud native applications should
    be specifically designed for the cloud and have properties that take advantage
    of the cloud environment and the cloud computing model. You can move a traditional
    application (designed to run *on the ground*) to the cloud, an approach commonly
    referred to as “lift and shift,” but that doesn’t make the application *native*
    to the cloud. Let’s see what does.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Fremantle 解释的关键概念是，云原生应用程序应专门为云设计，并具有利用云环境和云计算模型特性的属性。你可以将传统应用程序（设计为在本地运行 *on
    the ground*）迁移到云中，这种做法通常被称为“提升和迁移”，但这并不意味着应用程序是云 *native* 的。让我们看看是什么意思。
- en: 1.1.1 The Three Ps of Cloud Native
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.1 云原生的三个 P
- en: What does it mean for applications to be designed specifically for the cloud?
    The Cloud Native Computing Foundation (CNCF) answers that question in its cloud
    native definition:[²](#pgfId-1012307)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序专门为云设计意味着什么？云原生计算基金会 (CNCF) 在其云原生定义中回答了这个问题：[²](#pgfId-1012307)
- en: Cloud native technologies empower organizations to build and run scalable applications
    in modern, dynamic environments such as public, private, and hybrid clouds. Containers,
    service meshes, microservices, immutable infrastructure, and declarative APIs
    exemplify this approach.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生技术使组织能够在现代、动态的环境中（如公共云、私有云和混合云）构建和运行可扩展的应用程序。容器、服务网格、微服务、不可变基础设施和声明式API是这种方法的例证。
- en: These techniques enable loosely coupled systems that are resilient, manageable,
    and observable. Combined with robust automation, they allow engineers to make
    high-impact changes frequently and predictably with minimal toil.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术使系统松散耦合，具有弹性、可管理和可观察性。结合强大的自动化，它们允许工程师频繁且可预测地做出高影响的变化，而工作量最小化。
- en: 'From this definition, I identify three points that I like to call *The Three
    Ps of Cloud Native*:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个定义中，我确定了三个我喜欢称之为*云原生的三个P*：
- en: '*Platforms*—Cloud native applications run on platforms based on dynamic, distributed
    environments: the clouds (public, private, or hybrid).'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*平台*—云原生应用运行在基于动态、分布式环境的平台上：云（公共的、私有的或混合的）。'
- en: '*Properties*—Cloud native applications are designed to be scalable, loosely
    coupled, resilient, manageable, and observable.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*属性*—云原生应用被设计成可扩展的、松散耦合的、有弹性的、可管理的和可观察的。'
- en: '*Practices*—Practices around cloud native applications—automation, continuous
    delivery, and DevOps—include robust automation combined with frequent and predictable
    changes.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实践*—围绕云原生应用的实践——自动化、持续交付和DevOps——包括强大的自动化以及频繁和可预测的变化。'
- en: What is the Cloud Native Computing Foundation?
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是云原生计算基金会？
- en: The Cloud Native Computing Foundation (CNCF) is part of the Linux Foundation,
    and it “builds sustainable ecosystems and fosters communities to support the growth
    and health of cloud native open-source software.” The CNCF hosts many cloud native
    technologies and projects to enable cloud portability without vendor lock-in.
    If you want to discover the many projects addressing any cloud native aspect,
    I recommend checking out the CNCF Cloud Native Interactive Landscape.^a
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生计算基金会（CNCF）是Linux基金会的一部分，它“构建可持续的生态系统，并培养社区以支持云原生开源软件的增长和健康。”CNCF托管了许多云原生技术和项目，以实现无供应商锁定机制的云可移植性。如果你想发现许多针对任何云原生方面的项目，我建议查看CNCF云原生交互式景观.^a
- en: ^a Cloud Native Computing Foundation, “CNCF Cloud Native Interactive Landscape,”
    [https://landscape.cncf.io/](https://landscape.cncf.io/).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ^a 云原生计算基金会，“CNCF云原生交互式景观”，[https://landscape.cncf.io/](https://landscape.cncf.io/).
- en: In the following sections I’ll examine those concepts further. However, I’d
    first like you to notice how the definition of cloud native is not tied to any
    specific implementation detail or technology. The CNCF mentions some in its definition,
    like containers and microservices, but they are just examples. One of the common
    misconceptions when starting a migration to the cloud is that you have to adopt
    a microservices architecture, build containers, and deploy them to Kubernetes.
    That is not true. Fremantle’s post in 2010 is proof of that. He didn’t mention
    any of those because they didn’t exist. Yet, the applications he described not
    only are still considered cloud native, but they also comply with the definition
    given by the CNCF eight years later.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我将进一步探讨这些概念。然而，我首先想让你注意到云原生定义并没有与任何特定的实现细节或技术绑定。CNCF在其定义中提到了一些，如容器和微服务，但它们只是例子。在开始迁移到云的过程中，常见的误解之一是必须采用微服务架构，构建容器，并将它们部署到Kubernetes。这并不正确。Fremantle在2010年的帖子就是证明。他没有提到这些，因为它们当时并不存在。然而，他描述的应用不仅仍然被认为是云原生，而且也符合CNCF在八年后给出的定义。
- en: 1.2 The cloud and the cloud computing model
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2 云和云计算模型
- en: 'Before focusing on the main characters, the cloud native applications, I’d
    like to set the scene by describing the context in which cloud native applications
    run: the *cloud* (figure 1.2). In this section, I’ll define the cloud and its
    main characteristics. After all, if cloud native applications are designed to
    work well in a cloud environment, we should know what kind of environment that
    is.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在专注于主要角色，即云原生应用之前，我想通过描述云原生应用运行的环境来设定场景：*云*（图1.2）。在本节中，我将定义云及其主要特征。毕竟，如果云原生应用被设计成在云环境中良好工作，我们就应该知道是什么样的环境。
- en: '![01-02](../Images/01-02.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![01-02](../Images/01-02.png)'
- en: Figure 1.2 The cloud is an IT infrastructure characterized by different computing
    models and offered as a service by providers according to the degree of control
    consumers need.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 云是一种IT基础设施，具有不同的计算模型，根据消费者需要的控制程度由提供商提供服务。
- en: The cloud is an IT infrastructure that supports the delivery of computing resources
    to consumers according to the cloud computing model. The National Institute of
    Standards and Technology (NIST) defines cloud computing as follows:[³](#pgfId-1013168)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 云是一种IT基础设施，根据云计算模式向消费者提供计算资源。美国国家标准与技术研究院（NIST）将云计算定义为如下：[³](#pgfId-1013168)
- en: Cloud computing is a model for enabling ubiquitous, convenient, on-demand network
    access to a shared pool of configurable computing resources (e.g., networks, servers,
    storage, applications, and services) that can be rapidly provisioned and released
    with minimal management effort or service provider interaction.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 云计算是一种使网络访问无处不在、方便、按需的共享计算资源池（例如，网络、服务器、存储、应用程序和服务）的模型，这些资源可以快速配置和释放，同时管理努力或服务提供商的交互最小化。
- en: Just like you get electricity from a provider rather than generating it on your
    own, with the cloud you can get computing resources (such as servers, storage,
    and networks) as a commodity.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 就像您从供应商那里获取电力而不是自己发电一样，通过云，您可以像获取商品一样获取计算资源（如服务器、存储和网络）。
- en: The cloud provider manages the underlying cloud infrastructure, so the consumer
    doesn’t need to worry about physical resources like machines or networks. Companies
    moving to the cloud can get all the computing resources they need via a network
    (usually the internet) through a set of APIs that allows them to provision and
    scale resources as they need on an on-demand, self-service basis.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 云服务提供商管理底层云基础设施，因此消费者无需担心物理资源，如机器或网络。转向云的公司可以通过网络（通常是互联网）通过一组API获取他们所需的全部计算资源，这些API允许他们在按需、自助的基础上根据需要配置和扩展资源。
- en: 'Elasticity is one of the main characteristics of this model: computing resources
    can be provisioned and released dynamically, depending on the demand.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 弹性是该模型的主要特征之一：计算资源可以根据需求动态配置和释放。
- en: Elasticity is the degree to which a system is able to adapt to workload changes
    by provisioning and de-provisioning resources in an autonomic manner, such that
    at each point in time the available resources match the current demand as closely
    as possible.[⁴](#pgfId-1013226)
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 弹性是指系统通过自动配置和取消配置资源的能力来适应工作负载变化，以便在每一时刻，可用的资源尽可能接近当前需求。[⁴](#pgfId-1013226)
- en: Traditional IT infrastructures weren’t able to provide elasticity. Companies
    had to calculate the maximum computing capabilities needed and set up an infrastructure
    that would support that, even if most of it was only required sometimes. With
    the cloud computing model, the usage of computing resources is monitored, and
    consumers only pay for what they actually use.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的IT基础设施无法提供弹性。公司不得不计算所需的最高计算能力，并建立一个即使大部分时间只需要一部分也能支持该能力的基础设施。在云计算模式下，计算资源的使用情况得到监控，消费者只需为他们实际使用的部分付费。
- en: There is no strict requirement about where the cloud infrastructure should be
    or who should manage it. There are several deployment models for delivering cloud
    services. The main ones are private cloud, public cloud, and hybrid cloud.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于云基础设施应该在哪里或由谁管理没有严格的要求。有几种云服务的部署模式。主要的有私有云、公有云和混合云。
- en: '*Private cloud*—Cloud infrastructure provisioned to be used by a single organization.
    It can be managed by the organization itself or by a third party, and it can be
    hosted on premises or externally. A private cloud is usually the preferred option
    for organizations dealing with sensitive data or highly critical systems. It is
    also a common choice for having complete control over the infrastructure’s compliance
    with specific laws and requirements like the General Data Protection Regulation
    (GDPR) or the California Consumer Privacy Act (CCPA). For example, banks and healthcare
    providers are likely to set up their own cloud infrastructure.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*私有云*——为单个组织提供使用的云基础设施。它可以由该组织自己或第三方管理，并且可以内部托管或外部托管。对于处理敏感数据或高度关键系统的组织来说，私有云通常是首选选项。它也是确保基础设施符合特定法律和要求的常见选择，如通用数据保护条例（GDPR）或加利福尼亚消费者隐私法案（CCPA）。例如，银行和医疗保健提供者可能会建立自己的云基础设施。'
- en: '*Public cloud*—Cloud infrastructure provisioned for public use. It is usually
    owned and managed by an organization, the *cloud provider*, and is hosted on the
    provider’s premises. Examples of public cloud service providers are Amazon Web
    Services (AWS), Microsoft Azure, Google Cloud, Alibaba Cloud, and DigitalOcean.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*公有云*—为公共使用而提供的云基础设施。它通常由一个组织，即*云服务提供商*拥有和管理，并托管在提供商的场所。公有云服务提供商的例子包括亚马逊网络服务（AWS）、微软Azure、谷歌云、阿里云和DigitalOcean。'
- en: '*Hybrid cloud*—Composition of two or more distinct cloud infrastructures belonging
    to any of the previous types, bound together and offering services as if they
    were one single environment.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*混合云*—由两种或更多不同类型的云基础设施组成，这些基础设施属于之前提到的任何一种类型，它们被绑定在一起，提供如同单一环境的服务。'
- en: Figure 1.3 describes the five leading cloud computing service models, what is
    provided by the platform in each model, and which abstractions are provided to
    the consumer. For example, with the Infrastructure as a Service (IaaS) model,
    the platform provides and manages computing, storage, and networking resources,
    whereas the consumer provisions and manages virtual machines. The decision about
    which service model to choose should be driven by the degree of control the consumer
    needs over the infrastructure and which type of computing resources they need
    to manage.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3描述了五种主要的云计算服务模型，每个模型中平台提供的内容，以及提供给消费者的哪些抽象。例如，在基础设施即服务（IaaS）模型中，平台提供并管理计算、存储和网络资源，而消费者则配置和管理虚拟机。选择哪种服务模型的决定应该由消费者对基础设施的控制程度以及他们需要管理的计算资源类型来驱动。
- en: '![01-03](../Images/01-03.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![01-03](../Images/01-03.png)'
- en: Figure 1.3 The cloud computing service models differ by the level of abstraction
    they provide and who is responsible for managing which levels (the platform or
    the consumer).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 云计算服务模型的不同之处在于它们提供的抽象级别以及谁负责管理哪些级别（平台或消费者）。
- en: 1.2.1 Infrastructure as a Service (IaaS)
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.1 基础设施即服务（IaaS）
- en: In the *Infrastructure as a Service* (IaaS) model, consumers can directly control
    and provision resources like servers, storage, and networks. For example, they
    can provision virtual machines and install software like operating systems and
    libraries. Even though this model has been used for a while, it was in 2006 that
    Amazon made it popular and widely accessible with Amazon Web Services (AWS). Examples
    of IaaS offerings are AWS Elastic Compute Cloud (EC2), Azure Virtual Machines,
    Google Compute Engine, Alibaba Virtual Machines, and DigitalOcean Droplets.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在*基础设施即服务*（IaaS）模型中，消费者可以直接控制和配置资源，如服务器、存储和网络。例如，他们可以配置虚拟机并安装操作系统和库等软件。尽管这种模型已经使用了很长时间，但直到2006年，亚马逊通过亚马逊网络服务（AWS）使其变得流行并广泛可用。IaaS提供的例子包括AWS弹性计算云（EC2）、Azure虚拟机、谷歌计算引擎、阿里云虚拟机和DigitalOcean
    Droplets。
- en: 1.2.2 Container as a Service (CaaS)
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.2 容器即服务（CaaS）
- en: 'Using the *Container as a Service* (CaaS) model, consumers cannot control primitive
    virtualization resources. Instead, they provision and manage containers. The cloud
    provider takes care of provisioning the underlying resources that fulfill the
    needs of those containers, such as by starting new virtual machines and configuring
    networks to make them accessible through the internet. Docker Swarm, Apache Mesos,
    and Kubernetes are examples of tools used to build container platforms. All major
    cloud providers offer a managed Kubernetes service, which has become the de facto
    technology for CaaS offerings: Amazon Elastic Kubernetes Service (EKS), Azure
    Kubernetes Service (AKS), Google Kubernetes Engine (GKE), Alibaba Container Service
    for Kubernetes (ACK), and DigitalOcean Kubernetes.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*容器即服务*（CaaS）模型，消费者无法控制原始的虚拟化资源。相反，他们配置和管理容器。云服务提供商负责配置满足这些容器需求的基础资源，例如通过启动新的虚拟机并配置网络使其可通过互联网访问。Docker
    Swarm、Apache Mesos和Kubernetes是构建容器平台所使用的工具的例子。所有主要的云服务提供商都提供托管Kubernetes服务，这已成为CaaS提供的实际技术：亚马逊弹性Kubernetes服务（EKS）、Azure
    Kubernetes服务（AKS）、谷歌Kubernetes引擎（GKE）、阿里云Kubernetes容器服务（ACK）和DigitalOcean Kubernetes。
- en: 1.2.3 Platform as a Service (PaaS)
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.3 平台即服务（PaaS）
- en: In the *Platform as a Service* (PaaS) model, the platform provides infrastructure,
    tools, and APIs that developers can use to build and deploy applications. For
    example, as a developer, you can build a Java application, package it as a Java
    Archive (JAR) file, and then deploy it to a platform working according to the
    PaaS model. The platform provides the Java runtime and other required middleware,
    and it can also offer extra services like databases or messaging systems. Examples
    of PaaS offerings are Cloud Foundry, Heroku, AWS Elastic Beanstalk, Azure App
    Service, Google App Engine, Alibaba Web App Service, and DigitalOcean App Platform.
    In the past few years, vendors have been converging on Kubernetes for building
    a new PaaS experience for developers and operators. Examples of this new generation
    of services are VMware Tanzu Application Platform and RedHat OpenShift.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在*平台即服务*（PaaS）模型中，平台提供基础设施、工具和API，开发者可以使用它们来构建和部署应用程序。例如，作为一名开发者，你可以构建一个Java应用程序，将其打包成Java归档（JAR）文件，然后将其部署到一个按照PaaS模型工作的平台上。平台提供Java运行时和其他所需的中间件，还可以提供额外的服务，如数据库或消息系统。PaaS服务的例子包括Cloud
    Foundry、Heroku、AWS Elastic Beanstalk、Azure App Service、Google App Engine、Alibaba
    Web App Service和DigitalOcean App Platform。在过去的几年里，供应商们正逐渐转向Kubernetes，为开发者和运维人员构建新的PaaS体验。这些新一代服务的例子包括VMware
    Tanzu Application Platform和RedHat OpenShift。
- en: 1.2.4 Function as a Service (FaaS)
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.4 函数即服务（FaaS）
- en: The *Function as a Service* (FaaS) model relies on serverless computing to let
    consumers focus on implementing the business logic of their applications (often
    in the form of functions), whereas the platform takes care of providing servers
    and the rest of the infrastructure. Serverless applications are triggered by events,
    such as HTTP requests or messages. For example, you might code a function that
    analyzes a data set whenever available from a message queue and computes results
    according to some algorithms. Examples of commercial FaaS offerings are Amazon
    AWS Lambda, Microsoft Azure Functions, Google Cloud Functions, and Alibaba Functions
    Compute. Examples of open source FaaS offerings are Knative and Apache OpenWhisk.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数即服务*（FaaS）模型依赖于无服务器计算，让消费者专注于实现其应用程序的业务逻辑（通常以函数的形式），而平台则负责提供服务器和其余的基础设施。无服务器应用程序由事件触发，例如HTTP请求或消息。例如，你可能编写一个函数，当从消息队列中可用时分析数据集，并按照某些算法计算结果。商业FaaS服务的例子包括Amazon
    AWS Lambda、Microsoft Azure Functions、Google Cloud Functions和Alibaba Functions
    Compute。开源FaaS服务的例子包括Knative和Apache OpenWhisk。'
- en: 1.2.5 Software as a Service (SaaS)
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.5 软件即服务（SaaS）
- en: The service with the highest abstraction is *Software as a Service* (SaaS).
    In this model, consumers access applications as users, while the cloud provider
    manages the whole stack of software and infrastructure. Many companies build their
    applications, use a CaaS or PaaS model to run them, and then sell their usage
    to the end customers as SaaS. The consumers of SaaS applications typically use
    thin clients like web browsers or mobile devices to access them. Examples of applications
    available as SaaS are Proton Mail, GitHub, Plausible Analytics, and Microsoft
    Office 365.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最高抽象级别的服务是*软件即服务*（SaaS）。在这个模型中，消费者作为用户访问应用程序，而云服务提供商管理整个软件和基础设施栈。许多公司构建自己的应用程序，使用CaaS或PaaS模型来运行它们，然后将使用情况作为SaaS销售给最终客户。SaaS应用程序的消费者通常使用瘦客户端，如网络浏览器或移动设备来访问它们。可作为SaaS提供的应用程序示例包括Proton
    Mail、GitHub、Plausible Analytics和Microsoft Office 365。
- en: Platform vs. PaaS
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 平台与PaaS
- en: '*Platform* is a term that might generate some confusion in a cloud native discussion,
    so let’s clarify. In general, a platform is an operating environment you use to
    run and manage your applications. Google Kubernetes Engine (GKE) is a platform
    that offers cloud services according to the CaaS model. Microsoft Azure Functions
    is a platform that provides cloud services following the FaaS model. At a lower
    level, if you deploy your applications directly on an Ubuntu machine, that will
    be your platform. In the rest of the book, whenever I use the term *platform*,
    I mean the broader concept just explained, unless specified otherwise.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*平台*这个术语在云原生讨论中可能会引起一些混淆，所以让我们澄清一下。一般来说，平台是一个你用来运行和管理应用程序的操作环境。Google Kubernetes
    Engine（GKE）是一个提供CaaS模型云服务的平台。Microsoft Azure Functions是一个提供遵循FaaS模型云服务的平台。在较低级别，如果你直接在Ubuntu机器上部署你的应用程序，那么那将是你的平台。在本书的其余部分，当我使用*平台*这个术语时，我指的是前面解释的更广泛的概念，除非另有说明。'
- en: 1.3 Properties of cloud native applications
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3 云原生应用程序的特性
- en: 'The scene is set: you are in the cloud. How should you design applications
    to take advantage of its characteristics?'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 场景设定：你身处云中。你应该如何设计应用程序以利用其特性？
- en: 'The CNCF identifies five main properties that cloud native applications should
    have: scalability, loose coupling, resilience, observability, and manageability.
    Cloud native is a methodology for building and running applications that exhibit
    those properties. Cornelia Davis sums it up by stating that “cloud-native software
    is defined by how you compute, not about where you compute.”[⁵](#pgfId-1013729)
    In other words, the cloud is about *where*, and cloud native is about *how*.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: CNCF确定了云原生应用程序应具备的五个主要特性：可扩展性、松耦合、弹性、可观察性和可管理性。云原生是一种构建和运行具有这些特性的应用程序的方法。Cornelia
    Davis总结说：“云原生软件的定义在于你如何计算，而不是你计算在哪里。”[⁵](#pgfId-1013729)换句话说，云关乎“在哪里”，而云原生关乎“如何”。
- en: 'I have already covered the *where* part: the cloud. Let’s go ahead and explore
    the *how*. For a quick reference, figure 1.4 lists the properties with short descriptions.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经涵盖了“在哪里”的部分：云。让我们继续探索“如何”。为了快速参考，图1.4列出了特性及其简要描述。
- en: '![01-04](../Images/01-04.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![01-04](../Images/01-04.png)'
- en: Figure 1.4 The main properties of cloud native applications
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 云原生应用程序的主要特性
- en: 1.3.1 Scalability
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.1 可扩展性
- en: 'Cloud native applications are designed to *scale*, meaning that they can support
    increasing workloads if provided with additional resources. Depending on the nature
    of those extra resources, we can distinguish between vertical scalability and
    horizontal scalability:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生应用程序被设计为*可扩展*，这意味着如果提供额外的资源，它们可以支持增加的工作负载。根据这些额外资源的性质，我们可以区分垂直可扩展性和水平可扩展性：
- en: '*Vertical scalability* —Scaling vertically, or scaling up or down, means adding
    hardware resources to or removing them from the computing node, such as CPU or
    memory. This approach is limited, since it’s not possible to keep adding hardware
    resources. On the other hand, applications don’t need to be explicitly designed
    to be scaled up or down.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*垂直可扩展性*——垂直扩展，或扩展或缩减，意味着向计算节点添加硬件资源或从计算节点中移除它们，例如CPU或内存。这种方法是有限的，因为不可能无限制地添加硬件资源。另一方面，应用程序不需要被明确设计为可扩展或缩减。'
- en: '*Horizontal scalability* —Scaling horizontally, or scaling out or in, means
    adding more computing nodes or containers to, or removing them from, the system.
    This approach doesn’t have the same limits as vertical scalability, but it requires
    applications to be scalable.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*水平可扩展性*——水平扩展，或扩展或缩减，意味着向系统添加更多计算节点或容器，或者从系统中移除它们。这种方法没有垂直可扩展性那样的限制，但它要求应用程序是可扩展的。'
- en: Traditional systems would usually adopt vertical scalability in the event of
    increasing workloads. Adding CPU and memory was a common approach to enable an
    application to support more users without redesigning it for scalability. This
    is still a good option in specific scenarios, but we need something else for the
    cloud.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在工作负载增加的情况下，传统系统通常会采用垂直可扩展性。增加CPU和内存是使应用程序能够支持更多用户而不需要为可扩展性重新设计的常见方法。在特定场景下，这仍然是一个好选择，但我们需要为云做些其他事情。
- en: 'In the cloud, where everything is dynamic and in constant change, horizontal
    scalability is preferred. Thanks to the abstraction levels offered by the cloud
    computing models, it’s straightforward to spin up new instances of your application
    rather than increasing the computational power of the machines already running.
    Since the cloud is elastic, we can scale application instances in and out quickly
    and dynamically. I discussed elasticity as one of the main characteristics of
    the cloud: computing resources can be provisioned and released proactively, depending
    on the demand. Scalability is a prerequisite for elasticity.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在云环境中，由于一切都在动态变化中，因此水平扩展更受欢迎。得益于云计算模型提供的抽象层，启动应用程序的新实例比增加已运行机器的计算能力要简单得多。由于云是弹性的，我们可以快速且动态地扩展和缩减应用程序实例。我讨论了弹性作为云的主要特性之一：计算资源可以根据需求主动配置和释放。可扩展性是弹性的先决条件。
- en: Figure 1.5 shows the difference between vertical and horizontal scalability.
    In the first case, we scale by adding more resources to the existing virtual machine.
    In the second case, we add another virtual machine to help the existing one process
    the extra workload.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5显示了垂直和水平可扩展性的区别。在第一种情况下，我们通过向现有的虚拟机添加更多资源来进行扩展。在第二种情况下，我们添加另一个虚拟机以帮助现有的虚拟机处理额外的工作负载。
- en: '![01-05](../Images/01-05.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![01-05](../Images/01-05.png)'
- en: Figure 1.5 When you need to support increasing workloads, the vertical scalability
    model will add hardware resources to the computing node, while the horizontal
    scalability model will add more computing nodes.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5 当需要支持增加的工作负载时，垂直可扩展性模型会向计算节点添加硬件资源，而水平可扩展性模型则会添加更多的计算节点。
- en: As you’ll see when we discuss Kubernetes, the platform (whether CaaS, PaaS,
    or something else) takes care of scaling applications in and out dynamically.
    As developers, it’s our responsibility to design applications that can be scaled.
    The big obstacle to scalability is application state, which essentially is a matter
    of whether an application is stateful or stateless. Throughout the book, I’ll
    cover techniques for building stateless applications and enabling them to scale
    without issues. Among other things, I’ll show you how to push the application
    state from Spring to data stores like PostgreSQL and Redis.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论Kubernetes时，您将看到，平台（无论是CaaS、PaaS还是其他什么）负责动态地扩展和缩减应用程序。作为开发者，我们的责任是设计可扩展的应用程序。可扩展性的主要障碍是应用程序状态，这本质上是一个应用程序是否具有状态的问题。在整本书中，我将介绍构建无状态应用程序并使其无问题扩展的技术。其中之一，我将向您展示如何将应用程序状态从Spring推送到像PostgreSQL和Redis这样的数据存储中。
- en: 1.3.2 Loose coupling
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.2 松耦合
- en: '*Loose coupling* is an essential property of a system where parts have as little
    knowledge of each other as possible. The goal is to evolve each piece independently
    so that when one is changed, the others don’t need to change accordingly.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*松耦合*是一个系统的基本属性，其中各个部分尽可能少地了解彼此。目标是独立地发展每个部分，以便当一个部分发生变化时，其他部分不需要相应地改变。'
- en: '*Coupling*, and its twin concept *cohesion*, have played an essential role
    in software engineering for decades. It’s a good design practice to decompose
    a system into modules (*modularization*), each of which has minimal dependencies
    on the other parts (loose coupling) and to encapsulate code that changes together
    (high cohesion). Depending on the architectural style, a module can model a monolithic
    component or a standalone service (for example, a microservice). Either way, we
    should aim at achieving proper modularization with loose coupling and high cohesion.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*耦合*及其孪生概念*内聚*在软件工程中已经扮演了数十年的关键角色。将系统分解为模块（*模块化*）是一种良好的设计实践，其中每个模块对其他部分的依赖最小（松耦合）并且封装一起变化的代码（高内聚）。根据架构风格，一个模块可以模拟一个单体组件或一个独立的服务（例如，一个微服务）。无论哪种方式，我们都应该努力实现适当的模块化，同时保持松耦合和高内聚。'
- en: Parnas identified three benefits of modularization:[⁶](#pgfId-1014078)
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Parnas确定了模块化的三个好处:[⁶](#pgfId-1014078)
- en: '*Managerial*—Since each module is loosely coupled, the team responsible for
    it should not need to spend much time coordinating and communicating with other
    teams.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*管理性*——由于每个模块都是松耦合的，因此负责该模块的团队不需要花费太多时间与其他团队协调和沟通。'
- en: '*Product flexibility*—The overall system should be flexible since each module
    is evolved independently of the others.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*产品灵活性*——整体系统应该是灵活的，因为每个模块都是独立于其他模块进行演化的。'
- en: '*Comprehensibility*—People should be able to understand and work with a module
    without having to study the whole system.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可理解性*——人们应该能够在不研究整个系统的情况下理解并使用一个模块。'
- en: 'The preceding benefits are usually among those associated with microservices,
    but the truth is that you don’t need microservices to achieve them. In the last
    few years, many organizations have decided to migrate from monoliths to microservices.
    Some of them have failed because they lacked proper modularization. A monolith
    made up of tightly coupled, non-cohesive components, when migrated, produces a
    tightly coupled, non-cohesive microservice system, which sometimes is referred
    to as a *distributed monolith*. I don’t consider this a good name because it implies
    that monoliths are made up of tightly coupled, non-cohesive components by definition.
    That’s not true. The architectural style doesn’t matter: a bad design is a bad
    design. Indeed, I like the *modular monolith* term proposed by Simon Brown to
    increase awareness that monoliths can promote loose coupling and high cohesion,
    and that both monoliths and microservices can end up being “big balls of mud.”'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的好处通常与微服务相关联，但事实是，您不需要微服务就能实现这些好处。在过去的几年里，许多组织决定从单体迁移到微服务。其中一些失败是因为它们缺乏适当的模块化。由紧密耦合、缺乏凝聚力的组件组成的单体在迁移时会产生一个紧密耦合、缺乏凝聚力的微服务系统，有时被称为*分布式单体*。我不认为这是一个好名字，因为它暗示了单体本质上是由紧密耦合、缺乏凝聚力的组件组成的。这不是真的。架构风格并不重要：坏的设计就是坏的设计。事实上，我喜欢Simon
    Brown提出的*模块化单体*这个术语，以提高人们对单体可以促进松耦合和高凝聚力的认识，以及单体和微服务最终都可能变成“大泥球”的认识。
- en: Throughout the book, I’ll discuss some techniques for enforcing loose coupling
    in applications. In particular, we’ll adopt a service-based architecture and focus
    on building services with clear interfaces to communicate with each other, minimal
    dependencies on other services, and high cohesion.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我将讨论一些强制实施应用程序中松耦合的技术。特别是，我们将采用基于服务的架构，并专注于构建具有清晰接口的服务，以便相互通信，对其他服务的依赖性最小，并且具有高度的凝聚力。
- en: 1.3.3 Resilience
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.3 弹性
- en: A system is resilient if it provides its services even in the presence of faults
    or environmental changes. Resilience is “the capability of a hardware-software
    network to provide and maintain an acceptable level of service in the face of
    faults and challenges to normal operation.”[⁷](#pgfId-1014227)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果系统即使在出现故障或环境变化的情况下也能提供其服务，则该系统是弹性的。弹性是“硬件-软件网络在面临故障和正常操作挑战时提供并维持可接受服务水平的特性。”[⁷](#pgfId-1014227)
- en: 'When building cloud native systems, our goal should be to guarantee that our
    applications are always available, whether there is a failure in the infrastructure
    or in our software. Cloud native applications run in a dynamic environment where
    everything keeps changing, and faults can and will occur. This cannot be prevented.
    In the past, we used to consider changes and faults as exceptions, but for highly
    distributed systems like cloud native ones, changes are not exceptions: they are
    the rule.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建云原生系统时，我们的目标应该是确保我们的应用程序始终可用，无论基础设施或软件中是否存在故障。云原生应用程序运行在动态环境中，一切都在不断变化，故障可能发生，也必然会发生。这无法避免。在过去，我们曾将变化和故障视为例外，但对于像云原生这样的高度分布式系统，变化不是例外：它们是规则。
- en: 'When discussing resilience, it’s worth defining three essential concepts: fault,
    error, and failure:[⁸](#pgfId-1014264)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论弹性时，值得定义三个基本概念：故障、错误和故障：[⁸](#pgfId-1014264)
- en: '*Fault*—A fault is a defect that produces an incorrect internal state either
    in the software or the infrastructure. For example, a method call returns a null
    value, even if its specification mandates that a non-null value is returned.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*错误*—错误是软件或基础设施中产生不正确内部状态的一种缺陷。例如，即使其规范要求返回非空值，方法调用也可能返回null值。'
- en: '*Error*—An error is a discrepancy between the expected behavior of a system
    and the actual one. For example, due to the preceding fault, a NullPointerException
    is thrown.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*错误*—错误是系统预期行为与实际行为之间的差异。例如，由于前面的故障，抛出了NullPointerException。'
- en: '*Failure*—When a fault is triggered and results in an error, a failure might
    occur, making the system unresponsive and unable to behave according to its specifications.
    For example, if the NullPointerException is not caught, the error provokes a failure:
    the system responds to any request with a 500 response.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*故障*—当触发故障并导致错误时，可能会发生故障，使系统无法响应，无法按照其规格行事。例如，如果未捕获到NullPointerException，错误会引发故障：系统对任何请求都返回500响应。'
- en: Faults can become errors, which may provoke failures, so we should design applications
    to be *fault tolerant*. An essential part of resilience is ensuring that a failure
    will not cascade to other components of the system but stay isolated while it
    gets fixed. We also want the system to be *self-repairing* or *self-healing*,
    and the cloud model can enable that.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 故障可能会变成错误，这可能会引发故障，因此我们应该设计容错的应用程序。弹性的一个重要部分是确保故障不会级联到系统的其他组件，而是在修复期间保持隔离。我们还希望系统能够自我修复或自我恢复，云模型可以实现这一点。
- en: Throughout the book, I’ll show you some techniques for tolerating faults and
    preventing their effects from propagating to other parts of the system and spreading
    the failure. For example, we’ll use patterns like circuit breakers, retries, timeouts,
    and rate limiters.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我将向你展示一些容忍故障和防止其影响传播到系统其他部分以及扩散故障的技术。例如，我们将使用断路器、重试、超时和速率限制等模式。
- en: 1.3.4 Observability
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.4 可观测性
- en: Observability is a property that comes from the world of control theory. If
    you consider a system, observability is a measure of how well you can infer its
    internal state from its external outputs. In the software engineering context,
    the system is a single application or a distributed system as a whole. The external
    outputs can be data like metrics, logs, and traces. Figure 1.6 shows how observability
    works.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 可观测性是来自控制理论世界的属性。如果你考虑一个系统，可观测性是衡量你从其外部输出推断其内部状态有多好的一个指标。在软件工程背景下，系统可以是单个应用程序或整个分布式系统。外部输出可以是指标、日志和跟踪等数据。图1.6展示了可观测性是如何工作的。
- en: '![01-06](../Images/01-06.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![01-06](../Images/01-06.png)'
- en: Figure 1.6 Observability is about inferring the internal state of an application
    from its external outputs. Manageability is about changing the internal state
    and outputs via external inputs. In both cases, the application artifact is never
    changed. It’s immutable.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6 可观测性是关于从应用程序的外部输出推断其内部状态。可管理性是关于通过外部输入改变内部状态和输出。在这两种情况下，应用程序的工件永远不会改变。它是不可变的。
- en: The Observability Engineering team at Twitter identifies four pillars of observability:[⁹](#pgfId-1014452)
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Twitter的可观测性工程团队确定了可观测性的四个支柱：[⁹](#pgfId-1014452)
- en: '*Monitoring*—Monitoring is about measuring specific aspects of an application
    to get information on its overall health and identify failures. In this book,
    you’ll learn about the useful monitoring features of Spring Boot Actuator and
    integrate Prometheus with Spring to export relevant metrics about an application.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*监控*—监控是关于测量应用程序的特定方面以获取其整体健康状况和识别故障的信息。在这本书中，你将了解Spring Boot Actuator的有用监控功能，并将Prometheus与Spring集成以导出有关应用程序的相关指标。'
- en: '*Alerting/visualization*—Collecting data about the state of a system is useful
    only if it’s used to take some action. When a failure is identified while monitoring
    an application, an alert should be triggered, and some action should be taken
    to handle it. Specific dashboards are used to visualize the data collected and
    plot them in relevant graphs to provide a good picture of the system’s behavior.
    This book will show how to use Grafana to visualize data collected from cloud
    native applications.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*警报/可视化*—收集关于系统状态的资料只有在用于采取某些行动时才有用。当在监控应用程序时识别到故障，应触发警报，并采取一些行动来处理它。特定的仪表板用于可视化收集到的数据，并将它们绘制在相关的图表中，以提供系统行为的良好视图。本书将展示如何使用Grafana来可视化从云原生应用程序收集到的数据。'
- en: '*Distributed systems tracing infrastructure*—In a distributed system, it’s
    not enough to track every single subsystem’s behavior. It’s essential to trace
    the data flowing through the different subsystems. In this book, you’ll integrate
    Spring with OpenTelemetry and use Grafana Tempo to collect and visualize the traces.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分布式系统跟踪基础设施*—在分布式系统中，仅仅跟踪每个子系统的行为是不够的。跟踪通过不同子系统流动的数据是至关重要的。在这本书中，你将集成Spring和OpenTelemetry，并使用Grafana
    Tempo收集和可视化跟踪。'
- en: '*Log aggregation/analytics*—Keeping track of the main events in an application
    is critical to infer the software’s behavior and debug it if something goes wrong.
    In a cloud native system, logs should be aggregated and collected to provide a
    better picture of the system’s behavior and ensure the possibility of running
    analytics to mine information from that data. Throughout the book, I’ll talk more
    about logs. You’ll use Fluent Bit, Loki, and Grafana to collect and visualize
    logs, and you’ll learn the best practices for logging in a cloud native context.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*日志聚合/分析*——跟踪应用程序中的主要事件对于推断软件的行为以及在出现问题时进行调试至关重要。在云原生系统中，日志应该被聚合和收集，以提供对系统行为的更好了解，并确保能够运行分析以从这些数据中提取信息。在整个书中，我将更多地讨论日志。您将使用
    Fluent Bit、Loki 和 Grafana 来收集和可视化日志，并学习在云原生环境中日志的最佳实践。'
- en: 1.3.5 Manageability
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.5 可管理性
- en: 'In control theory, the counterpart of observability is controllability—the
    ability of external input to change the state or the output of a system in a finite
    time interval. This concept leads us to the last of the main properties of cloud
    native: manageability.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制理论中，可观察性的对应物是可控性——外部输入在有限时间间隔内改变系统状态或输出的能力。这个概念引导我们来到云原生主要特性的最后一个：可管理性。
- en: Drawing from control theory again, we can say that manageability measures how
    easily and efficiently an external input can change the state or the output of
    a system. In less mathematical terms, it’s the ability to modify an application’s
    behavior without needing to change its code. This is not to be confused with *maintainability*,
    which measures how easily and efficiently you can change a system from the inside
    by changing its code. Figure 1.6 shows how manageability works.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 再次从控制理论中汲取灵感，我们可以这样说，可管理性衡量外部输入改变系统状态或输出的容易程度和效率。用不那么数学化的语言来说，这是在不改变代码的情况下修改应用程序行为的能力。这不同于*可维护性*，可维护性衡量的是你通过改变代码从内部改变系统容易程度和效率。图
    1.6 展示了可管理性是如何工作的。
- en: 'One aspect of manageability is deploying and updating applications while keeping
    the overall system up and running. Another element is configuration, which I’ll
    address in depth throughout the book. We want to make cloud native applications
    configurable so we can modify their behavior without changing their code and building
    a new release. It’s common to make configurable settings like data source URLs,
    service credentials, and certificates. For example, depending on the environment,
    you may use different data sources: one for development, one for testing, and
    one for production. Other types of configuration could be feature flags, which
    determine whether specific features should be enabled at runtime. I’ll show you
    different strategies for configuring applications throughout the book, including
    using Spring Cloud Config Server, Kubernetes ConfigMaps and Secrets, and Kustomize.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 可管理性的一方面是在保持整体系统运行的同时部署和更新应用程序。另一个要素是配置，我将在整本书中深入探讨。我们希望云原生应用程序可配置，这样我们就可以在不改变代码和构建新版本的情况下修改它们的行为。常见的可配置设置包括数据源
    URL、服务凭证和证书。例如，根据环境的不同，您可能使用不同的数据源：一个用于开发，一个用于测试，一个用于生产。其他类型的配置可能是功能标志，它决定了在运行时是否应该启用特定功能。我将在整本书中向您展示配置应用程序的不同策略，包括使用
    Spring Cloud Config Server、Kubernetes ConfigMaps 和 Secrets 以及 Kustomize。
- en: 'Manageability is not only about particular changes themselves, but also about
    how easily and efficiently you can apply those changes. Cloud native systems are
    complex, so it’s essential to design applications that can adapt to changing requirements
    regarding functionality, the environment, and security. Due to this complexity,
    we should aim at managing as much as possible through automation, which leads
    us to the last of the Three Ps of Cloud Native: practices.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 可管理性不仅关乎特定的变化本身，还关乎你能够多么轻松和高效地应用这些变化。云原生系统复杂，因此设计能够适应功能、环境和安全方面变化要求的应用至关重要。由于这种复杂性，我们应该尽可能通过自动化来管理，这使我们转向云原生三大原则中的最后一个：实践。
- en: 1.4 Culture and practices supporting cloud native
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.4 支持云原生的文化和实践
- en: 'This section will focus on the last sentence of the definition of cloud native
    technologies provided by the CNCF: “Combined with robust automation, they allow
    engineers to make high-impact changes frequently and predictably with minimal
    toil.” I’ll discuss three concepts: automation, continuous delivery, and DevOps
    (figure 1.7).'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将重点关注 CNCF 提供的云原生技术定义中的最后一句：“结合强大的自动化，它们允许工程师频繁且可预测地以最小的努力进行高影响力的更改。” 我将讨论三个概念：自动化、持续交付和
    DevOps（图 1.7）。
- en: '![01-07](../Images/01-07.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![01-07](../Images/01-07.png)'
- en: Figure 1.7 Culture and practices for cloud native development
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.7 云原生开发的文化和实践
- en: 1.4.1 Automation
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4.1 自动化
- en: Automation is a core tenet of cloud native. The idea is to automate repetitive
    manual tasks to accelerate the delivery and deployment of cloud native applications.
    Many tasks can be automated, from building applications to deploying them, from
    provisioning infrastructure to managing configuration. The most important advantage
    of automation is that it makes processes and tasks repeatable and overall systems
    more stable and reliable. Manually executing a task is error-prone and costs money.
    By automating it, we can get a result that is both more reliable and more efficient.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化是云原生的核心原则。其理念是通过自动化重复的手动任务来加速云原生应用程序的交付和部署。许多任务可以自动化，从构建应用程序到部署它们，从配置基础设施到管理配置。自动化最重要的优势是它使流程和任务可重复，并使整体系统更加稳定和可靠。手动执行任务容易出错且成本高昂。通过自动化，我们可以得到既可靠又高效的成果。
- en: In the cloud computing model, computing resources are provisioned in an automated,
    self-service model, and they can be increased or decreased elastically. Two significant
    categories of automation for the cloud are infrastructure provisioning and configuration
    management. We call them *infrastructure as code* and *configuration as code*.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在云计算模型中，计算资源以自动化、自助服务的方式提供，并且可以弹性地增加或减少。云的自动化有两个重要类别：基础设施配置和配置管理。我们称它们为“基础设施即代码”和“配置即代码”。
- en: Martin Fowler defines *infrastructure as code* as “the approach to defining
    computing and network infrastructure through source code that can then be treated
    just like any software system.”[^(10)](#pgfId-1015287)
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 马丁·福勒将“基础设施即代码”定义为“通过源代码定义计算和网络基础设施的方法，然后可以像任何软件系统一样对待。”[^(10)](#pgfId-1015287)
- en: Cloud providers offer convenient APIs for creating and provisioning servers,
    networks, and storage. By automating those tasks with a tool like Terraform, putting
    the code in source control, and applying the same test and delivery practices
    used for application development, we get a more reliable and predictable infrastructure,
    which is reproducible, more efficient, and less risky. A simple example of an
    automated task could be creating a new virtual machine with 8 CPUs, 64 GB of memory,
    and Ubuntu 22.04 as the operating system.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 云服务提供商提供了方便的 API 来创建和配置服务器、网络和存储。通过使用 Terraform 等工具自动化这些任务，将代码放入源代码控制，并应用与应用程序开发中使用的相同测试和交付实践，我们得到一个更可靠和可预测的基础设施，它是可重复的、更高效的，且风险更低。一个简单的自动化任务示例可以是创建一个具有
    8 个 CPU、64 GB 内存和 Ubuntu 22.04 作为操作系统的虚拟机。
- en: After we’ve provisioned computing resources, we can manage them and automate
    their configuration. Paraphrasing the previous definition, *configuration as code*
    is the approach to defining the configuration of computing resources through source
    code, which can be treated just like any software system.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们配置了计算资源之后，我们可以管理它们并自动化它们的配置。根据之前的定义，我们可以将“配置即代码”解释为通过源代码定义计算资源配置的方法，它可以像任何软件系统一样对待。
- en: Using tools like Ansible, we can specify how a server or a network should be
    configured. For example, after provisioning the Ubuntu server from the previous
    paragraph, we can automate the task of installing the Java Runtime Environment
    (JRE) 17 and opening the ports 8080 and 8443 from the firewall. Configuration
    as code applies to application configuration as well.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Ansible 等工具，我们可以指定服务器或网络应该如何配置。例如，在上一段中配置 Ubuntu 服务器之后，我们可以自动化安装 Java 运行时环境
    (JRE) 17 和从防火墙中打开端口 8080 和 8443 的任务。配置即代码也适用于应用程序配置。
- en: 'By automating all the infrastructure provisioning and configuration management
    tasks, we can avoid unstable, unreliable *snowflake servers*. When each server
    is provisioned, managed, and configured manually, the result is a *snowflake*
    : a fragile, unique server that cannot be reproduced and is risky to change. Automation
    helps avoid snowflakes in favor of *phoenix servers*: all tasks acting on those
    servers are automated, every change can be tracked in source control, reducing
    risks, and each setup is reproducible. By taking this concept to its extreme,
    we achieve the so-called *immutable servers*, also mentioned by the CNCF in its
    cloud native definition as immutable infrastructure.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 通过自动化所有基础设施配置和管理任务，我们可以避免不稳定的、不可靠的 *雪花服务器*。当每个服务器都是手动配置、管理和配置时，结果是 *雪花*：一个脆弱的、独特的服务器，无法复制且更改风险高。自动化有助于避免雪花，转而使用
    *凤凰服务器*：所有作用于这些服务器的任务都是自动化的，每个更改都可以在源控制中跟踪，降低风险，并且每个设置都是可复制的。通过将这一概念发挥到极致，我们实现了所谓的
    *不可变服务器*，CNCF在其云原生定义中也提到了不可变基础设施。
- en: Note You might have heard the expression “pets vs. cattle” when comparing traditional
    snowflake infrastructure (requiring a lot of care and attention, like pets) and
    immutable infrastructure or containers (characterized by being disposable and
    replaceable, like cattle). I won’t use this expression in the book, but it’s sometimes
    used in discussions about this subject, so you should be aware of it.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：当比较传统的雪花式基础设施（需要大量的关注和照顾，就像宠物一样）和不可变基础设施或容器（以可丢弃和可替换为特征，就像牛群一样）时，你可能听说过“宠物与牛群”这个表达。在本书中，我不会使用这个表达，但在讨论这个主题时，有时会用到它，所以你应该了解这一点。
- en: 'After their initial provisioning and configuration, immutable servers are not
    changed: they are immutable. If any change is necessary, it’s defined as code
    and delivered. A new server is then provisioned and configured from the new code
    while the previous server is destroyed.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行初始配置后，不可变服务器不会发生变化：它们是不可变的。如果需要任何更改，它将被定义为代码并交付。然后，从新代码中为新服务器进行配置，同时销毁旧服务器。
- en: For example, you have two options if your current infrastructure consists of
    Ubuntu 20.04 servers and you want to upgrade to Ubuntu 22.04\. The first option
    is to define the upgrade via code and run the automation scripts to perform the
    operation on the existing machines (phoenix servers). The second option is to
    automate the provisioning of new machines running Ubuntu 22.04 and start using
    those (immutable servers), rather than performing the upgrade on existing machines.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你的当前基础设施由Ubuntu 20.04服务器组成，并且你想升级到Ubuntu 22.04，你有两种选择。第一种是通过代码定义升级并运行自动化脚本来在现有机器（凤凰服务器）上执行操作。第二种选择是自动化运行Ubuntu
    22.04的新机器的配置，并开始使用这些（不可变服务器），而不是在现有机器上执行升级。
- en: In the next section, I’ll talk about automation for building and deploying applications.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我将讨论构建和部署应用程序的自动化。
- en: 1.4.2 Continuous delivery
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4.2 持续交付
- en: Continuous delivery is “a software development discipline where you build software
    in such a way that the software can be released to production at any time.”[^(11)](#pgfId-1015944)
    With continuous delivery, teams implement features in short cycles, ensuring that
    the software can be released at any time reliably. Such a discipline is key to
    “make high-impact changes frequently and predictably with minimal toil,” as per
    the cloud native definition from the CNCF.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 持续交付是一种“软件开发学科，其中你以这种方式构建软件，使得软件可以随时发布到生产环境中。”[^(11)](#pgfId-1015944) 通过持续交付，团队在短周期内实现功能，确保软件可以随时可靠地发布。这种学科是“以最小的努力，频繁且可预测地实现高影响变化”的关键，正如CNCF的云原生定义。
- en: '*Continuous integration* (CI) is a foundational practice in continuous delivery.
    Developers commit their changes to the mainline (the main branch) continuously
    (at least once a day). At each commit, the software is automatically compiled,
    tested, and packaged as executable artifacts (such as JAR files or container images).
    The idea is to get fast feedback about the software’s status after each new change.
    If an error is detected, it should be immediately fixed to ensure the mainline
    keeps being a stable foundation for further development.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*持续集成*（CI）是持续交付的基础实践。开发者持续地将他们的更改提交到主线（主分支），至少每天提交一次。在每次提交时，软件会自动编译、测试和打包为可执行工件（如JAR文件或容器镜像）。其目的是在每次新更改后快速获取关于软件状态的反馈。如果检测到错误，应立即修复以确保主线保持为进一步开发的稳定基础。'
- en: '*Continuous delivery* (CD) builds on CI and focuses on keeping the mainline
    always healthy and in a releasable state. After an executable artifact is produced
    as part of the integration with the mainline, the software is deployed to a production-like
    environment. It goes through additional tests to assess its *releasability*, such
    as user acceptance tests, performance tests, security tests, compliance tests,
    and any other tests that might increase the confidence that the software can be
    released. If the mainline is always in a releasable state, releasing a new version
    of the software becomes a business decision instead of a technical one.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*持续交付*（CD）建立在CI的基础上，专注于保持主线始终健康且处于可发布状态。在主线集成过程中生成可执行工件后，软件被部署到一个类似生产环境。它将经过额外的测试来评估其*可发布性*，例如用户验收测试、性能测试、安全测试、合规性测试以及任何可能增加软件发布信心的其他测试。如果主线始终处于可发布状态，发布软件的新版本就变成了一个业务决策，而不是技术决策。'
- en: Continuous delivery encourages the automation of the whole process via a *deployment
    pipeline* (also called a *continuous delivery pipeline*), as described in the
    foundational book *Continuous Delivery* by Jez Humble and David Farley (Addison-Wesley
    Professional, 2010). A deployment pipeline goes from code commit to a releasable
    outcome, and it’s the only way to production. Throughout the book, we’ll build
    a deployment pipeline to keep the main branch of our applications always in a
    releasable state. In the end, we’ll use it to deploy applications automatically
    to a Kubernetes cluster in production.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 持续交付鼓励通过一个*部署管道*（也称为*持续交付管道*）来自动化整个流程，正如Jez Humble和David Farley所著的基础书籍《持续交付》（Addison-Wesley
    Professional, 2010）中所描述的。部署管道从代码提交到可发布的结果，这是唯一的进入生产的方式。在整个书中，我们将构建一个部署管道，以确保我们应用程序的主要分支始终处于可发布状态。最后，我们将使用它来自动将应用程序部署到生产环境中的Kubernetes集群。
- en: Sometimes continuous delivery is confused with *continuous deployment*. The
    former approach makes sure that after every change, the software is in a state
    in which it can be deployed to production. When that’s actually done is a business
    decision. With continuous deployment we add one last step to the deployment pipeline
    to automatically deploy a new release in production after every change.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 有时持续交付会被与*持续部署*混淆。前者确保每次更改后，软件都处于可以部署到生产状态。何时实际执行这是一个业务决策。使用持续部署，我们在部署管道中添加最后一步，在每次更改后自动将新版本部署到生产环境中。
- en: Continuous delivery is not about tools. It’s a discipline that involves cultural
    and structural changes in your organization. Setting up an automated pipeline
    to test and deliver your applications doesn’t mean that you’re doing continuous
    delivery. Similarly, using a CI server to automate builds doesn’t mean you’re
    doing continuous integration.[^(12)](#pgfId-1016557) That leads us to the next
    topic, which is also commonly mistaken as being about tools.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 持续交付不仅仅是关于工具。它是一种涉及你组织文化和管理结构变化的学科。设置一个自动化的管道来测试和交付你的应用程序并不意味着你正在进行持续交付。同样，使用CI服务器来自动化构建并不意味着你正在进行持续集成。[^(12)](#pgfId-1016557]
    这引出了下一个话题，这也是常被误认为是关于工具的话题。
- en: Continuous delivery vs. CI/CD
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 持续交付与CI/CD的比较
- en: Since continuous integration is a foundational practice of continuous delivery,
    the combination is often referred to as CI/CD. As a consequence, deployment pipelines
    are often called CI/CD pipelines. I have some reservations about the term, because
    continuous integration is not the only practice included in the continuous delivery
    discipline. For example, test-driven development (TDD), automated configuration
    management, acceptance testing, and continuous learning are equally important.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于持续集成是持续交付的基础实践，因此两者的组合通常被称为CI/CD。因此，部署管道通常被称为CI/CD管道。我对这个术语有一些保留意见，因为持续集成并不是持续交付学科中唯一包含的实践。例如，测试驱动开发（TDD）、自动化配置管理、验收测试和持续学习同样重要。
- en: The *CI/CD* term is not used by Jez Humble and Dave Farley in their *Continuous
    Delivery* book, nor in any other book they have written on the subject. Also,
    it can be confusing. Does *CD* stand for *continuous delivery* or *continuous
    deployment*? In this book, I will refer to the holistic approach of delivering
    “better software faster”^a as *continuous delivery* rather than CI/CD.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Jez Humble 和 Dave Farley 在他们的 *持续交付* 书中，以及他们关于该主题的任何其他书中，都没有使用 *CI/CD* 这个术语。此外，它可能会令人困惑。*CD*
    是指 *持续交付* 还是 *持续部署*？在这本书中，我将把“更快地交付更好的软件”的整体方法称为 *持续交付*，而不是 CI/CD。
- en: ^a D. Farley, *Continuous Delivery Pipelines*, 2021.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ^a D. Farley, *持续交付管道*, 2021。
- en: 1.4.3 DevOps
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4.3 DevOps
- en: '*DevOps* is another of those buzzwords that are pretty popular these days but
    too often misunderstood. When shifting to cloud native, DevOps is an important
    concept to grasp.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*DevOps* 是当今流行但常被误解的 buzzword 之一。当转向云原生时，掌握 DevOps 是一个重要的概念。'
- en: The origins of DevOps are peculiar. One of the curious aspects is that the creators
    of this concept didn’t initially provide a definition. The result was that several
    people used their own interpretations and, of course, we ended up using DevOps
    to mean different things.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps 的起源很特别。其中一个有趣的地方是，这个概念的创造者最初并没有提供一个定义。结果是，几个人用自己的解释，当然，我们最终用 DevOps 来表示不同的东西。
- en: 'Note If you’re interested in knowing more about the origins of DevOps, I suggest
    watching the Ken Mugrage talks available on YouTube: “DevOps and DevOpsDays—Where
    it started, where it is, where it’s going” ([http://mng.bz/Ooln](http://mng.bz/Ooln)).'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果你对了解 DevOps 的起源感兴趣，我建议你观看 YouTube 上可用的 Ken Mugrage 的演讲：“DevOps 和 DevOpsDays——它从哪里开始，它在哪里，它将走向何方”
    ([http://mng.bz/Ooln](http://mng.bz/Ooln))。
- en: Among all the definitions of DevOps, I find the one proposed by Ken Mugrage
    (principal technologist at ThoughtWorks) to be particularly informative and interesting.
    He highlights what I believe is the true meaning of DevOps.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有关于 DevOps 的定义中，我发现由 ThoughtWorks 的首席技术官 Ken Mugrage 提出的定义特别有信息量和趣味性。他强调了我认为是
    DevOps 真正含义的东西。
- en: '*A culture where people, regardless of title or background, work together to
    imagine, develop, deploy, and operate a system.*[^(13)](#pgfId-1016782)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*一个人们无论头衔或背景如何，共同想象、开发、部署和运营系统的文化*。[^(13)](#pgfId-1016782)'
- en: So DevOps is a culture, and it’s all about working together toward a common
    goal. Developers, testers, operators, security experts, and other people, regardless
    of title or background, work together to bring ideas to production and produce
    value.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，DevOps 是一种文化，它关乎共同目标下的协作。开发者、测试人员、运维人员、安全专家以及其他人员，无论头衔或背景如何，共同工作，将想法转化为生产并创造价值。
- en: 'It means the end of *silos*—no more walls between feature teams, QA teams,
    and operations teams. DevOps is often considered a natural continuation of agile,
    which is an enabler for DevOps with the concept of small teams delivering value
    to customers frequently. A concise way to describe DevOps is with a famous sentence
    that Werner Vogels, Amazon CTO, pronounced in 2006 when DevOps was not even a
    thing yet: “You build it, you run it.”[^(14)](#pgfId-1016821)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 *壁垒* 的终结——特征团队、QA 团队和运维团队之间不再有墙。DevOps 通常被认为是敏捷的自然延续，敏捷通过小团队频繁地向客户交付价值的概念，是
    DevOps 的一个促进者。用一句著名的话来简洁地描述 DevOps，那就是亚马逊 CTO Werner Vogels 在 2006 年提出的，当时 DevOps
    甚至还不是一件事情：“你构建它，你运行它。”[^(14)](#pgfId-1016821)
- en: 'Having defined what DevOps is, I’ll briefly mention what it isn’t:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了 DevOps 是什么之后，我将简要提及它不是什么：
- en: '*DevOps doesn’t mean NoOps.* It’s a common mistake to think that developers
    take care of operations and that the operator’s role disappears. Instead, it’s
    a collaboration. A team will include both roles, contributing to the overall team’s
    skills required to bring a product from the original idea to production.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*DevOps 并不意味着 NoOps*。认为开发者负责运维，操作员的角色消失是一种常见的错误。相反，这是一种协作。一个团队将包括这两个角色，共同贡献于将产品从原始想法带到生产的整体团队技能。'
- en: '*DevOps is not a tool.* Tools like Docker, Ansible, Kubernetes, and Prometheus
    are usually referred to as DevOps tools, but that’s wrong. DevOps is a culture.
    You don’t turn into a DevOps organization by using particular tools. In other
    words, DevOps is not a product, but tools are relevant enablers.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*DevOps 不是一个工具*。像 Docker、Ansible、Kubernetes 和 Prometheus 这样的工具通常被称为 DevOps
    工具，但这并不正确。DevOps 是一种文化。你不会通过使用特定的工具而变成 DevOps 组织。换句话说，DevOps 不是一个产品，但工具是相关的促进者。'
- en: '*DevOps is not automation.* Even if automation is an essential part of DevOps,
    automation is not its definition. DevOps is about developers and operators working
    together from the original idea to production while possibly automating some of
    their processes, such as continuous delivery.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*DevOps不是自动化。* 即使自动化是DevOps的一个基本组成部分，但自动化并不是它的定义。DevOps是关于开发者和操作者从最初的想法到生产过程中一起工作，同时可能自动化他们的一些流程，例如持续交付。'
- en: '*DevOps is not a role.* If we consider DevOps to be a culture or a mindset,
    it’s hard to make sense of a DevOps role. And yet, there is an increasing request
    for DevOps engineers. Usually when recruiters search for DevOps engineers, they
    are looking for skills like proficiency with automation tools, scripting, and
    IT systems.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*DevOps不是一个角色。* 如果我们将DevOps视为一种文化或一种心态，那么很难理解DevOps角色的意义。然而，对DevOps工程师的需求却在不断增加。通常，当招聘人员寻找DevOps工程师时，他们寻找的是像自动化工具、脚本和IT系统熟练度这样的技能。'
- en: '*DevOps is not a team.* Organizations not fully understanding the preceding
    points risk keeping the same silos as before, with one change: replacing the Ops
    silo with a DevOps silo, or, even worse, simply adding a new DevOps silo.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*DevOps不是一个团队。* 如果组织没有完全理解上述观点，他们可能会保留与以前相同的隔阂，只是将操作隔阂替换为DevOps隔阂，或者更糟糕的是，仅仅添加一个新的DevOps隔阂。'
- en: 'The collaboration between developers and operators is paramount when going
    cloud native. As you may have noticed, designing and building cloud native applications
    requires that you always keep in mind where you’re going to deploy those applications:
    the cloud. Working together with operators allows developers to design and build
    higher-quality products.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当走向云原生时，开发者和操作者之间的协作至关重要。正如你可能已经注意到的，设计和构建云原生应用程序需要你始终牢记你将部署这些应用程序的地方：云。与操作者一起工作允许开发者设计和构建更高品质的产品。
- en: It’s called DevOps, but remember that the definition doesn’t apply only to developers
    and operators. Instead, it generically refers to people, regardless of title or
    background. It means that collaboration also involves other roles like testers
    and security experts (though we probably don’t need new terms like DevSecOps,
    DevTestOps, DevSecTestOps, or DevBizSecTestOps). Together they are all responsible
    for the entire product life cycle and are key to achieving the goals of continuous
    delivery.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 它被称为DevOps，但请记住，这个定义不仅适用于开发者和操作者。相反，它普遍适用于人们，无论他们的头衔或背景如何。这意味着协作还涉及其他角色，如测试人员和安全专家（尽管我们可能不需要像DevSecOps、DevTestOps、DevSecTestOps或DevBizSecTestOps这样的新术语）。他们一起对整个产品生命周期负责，并且是实现持续交付目标的关键。
- en: 1.5 Is the cloud your best option?
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.5 云是你的最佳选择吗？
- en: One of the biggest mistakes in our industry is deciding to adopt a technology
    or approach just because it’s new and everyone is talking about it. There are
    endless stories about companies migrating their monoliths to microservices and
    ending up with disastrous failures. I have already explained the properties of
    the cloud and of cloud native applications. Those should provide you with some
    guidance. If your system doesn’t need those properties because it doesn’t have
    the problems they are trying to solve, chances are that “going cloud native” is
    not the best option for your project.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们行业最大的错误之一就是决定采用一种技术或方法，仅仅因为它很新，而且每个人都正在谈论它。关于公司将其单体迁移到微服务并最终以灾难性的失败告终的故事不计其数。我已经解释了云和云原生应用程序的特性。这些应该为你提供一些指导。如果你的系统不需要这些特性，因为它没有它们试图解决的问题，那么“走向云原生”可能不是你项目的最佳选择。
- en: As technologists, it’s easy for us to get caught up in the latest, trendiest,
    shiniest technology. The point is to figure out whether a specific technology
    or approach can solve *your* problems. We turn ideas into software that we deliver
    to our customers and that provides them with some value. That’s our end goal.
    If a technology or approach helps you provide more value to your customers, you
    should consider it. If it’s not worthy, and you decide to go with it anyway, you’ll
    likely end up having higher costs and many problems.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 作为技术人员，我们很容易陷入最新、最流行、最闪亮的技术。关键是要弄清楚一个特定的技术或方法是否能够解决*你的*问题。我们将想法转化为软件，交付给我们的客户，并为它们提供一些价值。这是我们最终的目标。如果一个技术或方法能帮助你为你的客户提供更多价值，你应该考虑它。如果它不值得，而你决定无论如何都要采用它，你很可能会面临更高的成本和许多问题。
- en: When is moving to the cloud a good idea? Why are companies adopting the cloud
    native approach? The main reasons for going cloud native, illustrated in figure
    1.8, are speed, scale, resilience, and cost. If your business vision includes
    those goals and faces the same problems that cloud technologies try to solve,
    then it’s good to consider moving to the cloud and adopting a cloud native approach.
    Otherwise, it might be better to stay on the ground. For example, if your company
    is providing services through a monolithic application in its maintenance phase
    that will not be further expanded with new features, and that has performed well
    in the last decade, there might be no good reason to migrate it to the cloud,
    let alone to turn it into a cloud native application.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在什么情况下迁移到云是一个好主意？为什么公司采用云原生方法？图1.8中说明了迁移到云原生的主要原因，包括速度、规模、弹性和成本。如果你的业务愿景包括这些目标，并且面临云技术试图解决的问题，那么考虑迁移到云并采用云原生方法是个不错的选择。否则，可能最好是留在原地。例如，如果你的公司正在通过其维护阶段的单体应用程序提供服务，该应用程序不会进一步扩展新功能，并且在过去十年中表现良好，那么将其迁移到云可能没有很好的理由，更不用说将其转变为云原生应用程序了。
- en: '![01-08](../Images/01-08.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![01-08](../Images/01-08.png)'
- en: Figure 1.8 Going cloud native can help you meet several goals related to speed,
    resilience, scale, and cost optimization.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.8 采用云原生可以帮助你实现与速度、弹性、规模和成本优化相关的多个目标。
- en: 1.5.1 Speed
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.5.1 速度
- en: Being able to deliver software faster is an important goal for enterprises nowadays.
    Bringing ideas into production as quickly as possible, therefore reducing the
    time to market, is a critical competitive advantage. Going to production with
    the right idea at the right time might make the difference between success and
    failure.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 能够更快地交付软件是企业当今的一个重要目标。尽可能快地将想法投入生产，从而缩短上市时间，这是一个关键的竞争优势。在正确的时间将正确的想法投入生产可能会决定成功与失败的区别。
- en: Customers expect to have more and more features implemented or bugs fixed, and
    they want them now. They will not be happy to wait six months for the next release
    of your software. Their expectations keep increasing, and you need a way to keep
    up with them. In the end, it’s all about providing value to customers and ensuring
    they are satisfied with the results. Otherwise, your business will not survive
    the fierce competition out there.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 客户期望越来越多地实现功能或修复错误，并且他们希望立即得到这些功能。他们不会高兴地等待六个月才能使用你软件的下一个版本。他们的期望不断增长，你需要一种方法来跟上他们。最终，这一切都是为了向客户提供价值，并确保他们对结果感到满意。否则，你的业务将无法在激烈的竞争中生存。
- en: Delivering faster and frequently is not only about competition and customer
    deadlines. It’s also about making the feedback cycle shorter. Frequent and small
    releases mean that you can get feedback from customers sooner. A shorter feedback
    loop, in turn, decreases the risk associated with the new functionality you’re
    releasing. Instead of spending months trying to implement the perfect feature,
    you can get it out there sooner, get feedback from customers, and adjust it to
    align with their expectations. Also, smaller releases contain fewer changes, thus
    reducing the number of parts that could fail.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 快速且频繁地交付不仅关乎竞争和客户截止日期，还关乎缩短反馈周期。频繁的小规模发布意味着你可以更快地从客户那里获得反馈。反过来，较短的反馈循环会降低你发布的新功能相关的风险。你不必花费数月时间尝试实现完美的功能，而是可以更快地将它推出，从客户那里获得反馈，并根据他们的期望进行调整。此外，较小的发布包含的更改较少，因此减少了可能失败的部分数量。
- en: Flexibility is also needed, since customers expect the continuous evolution
    of your software. For example, it should be flexible enough to support new types
    of clients. Nowadays, more and more objects in our daily lives have been connected
    to the internet, such as all kinds of mobile and IoT systems. You’ll want to be
    open to any future extensions and client types so you can provide business services
    in new ways.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 需要灵活性，因为客户期望你的软件持续进化。例如，它应该足够灵活，以支持新的客户端类型。如今，我们日常生活中越来越多的物品已经连接到互联网，例如各种移动和物联网系统。你希望对任何未来的扩展和客户端类型都持开放态度，以便以新的方式提供商业服务。
- en: The traditional software development approach does not support this goal. Too
    often it is characterized by massive releases, little flexibility, and extended
    release cycles. The cloud native approach, combined with automated tasks, continuous
    delivery workflows, and DevOps practices, helps businesses go faster and reduce
    the time to market.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的软件开发方法不支持这一目标。它往往以大规模发布、灵活性低和延长发布周期为特征。云原生方法，结合自动化任务、持续交付工作流程和DevOps实践，有助于企业加快速度并缩短上市时间。
- en: 1.5.2 Resilience
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.5.2 弹性
- en: Everything changes, and failures happen all the time. Gone are the times when
    we tried to predict failures and treat them as exceptions. As I mentioned before,
    changes are not exceptions. They are the rule.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都在变化，故障随时都会发生。我们试图预测故障并将它们视为异常的时代已经过去了。正如我之前提到的，变化不是异常，而是规则。
- en: Customers want software to be available 24/7 and to be upgraded as soon as a
    new feature is released. Downtime or failures can cause a direct loss of money
    and customer dissatisfaction. They may even affect one’s reputation, damaging
    the organization’s future market opportunities.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 客户希望软件能够全天候可用，并且在新功能发布时立即升级。停机或故障可能导致直接的经济损失和客户不满。它们甚至可能影响一个人的声誉，损害组织的未来市场机会。
- en: Whether there is a failure in the infrastructure or the software, your goal
    is to guarantee the availability and reliability of your systems, even if only
    in a degraded operational mode. To guarantee availability, you need to have something
    in place to face the failures when they arrive, handle them, and ensure that the
    overall system can still provide services to its users. Any action required to
    process the failure or tasks like upgrades should require zero downtime. Customers
    expect that.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 无论基础设施还是软件出现故障，您的目标是保证系统的可用性和可靠性，即使是在降级操作模式下也是如此。为了保证可用性，您需要准备应对故障的措施，处理它们，并确保整体系统能够继续为用户提供服务。处理故障或升级等任务所需的任何操作都应要求零停机时间。客户期望如此。
- en: 'We want cloud native applications to be resilient, and cloud technologies provide
    strategies for implementing resilient infrastructure. If being always available,
    safe, and resilient is a requirement for your business, the cloud native approach
    is a good option for you. The resilience of a software system, in turn, enables
    speed: the more stable the system, the more frequently you can safely release
    new features.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望云原生应用具有弹性，云技术提供了实现弹性基础设施的策略。如果始终可用、安全且具有弹性是您业务的要求，那么云原生方法对您来说是一个不错的选择。软件系统的弹性反过来又使速度得到提升：系统越稳定，您就越能频繁地安全发布新功能。
- en: 1.5.3 Scale
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.5.3 规模
- en: Elasticity is about being able to scale your software depending on the load.
    You can scale an elastic system to ensure an adequate service level for all your
    customers. If there is a higher load than usual, you’ll need to spin up more instances
    of your services to support that extra traffic. Or perhaps something terrible
    happened and some services failed—you’ll need to be able to spin up new instances
    to replace them.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 弹性是指根据负载调整软件的能力。您可以将弹性系统扩展到确保为所有客户提供充足的服务水平。如果负载高于正常水平，您将需要启动更多服务实例来支持额外的流量。或者，也许发生了可怕的事情，某些服务失败——您需要能够启动新实例来替代它们。
- en: Foreseeing what will happen is hard, if not impossible. It’s not enough to build
    scalable applications—you need them to scale dynamically. Whenever there is a
    high load, your system should scale out dynamically, quickly, and painlessly.
    When the high peak is over, it should scale in again.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 预测未来会发生什么很难，如果不是不可能的话。仅仅构建可扩展的应用程序是不够的——您需要它们能够动态扩展。每当有高负载时，您的系统应该能够快速、轻松地动态扩展。当高峰期过后，它应该再次缩小规模。
- en: If your business needs to adapt quickly and efficiently to new customers or
    requires the flexibility to support new types of clients (which increase the workload
    on the servers), the cloud’s very nature can provide you with all the elasticity
    you need, in combination with cloud native applications that are scalable by definition.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的业务需要快速有效地适应新客户或需要灵活性以支持新类型的客户（这会增加服务器的负载），云的本质可以为您提供所需的全部弹性，结合云原生应用程序，这些应用程序按定义是可扩展的。
- en: 1.5.4 Cost
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.5.4 成本
- en: 'As a software developer, you might not deal directly with money, but it’s your
    responsibility to take cost into account when designing a solution. The cloud
    computing model helps optimize IT infrastructure costs with its elasticity and
    on-demand pay-per-use policies. No more always-on infrastructure: you provision
    resources when you need them, pay for the actual usage, and then destroy them
    when you don’t need them anymore.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 作为软件开发者，你可能不会直接处理金钱，但在设计解决方案时，考虑成本是你的责任。云计算模型通过其弹性和按需付费的使用政策，有助于优化IT基础设施成本。不再需要始终在线的基础设施：你需要资源时才配置资源，根据实际使用付费，不再需要时再将其销毁。
- en: On top of that, adopting the cloud native approach leads to further cost optimizations.
    Cloud native applications are designed to be scalable so they can take advantage
    of the cloud’s elasticity. They are resilient, so the costs related to downtime
    and hard failures in production are lower. Being loosely coupled, they enable
    teams to go faster and speed up the time to market, with notable competitive advantages.
    And the list goes on.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，采用云原生方法还能进一步优化成本。云原生应用程序被设计成可扩展的，以便可以利用云的弹性。它们具有弹性，因此在生产中与停机时间和硬故障相关的成本较低。它们松散耦合，使团队能够更快地工作并加快上市时间，具有显著的竞争优势。还有更多。
- en: The hidden costs of moving to the cloud
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移到云的成本
- en: Before deciding to migrate to the cloud, it’s essential also to consider other
    types of costs. On the one hand, you can optimize costs by paying for only what
    you use. But on the other hand, you should consider the cost of migrating and
    its consequences.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定迁移到云之前，还必须考虑其他类型的成本。一方面，你可以通过只为你使用的部分付费来优化成本。但另一方面，你应该考虑迁移的成本及其后果。
- en: Migrating to the cloud requires specific competencies that employees might not
    have yet. This may mean investing in their education to acquire the necessary
    skills and perhaps hiring professionals as consultants to help with the migration
    to the cloud. Depending on the chosen solution, the organization may need to take
    over some extra responsibilities, such as handling security in the cloud, which
    in turn requires specific skills. There are also other considerations, like business
    interruptions during the migration, retraining end users, and updating documentation
    and support materials.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移到云需要特定的技能，员工可能还没有掌握。这可能意味着投资他们的教育以获得必要的技能，也许需要聘请专业人士作为顾问来帮助进行云迁移。根据所选方案，组织可能需要承担一些额外的责任，例如在云中处理安全问题，这反过来又需要特定的技能。还有其他考虑因素，如迁移期间的业务中断、重新培训最终用户以及更新文档和支持材料。
- en: 1.6 Cloud native topologies
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.6 云原生拓扑
- en: My explanation of cloud native didn’t involve specific technologies or architectures.
    The CNCF mentions some in its definition, like containers and microservices, but
    those are just examples. You don’t have to use Docker containers for your applications
    to be cloud native. Think about serverless or PaaS solutions. Writing functions
    for the AWS Lambda platform or deploying applications to Heroku doesn’t require
    you to build containers. Still, they are categorized as cloud native.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我对云原生的解释没有涉及特定的技术或架构。CNCF在其定义中提到了一些，如容器和微服务，但这些都只是例子。你的应用程序要成为云原生，不必一定要使用Docker容器。考虑无服务器或PaaS解决方案。为AWS
    Lambda平台编写函数或部署到Heroku不需要你构建容器。尽管如此，它们仍被归类为云原生。
- en: In this section, I’ll describe some common cloud native topologies (see figure
    1.9). First, I’ll introduce the concepts of containers and orchestration, which
    will be further explored later when I discuss Docker and Kubernetes. Then I’ll
    present the topic of serverless technologies and functions (FaaS). I will not
    focus much on the FaaS model in this book, but I will cover the basics of how
    to build serverless applications using Spring Native and Spring Cloud Function.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将描述一些常见的云原生拓扑结构（见图1.9）。首先，我将介绍容器和编排的概念，这些概念将在后续讨论Docker和Kubernetes时进一步探讨。然后，我将介绍无服务器技术和函数（FaaS）的主题。在这本书中，我不会过多关注FaaS模型，但我会涵盖使用Spring
    Native和Spring Cloud Function构建无服务器应用程序的基础知识。
- en: '![01-09](../Images/01-09.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![01-09](../Images/01-09.png)'
- en: Figure 1.9 The main cloud native computing models are containers (managed by
    orchestrators) and serverless.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.9 主要的云原生计算模型是容器（由编排器管理）和无服务器。
- en: 1.6.1 Containers
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.6.1 容器
- en: Imagine you join a team and start working on an application. The first thing
    you do is follow a guide to set up your local development environment that’s similar
    to the ones used by your colleagues. You develop a new feature and then test it
    in a quality assurance (QA) environment. Once it’s verified, the application can
    be deployed to staging for some extra testing and finally to production. The application
    is built to run in an environment with specific characteristics, so it’s essential
    to have all the different environments as similar as possible. How would you do
    that? That’s where containers enter the scene.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你加入了一个团队并开始开发一个应用程序。你做的第一件事是遵循指南设置与同事使用的本地开发环境相似的本地开发环境。你开发了一个新功能，然后在质量保证（QA）环境中对其进行测试。一旦验证无误，应用程序可以部署到预发布环境进行额外测试，最后部署到生产环境。应用程序被构建成在具有特定特性的环境中运行，因此确保所有不同的环境尽可能相似是至关重要的。你将如何做到这一点？这就是容器出现的地方。
- en: Before containers, you would rely on virtual machines to guarantee the reproducibility
    of the environment, isolation, and configurability. Virtualization works by leveraging
    a hypervisor component that abstracts the hardware, making it possible to run
    multiple operating systems on the same machine in an isolated fashion. The hypervisor
    would run directly on the machine hardware (type 1) or on the host operating system
    (type 2).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器出现之前，你会依赖虚拟机来保证环境的可重复性、隔离性和可配置性。虚拟化通过利用虚拟化组件来抽象硬件，使得在同一台机器上以隔离的方式运行多个操作系统成为可能。虚拟化直接在机器硬件（类型
    1）或宿主操作系统（类型 2）上运行。
- en: 'On the other hand, an *OS container* is a lightweight executable package that
    includes everything needed to run the application. Containers share the same kernel
    as the host: there’s no need to bootstrap full operating systems to add new isolated
    contexts. On Linux, that is possible by leveraging a couple of features offered
    by the Linux kernel:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，*操作系统容器*是一个轻量级的可执行包，它包含了运行应用程序所需的一切。容器与宿主机共享相同的内核：无需引导完整的操作系统来添加新的隔离环境。在
    Linux 上，这是通过利用 Linux 内核提供的几个特性来实现的：
- en: '*namespaces* for partitioning resources among processes so that each process
    (or group of processes) can only see a subset of the resources available on the
    machine'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*namespaces* 用于在进程之间划分资源，以便每个进程（或进程组）只能看到机器上可用的资源子集'
- en: '*cgroups* for controlling and limiting the resource usage for a process (or
    group of processes)'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*cgroups* 用于控制并限制进程（或进程组）的资源使用'
- en: Note When using virtualization only, the hardware is shared, whereas containers
    also share the same operating system kernel. Both provide computing environments
    for running software in isolation, even if the degree of isolation is not the
    same.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：当仅使用虚拟化时，硬件是共享的，而容器还共享相同的操作系统内核。两者都为在隔离环境中运行软件提供计算环境，尽管隔离程度不同。
- en: Figure 1.10 shows the difference between virtualization and container technologies.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.10 展示了虚拟化和容器技术之间的差异。
- en: '![01-10](../Images/01-10.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![01-10](../Images/01-10.png)'
- en: Figure 1.10 Virtualization and container technologies differ in what is shared
    across isolated contexts. Virtual machines share the hardware only. Containers
    share the operating system kernel as well. Containers are more lightweight and
    portable.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.10 虚拟化和容器技术在隔离环境中共享的内容上有所不同。虚拟机仅共享硬件。容器还共享操作系统内核。容器更轻量级且易于携带。
- en: Why are containers so popular for cloud native applications? Traditionally,
    you would have to install and maintain the Java Runtime Environment (JRE) and
    middleware on a virtual machine to make your application run. Instead, a container
    can run reliably in almost any computing environment, independent of the application,
    its dependencies, or middleware. It doesn’t matter which kind of application it
    is, in which language it’s written, or which libraries it uses. All containers
    have a similar shape from the outside, just like the containers used for shipping.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么容器在云原生应用程序中如此受欢迎？传统上，你需要在虚拟机上安装和维护 Java 运行时环境（JRE）和中间件，以便使你的应用程序运行。相反，容器可以在几乎任何计算环境中可靠地运行，独立于应用程序、其依赖项或中间件。它无关紧要它是哪种类型的应用程序，是用哪种语言编写的，或者它使用了哪些库。所有容器在外观上都有类似的形状，就像用于运输的容器一样。
- en: Therefore, containers enable agility, portability across different environments,
    and deployment repeatability. Being lightweight and less resource-demanding, they
    are perfect for running in the cloud, where applications are disposable and scaled
    dynamically and quickly. In comparison, building and destroying virtual machines
    is much more expensive and time-consuming.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，容器使敏捷性、跨不同环境的可移植性和部署可重复性成为可能。由于它们轻量级且资源需求较低，它们非常适合在云中运行，在那里应用程序是可丢弃的，并且可以动态和快速地扩展。相比之下，构建和销毁虚拟机要昂贵得多，耗时也长。
- en: Containers! Containers everywhere!
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 容器！到处都是容器！
- en: '*Container* is one of those words that can mean different things. Sometimes
    this ambiguity can generate confusion, so let’s see what it means in specific
    contexts.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '*容器* 是那些可以有不同的含义的词汇之一。有时这种歧义可能会产生混淆，所以让我们看看它在特定语境中的含义。'
- en: '*OS*—An OS container is a method for running one or more processes in an environment
    isolated from the rest of the system. This book will focus on *Linux containers*,
    but note that Windows containers also exist.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*OS*——OS 容器是在与系统其他部分隔离的环境中运行一个或多个进程的方法。本书将重点介绍 *Linux 容器*，但请注意，Windows 容器也存在。'
- en: '*Docker*—A Docker container is an implementation of a Linux container.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Docker*——Docker 容器是 Linux 容器的一种实现。'
- en: '*OCI*—An OCI container is a standardization of the Docker container implementation
    by the Open Container Initiative (OCI).'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*OCI*——OCI 容器是由开放容器倡议（OCI）对 Docker 容器实现的标准化的结果。'
- en: '*Spring*—A Spring container is the application context where objects, properties,
    and other application resources are managed and executed.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Spring*——Spring 容器是管理并执行对象、属性和其他应用程序资源的应用程序上下文。'
- en: '*Servlet*—A Servlet container provides a runtime for web applications leveraging
    the Java Servlet API. The Catalina component from the Tomcat server is an example
    of a Servlet container.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Servlet*——Servlet 容器为利用 Java Servlet API 的 Web 应用程序提供运行时。Tomcat 服务器中的 Catalina
    组件是 Servlet 容器的一个例子。'
- en: Virtualization and containers are not mutually exclusive. You can use them both
    in a cloud native context, having an infrastructure made up of virtual machines
    on which you run containers. The Infrastructure as a Service (IaaS) model provides
    a virtualization layer that you can use to bootstrap new virtual machines. On
    top of that, you can install a container runtime and run your containers.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟化和容器不是互斥的。你可以在云原生环境中同时使用它们，拥有由运行容器的虚拟机组成的底层基础设施。基础设施即服务（IaaS）模型提供了一个虚拟化层，你可以使用它来启动新的虚拟机。在此基础上，你可以安装容器运行时并运行你的容器。
- en: An application is usually made up of different containers that can be run on
    the same machine during development or while performing early testing. But you
    would quickly reach the point where it gets too complicated to manage many containers,
    primarily when you start replicating them for scalability and distributing them
    across different machines. That’s when you’ll start relying on the higher level
    of abstraction provided by the Container as a Service (CaaS) model, which offers
    functionality to deploy and manage containers in clusters of machines. Note that,
    behind the scenes, there is still a virtualization layer.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序通常由不同的容器组成，这些容器可以在开发期间或早期测试时在同一台机器上运行。但很快你就会达到一个难以管理许多容器的复杂程度，尤其是当你开始复制它们以实现可伸缩性和跨不同机器分发时。那时，你将开始依赖由容器即服务（CaaS）模型提供的更高层次的抽象，该模型提供了在机器集群中部署和管理容器的能力。请注意，幕后仍然存在一个虚拟化层。
- en: Containers are involved even when you’re using PaaS platforms like Heroku or
    Cloud Foundry. You deploy your applications on those platforms by providing just
    the JAR artifact, since they take care of the JRE, the middleware, the OS, and
    any needed dependencies. Behind the scenes they build a container out of all those
    components and finally run it. The difference is that it’s no longer you who is
    responsible for building a container—the platform does it for you. On the one
    hand, that’s convenient, in terms of fewer responsibilities for developers. On
    the other hand, you are giving up control over the runtime and middleware, and
    you might face vendor lock-in.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你在使用像 Heroku 或 Cloud Foundry 这样的 PaaS 平台时，容器也会被涉及。你只需提供 JAR 文件，就可以在这些平台上部署你的应用程序，因为它们会处理
    JRE、中间件、操作系统以及任何需要的依赖项。幕后，它们会构建一个由所有这些组件组成的容器，并最终运行它。区别在于，不再是你要负责构建容器——平台会为你完成这项工作。一方面，这对开发者来说很方便，因为责任更少。另一方面，你正在放弃对运行时和中间件的控制，并且可能会面临供应商锁定。
- en: In this book, you’ll learn how to use Cloud Native Buildpacks (a CNCF project)
    to containerize Spring applications, and you’ll use Docker to run them in your
    local environment.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，你将学习如何使用Cloud Native Buildpacks（一个CNCF项目）来容器化Spring应用程序，你将使用Docker在本地环境中运行它们。
- en: 1.6.2 Orchestration
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.6.2 编排
- en: So you have decided to use containers, great! You can rely on their portability
    to deploy them to any infrastructure providing a container runtime. You can achieve
    reproducibility, so there are no bad surprises when moving containers from development
    to staging to production. You can scale them quickly, since they’re so lightweight,
    and get high availability for your applications. You’re ready to adopt them for
    your next cloud native system. Or are you?
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你已经决定使用容器，太好了！你可以依赖它们的可移植性将它们部署到任何提供容器运行时的基础设施上。你可以实现可重复性，因此当容器从开发到预发布再到生产迁移时，不会有任何意外的坏情况。由于它们非常轻量级，你可以快速扩展它们，并为你的应用程序提供高可用性。你已经准备好为你的下一个云原生系统采用它们了。或者，你是吗？
- en: Provisioning and managing containers on a single machine is pretty straightforward.
    But when you start dealing with tens or hundreds of containers scaled and deployed
    on several machines, you need something else.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在单个机器上提供和管理容器相当直接。但是，当你开始处理在多个机器上扩展和部署的数十或数百个容器时，你需要其他东西。
- en: When you move from virtual servers (the IaaS model) to container clusters (the
    CaaS model), you’re also switching your point of view.[^(15)](#pgfId-1017695)
    In IaaS you focus on single computing nodes, which are virtual servers. In CaaS
    the underlying infrastructure is abstracted, and you’re focusing on clusters of
    nodes.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从虚拟服务器（IaaS模型）迁移到容器集群（CaaS模型）时，你也在改变你的视角。[^(15)](#pgfId-1017695) 在IaaS中，你关注单个计算节点，即虚拟服务器。在CaaS中，底层基础设施被抽象化，你关注的是节点的集群。
- en: With the new perspective offered by CaaS solutions, the deployment target will
    not be a machine anymore but rather a cluster of machines. CaaS platforms, such
    as those based on Kubernetes, provide many features to address all the significant
    concerns we look for in a cloud native environment, *orchestrating* containers
    across machines. The two different topologies are shown in figure 1.11.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 通过CaaS解决方案提供的新视角，部署目标将不再是单个机器，而是一组机器的集群。基于Kubernetes等平台的CaaS平台提供了许多功能，以解决我们在云原生环境中寻找的所有重大关注点，*编排*跨机器的容器。两种不同的拓扑结构如图1.11所示。
- en: '![01-11](../Images/01-11.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![01-11](../Images/01-11.png)'
- en: Figure 1.11 The deployment target of containers is a machine, whereas for orchestrators,
    it’s a cluster.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.11 容器的部署目标是单个机器，而编排器的目标是集群。
- en: 'Container orchestration helps you automate many different tasks:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 容器编排帮助你自动化许多不同的任务：
- en: Managing clusters, bringing up and down machines when necessary
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理集群，在必要时启动和关闭机器
- en: Scheduling and deploying containers within a cluster to a machine that meets
    the container requirements for CPU and memory
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在集群内调度和部署容器到满足CPU和内存要求的机器
- en: Dynamically scaling containers for high availability and resilience, leveraging
    health monitoring
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态扩展容器以实现高可用性和弹性，利用健康监控
- en: Setting up networks for containers to communicate with each other, defining
    routing, service discovery, and load balancing
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为容器设置网络以相互通信，定义路由、服务发现和负载均衡
- en: Exposing services to the internet, establishing ports and networks
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将服务暴露给互联网，建立端口和网络
- en: Allocating resources to containers according to specific criteria
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据特定标准为容器分配资源
- en: Configuring the applications running within the containers
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置容器内运行的应用程序
- en: Ensuring security and enforcing access control policies
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保安全并执行访问控制策略
- en: Orchestration tools are instructed declaratively, such as through YAML files.
    Following the format and language defined by the specific tool, you usually describe
    the state you’d like to achieve; for example, you would like to have three replicas
    of your web application container deployed in a cluster, exposing its services
    to the internet.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 编排工具通过声明性指令进行指导，例如通过YAML文件。遵循特定工具定义的格式和语言，你通常描述你想要达到的状态；例如，你希望在集群中部署三个你的Web应用程序容器的副本，将其服务暴露给互联网。
- en: Examples of container orchestrators are Kubernetes (a CNCF project), Docker
    Swarm, and Apache Mesos. In this book, you’ll learn how to use Kubernetes to orchestrate
    the containers for your Spring applications.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 容器编排器的例子有Kubernetes（一个CNCF项目）、Docker Swarm和Apache Mesos。在这本书中，你将学习如何使用Kubernetes来编排你的Spring应用的容器。
- en: 1.6.3 Serverless
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.6.3 无服务器
- en: 'After moving from virtual machines to containers, we can abstract the infrastructure
    even more: that’s where serverless technologies are placed. The serverless computing
    model enables developers to focus on implementing the business logic for their
    applications.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在从虚拟机迁移到容器之后，我们可以进一步抽象化基础设施：这就是无服务器技术所在的位置。无服务器计算模型使开发者能够专注于实现他们应用程序的业务逻辑。
- en: The name *serverless* might be misleading. Of course there is a server. The
    difference is that you do not need to manage it or orchestrate the application’s
    deployment on it. That’s a platform responsibility now. When you use an orchestrator
    like Kubernetes, you must still consider infrastructure provisioning, capacity
    planning, and scaling. In contrast, a serverless platform takes care of setting
    up the underlying infrastructure needed by the applications, including virtual
    machines, containers, and dynamic scaling.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: “无服务器”这个名字可能具有误导性。当然，有一个服务器。区别在于你不需要管理它或在该服务器上编排应用程序的部署。现在这是平台的责任。当你使用Kubernetes这样的编排器时，你仍然必须考虑基础设施的提供、容量规划和扩展。相比之下，无服务器平台负责设置应用程序所需的底层基础设施，包括虚拟机、容器和动态扩展。
- en: 'Serverless architectures are usually associated with functions, but they comprise
    two main models that are often used together:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器架构通常与函数相关联，但它们由两种主要模型组成，这些模型通常一起使用：
- en: '*Backend as a Service* (BaaS)—In this model, applications rely heavily on third-party
    services offered by cloud providers, such as databases, authentication services,
    and message queues. The focus is on reducing development and operational costs
    related to backend services. Developers can implement frontend applications (such
    as single-page applications or mobile applications) while offloading most or all
    of the backend functionality to BaaS vendors. For example, they could use Okta
    to authenticate users, Google Firebase for persisting data, and Amazon API Gateway
    to publish and manage REST APIs.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*后端即服务* (BaaS)—在这个模型中，应用程序严重依赖云提供商提供的第三方服务，例如数据库、身份验证服务和消息队列。重点是降低与后端服务相关的开发和运营成本。开发者可以实现前端应用程序（如单页应用程序或移动应用程序），同时将大多数或全部后端功能卸载给BaaS供应商。例如，他们可以使用Okta进行用户身份验证，使用Google
    Firebase持久化数据，以及使用Amazon API Gateway发布和管理REST API。'
- en: '*Function as a Service* (FaaS)—In this model, applications are stateless, triggered
    by events, and fully managed by the platform. The focus is on reducing deployment
    and operations costs related to orchestrating and scaling applications. Developers
    can implement the business logic for their applications, and the platform takes
    care of the rest. Serverless applications don’t have to be implemented with functions
    to be categorized as such. There are two main FaaS offerings. One option is to
    go with vendor-specific FaaS platforms, such as AWS Lambda, Azure Functions, or
    Google Cloud Functions. Another option is to choose a serverless platform based
    on open source projects, which can run either in a public cloud or on premises,
    addressing concerns like vendor lock-in and lack of control. Examples of such
    projects are Knative and Apache OpenWhisk. Knative provides a serverless runtime
    environment on top of Kubernetes, as you’ll see in chapter 16\. It’s used as the
    foundation for enterprise serverless platforms like VMware Tanzu Application Platform,
    RedHat OpenShift Serverless, and Google Cloud Run.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*函数即服务* (FaaS)—在这个模型中，应用程序是无状态的，由事件触发，并由平台完全管理。重点是降低与编排和扩展应用程序相关的部署和运营成本。开发者可以为他们的应用程序实现业务逻辑，而平台则负责其余部分。无服务器应用程序不需要用函数来实现才能被归类为这种类型。主要有两种主要的FaaS提供方式。一种选择是采用特定供应商的FaaS平台，例如AWS
    Lambda、Azure Functions或Google Cloud Functions。另一种选择是选择基于开源项目的无服务器平台，这些平台可以在公有云或本地运行，解决供应商锁定和控制不足等问题。此类项目的例子有Knative和Apache
    OpenWhisk。Knative在Kubernetes之上提供了一个无服务器运行环境，正如你在第16章中看到的。它被用作VMware Tanzu Application
    Platform、RedHat OpenShift Serverless和Google Cloud Run等企业级无服务器平台的基础。'
- en: Serverless applications are typically event-driven and run only when there is
    an event to handle, such as an HTTP request or a message. The event can be external
    or be produced by another function. For example, a function might be triggered
    whenever a message is added to a queue, process it, and then exit the execution.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器应用程序通常是事件驱动的，仅在需要处理事件时运行，例如HTTP请求或消息。事件可以是外部的，也可以由另一个函数产生。例如，每当消息被添加到队列中时，一个函数可能会被触发，处理该消息，然后退出执行。
- en: When there is nothing to process, the serverless platform shuts down all the
    resources involved with the function, so you can really pay for the actual usage.
    In the other cloud native topologies like CaaS or PaaS, there is always a server
    running 24/7\. Compared to traditional systems, they offer the advantage of dynamic
    scalability, reducing the number of resources provisioned at any given time. Still,
    there is always something up and running, and it has a cost. In the serverless
    model, resources are provisioned only when necessary. If there is nothing to process,
    everything is shut down. That’s what we call *scaling to zero*, and it’s one of
    the main features offered by serverless platforms.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有需要处理的内容时，无服务器平台会关闭与函数相关的所有资源，这样你就可以真正地为实际使用付费。在其他云原生拓扑结构，如CaaS或PaaS中，总有一台服务器在24/7运行。与传统系统相比，它们提供了动态可伸缩性的优势，减少了在任何给定时间配置的资源数量。然而，始终有东西在运行，并且它是有成本的。在无服务器模型中，资源仅在必要时配置。如果没有需要处理的内容，一切都会关闭。这就是我们所说的*缩放到零*，这是无服务器平台提供的主要功能之一。
- en: 'Besides cost optimization, serverless technologies also move some extra responsibility
    from the application to the platform. That might be an advantage, since it allows
    developers to focus exclusively on the business logic. But it’s also essential
    to consider what degree of control you would like to have and how you will deal
    with vendor lock-in. Each FaaS, and in general serverless, platform has its own
    features and APIs. Once you start writing functions for a specific platform, you
    can’t move them easily to another, as you would do with containers. With FaaS,
    you might compromise more than with any other approach—prioritizing responsibility
    and scope at the cost of control and portability. That’s why Knative became popular
    quickly: it is built on Kubernetes, which means that you can easily move your
    serverless workloads between platforms and vendors. In the end, it’s a matter
    of tradeoffs.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 除了成本优化外，无服务器技术还将一些额外的责任从应用程序转移到平台。这可能是一个优势，因为它允许开发者专注于业务逻辑。但考虑你希望拥有的控制程度以及你将如何处理供应商锁定也是至关重要的。每个FaaS平台，以及一般意义上的无服务器平台，都有自己的特性和API。一旦你开始为特定平台编写函数，你就不容易将其轻松地移动到另一个平台，就像处理容器那样。使用FaaS，你可能会比其他任何方法都更多地做出妥协——以牺牲控制和可移植性为代价，优先考虑责任和范围。这就是为什么Knative迅速流行起来的原因：它是建立在Kubernetes之上的，这意味着你可以轻松地在平台和供应商之间移动你的无服务器工作负载。最终，这是一个权衡的问题。
- en: 1.7 Architectures for cloud native applications
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.7 云原生应用程序的架构
- en: We have reached the last step of our journey to define cloud native, and I’ve
    introduced the primary characteristics we’ll rely on throughout the book. In the
    previous section, you got familiar with the main cloud native topologies, particularly
    containers, which are our computation units. Now let’s look at what’s inside and
    explore some high-level principles involved in architecting and designing cloud
    native applications. Figure 1.12 shows the main concepts covered in this section.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到达了定义云原生之旅的最后一站，我在书中介绍了我们将依赖的主要特征。在前一节中，你熟悉了主要的云原生拓扑结构，特别是容器，它们是我们的计算单元。现在让我们看看里面的内容，并探索一些在架构和设计云原生应用程序中涉及的高级原则。图1.12展示了本节涵盖的主要概念。
- en: '![01-12](../Images/01-12.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![01-12](../Images/01-12.png)'
- en: Figure 1.12 Cloud native architectural elements
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.12 云原生架构元素
- en: 1.7.1 From multi-tiered to microservices architectures and beyond
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.7.1 从多层架构到微服务架构以及更远
- en: IT infrastructures have always affected the way software applications are architected
    and designed. In the beginning, monolithic applications were deployed on huge
    mainframes as single components. When the internet and PCs became popular, we
    started designing applications according to the client/server paradigm. A multi-tiered
    architecture, relying on that paradigm, was widely used for desktop and web applications,
    decomposing the code into presentation, business, and data layers.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: IT基础设施始终影响着软件应用程序的架构和设计方式。最初，单体应用程序作为单一组件部署在巨大的主机上。当互联网和PC变得流行时，我们开始根据客户端/服务器范式设计应用程序。多层架构，依赖于这个范式，被广泛用于桌面和Web应用程序，将代码分解为表示层、业务层和数据层。
- en: 'With the increase in application complexity and the need for agility, new ways
    of further decomposing the code have been explored, and a new architectural style
    entered the stage: microservices. In the last few years, this architectural style
    has become more and more popular, and many companies decided to refactor their
    applications according to this new style. Microservices are usually compared to
    monolithic applications, as shown in figure 1.13.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用程序复杂性的增加和对敏捷性的需求，探索了进一步分解代码的新方法，一种新的架构风格——微服务（microservices）应运而生。在过去的几年里，这种架构风格越来越受欢迎，许多公司决定根据这种新风格重构他们的应用程序。微服务通常与图1.13所示的单体应用程序进行比较。
- en: '![01-13](../Images/01-13.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![01-13](../Images/01-13.png)'
- en: Figure 1.13 Monolithic applications vs. microservices. Monolithic architectures
    are often multi-tiered. Microservices are made up of different components that
    can be deployed independently.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.13 单体应用程序与微服务。单体架构通常是多层的。微服务由不同组件组成，这些组件可以独立部署。
- en: The main difference lies in how the application has been decomposed. A monolithic
    application is associated with using three large layers. A microservice-based
    application, in contrast, is associated with many components, each implementing
    only one piece of functionality. Many patterns have been proposed to decompose
    a monolith into microservices and to handle the complexity created by having many
    components instead of one.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 主要区别在于应用程序的分解方式。单体应用程序通常与使用三个大型层相关联。相比之下，基于微服务（microservices）的应用程序则与许多组件相关联，每个组件只实现一部分功能。已经提出了许多模式来将单体（monolith）分解成微服务，并处理由于拥有多个组件而不是一个组件而产生的复杂性。
- en: Note This book is not about microservices, so I won’t go into detail about them.
    If you are interested in the topic, you can check out *Building Microservices*,
    second ed., by Sam Newman (O’Reilly, 2021) and *Microservices Patterns* by Chris
    Richardson (Manning, 2018). For a more Spring-oriented analysis, you can find
    *Spring Microservices in Action*, second ed., by John Carnell and Illary Huaylupo
    Sanchez (Manning, 2021) in the Manning catalog. If you are not familiar with microservices,
    don’t worry. That knowledge is not required to follow along with this book.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本书不是关于微服务的，因此我不会详细介绍它们。如果您对这个主题感兴趣，可以查看山姆·纽曼（Sam Newman）的《Building Microservices》，第二版（O’Reilly，2021年）和克里斯·理查森（Chris
    Richardson）的《Microservices Patterns》（Manning，2018年）。如果您对Spring有更多兴趣，可以在Manning目录中找到约翰·卡内尔（John
    Carnell）和伊拉里·华伊卢波·桑切斯（Illary Huaylupo Sanchez）的《Spring Microservices in Action》，第二版（Manning，2021年）。如果您不熟悉微服务，不用担心。您不需要这些知识就能跟随本书。
- en: After many years of fame and failed migrations, intense discussions about the
    future of this popular architectural style have arisen in the developer community.
    Some engineers started talking about *macroservices* to reduce the number of components
    and, therefore, the complexity of managing them. The term “macroservices” was
    suggested sardonically by Cindy Sridharan, but it has been adopted in the industry
    and used by companies like Dropbox and Airbnb to describe their new architectures.[^(16)](#pgfId-1018237)
    Others proposed a *citadel* architectural style, consisting of a central monolith
    surrounded by microservices. Still others are advocating a return to monolithic
    applications in the form of modular monoliths.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在多年的名声和失败的迁移之后，关于这种流行架构风格未来的激烈讨论在开发者社区中兴起。一些工程师开始谈论*宏服务（macroservices）*以减少组件数量，从而降低管理它们的复杂性。术语“宏服务”是由辛迪·斯里达兰（Cindy
    Sridharan）讽刺性地提出的，但它在业界被采用，并被像Dropbox和Airbnb这样的公司用来描述他们的新架构。[^(16)](#pgfId-1018237)其他人提出了*堡垒（citadel）*架构风格，由一个中心单体和周围的微服务组成。还有一些人主张以模块化单体（modular
    monoliths）的形式回归单体应用程序。
- en: In the end, the important thing is to choose an architecture that can deliver
    value to our customers and our businesses. That’s why we develop applications
    in the first place. Each architectural style has its use cases. There is no such
    thing as a silver bullet or one-size-fits-all solution. Most of the negative experiences
    related to microservices were caused by other issues, such as bad code modularization
    or unfitting organization structure. There shouldn’t be a battle between monoliths
    and microservices.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，重要的是选择一种能够为我们客户和业务创造价值的架构。这就是我们最初开发应用程序的原因。每种架构风格都有其用例。没有银弹或一刀切解决方案。与微服务相关的许多负面经历都是由其他问题引起的，例如代码模块化不良或组织结构不合适。单体和微服务之间不应该有战争。
- en: In this book, I’m interested in showing you how to build cloud native applications
    with Spring and deploy them to Kubernetes as containers. Cloud native applications
    are distributed systems, just like microservices are. Some topics usually discussed
    in the context of microservices actually belong to any distributed system, such
    as routing and service discovery. Cloud native applications are loosely coupled
    by definition, and that is also a feature of microservices.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我感兴趣的是向你展示如何使用Spring构建云原生应用并将它们作为容器部署到Kubernetes。云原生应用是分布式系统，就像微服务一样。一些通常在微服务背景下讨论的主题实际上属于任何分布式系统，例如路由和服务发现。云原生应用根据定义是松散耦合的，这也是微服务的一个特性。
- en: Even if they have some similar aspects, it’s essential to understand that cloud
    native applications and microservices are not the same. You can definitely use
    a microservices style for cloud native applications. Many developers do, but it’s
    not a requirement. In this book, I will use an architectural style that we might
    call *service-based*. Perhaps it’s not a catchy name or a fancy one, but it’s
    enough for our purpose. We’ll deal with services. They can be of any size, and
    they can encapsulate logic according to different principles. That doesn’t matter.
    What we want is to design services to fit our development, organizational, and
    business needs.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 即使它们有一些相似之处，我们也要明白云原生应用和微服务并不相同。你当然可以使用微服务风格来构建云原生应用。许多开发者确实这样做，但这并不是一个必要条件。在这本书中，我将使用一种我们可能称之为*基于服务的*架构风格。也许这个名字不够吸引人，也不是很花哨，但对于我们的目的来说已经足够了。我们将处理服务。它们可以是任何大小，并且可以根据不同的原则封装逻辑。这并不重要。我们想要的只是设计服务以满足我们的开发、组织和业务需求。
- en: 1.7.2 Service-based architecture for cloud native applications
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.7.2 云原生应用的基于服务的架构
- en: Throughout this book, we’ll design and build cloud native applications according
    to a service-based architecture.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们将根据基于服务的架构设计和构建云原生应用。
- en: 'Our central unit of work will be a service that can interact with other services
    in different ways. Using the distinction proposed by Cornelia Davis in her book
    *Cloud Native Patterns* (Manning, 2019), we can identify two elements of the architecture:
    services and interactions.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的工作中心将是一个可以以不同方式与其他服务交互的服务。使用Cornelia Davis在她的书《云原生模式》（Manning，2019）中提出的方法，我们可以识别出架构的两个要素：服务和交互。
- en: '*Service*—A component that provides any kind of service to another component'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*服务*——为另一个组件提供任何类型服务的组件'
- en: '*Interaction*—The communication of services with each other to accomplish the
    system’s requirements'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*交互*——服务之间为了完成系统需求而进行的通信'
- en: Services are quite generic components—they might be anything. We can classify
    them according to whether they store any kind of state, distinguishing between
    *application services* (stateless) and *data services* (stateful).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 服务是非常通用的组件——它们可能是任何东西。我们可以根据它们是否存储任何类型的状态来对它们进行分类，区分*应用服务*（无状态）和*数据服务*（有状态）。
- en: Figure 1.14 shows the elements of a cloud native architecture. An application
    used to manage the inventory for a book library would be an application service.
    A PostgreSQL database used to store information about the books would be a data
    service.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.14显示了云原生架构的元素。一个用于管理图书馆库存的应用程序将是一个应用服务。一个用于存储书籍信息的PostgreSQL数据库将是一个数据服务。
- en: '![01-14](../Images/01-14.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![01-14](../Images/01-14.png)'
- en: Figure 1.14 Service-based architecture for cloud native applications. The main
    elements are services (application or data) that interact with each other in different
    ways.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.14 云原生应用的基于服务的架构。主要元素是服务（应用或数据），它们以不同的方式相互交互。
- en: Application services
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 应用服务
- en: Application services are stateless and are responsible for implementing any
    kind of logic. They don’t have to obey specific rules like those for microservices,
    as long as they expose all the cloud native properties you learned about earlier
    in this chapter.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 应用服务是无状态的，负责实现任何类型的逻辑。只要它们暴露了本章前面学到的所有云原生属性，它们就不必遵守像微服务那样的特定规则。
- en: It’s paramount that you design each service with loose coupling and high cohesion
    in mind. Services should be as independent as possible. Distributed systems are
    complex, so you should be extra careful during the design phase. Increasing the
    number of services leads to an increased number of problems.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计每个服务时，考虑松散耦合和高内聚至关重要。服务应尽可能独立。分布式系统很复杂，因此在设计阶段应格外小心。增加服务的数量会导致问题数量增加。
- en: You’ll probably develop and maintain most of the application services in your
    system by yourself, but you can also use some offered by cloud providers, such
    as authentication or payment services.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要自己开发和维护系统中的大多数应用服务，但你也可以使用云服务提供商提供的一些服务，例如身份验证或支付服务。
- en: Data services
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 数据服务
- en: Data services are stateful and are responsible for storing any kind of state.
    The *state* is everything that should be preserved when shutting down a service
    or spinning up a new instance.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 数据服务是有状态的，并负责存储任何类型的状态。*状态*是关闭服务或启动新实例时应保留的一切。
- en: Data services can be relational databases like PostgreSQL, key/value stores
    like Redis, or message brokers like RabbitMQ. You can manage these services by
    yourself. Doing so is more challenging than managing cloud native applications
    due to the storage required to save the state, but you will gain more control
    over your own data. Another option is to use the data services offered by a cloud
    provider, in which case the provider will be responsible for managing all the
    concerns related to storage, resilience, scalability, and performance. In this
    case, you can take advantage of the many data services explicitly built for the
    cloud, such as Amazon DynamoDB, Azure Cosmos DB, and Google BigQuery.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 数据服务可以是关系数据库，如PostgreSQL，键值存储，如Redis，或消息代理，如RabbitMQ。你可以自己管理这些服务。这样做比管理云原生应用更具挑战性，因为需要存储来保存状态，但你将对自己的数据有更多的控制。另一种选择是使用云提供商提供的数据服务，在这种情况下，提供商将负责管理所有与存储、弹性、可扩展性和性能相关的关注点。在这种情况下，你可以利用为云专门构建的许多数据服务，例如Amazon
    DynamoDB、Azure Cosmos DB和Google BigQuery。
- en: Cloud native data services are a fascinating topic, but we will mainly deal
    with applications in this book. Data-related concerns like clustering, replication,
    consistency, and distributed transactions will not be detailed too much in the
    book. I would love to, but they deserve their own book to be adequately covered.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生数据服务是一个有趣的话题，但本书我们将主要处理应用。关于集群、复制、一致性和分布式事务等数据相关的问题不会在本书中详细讨论。我非常愿意这样做，但它们值得有自己的一本书来充分覆盖。
- en: Interactions
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 交互
- en: Cloud native services communicate with each other to fulfill the requirements
    of the system. How that communication happens will affect the overall properties
    of the system. For example, choosing a request/response pattern (synchronous HTTP
    call) over an event-based approach (messages streamed through RabbitMQ) will result
    in different levels of resilience for the application. In this book, we’ll use
    different types of interactions, learn the differences between them, and see when
    to use each approach.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生服务通过相互通信来满足系统的需求。这种通信方式将影响系统的整体属性。例如，选择请求/响应模式（同步HTTP调用）而不是基于事件的方案（通过RabbitMQ流的消息）将导致应用程序具有不同的弹性水平。在本书中，我们将使用不同类型的交互，了解它们之间的差异，并了解何时使用每种方法。
- en: Summary
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Cloud native applications are highly distributed systems that are specifically
    designed for and live in the cloud.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云原生应用是高度分布式的系统，专门为云设计和运行。
- en: The cloud is an IT infrastructure provided as a commodity in terms of computing,
    storage, and networking resources.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云是基于计算、存储和网络资源作为商品提供的IT基础设施。
- en: In the cloud, users pay only for the actual resources they use.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在云中，用户只需为实际使用的资源付费。
- en: 'Cloud platforms deliver their services at different levels of abstraction:
    infrastructure (IaaS), container (CaaS), platform (PaaS), functions (FaaS), or
    software (SaaS).'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云平台在不同的抽象级别上提供其服务：基础设施（IaaS）、容器（CaaS）、平台（PaaS）、函数（FaaS）或软件（SaaS）。
- en: Cloud native applications are horizontally scalable, loosely coupled, highly
    cohesive, resilient to faults, manageable, and observable.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云原生应用是水平可扩展的、松散耦合的、高度内聚的、对故障有弹性的、可管理的和可观察的。
- en: Cloud native development is supported by automation, continuous delivery, and
    DevOps.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云原生开发由自动化、持续交付和DevOps支持。
- en: Continuous delivery is a holistic engineering practice for delivering high-quality
    software quickly, reliably, and safely.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续交付是一种整体工程实践，旨在快速、可靠和安全地交付高质量的软件。
- en: DevOps is a culture enabling collaboration among different roles to deliver
    business value together.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DevOps是一种文化，它使不同角色之间能够协作，共同创造商业价值。
- en: Modern businesses go cloud native to produce software that can be delivered
    quickly, can be scaled dynamically depending on demand, and is always available
    and resilient to failures while optimizing costs.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代企业采用云原生来生产可以快速交付、根据需求动态扩展，并且始终可用且对故障具有弹性的软件，同时优化成本。
- en: Containers (such as Docker containers) can be used as computational units when
    designing cloud native systems. They are more lightweight than virtual machines
    and provide portability, immutability, and flexibility.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在设计云原生系统时，容器（如Docker容器）可以用作计算单元。它们比虚拟机更轻量，并提供可移植性、不可变性和灵活性。
- en: Dedicated platforms (such as Kubernetes) offer services to manage containers
    without directly handling the underlying layers. They provide container orchestration,
    cluster management, network services, and scheduling.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专用平台（如Kubernetes）提供管理容器而不直接处理底层层的服务。它们提供容器编排、集群管理、网络服务和调度。
- en: Serverless computing is a model where the platform (such as Knative) manages
    servers and the underlying infrastructure, and the developer only focuses on the
    business logic. The backend functionality is enabled on a pay-per-use basis for
    cost optimization.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无服务器计算是一种模型，其中平台（如Knative）管理服务器和底层基础设施，而开发者只需关注业务逻辑。后端功能基于按使用付费的方式实现，以优化成本。
- en: A microservices architecture can be used to build cloud native applications,
    but it’s not a requirement.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务架构可以用来构建云原生应用，但这不是必需的。
- en: To design cloud native applications, we’ll use a service-based style characterized
    by services and their interactions.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计云原生应用时，我们将使用以服务和它们之间的交互为特征的服务式风格。
- en: Cloud native services can be classified into application services (stateless)
    and data services (stateful).
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云原生服务可以分为应用服务（无状态）和数据服务（有状态）。
- en: '* * *'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^(1.) P. Fremantle, “Cloud Native”, *Paul Fremantle’s Blog*, May 28, 2010, [http://mng.bz/Vy1G](http://mng.bz/Vy1G).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: ^（1.）P. Fremantle，“云原生”，*保罗·弗雷曼特的博客*，2010年5月28日，[http://mng.bz/Vy1G](http://mng.bz/Vy1G).
- en: ^(2.) Cloud Native Computing Foundation, “CNCF Cloud Native Definition v1.0,”
    [http://mng.bz/de1w](http://mng.bz/de1w).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: ^（2.）云原生计算基金会，“CNCF云原生定义v1.0”，[http://mng.bz/de1w](http://mng.bz/de1w).
- en: ^(3.) NIST, “The NIST Definition of Cloud Computing,” SP 800-145, September
    2011, [http://mng.bz/rnWy](http://mng.bz/rnWy).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: ^（3.）NIST，“云计算的NIST定义”，SP 800-145，2011年9月，[http://mng.bz/rnWy](http://mng.bz/rnWy).
- en: '^(4.) N.R. Herbst, S. Kounev, and R. Reussner, “Elasticity in Cloud Computing:
    What it is, and What it is Not,” in *Proceedings of the 10th International Conference
    on Autonomic Computing (ICAC 2013)*, [http://mng.bz/BZm2](http://mng.bz/BZm2).'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: ^（4.）N.R. Herbst，S. Kounev，和R. Reussner，“云计算中的弹性：它是什么，它不是什么”，在*第10届国际自适应性计算会议（ICAC
    2013）论文集*中，[http://mng.bz/BZm2](http://mng.bz/BZm2).
- en: ^(5.) C. Davis, “Realizing Software Reliability in the Face of Infrastructure
    Instability,” in *IEEE Cloud Computing* 4, 5, pp. 34-40, September/October 2017.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: ^（5.）C. Davis，“面对基础设施不稳定实现软件可靠性”，在*IEEE云计算* 4, 5, 第34-40页，2017年9月/10月。
- en: ^(6.) D.L. Parnas, “On the criteria to be used in decomposing systems into modules,”
    *Communications of the ACM* 15, 12 (December 1972), 1053-1058, [http://mng.bz/gwOl](http://mng.bz/gwOl).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: ^（6.）D.L. Parnas，“在将系统分解为模块时使用的标准”，“*ACM通讯*”15, 12 (1972年12月), 1053-1058, [http://mng.bz/gwOl](http://mng.bz/gwOl).
- en: ^(7.) J.E. Blyler, “Heuristics for resilience—A richer metric than reliability,”
    *2016 IEEE International Symposium on Systems Engineering (ISSE)*, 2016, pp. 1-4.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: ^（7.）J.E. Blyler，“用于弹性的启发式方法——比可靠性更丰富的指标”，“2016年IEEE国际系统工程会议（ISSE）”，2016年，第1-4页。
- en: ^(8.) A. Avižienis, J. Laprie, and B. Randell, “Fundamental Concepts of Dependability,”
    2001, [http://mng.bz/e7ez](http://mng.bz/e7ez).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: ^（8.）A. Avižienis，J. Laprie，和B. Randell，“可靠性基本概念”，2001年，[http://mng.bz/e7ez](http://mng.bz/e7ez).
- en: '^(9.) A. Asta, “Observability at Twitter: technical overview, part 1,” March
    18, 2016, [http://mng.bz/pO8G](http://mng.bz/pO8G).'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: ^（9.）A. Asta，“Twitter的可观察性：技术概述，第1部分”，2016年3月18日，[http://mng.bz/pO8G](http://mng.bz/pO8G).
- en: ^(10.) M. Fowler, “Infrastructure As Code,” March 1, 2016, [https://martinfowler.com/bliki/InfrastructureAsCode.html](https://martinfowler.com/bliki/InfrastructureAsCode.html).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: ^(10.) M. Fowler, “基础设施即代码,” 2016年3月1日, [https://martinfowler.com/bliki/InfrastructureAsCode.html](https://martinfowler.com/bliki/InfrastructureAsCode.html).
- en: ^(11.) M. Fowler, “Continuous Delivery,” May 30, 2013, [http://mng.bz/lRWo](http://mng.bz/lRWo).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: ^(11.) M. Fowler, “持续交付,” 2013年5月30日, [http://mng.bz/lRWo](http://mng.bz/lRWo).
- en: ^(12.) M. Fowler, “Continuous Integration Certification,” January 18, 2017,
    [http://mng.bz/xM4X](http://mng.bz/xM4X).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: ^(12.) M. Fowler, “持续集成认证,” 2017年1月18日, [http://mng.bz/xM4X](http://mng.bz/xM4X).
- en: ^(13.) K. Mugrage, “My definition of DevOps,” December 8, 2020, [http://mng.bz/AVox](http://mng.bz/AVox).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: ^(13.) K. Mugrage, “我对DevOps的定义,” 2020年12月8日, [http://mng.bz/AVox](http://mng.bz/AVox).
- en: '^(14.) J. Barr, “ACM Queue: Interview with Amazon’s Werner Vogels,” *AWS News
    Blog*, May 16, 2006, [http://mng .bz/ZpqA](http://mng.bz/ZpqA).'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: ^(14.) J. Barr, “ACM Queue：采访亚马逊的Werner Vogels,” *AWS新闻博客*, 2006年5月16日, [http://mng.bz/ZpqA](http://mng.bz/ZpqA).
- en: '^(15.) N. Kratzke and R. Peinl, “ClouNS—a Cloud-Native Application Reference
    Model for Enterprise Architects,” *2016 IEEE 20th International Enterprise Distributed
    Object Computing Workshop (EDOCW)*, 2016, pp. 1-10, doi: 10.1109/EDOCW.2016.7584353.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '^(15.) N. Kratzke 和 R. Peinl, “ClouNS——面向企业架构师的云原生应用程序参考模型,” *2016 IEEE 第20届国际企业分布式对象计算研讨会
    (EDOCW)*, 2016, 第1-10页, doi: 10.1109/EDOCW.2016.7584353.'
- en: ^(16.) C. Sridharan, May 15, 2022, [http://mng.bz/YG5N](http://mng.bz/YG5N).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: ^(16.) C. Sridharan, 2022年5月15日, [http://mng.bz/YG5N](http://mng.bz/YG5N).
