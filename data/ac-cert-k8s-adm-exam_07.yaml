- en: 7 Storage in Kubernetes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 Kubernetes中的存储
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Creating a volume in Kubernetes
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Kubernetes中创建卷
- en: Persistent volume claims and storage classes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久卷声明和存储类
- en: Using storage with applications in Kubernetes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Kubernetes中的应用程序中使用存储
- en: As we’ve seen from previous exercises, the life of a Pod is short, and so is
    the life of the data that resides in that Pod. To solve this problem and retain
    the data that a Pod uses, we create persistent volumes (PVs). On the exam, you’ll
    be tested on your ability to create a PV, as well as a persistent volume claim
    (PVC) and a storage class. We’ll discuss each of these topics in this chapter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从之前的练习中看到的，Pod的生命周期很短，驻留在该Pod中的数据生命周期也短。为了解决这个问题并保留Pod使用的相关数据，我们创建了持久卷（PV）。在考试中，你将测试创建PV、持久卷声明（PVC）和存储类的能力。我们将在本章中讨论这些主题。
- en: The storage domain
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 存储领域
- en: This chapter covers the storage domain of the CKA curriculum, which consists
    of 10% of the questions on the exam. This domain covers the methods by which application
    data is used in Kubernetes, including mounting storage to Pods for use with containers.
    It encompasses the following competencies.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了CKA课程中的存储领域，该领域占考试题目的10%。该领域涵盖了应用程序数据在Kubernetes中的使用方法，包括将存储挂载到Pod中以供容器使用。它包括以下能力。
- en: '| Competency | Chapter section |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| 能力 | 章节部分 |'
- en: '| --- | --- |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Understand storage classes and PVCs. | 7.1, 7.3 |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| 理解存储类和PVC。 | 7.1, 7.3 |'
- en: '| Understand volume mode, access modes, and reclaim policies for volumes. |
    7.1.1, 7.1.2, 7.1.3 |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| 理解卷模式、访问模式和回收策略。 | 7.1.1, 7.1.2, 7.1.3 |'
- en: '| Understand PVC primitives. | 7.2 |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 理解PVC原语。 | 7.2 |'
- en: '| Know how to configure applications with persistent storage. | 7.1, 7.2, 7.3,
    7.4 |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 了解如何配置具有持久存储的应用程序。 | 7.1, 7.2, 7.3, 7.4 |'
- en: 7.1 Persistent volumes
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1 持久卷
- en: To prevent data loss in Kubernetes, data is decoupled from the Pod itself by
    creating an entirely separate Kubernetes object called a *persistent volume*,
    which is available to all Pods in the cluster, as PVs are not namespaced. As Pods
    come and go, the data is not tied to the Pod itself, so it lives beyond the life
    of the Pod inside of its own managed resource. You can continue to add data objects
    to the volume, and the persistent volume will not change if another Pod is planning
    to mount that same volume, as is depicted in figure 7.1\. The actual storage is
    backed by the host, a network file system (NFS) server, a Simple Storage Solution
    (S3) bucket in Amazon, or any other storage provider.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止在Kubernetes中数据丢失，通过创建一个完全独立的Kubernetes对象，称为*持久卷*，将数据从Pod本身解耦，该对象对所有集群中的Pod都是可用的，因为PV不是命名空间化的。随着Pod的来去，数据并不绑定到Pod本身，因此它在其自己的管理资源中超越了Pod的生命周期。你可以继续向卷中添加数据对象，如果另一个Pod计划挂载相同的卷，持久卷将不会改变，如图7.1所示。实际的存储由主机、网络文件系统（NFS）服务器、亚马逊的简单存储解决方案（S3）存储桶或任何其他存储提供商支持。
- en: '![](../../OEBPS/Images/07-01.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/07-01.png)'
- en: Figure 7.1 A persistent volume (PV) that is mounted to a Pod, which can act
    as an independent entity
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 一个挂载到Pod的持久卷（PV），它可以作为一个独立的实体
- en: 'The CKA exam will test you on three types of storage: (1) the `emptyDir` volume,
    (2) the `hostPath` volume, and (3) the `nfs` volume, so these are the types we’ll
    focus on in this chapter (as opposed to many other types). For example, the exam
    question may say something like the following.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: CKA考试将测试你对三种存储类型的理解：(1) `emptyDir`卷，(2) `hostPath`卷，和(3) `nfs`卷，因此我们将重点关注这些类型（而不是许多其他类型）。例如，考试问题可能如下所述。
- en: '| Exam Task In cluster `ek8s`, configure a `hostPath` PV named `vol02833` with
    a size of 10 MB of local storage from the worker node host `node01`. The directory
    on the host should be `/mnt/data`. Create a PVC named `claim-02833` that will
    reserve 90 MB of storage from the volume `vol02833`. Mount it to a Pod within
    a Deployment named `frontend0113`; the mount path within the container should
    be `/usr/share/nginx/html`. The name of the YAML file should be `deploy.yaml`.
    |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 考试任务 在集群`ek8s`中，配置一个名为`vol02833`的`hostPath` PV，大小为10 MB的本地存储，来自工作节点主机`node01`。主机上的目录应该是`/mnt/data`。创建一个名为`claim-02833`的PVC，将从卷`vol02833`中保留90
    MB的存储。将其挂载到名为`frontend0113`的Deployment中的Pod；容器内的挂载路径应该是`/usr/share/nginx/html`。YAML文件的名称应该是`deploy.yaml`。
    |'
- en: If you don’t already have access to an existing Kubernetes cluster, creating
    a Kubernetes cluster with kind is explained in appendix A. Be sure to create a
    two-node cluster, as we’ll use the worker node’s local storage to create the PV
    resource. As soon as you have access to your two-node cluster, get a shell to
    the control plane node by running the command `docker exec -it kind-control-plane
    bash`. Once you have a shell, set your alias `k` to equal `kubectl` with the command
    `alias k=kubectl`. On the exam, they will already have this alias set for you,
    so it’s good to get used to using `k`, as opposed to having to type `kubectl`
    repeatedly.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有访问现有Kubernetes集群的权限，附录A中解释了如何使用kind创建Kubernetes集群。请确保创建一个双节点集群，因为我们将会使用工作节点的本地存储来创建PV资源。一旦您有权访问您的双节点集群，通过运行命令`docker
    exec -it kind-control-plane bash`来获取控制平面节点的shell。一旦您有了shell，通过命令`alias k=kubectl`将您的别名`k`设置为等于`kubectl`。在考试中，他们已经为您设置了此别名，所以熟悉使用`k`而不是反复输入`kubectl`是很好的。
- en: To create this PV resource, we’ll use the Kubernetes documentation to copy some
    YAML, which you’ll also be able to do during the exam. Not only is this good practice
    for exam day, but we’re also doing it this way because, by design, we’re not able
    to create the YAML template like we were with Deployments using `--dry-run=client`.
    Accessing the YAML using the documentation will allow you to become familiar with
    Kubernetes docs and how to navigate them.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建此PV资源，我们将使用Kubernetes文档来复制一些YAML，您在考试期间也将能够这样做。这不仅是对考试日的良好实践，而且我们之所以这样做，是因为按照设计，我们无法像使用`--dry-run=client`创建部署的YAML模板那样创建YAML模板。通过文档访问YAML将使您熟悉Kubernetes文档以及如何导航它们。
- en: EXAM TIP In the new exam environment, use the keyboard shortcut CTRL-SHIFT-C
    to copy and CTRL-SHIFT-V to paste. This, along with knowing how to search Kubernetes
    documentation, will save you time on the exam when you cannot easily create persistent
    storage with `kubectl`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 考试技巧：在新考试环境中，使用快捷键CTRL-SHIFT-C来复制和CTRL-SHIFT-V来粘贴。这，加上知道如何搜索Kubernetes文档，将在您无法轻松使用`kubectl`创建持久存储时节省考试时间。
- en: Go to [https://kubernetes.io/docs](https://kubernetes.io/docs) and use the search
    bar on the left side of the screen to search for the phrase `use a persistent
    volume`. Click on the link that says “Configure a Pod to Use a PersistentVolume
    for Storage | Kubernetes” and scroll down to the section “Create a Persistent
    Volume.” The full URL of the page is [http://mng.bz/rW0y](http://mng.bz/rW0y).
    Copy and paste the YAML from this page into a new file named `pv.yaml`. The result
    should look similar to figure 7.2.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 前往[https://kubernetes.io/docs](https://kubernetes.io/docs)，并使用屏幕左侧的搜索栏搜索短语“使用持久卷”。点击名为“配置Pod以使用持久卷进行存储
    | Kubernetes”的链接，并滚动到“创建持久卷”部分。该页面的完整URL是[http://mng.bz/rW0y](http://mng.bz/rW0y)。将此页面的YAML复制并粘贴到名为`pv.yaml`的新文件中。结果应类似于图7.2。
- en: '![](../../OEBPS/Images/07-02.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/07-02.png)'
- en: Figure 7.2 The YAML copied and pasted from Kubernetes documentation into a file
    named `pv.yaml`
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 从Kubernetes文档复制并粘贴到名为`pv.yaml`的文件中的YAML
- en: 'We’ll change the name of the PV from `task-pv-volume` to `vol02883` (figure
    7.2, line 4) and change the storage from `10Gi` to `100Mi` (figure 7.2, line 10).
    Save the file `pv.yaml` and create the PV with the command `k create -f pv.yaml`.
    If you perform the command `k get pv`, you will see an output similar to the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把PV的名称从`task-pv-volume`更改为`vol02883`（图7.2，第4行），并将存储从`10Gi`更改为`100Mi`（图7.2，第10行）。保存文件`pv.yaml`，并使用命令`k
    create -f pv.yaml`创建PV。如果您执行命令`k get pv`，您将看到类似于以下内容的输出：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You will see from the output that the status is available, which means it’s
    ready to be claimed. Let’s create our claim by scrolling down on that same page
    in the Kubernetes documentation. That page, again, is [http://mng.bz/Bm92](http://mng.bz/Bm92).
    Paste the YAML into a file named `pvc.yaml`. The file contents should be similar
    to figure 7.3.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中您可以看到状态是可用的，这意味着它已准备好被领取。让我们在Kubernetes文档的同一页面上向下滚动来创建我们的领取。该页面再次是[http://mng.bz/Bm92](http://mng.bz/Bm92)。将YAML粘贴到名为`pvc.yaml`的文件中。文件内容应类似于图7.3。
- en: '![](../../OEBPS/Images/07-03.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/07-03.png)'
- en: Figure 7.3 A PVC YAML file named `pvc.yaml`, which is copied from the Kubernetes
    documentation
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 一个名为`pvc.yaml`的PVC YAML文件，它是从Kubernetes文档中复制的
- en: 'Change the name of the PVC from `task-pv-claim` to `claim-02833` and change
    storage from `3Gi` to `90Mi` (figure 7.3, line 11). Create the PVC with the command
    `k apply -f pvc.yaml`. Once the resource is created, you can view the PVC with
    the command `k get pvc`, and you can also view the PV with the command `k get
    pv`. The output of that command will look like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 将 PVC 的名称从 `task-pv-claim` 更改为 `claim-02833`，并将存储从 `3Gi` 更改为 `90Mi`（图 7.3，第
    11 行）。使用命令 `k apply -f pvc.yaml` 创建 PVC。一旦资源创建成功，您可以使用命令 `k get pvc` 查看PVC，也可以使用命令
    `k get pv` 查看PV。该命令的输出将如下所示：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: EXAM TIP You can list multiple Kubernetes resources at once by just placing
    a comma in between the resource names. For example, perform the command `k get
    pv,pvc` to list both PVs and PVCs in the default namespace.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 考试提示：您可以通过在资源名称之间放置逗号来同时列出多个 Kubernetes 资源。例如，执行命令 `k get pv,pvc` 以在默认命名空间中列出
    PV 和 PVC。
- en: If you notice from the output, even though we specified `90Mi` in the PVC YAML,
    the capacity is `100Mi`. This is because the PVC will try to find the closest
    fit to the nearest PV that can fulfill that claim but cannot reserve only a portion
    of the PV. If we had requested `110Mi`, the PVC would not be satisfied, as there
    is no matching PV with the requested amount of storage.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您从输出中注意到，尽管我们在 PVC YAML 中指定了 `90Mi`，但容量是 `100Mi`。这是因为 PVC 将尝试找到最接近的 PV 来满足该请求，但不能仅保留
    PV 的一部分。如果我们请求 `110Mi`，PVC 将不会满足，因为没有匹配的 PV 具有请求的存储量。
- en: Let’s proceed to create a Deployment, so we can use our volume mounted to the
    container in the Pod. We can create a Deployment YAML with the command `k create
    deploy frontend0113 --image nginx --dry-run=client -o yaml > deploy.yaml`. Once
    our file is created, we’ll open it in Vim with the command `vim deploy.yaml`.
    The contents of the file should look similar to figure 7.4.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续创建一个 Deployment，这样我们就可以使用挂载到 Pod 容器中的卷。我们可以使用命令 `k create deploy frontend0113
    --image nginx --dry-run=client -o yaml > deploy.yaml` 创建 Deployment YAML。一旦文件创建成功，我们将使用命令
    `vim deploy.yaml` 打开它。文件内容应类似于图 7.4。
- en: '![](../../OEBPS/Images/07-04.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/07-04.png)'
- en: Figure 7.4 YAML for a Deployment that was created using the `kubectl` command
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 使用 `kubectl` 命令创建的 Deployment 的 YAML
- en: 'Under the spec, we’ll add the YAML for our volume inline with `containers`
    by typing `volumes:` on line 24 (you can delete `status: {}` as it is not required).
    Under `volumes:`, type `- name: vol-33`. Below that, inline with `name`, type
    `persistentVolumeClaim:`. Under `persistentVolumeClaim:`, indent two spaces and
    type `claimName: claim-02833`. Finally, delete the line `creationTimestamp: null`.
    The result will look like figure 7.5.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '在规范下，我们将通过在行 24 输入 `volumes:` 来将我们的卷 YAML 内联添加到 `containers` 中（您可以删除 `status:
    {}`，因为它不是必需的）。在 `volumes:` 下，输入 `- name: vol-33`。在其下方，与 `name` 保持一致，输入 `persistentVolumeClaim:`。在
    `persistentVolumeClaim:` 下，缩进两个空格并输入 `claimName: claim-02833`。最后，删除 `creationTimestamp:
    null` 这一行。结果将类似于图 7.5。'
- en: '![](../../OEBPS/Images/07-05.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/07-05.png)'
- en: Figure 7.5 Adding the `volumes` syntax to a Deployment spec in the YAML file
    `deploy.yaml`
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 在 YAML 文件 `deploy.yaml` 中将 `volumes` 语法添加到 Deployment 规范
- en: 'Before we create the Deployment, we’ll have to specify the mount path for the
    volume within the container. We’ll do that by adding a line below line 23\. Inline
    with resources, type `volumeMounts:`. Below that, type `- name: vol-33` (has to
    be the same as the volume name). Just below `name: vol-33`, inline with name,
    type `mountPath: "/usr/share/ nginx/html"`. The contents of the final Deployment
    YAML will look like figure 7.6.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '在创建 Deployment 之前，我们必须在容器内指定卷的挂载路径。我们将通过在行 23 下方添加一行来实现这一点。与资源保持一致，输入 `volumeMounts:`。在其下方，输入
    `- name: vol-33`（必须与卷名称相同）。在 `name: vol-33` 下方，与名称保持一致，输入 `mountPath: "/usr/share/nginx/html"`。最终
    Deployment YAML 的内容将类似于图 7.6。'
- en: '![](../../OEBPS/Images/07-06.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/07-06.png)'
- en: Figure 7.6 The complete YAML for a Deployment with a volume named `vol-33` attached
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 添加名为 `vol-33` 的卷的完整 Deployment YAML
- en: 'Now we can save our YAML file and create the Deployment with the command `k
    apply -f deploy.yaml``.` You can list the Deployment with the command `k get deploy`
    and list the Pods within the Deployment with the command `k get po`. The output
    will look similar to this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以保存我们的 YAML 文件，并使用命令 `k apply -f deploy.yaml` 创建 Deployment。您可以使用命令 `k
    get deploy` 列出 Deployment，并使用命令 `k get po` 列出 Deployment 内的 Pods。输出将类似于以下内容：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You will see that the container is running. This means that our volume was successfully
    mounted. To prove this, type the command `k describe po`, followed by the name
    of the Pod (the name of the Pod will be different for you). My command is `k describe
    po frontend0113-6d6c77b9b6-62qbh`. In the volume section of the output, you will
    see the volume named `vol-33` and the PVC that we created earlier. The abbreviated
    output will look similar to figure 7.7.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您会看到容器正在运行。这意味着我们的卷已成功挂载。为了证明这一点，请输入命令 `k describe po`，然后跟上是 Pod 的名称（Pod 的名称对您来说将是不同的）。我的命令是
    `k describe po frontend0113-6d6c77b9b6-62qbh`。在输出的卷部分，您将看到名为 `vol-33` 的卷以及我们之前创建的
    PVC。简略输出将类似于图 7.7。
- en: '![](../../OEBPS/Images/07-07.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/07-07.png)'
- en: Figure 7.7 Abbreviated output from the `k` `describe` `po` command, which shows
    the volume mounted to the Pod
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7 `k` `describe` `po` 命令的简略输出，显示了挂载到 Pod 上的体积
- en: Now that we’ve successfully created a PV, a PVC, and a Deployment that mounts
    that volume to a Pod, we have successfully completed this exam task.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经成功创建了一个 PV、一个 PVC 以及将卷挂载到 Pod 的 Deployment，我们已经成功完成了这个考试任务。
- en: 7.1.1 The problem with hostPath
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.1 hostPath 的问题
- en: The problem with using the `hostPath`-type volume is that, in multiple node
    clusters, the data is written to all of the nodes in the cluster, with the expectation
    that the storage configuration on all nodes is the same. If not, the data will
    only be written to one node. This means that if the Pod is scheduled to a node,
    there is a probability that the data will not reside on that node.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `hostPath` 类型的体积的问题在于，在多个节点集群中，数据会被写入集群中的所有节点，预期所有节点的存储配置都是相同的。如果不是这样，数据将只会写入一个节点。这意味着如果
    Pod 被调度到某个节点，数据可能不会驻留在该节点上。
- en: EXAM TIP If you get a question on the exam that indicates that the storage must
    persist beyond the life of the Pod, `hostPath` is going to be the volume type
    you need to provision unless stated otherwise. If you get a question that requires
    the data to exist on something besides local storage, the exam will state what
    the volume type should be (e.g., `nfs`).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 考试技巧：如果在考试中遇到一个表示存储必须超出 Pod 生命周期的题目，除非另有说明，否则 `hostPath` 将是您需要提供的卷类型。如果您遇到一个需要数据存在于除本地存储以外的题目，考试将说明应该使用哪种卷类型（例如，`nfs`）。
- en: 'To get around this problem, you can use the `nfs` volume type. An `nfs` volume
    allows you to store the data mounted to a Pod in an `nfs` share on the network.
    The `nfs` type also supports multiple writers; therefore, many Pods can use the
    volume simultaneously. Because we don’t have an `nfs` server running in our lab,
    I’ll show a simple example of a Pod that uses an `nfs` PV here:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，您可以使用 `nfs` 卷类型。`nfs` 卷允许您将挂载到 Pod 的数据存储在网络的 `nfs` 共享中。`nfs` 类型也支持多个写入者；因此，许多
    Pod 可以同时使用这个卷。因为我们实验室中没有运行 `nfs` 服务器，所以我将在这里展示一个使用 `nfs` PV 的 Pod 的简单示例：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The PV looks a little different than the previous one, as we have added the
    `nfs` field with the server and path. The path is where the mount is located on
    the `nfs` server. The mount options are based on the version of `nfs` that your
    server is using. Once we create this PV, we can create a PVC like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: PV 看起来与之前的不同，因为我们添加了包含服务器和路径的 `nfs` 字段。路径是挂载在 `nfs` 服务器上的位置。挂载选项基于您的服务器使用的 `nfs`
    版本。一旦我们创建了这个 PV，我们就可以创建一个像这样的 PVC：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As you can see, the structure of the claim is very much the same as the previous
    claim, except for the access mode. This is because you can write `nfs` volumes
    to multiple sources (Pods). Within a PVC, we can also specify which PV we want
    the claim to be bound to by specifying the `volumeName`, as on the very last line.
    Once we have both a PV and a PVC, we can create the YAML for our Pod as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，声明的结构非常类似于之前的声明，只是访问模式不同。这是因为您可以写入 `nfs` 卷到多个源（Pod）。在 PVC 中，我们也可以通过指定 `volumeName`
    来指定声明应绑定到的 PV，就像在最后一行那样。一旦我们有了 PV 和 PVC，我们就可以创建 Pod 的 YAML 如下：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Again, if you run this in your lab, it will fail because you do not have a running
    NFS server on your network; however, on the exam, it will be different. If there
    is a question that indicates you must use an `nfs` volume, you will most certainly
    be provided a running `nfs` server, in the form of a server address and path.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，如果在您的实验室中运行此示例，它将失败，因为您的网络中没有运行的 NFS 服务器；然而，在考试中，情况将不同。如果有问题表示您必须使用 `nfs`
    卷，您肯定会提供一个运行的 `nfs` 服务器，以服务器地址和路径的形式提供。
- en: 7.1.2 Volume modes
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.2 体积模式
- en: 'The *volume mode* is the type of volume being accessed in Kubernetes. By default,
    if you don’t include a specific mode, a PV will assume the volume mode `FileSystem`,
    as opposed to `Block`. We didn’t have to specify it in the YAML initially, but
    you can see what mode it defaults to by running the command `k describe pv vol02833`.
    The output of that command will look like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*卷模式*是Kubernetes中正在访问的卷类型。默认情况下，如果您没有包含特定的模式，PV将假定卷模式为`FileSystem`，而不是`Block`。最初我们不需要在YAML中指定它，但您可以通过运行命令`k
    describe pv vol02833`来查看它默认的模式。该命令的输出将类似于以下内容：'
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you see, between `Access Modes:` and `Capacity:` is `VolumeMode: FileSystem`.
    The filesystem mode is intended to be mounted into Pods as a directory. The block
    mode is backed by a block device, where the device is empty (unformatted). Some
    examples of block devices are Amazon Elastic Block Store (EBS), Azure Disk, iSCSI
    disks, FC (Fibre Channel) disks, CephFS, or even local disks (like we used in
    the exam task). For the CKA exam, you won’t have to create the block storage itself,
    you will only need to know how to change the `volumeMode` in the YAML spec. Because
    we still have the file `pv.yaml` from section 7.8, we’ll open this up and add
    one line to it. Just below `storageClassName`, inline, add `volumeMode: Block`.
    Also change the name of the PV, as you can’t have two volumes with the same name.
    The final YAML for our new block storage volume will look like figure 7.8.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '如您所见，在`Access Modes:`和`Capacity:`之间是`VolumeMode: FileSystem`。文件系统模式旨在将卷挂载到Pod中作为一个目录。块模式由块设备支持，其中设备是空的（未格式化）。块设备的例子包括Amazon
    Elastic Block Store (EBS)、Azure Disk、iSCSI磁盘、FC（光纤通道）磁盘、CephFS，甚至是本地磁盘（就像我们在考试任务中使用的那样）。对于CKA考试，您不需要创建块存储本身，您只需要知道如何更改YAML规范中的`volumeMode`。因为我们仍然有7.8节中的文件`pv.yaml`，我们将打开它并添加一行。在`storageClassName`下面，内联添加`volumeMode:
    Block`。同时更改PV的名称，因为您不能有两个具有相同名称的卷。我们新的块存储卷的最终YAML将类似于图7.8。'
- en: '![](../../OEBPS/Images/07-08.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/07-08.png)'
- en: Figure 7.8 Adding line 9 to create a PV in `Block` mode
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8 在`Block`模式下创建PV的第九行
- en: 'You can create this new PV with the command `k apply -f pv.yaml`, and you will
    see the PV right beside the existing PV. The output will look similar to this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用命令`k apply -f pv.yaml`创建这个新的PV，您将看到PV紧挨着现有的PV。输出将类似于以下内容：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You’ll notice that these look exactly the same in terms of their composition,
    but one is in `FileSystem` mode and one is in `Block` mode.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，在组成方面它们看起来完全相同，但一个是`FileSystem`模式，另一个是`Block`模式。
- en: 7.1.3 Access modes
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.3 访问模式
- en: '*Access* *mode* determines how the volume is to be accessed, by what permissions,
    and from which applications running in Kubernetes. You may have noticed, both
    in our `pv.yaml` file and our `pvc.yaml` file, we had specified an access mode
    of `ReadWriteOnce`. What does this mean? Think of it from the node’s perspective,
    as the node is the one accessing the volume. `ReadWriteOnce` means that only one
    node can mount the volume and read and write to it. The three other modes are
    `ReadOnlyMany`, which means multiple nodes can mount the volume for reading only;
    `ReadWriteMany`, which means multiple nodes can mount the volume for writing and
    reading; and `ReadWriteOncePod`, which means that only one Pod on that one node
    can mount that volume for reading and writing.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*访问模式*决定了卷如何被访问，通过什么权限，以及从哪些在Kubernetes中运行的应用程序。您可能已经注意到，在我们的`pv.yaml`文件和我们的`pvc.yaml`文件中，我们都指定了访问模式为`ReadWriteOnce`。这意味着什么？从节点的角度来考虑，因为节点是访问卷的那个。`ReadWriteOnce`意味着只有一个节点可以挂载卷并对其进行读写。其他三种模式是`ReadOnlyMany`，意味着多个节点可以只读挂载卷；`ReadWriteMany`，意味着多个节点可以读写挂载卷；以及`ReadWriteOncePod`，意味着只有一个Pod在该节点上可以挂载该卷进行读写。'
- en: A PV can have more than one access mode, whereas a PVC can only have one. Even
    if there are many modes specified in the PV YAML, the node can only utilize one
    access mode at a time, so you must choose one out of the four modes. For example,
    if we had added an access mode to our PV YAML, as in figure 7.9, you would have
    to choose either `ReadWriteOnce` or `ReadOnlyMany` in the PVC.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: PV可以有多个访问模式，而PVC只能有一个。即使PV YAML中指定了多个模式，节点一次也只能利用一个访问模式，因此您必须从四种模式中选择一个。例如，如果我们向我们的PV
    YAML添加了一个访问模式，如图7.9所示，您将不得不在PVC中选择`ReadWriteOnce`或`ReadOnlyMany`。
- en: '![](../../OEBPS/Images/07-09.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/07-09.png)'
- en: Figure 7.9 Multiple access modes specified in the YAML for a PV, of which only
    one can be used in the PVC
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9 在PV的YAML中指定了多个访问模式，其中只有一个是可以在PVC中使用的
- en: Also, most importantly, certain volumes only support certain access modes. For
    example, the type that we have here, `hostPath`, is not able to support `ReadOnlyMany`,
    `ReadWriteMany`, or `ReadWriteOncePod`. This is important to remember, as this
    may come up as a trick question on the exam.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，最重要的是，某些卷只支持某些访问模式。例如，我们这里有的类型`hostPath`不支持`ReadOnlyMany`、`ReadWriteMany`或`ReadWriteOncePod`。这一点很重要，因为这可能在考试中作为一个陷阱问题出现。
- en: EXAM TIP The exam may not explicitly state whether the access mode is `ReadOnlyMany`
    or `ReadWriteOnce`, as it assumes you know that `hostPath`-type volumes only support
    `ReadWriteOnce`. Alternatively, `nfs` volumes support `ReadWriteOnce`, `ReadOnlyMany`,
    and `ReadWriteMany`. The exam will only cover `emptyDir`, `hostPath`, and `nfs`
    volume types; `emptyDir` is not a PV type, so access modes are not available.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 考试技巧：考试可能不会明确说明访问模式是`ReadOnlyMany`还是`ReadWriteOnce`，因为它假设你知道`hostPath`类型的卷只支持`ReadWriteOnce`。另外，`nfs`卷支持`ReadWriteOnce`、`ReadOnlyMany`和`ReadWriteMany`。考试将只涵盖`emptyDir`、`hostPath`和`nfs`卷类型；`emptyDir`不是PV类型，因此没有访问模式。
- en: The short form of each access mode can be found in table 7.1; however, you only
    see these modes in short form when you describe either a PV or PVC.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 每个访问模式的简写可以在表7.1中找到；然而，只有当描述PV或PVC时，你才会看到这些简写形式。
- en: Table 7.1 Access modes and their short form, used in the YAML for a PV or PVC
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.1 访问模式和它们的简写形式，用于YAML中的PV或PVC
- en: '| Access mode | Short form | Description |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 访问模式 | 简写 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `ReadWriteOnce` | `RWO` | Only one node can mount the volume and read and
    write to it. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `ReadWriteOnce` | `RWO` | 只有一个节点可以挂载卷并对其进行读写。|'
- en: '| `ReadOnlyMany` | `ROX` | Multiple nodes can mount the volume for reading
    only. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `ReadOnlyMany` | `ROX` | 多个节点可以挂载卷进行只读。|'
- en: '| `ReadWriteMany` | `RWX` | Multiple nodes can mount the volume for writing
    and reading. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `ReadWriteMany` | `RWX` | 多个节点可以挂载卷进行读写。|'
- en: '| `ReadWriteOncePod` | `RWOP` | Only one Pod on that one node can mount that
    volume for reading and writing. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `ReadWriteOncePod` | `RWOP` | 只有一个Pod在该节点上可以挂载该卷进行读写。|'
- en: 7.1.4 Reclaim policies
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.4 回收策略
- en: 'Another default value that was applied to our PV in the exam task was the *reclaim
    policy*. A reclaim policy is for deciding what to do with the volume once the
    PVC bound to it is deleted. If you perform the command `k describe pv vol02833`,
    you will see the reclaim policy is set to `Retain` by default. The output from
    the `describe` command will look something like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在考试任务中应用于我们的PV的另一个默认值是*回收策略*。回收策略是用于决定在将PVC与其绑定删除后对卷进行什么操作。如果你执行命令`k describe
    pv vol02833`，你会看到默认的回收策略设置为`Retain`。`describe`命令的输出将类似于以下内容：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Between the `Claim` and `Access Modes` is the `Reclaim Policy`. This reclaim
    policy can also be set to `Recycle` or `Delete`. `Retain` means the volume can
    be used again, as it retains the data on the volume. It can then be used by another
    claim. `Recycle` means that the volume has been scrubbed (i.e., `rm -f`), but
    this policy has been deprecated, so use `Retain` or `Delete` instead. `Delete`
    indicates that the backed storage (i.e., Amazon EBS, Azure Disk) has been deleted
    as well as the PV object in Kubernetes. Only Amazon EBS, GCE PD, Azure Disk, and
    Cinder volumes support the delete policy.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Claim`和`Access Modes`之间是`Reclaim Policy`。此回收策略也可以设置为`Recycle`或`Delete`。`Retain`表示卷可以再次使用，因为它保留了卷上的数据。然后它可以被另一个声明使用。`Recycle`表示卷已被清理（即，`rm
    -f`），但此策略已被弃用，因此请改用`Retain`或`Delete`。`Delete`表示后端存储（即，Amazon EBS、Azure Disk）以及Kubernetes中的PV对象都已删除。只有Amazon
    EBS、GCE PD、Azure Disk和Cinder卷支持删除策略。
- en: Exam exercises
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 检验练习
- en: Create a PV named `volstore308` that reserves 22 MB of storage and does not
    specify a storage class. The volume will use the storage from the host at `/mnt/data`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`volstore308`的PV，预留22MB的存储空间，不指定存储类。该卷将使用主机上的`/mnt/data`存储空间。
- en: Create a PVC named `pv-claim-vol` that will claim the previously created PV
    with the correct access mode.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`pv-claim-vol`的PVC，将之前创建的PV以正确的访问模式声明。
- en: Create a Pod named `pod-access` with the image `centos:7` that will use the
    PVC from the previous step, and mount the volume inside the container at `/tmp/persistence`.
    Issue a command to keep the container alive. You can use `sleep 3600`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`pod-access`的Pod，使用镜像`centos:7`，将使用之前步骤中的PVC，并在容器内部挂载卷到`/tmp/persistence`。发布一个命令以保持容器活跃。你可以使用`sleep
    3600`。
- en: 7.2 Persistent volume claim
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2 持久卷声明
- en: As we experienced in the exam task in section 7.1, the PVC consumed the entire
    PV, even though the claim was for 10Mi less than the requested amount. To fulfill
    the request for storage, instead of waiting for an exact match, the PVC will choose
    the volume that is closest to match the request of that claim (figure 7.10).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在7.1节中的考试任务中体验到的，PVC消耗了整个PV，即使声称比请求量少10Mi。为了满足存储请求，而不是等待一个完全匹配的量，PVC将选择最接近该请求量的体积（图7.10）。
- en: '![](../../OEBPS/Images/07-10.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/07-10.png)'
- en: Figure 7.10 A PVC will choose the closest available volume size to fulfill the
    claim.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10 PVC将选择最接近的可用卷大小以满足请求。
- en: 'The job of the PVC is to reserve this storage on behalf of the container (within
    a Pod), so once this claim is in a `Bound` status, the claim will not release
    the volume, even if an administrator tries to delete the volume with force. For
    example, let’s try to delete the PV `vol02833` that we created as part of the
    exam task. Perform the command `k delete pv vol02833 -force``,` and you will see
    an output similar to the following (use CTRL-C to get back to your prompt after
    running this command):'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: PVC的职责是为容器（在Pod内）保留此存储，因此一旦此请求处于`已绑定`状态，请求将不会释放卷，即使管理员尝试强制删除卷。例如，让我们尝试删除作为考试任务一部分创建的PV
    `vol02833`。执行命令`k delete pv vol02833 -force`，你会看到类似的输出（在运行此命令后使用CTRL-C返回提示符）：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The PV will remain in a `Terminating` state, until the PVC is deleted. The
    PVC is not able to be deleted until the Pod is deleted. This prevents Kubernetes
    administrators from accidentally removing the underlying storage from a running
    Pod, which is a feature and not a bug. Try deleting the PVC with the command `k
    delete pvc claim-02833 -force`, and you’ll see the same output (use CTRL-C again
    to get your prompt back). The output will look similar to this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: PV将保持`终止`状态，直到PVC被删除。PVC在被删除之前无法被删除。这防止了Kubernetes管理员意外地从正在运行的Pod中移除底层存储，这是一个特性而不是错误。尝试使用命令`k
    delete pvc claim-02833 -force`删除PVC，你会看到相同的输出（再次使用CTRL-C来获取你的提示符）。输出将类似于以下内容：
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The PVC will continue to be in a `Terminating` state until the Deployment is
    deleted (and subsequently the Pod). In the meantime, the volume will continue
    to stay mounted to the Pod and usable—just as it did before the delete command
    was run—and will not affect the applications that are currently accessing the
    Pod and its storage. The *phase* of the Pod determines its state and can be obtained
    from the command `k get po`. A volume can be in one of the following phases:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: PVC将继续处于`终止`状态，直到部署被删除（随后是Pod）。在此期间，卷将继续挂载到Pod上并可用——就像在运行删除命令之前一样——并且不会影响当前访问Pod及其存储的应用程序。Pod的*阶段*决定了其状态，可以通过命令`k
    get po`获取。卷可以处于以下阶段之一：
- en: Available
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用
- en: Bound
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已绑定
- en: Released
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已发布
- en: Failed
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 失败
- en: 'We saw this when the PV was first created in section 7.1\. This is a requirement
    for the PVC: to claim the volume, it must be available to claim. *Bound* is the
    phase of the PV that indicates that it’s already claimed, which deems it unavailable
    to a new PVC. The *released* phase is significant because, if the PV is set to
    `retain` in the reclaim policy, it’s released and waiting for a new PVC to reclaim
    it. The *failed* phase means that during the reclaim process, the failed volume
    was not effective in bounding to a new PVC.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在7.1节中首次创建PV时看到了这一点。这是PVC的要求：要请求卷，它必须可用。*已绑定*是PV的阶段，表示它已经被请求，因此对新的PVC不可用。*已发布*阶段很重要，因为如果PV在回收策略中设置为`保留`，它将被释放并等待新的PVC回收它。*失败*阶段表示在回收过程中，失败的卷未能有效地绑定到新的PVC。
- en: 7.3 Storage class
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3 存储类
- en: 'While following the exam task from section 7.1, you may have noticed that we
    included a storage class in the YAML. A storage class is nothing more than a “storage
    profile” for a grouping of similar types of storage. It’s a lot like a label in
    that it doesn’t affect the underlying storage capability; it simplifies the process
    of creating persistent storage in Kubernetes. You can see existing storage classes
    in your cluster with the command `k get sc`. The output will look similar to this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在跟随7.1节的考试任务时，你可能已经注意到我们在YAML中包含了一个存储类。存储类不过是一个“存储配置文件”，用于一组类似类型的存储。它很像标签，因为它不影响底层存储能力；它简化了在Kubernetes中创建持久存储的过程。你可以使用命令`k
    get sc`查看你集群中的现有存储类。输出将类似于以下内容：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this kind Kubernetes cluster, a local path-type volume is precreated. This
    was created as part of the cluster creation process, not something I created manually.
    You’ll experience this in a lot of other cluster bootstrapping tools (as with
    kind), such as on the CKA exam with kubeadm, which will have preprovisioned storage
    classes that you will be asked to use with a PVC. An example of an exam question
    follows.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 Kubernetes 集群中，一个本地路径类型的卷是预先创建的。这是在集群创建过程中创建的，不是我自己手动创建的。你将在许多其他集群引导工具中体验到这一点（例如与
    kind 一样），例如在 CKA 考试中使用 kubeadm，它将预配置存储类，你将被要求使用 PVC。以下是一个考试题目的例子。
- en: '| Exam Task In cluster `ek8s`, create a PVC named `claim-03833` based on an
    existing storage class named `standard`. Claim 1 GB of storage space. Mount it
    to a Pod, within a Deployment named `backend0113`; the mount path within the container
    should be `/var/lib/mysql`. The name of the YAML file should be `backend.yaml`.
    |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| 在集群 `ek8s` 中，基于名为 `standard` 的现有存储类创建一个名为 `claim-03833` 的 PVC，申请 1 GB 的存储空间。将其挂载到名为
    `backend0113` 的 Deployment 中的 Pod 上；容器内的挂载路径应为 `/var/lib/mysql`。YAML 文件的名称应为 `backend.yaml`。
    |'
- en: Using the same cluster that you used in section 7.1, copy the previous `pvc.yaml`
    file and rename it `newpvc.yaml` with the command `cp pvc.yaml newpvc.yaml`. Open
    the file `newpvc.yaml` in Vim with the command `vim newpvc.yaml`. Change the name
    from `claim-02833` to `claim-03833` and change the `storageClassName` from `manual`
    to `standard`. Finally, change the `storage` from `90Mi` to `1Gi`. The final contents
    of the file will look like figure 7.11.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与 7.1 节中相同的集群，复制之前的 `pvc.yaml` 文件，并使用命令 `cp pvc.yaml newpvc.yaml` 将其重命名为 `newpvc.yaml`。使用命令
    `vim newpvc.yaml` 打开文件 `newpvc.yaml`。将名称从 `claim-02833` 更改为 `claim-03833`，将 `storageClassName`
    从 `manual` 更改为 `standard`。最后，将 `storage` 从 `90Mi` 更改为 `1Gi`。文件的最终内容将类似于图 7.11。
- en: '![](../../OEBPS/Images/07-11.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/07-11.png)'
- en: Figure 7.11 The PVC used with the storage class named `standard`
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.11 使用名为 `standard` 的存储类的 PVC
- en: 'To create the PVC, subsequently dynamically provisioning a PV, save and quit
    Vim, then type the command `k apply -f newpvc.yaml`. This is where things get
    interesting, and I must remind you NOT to panic if you experience this during
    the exam. When you list the PVC, you should get the following (which is a good
    thing):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建 PVC，随后动态配置 PV，保存并退出 Vim，然后输入命令 `k apply -f newpvc.yaml`。这里事情变得有趣，我必须提醒你，如果在考试中遇到这种情况，不要慌张。当你列出
    PVC 时，你应该得到以下结果（这是一个好现象）：
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The PVC is pending because the storage is only provisioned when a Pod—in other
    words, a “consumer”—is created to use (consume) that PVC, which is intelligent,
    as you don’t want to preprovision a bunch of volumes if they are not in use. This
    is the major difference between static provisioning—what we did in section 7.1—and
    the dynamic provisioning that occurs with storage classes. You will see this echoed
    if you run the command `k describe pvc claim-03833`. The output should look like
    this (abbreviated):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: PVC 处于挂起状态，因为存储只有在创建一个 Pod（换句话说，一个“消费者”）来使用（消耗）该 PVC 时才会配置，这是智能的，因为你不希望预先配置大量未使用的卷。这是静态配置（我们在
    7.1 节中执行的操作）与存储类发生的动态配置之间的主要区别。如果你运行命令 `k describe pvc claim-03833`，你会看到这一点得到反映。输出应该如下（已缩略）：
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now that we know our PVC is waiting for a consumer, let’s create one! Again,
    let’s copy the previous YAML file `deploy.yaml` to a new file named `backend.yaml`
    with the command `cp deploy.yaml backend.yaml`. Open the file `backend.yaml` with
    the command `vim backend.yaml`. Change the name and labels to `backend0113`, the
    image to `mysql:8.0`, the name of the container to `mysql`, the name of the `volumeMounts`
    to `mysqldata`, the `mountPath` to `"/var/lib/mysql"`, and most importantly the
    PV name to `claim-03833`. We’ll add the environment variable for the MySQL password
    and expose port 3306 on the container. The final YAML will look like figure 7.12.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道我们的 PVC 正在等待消费者，让我们创建一个！再次，让我们使用命令 `cp deploy.yaml backend.yaml` 将之前的
    YAML 文件 `deploy.yaml` 复制到一个名为 `backend.yaml` 的新文件中。使用命令 `vim backend.yaml` 打开文件
    `backend.yaml`。将名称和标签更改为 `backend0113`，将镜像更改为 `mysql:8.0`，将容器名称更改为 `mysql`，将 `volumeMounts`
    的名称更改为 `mysqldata`，将 `mountPath` 更改为 `"/var/lib/mysql"`，最重要的是将 PV 名称更改为 `claim-03833`。我们将添加
    MySQL 密码的环境变量，并在容器上暴露端口 3306。最终的 YAML 将类似于图 7.12。
- en: '![](../../OEBPS/Images/07-12.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/07-12.png)'
- en: Figure 7.12 A Deployment that uses the PVC named `claim-03833` mounted in the
    container at `/var/lib/mysql`
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.12 使用挂载在容器 `/var/lib/mysql` 中的 PVC 命名为 `claim-03833` 的 Deployment
- en: 'Let’s save the file and exit Vim. If you didn’t quite catch all of those changes
    and additions, you can download the file with the command `curl -O https://raw.githubusercontent.com/chadmcrowell/acing-the-cka-exam/main/ch_07/backend.yaml`.
    We can create the Deployment with the command `k apply -f backend.yaml`. Almost
    immediately, we’ll see that our PVC is bound, and there’s a new PV that was automatically
    provisioned. To list both the PVC and PV, run the command `k get pvc,pv`. The
    output of that command will look similar to this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们保存文件并退出 Vim。如果你没有完全捕捉到所有的更改和添加，你可以使用命令 `curl -O https://raw.githubusercontent.com/chadmcrowell/acing-the-cka-exam/main/ch_07/backend.yaml`
    下载文件。我们可以使用命令 `k apply -f backend.yaml` 创建 Deployment。几乎立即，我们会看到我们的 PVC 已经绑定，并且有一个新自动配置的
    PV。要列出 PVC 和 PV，运行命令 `k get pvc,pv`。该命令的输出将类似于以下内容：
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You have created a PVC that utilizes the standard storage class, created a Deployment
    that mounted the volume to a Pod, and completed the exam task.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经创建了一个使用标准存储类的 PVC，创建了一个将卷挂载到 Pod 的 Deployment，并完成了考试任务。
- en: 7.3.1 Inheriting from the storage class
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.1 从存储类继承
- en: 'As you may have noticed, the PV inherited certain properties of the storage
    class. One was the reclaim policy, which was set to delete. Others were the volume
    type (`hostPath` in our case) and volume binding mode. We can look at the YAML
    from a storage class with the command `k get sc standard -o yaml`. The output
    should look as follows (the annotations are shortened to make it easier to read):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如你可能已经注意到的，PV 继承了存储类的某些属性。其中一个是回收策略，设置为删除。其他的是卷类型（在我们的例子中是 `hostPath`）和卷绑定模式。我们可以使用命令
    `k get sc standard -o yaml` 查看存储类的 YAML。输出应该如下（注释已缩短以方便阅读）：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: These settings are applied automatically to each PV that is automatically provisioned
    with the storage class.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设置会自动应用于使用存储类自动配置的每个 PV。
- en: Exam exercises
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 考试练习
- en: Create a storage class named `node-local` that uses the provisioner `kubernetes
    .io/no-provisioner`. The volume binding mode should be `WaitForFirstConsumer`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `node-local` 的存储类，使用提供者 `kubernetes.io/no-provisioner`。卷绑定模式应该是 `WaitForFirstConsumer`。
- en: Create a PVC named `claim-sc` that will claim 39 MB of volume from the previously
    created class. The access mode should be `ReadWriteOnce`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `claim-sc` 的 PVC，将从之前创建的类中申请 39 MB 的卷。访问模式应该是 `ReadWriteOnce`。
- en: Create a Pod named `pod-sc` with the image `nginx` that will use the PVC from
    the previous step, and mount the volume inside the container at `/usr/nginx/www/html`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `pod-sc` 的 Pod，使用镜像 `nginx`，将使用之前步骤中的 PVC，并在容器内部挂载卷到 `/usr/nginx/www/html`。
- en: 7.4 Nonpersistent volumes
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.4 非持久化卷
- en: To fully realize the benefits of PVs, you must gain some exposure working with
    volumes that do not persist—by this, I mean the `emptyDir` volume type. This volume
    type uses storage from the container itself. This will most likely turn up on
    the exam, so let’s go through another exam scenario.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要充分实现 PV 的好处，你必须通过处理不持久化的卷来获得一些经验——这里我指的是 `emptyDir` 卷类型。这种卷类型使用容器本身的存储。这很可能会在考试中出现，所以让我们通过另一个考试场景来了解一下。
- en: '| Exam Task In cluster `ek8s`, create a Pod named `log-collector` that uses
    a volume with type `emptyDir` named `logvol`. Mount the volume in the container
    at `/var/log`. The name of the YAML file should be `log-collector.yaml`. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 考试任务 在集群 `ek8s` 中创建一个名为 `log-collector` 的 Pod，该 Pod 使用类型为 `emptyDir` 的卷 `logvol`。在容器中将卷挂载到
    `/var/log`。YAML 文件的名称应该是 `log-collector.yaml`。 |'
- en: 'We can continue to use the same cluster that we’ve been using since the beginning
    of the chapter. Go ahead and create the Pod YAML file with the command `k run
    log-collector --image busybox --command sleep --command "3600" --dry-run=client
    -o yaml > log-collector.yaml`. Open the file `log-collector.yaml` with the command
    `vim log-collector.yaml`. Just below the `restartPolicy`, we’ll insert `volumes:`.
    Just below that, on the next line, we’ll insert `- name: logvol`, and on the next
    line, inline with `name`, we’ll add `emptyDir: {}` (figure 7.13).'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以继续使用从本章开始就一直在使用的同一个集群。使用命令 `k run log-collector --image busybox --command
    sleep --command "3600" --dry-run=client -o yaml > log-collector.yaml` 创建 Pod YAML
    文件。使用命令 `vim log-collector.yaml` 打开文件 `log-collector.yaml`。在 `restartPolicy` 下方，我们将插入
    `volumes:`。在下面一行，我们将插入 `- name: logvol`，并在下一行，与 `name` 平行，我们添加 `emptyDir: {}`（图
    7.13）。'
- en: '![](../../OEBPS/Images/07-13.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/07-13.png)'
- en: Figure 7.13 The end of a Pod YAML spec, where the volume is set to a type `emptyDir`
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.13 Pod YAML 规范的结尾，其中卷设置为类型 `emptyDir`
- en: 'Much like we did with our Deployment YAML in section 7.1, we’ll add the `volumeMounts`
    to the container as well, which must be the same name as the volume that we added
    in figure 7.13\. Just below `resources` in the Pod YAML, insert `volumeMounts:`
    followed by `- mountPath: /var/log` just below. Finally, inline with `mountPath`,
    type `name: logvol`. The result should be similar to the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '就像我们在 7.1 节中使用的 Deployment YAML 一样，我们还会将 `volumeMounts` 添加到容器中，其名称必须与我们在图 7.13
    中添加的卷名称相同。在 Pod YAML 中 `resources` 下方插入 `volumeMounts:`，然后在其下方添加 `- mountPath:
    /var/log`。最后，与 `mountPath` 平行，输入 `name: logvol`。结果应该类似于以下内容：'
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As you see, it is very similar to how we mounted the volume to the Deployment
    in section 7.1, except we changed the volume type, the names, and the mount path.
    Let’s create the Pod with the command `k create -f log-collector.yaml`. The output
    of the command `k get po` should look like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这与我们在 7.1 节中挂载卷到 Deployment 的方式非常相似，除了我们更改了卷类型、名称和挂载路径。让我们使用命令 `k create
    -f log-collector.yaml` 创建 Pod。命令 `k get po` 的输出应该看起来像这样：
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Also, if you run the command `k describe po log-collector`, you should see
    in the `Volumes:` section that the volume is in fact mounted as type `EmptyDir`.
    Here’s an abbreviation of the output, which you should see as well:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你运行命令 `k describe po log-collector`，你应该在 `Volumes:` 部分看到卷实际上是以 `EmptyDir`
    类型挂载的。以下是输出结果的缩写，你应该也能看到：
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You have successfully created a Pod that mounts a volume of type `EmptyDir`
    and completed the task. When using this volume, you should understand that the
    data will not persist beyond the life of the Pod. If the Pod is killed, then the
    data will be deleted as well.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你已成功创建了一个挂载类型为 `EmptyDir` 的卷的 Pod，并完成了任务。在使用此卷时，你应该了解数据不会在 Pod 生命周期结束后持续存在。如果
    Pod 被终止，则数据也会被删除。
- en: Exam exercises
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 检验练习
- en: Create a Pod named `two-web` with two containers. The first container will be
    named `httpd` and will use the image `httpd:alpine3.17`. The second container
    will be named `nginx` and will use the image `nginx:1.23.3-alpine`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `two-web` 的 Pod，包含两个容器。第一个容器将命名为 `httpd`，并使用镜像 `httpd:alpine3.17`。第二个容器将命名为
    `nginx`，并使用镜像 `nginx:1.23.3-alpine`。
- en: Both containers should access the same volume that is shared from local storage
    on the container itself.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 两个容器都应该访问从容器本身本地存储共享的相同卷。
- en: '`Container1` will mount the volume to `/var/www/html/` and `Container2` will
    mount the volume to `/usr/share/nginx/html/`.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`Container1` 将卷挂载到 `/var/www/html/`，而 `Container2` 将卷挂载到 `/usr/share/nginx/html/`。'
- en: Start up the Pod and ensure everything is mounted and shared correctly.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 启动 Pod 并确保一切挂载和共享都正确。
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: To have data persist beyond the life of a Pod, we use PVs. For the exam, if
    you are asked to retain data after deleting a Pod, make sure to create a PV.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使数据在 Pod 生命周期结束后仍然持续存在，我们使用 PV。对于考试，如果你被要求在删除 Pod 后保留数据，请确保创建一个 PV。
- en: A volume is reserved or claimed for the Pod by a resource in Kubernetes called
    persistent volume claim, or PVC, which chooses the volume with the size nearest
    to the requested capacity. You will need to know how to mount a volume in a Deployment
    or Pod for the exam.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 中有一个名为持久卷声明（PVC）的资源，用于为 Pod 预留或声明卷，它选择与请求容量最接近的卷大小。对于考试，你需要知道如何在
    Deployment 或 Pod 中挂载卷。
- en: There are two volume modes to choose from when creating a PV—`FileSystem` and
    `Block`. If none is specified in the YAML, `FileSystem` mode is chosen. For the
    exam, look for an indication that the volume should be a directory; in this case,
    you would use the `FileSystem` volume type. If there’s mention of a raw file system,
    you would use the `Block` volume mode.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建 PV 时，可以选择两种卷模式——`FileSystem`（文件系统）和 `Block`（块）。如果在 YAML 中未指定，则默认选择 `FileSystem`
    模式。对于考试，寻找卷应该是目录的提示；在这种情况下，你会使用 `FileSystem` 卷类型。如果提到原始文件系统，你会使用 `Block` 卷模式。
- en: There are three reclaim policies available to a PV—`Retain`, `Recycle`, and
    `Delete`. The reclaim policy tells the PV what to do after it’s unmounted from
    the Pod. Watch out for words like *retain* or *delete* for exam questions like
    these.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 PV（持久卷）来说，有三种回收策略可供选择——`Retain`（保留）、`Recycle`（回收）和 `Delete`（删除）。回收策略告诉 PV
    在从 Pod 卸载后应该做什么。对于这类考试问题，要注意像 *retain* 或 *delete* 这样的词。
- en: 'There are four different access modes: `ReadWriteOnce`, `ReadOnlyMany`, `ReadWriteMany`,
    and `ReadWriteOncePod`. The access mode determines if nodes can access the PV,
    how many nodes can access the PV at a time, and whether they have read and/or
    write permission. For the exam, check to see if multiple nodes need access to
    the volume; that will be the key indicator of which access mode to use.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有四种不同的访问模式：`ReadWriteOnce`、`ReadOnlyMany`、`ReadWriteMany`和`ReadWriteOncePod`。访问模式决定了节点是否可以访问PV，一次可以有多少节点访问PV，以及它们是否有读和/或写权限。对于考试，检查是否需要多个节点访问卷；这将成为选择哪种访问模式的关键指标。
- en: A storage class is a way to dynamically provision storage in Kubernetes. You
    do not have to create a PV to use the storage class. When a question on the exam
    asks to use an existing storage class, you only have to create a PVC and choose
    which storage class to use; the volume will be created automatically.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储类是在Kubernetes中动态配置存储的一种方式。您不必创建PV即可使用存储类。当考试中的问题要求使用现有的存储类时，您只需创建一个PVC并选择要使用的存储类；卷将自动创建。
