- en: 4 Exploratory graph analysis
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 探索性图分析
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节涵盖
- en: Exploring a graph with Cypher query language
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Cypher查询语言探索图
- en: Aggregating data with Cypher query language
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Cypher查询语言聚合数据
- en: Using existential subqueries to filter by graph patterns
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用存在子查询根据图模式进行过滤
- en: Using counting subqueries to count graph patterns
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用计数子查询统计图模式
- en: Handling query cardinality when using multiple clauses in a single Cypher statement
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用单个Cypher语句中的多个子句时处理查询基数
- en: This chapter will teach you how to perform an exploratory data analysis of the
    imported Twitter social network using Cypher query language. Imagine you are working
    as a social media consultant and want to find as many insights as possible. As
    is typical with any analysis, you begin with an exploratory data analysis to get
    an overview of the data you are working with.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节将教会你如何使用Cypher查询语言对导入的Twitter社交网络进行探索性数据分析。想象你正在担任社交媒体顾问，并希望尽可能多地发现洞察。正如任何分析一样，你首先从探索性数据分析开始，以了解你正在处理的数据概览。
- en: I will present how I collected the data to give you a sense of the data you
    will be working on in this chapter. The imported Twitter social network was retrieved
    using the official Twitter API. I have fetched tweets that are part of the `NLP`
    or `Knowledge` `graph` topics. At this time, I had information about tweets and
    users who either were mentioned or published tweets. Next, I fetched additional
    metadata about users in the graph, such as their registration date and follower
    relationships. All the users in the imported Twitter subgraph have either published
    a tweet or have been mentioned by one. I did not include all the followers because
    that would explode the graph and the network would end up consisting of a couple
    of million users.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我将展示我是如何收集数据的，以便你了解在本章中你将工作的数据。导入的Twitter社交网络是通过官方Twitter API检索的。我抓取了属于`NLP`或`Knowledge`
    `graph`主题的推文。当时，我有关于被提及或发布推文的推文和用户的信息。接下来，我抓取了图中用户的其他元数据，例如他们的注册日期和关注关系。导入的Twitter子图中的所有用户都发布过推文或被提及过。我没有包括所有关注者，因为这会导致图爆炸，最终网络将包含几百万用户。
- en: One part of the exploratory graph analysis consists of counting the number of
    nodes and relationships in the network. With the Twitter network, it is also essential
    to know the timeline of the created tweets. In this chapter, you will learn how
    to aggregate time-based information with Cypher query language. As the last part
    of the exploratory analysis, you will examine some interesting nodes in the dataset,
    like users who posted the most tweets or were mentioned the most.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 探索性图分析的一部分是统计网络中节点和关系的数量。对于Twitter网络，了解创建推文的时序也非常重要。在本章中，你将学习如何使用Cypher查询语言聚合基于时间的信息。作为探索性分析的最后一部分，你将检查数据集中的一些有趣节点，例如发布最多推文或被提及最多的用户。
- en: Now that we’ve covered an overview of what you will be learning in this chapter,
    let’s start with some practical examples. To follow along with the examples in
    this chapter, you must have a Neo4j database instance with Twitter network data
    imported as described in chapter 3.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经概述了本章你将学习的内容，让我们从一些实际例子开始。要跟随本章中的例子，你必须有一个Neo4j数据库实例，并且已经按照第3章所述导入Twitter网络数据。
- en: 4.1 Exploring the Twitter network
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 探索Twitter网络
- en: The goal of the exploratory analysis is to get to know the dataset and teach
    you Cypher query syntax that will allow you to aggregate and filter data. I recommend
    you use the Neo4j Browser environment, which can be used to develop Cypher queries
    and return the query results in the form of a table as well as a graph visualization.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 探索性分析的目标是了解数据集，并教你Cypher查询语法，这将允许你聚合和过滤数据。我建议你使用Neo4j浏览器环境，它可以用来开发Cypher查询，并以表格和图形可视化的形式返回查询结果。
- en: If you open Neo4j Browser and select the database tab in the top-right corner,
    it will show a simple report indicating the number and the type of nodes and relationships
    in the database, as shown in figure 4.1.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开Neo4j浏览器并选择右上角的数据库标签，它将显示一个简单的报告，指示数据库中节点和关系的数量和类型，如图4.1所示。
- en: '![04-01](../../OEBPS/Images/04-01.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![04-01](../../OEBPS/Images/04-01.png)'
- en: Figure 4.1 Neo4j Browser database report
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 Neo4j浏览器数据库报告
- en: After the upload of Twitter data, as shown in chapter 3, there should be a total
    of 15,654 nodes in the database. As you already know, nodes are labeled either
    `Tweet` or `User`. In addition, there are also 58,369 connections across four
    relationship types. Both the node labels and the relationship types in the left-side
    toolbar are clickable. For example, if you click the `FOLLOWS` relationship type,
    the tool will generate a Cypher statement that returns a sample of 25 `FOLLOWS`
    relationships.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 3 章中展示的 Twitter 数据上传之后，数据库中应该总共有 15,654 个节点。正如你所知，节点被标记为 `Tweet` 或 `User`。此外，还有
    58,369 个连接分布在四种关系类型中。左侧工具栏中的节点标签和关系类型都是可点击的。例如，如果你点击 `FOLLOWS` 关系类型，工具将生成一个返回
    25 个 `FOLLOWS` 关系样本的 Cypher 语句。
- en: Listing 4.1 Generated Cypher query that visualizes a sample of 25 `FOLLOWS`
    relationships
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.1 生成的用于可视化 25 个 `FOLLOWS` 关系的 Cypher 查询
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The generated statement in listing 4.1 returns the results as the *path* data
    object. A sequence of connected nodes and relationships can be represented as
    a path data type. Cypher query syntax allows paths to be referenced by a variable
    name in a manner similar to node and relationship variables.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.1 中生成的语句返回结果作为 *路径* 数据对象。一系列连接的节点和关系可以用路径数据类型表示。Cypher 查询语法允许通过变量名引用路径，类似于节点和关系变量。
- en: You should get a visualization similar to that shown in figure 4.2 by executing
    the generated Cypher statement.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行生成的 Cypher 语句，你应该得到与图 4.2 中所示类似的可视化。
- en: '![04-02](../../OEBPS/Images/04-02.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![04-02](../../OEBPS/Images/04-02.png)'
- en: Figure 4.2 A subgraph of the followers network
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 关注者网络的一个子图
- en: Exercise 4.1
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 4.1
- en: As an exercise, generate a Cypher statement to visualize sample `RETWEETS` relationships.
    You can click on the relationship types in the left-side toolbar, or you can use
    the statement in listing 4.1 as the template and change the relationship type
    accordingly.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，生成一个 Cypher 语句来可视化样本 `RETWEETS` 关系。你可以在左侧工具栏中点击关系类型，或者可以使用列表 4.1 中的语句作为模板并相应地更改关系类型。
- en: 4.2 Aggregating data with Cypher query language
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 使用 Cypher 查询语言聚合数据
- en: Aggregating and counting data points is the basis of all data analysis. In the
    context of graph analysis, you will first learn how to count various graph patterns
    like the number of nodes and relationships. If you already have some experience
    with relational databases and SQL query language, you will see that Cypher follows
    a similar syntax for aggregating data. The first aggregation function you will
    learn is the `count()` function, which is used to count the number of rows or
    values produced by the `MATCH` clause.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合和计数数据点是所有数据分析的基础。在图分析中，你将首先学习如何计数各种图模式，如节点和关系的数量。如果你已经对关系数据库和 SQL 查询语言有一些经验，你会发现
    Cypher 在聚合数据时遵循类似的语法。你将学习的第一个聚合函数是 `count()` 函数，它用于计数 `MATCH` 子句生成的行或值。
- en: To count the number of the nodes in the database, you can execute the following
    Cypher statement.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算数据库中节点的数量，你可以执行以下 Cypher 语句。
- en: Listing 4.2 Counting the number of nodes
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.2 计算节点数量
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Matches all the nodes in the database
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 匹配数据库中的所有节点
- en: ❷ Returns the total count of nodes
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 返回节点的总数
- en: 'There is a total of 15,654 nodes in the graph. The `count()` function appears
    in two variants:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图中总共有 15,654 个节点。`count()` 函数有两种变体：
- en: '`count(*)`—Returns the number of rows produced by the Cypher statement'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count(*)`—返回由 Cypher 语句生成的行数'
- en: '`count(variable` `or` `expression)`—Returns the number of non-null values produced
    by an expression'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count(variable or expression)`—返回由表达式生成的非空值的数量'
- en: To test both variants of the `count()` function, you will count the number of
    `User` nodes and the non-null values of their `registeredAt` properties.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试 `count()` 函数的两个变体，你需要计算用户节点的数量以及它们 `registeredAt` 属性的非空值。
- en: Listing 4.3 Counting the number of `User` nodes and their non-null values of
    `registeredAt` properties
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.3 计算用户节点数量及其 `registeredAt` 属性的非空值
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Table 4.1 shows the results of listing 4.3.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.1 显示了列表 4.3 的结果。
- en: Table 4.1 Results of the Cypher statement in listing 4.3
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.1 列表 4.3 中 Cypher 语句的结果
- en: '| `numberOfRows` | `numberOfUsersWithRegisteredAtDate` |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `numberOfRows` | `numberOfUsersWithRegisteredAtDate` |'
- en: '| 3,594 | 3,518 |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 3,594 | 3,518 |'
- en: There are 3,594 `User` nodes in the graph, but only 3,518 of them have the non-null
    `registeredAt` property. The graph is missing the registration date information
    for 76 users. When preparing a dataset summary, you usually present the number
    of missing values as a ratio rather than an absolute number. In Neo4j, you must
    be careful because when you divide an integer by an integer, the result will also
    be an integer. To avoid this issue, you can cast either of the variables to the
    float data type.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图中有3,594个`User`节点，但其中只有3,518个具有非空的`registeredAt`属性。图中缺少76个用户的注册日期信息。在准备数据集摘要时，你通常将缺失值的数量以比率而不是绝对数的形式呈现。在Neo4j中，你必须小心，因为当你用整数除以整数时，结果也将是整数。为了避免这个问题，你可以将其中一个变量转换为浮点数据类型。
- en: Execute the following Cypher statement to evaluate the ratio of non-null values
    for the `registeredAt` node property of `User` nodes.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下Cypher语句以评估`User`节点`registeredAt`属性非空值的比率。
- en: Listing 4.4 Calculating the ratio of non-null values of `registeredAt` node
    property
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.4 计算`registeredAt`节点属性非空值的比率
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Matches all the users in the database
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 匹配数据库中的所有用户
- en: ❷ Counts the number of all users and the number of non-null registeredAt properties
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 计算所有用户数量以及非空`registeredAt`属性的数量
- en: ❸ Casts either of the variables to float to avoid dividing two integers
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将其中一个变量转换为浮点型以避免除以两个整数
- en: You’ll see that 97.88% of users have a non-null value of the `registeredAt`
    property. If you forgot to cast either the `usersWithRegisteredAtDate` or `numberOfRows`
    in listing 4.4 to float, the result would be 0.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到97.88%的用户具有非空的`registeredAt`属性值。如果你在列表4.4中忘记将`usersWithRegisteredAtDate`或`numberOfRows`转换为浮点型，结果将是0。
- en: Note In Neo4j, when you divide an integer value by another integer value, the
    result will also be the integer data type. If you want the result to be of the
    float type, such as with the ratio example in listing 4.4, you need to cast either
    of the variables to float using the `toFloat()` function.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在Neo4j中，当你将一个整数值除以另一个整数值时，结果也将是整型数据。如果你想结果为浮点型，例如在列表4.4中的比率示例，你需要使用`toFloat()`函数将其中一个变量转换为浮点型。
- en: Exercise 4.2
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 练习4.2
- en: Calculate the ratio of missing values for the `createdAt` node property of the
    `Tweet` nodes. The result of the statement should be a percentage of non-null
    values divided by the count of tweets.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 计算缺失值的比率，即`Tweet`节点`createdAt`节点属性的百分比，结果应该是非空值的比率除以推文的计数。
- en: The correct answer to exercise 4.2 is that there are no missing values for the
    `createdAt` property of `Tweet` nodes.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 练习4.2的正确答案是`Tweet`节点的`createdAt`属性没有缺失值。
- en: As you might be used to from your other data projects, you want to aggregate
    or count values grouped by specific values more often than not. For those familiar
    with SQL aggregations, you can define the grouping keys in the `GROUP` `BY` statement.
    *Grouping keys* are non-aggregate expressions used to group the values going into
    aggregate functions. Aggregation in Cypher is different from aggregation in SQL.
    In Cypher, you don’t need to specify a grouping key explicitly. As soon as any
    aggregation function is used in the Cypher statement, all non-aggregated columns
    in the `WITH` or `RETURN` clause become grouping keys. With Cypher query language,
    the grouping keys are implicitly defined, as you don’t need to explicitly add
    a `GROUP` `BY` statement after the aggregation functions.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你可能从其他数据项目中习惯的那样，你通常更频繁地按特定值聚合或计数值。对于熟悉SQL聚合的人来说，你可以在`GROUP BY`语句中定义分组键。*分组键*是用于将值分组到聚合函数中的非聚合表达式。Cypher中的聚合与SQL中的聚合不同。在Cypher中，你不需要显式指定分组键。一旦在Cypher语句中使用任何聚合函数，`WITH`或`RETURN`子句中的所有非聚合列都成为分组键。使用Cypher查询语言时，分组键是隐式定义的，因为你不需要在聚合函数之后显式添加`GROUP
    BY`语句。
- en: Suppose you want to count the number of nodes grouped by their node label. The
    function to extract the node labels is `labels()`. You only need to provide the
    `labels()` function as the grouping key alongside an aggregation function that
    will count the number of nodes.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要按节点标签分组计算节点数量。提取节点标签的函数是`labels()`。你只需要提供`labels()`函数作为分组键，并配合一个将计算节点数量的聚合函数。
- en: Listing 4.5 Counting the number of nodes by labels
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.5 按标签计数节点
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Table 4.2 shows the number of nodes for each label.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.2显示了每个标签的节点数量。
- en: Table 4.2 Counting nodes grouped by their label
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.2 按标签计数节点
- en: '| `labels` | `count` |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `labels` | `count` |'
- en: '| ["User"] | 3594 |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| ["用户"] | 3594 |'
- en: '| ["Tweet"] | 12060 |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| ["推文"] | 12060 |'
- en: At the moment, there are only two types of nodes in the graph. You can observe
    that the Cypher statement in listing 4.5 returns the node labels as a list. The
    list data type indicates that you can have multiple labels on a single node. Assigning
    a secondary node label is helpful in a network analysis when you want to speed
    up subsequent queries by tagging relevant subsections of nodes. As previously
    mentioned, you might notice the lack of a `GROUP` `BY` statement. In Cypher, you
    don’t need to explicitly specify a grouping key. As soon as an aggregation function
    is used, all non-aggregated result columns become grouping keys.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，图中只有两种类型的节点。你可以观察到列表4.5中的Cypher语句返回了节点标签列表。列表数据类型表示你可以在单个节点上拥有多个标签。在网络分析中，当你想要通过标记相关节点子集来加速后续查询时，分配二级节点标签是有帮助的。如前所述，你可能注意到缺少`GROUP
    BY`语句。在Cypher中，你不需要显式指定分组键。一旦使用聚合函数，所有非聚合结果列都成为分组键。
- en: Note With Cypher query language, the grouping keys are defined implicitly, meaning
    all non-aggregated columns in a `WITH` or `RETURN` clause automatically become
    grouping keys.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：使用Cypher查询语言，分组键是隐式定义的，这意味着在`WITH`或`RETURN`子句中的所有非聚合列自动成为分组键。
- en: Exercise 4.3
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 练习4.3
- en: Count the number of relationships by their type. To count the number of relationships
    grouped by their type, you start by describing a relationship pattern with Cypher
    syntax. Note that you cannot describe a relationship without its adjacent nodes.
    Because you are interested in counting all the relationship types, you must not
    specify any node labels or relationship types in the Cypher pattern. In the last
    part of the statement, you use the `type()` function to extract the relationship
    type and use it as a grouping key in combination with the `count()` aggregation
    function.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 按关系类型计数关系数量。要按类型分组计数关系数量，你首先需要使用Cypher语法描述一个关系模式。请注意，没有相邻节点的描述，你不能描述一个关系。因为你对计数所有关系类型感兴趣，所以在Cypher模式中你不能指定任何节点标签或关系类型。在语句的最后部分，你使用`type()`函数提取关系类型，并将其与`count()`聚合函数结合作为分组键。
- en: The solution to exercise 4.3 produces the output shown in table 4.3\.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 练习4.3的解决方案生成了表4.3所示的输出。
- en: Table 4.3 Count of relationships grouped by their type
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.3按类型分组的关系的计数
- en: '| `relationshipType` | `count` |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `relationshipType` | `count` |'
- en: '| `PUBLISH` | 12,060 |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `PUBLISH` | 12,060 |'
- en: '| `FOLLOWS` | 24,888 |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `FOLLOWS` | 24,888 |'
- en: '| `RETWEETS` | 8,619 |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `RETWEETS` | 8,619 |'
- en: '| `MENTIONS` | 12,379 |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `MENTIONS` | 12,379 |'
- en: '| `IN_REPLY_TO` | 423 |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `IN_REPLY_TO` | 423 |'
- en: The number of `PUBLISH` relationships is identical to the number of `Tweet`
    nodes. With the Twitter social network, a single `TWEET` has precisely one author,
    indicated by the `PUBLISH` relationship.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`PUBLISH`关系的数量与`Tweet`节点数量相同。在Twitter社交网络中，一个`TWEET`恰好有一个作者，由`PUBLISH`关系表示。'
- en: Interestingly, 8,619 out of 12,060 tweets are retweets, and 423 tweets are replies.
    Only around 30% of the tweets are original content. This is not so unusual; for
    example, the research by Joshua Hawthorne et al. (2013) shows that while normal
    users don’t have a high count of retweets per tweet, more prominent accounts rake
    in vast numbers of retweets. Additionally, when researchers examined the tweets
    by former US presidents (Minot et al., 2021), the number of retweets was at least
    an order of magnitude higher than usual. Consequently, there is a larger number
    of retweets than original tweets on the platform due to the significant amount
    of retweets of tweets by prominent accounts.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，在12,060条推文中，有8,619条是转发，423条是回复。只有大约30%的推文是原创内容。这并不罕见；例如，Joshua Hawthorne等人（2013年）的研究表明，尽管普通用户每条推文的转发数量不高，但更受欢迎的账户获得了大量的转发。此外，当研究人员检查前美国总统的推文时（Minot等人，2021年），转发的数量至少比通常高一个数量级。因此，由于重要账户的推文转发量很大，平台上转发的数量比原创推文多。
- en: What’s a bit surprising is that there are more mentions than tweets. I did not
    manually parse the mentioned information, as that was automatically provided by
    the official Twitter API. I’ve also noticed that when a user retweets another
    user, they are automatically mentioned in the retweet.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有一点令人惊讶的是，提及的数量比推文多。我没有手动解析提及的信息，因为这些信息是由官方Twitter API自动提供的。我还注意到，当用户转发其他用户的推文时，他们会被自动提及。
- en: Exercise 4.4
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 练习4.4
- en: Inspect the text of a retweet and compare it to the original tweet’s text. Use
    the `LIMIT` clause to limit the number of results to 1.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 检查转发的文本并与原始推文的文本进行比较。使用 `LIMIT` 子句将结果数量限制为 1。
- en: The solution to exercise 4.4 produces the output shown in table 4.4.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 4.4 的解决方案生成了表 4.4 中所示的输出。
- en: Table 4.4 A single comparison of tweet and retweet’s text
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.4 推文和转发文本的单个比较
- en: '| `retweetText` | `originalText` |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `retweetText` | `originalText` |'
- en: '| RT @Eli_Krumova: 5 Best Practices: Writing Clean & Professional #SQL #Code
    https://t.co/Y4DepLfOOn v/ @SourabhSKatoch #DataScience #AI #ML... | 5 Best Practices:
    Writing Clean & Professional #SQL #Code https://t.co/Y4DepLfOOn v/ @SourabhSKatoch
    #DataScience #AI #ML #MachineLearning #IoT #IIoT #IoTPL #Python #RStats #Cloud
    #CyberSecurity #Serverless #RPA #NLP #programming #coding #100DaysOfCode #DEVCommunity
    #CodeNewbie https://t.co/ma03V8btZBhttps://t.co/TOnwwHgaHQ |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| RT @Eli_Krumova: 5 Best Practices: Writing Clean & Professional #SQL #Code
    https://t.co/Y4DepLfOOn v/ @SourabhSKatoch #DataScience #AI #ML... | 5 Best Practices:
    Writing Clean & Professional #SQL #Code https://t.co/Y4DepLfOOn v/ @SourabhSKatoch
    #DataScience #AI #ML #MachineLearning #IoT #IIoT #IoTPL #Python #RStats #Cloud
    #CyberSecurity #Serverless #RPA #NLP #programming #coding #100DaysOfCode #DEVCommunity
    #CodeNewbie https://t.co/ma03V8btZBhttps://t.co/TOnwwHgaHQ |'
- en: One immediately obvious thing is that the retweet’s text is trimmed to a fixed
    length and does not always contain the original tweet’s complete text. Another
    more subtle difference is that the retweet’s text is prepended with RT followed
    by the original author’s handle. It seems that Twitter automatically prepends
    the original user’s handle in the retweet and treats it as a mention—I had no
    idea this was the case. It is a good practice to always begin with exploratory
    graph analysis before diving into graph algorithms to spot such abnormalities.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一个立即明显的事情是，转发文本被截断到固定长度，并且并不总是包含原始推文的完整文本。另一个更微妙的不同之处在于，转发文本以 RT 开头，后面跟着原始作者的昵称。看起来
    Twitter 自动在转发中添加原始用户的昵称，并将其视为提及——我之前并不知道这种情况。在深入研究图算法之前，始终进行探索性图分析是一个好的实践，以发现此类异常。
- en: Exercise 4.5
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 4.5
- en: 'For those of you who are more visually oriented, try to visualize a single
    graph pattern in which a user retweeted a post from another user. Include the
    `MENTION` relationships of both the original and the retweeted post. Follow these
    hints to help you construct the desired Cypher statement:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些更倾向于视觉的人来说，尝试可视化一个图模式，其中用户从另一个用户那里转发了帖子。包括原始和被转发推文的 `MENTION` 关系。遵循以下提示来帮助你构建所需的
    Cypher 语句：
- en: Match a graph pattern that describes a retweet, an original tweet, and their
    authors.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匹配一个描述转发、原始推文及其作者的图模式。
- en: Use the `WITH` clause in combination with the `LIMIT` clause to limit results
    to a single described pattern.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `WITH` 子句与 `LIMIT` 子句结合，将结果限制为单个描述的模式。
- en: Separately match the `MENTION` relationships of the original and retweeted post.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分别匹配原始和被转发推文的 `MENTION` 关系。
- en: Visualizing networks in Neo4j Browser is easiest by returning one or multiple
    path objects.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Neo4j 浏览器中可视化网络最简单的方法是返回一个或多个路径对象。
- en: This exercise is a bit more advanced, so take it step by step to construct the
    final Cypher statement. You can examine the results after each step to make sure
    you have correctly described the desired graph pattern. The solution to exercise
    4.5 produces the network visualization in Neo4j Browser shown in figure 4.3.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习稍微复杂一些，所以请一步一步地构建最终的 Cypher 语句。你可以在每一步之后检查结果，以确保你正确地描述了所需的图模式。练习 4.5 的解决方案在
    Neo4j 浏览器中产生了图 4.3 所示的网络可视化。
- en: '![04-03](../../OEBPS/Images/04-03.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![04-03](../../OEBPS/Images/04-03.png)'
- en: Figure 4.3 By default, a retweet also mentions the original tweet author.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 默认情况下，转发也会提及原始推文作者。
- en: 4.2.1 Time aggregations
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.1 时间聚合
- en: As with any dataset, it is essential to learn the timeline of the data points.
    Both the `User` and the `Tweet` nodes contain the datetime property. First, you
    will evaluate the time windows of the tweets. You can use the `min()` and `max()`
    functions on the datetime property to get the earliest and the last date values.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何数据集一样，了解数据点的时序至关重要。`User` 和 `Tweet` 节点都包含 datetime 属性。首先，你将评估推文的时间窗口。你可以使用
    `min()` 和 `max()` 函数对 datetime 属性进行操作，以获取最早和最后日期值。
- en: Listing 4.6 Retrieving the earliest and last created date values of tweets
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.6 获取推文的最早和最后创建日期值
- en: '[PRE5]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first tweet in the dataset was on August 12, 2016, and the last was on June
    1, 2021\. There is a five-year span between the first and the last tweet. While
    this information is nice, it is not very descriptive. To get a better feeling
    for the time window, you will calculate the distribution of tweets by year.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集中的第一条推文是在2016年8月12日，最后一条是在2021年6月1日。第一条和最后一条推文之间有五年的时间跨度。虽然这个信息不错，但并不非常具有描述性。为了更好地感受时间窗口，你将计算按年份分布的推文分布。
- en: In Cypher, a datetime property behaves like an object. You can access datetime
    attributes, such as the year and the month, by using the following Cypher syntax.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在Cypher中，日期时间属性的行为像一个对象。你可以使用以下Cypher语法来访问日期时间属性，如年份和月份。
- en: Listing 4.7 Extracting datetime attributes
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.7提取日期时间属性
- en: '[PRE6]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Table 4.5 shows the datetime attributes of this sample tweet.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.5显示了此样本推文的日期时间属性。
- en: Table 4.5 Datetime attributes of a sample tweet
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.5样本推文的日期时间属性
- en: '| `year` | `month` | `day` | `epochSeconds` |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `year` | `month` | `day` | `epochSeconds` |'
- en: '| 2021 | 6 | 1 | 1622537602 |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 2021 | 6 | 1 | 1622537602 |'
- en: You can then use the datetime attributes in combination with aggregation functions.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用日期时间属性与聚合函数结合使用。
- en: Exercise 4.6
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 练习4.6
- en: Calculate the distribution of tweets grouped by year created. Remember, Cypher
    uses implicit grouping key aggregations, so all you need to add to the `RETURN`
    statement is the `year` column and the `count` operator.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 计算按创建年份分组的推文分布。记住，Cypher使用隐式分组键聚合，所以你只需要在`RETURN`语句中添加`year`列和`count`运算符。
- en: The solution to exercise 4.6 produces the output in table 4.6.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 练习4.6的解决方案在表4.6中产生输出。
- en: Table 4.6 Distribution of tweets by their creation date
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.6按创建日期分布的推文
- en: '| `year` | `count` |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `year` | `count` |'
- en: '| 2021 | 12029 |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 2021 | 12029 |'
- en: '| 2020 | 19 |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 2020 | 19 |'
- en: '| 2019 | 6 |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 2019 | 6 |'
- en: '| 2018 | 3 |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 2018 | 3 |'
- en: '| 2016 | 3 |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 2016 | 3 |'
- en: Even though the time window between the first and the last tweet is five years,
    almost all the tweets were created in 2021\. Let’s drill it down even more.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 即使第一条推文和最后一条推文之间的时间窗口是五年，几乎所有推文都是在2021年创建的。让我们进一步深入分析。
- en: Exercise 4.7
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 练习4.7
- en: Use the `MATCH` clause in combination with the `WHERE` clause to select all
    the tweets that were created in 2021\. You can filter datetime attributes like
    you would other node properties. In the next step, calculate the distribution
    of tweets by their creation month. Use both the creation year and month as grouping
    keys.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 结合使用`MATCH`子句和`WHERE`子句来选择所有在2021年创建的推文。你可以像过滤其他节点属性一样过滤日期时间属性。在下一步中，计算推文按创建月份的分布。使用创建年份和月份作为分组键。
- en: By now, you are probably already in the habit of adding grouping keys as non-aggregate
    values in the `RETURN` or `WITH` clause. Additionally, you just need to be careful
    to use the `WHERE` clause to match only tweets that were created in 2021.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你可能已经养成了在`RETURN`或`WITH`子句中添加分组键作为非聚合值的习惯。此外，你只需要小心使用`WHERE`子句来匹配仅在2021年创建的推文。
- en: The solution to exercise 4.7 produces the output in table 4.7.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 练习4.7的解决方案在表4.7中产生输出。
- en: Table 4.7 Distribution of tweets by their creation date
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.7按创建日期分布的推文
- en: '| `year` | `month` | `count` |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `year` | `month` | `count` |'
- en: '| 2021 | 6 | 2695 |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 2021 | 6 | 2695 |'
- en: '| 2021 | 5 | 8507 |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 2021 | 5 | 8507 |'
- en: '| 2021 | 4 | 376 |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 2021 | 4 | 376 |'
- en: '| 2021 | 3 | 432 |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 2021 | 3 | 432 |'
- en: '| 2021 | 2 | 8 |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 2021 | 2 | 8 |'
- en: '| 2021 | 1 | 11 |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 2021 | 1 | 11 |'
- en: Around 93% (11,202 of 12,060) of the tweets were created in May and June of
    2021.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 大约93%（12,060条中的11,202条）的推文是在2021年5月和6月创建的。
- en: Exercise 4.8
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 练习4.8
- en: 'Before you move on to the rest of the chapter, I want to present you with a
    challenge. Can you prepare a Cypher statement that will return the top four days
    with the highest count of created tweets? Although you haven’t seen this exact
    example, you already have some experience with all the clauses required to construct
    this Cypher statement. Here are some hints that should help you:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在你继续本章的其余部分之前，我想向你提出一个挑战。你能准备一个Cypher语句，返回创建推文数量最高的前四天吗？虽然你没有看到这个具体的例子，但你已经有了一些使用构建此Cypher语句所需的所有子句的经验。以下是一些应该有帮助的提示：
- en: Start by matching all tweets.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先匹配所有推文。
- en: Use the creation year, month, and day as the grouping keys along with the `count()`
    aggregation.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用创建年份、月份和日期作为分组键，以及`count()`聚合。
- en: Use the `ORDER` `BY` clause to order the results based on the count descending.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ORDER BY`子句按计数降序排序结果。
- en: Use the `LIMIT` clause to return only the top four days.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`LIMIT`子句仅返回前四天。
- en: Exercise 4.8 is designed to test you on the implicit grouping aggregations in
    Cypher and use some of the previously discussed clauses together. Please take
    a couple of minutes to try to solve it on your own. I would recommend you return
    the results after each step of the query to determine whether you are on the right
    track.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 练习4.8旨在测试你对Cypher中的隐式分组聚合的理解，并使用之前讨论的一些子句。请花几分钟时间尝试自己解决它。我建议你在查询的每一步之后返回结果，以确定你是否走上了正确的道路。
- en: The solution to exercise 4.8 produces the output in table 4.8.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 练习4.8的解决方案在表4.8中产生输出。
- en: Table 4.8 Distribution of tweets by their creation date
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.8 按创建日期分布的推文
- en: '| `year` | `month` | `day` | `count` |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `year` | `month` | `day` | `count` |'
- en: '| 2021 | 5 | 31 | 6185 |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 2021 | 5 | 31 | 6185 |'
- en: '| 2021 | 6 | 1 | 2695 |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 2021 | 6 | 1 | 2695 |'
- en: '| 2021 | 5 | 30 | 1847 |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 2021 | 5 | 30 | 1847 |'
- en: '| 2021 | 5 | 28 | 62 |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 2021 | 5 | 28 | 62 |'
- en: Interestingly, you started with a five-year time window and were able to narrow
    it down to only four days by gradually digging deeper. Most of the tweets in the
    dataset were created between May 30 and June 1\. This information will help you
    evaluate the number of tweets and mentions given this timeframe.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，你从一个五年的时间窗口开始，通过逐步深入挖掘，最终将其缩小到只有四天。数据集中大部分推文都是在5月30日和6月1日之间创建的。这些信息将帮助你评估在这个时间框架内推文和提及的数量。
- en: 4.3 Filtering graph patterns
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 过滤图模式
- en: Now, you will investigate the network of mentions more thoroughly. You already
    know there are 12,379 `MENTIONS` relationships, but now, you want to determine
    how many distinct users have been mentioned. How would you construct the Cypher
    statement to retrieve the number of distinct users that have been mentioned? As
    a beginner, my first thought would be to use the following statement.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将更深入地研究提及的网络。你已经知道有12,379个`MENTIONS`关系，但现在，你想要确定被提及的不同用户数量。你将如何构造Cypher语句来检索被提及的不同用户数量？作为一个初学者，我的第一个想法是使用以下语句。
- en: Listing 4.8 Counting the number of occurrences of a user being mentioned
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.8 计算被提及的用户出现的次数
- en: '[PRE7]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: At first glance, the statement in listing 4.8 appears valid. You matched the
    users who were mentioned and then returned the count of users. But the `count()`
    function doesn’t count the number of distinct users; it counts the number of occurrences
    where the user variable is not null. You have actually counted the number of graph
    patterns where a `User` node has an incoming `MENTIONS` relationship originating
    from a `Tweet` node, which is 12,379\. One way to count the number of distinct
    users who were mentioned is by using the `distinct` prefix. The `distinct` prefix,
    shown in the following listing, is used to count the number of unique values of
    a reference variable or expression.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 初看，列表4.8中的语句似乎是有效的。你匹配了被提及的用户，然后返回了用户的计数。但是`count()`函数并不计算不同用户的数量；它计算用户变量非空的出现次数。你实际上计算了包含`User`节点从`Tweet`节点起源的`MENTIONS`关系的图模式的数量，即12,379。计算被提及的不同用户数量的方法之一是使用`distinct`前缀。以下列表中显示的`distinct`前缀用于计算引用变量或表达式的唯一值的数量。
- en: Listing 4.9 Counting the number of distinct users who were mentioned
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.9 计算被提及的不同用户数量
- en: '[PRE8]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Table 4.9 shows the results of listing 4.9.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.9显示了列表4.9的结果。
- en: Table 4.9 The number of occurrences and count of distinct users mentioned in
    a tweet
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.9 推文中提及的不同用户出现的次数和计数
- en: '| `numberOfOccurences` | `numberOfDistinctUsers` |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `numberOfOccurences` | `numberOfDistinctUsers` |'
- en: '| 12,379 | 1,632 |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| 12,379 | 1,632 |'
- en: There is a total of 1,632 distinct users who were mentioned at least once. When
    doing any query aggregations, you must also keep in mind the query cardinality
    and what you are actually counting. *Cardinality* is the number of rows or records
    of the input stream to the operation. Cypher performs a specific operation for
    each incoming row. In listing 4.9, the `MATCH` clause produces 12,379 rows. These
    rows are then used as an input to the `count` operator. Using the `count(u)` operator,
    you count the number of non-null values the `u` reference variable. Since the
    `MATCH` clause will produce no null values for the `u` variable, the result of
    the `count(u)` operation is 12,379\.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 总共有 1,632 个不同的用户至少被提及一次。在进行任何查询聚合时，您还必须考虑到查询的基数以及您实际在计算什么。"基数" 是操作输入流中的行或记录数。Cypher
    对每行输入执行特定操作。在列表 4.9 中，`MATCH` 子句产生了 12,379 行。这些行随后被用作 `count` 操作的输入。使用 `count(u)`
    操作符，您计算 `u` 引用变量的非空值数量。由于 `MATCH` 子句将为 `u` 变量产生无空值，因此 `count(u)` 操作的结果是 12,379。
- en: 'Note The cardinality of the query will also affect its performance. You want
    to keep the cardinality as low as possible to achieve the best execution speed.
    In Neo4j, you can prefix your Cypher statement with the `PROFILE` clause to compare
    the performance of queries. To learn more about the `PROFILE` clause, see the
    documentation: http://mng.bz/84pD.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：查询的基数也会影响其性能。您希望将基数保持在尽可能低，以实现最佳执行速度。在 Neo4j 中，您可以在 Cypher 语句前加上 `PROFILE`
    子句来比较查询的性能。有关 `PROFILE` 子句的更多信息，请参阅文档：http://mng.bz/84pD。
- en: You don’t have to expand all the `MENTIONS` relationships to get a list of users
    who were mentioned in at least a single tweet. Using the *existential subqueries*
    in the `WHERE` clause, you can filter on graph patterns. An existential subquery
    can be used to determine whether a specified pattern exists at least once in the
    graph. You can think of it as an expansion or upgrade of the `WHERE` clause in
    combination with the graph patterns, where you can introduce new reference variables
    or even use other clauses, like `MATCH`, in the subquery. The subquery begins
    and ends with curly brackets `{}`. You can use any of the variables from the outer
    query to describe a graph pattern; however, any new variables you introduce in
    the subquery are not carried over to the main query.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 您无需展开所有 `MENTIONS` 关系以获取至少在一条推文中被提及的用户列表。使用 `WHERE` 子句中的 *存在性子查询*，您可以在图模式上过滤。存在性子查询可用于确定指定的模式在图中至少存在一次。您可以将其视为与图模式结合的
    `WHERE` 子句的扩展或升级，其中您可以在子查询中引入新的引用变量，甚至使用其他子句，如 `MATCH`。子查询以大括号 `{}` 开头和结尾。您可以使用外部查询中的任何变量来描述图模式；然而，在子查询中引入的任何新变量都不会传递到主查询中。
- en: Listing 4.10 Counting the number of distinct users who were mentioned in tweets
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.10 计算推文中被提及的不同用户数量
- en: '[PRE9]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The Cypher statement in listing 4.10 produces the identical count of distinct
    users to the query result in listing 4.9 and is also more performant. The syntax
    used in listing 4.10 is useful for finding nodes in the network that are part
    of at least a single described graph pattern. In this example, you don’t care
    if a user was mentioned once or hundreds of times—you just want to match the distinct
    users who were mentioned at least once.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.10 中的 Cypher 语句产生的不同用户数量与列表 4.9 中的查询结果相同，并且性能也更好。列表 4.10 中使用的语法对于在网络上找到至少属于一个描述的图模式的节点非常有用。在这个例子中，您不在乎一个用户被提及一次还是数百次——您只想匹配至少被提及一次的不同用户。
- en: Note Existential subqueries are usually more performant, since they don’t have
    to expand all relationships. For example, the Cypher statement in listing 4.9
    has to expand 12,379 `MENTIONS` relationships and then use the `distinct` operator
    to retrieve the count of distinct `User` nodes. On the other hand, the existential
    subquery specified in listing 4.10 does not expand all `MENTIONS` relationships,
    as the expression is true if a single `MENTIONS` relationship is present. If a
    `User` node has 100 `MENTIONS` relationships, the Cypher statement in listing
    4.9 will expand all 100 relationships, while the existential subquery specified
    in listing 4.10 will be satisfied by finding the first `MENTIONS` relationship
    and will, therefore, ignore the other 99.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '注意 存在性子查询通常性能更好，因为它们不需要展开所有关系。例如，列表4.9中的Cypher语句必须展开12,379个`MENTIONS`关系，然后使用`distinct`运算符来检索不同`User`节点的计数。另一方面，列表4.10中指定的存在性子查询不需要展开所有`MENTIONS`关系，因为只要存在一个`MENTIONS`关系，表达式就是真实的。如果一个`User`节点有100个`MENTIONS`关系，列表4.9中的Cypher语句将展开所有100个关系，而列表4.10中指定的存在性子查询将满足找到第一个`MENTIONS`关系，因此将忽略其他99个。 '
- en: Exercise 4.9
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 练习4.9
- en: Count the number of distinct users who have published at least one tweet.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 计算至少发布过一条推文的独立用户数量。
- en: Using the existential subqueries in combination with graph patterns is also
    very helpful when negating a graph pattern. You could match the whole pattern
    in the previous example and use `distinct` to get the correct count. However,
    when you want to negate a graph pattern, you cannot use it in the `MATCH` clause.
    Hence, negating graph patterns is a prime example of using the existential subqueries
    in the `WHERE` clause to negate a graph pattern.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在否定图模式时，将存在性子查询与图模式结合使用也非常有帮助。你可以匹配前一个例子中的整个模式，并使用`distinct`来获取正确的计数。然而，当你想要否定一个图模式时，你无法在`MATCH`子句中使用它。因此，否定图模式是使用`WHERE`子句中的存在性子查询来否定图模式的典型例子。
- en: In this example, shown in the following listing, you will count the number of
    distinct users who were mentioned but haven’t, themselves, published a single
    tweet. You must negate the outgoing `PUBLISH` relationships to filter out users
    without any tweets.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下列表中显示的示例中，你将计算被提及但自己没有发布任何推文的独立用户数量。你必须否定出度的`PUBLISH`关系来过滤出没有任何推文的用户。
- en: Listing 4.11 Counting the number of users who were mentioned but haven’t published
    a single tweet
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.11 计算被提及但尚未发布任何推文的用户数量
- en: '[PRE10]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Around half of the distinct users (809 of 1,632) mentioned in a tweet in our
    dataset haven’t published any tweets themselves. As shown in listing 4.11, you
    can easily combine multiple graph pattern predicates to filter out nodes that
    fit the described graph patterns.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的数据集中，大约一半的不同用户（1,632个中的809个）在推文中被提及，但他们自己没有发布任何推文。如列表4.11所示，你可以轻松地组合多个图模式谓词来过滤出符合描述的图模式的节点。
- en: As previously mentioned, you can also introduce new reference variables in the
    existential subquery. For example, if you wanted to count the number of users
    mentioned in a tweet and discount the mentions that are part of the retweet pattern,
    you would need to introduce a new reference variable. In the following listing,
    you will use the existential subquery to count the number of users mentioned in
    a tweet and ignore the retweet mention pattern.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，你还可以在存在性子查询中引入新的引用变量。例如，如果你想计算推文中被提及的用户数量并折扣转发模式中的提及，你需要引入一个新的引用变量。在下面的列表中，你将使用存在性子查询来计算推文中被提及的用户数量并忽略转发提及模式。
- en: Listing 4.12 Counting the number of users who were mentioned in a tweet and
    discounting the retweet mention pattern with an existential subquery
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.12 使用存在性子查询计算被提及在推文中的用户数量，并折扣转发提及模式
- en: '[PRE11]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Uses the MATCH clause to identify the pattern in which a User has been mentioned
    by a Tweet
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用MATCH子句来识别用户被推文提及的模式
- en: ❷ Uses the existential query to negate graph patterns where the MENTION relationship
    exists because of a retweet pattern
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用存在性查询来否定由于转发模式而存在的MENTION关系的图模式
- en: ❸ Uses the distinct operator to return the distinct number of users part of
    the described graph pattern
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用distinct运算符来返回描述的图模式中不同用户的数量
- en: You needed to use the existential subquery in listing 4.12 to be able to introduce
    the reference variable `original`. The reference to the `original` is needed,
    as you only want to discount the specific `MENTION` relationships that are part
    of the retweet pattern.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在列表4.12中使用存在子查询才能引入引用变量`original`。对`original`的引用是必要的，因为你只想折扣那些属于转发模式的特定`MENTION`关系。
- en: The result of the statement in listing 4.12 is 1,206\. Therefore, around 26%
    (426 of 1,632) of the users who were mentioned have an incoming `MENTION` relationship
    only because their posts were retweeted. Interestingly enough, around 33% (1,206
    of 3,594) of all users were mentioned in a tweet if you discard retweets. And
    if you completed exercise 4.9, you know that around 75% (2,764 of 3,594) of all
    users have published at least one tweet.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.12中语句的结果是1,206。因此，大约26%（1,632中的426）被提及的用户只有进入的`MENTION`关系，因为他们的帖子被转发。有趣的是，如果你不考虑转发，大约33%（3,594中的1,206）的所有用户在推文中被提及。如果你完成了4.9练习，你应该知道大约75%（3,594中的2,764）的所有用户至少发布过一条推文。
- en: Exercise 4.10
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 练习4.10
- en: Find the top five users with the most distinct tweets retweeted. To make it
    easier for you, I have prepared a template Cypher statement you need to fill in,
    shown in table 4.10.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 找出转发独特推文最多的前五个用户。为了使您更容易，我已经准备了一个需要填写的模板Cypher语句，如表4.10所示。
- en: Listing 4.13 Template query for exercise 4.10
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.13 练习4.10的模板查询
- en: '[PRE12]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Uses a combination of the WHERE clause with a graph pattern to filter tweets
    that were retweeted. A tweet that was retweeted has an incoming RETWEETS relationship.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用WHERE子句与图模式的组合来过滤被转发的推文。被转发的推文有一个进入的RETWEETS关系。
- en: ❷ Uses the ORDER BY clause to order by numberOfRetweets, descending
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用ORDER BY子句按numberOfRetweets降序排序
- en: ❸ Uses the LIMIT to return only the top five users
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用LIMIT返回仅前五个用户
- en: By solving exercise 4.10, you should get the results shown in table 4.10.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 通过解决练习4.10，你应该得到表4.10中所示的结果。
- en: Table 4.10 Users with the top five highest counts of retweeted tweets
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.10 转发次数最多的前五个用户
- en: '| `user` | `numberOfRetweets` |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `user` | `numberOfRetweets` |'
- en: '| "IainLJBrown" | 754 |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| "IainLJBrown" | 754 |'
- en: '| "SuzanneC0leman" | 314 |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| "SuzanneC0leman" | 314 |'
- en: '| "Eli_Krumova" | 31 |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| "Eli_Krumova" | 31 |'
- en: '| "Paula_Piccard" | 31 |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| "Paula_Piccard" | 31 |'
- en: '| "Analytics_699" | 26 |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| "Analytics_699" | 26 |'
- en: It seems that IainLJBrown has, by far, the most retweeted tweets. In second
    place, with 354 tweets that were retweeted, is SuzanneC0leman. You could probably
    think of these users as influencers because they publish a lot but their followers
    also retweet their posts in high volumes. After that, there is an order of magnitude
    drop to only 31 retweeted posts from Eli_Krumova and Paula_Piccard.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: IainLJBrown似乎到目前为止转发推文最多。第二位，有354条被转发的推文，是SuzanneC0leman。你可能认为这些用户是影响者，因为他们发布很多，但他们的粉丝也大量转发他们的帖子。之后，转发次数的数量级下降到只有Eli_Krumova和Paula_Piccard的31条转发推文。
- en: 4.4 Counting subqueries
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 计数子查询
- en: Next, I will show you how to conveniently count graph patterns with Cypher.
    Although you already know how to count and filter graph patterns, there is a simple
    yet performant syntax to remember when counting various graph patterns. For example,
    you could use the following Cypher statement if you wanted to get the top five
    most mentioned users.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将向您展示如何方便地使用Cypher计数图模式。尽管你已经知道如何计数和过滤图模式，但在计数各种图模式时，有一个简单但高效的语法需要记住。例如，如果你想获取提及最多的前五个用户，可以使用以下Cypher语句。
- en: Listing 4.14 Retrieving the top five most mentioned users
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.14 检索提及最多的前五个用户
- en: '[PRE13]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There is nothing wrong with the statement in listing 4.14; however, you will
    frequently be performing multiple aggregations in a single query. When performing
    multiple aggregations in a query, you must be very mindful of the query cardinality
    (number of intermediate rows in the query). A simple yet very effective syntax
    to not increase the cardinality when counting the number of relationships a node
    has is to use the `count` `{}` operator and describe the desired graph pattern
    you want to count, as shown in the following listing.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.14中的陈述没有问题；然而，你经常会在一个查询中执行多个聚合操作。在查询中执行多个聚合操作时，你必须非常注意查询基数（查询中的中间行数）。在计数一个节点有多少关系时，不增加基数的一个简单但非常有效的语法是使用`count`
    `{}`运算符并描述你想要计数的所需图模式，如下面的列表所示。
- en: Listing 4.15 Convenient way of retrieving the top five most mentioned users
    by not increasing main query cardinality
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.15 通过不增加主查询基数，方便地检索提及最多的前五个用户
- en: '[PRE14]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You might have noticed that a common theme in Cypher syntax is to wrap a graph
    pattern in curly brackets and prepend a desired Cypher clause like `count`, `EXISTS`,
    or `CALL`, depending on your use case. The results of the Cypher statement in
    listing 4.15 are shown in table 4.11\.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，Cypher语法中的一个常见主题是将图模式用大括号括起来，并根据你的用例在前面添加一个所需的Cypher子句，如`count`、`EXISTS`或`CALL`。列表4.15中Cypher语句的结果显示在表4.11中。
- en: Table 4.11 Top five most mentioned users
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.11 提及最多的前五个用户
- en: '| `user` | `mentions` |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `user` | `mentions` |'
- en: '| "IainLJBrown" | 3646 |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| "IainLJBrown" | 3646 |'
- en: '| "SuzanneC0leman" | 673 |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| "SuzanneC0leman" | 673 |'
- en: '| "Analytics_699" | 476 |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| "Analytics_699" | 476 |'
- en: '| "Paula_Piccard" | 460 |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| "Paula_Piccard" | 460 |'
- en: '| "Eli_Krumova" | 283 |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| "Eli_Krumova" | 283 |'
- en: By far, the most mentioned user is IainLJBrown. If you are like me, you are
    probably wondering what the distribution of those mentioned is. Is this user frequently
    retweeted, are posts mentioning him frequently retweeted, or do people just like
    to mention him? From the results of exercise 4.10, you already know he has 754
    posts that were retweeted.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，被提及最多的用户是IainLJBrown。如果你像我一样，你可能想知道这些被提及者的分布情况。这个用户是否经常被转发，提及他的帖子是否经常被转发，或者人们只是喜欢提及他？从练习4.10的结果中，你已经知道他有754篇被转发的帖子。
- en: 4.5 Multiple aggregations in sequence
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5 连续多个聚合
- en: As mentioned, when performing multiple aggregation in sequence, you must be
    mindful of the intermediate cardinality. For example, say that you have two `MATCH`
    clauses in a row.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在连续执行多个聚合操作时，必须注意中间基数。例如，假设你有连续的两个`MATCH`子句。
- en: Listing 4.16 How multiple `MATCH` clauses affect the query cardinality
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.16 多个`MATCH`子句如何影响查询基数
- en: '[PRE15]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Table 4.12 shows how the cardinality of a query can explode when performing
    multiple `MATCH` statements in sequence if you don’t perform any intermediate
    steps.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.12展示了在连续执行多个`MATCH`子句而不进行任何中间步骤时，查询基数如何爆炸。
- en: Table 4.12 Multiple aggregation in sequence without reducing cardinality
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.12 不减少基数的情况下连续多个聚合
- en: '| `numberOfRows` | `countOfUsers` | `countOfTweets` |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| `numberOfRows` | `countOfUsers` | `countOfTweets` |'
- en: '| 43,343,640 | 43,343,640 | 43,343,640 |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| 43,343,640 | 43,343,640 | 43,343,640 |'
- en: You already know that this result doesn’t make sense at all. First, the number
    of users and tweets is identical, and you definitely don’t have 43 million nodes
    in the graph. So why do you get these results? Each `MATCH` or `OPTIONAL` `MATCH`
    produces a certain number of rows. Any subsequent `MATCH` or `OPTIONAL` `MATCH`
    clauses will be executed as many times as the rows produced by the previous `MATCH`
    clause. The first `MATCH` in listing 4.16 produces 3,594 rows. The second `MATCH`
    is then executed for each produced row separately. Effectively, the second `MATCH`
    will be executed 3,594 times. There are 12,060 tweets in our graph, so if you
    find the product of 12,060 and 3,594, you will get the 43 million rows.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道这个结果完全没有意义。首先，用户和推文的数量是相同的，你肯定没有4300万个节点在图中。那么为什么你会得到这些结果？每个`MATCH`或`OPTIONAL`
    `MATCH`会产生一定数量的行。任何后续的`MATCH`或`OPTIONAL` `MATCH`子句都将根据前一个`MATCH`子句产生的行数执行多次。列表4.16中的第一个`MATCH`产生了3,594行。然后第二个`MATCH`会针对每个产生的行分别执行。实际上，第二个`MATCH`将会执行3,594次。我们的图中共有12,060条推文，所以如果你找到12,060和3,594的乘积，你将得到4300万行。
- en: How do you avoid this problem? In this example, you can reduce the cardinality
    before the second `MATCH` clause to 1 so that the second `MATCH` clause will be
    executed only once. You can use any of the aggregating functions to reduce the
    cardinality. Let’s say you want to count the number of users and tweets in the
    graph. In this case, you can use the `count()` function after the first `MATCH`
    clause to reduce the cardinality.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如何避免这个问题？在这个例子中，你可以在第二个`MATCH`子句之前将基数减少到1，这样第二个`MATCH`子句就只会执行一次。你可以使用任何聚合函数来减少基数。假设你想要计算图中用户和推文的数量。在这种情况下，你可以在第一个`MATCH`子句之后使用`count()`函数来减少基数。
- en: Listing 4.17 Reducing cardinality between multiple `MATCH` clauses in a sequence
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.17 在多个`MATCH`子句之间减少基数
- en: '[PRE16]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ Reduces the cardinality to 1 before executing the subsequent MATCH clause
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在执行后续的`MATCH`子句之前将基数减少到1
- en: Table 4.13 shows how performing aggregations to reduce the intermediate cardinality
    of a query can produce valid results.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.13展示了如何通过执行聚合操作以减少查询的中间基数来产生有效结果。
- en: Table 4.13 Multiple aggregation in sequence with reducing intermediate cardinality
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.13 按顺序进行多次聚合，同时减少中间基数
- en: '| `numberOfRows` | `countOfUsers` | `countOfUsers` |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| `numberOfRows` | `countOfUsers` | `countOfUsers` |'
- en: '| 12,060 | 3,594 | 12,060 |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| 12,060 | 3,594 | 12,060 |'
- en: By reducing the intermediate cardinality after the first `MATCH` to 1, you are
    making sure any subsequent `MATCH` clauses will be executed only once. This will
    help you with query performance as well as getting accurate results. Another trick
    that will help you keep the cardinality in check is to use the `count` `{}` operator,
    as described in listing 4.15\.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在第一次 `MATCH` 之后减少中间基数到 1，您可以确保任何后续的 `MATCH` 子句只会执行一次。这将有助于您提高查询性能并获得准确的结果。另一个有助于您控制基数的方法是使用如列表
    4.15 所述的 `count` `{}` 操作符。
- en: Exercise 4.11
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 4.11
- en: 'Calculate the mention distribution for the user IainLJBrown. Mentions can come
    in three forms:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 计算用户 IainLJBrown 的提及分布。提及可以有以下三种形式：
- en: Someone retweeting a post from IainLJBrown
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 某人转发 IainLJBrown 的帖子
- en: Someone posting an original tweet that mentions IainLJBrown
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 某人发布了一条提及 IainLJBrown 的原创推文
- en: Someone retweeting a post that mentions IainLJBrown
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 某人转发提及 IainLJBrown 的帖子
- en: Make sure to reduce the cardinality after each `MATCH` or `OPTIONAL` `MATCH`
    clause. Because you don’t know beforehand if mentions of IainLJBrown fall into
    all three categories, I advise you to use `OPTIONAL` `MATCH` when counting the
    mentions distribution.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在每条 `MATCH` 或 `OPTIONAL` `MATCH` 子句之后减少基数。因为您事先不知道提及 IainLJBrown 的内容是否属于所有三个类别，我建议您在计算提及分布时使用
    `OPTIONAL` `MATCH`。
- en: The solution to exercise 4.11 is shown in the following listing.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 4.11 的解答如下。
- en: Listing 4.18 Calculating the distribution of mentions for user IainLJBrown
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.18 计算用户 IainLJBrown 的提及分布
- en: '[PRE17]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ Identifies the user
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 识别用户
- en: ❷ Counts the number of retweets their posts have received
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 计算他们帖子收到的转发数量
- en: ❸ Counts the number of mentions in original posts
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 计算原始帖子中的提及数量
- en: ❹ Counts the number of mentions in retweets and excludes retweets of the author’s
    post
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 计算转发中的提及数量，并排除作者帖子的转发
- en: Table 4.14 shows the resulting distribution of mentions for IainLJBrown.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.14 显示了 IainLJBrown 的结果分布。
- en: Table 4.14 Distribution of mentions for IainLJBrown
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.14 IainLJBrown 的提及分布
- en: '| `user` | `numberOfRetweets` | `mentionsInOriginalTweets` | `mentionsInRetweets`
    |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| `user` | `numberOfRetweets` | `mentionsInOriginalTweets` | `mentionsInRetweets`
    |'
- en: '| "IainLJBrown" | 3643 | 2 | 1 |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| "IainLJBrown" | 3643 | 2 | 1 |'
- en: The fact that you must use the `count()` operator directly after each `OPTIONAL`
    `MATCH` clause, and not only at the end, is a very important detail. This way,
    you reduce the in-between cardinality to 1 after each `OPTIONAL` `MATCH` clause
    and your count won’t explode. There are a couple of other ways you could get this
    result, so if your query is a little different but produces the same results,
    then it’s all OK. Almost all of the mentions for the user IainLJBrown come from
    their posts being retweeted. They were only mentioned in two original tweets,
    and one of them was likely retweeted once. If you consider the information from
    exercise 4.10, you know that 754 of his posts were retweeted 3,643 times. In this
    Twitter subgraph, he can definitely be regarded as an influencer.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须在每个 `OPTIONAL` `MATCH` 子句之后直接使用 `count()` 操作符，而不仅仅是最后，这是一个非常重要的细节。这样，您在每个
    `OPTIONAL` `MATCH` 子句之后将中间基数减少到 1，并且您的计数不会爆炸。您还有其他几种方法可以得到这个结果，所以如果您的查询略有不同但产生相同的结果，那么一切都很好。几乎所有关于用户
    IainLJBrown 的提及都来自他们的帖子被转发。他们只被提及在两篇原始推文中，其中一篇很可能被转发了一次。如果您考虑练习 4.10 的信息，您知道他的
    754 篇帖子被转发了 3,643 次。在这个 Twitter 子图中，他绝对可以被视为一个有影响力的人。
- en: Exercise 4.12
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 4.12
- en: Fetch the top five users who have published the most tweets or retweets. Use
    the `count` `{}` operator.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 获取发布最多推文或转发的 top 五个用户。使用 `count` `{}` 操作符。
- en: Congratulations! By completing all of the exercises, you have learned a considerable
    amount about Cypher aggregations and filtering.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！通过完成所有练习，您已经对 Cypher 聚合和过滤有了相当的了解。
- en: 4.6 Solutions to exercises
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.6 练习解答
- en: The solution to exercise 4.1 is as follows.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 4.1 的解答如下。
- en: Listing 4.19 Generated Cypher query that visualizes a sample of 25 `RETWEETS`
    relationships
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.19 生成的 Cypher 查询，用于可视化 25 条 `RETWEETS` 关系
- en: '[PRE18]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The solution to exercise 4.2 is as follows.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 4.2 的解答如下。
- en: Listing 4.20 Calculating the ratio of non-null values of the `createdAt` node
    property of tweets
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.20 计算推文 `createdAt` 节点属性的 `non-null` 值比率
- en: '[PRE19]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The solution to exercise 4.3 is as follows.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 练习4.3的解决方案如下。
- en: Listing 4.21 Counting the number of relationships grouped by their type
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.21 按类型分组计算关系的数量
- en: '[PRE20]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The solution to exercise 4.4 is as follows.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 练习4.4的解决方案如下。
- en: Listing 4.22 Cypher statement to compare the retweet and original tweet’s text
    property
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.22 比较转发推文和原始推文的文本属性
- en: '[PRE21]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The solution to exercise 4.5 is as follows.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 练习4.5的解决方案如下。
- en: Listing 4.23 Visualizing a single graph pattern in which a user retweeted a
    post from another user
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.23 可视化一个用户从另一个用户转发帖子的单个图模式
- en: '[PRE22]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The solution to exercise 4.6 is as follows.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 练习4.6的解决方案如下。
- en: Listing 4.24 Calculating the distribution of tweets by year
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.24 通过年份计算推文的分布
- en: '[PRE23]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The solution to exercise 4.7 is as follows.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 练习4.7的解决方案如下。
- en: Listing 4.25 Calculating the distribution of tweets created in 2021 by month
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.25 通过月份计算2021年创建的推文的分布
- en: '[PRE24]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The solution to exercise 4.8 is as follows.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 练习4.8的解决方案如下。
- en: Listing 4.26 Determining the top four days by the number of tweets created
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.26 通过创建推文的数量确定前四天
- en: '[PRE25]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The solution to exercise 4.9 is as follows.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 练习4.9的解决方案如下。
- en: Listing 4.27 Counting the number of distinct users who have published at least
    one tweet
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.27 计算至少发布了一条推文的独特用户的数量
- en: '[PRE26]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The solution to exercise 4.10 is as follows.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 练习4.10的解决方案如下。
- en: Listing 4.28 Finding the top five users who had the most distinct tweets retweeted
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.28 找到转发最多独特推文的顶级五名用户
- en: '[PRE27]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The solution to exercise 4.11 is as follows.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 练习4.11的解决方案如下。
- en: Listing 4.29 Calculating the distribution of mentions for user IainLJBrown
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.29 计算用户IainLJBrown的提及分布
- en: '[PRE28]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ❶ Identifies the user
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 识别用户
- en: ❷ Counts the number of retweets their posts have received
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 统计他们帖子收到的转发次数
- en: ❸ Counts the number of mentions in original posts
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 统计原始帖子中的提及次数
- en: ❹ Counts the number of mentions in retweets and excludes retweets of author’s
    post
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 统计在转发中提及的次数，并排除作者帖子的转发
- en: The solution to exercise 4.12 is as follows.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 练习4.12的解决方案如下。
- en: Listing 4.30 Fetching the top five users who have published the most tweets
    or retweets
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.30 获取发布最多推文或转发的顶级五名用户
- en: '[PRE29]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Summary
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: A path data object contains a sequence of connected nodes and relationships.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路径数据对象包含一系列连接的节点和关系。
- en: Cypher aggregations use implicit grouping keys.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cypher聚合使用隐式分组键。
- en: As soon as an aggregation function is used, all non-aggregated columns become
    grouping keys.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦使用聚合函数，所有非聚合列都成为分组键。
- en: Existential subqueries can help you efficiently filter using graph patterns.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在性子查询可以帮助您通过图模式高效地过滤。
- en: Existential subqueries are especially useful when you want to negate a graph
    pattern.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在性子查询在您想要否定图模式时特别有用。
- en: Cardinality is the number of rows or records of the input stream to the operation.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基数是操作输入流中行或记录的数量。
- en: A datetime object has multiple attributes that you can use to retrieve the year,
    month, day, or epoch information.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日期时间对象有多个属性，您可以使用它们来检索年、月、日或纪元信息。
- en: A `distinct` operator can be used to count the number of distinct patterns,
    nodes, relationships, or properties.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用`distinct`运算符来计算不同模式、节点、关系或属性的数目。
- en: Dividing an integer by an integer will return an integer. Therefore you need
    to cast one of the values to float using the `toFloat` function to avoid returning
    an integer.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一个整数除以一个整数将返回一个整数。因此您需要使用`toFloat`函数将其中一个值转换为浮点数，以避免返回整数。
- en: The `count` operator can be used to count the number of non-null properties
    or expressions.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用`count`运算符来计算非空属性或表达式的数量。
- en: When executing multiple clauses or aggregation functions in sequence, you have
    to be mindful of the intermediate query cardinality.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当连续执行多个子句或聚合函数时，您必须注意中间查询的基数。
- en: Counting subqueries are useful when you want to count graph patterns without
    affecting the cardinality of the main query.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计数子查询在您想要计数图模式而不影响主查询基数时很有用。
- en: You can prefix any Cypher statement with the `PROFILE` clause to evaluate its
    performance by examining total database hits.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在任何Cypher语句前加上`PROFILE`子句，通过检查总数据库击打来评估其性能。
