- en: 10 Packaging and managing apps with Helm
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 使用 Helm 打包和管理应用
- en: As vast as Kubernetes is, it doesn’t solve every problem by itself; a large
    ecosystem exists to fill the gaps. One of these gaps is packaging and distributing
    apps, and the solution is Helm. You can use Helm to group a set of Kubernetes
    YAML files into one artifact and share that on a public or private repository.
    Anyone with access to the repository can install the app with a single Helm command.
    That command might deploy a whole set of related Kubernetes resources including
    ConfigMaps, Deployments, and Services, and you can customize the configuration
    as part of the installation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Kubernetes 功能强大，但它并不能自行解决所有问题；存在一个庞大的生态系统来填补这些空白。其中之一就是打包和分发应用，而 Helm 就是解决方案。您可以使用
    Helm 将一组 Kubernetes YAML 文件组合成一个工件，并在公共或私有仓库中共享。任何有权访问仓库的人都可以使用单个 Helm 命令安装应用。该命令可能部署一系列相关的
    Kubernetes 资源，包括 ConfigMaps、Deployments 和 Services，您可以在安装过程中自定义配置。
- en: People use Helm in different ways. Some teams use Helm only to install and manage
    third-party apps from public repositories. Other teams use Helm for their own
    applications, packaging and publishing them to private repositories. In this chapter,
    you’ll learn how to do both, and you’ll leave with your own idea of how Helm might
    fit in your organization. You don’t need to learn Helm to be effective with Kubernetes,
    but it’s widely used so it’s something you should be familiar with. The project
    is governed by the Cloud Native Computing Foundation (CNCF)—the same foundation
    that stewards Kubernetes—which a reliable indicator of maturity and longevity.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 人们以不同的方式使用 Helm。有些团队仅使用 Helm 从公共仓库安装和管理第三方应用。其他团队则使用 Helm 为自己的应用打包和发布到私有仓库。在本章中，您将学习如何做这两件事，并带着自己对
    Helm 如何适应您组织的想法离开。您不需要学习 Helm 就能有效地使用 Kubernetes，但它被广泛使用，因此您应该熟悉它。该项目由云原生计算基金会（CNCF）管理——与托管
    Kubernetes 的同一基金会——这是一个可靠成熟度和长期性的指标。
- en: 10.1 What Helm adds to Kubernetes
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1 Helm 为 Kubernetes 增加的功能
- en: Kubernetes apps are modeled in a sprawl of YAML files at design time and managed
    using sets of labels at run time. There’s no native concept of an “application”
    in Kubernetes, which clearly groups together a set of related resources, and that’s
    one of the problems Helm solves. It’s a command-line tool that interacts with
    repository servers to find and download application packages and, with your Kubernetes
    cluster, to install and manage applications.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 应用在设计时以 YAML 文件的形式进行建模，在运行时使用标签集进行管理。Kubernetes 中没有“应用”的原生概念，这显然将一组相关资源分组在一起，这也是
    Helm 解决的问题之一。它是一个与仓库服务器交互以查找和下载应用包的命令行工具，并且与您的 Kubernetes 集群一起安装和管理应用。
- en: Helm is another layer of abstraction, this time at the application level. When
    you install an application with Helm, it creates a set of resources in your Kubernetes
    cluster—and they’re standard Kubernetes resources. The Helm packaging format extends
    Kubernetes YAML files, so a Helm package is really just a set of Kubernetes manifests
    stored along with some metadata. We’ll start by using Helm to deploy one of the
    sample apps from previous chapters, but first we need to install Helm.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 是另一层抽象，这次是在应用层面。当您使用 Helm 安装应用时，它会在您的 Kubernetes 集群中创建一组资源——它们是标准的 Kubernetes
    资源。Helm 打包格式扩展了 Kubernetes YAML 文件，因此 Helm 包实际上是一组 Kubernetes 清单，附带一些元数据存储在一起。我们将首先使用
    Helm 部署前几章中的一个示例应用，但在此之前，我们需要安装 Helm。
- en: 'Try it now Helm is a cross-platform tool that runs on Windows, macOS, and Linux.
    You can find the latest installation instructions here: [https://helm.sh/ docs/intro/install](https://helm.sh/docs/intro/install).
    This exercise assumes you already have a package manager like Homebrew or Chocolatey
    installed. If not, you’ll need to refer to the Helm site for the full installation
    instructions.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 现在就试试吧！Helm 是一个跨平台工具，可在 Windows、macOS 和 Linux 上运行。您可以在以下链接中找到最新的安装说明：[https://helm.sh/docs/intro/install](https://helm.sh/docs/intro/install)。本练习假设您已经安装了包管理器，如
    Homebrew 或 Chocolatey。如果没有，您需要参考 Helm 网站上的完整安装说明。
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The installation steps in this exercise may not work on your system, in which
    case, you’ll need to stop here and head to the Helm installation docs. We can’t
    go much further until you have Helm installed and you see successful output from
    the `version` command, like that shown in figure 10.1.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习中的安装步骤可能无法在您的系统上工作，在这种情况下，您需要在这里停止并前往 Helm 安装文档。在您安装 Helm 并看到 `version` 命令的成功输出，如第
    10.1 图所示之前，我们无法继续前进。
- en: '![](../Images/10-1.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/10-1.jpg)'
- en: Figure 10.1 There are lots of options to install Helm; using a package manager
    is easiest.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 安装 Helm 有很多选项；使用软件包管理器是最简单的。
- en: Helm is a client-side tool. Previous versions of Helm required a server component
    to be deployed in your Kubernetes cluster, but that was changed in the major update
    to Helm 3\. The Helm CLI uses the same connection information that kubectl uses
    to connect to your Kubernetes cluster, so you don’t need any extra configuration
    to install an app. You do need to configure a package repository, however. Helm
    repositories are similar to container image registries like Docker Hub, but the
    server publishes an index of all available packages; Helm caches a local copy
    of your repository indexes, which you can use to search packages.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 是一个客户端工具。Helm 的早期版本需要在你的 Kubernetes 集群中部署一个服务器组件，但在 Helm 3 的主要更新中，这一点已经改变。Helm
    CLI 使用与 kubectl 相同的连接信息来连接到你的 Kubernetes 集群，因此你不需要任何额外的配置来安装应用程序。然而，你需要配置一个软件包仓库。Helm
    仓库类似于 Docker Hub 这样的容器镜像仓库，但服务器发布了一个所有可用包的索引；Helm 缓存了你仓库索引的本地副本，你可以使用它来搜索包。
- en: Try it now Add the Helm repository for the book, sync it, and search for an
    app.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试吧 添加书籍的 Helm 仓库，同步它，并搜索一个应用程序。
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The Kiamol repository is a public server, and you can see in this exercise that
    there are two versions of the package called vweb. My output appears in figure
    10.2.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Kiamol 仓库是一个公共服务器，你可以在这个练习中看到有两个版本的名为 vweb 的包。我的输出显示在图 10.2 中。
- en: '![](../Images/10-2.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片 10-2](../Images/10-2.jpg)'
- en: Figure 10.2 Syncing a local copy of the Kiamol Helm repository and searching
    for packages
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 同步 Kiamol Helm 仓库的本地副本并搜索包
- en: You’re getting a feel for Helm, but it’s time for some theory so we can use
    the correct concepts and their correct names before we go any further. An application
    package in Helm is called a *chart*; charts can be developed and deployed locally
    or published to a *repository*. When you install a chart, that’s called a *release*;
    every release has a name, and you can install multiple instances of the same chart
    in your cluster as separate, named releases.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经对 Helm 有了一定的感觉，但现在需要一些理论知识，这样我们才能在继续前进之前使用正确的概念和它们的正确名称。在 Helm 中，一个应用程序包被称为
    *chart*；chart 可以在本地开发和部署，或者发布到 *repository*。当你安装一个 chart 时，这被称为 *release*；每个 release
    都有一个名称，你可以在你的集群中安装同一 chart 的多个实例，作为独立的、命名的 release。
- en: Charts contain Kubernetes YAML manifests, and the manifests typically contain
    parameterized values so users can install the same chart with different configuration
    settings—the number of replicas to run or the application logging level could
    be parameter values. Each chart also contains a default set of values, and they
    can be inspected using the command line. Figure 10.3 shows the file structure
    of a Helm chart.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Charts 包含 Kubernetes YAML 清单，清单通常包含参数化值，以便用户可以使用不同的配置设置安装相同的 chart——运行的副本数量或应用程序日志级别可以是参数值。每个
    chart 也包含一组默认值，可以使用命令行进行检查。图 10.3 显示了 Helm chart 的文件结构。
- en: '![](../Images/10-3.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片 10-3](../Images/10-3.jpg)'
- en: Figure 10.3 Helm charts contain all the Kubernetes YAML for the app, plus some
    metadata.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 Helm chart 包含应用程序的所有 Kubernetes YAML，以及一些元数据。
- en: The vweb charts package contains the simple web app we used to demonstrate updates
    and rollbacks in chapter 9\. Each chart contains a spec for a Service and a Deployment,
    with some parameterized values and default settings. You can use the Helm command
    line to inspect all the available values before installing the chart and then
    override the defaults with custom values when you install a release.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: vweb charts 包包含我们在第 9 章中用来演示更新和回滚的简单 Web 应用程序。每个 chart 包含一个 Service 和 Deployment
    的规范，以及一些参数化值和默认设置。你可以在安装 chart 之前使用 Helm 命令行检查所有可用的值，然后在安装 release 时使用自定义值覆盖默认值。
- en: Try it now Check the values available in version 1 of the vweb chart, and then
    install a release using custom values.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试吧 检查 vweb chart 的第 1 版中可用的值，然后使用自定义值安装一个 release。
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this exercise, you can see that the chart has default values for the Service
    port and the number of replicas in the Deployment. My output is shown in figure
    10.4\. You use the `set` argument with `helm` `install` to specify your own values,
    and when the install completes, you have an app running in Kubernetes without
    using kubectl and without any direct use of YAML manifests.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你可以看到 chart 为 Service 端口和 Deployment 中的副本数量提供了默认值。我的输出显示在图 10.4 中。你使用
    `helm install` 命令中的 `set` 参数来指定你自己的值，当安装完成后，你就可以在 Kubernetes 中运行一个应用程序，而无需使用 kubectl，也无需直接使用
    YAML 清单。
- en: '![](../Images/10-4.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片 10-4](../Images/10-4.jpg)'
- en: Figure 10.4 Installing an app with Helm—this creates Kubernetes resources, without
    using kubectl.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4 使用 Helm 安装应用程序——这会创建 Kubernetes 资源，而不使用 kubectl。
- en: Helm has a set of features for working with repositories and charts and for
    installing, updating, and rolling back releases, but it’s not intended for ongoing
    management of applications. The Helm command line isn’t a replacement for kubectl—you
    use them together. Now that the release is installed, you can work with the Kubernetes
    resources in the usual way, and you can also return to Helm if you need to modify
    settings.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 提供了一套用于处理仓库和图表以及安装、更新和回滚发布的功能，但它并不打算用于应用程序的持续管理。Helm 命令行不是 kubectl 的替代品——您需要一起使用它们。现在发布已安装，您可以像往常一样处理
    Kubernetes 资源，如果您需要修改设置，也可以返回 Helm。
- en: Try it now Check the resources Helm has deployed using kubectl, and then return
    to Helm to scale up the Deployment and check that the app is working correctly.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试吧 检查 Helm 部署的资源，然后返回 Helm 以扩展 Deployment 并检查应用程序是否正常工作。
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Let’s look at a couple of things from that exercise. The first is that the labels
    are a lot more verbose than the standard “app” and “version” labels you’ve seen
    so far. That’s because this is a public chart on a public repository, so I’m using
    the recommended label names from the Kubernetes Configuration Best Practices guide—that’s
    my choice, not a requirement of Helm. The second is that the Helm `upgrade` command
    specifies the Service port again, although it’s only the replica count I want
    to modify. This is because Helm uses the default values unless you specify them,
    so if the port isn’t included in the `upgrade` command, it would be changed to
    the default value. You can see my output in figure 10.5.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看那个练习中的几个要点。首先，标签比您迄今为止看到的标准的“应用程序”和“版本”标签要详细得多。这是因为这是一个公共仓库上的公共图表，所以我使用了
    Kubernetes 配置最佳实践指南中推荐的标准标签名称——这是我的选择，而不是 Helm 的要求。其次，Helm 的 `upgrade` 命令再次指定了服务端口，尽管我只想修改副本计数。这是因为
    Helm 使用默认值，除非您指定它们，所以如果端口没有包含在 `upgrade` 命令中，它将被更改为默认值。您可以在图 10.5 中看到我的输出。
- en: '![](../Images/10-5.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/10-5.jpg)'
- en: Figure 10.5 You don’t use Helm to manage apps, but you can use it to update
    the configuration.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.5 您不使用 Helm 来管理应用程序，但您可以使用它来更新配置。
- en: This is the consumer side of the Helm workflow. You can search repositories
    for applications, discover the configuration values available for an app, and
    then install and upgrade the application, all from the Helm command line. It’s
    package management for apps built to run in Kubernetes. In the next section you’ll
    learn how to package and publish your own apps, which is the producer side of
    the workflow.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Helm 工作流程的消费端。您可以从 Helm 命令行搜索应用程序仓库，发现应用程序可用的配置值，然后安装和升级应用程序。它是为在 Kubernetes
    中运行而构建的应用程序的包管理工具。在下一节中，您将学习如何打包和发布自己的应用程序，这是工作流程的生产端。
- en: 10.2 Packaging your own apps with Helm
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2 使用 Helm 打包自己的应用程序
- en: Helm charts are folders or zipped archives that contain Kubernetes manifests.
    You create your own charts by taking your application manifests, identifying any
    values you want to be parameterized, and replacing the actual value with a templated
    variable. Listing 10.1 shows the beginning of a templated Deployment spec, which
    uses values set by Helm for the resource name and the label value.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 图表是包含 Kubernetes 清单的文件夹或压缩存档。您可以通过将应用程序清单、识别您想要参数化的任何值，并用模板变量替换实际值来创建自己的图表。列表
    10.1 显示了模板化的 Deployment 规范的开始，它使用 Helm 设置的资源名称和标签值。
- en: Listing 10.1  web-ping-deployment.yaml, a templated Kubernetes manifest
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.1  web-ping-deployment.yaml，一个模板化的 Kubernetes 清单
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The double-brace syntax is for templated values—everything from the opening
    `{{` to the closing `}}` is replaced at install time, and Helm sends the processed
    YAML to Kubernetes. Multiple sources can be used as the input to replace templated
    values. The snippet in listing 10.1 uses the Release object to get the name of
    the release and the Values object to get a parameter value called `kiamolChapter`.
    The Release object is populated with information from the `install` or `upgrade`
    command, and the Values object is populated from defaults in the chart and any
    settings the user has overridden. Templates can also access static details about
    the chart and runtime details about the capabilities of the Kubernetes cluster.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 双大括号语法用于模板化值——从开头的 `{{` 到结尾的 `}}` 在安装时会被替换，Helm 将处理后的 YAML 发送到 Kubernetes。可以使用多个源作为输入来替换模板化值。列表
    10.1 中的片段使用发布对象获取发布名称，并使用值对象获取名为 `kiamolChapter` 的参数值。发布对象由 `install` 或 `upgrade`
    命令提供的信息填充，值对象则从图表的默认值和用户覆盖的任何设置中填充。模板还可以访问有关图表的静态详细信息以及有关 Kubernetes 集群功能的运行时详细信息。
- en: 'Helm is very particular about the file structure in a chart. You can use the
    `helm` `create` command to generate the boilerplate structure for a new chart.
    The top level is a folder whose name has to match the chart name you want to use,
    and that folder must have at least the following three items:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 对图表中的文件结构非常讲究。你可以使用 `helm` `create` 命令来生成新图表的样板结构。顶级是一个文件夹，其名称必须与你要使用的图表名称匹配，并且该文件夹必须至少包含以下三项：
- en: A `Chart.yaml` file that specifies the chart metadata, including the name and
    version
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `Chart.yaml` 文件，用于指定图表元数据，包括名称和版本
- en: A `values.yaml` file that sets the default values for parameters
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `values.yaml` 文件，用于设置参数的默认值
- en: A `templates` folder that contains the templated Kubernetes manifests
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含模板化 Kubernetes 清单的 `templates` 文件夹
- en: Listing 10.1 is from a file called `web-ping-deployment.yaml` in the `web-ping/templates`
    folder in this chapter’s source. The `web-ping` folder contains all the files
    needed for a valid chart, and Helm can validate the chart contents and install
    a release from the chart folder.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.1 来自本章源文件中 `web-ping/templates` 文件夹下的 `web-ping-deployment.yaml` 文件。`web-ping`
    文件夹包含创建有效图表所需的所有文件，Helm 可以验证图表内容，并从图表文件夹安装发布。
- en: Try it now When you’re developing charts, you don’t need to package them in
    zip archives; you can work with the chart folder.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在就试试 当你开发图表时，你不需要将它们打包成 zip 归档；你可以直接使用图表文件夹。
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `lint` command is only for working with local charts, but the `install`
    command is the same for local charts and for charts stored in a repository. Local
    charts can be folders or zipped archives, and you’ll see in this exercise that
    installing a release from a local chart is the same experience as installing from
    a repository. My output in figure 10.6 shows I now have two releases installed:
    one from the vweb chart and one from the web-ping chart.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`lint` 命令仅用于处理本地图表，但 `install` 命令对本地图表和存储在仓库中的图表都是相同的。本地图表可以是文件夹或压缩归档，你将在本练习中看到，从本地图表安装发布与从仓库安装具有相同的体验。我在图
    10.6 中的输出显示，我现在安装了两个发布：一个是来自 vweb 图表的，另一个来自 web-ping 图表。'
- en: '![](../Images/10-6.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.6](../Images/10-6.jpg)'
- en: Figure 10.6 Installing and upgrading from a local folder lets you iterate quickly
    on chart development.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6 从本地文件夹安装和升级允许你快速迭代图表开发。
- en: The web-ping application is a basic utility that checks whether a website is
    up by making HTTP requests to a domain name on a regular schedule. Right now,
    you have a Pod running, which is sending requests to my blog every 30 seconds.
    My blog runs on Kubernetes, so I’m sure it will be able to handle that. The app
    uses environment variables to configure the URL to use and the schedule interval,
    and those are templated in the manifest for Helm. Listing 10.2 shows the Pod spec
    with the templated variables.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: web-ping 应用程序是一个基本的实用程序，通过定期向域名发送 HTTP 请求来检查网站是否正常运行。目前，你有一个 Pod 正在运行，每 30 秒向我的博客发送请求。我的博客运行在
    Kubernetes 上，所以我确信它能够处理这些请求。该应用程序使用环境变量来配置要使用的 URL 和调度间隔，这些变量在 Helm 的清单中进行了模板化。列表
    10.2 显示了带有模板化变量的 Pod 规范。
- en: Listing 10.2 web-ping-deployment.yaml, templated container environment
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.2 web-ping-deployment.yaml，模板化容器环境
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Helm has a rich set of templating functions you can use to manipulate the values
    that get set in the YAML. The `quote` function in listing 10.2 wraps the provided
    value in quotation marks, if it doesn’t already have them. You can include looping
    and branching logic in your templates, calculate strings and numbers, and even
    query the Kubernetes API to find details from other objects. We won’t get into
    that much detail, but it’s important to remember that Helm lets you generate sophisticated
    templates that can do pretty much anything.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Helm提供了一套丰富的模板函数，您可以使用它们来操作在YAML中设置的值。列表10.2中的`quote`函数如果提供的值没有引号，则将其包裹在引号中。您可以在模板中包含循环和分支逻辑，计算字符串和数字，甚至查询Kubernetes
    API以从其他对象中获取详细信息。我们不会深入探讨这些细节，但重要的是要记住，Helm让您生成复杂的模板，几乎可以完成任何事情。
- en: You need to think carefully about the parts of your spec that need to be templated.
    One of the big benefits of Helm over standard manifest deployments is that you
    can run multiple instances of the same app from a single chart. You can’t do that
    with kubectl because the manifests contain resource names that need to be unique.
    If you deploy the same set of YAML multiple times, Kubernetes will just update
    the same resources. If you template all the unique parts of the spec—like resource
    names and label selectors—then you can run many copies of the same app with Helm.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要仔细思考需要模板化的规范部分。Helm相对于标准清单部署的一个主要好处是您可以从单个图表运行同一应用程序的多个实例。您不能使用kubectl这样做，因为清单包含需要唯一的资源名称。如果您多次部署相同的YAML集合，Kubernetes将仅更新相同的资源。如果您模板化规范中所有唯一的部分——如资源名称和标签选择器——则可以使用Helm运行同一应用程序的多个副本。
- en: Try it now Deploy a second release of the web-ping app, using the same chart
    folder but specifying a different URL to ping.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下：部署web-ping应用程序的第二个版本，使用相同的图表文件夹，但指定一个不同的URL进行ping。
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You’ll see in this exercise that I need to do some optimization on my blog—it
    returns in around 500 ms whereas the Kiamol website returns in 100 ms. More important,
    you can see two instances of the app running: two Deployments managing two sets
    of Pods with different container specs. My output is shown in figure 10.7.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您会看到我需要对我的博客进行一些优化——它大约需要500毫秒返回，而Kiamol网站只需要100毫秒。更重要的是，您可以看到应用程序的两个实例正在运行：两个Deployment管理着具有不同容器规范的两组Pod。我的输出显示在图10.7中。
- en: '![](../Images/10-7.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/10-7.jpg)'
- en: Figure 10.7 You can’t install multiple instances of an app with plain manifests,
    but you can with Helm.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7 您不能使用纯清单安装应用程序的多个实例，但可以使用Helm。
- en: It should be clear now that the Helm workflow for installing and managing apps
    is different from the kubectl workflow, but you also need to understand that the
    two are *incompatible*. You can’t deploy the app by running `kubectl` `apply`
    in the templates folder for the chart, because the templated variables are not
    valid YAML, and the command will fail. If you adopt Helm, you need to choose between
    using Helm for every environment, which is likely to slow down the developer workflow,
    or using plain Kubernetes manifests for development and Helm for other environments,
    which means you’ll have multiple copies of your YAML.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该很清楚，Helm的安装和管理应用程序的工作流程与kubectl的工作流程不同，但您还需要理解这两者是不兼容的。您不能通过在图表的模板文件夹中运行`kubectl
    apply`来部署应用程序，因为模板变量不是有效的YAML，该命令会失败。如果您采用Helm，您需要在为每个环境使用Helm，这可能会减慢开发人员的工作流程，或者使用纯Kubernetes清单进行开发并使用Helm处理其他环境之间做出选择，这意味着您将拥有多个YAML副本。
- en: Remember that Helm is about distribution and discovery as much as it’s about
    installation. The additional friction that Helm brings is the price of being able
    to simplify complex applications down to a few variables and share them on a repository.
    A repository is really just an index file with a list of chart versions that can
    be stored on any web server (the Kiamol repository uses GitHub pages, and you
    can see the whole contents at [https://kiamol.net/index.yaml](https://kiamol.net/index.yaml)).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，Helm不仅关乎安装，同样关乎分布和发现。Helm带来的额外摩擦是能够将复杂的应用简化为几个变量并在存储库中共享的代价。存储库实际上只是一个索引文件，其中包含可以存储在任何网络服务器上的图表版本列表（Kiamol存储库使用GitHub页面，您可以在[https://kiamol.net/index.yaml](https://kiamol.net/index.yaml)中查看全部内容）。
- en: You can use any server technology to host your repository, but for the rest
    of this section, we’ll use a dedicated repository server called ChartMuseum, which
    is a popular open source option. You can run ChartMuseum as a private Helm repository
    in your own organization, and it’s easy to set up because you can install it with
    a Helm chart.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用任何服务器技术来托管您的存储库，但在此节的其余部分，我们将使用一个名为ChartMuseum的专用存储库服务器，这是一个流行的开源选项。您可以在自己的组织中运行ChartMuseum作为私有Helm存储库，并且它很容易设置，因为您可以使用Helm图表来安装它。
- en: Try it now The ChartMuseum chart is on the official Helm repository, conventionally
    called “stable.” Add that repository, and you can install a release to run your
    own repository locally.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 ChartMuseum图表位于官方Helm存储库中，通常称为“stable”。添加该存储库，您就可以在本地运行自己的存储库。
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now you have three repositories registered with Helm: the Kiamol repository,
    the stable Kubernetes repository (which is a curated set of charts, similar to
    the official images in Docker Hub), and your own local repository. You can see
    my output in figure 10.8, which is abridged to reduce the output from the Helm
    `install` command.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经在Helm中注册了三个存储库：Kiamol存储库、稳定版Kubernetes存储库（这是一个精选的图表集，类似于Docker Hub中的官方镜像），以及您自己的本地存储库。您可以在图10.8中看到我的输出，它被缩减以减少Helm
    `install`命令的输出。
- en: '![](../Images/10-8.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10-8.jpg)'
- en: Figure 10.8 Running your own Helm repository is as simple as installing a chart
    from a Helm repository.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8 运行自己的Helm存储库就像从Helm存储库安装一个图表一样简单。
- en: 'Charts need to be packaged before they can be published to a repository, and
    publishing is usually a three-stage process: package the chart into a zip archive,
    upload the archive to a server, and update the repository index to add the new
    chart. ChartMuseum takes care of the last step for you, so you just need to package
    and upload the chart for the repository index to be automatically updated.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图表在发布到存储库之前需要打包，发布通常是一个三阶段的过程：将图表打包成zip归档，将归档上传到服务器，并更新存储库索引以添加新的图表。ChartMuseum为您处理最后一步，因此您只需打包和上传图表，存储库索引就会自动更新。
- en: Try it now Use Helm to create the zip archive for the chart, and use `curl`
    to upload it to your ChartMuseum repository. Check the repository—you’ll see your
    chart has been indexed.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 使用Helm为图表创建zip归档，并使用`curl`将其上传到您的ChartMuseum存储库。检查存储库——您会看到您的图表已被索引。
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Helm uses compressed archives to make charts easy to distribute, and the files
    are tiny—they contain the Kubernetes manifests and the metadata and values, but
    they don’t contain any large binaries. Pod specs in the chart specify container
    images to use, but the images themselves are not part of the chart—they’re pulled
    from Docker Hub or your own image registry when you install a release. You can
    see in figure 10.9 that ChartMusem generates the repository index when you upload
    a chart and adds the new chart details.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Helm使用压缩归档来简化图表的分发，文件非常小——它们包含Kubernetes清单、元数据和值，但不包含任何大型二进制文件。图表中的Pod规范指定了要使用的容器镜像，但镜像本身不是图表的一部分——在安装发布时，它们从Docker
    Hub或您自己的镜像仓库中拉取。您可以在图10.9中看到，当您上传图表时，ChartMuseum会生成存储库索引，并添加新的图表详细信息。
- en: '![](../Images/10-9.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10-9.jpg)'
- en: Figure 10.9 You can run ChartMuseum as a private repository to easily share
    charts between teams.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9 您可以将ChartMuseum作为私有存储库运行，以便在团队之间轻松共享图表。
- en: You can use ChartMuseum or another repository server in your organization to
    share internal applications or to push charts as part of your continuous integration
    process before making release candidates available on your public repository.
    The local repository you have is running only in your lab environment, but it’s
    published using a LoadBalancer Service, so anyone with network access can install
    the web-ping app from it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用ChartMuseum或其他组织内的存储库服务器来共享内部应用程序，或者在将发布候选版本发布到公共存储库之前，将图表作为持续集成过程的一部分进行推送。您拥有的本地存储库仅在您的实验室环境中运行，但它使用负载均衡器服务进行发布，因此任何具有网络访问权限的人都可以从它安装web-ping应用程序。
- en: Try it now Install yet another version of the web-ping app, this time using
    the chart from your local repository and providing a values file instead of specifying
    each setting in the `install` command.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 安装web-ping应用程序的另一个版本，这次使用您本地存储库中的图表，并提供一个值文件而不是在`install`命令中指定每个设置。
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this exercise, you saw another way to install a Helm release with custom
    settings—using a local values file. That’s a good practice, because you can store
    the settings for different environments in different files, and you mitigate the
    risk that an update reverts back to a default value when a setting isn’t provided.
    My output is shown in figure 10.10.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你看到了另一种使用自定义设置安装Helm发布的方法——使用本地值文件。这是一个好习惯，因为你可以将不同环境的设置存储在不同的文件中，并降低在设置未提供时更新回默认值的危险。我的输出如图10.10所示。
- en: '![](../Images/10-10.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图10-10](../Images/10-10.jpg)'
- en: Figure 10.10 Installing charts from your local repository is the same as installing
    from any remote repository.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10 从本地仓库安装图表与从任何远程仓库安装相同。
- en: You also saw in the previous exercise that you can install a chart from a repository
    without specifying a version. That’s not such a good practice, because it installs
    the latest version, which is a moving target. It’s better to always explicitly
    state the chart version. Helm requires you to use semantic versioning so chart
    consumers know whether the package they’re about to upgrade is a beta release
    or if it has breaking changes.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你在之前的练习中也看到了，你可以不指定版本从仓库安装一个图表。这不是一个好的做法，因为它会安装最新版本，这是一个移动的目标。最好总是明确地声明图表版本。Helm要求你使用语义版本，这样图表消费者就知道他们即将升级的包是beta版本还是它有破坏性更改。
- en: You can do far more with charts than I’m going to cover here. They can include
    tests, which are Kubernetes Job specs that run after installation to verify the
    deployment; they can have hooks, which let you run Jobs at specific points in
    the installation workflow; and they can be signed and shipped with a signature
    for provenance. In the next section, I’m going to cover one more feature you use
    in authoring templates, and it’s an important one—building charts that are dependent
    on other charts.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用图表做比我在这里要介绍的内容多得多的工作。它们可以包括测试，这些是安装后运行的Kubernetes作业规范，用于验证部署；它们可以有钩子，这让你可以在安装工作流程的特定点运行作业；并且它们可以带有签名并附带来源签名。在下一节中，我将介绍你在编写模板时使用的一个更多功能，这是一个重要的功能——构建依赖于其他图表的图表。
- en: 10.3 Modeling dependencies in charts
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3 在图表中建模依赖关系
- en: Helm lets you design your app so it works in different environments, and that
    raises an interesting problem for dependencies. A dependency might be required
    in some environments but not in others. Maybe you have a web app that really needs
    a caching reverse proxy to improve performance. In some environments, you’ll want
    to deploy the proxy along with the app, and in others, you’ll already have a shared
    proxy so you just want to deploy the web app itself. Helm supports these with
    conditional dependencies.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Helm让你设计你的应用程序，使其在不同的环境中都能工作，这为依赖关系提出了一个有趣的问题。在某些环境中可能需要依赖关系，而在其他环境中则不需要。也许你有一个真正需要缓存反向代理来提高性能的Web应用程序。在某些环境中，你可能希望与应用程序一起部署代理，而在其他环境中，你可能已经有一个共享代理，所以你只想部署Web应用程序本身。Helm通过条件依赖支持这些情况。
- en: Listing 10.3 shows a chart manifest for the Pi web application we’ve been using
    since chapter 5\. It has two dependencies—one from the Kiamol repository, and
    one from the local filesystem—and they are separate charts.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.3显示了自第5章以来我们一直在使用的Pi Web应用程序的图表规范。它有两个依赖项——一个来自Kiamol仓库，另一个来自本地文件系统——并且它们是独立的图表。
- en: Listing 10.3 chart.yaml, a chart that includes optional dependencies
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.3 chart.yaml，一个包含可选依赖项的图表
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You need to keep your charts flexible when you model dependencies. The *parent
    chart* (the Pi app, in this case) may require the *subchart* (the proxy and vweb
    charts), but subcharts themselves need to be standalone. You should template the
    Kubernetes manifests in a subchart to make it generically useful. If it’s something
    that is useful in only one application, then it should be part of that application
    chart and not a subchart.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当你建模依赖关系时，你需要保持你的图表灵活。*父图表*（在这个例子中是Pi应用程序）可能需要*子图表*（代理和vweb图表），但子图表本身需要是独立的。你应该在子图表中对Kubernetes规范进行模板化，使其具有通用性。如果它是仅在一个应用程序中有用的东西，那么它应该是该应用程序图表的一部分，而不是子图表。
- en: My proxy is generically useful; it’s just a caching reverse proxy, which can
    use any HTTP server as the content source. The chart uses a templated value for
    the name of the server to proxy, so although it’s primarily intended for the Pi
    app, it can be used to proxy any Kubernetes Service. We can verify that by installing
    a release that proxies an existing app in the cluster.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我的代理是通用的；它只是一个缓存反向代理，可以使用任何 HTTP 服务器作为内容源。图表使用模板化值来指定要代理的服务器名称，因此尽管它主要用于 Pi
    应用程序，但它也可以用来代理任何 Kubernetes 服务。我们可以通过安装一个代理现有集群中应用程序的发布来验证这一点。
- en: Try it now Install the proxy chart on its own, using it as a reverse proxy for
    the vweb app we installed earlier in the chapter.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 安装代理图，单独使用它作为我们在本章早期安装的 vweb 应用程序的反向代理。
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The proxy chart in that exercise is completely independent of the Pi app; it’s
    being used to proxy the web app I deployed with Helm from the Kiamol repository.
    You can see in figure 10.11 that it works as a caching proxy for any HTTP server.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个练习中的代理图完全独立于 Pi 应用程序；它被用来代理我从 Kiamol 仓库部署的 Helm 网络应用程序。您可以在图 10.11 中看到，它作为一个缓存代理为任何
    HTTP 服务器工作。
- en: '![](../Images/10-11.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/10-11.jpg)'
- en: Figure 10.11 The proxy subchart is built to be useful as a chart in its own
    right—it can proxy any app.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.11 代理子图被构建成可以作为图表本身使用——它可以代理任何应用程序。
- en: To use the proxy as a dependency, you need to add it in the dependency list
    in a parent chart, so it becomes a subchart. Then you can specify values for the
    subchart settings in the parent chart, by prefixing the setting name with the
    dependency name—the setting `upstreamToProxy` in the proxy chart is referenced
    as `proxy.upstreamToProxy` in the Pi chart. Listing 10.4 shows the default values
    file for the Pi app, which includes settings for the app itself and for the proxy
    dependency.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要将代理作为依赖项使用，您需要在父图表中的依赖项列表中添加它，使其成为一个子图。然后您可以在父图表中指定子图设置的值，通过在设置名称前加上依赖项名称——代理图中的
    `upstreamToProxy` 设置在 Pi 图表中引用为 `proxy.upstreamToProxy`。列表 10.4 显示了 Pi 应用的默认值文件，其中包括应用程序本身的设置和代理依赖项的设置。
- en: Listing 10.4 values.yaml, the default settings for the Pi chart
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.4 values.yaml，Pi 图表的默认设置
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: These values deploy the app itself without the proxy, using a LoadBalancer Service
    for the Pi Pods. The setting `proxy.enabled` is specified as the condition for
    the proxy dependency in the Pi chart, so the entire subchart is skipped unless
    the install settings override the default. The full values file also sets the
    `vweb.enabled` value to false—that dependency is there only to demonstrate that
    subcharts can be sourced from repositories, so the default is not to deploy that
    chart, either.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值部署应用程序本身而不使用代理，使用 LoadBalancer 服务为 Pi Pods 设置。`proxy.enabled` 设置被指定为 Pi 图表中代理依赖项的条件，因此除非安装设置覆盖默认值，否则整个子图将被跳过。完整的值文件还将
    `vweb.enabled` 值设置为 false——那个依赖项仅用于演示子图可以从存储库中获取，因此默认情况下也不部署该图表。
- en: There’s one extra detail to call out here. The name of the Service for the Pi
    app is templated in the chart, using the release name. That’s important to enable
    multiple installs of the same chart, but it adds complexity to the default values
    for the proxy subchart. The name of the server to proxy needs to match the Pi
    Service name, so the values file uses the same templated value as the Service
    name, and that links the proxy to the Service in the same release.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个额外的细节需要指出。Pi 应用的服务名称在图表中是使用发布名称模板化的。这对于启用同一图表的多个安装很重要，但它增加了代理子图默认值的复杂性。要代理的服务器名称需要与
    Pi 服务名称匹配，因此值文件使用与服务名称相同的模板化值，这将代理与同一发布中的服务链接起来。
- en: Charts need to have their dependencies available before you can install or package
    them, and you use the Helm command line to do that. Building dependencies will
    populate them into the chart’s charts folder, either by downloading the archive
    from a repository or packaging a local folder into an archive.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在您安装或打包图表之前，图表需要其依赖项可用，您使用 Helm 命令行来完成此操作。构建依赖项将它们填充到图表的 charts 文件夹中，无论是从存储库下载存档还是将本地文件夹打包成存档。
- en: Try it now Build the dependencies for the Pi chart, which downloads the remote
    chart, packages the local chart, and adds them to the chart folder.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 构建Pi图表的依赖项，它下载远程图表，打包本地图表，并将它们添加到图表文件夹中。
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Figure 10.12 shows why versioning is so important for Helm charts. Chart packages
    are versioned using the version number in the chart metadata. Parent charts are
    packaged with their dependencies, at the specified version. If I update the proxy
    chart without updating the version number, my Pi chart will be out of sync because
    version 0.1.0 of the proxy chart in the Pi package is different from the latest
    version 0.1.0\. You should consider Helm charts to be immutable and always publish
    changes by publishing a new package version.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.12 展示了为什么版本控制对于 Helm 图表来说如此重要。图表包使用图表元数据中的版本号进行版本控制。父图表与其依赖项一起打包，并指定版本。如果我没有更新代理图表的版本号，我的
    Pi 图表将不同步，因为 Pi 包中代理图表的版本 0.1.0 与最新版本 0.1.0 不同。您应该将 Helm 图表视为不可变的，并且始终通过发布新包版本来发布更改。
- en: '![](../Images/10-12.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10-12.jpg)'
- en: Figure 10.12 Helm bundles dependencies into the parent chart, and they are distributed
    as one package.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.12 Helm 将依赖项打包到父图表中，并作为一个包进行分发。
- en: This principle of conditional dependencies is how you could manage a much more
    complex application like the to-do app from chapter 8\. The Postgres database
    deployment would be a subchart, which users could skip altogether for environments
    where they want to use an external database. Or you could even have multiple conditional
    dependencies, allowing users to deploy a simple Postgres Deployment for dev environments,
    use a highly available StatefulSet for test environments, and plug into a managed
    Postgres service in production.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这种条件依赖的原则是您如何管理一个更复杂的应用程序，例如第 8 章中的待办事项应用。Postgres 数据库部署将是一个子图表，用户可以选择在需要使用外部数据库的环境中完全跳过。或者，您甚至可以有多个条件依赖，允许用户为开发环境部署简单的
    Postgres 部署，在测试环境中使用高度可用的 StatefulSet，并在生产环境中连接到管理的 Postgres 服务。
- en: The Pi app is simpler than that, and we can choose whether to deploy it on its
    own or with a proxy. This chart uses a templated value for the type of the Pi
    Service, but that could be computed in the template instead by setting it to LoadBalancer
    if the proxy is not deployed and ClusterIP if the proxy is deployed.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Pi 应用程序比这简单，我们可以选择是否单独部署它或与代理一起部署。此图表使用模板值来设置 Pi 服务的类型，但可以在模板中通过将其设置为 LoadBalancer（如果未部署代理）或
    ClusterIP（如果已部署代理）来计算它。
- en: Try it now Deploy the Pi app with the proxy subchart enabled. Use Helm’s `dry-run`
    feature to check the default deployment, and then use custom settings for the
    actual install.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 部署启用代理子图表的 Pi 应用程序。使用 Helm 的 `dry-run` 功能检查默认部署，然后使用自定义设置进行实际安装。
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You’ll see in this exercise that the `dry-run` flag is quite useful: it applies
    values to the templates and writes out all the YAML for the resources it would
    install, without deploying anything. Then in the actual installation, setting
    a couple of flags deploys an additional chart that is integrated with the main
    chart, so the application works as a single unit. My Pi calculation appears in
    figure 10.13.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在这次练习中看到 `dry-run` 标志非常有用：它将值应用到模板中，并输出它将安装的资源的所有 YAML，而不部署任何内容。然后在实际安装中，设置一些标志将部署一个与主图表集成的附加图表，因此应用程序作为一个单一单元运行。我的
    Pi 计算结果出现在图 10.13 中。
- en: '![](../Images/10-13.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10-13.jpg)'
- en: Figure 10.13 Installing a chart with an optional subchart by overriding default
    settings
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.13 通过覆盖默认设置安装带有可选子图表的图表
- en: 'There’s a whole lot of Helm that I haven’t made room for in this chapter, because
    there’s a level of complexity you need to dive into only if you bet big on Helm
    and plan to use it extensively. If that’s you, you’ll find Helm has the power
    to cover you. How’s this for an example: you can generate a hash from the contents
    of a ConfigMap template and use that as a label in a Deployment template, so every
    time the configuration changes, the Deployment label changes too, and upgrading
    your configuration triggers a Pod rollout.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我没有为 Helm 提供足够的空间，因为您需要深入了解 Helm 的复杂性，只有当您对 Helm 进行大量投资并计划广泛使用它时。如果您是这样的人，您会发现
    Helm 具有强大的功能来支持您。以下是一个例子：您可以从 ConfigMap 模板的内容生成哈希，并将其用作 Deployment 模板中的标签，这样每次配置更改时，Deployment
    标签也会更改，升级配置会触发 Pod 回滚。
- en: That’s neat, but it’s not for everybody, so in the next section, we’ll return
    to a simple demo app and look at how Helm smooths the upgrade and rollback process.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这很酷，但并不是适合每个人，所以在下一节中，我们将回到一个简单的演示应用，看看 Helm 如何简化升级和回滚过程。
- en: 10.4 Upgrading and rolling back Helm releases
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.4 升级和回滚 Helm 发布
- en: Upgrading an app with Helm doesn’t do anything special; it just sends the updated
    specs to Kubernetes, which rolls out changes in the usual way. If you want to
    configure the specifics of the rollout, you still do that in the YAML files in
    the chart, using the settings we explored in chapter 9\. What Helm brings to upgrades
    is a consistent approach for all types of resources and the ability to easily
    roll back to previous versions.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Helm 升级应用程序并没有什么特别之处；它只是将更新的规范发送到 Kubernetes，Kubernetes 会以通常的方式推出更改。如果你想要配置推出的具体细节，你仍然需要在图表中的
    YAML 文件中进行，使用我们在第 9 章中探讨的设置。Helm 带给升级的是对所有类型资源的一致方法以及轻松回滚到先前版本的能力。
- en: One other advantage you get with Helm is the ability to safely try out a new
    version by deploying an additional instance to your cluster. I started this chapter
    by deploying version 1.0.0 of the vweb app in my cluster, and it’s still running
    happily. Version 2.0.0 is available now, but before I upgrade the running app,
    I can use Helm to install a separate release and test the new functionality.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 还为你带来的一项其他优势是，通过在集群中部署额外的实例，你可以安全地尝试新版本。我开始本章时，在我的集群中部署了 vweb 应用程序的 1.0.0
    版本，它仍在愉快地运行。现在 2.0.0 版本已经可用，但在升级正在运行的应用程序之前，我可以用 Helm 安装一个单独的发布版本来测试新功能。
- en: Try it now Check that the original vweb release is still there, and then install
    a version 2 release alongside, specifying settings to keep the app private.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下。检查原始的 vweb 发布版本是否仍然存在，然后安装一个版本 2 的发布版本，并指定设置以保持应用程序私有。
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This exercise uses the parameters the chart supports to install the app without
    making it publicly available, using a ClusterIP Service type and a `port-forward`
    so the app is accessible only to the current user. The original app is unchanged,
    and I have a chance to smoke-test the new Deployment in the target cluster. Figure
    10.14 shows the new version running.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习使用图表支持的参数安装应用程序，而不使其公开可用，使用 ClusterIP 服务类型和 `port-forward`，这样应用程序就只能对当前用户可访问。原始应用程序没有改变，我有机会在目标集群中对新的
    Deployment 进行烟测试。图 10.14 显示了新版本正在运行。
- en: '![](../Images/10-14.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10-14.jpg)'
- en: Figure 10.14 Charts that deploy Services typically let you set the type, so
    you can keep them private.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.14 部署服务的图表通常允许你设置类型，因此你可以保持它们私有。
- en: Now I’m happy that the 2.0.0 version is good, I can use the Helm `upgrade` command
    to upgrade my actual release. I want to make sure I deploy with the same values
    I set in the previous release, and Helm has features to show the current values
    and to reuse custom values in the upgrade.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我很高兴 2.0.0 版本运行良好，我可以用 Helm 的 `upgrade` 命令升级我的实际发布版本。我想确保我使用与上一个发布中设置相同的值进行部署，并且
    Helm 有功能可以显示当前值并在升级中重用自定义值。
- en: Try it now Remove the temporary version 2 release, and upgrade the version 1
    release to the version 2 chart reusing the same values set on the current release.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下。删除临时的版本 2 发布版本，并将版本 1 发布版本升级到版本 2 图表，重用当前发布上设置的相同值。
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Oh dear. This is a particularly nasty issue that will take some tracking down
    to understand. The `reuse-values` flag tells Helm to reuse all the values set
    for the current release on the new release, but the version 2.0.0 chart includes
    another value, the type of the Service, which wasn’t set in the current release
    because it didn’t exist. The net result is that the Service type is blank, which
    defaults to ClusterIP in Kubernetes, and the update fails because that clashes
    with the existing Service spec. You can see this hinted at in the output in figure
    10.15.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀。这是一个特别棘手的问题，需要一些追踪才能理解。`reuse-values` 标志告诉 Helm 在新版本上重用为当前发布设置的 所有值，但 2.0.0
    版本的图表还包括另一个值，即 Service 的类型，因为在当前发布中它不存在，所以没有设置。最终结果是 Service 类型为空，默认为 Kubernetes
    中的 ClusterIP，更新失败是因为它与现有的 Service 规范冲突。你可以在图 10.15 的输出中看到这一点。
- en: '![](../Images/10-15.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10-15.jpg)'
- en: Figure 10.15 An invalid upgrade fails, and Helm can automatically roll back
    to the previous release.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.15 一个无效的升级失败，Helm 可以自动回滚到上一个版本。
- en: This sort of problem is where Helm’s abstraction layer really helps. You can
    get the same issue with a standard kubectl deployment, but if one resource update
    fails, you need to check through all the other resources and manually roll them
    back. Helm does that automatically with the `atomic` flag. It waits for all the
    resource updates to complete, and if any of them fails, it rolls back every other
    resource to the previous state. Check the history of the release, and you can
    see that Helm has automatically rolled back to version 1.0.0.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的问题正是Helm抽象层真正有帮助的地方。你可以在标准的kubectl部署中遇到同样的问题，但如果某个资源更新失败，你需要检查所有其他资源并手动回滚它们。Helm通过`atomic`标志自动执行此操作。它等待所有资源更新完成，如果其中任何一个失败，它将回滚其他所有资源到之前的状态。检查发布的历史，你可以看到Helm已自动回滚到版本1.0.0。
- en: Try it now Recall from chapter 9 that Kubernetes doesn’t give you much information
    on the history of a rollout-compare that to the detail you get from Helm.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试回滚。回想一下第9章中提到的Kubernetes在滚动更新历史方面提供的信息不多——将这一点与Helm提供的信息进行比较。
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'That command gets an exercise all to itself, because there’s a wealth of information
    that you just don’t get in the history for a standard Kubernetes rollout. Figure
    10.16 shows all four revisions of the release: the first install, a successful
    upgrade, a failed upgrade, and an automatic rollback.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 那个命令本身就是一个练习，因为你在标准的Kubernetes滚动更新历史中得不到这么多的信息。图10.16显示了发布的所有四个版本：第一次安装、一次成功的升级、一次失败的升级和自动回滚。
- en: '![](../Images/10-16.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/10-16.jpg)'
- en: Figure 10.16 The release history clearly links application and chart versions
    to revisions.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.16 发布历史清楚地将应用程序和图表版本链接到修订版。
- en: To fix the failed update, I can manually set all the values in the `upgrade`
    command or use a values file with the same settings that are currently deployed.
    I don’t have that values file, but I can save the output of the `get` `values`
    command to a file and use that in the upgrade, which gives me all my previous
    settings plus the defaults in the chart for any new settings.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复失败的更新，我可以手动设置`upgrade`命令中的所有值，或者使用具有当前部署相同设置的值文件。我没有那个值文件，但我可以将`get values`命令的输出保存到文件中，并在升级时使用它，这样我就有了所有之前的设置，以及任何新设置的图表中的默认值。
- en: Try it now Upgrade to version 2 again, this time saving the current version
    1 values to a file and using that in the `upgrade` command.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试升级到版本2，这次将当前版本1的值保存到文件中，并在`upgrade`命令中使用它。
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This upgrade succeeds, so the atomic rollback doesn’t kick in. The upgrade is
    actually effected by the Deployment, which scales up the replacement ReplicaSet
    and scales down the current ReplicaSet in the usual way. Figure 10.17 shows that
    the configuration values set in the previous release have been retained, the Service
    is listening on port 8010, and three Pods are running.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这次升级成功，所以原子回滚没有启动。升级实际上是通过Deployment实现的，它以常规方式扩展了替换ReplicaSet并缩减了当前ReplicaSet。图10.17显示了在之前版本中设置的配置值已保留，Service正在8010端口监听，并且有三个Pod正在运行。
- en: '![](../Images/10-17.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/10-17.jpg)'
- en: Figure 10.17 The upgrade succeeds by exporting the release settings to a file
    and using them again.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.17 通过将发布设置导出到文件并再次使用它们来实现升级成功。
- en: All that’s left is to try out a rollback, which is syntactically similar to
    a rollback in kubectl, but Helm makes it much easier to track down the revision
    you want to use. You’ve already seen the meaningful release history in figure
    10.16, and you can also use Helm to check the values set for a particular revision.
    If I want to roll back the web application to version 1.0.0 but preserve the values
    I set in revision 2, I can check those values first.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是尝试回滚，它在语法上与kubectl中的回滚类似，但Helm使跟踪你想要使用的修订版变得容易得多。你已经看到了图10.16中显示的有意义的发布历史，你也可以使用Helm来检查特定修订版设置的值。如果我想将Web应用程序回滚到版本1.0.0，但保留我在修订版2中设置的值，我首先可以检查那些值。
- en: Try it now Roll back to the second revision, which was version 1.0.0 of the
    app upgraded to use three replicas.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试回滚到第二个修订版，即应用程序的1.0.0版本升级到使用三个副本。
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You can see my output in figure 10.18, where the rollback is successful and
    the history shows that the latest revision is 6, which is actually a rollback
    to revision 2.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在图10.18中看到我的输出，回滚成功，历史显示最新修订版是6，实际上是一个回滚到修订版2。
- en: '![](../Images/10-18.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/10-18.jpg)'
- en: Figure 10.18 Helm makes it easy to check exactly what you’re rolling back to.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.18 Helm使检查你正在回滚到的确切内容变得容易。
- en: The simplicity of this example is good for focusing on the upgrade and rollback
    workflow, and highlighting some of the quirks, but it hides the power of Helm
    for major upgrades. A Helm release is an abstraction of an application, and different
    versions of the application might be modeled in different ways. A chart might
    use a ReplicationController in an early release, then change to a ReplicaSet and
    then a Deployment; as long as the user-facing parts remain the same, the internal
    workings become an implementation detail.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的简单性有助于集中精力在升级和回滚工作流程上，并突出一些怪癖，但它隐藏了 Helm 在重大升级中的强大功能。Helm 发布是一个应用程序的抽象，应用程序的不同版本可能以不同的方式建模。一个图表可能在早期版本中使用
    ReplicationController，然后改为 ReplicaSet，然后是 Deployment；只要用户界面部分保持不变，内部工作就变成了实现细节。
- en: 10.5 Understanding where Helm fits in
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.5 理解 Helm 的适用位置
- en: 'Helm adds a lot of value to Kubernetes, but it’s invasive—once you template
    your manifests, there’s no going back. Everyone on the team has to switch to Helm,
    or you have to commit to having multiple sets of manifests: pure Kubernetes for
    the development team and Helm for every other environment. You really don’t want
    two sets of manifests getting out of sync, but equally, Kubernetes itself is plenty
    to learn without adding Helm on top.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 为 Kubernetes 增加了大量价值，但它具有侵略性——一旦您模板化您的清单，就无法回头。团队中的每个人都必须切换到 Helm，或者您必须承诺拥有多套清单：开发团队的纯
    Kubernetes 和其他所有环境的 Helm。您真的不希望两套清单不同步，但同样，即使不添加 Helm，Kubernetes 本身也足够学习。
- en: Whether Helm fits in for you depends very much on the type of applications you’re
    packaging and the way your teams work. If your app is composed of 50+ microservices,
    then development teams might work on only a subset of the full app, running it
    natively or with Docker and Docker Compose, and a separate team owns the full
    Kubernetes deployment. In that environment, a move to Helm will reduce friction
    rather than increasing it, centralizing hundreds of YAML files into manageable
    charts.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 是否适合您在很大程度上取决于您打包的应用程序类型以及您团队的工作方式。如果您的应用程序由 50+ 个微服务组成，那么开发团队可能只处理整个应用程序的一个子集，以原生方式或使用
    Docker 和 Docker Compose 运行，而另一个团队负责完整的 Kubernetes 部署。在这种情况下，转向 Helm 将减少摩擦而不是增加摩擦，将数百个
    YAML 文件集中到可管理的图表中。
- en: A couple of other indicators that Helm is a good fit include a fully automated
    continuous deployment process—which can be easier to build with Helm—running test
    environments from the same chart version with custom values files, and running
    verification jobs as part of the deployment. When you find yourself needing to
    template your Kubernetes manifests—which you will sooner or later—Helm gives you
    a standard approach, which is better than writing and maintaining your own tools.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 其他一些表明 Helm 是一个好的选择包括一个完全自动化的持续部署流程——这可以通过 Helm 更容易地构建——使用相同的图表版本和自定义值文件运行测试环境，以及在部署过程中运行验证作业。当您发现自己需要模板化
    Kubernetes 清单——您迟早会这样做——Helm 给您提供了一个标准方法，这比编写和维护自己的工具要好。
- en: That’s all for Helm in this chapter, so it’s time to tidy up the cluster before
    moving on to the lab.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 本章关于 Helm 的内容就到这里，因此在进入实验室之前，需要整理集群。
- en: Try it now Everything in this chapter was deployed with Helm, so we can use
    Helm to uninstall it all.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看 本章中所有内容都是使用 Helm 部署的，因此我们可以使用 Helm 来卸载它们。
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 10.6 Lab
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.6 实验室
- en: 'It’s back to the to-do app again for the lab. You’re going to take a working
    set of Kubernetes manifests and package them into a Helm chart. Don’t worry—it’s
    not the full-on app from chapter 8 with StatefulSets and backup Jobs; it’s a much
    simpler version. Here are the goals:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 又回到了实验室的待办事项应用。您将从一个工作集的 Kubernetes 清单中提取并打包成 Helm 图表。不用担心——这并不是第 8 章中包含 StatefulSets
    和备份作业的完整应用程序；这是一个更简单的版本。以下是目标：
- en: Use the manifests in the `lab/todo-list` folder as the starting point (there
    are hints in the YAML for what needs templating).
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以 `lab/todo-list` 文件夹中的清单作为起点（YAML 中有关于需要模板化的提示）。
- en: Create the Helm chart structure.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 Helm 图表结构。
- en: Template the resource names and any other values that need to be templated so
    the app can run as multiple releases.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板化资源名称和其他需要模板化的值，以便应用程序可以作为多个发布运行。
- en: Add parameters for configuration settings to support running the app as different
    environments.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加配置设置的参数以支持以不同环境运行应用程序。
- en: Your chart should run as the Test configuration when installed with default
    values.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用默认值安装时，您的图表应运行为测试配置。
- en: Your chart should run as the Dev configuration when installed using the `lab/
    dev-values.yaml` values file.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用`lab/dev-values.yaml`值文件安装时，您的图表应运行为开发配置。
- en: 'If you’re planning on making use of Helm, you should really find time for this
    lab, because it contains the exact set of tasks you’ll need to do when you package
    apps in Helm. My solution is on GitHub for you to check in the usual place: [https://github.com/sixeyed/kiamol/blob/master/ch10/lab/README.md](https://github.com/sixeyed/kiamol/blob/master/ch10/lab/README.md).'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您打算使用 Helm，您真的应该为这个实验室腾出时间，因为它包含了您在 Helm 中打包应用程序时需要完成的精确任务集。我的解决方案在 GitHub
    上，您可以在通常的位置检查：[https://github.com/sixeyed/kiamol/blob/master/ch10/lab/README.md](https://github.com/sixeyed/kiamol/blob/master/ch10/lab/README.md).
- en: Happy Helming!
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 开心领导！
