- en: 2 That’s a good name
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 那是个好名字
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Names
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称
- en: Naming conventions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名约定
- en: Namespaces
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间
- en: The names that we give to items and concepts help us navigate the world and
    communicate with everyone else who shares it with us. The idea that names matter
    is even more important in the world of software development. Programming languages
    have keywords, grammar, and syntax that are generally a subset of a common, in-use
    language. In the case of Python, that language is English.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们给事物和概念取的名字帮助我们在这个世界中导航并与分享它们的其他人沟通。在软件开发的世界中，名字的重要性更为重要。编程语言有关键字、语法和语法定义，通常是一组常用语言的子集。在Python的情况下，这种语言是英语。
- en: For programming languages, this means we use a prescribed set of keywords, grammar,
    and syntax to create programs that will ultimately run. Naming elements in those
    programs, however, is entirely within your control, as you can draw from the rich
    set of English words and phrases to name the items you create in a program. You
    can even use strings of nonsense characters if that suits you. But should you?
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 对于编程语言来说，这意味着我们使用一组规定的关键字、语法和语法定义程序，这些程序最终会运行。然而，在那些程序中命名元素完全在你自己的控制之下，因为你可以从丰富的英语单词和短语中选取来命名你在程序中创建的项目。你甚至可以使用无意义的字符序列，如果这适合你的话。但你应该这样做吗？
- en: '“There are only two hard things in Computer Science: cache invalidation and
    naming things.”'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: “在计算机科学中，只有两件难事：缓存失效和命名事物。”
- en: The quote is attributed to Phil Karlton, a programmer with Netscape, the developer
    of the first widely used web browser. Putting aside cache invalidation, you might
    be thinking, “What’s so hard about naming things?” Let’s find out.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这句话归功于Phil Karlton，他是Netscape的一名程序员，也是第一个广泛使用的网络浏览器的开发者。抛开缓存失效不谈，你可能正在想，“命名事物有什么难的？”让我们来找出答案。
- en: 2.1 Names
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 名称
- en: Back when I first started writing code, one of the systems I worked on was based
    on Pascal. It was the first language I knew that allowed almost unlimited choice
    when it came to naming variables in the programs. One of the other young guys
    on the team created two global variables to test for True and False. He named
    them `cool` and `uncool`. At the time, we both thought this was pretty funny and
    made for some laughs when writing conditional statements and testing function
    return values.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我刚开始编写代码的时候，我参与的一个系统是基于帕斯卡的。这是我第一次了解到一种允许在程序中命名变量时几乎有无限选择的语言。团队中的另一位年轻小伙子创建了两全局变量来测试真和假。他给它们命名为`cool`和`uncool`。当时，我们都觉得这很有趣，在编写条件语句和测试函数返回值时，这让我们感到一些乐趣。
- en: Over time, those variable names were all over the code, losing their humorous
    quality and becoming more challenging to consider and maintain. What was the meaning
    of `cool` and `uncool`? If you didn’t know the actual value behind the symbol,
    were the meanings distinct or could they be more aligned with the English use
    of the words, which in many ways implied a range of meanings?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，这些变量名遍布代码中，失去了它们的幽默感，变得更加难以考虑和维护。`cool`和`uncool`的含义是什么？如果你不知道符号背后的实际值，这些含义是不同的，还是它们可能更多地与英语中单词的使用相一致，这在许多方面暗示了一个范围的意义？
- en: Naming something is a way for you and Python to share the identity of something.
    Usually, this means you want to identify a thing uniquely, so it’s distinct from
    all the other named things in a program. For example, Social Security numbers
    in the United States are given to people so they can uniquely identify themselves
    within the usage context of the country. This unique string of numbers helps people
    obtain employment, do their taxes, buy insurance, and do all kinds of other activities
    that require a nationally unique identifier.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 命名事物是你和Python共享事物身份的一种方式。通常，这意味着你想要唯一地标识一个事物，使其与程序中所有其他命名的事物区分开来。例如，美国的社会保障号码是分配给人们的，以便他们在国家的使用环境中唯一地识别自己。这个独特的数字序列帮助人们获得就业、纳税、购买保险以及进行所有需要国家唯一标识符的其他活动。
- en: Does this mean a Social Security number is a good name for a unique thing? Not
    really. Unless you have access to the systems that use the number, it’s entirely
    opaque. It conveys no information about the thing it’s identifying.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否意味着社会保障号码是一个独特事物的良好名称？其实不然。除非你能访问使用该号码的系统，否则它完全是不透明的。它传达不了任何关于它所标识的事物的信息。
- en: 'Let’s take this idea of unique names to another level. There are standardized
    identifiers called universally unique identifiers (UUIDs). A UUID is a sequence
    of characters that for all practical purposes is unique across the entire world.
    A sample UUID looks like this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个唯一命名的想法提升到另一个层次。存在一种称为通用唯一标识符（UUID）的标准标识符。UUID是一系列字符，在所有实际用途中，它在整个世界上都是唯一的。一个示例UUID看起来像这样：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can use Python’s built-in UUID module to create valid variable names based
    on UUID values:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用Python的内置UUID模块根据UUID值创建有效的变量名：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This would generate a valid Python variable name like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个有效的Python变量名，如下所示：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can create variable names this way to uniquely identify everything in your
    applications. These variable names would be unique within your entire application
    and across the known world.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用这种方式创建变量名来唯一标识你应用程序中的所有事物。这些变量名将在你的整个应用程序和已知世界中都是唯一的。
- en: Naming variables this way would also be a completely unusable naming convention.
    The variable name conveys absolutely no information about the thing it identifies.
    A variable name like this is also very long to type, impossible to remember, and
    unwieldy to use.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式命名变量也会是一个完全不可用的命名约定。变量名传达了关于其标识的事物的绝对信息。这样的变量名也特别长，难以记忆，且使用起来不方便。
- en: 2.1.1 Naming things
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.1 命名事物
- en: Naming things is not only about uniqueness but also about attaching information
    to named things. Trying to provide meaning to the name you assign, or as an indication
    of how the thing is used, adds meta information that’s very useful when developing
    Python programs. For example, if you name a variable `t` versus `total`, you’d
    have to examine the context of the surrounding code to know what `t` is, whereas
    `total` has a meaning that provides an understanding of how the variable is used.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 命名事物不仅关乎唯一性，还关乎将信息附加到命名的事物上。尝试为分配的名称提供意义，或作为事物使用方式的指示，为开发Python程序提供了非常有用的元信息。例如，如果你将变量命名为`t`而不是`total`，你将不得不检查周围代码的上下文来了解`t`是什么，而`total`的含义则提供了对变量如何使用的理解。
- en: Tip Creating useful variable names takes effort, but it’s effort well spent
    as a developer. You’ll find over time that variable names are difficult to change.
    This is because dependency on existing variables increases as an application is
    developed and used. Choosing good variable names avoids having to change a name
    down the road.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：创建有用的变量名需要付出努力，但对于开发者来说，这是一项值得付出的努力。随着时间的推移，你会发现变量名很难更改。这是因为随着应用程序的开发和使用，对现有变量的依赖性会增加。选择好的变量名可以避免将来需要更改名称。
- en: Based on the previous UUID example, the length of the name you give to something
    is also relevant to the effort of writing code. Programming does involve a lot
    of typing, which means the balance between meaning and brevity matters.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 根据之前的UUID示例，你给事物命名的长度也与编写代码的努力程度相关。编程确实涉及大量的输入，这意味着意义和简洁之间的平衡很重要。
- en: You’re suddenly in a position where an entire language is your hunting ground
    for words and phrases to name things. Your goal is to find words that attach meta
    information and yet are short enough to not get in the way of writing, or reading,
    a line of program code. This constrains what you could or should do when naming
    things. Like a painter working from a limited palette of colors, you can choose
    to be frustrated or get imaginative within that constraint and build something
    with artfulness and creativity.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你突然处于一个位置，整个语言都是你寻找用于命名事物的单词和短语的狩猎场。你的目标是找到既附加元信息又足够简短，不会妨碍编写或阅读程序代码的单词。这限制了你在命名事物时可以或应该做的事情。就像一个画家在一个有限的色彩调色板上工作一样，你可以选择感到沮丧或在这个限制内发挥想象力，用艺术性和创造力构建一些东西。
- en: 'Many of the programs you’ll write will include looping over a collection of
    things, counting things, and adding things together. Here’s an example of code
    iterating through a two-dimensional table:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你将要编写的许多程序将包括遍历事物集合、计数和将事物相加。以下是一个遍历二维表的代码示例：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This code is perfectly functional. The `t` variable consists of a Python list
    of lists, which represents a two-dimensional table. The `process_item()` function
    needs to know the row and column position of the item—the `it` variable—within
    the table to correctly process it. The variables `t`, `i`, `j`, `r`, and `it`
    are perfectly serviceable but give the reader no information about their intent.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码功能完全正常。变量 `t` 是一个包含列表的 Python 列表，它代表一个二维表格。`process_item()` 函数需要知道项目在表格中的行和列位置——即
    `it` 变量——以便正确处理它。变量 `t`、`i`、`j`、`r` 和 `it` 虽然完全可用，但并没有给读者提供关于它们意图的信息。
- en: 'You might be inclined to think it’s not a big deal for this example code but
    imagine if there were many more lines of code between each invocation of the `for`
    loop. In that case, the declaration of the `t`, `i`, `j`, `r`, and `it` variables
    are visually separated from their use. The reader would probably have to go back
    and find the declaration to understand the intent of the variable. Keep in mind
    that the reader could be you six months after writing this code when the meaning
    and intent are not so fresh in your mind. Here’s a better implementation of the
    code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为这个例子中的代码没有多大问题，但想象一下，如果每个 `for` 循环调用之间有更多行代码。在这种情况下，`t`、`i`、`j`、`r` 和
    `it` 变量的声明在视觉上与它们的用途分离。读者可能需要回过头来找到声明以理解变量的意图。记住，读者可能是你六个月后的自己，那时意义和意图可能不再那么清晰。以下是代码的更好实现：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The code has changed, so `t` is now `table`, `i` is `row_index,` `j` is `column_index`,
    `r` is `row`, and `it` is `item`. The variable names indicate what they contain
    and the meaning of their intended use. If the variable declarations are separated
    from their use by many lines of code, the reader can still quickly deduce what
    the variables mean and how to use them.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 代码已经更改，因此 `t` 现在是 `table`，`i` 是 `row_index`，`j` 是 `column_index`，`r` 是 `row`，而
    `it` 是 `item`。变量名称表明了它们包含的内容以及它们预期用途的意义。如果变量声明与它们的用途之间有大量代码，读者仍然可以快速推断出变量的含义以及如何使用它们。
- en: 'Another common operation in development is counting things and creating totals.
    Here are some simple examples:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 开发中另一个常见的操作是计数和创建总计。以下是一些简单的例子：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can see a couple of pretty good naming conventions in the previous example.
    The name `employees` gives the variable meaning. The use of the plural `employees`
    indicates it’s an iterable collection. It also shows that the collection has one
    or more things inside it that would represent an employee. The variable `employee`
    inside the list comprehension indicates it is a single item from within the `employees`
    collection.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在前面的例子中看到一些相当好的命名约定。名称 `employees` 给变量赋予了意义。使用复数 `employees` 表明它是一个可迭代的集合。它还表明集合中包含一个或多个代表员工的事物。列表推导式中的变量
    `employee` 表明它来自 `employees` 集合的单个项目。
- en: The variables `total_employees`, `total_parttime_employees`, and `total_ managers`
    indicate what they refer to by the use of `total` as part of their names. Each
    of them is a total count of something. The second part of each variable name indicates
    the thing being counted.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `total_employees`、`total_parttime_employees` 和 `total_managers` 通过在名称中使用
    `total` 来表明它们所指的内容。每个变量都是某种事物的总计。每个变量名称的第二部分表明了被计数的事物。
- en: 'Besides numerical calculations, you’ll often deal with things that have names
    already, like people within a company, community, or group. When you’re gathering
    user input or searching for someone by name, having a useful variable name makes
    it much easier to think about the thing you’re representing in code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 除了数值计算外，你经常会处理已经具有名称的事物，比如公司、社区或群体中的人。当你收集用户输入或按名称搜索某人时，一个有用的变量名称会使你更容易在代码中思考你所代表的事物：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Depending on the purpose of the code you’re writing, this might be a perfectly
    acceptable variable name to represent a person by name. Often, when working with
    people’s names, you’ll need more granularity and will want to represent a person’s
    name in parts:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你编写的代码的目的，这可能是一个完全可接受的变量名称来表示一个人的名字。通常，当与人们的名字一起工作时，你需要更多的粒度，并希望将一个人的名字分解表示：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'These variable names also work well and, like `full_name,` give the variable
    names meaning about what they represent. Here’s another variation:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量名称也工作得很好，并且像 `full_name` 一样，给变量名称赋予了它们所代表的意义。这里还有一个变体：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This version adopts a convention for how the variables are named. A convention
    like this means you’re choosing a pattern to create the variable names of people.
    Using a convention means the reader has to know and understand the convention
    in use. The tradeoff in the previous example is less typing but still a clear
    meaning of the variable name. It also might be more visually appealing, as the
    variable names line up vertically in a monospaced editing font.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本采用了一种变量命名的约定。这种约定意味着你选择一个模式来创建人的变量名。使用约定意味着读者必须知道并理解正在使用的约定。在先前的例子中，这种权衡是减少了输入量，但变量名仍然有清晰的意义。它也可能更具有视觉吸引力，因为变量名在等宽编辑字体中垂直排列。
- en: Adopting conventions is one technique for being more productive within the constraints
    of variable naming. If the shorthand naming convention is more visually appealing
    to you, this lends itself to recognizing patterns and identifying typos when visually
    parsing code.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 采用约定是提高在变量命名约束下生产力的一个技术。如果你觉得简写命名约定更具有视觉吸引力，这有助于在视觉解析代码时识别模式和识别错误。
- en: tip Establishing conventions and habits based on those conventions helps reduce
    the cognitive load on you as a developer. You can think more about the problem
    you’re trying to solve and less about what to name things.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：基于这些约定建立习惯有助于减轻作为开发者的认知负担。你可以更多地思考你试图解决的问题，而不是思考如何命名事物。
- en: 2.1.2 Naming experiment
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.2 命名实验
- en: You may not remember, but in the early days of personal computers, they had
    tiny hard drives. Early operating systems also had no concept of directories or
    subdirectories; all the files on the hard drive existed in one global directory.
    Additionally, filenames were limited to eight characters, the period character
    (.), and a three-character extension, which was generally used to indicate what
    the file contained.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能不记得，但在个人电脑的早期阶段，它们有很小的硬盘。早期的操作系统也没有目录或子目录的概念；硬盘上的所有文件都存在于一个全局目录中。此外，文件名限制为八个字符，点字符（.）和三个字符的扩展名，通常用来表示文件包含的内容。
- en: 'Because of this, bizarre and complex file-naming conventions were invented
    to maintain uniqueness and prevent filename collisions. These naming conventions
    came at the cost of logically meaningful filenames. An example of a possible resume
    file created in October 1995 would be something like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因，发明了一些奇特且复杂的文件命名约定来保持唯一性并防止文件名冲突。这些命名约定是以逻辑上有意义的文件名为代价的。一个可能的例子是1995年10月创建的简历文件，可能如下所示：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The solution to this problem was adding support to the operating system for
    named subdirectories and removing the filename character-length limit. Everyone
    is familiar with this now, as you’re able to create almost infinitely deep structures
    of directories and subdirectories.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方案是向操作系统添加对命名子目录的支持，并移除文件名字符长度限制。现在每个人都很熟悉这一点，因为你可以创建几乎无限深的目录和子目录结构。
- en: Experiment
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 实验
- en: 'Here’s a specification you’ve been asked to meet: the accounting department
    where you work requires all expense reports to have the same filename: `expenses.xlsx`.
    You need to create a directory structure where all your `expenses.xlsx` files
    can exist and not collide or overwrite each other to save and track these expense
    files.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个你被要求满足的规范：你工作的会计部门要求所有费用报告都使用相同的文件名：`expenses.xlsx`。你需要创建一个目录结构，以便所有你的`expenses.xlsx`文件可以存在，并且不会相互冲突或覆盖，以便保存和跟踪这些费用文件。
- en: The constraint is the requirement that all expense report files have a fixed
    filename. The implied constraint is that whatever directory structure you devise
    needs to work for as many expense reports as your work generates. The ability
    to create subdirectories is the tool you have to help solve this problem and keep
    the expense report files separated.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 约束是要求所有费用报告文件具有固定的文件名。隐含的约束是，无论你设计什么样的目录结构，它都需要适用于你工作产生的尽可能多的费用报告。创建子目录的能力是你用来帮助解决这个问题并保持费用报告文件分离的工具。
- en: Possible Solutions
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的解决方案
- en: Any solution depends on how many expense reports you create to do your job.
    If you’re working as a junior software developer, you might only travel a few
    times a year. In this case, you would only have to provide coarse granularity
    to keep your `expenses.xlsx` files separated. This simple structure gathers all
    the expense reports under a single root directory named `expenses` (figure 2.1).
    Each expense report exists in a directory named with the fully qualified date
    when the expense report was created. Using a date format of YYYY-MM-DD causes
    the directories to sort in a useful chronological order on many operating systems
    when displayed.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 任何解决方案都取决于你为了完成工作需要创建多少费用报告。如果你是一名初级软件开发人员，你可能一年只出差几次。在这种情况下，你只需要提供粗粒度来保持你的`expenses.xlsx`文件分开。这种简单的结构将所有费用报告收集在名为`expenses`的单个根目录下（图2.1）。每个费用报告都存在于以创建费用报告的完整日期命名的目录中。使用YYYY-MM-DD的日期格式，在许多操作系统中，当显示时，目录会以有用的时间顺序排序。
- en: '![](../../OEBPS/Images/CH02_F01_Farrell.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH02_F01_Farrell.png)'
- en: Figure 2.1 Simple directory structure to manage expense reports
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 管理费用报告的简单目录结构
- en: However, if you’re a sales engineer, you’re most likely traveling all the time
    and possibly meeting multiple clients per day. This changes how you handle the
    constraint and requires your directory structure to support much more granularity
    to keep all the `expenses.xlsx` files separate. A possible solution for a sales
    engineer would be to use the year, month, day, and client name values as subdirectories.
    Doing this allows you to keep the `expenses.xlsx` files distinct even when visiting
    multiple clients per day. This creates a convention where each part of the path
    to a particular `expenses.xlsx` file has meaning as well as a value. Figure 2.2
    illustrates this structure.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你是一名销售工程师，你很可能一直在出差，并且可能每天要见多个客户。这改变了你处理约束的方式，需要你的目录结构支持更多的粒度来保持所有`expenses.xlsx`文件分开。对于销售工程师的一个可能解决方案是使用年、月、日和客户名称值作为子目录。这样做可以让你在每天访问多个客户时保持`expenses.xlsx`文件的独立性。这创建了一个约定，即路径中每个特定`expenses.xlsx`文件的每个部分都具有意义和值。图2.2展示了这种结构。
- en: '![](../../OEBPS/Images/CH02_F02_Farrell.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH02_F02_Farrell.png)'
- en: Figure 2.2 A more involved directory structure that provides more granular file
    separation
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 提供更多细粒度文件分离的更复杂的目录结构
- en: It might not be evident based on the previous experiment, but what you’ve created
    are variable names that have meaning and convention. Look at the directory path
    to a particular expense report. You’ve created namespaces, each one narrowing
    the scope of what it contains. Reading the path from left to right, you see that
    each segment of the path separated by the / character creates a new, narrower
    namespace within the context of the previous one (figure 2.3).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 根据之前的实验，可能不明显，但你创建的是具有意义和约定的变量名。查看特定费用报告的目录路径。你已经创建了命名空间，每个命名空间都缩小了其包含内容的范围。从左到右阅读路径，你会看到路径中由/字符分隔的每个部分都在前一个上下文中创建了一个新的、更窄的命名空间（图2.3）。
- en: '![](../../OEBPS/Images/CH02_F03_Farrell.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH02_F03_Farrell.png)'
- en: Figure 2.3 The directory path creates a hierarchy of namespaces.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 目录路径创建了一个命名空间层次结构。
- en: Suppose you are the accountant who has mandated the file-naming convention for
    expense reports. As the accountant, you’ll have to save all the expense reports
    that employees submit. You’d be under the same constraint as the employees who
    are generating the expense reports, but with the added complexity of keeping all
    the employee expense reports distinct and separated from each other.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你是被授权制定费用报告命名规范的会计。作为会计，你需要保存所有员工提交的费用报告。你将面临与生成费用报告的员工相同的约束，但还要额外处理保持所有员工费用报告相互区分和独立的问题。
- en: Creating a directory structure to handle the added complexity could include
    higher-level abstractions of department and employee. Creating a directory structure
    providing this level of granularity to track and save all the employee expense
    reports is possible. Thinking about how to create the structure makes it clear
    that it’s time for the accounting department to rethink the file-naming requirements
    and constraints and design a better system.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个目录结构来处理增加的复杂性可能包括部门和员工的更高层次抽象。创建一个提供这种粒度的目录结构来跟踪和保存所有员工费用报告是可能的。思考如何创建结构使得会计部门重新思考文件命名要求和约束，并设计一个更好的系统变得清晰。
- en: 2.2 Namespaces
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 命名空间
- en: A namespace creates an abstraction containing other named things, including
    other namespaces. The name of the city or town where you live is an example. The
    city name provides a namespace containing all the people who live in that city.
    The city name may not be unique on its own, but within the context of the hierarchy
    it’s in—county, state, and so on—it would be.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间创建了一个包含其他命名事物的抽象，包括其他命名空间。你居住的城市或镇的名字就是一个例子。城市名称提供了一个命名空间，包含该城市所有居住的人。城市名称本身可能不是唯一的，但在它所在的层次结构（县、州等）的上下文中，它就是唯一的。
- en: Going further, the streets and roads where people live all have names. The street
    and road names become a namespace within the city namespace. For example, there
    are many streets named “Main Street” throughout the United States. However, there
    is usually only one Main Street in each city.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步来说，人们居住的街道和道路都有名字。街道和道路名称成为城市命名空间内的一个命名空间。例如，美国各地有许多名为“Main Street”的街道。然而，每个城市通常只有一个
    Main Street。
- en: 'This hierarchy of namespaces creates the convention of the United States mailing
    address. The full address for Janet Smith, working at the Empire State Building,
    might be something like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命名空间的层次结构创造了美国邮寄地址的约定。珍妮特·史密斯在帝国大厦工作的完整地址可能如下所示：
- en: Janet Smith
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Janet Smith
- en: Empire State Building, Suite 87A
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Empire State Building, Suite 87A
- en: 20 W 34th Street
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 20 W 34th Street
- en: New York, New York 10001
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: New York, New York 10001
- en: 'By convention, the mailing address namespace scope gets narrower reading from
    bottom to top. A software developer might remove redundant information and represent
    this address like the previous directory experiments in a left-to-right form:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，从下到上读取，邮寄地址命名空间的范围会越来越窄。软件开发者可能会删除冗余信息，并以左到右的形式表示这个地址，就像之前的目录实验一样：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here the city and state have been removed because the zip code contains that
    information. The namespace fields have been delimited with the `|` character because
    that character doesn’t appear in the address’s text. Continuing from left to right,
    you come to the final leaf node, the person to which the address applies.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，城市和州已经被删除，因为邮政编码包含了这些信息。命名空间字段已经被 `|` 字符分隔，因为这个字符不会出现在地址的文本中。从左到右继续，你将到达最终的叶节点，即地址适用的个人。
- en: tip The world is full of namespaces because it’s a useful convention to help
    us organize information. That usefulness applies to information we want to organize
    in our Python applications.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：世界上充满了命名空间，因为这是一种有用的约定，有助于我们组织信息。这种有用性适用于我们想要在 Python 应用程序中组织的信息。
- en: Like the directory structure experiment, reading from left to right, the scope
    of information contained within each distinct namespace gets narrower. Also, like
    the directory structure hierarchy, the position of each namespace follows a convention
    that gives each meaning.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 就像目录结构实验一样，从左到右读取，每个独立命名空间包含的信息范围会越来越窄。同样，就像目录结构层次一样，每个命名空间的位置遵循一种约定，赋予每个命名空间特定的意义。
- en: 2.3 Python namespaces
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 Python 命名空间
- en: The Python programming language provides the ability to create namespaces. Namespaces
    give you a great deal of power and control when handling the constraints of naming
    variables, giving them meaning, keeping them relatively short, and avoiding collisions.
    You do this by placing variable names in namespaces. Before you get to the point
    of creating namespaces of your own, let’s look at the one provided by the language.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Python 编程语言提供了创建命名空间的能力。命名空间在处理命名变量的约束、赋予它们意义、保持它们相对简短以及避免冲突时，为你提供了大量的权力和控制。你通过在命名空间中放置变量名来实现这一点。在你创建自己的命名空间之前，让我们看看语言提供的那个。
- en: 2.3.1 Built-ins level
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.1 内置级别
- en: When Python starts running an application, it creates a `builtins` namespace
    where `builtins` is the outermost namespace in Python and contains all of the
    functions you can access at any time. For example, the `print()` and `open()`
    functions exist in the `builtins` namespace.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Python 开始运行应用程序时，它会创建一个 `builtins` 命名空间，其中 `builtins` 是 Python 中的最外层命名空间，包含你可以在任何时候访问的所有函数。例如，`print()`
    和 `open()` 函数存在于 `builtins` 命名空间中。
- en: 'You can see what’s in the `builtins` namespace by entering this command at
    a Python interactive prompt:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在 Python 交互式提示符中输入以下命令来查看 `builtins` 命名空间中的内容：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This command runs the `dir` (directory) command on the `__builtins__` object.
    You’ll see all the exceptions and functions listed that are available everywhere
    in Python.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令在 `__builtins__` 对象上运行 `dir`（目录）命令。你将看到所有在 Python 任何地方都可以访问的异常和函数列表。
- en: You might not have thought about functions like `print()`, `open()`, and others
    as existing in a namespace, and you don’t have to to use them. The idea that they
    are in a namespace is useful as you learn more about creating your own namespaces
    and the scope of the objects within them.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能没有想过像 `print()`、`open()` 这样的函数存在于一个命名空间中，并且你不必这样做。当你更多地了解创建自己的命名空间以及其中对象的范围时，这个想法是有用的。
- en: 'There is something to keep in mind when working with the `builtins` namespace:
    it’s entirely possible to overwrite an object in a namespace with something of
    your own. For example, you could define a function like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理 `builtins` 命名空间时，有一点需要注意：在命名空间中用你自己的东西覆盖一个对象是完全可能的。例如，你可以定义一个像这样的函数：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Creating a function like this would be perfectly fine; however, the side effect
    of doing this is shadowing the `open()` function that’s already defined in the
    `builtins` namespace. It might make perfect sense for the program you’re writing
    to name your function `open()`, but shadowing Python’s `open()` function, and
    making it inaccessible, is probably not what you intended.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这样一个函数是完全可以接受的；然而，这样做的一个副作用是会覆盖掉在 `builtins` 命名空间中已经定义的 `open()` 函数。对于你正在编写的程序来说，将你的函数命名为
    `open()` 可能完全合理，但覆盖 Python 的 `open()` 函数并使其不可访问，可能并不是你的本意。
- en: 'You can handle this by creating your function as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下方式创建你的函数来处理这个问题：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The code works, but you’ve sacrificed brevity and simple meaning for uniqueness
    to avoid your function’s name colliding with Python’s `open()` function. Using
    a namespace provides a better solution.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 代码是可行的，但你为了避免你的函数名与 Python 的 `open()` 函数冲突而牺牲了简洁和简单的意义。使用命名空间提供了一个更好的解决方案。
- en: 2.3.2 Module level
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.2 模块级别
- en: The Python program file you create that starts your program running is considered
    the entry point for your program as a whole. When it starts, the objects in the
    `builtins` namespace are created and available anywhere in your Python programs.
    In Python, everything is an object—variables, functions, lists, dictionaries,
    classes—everything.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '你创建的启动程序运行的 Python 程序文件被认为是整个程序的入口点。当它启动时，`builtins` 命名空间中的对象被创建并可在你的 Python
    程序的任何地方使用。在 Python 中，一切都是对象——变量、函数、列表、字典、类——一切。 '
- en: Anything you create and name is also an object in the main program file and
    has the potential to collide with and overwrite the objects in `builtins` and
    other things you create and name. You can, and should, avoid this.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建并命名的任何内容也是主程序文件中的一个对象，并且有可能与 `builtins` 以及你创建并命名的其他对象发生冲突和覆盖。你可以，也应该避免这种情况。
- en: 'Breaking up your program code into multiple files containing logically grouped
    functionality is a useful convention to adopt. Doing so has the following benefits:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的程序代码拆分成包含逻辑分组功能的多个文件是一个有用的约定。这样做有以下好处：
- en: Keeps similar functionality together where it’s easier to contemplate
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将类似的功能集中在一起，使其更容易考虑
- en: Prevents program files from becoming too long to edit and manage reasonably
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止程序文件变得过长，难以合理编辑和管理
- en: Creates namespaces
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建命名空间
- en: 'Each Python code file creates a namespace for your use. Let’s say you create
    two functions named `add()` that have different behaviors, and you create a `main.py`
    file that looks like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Python代码文件都会为你创建一个命名空间。假设你创建了两个名为 `add()` 的函数，它们具有不同的行为，并且你创建了一个 `main.py`
    文件，其外观如下：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When you run this program, it won’t function the way you might think. There’s
    no way to indicate in the code which `add()` function is being called in the `print
    (add(12,` `12))` statement. When Python executes this code, it defines the first
    `add()` function and then immediately redefines it with the second, shadowing
    it and losing access to the first definition.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个程序时，它可能不会按你想象的方式运行。在代码中无法表明在 `print (add(12, 12))` 语句中调用的是哪个 `add()` 函数。当
    Python 执行此代码时，它定义了第一个 `add()` 函数，然后立即用第二个函数重新定义它，覆盖了它并失去了对第一个定义的访问。
- en: The behavior of the two functions is different; the first performs a mathematical
    addition on the two parameters, and the second performs a specialized `string`
    addition (concatenation) on the two parameters. However, as far as Python is concerned,
    the name of the function is the distinguishing feature. And because they are both
    defined in the same namespace, the second shadows the first and takes precedence.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 两个函数的行为不同；第一个在两个参数上执行数学加法，第二个在两个参数上执行专门的`字符串`加法（连接）。然而，在Python看来，函数的名称是区分特征。并且由于它们都在同一个命名空间中定义，第二个函数会覆盖第一个并具有优先级。
- en: 'To get both `add()` functions to exist, you need to create a namespace into
    which you can put one of the `add()` functions. To do this, create a `utility.py`
    file that looks like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要使两个`add()`函数都存在，你需要创建一个命名空间，可以将其中一个`add()`函数放入其中。为此，创建一个如下所示的`utility.py`文件：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then change your `main.py` file to this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将你的`main.py`文件更改为以下内容：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: When you run the `main.py` file, you get the intended output of
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行`main.py`文件时，你会得到预期的输出：
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Creating the `utility.py` file separates the two `add()` function definitions
    so they can both exist. In the `main.py` file, the import utility statement tells
    Python to pull all the objects in the `utility.py` file to a new namespace called
    `utility`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`utility.py`文件将两个`add()`函数定义分开，这样它们都可以存在。在`main.py`文件中，导入实用程序的语句告诉Python将`utility.py`文件中的所有对象拉入一个名为`utility`的新命名空间。
- en: 'Be aware that the namespace created by importing a file adds a namespace based
    on the base name of the file, which is the default behavior. You can override
    this default behavior in this way:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，通过导入文件创建的命名空间会基于文件的基本名称添加一个命名空间，这是默认行为。你可以通过以下方式覆盖此默认行为：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This statement tells Python to pull all the objects in the `utility.py` file
    into a namespace called `utils`. Being able to alias the namespace specifically
    can be a useful feature if you want to import two modules with the same name but
    maintain a unique namespace for each.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 此语句告诉Python将`utility.py`文件中的所有对象拉入一个名为`utils`的命名空间。如果你想要导入两个具有相同名称的模块但为每个模块维护一个唯一的命名空间，能够具体地别名命名空间可以是一个有用的功能。
- en: 'It’s also possible to mask a namespace when importing functionality. Using
    your current `main.py` example, it is done like this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以在导入功能时遮蔽命名空间。使用你当前的`main.py`示例，它这样做：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The code tells Python to pull all the objects in the `utility.py` file into
    the current namespace. This program now has an error in it because the utility
    namespace no longer exists, so the `print(utility.add(12,` `12))` statement doesn’t
    work. Removing `utility` from the print statement makes the program work, but
    you’re back to a variation of the original problem. The `add()` function defined
    in the `utility.py` file is shadowed by the `add()` function defined in the `main.py`
    file. For this reason, it’s usually not a good idea to use the `from` `<filename>`
    `import` `*` form when importing files.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 代码告诉Python将`utility.py`文件中的所有对象拉入当前命名空间。这个程序现在有一个错误，因为实用程序命名空间不再存在，所以`print(utility.add(12,
    12))`语句不起作用。从打印语句中移除`utility`可以使程序工作，但你回到了原始问题的变体。在`utility.py`文件中定义的`add()`函数被在`main.py`文件中定义的`add()`函数所遮蔽。因此，在导入文件时通常不建议使用`from
    `<filename>` `import` `*`形式。
- en: Being able to create namespaces based on files is useful, but Python’s support
    goes further. By capitalizing on the filesystem directory structure, you can create
    namespace hierarchies. Just like the previous directory structure naming experiment,
    this gives you more tools to create meaning and scope for the hierarchies you
    create.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 能够基于文件创建命名空间是有用的，但Python的支持更进一步。通过利用文件系统目录结构，你可以创建命名空间层次结构。就像之前的目录结构命名实验一样，这为你提供了更多创建层次结构意义和范围的工具。
- en: If you take your example a little further, you might decide to be more specific
    with the functionality you’re creating. The `utility.add()` function is specific
    to string handling, so why not make that clearer?
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将你的例子进一步扩展，你可能会决定更具体地说明你创建的功能。`utility.add()`函数是针对字符串处理的，那么为什么不使其更清晰呢？
- en: 'Create a new directory called `utilities` in the same folder as your `main.py`
    file. Move the `utility.py` file to the `utilities` directory and rename it `strings.py`.
    You now have a directory hierarchy that looks like this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在与你的`main.py`文件相同的文件夹中创建一个名为`utilities`的新目录。将`utility.py`文件移动到`utilities`目录，并将其重命名为`strings.py`。你现在有一个如下所示的目录层次结构：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This adds meaning just like the directory structure experiment does; `utilities`
    indicates that everything under the directory is considered a utility.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像目录结构实验一样增加了意义；`utilities` 表示目录下的所有内容都被视为工具。
- en: One thing to keep in mind when creating directory hierarchies to contain functionality
    is the need to create an `__init__.py` file. This file has to exist in each directory
    to let Python know the directory contains functionality or the path to it. When
    the `__init__.py` file exists in a directory, that directory is a Python package.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建目录层次结构以包含功能时，需要记住的是需要创建一个 `__init__.py` 文件。这个文件必须存在于每个目录中，以便让 Python 知道该目录包含功能或其路径。当
    `__init__.py` 文件存在于一个目录中时，该目录就是一个 Python 包。
- en: Often the `__init__.py` file is empty, but it doesn’t have to be. Any code inside
    the file is executed whenever the path containing it is part of an import statement.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`__init__.py` 文件是空的，但不必如此。文件内的任何代码都会在包含它的路径作为导入语句的一部分时执行。
- en: 'Based on this, create an empty `__init__.py` file in your `utilities` directory.
    Once that’s done, modify your `main.py` file like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这一点，在你的 `utilities` 目录中创建一个空的 `__init__.py` 文件。完成此操作后，按照以下方式修改你的 `main.py`
    文件：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `from utilities import strings` statement tells Python to navigate to the
    utilities package and pull all the objects from the `strings.py` file into the
    `strings` namespace. The `print(strings.add(12,` `12))` line has been changed
    to use the `strings` namespace to access the `add()` functionality. Now the namespace
    plus function name combine to increase the clarity and intention of the `add`
    function.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`from utilities import strings` 语句告诉 Python 导航到 `utilities` 包，并将 `strings.py`
    文件中的所有对象拉入 `strings` 命名空间。`print(strings.add(12, 12))` 行已被更改为使用 `strings` 命名空间来访问
    `add()` 功能。现在，命名空间加函数名结合在一起，增加了 `add` 函数的清晰度和意图。'
- en: When you create a Python file that you intend to import into other parts of
    your program, it’s common to think of the file as a module. The module contains
    functionality that’s useful to your program. This idea is very much like the “batteries
    included” statement that’s often associated with Python. Python comes with a large
    selection of standard modules you can import and use in your programs.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个打算导入到程序其他部分的 Python 文件时，通常会将该文件视为一个模块。该模块包含对程序有用的功能。这个想法与经常与 Python 联系的“包含电池”的说法非常相似。Python
    随带提供了一系列标准模块，你可以在程序中导入和使用。
- en: If you’ve used any of Python’s standard modules, like `sys`, you might notice
    those standard modules don’t exist in the working directory of your program like
    the `strings.py` module you created previously. Python searches for modules you
    want to import through a list of paths, the working directory being first.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用过 Python 的任何标准模块，比如 `sys`，你可能注意到那些标准模块并不像你之前创建的 `strings.py` 模块那样存在于你的程序的工作目录中。Python
    通过一系列路径来搜索你想要导入的模块，工作目录排在第一位。
- en: If you start a Python interpreter and at the prompt enter
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你启动 Python 解释器，并在提示符下输入
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'you’ll see output that looks something like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到类似以下的输出：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The output is the list of paths Python will search through when it runs across
    an `import` or `from` statement in your code. The list shown here is specific
    to my Mac; the listing you see will most likely be different depending on whether
    you’re using a Windows or Mac computer and whether you’re running Python in a
    virtual environment.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是 Python 在代码中遇到 `import` 或 `from` 语句时将搜索的路径列表。这里显示的列表特定于我的 Mac；你看到的列表很可能取决于你是否在使用
    Windows 或 Mac 计算机，以及你是否在虚拟环境中运行 Python。
- en: The first element in the list is an empty string. Python will look in the current
    working directory for modules. This is how it found the `utilities` package and
    the `strings` module in that package.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的第一个元素是一个空字符串。Python 将在当前工作目录中查找模块。这就是它找到 `utilities` 包以及该包中的 `strings` 模块的方式。
- en: It also means that if you create a module and name it identically to a Python
    system module, Python will find your package first and use it, ignoring the system
    package. When naming your packages and modules, keep this in mind.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着，如果你创建了一个模块，并且将其命名为与 Python 系统模块相同的名称，Python 将首先找到你的包并使用它，而忽略系统包。在命名你的包和模块时，请记住这一点。
- en: In our short example, the `import sys` statement causes Python to search the
    earlier-mentioned list of paths. Because a `sys` module doesn’t exist in your
    working directory, it looks in the other paths, where it does find the standard
    modules.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的简短示例中，`import sys` 语句导致 Python 搜索前面提到的路径列表。由于你的工作目录中没有 `sys` 模块，它会在其他路径中查找，并在那里找到了标准模块。
- en: The list of paths is used when you install a package or module with the `pip`
    command. The `pip` command will install the package in one of the paths from the
    list. As mentioned previously, using Python virtual environments is recommended
    to prevent `pip` from installing into your computer system’s version of Python.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `pip` 命令安装包或模块时，会使用路径列表。`pip` 命令将包安装到列表中的某个路径。如前所述，建议使用 Python 虚拟环境来防止 `pip`
    将包安装到你的计算机系统中的 Python 版本。
- en: 2.3.3 Function level
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.3 函数级别
- en: There are other levels of namespace control available to you. When you create
    a Python function, you’re creating a namespace for variable name creation. Another
    word used for this is *scope*. The functions you create exist in a module, either
    the main Python file of your program or separate module files.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你还有其他级别的命名空间控制可用。当你创建一个 Python 函数时，你正在创建一个用于变量名称创建的命名空间。另一个用于这个的词是 *作用域*。你创建的函数存在于一个模块中，无论是你的程序的主
    Python 文件还是单独的模块文件。
- en: 'The module file creates a namespace, and any functions you create in the module
    exist within that namespace. What does this mean? Take your `strings.py` module
    and make the following changes to it:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 模块文件创建了一个命名空间，你在模块中创建的任何函数都存在于这个命名空间中。这意味着什么？请将你的 `strings.py` 模块进行以下更改：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: These changes create a variable named `prefix` at the module-level namespace
    and initialize it with the string `"added."`
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改在模块级别的命名空间中创建了一个名为 `prefix` 的变量，并将其初始化为字符串 `"added."`
- en: 'If you run your main program, you’ll see the output of the `strings.add(12,
    12)` now outputs `added: 12 12`. When the `add()` function is executed, Python
    looks for the `prefix` variable inside the function namespace and, not finding
    one, looks at the module-level namespace. It finds the `prefix` variable in the
    module and uses it in the string formatting returned by the function.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你运行你的主程序，你会看到 `strings.add(12, 12)` 的输出现在为 `added: 12 12`。当 `add()` 函数执行时，Python
    在函数作用域内寻找 `prefix` 变量，没有找到后，它会查看模块级别的命名空间。它在模块中找到了 `prefix` 变量，并使用它来格式化函数返回的字符串。'
- en: 'Change the `strings.py` code again and make it look like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 再次更改 `strings.py` 代码，使其看起来像这样：
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Inside the `add()` function, you’ve created a variable named `prefix` and initialized
    it to a different string. If you rerun your code, you’ll see the output of the
    `strings .add(12,` `12)` function outputs `inside added:` `12` `12`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `add()` 函数内部，你创建了一个名为 `prefix` 的变量并将其初始化为不同的字符串。如果你重新运行你的代码，你会看到 `strings
    .add(12,` `12)` 函数的输出为 `inside added:` `12` `12`。
- en: What’s happening here is that Python now finds the `prefix` variable in the
    `add()` function’s local namespace and uses it. Not only is the `prefix` variable
    defined inside the `add()` function’s namespace, but it’s also created in the
    function’s scope. We’ll talk about scope more in the next section.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的情况是，Python 现在在 `add()` 函数的局部命名空间中找到了 `prefix` 变量并使用了它。不仅 `prefix` 变量在 `add()`
    函数的命名空间内定义，而且它也是在函数的作用域中创建的。我们将在下一节中更多地讨论作用域。
- en: 2.3.4 Namespace scope
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.4 命名空间作用域
- en: Names and namespaces are essential in your Python toolbox and are related to
    another tool as implied in the previous section. The scope of a variable is an
    important consideration when creating and using variables.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 名称和命名空间在 Python 工具箱中至关重要，并且与前面章节中暗示的另一个工具相关。在创建和使用变量时，变量的作用域是一个重要的考虑因素。
- en: 'The scope of a variable relates to its accessibility and lifetime in a module—a
    Python file. In Python, a variable is created when a value is assigned to it:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的作用域与其在模块（Python 文件）中的可访问性和生命周期相关。在 Python 中，当给变量赋值时创建变量：
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This statement creates the variable `prefix` and assigns it the string value
    `"prefix"`. The variable `prefix` also has a type of string, which Python determines
    at the time of assignment from the object being assigned—in this case, `"prefix"`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语句创建了变量 `prefix` 并将其赋值为字符串值 `"prefix"`。变量 `prefix` 也是一个字符串类型，Python 在赋值时根据被赋值的对象确定类型——在这种情况下，是
    `"prefix"`。
- en: If the prefix variable was created in a function
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前缀变量是在函数中创建的
- en: '[PRE27]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: the `prefix` variable would be within the scope of the `print_prefix()` function
    and would exist only when that function is running. Any code outside of the function
    that tried to access the `prefix` variable would generate an exception.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`prefix` 变量将位于 `print_prefix()` 函数的作用域内，并且仅在函数运行时存在。任何尝试在函数外部访问 `prefix` 变量的代码都会引发异常。'
- en: 'Let’s say you create a new module file named `message.py` that looks like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你创建了一个名为 `message.py` 的新模块文件，其外观如下：
- en: '[PRE28]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You created things that have different scopes and lifetimes. The `prefix` variable
    is in the global module scope. It is accessible anywhere within the `message.py`
    module. It also has the same lifetime as the module.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建了具有不同范围和生命周期的东西。`prefix` 变量位于全局模块范围。它在 `message.py` 模块内的任何地方都可以访问。它也具有与模块相同的生命周期。
- en: In this context, *lifetime* means from the point in the application where the
    module is imported to when the application is exited. It is possible to remove
    a module and reimport it, but in practice, this is rarely necessary.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中，*生命周期* 指的是从模块导入应用程序的点开始，到应用程序退出时为止。可以删除模块并重新导入它，但在实践中，这很少是必要的。
- en: 'If you use `import message` in your code, the `prefix` variable and `my_message`
    function are around for as long as the message module is. It is still within the
    message namespace and would be accessible to programs that import it like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 `import message` 在你的代码中，`prefix` 变量和 `my_message` 函数将存在于消息模块存在的时间内。它仍然在消息命名空间内，并且可以被像这样导入的程序访问：
- en: '[PRE29]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The variables defined inside the `my_message(text)` function have function-level
    scope. This means they are only accessible within the function, and their lifetime
    is from the point of their creation to the end of the function statements.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `my_message(text)` 函数内部定义的变量具有函数级范围。这意味着它们只能在函数内部访问，它们的生命周期从创建点到函数语句的结束。
- en: Because the `my_message(text)` function is contained within the module-level
    scope, the code within the function can access the `prefix` module variable. At
    the module scope, what’s declared at that level is accessible—the `prefix` and
    `my_ message` functions. The `my_message` function is part of the module-level
    (global) scope, but all the variables declared inside the function are not.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `my_message(text)` 函数包含在模块级作用域内，所以函数内的代码可以访问 `prefix` 模块变量。在模块作用域中，在该级别声明的声明是可访问的——`prefix`
    和 `my_message` 函数。`my_message` 函数是模块级（全局）作用域的一部分，但函数内部声明的所有变量都不是。
- en: Inside the `my_message` function, the two variables `text` and `new_message`
    are accessible as they are in the local function scope but aren’t accessible outside
    the function. The module variable `prefix` is in the global scope and is also
    accessible inside the function.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `my_message` 函数内部，两个变量 `text` 和 `new_message` 可以像在局部函数范围内一样访问，但函数外部无法访问。模块变量
    `prefix` 位于全局范围，并在函数内部也可以访问。
- en: The previous program shows that the scope is nested. Inner scopes have access
    to outer scopes that enclose them, as demonstrated by the `my_message` function
    having access to the `prefix` variable. Outer scopes do not have access to the
    inner scopes they enclose. Figure 2.4 shows this scope nesting.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的程序表明作用域是嵌套的。内部作用域可以访问包围它们的内部作用域，正如 `my_message` 函数可以访问 `prefix` 变量所展示的那样。外部作用域无法访问它们所包围的内部作用域。图
    2.4 展示了这种作用域嵌套。
- en: '![](../../OEBPS/Images/CH02_F04_Farrell.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH02_F04_Farrell.png)'
- en: Figure 2.4 How the scopes nest inside one another and where in a scope a variable
    is visible
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 作用域如何相互嵌套以及变量在作用域中的可见位置
- en: Social namespaces
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 社会命名空间
- en: Programming namespaces and scopes can be compared to the people we know who
    are from various parts of our lives. Let’s say you have a friend named Mary, and
    you also work with someone named Mary. If you’re with friends and someone mentions
    “Mary,” you would most likely think about your friend; she is in your local scope.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 编程命名空间和作用域可以与我们生活中来自各个部分认识的人进行比较。比如说，你有一个叫玛丽的女性朋友，你也在和一个叫玛丽的同事一起工作。如果你和朋友们在一起，有人提到“玛丽”，你很可能会想到你的朋友；她处于你的局部作用域。
- en: However, if someone says, “How’s that person you work with doing; Mary I think
    her name is?” In that case, you would think of the Mary you work with because
    the context was changed by the question to the work module scope.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果有人说，“你工作的那个人怎么样；玛丽，我想她的名字是？”在这种情况下，你会想到你工作的玛丽，因为问题改变了上下文，使其变为工作模块作用域。
- en: 2.3.5 Namespace experiment
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.5 命名空间实验
- en: Using what you’ve learned about names and namespaces, try this experiment using
    the information provided to solve a problem. This problem is about using meaningful
    names and namespaces to solve an otherwise awkward development problem.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你所学的关于名称和命名空间的知识，尝试使用提供的信息进行这个实验来解决一个问题。这个问题是关于使用有意义的名称和命名空间来解决一个本应尴尬的开发问题。
- en: Experiment
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 实验
- en: You’re the developer in charge of maintaining the software for an online community
    of users interested in similar things. The community wants the software to email
    them about upcoming events and to include noncommunity members who register to
    receive event emails. This latter group consists of potential new members who
    are interested but not yet committed to joining.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你是负责维护一个对类似事物感兴趣的在线用户社区的软件的开发者。该社区希望软件能够通过电子邮件通知他们即将发生的事件，并包括那些注册接收事件电子邮件的非社区成员。后者包括对加入感兴趣但尚未承诺加入的潜在新成员。
- en: The software can send personalized emails to the mailing list of registered
    users, both members and nonmembers. When creating the personalized email, the
    current software calls a function `get_name(person)` to obtain the name to render
    into the email based on the `person` object passed to it.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 软件可以向注册用户的邮件列表发送个性化的电子邮件，包括成员和非成员。在创建个性化电子邮件时，当前软件调用一个名为`get_name(person)`的函数，根据传递给它的`person`对象获取要渲染到电子邮件中的名称。
- en: 'The community wants to change how personalized email is rendered by creating
    a concept of “formal,” “informal,” and “casual” for the name. The email sent to
    nonmembers would always use the formal version. The email sent to members would
    base the name on the user’s account settings and could use any of the three levels
    of formality. This becomes your requirement: make the logically named `get_name
    (person)` function return three different values for three different use cases.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 社区希望通过为名称创建“正式”、“非正式”和“随意”的概念来改变个性化电子邮件的渲染方式。发送给非成员的电子邮件将始终使用正式版本。发送给成员的电子邮件将基于用户的账户设置，可以使用任何三个正式程度的级别。这成为你的要求：使逻辑命名的`get_name(person)`函数针对三种不同的用例返回三个不同的值。
- en: Possible Solution
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的解决方案
- en: 'One possible solution is to create three new versions of the `get_name(person)`
    function like this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可能的解决方案是创建三个新的`get_name(person)`函数版本，如下所示：
- en: '[PRE30]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This code is understandable and direct but is awkward to use in the rest of
    the application currently calling `get_name(...)`. Using this approach requires
    you to modify every instance of a call to `get_name(...)` to be an `if/elif/else`
    conditional to call the correct function. You’d also have to make the conditional
    information that selects the right function available for those `if/elif/else`
    condition tests.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码易于理解且直接，但在当前调用`get_name(...)`的应用程序中却显得有些笨拙。使用这种方法需要你修改每个`get_name(...)`调用的实例，将其改为`if/elif/else`条件语句以调用正确的函数。你还需要为这些`if/elif/else`条件测试提供选择正确函数的条件信息。
- en: 'Another approach would be to change the `get_name(person)` function to take
    an additional parameter that indicates how to format the response. Something like
    this would work:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是将`get_name(person)`函数修改为接受一个额外的参数，该参数指示如何格式化响应。如下所示，这种方法是可行的：
- en: '[PRE31]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this example, the variable `tone` is a string theoretically set to `formal`,
    `informal`, or `casual`. The value of `tone` would be used to format the name
    in an expected manner.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，变量`tone`是一个理论上设置为`formal`、`informal`或`casual`的字符串。`tone`的值将用于以预期的格式格式化名称。
- en: This example would also work but is only a marginal improvement over the individually
    named functions. Choosing this method requires you to find and edit every instance
    where the `get_name(...)` function is called in the entire program and update
    it to include the new `tone` parameter. If the function is used in many places,
    this could become a maintenance headache.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子也可以工作，但只是对单独命名的函数的微小改进。选择这种方法需要你找到并编辑整个程序中调用`get_name(...)`函数的每个实例，并将其更新为包括新的`tone`参数。如果函数被用在很多地方，这可能会成为一个维护难题。
- en: The use of namespaces creates a workable solution that doesn’t disrupt the other
    parts of the software. Rather than change the name signature of the `get_name(person)`
    function, or change its parameter list, you could use namespaces.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命名空间可以创建一个可行的解决方案，而不会干扰软件的其他部分。你不必更改`get_name(person)`函数的名称签名或其参数列表，可以使用命名空间。
- en: 'As a contrived example, here is a `main.py` program that simulates sending
    out an email to the community, before accounting for the required changes:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个虚构的例子，以下是一个模拟在考虑必要的更改之前向社区发送电子邮件的`main.py`程序：
- en: '[PRE32]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `get_name(person)` function from the `names.py` module might look like
    this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`names.py`模块中的`get_name(person)`函数可能如下所示：'
- en: '[PRE33]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This function looks at the `person` information and, depending on whether the
    person has a title value or not, formats the name accordingly and returns it.
    The `get_name(person)` function is the formal version and can be used as is.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数查看`person`信息，并根据该人是否有头衔值来相应地格式化姓名并返回它。`get_name(person)`函数是正式版本，可以直接使用。
- en: 'The change requirements are to create a formal, informal, and casual greeting
    for the emails based on the tone determined by the account. You already have a
    formal version of the `get_name(person)` function and just need to create the
    informal and casual versions. Create a module file called `informal.py` in the
    utilities package directory that looks like this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 更改要求是创建基于账户确定的语气的正式、非正式和随意问候语。你已经有了`get_name(person)`函数的正式版本，只需要创建非正式和随意版本。在工具包目录中创建一个名为`informal.py`的模块文件，代码如下：
- en: '[PRE34]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This function concatenates the first and last name and leaves out the title.
    Create another module called `casual.py` in the utilities package directory that
    looks like this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将姓名的首字母和姓氏连接起来，并省略了头衔。在工具包目录中创建另一个名为`casual.py`的模块，其代码如下：
- en: '[PRE35]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This function returns the person’s first name and nothing more.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数返回人的名字，不包含其他信息。
- en: Based on the change requirements, you also need to create a way to define the
    tone to use in the email based on the community members’ account information.
    The information to examine is whether or not they are a member and, if they are
    a member, what the greeting setting is in the account.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 根据更改要求，你还需要创建一种方法来根据社区成员的账户信息定义在电子邮件中使用的语气。需要检查的信息是，他们是否是成员，如果是成员，账户中的问候设置是什么。
- en: 'For this experiment, you can create an `account.py` module in the `utilities`
    package directory. The `account.py` module contains the following code:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个实验，你可以在`utilities`包目录中创建一个名为`account.py`的模块。`account.py`模块包含以下代码：
- en: '[PRE36]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This code returns a randomly selected value from the list of tone strings—"`formal`",
    "`informal`", and "`casual`." In a real application, the tone would probably be
    retrieved from a database table containing information about the users.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码从包含语气字符串列表（`"formal"`、`"informal"`和`"casual"`）中随机选择一个值。在实际应用中，语气可能从包含有关用户信息的数据库表中检索。
- en: 'Now you have everything you need to meet the requirements and change how the
    mailing list is processed. Here’s an updated listing of the `main.py` program,
    showing how the namespaces you’ve created are used:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经拥有了满足要求并改变邮件列表处理方式所需的一切。以下是更新后的`main.py`程序列表，展示了你创建的命名空间是如何被使用的：
- en: '[PRE37]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This version of the `main.py` program imports the three new modules, `informal`,
    `casual`, and `account`. At the top of the community iteration, the tone is retrieved
    according to the person passed to the `account.get_tone(person)` function call.
    The `tone` variable is used in an `if/elif/else` set of statements to set the
    `get_name` variable.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 此版本的`main.py`程序导入了三个新模块，`informal`、`casual`和`account`。在社区迭代顶部，根据传递给`account.get_tone(person)`函数调用的`person`，检索语气。`tone`变量用于`if/elif/else`语句集中来设置`get_name`变量。
- en: Notice the `get_name` variable is set to the `get_name` function from a specific
    module depending on the value of the tone. The code sets the `get_name` variable
    to refer to a function; it does not call the function. Now that `get_name` is
    a function object, it can be used as a function in the `print(get_name(person))`
    statement. The `get _name(person)` function call will get the right result because
    it refers to the desired module’s `get_name(person)` function at each iteration
    when the `tone` variable is set.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`get_name`变量根据语气的值设置为特定模块中的`get_name`函数。代码将`get_name`变量设置为引用一个函数；它并没有调用该函数。现在`get_name`是一个函数对象，它可以在`print(get_name(person))`语句中作为函数使用。`get
    _name(person)`函数调用将得到正确的结果，因为它在每次迭代时都引用了在设置`tone`变量时所需模块的`get_name(person)`函数。
- en: All of this work up front to create the modules and the code within them was
    done to avoid losing a good logical name like the `get_name` function and allow
    it to be used unchanged anywhere else in the program. The work also prevents name
    conflicts through the use of namespaces.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些前期工作，包括创建模块及其内部的代码，都是为了避免丢失像`get_name`函数这样的良好逻辑名称，并允许它在程序的其他地方不变地使用。这项工作还通过使用命名空间来防止名称冲突。
- en: Summary
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: How we name things has an important and lasting effect on the way we think about
    the applications we’re developing. It’s well worth spending time thinking about
    the names we choose.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何命名事物对我们思考正在开发的应用程序的方式有着重要且持久的影响。花时间思考我们选择的名称是非常值得的。
- en: Namespaces are a way to provide context for other things we name. Because a
    namespace is another thing we name to contain and give our applications structure,
    the same consideration applies to naming them.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间是提供其他命名事物上下文的一种方式。因为命名空间是我们命名以包含和为我们的应用程序提供结构的另一个事物，所以对它们的命名同样适用相同的考虑。
- en: Namespaces create hierarchal structures, creating parent, child, and sibling
    relationships that help architect Python applications.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间创建层次结构，建立父级、子级和兄弟关系，有助于构建Python应用程序。
- en: Python has multiple means to create namespaces that help complex applications
    coexist and become simpler using convenient names without conflict.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python有多种创建命名空间的方法，这有助于复杂的应用程序共存，并通过使用方便的名称来简化它们，从而避免冲突。
