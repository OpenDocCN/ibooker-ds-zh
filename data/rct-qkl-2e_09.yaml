- en: 9 Working with forms in React
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 在React中处理表单
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Defining forms and form elements
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义表单和表单元素
- en: Capturing changes to form data
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获表单数据的变化
- en: Updating data in form elements
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在表单元素中更新数据
- en: Accessing form elements through events and references
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过事件和引用访问表单元素
- en: Using controlled or uncontrolled inputs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用受控或未受控输入
- en: 'Imagine the web without forms: You can’t log in anywhere. You can’t order anything
    in a web shop. You can’t chat with anyone. And, you can’t even complain about
    it because there’s no contact form!'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个没有表单的网页：你无法在任何地方登录。你无法在网店中订购任何东西。你无法与任何人聊天。甚至，你都无法抱怨，因为没有联系表单！
- en: Forms are the backbone of many interactive web applications. Forms, and form
    elements in particular, are the primary way to capture user input in input fields,
    check boxes, drop-downs, file uploads, and a bunch more related elements.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 表单是许多交互式Web应用的骨架。特别是表单元素，是捕获用户输入（在输入字段、复选框、下拉菜单、文件上传以及更多相关元素中）的主要方式。
- en: Because forms are so important, any decent web framework has to support handling
    form data. React is very capable of dealing with forms. In fact, proper handling
    of form data was one of the earliest priorities in the React codebase because
    it was essential for the work React was developed for.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 由于表单非常重要，任何合格的Web框架都必须支持处理表单数据。React在处理表单方面非常强大。实际上，正确处理表单数据是React代码库中最早优先考虑的事项之一，因为这对于React开发的工作至关重要。
- en: You can work with forms in React in one of two ways. You can let React control
    the state of the form and store the current values in the component state, which
    is the recommended and primary way. It’s the recommended way because you keep
    the logic and data flow inside React. Having your React application be in control
    of your entire application is often preferred over handing out control to other
    parties or applications. In this instance, you take control from the browser’s
    automatic form handling and let React deal with it.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过两种方式在React中处理表单。你可以让React控制表单的状态，并将当前值存储在组件状态中，这是推荐和主要的方式。这是推荐的方式，因为你可以将逻辑和数据流保持在React内部。让你的React应用控制整个应用通常比将控制权交给其他方或应用更受欢迎。在这种情况下，你从浏览器的自动表单处理中接管控制权，让React来处理。
- en: Alternatively, you can let HTML have the responsibility of the form state and
    only read it in React when required. This has the benefit of using the browser’s
    built-in form handling, but it comes with a loss of control in your application.
    An uncontrolled input value is at the mercy of the user and the browser. Your
    application can’t (easily) force it to conform to any rules you might want to
    apply.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以让HTML负责表单状态，并在React需要时才读取它。这样做的好处是利用了浏览器内置的表单处理功能，但这也意味着你在应用中会失去一些控制权。未受控的输入值完全受用户和浏览器支配。你的应用无法（轻易地）强制它遵守你可能想要应用的任何规则。
- en: We call these two options *controlled* and *uncontrolled*, respectively. We’ll
    dig into what those two different modes entail and how they affect your options
    and your architecture in this chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这两个选项分别称为“受控”和“未受控”。在本章中，我们将深入探讨这两种不同模式包含的内容以及它们如何影响你的选项和架构。
- en: By the end of this chapter, you’ll be able to create complex forms with all
    sorts of inputs, including text fields, date fields, number inputs, ranges, buttons,
    and dropdowns. Figure 9.1 shows a full list of all the input variants that you
    can use in React, and, by the end of this chapter, you’ll be able to wield all
    of them in your React applications. You’ll also be able to spot the instances
    where an uncontrolled form might be better than the default of using a controlled
    form, although those instances are likely rare.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够创建包含各种输入（包括文本字段、日期字段、数字输入、范围、按钮和下拉菜单）的复杂表单。图9.1显示了React中可以使用的所有输入变体的完整列表，到本章结束时，你将能够在React应用中使用它们。你还将能够识别出未受控表单可能比默认的受控表单更好的情况，尽管这些情况可能很少见。
- en: '![09-01](../Images/09-01.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![09-01](../Images/09-01.png)'
- en: Figure 9.1 All the different HTML input controls that you can also use in React
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 所有可以在React中使用的不同HTML输入控件
- en: Note The source code for the examples in this chapter is available at [https://rq2e.com/ch09](https://rq2e.com/ch09).
    But as you learned in chapter 2, you can instantiate all the examples directly
    from the command line using a single command.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本章中示例的源代码可在[https://rq2e.com/ch09](https://rq2e.com/ch09)找到。但正如你在第二章中学到的，你可以使用单个命令直接从命令行实例化所有示例。
- en: 9.1 Controlled vs. uncontrolled inputs
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1 受控与非受控输入
- en: When an input is controlled, React is in charge of what gets displayed. React
    has to “confirm” that a given change to the input value is going to cause the
    input to change. When an input is uncontrolled, the input changes based on the
    user’s interactions, and React can only passively read the state, but not affect
    or change it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当输入被控制时，React 负责显示什么。React 必须确认对输入值的给定更改将导致输入值发生变化。当输入未被控制时，输入值根据用户的交互而改变，React
    只能被动地读取状态，但不能影响或改变它。
- en: The difference between these two approaches is highlighted in figure 9.2\. Note
    actions 4 and 5 on the controlled version of the diagram, in particular. These
    two interactions are mandatory. On the other hand, in the uncontrolled version,
    action 4.b is optional, and action 5.b is completely missing because this action
    isn’t possible.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法的区别在图 9.2 中得到了突出。特别要注意图示受控版本中的动作 4 和 5。这两个交互是强制性的。另一方面，在非受控版本中，动作 4.b 是可选的，而动作
    5.b 完全缺失，因为这种动作是不可能的。
- en: '![09-02](../Images/09-02.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![09-02](../Images/09-02.png)'
- en: Figure 9.2 The flow of data in controlled versus uncontrolled inputs differs
    in the fact that React doesn’t control the value after the input has been rendered.
    Action 5.a highlights React’s control over the input even after the user interacts
    with it—React can intercept updates and change them on the fly or even ignore
    them. In the uncontrolled input on the bottom, React has no such control, and
    whatever the user enters will be displayed in the input.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 在受控和非受控输入中，数据流的不同之处在于 React 在输入渲染后不控制值。动作 5.a 强调了 React 即使在用户交互后对输入的控制——React
    可以拦截更新并在飞行中更改它们，甚至忽略它们。在底部的非受控输入中，React 没有这样的控制，用户输入的任何内容都将显示在输入中。
- en: On both versions of the diagram, React can decide what the initial value is.
    But only on the controlled version of the diagram can React control what the value
    is after the user starts inputting data.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在图示的两个版本中，React 都可以决定初始值是什么。但只有在受控版本的图示中，React 才能控制用户开始输入数据后值的改变。
- en: In situations where you don’t need to control the input after the initial value,
    you can use either mode. In situations where you want to control the input as
    the user is entering data—for example, when you want to filter the input or apply
    some formatting mask on it—then you have to use a controlled input. There are
    never situations where you *must* use an uncontrolled input, so there is no reason
    to use it. The option exists mostly for performance reasons. In the next two sections,
    we’ll look at some examples of how to indicate that your input is of the given
    type and then use it.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在你不需要在初始值之后控制输入的情况下，你可以使用任一模式。在你想要在用户输入数据时控制输入的情况下——例如，当你想要过滤输入或对其应用一些格式化掩码时——你必须使用受控输入。永远没有必须使用非受控输入的情况，所以没有必要使用它。这个选项主要出于性能考虑。在接下来的两个部分中，我们将查看一些如何表明你的输入是给定类型以及如何使用它的示例。
- en: 9.2 Managing controlled inputs
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2 管理受控输入
- en: For this example, we want to create a very basic input form. We’ll build a simple
    calculator with two different inputs and an output, which will display the sum
    of the two values. To achieve this result, we need to create JSX, as shown in
    figure 9.3.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们想要创建一个非常基本的输入表单。我们将构建一个包含两个不同输入和一个输出的简单计算器，该输出将显示两个值的总和。为了实现这个结果，我们需要创建如图
    9.3 所示的 JSX。
- en: '![09-03](../Images/09-03.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![09-03](../Images/09-03.png)'
- en: 'Figure 9.3 The desired output JSX for our calculator contains two inputs. Note
    how we pass two specific properties to both inputs: value and onChange.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 我们计算器的期望输出 JSX 包含两个输入。注意我们向两个输入传递了两个特定的属性：值和 onChange。
- en: As you can see, we specify both the value and onChange properties for our inputs,
    which is required to make a controlled input. In fact, this is the definition
    of a controlled input. If you set the value directly in React, you must also listen
    for the change event and update the value, which makes your input controlled.
    If you don’t set a value in React, you don’t need to listen for updates because
    you can’t control the input anyway.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们为输入指定了值和 onChange 属性，这是创建受控输入所必需的。实际上，这就是受控输入的定义。如果你在 React 中直接设置值，你必须也监听更改事件并更新值，这使得你的输入成为受控输入。如果你没有在
    React 中设置值，你不需要监听更新，因为你无论如何都无法控制输入。
- en: As a bonus, to make sure the inputs are numbers, we’ll also set their types
    to "number". Let’s go ahead and implement this in the following listing. If you
    try this out in the browser, you should see something like figure 9.4.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外的好处，为了确保输入是数字，我们还将它们的类型设置为"number"。让我们继续在下面的列表中实现这一点。如果您在浏览器中尝试此操作，您应该会看到类似于图9.4的内容。
- en: '![09-04](../Images/09-04.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![09-04](../Images/09-04.png)'
- en: Figure 9.4 Our summation component in action. The sum of 1000 and 729 is indeed
    1729 (as Ramanujan pointed out).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 我们的动作求和组件。1000和729的和确实是1729（正如拉马努金所指出的）。
- en: Listing 9.1 Summation
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.1 求和
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Initializes two state values. We don’t have to initialize them to 0; any start
    numbers will work here.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 初始化两个状态值。我们不必将它们初始化为0；任何起始数字在这里都适用。
- en: ❷ Creates two almost identical change handlers that just update different state
    values from the input events
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建了两个几乎相同的更改处理程序，它们只是从输入事件更新不同的状态值
- en: ❸ Assigns the correct values and change listeners to the two inputs
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将正确的值和更改监听器分配给两个输入
- en: ❹ Displays the output in the end, which is the sum of the two state values
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 显示最终输出，即两个状态值的总和
- en: 'Repository: rq09-controlled-sum'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库：rq09-controlled-sum
- en: 'This example can be seen in repository rq09-controlled-sum. You can use that
    repository by creating a new app based on the associated template:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例可在rq09-controlled-sum存储库中看到。您可以通过创建基于相关模板的新应用程序来使用该存储库：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您也可以访问此网站浏览代码，直接在浏览器中查看应用程序的运行情况，或下载源代码的zip文件：
- en: '[https://rq2e.com/rq09-controlled-sum](https://rq2e.com/rq09-controlled-sum)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq09-controlled-sum](https://rq2e.com/rq09-controlled-sum)'
- en: Note that we’ve set both value and onChange as properties on the inputs—that’s
    not a coincidence. These two properties are the exact properties you need to specify
    to use a controlled input, and you need to make sure that the value changes when
    the change handler is invoked. You can also change the value at other times, but
    you *must* update the value when the change handler updates. If not, the information
    entered by the user will be ignored.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经将值和onChange设置为输入的属性——这不是巧合。这两个属性正是您需要指定的属性，以使用受控输入，并且您需要确保在调用更改处理程序时值发生变化。您也可以在其他时候更改值，但您*必须*在更改处理程序更新时更新值。如果不这样做，用户输入的信息将被忽略。
- en: 9.2.1 Filtered input
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.1 过滤输入
- en: If you don’t update the state value when data has been entered, the input field
    doesn’t update. You can, of course, use this behavior selectively. Let’s say we
    want to add an input for a hex color and next to that a small square that displays
    that same color.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不在数据输入时更新状态值，输入字段不会更新。当然，你可以有选择地使用这种行为。假设我们想要添加一个十六进制颜色的输入，旁边是一个显示相同颜色的小方块。
- en: A hex color is six hexadecimal digits, so 0-9 and A-F. Because nondigits are
    allowed, we can’t rely on type="number" as we did before. We’ll use a regular
    type="text" input for this, but we need to filter the input so only the valid
    characters make it into the actual text field after the user has entered some
    data. See the diagram in figure 9.5.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一个十六进制颜色由六个十六进制数字组成，即0-9和A-F。由于允许非数字字符，我们不能像以前那样依赖type="number"。我们将使用type="text"的常规输入，但我们需要过滤输入，以确保用户输入的数据中只有有效的字符被输入到实际的文本字段中。请参见图9.5。
- en: '![09-05](../Images/09-05.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![09-05](../Images/09-05.png)'
- en: Figure 9.5 The data flow in our color display component includes a filter in
    the onChange event handler. We’ll strip out nonhexadecimal characters from the
    input string before we “confirm” the value back to JSX.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 我们的颜色显示组件中的数据流包括在onChange事件处理程序中的过滤器。在我们将值“确认”回JSX之前，我们将从输入字符串中删除非十六进制字符。
- en: Note We’re aware of the special input for selecting colors, namely, <input type="color"
    />, which is supported by all modern browsers. We won’t use it here, however,
    as that would make it too easy.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们了解用于选择颜色的特殊输入，即<input type="color" />，它被所有现代浏览器支持。然而，我们不会在这里使用它，因为这会使它变得过于简单。
- en: To do this, we simply apply a filter in the onChange function before setting
    the state value. The input field will then correctly update when we enter valid
    characters, but ignore any invalid characters. On top of this, we’re also going
    to force all the characters to be uppercase because it just looks nicer. When
    we display the color, we only display six-character color strings. If the string
    isn’t six characters long, we display a placeholder background to indicate no
    valid input. Let’s implement this in the next listing. If you run this in the
    browser, you get the result in figure 9.6.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们只需在设置状态值之前在onChange函数中应用一个过滤器。然后，当输入有效字符时，输入字段将正确更新，而忽略任何无效字符。此外，我们还将强制所有字符都转换为大写，因为这看起来更漂亮。当我们显示颜色时，我们只显示六个字符的颜色字符串。如果字符串不是六个字符长，我们显示一个占位符背景来指示没有有效输入。让我们在下一个列表中实现这一点。如果您在浏览器中运行它，您将在图9.6中看到结果。
- en: '![09-06](../Images/09-06.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![09-06](../Images/09-06.png)'
- en: Figure 9.6 0FF1CE is a valid color—a nice cyan shade.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 0FF1CE是一个有效的颜色——一种漂亮的青色。
- en: Listing 9.2 Hex color display
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.2 十六进制颜色显示
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Defines a static placeholder, which uses a conic gradient to display a checkered
    background
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义了一个静态占位符，它使用圆锥渐变来显示棋盘背景
- en: ❷ Initializes our state to a valid color input
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将我们的状态初始化为有效的颜色输入
- en: ❸ In the change handler, examines the current value of the input field after
    the event, filters the input against a regular expression, and uppercases the
    entire result
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在变更处理程序中，检查事件后的输入字段当前值，使用正则表达式过滤输入，并将整个结果转换为大写
- en: ❹ When we want to output the color value, we first check if the color string
    is exactly six characters. If good, we precede it with a hash mark in front; otherwise,
    we display the placeholder instead.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 当我们想要输出颜色值时，我们首先检查颜色字符串是否正好是六个字符。如果是好的，我们在前面加上一个井号；否则，我们显示占位符。
- en: ❺ Adds the value and change handler to the input field as before
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 如前所述，将值和变更处理程序添加到输入字段
- en: 'Repository: rq09-color'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库：rq09-color
- en: 'This example can be seen in repository rq09-color. You can use that repository
    by creating a new app based on the associated template:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在rq09-color仓库中看到。您可以通过创建一个基于相关模板的新应用程序来使用该仓库：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您也可以访问这个网站来浏览代码，直接在您的浏览器中查看应用程序，或者下载源代码的zip文件：
- en: '[https://rq2e.com/rq09-color](https://rq2e.com/rq09-color)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq09-color](https://rq2e.com/rq09-color)'
- en: Note that in the diagram in figure 9.5, we discussed evaluating the newly input
    character to either include or discard it, but in the actual source code in the
    onChange callback in listing 9.2, we don’t look at an individual character, but
    the entire input value every time. This is because inputs aren’t necessarily entered
    one character at a time. The user could paste in a string of characters from their
    clipboard. If they did so, we would have to check the entire new input rather
    than a single character. The user can also decide to enter a new character anywhere
    in the new string, which would complicate things even further. To circumvent all
    such extra work, we always evaluate the whole input and validate it against our
    filter.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在图9.5的图中，我们讨论了评估新输入字符是包含还是丢弃，但在实际源代码中，在列表9.2的onChange回调中，我们不是查看单个字符，而是每次都查看整个输入值。这是因为输入并不一定是逐个字符输入的。用户可以从剪贴板粘贴一串字符。如果他们这样做，我们就必须检查整个新的输入而不是单个字符。用户还可以决定在新字符串的任何位置输入新字符，这将使事情更加复杂。为了绕过所有这些额外的工作，我们总是评估整个输入，并对其与我们的过滤器进行验证。
- en: In addition, note that we decided to initialize the state value to something
    other than just the empty string this time. This is literally all it takes to
    set a default value in the input field.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，这次我们决定将状态值初始化为不仅仅是空字符串。这实际上就是在输入字段中设置默认值所需的所有操作。
- en: 9.2.2 Masked input
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.2 掩码输入
- en: A more advanced variant of a change handler is to apply a mask to a given input
    field as the user is typing. For this example, we want to add an input for entering
    a ticket number for a fictional website. These fictional ticket numbers are defined
    as three alphanumeric characters followed by a dash followed by another three
    alphanumeric characters, for example, R1S-T2U.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种更高级的变更处理程序是，在用户输入时对给定的输入字段应用一个掩码。对于这个例子，我们想要添加一个用于输入虚构网站票据号的输入框。这些虚构的票据号定义为三个字母数字字符，后面跟着一个破折号，再跟着另外三个字母数字字符，例如，R1S-T2U。
- en: When we have an input like that, it makes sense to help the user as they are
    typing. For one thing, we want to display the characters in uppercase regardless
    of the user entering them as such (we already know how to do that!). Secondly,
    we want to add a dash after the first three characters. Finally, we want to limit
    the input to only seven characters total.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一个这样的输入时，在用户输入时帮助他们是有意义的。首先，我们希望无论用户是否以这种方式输入，都显示大写字母（我们已经知道如何做到这一点！）。其次，我们希望在第一个三个字符后添加一个破折号。最后，我们希望将输入限制为总共只有七个字符。
- en: This does sound complicated, but it’s fairly easy. We just have to modify our
    onChange to only update the state value with the valid and correctly formatted
    string and ignore any other input. The actual JavaScript code to accomplish this
    task is a set of string-formatting operations that together achieve the desired
    business logic.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来可能很复杂，但实际上相当简单。我们只需要修改我们的onChange，只更新状态值中的有效和正确格式的字符串，并忽略任何其他输入。完成此任务的实际JavaScript代码是一系列字符串格式化操作，这些操作共同实现了所需的企业逻辑。
- en: This time, we also want to add a placeholder to our input, guiding the user
    as they are about to enter some data. Let’s implement all of this in the next
    listing. If you run this in the browser, you get the result shown in figure 9.7.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们还想在我们的输入中添加一个占位符，在用户输入数据时引导他们。让我们在下一个列表中实现所有这些。如果你在浏览器中运行它，你会得到图9.7中所示的结果。
- en: '![09-07](../Images/09-07.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![09-07](../Images/09-07.png)'
- en: Figure 9.7 This is the output of the Ticket Number input field before and while
    entering a value. When you try this out, note how the dash is automatically added
    after entering three characters.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 这是票号输入字段在输入值之前和输入时的输出。当你尝试这个时，请注意破折号是如何在输入三个字符后自动添加的。
- en: Listing 9.3 Ticket number input
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.3 票号输入
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ This time we have some more validation of the input value, which results in
    breaking it down into at most two parts of up to three characters.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这次我们对输入值进行了更多的验证，这导致将其分解为最多两个部分，每部分最多三个字符。
- en: ❷ If there are exactly three characters in the first part, we help the user
    by adding a dash to the input field.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果第一部分恰好有三个字符，我们会通过在输入字段中添加破折号来帮助用户。
- en: ❸ If the input is exactly seven characters long, it must be a valid ticket number.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果输入恰好有七个字符长，它必须是一个有效的票号。
- en: ❹ Adds all the properties to the input field, including a placeholder value
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将所有属性添加到输入字段中，包括占位符值
- en: ❺ Displays an icon at the end indicating whether the input is valid or not
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 在末尾显示一个图标，指示输入是否有效
- en: 'Repository: rq09-ticket-no'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库：rq09-ticket-no
- en: 'This example can be seen in repository rq09-ticket-no. You can use that repository
    by creating a new app based on the associated template:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在rq09-ticket-no仓库中看到。你可以通过创建一个基于相关模板的新应用程序来使用该仓库：
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以访问这个网站来浏览代码，直接在浏览器中查看应用程序的运行情况，或者下载源代码的zip文件：
- en: '[https://rq2e.com/rq09-ticket-no](https://rq2e.com/rq09-ticket-no)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq09-ticket-no](https://rq2e.com/rq09-ticket-no)'
- en: Note that this isn’t a perfect solution. If you press Backspace to delete some
    of the characters, you’re prohibited from deleting the dash character because
    after deleting it, the script will notice that the string is three characters
    long and automatically add the dash again. Creating such masked inputs can be
    very tricky. There are some libraries and tutorials out there that can help you
    if you need to create complex masked inputs like this.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这并不是一个完美的解决方案。如果你按下Backspace键来删除一些字符，你将无法删除破折号字符，因为删除后，脚本会注意到字符串长度为三个字符，并自动再次添加破折号。创建这样的掩码输入可能非常棘手。如果你需要创建这种复杂的掩码输入，有一些库和教程可以帮助你。
- en: 9.2.3 Many similar inputs
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.3 许多类似的输入
- en: If you have a form with many inputs, it can get tedious (and cause duplicated
    code) to create separate state values and change handlers for all of them. Instead,
    you can have a single state value that contains all your form values and a generic
    change handler generator that can update any input.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个包含许多输入的表单，为所有这些创建单独的状态值和更改处理程序可能会很繁琐（并可能导致代码重复）。相反，你可以有一个包含所有表单值的单个状态值，以及一个通用的更改处理程序生成器，它可以更新任何输入。
- en: For example, this works for a simple address form that has inputs for address
    line 1, address line 2, city, zip code, state, and country. We’re using plain
    input fields for all of these without validation because different countries have
    all sorts of different rules for validating them. Without more information, we’ll
    just let the users enter any data they like in these fields.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这对于一个简单的地址表单是有效的，该表单包含地址行1、地址行2、城市、邮编、州和国家/地区的输入。我们为所有这些使用普通的输入字段，而不进行验证，因为不同国家/地区对它们的验证规则各不相同。没有更多信息的情况下，我们只是让用户在这些字段中输入他们喜欢的任何数据。
- en: We’ll keep a single object in state with all the relevant form data, initialized
    to an empty string. Because we have all the values in the same object indexed
    by a key, we can use that single key to identify which field to update on each
    update handler. The resulting JSX will look something like the partial JSX tree
    displayed in figure 9.8.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在状态中保持一个对象，包含所有相关的表单数据，初始化为空字符串。因为我们所有的值都在同一个对象中，通过键索引，我们可以使用这个单个键来识别每个更新处理器中要更新的字段。生成的JSX将类似于图9.8中显示的部分JSX树。
- en: '![09-08](../Images/09-08.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![09-08](../Images/09-08.png)'
- en: Figure 9.8 A partial DOM tree (it doesn’t show labels and other trivial elements)
    that focuses on the inputs and their properties. Note that we’ve switched to a
    left-to-right tree rather than a top-to-bottom tree merely to fit all the elements
    in.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8 一个部分DOM树（不显示标签和其他琐碎元素），专注于输入及其属性。请注意，我们只是为了将所有元素都放入其中，而将树从自上而下改为自左向右。
- en: All we need to do now is create an event handler generator function that takes
    the property of the state object to set and updates it with the input value from
    the event object as the event handler is invoked. For this, we must create a function
    that returns a function, as we saw in chapter 8\. Let’s put this all together
    in listing 9.4\. If you run this in the browser, you get the result shown in figure
    9.9.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要创建一个事件处理器生成函数，该函数接受要设置的状态对象的属性，并在事件处理器被调用时使用事件对象的输入值来更新它。为此，我们必须创建一个返回函数的函数，就像我们在第8章中看到的那样。让我们将这些内容全部汇总到列表9.4中。如果你在浏览器中运行它，你会得到图9.9中显示的结果。
- en: '![09-09](../Images/09-09.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![09-09](../Images/09-09.png)'
- en: Figure 9.9 The complete address form in the browser—not the prettiest, but fully
    functional.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9 浏览器中的完整地址表单——不是最漂亮的，但完全功能。
- en: Listing 9.4 Address form
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.4 地址表单
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ The state is an object this time, holding all the variables that we need.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这次状态是一个对象，包含我们需要的所有变量。
- en: ❷ The onChange function is now a generator that first takes a key and then returns
    an event handler.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ onChange函数现在是一个生成器，它首先接受一个键，然后返回一个事件处理器。
- en: ❸ When an input changes, we update the state with the entire old state (to not
    override any existing values), but we then add in the new value with the indicated
    key.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 当输入更改时，我们使用整个旧状态更新状态（以不覆盖任何现有值），然后添加带有指示键的新值。
- en: ❹ Applies the value and change handler to all the inputs
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将值和更改处理器应用于所有输入
- en: 'Repository: rq09-address'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库：rq09-address
- en: 'This example can be seen in repository rq09-address. You can use that repository
    by creating a new app based on the associated template:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在rq09-address存储库中看到。你可以通过创建一个基于相关模板的新应用程序来使用该存储库：
- en: '[PRE7]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以访问这个网站来浏览代码，直接在你的浏览器中查看应用程序的运行情况，或者下载源代码的zip文件：
- en: '[https://rq2e.com/rq09-address](https://rq2e.com/rq09-address)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq09-address](https://rq2e.com/rq09-address)'
- en: Using the name property
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用名称属性
- en: We can take this idea one step further. Form elements can have a name attribute,
    which is the ID of the field that will be submitted if you use a regular HTML
    form. We can use that property to contain the key to be updated in the change
    handler. Then, we don’t need to pass the key to the change handler at all because
    it can examine the name property of the event target. Our JSX would look like
    figure 9.10 instead (compare with figure 9.8).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个想法再进一步。表单元素可以有一个名称属性，这是如果你使用常规HTML表单将提交的字段的ID。我们可以使用这个属性来包含更改处理器中要更新的键。然后，我们根本不需要将键传递给更改处理器，因为它可以检查事件目标的名称属性。我们的JSX将看起来像图9.10而不是图9.8（比较图9.8）。
- en: '![09-10](../Images/09-10.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![09-10](../Images/09-10.png)'
- en: Figure 9.10 A partial DOM tree with our simpler event handlers
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10 带有我们更简单的事件处理器的部分DOM树
- en: Now, we can use the same event handler for every element. The event handler
    will update the state object with the key taken from the event target name and
    the value taken from the event target value.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以为每个元素使用相同的事件处理器。事件处理器将使用事件目标名称作为键，使用事件目标值作为值来更新状态对象。
- en: This time, we also want to see that our state actually contains what we think
    it does. So, at the end, we’ll include a <pre> element, which dumps out the data
    variable as a JSON document. We put this all together in the following listing.
    Take a look at figure 9.11 to see this in action.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们还想看到我们的状态实际上包含我们所认为的内容。因此，在最后，我们将包括一个<pre>元素，它将数据变量作为JSON文档输出。我们将所有这些内容组合在下面的列表中。查看图9.11以了解其工作情况。
- en: '![09-11](../Images/09-11.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![09-11](../Images/09-11.png)'
- en: Figure 9.11 Our smart but simple address form seems to be working exactly as
    designed!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.11 我们智能但简单的地址表单似乎完全按照设计工作！
- en: Listing 9.5 Simpler address form
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.5 简化的地址表单
- en: '[PRE8]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ The onChange function is now back to being a simple event handler, and we
    extract the name of the input from the target.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ onChange函数现在又回到了一个简单的事件处理器，我们从目标中提取输入的名称。
- en: ❷ Also extracts the current value in the input field the same way
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 同样以相同的方式提取输入字段中的当前值
- en: ❸ Updates the state object with the newly changed input
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用新更改的输入更新状态对象
- en: ❹ Assigns the name property and a simple event handler to each input node
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 为每个输入节点分配名称属性和简单的事件处理器
- en: ❺ Prints out a nice JSON representation of the current data state so we can
    see that we’re doing everything correctly
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 打印出当前数据状态的漂亮JSON表示，这样我们就可以看到我们是否正在正确地做每件事
- en: 'Repository: rq09-smart-address'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库：rq09-smart-address
- en: 'This example can be seen in repository rq09-smart-address. You can use that
    repository by creating a new app based on the associated template:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例可在rq09-smart-address仓库中看到。您可以通过创建基于相关模板的新应用程序来使用该仓库：
- en: '[PRE9]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以访问此网站来浏览代码，在您的浏览器中直接查看应用程序，或下载源代码的zip文件：
- en: '[https://rq2e.com/rq09-smart-address](https://rq2e.com/rq09-smart-address)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq09-smart-address](https://rq2e.com/rq09-smart-address)'
- en: This idea of using the input name property to store the key for the information
    entered in the input is very common. It’s not a requirement but is a very convenient
    way of organizing forms, especially if they grow large.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用输入名称属性来存储输入中输入的信息的键的想法非常常见。这不是必需的，但是一种非常方便的方式来组织表单，特别是如果它们变得很大。
- en: This form (and all the forms we created previously in this chapter) is missing
    something, however. How do we submit this form? What do we do with the data when
    we submit it? Let’s get to that in the next section.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个表单（以及我们在本章中之前创建的所有表单）缺少一些东西。我们如何提交这个表单？在提交时我们如何处理数据？让我们在下一节中探讨这个问题。
- en: 9.2.4 Form submission
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.4 表单提交
- en: Let’s create a very simple to-do application that is complete, useful, and fully
    functional. It’s a classic exercise to complete in a web framework, so we might
    as well get it over with.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个非常简单但完整、有用且完全功能的待办事项应用程序。在Web框架中完成这是一个经典的练习，所以我们不妨完成它。
- en: 'We want to be able to create new to-do items with a title, category, duration,
    and due date. We then want to be able to see a list of to-do items created, and,
    of course, delete items as we complete them. We’ll have two different screens:
    one for displaying the list of items and another for adding a new item.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够创建带有标题、类别、持续时间和截止日期的新待办事项。然后我们希望能够看到创建的待办事项列表，当然，在完成它们时删除项目。我们将有两个不同的屏幕：一个用于显示项目列表，另一个用于添加新项目。
- en: The important part at this stage is the form handling. We want to create a form
    with some inputs. When the user submits the form, we want to create a new data
    object based on the entered data, add it to the list of items, clear the form,
    and allow the user to add a new one. This flow is shown in figure 9.12.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，重要的是表单处理。我们想要创建一个带有一些输入的表单。当用户提交表单时，我们想要根据输入的数据创建一个新的数据对象，将其添加到项目列表中，清除表单，并允许用户添加新的项目。这个流程如图9.12所示。
- en: '![09-12](../Images/09-12.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![09-12](../Images/09-12.png)'
- en: Figure 9.12 The flow of data in our to-do application
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.12 待办事项应用程序中的数据流程
- en: 'In this application, we’ll store the list of to-do items in memory only, so
    if you reload the page, you lose all the data. Persisting the data isn’t the interesting
    part; for now, we just want to handle the form data in a logical way. Let’s create
    this application using three components (see their structure in figure 9.13):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用中，我们只会在内存中存储待办事项列表，所以如果你重新加载页面，你将丢失所有数据。持久化数据并不是有趣的部分；目前，我们只想以逻辑方式处理表单数据。让我们使用三个组件来创建这个应用（参见图9.13中的结构）：
- en: <App />—This main component contains the list of items as local state as well
    as methods for adding and deleting items. It also knows whether we’re currently
    adding an item or looking at the list of all items and provides a small menu for
    switching between the two views.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <App />—这个主要组件包含项目列表作为本地状态，以及添加和删除项目的函数。它还知道我们当前是在添加项目还是查看所有项目的列表，并提供一个小的菜单来在两种视图之间切换。
- en: <List />—This component accepts a list of items to display as well as a function
    to call when deleting an item.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <List />—这个组件接受要显示的项目列表以及当删除项目时调用的函数。
- en: <Add />—This component contains a form for entering information about a new
    item and submitting it. When an item is submitted, you go back to the list. You
    can also cancel the submission and go back to the list without adding anything.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <Add />—这个组件包含一个用于输入新项目信息的表单以及提交它的功能。当提交一个项目时，你将回到列表。你也可以取消提交并返回列表而不添加任何内容。
- en: '![09-13](../Images/09-13.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![09-13](../Images/09-13.png)'
- en: Figure 9.13 A very rough overview of the three components in our application
    and their relationships
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.13 我们应用中三个组件的非常粗略的概述及其关系
- en: In the end, we want to create an application that looks like figure 9.14.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们希望创建一个看起来像图9.14的应用程序。
- en: '![09-14](../Images/09-14.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![09-14](../Images/09-14.png)'
- en: Figure 9.14 The final application when viewing a list of items and adding a
    new item
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.14 查看项目列表并添加新项目时的最终应用
- en: Now, let’s start implementing the main <App /> component. For this example,
    we’ll use multiple files, so the app component goes in the App.js file. The contents
    are shown in listing 9.6.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始实现主要的 <App /> 组件。对于这个例子，我们将使用多个文件，所以应用程序组件放在 App.js 文件中。内容如列表9.6所示。
- en: Listing 9.6 The main component in App.js
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.6 App.js中的主要组件
- en: '[PRE10]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Imports the two detail views from separate files
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从单独的文件导入两个详细视图
- en: ❷ The initial state of the application reflects an empty list of to-do items
    and that we’re not currently adding an item.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 应用的初始状态反映了一个空的待办事项列表，并且我们当前没有添加项目。
- en: ❸ When we delete an item, we update the state with all the items except the
    one to be deleted.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 当我们删除一个项目时，我们更新状态，包括所有项目，但不包括要删除的项目。
- en: ❹ When we add an item, we update the state with all the existing items plus
    the newly added item. We then return to the list view.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 当我们添加一个项目时，我们更新状态，包括所有现有项目和新增的项目。然后我们返回到列表视图。
- en: ❺ When we cancel adding an item, we just return to the list view.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 当我们取消添加项目时，我们只是返回到列表视图。
- en: ❻ Our menu simply toggles the flag about whether we’re adding an item or not.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 我们菜单简单地切换是否添加项目的标志。
- en: ❼ The main part of the application depends on the current state—are we adding
    an item or not?
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 应用程序的主要部分依赖于当前状态——我们是在添加项目吗？
- en: ❽ If we’re adding an item, we include the relevant component with the two necessary
    callbacks as properties.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 如果我们在添加项目，我们包括相关的组件，并作为属性包含两个必要的回调函数。
- en: ❾ If we’re not adding an item, we display a list of all the items, so we need
    to pass the relevant properties here as well.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 如果我们不在添加项目，我们显示所有项目的列表，因此我们还需要在这里传递相关的属性。
- en: 'With the main <App /> component out of the way, let’s turn our focus to the
    <List /> component in List.js. It’s a lot simpler because it just displays a table
    of all the items and includes a button next to each one that allows you to delete
    that item. The component takes two properties: the list of items to display and
    the callback to call when deleting an item, as implemented in the next listing.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完主要的 <App /> 组件之后，让我们将注意力转向 List.js 中的 <List /> 组件。它很简单，因为它只是显示所有项目的表格，并在每个项目旁边包含一个按钮，允许你删除该项目。该组件接受两个属性：要显示的项目列表和当删除项目时调用的回调函数，如下一列表所示。
- en: Listing 9.7 The list component in List.js
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.7 List.js中的列表组件
- en: '[PRE11]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ The important part of this component is the early return in case of no items.
    There’s no need to display a table if there’s nothing to fill it with.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这个组件的重要部分是在没有项目时进行早期返回。如果没有内容填充，就没有必要显示表格。
- en: ❷ When there is something to display, we loop over all the items and display
    a table row for each.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 当有内容需要展示时，我们会遍历所有项目并为每个项目显示一行表格。
- en: ❸ The Delete button invokes the cancel callback function with the entire item
    as an argument.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 删除按钮会调用带有整个项目作为参数的取消回调函数。
- en: 'Finally, we need to implement the important component for this application:
    the form to add a new item in the <Add /> component in Add.js. We’ll use all the
    tricks we’ve seen in this chapter, including a generic change handler for all
    the inputs that update the component state, based on the input name property.
    Let’s implement this in listing 9.8.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要实现这个应用程序的重要组件：在Add.js中的<Add />组件中添加新项目的表单。我们将使用本章中看到的所有技巧，包括一个通用的更改处理程序，用于所有更新组件状态的输入，基于输入的名称属性。让我们在列表9.8中实现它。
- en: Listing 9.8 The form component in Add.js
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.8 Add.js中的表单组件
- en: '[PRE12]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Initializes our state as before
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如前所述初始化我们的状态
- en: ❷ This is the same change handler we used in listing 9.5—it’s a very versatile
    construct!
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 这是我们之前在列表9.5中使用过的同一个更改处理程序——它是一个非常通用的结构！
- en: ❸ When we submit the form, we need to send the form data to the relevant callback
    and prevent the default form action. If we forget the latter, the page will reload
    and all data will be lost.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 当我们提交表单时，我们需要将表单数据发送到相关的回调函数并防止默认的表单操作。如果我们忘记后者，页面将重新加载并且所有数据都将丢失。
- en: ❹ Assigns the submit handler to the form
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将提交处理程序分配给表单
- en: ❺ Assigns the properties to the inputs as normal. Note how we also add type="date"
    to the due date input.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 正常地将属性分配给输入框。注意我们如何也将type="date"添加到截止日期输入框中。
- en: ❻ A button is by default a Submit button unless explicitly set to type="button",
    so this is the Submit button. We don’t need a click handler because the form submit
    handler will take care of that.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 按钮默认是提交按钮，除非明确设置为type="button"，所以这是提交按钮。我们不需要点击处理程序，因为表单提交处理程序将负责处理。
- en: ❼ The Cancel button must not submit the form, so we have to add an explicit
    type and then invoke the cancel callback on click.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 取消按钮不能提交表单，因此我们必须添加一个显式的类型，然后在点击时调用取消回调。
- en: 'Repository: rq09-todo'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库：rq09-todo
- en: 'This example can be seen in repository rq09-todo. You can use that repository
    by creating a new app based on the associated template:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例可以在rq09-todo仓库中看到。您可以通过创建一个基于相关模板的新应用程序来使用该仓库：
- en: '[PRE13]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以访问此网站来浏览代码，在您的浏览器中直接查看应用程序的运行情况，或者下载源代码的zip文件：
- en: '[https://rq2e.com/rq09-todo](https://rq2e.com/rq09-todo)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '[rq09-todo仓库](https://rq2e.com/rq09-todo)'
- en: This is our first larger application, so we strongly encourage you to play with
    the source code for this one, if you aren’t already doing that for every example.
    You should begin to see how all the things we’ve discussed about properties, events,
    state, JSX, and component composition go together in this application and are
    rounded off by our new knowledge about form handling to create a small but very
    powerful application.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的第一个较大的应用程序，所以我们强烈建议您尝试玩一下这个源代码，如果您还没有为每个示例这样做的话。您应该开始看到我们讨论的所有关于属性、事件、状态、JSX和组件组合在这个应用程序中的结合，以及我们关于表单处理的新知识如何使这个小型但非常强大的应用程序更加完善。
- en: Nothing is stopping us from expanding this to include all sorts of new elements.
    We can have a separate form for creating categories for new items and then display
    a drop-down of categories to choose from in the form. We just need to know how
    to use drop-downs, but we’ll get to that in the next section. We can also create
    a calendar display mode, where all the items will be displayed in a grid. We can
    add all the extra properties we want on the items, for example, expected duration.
    We can then summarize the expected duration for all items each day.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么阻止我们将其扩展到包括所有各种新元素。我们可以为创建新项目的类别创建一个单独的表单，然后在表单中显示一个下拉菜单以供选择。我们只需要知道如何使用下拉菜单，但我们将在这下一节中介绍。我们还可以创建一个日历显示模式，其中所有项目都将显示在一个网格中。我们可以在项目上添加我们想要的任何额外属性，例如预期持续时间。然后我们可以为每天的所有项目总结预期持续时间。
- en: Form submission versus button click
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 表单提交与按钮点击
- en: When you want to submit your form, you basically want to collect the data in
    the form and send it to a remote service or some other storage location. Because
    we’re using controlled inputs in this section, the React component state is the
    source of truth, so we can read the value directly from the state.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要提交你的表单时，你基本上想要收集表单中的数据并将其发送到远程服务或另一个存储位置。因为我们在这个部分使用受控输入，所以React组件的状态是真相的来源，因此我们可以直接从状态中读取值。
- en: 'We want to create a submit handler on the form. As we’ve previously discussed,
    a form’s submit handler will automatically be invoked by the browser in two different
    instances:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想在表单上创建一个提交处理程序。正如我们之前讨论的，表单的提交处理程序将在两种不同的情况下自动由浏览器调用：
- en: If the user clicks a Submit button inside the form
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户在表单内点击提交按钮
- en: If the user has focus inside an input field in the form with a Submit button
    and presses Enter
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户在包含提交按钮的表单中的输入字段内聚焦并按下Enter键
- en: Because the form’s submit handler handles both of those use cases, it’s the
    proper place to deal with it. If we placed the handler directly as a click handler
    on the Submit button, we would be mishandling form submission if the user has
    focus inside an input field with a Submit button and presses Enter.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 因为表单的提交处理程序处理了这两个用例，所以它是处理这个问题的合适位置。如果我们直接将处理程序作为点击处理程序放在提交按钮上，那么如果用户在包含提交按钮的输入字段内聚焦并按下Enter键，我们就会错误地处理表单提交。
- en: 9.2.5 Other inputs
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.5 其他输入
- en: We briefly saw a different type of input in that previous example. We had a
    date input and, as you could see in figure 9.14, it displayed differently in the
    browser. That’s not the only special type we have, as there are many other useful
    input variants. Figure 9.15 (a copy of figure 9.1) shows a list of all the input
    types that you can use in HTML forms in general and in React forms in particular.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们简要地看到了不同类型的输入。我们有一个日期输入字段，如图9.14所示，它在浏览器中的显示方式不同。这并不是我们拥有的唯一特殊类型，因为还有许多其他有用的输入变体。图9.15（图9.1的副本）显示了在HTML表单中一般可以使用以及在React表单中特别可以使用的所有输入类型。
- en: '![09-15](../Images/09-15.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![09-15](../Images/09-15.png)'
- en: Figure 9.15 A table of various inputs available in HTML and React forms. Note
    how this includes mostly variations of input fields, but also a range of buttons
    and a drop-down.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.15 HTML和React表单中可用的各种输入的表格。注意，这主要包括输入字段的变体，但也包括一系列按钮和下拉菜单。
- en: Some of these inputs are merely variants that make it easier to input data on
    smaller devices. For instance, type="tel", when focused on a mobile device, will
    display a keyboard with only the buttons that are relevant for entering phone
    numbers (digits, +, -, and a few others). Others are a lot more complex and have
    more intricate interfaces.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这些输入中的一些仅仅是变体，使得在较小的设备上输入数据更加容易。例如，当在移动设备上聚焦时，type="tel"将显示一个仅包含与输入电话号码相关的按钮的键盘（数字、+、-以及一些其他按钮）。其他输入则更加复杂，具有更复杂的界面。
- en: A few of these inputs aren’t actually inputs, but just buttons. These include
    the reset, submit, button, and image types that you can see in figure 9.15.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些输入实际上并不是输入，而是按钮。这些包括图9.15中可以看到的重置、提交、按钮和图像类型。
- en: Most of these inputs have the same API as text input fields though, so they
    are very easy to work with from a React perspective. Notice how, in the previous
    example, we didn’t have to change anything in React just because we used a date
    field. We used the properties and events in the same way.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大多数这些输入字段与文本输入字段具有相同的API，但从React的角度来看，它们非常容易处理。注意，在前面的例子中，我们并没有因为使用了日期字段而在React中做任何改变。我们以相同的方式使用了属性和事件。
- en: However, some of these input types are slightly different and require you to
    use the inputs and the events in a different way. We’ll go over each input type
    in the next subsections with some small examples to display how you can use the
    different input types.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些输入类型中的一些略有不同，需要你以不同的方式使用输入和事件。我们将在下一小节中通过一些小示例逐一介绍每种输入类型，以展示你如何使用不同的输入类型。
- en: Note All the examples in this section will be included in the rq09-todo repository
    mentioned previously, as they are all variants of the add form used in that example.
    These files will only be partially functioning though, as the list component in
    that application is only set up to work with the regular add form we used previously.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本节中的所有示例都将包含在之前提到的rq09-todo存储库中，因为它们都是该示例中使用的添加表单的变体。然而，这些文件将只部分功能，因为该应用程序中的列表组件仅设置用于我们之前使用的常规添加表单。
- en: One input type will be skipped. The file input isn’t possible to use in a controlled
    input, so we’ll describe that one a bit later, when we get to the uncontrolled
    inputs.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 将跳过一种输入类型。文件输入在受控输入中不可用，所以我们将在稍后描述它，当我们到达非受控输入时。
- en: Numeric inputs
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 数字输入
- en: Number inputs are almost identical to text inputs with a single exception. The
    normal value property on the target object is a string, but because we’re working
    with numbers, we want to get the current value of the input field as a number.
    To do that, we can look at the evt.target.valueAsNumber property rather than the
    regular evt .target.value property. We don’t have to manually parse the input
    and convert it to a string using a given base because JavaScript will do that
    for us automatically.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 数字输入几乎与文本输入完全相同，只有一个例外。目标对象上的正常值属性是一个字符串，但由于我们正在处理数字，我们希望获取输入字段的当前值作为数字。为此，我们可以查看evt.target.valueAsNumber属性，而不是常规的evt.target.value属性。我们不需要手动解析输入并将其转换为字符串，因为JavaScript会自动为我们完成这项工作。
- en: 'There are two categories of numeric inputs: number inputs and calendar inputs.
    Number inputs include the input types "number" and "range", and the calendar inputs
    include the input types "date", "datetime-local", "month", "time", and "week".'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 数字输入分为两类：数字输入和日历输入。数字输入包括“number”和“range”输入类型，而日历输入包括“date”、“datetime-local”、“month”、“time”和“week”输入类型。
- en: If you have a calendar input, the value property will return the selection as
    a string, depending on your local language and other settings. So, for a type="week"
    input, the value might return "2022-W52" as a string. The valueAsNumber property,
    on the other hand, returns a timestamp for most calendar input types, which is
    the number of milliseconds between midnight on January 1 in 1970 and the selected
    date and/or time. So, for the same week 52 in 2022, this would return the number
    1672012800000.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个日历输入，值属性将根据你的本地语言和其他设置将选择作为字符串返回。因此，对于type="week"输入，值可能返回"2022-W52"作为字符串。另一方面，valueAsNumber属性对大多数日历输入类型返回一个时间戳，这是1970年1月1日凌晨与所选日期和时间之间的毫秒数。因此，对于2022年的同一周52，这将返回数字1672012800000。
- en: Month inputs are again a special variant of the calendar inputs as they return
    the number of months between January 1970 and the selected month. So, if you select
    December 2022 in the input, the valueAsNumber would return 635, as that is the
    number of months passed since then. Numeric inputs also take min, max, and step
    properties that indicate the valid value range as well as the default amount the
    input can change by if you’re using the keyboard to change the value.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 月份输入再次是日历输入的特殊变体，因为它们返回1970年1月和所选月份之间的月份数。因此，如果你在输入中选择2022年12月，valueAsNumber将返回635，因为这是从那时起经过的月份数。数字输入还接受min、max和step属性，这些属性指示有效值范围以及如果你使用键盘更改值时输入可以更改的默认量。
- en: React doesn’t care if you set the value of a number input as a number or a string.
    It will be converted to a number before being displayed though, so if you pass
    something that can’t be displayed in the given input, it will display incorrectly.
    For this reason, it makes sense to store the values as numbers in JavaScript to
    avoid conversion problems.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: React不会关心你将数字输入的值设置为数字还是字符串。但在显示之前，它将被转换为数字，所以如果你传递了无法在给定输入中显示的内容，它将显示不正确。因此，将值作为数字存储在JavaScript中以避免转换问题是有意义的。
- en: Check boxes and radio buttons
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 复选框和单选按钮
- en: Check boxes and radio buttons are special because they don’t have a value—or
    at least they don’t have a value that changes. The value is just an identifier
    that denotes what the check box or radio button signifies, but it doesn’t hold
    information about whether the input is checked or not.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 复选框和单选按钮是特殊的，因为它们没有值——或者至少它们的值不会改变。值只是一个标识符，表示复选框或单选按钮的含义，但它不包含有关输入是否被选中或未选中的信息。
- en: For instance, consider the form shown in figure 9.16\. The four radio buttons
    are all independent <input> elements, but their values are static—they are just
    the four priorities. The dynamic part of this input element is the information
    about which radio button is currently selected in the list. For this reason, these
    two types of input, check boxes and radio buttons, have a checked property that
    you have to set to true or false to control the state of the component.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑图9.16中显示的表单。四个单选按钮都是独立的<input>元素，但它们的值是静态的——它们只是四个优先级。这个输入元素的动态部分是关于列表中当前选中的单选按钮的信息。因此，这两种类型的输入，复选框和单选按钮，都有一个checked属性，你必须将其设置为true或false来控制组件的状态。
- en: '![09-16](../Images/09-16.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![09-16](../Images/09-16.png)'
- en: Figure 9.16 Radio buttons are used to set a priority.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.16 使用单选按钮来设置优先级。
- en: First, we’ll create the form with the four radio buttons. The following listing
    shows what that will look like.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建包含四个单选按钮的表单。以下列表显示了这将是什么样子。
- en: Listing 9.9 The form component if we want radio buttons (excerpt)
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.9 如果我们想要单选按钮的表单组件（摘录）
- en: '[PRE14]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ Creates a helper component to render a label with a radio button inside
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个辅助组件来渲染一个包含单选按钮的标签
- en: ❷ Set the name of all the radio buttons to the same name in this component so
    they are part of the same radio button group.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将所有单选按钮的名称设置为在此组件中相同的名称，以便它们成为同一个单选按钮组的一部分。
- en: ❸ Sets checked to true on only the radio button that is currently selected
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 只将当前选中的单选按钮的选中状态设置为true
- en: ❹ Sets the value that is static for each instance of this component
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 为此组件的每个实例设置静态值
- en: ❺ Adds the same change handler to all of them
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将相同的变更处理程序添加到所有这些中
- en: ❻ The change handler works as usual.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 变更处理程序按常规工作。
- en: ❼ Creates four instances of the Radio component
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 创建四个Radio组件实例
- en: Let’s create another variant of our to-do form from earlier. This time, we just
    want to record the title of the task and whether this is an urgent task or not.
    This will be a Boolean flag that we store in the item object. We’ll use a check
    box for this purpose.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建之前提到的待办事项表单的另一个变体。这次，我们只想记录任务的标题以及这个任务是否紧急。这将是一个存储在项目对象中的布尔标志。我们将为此目的使用复选框。
- en: Listing 9.10 The form component with a check box (excerpt)
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.10 带有复选框的表单组件（摘录）
- en: '[PRE15]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ The change handler for the title input works, as we’ve seen many times, by
    looking at the value on the target property.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 标题输入框的变更处理程序通过查看目标属性上的值来工作，正如我们多次看到的。
- en: ❷ The change handler for the check box is different, though. It examines the
    Boolean property .checked on the target property.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 复选框的变更处理程序不同。它检查目标属性上的布尔属性.checked。
- en: ❸ Assigns the value and onChange properties as normal to the regular text input
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 正常分配值和onChange属性到常规文本输入
- en: ❹ Assigns checked and onChange properties to our check box input. Note that
    we don’t need a value property because it doesn’t serve any useful function in
    this instance.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将checked和onChange属性分配给我们的复选框输入。请注意，我们不需要value属性，因为在这次实例中它没有任何有用的功能。
- en: Select boxes
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 选择框
- en: Select boxes, also known as drop-downs, are seemingly very different from other
    input types in HTML. Select boxes use multiple elements and have their selection
    indicated in a completely different way. But React makes it easy to use this input
    type. You can use select boxes identically to regular input elements in terms
    of the properties to use. Of course, you still have to add the option elements.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 选择框，也称为下拉菜单，在HTML中的其他输入类型中似乎非常不同。选择框使用多个元素，并且它们的选项以完全不同的方式表示。但React使得使用这种输入类型变得简单。在属性使用方面，你可以像使用常规输入元素一样使用选择框。当然，你仍然需要添加选项元素。
- en: Let’s implement the priority example we saw in figure 9.16, but with a drop-down
    instead. This would look something like figure 9.17\. This is surprisingly simple
    to do because React makes it easy for us.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现图9.16中看到的优先级示例，但使用下拉菜单代替。这看起来可能像图9.17所示。这出奇地简单，因为React使我们能够轻松地做到这一点。
- en: '![09-17](../Images/09-17.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![09-17](../Images/09-17.png)'
- en: Figure 9.17 Priority can now be set using a drop-down.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.17 现在可以使用下拉菜单设置优先级。
- en: Listing 9.11 The form component with a drop-down (excerpt)
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.11 带有下拉菜单的表单组件（摘录）
- en: '[PRE16]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ Initializes the priority to a simple string
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将优先级初始化为简单的字符串
- en: ❷ We can use the same change handler for regular inputs as well as for select
    boxes.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们可以使用与常规输入一样以及与选择框相同的变更处理程序。
- en: ❸ Assigns the value and onChange properties like on a regular input directly
    on the select element
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 直接在select元素上分配值和onChange属性，就像在常规输入上一样
- en: ❹ Adds the options using option elements with a value and a display text
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用具有值和显示文本的选项元素添加选项
- en: If you’ve used select boxes in HTML before, you know that you normally have
    to set the selected property on the individual <option> elements to indicate which
    one is selected. There is no value property on the select element in HTML. But
    React has made sure to make this easy to use, so the API is the same for inputs
    as it is for select boxes, and that’s pretty nifty!
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前使用过HTML中的选择框，你知道你通常必须设置selected属性在各个<option>元素上，以指示哪个被选中。HTML中的选择元素上没有值属性。但是React确保使其易于使用，因此API与输入相同，对于选择框也是如此，这非常巧妙！
- en: You can even use multiselect boxes, where the user is able to select more than
    one option. Imagine if we had a select box with a list of people, where the user
    could select which persons were involved in a given task. If we store an array
    of people in the local state, we can use the array of selections as the value
    for the component, as shown in the next listing.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以使用多选框，用户能够选择多个选项。想象一下，如果我们有一个包含人员名单的选项框，用户可以从中选择参与特定任务的人员。如果我们将人员数组存储在本地状态中，我们可以使用选择数组作为组件的值，如下一列表所示。
- en: Listing 9.12 The form component with multiselect (excerpt)
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.12 带有多选框的表单组件（摘录）
- en: '[PRE17]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ The state value is just an array, and we can initialize it to an empty array.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 状态值只是一个数组，我们可以将其初始化为空数组。
- en: ❷ We need to create a custom change handler, however, because we have to look
    at the list of selected options on the target object.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们需要创建一个自定义的变更处理器，因为我们必须查看目标对象上所选选项的列表。
- en: ❸ For each of the selected options, we have to extract the value property. We
    can then store the resulting array of option values in the state.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 对于每个选定的选项，我们必须提取值属性。然后我们可以将结果选项值数组存储在状态中。
- en: ❹ We assign the properties as normal, but now we also set the "multiple" property.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 我们像往常一样分配属性，但现在我们还设置了"multiple"属性。
- en: Handling multiselect boxes is a bit more work, but it’s rarely required. However,
    it’s a great tool to have in the toolbox for those once-in-a-blue-moon occasions.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 处理多选框需要更多的工作，但很少需要。然而，对于那些偶尔需要的情况，这是一个很好的工具箱。
- en: Multiline inputs
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 多行输入
- en: 'Multiline inputs are known as text areas in HTML. Text areas are seemingly
    identical to inputs in HTML with the main exception that the value of the text
    field isn’t added as the value property on the element but as a child text node.
    If we want to set the value of an input field in HTML to "this text", we do it
    using the value property:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 多行输入在HTML中被称为文本区域。文本区域在HTML中似乎与输入字段相同，主要区别在于文本字段的值不是作为元素的值属性添加，而是作为子文本节点。如果我们想将HTML中输入字段的值设置为"this
    text"，我们使用值属性来完成：
- en: '[PRE18]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If we want to do the same in a text area, we have to set it as the child of
    the element:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在文本区域中做同样的事情，我们必须将其设置为元素的子节点：
- en: '[PRE19]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: However, in React, we don’t do that. In React, we use text areas as if they
    are text fields. So, if we wanted to add a description field to our to-do form,
    we would simply extend the form.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在React中，我们并不这样做。在React中，我们使用文本区域就像它们是文本字段一样。所以，如果我们想在待办事项表单中添加一个描述字段，我们只需扩展表单即可。
- en: Listing 9.13 The form component with textarea (excerpt)
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.13 带有文本区域的表单组件（摘录）
- en: '[PRE20]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ The state value is again initialized to a string.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 状态值再次初始化为字符串。
- en: ❷ Sets the value property directly on the textarea element—no need to set it
    as a child node
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 直接在textarea元素上设置值属性——不需要将其设置为子节点
- en: ❸ Uses the same generalized change handler as before as long as we make sure
    to set the name property as well
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 只要我们确保设置名称属性，就使用与之前相同的通用变更处理器
- en: With all these extra input types, you should now be well equipped to create
    even the most complex forms and handle the data both properly and cleverly with
    a great deal of code reuse, to avoid repeating yourself.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些额外的输入类型中，你现在应该已经准备好创建最复杂的表单，并且能够以大量代码重用的方式，既正确又巧妙地处理数据，避免重复。
- en: 9.2.6 Other properties
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.6 其他属性
- en: 'All the other properties still work as expected on all the different types
    of inputs. That is because most of the extra functionality is managed in HTML,
    so we don’t need to do anything in React to get the benefits from these extra
    capabilities. Following is a an inexhaustive list of extra properties you can
    add to your inputs to change how your form works:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他属性在所有不同类型的输入上仍然按预期工作。这是因为大部分额外功能由HTML管理，所以我们不需要在React中做任何事情来获得这些额外功能的好处。以下是一个你可以添加到输入中以改变表单工作方式的额外属性的不完整列表：
- en: required—If set on an input field, the input will be required. If the field
    is left empty, the form cannot be submitted—the browser won’t invoke the onSubmit
    callback. If the field is non-empty, submitting works as normal. This is a Boolean
    property, so you just need to include it as <input required />.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: required—如果设置在输入字段上，输入将是必需的。如果字段为空，则无法提交表单——浏览器不会调用onSubmit回调。如果字段非空，提交将按正常工作。这是一个布尔属性，所以你只需要将其包含为<input
    required />。
- en: 'min, max, *and* step—The properties are used for number inputs and ranges to
    control the allowed ranges for the values. You can use them in a range input like
    so: <input type="range" min="100" max="200" step="10" />.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: min, max, *和* step—这些属性用于数字输入和范围，以控制值的允许范围。你可以在范围输入中使用它们，如下所示：<input type="range"
    min="100" max="200" step="10" />。
- en: 'readOnly—This property does exactly what it says: makes your input read-only.
    You can’t edit the value in the input field, nor will it ever invoke the onChange
    handler. This is also a Boolean property. Note the spelling with a capital O.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: readOnly—这个属性确实如其名所示：使你的输入变为只读。你无法编辑输入字段中的值，也不会触发onChange处理程序。这也是一个布尔属性。注意拼写中的大写O。
- en: disabled—If set, the input is disabled. This is different from a read-only input
    in that you can can’t focus a disabled input like you can a read-only input. Read-only
    inputs are also still considered part of the submittable data in a form, but disabled
    inputs aren’t. This is a Boolean property.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: disabled—如果设置，输入将被禁用。这与只读输入不同，因为你不能像只读输入那样聚焦禁用输入。只读输入仍然被视为表单中可提交数据的一部分，但禁用输入不是。这是一个布尔属性。
- en: list—If set to the ID of a <datalist> element elsewhere in the document, that
    data list will serve as a list of options that you can enter into the input. It’s
    kind of like a drop-down, except that the list is only a list of suggestions,
    so the input isn’t limited to those values.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: list—如果设置为文档中其他位置的<datalist>元素的ID，该数据列表将作为你可以输入到输入中的选项列表。它有点像下拉菜单，只不过列表只是建议列表，所以输入不限于这些值。
- en: maxLength—This indicates the maximum number of characters allowed in the input
    and is managed by most browsers automatically. Note the capital L in the spelling.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: maxLength—这表示允许在输入中输入的最大字符数，并且大多数浏览器会自动管理。注意拼写中的大写L。
- en: 'There are many more properties not covered here. None of these are React-specific
    but work in HTML in general. We suggest checking the MDN documentation for input
    fields if you would like to know more: [http://mng.bz/WzAg](http://mng.bz/WzAg).'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有许多其他未涵盖的属性。这些属性都不是React特定的，但在HTML中通常都适用。如果你想了解更多信息，建议查看MDN文档中关于输入字段的说明：[http://mng.bz/WzAg](http://mng.bz/WzAg)。
- en: 9.3 Managing uncontrolled inputs
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3 管理非受控输入
- en: Let’s create another very simple calculator—this time with only a single input.
    We want to create a component that, given an input, will return the sum of all
    the integers leading up to that number. So, given an input of 4, it would return
    1+2+3+4=10. There’s a very simple formula for this, which is just n*(n+1)/2, with
    n being the number to calculate the sum for. This time we’re not going to calculate
    the final value until the user clicks the Submit button. The component tree for
    creating this as a controlled component is shown in figure 9.18.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建另一个非常简单的计算器——这次只有一个输入。我们想要创建一个组件，给定一个输入，将返回所有小于或等于该数字的整数的总和。所以，给定一个输入为4，它将返回1+2+3+4=10。这里有一个非常简单的公式，即n*(n+1)/2，其中n是要计算总和的数字。这次我们不会在用户点击提交按钮之前计算最终值。创建此受控组件的组件树如图9.18所示。
- en: '![09-18](../Images/09-18.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![09-18](../Images/09-18.png)'
- en: Figure 9.18 The output JSX for an integer sum calculator. When the form submits,
    we calculate the sum, which is displayed in the output element.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.18 整数求和计算器的输出JSX。当表单提交时，我们计算总和，并在输出元素中显示。
- en: As we’ve done many times, we create a local state variable that holds the input
    value. This time, we also need another variable to hold the sum, as the sum only
    changes when the form is submitted.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们多次做的那样，我们创建一个本地状态变量来保存输入值。这次，我们还需要另一个变量来保存总和，因为只有在表单提交时总和才会改变。
- en: So, what do we need the number variable for at all? The only reason for the
    number variable is to be able to pass it back into the controlled input component.
    Sure, it’s very convenient to have, and we have full control over the input, but
    we don’t really need that control because the user can enter whatever they want
    (as long as we set min="0", as you can’t calculate the sum for negative numbers).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们为什么还需要数字变量呢？数字变量的唯一原因是可以将其传递回受控输入组件。当然，拥有它非常方便，并且我们可以完全控制输入，但我们实际上并不需要这种控制，因为用户可以输入他们想要的任何内容（只要我们设置了min="0"，因为不能计算负数的总和）。
- en: There is another way we could do this. We could let go of all control of the
    input and just have the HTML control and keep it there until we need it. We only
    need the value when the form submits and don’t really need to burden our component
    with controlling the state of the input while we work.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以用另一种方式来做这件事。我们可以放弃对输入的所有控制，只让HTML控制，并保持它直到我们需要它。我们只需要在表单提交时获取值，而实际上我们不需要在处理时让我们的组件负担控制输入状态的重任。
- en: The downside to this is that we can only control the initial value in the component;
    after that, we can’t really do anything. But we also don’t need to keep control
    of the value in this component, so that’s fine. If we implemented this, we would
    only have the sum variable in the state and calculate that in the form submit
    event handler. The resulting component tree is shown in figure 9.19.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是我们只能控制组件中的初始值；之后，我们实际上无法做任何事情。但我们也不需要在这个组件中保持对值的控制，所以这没关系。如果我们实现了这个，我们将在状态中只有一个总和变量，并在表单提交事件处理程序中计算它。结果组件树如图9.19所示。
- en: '![09-19](../Images/09-19.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![09-19](../Images/09-19.png)'
- en: Figure 9.19 The output JSX for the integer sum calculator with an uncontrolled
    input component
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.19 整数求和计算器的输出JSX，带有非受控输入组件
- en: The trick now becomes how to access the number in the input. We could make a
    reference to the input and go through ref.current.valueAsNumber, but that’s not
    necessary. The submit event will have a target property, which is a reference
    to the form element, and the form element has a direct reference to all its inputs
    by name through the .elements collection. So, because we’ve named the input "operand",
    we can access it through the form submit event object as evt.target.elements.operand.valueAsNumber.
    That’s not too shabby. Let’s implement this as shown in the next listing.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的技巧是如何访问输入中的数字。我们可以对输入创建一个引用，并通过ref.current.valueAsNumber来访问，但这不是必要的。提交事件将有一个target属性，它是对表单元素的引用，而表单元素通过.name集合直接引用其所有输入。因此，因为我们已经将输入命名为"operand"，所以我们可以通过表单提交事件对象作为evt.target.elements.operand.valueAsNumber来访问它。这并不太糟糕。让我们按照下面的列表来实现它。
- en: Listing 9.14 The sum of natural numbers
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.14 自然数的总和
- en: '[PRE21]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ We don’t store the input data in state at all.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们根本不在状态中存储输入数据。
- en: ❷ Instead of reading input values from the state, we must read them through
    the DOM. Fortunately, that’s very easy to do for form elements.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们必须通过DOM读取输入值，而不是从状态中读取。幸运的是，对于表单元素来说，这样做非常简单。
- en: ❸ Sets defaultValue but not value on the input element, and sets the name so
    it’s easy to find via the form
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在输入元素上设置defaultValue但不设置value，并设置名称以便通过表单轻松查找
- en: 'Repository: rq09-natural-sum'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库：rq09-natural-sum
- en: 'This example can be seen in repository rq09-natural-sum. You can use that repository
    by creating a new app based on the associated template:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在rq09-natural-sum仓库中看到。您可以通过创建一个基于相关模板的新应用程序来使用该仓库：
- en: '[PRE22]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以访问这个网站来浏览代码，直接在浏览器中查看应用程序的运行情况，或者下载源代码的zip文件：
- en: '[https://rq2e.com/rq09-natural-sum](https://rq2e.com/rq09-natural-sum)'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq09-natural-sum](https://rq2e.com/rq09-natural-sum)'
- en: This should work. Let’s try to run it in the browser, where you should see something
    like figure 9.20.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该可以工作。让我们尝试在浏览器中运行它，在那里你应该会看到类似图9.20的内容。
- en: '![09-20](../Images/09-20.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![09-20](../Images/09-20.png)'
- en: Figure 9.20 The natural sum calculator in action correctly calculating the sum
    for the input 4
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.20 自然数求和计算器在正确计算输入4的总和时的运行情况
- en: Note that we could have had a change event handler on the input, reading the
    value as it changes, but we didn’t need to.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们本来可以在输入上有一个变化事件处理器，读取其变化时的值，但我们不需要这么做。
- en: So, what did we gain here and what did we lose? We’ve summarized the differences
    of the two approaches in table 9.1.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们在这里得到了什么，失去了什么？我们在表9.1中总结了两种方法之间的差异。
- en: Table 9.1 Differences between controlled versus uncontrolled inputs
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 表9.1 控制与非控制输入之间的差异
- en: '|  | Controlled input | Uncontrolled input |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '|  | 控制输入 | 非控制输入 |'
- en: '| **Set initial value** | Yes. | Yes. |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| **设置初始值** | 是的。 | 是的。 |'
- en: '| **Read value as it changes** | We have to. | We can if we want to, but we
    don’t have to. |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| **读取变化时的值** | 我们必须这么做。 | 如果想的话，我们可以这么做，但不是必须的。 |'
- en: '| **Read values on submit** | Easy, we have them in state. | We have to go
    through the DOM, but definitely possible. |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| **在提交时读取值** | 很简单，我们已经在状态中有它们了。 | 我们必须通过DOM来读取，但肯定是可以做到的。 |'
- en: '| **State values** | We need them for every input. | We don’t need any at all.
    |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| **状态值** | 我们需要为每个输入使用它们。 | 我们根本不需要任何。 |'
- en: '| **Change values on the fly** | Easy. | Very difficult (but could be done
    through the DOM). |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| **动态更改值** | 很简单。 | 非常困难（但可以通过DOM实现）。 |'
- en: '| **Source of truth** | Component state value. | DOM value. |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| **数据来源** | 组件状态值。 | DOM值。 |'
- en: 9.3.1 Opportunities
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.1 机会
- en: When would you want to use an uncontrolled input, then? Table 9.1 gives us some
    hints. If you think back to the previous address form we had in listing 9.5, we
    needed a bunch of state values and change handlers, but we didn’t actually do
    anything with all of them. We simply copied the DOM values to state values and
    back again.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你什么时候会想使用非控制输入呢？表9.1给我们提供了一些提示。如果你回想一下我们之前在列表9.5中提到的地址表单，我们需要一些状态值和变化处理器，但实际上我们没有对它们做任何事情。我们只是将DOM值复制到状态值，然后再反过来。
- en: If we want to implement that same form with uncontrolled inputs, it would be
    surprisingly simple. Recall that in listing 9.5 we didn’t actually use the form
    for anything. We didn’t have a submit handler on the form. We edited the data,
    but didn’t send it anywhere.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想用非控制输入实现相同的表单，那将会非常简单。回想一下在列表9.5中，我们实际上并没有使用表单做任何事情。我们没有在表单上设置提交处理器。我们编辑了数据，但没有将其发送到任何地方。
- en: 'So, let’s say we want to make an address form, and on submit, we want to send
    the data to a remote service using a POST request at this URL: / /salespower.invalid/
    api/address. Note that this is just an example URL; it doesn’t work (the .invalid
    top-level domain also indicates that). If we expand the example in listing 9.5
    with a submit handler that sends the data as post data to this URL, it becomes
    listing 9.15.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想制作一个地址表单，并在提交时，想通过这个URL使用POST请求将数据发送到远程服务：/ /salespower.invalid/ api/address。请注意，这只是一个示例URL；它不起作用（.invalid顶级域名也表明了这一点）。如果我们将列表9.5中的示例扩展为一个提交处理器，该处理器将数据作为POST数据发送到这个URL，它就变成了列表9.15。
- en: Listing 9.15 Controlled address form with submit
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.15 控制地址表单与提交
- en: '[PRE23]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ Initializes state first
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 首先初始化状态
- en: ❷ Creates a change handler that can update the state
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个可以更新状态的变更处理器
- en: ❸ Uses the state as the data to send in the submit handler
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用状态作为提交处理器中的数据
- en: ❹ Assigns an onChange handler to every input
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 为每个输入分配一个onChange处理器
- en: ❺ The Submit button
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 提交按钮
- en: Let’s look at this with uncontrolled inputs. First of all, we don’t need any
    state value at all, and we don’t need any change handlers anywhere. Just those
    two things will greatly reduce the complexity of our form.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看非控制输入的情况。首先，我们根本不需要任何状态值，也不需要在任何地方使用变化处理器。这两件事将大大减少我们表单的复杂性。
- en: The submit handler will get a bit more complex, though, because even though
    we have an object of the state values in evt.target.elements, it’s not directly
    a list of state values, but an object of the input elements themselves. However,
    this object also contains all the form inputs as numbered indices, so form.elements[0]
    is the first element in the form, and so on. The Submit button is also an element
    of the form, but we can look at only the first six form inputs because we know
    they are the only relevant ones. We need to go over this list of elements, extract
    the name and value of each, and put that into an object.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 提交处理器将变得更加复杂，因为尽管我们在evt.target.elements中有一个状态值的对象，但它并不是直接的状态值列表，而是输入元素本身的对象。然而，这个对象也包含了所有的表单输入，作为编号索引，所以form.elements[0]是表单中的第一个元素，以此类推。提交按钮也是表单的一个元素，但我们只能查看前六个表单输入，因为我们知道它们是唯一相关的。我们需要遍历这个元素列表，提取每个的名称和值，并将它们放入一个对象中。
- en: Listing 9.16 Uncontrolled address form with submit
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.16 无控制地址表单与提交
- en: '[PRE24]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ The primary change here is in the submit handler, where we extract the current
    data directly from the form rather than reading it from the local component state
    as before.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这里的主要变化是在提交处理器，我们直接从表单中提取当前数据，而不是像以前那样从本地组件状态中读取。
- en: ❷ Adds the submit handler to the form object
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将提交处理器添加到表单对象中
- en: ❸ The Submit button
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 提交按钮
- en: If we count characters in the two different listings, the controlled variant
    in listing 9.15 comes in at 1,441 characters, whereas the uncontrolled example
    in listing 9.16 is only 1,022 characters. That’s an ~30% reduction in code! Plus,
    the controlled component renders every time the user types something, whereas
    the uncontrolled component never re-renders at all!
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们计算两个不同列表中的字符数，列表9.15中的受控变体有1,441个字符，而列表9.16中的无控制示例只有1,022个字符。这减少了大约30%的代码！此外，受控组件在用户输入时每次都会重新渲染，而未受控组件根本不会重新渲染！
- en: This almost sounds like an uncontrolled form is better, and it is in this extremely
    simple case with a form, where you don’t need to control anything. But if you
    want to control the form smartly with things such as validations, limitations,
    formatting, and so on, then you do need to make at least those fields controlled.
    To be honest, if you have such a simple address form that has no validation or
    rules and just sends the input values to a target URL using POST, you don’t need
    React (or JavaScript) at all. A regular old HTML form can do that for you.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来几乎像是无控制表单更好，在这样一个极其简单的表单案例中，你不需要控制任何东西。但如果你想要通过验证、限制、格式化等方式智能地控制表单，那么你至少需要使那些字段受控。说实话，如果你有一个如此简单的地址表单，没有验证或规则，只是使用POST将输入值发送到目标URL，你根本不需要React（或JavaScript）。一个普通的HTML表单就可以为你做到这一点。
- en: React only really shines once web applications become complex, and ditto for
    your forms. If you want to add something such as validation to any of the two
    preceding forms, it’s so much easier to do in the controlled example in listing
    9.15 than in the uncontrolled one in listing 9.16\. If you don’t need any of that,
    you might not need to control your inputs inside your React component. In fact,
    you might not even need React at all.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: React只有在网络应用变得复杂时才能真正发光，你的表单也是如此。如果你想在前面两个表单中添加验证等功能，那么在列表9.15中的受控示例中做这件事比在列表9.16中的无控制示例中要容易得多。如果你不需要这些功能，你可能不需要在React组件内部控制你的输入。事实上，你可能甚至不需要React。
- en: 9.3.2 File inputs
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.2 文件输入
- en: File inputs can *only* be uncontrolled because the value property is protected
    in the DOM as a browser security feature. You can’t directly set the value of
    a file input; you can only read it once the user selects a file to upload. The
    only thing you can do is clear the value, but you can’t in any way alter or set
    it to an initial value.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 文件输入只能是无控制的，因为值属性在DOM中被作为浏览器安全特性保护。你不能直接设置文件输入的值；你只能在用户选择上传文件后读取它。你能做的唯一一件事是清除值，但你不能以任何方式更改或将其设置为初始值。
- en: 'Thus, in React, file inputs can never be controlled. If you create a component
    with <input type="file" value={file} />, the browser will tell you to stop fooling
    around with a message like this:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在React中，文件输入永远不能被控制。如果你创建一个带有`<input type="file" value={file} />`的组件，浏览器会告诉你停止胡闹，并显示类似这样的消息：
- en: '[PRE25]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It’s not something React prevents you from doing. It’s just that the browser
    simply won’t allow you to try to set the value of a file input.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是React阻止你做的事情。只是浏览器根本不允许你尝试设置文件输入的值。
- en: So, if you need a file input in your React form, you must make (at least) that
    input uncontrolled. But because you never need to validate, limit, or format the
    current value of a file input anyway, this should be just fine.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你需要在React表单中添加文件输入，你必须至少使该输入无控制。但因为你根本不需要验证、限制或格式化文件输入的当前值，所以这应该没问题。
- en: 9.4 Quiz
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.4 测验
- en: You can only specify an initial value in a controlled input, not in an uncontrolled
    input. *True* or *false*?
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你只能在受控输入中指定初始值，不能在无受控输入中。*正确*还是*错误*？
- en: Which event handler do you use to handle input in a select box?
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你在处理下拉框中的输入时使用哪个事件处理器？
- en: onValue
  id: totrans-328
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: onValue
- en: onChange
  id: totrans-329
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: onChange
- en: onSelect
  id: totrans-330
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: onSelect
- en: onClick
  id: totrans-331
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: onClick
- en: Which of the following properties would you use to read the new state of a check
    box input in the event handler?
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会使用以下哪个属性在事件处理器中读取复选框输入的新状态？
- en: evt.target.value
  id: totrans-333
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: evt.target.value
- en: evt.target.selected
  id: totrans-334
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: evt.target.selected
- en: evt.target.checked
  id: totrans-335
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: evt.target.checked
- en: evt.target.valueAsBoolean
  id: totrans-336
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: evt.target.valueAsBoolean
- en: When you need to target an uncontrolled input node with the name "email" in
    a form submit handler, which of the follow is the correct way to do it?
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您需要在表单提交处理程序中针对名为 "email" 的未受控输入节点时，以下哪种方法是正确的？
- en: evt.target.inputs.email
  id: totrans-338
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: evt.target.inputs.email
- en: evt.target.email
  id: totrans-339
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: evt.target.email
- en: evt.target.nodes.email
  id: totrans-340
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: evt.target.nodes.email
- en: evt.target.elements.email
  id: totrans-341
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: evt.target.elements.email
- en: Which two properties are required on a controlled input element?
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在受控输入元素上需要哪两个属性？
- en: name
  id: totrans-343
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: name
- en: value
  id: totrans-344
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: value
- en: defaultValue
  id: totrans-345
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: defaultValue
- en: onChange
  id: totrans-346
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: onChange
- en: Quiz answers
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问答答案
- en: '*False*. Setting the initial value is possible in both modes. You can’t update
    the value after the initial value in the uncontrolled input, but you *can* set
    the initial value.'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*错误*。在两种模式下都可以设置初始值。在未受控输入中，您不能更新初始值之后的价值，但您可以*设置*初始值。'
- en: You always use the onChange event handler, regardless of which form input element
    you’re using.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无论您使用哪个表单输入元素，您始终使用 onChange 事件处理器。
- en: The state of a check box input element is stored in the checked property, so
    you would access it as evt.target.checked in the change handler.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复选框输入元素的状态存储在 checked 属性中，因此您可以在更改处理程序中通过 evt.target.checked 访问它。
- en: Form elements are accessible through the form element in the DOM via the elements
    property. A form element named "email" would be reachable from a form submit handler
    through evt.target.elements.email.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 表单元素可以通过 DOM 中的表单元素通过 elements 属性访问。名为 "email" 的表单元素可以通过表单提交处理器的 evt.target.elements.email
    访问。
- en: All controlled inputs must always have the value and the onChange properties
    defined.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有受控输入必须始终定义值和 onChange 属性。
- en: Summary
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Handling form data is a first-class priority in React, and forms and inputs
    are very easy to work with.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理表单数据是 React 中的首要任务，表单和输入非常容易处理。
- en: Form input elements can be either controlled or uncontrolled.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表单输入元素可以是受控的或未受控的。
- en: The recommended approach is to use controlled inputs, which give you the option
    to validate, modify, and filter input on the fly.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建议使用受控输入，这为您提供了在飞行中验证、修改和过滤输入的选项。
- en: To use a controlled input, you must specify the value and onChange properties
    on the input element in JSX and “confirm” every change by updating the value property.
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使用受控输入，您必须在 JSX 中的输入元素上指定值和 onChange 属性，并通过更新值属性“确认”每次更改。
- en: The alternative is to use uncontrolled inputs, which reduce your options of
    modifying data but also reduce the amount of code you need to work with for forms
    that require little data control.
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一种选择是使用未受控输入，这减少了修改数据的选择，但也减少了处理需要少量数据控制的表单所需的代码量。
- en: Uncontrolled inputs can specify the initial value using defaultValue, but must
    not set the value property.
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未受控输入可以使用 defaultValue 指定初始值，但不能设置 value 属性。
- en: You can use all types of HTML inputs in React, including but not limited to,
    text inputs, number inputs, calendar and time inputs, password inputs, check boxes,
    radio buttons, drop-downs, range meters, and text areas.
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在 React 中使用所有类型的 HTML 输入，包括但不限于文本输入、数字输入、日历和时间输入、密码输入、复选框、单选按钮、下拉菜单、范围计和文本区域。
- en: Some input types have some slight variations in the API, for example, reading
    the state of check boxes, radio buttons, and multiselect boxes.
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些输入类型在 API 中有一些细微的差异，例如，读取复选框、单选按钮和多选框的状态。
- en: File inputs can only ever be uncontrolled, as you can’t control the value of
    a file input in JavaScript.
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件输入只能始终是未受控的，因为在 JavaScript 中无法控制文件输入的值。
