- en: '14 Rhymer: Using regular expressions to create rhyming words'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14 Rhymer：使用正则表达式创建押韵单词
- en: '| In the movie *The Princess Bride*, the characters Inigo and Fezzik have a
    rhyming game they like to play, especially when their cruel boss, Vizzini, yells
    at them:Inigo: That Vizzini, he can fuss.Fezzik: I think he likes to scream at
    us.Inigo: Probably he means no harm.Fezzik: He’s really very short on charm.When
    I was writing the alternate.txt for chapter 7, I would come up with a word like
    “cyanide” and wonder what I could rhyme with that. Mentally I started with the
    first consonant sound of the alphabet and substituted “b” for “byanide,” skipped
    “c” because that’s already the first character, then “d” for “dyanide,” and so
    forth. This is effective but tedious, so I decided to write a program to do this
    for me, as one does. | ![](../Images/14-unnumb-1.png)  |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: 在电影《公主新娘》中，角色伊尼奥和菲兹克喜欢玩一个押韵游戏，尤其是在他们残酷的老板维兹尼对他们大喊大叫时：伊尼奥：那个维兹尼，他可以挑剔。菲兹克：我想他喜欢对我们大喊大叫。伊尼奥：可能他并无恶意。菲兹克：他真的很缺乏魅力。当我为第7章编写alternate.txt时，我会想出一个像“氰化物”这样的词，然后想知道我能和它押韵什么。我在心里从字母表中的第一个辅音音素开始，用“b”代替“byanide”，跳过“c”，因为那已经是第一个字符，然后用“d”代替“dyanide”，以此类推。这种方法很有效，但也很繁琐，所以我决定写一个程序来帮我做这件事，就像人们通常会做的那样。|
    ![图片](../Images/14-unnumb-1.png) |
- en: This is basically another find-and-replace type of program, like swapping all
    the numbers in a string in chapter 4 or all the vowels in a string in chapter
    8\. We wrote those programs using very manual, *imperative* methods, like iterating
    through all the characters of a string, comparing them to some wanted value, and
    possibly returning a new value.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上又是一个查找并替换类型的程序，就像在第4章中交换字符串中的所有数字或在第8章中交换字符串中的所有元音一样。我们使用非常手动、**命令式**的方法编写了这些程序，比如遍历字符串中的所有字符，将它们与某个想要的价值进行比较，并可能返回一个新值。
- en: In the final solution for chapter 8, we briefly touched on “regular expressions”
    (also called “regexes”--pronounced with a soft “g” like in “George”), which give
    us a *declarative* way to describe patterns of text. The material here may seem
    a bit of a reach, but I really want to help you dig into regexes to see what they
    can do.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在第8章的最终解决方案中，我们简要提到了“正则表达式”（也称为“regexes”——发音时“g”的音轻柔，就像在“George”中一样），它为我们提供了一种**声明式**的方式来描述文本的模式。这里的材料可能有点超出了范围，但我真的很想帮助你深入了解正则表达式，看看它们能做什么。
- en: '| In this chapter, we’re going to take a given word and create “words” that
    rhyme. For instance, the word “bake” rhymes with words like “cake,” “make,” and
    “thrake,” the last of which isn’t actually a dictionary word but just a new string
    I created by replacing the “b” in “bake” with “thr.”The algorithm we’ll use will
    split a word into any initial consonants and the rest of the word, so “bake” is
    split into “b” and “ake.” We’ll replace the “b” with all the other consonants
    from the alphabet plus these consonant clusters: | ![](../Images/14-unnumb-2.png)  |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '| 在本章中，我们将取一个给定的单词，并创建“押韵的单词”。例如，单词“bake”与“cake”、“make”和“thrake”等单词押韵，最后一个实际上并不是字典中的单词，而只是我用“thr”替换“bake”中的“b”创建的新字符串。我们将使用的算法将单词拆分为任何初始辅音和单词的其余部分，所以“bake”被拆分为“b”和“ake”。我们将用字母表中所有其他辅音以及这些辅音簇替换“b”：|
    ![图片](../Images/14-unnumb-2.png) |'
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'These are the first three words our program will produce for “cake”:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们程序为“cake”生成的前三个单词：
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And these are the last three:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这最后三个：
- en: '[PRE2]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Make sure your output is sorted alphabetically as this is important for the
    tests.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的输出按字母顺序排序，这对于测试很重要。
- en: 'We’ll replace any leading consonants with a list of other consonant sounds
    to create a total of 56 words:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用其他辅音音素列表替换任何开头的辅音，以创建总共56个单词：
- en: '[PRE3]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Note that we’ll replace *all* the leading consonants, not just the first one.
    For instance, with the word “chair” we need to replace “ch”:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们将**替换**所有开头的辅音，而不仅仅是第一个。例如，对于单词“chair”，我们需要替换“ch”：
- en: '[PRE4]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If a word like “apple” does not start with a consonant, we’ll append all the
    consonant sounds to the beginning to create words like “bapple” and “shrapple.”
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果像“apple”这样的单词不以辅音开头，我们将把所有辅音音素附加到开头，以创建像“bapple”和“shrapple”这样的单词。
- en: '[PRE5]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Because there is no consonant to *replace*, words that start with a vowel will
    produce 57 rhyming words:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 因为没有辅音可以**替换**，以元音开头的单词将产生57个押韵单词：
- en: '[PRE6]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To make this a bit easier, the output should always be all lowercase, even
    if the input has uppercase letters:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这更容易，输出应始终为全部小写，即使输入有大写字母：
- en: '[PRE7]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If a word contains nothing but consonants, we’ll print a message stating that
    the word cannot be rhymed:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个单词只包含辅音，我们将打印一条消息，说明该单词不能押韵：
- en: '|'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE8]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The task of finding the initial consonants is made significantly easier with
    regexes.In this program, you will
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用正则表达式可以显著简化查找首字母音的任务。在这个程序中，你将
- en: Learn to write and use regular expressions
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习编写和使用正则表达式
- en: Use a guard with a list comprehension
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用列表推导式中的守卫
- en: Explore the similarities of list comprehension with a guard to the `filter()`
    function
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索列表推导式与守卫与`filter()`函数的相似之处
- en: Entertain ideas of “truthiness” when evaluating Python types in a Boolean context
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在布尔上下文中评估Python类型时，考虑“真值”的概念
- en: '| ![](../Images/14-unnumb-3.png)  |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| ![图片](../Images/14-unnumb-3.png) |'
- en: 14.1 Writing rhymer.py
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.1 编写rhymer.py
- en: The program takes a single, positional argument, which is the string to rhyme.
    Figure 14.1 shows a snazzy, jazzy, frazzy, thwazzy string diagram.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序接受一个单一的位置参数，即要押韵的字符串。图14.1展示了一个时髦的、爵士的、混乱的、刺耳的字符串图。
- en: '![](../Images/14-1.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/14-1.png)'
- en: Figure 14.1 The input for our rhymer program should be a word, and the output
    will be a list of rhyming words or an error.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1 我们rhymer程序的输入应该是单词，输出将是押韵单词的列表或错误。
- en: 'If given no arguments or the `-h` or `--help` flags, it should print a usage
    statement:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有提供参数或`-h`或`--help`标志，它应该打印一个用法说明：
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 14.1.1 Breaking a word
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.1 分解单词
- en: To my mind, the main problem of the program is breaking the given word into
    the leading consonant sounds and the rest--something like the “stem” of the word.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，该程序的主要问题是将给定的单词分解为首字母音和其余部分——类似于单词的“词干”。
- en: 'To start out, we can define a placeholder for a function I call `stemmer()`
    that does nothing right now:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以定义一个占位符函数，我称之为`stemmer()`，目前它什么也不做：
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ① The pass statement will do nothing at all. Since the function does not return
    a value, Python will return None by default.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ① `pass`语句将什么都不做。由于函数不返回值，Python默认返回None。
- en: 'Then we can define a `test_stemmer()` function to help us think about the values
    we might give the function and what we expect it to return. We want a test with
    good values like “cake” and “apple” that can be rhymed as well as values like
    the empty string or a number, which cannot:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以定义一个`test_stemmer()`函数来帮助我们思考可能提供给函数的值以及我们期望它返回什么。我们想要一个包含像“cake”和“apple”这样的良好值，这些值可以押韵，以及像空字符串或数字这样的值，这些值不能押韵：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The tests cover the following good and bad inputs:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 测试涵盖了以下良好和不良输入：
- en: ① The empty string
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ① 空字符串
- en: ② A word with a single leading consonant
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ② 以单个首字母开头的单词
- en: ③ A word with a leading consonant cluster
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 以首字母音簇开头的单词
- en: ④ A word with no initial consonants; also an uppercase word, so this checks
    that lowercase is returned
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 没有首字母音的单词；也是一个大写单词，因此这检查是否返回了小写
- en: ⑤ A word with no vowels
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 没有元音的单词
- en: ⑥ Something that isn’t a word at all
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 完全不是单词的东西
- en: I decided that my `stemmer()` function will always returns a 2-tuple of the
    `(start,` `rest)` of the word. (You can write a function that does something different,
    but be sure to change the test to match.) It’s the second part of that `tuple`--the
    `rest`--that we can use to create rhyming words. For instance, the word “cake”
    produces a `tuple` with `('c',` `'ake')`, and “chair” is split into `('ch',` `'air')`.
    The argument “`APPLE`” has no `start` and only the `rest` of the word, which is
    lowercase.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我决定我的`stemmer()`函数将始终返回一个包含`(start, rest)`的2元组。（你可以编写一个执行不同操作的函数，但请确保更改测试以匹配。）我们可以使用该元组的第二部分——`rest`——来创建押韵的单词。例如，单词“cake”产生一个包含`('c',
    'ake')`的元组，而“chair”被分割成`('ch', 'air')`。参数“`APPLE`”没有`start`，只有单词的`rest`部分，它是小写的。
- en: 'When I’m writing tests, I usually try to provide both good and bad data to
    my functions and programs. Three of the test values cannot be rhymed: the empty
    string (`''''`), a string with no vowels (`''RDNZL''`), and a string with no letters
    (`''123''`). The `stemmer()` function will still return a `tuple` containing the
    lowercased word in the first position of the tuples and the empty string in the
    second position for the `rest` of the word. It is up to the calling code to deal
    with a word that has no part that can be used to rhyme.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当我编写测试时，我通常尝试为我的函数和程序提供良好和不良的数据。三个测试值不能押韵：空字符串(`''`)、没有元音的字符串(`'RDNZL'`)和没有字母的字符串(`'123'`)。`stemmer()`函数仍然会返回一个包含在元组的第一个位置的小写字符串和在元组的第二个位置为单词的其余部分的空字符串的元组。处理一个没有可以用来押韵的部分的单词取决于调用代码。
- en: 14.1.2 Using regular expressions
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.2 使用正则表达式
- en: It’s certainly *possible* to write this program without regular expressions,
    but I hope you’ll see how radically different using regexes can be from manually
    writing your own search-and-replace code.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，*可能*不使用正则表达式编写这个程序，但我希望你能看到使用正则表达式与手动编写自己的搜索和替换代码有多么不同。
- en: 'To start off, we need to bring in the `re` module:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要引入`re`模块：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: I encourage you to read `help(re)` to get a feel for all that you can do with
    regexes. They are a deep subject with many books and whole branches of academia
    devoted to them (*Mastering Regular Expressions* by Jeffrey Friedl (O’Reilly,
    2006) is one book I would recommend). There are many helpful websites that can
    further explain regexes, and some can help you write them (such as [https://regexr.com/](https://regexr.com/)).
    We will only scratch the surface of what you can do with regexes.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励你阅读`help(re)`来了解你可以用正则表达式做什么。这是一个深奥的主题，有无数本书和整个学术分支都致力于这个主题（杰弗里·弗里德尔的《精通正则表达式》（O’Reilly，2006）是我推荐的一本书）。有许多有用的网站可以进一步解释正则表达式，有些可以帮助你编写它们（例如[https://regexr.com/](https://regexr.com/)）。我们将只触及正则表达式所能做的表面。
- en: Our goal in this program is to write a regex that will find consonants at the
    beginning of a string. We can define consonants as the characters of the English
    alphabet that are not vowels (“a,” “e,” “i,” “o,” and “u”). Our `stemmer()` function
    will only return lowercase letters, so there are only 21 consonants we need to
    define. You could write them out, but I’d rather write a bit of code!
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，我们的目标是编写一个正则表达式，以找到字符串开头的辅音。我们可以将辅音定义为不是元音的英语字母（“a”，“e”，“i”，“o”和“u”）。我们的`stemmer()`函数将只返回小写字母，所以我们只需要定义21个辅音。你可以把它们写出来，但我更愿意写一点代码！
- en: 'We can start with `string.ascii_lowercase`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从`string.ascii_lowercase`开始：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we can use a list comprehension with a “guard” clause to filter out the
    vowels. As we want a `str` of consonants and not a `list`, we can use `str.join()`
    to make a new `str` value:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用一个带有“守卫子句”的列表推导式来过滤掉元音。因为我们想要一个`str`的辅音而不是一个`list`，我们可以使用`str.join()`来创建一个新的`str`值：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The longer way to write this with a `for` loop and an `if` statement is as
    follows (see figure 14.2):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`for`循环和`if`语句的更长的写法如下（见图14.2）：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![](../Images/14-2.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图14-2](../Images/14-2.png)'
- en: Figure 14.2 The `for` loop (top) can be written as a list comprehension (bottom).
    This list comprehension includes a guard so that only consonants are selected,
    which is like the `if` statement at the top.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.2 `for`循环（顶部）可以写成列表推导式（底部）。这个列表推导式包含一个守卫子句，以确保只选择辅音，这就像顶部的`if`语句。
- en: 'In chapter 8 we created a “character class” for matching the vowels by listing
    them in square brackets, like `''[aeiou]''`. We can do the same here with our
    `consonants`, like so:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在第8章中，我们创建了一个“字符类”来匹配元音，通过在方括号中列出它们，如`'[aeiou]'`。我们也可以用我们的`consonants`这样做：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `re` module has two search-like functions called `re.match()` and `re.search()`,
    and I always get them confused. They both look for a `pattern` (the first argument)
    in some `text`, but the `re.match()` functions starts *from the beginning* of
    the `text`, whereas the `re.search()` function will match starting *anywhere*
    in the `text`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`re`模块有两个类似于搜索的函数，称为`re.match()`和`re.search()`，我总是把它们搞混。它们都在某个`text`中寻找一个`pattern`（第一个参数），但`re.match()`函数从`text`的`beginning`开始，而`re.search()`函数将在`text`的任何地方进行匹配。'
- en: As it happens, `re.match()` is just fine because we are looking for consonants
    at the beginning of a string (see figure 14.3).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，`re.match()`非常合适，因为我们正在寻找字符串开头的辅音（见图14.3）。
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ① Try to match the given pattern in the given text. If this succeeds, we get
    a re.Match object; otherwise, the value None is returned.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ① 尝试在给定文本中匹配给定的模式。如果成功，我们得到一个re.Match对象；否则，返回None值。
- en: ② The match was successful, so we see a “stringified” version of the re.Match
    object.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ② 匹配成功，所以我们看到了re.Match对象的“字符串化”版本。
- en: '![](../Images/14-3.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图14-3](../Images/14-3.png)'
- en: Figure 14.3 The character class of consonants will match the “c” at the beginning
    of “chair.”
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.3 辅音字符类将与“chair”开头的“c”匹配。
- en: 'The `match=''c''` shows us that the regular expression found the string `''c''`
    at the beginning. Both the `re.match()` and `re.search()` functions will return
    a `re.Match` object on success. You can read `help(re.Match)` to learn more about
    all the cool things you can do with them:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`match=''c''`显示正则表达式找到了字符串`''c''`在开头。`re.match()`和`re.search()`函数在成功时都会返回一个`re.Match`对象。你可以阅读`help(re.Match)`来了解更多关于你可以用它们做什么的酷东西：'
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'How do we get our regex to match the letters `''ch''`? We can put a `''+''`
    sign after the character class to say we want *one or more* (see figure 14.4).
    (Does this sound a bit like `nargs=''+''` to say one or more arguments?) I will
    use an f-string here to create the pattern:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何让正则表达式匹配字母`'ch'`？我们可以在字符类后跟一个`'+'`符号来表示我们想要*一个或多个*（这听起来有点像`nargs='+'`来表示一个或多个参数？）我将在这里使用f-string来创建模式：
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '![](../Images/14-4.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/14-4.png)'
- en: Figure 14.4 Adding a plus sign to the class will match one or more characters.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.4 在类名中添加加号将匹配一个或多个字符。
- en: What does it give us for a string with no leading consonants like “apple,” as
    in figure 14.5?
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像“apple”这样的没有前导辅音的字符串，它给我们带来了什么，如图14.5所示？
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![](../Images/14-5.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/14-5.png)'
- en: Figure 14.5 This regex fails to match a word that does not start with a consonant.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.5 这个正则表达式未能匹配以辅音开头的单词。
- en: It seems we got nothing back from that. What is the `type()` of that return
    value?
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们没有从那里得到任何东西。那个返回值的`type()`是什么？
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Both the `re.match()` and `re.search()` functions return `None` to indicate
    a failure to match any text. We know that only some words will have a leading
    consonant sound, so this is not surprising. We’ll see in a moment how to make
    this an optional match.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`re.match()`和`re.search()`函数都返回`None`来指示未能匹配任何文本。我们知道只有一些单词会有前导辅音音素，所以这并不奇怪。我们很快就会看到如何将其变为可选匹配。'
- en: 14.1.3 Using capture groups
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.3 使用捕获组
- en: 'It’s all well and good to have found (or not) the leading consonants, but the
    goal here is to split the `text` into two parts: the consonants (if any) and the
    rest of the word.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 找到（或未找到）前导辅音固然很好，但这里的目的是将`text`分成两部分：辅音（如果有）和单词的其余部分。
- en: 'We can wrap parts of the regex in parentheses to create “capture groups.” If
    the regex matches successfully, we can recover the parts using the `re.Match.groups()`
    method (see figure 14.6):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将正则表达式的一部分用括号括起来以创建“捕获组”。如果正则表达式匹配成功，我们可以使用`re.Match.groups()`方法恢复这些部分（见图14.6）：
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '![](../Images/14-6.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/14-6.png)'
- en: Figure 14.6 Adding parentheses around a pattern causes the matching text to
    be available as a capture group.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.6 在模式周围添加括号会使匹配的文本作为捕获组可用。
- en: 'To capture everything that comes after the `consonants`, we can use a period
    (`.`) to match anything, and add a plus sign (`+`) to mean one or more. We can
    put that into parentheses to capture it (see figure 14.7):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要捕获`consonants`之后的所有内容，我们可以使用点（`.`）来匹配任何内容，并添加一个加号（`+`）表示一个或多个。我们可以将这个放入括号中以便捕获它（见图14.7）：
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![](../Images/14-7.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/14-7.png)'
- en: Figure 14.7 We define two capture groups to access the leading consonant sound
    and whatever follows.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.7 我们定义了两个捕获组来访问前导辅音音素和随后的任何内容。
- en: 'What happens when we try to use this on “apple”? It fails to make the first
    match on the consonants, so *the whole match fails* and returns `None` (see figure
    14.8):'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试在“apple”上使用这个模式时，它未能匹配到辅音，因此*整个匹配失败*并返回`None`（见图14.8）：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '![](../Images/14-8.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/14-8.png)'
- en: Figure 14.8 The pattern still fails when the text starts with a vowel.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.8 当文本以元音开头时，模式仍然失败。
- en: 'Remember that `re.match()` returns `None` when it fails to find the pattern.
    We can add a question mark (`?`) at the end of the `consonants` pattern to make
    it optional (see figure 14.9):'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`re.match()`在未能找到模式时返回`None`。我们可以在`consonants`模式的末尾添加一个问号（`?`）使其变为可选（见图14.9）：
- en: '[PRE25]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '![](../Images/14-9.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/14-9.png)'
- en: Figure 14.9 A question mark after a pattern makes it optional.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.9 在模式后跟一个问号使其变为可选。
- en: 'The `match.groups()` function returns a `tuple` containing the matches for
    each grouping created by the parentheses. You can also use `match.group()` (singular)
    with a group number to get a specific group. Note that these start numbering from
    1:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`match.groups()`函数返回一个包含每个由括号创建的分组匹配的`tuple`。您也可以使用`match.group()`（单数）与一个组号来获取特定的组。请注意，这些从1开始编号：'
- en: '[PRE26]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ① There was no match for the first group on “apple,” so this is a None.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ① 在“apple”上没有匹配到第一组，因此这是一个None。
- en: ② The second group captured the entire word.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ② 第二组捕获了整个单词。
- en: 'If you match on “chair,” there are values for both groups:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在“chair”上匹配，两组都有值：
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'So far we’ve only dealt with lowercase text because our program will always
    emit lowercase values. Still, let’s explore what happens when we try to match
    uppercase text:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只处理了小写文本，因为我们的程序将始终输出小写值。不过，让我们探索一下当我们尝试匹配大写文本时会发生什么：
- en: '[PRE28]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Not surprisingly, that fails. Our pattern only defines lowercase characters.
    We could add all the uppercase consonants, but it’s a bit easier to use a third
    optional argument to `re.match()` to specify case-insensitive searching:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，这失败了。我们的模式只定义了小写字母。我们可以添加所有大写辅音，但使用 `re.match()` 的第三个可选参数来指定不区分大小写的搜索要容易一些：
- en: '[PRE29]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Or you can force the text you are searching to lowercase:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以强制将你正在搜索的文本转换为小写：
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: What do you get when you search on text that has nothing but consonants?
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在只有辅音的文本上搜索时，你会得到什么？
- en: '[PRE31]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Were you expecting the first group to include *all* the consonants and the second
    group to have nothing? It might seem a bit odd that it decided to split off the
    “l” into the last group, as shown in figure 14.10, but we have to think *extremely
    literally* about how the regex engine is working. We described an optional group
    of one or more consonants that *must be followed* by one or more of anything else.
    The “l” counts as one or more of anything else, so the regex matched exactly what
    we requested.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否期望第一个组包含所有辅音，而第二个组没有任何内容？它决定将“l”拆分到最后一组，如图 14.10 所示，这似乎有点奇怪，但我们必须极其字面地思考正则表达式引擎是如何工作的。我们描述了一个可选的包含一个或多个辅音的组，该组必须由一个或多个其他任何内容跟随。这里的“l”算作一个或多个其他任何内容，所以正则表达式正好匹配我们所请求的内容。
- en: '![](../Images/14-10.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.10](../Images/14-10.png)'
- en: Figure 14.10 The regex does exactly what we ask, but perhaps not what we wanted.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.10 正则表达式正好做了我们要求的事情，但可能不是我们想要的。
- en: 'If we change the `(.+)` to `(.*)` to make it *zero or more*, it works as expected:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 `(.+)` 改为 `(.*)` 以使其变为“零或更多”，它将按预期工作：
- en: '[PRE32]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Our regex is not quite complete, as it doesn’t handle matching on something
    like `123`. That is, it matches too well because the period (`.`) will match the
    digits, which we don’t want:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的正则表达式还不完整，因为它不处理匹配类似 `123` 的情况。也就是说，它匹配得太好了，因为点号 (`.`) 会匹配数字，而我们不希望这样：
- en: '[PRE33]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We need to indicate that there should be *at least one vowel* after the consonants,
    which may be followed by anything else. We can use another character class to
    describe any vowel. Since we need to capture this, we’ll put it in parentheses,
    so `([aeiou])`. That may be followed by *zero or more* of anything, which also
    needs to be captured, so `(.*)`, as shown in figure 14.11.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要表明在辅音之后应该至少有一个元音，这可能由任何其他内容跟随。我们可以使用另一个字符类来描述任何元音。由于我们需要捕获这个，我们将它放在括号中，所以
    `([aeiou])`。这可能由零个或多个任何内容跟随，这也需要被捕获，所以 `(.*)`，如图 14.11 所示。
- en: '![](../Images/14-11.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.11](../Images/14-11.png)'
- en: Figure 14.11 The regex now requires the presence of a vowel.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.11 正则表达式现在要求存在元音。
- en: 'Let’s go back and try this on values we expect to work:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到这里，尝试在预期会工作的值上操作：
- en: '[PRE34]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As you can see, this fails to match when the string contains no vowels or letters:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，当字符串不包含元音或字母时，这无法匹配：
- en: '[PRE35]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 14.1.4 Truthiness
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.4 真实性
- en: We know that our program will receive some inputs that cannot be rhymed, so
    what should the `stemmer()` function do with these? Some people like to use exceptions
    in cases like this. We’ve encountered exceptions like asking for a list index
    or a dictionary key that does not exist. If exceptions are not caught and handled,
    they cause our programs to crash!
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们的程序将接收到一些无法押韵的输入，那么 `stemmer()` 函数对这些应该怎么办？有些人喜欢在这种情况下使用异常。我们遇到过请求列表索引或不存在字典键的异常。如果异常没有被捕获和处理，它们会导致我们的程序崩溃！
- en: 'I try to avoid writing code that creates exceptions. I decided that my `stemmer()`
    function would always return a 2-tuple of `(start,` `rest)`, and that I would
    always use the empty string to denote a missing value rather than a `None`. Here
    is one way I could write the code for returning those tuples:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我尽量避免编写会创建异常的代码。我决定我的 `stemmer()` 函数总是返回一个 `(start, rest)` 的 2-元组，并且我会始终使用空字符串来表示缺失值，而不是
    `None`。以下是我可以编写代码返回这些元组的一种方式：
- en: '[PRE36]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: ① The match will be None if the regex failed, which is “falsey.” If it succeeds,
    then it will be “truthy.”
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ① 如果正则表达式失败，匹配将是 `None`，这是“假值”。如果它成功，那么它将是“真值”。
- en: ② There are three capture groups that we can put into three variables. We want
    to ensure we don’t return any None values, so we can use an “or” to evaluate the
    left side as “truthy” and take the empty string on the right if it’s not.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们可以将三个捕获组放入三个变量中。我们想要确保不返回任何 `None` 值，所以我们可以使用“或”来评估左侧作为“真值”，如果它不是，则取右侧的空字符串。
- en: ③ Return a tuple that has the first part of the word (maybe consonants) and
    the “rest” of the word (the vowel plus anything else).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 返回一个元组，包含单词的第一个部分（可能是辅音）和“剩余”部分（元音加上其他任何内容）。
- en: ④ If the match was None, return a tuple of the word and an empty string to indicate
    there is no “rest” of the word to rhyme.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 如果匹配结果是None，返回一个包含单词和空字符串的元组，以表示没有“剩余”的单词可以押韵。
- en: 'Let’s take a moment to think about the `or` operator, which we’re using to
    decide between something on the left *or* something on the right. The `or` will
    return the first “truthy” value, the one that--sort of, kind of--evaluates to
    `True` in a Boolean context:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花点时间思考一下`or`运算符，我们正在使用它来决定是选择左边的内容还是右边的内容。`or`将返回第一个“真值”，即那种在布尔上下文中——某种程度上，多少有点——评估为`True`的值：
- en: '[PRE37]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: ① It’s easiest to see with literal True and False values.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ① 最容易看到的是直接的真值和假值。
- en: ② No matter the order, the True value will be taken.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ② 不论顺序如何，都会取真值。
- en: ③ In a Boolean context, the integer value 0 is “falsey,” and any other value
    is “truthy.”
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 在布尔上下文中，整数值0是“假值”，任何其他值都是“真值”。
- en: ④ The number values behave exactly like actual Boolean values.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 数字值的行为与实际的布尔值完全一样。
- en: ⑤ Floating-point values also behave like integer values, where 0.0 is “falsey”
    and anything else is “truthy.”
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 浮点值也像整数值一样表现，其中0.0是“假值”，其他任何内容都是“真值”。
- en: ⑥ With string values, the empty string is “falsey” and anything else is “truthy.”
    It may look odd because it returns '0', but that’s not the numeric value zero
    but the string we use to represent the value of zero. Wow, so philosophical.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 对于字符串值，空字符串是“假值”，其他任何内容都是“真值”。这看起来可能有点奇怪，因为它返回的是'0'，但这并不是数字0，而是我们用来表示0值的字符串。哇，这真是有哲学意味。
- en: ⑦ If no value is “truthy,” the last value is returned.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 如果没有值是“真值”，则返回最后一个值。
- en: ⑧ The empty list is “falsey,” so any non-empty list is “truthy.”
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 空列表是“假值”，所以任何非空列表都是“真值”。
- en: ⑨ The empty dict is “falsey,” and any non-empty dict is “truthy.”
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 空字典是“假值”，任何非空字典都是“真值”。
- en: 'You should be able to use these ideas to write a `stemmer()` function that
    will pass the `test_stemmer()` function. Remember, if both of these functions
    are in your rhymer.py program, you can run the `test_` functions like so:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够使用这些想法来编写一个`stemmer()`函数，该函数将传递`test_stemmer()`函数。记住，如果这两个函数都在你的`rhymer.py`程序中，你可以这样运行`test_`函数：
- en: '[PRE38]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 14.1.5 Creating the output
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.5 创建输出
- en: 'Let’s review what the program should do:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下程序应该做什么：
- en: Take a positional string argument.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接收一个位置字符串参数。
- en: 'Try to split it into two parts: any leading consonants and the rest of the
    word.'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试将其分成两部分：任何前面的辅音字母和单词的其余部分。
- en: If the split is successful, combine the “rest” of the word (which might actually
    be the entire word if there are no leading consonants) with all the other consonant
    sounds. Be sure to *not* include the original consonant sound and to sort the
    rhyming strings.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果拆分成功，将单词的“剩余”部分（如果前面没有辅音字母，实际上可能是整个单词）与所有其他辅音音素结合起来。确保不要包括原始的辅音音素，并对押韵字符串进行排序。
- en: If you are unable to split the word, print the message `Cannot` `rhyme` `"<word>"`.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果无法拆分单词，打印消息`Cannot` `rhyme` `"<word>"`。
- en: Now it’s time to write the program. Have fun storming the castle!
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候编写程序了。祝你在攻打城堡时玩得开心！
- en: 14.2 Solution
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.2 解决方案
- en: “No more rhymes now, I mean it!”
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: “现在没有押韵了，我是认真的！”
- en: “Anybody want a peanut?”
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: “有人想要花生吗？”
- en: Let’s take a look at one way to solve this problem. How different was your solution?
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看解决这个问题的方法之一。你的解决方案与这个方法有多大的不同？
- en: '[PRE39]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: ① The re module is for regular expressions.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ① `re`模块是用于正则表达式的。
- en: ② Get the command-line arguments.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ② 获取命令行参数。
- en: ③ Define all the prefixes that will be added to create rhyming words.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 定义所有将要添加以创建押韵词的前缀。
- en: ④ Split the word argument into two possible parts. Because the stemmer() function
    always returns a 2-tuple, we can unpack the values into two variables.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 将单词参数分成两个可能的组成部分。因为`stemmer()`函数总是返回一个2元组，所以我们可以将值解包到两个变量中。
- en: ⑤ Check if there is a part of the word that we can use to create rhyming strings.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 检查是否有可以用来创建押韵字符串的单词部分。
- en: ⑥ If there is, use a list comprehension to iterate through all the prefixes
    and add them to the stem of the word. Use a guard to ensure that any given prefix
    is not the same as the beginning of the word. Sort all the values and print them,
    joined on newlines.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 如果有，使用列表推导式遍历所有前缀并将它们添加到单词的词干中。使用守卫来确保任何给定前缀都不与单词的开头相同。对所有值进行排序并按新行连接打印它们。
- en: ⑦ If there is nothing for the “rest” of the word that can be used to create
    rhymes, let the user know.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 如果没有可以用来创建押韵的“剩余”单词部分，让用户知道。
- en: ⑧ Lowercase the word.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 将单词转换为小写。
- en: ⑨ Since we will use the vowels more than once, assign them to a variable.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 由于我们将多次使用元音，所以将它们分配给一个变量。
- en: ⑩ The consonants are the letters that are not vowels. We will only match to
    lowercase letters.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ 辅音是指不是元音的字母。我们只会匹配小写字母。
- en: ⑪ The pattern is defined using consecutive literal strings that Python will
    join together into one string. By breaking up the pieces onto separate lines,
    we can comment on each part of the regular expression.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ⑪ 模式使用连续的字符串字面量定义，Python 将将其连接成一个字符串。通过将片段拆分到单独的行上，我们可以对正则表达式的每一部分进行注释。
- en: ⑫ Use the re.match() function to start matching at the beginning of the word.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ⑫ 使用 `re.match()` 函数从单词的开始进行匹配。
- en: ⑬ The re.match() function will return None if the pattern failed to match, so
    check if the match is “truthy” (not None).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ⑬ 如果模式匹配失败，`re.match()` 函数将返回 None，因此请检查匹配是否为“真值”（非 None）。
- en: ⑭ Put each group into a variable, always ensuring that we use the empty string
    rather than None.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ⑭ 将每个组放入变量中，始终确保我们使用空字符串而不是 None。
- en: ⑮ Return a new tuple that has the “first” part of the word (possible leading
    consonants) and the “rest” of the word (the vowel plus anything else).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ⑮ 返回一个新的元组，包含单词的“第一”部分（可能的引导辅音）和单词的“其余”部分（元音加上其他任何内容）。
- en: ⑯ If the match failed, return the word and an empty string for the “rest” of
    the word to indicate there is nothing to rhyme.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ⑯ 如果匹配失败，返回单词和空字符串作为“剩余”部分，以表示没有可以押韵的部分。
- en: ⑰ The tests for the stemmer() function. I usually like to put my unit tests
    directly after the functions they test.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ⑰ 对 `stemmer()` 函数进行测试。我通常喜欢将单元测试直接放在被测试函数之后。
- en: 14.3 Discussion
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.3 讨论部分
- en: There are many ways you could have written this, but, as always, I wanted to
    break the problem down into units I could write and test. For me, this came down
    to splitting the word into a possible leading consonant sound and the rest of
    the word. If I can manage that, I can create rhyming strings; if I cannot, then
    I need to alert the user.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以以多种方式编写这个，但，像往常一样，我想将问题分解成我可以编写和测试的单位。对我来说，这归结为将单词拆分为可能的引导辅音音素和单词的其余部分。如果我能做到这一点，我就可以创建押韵字符串；如果我不能，那么我需要提醒用户。
- en: 14.3.1 Stemming a word
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3.1 对单词进行词干提取
- en: 'For the purposes of this program, the “stem” of a word is the part after any
    initial consonants, which I define using a list comprehension with a guard to
    take only the letters that are not vowels:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个程序，单词的“词干”是指任何初始辅音之后的部分，我使用列表推导式并带有保护条件来定义它，以仅获取不是元音的字母：
- en: '[PRE40]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Throughout the chapters, I have shown how a list comprehension is a concise
    way to generate a list and is preferable to using a `for` loop to append to an
    existing list. Here we have added an `if` statement to only include some characters
    if they are not vowels. This is called a *guard* statement, and only those elements
    that evaluate as “truthy” will be included in the resulting `list`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个章节中，我展示了列表推导式是一个生成列表的简洁方式，并且比使用 `for` 循环向现有列表中追加更可取。在这里，我们添加了一个 `if` 语句，仅当字符不是元音时才包括它们。这被称为
    *保护语句*，只有评估为“真值”的元素才会包含在结果列表中。
- en: We’ve looked at `map()` several times now and talked about how it is a *higher-order
    function* (HOF) because it takes *another function* as the first argument and
    will apply it to all the elements from some *iterable* (something that can be
    *iterated*, like a `list`). Here I’d like to introduce another HOF called `filter()`,
    which also takes a function and an iterable (see figure 14.12). As with the list
    comprehension with the guard, only those elements that return a “truthy” value
    from the function are allowed in the resulting `list`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经多次查看 `map()` 并讨论了它是一个 *高阶函数* (HOF)，因为它接受 *另一个函数* 作为第一个参数，并将它应用于某个 *可迭代对象*（可以迭代的，如
    `list`）的所有元素。在这里，我想介绍另一个名为 `filter()` 的高阶函数，它也接受一个函数和一个可迭代对象（见图 14.12）。与带有保护条件的列表推导式一样，只有那些从函数返回“真值”的元素才允许包含在结果列表中。
- en: '![](../Images/14-12.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图 14-12](../Images/14-12.png)'
- en: Figure 14.12 The `map()` and `filter()` functions both take a function and an
    iterable, and both produce a new list.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.12 `map()` 和 `filter()` 函数都接受一个函数和一个可迭代对象，并且都会生成一个新的列表。
- en: 'Here is another way to write the idea of the list comprehension using `filter()`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用 `filter()` 编写列表推导式想法的另一种方式：
- en: '[PRE41]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Just as with `map()`, I use the `lambda` keyword to create an *anonymous function*.
    The `c` is the variable that will hold the argument, which, in this case, will
    be each character from `string.ascii_lowercase`. The entire body of the function
    is the evaluation `c` `not` `in` `vowels`. Each of the vowels will return `False`
    for this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 正如与 `map()` 一样，我使用 `lambda` 关键字创建一个 *匿名函数*。`c` 是将持有参数的变量，在这种情况下，它将是 `string.ascii_lowercase`
    中的每个字符。函数的整个主体是评估 `c` `not` `in` `vowels`。对于每个元音，它都会返回 `False`：
- en: '[PRE42]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'And each of the consonants will return `True`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 每个辅音都会返回 `True`：
- en: '[PRE43]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Therefore, only the consonants will be allowed to pass through `filter()`.
    Think back to our “blue” cars; let’s write a `filter()` that only accepts cars
    that start with the string “blue”:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，只有辅音会被允许通过 `filter()`。回想一下我们的“蓝色”汽车；让我们编写一个 `filter()` 函数，它只接受以字符串“blue”开头的汽车：
- en: '[PRE44]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'When the `car` variable has the value “red Chevy,” the `lambda` returns `False`,
    and that value is rejected:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `car` 变量的值为“red Chevy”时，`lambda` 返回 `False`，该值被拒绝：
- en: '[PRE45]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Note that if none of the elements from the original iterable are accepted,
    `filter()` will produce an empty `list` (`[]`). For example, I could `filter()`
    for numbers greater than 10\. Note that `filter()` is another *lazy* function
    that I must coerce using the `list` function in the REPL:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果原始可迭代对象中的没有任何元素被接受，`filter()` 将产生一个空 `list` (`[]`)。例如，我可以 `filter()` 大于
    10 的数字。注意 `filter()` 是另一个 *惰性* 函数，我必须使用 REPL 中的 `list` 函数来强制转换：
- en: '[PRE46]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'A list comprehension would also return an empty list:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导式也会返回一个空列表：
- en: '[PRE47]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Figure 14.13 shows the relationship between creating a new `list` called `consonants`
    using an imperative `for`-loop approach, an idiomatic list comprehension with
    a guard, and a purely functional approach using `filter()`. All of these are perfectly
    acceptable, though the most Pythonic technique is probably the list comprehension.
    The `for` loop would be very familiar to a C or Java programmer, while the `filter()`
    approach would be immediately recognizable to the Haskeller or even someone from
    a Lisp-like language. The `filter()` might be slower than the list comprehension,
    especially if the iterable were large. Choose whichever way makes more sense for
    your style and application.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.13 展示了使用命令式 `for`-循环方法创建一个名为 `consonants` 的新 `list`、使用带守卫的惯用列表推导式以及使用 `filter()`
    的纯函数方法之间的关系。所有这些方法都是完全可以接受的，尽管最 Pythonic 的技术可能是列表推导式。对于 C 或 Java 程序员来说，`for` 循环会非常熟悉，而对于
    Haskell 或 Lisp 类语言的人来说，`filter()` 方法会立即被识别出来。`filter()` 可能比列表推导式慢，特别是如果可迭代对象很大。选择对你风格和应用更有意义的方法。
- en: '![](../Images/14-13.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/14-13.png)'
- en: 'Figure 14.13 Three ways to create a list of consonants: using a `for` loop
    with an `if` statement, a list comprehension with a guard, and a `filter()`'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.13 创建辅音列表的三种方法：使用带 `if` 语句的 `for` 循环、带守卫的列表推导式和 `filter()`
- en: 14.3.2 Formatting and commenting the regular expression
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3.2 格式化和注释正则表达式
- en: 'We talked in the introduction about the individual parts of the regular expression
    I ended up using. I’d like to take a moment to mention the way I formatted the
    regex in the code. I used an interesting trick of the Python interpreter that
    will implicitly concatenate adjacent string literals. See how these four strings
    become one:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在引言中，我们讨论了我最终使用的正则表达式的各个部分。我想花一点时间来提及我在代码中格式化正则表达式的方式。我使用了 Python 解释器的一个有趣技巧，该技巧可以隐式地连接相邻的字符串字面量。看看这四个字符串如何变成一个：
- en: '[PRE48]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Note that there are no commas after each string, as that would create a `tuple`
    with four individual strings:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每个字符串后面都没有逗号，因为那将创建一个包含四个单独字符串的 `tuple`：
- en: '[PRE49]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The advantage of writing out the regular expression on separates lines is that
    you can add comments to help your reader understand each part:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 将正则表达式写在单独的行上的优点是可以添加注释来帮助读者理解每一部分：
- en: '[PRE50]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The individual strings will be concatenated by Python into a single string:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 个体字符串将由 Python 连接成一个单独的字符串：
- en: '[PRE51]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: I could have written the entire regex on one line, but ask yourself which version
    would you rather read and maintain, the preceding version or the following:[1](#pgfId-1017737)
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我本可以将整个正则表达式写在一行中，但问问自己，你更愿意阅读和维护哪种版本，前面的版本还是下面的版本：[1](#pgfId-1017737)
- en: '[PRE52]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 14.3.3 Using the stemmer() function outside your program
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3.3 在程序外部使用 stemmer() 函数
- en: One of the very interesting things about Python code is that your rhymer.py
    program is also--kind of, sort of--a sharable *module* of code. That is, you haven’t
    explicitly written it to be a container of reusable (and tested!) functions, but
    it is. You can even run the functions from inside the REPL.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Python代码的一个非常有趣的事情是，你的rhymer.py程序也是一种——有点， sort of——可共享的*模块*代码。也就是说，你没有明确地编写它来作为可重用（并且经过测试！）函数的容器，但它确实是。你甚至可以从REPL内部运行这些函数。
- en: 'For this to work, be sure you run `python3` inside the same directory as the
    rhymer.py code:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个功能正常工作，请确保你在与rhymer.py代码相同的目录下运行`python3`：
- en: '[PRE53]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now you can run and test your `stemmer()` function manually:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以手动运行和测试你的`stemmer()`函数：
- en: '[PRE54]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The deeper meaning of `if __name__ == '__main__':`
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`if __name__ == ''__main__'':`的深层含义'
- en: Note that if you were to change the last two lines of rhymer.py from this,
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你要将rhymer.py的最后两行从这里更改，
- en: '[PRE55]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: to this,
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 到这里，
- en: '[PRE56]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'the `main()` function would be run when you try to import the module:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试导入模块时，将会运行`main()`函数：
- en: '[PRE57]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This is because `import` `rhymer` causes Python to execute the rhymer.py file
    to the end. If the last line of the module calls `main()`, then `main()` will
    run!
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`import` `rhymer`会导致Python执行rhymer.py文件直到末尾。如果模块的最后一行调用`main()`，那么`main()`将会运行！
- en: The `__name__` variable is set to `'__main__'` when rhymer.py is being *run
    as a program*. That is the only time `main()` is executed. When the module is
    being imported by another module, then `__name__` is equal to `rhymer`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当rhymer.py作为程序运行时，`__name__`变量被设置为`'__main__'`。这是`main()`被执行的唯一时间。当模块被另一个模块导入时，`__name__`等于`rhymer`。
- en: 'If you don’t explicitly `import` a function, you can use the fully qualified
    function name by adding the module name to the front:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有明确`import`一个函数，你可以通过在前面添加模块名称来使用完全限定的函数名称：
- en: '[PRE58]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '| There are many advantages to writing many small functions rather than long,
    sprawling programs. One is that small functions are much easier to write, understand,
    and test. Another is that you can put your tidy, tested functions into modules
    and share them across different programs you write. | ![](../Images/14-unnumb-4.png)
    |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| 写很多小的函数而不是长而分散的程序有很多优点。其中之一是小的函数更容易编写、理解和测试。另一个优点是你可以将整洁、经过测试的函数放入模块中，并在你编写的不同程序之间共享它们。
    | ![](../Images/14-unnumb-4.png) |'
- en: As you write more and more programs, you will find yourself solving some of
    the same problems repeatedly. It’s far better to create modules with reusable
    code than to copy pieces from one program to another. If you ever find a bug in
    a shared function, you can fix it once, and all the programs sharing the function
    get the fix. The alternative is to find the duplicated code in every program and
    change it (hoping that this doesn’t introduce even more problems because the code
    is entangled with other code).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你编写越来越多的程序，你会发现自己在反复解决一些相同的问题。创建具有可重用代码的模块比从程序到程序复制代码要好得多。如果你在共享函数中找到一个错误，你可以修复一次，所有共享该函数的程序都会得到修复。另一种选择是在每个程序中找到重复的代码并更改它（希望这不会因为代码与其他代码纠缠而引入更多问题）。
- en: 14.3.4  Creating rhyming strings
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3.4  创建押韵字符串
- en: 'I decided that my `stemmer()` function would always return a 2-tuple of the
    `(start,` `rest)` for any given word. As such, I can unpack the two values into
    two variables:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我决定我的`stemmer()`函数将始终返回一个包含`(start, rest)`的2元组，对于任何给定的单词。因此，我可以将这两个值解包到两个变量中：
- en: '[PRE59]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'If there is a value for `rest`, I can add all my `prefixes` to the beginning:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有`rest`的值，我可以将所有的`prefixes`添加到前面：
- en: '[PRE60]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'I decided to use another list comprehension with a guard to skip any prefix
    that is the same as the `start` of the word. The result will be a new `list` that
    I pass to the `sorted()` function to get the correctly ordered strings:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我决定使用另一个带有守卫器的列表推导式来跳过任何与单词`start`相同的`prefix`。结果将是一个新的`list`，我将它传递给`sorted()`函数以获取正确排序的字符串：
- en: '[PRE61]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'I then `print()` that `list`, joined on newlines. If there is no `rest` of
    the given word, I `print()` a message that the word cannot be rhymed:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 然后`print()`那个列表，按新行连接。如果没有给定单词的`rest`，我`print()`一条消息，说明该单词不能押韵：
- en: '[PRE62]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 14.3.5  Writing stemmer() without regular expressions
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3.5  不使用正则表达式编写stemmer()函数
- en: 'It is certainly possible to write a solution that does not use regular expressions.
    We could start by finding the first position of a vowel in the given string. If
    one is present, we could use a list slice to return the portion of the string
    up to that position and the portion starting at that position:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 当然可以编写一个不使用正则表达式的解决方案。我们可以从找到给定字符串中元音字母的第一个位置开始。如果存在，我们可以使用列表切片来返回字符串到该位置的部分以及从该位置开始的字符串部分：
- en: '[PRE63]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: ① Lowercase the given word to avoid dealing with uppercase letters.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ① 将给定的单词转换为小写以避免处理大写字母。
- en: ② Filter the vowels 'aeiou' to find those in word, and then map the present
    vowels to word.index to find their positions. This is one of the rare instances
    when we need to use the list() function to coerce Python into evaluating the lazy
    map() function because the next if statement needs a concrete value.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: ② 过滤元音字母 'aeiou' 以找到单词中的那些，然后将存在的元音字母映射到`word.index`以找到它们的位置。这是我们需要使用`list()`函数来强制Python评估懒映射（lazy
    map()）函数的罕见情况之一，因为下一个if语句需要一个具体的值。
- en: ③ Check if there are any vowels present in the word.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 检查单词中是否存在元音字母。
- en: ④ Find the index of the first vowel by taking the minimum (min) value from the
    positions.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 通过取位置的最小值（min）来找到第一个元音字母的索引。
- en: ⑤ Return a tuple of a slice of the word up to the first vowel, and another starting
    at the first vowel.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 返回一个包含单词到第一个元音字母的切片和从第一个元音字母开始的另一个切片的元组。
- en: ⑥ Otherwise, no vowels were found in the word.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 否则，单词中没有找到元音字母。
- en: ⑦ Return a 2-tuple of the word and the empty string to indicate there is no
    rest of the word to use for rhyming.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 返回一个包含单词和空字符串的2元组，以表示没有剩余的单词可用于押韵。
- en: '| This function will also pass the `test_stemmer()` function. By writing a
    test just for the idea of this one function, and exercising it with all the different
    values I would expect, I’m free to *refactor* my code. In my mind, the `stemmer()`
    function is a black box. What goes on inside the function is of no concern to
    the code that calls it. As long as the function passes the tests, it is “correct”
    (for certain values of “correct”).Small functions and their *tests* will set you
    free to improve your programs. First make something work, and make it beautiful.
    Then try to make it better, using your tests to ensure it keeps working as expected.
    | ![](../Images/14-unnumb-5.png)  |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| 此函数还将通过`test_stemmer()`函数。通过为这个函数的想法编写一个测试，并使用所有我预期的不同值来练习它，我可以自由地*重构*我的代码。在我的心中，`stemmer()`函数是一个黑盒。函数内部发生的事情与调用它的代码无关。只要函数通过测试，它就是“正确”的（对于“正确”的某些值）。小型函数及其*测试*将使你自由地改进你的程序。首先让某物工作，并使其美观。然后尝试使其更好，使用测试来确保它按预期工作。
    | ![14-unnumb-5.png](../Images/14-unnumb-5.png) |'
- en: 14.4 Going further
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.4 深入学习
- en: Add an `--output` option to write the words to a given file. The default should
    be to write to `STDOUT`.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个`--output`选项，将单词写入指定的文件。默认情况下，应写入`STDOUT`。
- en: Read an input file and create rhyming words for all the words in the file. You
    can borrow from the program in chapter 6 to read a file and break it into words,
    then iterate each word, and create an output file for each word with the rhyming
    words.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取输入文件并为文件中的所有单词创建押韵词。你可以从第6章的程序中借用，以读取文件并将其分解成单词，然后迭代每个单词，并为每个单词创建一个包含押韵词的输出文件。
- en: Write a new program that finds all unique consonant sounds in a dictionary of
    English words. (I have included inputs/words.txt.zip, which is a compressed version
    of the dictionary from my machine. Unzip the file to use inputs/ words.txt.) Print
    the output in alphabetical order and use those to expand this program’s consonants.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个新的程序，找出英语单词字典中所有独特的辅音音素。（我已经包括了inputs/words.txt.zip，这是我机器上字典的压缩版本。解压文件以使用inputs/words.txt。）以字母顺序打印输出，并使用这些来扩展程序中的辅音。
- en: Alter your program to only emit words that are found in the system dictionary
    (for example, inputs/words.txt).
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改你的程序，使其只输出系统中字典（例如，inputs/words.txt）中存在的单词。
- en: Write a program to create Pig Latin, where you move the initial consonant sound
    from the beginning of the word to the end and add “-ay,” so that “cat” becomes
    “at-cay.” If a word starts with a vowel, add “-yay” to the end so that “apple”
    becomes “apple-yay.”
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个程序来创建Pig Latin，将单词开头的辅音音素移动到末尾，并添加“-ay”，使“cat”变成“at-cay”。如果一个单词以元音字母开头，则在末尾添加“-yay”，使“apple”变成“apple-yay”。
- en: Write a program to create spoonerisms, where the initial consonant sounds of
    adjacent words are switched, so you get “blushing crow” instead of “crushing blow.”
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个程序来创建斯波纳姆（spoonerisms），即交换相邻单词的初始辅音音素，所以你会得到“blushing crow”而不是“crushing
    blow”。
- en: Summary
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Regular expressions allow you to declare a pattern that you wish to find. The
    regex *engine* will sort out whether the pattern is found or not. This is a *declarative*
    approach to programming, in contrast to the *imperative* method of manually seeking
    out patterns by writing code ourselves.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式允许你声明你希望找到的模式。正则表达式 *引擎* 将确定模式是否被找到。这是一种 *声明式* 编程方法，与手动通过编写代码来寻找模式的 *命令式*
    方法相反。
- en: You can wrap parts of the pattern in parentheses to “capture” them into groups
    that you can fetch from the result of `re.match()` or `re.search()`.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以将模式的部分用括号括起来以“捕获”它们，然后从 `re.match()` 或 `re.search()` 的结果中获取这些组。
- en: You can add a guard to a list comprehension to avoid taking some elements from
    an iterable.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在列表推导式中添加一个守卫来避免从可迭代对象中取一些元素。
- en: The `filter()` function is another way to write a list comprehension with a
    guard. Like `map()`, it is a lazy, higher-order function that takes a function
    that will be applied to every element of an iterable. Only those elements that
    are deemed “truthy” by the function are returned.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter()` 函数是另一种带有守卫的列表推导式写法。像 `map()` 一样，它是一个惰性、高阶函数，它接受一个将被应用于可迭代对象每个元素的函数。只有那些被函数认为是“真值”的元素才会被返回。'
- en: Python can evaluate many types--including strings, numbers, lists, and dictionaries--in
    a Boolean context to arrive at a sense of “truthiness.” That is, you are not restricted
    to just `True` and `False` in `if` expressions. The empty string `''`, the `int`
    `0`, the `float` `0.0`, the empty `list[]`, and the empty `dict{}` are all considered
    “falsey,” so any non-falsey value from those types, like the non-empty `str`,
    `list`, or `dict`, or any numeric value not zero-ish, will be considered “truthy.”
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 可以在布尔上下文中评估许多类型--包括字符串、数字、列表和字典--以获得“真值”的感觉。也就是说，在 `if` 表达式中，你不仅限于 `True`
    和 `False`。空字符串 `''`、整数 `0`、浮点数 `0.0`、空列表 `[]` 和空字典 `{}` 都被认为是“假值”，所以那些类型中的任何非假值，如非空
    `str`、`list` 或 `dict`，或任何非零的数值，都将被认为是“真值”。
- en: You can break long string literals into shorter adjacent strings in your code
    to have Python join them into one long string. It’s advisable to break long regexes
    into shorter strings and add comments on each line to document the function of
    each pattern.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在代码中将长字符串字面量拆分为较短的相邻字符串，让 Python 将它们连接成一个长字符串。建议将长正则表达式拆分为较短的字符串，并在每行添加注释以记录每个模式的功能。
- en: Write small functions and tests, and share them in modules. Every .py file can
    be a module from which you can `import` functions. Sharing small, tested functions
    is better than writing long programs and copying/pasting code as needed.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写小的函数和测试，并在模块中共享它们。每个 `.py` 文件都可以是一个模块，你可以从中 `import` 函数。共享小的、经过测试的函数比编写长程序并在需要时复制/粘贴代码要好。
- en: '* * *'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 1 “Looking at code you wrote more than two weeks ago is like looking at code
    you are seeing for the first time.”--Dan Hurvitz
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 1 “查看你两周前写的代码就像第一次看到它一样。”--丹·赫尔维茨
