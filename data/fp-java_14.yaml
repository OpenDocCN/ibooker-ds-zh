- en: Chapter 15\. Solving common problems functionally
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第15章. 函数式解决常见问题
- en: '***This chapter covers***'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '***本章涵盖***'
- en: Using assertions
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用断言
- en: Reading property files
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取属性文件
- en: Adapting imperative libraries
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适配命令式库
- en: You now have at your disposal many functional tools that can make your life
    as a programmer easier. But knowing the tools isn’t enough. To become efficient
    in functional programming, you must make it second nature. You need to think functionally.
    Initially you’ll keep your imperative reflexes, and you’ll probably have to think
    about how you might translate an imperative solution into functional coding. You’ll
    have become a proficient functional programmer when your first approach to a programming
    problem is to think about a functional solution first (and perhaps have some difficulties
    translating it into imperative!).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你拥有许多功能工具，可以使你的编程生活更容易。但了解工具是不够的。要成为函数式编程的高效程序员，你必须让它成为第二本能。你需要以函数式的方式思考。最初，你将保持命令式的反射，你可能会考虑如何将命令式解决方案转换为函数式编码。当你第一次处理编程问题时，首先考虑函数式解决方案（也许会有一些困难将其转换为命令式！）时，你将成为一个熟练的函数式程序员。
- en: To reach this stage, there’s no other way than practicing. And because, at least
    in the Java world, a huge majority of the known solutions to common problems are
    imperative, it can be a good exercise to look at some common problems and see
    how they can be solved in a functional way.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 要达到这个阶段，没有其他方法，只能通过练习。而且，至少在Java世界中，大多数已知解决常见问题的方案都是命令式的，因此，查看一些常见问题并看看它们如何以函数式方式解决可能是一个很好的练习。
- en: Lots of examples are available on the internet about solving mathematical problems
    in a functional way. These examples are very interesting, but they’re sometimes
    counterproductive in the sense that they make programmers believe that functional
    programming is only good for solving mathematical problems. Worse yet, it leads
    some into thinking that mathematical skills are necessary for practicing functional
    programming. This isn’t the case. Mathematical skills are necessary for solving
    mathematical problems, but most programming problems you need to solve aren’t
    related to mathematics. And they’re often simpler to solve in a functional way.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网上有许多关于以函数式方式解决数学问题的示例。这些示例非常有趣，但有时它们在某种程度上是适得其反的，因为它们让程序员相信函数式编程只适用于解决数学问题。更糟糕的是，它导致一些人认为数学技能是实践函数式编程所必需的。这不是事实。数学技能对于解决数学问题是必要的，但你需要解决的绝大多数编程问题与数学无关。而且，它们通常以函数式方式解决要简单得多。
- en: In this chapter, we’ll look at some common problems programmers have to solve
    in everyday professional life and see how they can be approached differently using
    the functional paradigm.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨程序员在日常生活中必须解决的常见问题，并看看它们如何可以通过函数式范式以不同的方式来处理。
- en: 15.1\. Using assertions to validate data
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.1. 使用断言验证数据
- en: Java has had assertions since version 1.4\. Assertions are used to check invariants
    such as preconditions, post-conditions, control-flow conditions, and class conditions.
    In functional programming, there’s generally no control flow, and classes are
    usually immutable, so the only conditions to check are pre- and post-conditions,
    which, for the same reasons (immutability and absence of control flow), consist
    in testing the arguments received by methods and functions, and testing their
    results before returning them.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Java从1.4版本开始就有断言。断言用于检查不变量，如前置条件、后置条件、控制流条件和类条件。在函数式编程中，通常没有控制流，类通常是不可变的，所以唯一需要检查的条件是前置条件和后置条件，由于同样的原因（不可变性和没有控制流），这些条件包括测试方法接收到的参数，并在返回之前测试它们的结果。
- en: 'Testing the argument value is necessary in partial functions such as this:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在部分函数（如这个例子）中测试参数值是必要的：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This method returns a usable value for any input, except for 0, for which it
    returns “infinity.” Because you probably can’t do anything with this value, you
    might prefer to handle it in a specific way. In imperative programming, you could
    write this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法对任何输入都返回一个可用的值，除了0，对于0它返回“无穷大”。因为你可能无法使用这个值，你可能更喜欢以特定的方式处理它。在命令式编程中，你可以这样写：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'But in Java you can disable assertions at runtime, so the common trick is to
    prevent the program from running with assertions disabled by using a static initializer:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 但在Java中，你可以在运行时禁用断言，所以常见的技巧是使用静态初始化器来防止程序在禁用断言的情况下运行：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This is what Oracle suggests. Of course, it’s simpler to write this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Oracle 建议的。当然，写成这样更简单：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In functional programming, the function should be transformed into a total
    function, as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，函数应该被转换成一个全函数，如下所示：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There’s then no need to check the argument, because this test is part of the
    function implementation. And, of course, there’s no need to check the returned
    value.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，就没有必要检查参数了，因为这种测试是函数实现的一部分。当然，也没有必要检查返回的值。
- en: 'One condition that must often be checked is that arguments aren’t `null`. Java
    has `Objects.requireNonNull` for this. There are variants of this method taking
    an additional error message, or a `Supplier` of an error message. These methods
    can sometimes be useful:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 必须经常检查的一个条件是参数不是 `null`。Java 有 `Objects.requireNonNull` 用于此。这个方法有变体，可以接受一个额外的错误消息，或者一个错误消息的
    `Supplier`。这些方法有时可能很有用：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'But in a functional program, the most generic form of assertion consists of
    testing an argument against a specific condition, returning a `Result.Failure`
    if the condition isn’t matched, and a `Result.Success` otherwise. Take the example
    of a factory method for a `Person` type:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 但在函数式程序中，最通用的断言形式是对一个参数进行特定条件的测试，如果不匹配条件则返回 `Result.Failure`，否则返回 `Result.Success`。以
    `Person` 类型的工厂方法为例：
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This method might be used with data extracted from a database:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法可以与从数据库中提取的数据一起使用：
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In such a case, you might want to validate the data before calling the `apply`
    method. For example, you might want to check that the ID is positive, and that
    the first and last names aren’t `null` or empty and that they start with an uppercase
    letter. In imperative Java, this could be done through the use of assertion methods:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你可能在调用 `apply` 方法之前想要验证数据。例如，你可能想要检查 ID 是否为正数，以及名字和姓氏是否不是 `null` 或空，并且它们以大写字母开头。在命令式
    Java 中，这可以通过使用断言方法来完成：
- en: '[PRE8]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In functional programming, you don’t throw exceptions; you use special contexts
    such as `Result` for error handling. This kind of validation is abstracted into
    the `Result` type. All you have to do is write the validating functions, which
    means you just have to write methods and use method references. Generic validation
    function can be grouped into a special class:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，你不抛出异常；你使用特殊的上下文，如 `Result` 进行错误处理。这种验证被抽象成 `Result` 类型。你所要做的就是编写验证函数，这意味着你只需要编写方法和使用方法引用。通用的验证函数可以组合到一个特殊类中：
- en: '[PRE9]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can then validate the data:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以验证数据：
- en: '[PRE10]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'But you can also simplify things by abstracting more of the process in the
    `Assertion` class:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 但你也可以通过在 `Assertion` 类中抽象更多过程来简化事情：
- en: '[PRE11]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And you can create a `Person` as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建一个 `Person` 如下：
- en: '[PRE12]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The following listing shows the `Assertion` class with some example methods.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表展示了 `Assertion` 类和一些示例方法。
- en: Listing 15.1\. Examples of functional assertions
  id: totrans-39
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.1\. 功能性断言的示例
- en: '[PRE13]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 15.2\. Reading properties from file
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2\. 从文件中读取属性
- en: Most software applications are configured using property files that are read
    at startup. Properties are key/value pairs, and both keys and values are written
    as strings. Whatever the chosen property format (`key=value`, XML, JSON, YAML,
    and so on), the programmer always has to read strings and transform them into
    Java objects or primitives. This process is tedious and error prone. You can use
    a specialized library for this, but if something goes wrong, you’ll find yourself
    throwing exceptions. To get more functional behavior, you’ll have to write your
    own library.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数软件应用程序都是通过在启动时读取属性文件进行配置的。属性是键/值对，键和值都作为字符串写入。无论选择的属性格式是 `key=value`、XML、JSON、YAML
    等等，程序员总是需要读取字符串并将它们转换成 Java 对象或原始数据。这个过程既繁琐又容易出错。你可以使用专门的库来做这件事，但如果出了问题，你会发现自己在抛出异常。为了获得更多功能性的行为，你可能需要编写自己的库。
- en: 15.2.1\. Loading the property file
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.2.1\. 加载属性文件
- en: 'Whatever format you use, the process is exactly the same: reading the file
    and handling any `IOException` that could arise in that process. In the following
    example, you’ll read a Java property file.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用什么格式，过程都是一样的：读取文件并处理在这个过程中可能出现的任何 `IOException`。在下面的示例中，你将读取一个 Java 属性文件。
- en: The first thing to do is to read the file and return a `Result<Properties>`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的事情是读取文件并返回一个 `Result<Properties>`。
- en: Listing 15.2\. Reading a Java property file
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.2\. 读取 Java 属性文件
- en: '![](Images/ch15ex02-0.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ch15ex02-0.jpg)'
- en: '![](Images/ch15ex02-1.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ch15ex02-1.jpg)'
- en: In this example, you load the property file from the classpath. It could, of
    course, be loaded from anywhere on disk, or read from a remote URL, or any other
    source.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你从类路径中加载属性文件。当然，它也可以从磁盘上的任何位置加载，或者从远程URL读取，或者从任何其他来源读取。
- en: 15.2.2\. Reading properties as strings
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.2.2\. 将属性作为字符串读取
- en: 'The simple use case consists in reading the properties as strings. This is
    very straightforward. You just have to add a `readProperty` method to the `PropertyReader`
    class, taking the property name as its argument and returning a `Result<String>`.
    But be aware that the following won’t work:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的使用案例就是将属性作为字符串读取。这非常直接。你只需要向`PropertyReader`类添加一个`readProperty`方法，该方法以属性名称作为参数，并返回一个`Result<String>`。但请注意，以下情况不会工作：
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If the property doesn’t exist, the `getProperty` method returns `null`. (In
    Java 8, it should return an `Optional`, but it doesn’t.) Note that the `Properties`
    class can be constructed with a default property list, and that the `getProperty`
    method can itself be called with a default value. But not all properties have
    default values.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果属性不存在，`getProperty`方法返回`null`。（在Java 8中，它应该返回`Optional`，但它没有。）请注意，`Properties`类可以用默认属性列表构造，并且`getProperty`方法本身可以带有默认值调用。但并非所有属性都有默认值。
- en: 'To handle this problem, you can create a helper method:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这个问题，你可以创建一个辅助方法：
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, let’s say you have a property file in the classpath, containing the following
    properties:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你在类路径中有一个属性文件，包含以下属性：
- en: '[PRE16]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can access properties in a safe way:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以安全地访问属性：
- en: '[PRE17]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Given your property file, you’ll get the following result:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 给定你的属性文件，你会得到以下结果：
- en: '[PRE18]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The first line corresponds to the `host` property, which is correct. The second
    line corresponds to the `name` property, and it’s an empty string, which might
    or might not be correct; you don’t know. It depends on whether the name is optional
    from the business point of view. The third line corresponds to the missing `year`
    property, but the “Null value” message isn’t very informative. Of course, it’s
    contained in a `Result <String>` that could be assigned to a `year` variable,
    so you could know which property is missing. But it would be better to have the
    name of the property as part of the message. Furthermore, if the file isn’t found,
    you get a very uninformative error message:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行对应于`host`属性，这是正确的。第二行对应于`name`属性，它是一个空字符串，这可能正确也可能不正确；你不知道。这取决于从业务角度来看名称是否是可选的。第三行对应于缺失的`year`属性，但“空值”信息并不很有帮助。当然，它包含在一个`Result
    <String>`中，可以分配给`year`变量，因此你可以知道哪个属性缺失。但最好将属性名称作为消息的一部分。此外，如果文件找不到，你会得到一个非常不详细的错误信息：
- en: '[PRE19]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 15.2.3\. Producing better error messages
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.2.3\. 生成更好的错误信息
- en: The problem you’re facing here is a very good example of what should never happen.
    Using the Java standard library, you’re confident that things will go as expected.
    In particular, you expect that if a file isn’t found, or if it can’t be read,
    you’ll get an `IOException`. You would even hope to be told the full path of the
    file, because a “missing” file is often just a file that’s not in the right place
    (or is a file that Java isn’t looking for in the right place). A good error message
    in such a case would be “I am looking for file ‘abc’ in location ‘xyz’ but can’t
    find it.”
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这里遇到的问题是一个非常好的例子，说明了永远不应该发生的事情。使用Java标准库，你确信事情会按预期进行。特别是，你期望如果找不到文件，或者无法读取，你会得到一个`IOException`。你甚至希望被告知文件的完整路径，因为“缺失”的文件通常只是不在正确位置（或者是一个Java没有在正确位置寻找的文件）。在这种情况下，一个好的错误信息会是“我在位置‘xyz’寻找文件‘abc’，但找不到它。”
- en: 'Now, look at the code for the `ClassLoader.getResourceAsStream` method:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看看`ClassLoader.getResourceAsStream`方法的代码：
- en: '[PRE20]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: No, you’re not dreaming. This is how Java 8 is written. The conclusion is that
    you, as a programmer, should never use a method from the Java standard library
    without looking at the corresponding code.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 不，你并没有做梦。这就是Java 8的编写方式。结论是，作为程序员，你应该在查看相应代码之前，永远不要使用Java标准库中的任何方法。
- en: Note that the Javadoc says that the method returns “An input stream for reading
    the resource, or `null` if the resource could not be found.” This means that many
    things can go wrong. An `IOException` might occur if the file isn’t found, or
    if there’s a problem while reading it. Or the filename could be `null`. Or the
    `getResource` method could throw an exception or return `null`. (Look at the code
    for this method to see what I mean.)
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Javadoc 表示该方法返回“用于读取资源的输入流，或者如果资源找不到，则返回 `null`。”这意味着许多事情可能会出错。如果找不到文件或在读取文件时出现问题，可能会发生
    `IOException`。或者文件名可能是 `null`。或者 `getResource` 方法可能会抛出异常或返回 `null`。（查看该方法的代码以了解我的意思。）
- en: 'The minimum that you should do is provide a different message for each case.
    And despite the fact that an `IOException` is very unlikely to be thrown, you
    must still handle this case, as well as the general case of an unexpected exception:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您至少应该为每种情况提供不同的消息。尽管 `IOException` 很不可能被抛出，但您仍然必须处理这种情况，以及意外的异常的通用情况：
- en: '[PRE21]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now, if the file isn’t found, the message is
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果找不到文件，消息将是
- en: '[PRE22]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You also have to deal with property-related error messages. When using code
    like this
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 您还必须处理与属性相关的错误消息。当使用如下代码时
- en: '[PRE23]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'it’s clear that if you get the `Null value` error message, it means the `year`
    property wasn’t found. But in the following example, the `Null value` message
    gives no information about which property was missing:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您收到“空值”错误消息，那么这意味着 `year` 属性未找到。但在以下示例中，“空值”消息没有提供有关缺少哪个属性的信息：
- en: '[PRE24]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To solve this problem, you have several options at your disposal. The simplest
    is to map the failure in the `getProperty` helper method of the `PropertyReader`
    class:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，您有几种选择可供选择。最简单的是在 `PropertyReader` 类的 `getProperty` 辅助方法中映射失败：
- en: '[PRE25]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The preceding example produces the following error message, indicating clearly
    that the `id` property wasn’t present in the property file:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例产生了以下错误消息，清楚地表明 `id` 属性在属性文件中不存在：
- en: '[PRE26]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Another potential source of failure is a parsing error while converting the
    string `id` property into an integer. For example, if the property was
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个潜在的错误来源是在将字符串 `id` 属性转换为整数时发生的解析错误。例如，如果该属性是
- en: '[PRE27]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: the error message will be
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 错误消息将是
- en: '[PRE28]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This doesn’t give you meaningful information, and that’s because it’s the standard
    Java 8 error message for a parsing error. Most standard Java error messages are
    like this. It’s like a `NullPointerException`. It says that a reference was found
    `null`, but it doesn’t say which one. Here, it doesn’t even say which error was
    encountered. The nature of the error was carried by the exception. Printing the
    stack trace would have given you this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不提供有意义的错误信息，这是因为它是标准Java 8解析错误的错误消息。大多数标准Java错误消息都是这样的。它就像一个 `NullPointerException`。它说找到了一个
    `null` 引用，但没有说哪个。在这里，甚至没有说明遇到了哪个错误。错误的性质由异常携带。打印堆栈跟踪将给出以下信息：
- en: '[PRE29]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'What you really need is the name of the property that caused the exception.
    Something like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您真正需要的是导致异常的属性名称。类似于以下内容：
- en: '[PRE30]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: But you have to write the name of the property twice, and you’d like to replace
    “???” with the value found (this isn’t possible because the value is already lost).
    Because you’ll have to parse property values for all non-string properties, you
    should abstract this inside the `PropertyReader` class.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 但是你必须将属性名称写两次，并且希望用找到的值替换“???”（这是不可能的，因为该值已经丢失）。因为您将不得不解析所有非字符串属性值，所以您应该在 `PropertyReader`
    类中抽象这一过程。
- en: 'To do so, you’ll first rename the `getProperty` method:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，您首先需要重命名 `getProperty` 方法：
- en: '[PRE31]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, you’ll add a `getAsInteger` method:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您将添加一个 `getAsInteger` 方法：
- en: '[PRE32]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, you don’t need to worry about errors while converting to integers:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您不需要担心在转换为整数时出错：
- en: '[PRE33]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 15.2.4\. Reading properties as lists
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.2.4\. 将属性作为列表读取
- en: 'You could do the same thing you’ve done for integers for other numeric types,
    such as `long` or `double`. But you can do much more than this. You can read properties
    as lists:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以为其他数值类型，如 `long` 或 `double`，做与整数相同的事情。但您能做的远不止这些。您可以读取属性作为列表：
- en: '[PRE34]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You just have to add a specialized method to handle this case. You can use
    the following method to get a property as a list of integers:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您只需添加一个专门的方法来处理这种情况。您可以使用以下方法将属性作为整数列表获取：
- en: '[PRE35]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Of course, you’ll need to add the `fromSeparatedString` method to the `List`
    class. As I said in the previous chapter, this code isn’t intended to use the
    result of the exercises of previous chapters but the `fpinjava-common` module
    that’s available in the code accompanying this book ([https://github.com/fpinjava/fpinjava](https://github.com/fpinjava/fpinjava)).
    This is mostly the same code as in the solutions to the exercises, but with some
    additional methods, such as `List.fromCollection(...)` in the following example:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你需要将`fromSeparatedString`方法添加到`List`类中。正如我在上一章所说，这段代码不是用来使用上一章练习的结果，而是使用本书附带代码中的`fpinjava-common`模块（[https://github.com/fpinjava/fpinjava](https://github.com/fpinjava/fpinjava)）。这基本上与练习的解决方案中的代码相同，但增加了一些方法，例如以下示例中的`List.fromCollection(...)`：
- en: '[PRE36]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'But you can do much more. You can read a property as a list of any numerical
    values by providing the conversion function:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 但你可以做更多。你可以通过提供转换函数来读取任何数值列表的属性：
- en: '[PRE37]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'And now you can define functions for all sorts of number formats in terms of
    `getAsList`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以定义各种数字格式的函数，以`getAsList`为依据：
- en: '[PRE38]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 15.2.5\. Reading enum values
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.2.5\. 读取枚举值
- en: One frequent use case is reading a property as an `enum` value, which is a particular
    case of reading a property as any type. You can first create a method to convert
    a property to any type `T`, taking a function from `String` to a `Result<T>:`
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的用例是将属性作为`enum`值读取，这是读取属性为任何类型的特例。你可以首先创建一个方法将属性转换为任何类型`T`，接受一个从`String`到`Result<T>`的函数：
- en: '[PRE39]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You can now create a `getAsEnum` method in terms of `getAsType`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以在`getAsType`的基础上创建一个`getAsEnum`方法：
- en: '![](Images/406fig01_alt.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/406fig01_alt.jpg)'
- en: Given the following property
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 给定以下属性
- en: '[PRE40]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: and the following `enum`,
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以及以下`enum`，
- en: '[PRE41]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'you can now read the property using the following code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以使用以下代码读取属性：
- en: '[PRE42]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 15.2.6\. Reading properties of arbitrary types
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.2.6\. 读取任意类型的属性
- en: So far, you’ve been reading properties as strings, primitives (`int`, `double`,
    `boolean`, and so on), or `enum`s. It may also be interesting to read properties
    as arbitrary objects. For this, you’ll have to write the object properties in
    a kind of serialized form in the property file, and then load these properties
    and deserialize them.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你一直是以字符串、原始数据类型（`int`、`double`、`boolean`等）或`enum`的形式读取属性。读取属性为任意对象可能也很有趣。为此，你必须在属性文件中以某种序列化的形式编写对象属性，然后加载这些属性并反序列化它们。
- en: 'You can use the `getAsType` method to read a property as any type. For example,
    you could read the following property to get a `Person`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`getAsType`方法以任何类型读取属性。例如，你可以读取以下属性以获取一个`Person`：
- en: '[PRE43]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: All you have to do is provide a function from `String` to `Result<Person>`.
    This function should be able to create a `Person` from the string `id:3,firstName:Jane,lastName:Doe`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要提供一个从`String`到`Result<Person>`的函数。这个函数应该能够从字符串`id:3,firstName:Jane,lastName:Doe`中创建一个`Person`对象。
- en: To simplify its use, you could create a `getAsPerson` method. But because it’s
    type-specific, you shouldn’t put it inside the `PropertyReader`. A static factory
    method taking a `PropertyReader` and the property name as its arguments can be
    added to the `Person` class.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化其使用，你可以创建一个`getAsPerson`方法。但由于它是类型特定的，你不应该将其放在`PropertyReader`内部。可以添加一个静态工厂方法到`Person`类中，该方法接受一个`PropertyReader`和属性名作为参数。
- en: There are several ways to implement it. One way is to get the property as a
    list and then split each element, putting the key/value pairs in a map. It would
    then be easy to create a `Person` from this map. Another way to go would be to
    create a second `PropertyReader` that reads from the string after having replaced
    the commas with newline characters. The following listing shows the `Person` class
    with two specific methods for constructing instances from a property string.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 实现它的方法有多种。一种方法是将属性作为列表获取，然后分割每个元素，将键/值对放入映射中。然后就可以很容易地从映射中创建一个`Person`对象。另一种方法是创建一个第二`PropertyReader`，在将逗号替换为换行符后从字符串中读取。以下列表显示了具有从属性字符串构建实例的两个特定方法的`Person`类。
- en: Listing 15.3\. Methods that allow you to read properties as objects or lists
    of objects
  id: totrans-126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表15.3\. 允许你以对象或对象列表读取属性的方法
- en: '[PRE44]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `getAsPersonList` method allows you to read vector properties written as
    follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`getAsPersonList`方法允许你以如下方式读取向量属性：'
- en: '[PRE45]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: These methods necessitate some changes in the `PropertyReader` class.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法需要在`PropertyReader`类中进行一些修改。
- en: Listing 15.4\. Static factory methods added to the `PropertyReader` class
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表15.4\. 添加到`PropertyReader`类的静态工厂方法
- en: '![](Images/ch15ex04-0.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ch15ex04-0.jpg)'
- en: '![](Images/ch15ex04-1.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ch15ex04-1.jpg)'
- en: Of course, the same thing can be done for XML property files (which are handled
    by Java out of the box) or for other formats, such as JSON or YAML.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，同样的操作也可以应用于 XML 属性文件（Java 默认处理此类文件）或其他格式，例如 JSON 或 YAML。
- en: '15.3\. Converting an imperative program: the XML reader'
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3\. 将命令式程序转换为：XML 读取器
- en: Writing new functional programs for any task you have to accomplish is exciting,
    but you generally don’t have time for this. Often, you’ll want to use existing
    imperative programs in your own code. This is the case each time you want to use
    a Java library. Of course, you may find it more interesting to start from scratch
    and build a completely new, 100% functional solution. But you have to be realistic.
    You generally don’t have the time or budget to do this, and you’ll have to use
    existing nonfunctional libraries.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为任何任务编写新的函数式程序都是令人兴奋的，但通常你没有时间这样做。通常，你会在自己的代码中使用现有的命令式程序。每次你想使用 Java 库时都是这种情况。当然，你可能更喜欢从头开始构建一个完全新的、100%
    函数式解决方案。但你必须现实。你通常没有时间或预算这样做，你将不得不使用现有的非函数式库。
- en: As you’ll soon discover, once you’re comfortable with functional techniques,
    it’s really a pain to go back to the old imperative coding style. The solution
    is generally to build a thin functional wrapper around these imperative libraries.
    As an example, we’ll examine a very common library for reading XML files, JDOM
    2.0.6\. This is the most commonly used Java library for this task.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如你很快会发现，一旦你熟悉了函数式技术，回到旧的命令式编码风格就真的很痛苦。通常的解决方案是在这些命令式库周围构建一个薄薄的函数式包装器。作为一个例子，我们将检查一个非常常见的用于读取
    XML 文件的库，JDOM 2.0.6。这是此任务最常用的 Java 库。
- en: You’ll start with the example program in [listing 15.5](#ch15ex05). This program
    comes from one of the numerous sites proposing tutorials about how to use JDOM
    ([http://mng.bz/4p3x](http://mng.bz/4p3x)). I’ve chosen this example because it’s
    minimal and fits easily in the book.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你将从 [列表 15.5](#ch15ex05) 中的示例程序开始。此程序来自众多提供有关如何使用 JDOM 的教程的网站之一（[http://mng.bz/4p3x](http://mng.bz/4p3x)）。我选择这个示例是因为它最小化且易于融入本书中。
- en: 'Listing 15.5\. Reading XML data with JDOM: imperative version'
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.5\. 使用 JDOM 读取 XML 数据：命令式版本
- en: '[PRE46]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The data file used with this example is shown in the following listing.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 与此示例一起使用的数据文件如下所示。
- en: Listing 15.6\. The XML file to read
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.6\. 需要读取的 XML 文件
- en: '[PRE47]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: First, you’ll look at the benefits you can get from rewriting this example in
    a functional way. The first problem you might have is that no part of the program
    can be reused. Of course, it’s only an example, but even as an example, it should
    be written in a reusable way, at least so it’s testable. Here, the only way to
    test the program is to look at the console, which will display either the expected
    result or an error message. As you’ll see, it might even display an erroneous
    result.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你将看看通过以函数式方式重写此示例可以获得哪些好处。你可能遇到的第一问题是程序没有任何部分可以重用。当然，这只是一个示例，但即使是作为一个示例，它也应该以可重用的方式编写，至少应该可测试。在这里，测试程序的唯一方法是查看控制台，它将显示预期的结果或错误消息。正如你将看到的，它甚至可能显示错误的结果。
- en: 15.3.1\. Listing the necessary functions
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.3.1\. 列出必要的函数
- en: 'To make this program more functional, you should start by listing the fundamental
    functions you need, write them as autonomous, reusable, and testable units, and
    then code the example by composing these functions. Here are the main functions
    of the program:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要使此程序更具函数性，你应该首先列出你需要的基本函数，将它们编写为自主的、可重用的和可测试的单位，然后通过组合这些函数来编写示例。以下是程序的主要功能：
- en: Read a file and return the content as an XML string.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取文件并将内容作为 XML 字符串返回。
- en: Convert the XML string into a list of elements.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 XML 字符串转换为元素列表。
- en: Convert a list of elements into a list of string representations of these elements.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将元素列表转换为这些元素的字符串表示列表。
- en: You’ll also need an effect for displaying the list of strings to the computer
    screen.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要一个效果来将字符串列表显示到计算机屏幕上。
- en: '|  |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The description of the main functions of this program is only suitable for a
    small file that can be loaded entirely in memory.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序主要功能的描述仅适用于可以完全加载到内存中的小文件。
- en: '|  |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'The first function you need can be implemented as the following method:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要的第一个函数可以按以下方法实现：
- en: '[PRE48]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This method won’t throw any exceptions, but returns a `Result<String>`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法不会抛出任何异常，但返回一个 `Result<String>`。
- en: 'The second method converts an XML string into a list of elements, so it needs
    to know the name of the root XML element. It will have the following signature:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个方法将XML字符串转换为元素列表，因此它需要知道根XML元素的名字。它将具有以下签名：
- en: '[PRE49]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The third function you need will receive a list of elements as its argument
    and return a list of string representations of those elements. This will be implemented
    by a method with the following signature:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要的第三个函数将接收一个元素列表作为其参数，并返回这些元素的字符串表示形式列表。这将通过以下签名的方法实现：
- en: '[PRE50]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Eventually, you’ll need to apply an effect to the data, so you’ll have to define
    it as a method with the following signature:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，你需要对数据进行应用效果，因此你必须将其定义为具有以下签名的方法：
- en: '[PRE51]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This decomposition in functions doesn’t look much different from what you could
    do in imperative programming. After all, it’s also good practice to decompose
    imperative programs into methods with a single responsibility each. It is, however,
    more different than it might look. Note that the `readDocument` method takes as
    its first parameter a string that’s returned by a method that could (in the imperative
    world) throw an exception. Thus, you’d have to deal with the additional method:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这种在函数中的分解看起来与你在命令式编程中能做的事情没有太大区别。毕竟，将命令式程序分解为具有单一职责的方法也是一种良好的实践。然而，实际上它比看起来要不同。请注意，`readDocument`方法将其第一个参数作为一个字符串，这个字符串是由可能（在命令式世界中）抛出异常的方法返回的。因此，你必须处理额外的函数：
- en: '[PRE52]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In the same way, the file path could be returned by the same kind of method:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，文件路径可以通过相同类型的函数返回：
- en: '[PRE53]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The important thing to note is that the argument types and return types of these
    functions don’t match! This is the explicit translation of the fact that the imperative
    versions of these functions would be partial, which means they’d possibly throw
    exceptions. Methods throwing exceptions don’t compose well. In contrast, your
    functions compose perfectly.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的重要事项是，这些函数的参数类型和返回类型不匹配！这是这些函数的命令式版本可能不完整的一个明确表述，这意味着它们可能会抛出异常。抛出异常的方法不容易组合。相比之下，你的函数可以完美地组合。
- en: 15.3.2\. Composing the functions and applying an effect
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.3.2\. 组合函数并应用效果
- en: 'Although the argument and return types don’t match, your functions can be composed
    easily, using the comprehension pattern:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然参数和返回类型不匹配，但你的函数可以很容易地使用理解模式进行组合：
- en: '[PRE54]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'To display the result, you simply apply the corresponding effect:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示结果，你只需应用相应的效果：
- en: '[PRE55]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Your functional version of the program is much cleaner, and it’s fully testable—or
    it will be when you’ve implemented all the necessary functions.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你的程序的功能版本更加简洁，并且可以完全测试——或者在你实现了所有必要的函数之后，它将可以完全测试。
- en: 15.3.3\. Implementing the functions
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.3.3\. 实现函数
- en: Your program is relatively elegant, but you still have to implement the functions
    and effects you’re using in order to make it work. The good news is that each
    function is very simple and can be easily tested.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你的程序相对优雅，但你仍然需要实现你正在使用的函数和效果，以便使其工作。好消息是每个函数都非常简单，并且可以轻松测试。
- en: 'First, you’ll implement the `getXmlFilePath` and `getRootElementName` functions.
    In our example, these are constants that would be replaced in a real application:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要实现`getXmlFilePath`和`getRootElementName`函数。在我们的例子中，这些是将在实际应用中替换的常量：
- en: '[PRE56]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Then you have to implement the `readFile2String` method. Here’s one of the
    many possible implementations:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你必须实现`readFile2String`方法。以下是一种可能的实现方式：
- en: '[PRE57]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Note that you catch `IOException` and `Exception` separately. This isn’t mandatory,
    but it allows you to provide better error messages. In any case, you must always
    catch `Exception`. (You could get a `SecurityException` here, for example.)
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你分别捕获`IOException`和`Exception`。这不是强制性的，但它允许你提供更好的错误消息。无论如何，你必须始终捕获`Exception`。（例如，你可能会在这里遇到`SecurityException`。）
- en: 'Next, you need to implement the `readDocument` method. This method takes as
    its parameters an XML string containing the XML data and the name of the root
    element:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要实现`readDocument`方法。该方法接受一个包含XML数据的XML字符串和根元素的名字作为参数：
- en: '![](Images/413fig01_alt.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/413fig01_alt.jpg)'
- en: You first catch `IOException` (which is very unlikely to be thrown, because
    you’re reading from a string) and `JDOMException`, both of which are checked exceptions
    and return a failure with the corresponding error message. But by looking at the
    JDOM code (no one should call a library method without first looking at how it
    is implemented), you see that the code might throw an `IllegalStateException`
    or a `Null-PointerException`. Once again, you have to catch `Exception`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先捕获 `IOException`（由于你正在读取字符串，所以不太可能抛出）和 `JDOMException`，这两个都是检查异常，并返回带有相应错误信息的失败。但通过查看
    JDOM 代码（没有人应该在查看实现之前调用库方法），你会发现代码可能会抛出 `IllegalStateException` 或 `NullPointerException`。又一次，你必须捕获
    `Exception`。
- en: 'The `toStringList` method simply maps the list to a function responsible for
    the conversion:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`toStringList` 方法简单地将列表映射到负责转换的函数：'
- en: '[PRE58]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Finally, you need to implement the effect that will be applied to the result:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要实现将应用于结果的效果：
- en: '[PRE59]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 15.3.4\. Making the program even more functional
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.3.4\. 使程序更加功能化
- en: 'Your program is now much more modular and testable, and its parts are reusable.
    But you can still do better. You’re still using four nonfunctional elements: the
    file path, the name of the root element, the format used to convert the elements
    to string, and the effect that’s applied to the result. To make your program fully
    functional, you should make these elements parameters of your program.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你的程序现在更加模块化和可测试，其部分是可重用的。但你还可以做得更好。你仍然在使用四个非功能性元素：文件路径、根元素名称、将元素转换为字符串的格式以及应用于结果的效果。为了使你的程序完全功能化，你应该将这些元素作为程序参数。
- en: 'The `processElement` method also used specific data in the form of the element
    names, which correspond to the parameters of the format string used to display
    them. You can replace the format parameter with a `Tuple` of the format string
    and a list of parameters. This way, the `processElement` method will become the
    following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`processElement` 方法也使用了以元素名形式的具体数据，这些元素名对应于用于显示它们的格式字符串的参数。你可以用格式字符串和参数列表的
    `Tuple` 替换格式参数。这样，`processElement` 方法将变成以下形式：'
- en: '[PRE60]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Now your program can be a pure function, taking four arguments and returning
    a new (nonfunctional) executable program as its result. This version of the program
    is represented in the following listing.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在程序可以是一个纯函数，接受四个参数，并返回一个新的（非功能性的）可执行程序作为其结果。这个版本的程序在下面的列表中展示。
- en: Listing 15.7\. The fully functional XML reader program
  id: totrans-194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.7\. 完全功能化的 XML 读取器程序
- en: '![](Images/ch15ex07-0.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ch15ex07-0.jpg)'
- en: '![](Images/ch15ex07-1.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ch15ex07-1.jpg)'
- en: At this point, this program can be tested with the client code shown in the
    following listing.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，这个程序可以用下面的列表中所示的客户端代码进行测试。
- en: Listing 15.8\. The client program to test the XML reader
  id: totrans-198
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.8\. 测试 XML 读取器的客户端程序
- en: '[PRE61]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This program isn’t ideal because you haven’t handled the potential error that
    could arise from invalid element names. For example, if you use a wrong element
    name, you might get the following result:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序并不理想，因为你没有处理可能由无效元素名引起的潜在错误。例如，如果你使用了一个错误的元素名，你可能会得到以下结果：
- en: '[PRE62]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'You can guess what the error is by seeing that all the first names are `null`,
    but it would be better to replace the word “null” with an explicit message containing
    the erroneous element name. A more important problem is that if you forget one
    of the element names in the list, you’ll get an exception from the `String.format`
    method because of the following code:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过看到所有名字都是 `null` 来猜测错误是什么，但最好是将“null”这个词替换成一个包含错误元素名的显式消息。一个更重要的问题是，如果你在列表中忘记了一个元素名，你将因为以下代码而从
    `String.format` 方法得到一个异常：
- en: '[PRE63]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In this code, the array of parameters will have only three elements instead
    of the expected four. But it will be difficult to locate the source of the error
    from the exception trace.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，参数数组将只有三个元素，而不是预期的四个。但要从异常跟踪中找到错误的来源将非常困难。
- en: In fact, the real cause of the problem is that you’ve taken all the specific
    data out of the `ReadXmlFile` class, such as the root element name, the file path,
    and the effect to apply, but the `processElement` method is still specific to
    the client business use case. The `ReadXmlFile` class only allows you to read
    all elements that are direct children of the root element, gathering some of their
    direct child elements’ values (those whose names are passed along with the format).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，问题的真正原因是，你已经从`ReadXmlFile`类中提取了所有特定数据，例如根元素名称、文件路径和要应用的效果，但`processElement`方法仍然是针对客户端业务用例特定的。`ReadXmlFile`类只允许你读取根元素的直接子元素，收集它们的一些直接子元素值（那些名称与格式一起传递的）。
- en: A third problem is that the `readXmlFile` method takes two arguments of the
    same type. This is a source of error if arguments are swapped, which won’t be
    detected by the compiler.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个问题是`readXmlFile`方法接受两个相同类型的参数。如果参数被交换，这将成为一个错误源，编译器不会检测到。
- en: 15.3.5\. Fixing the argument type problem
  id: totrans-207
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.3.5\. 解决参数类型问题
- en: 'The third problem is very easy to fix by using the value types technique described
    in [chapter 3](kindle_split_010.xhtml#ch03). Instead of using `Result<String>`
    arguments, you can use `Result<FilePath>` and `Result<ElementName>`. `FilePath`
    and `ElementName` are just value classes for string values:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个问题通过使用第3章中描述的值类型技术非常容易解决。你不需要使用`Result<String>`参数，你可以使用`Result<FilePath>`和`Result<ElementName>`。`FilePath`和`ElementName`只是字符串值的值类：
- en: '[PRE64]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The `ElementName` class is similar. Of course, you have to add the validation
    code if you want some validation to happen. The simplest way is to check the value
    against a regular expression. To use these new classes, the `readXmlFile` method
    can be modified as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`ElementName`类也是类似的。当然，如果你想进行一些验证，你必须添加验证代码。最简单的方法是检查值是否与正则表达式匹配。要使用这些新类，`readXmlFile`方法可以修改如下：'
- en: '[PRE65]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: As you see, the changes are minimal. Note that you can use getters instead of
    public properties in the value type classes if you think having public properties
    is inappropriate.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，更改是最小的。注意，如果你认为在值类型类中使用公共属性不合适，你可以使用getter而不是公共属性。
- en: 'The client class must also be modified:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端类也必须进行修改：
- en: '[PRE66]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: With these changes, it’s now impossible to switch the order of the arguments
    without being warned by the compiler.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改后，现在不可能在不被编译器警告的情况下交换参数的顺序。
- en: 15.3.6\. Making the element-processing function a parameter
  id: totrans-216
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.3.6\. 将元素处理函数作为参数
- en: 'The two remaining problems can be solved with a single change: passing the
    element-processing function as a parameter to the `readXmlFile` method. This way,
    this method will have a single task: read the list of first-level elements in
    the file, apply them to a configurable function, and return the result. The main
    difference is that the method will no longer produce a list of strings and apply
    a string effect.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的两个问题可以通过一个更改来解决：将元素处理函数作为参数传递给`readXmlFile`方法。这样，这个方法将只有一个任务：读取文件中的第一级元素列表，将它们应用于可配置的函数，并返回结果。主要区别是，该方法将不再生成字符串列表并应用字符串效果。
- en: 'You’ll need to make the method generic. This means only the following changes:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要使方法通用。这意味着只有以下更改：
- en: '![](Images/419fig01_alt.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/419fig01_alt.jpg)'
- en: 'The client program can now be modified accordingly. This relieves you of using
    the `Tuple` trick to pass both the format string and the list of parameter names:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端程序现在可以相应地进行修改。这让你摆脱了使用`Tuple`技巧来传递格式字符串和参数名称列表的需求：
- en: '![](Images/419fig02_alt.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/419fig02_alt.jpg)'
- en: Note that the `processList` effect has not changed. Now it’s up to the client
    to provide a function to convert one element, and an effect to apply to this element.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`processList`效果没有改变。现在，客户端需要提供一个函数来转换一个元素，以及应用于此元素的效果。
- en: 15.3.7\. Handling errors on element names
  id: totrans-223
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.3.7\. 处理元素名称上的错误
- en: Now you’re left with the problem of errors happening while you read the elements.
    The function that you pass to the `readXmlFile` method returns a raw type, meaning
    that it should be a total function, but it’s not. It was in our initial example,
    because an error produced the “null” string. Now that you’re using a function
    from `Element` to `T`, you could use `Result<String>` as the realization of `T`,
    but this wouldn’t be very practical because you’d end up with a `List<Result<T>>`,
    and you’d have to transform it to a `Result<List<T>>`. Not a big deal, but this
    should definitely be abstracted.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您面临的问题是读取元素时发生错误。传递给`readXmlFile`方法的函数返回一个原始类型，这意味着它应该是一个全函数，但它不是。在我们的初始示例中，这是因为错误产生了“null”字符串。现在您正在使用从`Element`到`T`的函数，您可以使用`Result<String>`作为`T`的实现，但这不太实用，因为您最终会得到一个`List<Result<T>>`，您必须将其转换为`Result<List<T>>`。这不是什么大问题，但这一点绝对应该被抽象化。
- en: 'The solution is to use a function from `Element` to `Result<T>`, and use the
    `List.sequence` method to transform the result into a `Result<List<T>>`. Here’s
    the new method:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是使用从`Element`到`Result<T>`的函数，并使用`List.sequence`方法将结果转换为`Result<List<T>>`。以下是新方法：
- en: '![](Images/420fig01_alt.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/420fig01_alt.jpg)'
- en: 'The only additional change to be made is to handle the error that might occur
    in the process element method. The best approach is to examine the code of the
    `getChildText` method from JDOM. This method is implemented as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 需要进行的唯一额外更改是处理在过程元素方法中可能发生的错误。最佳方法是检查JDOM中`getChildText`方法的代码。此方法实现如下：
- en: '[PRE67]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'As you can see (as you continue examining the code for the `getChild` method),
    this method won’t throw any exceptions, but it will return `null` if the element
    doesn’t exist. So you can modify your `processElement` method:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见（当您继续检查`getChild`方法的代码时），此方法不会抛出任何异常，但如果元素不存在，它将返回`null`。因此，您可以修改您的`processElement`方法：
- en: '![](Images/421fig01_alt.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/421fig01_alt.jpg)'
- en: 'Now, most potential errors are handled in a functional way. Note, however,
    that not all errors can be handled functionally. As I said earlier, exceptions
    that are thrown by the effect passed to the `readXmlFile` method can’t be handled
    this way. These are exceptions thrown by the program that’s returned by the method.
    When the method returns the program, it hasn’t yet been executed. These exceptions
    must be caught while executing the resulting program:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，大多数潜在的错误都以功能方式处理。然而，请注意，并非所有错误都可以以功能方式处理。正如我之前所说，传递给`readXmlFile`方法的效应抛出的异常不能以这种方式处理。这些是由方法返回的程序抛出的异常。当方法返回程序时，它尚未执行。这些异常必须在执行结果程序时捕获：
- en: '[PRE68]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: You’ll find the complete example in the code accompanying this book ([http://github.com/fpinjava/fpinjava](http://github.com/fpinjava/fpinjava)).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书附带的代码中找到完整的示例（[http://github.com/fpinjava/fpinjava](http://github.com/fpinjava/fpinjava)）。
- en: 15.4\. Summary
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.4. 摘要
- en: Putting values in the `Result` context is the functional equivalent of assertions.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将值放入`Result`上下文是断言的功能等价。
- en: Property files can be read in a safe manner using the `Result` context.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用`Result`上下文安全地读取属性文件。
- en: Functional property reading relieves you of handling conversion errors.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能性属性读取可让您免于处理转换错误。
- en: Properties can be read as any type, `enum`, or collection in an abstracted way.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性可以以抽象方式读取为任何类型、`enum`或集合。
- en: Functional wrappers can be built around legacy imperative libraries.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在遗留命令式库周围构建功能包装器。
