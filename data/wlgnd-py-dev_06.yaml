- en: 5 Exceptional events
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 个异常事件
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: What exceptions are
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常是什么
- en: Why they occur in programs
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么它们会在程序中发生
- en: How to handle exceptions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何处理异常
- en: How to raise an exception
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何抛出异常
- en: Creating custom exceptions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义异常
- en: Developing software can lead you to think in a binary way—things are either
    on or off; they work or don’t work; something is either true or false. However,
    the real world is far from binary; it is a sea of variety. The software you create
    for yourself, and others, lives in that world.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 开发软件可能会让你以二进制的方式思考——事物要么开启要么关闭；要么工作要么不工作；某事要么是真的要么是假的。然而，现实世界远非二进制；它是一个充满多样性的海洋。你为自己和他人创建的软件就生活在这个世界中。
- en: The real world is not black or white; it is an infinitely variable field stretching
    between those two extremes. Computer systems that run software lose power and
    fail. The networks connecting systems are slow, intermittent, or unreliable. The
    storage systems on which software depends to save information become full, unreliable,
    or fail. The users of your software make incorrect assumptions and enter wrong
    or misleading data.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 真实世界不是非黑即白；它是一个介于这两个极端之间的无限可变领域。运行软件的计算机系统会失去电力并失败。连接系统的网络可能缓慢、间歇或不稳定。依赖于软件保存信息的存储系统可能会满载、不可靠或失败。你的软件用户可能会做出错误的假设并输入错误或误导性的数据。
- en: In addition to the problematic world in which software runs, you will create
    bugs in the code you write. Software bugs are errors or failures, causing an application
    to produce unexpected results. Most software applications providing something
    useful are complex enough that bugs will creep in. These come from wrong assumptions
    on the part of the developer, oversights, and simple everyday mistakes.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 除了软件运行的具有问题的世界之外，你还会在编写的代码中引入错误。软件错误是错误或失败，导致应用产生意外的结果。大多数提供有用功能的软件应用都足够复杂，以至于会存在错误。这些错误来自开发者的错误假设、疏忽和简单的日常错误。
- en: This shouldn’t discourage you as a developer but should broaden the way you
    think about creating software applications. The problems outlined previously can
    be managed and handled and are part of the challenge of becoming a developer.
    How you handle these challenges is dependent on the requirements of the application
    and its users.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这不应该让你作为开发者感到气馁，而应该拓宽你思考创建软件应用的方式。前面概述的问题可以管理和处理，并且是成为开发者挑战的一部分。你如何处理这些挑战取决于应用的需求及其用户。
- en: If you’re knocking together a quick program to solve a problem for yourself,
    creating something that might crash if given incorrect input is probably acceptable.
    On the other hand, if you’re creating something hundreds, or thousands, of users
    will access, application crashes are far less acceptable. It will take longer
    to develop and build code to handle conditions that might arise. Figure 5.1 shows
    the relationship between three things related to the development of software applications.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只是快速编写一个程序来解决自己的问题，创建一个如果输入不正确可能会崩溃的程序可能是可以接受的。另一方面，如果你正在创建成百上千用户会访问的程序，程序崩溃就远不可接受了。处理可能出现的条件需要更长的时间来开发和构建代码。图5.1显示了与软件开发应用相关的三个事物之间的关系。
- en: '![](../../OEBPS/Images/CH05_F01_Farrell.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH05_F01_Farrell.png)'
- en: Figure 5.1 The Venn diagram of three aspects of the reality of developing software
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 软件开发现实三个方面的韦恩图
- en: '*Good* in this context indicates that the software application quality is good
    and meets the requirements and user expectations, with a low occurrence of bugs.
    Fast and Cheap are a little harder to define because they relate to time and money,
    as the adage goes.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个语境中，“好”意味着软件应用质量良好，满足需求和用户期望，并且错误发生频率低。快速和便宜的定义稍微有些困难，因为它们与时间和金钱相关，正如俗话所说。
- en: The intersection of Good and Cheap represents the time it takes to develop a
    software application and indicates that it can take more time to create. This
    can happen if an inexperienced developer, or a small team of developers, works
    for a relatively long time to create a good application.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 好和便宜的交集代表了开发软件应用所需的时间，表明这可能需要更多的时间来创建。这可能发生在没有经验的开发者或一个小型开发团队相对长时间地努力创建一个良好的应用时。
- en: The intersection of Good and Fast also represents time and indicates creating
    the application quickly, with good quality. This almost always entails more experienced
    developers who can create an application in a relatively short amount of time.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 好与快的交集代表时间，并表明快速、高质量地创建应用程序。这几乎总是意味着更有经验的开发者可以在相对较短的时间内创建应用程序。
- en: The intersection of Fast and Cheap involves making tradeoffs in quality to create
    the application quickly. An application created this way might be acceptable for
    a one-off utility application but generally should be avoided.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 快与便宜的交集涉及到在快速创建应用程序的同时在质量上进行权衡。以这种方式创建的应用程序可能适用于一次性实用程序，但通常应避免。
- en: Only the intersection of two of the circles can ever be achieved, even though
    the diagram shows the intersection of all three circles. The intersection of all
    three circles is where magical unicorns live. Trying to find a path to the land
    of the unicorns will keep you from actually creating something useful.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 即使图表显示了三个圆的交集，但只有两个圆的交集是可能实现的。三个圆的交集是神奇独角兽居住的地方。试图找到通往独角兽之地的路径会让你无法真正创造出有用的东西。
- en: A software application with good quality meets the needs of its users in a couple
    of ways. It provides the functionality intended and what the user expects, and
    it doesn’t behave in unexpected ways if things go wrong.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 软件应用程序以良好的质量满足用户的需求，以几种方式。它提供了用户期望的功能，并在出错时不会以意外的方式表现。
- en: As mentioned in the introduction to this chapter, in the real world, unexpected
    events happen all the time. Storage devices become full, networks disconnect,
    and users enter incorrect data, unintentionally or otherwise. Unexpected events
    can occur at any time and are handled in Python by an exception being raised.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章引言中所述，在现实世界中，意外事件随时都在发生。存储设备会满，网络会断开，用户会输入错误的数据，无论是无意还是有意。意外事件可能随时发生，Python通过引发异常来处理。
- en: 5.1 Exceptions
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 异常
- en: Python handles unexpected events in running applications by raising exceptions.
    You can think of these as exceptional conditions occurring while an application
    runs, and they’re not all necessarily errors.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Python通过引发异常来处理运行中的应用程序中的意外事件。你可以将这些视为应用程序运行期间发生的异常条件，并且它们并不一定都是错误。
- en: 'If you’ve written any Python programs, you’ve seen exceptions raised. A simple
    math error in a program statement will raise an exception, as shown here:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你编写过任何Python程序，你一定见过引发的异常。程序语句中的简单数学错误会引发异常，如下所示：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The exception `ZeroDivisionError` is raised by Python because the results of
    dividing a value of 10 by 0 are undefined. The exception `ZeroDivisionErro`r is
    a child, or subclass, of the base `Exception` class. The `Exception` class is
    the parent of most other exceptions that Python can raise.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Python会引发`ZeroDivisionError`异常，因为将10除以0的结果是未定义的。`ZeroDivisionError`异常是基本`Exception`类的子类或子类。`Exception`类是Python可以引发的大多数其他异常的父类。
- en: In this way, the `Exception` class is precisely like how the `Shape` class is
    the parent of the `Rectangle` class in the previous chapter. A `ZeroDivisionError`
    exception is a more specific version of the more general base `Exception` class`.`
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，`Exception`类就像上一章中`Shape`类是`Rectangle`类的父类一样。`ZeroDivisionError`异常是更通用的基本`Exception`类的更具体版本。
- en: When an exception occurs in a program, Python will stop executing your program
    code and start working its way back up the call stack looking for an exception
    handler. The call stack is the series of function calls leading to the code that
    raised the exception. Python is looking for a handler to intercept the exception
    and do something with it. If no exception handler is found, Python exits the application
    and prints a stack trace.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序中发生异常时，Python将停止执行你的程序代码，并开始沿着调用栈向上查找异常处理程序。调用栈是导致引发异常的代码的一系列函数调用。Python正在寻找一个处理程序来拦截异常并对其进行处理。如果没有找到异常处理程序，Python将退出应用程序并打印堆栈跟踪。
- en: 'The stack trace is a chronological listing descending from the root of the
    application down the call stack of functions that were called to reach the point
    in the code where the exception was raised. Each function listed in the stack
    trace also shows the line number in the module where the function in the stack
    trace is called. The stack trace continues until the last function is called,
    where the line number that raised the exception is displayed. The example program
    `examples/CH_05/example_01.py` demonstrates this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈跟踪是从应用程序的根开始，按时间顺序向下列出调用栈中调用的函数，直到到达代码中引发异常的点。堆栈跟踪中列出的每个函数也显示了调用堆栈中函数所在的模块中的行号。堆栈跟踪一直持续到最后一个函数被调用，此时显示引发异常的行号。示例程序
    `examples/CH_05/example_01.py` 展示了这一点：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This program shows `func_a()` getting input from the user for the `dividend`
    and `divisor` and converting those input strings to floating-point values. It
    then calls `func_b()`, which calls `func_c()`, which performs the division operation
    on the two passed parameters. Running this program produces the following output
    for the values entered at the prompts:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序显示了 `func_a()` 从用户那里获取 `dividend` 和 `divisor` 的输入，并将这些输入字符串转换为浮点值。然后它调用
    `func_b()`，`func_b()` 又调用 `func_c()`，在传递的两个参数上执行除法操作。运行此程序会在提示中输入的值产生以下输出：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The code shows Python encountering an exception in `func_c()` when it tries
    to divide 12.2 by 0, then going back up the call stack to `func_b()` and up to
    `func_a()`, looking for a handler to intercept the exception. Because there isn’t
    a handler, Python exits the program and prints the exception and stack trace that
    caused the application to crash.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 代码显示 Python 在尝试将 12.2 除以 0 时在 `func_c()` 函数中遇到异常，然后沿着调用栈向上到 `func_b()`，再向上到
    `func_a()`，寻找处理程序来拦截异常。因为没有处理程序，Python 退出程序并打印出导致应用程序崩溃的异常和堆栈跟踪。
- en: tip I inserted `<path` `to` `code>` in the program output and stack trace above
    because the path to the code shown was relevant to my Mac and wouldn’t be the
    same as what you would see running the code on your computer.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：我在上面的程序输出和堆栈跟踪中插入了 `<path to code>`，因为显示的代码路径与我使用的 Mac 相关，并且与你在计算机上运行代码时看到的不一样。
- en: 'Another possible exception that the program can raise happens if the user enters
    a string at either of the two prompts that can’t be converted to a floating-point
    value. Here is an example of running the program raising that exception:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 程序可能引发的另一个可能的异常是，如果用户在两个提示中的任何一个输入了一个无法转换为浮点值的字符串。以下是一个运行程序引发该异常的示例：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, the stack trace only shows `func_a()` because the `ValueError`
    exception was raised within that function when the program tried to convert the
    string `Python` to a floating-point value.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，堆栈跟踪只显示了 `func_a()`，因为当程序尝试将字符串 `Python` 转换为浮点值时，`ValueError` 异常在该函数内部引发。
- en: 5.2 Handling exceptions
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 处理异常
- en: 'Handling exceptions in Python is done by using a `try / except` block in your
    program code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中处理异常是通过在程序代码中使用 `try / except` 块来完成的：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `try` statement begins a block of code that might raise an exception your
    program can handle. The `except` `Exception` `as` `e:` statement ends the block
    of code and is where an exception is intercepted and assigned to the `e` variable.
    The use of `e` is not required syntax, and the variable name `e` is just my convention.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`try` 语句开始一个可能引发程序可以处理的异常的代码块。`except Exception as e:` 语句结束代码块，并且是在这里拦截异常并将其分配给
    `e` 变量的地方。使用 `e` 不是必需的语法，变量名 `e` 只是我的惯例。'
- en: Because of the `except` `Exception` `as` `e:` in the handler part of the block,
    the previous example will catch any exception raised by the code within the `try`
    `/` `except` block. The `else` and `finally` clauses of the `try` `/` `except`
    block are optional and used less often in practice.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 由于处理程序部分中的 `except Exception as e:`，前面的示例将捕获 `try / except` 块内引发的任何异常。`try /
    except` 块的 `else` 和 `finally` 子句是可选的，并且在实践中使用较少。
- en: 5.2.1 Handling an exception if the code can do something about it
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.1 如果代码可以处理异常，则处理异常
- en: When thinking about exceptions, it’s easy to get into a frame of mind to handle
    them everywhere they might occur. Depending on where in the program the exception
    occurs, this might be a logical choice.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当考虑异常时，很容易陷入一种处理它们可能出现的任何地方的心态。根据异常在程序中的发生位置，这可能是逻辑上的选择。
- en: Often, exceptions happen within the context of a function where the code is
    acting on the arguments passed to it. At this point, the scope of work the code
    is performing is narrow, and the broader context of what the program is trying
    to accomplish is at a higher level.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，异常发生在代码作用于传递给它的参数的函数上下文中。在这种情况下，代码执行的工作范围很窄，而程序试图实现更广泛的上下文则处于更高层级。
- en: tip If you’re using the concept of “single responsibility,” then it is likely
    that the function has little context of the bigger picture that the application
    is creating.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：如果您使用“单一职责”的概念，那么函数可能对应用程序创建的更大图景了解不多。
- en: When an exception occurs in a function, the exception handler can make reasonable
    choices within the context of the function. The handler might be able to retry
    the operation for a fixed number of attempts before letting the exception flow
    upward in the call stack to a higher context. It could make assumptions based
    on the exception and correct or change the state of data to make the code continue
    without raising an exception.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数中发生异常时，异常处理器可以在函数的上下文中做出合理的选择。处理器可能能够在让异常在调用堆栈中向上传播到更高上下文之前，尝试重试操作固定次数。它可以根据异常做出假设，并纠正或更改数据的状态，使代码继续执行而不会引发异常。
- en: 5.2.2 Allowing exceptions to flow upward in your programs
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.2 允许异常向上传播到程序中
- en: Unless the code where the exception occurs can do something useful about the
    exception, it’s better to let the exception flow upward through the call stack
    to a higher level of context. At higher levels of context, decisions can be made
    about how to handle the exception. The higher-level context might be the point
    where choices about retrying operations are made. At the higher levels of context,
    more information might be available about what the program is trying to accomplish
    and what alternative paths can be taken. At this point, you can decide what information
    to present to the user so they can make choices about how to proceed.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果异常发生的代码无法对异常采取任何有用的措施，那么最好让异常通过调用堆栈向上传播到更高层级的上下文中。在更高层级的上下文中，可以做出关于如何处理异常的决定。更高层级的上下文可能是做出重试操作选择的地方。在更高层级的上下文中，可能可以获得更多关于程序试图实现什么以及可以采取哪些替代路径的信息。在这种情况下，您可以决定向用户展示哪些信息，以便他们可以决定如何继续操作。
- en: The program should also log the exception and the stack trace associated with
    it, so the application developers have information about the path taken that generated
    the exception. This is incredibly useful information to have when debugging an
    application and trying to resolve problems.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 程序还应记录异常及其关联的堆栈跟踪，以便应用程序开发者了解导致异常的路径。当调试应用程序并尝试解决问题时，这组信息非常有用。
- en: Where in the code to log exceptions depends partly on whether the exception
    was handled or not. If the exception was handled, it may not be necessary to log
    information about it. However, it might be useful to output a log message, not
    as an error but at the information level to make it visible.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中记录异常的位置部分取决于异常是否被处理。如果异常被处理，可能没有必要记录有关它的信息。然而，输出一条日志消息可能是有用的，这不是错误，而是信息级别，以便使其可见。
- en: It’s also possible that an exception is fatal to the program and nothing can
    be done other than logging the exception stack trace and exiting the program.
    Exiting an application is an entirely reasonable course of action for some applications,
    such as utility programs and command-line tools.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 也可能存在异常对程序是致命的，除了记录异常堆栈跟踪和退出程序之外，无法采取任何其他措施。对于某些应用程序，如实用程序和命令行工具，退出应用程序是完全合理的行动方案。
- en: 5.2.3 Informing the user
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.3 通知用户
- en: Keeping the application user informed about the status of an application and
    the events occurring in it is also useful. An exception handler in the right context
    of the application flow can inform the user to take steps toward corrective action,
    allowing the application to retry an action and succeed. The type of exception,
    and the message attached to it, can help generate an informative message to present
    to the user.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 保持应用程序用户了解应用程序的状态和其中发生的事件也是有用的。在应用程序流程的正确上下文中，异常处理器可以通知用户采取纠正措施，允许应用程序重试操作并成功。异常的类型以及附加到其上的消息可以帮助生成一条信息性消息，向用户展示。
- en: 5.2.4 Never silence an exception
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.4 永远不要静默异常
- en: 'It’s possible to handle an exception and silence it. Silencing an exception
    is shown in these two examples:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能处理异常并抑制它。抑制异常在以下两个示例中展示：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first example catches all exceptions, including system and keyboard events
    like CTRL-C to exit a program, which generates the exception `KeyboardInterrupt`.
    This is a system exception and not necessarily an error, just an exceptional event.
    The second example catches a narrower scope of exceptions, many of which can be
    considered error conditions, but it’s still far too wide a net.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例捕获所有异常，包括系统事件和键盘事件，如 CTRL-C 退出程序，这会生成 `KeyboardInterrupt` 异常。这是一个系统异常，并不一定是错误，而是一个异常事件。第二个示例捕获更窄范围的异常，其中许多可以被认为是错误条件，但它仍然过于宽泛。
- en: Worse than catching too broad a class of exceptions, the previous code lets
    the exception pass silently. It doesn’t inform the user or log the exception stack
    trace. The user is deprived of information about why the application is malfunctioning,
    and the developer isn’t given any information about what the exception is or where
    it’s occurring.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获过于广泛的异常类别比这更糟糕，之前的代码让异常无声地通过。它没有通知用户或记录异常堆栈跟踪。用户被剥夺了了解应用为何出现故障的信息，开发者也没有得到任何有关异常是什么或它发生在哪里的信息。
- en: The presence of either of these blocks of code is an indication of a low-quality
    application. Trying to find the source of the problem where this pattern of code
    exists in an application is frustrating and time-consuming.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 存在这样的代码块之一是低质量应用的标志。试图在应用中找到这种代码模式的问题源头是令人沮丧且耗时的。
- en: Example 1 improved
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1 改进
- en: 'The following example code acts on the previous discussion to show when to
    allow exceptions to flow upward in the call stack and when an exception handler
    can be used to try and correct the situation that caused the exception. The program
    `examples/CH_05/example_01.py` can be improved to handle exceptions and provide
    a better user experience. The program `examples/CH_05/example_02.py` demonstrates
    this improvement:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例代码基于之前的讨论，展示了何时允许异常向上传递到调用栈，以及何时可以使用异常处理器尝试纠正导致异常的情况。程序 `examples/CH_05/example_01.py`
    可以改进以处理异常并提供更好的用户体验。程序 `examples/CH_05/example_02.py` 展示了这种改进：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this example, the functions `func_a()`, `func_b()`, and `func_c()` are unchanged
    and don’t catch exceptions. They follow the pattern of letting exceptions flow
    upward through the stack to a higher-level context.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，函数 `func_a()`、`func_b()` 和 `func_c()` 都没有改变，并且不捕获异常。它们遵循让异常向上通过堆栈传递到更高级别上下文的模式。
- en: That higher-level context is `func_a()`. Now there is a while loop around the
    function that will keep trying `func_a()` until it can complete successfully.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这一级别的上下文是 `func_a()`。现在有一个围绕该函数的 while 循环，它会不断尝试执行 `func_a()`，直到成功完成。
- en: Within the while loop, there is an exception handler catching two exceptions,
    `ZeroDivisionError` and `ValueError`. Both of these handlers prompt the user with
    information about what went wrong and provide advice about how to proceed.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在 while 循环内部，有一个异常处理器捕获两个异常，`ZeroDivisionError` 和 `ValueError`。这两个处理器都会向用户提供有关出错的信息，并提供有关如何继续的建议。
- en: The `else` clause of the handler only executes if `func_a()` runs successfully
    without raising an exception. When this happens, it sets the `successful` variable
    to `True`, signaling the enclosing while loop to exit.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器的 `else` 子句仅在 `func_a()` 成功运行且未引发异常时执行。当发生这种情况时，它将 `successful` 变量设置为 `True`，向包围的
    while 循环发出退出信号。
- en: 'The `finally` clause takes advantage of the state of the `successful` variable
    to either indicate the program is done or encourage the user to try again. Running
    this program with possible input from the user looks like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`finally` 子句利用 `successful` 变量的状态来指示程序已完成或鼓励用户再次尝试。运行此程序并从用户可能的输入来看，情况如下：'
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This program follows most of the recommendations to handle exceptions:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序遵循了处理异常的大部分建议：
- en: Allows the exceptions that can’t be handled locally to flow upward to a higher
    context
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许无法在本地处理的异常向上流动到更高上下文
- en: Handles an exception if the code can do something useful about it
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果代码可以对此异常做些有用的事情，则处理异常
- en: Informs the user about the problem and suggests a solution
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通知用户问题并提出解决方案
- en: Doesn’t silence an exception
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不抑制异常
- en: The program doesn’t log the exception and the stack trace, as this would be
    distracting information for the user given the simplicity of this program. This
    program handled the exception as part of its expected program flow, which makes
    logging the exception information unnecessary.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 程序没有记录异常和堆栈跟踪，因为对于这个程序来说，这些信息可能会分散用户的注意力。这个程序将异常处理作为其预期程序流程的一部分，这使得记录异常信息变得不必要。
- en: That’s not to say the information couldn’t be added to the handlers for `ZeroDivisionError`
    and `ValueError if it were deemed useful. Logging an exception can be handled
    by using Python’s logging module in the following manner:`
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是说，如果认为有用，这些信息不能被添加到 `ZeroDivisionError` 和 `ValueError` 的处理程序中。可以使用以下方式使用
    Python 的日志模块来处理异常：`
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This code imports the `logging` module and creates a simple `logger` instance
    named after the module in which the instance is created. It then sets the terminal
    as the output of log messages, creates a formatter for what messages should look
    like, and adds the handler to the logger instance. Configuring a logger more fully
    will be part of later chapter examples when we start building the MyBlog web application.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码导入了 `logging` 模块，并创建了一个以创建实例的模块命名的简单 `logger` 实例。然后它将终端设置为日志消息的输出，创建了一个用于消息外观的格式化器，并将处理程序添加到日志记录器实例中。更全面地配置日志记录器将是后续章节示例的一部分，当我们开始构建
    MyBlog 网络应用程序时。
- en: 'Calling `logger.error()` inside the exception handler will print the message.
    That message will be formatted and look like this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在异常处理程序中调用 `logger.error()` 将会打印消息。该消息将被格式化，看起来像这样：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The output includes a timestamp when the exception occurred, the module name,
    the error level, and the message. In the previous example, the `__main__` name
    exists because the example was run as a standalone application.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 输出包括异常发生的时间戳、模块名称、错误级别和消息。在先前的例子中，`__main__` 名称存在是因为示例作为独立应用程序运行。
- en: If the code was imported into a larger application as a module, `__main__` would
    be replaced with the name of the module. In a larger application, this information
    is useful to narrow down the area where the exception occurred.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码作为一个模块被导入到更大的应用程序中，`__main__` 将会被替换为模块的名称。在更大的应用程序中，这个信息有助于缩小异常发生的位置。
- en: In this simple example, the output of the logger is directed to `stdout`, which
    is the console, or screen for most users. Most use cases of loggers are directed
    to log files, or log aggregator systems, to keep logging information from interfering
    with any output the program is producing for the user.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的例子中，日志记录器的输出被定向到 `stdout`，对于大多数用户来说，这代表控制台或屏幕。大多数日志记录器的使用案例都是将输出定向到日志文件或日志聚合系统，以防止日志信息干扰程序为用户产生的任何输出。
- en: The introduction to this section states an exception should never be silenced,
    which is predominantly the right way to handle exceptions. There are situations
    where the developer’s knowledge about the code would make silencing an exception
    acceptable if taken with forethought. The recommendations listed previously still
    hold, however.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍中提到，异常永远不会被静默处理，这是处理异常的主要正确方式。然而，在某些情况下，如果开发者对代码的了解使得在深思熟虑的情况下静默处理异常是可以接受的，那么上述建议仍然适用。
- en: 5.3 Raising an exception
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3 抛出异常
- en: In Python, you can raise exceptions programmatically in your code. Raising an
    exception might seem like an odd thing to do since most of the time an exception
    equates to errors. However, raising an exception is a useful way to handle conditions
    within your programs that you decide are exceptional and not necessarily programmatic
    errors.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，你可以在代码中以编程方式抛出异常。抛出异常可能看起来像是一件奇怪的事情，因为大多数时候异常等同于错误。然而，抛出异常是处理程序中你决定是异常而不是程序性错误的条件的有效方式。
- en: As an example, suppose you’re writing a quiz application that provides calculations
    based on user input. One of the calculation functions only works if a user-entered
    parameter is greater than 0 and less than or equal to 100\. The code should define
    a range of values acceptable to the function.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你正在编写一个提供基于用户输入的计算的测验应用程序。其中一个计算函数仅当用户输入的参数大于 0 且小于或等于 100 时才有效。代码应该定义一个该函数可接受值的范围。
- en: Because integers in Python have a large range, your program code will need to
    limit the user input to within the range 0 < value ≤ 100\. Restricting the range
    is easy enough to do at the point of use in the function, but what should the
    function do if the range is violated?
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Python中的整数范围很大，你的程序代码需要将用户输入限制在0 < value ≤ 100的范围内。在函数的使用点限制范围是足够容易的，但函数如果违反了范围限制，应该怎么做呢？
- en: 'Most likely the function should do nothing, as it doesn’t have the context
    to do anything useful if the range restriction is violated. Keeping in mind the
    idea of letting exceptions flow upward to where they can be handled, raising an
    exception can be useful. Here is one way to handle the range restriction in the
    function:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最有可能的是，函数应该什么都不做，因为它没有上下文来执行任何有用的操作，如果范围限制被违反。考虑到让异常向上流动到可以处理它们的层级，抛出异常是有用的。这里有一种处理函数中范围限制的方法：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: At the very top of the function, a conditional statement checks if the `value`
    parameter is not within the acceptable range, and if not, a `ValueError` exception
    is raised. If the parameter is within range, the function continues normally.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数的最顶部，一个条件语句检查`value`参数是否不在可接受范围内，如果不是，则抛出一个`ValueError`异常。如果参数在范围内，函数将正常继续执行。
- en: The code delegated the responsibility for handling the out-of-range `ValueError`
    exception up the call stack to the calling function. The calling function most
    likely does have the context necessary to handle the exception, perhaps by prompting
    the user to enter the `value` parameter again.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将处理超出范围的`ValueError`异常的责任委托给调用栈上的调用函数。调用函数很可能具有处理异常所需的上下文，可能通过提示用户再次输入`value`参数来实现。
- en: 'Handling the `ValueError` exception in the calling function might look like
    this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用函数中处理`ValueError`异常可能如下所示：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `get_data_from_user()` function calls the `range_check_user_input()` function
    inside a `try` `/` `except` block that handles a `ValueError` exception, prints
    the error out for the user, and restarts the process to get data from the user.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_data_from_user()`函数在`try` `/` `except`块中调用`range_check_user_input()`函数，该块处理`ValueError`异常，向用户打印错误信息，并重新启动过程以获取用户数据。'
- en: 5.4 Creating your own exceptions
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.4 创建自己的异常
- en: 'Python allows you to create custom exception classes your code can raise. Creating
    a custom exception might seem unnecessary since Python has a rich set of exception
    classes already defined. There are a couple of good reasons to create custom exceptions:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Python允许你创建自定义异常类，你的代码可以抛出这些异常。创建自定义异常可能看起来是不必要的，因为Python已经定义了一套丰富的异常类。创建自定义异常有几个很好的理由：
- en: Exception namespace creation
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常命名空间创建
- en: Exception filtering
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常过滤
- en: In the previous section, the `ValueError` was raised by the `range_check_ user_input()`
    function, so an exception handler at a higher level in the `get_data_from_user()`
    function can intercept and address it. But suppose the `range_check_user_input()`
    function raised an unrelated `ValueError` later in the function. The exception
    would flow upward through the stack to the calling function and be caught by the
    exception handler in `get_data_from_user()`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，`range_check_user_input()`函数抛出了`ValueError`，因此`get_data_from_user()`函数中更高层次的异常处理程序可以拦截并处理它。但是，假设`range_check_user_input()`函数在函数的后面抛出了不相关的`ValueError`。异常将通过调用栈向上流动到调用函数，并被`get_data_from_user()`中的异常处理程序捕获。
- en: At that point, what should the `get_data_from_user()` function do? The code
    can’t assume the correct behavior is to show the error to the user and restart
    the process of gathering data, because the range check isn’t the only possible
    source of the exception.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个点上，`get_data_from_user()`函数应该做什么？代码不能假设正确的行为是向用户显示错误并重新启动收集数据的过程，因为范围检查不是异常的唯一可能来源。
- en: One option is to examine the exception arguments by looking at the `e.args`
    attribute tuple. Then the code can make choices within the exception handler to
    determine the source of the exception. This solution is brittle since it depends
    on the arguments passed at the point where `ValueError` was raised, and those
    might change sometime later.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一种选择是通过查看`e.args`属性元组来检查异常参数。然后代码可以在异常处理程序中做出选择，以确定异常的来源。这种解决方案是脆弱的，因为它依赖于在`ValueError`抛出时的参数，而这些参数可能会在以后改变。
- en: 'A better design is to create an exception specific to the needs of the program,
    narrowing the scope of the exceptions to handle. You can create a custom exception
    handler in the module that defines the `range_check_user_input()` function like
    this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的设计是创建一个针对程序需求的特定异常，缩小异常处理的范围。你可以在定义`range_check_user_input()`函数的模块中创建一个自定义异常处理器，如下所示：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This code creates a new exception class named `OutsideRangeException` that
    inherits from the parent `Exception` class. This new exception class is used in
    the `range_ check_user_input()` function and raised if the `value` parameter is
    outside the defined range of acceptable values. Now the abbreviated program code
    looks like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码创建了一个名为`OutsideRangeException`的新异常类，它继承自父类`Exception`。这个新异常类在`range_check_user_input()`函数中使用，并在`value`参数超出定义的可接受值范围时引发。现在简化的程序代码看起来像这样：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If the parameter `value` is outside the acceptable range, the `get_data_from_
    user()` function can catch that specific custom exception and handle it. If any
    other exception is raised by the `range_check_user_input()` function, that exception
    will flow upward to a handler catching that specific exception (or just the base
    class `Exception`). A complete example program using the logging module that demonstrates
    this is shown here with comments removed for brevity:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数`value`超出了可接受的范围，`get_data_from_user()`函数可以捕获这个特定的自定义异常并处理它。如果`range_check_user_input()`函数引发任何其他异常，该异常将向上传递到捕获该特定异常（或只是基类`Exception`）的处理程序。下面是一个使用日志模块的完整示例程序，展示了这一点，为了简洁起见，注释已被移除：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 5.5 Closing thoughts
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.5 结束语
- en: Understanding how to handle and use exceptions is essential to a developer.
    They are the events our programs receive from the real world about the things
    happening to our programs and the result of the actions our programs take.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 理解如何处理和使用异常对于一个开发者来说至关重要。它们是我们程序从现实世界接收到的关于程序发生的事情以及程序采取的行动的结果的事件。
- en: A goal of development is to create something useful in the world. Exceptions
    and how we handle them are tools allowing you to develop successful programs that
    will be used and well-received in that world.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 开发的一个目标是创建对世界有用的东西。异常以及我们如何处理它们是允许你开发出在这个世界上将被使用和良好接受的成功的程序的工具。
- en: Exceptions and exception handling are another slice of the developer’s world.
    Looking at them closely and gaining an understanding of their details allows you
    to use exceptions well as we examine other aspects of developing applications.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 异常和异常处理是开发者世界的一部分。仔细观察它们并了解它们的细节，可以帮助你更好地使用异常，正如我们在检查应用程序开发的其它方面时一样。
- en: Summary
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: The world is full of events—some expected, some unexpected. Applications are
    also subject to expected and unexpected events, which manifest themselves as exceptions.
    Exceptions, and how they’re handled in an application, are part of the developer’s
    life.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 世界充满了事件——有些是预期的，有些是意外的。应用程序也受到预期和意外事件的困扰，这些事件表现为异常。异常以及它们在应用程序中的处理是开发者生活的一部分。
- en: Exceptions in Python are handled by introducing try/except blocks of code in
    our applications. These try/except blocks give us a way to catch exceptions and
    address them, if necessary.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python中，异常是通过在应用程序中引入try/except代码块来处理的。这些try/except代码块为我们提供了捕获异常并处理它们（如果需要的话）的方法。
- en: Where to catch an exception in an application is often decided by where in the
    code the context exists to do something useful about the exceptional event.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用程序中捕获异常的位置通常取决于代码中存在处理异常事件的有用上下文的位置。
- en: Generating exceptions is not always about errors. An exception is neither good
    nor bad; it’s just an event. They can be useful for signaling an event to other
    parts of an application that might be relevant to the design of your applications.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成异常并不总是关于错误。异常既不是好的也不是坏的；它只是一个事件。它们可以用来向应用程序的其他部分发出信号，这些部分可能与你的应用程序设计相关。
