- en: 12 Putting the parts together into a complete game
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12 将部分组合成一个完整的游戏
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Assembling objects and code from other projects
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从其他项目组装对象和代码
- en: Programming point-and-click controls
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程点按控制
- en: Upgrading the UI from the old to a new system
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从旧UI系统升级到新系统
- en: Loading new levels in response to objectives
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据目标加载新关卡
- en: Setting up win/loss conditions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置胜负条件
- en: Saving and loading the player’s progress
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存和加载玩家的进度
- en: The project in this chapter will tie together everything from previous chapters.
    Most chapters have been pretty self-contained, and we haven’t taken an end-to-end
    look at the entire game. I’ll walk you through pulling together pieces that have
    been introduced separately so that you know how to build a complete game from
    all of those pieces.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的项目将把之前章节中的所有内容串联起来。大多数章节都相当独立，我们没有从头到尾审视整个游戏。我将带你了解如何将分别引入的各个部分组合起来，以便你知道如何从所有这些部分构建一个完整的游戏。
- en: I’ll also discuss the encompassing structure of the game, including switching
    levels and ending the game (displaying Game Over when you die, and Success when
    you reach the exit). And I’ll show you how to save the game, because saving the
    player’s progress becomes increasingly important as the game grows in size.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我还将讨论游戏的整体结构，包括切换关卡和结束游戏（当你死亡时显示“游戏结束”，达到出口时显示“成功”）。我还会向你展示如何保存游戏，因为随着游戏规模的扩大，保存玩家的进度变得越来越重要。
- en: WARNING Much of this chapter uses tasks that were explained in detail in previous
    chapters, so I’ll move through the steps quickly. If certain steps confuse you,
    refer to the relevant chapter (for example, chapter 7 about the UI) for a more
    detailed explanation.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：本章的大部分内容使用了在之前章节中已详细解释的任务，所以我会快速地通过这些步骤。如果某些步骤让你感到困惑，请参考相关章节（例如，关于UI的第7章）以获得更详细的解释。
- en: This chapter’s project is a demo of an action role-playing game (RPG). In this
    sort of game, the camera is placed high and looks down sharply (see figure 12.1),
    and the character is controlled by clicking the mouse where you want to go. You
    may be familiar with the game *Diablo*, which is an action RPG like this. I’m
    switching to yet another game genre so that we can squeeze in one more genre before
    the end of the book!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的项目是一个动作角色扮演游戏（RPG）的演示。在这类游戏中，摄像机放置得较高，并且向下锐利地观察（见图12.1），角色通过点击鼠标到你想要去的地方来控制。你可能熟悉《暗黑破坏神》这款游戏，它就是这样一款动作RPG。我将切换到另一个游戏类型，以便在本书结束前再塞进一个类型！
- en: '![CH12_F01_Hocking3](../Images/CH12_F01_Hocking3.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![CH12_F01_Hocking3](../Images/CH12_F01_Hocking3.png)'
- en: Figure 12.1 Screenshot of the top-down viewpoint
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 顶视图截图
- en: 'In full, the project in this chapter will be the biggest game yet. It’ll have
    these features:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 完整来说，本章的项目将是迄今为止最大的游戏。它将具有以下功能：
- en: A top-down view with point-and-click movement
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶视图和点击移动
- en: The ability to click devices to operate them
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击设备以操作它们的能力
- en: Scattered items you can collect
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以收集的散落物品
- en: Inventory that’s displayed in a UI window
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在UI窗口中显示的库存
- en: Enemies wandering around the level
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在关卡中游荡的敌人
- en: The ability to save the game and restore your progress
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存游戏并恢复进度的能力
- en: Three levels that must be completed in sequence
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须按顺序完成的三个关卡
- en: Whew, that’s a lot to pack in; good thing this is almost the last chapter!
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，要包含的内容很多；幸好这几乎是最后一章了！
- en: 12.1 Building an action RPG by repurposing projects
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.1 通过重新利用项目构建动作RPG
- en: We’ll develop the action RPG demo by building on the project from chapter 9\.
    Copy that project’s folder and open the copy in Unity to start working. Or, if
    you skipped directly to this chapter, download the sample project for chapter
    9 to build on that.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过在第9章的项目基础上构建来开发动作RPG演示。复制该项目的文件夹，并在Unity中打开副本以开始工作。或者，如果你直接跳到了这一章，请下载第9章的示例项目以在此基础上构建。
- en: The reason we’re building on the chapter 9 project is that it’s the closest
    to our goal for this chapter and thus will require the least modification (compared
    to other projects). Ultimately, we’ll pull together assets from several chapters,
    so technically it’s not that different than if we started with one of those projects
    and pulled in assets from chapter 9.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们基于第9章的项目进行构建的原因是，它离本章的目标最近，因此需要最少的修改（与其他项目相比）。最终，我们将从几个章节中汇集资源，所以从技术上讲，这并不比我们从那些项目开始并从第9章中提取资源有太大不同。
- en: 'Here’s a recap of what’s in the project from chapter 9:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是第9章项目中包含内容的回顾：
- en: A character with an animation controller already set up
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已经设置好动画控制器的角色
- en: A third-person camera that follows the character around
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个跟随角色周围的三人称摄像机
- en: A level with floors, walls, and ramps
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个有地板、墙壁和斜坡的水平面
- en: Lights and shadows all placed
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 灯光和阴影都已放置
- en: Operable devices, including a color-changing monitor
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可操作设备，包括颜色变化的显示器
- en: Collectible inventory items
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可收集的库存物品
- en: Backend managers code framework
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后端管理器代码框架
- en: This hefty list of features covers quite a bit of the action in the RPG demo
    already, but we’ll either need to modify or add a bit more.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能丰富的列表涵盖了 RPG 示例中的相当一部分动作，但我们可能需要修改或添加更多。
- en: 12.1.1 Assembling assets and code from multiple projects
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.1 从多个项目中组装资源和代码
- en: The first two modifications will be to update the managers framework and to
    bring in computer-controlled enemies. For the former task, recall that updates
    to the framework were made in chapter 10, which means those updates aren’t in
    the project from chapter 9\. For the latter task, recall that you programmed an
    enemy in chapter 3.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 前两项修改将是更新管理框架并引入计算机控制的敌人。对于前一个任务，回想一下在第 10 章中进行了框架的更新，这意味着这些更新不在第 9 章的项目中。对于后一个任务，回想一下你在第
    3 章中编写了一个敌人。
- en: Updating the managers framework
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 更新管理框架
- en: Updating the managers is a fairly simple task, so let’s get that out of the
    way first. The IGameManager interface was modified in chapter 10.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 更新管理器是一个相当简单的任务，所以我们首先把它解决掉。在第 10 章中修改了 IGameManager 接口。
- en: Listing 12.1 Adjusted IGameManager
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.1 调整后的 IGameManager
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The code in this listing adds a reference to NetworkService, so also be sure
    to copy over that additional script; drag the file from its location in the chapter
    10 project (remember, a Unity project is a folder on your disc, so get the file
    from there), and drop it in the new project. Now modify Managers to work with
    the changed interface.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的代码添加了对 NetworkService 的引用，因此也务必复制额外的脚本；从第 10 章项目中的位置拖拽文件（记住，Unity 项目是磁盘上的一个文件夹，所以从那里获取文件），并将其放入新项目中。现在修改
    Managers 以适应更改后的接口。
- en: Listing 12.2 Changing a bit of code in the Managers script
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.2 在 Managers 脚本中修改一些代码
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ The adjustments are at the beginning of this method.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 该方法的调整在开头。
- en: Finally, adjust both InventoryManager and PlayerManager to reflect the changed
    interface. The next listing shows the modified code from InventoryManager; PlayerManager
    needs the same code modifications but with different names.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，调整 InventoryManager 和 PlayerManager 以反映更改后的接口。下面的列表显示了修改后的 InventoryManager
    代码；PlayerManager 需要相同的代码修改，但名称不同。
- en: Listing 12.3 Adjusting InventoryManager to reflect IGameManager
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.3 调整 InventoryManager 以反映 IGameManager
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Same adjustments in both managers, but change names
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在两个管理器中执行相同的调整，但更改名称
- en: Once all the minor code changes are in, everything should still act as before.
    This update should work invisibly, and the game will still work the same. That
    adjustment was easy, but the next one will be harder.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有的微小代码更改都完成，一切仍然应该像以前一样工作。这次更新应该无痕进行，游戏仍然会按原样运行。那次调整很简单，但下一次会更难。
- en: Bringing over the AI enemy
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 将 AI 敌人迁移过来
- en: Besides the NetworkServices adjustments from chapter 10, you also need the AI
    enemy from chapter 3\. Implementing enemy characters involved a bunch of scripts
    and art assets, so you need to import all those assets.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 除了第 10 章中的 NetworkServices 调整外，你还需要第 3 章中的 AI 敌人。实现敌人角色涉及大量的脚本和艺术资源，因此你需要导入所有这些资源。
- en: 'First, copy over these scripts (remember, WanderingAI and ReactiveTarget were
    behaviors for the AI enemy, Fireball was the projectile fired, the enemy attacks
    the PlayerCharacter component, and SceneController handles spawning enemies):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，复制这些脚本（记住，WanderingAI 和 ReactiveTarget 是 AI 敌人的行为，Fireball 是发射的弹丸，敌人攻击 PlayerCharacter
    组件，SceneController 负责生成敌人）：
- en: PlayerCharacter
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PlayerCharacter
- en: SceneController
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SceneController
- en: WanderingAI
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WanderingAI
- en: ReactiveTarget
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ReactiveTarget
- en: Fireball
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fireball
- en: Similarly, get the Flame material, Fireball prefab, and Enemy prefab by dragging
    in those files. If you got the enemy from chapter 11 instead of 3, you may also
    need the added fire particle material.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，通过拖拽这些文件来获取火焰材质、火球预制体和敌人预制体。如果你是从第 11 章而不是第 3 章获取的敌人，你可能还需要添加的火焰粒子材质。
- en: After copying over all the required assets, the links between assets will probably
    be broken, so you’ll need to relink the referenced objects in broken assets to
    get them to work. In particular, check the scripts on all prefabs because they
    probably disconnected. For example, the Enemy prefab has two missing scripts in
    the Inspector, so click the circle button (indicated in figure 12.2) to choose
    WanderingAI and ReactiveTarget from the list of scripts. Similarly, check the
    Fireball prefab and relink that script if needed. Once you’re through with the
    scripts, check the links to materials and textures.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在复制所有必需的资产后，资产之间的链接可能会断开，因此你需要将断开的资产中引用的对象重新链接，以便它们能够工作。特别是，检查所有预制体上的脚本，因为它们可能已经断开连接。例如，敌人预制体在检查器中缺少两个脚本，所以点击图12.2中指示的圆形按钮，从脚本列表中选择WanderingAI和ReactiveTarget。同样，检查火球预制体，并在需要时重新链接该脚本。一旦你处理完脚本，检查材质和纹理的链接。
- en: '![CH12_F02_Hocking3](../Images/CH12_F02_Hocking3.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![CH12_F02_Hocking3](../Images/CH12_F02_Hocking3.png)'
- en: Figure 12.2 Linking a script to a component
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 将脚本链接到组件
- en: Now add SceneController to the controller object and drag the Enemy prefab onto
    that component’s Enemy slot in the Inspector. You may need to drag the Fireball
    prefab onto the Enemy’s script component (select the Enemy prefab and look at
    WanderingAI in the Inspector). Also attach PlayerCharacter to the player object
    so that enemies will attack the player.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将SceneController添加到控制器对象中，并将敌人预制体拖到检查器中该组件的敌人槽位。你可能需要将火球预制体拖到敌人的脚本组件上（选择敌人预制体，并在检查器中查看WanderingAI）。此外，将PlayerCharacter附加到玩家对象上，以便敌人攻击玩家。
- en: Play the game and you’ll see the enemy wandering around. The enemy shoots fireballs
    at the player, although they won’t do much damage; select the Fireball prefab
    and set its Damage value to 10.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 玩游戏，你会看到敌人四处游荡。敌人向玩家发射火球，尽管它们造成的伤害不大；选择火球预制体，并将其伤害值设置为10。
- en: NOTE Currently, the enemy isn’t particularly good at tracking down and hitting
    the player. In this case, I’d start by giving the enemy a wider field of vision
    (using the dot product approach from chapter 9). Ultimately, you’ll spend a lot
    of time polishing a game, and that includes iterating on the behavior of enemies.
    Polishing a game to make it more fun, though crucial for a game to be released,
    isn’t something you’ll do in this book.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：目前，敌人并不擅长追踪和击中玩家。在这种情况下，我会首先给敌人一个更宽的视野（使用第9章中的点积方法）。最终，你将在游戏打磨上花费大量时间，这包括迭代敌人的行为。虽然打磨游戏以使其更有趣对于游戏的发布至关重要，但这本书中不会涉及这一部分。
- en: The other issue is that when you wrote this code in chapter 3, the player’s
    health was an ad hoc addition, written for testing. Now the game has a PlayerManager,
    so modify PlayerCharacter according to the next listing in order to work with
    health in that manager.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是你编写第3章中的代码时，玩家的健康值是一个临时的添加，是为了测试而编写的。现在游戏有了PlayerManager，所以根据下面的列表修改PlayerCharacter，以便与该管理器中的健康值一起工作。
- en: Listing 12.4 Adjusting PlayerCharacter to use health in PlayerManager
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.4 调整PlayerCharacter以使用PlayerManager中的健康值
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Use the value in PlayerManager instead of the variable in PlayerCharacter.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用PlayerManager中的值而不是PlayerCharacter中的变量。
- en: At this point, you have a game demo with pieces assembled from multiple previous
    projects. An enemy character has been added to the scene, making the game more
    threatening. But the controls and viewpoint are still from the third-person movement
    demo, so let’s implement point-and-click controls for an action RPG.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你已经有一个游戏演示，其中的角色是由多个先前项目中的部件组装而成的。场景中增加了一个敌人角色，使得游戏更具威胁性。但是控制方式和视角仍然是来自第三人称移动演示，所以让我们为动作角色扮演游戏实现点按控制。
- en: '12.1.2 Programming point-and-click controls: Movement and devices'
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.2 编程点按控制：移动和设备
- en: This demo needs a top-down view and mouse control of the player’s movement (refer
    to figure 12.1). Currently, the camera responds to the mouse, whereas the player
    responds to the keyboard (as programmed in chapter 8), which is the reverse of
    what you want in this chapter. In addition, you’ll modify the color-changing monitor
    so that devices are operated by clicking them. In both cases, the existing code
    isn’t terribly far from what you need; you’ll make adjustments to both the movement
    and device scripts.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个演示需要一个俯视图和鼠标控制玩家的移动（参考图12.1）。目前，摄像头响应鼠标，而玩家响应键盘（如第8章中编程的那样），这与本章中你想要的效果相反。此外，你将修改颜色变化的显示器，以便通过点击来操作设备。在这两种情况下，现有的代码与所需的代码并不相去甚远；你将对移动和设备脚本进行调整。
- en: Setting up the top-down view of the scene
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 设置场景的俯视图
- en: First, you’ll raise the camera to 8 Y to position it for an overhead view. You’ll
    also adjust OrbitCamera to remove mouse controls from the camera and use only
    arrow keys.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将相机提升到8 Y以定位它进行俯视图。你还将调整OrbitCamera以从相机中移除鼠标控制，并仅使用箭头键。
- en: Listing 12.5 Adjusting OrbitCamera to remove mouse controls
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.5 调整OrbitCamera以移除鼠标控制
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Reverse the direction from before.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 反转之前的方向。
- en: The camera’s Near/Far clipping planes
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 相机的近/远裁剪平面
- en: While you’re adjusting the camera, I want to point out the Near/Far clipping
    planes. These settings never came up before because the defaults are fine, but
    you may need to adjust these in a future project.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在调整相机时，我想指出近/远裁剪平面。这些设置之前从未出现过，因为默认值是合适的，但在未来的项目中你可能需要调整这些设置。
- en: If you need to adjust these values, select the camera in the scene and look
    for the Clipping Planes section in the Inspector; both Near and Far are numbers
    you’ll type here. These values define near and far boundaries within which meshes
    are rendered. Polygons closer than the Near clipping plane or farther than the
    Far clipping plane aren’t drawn.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要调整这些值，在场景中选择相机，并在检查器中查找裁剪平面部分；近和远都是你在这里输入的数字。这些值定义了多边形渲染的近和远边界。比近裁剪面更近或比远裁剪面更远的多边形不会被绘制。
- en: You want the Near/Far clipping planes as close together as possible, while still
    being far enough apart to render everything in your scene. When those planes are
    too far apart (Near is too close, or Far is too far), the rendering algorithm
    can no longer tell which polygons are closer. This results in a characteristic
    rendering error called *z-fighting* (as in the z-axis for depth), where polygons
    flicker on top of each other.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望近/远裁剪平面尽可能靠近，同时仍然足够远，以便渲染场景中的所有内容。当这些平面相距太远（近裁剪面太近，或远裁剪面太远）时，渲染算法就再也无法判断哪个多边形更近。这导致了一种称为*z-fighting*（在z轴上）的典型渲染错误，其中多边形在彼此之上闪烁。
- en: With the camera raised even higher, the view when you play the game will be
    top-down. At the moment, though, the movement controls still use the keyboard,
    so let’s write a script for point-and-click movement.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当相机被抬得更高时，你在玩游戏时的视角将是俯视图。然而，目前移动控制仍然使用键盘，所以让我们编写一个脚本来实现点按移动。
- en: Writing the movement code
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 编写移动代码
- en: The general idea for this code will be to automatically move the player toward
    its target position (as illustrated in figure 12.3). This position is set by clicking
    in the scene. In this way, the code that moves the player isn’t directly reacting
    to the mouse, but the player’s movement is being controlled indirectly by clicking.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码的一般思路是自动将玩家移动到其目标位置（如图12.3所示）。这个位置是通过在场景中点击来设置的。这样，移动玩家的代码不是直接对鼠标做出反应，而是通过点击间接控制玩家的移动。
- en: '![CH12_F03_Hocking3](../Images/CH12_F03_Hocking3.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![CH12_F03_Hocking3](../Images/CH12_F03_Hocking3.png)'
- en: Figure 12.3 How point-and-click controls work
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 点和点击控制的工作原理
- en: NOTE This movement algorithm is useful for AI characters as well. Rather than
    using mouse clicks, the target position could be on a path that the character
    follows.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 备注：此移动算法对AI角色也很有用。而不是使用鼠标点击，目标位置可以是在角色跟随的路径上。
- en: To implement this, create a new script called PointClickMovement and replace
    the RelativeMovement component on the player. Start coding PointClickMovement
    by pasting in the entirety of RelativeMovement (because you still want most of
    that script for handling falling and animations). Then, adjust the code according
    to this listing.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，创建一个新的脚本名为PointClickMovement，并替换玩家上的RelativeMovement组件。通过粘贴RelativeMovement的全部内容开始编写PointClickMovement（因为你仍然需要大部分脚本来处理下落和动画）。然后，根据此列表调整代码。
- en: Listing 12.6 New movement code in PointClickMovement script
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.6 PointClickMovement脚本中的新移动代码
- en: '[PRE5]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Correct the name after pasting scripts.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在粘贴脚本后更正名称。
- en: ❷ Define this value as “nullable” with the ? symbol.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用?符号将此值定义为“可空的”。
- en: ❸ Set the target position when the mouse clicks.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 当鼠标点击时设置目标位置。
- en: ❹ Raycast at the mouse position.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在鼠标位置进行射线投射。
- en: ❺ Set target to the position that was hit.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将目标设置为被击中的位置。
- en: ❻ Move if the target position is set.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 如果设置了目标位置，则移动。
- en: ❼ Rotate toward the target only while moving quickly.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 只有在快速移动时才朝向目标旋转。
- en: ❽ Decelerate to 0 when close to the target.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 当接近目标时减速至0。
- en: ❾ Everything stays the same from here down.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 从这里向下，一切保持不变。
- en: 'Almost everything at the beginning of the Update() method was gutted, because
    that code was handling keyboard movement. Notice that this new code has two main
    if statements: one that runs when the mouse clicks, and one that runs when a target
    is set.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎在Update()方法开始时的所有内容都被删除了，因为那段代码处理键盘移动。注意，新代码有两个主要的条件语句：一个在鼠标点击时运行，另一个在设置目标时运行。
- en: TIP *Nullable values* are a handy programming trick used in this script. Notice
    that the target position value is defined as Vector3? instead of just Vector3;
    this is C# syntax for declaring a nullable value. Some value types (such as Vector3)
    cannot normally be set to null, but you may encounter a situation where it is
    useful to have a null state that means “no value is set.” In that case, you can
    make it a nullable value, allowing you to set the value to null, and then access
    the underlying Vector3 (or whatever) by typing targetPos.Value.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：*可空值*是此脚本中使用的有用的编程技巧。注意，目标位置值被定义为Vector3?而不是Vector3；这是C#声明可空值的语法。某些值类型（如Vector3）通常不能设置为null，但您可能会遇到需要null状态表示“未设置值”的情况。在这种情况下，您可以将其设置为可空值，允许您将值设置为null，然后通过键入targetPos.Value来访问底层的Vector3（或任何其他）。
- en: 'When the mouse clicks, set the target according to where the mouse clicked.
    Here’s yet another great use for raycasting: to determine which point in the scene
    is under the mouse cursor. The target position is set to where the mouse hits.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当鼠标点击时，根据鼠标点击的位置设置目标。这是射线投射的另一个很好的用途：确定场景中鼠标光标下的哪个点。目标位置被设置为鼠标击中的位置。
- en: 'As for the second conditional, first rotate to face the target. Quaternion.Slerp()
    rotates smoothly to face the target, rather than immediately snapping to that
    rotation; also lock rotation while slowing down (otherwise, the player can rotate
    oddly when at the target) by rotating only when over half-speed. Then, transform
    the forward direction from the player’s local coordinates to global coordinates
    (to move forward). Finally, check the distance between the player and the target:
    if the player has almost reached the target, decrement the movement speed and
    eventually end the movement by removing the target position.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 关于第二个条件，首先旋转以面对目标。Quaternion.Slerp()以平滑的方式旋转以面对目标，而不是立即切换到那个旋转；在减速时（否则，当玩家到达目标时，玩家可能会以奇怪的方式旋转）仅当速度超过一半时旋转，以锁定旋转。然后，将玩家的前向方向从本地坐标转换为全局坐标（以向前移动）。最后，检查玩家和目标之间的距离：如果玩家几乎到达目标，则减少移动速度，并通过移除目标位置最终结束移动。
- en: 'Exercise: Turn off jump control'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：关闭跳跃控制
- en: 'Currently, this script still has the jump control from RelativeMovement. The
    player still jumps when the spacebar is pressed, but there shouldn’t be a jump
    button with point-and-click movement. Here’s a hint: adjust the code inside the
    ''if (hitGround)'' conditional branch.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这个脚本仍然有来自RelativeMovement的跳跃控制。当按下空格键时，玩家仍然会跳跃，但在点对点移动中不应该有跳跃按钮。这里有一个提示：调整'if
    (hitGround)'条件分支内的代码。
- en: This takes care of moving the player by using mouse controls. Play the game
    to test it out. Next, let’s make devices operate when clicked.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过使用鼠标控制来处理玩家的移动。玩一下游戏来测试它。接下来，让我们让设备在点击时操作。
- en: Pathfinding with A* and NavMesh
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用A*和NavMesh进行路径查找
- en: 'The movement code we just wrote directs the player straight toward the target.
    However, characters in a game often must find their way around obstacles, rather
    than moving in a straight line. Navigating characters around obstacles is referred
    to as pathfinding. Because this is such a common situation in games, Unity provides
    a built-in pathfinding solution, called NavMesh. Learn more at the following links:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才编写的移动代码将玩家直接引导到目标。然而，游戏中的角色通常必须绕过障碍物找到路径，而不是直线移动。绕过障碍物导航角色被称为路径查找。因为这在游戏中是一个非常常见的情况，Unity提供了一个内置的路径查找解决方案，称为NavMesh。更多信息请参阅以下链接：
- en: '[http://mng.bz/o8Mr](http://mng.bz/o8Mr)'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://mng.bz/o8Mr](http://mng.bz/o8Mr)'
- en: '[http://mng.bz/nryg](https://shortener.manning.com/nryg)'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://mng.bz/nryg](https://shortener.manning.com/nryg)'
- en: Meanwhile, although NavMesh is free and works well, many developers prefer A*
    Pathfinding Project, available from [https://arongranberg.com/astar/](https://arongranberg.com/astar/).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，尽管NavMesh是免费的并且工作良好，但许多开发者更喜欢从[https://arongranberg.com/astar/](https://arongranberg.com/astar/)提供的A*路径查找项目。
- en: Operating devices by using the mouse
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用鼠标操作设备
- en: In chapter 9 (and here, until we adjust the code), devices were operated by
    pressing a key. Instead, they should operate when clicked. To do this, you’ll
    first create a base script that all devices will inherit from; the base script
    will have the mouse control, and devices will inherit that. Create a new script
    called BaseDevice and write the code shown in the following listing.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在第9章（以及在此处，直到我们调整代码），设备是通过按键来操作的。相反，它们应该在点击时操作。为此，你首先将创建一个所有设备都将继承的基础脚本；基础脚本将包含鼠标控制，设备将继承它。创建一个新的脚本名为BaseDevice，并编写以下列表中所示的代码。
- en: Listing 12.7 BaseDevice script that operates when clicked
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.7 当点击时操作的BaseDevice脚本
- en: '[PRE6]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Function that runs when clicked
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 点击时运行的函数
- en: ❷ Correction to vertical position
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 垂直位置的修正
- en: ❸ Call Operate() if the player is nearby and facing.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果玩家附近且面向，则调用Operate()。
- en: ❹ virtual marks a method that inheritance can override.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ virtual标记一个可以被继承覆盖的方法。
- en: Most of this code happens inside OnMouseDown because MonoBehaviour calls that
    method when the object is clicked. First, it checks the distance to the player
    (with a vertical position correction, just as in chapter 9) and then it uses the
    dot product to see whether the player is facing the device. Operate() is an empty
    shell to be filled in by devices that inherit this script.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分代码发生在OnMouseDown中，因为当对象被点击时，MonoBehaviour会调用该方法。首先，它检查玩家（带有垂直位置修正，就像第9章中那样）的距离，然后使用点积来判断玩家是否面向设备。Operate()是一个空壳，由继承此脚本的设备来填充。
- en: NOTE This code looks in the scene for an object with the Player tag, so assign
    this tag to the player object. Tag is a drop-down menu at the top of the Inspector;
    you can define custom tags as well, but several tags are defined by default, including
    Player. Select the player object to edit it and then select the Player tag.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：此代码在场景中查找带有Player标签的对象，因此请将此标签分配给玩家对象。标签位于检查器顶部的下拉菜单中；你还可以定义自定义标签，但默认情况下已定义了几个标签，包括Player。选择玩家对象进行编辑，然后选择Player标签。
- en: Now that BaseDevice is programmed, you can modify ColorChangeDevice to inherit
    from that script. This is the new code.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在BaseDevice已经编程，你可以修改ColorChangeDevice使其继承该脚本。这是新的代码。
- en: Listing 12.8 Adjusting ColorChangeDevice to inherit from BaseDevice
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.8 调整ColorChangeDevice以从BaseDevice继承
- en: '[PRE7]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Inherit BaseDevice instead of MonoBehaviour.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从MonoBehaviour继承BaseDevice。
- en: ❷ Override this method from the base class.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从基类重写此方法。
- en: Because this script inherits from BaseDevice instead of MonoBehaviour, it gets
    the mouse control functionality. Then it overrides the empty Operate() method
    to program the color-changing behavior.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个脚本继承自BaseDevice而不是MonoBehaviour，所以它获得了鼠标控制功能。然后它重写了空的Operate()方法来编程颜色变化行为。
- en: Make the same changes (inherit from BaseDevice instead of MonoBehaviour, and
    add override to the Operate method) to DoorOpenDevice. Now these devices will
    operate when you click them. Also remove the player’s DeviceOperator script component,
    because that script operates devices by pressing the key.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 将相同的更改（从MonoBehaviour继承BaseDevice并添加对Operate方法的覆盖）应用到DoorOpenDevice。现在这些设备在被点击时会操作。同时移除玩家的DeviceOperator脚本组件，因为该脚本通过按键来操作设备。
- en: 'This new device input brings up an issue with the movement controls: currently,
    the movement target is set anytime the mouse clicks, but you don’t want to set
    the movement target when clicking devices. You can fix this issue by using layers;
    similar to the way a tag was set on the player, objects can be set to different
    layers, and the code can check for that. Adjust PointClickMovement to check for
    the object’s layer.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的设备输入带来了运动控制的问题：目前，运动目标在鼠标点击时设置，但你不想在点击设备时设置运动目标。你可以通过使用层来修复这个问题；类似于在玩家上设置标签的方式，对象可以被设置为不同的层，代码可以检查这一点。调整PointClickMovement以检查对象的层。
- en: Listing 12.9 Adjusting mouse-click code in PointClickMovement
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.9 在PointClickMovement中调整鼠标点击代码
- en: '[PRE8]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Added code; the rest is reference.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 添加的代码；其余为参考。
- en: This listing adds a conditional inside the mouse-click code to see whether the
    clicked object is on the Ground layer. Layers (like Tags) is a drop-down menu
    at the top of the Inspector; click it to see the options. Also, like tags, several
    layers are already defined by default. You want to create a new layer, so choose
    Edit Layers in the menu. Type Ground in an empty layer slot (probably slot 8;
    NameToLayer() in the code converts names into layer numbers so that you can use
    the name instead of the number).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表在鼠标点击代码中添加了一个条件，以查看点击的对象是否在地面层。图层（就像标签一样）是检查器顶部的下拉菜单；点击它以查看选项。同样，默认情况下已经定义了几个图层。你想创建一个新的图层，所以请在菜单中选择编辑图层。在空图层槽中输入“地面”（可能是槽8；代码中的NameToLayer()函数将名称转换为图层编号，这样你就可以使用名称而不是数字）。
- en: Now that the Ground layer has been added to the menu, set ground objects to
    the Ground layer—that means the floor of the building, along with the ramps and
    platforms that the player can walk on. Select those objects, and then select Ground
    in the Layers menu.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在地面层已经被添加到菜单中，将地面对象设置为地面层——这意味着建筑物的地板，以及玩家可以行走的斜坡和平台。选择这些对象，然后在图层菜单中选择地面。
- en: Play the game and you won’t move when clicking the color-changing monitor. Great,
    the point-and-click controls are complete! One more thing to bring into this project
    from previous projects is the UI.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 玩游戏时，点击颜色变化的监视器不会移动。太好了，点按控制已经完成！从以前的项目中引入这个项目的另一件事是UI。
- en: 12.1.3 Replacing the old GUI with a new interface
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.3 用新界面替换旧GUI
- en: Chapter 9 used Unity’s old immediate-mode GUI because that approach was simpler
    to code. But the UI from chapter 9 doesn’t look as nice as the one from chapter
    7, so let’s bring over that interface system. The newer UI is more visually polished
    than the old GUI; figure 12.4 shows the interface you’re going to create.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 第9章使用了Unity的旧即时模式GUI，因为这种方法更容易编写代码。但第9章的UI看起来没有第7章的好，所以让我们引入那个界面系统。新的UI比旧的GUI更具有视觉上的精致；图12.4显示了你要创建的界面。
- en: '![CH12_F04_Hocking3](../Images/CH12_F04_Hocking3.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![CH12_F04_Hocking3](../Images/CH12_F04_Hocking3.png)'
- en: Figure 12.4 The UI for this chapter’s project
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4 本章项目UI
- en: 'First, you’ll set up the UI graphics. Once the UI images are all in the scene,
    you can attach scripts to the UI objects. I’ll list the steps involved without
    going into detail; if you need a refresher, refer to chapter 7\. If needed, install
    the TextMeshPro and 2D Sprite packages (refer back to chapters 5 and 6 for these)
    before starting:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要设置UI图形。一旦UI图像都已经在场景中，你就可以将脚本附加到UI对象上。我将列出涉及到的步骤，但不会深入细节；如果你需要复习，请参考第7章。如果需要，在开始之前安装TextMeshPro和2D
    Sprite包（请参考第5章和第6章），然后：
- en: Import popup.png as a sprite (choose Texture Type).
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将popup.png作为精灵导入（选择纹理类型）。
- en: In the Sprite Editor, set a 12-pixel border on all sides (remember to apply
    changes).
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在精灵编辑器中，为所有边设置12像素的边框（记得应用更改）。
- en: Create a canvas in the scene (GameObject > UI > Canvas).
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景中创建一个画布（GameObject > UI > Canvas）。
- en: Choose the Pixel Perfect setting of the canvas.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择画布的像素完美设置。
- en: (Optional) Name the object HUD Canvas and switch to 2D view mode.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （可选）将对象命名为HUD Canvas并切换到2D视图模式。
- en: Create a Text object connected to that canvas (GameObject > UI > Text - TextMeshPro).
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个与该画布连接的文本对象（GameObject > UI > Text - TextMeshPro）。
- en: Set the Text object’s anchor to top left and the object’s position to 120, -50.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文本对象的锚点设置为左上角，并将对象的位置设置为120, -50。
- en: 'Set the label’s Vertex Color to black, set Font Size to 16, and type Health:
    as the text.'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将标签的顶点颜色设置为黑色，字体大小设置为16，并输入文本“健康：”。
- en: Create an image connected to that canvas (GameObject > UI > Image).
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个与该画布连接的图像（GameObject > UI > Image）。
- en: Name the new object Inventory Popup.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新对象命名为“库存弹出窗口”。
- en: Assign the pop-up sprite to the image’s Source Image.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将弹出精灵分配给图像的源图像。
- en: Set Image Type to Sliced and select Fill Center.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图像类型设置为切片并选择填充中心。
- en: Position the pop-up image at 0, 0 and scale the pop-up to 250 for width and
    150 for height.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将弹出图像定位在0, 0处，并将弹出图像的宽度缩放为250，高度缩放为150。
- en: 'NOTE Recall how to switch between viewing the 3D scene and the 2D interface:
    toggle 2D view mode and double-click either the Canvas or the Building to zoom
    in on that object.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：回想一下如何在3D场景和2D界面之间切换视图：切换2D视图模式并双击Canvas或Building来放大该对象。
- en: Now you have the Health label in the corner and the large blue pop-up window
    in the center. Let’s program these parts first before getting deeper into the
    UI functionality. The interface code will use the same Messenger system from chapter
    7, so copy over the Messenger script. Then create a GameEvent script.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经在角落里有了健康标签，在中心有一个大型的蓝色弹出窗口。在我们深入UI功能之前，先编程这些部分。界面代码将使用第7章中相同的消息传递系统，所以复制消息传递脚本。然后创建一个GameEvent脚本。
- en: Listing 12.10 GameEvent script to use with this Messenger system
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.10 使用此消息传递系统的GameEvent脚本
- en: '[PRE9]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: For now, only one event is defined; over the course of this chapter, you’ll
    add a few more events. Broadcast this event from PlayerManager.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 目前只定义了一个事件；在本章的其余部分，你将添加几个更多的事件。从PlayerManager广播此事件。
- en: Listing 12.11 Broadcasting the health event from PlayerManager
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.11 从PlayerManager广播健康事件
- en: '[PRE10]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Add a line to the end of this function.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在此函数的末尾添加一行。
- en: The event is broadcast every time ChangeHealth() finishes to tell the rest of
    the program that the health has changed. You want to adjust the health label in
    response to this event, so create a UIController script.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 每次ChangeHealth()完成后，事件都会广播，以通知程序其他部分健康已经改变。你想要根据此事件调整健康标签，所以创建一个UIController脚本。
- en: Listing 12.12 The script UIController, which handles the interface
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.12 处理界面的UIController脚本
- en: '[PRE11]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Reference the UI object in the scene.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在场景中引用UI对象。
- en: ❷ Set the listener for the health update event.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 设置健康更新事件的监听器。
- en: ❸ Call the function manually at startup.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在启动时手动调用函数。
- en: ❹ Initialize the pop-up to be hidden.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在启动时手动初始化弹出窗口为隐藏状态。
- en: ❺ Toggle the pop-up with the M key.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 使用M键切换弹出窗口。
- en: ❻ Event listener calls the function to update the health label.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 事件监听器调用函数以更新健康标签。
- en: Remove BasicUI from the Controller object, and attach this new script to the
    Canvas (notably *not* the Controller object, which should have only SceneController
    now). Also, create an InventoryPopup script (add an empty public Refresh() method
    for now; the rest will be filled in later) and attach it to the Inventory Popup
    object. Now you can drag the pop-up to the reference slot in the Canvas object’s
    UIController component (and then do the same for the health label).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 从控制器对象中删除BasicUI，并将此新脚本附加到画布上（特别是不要附加到控制器对象，该对象现在应该只有SceneController）。此外，创建一个InventoryPopup脚本（现在添加一个空的public
    Refresh()方法；其余将在以后填写），并将其附加到库存弹出窗口对象上。现在你可以将弹出窗口拖到Canvas对象的UIController组件中的参考槽位（然后对健康标签做同样的操作）。
- en: The health label changes when you get hurt or use health packs, and pressing
    the M key toggles the pop-up window. One last detail to adjust is that clicking
    the pop-up window currently causes the player to move; as with devices, you don’t
    want to set the target position when the UI has been clicked. Make the adjustment
    to PointClickMovement.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当你受伤或使用健康包时，健康标签会改变，按下M键切换弹出窗口。最后需要调整的一个细节是，点击弹出窗口目前会导致玩家移动；与设备一样，当UI被点击时，你不想设置目标位置。调整PointClickMovement。
- en: Listing 12.13 Checking the UI in PointClickMovement
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.13 在PointClickMovement中检查UI
- en: '[PRE12]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note that the conditional checks whether or not the mouse is on the UI. That
    completes the overall structure of the interface, so now let’s deal with the inventory
    pop-up specifically.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，条件检查鼠标是否在UI上。这样，界面的整体结构就完成了，现在让我们专门处理库存弹出窗口。
- en: Implementing the Inventory pop-up
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 实现库存弹出窗口
- en: 'The pop-up window is currently blank, but it should display the player’s inventory
    (depicted in figure 12.5). These steps will create the UI objects:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 弹出窗口目前是空的，但它应该显示玩家的库存（如图12.5所示）。以下步骤将创建UI对象：
- en: Create four images and parent them to the pop-up (that is, drag objects in the
    Hierarchy).
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建四个图像并将它们作为弹出窗口的父级（即，在层次结构中拖动对象）。
- en: Create four text labels and parent them to the pop-up.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建四个文本标签并将它们作为弹出窗口的父级。
- en: Position all the images at 0 Y and set X values to -75, -25, 25, and 75.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有图像定位在Y轴0处，并将X值设置为-75、-25、25和75。
- en: Position the text labels at 45 Y and set X values to -75, -25, 25, and 75.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文本标签定位在Y轴45处，并将X值设置为-75、-25、25和75。
- en: Set the text (not the anchor!) to Center alignment, Bottom vertical align, and
    Height 60.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文本（不是锚点！）设置为居中对齐，垂直对齐为底部，高度为60。
- en: Enter x2 for all the text labels, set Vertex Color black, and Font Size to 16.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为所有文本标签输入x2，设置顶点颜色为黑色，字体大小为16。
- en: In Resources, set all inventory icons as Sprite (instead of Textures).
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在资源中，将所有库存图标设置为Sprite（而不是纹理）。
- en: Drag these sprites to the Source Image slot of the Image objects (also set Native
    Size).
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这些精灵拖到图像对象的源图像槽位（也设置原始大小）。
- en: Add another text label and two buttons, all parented to the pop-up.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加另一个文本标签和两个按钮，所有这些都在弹出窗口中作为父级。
- en: Position this text label at -140, -45 with Right alignment and Middle vertical
    align.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此文本标签定位在-140，-45处，使用右对齐和中间垂直对齐。
- en: 'Type Energy: for the text on this label, set Vertex Color to black, and set
    Font Size to 14.'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此标签的文本中键入“能量：”，将顶点颜色设置为黑色，并将字体大小设置为14。
- en: Set both buttons to Width 60. For Position, set Y to -50 and X to 0 or 70.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个按钮的宽度都设置为60。对于位置，将Y设置为-50，X设置为0或70。
- en: Expand the two buttons in the Hierarchy and type Equip on one button and Use
    on the other.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中展开两个按钮，并在一个按钮上键入“装备”，在另一个按钮上键入“使用”。
- en: '![CH12_F05_Hocking3](../Images/CH12_F05_Hocking3.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![CH12_F05_Hocking3](../Images/CH12_F05_Hocking3.png)'
- en: Figure 12.5 Diagram of the inventory UI
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5 库存UI图
- en: These are the visual elements for the inventory pop-up; next is the code. Write
    the contents of the following into the InventoryPopup script.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是库存弹出窗口的视觉元素；接下来是代码。将以下内容写入InventoryPopup脚本。
- en: Listing 12.14 Full script for InventoryPopup
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 列12.14 InventoryPopup的完整脚本
- en: '[PRE13]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Arrays to reference four images and text labels
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 用于引用四个图像和文本标签的数组
- en: ❷ Check the inventory list while looping through all UI images.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在遍历所有UI图像时检查库存列表。
- en: ❸ Load the sprite from Resources.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 从资源加载精灵。
- en: ❹ Resize the image to the native size of the sprite.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将图像调整到精灵的原始大小。
- en: ❺ Label may say “Equipped” in addition to item count.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 标签可能除了物品计数外还会说“装备”。
- en: ❻ Enable clicking icons.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 启用点击图标。
- en: ❼ Lambda function to trigger differently for each item
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ Lambda函数针对每个项目触发不同的操作
- en: ❽ Clear the listener to refresh from the clean slate.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 清除听众以从干净石板刷新。
- en: ❾ Add this listener function to EventTrigger.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 将此监听器函数添加到EventTrigger。
- en: ❿ Hide this image/text if there’s no item to display.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ 如果没有要显示的物品，则隐藏此图像/文本。
- en: ⓫ Hide buttons if no item is selected.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ⓫ 如果没有选择物品，则隐藏按钮。
- en: ⓬ Display currently selected item.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ⓬ 显示当前选中的物品。
- en: ⓭ Use button only for health item.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ⓭ 只使用按钮用于健康物品。
- en: ⓮ Function called by mouse click listener
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ⓮ 由鼠标点击监听器调用的函数
- en: ⓯ Refresh the inventory display after making changes.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ⓯ 在做出更改后刷新库存显示。
- en: Whew, that was a long script! With this programmed, it’s time to link everything
    in the interface. The script component on the pop-up object now has the various
    object references, including the two arrays; expand both arrays and set to a length
    of 4 (see figure 12.6). Drag the four images to the icons array, and drag the
    four text labels to the labels array.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 呼，这是一个很长的脚本！有了这个程序，现在是时候将界面中的所有内容链接起来。弹出窗口对象上的脚本组件现在有各种对象引用，包括两个数组；展开两个数组并将长度设置为4（见图12.6）。将四个图像拖到图标数组中，将四个文本标签拖到标签数组中。
- en: '![CH12_F06_Hocking3](../Images/CH12_F06_Hocking3.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![CH12_F06_Hocking3](../Images/CH12_F06_Hocking3.png)'
- en: Figure 12.6 Arrays displayed in the Inspector
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6 检查器中显示的数组
- en: NOTE If you aren’t sure which object was dragged where (they all look the same),
    click the slot in the Inspector to see that object highlighted in the Hierarchy
    view.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果您不确定哪个对象被拖到了哪里（它们看起来都一样），请点击检查器中的槽位，以在层次结构视图中突出显示该对象。
- en: Similarly, slots in the component reference the text label and buttons at the
    bottom of the pop-up. After linking those objects, you’ll add OnClick listeners
    for both buttons. Link these events to the pop-up object, and choose either OnEquip()
    or OnUse() as appropriate.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，组件中的槽位引用弹出窗口底部的文本标签和按钮。在链接这些对象后，您将为两个按钮添加OnClick监听器。将这些事件链接到弹出窗口对象，并选择适当的OnEquip()或OnUse()。
- en: Finally, add an EventTrigger component to all four of the item images. The InventoryPopup
    script modifies this component on each icon, so they better have this component!
    You’ll find EventTrigger under Add Component > Event. (It may be more convenient
    to copy/paste the component by clicking the little gear button in the top corner
    of the component, select Copy Component from one object, and then Paste As New
    on the other.) Add this component but don’t assign event listeners, because that’s
    done in the InventoryPopup code.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将事件触发器组件添加到所有四个物品图像上。InventoryPopup脚本会修改每个图标的该组件，所以它们最好有这个组件！您可以在“添加组件”>“事件”下找到EventTrigger。（通过点击组件右上角的齿轮按钮，复制/粘贴组件可能更方便，从一个对象中选择复制组件，然后在另一个对象上粘贴为新组件。）添加此组件，但不要分配事件监听器，因为那是在InventoryPopup代码中完成的。
- en: That completes the inventory UI! Play the game to watch the inventory pop-up
    respond when you collect items and click buttons. We’re now finished assembling
    parts from previous projects; next I’ll explain how to build a more expansive
    game from this beginning.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了库存用户界面！玩玩游戏，看看当你收集物品和点击按钮时库存弹出窗口如何响应。我们现在已经完成了从以前的项目中组装部件；接下来，我将解释如何从这个起点构建一个更庞大的游戏。
- en: 12.2 Developing the overarching game structure
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.2 开发整体游戏结构
- en: Now that you have a functioning action RPG demo, we’re going to build the overarching
    structure of this game. By that, I mean the overall flow of the game through multiple
    levels and progressing through the game by beating levels. What we got from chapter
    9’s project was a single level, but the road map for this chapter specified three
    levels.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有一个功能齐全的动作角色扮演游戏演示，我们将构建这个游戏的整体结构。我的意思是，游戏通过多个关卡的整体流程，通过击败关卡来推进游戏。我们从第
    9 章的项目中得到了一个单一关卡，但本章的路线图指定了三个关卡。
- en: Doing this will involve decoupling the scene even further from the Managers
    backend, so you’ll broadcast messages about the managers (just as PlayerManager
    broadcasts health updates). Create a new script called StartupEvent (listing 12.15);
    define these events in a separate script because these events go with the reusable
    Managers system, whereas GameEvent is specific to the game.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事将进一步解耦场景和 Managers 后端，因此你需要广播关于经理的消息（就像 PlayerManager 广播健康更新一样）。创建一个名为 StartupEvent
    的新脚本（列表 12.15）；在单独的脚本中定义这些事件，因为这些事件与可重用的 Managers 系统相关，而 GameEvent 是特定于游戏的。
- en: Listing 12.15 The StartupEvent script
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.15 StartupEvent 脚本
- en: '[PRE14]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now it’s time to start adjusting Managers, including broadcasting these new
    events!
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候开始调整经理们了，包括广播这些新事件！
- en: 12.2.1 Controlling mission flow and multiple levels
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.1 控制任务流程和多个关卡
- en: Currently, the project has only one scene, and the Game Managers object is in
    that scene. The problem with that is that every scene will have its own set of
    game managers, whereas you want a single set of game managers shared by all scenes.
    To do that, you’ll create a separate Startup scene that initializes the managers
    and then shares that object with the other scenes of the game.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，项目只有一个场景，游戏经理对象就在那个场景中。问题是每个场景都会有一组自己的游戏经理，而你希望有一个所有场景共享的单个游戏经理集合。为了做到这一点，你将创建一个单独的启动场景，初始化经理，然后与其他游戏场景共享该对象。
- en: We’re also going to need a new manager to handle progress through the game.
    Create a new script called MissionManager.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个新的经理来处理游戏进度。创建一个名为 MissionManager 的新脚本。
- en: Listing 12.16 Creating MissionManager
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.16 创建 MissionManager
- en: '[PRE15]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ Check if last level reached.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 检查是否达到最后一个关卡。
- en: ❷ Unity’s command to load a scene
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ Unity 加载场景的命令
- en: For the most part, nothing unusual is going on in this listing, but note the
    LoadScene() method near the end. Although I mentioned this method before (in chapter
    5), it’s more important now. That’s Unity’s method for loading a scene file; in
    chapter 5, you used it to reload the one scene in the game, but you can load any
    scene by passing in the name of the scene file.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个列表中，大部分内容都很正常，但请注意结尾附近的 LoadScene() 方法。尽管我之前提到过这个方法（在第 5 章中），但现在它更为重要。这是
    Unity 加载场景文件的方法；在第 5 章中，你用它来重新加载游戏中的一个场景，但你可以通过传递场景文件名来加载任何场景。
- en: Attach this script to the Game Managers object in the scene. Also add the new
    component to the Managers script.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 将此脚本附加到场景中的游戏经理对象。同时将新组件添加到经理脚本中。
- en: Listing 12.17 Adding a new component to the Managers script
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.17 向经理脚本添加新组件
- en: '[PRE16]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ Unity’s command to persist an object between scenes
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Unity 在场景间持久化对象的命令
- en: ❷ Startup event broadcast with data related to the event.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 带有与事件相关数据的启动事件广播。
- en: ❸ Startup event broadcast without parameters.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 无参数的启动事件广播。
- en: Most of this code should already be familiar to you (adding MissionManager is
    like adding other managers), but there are two new parts. One is the event that
    sends two integer values; you saw both generic valueless events and messages with
    a single number before, but you can send an arbitrary number of values with the
    same syntax.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的大部分内容你应该已经很熟悉了（添加 MissionManager 就像添加其他经理一样），但有两部分是新的。一个是发送两个整数值的事件；你之前已经看到了无参数的通用事件和只有一个数字的消息，但你可以用相同的语法发送任意数量的值。
- en: The other new bit of code is the DontDestroyOnLoad() method. It’s a method provided
    by Unity for persisting an object between scenes. Normally, all objects in a scene
    are purged when a new scene loads, but by using DontDestroyOnLoad() on an object,
    you ensure that object will still be there in the new scene.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 另一段新代码是 DontDestroyOnLoad() 方法。这是 Unity 提供的一种在场景之间持久化对象的方法。通常，当加载新场景时，场景中的所有对象都会被清除，但通过在对象上使用
    DontDestroyOnLoad()，您可以确保该对象在新场景中仍然存在。
- en: Separate scenes for startup and level
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 分离启动和级别场景
- en: 'Because the Game Managers object will persist in all scenes, you must separate
    the managers from individual levels of the game. In Project view, duplicate the
    scene file (Edit > Duplicate) and then rename the two files appropriately: one
    Startup and the other Level1. Open Level1 and delete the Game Managers object
    (it’ll be provided by Startup). Open Startup and delete everything other than
    Game Managers, Controller, Main Camera, HUD Canvas, and EventSystem. Adjust the
    camera by removing the OrbitCamera component, and changing the Clear Flags menu
    from Skybox to Solid Color. Remove the script components on Controller, and delete
    the UI objects (health label and Inventory Popup) parented to the Canvas.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 由于游戏管理人员对象将在所有场景中持续存在，您必须将管理人员与游戏各个级别分开。在项目视图中，复制场景文件（编辑 > 复制）然后适当地重命名两个文件：一个为
    Startup，另一个为 Level1。打开 Level1 并删除游戏管理人员对象（它将由 Startup 提供）。打开 Startup 并删除除了游戏管理人员、控制器、主摄像机、HUD
    画布和 EventSystem 之外的所有内容。通过移除 OrbitCamera 组件并更改 Clear Flags 菜单从 Skybox 到 Solid
    Color 来调整摄像机。从控制器上移除脚本组件，并删除附加到 Canvas 的 UI 对象（健康标签和库存弹出窗口）。
- en: The UI is currently empty, so create a new slider (see figure 12.7) and then
    turn off its Interactable setting. The Controller object no longer has any script
    components, so create a new StartupController script (listing 12.18) and attach
    that to the Controller object.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当前 UI 是空的，因此创建一个新的滑动条（见图 12.7）然后关闭其交互设置。控制器对象不再有任何脚本组件，因此创建一个新的 StartupController
    脚本（列表 12.18）并将其附加到控制器对象上。
- en: '![CH12_F07_Hocking3](../Images/CH12_F07_Hocking3.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![CH12_F07_Hocking3](../Images/CH12_F07_Hocking3.png)'
- en: Figure 12.7 The Startup scene with everything unnecessary removed
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.7 移除了所有不必要的元素的 Startup 场景
- en: Listing 12.18 The new StartupController script
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.18 新的 StartupController 脚本
- en: '[PRE17]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ Update the slider to show loading progress.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 更新滑动条以显示加载进度。
- en: ❷ Load the next scene after managers have started.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在管理人员开始后加载下一场景。
- en: Next, link the Slider object to the slot in the Inspector. One last thing to
    do in preparation is add the two scenes to Build Settings. Building the app will
    be the topic of the next chapter, so for now choose File > Build Settings to see
    and adjust the list of scenes. Click the Add Open Scenes button to add a scene
    to the list (load both scenes and do this for each).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将滑动条对象链接到检查器中的槽位。在准备阶段要做的最后一件事是将两个场景添加到构建设置中。构建应用程序将是下一章的主题，所以现在选择文件 > 构建设置以查看和调整场景列表。点击添加打开场景按钮将场景添加到列表中（加载两个场景并为每个场景执行此操作）。
- en: NOTE You need to add the scenes to Build Settings so that they can be loaded.
    If you don’t, Unity won’t know what scenes are available. You didn’t need to do
    this in chapter 5 because you weren’t actually switching levels—you were just
    reloading the current scene.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 备注：您需要将场景添加到构建设置中，以便它们可以被加载。如果不这样做，Unity 将不知道有哪些场景可用。您在第五章中不需要这样做，因为您实际上并没有切换级别——您只是重新加载了当前场景。
- en: Now you can launch the game by clicking Play from the Startup scene. The Game
    Managers object will be shared in both scenes.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以通过从 Startup 场景点击播放来启动游戏。游戏管理人员对象将在两个场景中共享。
- en: 'WARNING Because the managers are loaded in the Startup scene, you always need
    to launch the game from that scene. You could remember to always open that scene
    before clicking Play, but this editor script will automatically switch to a set
    scene when you click Play: [https://github.com/jhocking/from-unity-wiki/blob/main/SceneAutoLoader.cs](https://github.com/jhocking/from-unity-wiki/blob/main/SceneAutoLoader.cs).'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：由于管理人员在启动场景中加载，您始终需要从该场景启动游戏。您可能记得在点击播放之前总是打开该场景，但此编辑器脚本将在您点击播放时自动切换到设置的场景：[https://github.com/jhocking/from-unity-wiki/blob/main/SceneAutoLoader.cs](https://github.com/jhocking/from-unity-wiki/blob/main/SceneAutoLoader.cs)。
- en: TIP By default, the lighting system regenerates the lightmaps when the level
    is loaded. But this works only while you are editing the level; lightmaps won’t
    be generated when loading levels while the game is running. As you did in chapter
    10, you can turn off Auto lighting in the lighting window (Window > Rendering
    > Lighting) and then click the button to manually bake lightmaps (remember, don’t
    touch the lighting data that’s created).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：默认情况下，当关卡加载时，照明系统会重新生成光照贴图。但这仅在您正在编辑关卡时有效；当游戏运行时加载关卡时，不会生成光照贴图。就像在第 10 章中做的那样，您可以在照明窗口（窗口
    > 渲染 > 照明）中关闭自动照明，然后点击按钮手动烘焙光照贴图（记住，不要触摸创建的照明数据）。
- en: This structural change handles the sharing of game managers between different
    scenes, but you still don’t have any success or failure conditions within the
    level.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构变化处理了不同场景之间游戏管理器的共享，但你仍然在关卡内没有任何成功或失败条件。
- en: 12.2.2 Completing a level by reaching the exit
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.2 通过达到出口完成关卡
- en: To handle level completion, you’ll put an object in the scene for the player
    to touch, and that object will inform MissionManager when the player reaches the
    objective. This will involve the UI responding to a message about level completion,
    so add another entry to GameEvent.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理关卡完成，您需要在场景中放置一个玩家可以触摸的对象，并且该对象将在玩家达到目标时通知 MissionManager。这将涉及 UI 对关卡完成消息的响应，因此向
    GameEvent 添加另一个条目。
- en: Listing 12.19 Level Complete added to GameEvent
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.19 将“关卡完成”添加到 GameEvent
- en: '[PRE18]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now add a new method to MissionManager to keep track of mission objectives and
    broadcast the new event message.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在向 MissionManager 添加一个新方法，以跟踪任务目标和广播新的事件消息。
- en: Listing 12.20 Objective method in MissionManager
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.20 MissionManager 中的目标方法
- en: '[PRE19]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Adjust the UIController script to respond to that event.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 调整 UIController 脚本以响应该事件。
- en: Listing 12.21 New event listener in UIController
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.21 UIController 中的新事件监听器
- en: '[PRE20]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ Show the message for two seconds and then go to next level.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 显示消息两秒钟后进入下一关卡。
- en: You’ll notice that this listing has a reference to a text label. Open the Level1
    scene to edit it, and create a new UI text object. This label will be a level
    completion message that appears in the middle of the screen. Set this text to
    Width 240, Height 60, Center for both Align and Vertical-align, Vertex Color black,
    and Font Size 22. Type Level Complete! in the text area and then link this text
    object to the levelEnding reference of UIController.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到这个列表有一个对文本标签的引用。打开 Level1 场景进行编辑，并创建一个新的 UI 文本对象。这个标签将是一个显示在屏幕中间的关卡完成消息。将宽度设置为
    240，高度设置为 60，对齐和垂直对齐都设置为居中，顶点颜色设置为黑色，字体大小设置为 22。在文本区域中键入 Level Complete!，然后将此文本对象链接到
    UIController 的 levelEnding 引用。
- en: 'Finally, we’ll create an object that the player touches to complete the level
    (figure 12.8 shows what the objective looks like). This will be similar to collectible
    items: it needs a material and a script, and you’ll make the entire thing a prefab.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将创建一个玩家触摸以完成关卡的对象（图 12.8 展示了目标的外观）。这将与可收集物品类似：它需要一个材质和脚本，您将使整个对象成为一个预制件。
- en: '![CH12_F08_Hocking3](../Images/CH12_F08_Hocking3.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![CH12_F08_Hocking3](../Images/CH12_F08_Hocking3.png)'
- en: Figure 12.8 Objective object that the player touches to complete the level
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.8 玩家触摸以完成关卡的目标对象
- en: Create a cube object at Position 18, 1, 0. Select the Is Trigger option of the
    Box Collider, turn off both Cast and Receive Shadows in Mesh Renderer, and set
    the object to the Ignore Raycast layer. Create a new material called objective;
    make it bright green and set the shader to Unlit > Color for a flat, bright look.
    Next, create the ObjectiveTrigger script and attach that script to the cube object.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在位置 18, 1, 0 处创建一个立方体对象。选择 Box Collider 的“Is Trigger”选项，在 Mesh Renderer 中关闭
    Cast 和 Receive Shadows，并将对象设置为 Ignore Raycast 层。创建一个名为 objective 的新材质；使其呈现亮绿色，并将着色器设置为
    Unlit > Color 以获得平坦、明亮的视觉效果。接下来，创建 ObjectiveTrigger 脚本，并将其附加到立方体对象上。
- en: Listing 12.22 Code for ObjectiveTrigger to put on objective objects
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.22 ObjectiveTrigger 代码，用于放置目标对象
- en: '[PRE21]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ Call the new objective method in MissionManager.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 调用 MissionManager 中的新目标方法。
- en: Drag this object from the Hierarchy into Project view to turn it into a prefab;
    in future levels, you could put the prefab in the scene. Now play the game and
    go reach the objective. The completion message shows when you beat the level.
    Next, let’s have a failure message to show when you lose.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 将此对象从 Hierarchy 拖到 Project 视图中，将其转换为预制件；在未来的关卡中，您可以将预制件放入场景中。现在玩游戏并达到目标。当您通关关卡时，会显示完成消息。接下来，让我们有一个失败消息来显示您失败的情况。
- en: 12.2.3 Losing the level when caught by enemies
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.3 被敌人捕获时失去关卡
- en: 'The failure condition will be when the player runs out of health (because of
    the enemy attacking). First, add another entry in GameEvent:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 失败条件是玩家生命耗尽（因为敌人攻击）。首先，在 GameEvent 中添加另一个条目：
- en: '[PRE22]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now adjust PlayerManager to broadcast this message when the player’s health
    drops to 0.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在调整 PlayerManager，当玩家的生命值降至 0 时广播此消息。
- en: Listing 12.23 Broadcast level failed from PlayerManager
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.23 从 PlayerManager 广播等级失败
- en: '[PRE23]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ Call the update method instead of setting variables directly.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 调用更新方法而不是直接设置变量。
- en: ❷ Reset the player to the initial state.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 重置玩家到初始状态。
- en: Add a method to MissionManager for restarting the level.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 为 MissionManager 添加一个用于重启等级的方法。
- en: Listing 12.24 MissionManager, which can restart the current level
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.24 可以重启当前等级的 MissionManager
- en: '[PRE24]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: With that in place, add another event listener to UIController.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，向 UIController 添加另一个事件监听器。
- en: Listing 12.25 Responding to failed level in UIController
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.25 在 UIController 中响应失败等级
- en: '[PRE25]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ❶ Reuse the same text label, but set a different message.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 重复使用相同的文本标签，但设置不同的消息。
- en: ❷ Restart the current level after a two-second pause.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在两秒暂停后重启当前等级。
- en: Play the game and let the enemy shoot you several times; the level failure message
    will appear. Great job—the player can now complete and fail levels! Building off
    that, the game must keep track of the player’s progress.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 玩游戏并让敌人射击你几次；等级失败消息将出现。干得好——玩家现在可以完成和失败等级了！在此基础上，游戏必须跟踪玩家的进度。
- en: 12.3 Handling the player’s progression through the game
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.3 处理玩家在游戏中的进度
- en: 'Right now, the individual level operates independently, without any relation
    to the overall game. You’ll add two things that will make progress through the
    game feel more complete: saving the player’s progress and detecting when the game
    (not just the level) is complete.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，单个等级独立运行，没有任何与整体游戏的关系。你将添加两个使游戏进度感觉更完整的东西：保存玩家的进度和检测游戏（不仅仅是等级）是否完成。
- en: 12.3.1 Saving and loading the player’s progress
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3.1 保存和加载玩家的进度
- en: Saving and loading the game is an important part of most games. Unity and Mono
    provide I/O functionality that you can use for this purpose. Before you can start
    using that, though, you must add UpdateData() for both MissionManager and InventoryManager.
    That method will work as it does in PlayerManager and will enable code outside
    the manager to update data within the manager. Listing 12.26 and listing 12.27
    show the changed managers.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 保存和加载游戏是大多数游戏的重要部分。Unity 和 Mono 提供了可用于此目的的 I/O 功能。不过，在开始使用之前，你必须为 MissionManager
    和 InventoryManager 添加 UpdateData() 方法。该方法将像在 PlayerManager 中那样工作，并允许管理器外部的代码更新管理器内的数据。列表
    12.26 和列表 12.27 展示了更改后的管理者。
- en: Listing 12.26 UpdateData() method in MissionManager
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.26 MissionManager 中的 UpdateData() 方法
- en: '[PRE26]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ Modify this line by using the new method.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 通过使用新方法修改此行。
- en: Listing 12.27 UpdateData() method in InventoryManager
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.27 InventoryManager 中的 UpdateData() 方法
- en: '[PRE27]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ❶ Initialize an empty list.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 初始化一个空列表。
- en: ❷ Need getter for save game code to access the data.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 需要获取保存游戏代码的访问数据的方法。
- en: Now that the various managers all have UpdateData() methods, the data can be
    saved from a new code module. Saving the data will involve a procedure referred
    to as *serializing* the data.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在各个管理者都拥有了 UpdateData() 方法，数据可以从新的代码模块中保存。保存数据将涉及一个称为 *序列化* 数据的过程。
- en: DEFINITION *Serialize* means to encode a batch of data into a form that can
    be stored.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *序列化* 意味着将一批数据编码成可以存储的形式。
- en: You’ll save the game as binary data, but note that C# is also fully capable
    of saving text files. For example, the JSON strings you worked with in chapter
    10 were data serialized as text. Previous chapters used PlayerPrefs, but in this
    project, you’re going to save a local file; PlayerPrefs is intended to save only
    a handful of values, like settings, not an entire game. Create the DataManager
    script (listing 12.28).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 你将以二进制数据保存游戏，但请注意，C# 也完全能够保存文本文件。例如，在第 10 章中你处理过的 JSON 字符串就是作为文本序列化的数据。前面的章节使用了
    PlayerPrefs，但在这个项目中，你将保存本地文件；PlayerPrefs 仅用于保存少量值，如设置，而不是整个游戏。创建 DataManager 脚本（列表
    12.28）。
- en: WARNING You can’t directly access the filesystem in a web game. This is a security
    feature of web browsers. To save data for web games, you may need to write a plugin
    as described in the next chapter, or post the data to your server.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 警告 在网页游戏中无法直接访问文件系统。这是网页浏览器的安全特性。为了保存网页游戏的数据，你可能需要编写下一章中描述的插件，或者将数据发送到你的服务器。
- en: Listing 12.28 New script for DataManager
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.28 DataManager 的新脚本
- en: '[PRE28]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ❶ Construct full path to the game.dat file.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 构建游戏.dat 文件的全路径。
- en: ❷ Dictionary that will be serialized
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将要序列化的字典
- en: ❸ Create a file at the file path.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在文件路径创建一个文件。
- en: ❹ Serialize the Dictionary as contents of the created file.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将字典序列化为创建的文件的内容。
- en: ❺ Continue to load only if the file exists.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 只有在文件存在的情况下才继续加载。
- en: ❻ Dictionary to put loaded data in
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 将加载的数据放入的字典
- en: ❼ Update managers with deserialized data.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 使用反序列化数据更新管理器。
- en: During Startup(), the full file path is constructed using Application.persistentDataPath,
    a location Unity provides to store data in. The exact file path differs on different
    platforms, but Unity abstracts it behind this static variable. The File.Create()
    method will create a binary file; call File.CreateText() if you want a text file.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Startup() 中，使用 Application.persistentDataPath 构建完整的文件路径，这是 Unity 提供用于存储数据的位置。确切的文件路径在不同平台上有所不同，但
    Unity 通过这个静态变量在后面抽象化它。File.Create() 方法将创建一个二进制文件；如果你想创建一个文本文件，请调用 File.CreateText()。
- en: WARNING When constructing file paths, the path separator is different on different
    computer platforms. C# has Path.DirectorySeparatorChar to account for this.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：在构建文件路径时，不同计算机平台上的路径分隔符不同。C# 有 Path.DirectorySeparatorChar 来处理这个问题。
- en: Open the Startup scene to find Game Managers. Add the DataManager script component
    to the Game Managers object, and then add the new manager to the Managers script.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 Startup 场景以找到游戏管理器。将 DataManager 脚本组件添加到游戏管理器对象中，然后将新管理器添加到 Managers 脚本中。
- en: Listing 12.29 Adding DataManager to Managers
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.29 将 DataManager 添加到管理器中
- en: '[PRE29]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ❶ Managers start in this order.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 管理器以这个顺序启动。
- en: WARNING Because DataManager uses other managers (to update them), you should
    make sure that the other managers appear earlier in the startup sequence.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：因为 DataManager 使用其他管理器（以更新它们），你应该确保其他管理器在启动序列中出现的顺序更靠前。
- en: Finally, in Level1, add buttons to use functions in DataManager (figure 12.9
    shows the buttons). Create two buttons parented to the HUD Canvas (not in the
    Inventory pop-up). Call them (set the attached text objects) Save Game and Load
    Game, set the Anchor button to bottom right, and position them at -100,65, and
    -100,30.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 Level1 中，添加按钮以使用 DataManager 中的函数（如图 12.9 所示的按钮）。创建两个按钮，它们是 HUD Canvas
    的父级（不在库存弹出窗口中）。将它们命名为（设置附加的文本对象）Save Game 和 Load Game，将锚点按钮设置为右下角，并将它们定位在 -100,65
    和 -100,30。
- en: '![CH12_F09_Hocking3](../Images/CH12_F09_Hocking3.png)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![CH12_F09_Hocking3](../Images/CH12_F09_Hocking3.png)'
- en: Figure 12.9 Save and Load buttons on the bottom right of the screen
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.9 屏幕右下角的保存和加载按钮
- en: These buttons will link to functions in UIController, so write those methods.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这些按钮将链接到 UIController 中的函数，因此需要编写这些方法。
- en: Listing 12.30 Save and load methods in UIController
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.30 UIController 中的保存和加载方法
- en: '[PRE30]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Link these functions to OnClick listeners in the buttons (add a listing in the
    OnClick setting, drag in the UIController object, and select functions from the
    menu). Now play the game, pick up a few items, use a health pack to increase your
    health, and then save the game. Restart the game and check your inventory to verify
    that it’s empty. Click Load; you now have the health and items you had when you
    saved the game!
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些函数链接到按钮的 OnClick 监听器（在 OnClick 设置中添加一个列表，拖入 UIController 对象，并从菜单中选择函数）。现在玩游戏，捡起一些物品，使用健康包来增加你的健康，然后保存游戏。重新启动游戏并检查你的库存以验证它是否为空。点击加载；你现在有了你保存游戏时拥有的健康和物品！
- en: 12.3.2 Beating the game by completing three levels
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3.2 通过完成三个关卡来击败游戏
- en: 'As implied by our saving of the player’s progress, this game can have multiple
    levels, not just the one level you’ve been testing. To properly handle multiple
    levels, the game must detect the completion of not only a single level, but also
    the entire game. First, add yet another GameEvent:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所保存的玩家进度所示，这个游戏可以有多个关卡，而不仅仅是测试的那个关卡。为了正确处理多个关卡，游戏必须检测到单个关卡以及整个游戏的完成。首先，添加另一个
    GameEvent：
- en: '[PRE31]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now modify MissionManager to broadcast that message after the last level.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 现在修改 MissionManager，在最后一关之后广播该消息。
- en: Listing 12.31 Broadcasting Game Complete from MissionManager
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.31 从 MissionManager 广播游戏完成
- en: '[PRE32]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Respond to that message in UIController.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在 UIController 中响应该消息。
- en: Listing 12.32 Adding an event listener to UIController
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.32 向 UIController 添加事件监听器
- en: '[PRE33]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Try completing the level to see what happens: move the player to the level
    objective to complete the level as before. You’ll first see the Level Complete
    message, but after a couple of seconds, it’ll change to a message about completing
    the game.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试完成关卡以查看发生了什么：将玩家移动到关卡目标以完成关卡，就像以前一样。你首先会看到关卡完成的提示，但几秒钟后，它会变成完成游戏的提示。
- en: Adding more levels
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 添加更多级别
- en: At this point, you can add an arbitrary number of additional levels, and MissionManager
    will watch for the last level. The final thing you’ll do in this chapter is add
    a few more levels to the project to demonstrate the game progressing through multiple
    levels.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可以添加任意数量的额外级别，并且MissionManager将监视最后一个级别。在这一章中，你将做的最后一件事是为项目添加几个更多级别，以展示游戏通过多个级别的发展。
- en: 'Duplicate the Level1 scene file twice, make sure the names are Level2 and Level3,
    and add the new levels to Build Settings (so that they can be loaded during gameplay;
    remember to generate the lighting). Modify each scene so that you can tell the
    difference between levels; feel free to rearrange most of the scene, but you must
    keep several essential game elements: the player object that’s tagged Player,
    the floor object set to the Ground layer, and the objective object, Controller,
    HUD Canvas, and EventSystem.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 将Level1场景文件复制两次，确保名称为Level2和Level3，并将新级别添加到构建设置中（以便在游戏过程中加载；记得生成光照）。修改每个场景，以便你能区分级别；你可以自由地重新排列场景的大部分内容，但你必须保留几个基本游戏元素：标记为Player的玩家对象、设置为Ground层的地板对象以及目标对象、Controller、HUD画布和EventSystem。
- en: Architecting a shared HUD
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 构建共享的HUD
- en: The UI was duplicated along with the rest of the level, resulting in three identical
    UI setups. That’s fine for this small learning project but would be unwieldy for
    a polished game with many levels. Instead, you should move the UI to a central
    place that’s shared among the levels.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: UI与级别一起被复制，导致有三个相同的UI设置。这对于这个小型学习项目来说是可以的，但对于具有许多级别的精炼游戏来说可能会很麻烦。相反，你应该将UI移动到一个中央位置，该位置在级别之间共享。
- en: Much as you did with the Startup scene, you could put the UI (both HUD Canvas
    and EventSystem) in a separate scene to load in addition to the levels. Unlike
    the Startup scene, however, you will probably want to control the loading of the
    UI more deliberately than simply using the DontDestroyOnLoad() function. That
    function causes objects to persist in all scenes, but the UI is not identical
    in every scene of a game. For example, a game’s starting menu scene usually has
    a different UI than all the levels.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你在启动场景中做的那样，你可以将UI（包括HUD画布和EventSystem）放在一个单独的场景中，除了加载级别外还要加载。然而，与启动场景不同的是，你可能希望比简单地使用DontDestroyOnLoad()函数更细致地控制UI的加载。该函数会导致对象在所有场景中持续存在，但游戏的每个场景中的UI并不相同。例如，游戏的起始菜单场景通常与所有级别的UI不同。
- en: Unity solves this problem with the Additive scene loading mode. Scenes loaded
    in this mode are added on to what’s already loaded, rather than replacing it.
    For example, modifying this project’s code to use a shared UI scene would simply
    entail adding a line of code like SceneManager.LoadScene( "HUDScene", LoadSceneMode.Additive);
    immediately after every standard LoadScene() call in MissionManager. Read the
    documentation about this optional scene loading mode at [http://mng.bz/v4GJ](http://mng.bz/v4GJ).
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: Unity使用增量场景加载模式来解决此问题。以这种方式加载的场景是添加到已加载的内容上，而不是替换它。例如，修改此项目的代码以使用共享UI场景，只需在MissionManager中的每个标准LoadScene()调用后立即添加一行代码如SceneManager.LoadScene("HUDScene",
    LoadSceneMode.Additive)；即可。关于这种可选场景加载模式的文档，请参阅[http://mng.bz/v4GJ](http://mng.bz/v4GJ)。
- en: You also need to adjust MissionManager to load the new levels. Change maxLevel
    to 3 by changing the UpdateData(0, 1) call to UpdateData(0, 3). Now play the game
    and you’ll start on Level1 initially; reach the level objective and you’ll move
    on to the next level! Incidentally, you can also save on a later level to see
    that the game will restore that progress.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要调整MissionManager以加载新级别。通过将UpdateData(0, 1)调用更改为UpdateData(0, 3)来将maxLevel更改为3。现在玩游戏，你最初将开始于Level1；达到级别目标后，你将进入下一个级别！顺便说一句，你还可以在后面的级别中保存，以查看游戏将恢复该进度。
- en: 'You now know how to create a full game with multiple levels. The obvious next
    task is the final chapter: getting your game into the hands of players.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经知道了如何创建一个包含多个级别的完整游戏。接下来的明显任务就是最后一章：让你的游戏进入玩家的手中。
- en: 'Exercise: Integrating audio into the full game'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：将音频集成到完整游戏中
- en: 'Chapter 11 was all about implementing audio in Unity. I didn’t explain how
    to integrate that into this chapter’s project, but at this point you should understand
    how. I encourage you to practice your skills by integrating the audio functionality
    from the previous chapter into this chapter’s project. Here’s a hint: change the
    key to toggle the audio settings pop-up so that it doesn’t interfere with the
    inventory pop-up.'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 第11章全部是关于在 Unity 中实现音频。我没有解释如何将这部分内容整合到本章的项目中，但到现在你应该已经理解了如何操作。我鼓励你通过将上一章的音频功能整合到本章的项目中来练习你的技能。这里有一个提示：更改键来切换音频设置弹出窗口，以免干扰库存弹出窗口。
- en: Summary
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Unity makes it easy to repurpose assets and code from a project in a different
    game genre.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity 使得在不同游戏类型的项目中重用资产和代码变得容易。
- en: Another great use for raycasting is to determine where in the scene the player
    is clicking.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个使用射线投射的绝佳用途是确定玩家在场景中的点击位置。
- en: Unity has simple methods for both loading levels and persisting certain objects
    between levels.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity 提供了简单的方法来加载关卡并在关卡之间持久化某些对象。
- en: You progress through levels in response to various events within the game.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你根据游戏中的各种事件来通过关卡。
- en: You can use the I/O methods that come with C# to store data at Application .persistentDataPath.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 C# 中的 I/O 方法在 Application .persistentDataPath 存储数据。
