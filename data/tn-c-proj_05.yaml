- en: 5 Encoding and decoding
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 编码和解码
- en: It’s easy to confuse the topic of encoding and decoding with encryption. These
    are similar procedures, but the purpose of encryption is to conceal and safeguard
    information. Encoding is done for transportation of information that may be too
    complex for the medium or to translate between different systems or for other
    innocuous purposes. Regardless, the process of encoding and decoding has the potential
    to be action packed and full of intrigue.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 容易将编码和解码的主题与加密混淆。这些是类似的过程，但加密的目的是隐藏和保护信息。编码是为了传输可能对介质过于复杂的信息，或在不同系统之间进行转换，或其他无害的目的。无论如何，编码和解码的过程具有充满动作和神秘性的潜力。
- en: Well, perhaps not.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，也许不是。
- en: 'Still, back in the early days of computer telecommunications, encoding and
    decoding were regular occurrences. I remember transferring my first program over
    a modem: 16 kilobytes that took 16 minutes to transfer. That program consisted
    of binary data, but it was transported as plain text. It required encoding on
    the sending end and decoding on the receiving end. Such magic happens today as
    well, though probably much faster.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在计算机电信的早期，编码和解码是常规操作。我记得通过调制解调器传输我的第一个程序：16千字节，传输耗时16分钟。该程序由二进制数据组成，但它以纯文本的形式传输。它需要在发送端进行编码，在接收端进行解码。今天仍然会发生这样的魔法，尽管可能要快得多。
- en: 'To explore the concept of encoding and decoding, regardless of the thrills
    and dangers, you must:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 要探索编码和解码的概念，无论其刺激和危险，你必须：
- en: Appreciate how characters are represented on computers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 欣赏字符在计算机上的表示
- en: Learn various ASCII encoding tricks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习各种ASCII编码技巧
- en: Play with character representation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩弄字符表示
- en: Translate plain text into hex bytes for data transfer
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将纯文本转换为十六进制字节进行数据传输
- en: Reverse translate hex bytes back into text (or data)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将十六进制字节反向翻译回文本（或数据）
- en: Improve encoding techniques by adding checksums
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过添加校验和来改进编码技术
- en: Explore the URL encoding method
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索URL编码方法
- en: None of these items is dreary, not like that book on 100 fun and legal home
    projects you can do with an ironing board. But if you want to know more about
    encryption, refer to chapter 4.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这些项目都不枯燥，不像那本关于用熨斗可以做的100个有趣且合法的家庭项目的书。但如果你想了解更多关于加密的信息，请参阅第4章。
- en: 5.1 The concept of plain text
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 纯文本的概念
- en: The computer doesn’t know text. The *char* data type is merely a tiny integer,
    ranging in value from 0 through 255 (*unsigned*) or -128 to 127 (*signed*). It’s
    only the presentation of the *char* data type that makes it look like a character.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机不知道文本。*char*数据类型仅仅是一个很小的整数，其值从0到255（*无符号*）或-128到127（*有符号*）。只有*char*数据类型的表示才使其看起来像字符。
- en: In C, the *putchar()* function outputs a value as a character. The function’s
    *man* page declares the function’s argument as an integer, though it appears on
    the standard output device as a character.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在C语言中，*putchar()*函数将一个值作为字符输出。该函数的*man*页面声明该函数的参数为一个整数，尽管它作为字符出现在标准输出设备上。
- en: The *printf()* function is a bit more understanding of characters. It outputs
    a *char* data type as a character but only when the %c placeholder is used in
    the format string. If you substitute %d, the decimal integer output placeholder,
    the data is output as a number.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*printf()*函数对字符的理解更深入一些。它将*char*数据类型作为字符输出，但仅当在格式字符串中使用%c占位符时。如果你用%d替换，即十进制整数输出占位符，数据将作为数字输出。'
- en: But what thing is output? How does the computer know to match a specific value
    with a given character? The answer comes in the form of the venerable digital
    acronym, ASCII.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 但输出的是什么东西？计算机如何知道将特定的值与给定的字符匹配？答案是古老的数字缩写词ASCII。
- en: 5.1.1 Understanding ASCII
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.1 理解ASCII
- en: 'It’s important to note that ASCII is pronounced “ass-key.” That’s right: ass
    and key. Titter all you like, but if you say, “ask two,” everyone will know you’re
    a dork.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意ASCII的发音是“ass-key”。没错：ass和key。尽管你可以嘲笑，但如果你说“ask two”，每个人都会知道你是个傻瓜。
- en: It’s unimportant to note that ASCII stands for the American Standard Code for
    Information Interchange. Yes, it’s a standard devised by people who sit around
    all day having fun creating standards. And though the standard was developed in
    the early 1960s, it wasn’t until the mid-1980s that pretty much every computer
    on the planet began using ASCII codes consistently.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 不必注意，ASCII代表美国信息交换标准代码。是的，这是一个由整天坐着创造标准的人制定的标准。尽管该标准在20世纪60年代初开发，但直到20世纪80年代中期，几乎地球上的每台计算机才开始一致使用ASCII代码。
- en: By adopting the ASCII standard for assigning codes to characters, computers
    can exchange basic information without requiring any translation. Before it was
    widely adopted in the late 1970s, computers had to run translation programs to
    get even a text file to read properly from one system to the next. But today,
    a text file on your overpriced Macintosh is easily readable on my cheap-o Linux
    box that my friend Don built in the back of his shop for $499.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通过采用ASCII标准为字符分配代码，计算机可以在无需任何翻译的情况下交换基本信息。在1970年代末得到广泛采用之前，计算机必须运行翻译程序，才能从一个系统正确地读取甚至一个文本文件到下一个系统。但如今，你那昂贵的Macintosh上的文本文件在我的便宜Linux盒子上也能轻松阅读，我的朋友Don在他的商店后面用499美元组装了这个盒子。
- en: The way ASCII works is to assign codes, integer values, to common characters
    and symbols. This translation originated from the telegraph era, where the codes
    had to be consistent for a message to be translated—encoded and decoded—lest the
    Hole-in-the-Wall Gang rob the 12:10 yet again because old Hamer McCleary was taking
    a nap at the Belle Fourche station.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ASCII的工作方式是为常见的字符和符号分配代码，即整数值。这种翻译起源于电报时代，当时代码必须一致，以便消息能够被翻译——编码和解码——否则“洞口帮”会再次抢劫12:10，因为老Hamer
    McCleary在Belle Fourche车站打瞌睡。
- en: ASCII codes are devised in a clever pattern, which is amazing for any group
    of humans to produce. The pattern allows for all sorts of fun and creative things
    to happen, as covered in section 5.1.4\. Figure 5.1 lists the ASCII code table
    in its common, four “stick” presentation. See whether you can spy any of the patterns.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ASCII代码的设计巧妙，这对任何一组人类来说都是惊人的。这种模式允许发生各种有趣和创造性的事情，如第5.1.4节所述。图5.1列出了ASCII代码表，以常见的四“棒”形式展示。看看你是否能发现任何模式。
- en: '![05-01](Images/05-01.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![05-01](Images/05-01.png)'
- en: Figure 5.1 The ASCII table showing decimal, octal, hexadecimal, and character
    values
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 显示十进制、八进制、十六进制和字符值的ASCII表
- en: From figure 5.1, you see that ASCII codes range from 0 through 127\. These are
    binary values 000-0000 through 111-1111\. For the C language *char* data type,
    these values are all positive whether the variable is *signed* or *unsigned*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 从图5.1中，你可以看到ASCII代码的范围是从0到127。这些是二进制值000-0000到111-1111。对于C语言的*char*数据类型，这些值都是正数，无论变量是*signed*还是*unsigned*。
- en: Each of the four columns, or “sticks,” in the ASCII table (refer to figure 5.1)
    represents a different category of character types. Again, the codes are organized,
    probably due to some education from earlier abominable computer character codes
    that have since been taken out, placed in a dumpster, and set on fire with a jet
    engine.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ASCII表中的四列，或“棒”，代表不同类型的字符类别。再次强调，代码是有组织的，这可能是由于早期那些令人厌恶的计算机字符代码的一些教育，这些代码后来被扔进垃圾桶，并用喷气发动机烧毁。
- en: The first stick consists of nonprinting control codes, which is why its output
    looks so dull in figure 5.1\. Read more about the control codes in section 5.1.2.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 第一根棒包含非打印控制代码，这就是为什么它在图5.1中的输出看起来如此单调。关于控制代码的更多信息，请参阅第5.1.2节。
- en: 'Characters in the second stick in the ASCII table were selected for sorting
    purposes. The first few characters echo those on a teletype machine, the shifted
    number keys. These still hold true today for the most part: Shift+1 is the ! (exclamation
    point), Shift+3 is the # (hash), and so on.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ASCII表第二根棒中的字符是为了排序目的而选择的。前几个字符与电传打字机上的字符相同，即转换后的数字键。这些在今天的大部分情况下仍然适用：Shift+1是感叹号(!)，Shift+3是井号(#)，等等。
- en: The third stick contains uppercase letters, plus a few symbols.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 第三根棒包含大写字母，还有一些符号。
- en: The fourth stick contains lowercase letters, plus the rest of the symbols.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 第四根棒包含小写字母，以及剩余的符号。
- en: Miracles and magic surrounding the ASCII table and these codes are covered in
    the next few sections.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 关于ASCII表和这些代码周围的奇迹和魔法将在接下来的几节中介绍。
- en: Exercise 5.1
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 练习5.1
- en: Having an ASCII table handy is vital to any programmer. Rather than sell you
    my handsome ASCII wall chart on Etsy, I decided that you must code your own ASCII
    table. Make the output appear exactly as shown in figure 5.1—which happens to
    be the output from my own ASCII program and looks like the wall chart. I often
    run my ASCII program as a reference because such information is useful and a program
    is a quick way to keep it handy, though I’m not making any money on Etsy.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个ASCII表对任何程序员来说都是至关重要的。与其在Etsy上卖我那漂亮的ASCII墙图，我决定你必须自己编写ASCII表。让输出看起来与图5.1中所示完全一致——这恰好是我自己的ASCII程序输出的结果，看起来就像墙图。我经常运行我的ASCII程序作为参考，因为这样的信息很有用，而程序是一种快速保存这些信息的方法，尽管我在Etsy上没有赚钱。
- en: The source code for my solution to this exercise is found in this book’s online
    repository as asciitable01.c. But please try creating your own before you just
    ape everything that I did.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我对这个练习的解决方案的源代码可以在本书的在线仓库中找到，文件名为asciitable01.c。但在你盲目模仿我所做的一切之前，请先尝试自己创建一个。
- en: 5.1.2 Exploring the control codes
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.2 探索控制码
- en: I find the first stick of ASCII codes to be the most interesting, from both
    a historical and hilarious perspective. The control code names are adorable! “End
    of Text”? Try using that one in a meeting sometime, but just say “Control C” instead.
    Some people might get it.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现ASCII码的第一组是最有趣的，从历史和幽默的角度来看都是如此。控制码的名字真是可爱！“文本结束”？试着在会议上用这个，但最好说“控制C”，这样一些人可能就会明白了。
- en: “End of Text” is the official name of the Ctrl+C control code, ASCII code 3\.
    Table 5.1 lists the details. Some of the codes or their keyboard equivalents might
    be familiar to you.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: “文本结束”是Ctrl+C控制码的官方名称，ASCII码3。表5.1列出了详细信息。其中一些代码或它们的键盘等效可能对你来说很熟悉。
- en: Table 5.1 ASCII control codes
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.1 ASCII控制码
- en: '| Decimal | Octal | Hex | Name | Ctrl | Esc | Definition |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 十进制 | 八进制 | 十六进制 | 名称 | Ctrl | Esc | 定义 |'
- en: '| 0 | 0 | 00 | NULL | ^@ | \0 | Null character |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 00 | NULL | ^@ | \0 | 空字符 |'
- en: '| 1 | 1 | 01 | SOH | ^A |  | Start of heading |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 01 | SOH | ^A |  | 文件头开始 |'
- en: '| 2 | 2 | 02 | STX | ^B |  | Start of text |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 2 | 02 | STX | ^B |  | 文本开始 |'
- en: '| 3 | 3 | 03 | ETX | ^C |  | End of text |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 3 | 03 | ETX | ^C |  | 文本结束 |'
- en: '| 4 | 4 | 04 | EOT | ^D |  | End of transmission |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 4 | 04 | EOT | ^D |  | 传输结束 |'
- en: '| 5 | 5 | 05 | ENQ | ^E |  | Enquiry, “Who is?” |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 5 | 05 | ENQ | ^E |  | 询问，“谁？” |'
- en: '| 6 | 6 | 06 | ACK | ^F |  | Acknowledgment |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 6 | 06 | ACK | ^F |  | 确认 |'
- en: '| 7 | 7 | 07 | BEL | ^G | \a | Bell |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 7 | 07 | BEL | ^G | \a | 铃 |'
- en: '| 8 | 10 | 08 | BS | ^H | \b | Backspace |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 10 | 08 | BS | ^H | \b | 退格 |'
- en: '| 9 | 11 | 09 | HT | ^I | \t | Horizontal tab |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 11 | 09 | HT | ^I | \t | 水平制表符 |'
- en: '| 10 | 12 | 0A | LF | ^J | \n | Line feed |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 12 | 0A | LF | ^J | \n | 换行 |'
- en: '| 11 | 13 | 0B | VT | ^K | \v | Vertical tab |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 11 | 13 | 0B | VT | ^K | \v | 垂直制表符 |'
- en: '| 12 | 14 | 0C | FF | ^L | \f | Form feed |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 12 | 14 | 0C | FF | ^L | \f | 表格馈送 |'
- en: '| 13 | 15 | 0D | CR | ^M | \r | Carriage return |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 13 | 15 | 0D | CR | ^M | \r | 回车 |'
- en: '| 14 | 16 | 0E | SO | ^N |  | Shift out |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 14 | 16 | 0E | SO | ^N |  | 位移输出 |'
- en: '| 15 | 17 | 0F | SI | ^O |  | Shift in |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 15 | 17 | 0F | SI | ^O |  | 位移输入 |'
- en: '| 16 | 20 | 10 | DLE | ^P |  | Data link escape |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 16 | 20 | 10 | DLE | ^P |  | 数据链路转义 |'
- en: '| 17 | 21 | 11 | DC1 | ^Q |  | Device control one, XON |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 17 | 21 | 11 | DC1 | ^Q |  | 设备控制一，XON |'
- en: '| 18 | 22 | 12 | DC2 | ^R |  | Device control two |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 18 | 22 | 12 | DC2 | ^R |  | 设备控制二 |'
- en: '| 19 | 23 | 13 | DC3 | ^S |  | Device control three, XOFF |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 19 | 23 | 13 | DC3 | ^S |  | 设备控制三，XOFF |'
- en: '| 20 | 24 | 14 | DC4 | ^T |  | Device control four |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 20 | 24 | 14 | DC4 | ^T |  | 设备控制四 |'
- en: '| 21 | 25 | 15 | NAK | ^U |  | Negative acknowledgment |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 21 | 25 | 15 | NAK | ^U |  | 负确认 |'
- en: '| 22 | 26 | 16 | SYN | ^V |  | Synchronous idle |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 22 | 26 | 16 | SYN | ^V |  | 同步空闲 |'
- en: '| 23 | 27 | 17 | ETB | ^W |  | End transmission block |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 23 | 27 | 17 | ETB | ^W |  | 传输块结束 |'
- en: '| 24 | 30 | 18 | CAN | ^X |  | Cancel |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 24 | 30 | 18 | CAN | ^X |  | 取消 |'
- en: '| 25 | 31 | 19 | EM | ^Y |  | End of medium |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 25 | 31 | 19 | EM | ^Y |  | 媒体结束 |'
- en: '| 26 | 32 | 1A | SUB | ^Z |  | Substitute |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 26 | 32 | 1A | SUB | ^Z |  | 替换 |'
- en: '| 27 | 33 | 1B | ESC | ^[ | \e | Escape |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 27 | 33 | 1B | ESC | ^[ | \e | 转义 |'
- en: '| 28 | 34 | 1C | FS | ^\ |  | File separator |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 28 | 34 | 1C | FS | ^\ |  | 文件分隔符 |'
- en: '| 29 | 35 | 1D | GS | ^] |  | Group separator |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 29 | 35 | 1D | GS | ^] |  | 组分隔符 |'
- en: '| 30 | 36 | 1E | RS | ^^ |  | Record separator |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 30 | 36 | 1E | RS | ^^ |  | 记录分隔符 |'
- en: '| 31 | 37 | 1F | US | ^_ |  | Unit separator |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 31 | 37 | 1F | US | ^_ |  | 单位分隔符 |'
- en: 'Table 5.1 lists decimal, octal (base 8), and hexadecimal values for each ASCII
    code. The Name column shows the ancient teletype name, the code’s original and
    forgotten purpose. Still, some of these control codes are used today: the computer’s
    beep remains control code 7, the “bell,” keyboard equivalent Ctrl+G and escape
    sequence \a (for alert or alarm).'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.1列出了每个ASCII码的十进制、八进制（基8）和十六进制值。名称列显示了古老的电传打字机名称，以及代码的原始和被遗忘的用途。尽管如此，一些控制码至今仍在使用：计算机的蜂鸣声仍然是控制码7，即“铃”，键盘等效Ctrl+G和转义序列\a（用于警报或警报）。
- en: The Ctrl column shows the control key combinations used in the terminal window.
    Modern descriptions use the word *Ctrl* for control, though the grizzled, sandal-wearing
    Unix coders of yore prefer the caret character, ^. This expression explains why
    pressing Ctrl+D as the Linux EOF character outputs ^D in a terminal window. And
    this character’s original name is “End of Transmission,” which makes sense. (Don’t
    press Ctrl+D just to see the ^D character appear; doing so closes the terminal
    window.)
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Ctrl列显示了在终端窗口中使用的控制键组合。现代描述使用单词*Ctrl*来表示控制，尽管过去的灰白头发、穿着凉鞋的Unix程序员更喜欢使用撇号字符，^。这个表达式解释了为什么按Ctrl+D作为Linux的EOF字符会在终端窗口中输出^D，这个字符的原始名称是“传输结束”，这是有道理的。（不要只是为了看到^D字符而按Ctrl+D；这样做会关闭终端窗口。）
- en: 'Some of the control key shortcuts map directly to other keys on the keyboard,
    primarily for use in a terminal window. For example, Ctrl+M is the Enter/Return
    key: pressing Ctrl+M is the same as pressing the Enter key. Other control keys
    mapped include:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一些控制键快捷方式直接映射到键盘上的其他键，主要用于终端窗口。例如，Ctrl+M是回车/换行键：按下Ctrl+M与按下回车键相同。其他映射的控制键包括：
- en: Ctrl+I to Tab
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ctrl+I到制表键
- en: Ctrl+H to Backspace
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ctrl+H到退格键
- en: Ctrl+[ to Esc
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ctrl+[到Esc
- en: These shortcuts may not work in all circumstances, but table 5.1 shows how they’re
    mapped.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这些快捷方式可能并不适用于所有情况，但表5.1展示了它们是如何映射的。
- en: The Esc column in table 5.1 lists the C escape character equivalent for some
    of the common control codes. Remember, any code can be specified as an escape
    character sequence in C if you use the format \xnn where *nn* is the character’s
    ASCII code in hexadecimal.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.1中的Esc列列出了某些常见控制代码的C转义字符等效。记住，如果你使用格式\xnn（其中*nn*是字符的十六进制ASCII码），任何代码都可以在C中被指定为转义字符序列。
- en: Many of the control keys have lost their purpose in a modern computer. Back
    in the teletype days—from which the current terminal window in Linux has its roots—they
    were significant. In fact, the Ctrl+S/Ctrl+Q (XON, XOFF) keys still work to pause
    and resume a scrolling display of text. It’s just that modern terminals display
    text so rapidly that using these keys today is pointless.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 许多控制键在现代计算机中已经失去了它们的作用。回顾电传打字机时代——Linux当前终端窗口的根源所在——它们曾经是重要的。事实上，Ctrl+S/Ctrl+Q（XON,
    XOFF）键仍然可以用来暂停和恢复文本的滚动显示。只是现代终端显示文本的速度如此之快，以至于现在使用这些键已经没有意义了。
- en: '*Be careful* when outputting a control character in your code. Some of them
    have predictable functions, specifically those in the Esc column in table 5.1\.
    These escape sequences are useful in C. But sending a weirdo control code to standard
    output can potentially mess up the display. For example, on some terminals, outputting
    ^L (code 12, Form Feed) clears the display. When sent to a printer—even a modern
    printer—^L ejects a sheet of paper.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*小心*在代码中输出控制字符。其中一些具有可预测的功能，特别是表5.1中的Esc列中的那些。这些转义序列在C中很有用。但向标准输出发送奇怪的控制代码可能会损坏显示。例如，在某些终端上，输出^L（代码12，换页）会清除显示。当发送到打印机——即使是现代打印机——^L会弹出一张纸。'
- en: As a tip—because I know someday you’re going to try outputting a control code
    on purpose or perhaps accidentally—if a control code whacks out the terminal display,
    issue the *reset* command. Type **reset** and press Enter, and the terminal attempts
    to recover itself from however you messed it up.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提示——因为我知道有一天你会故意或可能意外地尝试输出一个控制代码——如果一个控制代码弄乱了终端显示，发出*reset*命令。输入**reset**并按Enter键，终端会尝试从你弄乱的地方恢复过来。
- en: The final control code doesn’t appear in the last stick of the ASCII table (refer
    to table 5.1). This is character code 127, often called Del (Delete) or Rub Out.
    Like codes 0 through 31, it’s nonprintable, but its output doesn’t mess up the
    display. This character is a holdover from the teletype era, where it was used
    as a backup-and-erase character; the Backspace code (8 or ^H) merely moves the
    cursor and is a nondestructive backup.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个控制代码没有出现在ASCII表的最后一栏中（参见表5.1）。这是字符代码127，通常称为Del（删除）或Rub Out。像代码0到31一样，它是不可打印的，但它的输出不会弄乱显示。这个字符是电传打字机时代的遗留物，当时它被用作备份和删除字符；退格代码（8或^H）只是移动光标，是一种非破坏性的备份。
- en: What of the other 128 character codes in a byte?
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 字节中的其他128个字符代码是什么？
- en: Even back in the microcomputer era, a byte of data consisted of 256 possible
    codes, 0 through 255\. ASCII characters defined the standard for codes 0 through
    127\. The other codes were nonstandard—not defined by ASCII, though many early
    computer users would mislabel them as such.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在微型计算机时代，一个字节数据由256个可能的码组成，从0到255。ASCII字符定义了0到127的码的标准。其他码是非标准的——虽然ASCII没有定义，但许多早期的计算机用户会错误地将它们标记为这样的码。
- en: On the IBM PC, codes 128 through 255 were referred to as Extended ASCII. These
    codes output consistent characters for all PC compatibles (more or less), but
    not for an Apple II, Commodore 64, or any other popular and wimpy systems of the
    era. Even then, it was possible to change the Extended ASCII codes by swapping
    in a new code page on the PC. This diversity of characters caused massive confusion.
    Fortunately, the state of the computer industry back then was consistent massive
    confusion, so few people noticed.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在IBM PC上，128到255的码被称为扩展ASCII。这些码为所有PC兼容机（或多或少）输出一致的字符，但不适用于Apple II、Commodore
    64或其他那个时代的流行和脆弱的系统。即使那时，通过在PC上更换新的代码页，也可以更改扩展ASCII码。这种字符的多样性导致了巨大的混乱。幸运的是，当时的计算机行业状态是一致的混乱，所以很少有人注意到。
- en: Today, any character code above 127 is standardized according to Unicode. These
    codes define just about every character you’ve never seen nor heard of. Refer
    to chapter 8 for additional and scintillating details.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，任何大于127的字符码都按照Unicode进行了标准化。这些码定义了你从未见过或听说的几乎所有字符。有关更多和令人兴奋的细节，请参阅第8章。
- en: 5.1.3 Generating noncharacter output
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.3 生成非字符输出
- en: 'When output as a character, *char* variables appear as a character. And thank
    goodness: the days of computers showing raw data are over—except for the movies,
    where computers still feature blinking lights and displays that output row upon
    row of numbers. Then again, monitors in movies make noise when displaying text
    and “hackers” type endlessly at a computer where they should be using a mouse.
    Silly Hollywood.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当作为字符输出时，*char*变量显示为字符。谢天谢地：计算机显示原始数据的时代已经过去了——除了电影，在那里计算机仍然有闪烁的灯光和输出一行又一行的数字的显示器。然后，电影中的显示器在显示文本时会发出噪音，而“黑客”在应该使用鼠标的电脑上无休止地打字。愚蠢的好莱坞。
- en: 'Using conversion characters other than %c, you can write code that outputs
    *char* data as decimal or hexadecimal values—even using the same variable:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用除%c之外的转换字符，你可以编写输出*char*数据为十进制或十六进制值的代码——甚至可以使用相同的变量：
- en: '[PRE0]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this statement, variable ch is output thrice: once as its character value,
    once as a decimal integer, and again as a hexadecimal integer. If you’re into
    octal, you can use %o to output the value in base 8 as well. In fact, if you wrote
    code for exercise 5.1, you probably used a *printf()* statement along these lines.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个声明中，变量ch被输出三次：一次作为其字符值，一次作为十进制整数，再次作为十六进制整数。如果你对八进制感兴趣，可以使用%o来输出以8为基数的值。实际上，如果你为练习5.1编写了代码，你可能使用了类似这样的*printf()*语句。
- en: But what about binary?
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 但二进制怎么办？
- en: The standard C library lacks a binary output function. Therefore, it’s your
    job to write one. Or you can just rely upon what I use, my *binString()* function.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 标准C库缺少二进制输出函数。因此，这是你的工作，编写一个。或者，你也可以依赖我使用的，我的*binString()*函数。
- en: Listing 5.1 shows the 8-bit version of my *binString()* function, concocted
    to output values stored in the *char* data type. The function uses the bitwise
    & operator to determine whether the far left bit in the character byte is on (1).
    If so, the character '1' is placed into the b[] buffer; otherwise, '0' is set.
    The value in variable a is then shifted one bit position to the left, and the
    operation repeats. As the bits are checked, string b[] is filled with ones and
    zeros. This string is declared *static*, so its value can be returned and the
    binary string used by whatever statement calls the *binString()* function.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.1显示了*binString()*函数的8位版本，该函数是为了输出存储在*char*数据类型中的值。该函数使用位与(&)运算符来确定字符字节中左边的位是否开启（1）。如果是，字符'1'将被放置到b[]缓冲区中；否则，设置为'0'。然后变量a中的值向左移动一个位位置，操作重复进行。在检查位时，字符串b[]被填充为一和零。这个字符串被声明为*静态的*，因此其值可以被返回，并且二进制字符串可以被调用*binString()*函数的任何语句使用。
- en: Listing 5.1 The 8-bit *binString()* function
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.1 8位*binString()*函数
- en: '[PRE1]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ The string is *static* so that its value is retained; nine characters allow
    for an 8-bit byte, plus another element for the terminating null character.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 字符串是*静态的*，因此其值被保留；九个字符允许一个8位字节，加上一个用于终止空字符的额外元素。
- en: ❷ Initializes the index variable
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 初始化索引变量
- en: ❸ Loops for each bit in the 8-bit byte
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 对8位字节中的每个位进行循环
- en: ❹ The ternary operator sets a 1 or 0 into the string, depending on the value
    of the far left bit in variable a.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 三元运算符根据变量a最左边的位值将1或0设置到字符串中。
- en: ❺ Variable a’s value is shifted one bit position to the left.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 变量a的值向左移动一个位位置。
- en: ❻ At this point, i is equal to 8, so the string is capped.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 此时，i等于8，因此字符串被截断。
- en: The 8-bit *binString()* function can be woven into code to output values in
    the ASCII table in binary, which is yet another way to generate noncharacter output—more
    interesting than dull decimal, sexy hex, or outdated octal.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 8位*binString()*函数可以被编织到代码中，以二进制形式输出ASCII表中的值，这是生成非字符输出的另一种方式——比单调的十进制、性感的十六进制或过时的八进制更有趣。
- en: To see *binString()* function in action, refer to the source code file binascii01.c
    included in this book’s online repository. Its program outputs an ASCII table
    with binary data.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看*binString()*函数的实际效果，请参考本书在线仓库中包含的源代码文件binascii01.c。其程序输出带有二进制数据的ASCII表。
- en: As a nerd, I enjoy the patterns created by binary values and how they relate
    to hexadecimal. In fact, I find it easy to convert between hex and binary, often
    doing so in my head. This relationship is illustrated in table 5.2, which makes
    it easy to understand some common ASCII conversion tricks revealed in the next
    section.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名书呆子，我喜欢由二进制值创造的图案以及它们与十六进制的关系。事实上，我发现将十六进制和二进制之间转换很容易，我经常在脑海中这样做。这种关系在表5.2中得到了说明，这使得理解下一节中揭示的一些常见ASCII转换技巧变得容易。
- en: Table 5.2 Binary to hexadecimal conversions
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.2 二进制到十六进制的转换
- en: '| Binary | Hex | Binary | Hex |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| 二进制 | 十六进制 | 二进制 | 十六进制 |'
- en: '| 0000 | 0 | 1000 | 8 |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| 0000 | 0 | 1000 | 8 |'
- en: '| 0001 | 1 | 1001 | 9 |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 0001 | 1 | 1001 | 9 |'
- en: '| 0010 | 2 | 1010 | A |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 0010 | 2 | 1010 | A |'
- en: '| 0011 | 3 | 1011 | B |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 0011 | 3 | 1011 | B |'
- en: '| 0100 | 4 | 1100 | C |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 0100 | 4 | 1100 | C |'
- en: '| 0101 | 5 | 1101 | D |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 0101 | 5 | 1101 | D |'
- en: '| 0110 | 6 | 1110 | E |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 0110 | 6 | 1110 | E |'
- en: '| 0111 | 7 | 1111 | F |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 0111 | 7 | 1111 | F |'
- en: Figure 5.2 illustrates binary bit positions, which help continue my nerd-gushing
    adoration of the binary-hexadecimal affair. For example, note that even numbers
    have zero set as the first binary digit. (Like decimal, binary digits are ordered
    from right to left, lowest to highest.) Odd values have the 1 digit in the first
    position.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2说明了二进制位位置，这有助于继续我对二进制-十六进制关系的书呆子般的热爱。例如，注意偶数以0作为第一个二进制位。 (像十进制一样，二进制位从右到左、从低到高排序。)奇数在第一个位置有1位。
- en: '![05-02](Images/05-02.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![05-02](Images/05-02.png)'
- en: Figure 5.2 Bit positions in a byte and how they factor out into a value
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 字节中的位位置及其如何分解为值
- en: 'Other things I find cool: binary 1010 is hex A, which is 10 decimal. The double
    “10” digits is a nice clue. Binary 1011 is hex B, or 11 decimal. Other patterns
    are obvious if you examine table 5.2 and figure 5.2—but be wary of becoming a
    nerd, too, if you overly enjoy such things.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我觉得其他一些事情也很酷：二进制1010是十六进制A，也就是十进制的10。双“10”数字是一个很好的线索。二进制1011是十六进制B，或者十进制的11。如果你查看表5.2和图5.2，会发现其他模式也很明显——但要注意，如果你过于享受这类事物，也可能变成一个书呆子。
- en: 5.1.4 Playing with ASCII conversion tricks
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.4 玩转ASCII转换技巧
- en: The folks who laid out the ASCII table, assigning codes to characters, were
    clever—for humans. Either they were towering geniuses who appreciated knowledge
    as they coordinated values and characters, or they just hit the luck jackpot.
    I don’t care either way. But I will take advantage of the serendipity.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 设计ASCII表的那些人，为字符分配代码，对人类来说很聪明。要么他们是协调值和字符时欣赏知识的杰出天才，要么他们只是中了幸运大奖。我两种情况都不在乎。但我将利用这种偶然性。
- en: Oh, and I loathe the word *serendipity*.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，我讨厌这个词*serendipity*。
- en: 'One of the tricks I take advantage of is the way digits 0 through 9 are mapped
    to hex values 0x30 through 0x39\. This arrangement makes it easy to perform simple
    math on the character values to translate them into numeric values. For example:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我利用的一个技巧是将数字0到9映射到十六进制值0x30到0x39。这种安排使得对字符值进行简单数学运算以将它们转换为数值变得容易。例如：
- en: '[PRE2]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This *printf()* statement subtracts '0' from '9', which look like character
    values but are seen by the compiler as 0x39 - 0x30\. The result is output as decimal
    value nine, which is what '9' represents.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个*printf()*语句从'9'减去'0'，看起来像字符值，但被编译器视为0x39 - 0x30。结果是作为十进制值九输出，这正是'9'所代表的。
- en: 'If *char* variable a contains a digit character, you can extract its integer
    value with:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*char*变量a包含一个数字字符，你可以使用以下方法提取其整数值：
- en: '[PRE3]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can pull a similar trick with letters of the alphabet to get them in the
    range of 0 though 25, though the hexadecimal value of A or a isn’t as sexy. For
    example, assume an uppercase letter is in *char* variable ch:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用类似的方法用字母表中的字母来获取它们在 0 到 25 的范围内，尽管 A 或 a 的十六进制值并不那么吸引人。例如，假设一个大写字母在 *char*
    变量 ch 中：
- en: '[PRE4]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, the value of offset is equal to the number of the uppercase letter in
    ch, zero through 25 for A through Z. An example of this operation at work appears
    in chapter 3, where the nato[] array is referenced by using a letter of the alphabet.
    See nato01.c and nato02.c in this book’s online repository for chapter 3.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，偏移量的值等于字符 ch 中大写字母的数量，从 A 到 Z 的 0 到 25。这个操作的例子在第 3 章中可以看到，其中使用字母表中的一个字母来引用
    nato[] 数组。请参阅本书在线仓库中的 nato01.c 和 nato02.c，以了解第 3 章的内容。
- en: 'ASCII table sticks one and three (refer to table 5.1) show the same characters
    for a different run of numbers. The control codes in the first stick use characters
    ^@ through ^_ (underscore) and the third stick uses character @ through _ (underscore).
    So, one way to express a control code is to add hex value 0x40 to the character’s
    value for output. In the following *printf()* statement, *char* variable cc holds
    a control code value (0x00 through 0x1F), which is output as ^@ through ^_:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ASCII 表的列一和三（参考表 5.1）显示了不同数字序列中的相同字符。第一列的控制代码使用字符 ^@ 通过 ^_（下划线）和第三列使用字符 @ 通过
    _（下划线）。因此，表示控制代码的一种方法是将字符值加上十六进制值 0x40。在下面的 *printf()* 语句中，*char* 变量 cc 持有控制代码值（0x00
    到 0x1F），以 ^@ 通过 ^_ 的形式输出：
- en: '[PRE5]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following statement reflects another way to express the statement with
    the same output:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以下语句反映了表达相同输出的另一种方式：
- en: '[PRE6]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you compare the ASCII table’s third and fourth sticks (again in figure 5.1),
    you see that the upper- and lowercase characters differ by exactly 32 or 0x20\.
    This arrangement allows for some interesting character manipulations to switch
    between upper- and lowercase letters:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你比较 ASCII 表的第三和第四列（再次参考图 5.1），你会看到大写和小写字符之间的差异正好是 32 或 0x20。这种安排允许进行一些有趣的字符操作，以在大小写字母之间切换：
- en: To convert an uppercase letter to lowercase, you reset the sixth bit in the
    byte.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将大写字母转换为小写，你需要将字节的第六位重置。
- en: To convert a lowercase letter to uppercase, you set the sixth bit in the byte.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将小写字母转换为大写，你需要将字节的第六位设置。
- en: 'Figure 5.3 illustrates the bit setting and resetting process with the letters
    A and a. The same relationship holds for all letters of the Latin alphabet: setting
    or resetting the sixth bit changes a character between upper- and lowercase.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 通过字母 A 和 a 说明了位设置和重置的过程。对于拉丁字母表中的所有字母，这种关系都成立：设置或重置第六位会改变字符的大小写。
- en: '![05-03](Images/05-03.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![05-03](Images/05-03.png)'
- en: Figure 5.3 How the sixth bit in a byte affects letter case
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 字节的第六位如何影响字母的大小写
- en: To magically manipulate the sixth bit in a byte, you use a bitwise logical operator,
    & (AND) or | (OR). You most likely skipped over these operators when you first
    learned C. For shame.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要神奇地操作字节的第六位，你使用位运算符，&（与）或 |（或）。你很可能在学习 C 语言时跳过了这些运算符。真遗憾。
- en: 'To convert uppercase to lowercase, you must set the sixth bit. This operation
    is handled by the | (OR) operator on the byte’s sixth bit. The expression is:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要将大写转换为小写，你必须设置第六位。这个操作由字节第六位的 |（或）运算符处理。表达式是：
- en: '[PRE7]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Above, the uppercase letter in *char* variable c is converted to its lowercase
    equivalent. The code can also be abbreviated as:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码中，*char* 变量 c 中的大写字母被转换为其小写等价物。代码也可以简写为：
- en: '[PRE8]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To convert a lowercase letter to uppercase, you must reset (change to zero)
    the sixth bit in the byte. To handle this operation, use the & bitwise operator,
    which masks out bits:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要将小写字母转换为大写，你必须重置（改变为零）字节的第六位。为了处理这个操作，使用 & 位运算符，它屏蔽了位：
- en: '[PRE9]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Also:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 此外：
- en: '[PRE10]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The binary representation of 0x20 is 01000000. The binary representation of
    0xdf is 10111111.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 0x20 的二进制表示为 01000000。0xdf 的二进制表示为 10111111。
- en: The source code shown in listing 5.2 demonstrates these techniques. The sample
    string in sentence[] is processed twice. The first time, a *while* loop plucks
    uppercase characters from the string, converting them to lowercase by the bitwise
    | 0x20 operation. The second *while* loop targets lowercase letters, converting
    them to uppercase with the & 0xdf operation. Pointer s is used to work through
    the sentence[] array one character at a time.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中展示的源代码演示了这些技术。sentence[] 中的样本字符串被处理了两次。第一次，一个 *while* 循环从字符串中提取大写字符，通过位运算
    | 0x20 将它们转换为小写。第二次 *while* 循环针对小写字母，通过 & 0xdf 操作将它们转换为大写。指针 s 用于逐个字符地遍历 sentence[]
    数组。
- en: Listing 5.2 Source code for casetricks01.c
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.2 casetricks01.c 的源代码
- en: '[PRE11]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Filters out uppercase text
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 过滤掉大写文本
- en: ❷ Outputs the lowercase character
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 输出小写字符
- en: ❸ Filters out lowercase text
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 过滤掉小写文本
- en: ❹ Outputs the uppercase character
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 输出大写字符
- en: 'Here is sample output:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是样本输出：
- en: '[PRE12]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In my code, I often revert to using the ctype functions *tolower()* or *toupper()*
    to make the conversion. But these bitwise operations perform the trick just as
    well, with the bonus that they make your code look super cryptic.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的代码中，我经常回退到使用 ctype 函数 *tolower()* 或 *toupper()* 来进行转换。但位运算也能同样完成这个任务，而且它们还能让你的代码看起来超级神秘。
- en: 5.2 The hex encoder/decoder
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 十六进制编码器/解码器
- en: My first telecommunications file transfer took 16 minutes. It was between a
    friend’s TRS-80 computer and mine, using an analog modem over standard phone lines.
    The transfer speed was 300 BPS, if you want to feign an appalled expression.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我的第一次电信文件传输耗时 16 分钟。这是在一位朋友的 TRS-80 计算机和我的计算机之间进行的，使用标准电话线路上的模拟调制解调器。如果你想要装出一副震惊的表情，传输速度是
    300 BPS。
- en: 'The data transferred was plain text. It could have been binary because, quite
    honestly, the phone line doesn’t care which bits in a byte represent characters.
    Still, I sat for 15 minutes watching jibber jabber flow down my screen and magically
    transform into a program: the original binary was encoded as two-digit hexadecimal
    values, transmitted, and then another program on my computer digested the hex
    bytes, converting them back into binary data.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 传输的数据是纯文本。它可以是二进制，因为坦白说，电话线路并不关心字节中哪些位代表字符。然而，我还是坐了 15 分钟，看着乱七八糟的信息流过我的屏幕，神奇地变成了一个程序：原始二进制被编码为两位十六进制值，然后传输，然后我的计算机上的另一个程序消化了这些十六进制字节，将它们转换回二进制数据。
- en: Another example of this hexadecimal encoding was found in the computer magazines
    of the era. Articles showcased amazing programs that you could type in; the hex
    bytes were listed on the pages. Hobbyists eagerly typed byte after byte into their
    keyboards, a hex decoder program gobbling up all the digits and creating a binary
    program that—fingers crossed—ran the first time and performed some wondrous task.
    Those were the days.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这种十六进制编码的另一个例子可以在那个时代的计算机杂志中找到。文章展示了你可以键入的惊人程序；十六进制字节列在页面上。爱好者们急切地将一个字节接一个字节地输入到他们的键盘上，一个十六进制解码程序吞噬了所有数字，创建了一个二进制程序——
    fingers crossed——第一次运行并执行了一些奇妙任务。那些都是好日子。
- en: By the way, hex encoding isn’t encryption nor is it compression. It’s merely
    a way to express binary data in a printable manner.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，十六进制编码既不是加密也不是压缩。它只是以可打印的方式表达二进制数据的一种方法。
- en: 5.2.1 Writing a simple hex encoder/decoder
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.1 编写简单的十六进制编码器/解码器
- en: The most important part about converting ASCII—and binary—to hex is doing so
    in a format that’s reliably converted back. After all, some type of verification
    is required to ensure that the data was successfully backed out of the encoding
    garage.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 将 ASCII 和二进制转换为十六进制最重要的部分是确保以可靠的方式转换回原始格式。毕竟，需要某种类型的验证来确保数据成功从编码中提取出来。
- en: One way to translate any information into hex is to write a filter, such as
    the one shown in the next listing. (Refer to chapter 4 if you need brushing up
    on filters.) The filter processes each byte (*int* ch) input. The *printf()* statement’s
    conversion character %02X outputs the byte as a 2-digit hex value with a leading
    zero, if necessary. The code outputs a newline only after all input is processed,
    which means the translation is one long string of hex bytes.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 将任何信息转换为十六进制的一种方法就是编写一个过滤器，例如下一个列表中展示的过滤器。（如果你需要复习过滤器，请参考第 4 章。）该过滤器处理每个输入的字节
    (*int* ch)。*printf()* 语句的转换字符 %02X 将字节输出为带前导零的两位十六进制值。代码只有在处理完所有输入后才输出换行符，这意味着转换是一个长的十六进制字节字符串。
- en: Listing 5.3 Source code for hexenfilter01.c
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.3 hexenfilter01.c 的源代码
- en: '[PRE13]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here’s a sample run at the command prompt, using standard input (the keyboard),
    assuming that the program name is *hexe* and it exists in the current directory:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个在命令提示符下使用标准输入（键盘）的示例运行，假设程序名称为 *hexe* 并且它位于当前目录中：
- en: '[PRE14]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Figure 5.4 illustrates what’s going on with the output, how each character of
    input is translated into the hex bytes.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4说明了输出过程中发生了什么，每个输入字符是如何被转换成十六进制字节的。
- en: '![05-04](Images/05-04.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![05-04](Images/05-04.png)'
- en: Figure 5.4 What’s going on with the output of a simple hex encoder
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 简单十六进制编码器的输出情况
- en: 'This filter can process more than plain text. You can redirect input from any
    file type, including a binary executable:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 此过滤器可以处理不仅仅是纯文本。你可以从任何文件类型重定向输入，包括二进制可执行文件：
- en: '[PRE15]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The problem with this serial hex digit approach is that the output is useful
    only to the decoder program. I wouldn’t expect a user to type in a long string
    of hex digits. Such a chore would be a nightmare.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这种串行十六进制数字方法的问题在于，输出结果仅对解码程序有用。我不期望用户输入一长串十六进制数字。这样的任务将是一场噩梦。
- en: To decode the long-string-of-text hex filter, you must write a program that
    properly translates 2-digit hex values into their byte-value equivalent. The assumption
    made in such a program is that it’s receiving the exact type of information that
    the encoder generates—which is a huge assumption, and one I’d never make in any
    program I planned on releasing as a practical utility.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要解码长字符串文本的十六进制过滤器，你必须编写一个程序，将两位十六进制值正确地转换为它们的字节值等效。此类程序所做出的假设是它接收到的信息类型与编码器生成的是完全相同的——这是一个巨大的假设，我绝不会在任何计划发布的实用工具程序中做出这样的假设。
- en: A big part of the translation is identifying and converting hexadecimal digits
    into their integer values. To accomplish this task, I present the *tohex()* function,
    shown in the following listing. It hunts down ASCII characters 0 through 9 and
    A through F, translating them into their integer equivalents. Anything out of
    range generates a return value of -1\. (The function doesn’t convert lowercase
    hex digits, which isn’t necessary for decoding in this example.)
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 翻译工作的一大部分是识别并将十六进制数字转换为它们的整数值。为了完成这个任务，我展示了 *tohex()* 函数，如下所示。它查找ASCII字符0到9和A到F，并将它们转换为它们的整数等效值。超出范围的任何内容都会生成返回值-1。
    （该函数不转换小写十六进制数字，在这个例子中解码并不需要。）
- en: Listing 5.4 The *tohex()* function.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.4 *tohex()* 函数。
- en: '[PRE16]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ Eliminates the digits 0 through 9
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 移除数字0到9
- en: ❷ Returns the digit’s integer value
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 返回数字的整数值
- en: ❸ Eliminates the letters *A* through *F*
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 移除字母 *A* 到 *F*
- en: '❹ Returns the character’s hex value: ‘A’==0x0A'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 返回字符的十六进制值：‘A’==0x0A
- en: ❺ All other characters return -1.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 所有其他字符返回-1。
- en: The *tohex()* function fights only part of the battle. The rest of the job is
    to read standard input, assembling every two hex digits into a byte. To accomplish
    this task, I wrote an endless *while* loop, shown next. It fetches the two characters,
    sticks them together, and then outputs the resulting value, which can be binary
    or plain text.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*tohex()* 函数只解决了战斗的一部分。其余的工作是读取标准输入，将每两个十六进制数字组装成一个字节。为了完成这个任务，我编写了一个无限 *while*
    循环，如下所示。它获取两个字符，将它们组合在一起，然后输出结果值，该值可以是二进制或纯文本。'
- en: Listing 5.5 Decoding the endless line of a hex filter
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.5 解码十六进制过滤器的无限行
- en: '[PRE17]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ The endless loop relies upon the presence of an EOF to terminate.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 无限循环依赖于EOF的存在来终止。
- en: ❷ Reads a character and immediately . . .
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 读取一个字符并立即 . . .
- en: ❸ . . . checks for the EOF and breaks the loop if found
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ . . . 检查EOF，如果找到则退出循环
- en: ❹ Converts the character to a hex value
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将字符转换为十六进制值
- en: ❺ Exits if the character isn’t hex
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 如果字符不是十六进制则退出
- en: ❻ Shifts value a four bits to represent the upper half of the byte in value
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 将值左移四位以表示字节值的高位
- en: ❼ Repeats the process for the next character, but without the shift
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 对下一个字符重复此过程，但不进行移位
- en: ❽ Outputs the resulting byte
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 输出结果字节
- en: 'The entire batch of code is available in this book’s online repository as hexdefilter01.c.
    It can be run straight-up, assuming you know a smattering of hex values to type
    in:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 整个代码块都可以在这个书的在线仓库中找到，作为 hexdefilter01.c。如果你知道一些要输入的十六进制值，可以直接运行：
- en: '[PRE18]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The program stops when it encounters a nonhex digit or when the EOF is encountered,
    which helps match it up perfectly with the output from the hexenfilter01.c program.
    In fact—the true test of encoding and decoding—you can pump output through both
    filters and end up with the original data:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 'The program stops when it encounters a nonhex digit or when the EOF is encountered,
    which helps match it up perfectly with the output from the hexenfilter01.c program.
    In fact—the true test of encoding and decoding—you can pump output through both
    filters and end up with the original data:'
- en: '[PRE19]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Text is echoed to standard input but first piped through the hexe (hexenfilter01.c)
    program, assumed to be in the current directory. This encoded output is then piped
    through the *hexd* (hexdefilter01.c) program. The output is the original text.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Text is echoed to standard input but first piped through the hexe (hexenfilter01.c)
    program, assumed to be in the current directory. This encoded output is then piped
    through the *hexd* (hexdefilter01.c) program. The output is the original text.
- en: These simple filters process information, whipping it into one long string of
    hexadecimal characters. This type of hex encoding may work for transferring a
    silly game on a 300 BPS modem in the last century, but good luck getting a user
    to type in all those bytes without crossing their eyes. No, additional formatting
    is necessary for a better hex encoder/decoder.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: These simple filters process information, whipping it into one long string of
    hexadecimal characters. This type of hex encoding may work for transferring a
    silly game on a 300 BPS modem in the last century, but good luck getting a user
    to type in all those bytes without crossing their eyes. No, additional formatting
    is necessary for a better hex encoder/decoder.
- en: 5.2.2 Coding a better hex encoder/decoder
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.2 编码更好的十六进制编码器/解码器
- en: I prefer a hex encoding method that shows its details in a neat, orderly manner.
    Especially back in the old days, if you were typing in row upon row of hex bytes
    published in a computer magazine to input a program, you didn’t need to see the
    Great Wall of Hex.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: I prefer a hex encoding method that shows its details in a neat, orderly manner.
    Especially back in the old days, if you were typing in row upon row of hex bytes
    published in a computer magazine to input a program, you didn’t need to see the
    Great Wall of Hex.
- en: 'A good approach to hex-encoding data, especially if the information is to be
    presented both for a human and a decoding program, is to format the output in
    neat rows and columns. For example:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 'A good approach to hex-encoding data, especially if the information is to be
    presented both for a human and a decoding program, is to format the output in
    neat rows and columns. For example:'
- en: '[PRE20]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ Title text with version number
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Title text with version number
- en: ❷ Neatly and consistently outputs rows of hex values
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 清晰且一致地输出十六进制值行
- en: ❸ Terminating line
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 终止行
- en: This output is from a filter, though it’s formatted to be more presentable and
    predictable. It still has its flaws, which I’ll get into eventually, but it’s
    a better encoder despite the data output being a series of hexadecimal digits,
    just like that of the filter presented in the preceding section.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: This output is from a filter, though it’s formatted to be more presentable and
    predictable. It still has its flaws, which I’ll get into eventually, but it’s
    a better encoder despite the data output being a series of hexadecimal digits,
    just like that of the filter presented in the preceding section.
- en: Listing 5.6 shows the source code for the *Hex Encode 1.0* program. It’s based
    on a typical I/O filter, though it formats output based on a certain number of
    hex digits per line, shown in the code as defined constant BYTES_PER_LINE. Variable
    bytes tracks the digits output, ensuring that the hex digit pairs stay consistent
    line by line. This value is reset when the number of digits output equals the
    defined constant BYTES_PER_LINE, and a new line of hex digits is output. The final
    line output marks the end of encoding.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.6 展示了 *Hex Encode 1.0* 程序的源代码。它基于典型的 I/O 过滤器，尽管它根据代码中定义的常量 BYTES_PER_LINE
    格式化输出。变量 bytes 跟踪输出的数字，确保十六进制数字对逐行保持一致。当输出的数字数量等于定义的常量 BYTES_PER_LINE 时，此值将被重置，并输出一行新的十六进制数字。输出的最后一行标记了编码的结束。
- en: Listing 5.6 Source code for hexencode01.c
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.6 hexencode01.c 的源代码
- en: '[PRE21]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ Set this value as a defined constant so that it can be updated easily.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Set this value as a defined constant so that it can be updated easily.
- en: ❷ Initializes the byte counter
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 初始化字节计数器
- en: ❸ Outputs the header line before processing standard input
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ Outputs the header line before processing standard input
- en: ❹ Checks for the end of the line
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ Checks for the end of the line
- en: ❺ If so, outputs a newline . . .
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ If so, outputs a newline . . .
- en: ❻ . . . and resets the byte counter
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ . . . 并重置字节计数器
- en: ❼ After processing standard input (including the EOF), outputs the tail line
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 在处理完标准输入（包括 EOF）后，输出尾行
- en: 'The hex-encoding code works like any filter, waiting for the EOF or, when using
    standard input, a press of the Ctrl+D key to terminate. Here is sample output:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 'The hex-encoding code works like any filter, waiting for the EOF or, when using
    standard input, a press of the Ctrl+D key to terminate. Here is sample output:'
- en: '[PRE22]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Writing the encoding program is the easy part. More difficult is decoding, where
    you must properly interpret the format to convert the hex digits back into bytes.
    As with any complex coding contraption, I accomplish such a task one step at a
    time.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 编写编码程序是容易的部分。更难的是解码，你必须正确解释格式，将十六进制数字转换回字节。就像任何复杂的编码装置一样，我一步一步地完成这样的任务。
- en: The first step to writing the hex decoder is to write a filter that processes
    a line of input at a time. This proto-program is shown in the next listing. It’s
    incomplete as far as decoding is concerned. It extracts a line of text from standard
    input and stores it in the line[] buffer. The buffer is output once it’s filled,
    which is dull. Still, future versions of the program will use the line[] buffer
    to process the encoded values.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 编写十六进制解码器的第一步是编写一个一次处理一行输入的过滤器。这个原型程序在下一列表中显示。在解码方面，它是不完整的。它从标准输入中提取一行文本并存储在
    line[] 缓冲区中。缓冲区填满后输出，这很无聊。然而，程序的将来版本将使用 line[] 缓冲区来处理编码值。
- en: Listing 5.7 Source code for hexdecode01.c
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.7 hexdecode01.c 的源代码
- en: '[PRE23]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ Calculates the buffer size for the number of bytes times the number of spaces
    used, plus one for the null character
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 计算缓冲区大小，为字节数乘以使用的空格数，再加一个空字符
- en: ❷ Stores incoming characters in the buffer
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将传入的字符存储在缓冲区中
- en: ❸ Increments the offset
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 增加偏移量
- en: ❹ Checks for newline (as the decoded file is formatted) or a full buffer
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 检查换行符（因为解码文件是格式化的）或缓冲区已满
- en: ❺ Replaces the newline with a null character; otherwise, caps the string
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将换行符替换为空字符；否则，截断字符串
- en: ❻ Outputs the line, unmodified
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 输出未修改的行
- en: 'As written, the source code for hexdecode01.c processes any input line by line.
    The lines are truncated at LENGTH number of characters, which is calculated as
    the exact length of lines output by the *hexencode* program shown earlier. No
    other processing is done on the incoming data, so the program’s output looks exactly
    like whatever is input. Here, you see the file sample.txt, created by the *hexencode*
    program, which is output as is by the *hexdecode* program:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如其所述，hexdecode01.c 的源代码逐行处理任何输入。这些行在 LENGTH 个字符处被截断，其计算方式是前面显示的 *hexencode*
    程序输出的行的确切长度。对传入的数据没有进行其他处理，因此程序的输出看起来与输入的完全一样。在这里，您可以看到由 *hexencode* 程序创建的文件 sample.txt，它被
    *hexdecode* 程序原样输出：
- en: '[PRE24]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The program works, so the code accomplished the first step in the process.
    To improve the code, the next change confirms that the input data is formatted
    properly. After all, this is a decoding program for a specific encoded data format.
    This improvement takes advantage of the *hexencode* program’s first and last lines
    of output (shown in the sample output): the initial line HEX ENCODE 1.0 must be
    detected or else the file is improperly formatted and no further processing is
    necessary. Also, the final line, HEX ENCODE END, is tested to determine when line
    processing is over.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 程序运行正常，所以代码完成了过程中的第一步。为了改进代码，接下来的更改确认输入数据格式正确。毕竟，这是一个特定编码数据格式的解码程序。这种改进利用了 *hexencode*
    程序的第一行和最后一行输出（如示例输出所示）：初始行 HEX ENCODE 1.0 必须被检测到，否则文件格式不正确，不需要进一步处理。同样，最后的行 HEX
    ENCODE END 被测试以确定行处理何时结束。
- en: 'Several small chunks of code must be added to hexdecode01.c to make these improvements.
    First, the new code uses the *exit()* and *strncmp()* functions, which require
    the inclusion of two header files:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 必须向 hexdecode01.c 添加几个小的代码块来做出这些改进。首先，新代码使用了 *exit()* 和 *strncmp()* 函数，这需要包含两个头文件：
- en: '[PRE25]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'A new variable declaration is required, pointer r. This pointer holds the return
    value from the *fgets()* function, which is used to determine whether input is
    valid:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 需要一个新的变量声明，指针 r。这个指针持有 *fgets()* 函数的返回值，该函数用于确定输入是否有效：
- en: '[PRE26]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The variable declarations are followed by a chunk of code designed to read
    the initial line of text. The *fgets()* function reads the line from standard
    input (stdin), which is then tested with an *if* statement. If the return value
    from *fgets()* is NULL or the string doesn’t compare with the required hex-encoding
    header, an error message is output and the program terminates:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 变量声明之后是一段代码，用于读取初始文本行。*fgets()* 函数从标准输入（stdin）读取行，然后使用 *if* 语句进行测试。如果 *fgets()*
    的返回值为 NULL 或字符串不与所需的十六进制编码头匹配，则输出错误消息并终止程序：
- en: '[PRE27]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ❶ The first line of input is gobbled up.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 吞吐输入的第一行。
- en: ❷ *fgets()* returns NULL on invalid input; otherwise, the *strncmp()* function
    performs an exact comparison on the first line of text versus the required text.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在无效输入时，*fgets()* 返回 NULL；否则，*strncmp()* 函数对文本的第一行与所需文本进行精确比较。
- en: ❸ An error message is sent to the standard error device to avoid output confusion.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将错误信息发送到标准错误设备，以避免输出混淆。
- en: I omitted version testing on the first line of text, which I’m saving for a
    later improvement to the code, covered in the next section.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我省略了文本第一行的版本测试，我将它留到稍后改进代码时使用，这部分内容将在下一节中介绍。
- en: 'The final chunk of text is added in the *while* loop, just before the *printf()*
    statement that outputs the value of line[]. The statements test for the terminating
    line in the formatted hex encoding. If found, the loop is broken without outputting
    the final line:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一段文本添加在 *while* 循环中，就在输出 line[] 值的 *printf()* 语句之前。这些语句检查格式化十六进制编码中的终止行。如果找到，循环将中断而不会输出最后一行：
- en: '[PRE28]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: All these modifications are included in the source code file hexdecode02.c,
    available in this book’s online repository.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些修改都包含在源代码文件 hexdecode02.c 中，该文件可在本书的在线仓库中找到。
- en: 'When compiled and run, the output is similar to the earlier program, but an
    improperly formatted hex encode file is identified right away. So, if you run
    the program on its own source code file, you see this output:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行后，输出与早期程序类似，但可以立即识别出格式不正确的十六进制编码文件。因此，如果你在自己的源代码文件上运行程序，你会看到以下输出：
- en: '[PRE29]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Otherwise, the output looks the same as the first version. The hex byte lines
    are read and output with no further processing:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，输出看起来与第一个版本相同。读取并输出十六进制字节行，无需进一步处理：
- en: '[PRE30]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The final improvement is to process the hex digits, translating them into values.
    This change requires only one new variable and one additional chunk of statements.
    The new variable is integer hex, which can be added to the existing int variable
    declarations:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的改进是处理十六进制数字，将它们转换为值。这个更改只需要一个新变量和一个额外的语句块。新变量是整数 hex，可以添加到现有的 int 变量声明中：
- en: '[PRE31]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: To translate the hexadecimal character pairs into bytes, the *while* loop’s
    *printf()* statement is replaced with a nested *while* loop. This inner loop processes
    the line[] buffer, parsing out the hex digit pairs. I use the *strtok()* function
    to handle the parsing or “tokenizing,” if that’s what the *tok* stands for. Using
    this function saves a lot of overhead, reducing the code by several statements.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将十六进制字符对转换为字节，将 *while* 循环的 *printf()* 语句替换为嵌套的 *while* 循环。这个内部循环处理 line[]
    缓冲区，解析出十六进制数字对。我使用 *strtok()* 函数来处理解析或“标记化”，如果 *tok* 就代表这个意思。使用这个函数可以节省很多开销，减少了几个语句。
- en: 'Within the nested *while* loop, a *sscanf()* function translates the parsed
    hex digits, which are now considered a 2-character string, into an integer value.
    The value generated is sent to standard output. The process repeats until the
    entire line is processed, which is the beauty of the *strtok()* function:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌套的 *while* 循环中，一个 *sscanf()* 函数将解析出的十六进制数字，现在被视为一个 2 个字符的字符串，转换为整数值。生成的值被发送到标准输出。这个过程会一直重复，直到整行被处理，这正是
    *strtok()* 函数的美丽之处：
- en: '[PRE32]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: ❶ Parses the string (input line of text), separating its content by spaces
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 解析字符串（文本输入行），通过空格分隔其内容
- en: ❷ As long as the *strtok()* function returns a non-NULL value, loops
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 只要 *strtok()* 函数返回非 NULL 值，循环
- en: ❸ Translates the 2-character hex string into an integer value
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将 2 个字符的十六进制字符串转换为整数值
- en: ❹ Outputs the integer value (which can be non-ASCII)
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 输出整数值（可能不是 ASCII）
- en: ❺ Keeps scanning the same string
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 继续扫描相同的字符串
- en: This final modification to the code is available in the repository as hexdecode03.c.
    It completes the project. The resulting program, which I’ve named *hexdecode*,
    can properly decode the data encoded by the *hexencode* program.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的最后一次修改可在仓库中找到，文件名为 hexdecode03.c。它完成了项目。我将其命名为 *hexdecode* 的程序可以正确解码由 *hexencode*
    程序编码的数据。
- en: 'To put the program to the test, I encoded and then decoded the program file
    itself. The first step is to encode the program file, saving the output for use
    later:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试程序，我首先对程序文件进行了编码，然后进行了解码。第一步是编码程序文件，将输出保存以供以后使用：
- en: '[PRE33]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This command processes the binary data in the *hexdecode* program file. The
    output is redirected to a new file named hexdecode.hex. This file is plain text
    but formatted as shown throughout this section: with a header, rows of hex digits,
    and a tail.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令处理*hexdecode*程序文件中的二进制数据。输出被重定向到一个名为hexdecode.hex的新文件。此文件是纯文本，但格式如本节所示：带有标题、十六进制数字行和尾部。
- en: 'To decode the file and translate it back into binary data, use this command:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 要解码文件并将其转换回二进制数据，请使用以下命令：
- en: '[PRE34]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The *cat* command outputs the encoded file, hexdecode.hex, created earlier.
    This output (which is plain text) is piped through the *hexdecode* program. The
    result—now binary data, so standard output looks ugly—is redirected into a new
    file, hexdecode.bin.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '*cat*命令输出了之前创建的编码文件，hexdecode.hex。这个输出（它是纯文本）通过*hexdecode*程序。结果是现在为二进制数据，因此标准输出看起来很丑陋，被重定向到一个新文件，hexdecode.bin。'
- en: 'To ensure that both the original hexdecode program file and the encoded/decoded
    data file hexdecode.bin are identical, I use the *diff* command:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保原始的hexdecode程序文件和编码/解码数据文件hexdecode.bin是相同的，我使用了*diff*命令：
- en: '[PRE35]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Because the *diff* program generates no output, it’s confirmed that the original
    binary file was encoded into a text file of hexadecimal character pairs *and*
    successfully decoded back into its original binary format. The *hexencode/hexdecode*
    filters work. Then again, I wouldn’t have written all this stuff if they didn’t.
    No spoilers.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 因为*diff*程序不生成输出，所以可以确认原始二进制文件被编码成十六进制字符对的文本文件，并且成功解码回其原始二进制格式。*hexencode/hexdecode*过滤器工作正常。然后，如果它们不起作用，我就不会写所有这些内容。没有剧透。
- en: 5.2.3 Adding a wee bit of error-checking
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.3 添加一点错误检查
- en: I was delighted with my original efforts for the hexencode/hexdecode series
    of filters. That’s until I started looking at the encoded information and trying
    to figure out how it could be messed up. After all, upon successful creation of
    any program, you as a C coder must immediately figure out how to break it.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我对我的hexencode/hexdecode系列过滤器最初的努力感到非常满意。然而，当我开始查看编码信息并试图弄清楚它可能被破坏的方式时，我的心情发生了变化。毕竟，在成功创建任何程序之后，作为一个C语言程序员，你必须立即想出如何破坏它。
- en: Consider that you’re a teen with a computer (and no social life, natch), and
    you’re eager to type in the new *Laser Blaster* game fresh from the pages of *Compute!*
    magazine. You type line after line, hex digit after digit. Did you screw up? If
    so, at what point did the mistake happen?
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你是一个拥有电脑（当然，没有社交生活）的青少年，你渴望输入从*Compute!*杂志上新鲜出炉的*Laser Blaster*游戏。你一行行地输入，一个十六进制数字接一个十六进制数字。你出错了吗？如果是，错误发生在哪个点？
- en: To help track entry errors, early hex dumps in magazines offered a checksum
    digit at the end of each row. This checksum is merely the total of all the byte
    values in the row, sometimes modulo 0x100 to make it look like another two digit
    hex value. When the user typed in the code, they could run the checksum (or their
    hex decoder program would) to determine whether a mistake was made and which line
    had to be reread and whether the entire operation had to start all over again.
    Yes, this is one reason Jolt Cola came in 12-packs.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助跟踪输入错误，早期的杂志中的十六进制转储在每一行的末尾提供了一个校验和数字。这个校验和仅仅是该行中所有字节的值的总和，有时取模0x100以使其看起来像另一个两位十六进制值。当用户输入代码时，他们可以运行校验和（或者他们的十六进制解码程序会）来确定是否出错，以及哪一行需要重新读取，以及是否整个操作需要从头开始。是的，这就是Jolt
    Cola以12瓶装出现的原因。
- en: The source code for checksum01.c is shown in the next listing. It demonstrates
    how to perform a simple type of checksum. Each successive value from array hexbytes[]
    is accumulated in *int* variable checksum. This result is output modulo 0x100,
    which keeps it byte-size for consistency.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: checksum01.c的源代码在下一列表中展示。它演示了如何执行一种简单的校验和。从数组hexbytes[]中连续的每个值都累积在*int*变量checksum中。这个结果以模0x100输出，以保持其字节大小的一致性。
- en: Listing 5.8 Source code for checksum01.c
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.8 checksum01.c的源代码
- en: '[PRE36]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: ❶ Just a random assortment of hex values; 10 total
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 只是一些随机的十六进制值；总共10个
- en: ❷ Initializes the checksum variable here
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在这里初始化校验和变量
- en: ❸ Accumulates the totals
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 累积总和
- en: ❹ Outputs the checksum, but limited to a char-size value
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 输出校验和，但限制为字符大小值
- en: Writing a program like checksum01.c is an approach I often take to solving a
    larger programming project. Whenever I add a new feature to any program, I want
    to ensure that it works. If instead I add the feature to existing code, the process
    may introduce other problems that complicate bug hunting.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 编写像 checksum01.c 这样的程序是我解决更大编程项目时经常采取的方法。每当我向任何程序添加一个新功能时，我都想确保它能正常工作。如果我把这个功能添加到现有代码中，这个过程可能会引入其他问题，从而复杂化错误追踪。
- en: 'Here’s sample output from the checksum01.c program:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 checksum01.c 程序的示例输出：
- en: '[PRE37]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: More complex methods exist to calculate a checksum, including some clever variations
    that can even tell you which specific value is incorrect. But never mind!
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 存在着更复杂的方法来计算校验和，包括一些聪明的变体，甚至可以告诉你哪个具体值是错误的。但不要在意！
- en: Adding a checksum to the *hexencode/hexdecode* programs requires that both source
    code files are modified. Yes, it’s version 2.0, now featuring (modest) error checking.
    So, not only must both programs calculate and output a checksum byte, but the
    version number must also be updated and verified. If you want to go further, you
    can have the *hexdecode* program still decode version 1.0 files without applying
    the checksum. More work to do!
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *hexencode/hexdecode* 程序中添加校验和需要修改两个源代码文件。是的，现在是 2.0 版本，现在具有（适度）的错误检查功能。因此，不仅两个程序必须计算和输出校验和字节，版本号也必须更新并验证。如果你想更进一步，可以让
    *hexdecode* 程序仍然解码 1.0 版本的文件而不应用校验和。还有更多的工作要做！
- en: Exercise 5.2
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 5.2
- en: Update the source code to hexencode01.c to add a checksum hex value to be output
    at the end of each row. Don’t forget the final row’s checksum (hint, hint). Oh,
    and update the version number to 2.0\. My solution is found in this book’s online
    repository as hexencode02.c.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 将源代码更新到 hexencode01.c，以添加一个校验和十六进制值，并将其输出到每行的末尾。别忘了最后一行的校验和（提示，提示）。哦，别忘了更新版本号到
    2.0。我的解决方案可以在本书的在线仓库中找到，名为 hexencode02.c。
- en: 'The code for your solution to exercise 5.2 may not look exactly as mine does,
    but the output should resemble something like this:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 你对练习 5.2 的解决方案的代码可能看起来并不完全像我的一样，但输出应该类似于以下内容：
- en: '[PRE38]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This output is like the program’s first (1.0) version’s output, but an extra
    hex value appears at the end of each row. This value is the checksum.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出类似于程序的第一版（1.0）输出，但每行的末尾都出现了一个额外的十六进制值。这个值是校验和。
- en: 'Decoding this data, turning it back into binary, requires an update to the
    *hexdecode* program, obviously: first, it must check the version number. If the
    encoded data shows “v2.0,” the decoder must examine the byte value and confirm
    that the line was properly decoded. If not, decoding stops and the information
    is flagged as invalid. And, yes, I’m making you perform this change on your own
    as the next exercise.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 解码这些数据，将其转换回二进制，显然需要更新 *hexdecode* 程序：首先，它必须检查版本号。如果编码数据显示“v2.0”，解码器必须检查字节值并确认该行是否已正确解码。如果没有，解码将停止，并将信息标记为无效。是的，我让你自己进行这个更改作为下一个练习。
- en: Exercise 5.3
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 5.3
- en: Convert the source code for hexdecode03.c to handle the extra checksum byte
    set there by the program created from hexencode01.c (exercise 5.2). You must properly
    account for and use the checksum byte to ensure that each line of the encoded
    text file is read properly. My solution is named hexdecode04.c, which is available
    in the online repository. Please attempt this exercise on your own before you
    cheat and see how I did it. Comments in my code explain what’s going on—and a
    particularly lucky turn of events that surprised even me.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 将 hexdecode03.c 的源代码转换为处理由 hexencode01.c（练习 5.2）创建的程序设置的额外校验和字节。你必须正确地考虑并使用校验和字节，以确保正确读取编码文本文件的每一行。我的解决方案命名为
    hexdecode04.c，可在在线仓库中找到。请在作弊之前自己尝试这个练习，看看我是如何做到的。我的代码中的注释解释了正在发生的事情——以及一个甚至让我都感到惊讶的幸运转折。
- en: Alas, my solution isn’t perfect, as you can read in my code comments. Further
    modification may help send the code in the right direction. This is a topic I
    may explore on my blog in the future, especially after I’ve eaten lots of cake.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，我的解决方案并不完美，正如你可以在我的代码注释中读到的那样。进一步的修改可能有助于将代码引向正确的方向。这是一个我可能在未来的博客中探讨的话题，尤其是在我吃过很多蛋糕之后。
- en: 5.3 URL encoding
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3 URL 编码
- en: Another type of text encoding, one that you’ve probably seen before and become
    frightened over, is URL encoding. Also known as percent encoding, this encoding
    format preserves web page address and online form content by using printable characters
    and a smattering of percent signs. This encoding avoids some characters appearing
    in a URL that may offend our internet overlords.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种文本编码类型，你可能以前见过并感到害怕，就是URL编码。也称为百分号编码，这种编码格式通过使用可打印字符和一些百分号来保留网页地址和在线表单内容。这种编码避免了某些字符出现在URL中可能会冒犯我们的网络霸主。
- en: Specifically, for a web page address, URL encoding is used when referencing
    something that may otherwise be misinterpreted by the web server, such as a binary
    value, embedded web page, spaces, or other sneaky data. URL encoding allows this
    information to be sent as plain text and properly decoded later.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，对于网页地址，当引用可能被Web服务器错误解释的内容时，会使用URL编码，例如二进制值、嵌入的网页、空格或其他隐蔽数据。URL编码允许这些信息以纯文本形式发送，并在稍后正确解码。
- en: As with any other encoding, you can write a URL-encoding translation program
    in C. All you need to know are all the URL encoding rules.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何其他编码一样，你可以用C编写URL编码转换程序。你需要知道的是所有的URL编码规则。
- en: 5.3.1 Knowing all the URL encoding rules
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.1 了解所有URL编码规则
- en: 'To help you make the connection between what you may have seen and how URL
    encoding looks, here’s an example:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你将你所看到的内容与URL编码的外观联系起来，这里有一个例子：
- en: '[PRE39]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: All the encoding is plain text; URL-encoded is human-readable. Although every
    character could be encoded, only special characters are presented as a 2-digit
    hex value prefixed with a percent sign—for example, %24 for the dollar sign character,
    ASCII code 0x24.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 所有编码都是纯文本；URL编码是可读的。尽管每个字符都可以进行编码，但只有特殊字符以两位十六进制值的形式呈现，前面加上百分号——例如，%24表示美元符号字符，ASCII码0x24。
- en: 'Though various rules exist regarding this encoding method, the HTML 5 standard
    defines it as follows:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在关于这种编码方法的规则，但HTML 5标准如下定义：
- en: Alphanumeric characters are not translated (0 to 9, A to Z, upper- and lowercase).
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字母数字字符不进行翻译（0到9，A到Z，大小写）。
- en: The characters - (dash), . (period), _ (underscore), and * (asterisk) are retained.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符 -（破折号）、.（点）、_（下划线）和*（星号）被保留。
- en: Spaces are converted into the + (plus) character, though the %20 code is also
    used.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空格被转换为+（加号）字符，尽管也使用了%20代码。
- en: All other characters are represented as their hexadecimal ASCII value, prefixed
    with a percent sign.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有其他字符都表示为它们的十六进制ASCII值，前面加上百分号。
- en: If the data to encode is wider than a byte, such as a Unicode character, it’s
    divided into byte-size values, each a 2-digit hex number prefixed with a percent
    sign. This final point may not be consistent for all wide-character values.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果要编码的数据宽度超过一个字节，例如Unicode字符，它将被分成字节大小的值，每个值都是一个两位十六进制数，前面加上百分号。这一点可能对所有宽字符值并不一致。
- en: Subtle variations on these rules exist, but you get the gist of it. This information
    is adequate for you to experience the joy of writing your own URL encoding and
    decoding programs.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则存在细微的变体，但你应该能理解其大意。这些信息足以让你体验编写自己的URL编码和解码程序的乐趣。
- en: 5.3.2 Writing a URL encoder
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.2 编写URL编码器
- en: The key to success with writing a URL-encoding program, a filter in this incarnation,
    is to catch the exceptions first. Output whatever characters need no translation
    just as they are. Once these items are eliminated, all other characters the program
    outputs must obey the percent-hexadecimal encoding method.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 编写URL编码程序的关键，在这个版本中是一个过滤器，是首先捕获异常。对于不需要翻译的字符，直接按照原样输出。一旦这些项目被消除，程序输出的所有其他字符都必须遵循百分号十六进制编码方法。
- en: The source code for urlencoder01.c appears in the following listing. It’s a
    standard filter that processes input one character at a time. The four URL encoding
    exceptions are handled first (- . _ *) followed by the space. The *isalnum()*
    function weeds out all alphanumeric characters. Anything remaining is output using
    the %-hexadecimal format, as shown in the code’s *printf()* statement.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: urlencoder01.c的源代码如下所示。它是一个标准的过滤器，逐个字符处理输入。首先处理四个URL编码异常（- . _ *），然后是空格。*isalnum()*函数排除所有字母数字字符。剩余的内容使用%-十六进制格式输出，如代码中的*printf()*语句所示。
- en: Listing 5.9 Source code for urlencoder01.c
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.9 urlencoder01.c的源代码
- en: '[PRE40]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: ❶ These characters are okay; output as-is.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这些字符是可以的；直接输出。
- en: ❷ The space is output as a + character.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 空格输出为+字符。
- en: ❸ Alphanumeric characters are output as-is.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 以原样输出字母数字字符。
- en: ❹ The %% is required to output a percent sign, followed by a 2-digit hexadecimal
    value, prefixed by a leading zero if necessary.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 需要使用%%来输出百分号，后跟一个两位十六进制值，如果需要，前面有一个前导零。
- en: 'Here is a sample run of the program, which I’ve named *urlencoder*:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是程序的示例运行，我将其命名为*urlencoder*：
- en: '[PRE41]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here, the filter is run at the prompt, so all keyboard input appears in the
    output. This approach explains why you see the %0A character for the newline at
    the end of the final line, followed by the Ctrl+D key (^D) to terminate input.
    The command prompt, $, appears immediately after.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，过滤器在提示符下运行，因此所有键盘输入都显示在输出中。这种方法解释了为什么你会看到末行结尾的换行符%0A，然后是Ctrl+D键(^D)来终止输入。命令提示符$紧接着出现。
- en: 'If you’re used to seeing URL encoding, and understand the basic parts of a
    URL, you may recognize a few common codes:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯了看到URL编码，并且理解了URL的基本组成部分，你可能认识一些常见的代码：
- en: '%3A for the colon, :'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '%3A代表冒号，:'
- en: '%2F for the forward slash, /'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '%2F代表正斜杠，/'
- en: 'Other codes I see often are:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常看到的其他代码有：
- en: '%3F for the question mark, ?'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '%3F代表问号，?'
- en: '%26 for an ampersand, &'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '%26代表和号，&'
- en: Of course, beyond being a nerd, you need not memorize these common URL encodings.
    Instead, you can write your own URL decoder, which is also a sign of being a nerd
    but with a potential to garner an income.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，除了是一个书呆子之外，你不需要记住这些常见的URL编码。相反，你可以编写自己的URL解码器，这也是一个书呆子的标志，但有可能带来收入。
- en: 5.3.3 Creating a URL decoder
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.3 创建URL解码器
- en: I hope you won’t find creating a URL decoder too difficult. Unlike the encoder,
    the only incoming character the filter should care about is the percent sign.
    Oh, sure, you could test for “illegal” characters such as those out of range;
    I’ll leave the extra coding up to you.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你会发现创建URL解码器并不太难。与编码器不同，过滤器唯一关心的输入字符是百分号。哦，当然，你可以测试“非法”字符，如超出范围的字符；我将额外的编码留给你自己。
- en: The key to weeding out the hex digits is to scan for the % character. Once it’s
    encountered, you can use a function like tohex(), covered way back in section
    5.2.1, to translate the next two incoming hex digits. Again, more testing can
    be done to determine whether the characters were legitimate hexadecimal digits—but
    you get the idea.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 去除十六进制数字的关键是扫描%字符。一旦遇到，可以使用类似于tohex()的函数，如5.2.1节中所述，来翻译接下来的两个十六进制数字。再次强调，可以进行更多测试以确定字符是否为合法的十六进制数字——但你应该明白了。
- en: Presented in the next listing is my quick-and-dirty solution to the URL decoder.
    It uses a modified version of the *tohex()* function shown earlier; this one also
    checks for lowercase hexadecimal digits. Otherwise, the only “bad” incoming character
    this code scans for is the EOF.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一列表中展示的是我对URL解码器的快速且简单的解决方案。它使用了一个修改过的*tohex()*函数，这个函数也检查小写十六进制数字。否则，此代码扫描的唯一“坏”输入字符是EOF。
- en: Listing 5.10 Source code for urldecoder01.c
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.10 urldecoder01.c的源代码
- en: '[PRE42]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: ❶ Modified to add lowercase
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 修改以添加小写
- en: ❷ Checks for the % sign and grabs the next two characters
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 检查%符号并获取下一个两个字符
- en: ❸ Bails on EOF
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在EOF时退出
- en: ❹ Converts the hex digit to an integer
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将十六进制数字转换为整数
- en: ❺ Grabs the next character
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 获取下一个字符
- en: ❻ Outputs the proper character value
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 输出正确的字符值
- en: The program created from the url_decoder01.c source code translates URL encoding,
    dealing with the % values as they’re encountered. Its major problem, however,
    is that it doesn’t know how to deal with improperly formed URL-encoded text. Some
    error checking is in order . . . but I’ve reached my assigned page count for this
    chapter—plus, it’s almost midnight and I’m out of Ritalin.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 从url_decoder01.c源代码创建的程序将URL编码转换为，处理遇到的%值。然而，它的问题在于不知道如何处理格式不正确的URL编码文本。需要进行一些错误检查……但我已经达到了本章分配的页数——而且快到午夜了，我也没有Ritalin了。
- en: Exercise 5.4
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 练习5.4
- en: Your task is to improve the URL decoder shown in listing 5.10\. To do so, ensure
    that an unwanted character doesn’t filter in. When such an offense occurs, exit
    the program with an appropriate error message. Further, check the return value
    from the tohex() function to ensure that it properly reads hexadecimal values.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 你的任务是改进5.10列表中显示的URL解码器。为此，确保不要过滤掉不需要的字符。当发生此类违规行为时，使用适当的错误消息退出程序。此外，检查tohex()函数的返回值，以确保它正确读取十六进制值。
- en: You can find my solution in this book’s online source code repository. The file
    is named urldecoder02.c. Please try this exercise on your own. Don’t cheat. You
    know the drill.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的在线源代码仓库中找到我的解决方案。文件名为urldecoder02.c。请亲自尝试这个练习。不要作弊。您知道该怎么做。
