- en: Chapter 6\. Classes and object-oriented programming
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第6章\. 类和面向对象编程
- en: '|  |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**This chapter covers**'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: '*An easier way to think about classes*'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*关于类的更简单思考方式*'
- en: '*How to use classes to design your programs*'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*如何使用类来设计你的程序*'
- en: '|  |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Until now, we’ve been skimming over one of the fundamental ways you can organize
    your program in Python: the class. Classes and object-oriented programming are
    normally seen as big, scary things that real programmers use to write their programs,
    and you might think you need a lot of theoretical knowledge in order to use them
    properly. Nothing could be further from the truth. In Python, it’s possible to
    ease into classes and object-oriented programming.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在浏览Python中组织程序的一种基本方式：类。类和面向对象编程通常被视为庞大而令人畏惧的事物，真正的程序员使用它们来编写程序，你可能认为你需要大量的理论知识才能正确使用它们。事实远非如此。在Python中，你可以轻松地进入类和面向对象编程。
- en: In this chapter, you’ll start with the code you wrote back in [chapter 2](kindle_split_010.html#ch02)
    to generate caves for Hunt the Wumpus and then see how much easier it is to write
    it using classes. Then you’ll build up from there into a full-fledged adventure
    game along the lines of Adventure or Zork. While you do that, you’ll find out
    all about Python’s classes and how to make the most of them.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将从[第2章](kindle_split_010.html#ch02)中编写的代码开始，生成Hunt the Wumpus的洞穴，然后看看使用类编写它有多容易。然后，你将在此基础上构建一个完整的冒险游戏，类似于Adventure或Zork。在这个过程中，你将了解Python的类以及如何充分利用它们。
- en: What exactly are classes?
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 究竟什么是类？
- en: If you think all the way back to [chapter 2](kindle_split_010.html#ch02), you
    might remember that you had a group of functions that dealt with caves for the
    player and wumpus to live in. There was a function for creating a cave, another
    for linking two caves together to create a tunnel, one to make sure all the caves
    were linked, and so on. When you were writing the program, you dealt with the
    caves entirely through functions. One way to create a class is to identify a group
    of functions like this and make their relationship official.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回想起[第2章](kindle_split_010.html#ch02)，你可能还记得你有一组处理玩家和Wumpus居住的洞穴的函数。有一个用于创建洞穴的函数，另一个用于将两个洞穴连接起来以创建隧道，一个用于确保所有洞穴都连接起来，等等。当你编写程序时，你完全通过函数来处理洞穴。创建类的一种方法就是识别这样的函数组，并正式确定它们之间的关系。
- en: Classes contain data
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 类包含数据
- en: Another way to think about classes is as if a class was a container or a wrapper
    placed around data you want to use in your program. You can group all the data
    needed to perform a particular task, and provide functions to deal with it, particularly
    if the data is complicated, difficult to work with, or needs to be consistent—for
    example, the program that keeps track of the balance of your account at the bank.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种思考类的方式是将类视为一个容器或包装器，它围绕着你程序中想要使用的数据。你可以将执行特定任务所需的所有数据分组，并提供处理这些数据的函数，尤其是如果数据复杂、难以处理或需要一致性时——例如，跟踪你在银行账户余额的程序。
- en: They’re a type of their own
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 它们是它们自己的类型
- en: Classes are similar to something called an *abstract data type*, which is a
    set of data and all the operations that can be performed on that data. You don’t
    have to specify all the possible things you can do with the data inside your class,
    only what’s useful for your particular situation. When designing your class, though,
    it often helps to think of all the possible things you might want to use it for,
    and add those that make sense.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 类类似于称为*抽象数据类型*的东西，它是一组数据以及可以对该数据进行的所有操作。你不必指定你可以在类内部对数据进行的所有可能的事情，只需指定对你特定情况有用的即可。然而，在设计类时，通常有助于考虑你可能想要使用它的所有可能的事情，并添加那些有意义的。
- en: How do they work?
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 它们是如何工作的？
- en: 'Think of classes as a big rubber stamp. Once you’ve created your rubber stamp,
    you can easily stamp out as many pictures as you like. Classes work the same way.
    You generally don’t work directly with a class: you instead work with *instances*
    of that class, which you create by using the original class.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 将类想象成一个大的橡皮图章。一旦你创建了你的橡皮图章，你就可以轻松地印出你喜欢的任何数量的图片。类的工作方式也是一样的。你通常不会直接与类工作：你而是与该类的*实例*一起工作，这些实例是通过使用原始类创建的。
- en: Classes in a program have one advantage—if you need a slightly different picture,
    it’s easy to create a copy of the original class, change it a bit, and work with
    that. [Figure 6.1](#ch06fig01) shows you what the classes in this chapter might
    look like, if they were rubber stamps.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 程序中的类有一个优点——如果你需要稍微不同的图片，很容易创建原始类的副本，稍作修改，然后使用它。[图6.1](#ch06fig01)展示了本章中的类可能看起来像什么，如果它们是橡皮图章的话。
- en: Figure 6.1\. Monsters are like the player, except with horns and a frowny face.
  id: totrans-17
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.1\. 怪物就像玩家一样，只是有角和皱眉的脸。
- en: '![](06fig01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig01.jpg)'
- en: Both the instance and the class itself can have methods for you to call and
    data to access. For the most part, these will be set when you first create an
    instance, but Python also allows you to update them on the fly if you need to,
    even to the point of rebinding methods.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 实例和类本身都可以有你可以调用的方法和可以访问的数据。在大多数情况下，这些将在你首次创建实例时设置，但Python还允许你在需要时即时更新它们，甚至可以重新绑定方法。
- en: '|  |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-21
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Object-oriented programming includes a great deal of terminology— most of it
    apparently designed to confuse the unwary reader. You’ll hear people refer to
    classes, objects, instances, methods, class methods, getters, setters, and so
    on. If you’re unsure what someone means, try to figure out whether they’re talking
    about the rubber stamp or the mark it’s making on your program.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程包含大量的术语——其中大部分显然是为了混淆粗心的读者。你会听到人们提到类、对象、实例、方法、类方法、获取器、设置器等等。如果你不确定某人是什么意思，试着弄清楚他们是在谈论橡皮图章还是它在你的程序上留下的印记。
- en: '|  |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Your first class
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 你的第一个类
- en: The class in the following listing should look familiar, although there are
    some parts that are quite different. It contains the cave list and methods you
    wrote in [chapter 2](kindle_split_010.html#ch02), but updated so they’re contained
    within a class.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下列表中的类应该看起来很熟悉，尽管有一些部分相当不同。它包含了你在[第2章](kindle_split_010.html#ch02)中编写的洞穴列表和方法，但已更新以便它们包含在类中。
- en: Listing 6.1\. An object to store caves
  id: totrans-26
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.1\. 存储洞穴的对象
- en: '![](ch06list1-0.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](ch06list1-0.jpg)'
- en: '![](ch06list1-1.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](ch06list1-1.jpg)'
- en: You start with the syntax Python uses to create a class ![](one.jpg). It’s similar
    to the creation of a function, except that, by convention, a class name starts
    with a capital letter (classes are important, after all). The *object* in brackets
    is the class that this one inherits from—in this case, Python’s generic *object*
    class, because you’re not inheriting anything.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你从Python创建类所使用的语法开始 ![](one.jpg)。它与创建函数的语法类似，但按照惯例，类名以大写字母开头（毕竟类很重要）。括号中的*object*是这个类继承自的类——在这种情况下，Python的通用*object*类，因为你没有继承任何东西。
- en: Most Python classes will have the *__init__* method, which is responsible for
    setting up instances of the class when the class is first created ![](two.jpg).
    Did you notice that you’ve gained a *self* argument in the method? That’s so a
    method can access variables and share state. All the lists you used in [chapter
    2](kindle_split_010.html#ch02) are here, but prefixed with *self* so they refer
    to the variables in the instance.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Python类都将有*__init__*方法，该方法负责在类首次创建时设置类的实例 ![](two.jpg)。你注意到你在方法中获得了*self*参数了吗？这是为了让方法可以访问变量并共享状态。你在[第2章](kindle_split_010.html#ch02)中使用的所有列表都在这里，但以*self*为前缀，以便它们引用实例中的变量。
- en: The functions you used to set up the caves are here, and they’ve received the
    *self* treatment, too ![](three.jpg). Other than that, there aren’t many changes
    to them, which is what you’re expecting because they’re just functions with an
    explicit *self*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你用来设置洞穴的函数在这里，它们也接受了*self*处理 ![](three.jpg)。除此之外，它们没有太多变化，这正是你所期望的，因为它们只是带有显式*self*的函数。
- en: Once you’ve set up your class, you create an instance of it and call its *print_caves()*
    method to test it out ![](four.jpg). Python runs the *__init__* method of the
    class, which in turn calls *setup_caves()* and *link_caves()* and creates your
    cave network, which you can see from the results of *caves.print_caves()*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你设置了你的类，你就创建它的一个实例，并调用它的*print_caves()*方法来测试它 ![](four.jpg)。Python运行类的*__init__*方法，然后它依次调用*setup_caves()*和*link_caves()*，创建你的洞穴网络，你可以从*caves.print_caves()*的结果中看到。
- en: '![](f0185-01.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](f0185-01.jpg)'
- en: What have you gained from putting all the functions inside a class? The main
    benefit is that all the details of the caves are contained within the instance
    you’ve created. You could now create extra cave systems at the same time and not
    have to worry about them conflicting with each other. From here, you can also
    extend the class—perhaps including the atmospheric cave names and other functions
    I’ve excluded—or adding a method to extend the cave system.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有功能放入类中，你从中获得了什么？主要的好处是所有洞穴的细节都包含在你创建的实例中。你现在可以同时创建额外的洞穴系统，而不用担心它们之间会相互冲突。从这里，你也可以扩展类——也许包括大气洞穴名称和其他我排除的功能——或者添加一个方法来扩展洞穴系统。
- en: '|  |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Classes are another divide-and-conquer mechanism you can use in your programs.
    Once you’ve created an instance, you don’t need to think about why it works, just
    about what you can use it for in your code.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 类是你在程序中可以使用的另一种分而治之的机制。一旦创建了实例，你不需要考虑它为什么工作，只需要考虑你在代码中可以用它做什么。
- en: '|  |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: There’s one problem with your new *Caves* class, though. Although you’ve created
    the class and it works well, it’s still not an object-oriented design. You’ve
    just taken your existing functional design and pushed it into a class. If, in
    the future, you wanted to add extra functionality—such as having treasure to pick
    up within the caves, more monsters, or other features—they’d be hard to add. Much
    in the same way that adding functions changed the design of your program back
    in [chapter 2](kindle_split_010.html#ch02), using classes properly will change
    the emphasis of your design now.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你创建了新的 *Caves* 类并且它工作得很好，但它仍然不是一个面向对象的设计。你只是将现有的功能设计推入了一个类中。如果你将来想要添加额外的功能——比如在洞穴中捡起宝藏、更多怪物或其他特性——它们将很难添加。这与在第二章中添加函数改变程序设计的方式非常相似，正确地使用类现在将改变你设计的重点。
- en: Object-oriented design
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 面向对象设计
- en: One of the reasons many people prefer object-oriented programs is that objects
    tend to map well onto the things you deal with in the real world and make it easier
    for you to think about how they interact when you’re developing your program.
    If you were writing a program to manage your finances, you might create classes
    called *Account*, *Expense*, *Income*, and *Transaction*. If you were writing
    a program to control a factory, you could have classes called *Component*, *ConveyorBelt*,
    *Assembly* (as in, multiple components joined together), and *AssemblyLine*.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人更喜欢面向对象程序的一个原因是，对象往往很好地映射到你在现实世界中处理的事物，并且使你在开发程序时更容易思考它们如何交互。如果你在编写一个管理财务的程序，你可能会创建名为
    *Account*、*Expense*、*Income* 和 *Transaction* 的类。如果你在编写一个控制工厂的程序，你可能有名为 *Component*、*ConveyorBelt*、*Assembly*（即多个组件组合在一起）和
    *AssemblyLine* 的类。
- en: Let’s take a step back and think about the adventure game a bit more. What sorts
    of things will it have? Well, if you take a traditional approach, the player will
    be an intrepid adventurer, searching for treasure, fame, and glory in an underground
    dungeon or cave system filled to the ceiling with monsters. The following figure
    shows a “back of the envelope” sketch of what your game might look like, the sort
    of drawing you might use to explain it to a friend.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们退一步，更深入地思考一下冒险游戏。它会有哪些内容？好吧，如果你采取传统的方法，玩家将是一个勇敢的冒险家，在一个充满怪物、天花板堆满宝藏、名声和荣耀的地下地牢或洞穴系统中寻找宝藏。以下图显示了你的游戏可能的样子，这种草图你可能用来向朋友解释。
- en: 'The fundamental feature you should be addressing is the cave, rather than the
    cave system as a whole. The mechanics of the lists and functions may have tricked
    you into thinking the cave system was the important part, but you can get a much
    cleaner design by thinking at the right level: of individual caves and what’s
    inside them. The following listing shows how the caves could be written. You should
    put it into a file called caves.py; otherwise some of the code later in this chapter
    won’t work.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该解决的基本特性是洞穴，而不是整个洞穴系统。列表和功能的机制可能让你误以为洞穴系统是重要的部分，但通过在正确的层面上思考：单个洞穴及其内部的内容，你可以得到一个更干净的设计。以下列表显示了洞穴应该如何编写。你应该将其放入名为
    caves.py 的文件中；否则，本章后面的一些代码可能无法正常工作。
- en: Figure 6.2\. A basic sketch of your game
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.2\. 你游戏的基本草图
- en: '![](f0187-01.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![f0187-01.jpg](f0187-01.jpg)'
- en: Listing 6.2\. A more object-oriented design
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.2\. 更面向对象的设计
- en: '![](ch06list2-0.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![ch06list2-0.jpg](ch06list2-0.jpg)'
- en: '![](ch06list2-1.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![游戏草图](ch06list2-1.jpg)'
- en: You start with the setup for the new *Cave* object ![](one.jpg). Rather than
    set up one list for cave names, another for linking, and a third to tell whether
    a cave’s been visited or not, you store it all within the object itself. When
    you build lists of caves later, you can easily filter by these attributes. You
    add a *self.here* list to store any other objects (such as the player, monsters,
    and treasure) that might be in the cave, and also a *description* string, which
    will describe the cave when the player enters it. You’ll ignore these two new
    values for now.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你从为新*洞穴*对象设置初始状态开始 ![图片](one.jpg)。而不是为洞穴名称设置一个列表，为链接设置另一个列表，以及一个用于判断洞穴是否被访问过的列表，你将所有这些信息都存储在对象本身中。当你稍后构建洞穴列表时，你可以很容易地通过这些属性进行筛选。你添加一个*self.here*列表来存储可能存在于洞穴中的任何其他对象（例如玩家、怪物和宝藏），以及一个*description*字符串，当玩家进入洞穴时，这个字符串将描述洞穴。你现在可以忽略这两个新值。
- en: 'Because you can easily tell what a cave is linked to ![](two.jpg), adding a
    tunnel to another cave is easy: add them into the list of tunnels and add *self*
    (*self* is the current *Cave* instance) into the list of tunnels. Notice, too,
    how you’re dealing with the caves at the instance level, which makes your program
    a lot clearer.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你可以很容易地看出一个洞穴连接到了什么 ![图片](two.jpg)，所以向另一个洞穴添加隧道很容易：将它们添加到隧道列表中，并将*self*（*self*是当前的*Cave*实例）添加到隧道列表中。注意，你也正在处理实例级别的洞穴，这使得你的程序更加清晰。
- en: One last thing you’ll do is add a *__repr__* method to your class ![](three.jpg).
    The one that’s built in to the base *object* is a little unreadable (it will be
    something like *<__main__.Cave object at 0x00B38EF0>*), and this makes your program’s
    output look much nicer when you have to print out a cave.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你最后要做的就是在你的类中添加一个*__repr__*方法 ![图片](three.jpg)。内置到基类*object*中的那个有点难以阅读（它可能看起来像*<__main__.Cave
    object at 0x00B38EF0>*），这使得当你需要打印出洞穴时，程序输出看起来更美观。
- en: '![](f0188-01.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](f0188-01.jpg)'
- en: Now all you need to do is to figure out how to link the caves. Borrowing the
    list of cave names from [chapter 2](kindle_split_010.html#ch02), you can assign
    each one to a new cave instance, link that instance to an existing cave, and then
    add it into the *caves* list ![](four.jpg). The only even slightly tricky bit
    is how you find caves to link to. But you can easily figure that out by checking
    the length of each cave’s tunnel list inside a list comprehension. Also, notice
    that Python doesn’t constrain how you solve a problem—you’re free to use functions,
    classes, and bare code wherever you need to.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你需要做的就是弄清楚如何连接洞穴。借用[第2章](kindle_split_010.html#ch02)中的洞穴名称列表，你可以将每个名称分配给一个新的洞穴实例，将该实例链接到现有的洞穴，并将其添加到*caves*列表
    ![图片](four.jpg)。唯一稍微有点棘手的地方是如何找到要链接的洞穴。但你可以通过检查列表推导式中每个洞穴隧道列表的长度来轻松地解决这个问题。此外，请注意，Python不会限制你解决问题的方法——你可以在需要的地方自由使用函数、类和裸代码。
- en: If you’re not convinced that it works, ![](five.jpg) print out the complete
    cave list.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不相信它有效，![图片](five.jpg) 打印出完整的洞穴列表。
- en: 'The main thing to notice is how much of [listing 6.1](#ch06list1) is replaced.
    The original version of *Caves* had six different methods calling each other;
    you’ve replaced that with one class and an external function. As you learned in
    [chapter 2](kindle_split_010.html#ch02), shorter, simpler code is often a sign
    that you’re on the right track, and an object-oriented design maps well onto your
    adventure game. Let’s move on and tackle the next part of your program: handling
    input from the player.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 主要需要注意的是[列表6.1](#ch06list1)中有多少被替换了。*Caves*的原始版本有六个不同的方法相互调用；你用一个新的类和一个外部函数替换了它。正如你在[第2章](kindle_split_010.html#ch02)中学到的，更短、更简单的代码通常意味着你正在正确的道路上，面向对象的设计很好地映射到你的冒险游戏中。让我们继续前进，解决程序的下一段：处理玩家的输入。
- en: Player input
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 玩家输入
- en: Most adventure games are played by typing instructions at a prompt, things like
    GO NORTH, GET SWORD, KILL MONSTER, and GET TREASURE. The game then responds with
    the results of your action, as well as a description of the room you’re in and
    things that are in the room. You’ll take the same approach and use some of the
    properties of objects to make your program easy to extend. Bear in mind that you’ll
    also want to make your code easy to test, so you’ll break out your user input
    into a separate function.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数冒险游戏是通过在提示符中输入指令来玩的，比如GO NORTH（向北走）、GET SWORD（拿剑）、KILL MONSTER（杀怪物）和GET TREASURE（拿宝藏）。游戏随后会响应你的动作结果，以及你所在房间的描述和房间中的物品。你将采取相同的方法，并使用一些对象的属性来使你的程序易于扩展。记住，你还将想要使你的代码易于测试，所以你会将用户输入分离到一个单独的函数中。
- en: '![](f0189-01.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](f0189-01.jpg)'
- en: 'First steps: verbing nouns'
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第一步：将名词动词化
- en: You’ll start by trying to find a good way to write the “verb noun” interface
    into your class structure. Normally, because an object will be a noun, and the
    methods on that object will be verbs, a command like GET SWORD should try to find
    the sword object in the current room and call its *get* interface. Designing this
    way means that, rather than having one massive *Playe*r class that knows how to
    do everything possible in the game, you can instead have more, smaller classes,
    which are easier to understand (and change and extend).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你将从尝试找到一种好方法将“动词名词”接口写入你的类结构开始。通常，因为一个对象将是一个名词，而该对象上的方法将是动词，所以像 GET SWORD 这样的命令应该尝试在当前房间中找到剑对象，并调用其
    *get* 接口。这样设计意味着，而不是有一个知道游戏中所有可能操作的大 *Player* 类，你可以有更多、更小的类，这些类更容易理解（以及修改和扩展）。
- en: 'The following listing has the code for the core of your application: the player
    object. It’s responsible for reading input from the player, as well as finding
    the right object to call to interpret the command. You put it into a file called
    player.py.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表包含应用程序核心的代码：玩家对象。它负责从玩家那里读取输入，以及找到正确的对象来解释命令。你将它放入一个名为 player.py 的文件中。
- en: Listing 6.3\. A `Player` object
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.3\. 一个 `Player` 对象
- en: '![](ch06list3-0.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](ch06list3-0.jpg)'
- en: '![](ch06list3-1.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](ch06list3-1.jpg)'
- en: The variables you’ll initially need within your *Player* class are pretty straightforward
    ![](one.jpg). You add them to a location and tell the game they’re playing.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你在 *Player* 类中最初需要的变量相当直接 ![](one.jpg)。你将它们添加到一个位置，并告诉游戏他们正在玩游戏。
- en: You split up the command here and make sure there’s always something in the
    verb and noun variables ![](two.jpg). You’re using *shlex.split()* to split your
    command because it handles quotes much better than the normal split. If, for example,
    the player types GET “GOLD KEY,” then *shlex.split()* will read GOLD KEY as one
    part. You join anything after the verb and assume it’s part of the noun, so GET
    GOLD KEY will work, too.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这里拆分命令，并确保动词和名词变量中始终有内容 ![](two.jpg)。你使用 *shlex.split()* 来拆分你的命令，因为它比正常的拆分更好地处理引号。例如，如果玩家输入
    GET “GOLD KEY”，那么 *shlex.split()* 将 GOLD KEY 读取为一个部分。你将动词之后的所有内容连接起来，并假设它是名词的一部分，所以
    GET GOLD KEY 也会工作。
- en: Once you have your command in an easy-to-process format, you try to find a method
    to call ![](three.jpg). If the method finder returns *None*, it means there wasn’t
    a method to handle the command, and you return an error (if you’ve ever played
    an adventure game, this will be all too familiar).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了易于处理的命令格式，你尝试找到一个可以调用的方法 ![](three.jpg)。如果方法查找器返回 *None*，这意味着没有方法来处理命令，你返回一个错误（如果你曾经玩过冒险游戏，这会非常熟悉）。
- en: When you have your command, you try to find a method to handle it ![](four.jpg).
    If you have a noun, you look for an object that matches it—for example, the SWORD
    in GET SWORD—and see if it can respond. The *getattr()* function is a good way
    to do this—it looks for a class attribute or method whose name is set in a variable.
    If it can’t find it, then it passes the command through to either the location
    or the player (this will help you provide a better interface in the next few sections).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有了你的命令后，你尝试找到一个处理它的方法 ![](four.jpg)。如果你有一个名词，你寻找一个与它匹配的对象——例如，GET SWORD 中的
    SWORD——并查看它是否可以响应。*getattr()* 函数是这样做的好方法——它寻找一个在变量中设置的名称的类属性或方法。如果找不到，那么它将命令传递给位置或玩家（这将在下一节中帮助你提供更好的接口）。
- en: If the player hasn’t given you a noun, then it might be a more generic command,
    like LOOK or QUIT, so you look for it in your current location and the *Player*
    object ![](five.jpg). If neither of those works, then you haven’t found one, and
    you “fall off” the end of the method. This means you return *None*, which results
    in an error.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家没有给出名词，那么它可能是一个更通用的命令，如 LOOK 或 QUIT，所以你在当前位置和 *Player* 对象中寻找它 ![](five.jpg)。如果这两个都不起作用，那么你没有找到它，并且你“掉落”到方法的末尾。这意味着你返回
    *None*，这会导致错误。
- en: You add two basic commands ![](six.jpg) to the *Player*, LOOK and QUIT, so you
    can get a feel for how they’ll work in the finished game. You’ll need to add an
    empty actions list to the *Cave* class, too; otherwise, this will raise an error
    if the *Player* instance can’t handle a command.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你为 *Player* 添加了两个基本命令 ![](six.jpg)，即 LOOK 和 QUIT，这样你就可以感受到它们在完成的游戏中的工作方式。你还需要为
    *Cave* 类添加一个空的动作列表；否则，如果 *Player* 实例无法处理一个命令，这将引发错误。
- en: Now that you have a player, you need to be able to read input from the player
    and use that input to run the game. A sample framework is shown in the following
    listing. You make a simple cave, put the player into it, and then loop, reading
    input until the player is finished playing. Later, you’ll probably incorporate
    this into a *Game* object, but because Python is flexible, you can leave it as
    a function while you write and test the other classes.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了玩家，你需要能够从玩家那里读取输入，并使用该输入来运行游戏。以下是一个示例框架。你创建一个简单的洞穴，将玩家放入其中，然后循环读取输入，直到玩家完成游戏。稍后，你可能会将其集成到*Game*对象中，但鉴于Python的灵活性，你可以在编写和测试其他类时将其保留为函数。
- en: Listing 6.4\. Running your `Player` class
  id: totrans-72
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.4\. 运行你的`Player`类
- en: '![](06list04.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](06list04.jpg)'
- en: Your *Player* class needs a location to work properly, so you set up a test
    cave here and put the player into it ![](one.jpg). A simple description and name
    is all you need to get going.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你的*Player*类需要一个位置才能正常工作，所以你在这里设置了一个测试洞穴，并将玩家放入其中![图片](one.jpg)。一个简单的描述和名称就足够开始使用了。
- en: Once you’ve done that, you get input from the player and pass it to the *process_input()*
    method, which will run your code and return the results as a list of strings ![](two.jpg).
    You then print them one to a line using the *join()* method of the *'\n'* string.
    When the player has issued the quit command, the *player.playing* variable will
    be false, and you stop the program.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你这样做，你从玩家那里获取输入，并将其传递给*process_input()*方法，该方法将运行你的代码，并以字符串列表的形式返回结果![图片](two.jpg)。然后你使用*'\n'*字符串的*join()*方法将它们逐行打印出来。当玩家发出退出命令时，*player.playing*变量将为false，你将停止程序。
- en: '![](f0193-01.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](f0193-01.jpg)'
- en: If you run the adventure program now, you should be able to give it commands
    such as LOOK and QUIT. It’s simple stuff, but you’ll see how to extend the interface
    in the next section.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行冒险程序，你应该能够给出诸如LOOK和QUIT之类的命令。这很简单，但你将在下一节中看到如何扩展界面。
- en: Treasure!
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 宝藏！
- en: Let’s start adding some more exciting things to the game. First, you’d like
    to be able to give the player some equipment or treasure early on, to draw them
    into the game and get them involved. It’s not an adventure without treasure or
    a sword, so let’s add those first. Before you do, though, you’ll need to think
    a bit more about your design.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从游戏中添加一些更令人兴奋的东西开始。首先，你可能希望能够在游戏初期就给玩家一些装备或宝藏，以吸引他们进入游戏并让他们参与其中。没有宝藏或剑的冒险不是真正的冒险，所以让我们先添加这些。不过，在你这样做之前，你需要更多地考虑你的设计。
- en: Where should your methods go?
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 方法应该放在哪里？
- en: You’ll obviously need to interact with your items, which means you’ll at least
    want to be able to do things like GET SWORD, LOOK SWORD, and DROP SWORD. With
    your current way of doing things, that means there will need to be a method somewhere
    to handle GET, LOOK, and DROP.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，你需要与你的物品进行交互，这意味着你至少希望能够执行诸如GET SWORD、LOOK SWORD和DROP SWORD之类的操作。按照你目前的方式做事，这意味着你需要在某个地方有一个方法来处理GET、LOOK和DROP。
- en: One option is to store it in the *Player* class—after all, it’s the player doing
    the getting and dropping. It’s tempting to think along these lines, but when doing
    any object-oriented programming, you’ll want to delegate as much responsibility
    as possible. For example, later on you’ll probably want to add objects that the
    player can’t pick up, like a heavy chest or a statue. That’s fine; add a check
    to see if the object has an *immovable* flag set. What if the player can pick
    up the chest if they have the gilded girdle of strength? Hmm, another check. You
    can see where this is going—by the time you finish the game, you might have 5
    or 6 (or 20) conditions in the *get()* method on your player.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一个选择是将它们存储在*Player*类中——毕竟，是玩家在进行获取和丢弃操作。沿着这些思路思考是很有吸引力的，但在进行任何面向对象的编程时，你希望尽可能多地委派责任。例如，稍后你可能希望添加玩家无法捡起的对象，比如一个沉重的箱子或一座雕像。这没问题；添加一个检查以查看对象是否设置了*不可移动*标志。如果玩家有力量腰带，他们能捡起箱子吗？嗯，另一个检查。你可以看到这是怎么回事——等你完成游戏时，你可能在玩家的*get()*方法中可能有5个或6个（或20个）条件。
- en: '|  |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-84
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Class design can be a tricky thing when you’re first starting out. The main
    thing to remember is that experience counts, so you’ll get better with practice.
    Also, don’t forget that you can experiment with different designs and pick the
    best one.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当你刚开始时，类设计可能是一件棘手的事情。要记住的主要事情是经验很重要，所以你会随着实践而变得更好。此外，别忘了你可以尝试不同的设计，并选择最好的一个。
- en: '|  |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: A better way is to make the objects themselves responsible for judging whether
    they can be picked up. A chest “knows” it’s heavy, and can check to make sure
    the player has the right items in their inventory before allowing itself to be
    picked up. It sounds odd, but the *Player* object shouldn’t be responsible for
    how heavy objects are or how monsters fight, and adding things like that to the
    *Player* object will make it too complicated. Let’s see how you’d program some
    objects that can be looked at; then, you’ll modify them so they can be picked
    up.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是让对象自己判断它们是否可以被捡起。一个箱子“知道”它很重，并且在允许自己被捡起之前可以检查玩家是否拥有正确的物品在他们的背包中。这听起来很奇怪，但*玩家*对象不应该负责物体的重量或怪物如何战斗，将这类东西添加到*玩家*对象会使它过于复杂。让我们看看如何编写一些可以被查看的对象；然后，你将修改它们以便它们可以被捡起。
- en: Listing 6.5\. An object that can be looked at
  id: totrans-88
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.5\. 可以被查看的对象
- en: '[PRE0]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The things the *Item* needs to know are pretty much the same as for the *Player*
    and *Cave* objects: what its name is and where it is. You can feed all those in
    when you create an *Item* instance.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*物品*需要知道的事情基本上与*玩家*和*洞穴*对象相同：它的名字和位置。你可以在创建*物品*实例时提供所有这些信息。'
- en: 'Initially, your item responds to one command: LOOK. When the player issues
    a LOOK ITEM command with the item’s name as a noun, this is the method that will
    be called; all it does is return the item’s description.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，你的物品只响应一个命令：LOOK。当玩家发出带有物品名称作为名词的LOOK ITEM命令时，这个方法将被调用；它所做的只是返回物品的描述。
- en: Finding the treasure
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 寻找宝藏
- en: Additionally, you’ll want to modify the description of the cave so the player
    knows what items are in a particular location. While you’re at it, you’ll follow
    the lead set so far and move the *look()* method from the *Player* class; delete
    the method from *Player*, and add this one into the *Cave* class.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还需要修改洞穴的描述，让玩家知道特定位置有什么物品。在你做这件事的同时，你将遵循迄今为止设定的指导原则，将*look()*方法从*玩家*类中移除；从*玩家*类中删除该方法，并将其添加到*洞穴*类中。
- en: '![](f0195-01.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](f0195-01.jpg)'
- en: Listing 6.6\. Modifying the `look()` command
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.6\. 修改`look()`命令
- en: '![](06list06_alt.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](06list06_alt.jpg)'
- en: The main change to this method is to list all the items in the location and
    place them under the description ![](one.jpg). Without this, the player won’t
    know there’s a sword in the cave, unless they happen to guess there might be.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的主要更改是列出位置中的所有物品并将它们放在描述下 ![one.jpg]。没有这个，玩家不会知道洞穴里有一把剑，除非他们偶然猜到可能存在。
- en: This function will also be called if the player tries to refer to something
    that doesn’t exist (such as LOOK AARDVARK). If there’s no aardvark in the room,
    you need to return an error ![](two.jpg).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家试图引用不存在的东西（例如LOOK AARDVARK），此函数也将被调用。如果房间里没有土拨鼠，你需要返回一个错误 ![two.jpg]。
- en: '![](f0195-02.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](f0195-02.jpg)'
- en: Don’t forget to update the actions the *Cave* object can handle ![](three.jpg)
    and remove *'look'* from the *Player* class—otherwise, it will continue to try
    to handle the LOOK command.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记更新*洞穴*对象可以处理的行为 ![three.jpg] 并从*玩家*类中移除*look*——否则，它将继续尝试处理LOOK命令。
- en: Listing 6.7\. Updating your setup
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.7\. 更新你的设置
- en: '[PRE1]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Add items into your adventure! Set their name, description, and location, and
    the *Item* object will take care of the rest.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 将物品添加到你的冒险中！设置它们的名称、描述和位置，*物品*对象将处理其余的事情。
- en: If you run the adventure now, you should be able to look at your treasure and
    a shiny sword, but you can’t reach them. So ... tantalizingly ... close ...
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行这个冒险游戏，你应该能够查看你的宝藏和一把闪亮的剑，但你无法触及它们。所以……诱人地……很近……
- en: Picking up the treasure
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 拿起宝藏
- en: 'All you need now is for the objects to respond to being picked up. You need
    to make two updates: the first is to the objects, to give them *get()* and *drop()*
    methods, and the second is to update the *Player* class so it can carry things.
    The next listing shows how you can add those commands to the game.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你需要的只是让对象能够被捡起。你需要进行两个更新：第一个是更新对象，给它们提供*get()*和*drop()*方法，第二个是更新*玩家*类，使其能够携带物品。下一个列表显示了如何将这些命令添加到游戏中。
- en: Listing 6.8\. Items that will let themselves be picked up
  id: totrans-107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.8\. 可以被捡起的物品
- en: '![](06list08_alt.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](06list08_alt.jpg)'
- en: The *get()* method itself is straightforward ![](one.jpg). The object needs
    to remove itself from the *here* array in the current location and put itself
    into the player’s inventory (you’ll make that list in a minute) and set its current
    location. Once you’ve done that, you return a message to let the player know.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*get()*方法本身很简单 ![图片](one.jpg)。对象需要从当前位置的*here*数组中移除自己，并将其放入玩家的库存（你将在下一分钟创建这个列表）并设置其当前位置。完成这些后，你返回一条消息，让玩家知道。'
- en: '![](f0197-01.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片](f0197-01.jpg)'
- en: If you run the previous code without this check ![](two.jpg) it will work fine;
    but if the player tries to pick up the item again, your program will crash, because
    it can’t remove an item from a list if it isn’t there.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在没有这个检查的情况下运行之前的代码 ![图片](two.jpg)，它将正常工作；但如果玩家再次尝试拾取物品，你的程序将会崩溃，因为如果物品不在列表中，你无法从列表中移除它。
- en: The *drop()* method is pretty much the same as the *get()* method, only in reverse
    ![](three.jpg). Just like the previous *get()* method, you need to check that
    the object is in the player’s inventory before you move it back to the location
    you’re in.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*drop()*方法基本上与*get()*方法相同，只是方向相反 ![图片](three.jpg)。就像之前的*get()*方法一样，在将物品移回你所在的位置之前，你需要检查该物品是否在玩家的库存中。'
- en: The next listing updates the *Player* class so it can hold objects, adds some
    commands to tell you what you’re carrying, and outputs error messages. Let’s also
    look in the inventory when trying to find handlers for commands.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表更新了*Player*类，使其能够持有物品，添加了一些命令来告诉你你携带了什么，并输出错误信息。让我们在尝试查找命令处理程序时也查看库存。
- en: Listing 6.9\. Updates to the `Player` class
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.9\. `Player`类的更新
- en: '![](ch06list9-0.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch06list9-0.jpg)'
- en: '![](ch06list9-1.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch06list9-1.jpg)'
- en: To start with, the player needs to be able to carry things around with an inventory
    ![](one.jpg). The easiest option is to add a list to your class. When the player
    picks up objects, they’ll be appended to this list.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，玩家需要能够携带物品，这需要一个库存 ![图片](one.jpg)。最简单的选项是将一个列表添加到你的类中。当玩家拾取物品时，它们将被添加到这个列表中。
- en: '![](f0198-01.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图片](f0198-01.jpg)'
- en: These error handlers ![](two.jpg) are similar to the error handler you wrote
    for the *Cave* class. If you try to get something that’s not in the current location,
    then these methods will be called to handle the GET and DROP commands.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这些错误处理程序 ![图片](two.jpg) 与你为*Cave*类编写的错误处理程序类似。如果你尝试获取当前位置中没有的东西，那么这些方法将被调用以处理GET和DROP命令。
- en: Players should be able to remember what they’ve found so far, so ![](three.jpg)
    is a command that will list everything they’re carrying.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家应该能够记住他们迄今为止找到的东西，所以 ![图片](three.jpg) 是一个列出他们所携带一切的命令。
- en: The final change is to check the items in your inventory when looking for handlers
    ![](four.jpg). This way, players can LOOK at or DROP things in their inventory.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的更改是在查找处理程序时检查你的库存 ![图片](four.jpg)。这样，玩家就可以查看或丢弃他们库存中的物品。
- en: Now you can pick up the sword and shiny coin, as well as look at them. You can
    also put them back down again (although that’s much less adventurous). Your trusty
    sword and first piece of treasure in hand, it’s time to venture further into the
    caves.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以捡起剑和闪亮的硬币，也可以查看它们。你还可以将它们放回原处（尽管这不太像冒险）。手握你信任的剑和第一件宝藏，是时候深入洞穴了。
- en: Further into the caves
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 深入洞穴
- en: An adventure isn’t an adventure without some sort of exploration. In most games,
    you move around by issuing commands like GO NORTH, or just NORTH or N for short.
    As you travel, the game will update the descriptions to tell you about the area
    you’ve just moved through. You’ll set up your movement commands in the same way
    you set up the other commands, but you’ll add some shortcuts, too, so typing your
    movement is easier.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一个冒险如果没有某种形式的探索就不算冒险。在大多数游戏中，你可以通过发出像GO NORTH（向北走）或简写为N这样的命令来移动。当你旅行时，游戏将更新描述来告诉你你刚刚移动过的区域。你将以设置其他命令相同的方式设置你的移动命令，但也会添加一些快捷键，这样输入移动命令会更简单。
- en: '![](f0199-01.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](f0199-01.jpg)'
- en: First, let’s look at how you add the directions themselves into the *Cave* class.
    Then, you’ll create the commands that let your player move around.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看如何将方向本身添加到*Cave*类中。然后，你将创建允许玩家移动的命令。
- en: Listing 6.10\. Adding movement to the `Cave` class
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.10\. 向`Cave`类添加移动功能
- en: '![](ch06list10-0.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch06list10-0.jpg)'
- en: '![](ch06list10-1.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch06list10-1.jpg)'
- en: The first part of the changes adds a list of valid directions into the *Cave*
    class ![](one.jpg), so you know all the directions you can travel. You can also
    use this to find the opposite direction (you’ll need that in a minute).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 变更的第一部分将有效方向列表添加到*Cave*类中![one.jpg]，这样你知道可以旅行的所有方向。你也可以用这个来找到相反的方向（你很快就会需要它）。
- en: '![](f0200-01.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![f0200-01.jpg]'
- en: When you’re creating each cave, you’ll need to set up the basic data structure
    you’ll use to store the caves that can be reached in each direction ![](two.jpg).
    For now, they’re all *None*, which means there’s no other cave that way.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建每个洞穴时，你需要设置基本的数据结构，你将使用它来存储每个方向可以到达的洞穴![two.jpg]。目前，它们都是*None*，这意味着那个方向没有其他洞穴。
- en: '![](three.jpg) is a convenience method to list the directions of all the exits
    for a particular cave. It’s pretty simple—a list comprehension over *self.tunnels*—but
    it makes your code much easier to follow when you can access *cave.exits()*. Don’t
    let the order the functions are written in fool you—the code for this method was
    pulled from *look* when that started to look ugly.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![three.jpg]是一个方便的方法，用于列出特定洞穴所有出口的方向。它很简单——一个通过*self.tunnels*的列表推导——但它使得当你可以访问*cave.exits()*时，你的代码更容易理解。不要被函数编写的顺序所迷惑——这个方法的方法代码是从*look*中提取出来的，因为那时它开始看起来很丑陋。'
- en: Players will want to know which way they can go from cave to cave, so ![](four.jpg)
    lists all the valid exits. If there aren’t any, then you let them know that, too.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家会想知道他们可以从洞穴到洞穴走哪个方向，所以![four.jpg]列出了所有有效的出口。如果没有，你也让他们知道这一点。
- en: 'You also need a way to create tunnels between your caves. Linking one way is
    easy: you put the cave in *self.tunnels* in the right direction. But you’d like
    your tunnels to be two-way, so you look up the reverse direction in the list and
    add a link to yourself from the target cave ![](five.jpg).'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要一种方法来创建洞穴之间的隧道。单向链接很简单：你将洞穴放入*self.tunnels*中正确的方向。但你想让你的隧道是双向的，所以你在列表中查找相反的方向，并从目标洞穴添加一个链接到你自己![five.jpg]。
- en: 'If this method looked a little strange, it’s because you added some exceptions
    to catch error cases when linking tunnels ![](six.jpg). The *raise()* command
    will create errors similar to the ones you’ve been seeing so far: for example,
    when you’ve mistyped something. In this case you’re effectively creating your
    own type of object, much like an integer or a string, so it’s much better to behave
    like one and raise an exception rather than print an error or ignore the bad input.
    You’ll be crashing close to the source of the problem and giving a clear error
    message, which makes it much easier to troubleshoot your programs.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个方法看起来有点奇怪，那是因为你添加了一些异常来捕获连接隧道时的错误情况![six.jpg]。*raise()*命令将创建类似于你迄今为止看到的错误：例如，当你输入错误时。在这种情况下，你实际上创建了自己的对象类型，就像整数或字符串一样，所以表现得像一个是更好的选择，抛出异常而不是打印错误或忽略不良输入。你将接近问题的源头崩溃，并给出一个清晰的错误消息，这使得调试你的程序变得容易得多。
- en: '|  |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: When you’re designing classes like *Cave* (which are effectively library classes),
    it’s always a good idea to catch cases like this and raise an exception where
    possible. That way, when you’re using the class later, it’s obvious when you’ve
    made a mistake.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当你设计像*Cave*这样的类（它们实际上是库类）时，总是捕捉这类情况并尽可能抛出异常的好主意。这样，当你以后使用这个类时，当你犯错时，就会很明显。
- en: '|  |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Now you have a *Cave* class that can store directions and links to other caves,
    as well as describe those directions to the player. Let’s now add some commands
    to let the player move between caves, as shown in the following listing.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有一个可以存储方向和其他洞穴链接的*Cave*类，以及向玩家描述这些方向。现在让我们添加一些命令，让玩家可以在洞穴之间移动，如下所示。
- en: Listing 6.11\. Commands to move between caves
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.11\. 在洞穴之间移动的命令
- en: '![](ch06list11-0.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![ch06list11-0.jpg]'
- en: '![](ch06list11-1.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![ch06list11-1.jpg]'
- en: The basic command you’re adding is called GO (as in, GO NORTH). First, you need
    to check the direction the player entered, to make sure it’s valid and that there’s
    a cave in that direction ![](one.jpg).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你添加的基本命令被称为GO（例如，GO NORTH）。首先，你需要检查玩家输入的方向，确保它是有效的，并且那个方向有洞穴![one.jpg]。
- en: 'Once you’re sure it’s valid, you can go ahead and move the player ![](two.jpg).
    The mechanics are straightforward: remove the player from the current cave, add
    the player to the new one, and update the player’s location. You also append the
    new cave’s description onto the results of the command, to make life easier on
    the player and save wear and tear on their keyboard.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你确定它是有效的，你就可以继续移动玩家 ![two.jpg]。机制很简单：从当前洞穴中移除玩家，将玩家添加到新的洞穴中，并更新玩家的位置。你还把新洞穴的描述附加到命令的结果上，这样就可以让玩家生活更轻松，并减少他们键盘的磨损。
- en: You can also make life easier by providing shortcuts for common commands ![](three.jpg).
    Typing GO NORTH over and over again gets tedious, so you allow the player to use
    NORTH or just N, and similar for each of the other cardinal directions. Behind
    the scenes, these commands call the original *go()* method, so there’s no difference
    in how they behave.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过提供常用命令的快捷方式来使生活更轻松 ![three.jpg]。反复输入 GO NORTH 会变得很繁琐，所以你允许玩家使用 NORTH 或只是
    N，以及其他四个基本方向的类似操作。幕后，这些命令调用原始的 *go()* 方法，所以它们的行为没有区别。
- en: The last thing you need to do is update the list of valid actions for the *Cave*
    class ![](four.jpg). You also add a shortcut for the *look()* command while you’re
    at it.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要更新 *Cave* 类的有效动作列表 ![four.jpg]。同时，你也可以为 *look()* 命令添加一个快捷方式。
- en: There, you’re done. Notice how you’ve split the functionality between the player
    and the location they’re in? This is a normal feature of good object-oriented
    design, where the objects have well-separated responsibilities. In this case,
    the *cave* object is responsible for keeping track of its exits and where they
    go, and the *player* object can use that information from inside its *go()* command.
    If, later, something else might make use of directions, you don’t have to extract
    the code from the *player* object, or wherever you’ve hidden it, to make the new
    functionality work.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在那里，你就完成了。注意你如何将功能在玩家和他们所在的位置之间分割？这是良好面向对象设计的一个正常特性，其中对象有很好的分离责任。在这种情况下，*洞穴*
    对象负责跟踪其出口和它们去往的地方，而 *玩家* 对象可以在其 *go()* 命令内部使用这些信息。如果以后其他东西可能需要使用方向，你不需要从 *玩家*
    对象或你隐藏它的任何地方提取代码来使新的功能工作。
- en: The player still needs somewhere to move to, though, so the next listing extends
    the previous cave-generating function to help out.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，玩家仍然需要某个地方可以移动，所以下一个列表扩展了之前的洞穴生成函数以提供帮助。
- en: '![](f0203-01.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![f0203-01.jpg]'
- en: Listing 6.12\. Creating a cave network
  id: totrans-152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.12\. 创建洞穴网络
- en: '![](ch06list12-0.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![ch06list12-0.jpg]'
- en: '![](ch06list12-1.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![ch06list12-1.jpg]'
- en: You start with another convenience method ![](one.jpg). In a minute you’ll see
    how it’s used, but it’s to tell you whether a cave can be linked to (or not, if
    all four directions are occupied).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从另一个便利方法开始 ![one.jpg]。在一分钟内，你就会看到它是如何使用的，但这是用来告诉你一个洞穴是否可以连接到（或者不可以，如果四个方向都被占据了）。
- en: '![](f0204-01.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![f0204-01.jpg]'
- en: This function ![](two.jpg) is a modification of the previous *create_caves()*
    that you wrote all the way back in [listing 6.2](#ch06list2). The main difference
    is that this one picks a direction as well as a cave, but other than that, it’s
    the standard connected cave structure.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数 ![two.jpg] 是你之前在 [列表 6.2](#ch06list2) 中编写的 *create_caves()* 函数的一个修改版。主要区别是它不仅选择了一个方向，还选择了一个洞穴，但除此之外，它是一个标准的连通洞穴结构。
- en: You pick the next cave to link to by using the *can_tunnel_to()* convenience
    method in a list comprehension ![](three.jpg).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用列表推导式中的 *can_tunnel_to()* 便利方法来选择下一个要连接的洞穴 ![three.jpg]。
- en: You also need to pick an empty direction to link your cave against ![](four.jpg).
    The choice function will fail if you don’t have any directions, but you’re not
    too worried about that happening because *can_tunnel_to()* method has already
    told you that it has at least one.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要选择一个空方向来将你的洞穴与之连接 ![four.jpg]。如果没有方向，选择函数将失败，但你并不太担心这种情况发生，因为 *can_tunnel_to()*
    方法已经告诉你它至少有一个方向。
- en: Once you have your cave with a spare slot, it’s easy to link the new cave in
    ![](five.jpg). You also add your new cave to the list so other new caves can be
    linked to it, too.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的洞穴有空余的位置，连接新洞穴就很容易了 ![five.jpg]。你还将你的新洞穴添加到列表中，这样其他新洞穴也可以连接到它。
- en: Finally, update the game setup (in player.py) to use the new cave system ![](six.jpg).
    Rather than have only one empty, desolate cave, you now put everything into the
    first cave in the list, including the player. Other than that, it’s pretty much
    the same.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，更新游戏设置（在player.py文件中）以使用新的洞穴系统 ![六](six.jpg)。不再只有一个空旷、荒凉的洞穴，你现在将所有东西都放入列表中的第一个洞穴，包括玩家。除此之外，其他都差不多。
- en: Now when you run players.py, you should see some exits from your starting position,
    as well as the normal description and items. You can pick up your sword, move
    around, drop it in another location, and come back to it.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当你运行players.py时，你应该能看到从起始位置的一些出口，以及正常的描述和物品。你可以拿起你的剑，四处走动，把它扔到另一个地方，然后再回来。
- en: Congratulations, you’ve created a world! Feel free to go and explore it. When
    you come back, you’ll add some more parts.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你，你已经创建了一个世界！请随意去探索它。当你回来时，你将添加更多部分。
- en: Here there be monsters!
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 这里到处都是怪物！
- en: You now have a player, items, and treasure to collect. All that’s left to put
    in your adventure is sudden, painful death, also known as danger and excitement.
    You’ll add to your game some monsters that will move around the map and that might
    attack the player if they’re in the same cave and feeling nasty, or else pick
    up any treasure lying around. The player can attack the monsters, too, and loot
    their treasure.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在有一个玩家，一些物品和宝藏可以收集。剩下要放入你的冒险中的只有突然、痛苦的死亡，也就是危险和刺激。你将在游戏中添加一些会在地图上移动并可能攻击玩家的怪物，如果它们在同一个洞穴里并且感觉不好，或者捡起任何散落的宝藏。玩家也可以攻击怪物，并掠夺它们的宝藏。
- en: Creating your monsters
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建你的怪物
- en: Let’s think about that for a second. Don’t the monsters sound awfully familiar?
    Let’s draw up a chart to help.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微思考一下。怪物听起来是不是很熟悉？让我们画一个图表来帮助。
- en: '| Monster | Player |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 怪物 | 玩家 |'
- en: '| --- | --- |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Moves around the map | Moves around the map |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 在地图上移动 | 在地图上移动 |'
- en: '| Collects treasure | Collects treasure |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| 收集宝藏 | 收集宝藏 |'
- en: '| Attacks the player | Attacks monsters |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 攻击玩家 | 攻击怪物 |'
- en: The monsters and the player seem to share an awful lot in common. In a function-based
    program, you’d look at this and recognize that you need to avoid duplication,
    but how do you do that with an object-oriented program? The answer is to subclass
    *Player*, commonly referred to as *inheritance*.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 怪物和玩家似乎有很多共同之处。在一个基于函数的程序中，你会看到这一点并认识到你需要避免重复，但在面向对象的程序中如何做到这一点呢？答案是子类化 *Player*，通常称为
    *继承*。
- en: '![](f0206-01.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![f0206-01](f0206-01.jpg)'
- en: Inheritance is a fancy way of saying “make a slightly different copy of my class
    that does this and this differently.” In the case of the monsters in your game,
    they’ll behave much the same way, but instead of the player telling them what
    to do next, the monsters figure it out for themselves. The monsters will also
    need to have a name and description so the player can look at them. That means
    their *__init__* and *get_input* functions need to be different, but you’ll keep
    most of the rest of the *Player* class intact. The next listing is a first draft
    of the new *Monster* class.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 继承是一种说法，即“制作一个略有不同但做这些事情不同的类的副本。”在你的游戏中的怪物情况下，它们的行为几乎相同，但怪物不是由玩家告诉下一步该做什么，而是自己决定。怪物还需要有一个名字和描述，这样玩家就可以查看它们。这意味着它们的
    *__init__* 和 *get_input* 函数需要不同，但你将保持 *Player* 类的大部分内容不变。下一个列表是新的 *Monster* 类的第一个草案。
- en: Listing 6.13\. Adding monsters to the game
  id: totrans-176
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.13\. 向游戏中添加怪物
- en: '![](06list13_alt.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![06list13_alt](06list13_alt.jpg)'
- en: The first thing you need to do is to import the *player* module ![](one.jpg).
    Once that’s done, you can use *player.Player* instead of *object* when you create
    your class. Now, instead of using the base *object*, Python will look in *player.Player*
    when it tries to find an attribute or method that isn’t defined directly in the
    *Monster* class.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做的第一件事是导入 *player* 模块 ![一](one.jpg)。一旦完成，你可以在创建类时使用 *player.Player* 而不是 *object*。现在，当Python尝试查找在
    *Monster* 类中未直接定义的属性或方法时，它会在 *player.Player* 中查找。
- en: When you’re initializing your *monster* class, you’ll also need to initialize
    the parent class to make sure everything’s set up properly ![](two.jpg). In this
    case, the main thing that needs to be set is the location of the monster.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当你初始化你的 *怪物* 类时，你还需要初始化父类以确保一切设置正确 ![二](two.jpg)。在这种情况下，需要设置的主要事情是怪物的位置。
- en: Here’s where you can see the similarities between the *player* and *monster*
    classes. Your monster AI is a different version of *get_input* that generates
    a command rather than asking the player to provide one ![](three.jpg). To start,
    you’ll keep things simple, returning either a blank string to do nothing or a
    random direction to move around (making good use of the cave class’s *exits()*
    function).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你可以看到 *player* 和 *monster* 类之间的相似之处。你的怪物人工智能是一个不同的 *get_input* 版本，它生成一个命令而不是要求玩家提供命令
    ![图片](three.jpg)。一开始，你会保持简单，返回一个空字符串以什么都不做，或者返回一个随机方向来移动（充分利用洞穴类的 *exits()* 函数）。
- en: The player will want to try to interact with the monster, so you need to provide
    mechanisms for that to occur ![](four.jpg). *look()* is copied from the *Item*
    class and returns the monster’s description, and *get()* gives an amusing error
    message.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家会想要尝试与怪物互动，因此你需要提供实现这一点的机制 ![图片](four.jpg)。*look()* 从 *Item* 类复制而来，返回怪物的描述，而
    *get()* 则给出一个有趣的错误信息。
- en: Now you have a *monster* class that is fully capable of interacting with the
    world in the same way the player can, and that will see all the same information.
    This is important for a few reasons. Let’s take a closer look at those reasons
    and how they tie in to object-oriented design.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有一个能够以与玩家相同的方式与世界交互的 *怪物* 类，并且将看到所有相同的信息。这有几个重要的原因。让我们更仔细地看看这些原因以及它们如何与面向对象设计相结合。
- en: '![](f0207-01.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图片](f0207-01.jpg)'
- en: Some object-oriented design tips
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 一些面向对象设计的技巧
- en: 'The first reason to use inheritance is that you can rely on having the common
    functionality of the base class, which reduces the amount of “special casing”
    that your program needs in order to run. You don’t need two separate game loops,
    one for the player and another for the monsters, or program code that looks like
    *if player then: ... else* *if monster then: ...*. Instead, you can treat monsters
    and players identically.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '使用继承的第一个原因是，你可以依赖基类中存在的公共功能，这减少了程序运行时所需的“特殊处理”数量。你不需要为玩家和怪物分别编写两个独立的游戏循环，或者看起来像
    *if player then: ... else* *if monster then: ...* 的程序代码。相反，你可以将怪物和玩家同等对待。'
- en: The second reason to use inheritance is that it makes your program easier to
    extend; this effectively builds an interface which monsters, players, and whatever
    else you can think of can interact with the world. If you needed to add a third
    type of actor to your world, you only need to write the parts specific to that
    actor.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 使用继承的第二个原因是，它使你的程序更容易扩展；这实际上建立了一个接口，怪物、玩家以及你可以想到的任何其他东西都可以与之交互。如果你需要向你的世界中添加第三种类型的演员，你只需要编写特定于该演员的部分。
- en: The final reason is that using inheritance greatly reduces the amount of code
    you have to write and makes your program much easier to understand, which is always
    good, whether your program is object-oriented or not.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个原因是，使用继承大大减少了你需要编写的代码量，并使你的程序更容易理解，这总是好的，无论你的程序是否是面向对象的。
- en: The other point to note is that this isn’t the only way you can design your
    classes. A different, possibly better, way is to create a third class (called
    something like *Mobile* or *Actor*) with all the common functionality between
    the player and the monster, and then have both the player and monster classes
    inherit from that. In object-oriented design, this is normally referred to as
    an *abstract class*. You’re not supposed to create instances of *Actor*; instead,
    you inherit from it, add the bits that are missing, and then create an instance
    from your subclass.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 另一点需要注意的是，这并不是设计类的唯一方法。另一种可能更好的方法是创建一个第三类（可以称为 *Mobile* 或 *Actor*），其中包含玩家和怪物之间的所有公共功能，然后让玩家和怪物类都从该类继承。在面向对象设计中，这通常被称为
    *抽象类*。你不应该创建 *Actor* 的实例；相反，你应该从它继承，添加缺少的部分，然后从你的子类创建实例。
- en: '|  |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-190
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Object-oriented terminology can be confusing, but once you’ve seen a few examples,
    you’ll find it pretty straightforward. Just relate it back to something you know
    well, like the *Cave*, *Player*, and *Monster* classes in this chapter.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象术语可能会令人困惑，但一旦你看过几个例子，你会发现它相当直观。只需将其与你熟悉的事物联系起来，比如本章中的 *Cave*、*Player* 和
    *Monster* 类。
- en: '|  |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: In this case, the advantages of specifying an abstract class aren’t immediately
    clear because you only have two classes. But, it’s an option in the future if
    you find there’s functionality that the *Player* class needs but monsters shouldn’t
    have access to, or vice versa.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，指定抽象类的优势并不立即明显，因为你只有两个类。但是，如果你将来发现 `Player` 类需要的功能而怪物不应该访问，或者反之亦然，这是一个选项。
- en: 'Another design point is that, up until now, you’ve favored composition over
    inheritance. Inheritance is normally referred to as an “is/a” relationship: a
    player is an actor, a monster is an actor, too. Composition, on the other hand,
    is a “has/a” relationship: a cave has a player in it, a player has a number of
    items. Composition tends to couple your objects less tightly—they have to interact
    via method calls and inspecting each other’s values—unlike inheritance, which
    automatically inserts the methods of one object into the other. Most of the time,
    you’ll want to use composition; but when used in the right situation, inheritance
    can make a big difference. [Figure 6.3](#ch06fig03) shows the difference between
    composition and inheritance in your game so far.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个设计点是，到目前为止，你更倾向于组合而非继承。继承通常被称为“是/有”关系：玩家是一个角色，怪物也是一个角色。另一方面，组合是一个“有/包含”关系：洞穴中有一个玩家，玩家有多个物品。组合通常会使你的对象耦合度更低——它们必须通过方法调用和检查彼此的值来交互——与继承不同，继承会自动将一个对象的方法插入到另一个对象中。大多数情况下，你将想要使用组合；但在适当的情况下，继承可以产生重大影响。[图
    6.3](#ch06fig03) 展示了你游戏中组合与继承的区别。
- en: Figure 6.3\. Some of the inheritance and composition in your game
  id: totrans-195
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.3\. 你游戏中的一些继承和组合
- en: '![](06fig03.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图片](06fig03.jpg)'
- en: Tying it all together
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将所有内容整合在一起
- en: Now that you have the player and monster classes, you need to make some changes
    to how the game handles the player when it runs. You no longer want the special
    case of getting input only for the player; your monsters have equal rights, too!
    You’d also like all the functions you’ve been using up until now enclosed within
    a class, so it’s easier for them to interact properly. The following listing features
    a class that does just that—you can use it to set up a game, build caves, and
    gather input until the player has finished.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了玩家和怪物类，你需要对游戏运行时处理玩家的方式做一些更改。你不再只想为玩家获取输入的特殊情况；你的怪物也有平等的权利！你也不想将迄今为止使用的所有函数都封装在一个类中，这样它们更容易正确交互。以下列表展示了一个正好做到这一点的类——你可以使用它来设置游戏、构建洞穴并收集输入，直到玩家完成。
- en: Listing 6.14\. A `Game` class
  id: totrans-199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.14\. `Game` 类
- en: '![](ch06list14-0.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch06list14-0.jpg)'
- en: '![](ch06list14-1.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch06list14-1.jpg)'
- en: This *__init__* function contains all the setup code you’ve been running from
    the *Player* class so far, creating items, monsters, and the player. *__init__*
    is a much more sensible place to put it ![](one.jpg).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `__init__` 函数包含了迄今为止从 `Player` 类中运行的所有设置代码，创建了物品、怪物和玩家。`__init__` 是一个更合理的放置位置！![图片](one.jpg)。
- en: Next, you ask each actor in the game what it’s going to do next ![](two.jpg).
    Note that the *dir()* function applies equally well to your own classes as it
    does to Python’s built-in objects. Splitting the input away from the processing
    like this means one actor can’t make decisions based on what other actors are
    about to do, which makes the game easier to understand for both the player and
    yourself.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你询问游戏中的每个角色接下来要做什么！![图片](two.jpg)。请注意，`dir()` 函数同样适用于你的类，以及 Python 的内置对象。将输入与处理分离，这样意味着一个角色不能基于其他角色即将要做的事情做出决定，这使得游戏对玩家和开发者来说都更容易理解。
- en: 'Once you’ve gathered all the input, each actor will act in turn ![](three.jpg).
    The mechanism is much the same: build a list of actors and then iterate over them.
    If you want to be fair, you should probably shuffle this list to determine who
    acts first, but the monsters don’t care about fairness.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦收集了所有输入，每个角色将依次行动！![图片](three.jpg)。机制几乎相同：构建一个角色列表，然后遍历它们。如果你想做到公平，你可能需要对这个列表进行洗牌以确定谁先行动，但怪物并不关心公平性。
- en: Here’s your main game loop ![](four.jpg). It’s the same as the one you had previously,
    except it calls out to *do_input* and *do_update*, and the player and monsters
    store their output in a result list. You’ve also created a separate events list,
    to store things that happen during each turn.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你的主游戏循环！![图片](four.jpg)。它与之前的一样，只是调用了 `do_input` 和 `do_update`，玩家和怪物将它们的输出存储在一个结果列表中。你还创建了一个单独的事件列表，用于存储每回合发生的事情。
- en: The final benefit is that you now have a nice clean *__main__* loop ![](five.jpg).
    All the tricky code that used to be here has been broken into bits and contained
    within methods.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的益处是，你现在有一个干净整洁的*__main__*循环![图片](five.jpg)。这里曾经有的所有复杂代码都被拆分成小块，并包含在方法中。
- en: '![](f0211-01.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图片](f0211-01.jpg)'
- en: 'The last thing you need to do is to add an update function to the *Player*
    class. When the code checks all the objects in the game world, it will see the
    player, and everything derived from the *Player* class, as things that need to
    be updated:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你最后需要做的是给*Player*类添加一个更新函数。当代码检查游戏世界中的所有对象时，它会看到玩家，以及从*Player*类派生出的所有对象，它们都需要更新：
- en: '[PRE2]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: All this does is call *process_input* with whatever the player’s input has been,
    and store the return value—which will be a list of strings—in *self.result*. You
    also need to add a name to the *Player* class too, because *Monster* will be calling
    *process_input* on the player when they’re trying to run commands.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是调用*process_input*函数，无论玩家的输入是什么，并将返回值（将是一个字符串列表）存储在*self.result*中。你还需要给*Player*类添加一个名字，因为*Monster*会在玩家尝试运行命令时调用*process_input*。
- en: If you run your program now, you should see an orc in the room with you. Press
    the Enter key a few times to simulate waiting a while, and the orc should leave
    for another room. If you search around, you should be able to find the orc aimlessly
    wandering the caves. Unless you want your game to resemble a European art house
    piece exploring the futility of existence, though, you’d better start adding some
    more interesting game elements.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行你的程序，你应该能看到一个兽人在房间里和你在一起。按几次Enter键来模拟等待一段时间，兽人应该会离开去另一个房间。如果你四处寻找，你应该能找到兽人在洞穴里漫无目的地徘徊。不过，除非你希望你的游戏像欧洲艺术电影一样探索存在的无意义，否则你最好开始添加一些更有趣的游戏元素。
- en: Danger and excitement
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 危险与刺激
- en: The final part of your game will be to allow the players and monsters to attack
    each other. Some sort of element of competition is essential in games, whether
    you’re competing on combat, speed, who can build the biggest city, exploring,
    or building the best house. In this case, you’re writing a dungeon adventure,
    so combat is pretty much essential—anyone who’s played Dungeons and Dragons will
    be expecting to be able to hit orcs. Because combat will be between the player
    and monsters, you’ll start with the *Player* class and add an attack method, as
    per the following listing.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你的游戏的最后一部分将是允许玩家和怪物互相攻击。在游戏中，竞争的元素是必不可少的，无论是战斗、速度、谁可以建造最大的城市、探索还是建造最好的房子。在这种情况下，你正在编写一个地下城冒险游戏，所以战斗几乎是必不可少的——任何玩过《龙与地下城》的人都会期待能够击中兽人。因为战斗将在玩家和怪物之间进行，所以你将从*Player*类开始，并添加一个攻击方法，如下所示。
- en: '![](f0212-01.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图片](f0212-01.jpg)'
- en: Listing 6.15\. Attacking other objects
  id: totrans-215
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.15。攻击其他对象
- en: '![](ch06list15-0.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch06list15-0.jpg)'
- en: '![](ch06list15-1.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch06list15-1.jpg)'
- en: You start by adding some extra attributes you’ll need for the *attack()* method
    ![](one.jpg). *hit_points* is pretty obvious, *events* is for storing things that
    happened to the player (or which they saw) during the turn, and you’ve already
    added a name and description so you can handle combat easily whether the target
    is a monster or a player.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先添加一些你需要用于*attack()*方法的额外属性![图片](one.jpg)。*hit_points*很明显，*events*用于存储玩家（或他们看到的）在回合中发生的事情，你已经添加了名字和描述，这样你可以轻松地处理战斗，无论目标是怪物还是玩家。
- en: '![](f0214-01.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图片](f0214-01.jpg)'
- en: 'You’ll use a simple combat mechanism: calculate a to-hit number, roll a die,
    and, if the number rolled is under or equal to the to-hit roll, the player or
    monster is hit ![](two.jpg). The to-hit number will normally be 2, but if you
    have a sword, then it will be 4\. Remember that the *attack()* command will be
    called on the object that’s being attacked, rather than the one doing the attacking.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用一个简单的战斗机制：计算一个命中数，掷骰子，如果掷出的数字小于或等于命中数，玩家或怪物就会被击中![图片](two.jpg)。命中数通常是2，但如果你有剑，那么它将是4。记住，*attack()*命令将在被攻击的对象上调用，而不是攻击者。
- en: Next, you roll to see if you hit ![](three.jpg)—it’s a random choice from 1
    to 6\. If the number rolled is greater than the to-hit number, then you miss.
    Before you exit, though, you tell both the attacker and the attacked what’s happened.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你掷骰子看是否击中![图片](three.jpg)——从1到6的随机选择。如果掷出的数字大于命中数，那么你就没击中。不过，在你离开之前，你需要告诉攻击者和被攻击者发生了什么。
- en: If you’re hit, then you lose a hit point. If the hit points are reduced to zero
    or below, then you die ![](four.jpg). If it’s the player that has died, this will
    trigger the end of the game. Either way, you report it, but generate the messages
    before you call out to the *die()* function, because that may modify it *("You
    kill the A dead orc!"*).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你被击中，那么你将失去一个生命值。如果生命值减少到零或以下，那么你就死了 ![four.jpg]。如果玩家死亡，这将触发游戏的结束。无论如何，你都要报告，但在调用
    *die()* 函数之前生成消息，因为那可能会修改它 *("你杀死了那个死去的兽人"*)。
- en: 'If you’re not dead yet, then the situation is much the same as a miss: report
    it to the attacker and the target, and move on ![](five.jpg).'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有死，那么情况与未命中相似：向攻击者和目标报告，然后继续前进 ![five.jpg]。
- en: Because there could potentially be a lot of bookkeeping to be done when a monster
    dies, you pull that out into its own method ![](six.jpg). You mark yourself as
    not playing, cancel any outstanding orders, and change your name to reflect your
    newly deceased status. You also add a sanity check to make sure you can’t attack
    yourself.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 因为当怪物死亡时，可能需要进行大量的记录工作，所以你将其拉入自己的方法 ![six.jpg]。你标记自己为非玩家，取消任何未完成的命令，并将你的名字改为反映你新近死亡的状态。你还添加了一个理智检查，以确保你不能攻击自己。
- en: 'That’s all you need to do to enable combat in your game! Because the classes
    are all nicely encapsulated, there’s no need to make any changes to the *Cave*,
    *Item*, and *Game* classes. Well, not entirely. If you think back to the last
    chapter or run the code, you’ll see an obvious problem: the monsters don’t fight
    back. Worse, after you’ve killed them, they still run around! Both of these problems
    are easy to fix with a simple upgrade to the monster’s AI, as shown in the next
    listing.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你使游戏中的战斗功能生效所需做的全部工作！因为类都被很好地封装了，所以不需要对 *Cave*、*Item* 和 *Game* 类进行任何更改。嗯，不完全是这样。如果你回想起上一章或运行代码，你会看到一个明显的问题：怪物不会反击。更糟糕的是，在你杀死它们之后，它们仍然四处跑动！这两个问题都可以通过简单地升级怪物的AI来解决，如下一列表所示。
- en: Listing 6.16\. Updating your monster’s AI
  id: totrans-226
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.16\. 更新你的怪物AI
- en: '![](06list16_alt.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![06list16_alt.jpg]'
- en: Dead monsters tell no tales. If it’s dead, then it shouldn’t be generating any
    input at all ![](one.jpg); without this section, you’d have an undead orc running
    around your caves after you kill it.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 死去的怪物不会说故事。如果它死了，那么它就不应该生成任何输入 ![one.jpg]；如果没有这个部分，你会在杀死它之后在你的洞穴中看到一个不死不活的兽人四处跑动。
- en: Next, you can let the monster get revenge on the player ![](two.jpg). If the
    monster can see the player in the cave, then you issue an attack order, exactly
    as the player would if they could see the monster. Take that, player! If the monster
    can’t see them, then it goes back to its random wandering around the caves.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以让怪物对玩家进行报复 ![two.jpg]。如果怪物能在洞穴中看到玩家，那么你就发出攻击命令，就像玩家能看到怪物一样。来吧，玩家！如果怪物看不到他们，那么它就会回到洞穴中随机游荡。
- en: 'Now you have all the elements of an adventure game: a network of rooms to explore,
    monsters to attack the player, and items and treasure to collect to help players
    in their quest. Armed with the code in this chapter and your imagination, you
    should be able to create pretty much any type of adventure game you like.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经拥有了冒险游戏的所有元素：一个可以探索的房间网络，攻击玩家的怪物，以及收集物品和宝藏来帮助玩家完成他们的任务。凭借本章中的代码和你的想象力，你应该能够创建几乎任何你喜欢的冒险游戏。
- en: Where to from here?
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接下来该做什么？
- en: The classes and methods that have been introduced in this chapter have only
    scratched the surface of what you can add to your game. Depending on the type
    of game you prefer, you can take your development in any direction. Here are some
    ideas on how you could extend the game you’ve written so far.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 本章所介绍的课程和方法只是触及了你可以为你的游戏添加内容的表面。根据你偏好的游戏类型，你可以将你的开发引向任何方向。以下是一些关于如何扩展你迄今为止所编写的游戏的思路。
- en: Add more monsters and treasure
  id: totrans-233
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加更多怪物和宝藏
- en: Currently, there’s only one orc and a couple of different items. You could add
    more types of monsters and treasure (or more powerful weapons or weapons that
    affect monsters differently). You’d also want a score that the player can access
    with a score method on the player, and that should also be printed out when the
    player quits, or dies.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，游戏中只有一个兽人和几样不同的物品。你可以添加更多类型的怪物和宝藏（或者更强大的武器，或者能以不同方式影响怪物的武器）。你还会想要一个玩家可以通过玩家上的得分方法访问的得分，当玩家退出或死亡时，也应该将其打印出来。
- en: Extend combat and items
  id: totrans-235
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 扩展战斗和物品
- en: You could extend the *Item* class or *Player.attack()* method, to add other
    items that might be useful, such as armor or rope, and something to use them on.
    If you’re adding lots of weapons or armor with different to-hit modifiers, you
    might want to think about ways to simplify how to find the amount you add or subtract
    from the to-hit roll or damage done.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以扩展 *Item* 类或 *Player.attack()* 方法，添加可能有用的其他物品，例如盔甲或绳索，以及使用它们的东西。如果你添加了很多具有不同命中修正值的武器或盔甲，你可能想要考虑简化查找你添加或从命中骰或造成的伤害中减去的数量的方法。
- en: Add more adventure
  id: totrans-237
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加更多冒险元素
- en: Some adventure games are more about exploring atmospheric locations than killing
    monsters. You could add proper descriptions during the setup phase, or have a
    pre-generated cave system instead of a randomly generated one, and add specific
    methods to handle particular events—such as a boat that sets sail, or a castle
    drawbridge that you can raise or lower.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 一些冒险游戏更多地是关于探索具有氛围的位置，而不是杀怪物。你可以在设置阶段添加适当的描述，或者使用预先生成的洞穴系统而不是随机生成的，并添加特定的方法来处理特定事件——例如，一艘起航的船，或者你可以升起或降下的城堡吊桥。
- en: Experiment with verbs and nouns
  id: totrans-239
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 尝试使用动词和名词
- en: You might want to play around with adding different methods to the *Item* class,
    to see what you can do when you override built-in methods. For example, you could
    add the movement methods *go()*, *north()*, and so on to an item, and make a door
    that’s impassable until the player has the right key. That’s also possible with
    a static monster that needs the right magic sword or a secret password in order
    to pass. There’s also scope for allowing other items to handle particular commands
    if the game can’t find the original object.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想要尝试向 *Item* 类添加不同的方法，看看当你覆盖内置方法时你能做什么。例如，你可以在一个物品上添加移动方法 *go()*, *north()*,
    等等，并制作一个直到玩家拥有正确的钥匙才能通过的门。使用需要正确魔法剑或秘密密码才能通过的静态怪物也是可能的。如果游戏找不到原始对象，还可以允许其他物品处理特定的命令。
- en: Investigate some more advanced features of classes
  id: totrans-241
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 探索类的更多高级特性
- en: It’s important to note that you haven’t dealt with all the functionality of
    classes, just the common parts you’ll deal with in 95% of your programs. There
    are other advanced class features, such as missing method and attribute handling,
    properties, and mix-in classes, that we’ll introduce in later chapters as they
    become relevant. If you’re already familiar with classes from other languages,
    though, you might want to have a look through Python’s class documentation to
    see what else you can do with them.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，你还没有处理类的所有功能，只是你将在95%的程序中处理的常见部分。还有其他高级类特性，如缺失方法和属性处理、属性和混入类，我们将在相关章节中介绍。如果你已经熟悉其他语言中的类，那么你可能想查阅Python的类文档，看看你还能用它们做什么。
- en: Summary
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: 'We’ve covered a number of object-oriented topics and design issues in this
    chapter and looked at how classes can help make your programs clearer and easier
    to understand. In particular, we addressed the following:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中讨论了许多面向对象的主题和设计问题，并探讨了如何通过类来使你的程序更清晰、更容易理解。特别是，我们讨论了以下内容：
- en: How classes can encapsulate data and functions and initialize them to make instances,
    which you can reason about and understand much more easily than separate data
    and functions
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类如何封装数据和函数，并将它们初始化为实例，这样你就可以更容易地推理和理解它们，而不是单独的数据和函数
- en: How classes can interact, calling each other’s methods and looking at data to
    make decisions about what to do
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类如何交互，调用彼此的方法并查看数据以做出决策
- en: That classes can be combined using composition (where instances can contain
    other instances) and inheritance (where classes can be declared to be particular
    subtypes of another class)
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类可以通过组合（实例可以包含其他实例）和继承（类可以被声明为另一个类的特定子类型）来组合使用
- en: 'We haven’t covered all the features of Python’s class system yet—far from it—but
    you now have a firm grasp of the fundamentals of how classes are used and, more
    important, how to use them to solve problems in your programs. In future chapters,
    you’ll be making more use of classes and their more advanced features. In the
    next chapter, though, we’ll be taking a look at another Python feature that is
    closely related to the function: the generator.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有涵盖 Python 类系统的所有特性——远未触及——但你现在已经牢固掌握了类的基本用法，更重要的是，如何在你自己的程序中使用它们来解决问题。在未来的章节中，你将更多地使用类及其更高级的特性。然而，在下一章中，我们将探讨另一个与函数紧密相关的
    Python 特性：生成器。
