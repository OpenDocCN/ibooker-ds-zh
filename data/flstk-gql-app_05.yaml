- en: 4 The Neo4j GraphQL Library
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 Neo4j GraphQL库
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Reviewing common issues that arise when building GraphQL API applications
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审查在构建GraphQL API应用程序时出现的常见问题
- en: Introducing database integrations for GraphQL that aim to address these common
    problems, including the Neo4j GraphQL library
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍旨在解决这些常见问题的GraphQL数据库集成，包括Neo4j GraphQL库
- en: Building a GraphQL endpoint backed by Neo4j, taking advantage of the features
    of the Neo4j GraphQL library, such as generated query and mutation types, filtering,
    and temporal and spatial data types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个基于Neo4j的GraphQL端点，利用Neo4j GraphQL库的功能，例如生成的查询和突变类型、过滤以及时间和空间数据类型
- en: Extending the functionality of our autogenerated GraphQL API with custom logic
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过自定义逻辑扩展自动生成的GraphQL API的功能
- en: Introspecting a GraphQL schema from an existing Neo4j database
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从现有的Neo4j数据库中检查GraphQL模式
- en: GraphQL backend implementations commonly run into a set of issues that negatively
    impact performance and developer productivity. We’ve identified some of these
    problems previously (e.g., the *n* + 1 query problem), and in this chapter, we
    take a deeper look at these common issues and discuss how they can be mitigated,
    using database integrations for GraphQL that make it easier to build efficient
    GraphQL APIs backed by databases.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL后端实现通常会遇到一系列问题，这些问题会负面影响性能和开发者的生产力。我们之前已经确定了一些这些问题（例如，*n* + 1查询问题），在本章中，我们将更深入地探讨这些常见问题，并讨论如何通过数据库集成来减轻这些问题，这些集成使得构建基于数据库的高效GraphQL
    API变得更容易。
- en: Specifically, we look at using the Neo4j GraphQL library, a Node.js library
    designed to work with JavaScript GraphQL implementations, such as Apollo Server
    for building GraphQL APIs backed by Neo4j. The Neo4j GraphQL library allows us
    to generate a fully functional GraphQL API from GraphQL type definitions, driving
    the database data model from GraphQL and autogenerating resolvers for data fetching
    and mutations, including complex filtering, ordering, and pagination. The Neo4j
    GraphQL library also enables adding custom logic beyond the generated create,
    read, update, and delete operations.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们探讨使用Neo4j GraphQL库，这是一个Node.js库，旨在与JavaScript GraphQL实现（如Apollo Server）一起工作，用于构建基于Neo4j的GraphQL
    API。Neo4j GraphQL库允许我们从GraphQL类型定义生成一个完全功能的GraphQL API，从GraphQL驱动数据库数据模型，并自动生成用于数据获取和突变的解析器，包括复杂的过滤、排序和分页。Neo4j
    GraphQL库还使我们能够添加超出生成的创建、读取、更新和删除操作的定制逻辑。
- en: In this chapter, we look at using the Neo4j GraphQL library to integrate our
    business review GraphQL API with Neo4j, adding a persistence layer to our API.
    In this initial look at the Neo4j GraphQL library, we focus on querying existing
    data using the sample dataset in Neo4j used in the previous chapter. We will explore
    creating and updating data (GraphQL mutations) as well as more complex GraphQL
    querying semantics, such as interfaces and fragments, in future chapters, introducing
    these concepts in the context of building out our user interface. Figure 4.1 shows
    how the Neo4j GraphQL library fits into the larger architecture of our application.
    The goal of the Neo4j GraphQL library is to make it easy to build an API backed
    by Neo4j, not to the database directly with GraphQL.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨使用Neo4j GraphQL库将我们的业务审查GraphQL API与Neo4j集成，为我们的API添加持久化层。在初步了解Neo4j
    GraphQL库时，我们专注于使用前一章中在Neo4j中使用的示例数据集查询现有数据。我们将在未来的章节中探索创建和更新数据（GraphQL突变）以及更复杂的GraphQL查询语义，如接口和片段，这些概念将在构建用户界面的上下文中介绍。图4.1显示了Neo4j
    GraphQL库如何融入我们应用程序的更大架构。Neo4j GraphQL库的目标是使构建基于Neo4j的API变得容易，而不是直接使用GraphQL与数据库交互。
- en: '![CH04_F01_Lyon](../../OEBPS/Images/CH04_F01_Lyon.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F01_Lyon](../../OEBPS/Images/CH04_F01_Lyon.png)'
- en: Figure 4.1 The Neo4j GraphQL library helps build the API layer between the client
    and database.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 Neo4j GraphQL库帮助构建客户端和数据库之间的API层。
- en: 4.1 Common GraphQL problems
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 常见的GraphQL问题
- en: 'When building GraphQL APIs, there are two types of problems that developers
    typically face: poor performance and writing lots of boilerplate code, which can
    impact developer productivity.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建GraphQL API时，开发者通常面临两种类型的问题：性能不佳和编写大量样板代码，这可能会影响开发者的生产力。
- en: 4.1.1 Poor performance and the n + 1 query problem
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.1 表现不佳和n + 1查询问题
- en: We previously discussed the *n* + 1 query problem, which can arise when multiple
    requests are sent to the data layer to resolve a single GraphQL request. Because
    of the nested way GraphQL resolver functions are called, multiple database requests
    are often required to resolve a GraphQL query from the data layer. For example,
    imagine a query searching for businesses by name as well as all reviews for each
    business. A naive implementation would first query the database for all businesses
    matching the search phrase. Then, for each matching business, it would send an
    additional query to the database to find any reviews for the business. Each query
    to the database would incur network and query latency, which can significantly
    impact performance.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论了 *n* + 1 查询问题，这个问题可能出现在向数据层发送多个请求以解析单个 GraphQL 请求时。由于 GraphQL 解析器函数调用的嵌套方式，通常需要多个数据库请求来从数据层解析
    GraphQL 查询。例如，想象一个查询，它通过名称搜索企业以及每个企业的所有评论。一个简单的实现会首先查询数据库以找到所有与搜索短语匹配的企业。然后，对于每个匹配的企业，它会向数据库发送额外的查询以找到该企业的任何评论。对数据库的每次查询都会产生网络和查询延迟，这可能会显著影响性能。
- en: A common solution for this is to use a caching and batching pattern known as
    DataLoader. This can alleviate some performance issues; however, it can still
    require multiple database requests and cannot be used in all cases, such as when
    the ID of an object is not known.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的常见方法是使用一种名为 DataLoader 的缓存和批量模式。这可以缓解一些性能问题；然而，它仍然可能需要多个数据库请求，并且不能在所有情况下使用，例如当不知道对象的
    ID 时。
- en: 4.1.2 Boilerplate and developer productivity
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.2 模板代码和开发者生产力
- en: The term *boilerplate* is used to describe repetitive code that is written to
    accomplish a common task. In the case of implementing GraphQL APIs, writing boilerplate
    code to implement data-fetching logic in resolvers is often required. This can
    negatively impact developer productivity, slowing down development, as the developer
    is required to write simple data-fetching logic for each type and field instead
    of focusing on the key components of their application. In the context of our
    business review application, this would mean manually writing the logic for finding
    businesses by name in the database, finding reviews associated with each business
    and each user connected to each review, and so on, until we’ve manually defined
    the logic for fetching all fields of our GraphQL schema.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 术语 *boilerplate* 用于描述编写来完成常见任务的重复性代码。在实现 GraphQL API 的情况下，通常需要在解析器中编写模板代码来实现数据获取逻辑，这可能会对开发者生产力产生负面影响，减慢开发速度，因为开发者需要为每种类型和字段编写简单的数据获取逻辑，而不是专注于应用程序的关键组件。在我们的业务审查应用程序的上下文中，这意味着需要手动编写在数据库中按名称查找企业的逻辑，查找与每个企业相关的评论以及与每个评论关联的每个用户，等等，直到我们手动定义了获取我们
    GraphQL 模式所有字段的逻辑。
- en: 4.2 Introducing GraphQL database integrations
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 介绍 GraphQL 数据库集成
- en: GraphQL integrations for databases are a class of tools that enable building
    GraphQL APIs that interact with databases. There are a handful of these tools
    with different feature sets and levels of integration—in this book, we focus on
    the Neo4j GraphQL library. However, in general, the goal of these GraphQL *engines*
    is to address the common GraphQL problems previously identified in a consistent
    way by reducing boilerplate and addressing data-fetching performance issues.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库的 GraphQL 集成是一类工具，它能够构建与数据库交互的 GraphQL API。这些工具数量有限，具有不同的功能集和集成级别——在这本书中，我们专注于
    Neo4j GraphQL 库。然而，总的来说，这些 GraphQL *引擎* 的目标是以一致的方式解决之前确定的常见 GraphQL 问题，通过减少模板代码和解决数据获取性能问题。
- en: Throughout the rest of this chapter, we focus on using the Neo4j GraphQL library
    to build a GraphQL API backed by Neo4j. It is important to note that our GraphQL
    API serves as a layer between the client and the database—we do not want to directly
    query our database from the client. The API layer serves an important function,
    allowing us to implement features, such as authorization and custom logic, that
    we don’t want to expose to the client. Also, since GraphQL is an API query language
    (not a database query language), it lacks many semantics (e.g., projections) that
    we would expect in a database query language.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，我们专注于使用 Neo4j GraphQL 库构建一个由 Neo4j 支持的 GraphQL API。需要注意的是，我们的 GraphQL
    API 作为客户端和数据库之间的一个层——我们不希望客户端直接从数据库中查询。API 层扮演着重要的角色，它允许我们实现一些功能，例如授权和自定义逻辑，这些我们不想暴露给客户端。此外，由于
    GraphQL 是一种 API 查询语言（而不是数据库查询语言），它缺乏我们在数据库查询语言中期望的许多语义（例如，投影）。
- en: 4.3 The Neo4j GraphQL Library
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 Neo4j GraphQL 库
- en: The Neo4j GraphQL library is a Node.js library that works with any JavaScript
    GraphQL implementation, such as GraphQL.js and Apollo Server, and is designed
    to make it as easy as possible to build GraphQL APIs backed by a Neo4j database.
    The two main functions of the Neo4j GraphQL library are *GraphQL schema generation*
    and *GraphQL to Cypher translation*. You may wish to refer to the project’s documentation
    at [http://mng.bz/woNO](http://mng.bz/woNO).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Neo4j GraphQL 库是一个 Node.js 库，它可以与任何 JavaScript GraphQL 实现（如 GraphQL.js 和 Apollo
    Server）一起工作，旨在使基于 Neo4j 数据库构建 GraphQL API 尽可能简单。Neo4j GraphQL 库的两个主要功能是 *GraphQL
    模式生成* 和 *GraphQL 到 Cypher 的翻译*。您可能希望参考项目文档，网址为 [http://mng.bz/woNO](http://mng.bz/woNO)。
- en: 'GraphQL to Cypher translation enables the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 到 Cypher 的翻译可以实现以下功能：
- en: Generating a single database query at runtime from arbitrary GraphQL requests
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时从任意 GraphQL 请求生成单个数据库查询
- en: Handling custom logic defined in the GraphQL schema as subqueries in the generated
    database queries
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在生成的数据库查询中将 GraphQL 模式中定义的自定义逻辑作为子查询处理
- en: The GraphQL schema generation process takes GraphQL type definitions and generates
    a GraphQL API with create, read, update, delete (CRUD) operations for the types
    defined. In GraphQL semantics, this includes adding a Query and Mutation type
    to the schema and generating resolvers for these queries and mutations. The generated
    API includes support for filtering, ordering, pagination, and native database
    types, such as spatial and temporal types, without having to define these manually
    in the type definitions. The result of this process is a GraphQL executable schema
    object, which can then be passed to a GraphQL server implementation, such as Apollo
    Server, to serve the API and handle networking and GraphQL execution processes.
    The schema generation process eliminates the need to write boilerplate code for
    data fetching and mapping the GraphQL and database schemas.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 模式生成过程将 GraphQL 类型定义转换为具有创建、读取、更新、删除（CRUD）操作的 GraphQL API。在 GraphQL
    语义中，这包括向模式中添加查询和突变类型，并为这些查询和突变生成解析器。生成的 API 包括对过滤、排序、分页和本地数据库类型（如空间和时间类型）的支持，而无需在类型定义中手动定义这些类型。此过程的结果是一个可执行的
    GraphQL 模式对象，然后可以将其传递给 GraphQL 服务器实现（如 Apollo Server），以提供 API 并处理网络和 GraphQL 执行过程。模式生成过程消除了编写数据获取和映射
    GraphQL 和数据库模式样板代码的需求。
- en: The GraphQL translation process happens at query time. When a GraphQL request
    is received, a single Cypher query is generated, which can resolve the request
    and is sent to the database. Generating a single database query for any arbitrary
    GraphQL operation solves the *n* + 1 query problem, assuring only one round trip
    to the database per GraphQL request. You can find the documentation and other
    resources for the Neo4j GraphQL library at [dev.neo4j.com/graphql](https://neo4j.com/product/graphql-library/).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 翻译过程在查询时发生。当接收到 GraphQL 请求时，生成一个单一的 Cypher 查询，该查询可以解析请求并发送到数据库。为任何任意的
    GraphQL 操作生成单个数据库查询解决了 *n* + 1 查询问题，确保每个 GraphQL 请求只进行一次数据库往返。您可以在 [dev.neo4j.com/graphql](https://neo4j.com/product/graphql-library/)
    找到 Neo4j GraphQL 库的文档和其他资源。
- en: 4.3.1 Project setup
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.1 项目设置
- en: Throughout the rest of the chapter, we will explore the features of the Neo4j
    GraphQL library by creating a new GraphQL API for Neo4j, using the sample dataset
    of businesses and reviews from the *Exercise* section of the previous chapter.
    We will first create a new Node.js project that makes use of the Neo4j GraphQL
    library and the Neo4j JavaScript driver to fetch data from Neo4j. Then, we will
    explore the various features of the Neo4j GraphQL library, adding additional code
    to our GraphQL API application as we move along.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，我们将通过为 Neo4j 创建一个新的 GraphQL API 来探索 Neo4j GraphQL 库的功能，使用来自上一章 *练习*
    部分的业务和评论样本数据集。首先，我们将创建一个新的 Node.js 项目，该项目利用 Neo4j GraphQL 库和 Neo4j JavaScript
    驱动程序从 Neo4j 获取数据。然后，我们将探索 Neo4j GraphQL 库的各种功能，随着我们的进展，我们将向我们的 GraphQL API 应用程序添加额外的代码。
- en: Neo4j
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Neo4j
- en: First, make sure a Neo4j instance is running (you can use Neo4j Desktop, Neo4j
    Sandbox, or Neo4j Aura, but we will assume you are using Neo4j Desktop for the
    purposes of this chapter). If using Neo4j Desktop, you will need to install the
    APOC standard library plugin. Don’t worry about this step if you’re using Neo4j
    Sandbox or Neo4j Aura; APOC is included by default in those services. To install
    APOC in Neo4j Desktop, click the *Plugins* tab in your project, and then look
    for APOC in the list of available plugins, and click *Install*. Next, make sure
    your Neo4j database is empty by running the Cypher statement (see listing 4.1).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请确保Neo4j实例正在运行（您可以使用Neo4j Desktop、Neo4j Sandbox或Neo4j Aura，但为了本章的目的，我们将假设您正在使用Neo4j
    Desktop）。如果您使用Neo4j Desktop，您需要安装APOC标准库插件。如果您使用Neo4j Sandbox或Neo4j Aura，则无需担心此步骤；APOC默认包含在这些服务中。要在Neo4j
    Desktop中安装APOC，请点击项目中的*插件*选项卡，然后在可用插件列表中查找APOC，并点击*安装*。接下来，通过运行Cypher语句（见列表4.1）确保您的Neo4j数据库为空。
- en: Warning This statement will delete all data in your Neo4j database, so make
    sure this is the instance you want to use, not a database you don’t want to delete.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 警告 此语句将删除您的Neo4j数据库中的所有数据，所以请确保这是您想要使用的实例，而不是您不想删除的数据库。
- en: Listing 4.1 Clearing out our Neo4j database
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.1 清空我们的Neo4j数据库
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, we’re ready to load our sample dataset, which you may have done already
    if you completed the exercise section in the previous chapter. Run the following
    command in Neo4j Browser (see figure 4.2):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备加载我们的示例数据集，如果您完成了上一章的练习部分，您可能已经完成了这一步。在Neo4j浏览器中运行以下命令（见图4.2）：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![CH04_F02_Lyon](../../OEBPS/Images/CH04_F02_Lyon.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F02_Lyon](../../OEBPS/Images/CH04_F02_Lyon.png)'
- en: Figure 4.2 Loading the sample dataset into Neo4j
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 将示例数据集加载到Neo4j中
- en: This will load a sample dataset into Neo4j that we will use as the basis for
    our GraphQL API. In the next listing, we can explore the data a bit by running
    a command, which will give us a visual overview of the data included in the sample
    dataset (see figure 4.3).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在Neo4j中加载一个示例数据集，我们将以此为基础构建我们的GraphQL API。在下一个列表中，我们可以通过运行一个命令来探索这些数据，该命令将给我们一个关于示例数据集中包含的数据的视觉概述（见图4.3）。
- en: '![CH04_F03_Lyon](../../OEBPS/Images/CH04_F03_Lyon.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F03_Lyon](../../OEBPS/Images/CH04_F03_Lyon.png)'
- en: Figure 4.3 The graph schema of our sample dataset
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 我们示例数据集的图模式
- en: Listing 4.2 Visualizing the graph schema in Neo4j
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.2 在Neo4j中可视化图模式
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We see that we have four node labels—Business, Review, Category, and User—connected
    by three relationship types: IN_CATEGORY (connecting businesses to the categories
    to which they belong), REVIEWS (connecting reviews to businesses), and WROTE (connecting
    users to reviews they have authored). We can also view the node properties stored
    on the various node labels, as shown in the next listing.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们有四个节点标签——Business、Review、Category和User——通过三种关系类型连接：IN_CATEGORY（将企业连接到它们所属的类别）、REVIEWS（将评论连接到企业）和WROTE（将用户连接到他们所撰写的评论）。我们还可以查看存储在各个节点标签上的节点属性，如下一个列表所示。
- en: Listing 4.3 Inspecting the node properties stored in Neo4j
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.3 检查存储在Neo4j中的节点属性
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This command will render a table, showing us the property names, their types,
    and whether or not they are found on all nodes of that label:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将显示一个表格，显示属性名称、它们的类型以及是否在所有该标签的节点上找到：
- en: '![CH04_F03_Lyon_table_01](../../OEBPS/Images/CH04_F03_Lyon_table_01.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F03_Lyon_table_01](../../OEBPS/Images/CH04_F03_Lyon_table_01.png)'
- en: We will make use of this table in a few moments when we construct GraphQL type
    definitions that describe this graph.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在构建描述此图的GraphQL类型定义时使用此表。
- en: Node.js app
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js应用
- en: 'Now that we have our Neo4j database loaded with our sample dataset, let’s set
    up a new Node.js project for our GraphQL API:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将我们的示例数据集加载到Neo4j数据库中，让我们为我们的GraphQL API设置一个新的Node.js项目：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We will also install our dependencies:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将安装我们的依赖项：
- en: '@neo4j/graphql—A package to make it easier to use GraphQL and Neo4j together.
    The Neo4j GraphQL library translates GraphQL queries to a single Cypher query,
    eliminating the need to write queries in GraphQL resolvers and for batching queries.
    It also exposes the Cypher query language through GraphQL via the @cypher schema
    directive.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '@neo4j/graphql——一个使使用GraphQL和Neo4j更容易的包。Neo4j GraphQL库将GraphQL查询转换为单个Cypher查询，消除了在GraphQL解析器和批处理查询中编写查询的需要。它还通过@cypher架构指令通过GraphQL公开Cypher查询语言。'
- en: apollo-server—Apollo Server is an open source GraphQL server that works with
    any GraphQL schema built with graphql.js, including the Neo4j GraphQL library.
    It also has options for working with many different Node.js webserver frameworks
    or the default Express.js.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: apollo-server—Apollo Server 是一个开源的 GraphQL 服务器，它可以与任何使用 graphql.js 构建的 GraphQL
    模式一起工作，包括 Neo4j GraphQL 库。它还提供了与许多不同的 Node.js 网络服务器框架或默认的 Express.js 一起工作的选项。
- en: graphql—The GraphQL.js reference implementation for JavaScript is a peer dependency
    of both @neo4j/graphql and apollo-server. As of this writing, the @neo4j/graphql
    package is compatible with version 15.x of graphql; therefore, we will install
    the latest v15.x release.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: graphql—GraphQL.js 的 JavaScript 引用实现是 @neo4j/graphql 和 apollo-server 的 peer
    dependency。截至本文写作时，@neo4j/graphql 包与 graphql 15.x 版本兼容；因此，我们将安装最新的 v15.x 版本。
- en: 'neo4j-driver—The Neo4j client drivers allow for connecting to a Neo4j instance,
    either local or remote, and executing Cypher queries over the Bolt protocol. Neo4j
    drivers are available in many different languages, and here we use the Neo4j JavaScript
    driver:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: neo4j-driver—Neo4j 客户端驱动程序允许通过 Bolt 协议连接到本地或远程的 Neo4j 实例，并执行 Cypher 查询。Neo4j
    驱动程序在许多不同的语言中可用，这里我们使用 Neo4j JavaScript 驱动程序：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, create a new file called index.js, and let’s add some initial code in the
    next listing.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建一个名为 index.js 的新文件，并在下一列表中添加一些初始代码。
- en: 'Listing 4.4 index.js: Initial GraphQL API code'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.4 index.js：初始 GraphQL API 代码
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Importing our dependencies
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入我们的依赖项
- en: ❷ Creating a connection to our Neo4j database
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建到我们的 Neo4j 数据库的连接
- en: ❸ This line serves as a placeholder for our GraphQL type definitions to be filled
    in later.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 这一行作为我们稍后要填写的 GraphQL 类型定义的占位符。
- en: ❹ Passing our GraphQL type definitions and database connection as we instantiate
    the Neo4jGraphQL class
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在实例化 Neo4jGraphQL 类时传递我们的 GraphQL 类型定义和数据库连接
- en: ❺ Our generated GraphQL schema is passed to Apollo Server.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 我们生成的 GraphQL 模式被传递给 Apollo Server。
- en: ❻ Here we start the GraphQL server.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 这里我们开始启动 GraphQL 服务器。
- en: This is the basic structure for our GraphQL API application code. The credentials
    used when constructing the Neo4j driver instance will depend on whether you are
    using Neo4j Desktop, Neo4j Sandbox, or Neo4j Aura, as well as on your initial
    chosen password. Be sure to adjust the connection credentials for your specific
    Neo4j instance.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的 GraphQL API 应用程序代码的基本结构。构建 Neo4j 驱动程序实例时使用的凭据将取决于你是否使用 Neo4j Desktop、Neo4j
    Sandbox 或 Neo4j Aura，以及你最初选择的密码。请确保调整你的特定 Neo4j 实例的连接凭据。
- en: If we tried to run our GraphQL API application now, we would quickly see an
    error message complaining that we haven’t provided GraphQL type definitions. We
    must provide GraphQL type definitions that define the GraphQL API, so the next
    step is to fill in our GraphQL type definitions.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在尝试运行我们的 GraphQL API 应用程序，我们会很快看到一条错误消息，抱怨我们没有提供 GraphQL 类型定义。我们必须提供定义
    GraphQL API 的 GraphQL 类型定义，因此下一步是填写我们的 GraphQL 类型定义。
- en: 4.3.2 Generated GraphQL schema from type definitions
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.2 从类型定义生成 GraphQL 模式
- en: 'Following the GraphQL-first approach described previously, our GraphQL type
    definitions will drive the API specification. In this case, we know what data
    we want to expose (our sample dataset loaded in Neo4j), so we can refer to the
    table of node properties shown previously and apply a simple rule as we create
    our GraphQL type definitions: Node labels become types, taking on the node properties
    as fields. We also need to define relationship fields in our GraphQL type definitions.
    Let’s first look at the complete type definitions in the next listing and then
    explore how we define relationship fields.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 按照之前描述的 GraphQL 首选方法，我们的 GraphQL 类型定义将驱动 API 规范。在这种情况下，我们知道我们想要公开什么数据（我们加载到
    Neo4j 中的示例数据集），因此我们可以参考之前显示的节点属性表，并在创建我们的 GraphQL 类型定义时应用一个简单的规则：节点标签成为类型，承担节点属性作为字段。我们还需要在我们的
    GraphQL 类型定义中定义关系字段。让我们首先查看下一列表中的完整类型定义，然后探讨我们如何定义关系字段。
- en: 'Listing 4.5 index.js: GraphQL type definitions'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.5 index.js：GraphQL 类型定义
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '@relationship GraphQL schema directive'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '@relationship GraphQL 模式指令'
- en: In the property graph model used by Neo4j, every relationship has a direction
    and type. To represent this in GraphQL, we make use of GraphQL schema directives—specifically,
    the @relationship schema directive. A directive is similar to an annotation in
    our GraphQL type definitions. It is an identifier preceded by the @ character,
    and may then, optionally, contain a list of named arguments. Schema directives
    are GraphQL’s built-in extension mechanism, indicating some custom logic for the
    GraphQL server implementation.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Neo4j 使用的属性图模型中，每个关系都有一个方向和类型。为了在 GraphQL 中表示这一点，我们使用了 GraphQL 模式指令——特别是，@relationship
    模式指令。指令类似于我们在 GraphQL 类型定义中的注释。它是一个由 @ 字符前缀的标识符，然后可以（可选地）包含一个命名参数列表。模式指令是 GraphQL
    的内置扩展机制，表示 GraphQL 服务器实现的一些自定义逻辑。
- en: When defining relationship fields using the @relationship directive, the type
    argument indicates the relationship type stored in Neo4j, and the direction argument
    indicates the relationship direction. In addition to schema directives, directives
    can also be used in GraphQL queries to indicate specific behavior. We will see
    some examples of query directives when we explore managing client state using
    Apollo Client in our React application.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 @relationship 指令定义关系字段时，类型参数表示存储在 Neo4j 中的关系类型，方向参数表示关系方向。除了模式指令外，指令还可以在
    GraphQL 查询中使用，以指示特定的行为。当我们探索在 React 应用程序中使用 Apollo Client 管理客户端状态时，我们将看到一些查询指令的示例。
- en: 'Now, let’s run our API application:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行我们的 API 应用程序：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As output, we should see the address at which our API application is listening—in
    this case, on port 4000 on localhost:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 作为输出，我们应该看到我们的 API 应用程序正在监听的地址——在本例中，localhost 上的端口 4000：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Navigate to http://localhost:4000 in your web browser, and you should see the
    Apollo Studio landing page. Click the *Schema* icon in the upper-left corner of
    Apollo Studio in GraphQL to see the fully generated API (see figure 4.4). Spend
    a few minutes looking through the query field descriptions, and you’ll notice
    arguments have been added to types for things like ordering, pagination, and filtering.
    You can also toggle between *Reference* and *SDL* views to see the full generated
    GraphQL SDL, based on our initial GraphQL type definitions.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的网络浏览器中导航到 http://localhost:4000，您应该会看到 Apollo Studio 的登录页面。在 Apollo Studio
    的 GraphQL 中，点击左上角的 *Schema* 图标以查看完全生成的 API（见图 4.4）。花几分钟浏览查询字段描述，您会注意到已为诸如排序、分页和过滤之类的功能添加了参数。您还可以在
    *Reference* 和 *SDL* 视图之间切换，以查看基于我们初始 GraphQL 类型定义的完整生成的 GraphQL SDL。
- en: '![CH04_F04_Lyon](../../OEBPS/Images/CH04_F04_Lyon.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F04_Lyon](../../OEBPS/Images/CH04_F04_Lyon.png)'
- en: Figure 4.4 Apollo Studio showing our generated API
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 显示我们的生成 API 的 Apollo Studio
- en: 4.4 Basic GraphQL queries
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 基本GraphQL查询
- en: 'Now that we have our GraphQL server powered by Apollo Server and the Neo4j
    GraphQL library up and running, let’s start querying our API using Apollo Studio.
    Looking at the *Schema* tab in Apollo Studio, we can see the API entry points
    (in GraphQL parlance, each Query type field is an entry point to the API) available
    to us: Business, User, Review, and Category—one for each type defined in our type
    definitions. Let’s start by querying for all businesses and returning only the
    name field, as the next listing shows.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经有了由 Apollo Server 和 Neo4j GraphQL 库提供支持的 GraphQL 服务器正在运行，让我们开始使用 Apollo
    Studio 查询我们的 API。查看 Apollo Studio 的 *Schema* 选项卡，我们可以看到可用的 API 入口点（在 GraphQL 术语中，每个
    Query 类型字段是 API 的入口点）：Business、User、Review 和 Category——每个类型定义中有一个。让我们首先查询所有企业，并只返回名称字段，如下一个列表所示。
- en: Listing 4.6 GraphQL query to find all businesses
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.6 查询所有企业的 GraphQL 查询
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If we run this query in Apollo Studio, we should see a list of businesses names:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在 Apollo Studio 中运行此查询，我们应该看到企业名称列表：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Neat! This data has been fetched from our Neo4j instance for us, and we didn’t
    even need to write any resolvers!
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 真 neat！这些数据已经从我们的 Neo4j 实例中为我们获取，我们甚至不需要编写任何解析器！
- en: 'Let’s turn on debug logging for the Neo4j GraphQL library so we can see the
    generated Cypher queries being sent to the database. To do this, we’ll need to
    set a DEBUG environment variable. Let’s stop our GraphQL server by pressing Ctrl-C
    in the terminal, and now when we start the GraphQL API application again, we’ll
    set the DEBUG environment variable:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开 Neo4j GraphQL 库的调试日志，以便我们可以看到发送到数据库的生成 Cypher 查询。为此，我们需要设置一个 DEBUG 环境变量。让我们通过在终端中按
    Ctrl-C 停止我们的 GraphQL 服务器，然后当我们再次启动 GraphQL API 应用程序时，我们将设置 DEBUG 环境变量：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If we run our GraphQL query again and check the console output in the terminal,
    we can see the generated Cypher query logged to the terminal, as shown in the
    following listing.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次运行我们的GraphQL查询并检查终端的输出，我们可以在下一列表中看到生成的Cypher查询被记录到终端中。
- en: Listing 4.7 Generated Cypher query
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.7 生成的Cypher查询
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We can add additional fields to the GraphQL query, and those fields will be
    added to the generated Cypher query, returning only the data needed. For example,
    the GraphQL query adds the address of the business and the name field, as the
    next listing shows.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向GraphQL查询添加额外的字段，这些字段将被添加到生成的Cypher查询中，只返回所需的数据。例如，GraphQL查询添加了企业的地址和名称字段，如下一列表所示。
- en: Listing 4.8 GraphQL query to return business name and address
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.8 返回企业名称和地址的GraphQL查询
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The Cypher translation of the GraphQL query now includes the address field as
    well, as shown in the following listing.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的GraphQL查询的Cypher翻译包括地址字段，如下一列表所示。
- en: Listing 4.9 Generated Cypher query including address property
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.9 包含地址属性的生成的Cypher查询
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'And finally, when we examine the results of the GraphQL query, we now see an
    address listed for each business:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当我们检查GraphQL查询的结果时，我们现在看到每个企业都列出了一个地址：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Next, let’s take advantage of some of the features of the generated GraphQL
    API.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们利用生成的GraphQL API的一些功能。
- en: 4.5 Ordering and pagination
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5 排序和分页
- en: Each query field includes an input object argument options. We can specify values
    for limit and sort in this options argument to facilitate ordering and pagination.
    Here we search for the first three businesses ordered by the value of the name
    field.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 每个查询字段都包括一个输入对象参数options。我们可以在此选项参数中指定limit和sort的值，以方便排序和分页。在这里，我们按名称字段的值搜索前三个企业。
- en: Listing 4.10 Initial GraphQL API code including sort and limit
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.10 包含排序和限制的初始GraphQL API代码
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Ordering enums are generated for each type, offering ascending and descending
    options for each field. Running our query returns businesses now ordered by name,
    as shown in the next listing.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为每种类型生成排序枚举，为每个字段提供升序和降序选项。运行我们的查询现在返回按名称排序的企业，如下一列表所示。
- en: Listing 4.11 Paginated results
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.11 分页结果
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If we switch to the terminal, we can see the Cypher query generated from our
    GraphQL query, which now includes ORDER BY and LIMIT clauses that map to our first
    and orderBy GraphQL arguments, as the following listing shows. This means that
    the ordering and limiting is executed in the database, rather than in the client,
    so only the necessary data is returned from the database query.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们切换到终端，我们可以看到从我们的GraphQL查询生成的Cypher查询，现在包括ORDER BY和LIMIT子句，它们映射到我们的第一个和orderBy
    GraphQL参数，如下一列表所示。这意味着排序和限制是在数据库中执行的，而不是在客户端，因此只从数据库查询返回必要的数据。
- en: Listing 4.12 Generated Cypher query including sort and limit
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.12 包含排序和限制的生成的Cypher查询
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Note that this query includes a $first parameter, rather than the value 3 inline
    in the query. Parameter usage is important here because it ensures a user is not
    able to inject potentially malicious Cypher code into the generated query and
    also ensures the query plan generated by Neo4j can be reused, increasing performance.
    To run this query in Neo4j Browser, first set a value for the first parameter
    with the :param command:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此查询包含一个$first参数，而不是在查询中内联的值3。在此处参数使用很重要，因为它确保用户无法将可能有害的Cypher代码注入到生成的查询中，同时也确保Neo4j生成的查询计划可以重用，从而提高性能。要在Neo4j浏览器中运行此查询，首先使用:param命令为第一个参数设置一个值：
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 4.6 Nested queries
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.6 嵌套查询
- en: Cypher can easily express the types of graph traversals in our GraphQL queries,
    and the Neo4j GraphQL library is capable of generating the equivalent Cypher queries
    for arbitrary GraphQL requests, including nested queries. Now we traverse from
    businesses to their categories, as the next listing shows.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Cypher可以轻松表达我们GraphQL查询中的图遍历类型，Neo4j GraphQL库能够为任意的GraphQL请求生成等效的Cypher查询，包括嵌套查询。现在，如下一列表所示，我们从企业遍历到它们的类别。
- en: Listing 4.13 GraphQL query including nested selection set
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.13 包含嵌套选择集的GraphQL查询
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And the result shows each business is connected to one or more categories:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示每个企业都与一个或多个类别相连：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 4.7 Filtering
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.7 过滤
- en: The filter functionality is exposed by adding a where argument with associated
    inputs based on the GraphQL type definitions that expose filtering criteria. You
    can see the full list of filtering criteria in the documentation at [neo4j.com/docs/graphql-manual/current/filtering/](https://neo4j.com/docs/graphql-manual/current/filtering/).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加一个带有基于 GraphQL 类型定义的关联输入的 where 参数，暴露了过滤器功能。您可以在文档中查看完整的过滤标准列表，网址为 [neo4j.com/docs/graphql-manual/current/filtering/](https://neo4j.com/docs/graphql-manual/current/filtering/)。
- en: 4.7.1 where argument
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.7.1 where 参数
- en: In the next listing, we use the where argument to search for businesses with
    names that contain Brew.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个列表中，我们使用 where 参数来搜索名称中包含 Brew 的业务。
- en: Listing 4.14 GraphQL query filter for business names containing Brew
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.14 包含 Brew 的业务名称的 GraphQL 查询过滤器
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Our results now show businesses that match the filtering criteria, and only
    businesses that contain the string Brew in their name are returned:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的结果现在显示了符合过滤标准的业务，并且只返回名称中包含字符串 Brew 的业务：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 4.7.2 Nested filter
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.7.2 嵌套过滤
- en: To filter based on the results of nested fields applied to the root, we can
    nest our filter arguments. In the next listing, we search for businesses that
    contain the name Brew and that have at least one review with at least a 4.75 rating.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要根据应用于根的嵌套字段的結果进行过滤，我们可以嵌套我们的过滤器参数。在下一个列表中，我们搜索包含名称 Brew 且至少有一个至少评分为 4.75 的评论的业务。
- en: Listing 4.15 GraphQL query using a nested filter
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.15 使用嵌套过滤器的 GraphQL 查询
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If we inspect the results of this GraphQL query, we can see two matching businesses:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查这个 GraphQL 查询的结果，我们可以看到两个匹配的业务：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '4.7.3 Logical operators: AND, OR'
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.7.3 逻辑运算符：AND、OR
- en: Filters can be wrapped in logical operators OR and AND. For example, we can
    search for businesses in either the Coffee or Breakfast category by using an OR
    operator in the filter argument, as shown in the next listing.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器可以用逻辑运算符 OR 和 AND 进行包装。例如，我们可以在过滤器参数中使用 OR 运算符来搜索咖啡或早餐类别的企业，如下一个列表所示。
- en: Listing 4.16 GraphQL query with a filter using logical operators
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.16 使用逻辑运算符的过滤器的 GraphQL 查询
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This GraphQL query yields businesses that are connected to either the Coffee
    or Breakfast category:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 GraphQL 查询返回与咖啡或早餐类别相关联的业务：
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 4.7.4 Filtering in selections
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.7.4 选择中的过滤
- en: Filters can also be used throughout the selection set to apply the filter at
    the level of the selection. For example, let’s say that in the next listing, we
    want to find all Coffee or Breakfast businesses but only view reviews containing
    the phrase breakfast sandwich.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器也可以在整个选择集中使用，以在选择的级别应用过滤器。例如，假设在下一个列表中，我们想要找到所有咖啡或早餐企业，但只查看包含短语早餐三明治的评论。
- en: Listing 4.17 GraphQL query with filter argument in the selection set
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.17 在选择集中使用过滤器参数的 GraphQL 查询
- en: '[PRE29]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Since the filter was applied at the reviews selection, businesses that do not
    have any reviews containing the phrase breakfast sandwich are still shown in the
    results; however, only reviews containing that phrase are shown:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 由于过滤器是在评论选择上应用的，因此没有包含短语早餐三明治的评论的业务仍然显示在结果中；然而，只显示包含该短语的评论：
- en: '[PRE30]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 4.8 Working with temporal fields
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.8 使用时间字段
- en: Neo4j supports native temporal types as properties on nodes and relationships.
    These types include Date, DateTime, and LocalDateTime. With the Neo4j GraphQL
    library, you can use these temporal types in your GraphQL schema.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Neo4j 支持作为节点和关系的属性的原生时间类型。这些类型包括 Date、DateTime 和 LocalDateTime。使用 Neo4j GraphQL
    库，您可以在您的 GraphQL 模式中使用这些时间类型。
- en: 4.8.1 Using a Date type in queries
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.8.1 在查询中使用日期类型
- en: We’re using a Date type on the Review type. The Date type is represented by
    a string with the format yyyy-mm-dd but is stored as a native Date type in the
    database with support for date operations. Let’s query for the three most recent
    reviews in the next listing.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 Review 类型上使用日期类型。日期类型由 yyyy-mm-dd 格式的字符串表示，但在数据库中以原生日期类型存储，支持日期操作。让我们在下一个列表中查询最近的三条评论。
- en: Listing 4.18 GraphQL query using a date field
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.18 使用日期字段的 GraphQL 查询
- en: '[PRE31]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Since we specified the date field in our selection set, we see that in the
    results:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在选择集中指定了日期字段，因此我们在结果中看到：
- en: '[PRE32]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 4.8.2 Date and DateTime filters
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.8.2 日期和 DateTime 过滤器
- en: Temporal fields are also included in the generated filtering enums, allowing
    for filtering using dates and date ranges. In the next listing, let’s search for
    reviews created before January 1, 2017.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 时间字段也包含在生成的过滤枚举中，允许使用日期和日期范围进行过滤。在下一个列表中，我们将搜索在2017年1月1日之前创建的评论。
- en: Listing 4.19 GraphQL query using a date filter
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.19 使用日期过滤器进行 GraphQL 查询
- en: '[PRE33]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can see that the results are now ordered by the date field:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，结果现在按日期字段排序：
- en: '[PRE34]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 4.9 Working with spatial data
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.9 处理空间数据
- en: 'Neo4j currently supports the spatial point type, which can represent both 2D
    (e.g., latitude and longitude) and 3D (e.g., x,y,z or latitude, longitude, height)
    points, using both geographic coordinate reference systems (e.g., latitude and
    longitude) and Cartesian coordinate reference systems. The Neo4j GraphQL library
    makes available two spatial types: Point, for points using the geographic coordinate
    reference system, and CartesianPoint, for points using the Cartesian coordinate
    reference system. You can read more about working with spatial data in the Neo4j
    GraphQL library in this documentation: [http://mng.bz/qYKA](http://mng.bz/qYKA).'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Neo4j 目前支持空间点类型，它可以表示二维（例如，纬度和经度）和三维（例如，x,y,z 或纬度，经度，高度）的点，使用地理坐标参考系统（例如，纬度和经度）和笛卡尔坐标参考系统。Neo4j
    GraphQL 库提供了两种空间类型：Point，用于使用地理坐标参考系统的点，和 CartesianPoint，用于使用笛卡尔坐标参考系统的点。您可以在本文档中了解更多关于在
    Neo4j GraphQL 库中处理空间数据的信息：[http://mng.bz/qYKA](http://mng.bz/qYKA)。
- en: 4.9.1 The Point type in selections
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.9.1 选择中的 Point 类型
- en: Point type fields are object fields in the GraphQL schema, so let’s retrieve
    the latitude and longitude fields for our matching businesses by adding those
    fields to our selection set in the next listing.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Point 类型字段是 GraphQL 模式中的对象字段，因此让我们通过在下一个列表中添加这些字段来检索匹配商业实体的纬度和经度字段。
- en: Listing 4.20 GraphQL query using a Point field
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.20 使用 Point 字段进行 GraphQL 查询
- en: '[PRE35]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, in the GraphQL query result, we see longitude and latitude included for
    each business:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 GraphQL 查询结果中，我们看到每个商业实体都包含了经度和纬度：
- en: '[PRE36]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 4.9.2 Distance filter
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.9.2 距离过滤器
- en: When querying using point data, we often want to find things that are close
    to other things. For example, what businesses are within 1.5 km of me? We can
    accomplish this using the generated where argument, as the following listing shows.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用点数据进行查询时，我们经常想找到靠近其他事物的事物。例如，哪些商业实体在我 1.5 公里范围内？我们可以使用生成的 where 参数来完成此操作，如下列所示。
- en: Listing 4.21 GraphQL query using a distance filter
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.21 使用距离过滤器进行 GraphQL 查询
- en: '[PRE37]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'For points using the geographic coordinate reference system (latitude and longitude),
    distance is measured in meters:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用地理坐标参考系统（纬度和经度）的点，距离以米为单位：
- en: '[PRE38]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 4.10 Adding custom logic to our GraphQL API
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.10 向我们的 GraphQL API 添加自定义逻辑
- en: 'So far, we’ve seen basic querying operations created by the Neo4j GraphQL library.
    Often, we want to add custom logic to our API. For example, we may want to calculate
    the most popular business or recommend businesses to users. There are two options
    for adding custom logic to your API using the Neo4j GraphQL library: the @cypher
    schema directive or implementing custom resolvers.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了由 Neo4j GraphQL 库创建的基本查询操作。通常，我们想在我们的 API 中添加自定义逻辑。例如，我们可能想计算最受欢迎的商业或向用户推荐商业。使用
    Neo4j GraphQL 库向您的 API 添加自定义逻辑有两种选项：@cypher 模式指令或实现自定义解析器。
- en: 4.10.1 The @cypher GraphQL schema directive
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.10.1 @cypher GraphQL 模式指令
- en: The Neo4j GraphQL library exposes Cypher through GraphQL via the @cypher GraphQL
    schema directive. Annotate a field in your schema with the @cypher directive to
    map the results of that query to the annotated GraphQL field. The @cypher directive
    takes a single argument statement, which is a Cypher statement. Parameters are
    passed into this query at runtime, including this, which is the currently resolved
    node, as well as any field-level arguments defined in the GraphQL type definition.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Neo4j GraphQL 库通过 GraphQL 通过 @cypher GraphQL 模式指令暴露 Cypher。在您的模式中用 @cypher 指令注释一个字段，以将查询的结果映射到注释的
    GraphQL 字段。@cypher 指令接受一个参数语句，这是一个 Cypher 语句。参数在运行时传递到这个查询中，包括当前解析的节点，以及在任何 GraphQL
    类型定义中定义的字段级参数。
- en: NOTE The @cypher directive and other features of the Neo4j GraphQL library require
    the use of the APOC standard library plugin. Be sure you’ve followed the steps
    to install APOC in the *Project Setup* section of this chapter.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：@cypher 指令和 Neo4j GraphQL 库的其他功能需要使用 APOC 标准库插件。请确保您已遵循本章 *项目设置* 部分的步骤安装
    APOC。
- en: Computed scalar fields
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 计算标量场
- en: We can use the @cypher directive to define a custom scalar field, creating a
    computed field in our schema. In the next listing, we add an averageStars field
    to the Business type, which calculates the average stars of all reviews for the
    business, using the this variable.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 @cypher 指令定义一个自定义标量字段，在我们的模式中创建一个计算字段。在下一个列表中，我们向 Business 类型添加一个 averageStars
    字段，该字段使用 this 变量计算业务所有评论的平均星级。
- en: 'Listing 4.22 index.js: Adding the averageStars field'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.22 index.js：添加 averageStars 字段
- en: '[PRE39]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We need to restart our GraphQL server, since we have modified the type definitions:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已修改了类型定义，我们需要重新启动我们的 GraphQL 服务器：
- en: '[PRE40]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now let’s include the averageStars field in our GraphQL query in the next listing.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在下一个列表中将 averageStars 字段包含在我们的 GraphQL 查询中。
- en: Listing 4.23 GraphQL query, including averageStars field
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.23 包含 averageStars 字段的 GraphQL 查询
- en: '[PRE41]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can see in the results that the computed value for averageStars is now included:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到在结果中，averageStars 的计算值现在已包含：
- en: '[PRE42]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If we check the terminal output to see the generated Cypher query, we will notice
    that the generated Cypher query includes the annotated Cypher query from our @cypher
    directive as a subquery, preserving the single database call to resolve the GraphQL
    request but still including our custom logic!
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查终端输出以查看生成的 Cypher 查询，我们会注意到生成的 Cypher 查询将我们的 @cypher 指令中的注释 Cypher 查询作为子查询包含在内，保留了单个数据库调用以解析
    GraphQL 请求，但仍然包括我们的自定义逻辑！
- en: Computed object and array fields
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 计算对象和数组字段
- en: We can also use the @cypher schema directive to resolve object and array fields.
    Let’s add a recommended business field to the Business type. We’ll use a simple
    Cypher query to find common businesses that other users reviewed. For example,
    if a user likes Market on Front, we could recommend other businesses that were
    also reviewed by users who reviewed Market on Front.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 @cypher 模式指令来解析对象和数组字段。让我们向 Business 类型添加一个推荐的业务字段。我们将使用一个简单的 Cypher
    查询来查找其他用户评论过的共同业务。例如，如果一个用户喜欢 Front 上的 Market，我们可以推荐其他也被 Market on Front 的评论者评论过的业务。
- en: Listing 4.24 Cypher query to find recommended businesses
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.24 查找推荐业务的 Cypher 查询
- en: '[PRE43]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We can make use of this Cypher query in our GraphQL schema by including it in
    a @cypher directive on the recommended field in our Business type definition.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在我们的 Business 类型定义中的推荐字段上包含 @cypher 指令来在我们的 GraphQL 模式中使用此 Cypher 查询。
- en: 'Listing 4.25 index.js: Adding the recommended field'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.25 index.js：添加推荐字段
- en: '[PRE44]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We also define a first field argument, which is passed to the Cypher query included
    in the @cypher directive as a Cypher parameter and acts as a limit on the number
    of recommended businesses returned.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了一个第一个字段参数，它作为 Cypher 查询传递给 @cypher 指令的 Cypher 参数，并作为返回推荐业务数量的限制。
- en: Custom top-level query fields
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义顶级查询字段
- en: Another helpful way to use the @cypher directive is as a custom query or mutation
    field. For example, let’s see how we can add full-text query support to search
    for businesses. Applications often use full-text search to correct for things
    like misspellings in user input using fuzzy matching. In Neo4j, we can use full-text
    search by first creating a full-text index.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 @cypher 指令的另一种有用方式是作为自定义查询或突变字段。例如，让我们看看我们如何添加全文查询支持以搜索业务。应用程序通常使用全文搜索来纠正用户输入中的拼写错误等问题，使用模糊匹配。在
    Neo4j 中，我们可以通过首先创建全文索引来使用全文搜索。
- en: 'Listing 4.26 Cypher: Creating full-text index'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.26 创建全文索引的 Cypher
- en: '[PRE45]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Then, to query the index in this case we misspell libary, but including the
    ~ character enables fuzzy matching, ensuring we still find what we’re looking
    for.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了查询此索引，我们拼写错误为 libary，但包括 ~ 字符启用模糊匹配，确保我们仍然能找到我们想要的东西。
- en: 'Listing 4.27 Cypher: Querying the full-text index'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.27 查询全文索引的 Cypher
- en: '[PRE46]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Wouldn’t it be nice to include this fuzzy-matching full-text search in our GraphQL
    API? To do that, let’s create a query field, called fuzzyBusinessByName, which
    takes a search string and searches for businesses, as shown in the following listing.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 将这种模糊匹配的全文搜索包含在我们的 GraphQL API 中不是很好吗？为了做到这一点，让我们创建一个名为 fuzzyBusinessByName
    的查询字段，它接受一个搜索字符串并搜索业务，如下所示。
- en: 'Listing 4.28 index.js: Adding a custom Query field'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.28 index.js：添加自定义查询字段
- en: '[PRE47]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Again, since we’ve updated the type definitions, we must restart the GraphQL
    API application:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已更新了类型定义，我们必须重新启动 GraphQL API 应用程序：
- en: '[PRE48]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: If we check the *Schema* tab in Apollo Studio, we will see a new Query field,
    fuzzyBusinessByName, and we can now search for business names using this fuzzy
    matching, as the next listing shows.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在 Apollo Studio 中检查 *Schema* 选项卡，我们会看到一个新查询字段 fuzzyBusinessByName，现在我们可以使用这个模糊匹配来搜索企业名称，如下所示。
- en: Listing 4.29 GraphQL query using our custom Query field
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.29 使用我们的自定义查询字段进行 GraphQL 查询
- en: '[PRE49]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Since we are using full-text search, even though we spelled libary incorrectly,
    we still find matching results:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用全文搜索，即使我们拼写 libary 错误，我们仍然可以找到匹配的结果：
- en: '[PRE50]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The @cypher schema directive is a powerful way to add custom logic and advanced
    functionality to our GraphQL API. We can also use the @cypher directive for authorization
    features, accessing values, such as authorization tokens, from the request object—a
    pattern that will be discussed in a later chapter when we explore different options
    for adding authorization to our API. You can read more about the @cypher GraphQL
    schema directive in the documentation: [http://mng.bz/7yom](http://mng.bz/7yom).'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '@cypher 模式指令是一种强大的方式，可以为我们添加自定义逻辑和高级功能到我们的 GraphQL API。我们还可以使用 @cypher 指令来实现授权功能，从请求对象中访问值，例如授权令牌，这一模式将在后续章节中讨论，当我们探索向我们的
    API 添加授权的不同选项时。您可以在文档中了解更多关于 @cypher GraphQL 模式指令的信息：[http://mng.bz/7yom](http://mng.bz/7yom)。'
- en: 4.10.2 Implementing custom resolvers
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.10.2 实现自定义解析器
- en: While the @cypher directive is one way to add custom logic, in some cases we
    may need to implement custom resolvers that implement logic that is unable to
    be expressed in Cypher. For example, we may need to fetch data from another system
    or apply some custom validation rules. In these cases, we can implement a custom
    resolver and attach it to the GraphQL schema, so that resolver is called to resolve
    our custom field instead of relying on the Cypher query generated by the Neo4j
    GraphQL library to resolve the field.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 @cypher 指令是一种添加自定义逻辑的方法，但在某些情况下，我们可能需要实现无法用 Cypher 表达的自定义解析器。例如，我们可能需要从另一个系统获取数据或应用一些自定义验证规则。在这些情况下，我们可以实现一个自定义解析器并将其附加到
    GraphQL 模式上，这样解析器就会被调用以解析我们的自定义字段，而不是依赖于 Neo4j GraphQL 库生成的 Cypher 查询来解析字段。
- en: In our example, let’s imagine there is an external system that can be used to
    determine current wait times at businesses. We want to add an additional waitTime
    field to the Business type in our schema and implement the resolver logic for
    this field to use this external system.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，让我们假设有一个外部系统可以用来确定企业当前的等待时间。我们想在我们的模式中为 Business 类型添加一个额外的 waitTime
    字段，并实现这个字段的解析逻辑以使用这个外部系统。
- en: To do this, we first add the field to our schema, adding the @ignore directive
    to ensure the field is excluded from the generated Cypher query, as the next listing
    shows. This is our way of telling the Neo4j GraphQL library that a custom resolver
    will be responsible for resolving this field, and we don’t expect it to be fetched
    from the database automatically.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们首先在我们的模式中添加这个字段，添加 @ignore 指令以确保该字段被排除在生成的 Cypher 查询之外，如下列所示。这是我们告诉
    Neo4j GraphQL 库自定义解析器将负责解析这个字段，并且我们不期望它自动从数据库中检索。
- en: 'Listing 4.30 index.js: Adding the waitTime field'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.30 index.js：添加 waitTime 字段
- en: '[PRE51]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Next, we create a resolver map with our custom resolver, as shown in listing
    4.31\. We didn’t have to create this previously because the Neo4j GraphQL library
    generated our resolvers for us. Our wait time calculation will involve just selecting
    a value at random, but we could implement any custom logic here to determine the
    waitTime value, such as making a request to a third-party API.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个包含我们自定义解析器的解析器映射，如下列 4.31 所示。我们之前不需要创建这个映射，因为 Neo4j GraphQL 库为我们生成了解析器。我们的等待时间计算将仅涉及随机选择一个值，但我们可以在这里实现任何自定义逻辑来确定
    waitTime 值，例如向第三方 API 发送请求。
- en: 'Listing 4.31 index.js: Creating a resolver map'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.31 index.js：创建解析器映射
- en: '[PRE52]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Then, we add this resolver map to the parameters passed to the Neo4jGraphQL
    constructor, as the following listing shows.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将这个解析器映射添加到传递给 Neo4jGraphQL 构造函数的参数中，如下列所示。
- en: 'Listing 4.32 index.js: Generating the GraphQL schema'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.32 index.js：生成 GraphQL 模式
- en: '[PRE53]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, we restart the GraphQL API application, since we’ve updated the code:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们重新启动 GraphQL API 应用程序，因为我们已经更新了代码：
- en: '[PRE54]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: After restarting, in Apollo Studio, if we check the schema for the business
    type, we will see our new field waitTime on the Business type. In the next listing,
    let’s search for restaurants and see what their wait times are by including the
    waitTime field in the selection set.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 重启后，在Apollo Studio中，如果我们检查业务类型的模式，我们将看到业务类型上的新字段waitTime。在下一个列表中，让我们通过在选择集中包含waitTime字段来搜索餐厅并查看它们的等待时间。
- en: Listing 4.33 GraphQL query using field with custom resolver
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.33 使用自定义解析器的GraphQL查询
- en: '[PRE55]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In the results, we now see a value for the wait time. Your results will, of
    course, vary, since the value is randomized:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在结果中，我们现在可以看到等待时间的一个值。当然，你的结果会有所不同，因为值是随机的：
- en: '[PRE56]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 4.11 Introspecting GraphQL schema from an existing database
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.11 从现有数据库检查GraphQL模式
- en: Typically, when we start a new application, we don’t have an existing database
    and follow the GraphQL-first development paradigm by starting with type definitions.
    However, in some cases, we may have an existing Neo4j database populated with
    data. In those cases, it can be convenient to generate GraphQL type definitions
    based on the existing database that can then be fed into the Neo4j GraphQL library
    to generate a GraphQL API for the existing database. We can do this with the use
    of the @neo4j/ introspector package.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们开始一个新的应用程序时，我们没有现有的数据库，并且遵循GraphQL-first开发范式，从类型定义开始。然而，在某些情况下，我们可能有一个用数据填充的现有Neo4j数据库。在这些情况下，根据现有数据库生成GraphQL类型定义可能很方便，然后可以将这些类型定义输入到Neo4j
    GraphQL库中，为现有数据库生成GraphQL API。我们可以使用@neo4j/introspector包来完成这项工作。
- en: 'First, we’ll need to install the @neo4j/introspector package:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要安装@neo4j/introspector包：
- en: '[PRE57]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This Node.js script will connect to our Neo4j database and introspect the GraphQL
    type definitions that describe this data, as shown in the next listing; then we
    will write those type definitions to a file named schema.graphql.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Node.js脚本将连接到我们的Neo4j数据库，并检查描述此数据的GraphQL类型定义，如下所示；然后我们将这些类型定义写入名为schema.graphql的文件。
- en: 'Listing 4.34 intropect.js: Introspecting GraphQL type definitions'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.34 intropect.js：检查GraphQL类型定义
- en: '[PRE58]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Then, we can load this schema.graphql file and pass the type definitions to
    the Neo4jGraphQL constructor as the following listing shows.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以加载这个schema.graphql文件，并将类型定义传递给Neo4jGraphQL构造函数，如下所示。
- en: Listing 4.35 Loading our GraphQL type definitions from schema.graphql
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.35 从schema.graphql加载我们的GraphQL类型定义
- en: '[PRE59]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: So far, all of our GraphQL querying has been done using Apollo Studio, which
    is great for testing and development, but typically, our goal is to build an application
    that queries the GraphQL API. In the next few chapters, we’ll start to build out
    the user interface for our business reviews application using React and Apollo
    Client. Along the way, we will learn more about GraphQL concepts, such as mutations,
    fragments, interface types, and more!
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所有的GraphQL查询都是使用Apollo Studio完成的，这对于测试和开发来说很棒，但通常我们的目标是构建一个查询GraphQL
    API的应用程序。在接下来的几章中，我们将开始构建我们的业务评论应用程序的用户界面，使用React和Apollo Client。在这个过程中，我们将学习更多关于GraphQL概念的知识，如mutations、fragments、interface
    types等！
- en: 4.12 Exercises
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.12 练习
- en: Query the GraphQL API we created in this chapter, using Apollo Studio to find
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Apollo Studio查询本章中创建的GraphQL API
- en: Which users have reviewed the business named Hanabi.
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些用户评论了名为Hanabi的企业。
- en: Find any reviews that contain the word comfortable. What businesses are they
    reviewing?
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找包含单词“舒适”的任何评论。他们评论的是哪些企业？
- en: Which users have given no 5-star reviews?
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些用户没有给出五星级的评论？
- en: Add a @cypher directive field to the Category type that computes the number
    of businesses in each category. How many businesses are in the Coffee category?
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向Category类型添加一个@cypher指令字段，计算每个类别中的企业数量。咖啡类别中有多少家企业？
- en: Create a Neo4j Sandbox instance at [https://sandbox.neo4j.com](https://sandbox.neo4j.com),
    choosing from any of the prepopulated datasets. Using the @neo4j/introspector
    package, create a GraphQL API for this Neo4j Sandbox instance without manually
    writing GraphQL type definitions. What data can you query for using GraphQL?
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在[https://sandbox.neo4j.com](https://sandbox.neo4j.com)创建一个Neo4j沙盒实例，从任何预填充的数据集中选择。使用@neo4j/introspector包，为这个Neo4j沙盒实例创建一个GraphQL
    API，而无需手动编写GraphQL类型定义。你可以使用GraphQL查询哪些数据？
- en: 'Refer to the book’s GitHub repository to see the exercise solutions: [http://mng.bz/mOYP](http://mng.bz/mOYP).'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅本书的GitHub仓库以查看练习解决方案：[http://mng.bz/mOYP](http://mng.bz/mOYP)。
- en: Summary
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Common problems that arise when building GraphQL APIs include the *n* + 1 query
    problem, schema duplication, and a large amount of boilerplate data-fetching code.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在构建GraphQL API时可能会遇到的一些常见问题包括*n* + 1查询问题、模式重复和大量样板数据获取代码。
- en: GraphQL database integrations, like the Neo4j GraphQL library, can help mitigate
    these problems by generating database queries from GraphQL requests, driving database
    schema from GraphQL type definitions, and autogenerating a GraphQL API from GraphQL
    type definitions.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像Neo4j GraphQL库这样的GraphQL数据库集成可以通过从GraphQL请求生成数据库查询、从GraphQL类型定义驱动数据库模式以及从GraphQL类型定义自动生成GraphQL
    API来帮助缓解这些问题。
- en: The Neo4j GraphQL library makes it easy to build GraphQL APIs backed by a Neo4j
    database by generating resolvers for data fetching and adding filtering, ordering,
    and pagination to the generated API.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Neo4j GraphQL库通过生成用于数据获取的解析器，并添加过滤、排序和分页到生成的API，使得基于Neo4j数据库构建GraphQL API变得容易。
- en: Custom logic can be added to our GraphQL API by using the @cypher schema directive
    to define custom logic for fields or by implementing custom resolvers and attaching
    them to the GraphQL schema.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用@cypher模式指令来定义字段的自定义逻辑，或者实现自定义解析器并将它们附加到GraphQL模式中，我们可以向我们的GraphQL API添加自定义逻辑。
- en: If we have an existing Neo4j database, we can use the @neo4j/introspector package
    to generate GraphQL type definitions and a GraphQL API on top of the existing
    database.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们有一个现有的Neo4j数据库，我们可以使用@neo4j/introspector包在现有数据库上生成GraphQL类型定义和GraphQL API。
