- en: 9 Advanced GraphQL considerations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 高级 GraphQL 考虑事项
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Using abstract types of unions and interfaces for their benefits
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用联合和接口的抽象类型带来的好处
- en: Paginating query results, using offsets and cursors
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用偏移量和游标分页查询结果
- en: Working with relationship properties, using Relay connection types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用关系属性，利用 Relay 连接类型进行操作
- en: 'So far, we haven’t leveraged one of the most powerful and important features
    of GraphQL’s type system—*abstract types*—which allow us to represent multiple
    concrete types in a single GraphQL field. Similarly, we also haven’t really made
    use of an important feature of the property graph model—*relationship properties*—which
    allow us to associate attributes with the relationships that connect nodes rather
    than just nodes themselves. In this chapter, we will see how to leverage the abstract
    union and interface types supported by GraphQL. We will also make use of relationship
    properties and, along the way, introduce GraphQL Connection objects and pagination
    methods. We will move away from our business review application and simplify our
    data model, focusing instead on an API for a simple online store that sells two
    types of products: books and videos.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有充分利用 GraphQL 类型系统中最强大和最重要的特性之一——*抽象类型*，它允许我们在单个 GraphQL 字段中表示多个具体类型。同样，我们也没有真正利用属性图模型的一个重要特性——*关系属性*，它允许我们将属性与连接节点的关联关系相关联，而不仅仅是节点本身。在本章中，我们将看到如何利用
    GraphQL 支持的抽象联合和接口类型。我们还将利用关系属性，并在过程中介绍 GraphQL 连接对象和分页方法。我们将从我们的业务审查应用转向简化我们的数据模型，转而关注一个简单的在线商店
    API，该商店销售两种类型的产品：书籍和视频。
- en: 9.1 GraphQL abstract types
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1 GraphQL 抽象类型
- en: 'GraphQL supports two abstract types: *interfaces* and *unions*. Abstract types
    allow us to represent multiple concrete types (or arrays of multiple types) in
    a single field. Interfaces are used when one or more fields are shared across
    concrete types and they declare the shared fields that must be implemented in
    the concrete type. In this way, an interface can be thought of as a contract that
    specifies the minimal set of fields that a type must have to implement the interface.
    Unions do not need to share fields across concrete types and do not share this
    idea of a contract. Unions are, therefore, simply a grouping of concrete types.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 支持两种抽象类型：*接口*和*联合*。抽象类型允许我们在单个字段中表示多个具体类型（或多个类型的数组）。当一或多个字段在具体类型之间共享时，使用接口；它们声明了必须在具体类型中实现共享的字段。这样，接口可以被视为一个合同，它指定了类型必须具有的最小字段集以实现接口。联合不需要在具体类型之间共享字段，也不共享这种合同的概念。因此，联合只是具体类型的简单分组。
- en: 9.1.1 Interface types
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.1 接口类型
- en: Interface types are used to represent multiple object types that are conceptually
    similar and share at least one common field. For example, our store API may have
    the concept of a *person*. Each person could be either a customer or an employee.
    Every person would have fields such as first name, last name, and username. However,
    only a customer would have a shipping address, and only an employee would have
    a hire date. In GraphQL type definitions, we can represent this concept, as shown
    in the next listing.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 接口类型用于表示概念上相似且至少共享一个公共字段的多种对象类型。例如，我们的商店 API 可能有一个 *person* 的概念。每个人可以是客户或员工。每个人都会有诸如姓名、姓氏和用户名等字段。然而，只有客户会有送货地址，只有员工会有雇佣日期。在
    GraphQL 类型定义中，我们可以表示这个概念，如以下列表所示。
- en: Listing 9.1 Defining an interface in GraphQL type definitions
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.1 在 GraphQL 类型定义中定义接口
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The implementing (or concrete) type must implement all the fields declared in
    the interface and can then define other fields associated with the type. Here,
    Customer and Employee both implement the Person interface and, therefore, must
    include the firstName, lastName, and username fields. Customer adds a shippingAddress
    field, and Employee adds a hireDate field.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 实现（或具体）类型必须实现接口中声明的所有字段，然后可以定义与类型相关联的其他字段。在这里，Customer 和 Employee 都实现了 Person
    接口，因此必须包含 firstName、lastName 和 username 字段。Customer 添加了 shippingAddress 字段，而 Employee
    添加了 hireDate 字段。
- en: Querying the people Query field would return an array of objects, where each
    object could be either an Employee or a Customer object. We use an *inline fragment*
    in the GraphQL query to specify the selection set and fields to be returned for
    each type, as shown in the following listing. Inline fragments allow us to request
    fields on the concrete type and include a type condition.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 查询“人”查询字段将返回一个对象数组，其中每个对象可以是员工或客户对象。我们在 GraphQL 查询中使用内联片段来指定要返回的每个类型的选择集和字段，如下所示。内联片段允许我们请求具体类型的字段并包含一个类型条件。
- en: Listing 9.2 Querying an interface using inline fragments
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.2 使用内联片段查询接口
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We also include the __typename meta field that tells us the concrete type of
    each object in the people array.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还包括了 __typename 元字段，它告诉我们人数组中每个对象的实际类型。
- en: 9.1.2 Union types
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.2 联合类型
- en: Unions are similar to interfaces in that they are abstract types that can be
    used to represent multiple concrete types; however, the concrete types composed
    in a union do not need to have any common fields. A common use case for unions
    is to represent a search result. For example, our store API may support a product
    search feature that allows a user to search for items that may be either books
    or videos. To enable this, we create a Product union that contains both Book and
    Video types and a Query field search that returns an array of Product objects,
    as shown in the next listing.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 联合体与接口类似，因为它们是抽象类型，可以用来表示多个具体类型；然而，联合体中组成的具体类型不需要有任何公共字段。联合体的一个常见用例是表示搜索结果。例如，我们的商店
    API 可能支持一个产品搜索功能，允许用户搜索可能是书籍或视频的项目。为了启用此功能，我们创建了一个包含书籍和视频类型的 Product 联合体以及一个返回产品对象数组的
    Query 字段搜索，如下一列表所示。
- en: Listing 9.3 Defining a union in GraphQL type definitions
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.3 在 GraphQL 类型定义中定义联合体
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Similar to how we query fields of the concrete type of an interface using an
    inline fragment, we use an inline fragment when querying unions. However, since
    a union type itself does not contain any fields, we can only ask for the __typename
    meta field when querying a union without using an inline fragment, as shown in
    the following listing.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们使用内联片段查询接口的具体类型的字段类似，我们在查询联合体时也使用内联片段。然而，由于联合体类型本身不包含任何字段，当我们查询联合体而不使用内联片段时，我们只能请求
    __typename 元字段，如下所示。
- en: Listing 9.4 Querying a union
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.4 查询联合体
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 9.1.3 Using abstract types with the Neo4j GraphQL library
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.3 使用 Neo4j GraphQL 库的抽象类型
- en: 'Now that we’ve explored interfaces and unions a bit, let’s see how we can make
    use of abstract types in a GraphQL API using the Neo4j GraphQL Library. Let’s
    leave behind our business reviews application and start a new application for
    our imagined book and video store. In a new directory, run the following command
    to create a new Node.js project:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对接口和联合体进行了一些探索，让我们看看如何使用 Neo4j GraphQL 库在 GraphQL API 中利用抽象类型。让我们放下我们的业务审查应用，开始一个新的应用，用于我们想象中的书店和视频店。在一个新的目录下，运行以下命令来创建一个新的
    Node.js 项目：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, we’ll install the dependencies for our new Node.js GraphQL API application,
    which should be familiar by now:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将安装我们新的 Node.js GraphQL API 应用程序的依赖项，这应该现在已经很熟悉了：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you’d like to keep working with the business reviews application from previous
    chapters, you can create a new Neo4j database in Neo4j Aura or locally, using
    Neo4j Desktop. Alternatively, you can keep using the same database and run the
    following Cypher statement to delete the business review data:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想继续使用前几章中的业务审查应用，你可以在 Neo4j Aura 或本地使用 Neo4j Desktop 创建一个新的 Neo4j 数据库。或者，你可以继续使用相同的数据库，并运行以下
    Cypher 语句来删除业务审查数据：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Create a new file .env to define the environment variables that specify the
    connection credentials for your Neo4j database, setting values for the environment
    variables NEO4J_USER, NEO4J_URI, and NEO4J_PASSWORD, as shown in the following
    listing.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的 .env 文件来定义指定 Neo4j 数据库连接凭据的环境变量，设置环境变量 NEO4J_USER、NEO4J_URI 和 NEO4J_PASSWORD
    的值，如下所示。
- en: 'Listing 9.5 .env: Be sure to replace the values with your Aura connection credentials'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.5 .env：请确保用您的 Aura 连接凭据替换以下值
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now that we have a new Node.js project and either a new or an empty Neo4j database,
    let’s start by defining the GraphQL type definitions for our API and see how abstract
    types can help simplify our API schema.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个新的 Node.js 项目以及一个新的或空的 Neo4j 数据库，让我们首先定义我们的 API 的 GraphQL 类型定义，看看抽象类型如何帮助我们简化
    API 架构。
- en: Modeling an online book and video store API
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 建模在线书店和视频店 API
- en: 'Let’s start our new API by going to the (virtual) whiteboard: [https://arrows.app](https://arrows.app).
    Following the graph data modeling process we identified in chapter 3, we will
    identify the entities (nodes) in our application, how they are connected (relationships),
    and their attributes (node properties). Let’s keep things simple and focus on
    users who will place orders and orders that will contain books and/or videos.
    Creating the property graph model to handle these requirements, we end up with
    a fairly straightforward graph model (see figure 9.1).'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们的新 API 开始，去（虚拟）白板：[https://arrows.app](https://arrows.app)。遵循我们在第3章中确定的图数据建模过程，我们将确定应用程序中的实体（节点），它们是如何连接的（关系），以及它们的属性（节点属性）。让我们保持简单，关注那些将下订单的用户以及将包含书籍和/或视频的订单。创建处理这些要求的属性图模型，我们最终得到一个相当直接的图模型（见图
    9.1）。
- en: '![CH09_F01_Lyon](../../OEBPS/Images/CH09_F01_Lyon.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![CH09_F01_Lyon](../../OEBPS/Images/CH09_F01_Lyon.png)'
- en: Figure 9.1 Graph data model for an online store that sells books and videos
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 销售书籍和视频的在线商店的图数据模型
- en: As we saw in chapter 4, we can use this property graph model diagram to translate
    GraphQL type definitions that map to this property graph model, using the @relationship
    GraphQL schema directive to capture the direction and type of our relationships,
    as the next listing shows.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第4章中看到的，我们可以使用这个属性图模型图来翻译映射到这个属性图模型的 GraphQL 类型定义，使用 @relationship GraphQL
    模式指令来捕获我们关系的方向和类型，如下面的列表所示。
- en: Listing 9.6 GraphQL type definitions for our online store data model
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.6 我们在线商店数据模型的 GraphQL 类型定义
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that we’re making use of the @id and @timestamp directives to autogenerate
    these values, so the client won’t need to pass them to the API. Our client shouldn’t
    be concerned with generating a random unique ID for orders or passing the time
    that the order was created, as doing this would also open up security implications.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在使用 @id 和 @timestamp 指令来自动生成这些值，因此客户端不需要将它们传递给 API。我们的客户端不应该担心为订单生成一个随机的唯一
    ID，或者传递订单创建的时间，因为这样做也会带来安全影响。
- en: But take a look at the Order.books and Order.videos fields. To see what products
    are contained in the order, our client will need to request both of those fields—one
    of which may be an empty array. This is a bit awkward for the client; let’s see
    how we can improve this with the use of abstract types, specifically with the
    use of a union type, since our Video and Book type do not share any common fields.
    Instead of the Order.books and Order.videos fields, let’s define a new union type
    Product in the next listing and add an Order.products field, which will allow
    us to work with products connected to the order (whether they be books or videos)
    in a single field.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 但看看 Order.books 和 Order.videos 字段。为了看到订单中包含的产品，我们的客户端需要请求这两个字段——其中一个可能是空数组。这对客户端来说有点尴尬；让我们看看我们如何通过使用抽象类型，特别是使用联合类型来改进这一点，因为我们的
    Video 和 Book 类型没有共享任何公共字段。而不是 Order.books 和 Order.videos 字段，让我们在下一个列表中定义一个新的联合类型
    Product，并添加一个 Order.products 字段，这将允许我们在单个字段中处理与订单连接的产品（无论是书籍还是视频）。
- en: Listing 9.7 GraphQL type definitions for our online store data model using a
    union type
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.7 使用联合类型为我们在线商店数据模型定义的 GraphQL 类型定义
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Defining a union type named Product, which can be of type either Video or
    Book
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义一个名为 Product 的联合类型，可以是 Video 或 Book 类型
- en: ❷ Using our new Product type in a relationship field on the Order type
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在 Order 类型上的关系字段中使用我们新的 Product 类型
- en: Creating the GraphQL server
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 GraphQL 服务器
- en: Now that we’ve finalized our GraphQL type definitions, let’s use them to create
    a GraphQL API using the Neo4j GraphQL Library. Let’s create a new index.js with
    these new type definitions and the code necessary to create a GraphQL API using
    Apollo Server and the Neo4j GraphQL Library, as shown next.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经最终确定了我们的 GraphQL 类型定义，让我们使用它们来创建一个使用 Neo4j GraphQL 库的 GraphQL API。让我们创建一个新的
    index.js，包含这些新的类型定义以及使用 Apollo 服务器和 Neo4j GraphQL 库创建 GraphQL API 所需的代码，如下所示。
- en: 'Listing 9.8 index.js: GraphQL API for our online store'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.8 index.js：我们的在线商店的 GraphQL API
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The structure of this file should be familiar from past chapters in which we
    defined GraphQL type definitions, created a Neo4j driver instance, and generated
    a GraphQL schema using the Neo4j GraphQL Library to be served by Apollo Server.
    Now let’s start our GraphQL server:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件的结构应该与过去章节中我们定义 GraphQL 类型定义、创建 Neo4j 驱动实例以及使用 Neo4j GraphQL 库生成 GraphQL
    模式以由 Apollo 服务器提供的内容相似。现在让我们开始我们的 GraphQL 服务器：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Using abstract types in GraphQL mutations
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GraphQL 模式突变中使用抽象类型
- en: Next, let’s open our web browser and navigate to http://localhost:4000, where
    we will use Apollo Studio and start creating some data in the database, using
    the GraphQL mutations generated by the Neo4j GraphQL Library in our schema. First,
    let’s create two users, using the generated createUsers GraphQL mutation, as shown
    next.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们打开我们的网络浏览器并导航到 http://localhost:4000，在那里我们将使用 Apollo Studio 并开始使用我们模式中由
    Neo4j GraphQL 库生成的 GraphQL 变更在数据库中创建一些数据。首先，让我们使用生成的 createUsers GraphQL 变更创建两个用户，如下所示。
- en: 'Listing 9.9 GraphQL mutation: Creating users'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.9 GraphQL 变更：创建用户
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the response to this GraphQL operation, we should see the user objects with
    the usernames we passed in the mutation operation:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 GraphQL 操作的响应中，我们应该看到用户对象，这些用户名是我们传递给变更是操作的：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the next listing, let’s create some products for our store, which we said
    sells books and videos. To do this, we’ll use both the createBooks and createVideos
    mutations.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个列表中，让我们为我们的商店创建一些产品，正如我们所说的，这个商店销售书籍和视频。为此，我们将使用 createBooks 和 createVideos
    变更。
- en: 'Listing 9.10 GraphQL mutation: Creating products'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.10 GraphQL 变更：创建产品
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And in the response, we will have arrays with the book and video objects we
    just created:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在响应中，我们将有包含我们刚刚创建的书籍和视频对象的数组：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now we’re ready to create some orders. There are a few different ways we could
    go about this—for example, by using the updateUsers mutation—but let’s use the
    createOrders mutation, as shown in the next listing. Since the values for the
    created and orderId fields are being autogenerated for us, we don’t need to specify
    those values in the mutation.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好创建一些订单了。我们可以用几种不同的方式来做这件事——例如，使用 updateUsers 变更——但让我们使用 createOrders
    变更，如下一个列表所示。由于创建和 orderId 字段的值正在为我们自动生成，我们不需要在变更是中指定这些值。
- en: 'Listing 9.11 GraphQL mutation: Creating a single order'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.11 GraphQL 变更：创建单个订单
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Notice the use of inline fragments in the products selection. We know that
    this field returns an array of Product objects, which is a union type, and each
    object could resolve to be either a Book or Video. We can add the __typename field
    to the selection, which will tell us the concrete type of each object, but to
    return the actual fields of the concrete type (Book or Video), we need to use
    an inline fragment to specify the fields to be returned when the concrete type
    of the object being resolved matches the type specified in the inline fragment:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在产品选择中使用了内联片段。我们知道该字段返回一个 Product 对象数组，这是一个联合类型，并且每个对象可以解析为 Book 或 Video。我们可以向选择中添加
    __typename 字段，这将告诉我们每个对象的实际类型，但为了返回实际类型的字段（Book 或 Video），我们需要使用内联片段来指定当解析的对象的实际类型与内联片段中指定的类型匹配时要返回的字段：
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the response object, we will see that our order objects have been assigned
    random ID values as well as timestamps. Notice that our products array is a mix
    of Book and Video objects:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在响应对象中，我们将看到我们的订单对象已经被分配了随机 ID 值以及时间戳。注意，我们的产品数组是 Book 和 Video 对象的混合：
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If we use Neo4j Browser to inspect the data we’ve created in the database via
    our GraphQL API so far, we can see the graph representation of our order, users,
    and products and how they are connected (see figure 9.2).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 Neo4j 浏览器来检查我们通过我们的 GraphQL API 创建的数据，我们可以看到我们的订单、用户和产品的图表示以及它们是如何连接的（见图
    9.2）。
- en: '![CH09_F02_Lyon](../../OEBPS/Images/CH09_F02_Lyon.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![CH09_F02_Lyon](../../OEBPS/Images/CH09_F02_Lyon.png)'
- en: Figure 9.2 An order containing two books and a video
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 包含两本书和一个视频的订单
- en: In the next listing, let’s create a few more orders using another GraphQL mutation.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个列表中，让我们使用另一个 GraphQL 变更创建更多订单。
- en: 'Listing 9.12 GraphQL mutation: Creating multiple orders'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.12 GraphQL 变更：创建多个订单
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Notice that we can pass an array of input objects to create several orders
    in a single GraphQL mutation:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可以传递一个输入对象数组，在单个 GraphQL 变更中创建多个订单：
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now that we’ve created several orders and their associated books and videos,
    let’s explore how we can paginate data results in GraphQL.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了几个订单及其相关的书籍和视频，让我们探索如何在 GraphQL 中分页数据结果。
- en: 9.2 Pagination with GraphQL
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2 使用 GraphQL 进行分页
- en: Many applications display data in tables or lists. When populating these list
    views, it may make sense for the application to only request a subset of the total
    result set from the server—often, only the data needed to render the current view.
    For example, in the context of our online store, we may want to show a list of
    all orders sorted in chronological order or allow a specific user to view all
    their orders. However, there may be thousands, or even millions, of orders; we
    don’t want to fetch all of these orders from the server (that would be a lot of
    data to send over the network).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序在表格或列表中显示数据。当填充这些列表视图时，应用程序可能只从服务器请求总结果集的子集——通常，只需要渲染当前视图所需的数据。例如，在我们的在线商店的上下文中，我们可能想显示按时间顺序排序的所有订单列表，或者允许特定用户查看他们所有的订单。然而，可能有数千甚至数百万订单；我们不希望从服务器获取所有这些订单（那将需要通过网络发送大量数据）。
- en: 'Instead, we would *paginate* the order data by requesting certain chunks (or
    pages), as they are to be rendered in the application. For example, we may initially
    request the first 20 orders, sorted by date of creation. Then, when the user scrolls
    to the end of the first 20, the next page of results is requested from the server.
    GraphQL offers two types of pagination: *offset* and *cursor*.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们会通过请求某些块（或页），正如它们在应用程序中渲染的那样，来**分页**订单数据。例如，我们可能最初请求前20个订单，按创建日期排序。然后，当用户滚动到前20个订单的末尾时，就会从服务器请求下一页的结果。GraphQL提供了两种分页类型：**偏移**和**游标**。
- en: 9.2.1 Offset pagination
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.1 偏移分页
- en: '*Offset pagination* uses two field arguments, commonly called limit and offset,
    to chunk the results of an array field into pages. We typically use a third argument,
    sort, to specify the sort order for the array. The limit argument specifies the
    number of results to be included, and offset is the number of objects to skip
    before returning values and is incremented by the value used for limit to fetch
    the next page. For example, if we wanted to chunk our results into pages of size
    10, then the first page would use an offset value of 0 and a limit value of 10,
    the second page would use an offset value of 10 and a limit value of 10, and so
    on.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**偏移分页**使用两个字段参数，通常称为limit（限制）和offset（偏移），将数组字段的输出分块成页。我们通常使用第三个参数，sort（排序），来指定数组的排序顺序。limit参数指定要包含的结果数量，而offset是在返回值之前跳过的对象数量，并且通过limit的值递增以获取下一页。例如，如果我们想将结果分块成每页10个，那么第一页将使用偏移值0和限制值10，第二页将使用偏移值10和限制值10，依此类推。'
- en: Let’s imagine our store application has a *View Orders* view, in which all orders
    are displayed in a table, initially sorted by date of order creation. Our GraphQL
    query to load *all* that data might look something like the following.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象我们的商店应用程序有一个**查看订单**视图，在这个视图中，所有订单都按订单创建日期排序显示在表格中。加载所有这些数据的GraphQL查询可能看起来像以下这样。
- en: Listing 9.13 Querying for all orders sorted by date created
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.13 按创建日期排序查询所有订单
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This query is returning *all* orders. What if we have millions of orders? We
    would be sending too much data over the network, and our user would be waiting
    a long time for the page to load and show the orders! Our application is only
    capable of displaying so many orders at a time, anyway, so we end up not making
    use of most of the data. Instead, we want to *slice* our order results and only
    return a subset that is relevant for display in the application. We’ll paginate
    our orders into pages of size 2, requesting the first page, as the next listing
    shows.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询返回了**所有**订单。如果我们有数百万订单呢？我们会发送过多的数据到网络上，并且我们的用户将需要等待很长时间才能加载和显示订单！我们的应用程序一次只能显示这么多订单，所以最终我们没有充分利用大部分数据。相反，我们希望**切片**我们的订单结果，并且只返回与应用程序显示相关的子集。我们将订单分页到每页2个，请求第一页，如下所示。
- en: Listing 9.14 Querying for orders using offset pagination
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.14 使用偏移分页查询订单
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: GraphQL count queries for pagination
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL分页查询
- en: We then increment the offset value to give us the next page. But how do we know
    how many pages to request? We typically want to be able to display the total number
    of pages in the application so the user knows how much data they are dealing with.
    To facilitate this, we can make use of the *count queries*. The Neo4j GraphQL
    Library generates a count query field for each type that returns the number of
    nodes of that type in the database, as shown in the next listing. The client application
    can then use this number to compute the total number of pages.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们增加偏移量值以获取下一页。但我们如何知道要请求多少页？我们通常希望能够在应用程序中显示总页数，以便用户知道他们正在处理多少数据。为了便于实现这一点，我们可以利用
    *计数查询*。Neo4j GraphQL 库为每个在数据库中返回该类型节点数的类型生成一个计数查询字段，如下一列表所示。客户端应用程序可以使用这个数字来计算总页数。
- en: Listing 9.15 Offset pagination, including the ordersCount field
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.15 包含 ordersCount 字段的偏移量分页
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If we are using a filter, such as filtering for orders placed after a certain
    date, we can pass the same filter argument to the count query to determine the
    total number of results and calculate the number of pages to be displayed on the
    client.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用过滤器，例如过滤在某个日期之后下订单的订单，我们可以将相同的过滤器参数传递给计数查询以确定结果总数并计算客户端要显示的页数。
- en: 9.2.2 Cursor pagination
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.2 游标分页
- en: Cursor pagination is another commonly used model. Instead of using a numeric
    offset to slice the results into pages, we use a cursor, which is an opaque string
    value that identifies the last object in a page of results. To see cursor pagination
    in action, let’s imagine our application has a view of orders for a particular
    user; for example, a user may wish to view all orders they have placed, sorted
    by the date the order was created.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 游标分页是另一种常用的模型。我们不是使用数字偏移量来将结果切割成页面，而是使用一个游标，它是一个不透明的字符串值，用于标识结果页面中的最后一个对象。为了看到游标分页的实际应用，让我们想象我们的应用程序有一个特定用户的订单视图；例如，一个用户可能希望查看他们所有已下订单，按订单创建日期排序。
- en: To use cursor pagination with the Neo4j GraphQL Library, we start by requesting
    the ordersConnection field, instead of the orders field. The ordersConnection
    field is what is known as a Relay connection object. Let’s first see how these
    Relay connections are used and then explore the Relay connection model.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Neo4j GraphQL 库进行游标分页，我们首先请求 ordersConnection 字段，而不是 orders 字段。ordersConnection
    字段被称为 Relay 连接对象。让我们首先看看这些 Relay 连接是如何使用的，然后探索 Relay 连接模型。
- en: Listing 9.16 Using the ordersConnection Relay connection type
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.16 使用 ordersConnection Relay 连接类型
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Notice that our selection set for the ordersConnection field now includes nested
    edges and node fields. What’s going on there?
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们为 ordersConnection 字段的选取集中现在包括了嵌套的边和节点字段。那里发生了什么？
- en: The Relay connection model
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Relay 连接模型
- en: These *connection* fields are generated by the Neo4j GraphQL Library for each
    relationship field and conform to the “Relay Cursor Connections Specification”
    ([https://relay.dev/graphql/connections.htm](https://relay.dev/graphql/connections.htm)),
    commonly referred to as the *Relay specification* or *Relay connections*. *Relay*
    is a GraphQL client that includes many features beyond the scope of this book;
    however, this Relay specification has become a common blueprint for implementing
    cursor pagination in GraphQL and introduces the concept of a connection type.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 *连接* 字段由 Neo4j GraphQL 库为每个关系字段生成，并符合“Relay游标连接规范”（[https://relay.dev/graphql/connections.htm](https://relay.dev/graphql/connections.htm)），通常被称为
    *Relay规范* 或 *Relay连接*。*Relay* 是一个包含许多超出本书范围功能的 GraphQL 客户端；然而，这个 Relay 规范已成为在
    GraphQL 中实现游标分页的常见蓝图，并引入了连接类型的概念。
- en: These connection types provide a standard method for cursor pagination in two
    ways. First, common field arguments first and after are used for slicing and paginating
    results. Second, connections enable a standard method of paginating results, providing
    cursors and other meta information about the result set, such as whether any more
    results are available for the client to fetch in the paginated results.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这些连接类型以两种方式提供了游标分页的标准方法。首先，使用常见的字段参数 first 和 after 来切割和分页结果。其次，连接允许一种标准的方法来分页结果，提供游标和其他关于结果集的元信息，例如是否还有更多结果可供客户端在分页结果中获取。
- en: 'According to the Relay specification, each connection object must contain an
    edges array field and a pageInfo object field. The edges field is a list of *edge
    types*, defined by the Relay specification, that wrap the relationships, connecting
    nodes in our graph. The pageInfo field contains metadata about the page, such
    as hasNextPage and hasPreviousPage, as well as the cursors used for requesting
    the next and previous pages: startCursor and endCursor. Additionally, the Neo4j
    GraphQL Library adds a totalCount field that tells us the total number of edges.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 Relay 规范，每个连接对象必须包含一个 edges 数组字段和一个 pageInfo 对象字段。edges 字段是一个由 Relay 规范定义的
    *edge types* 列表，它封装了关系，连接我们图中的节点。pageInfo 字段包含有关页面的元数据，例如 hasNextPage 和 hasPreviousPage，以及用于请求下一页和前一页的游标：startCursor
    和 endCursor。此外，Neo4j GraphQL 库还添加了一个 totalCount 字段，它告诉我们边的总数。
- en: 'Let’s see this in action in the next listing. We will add the first: 2 field
    argument to our previous query to paginate orders in pages of size 2. We’ll also
    request the pageInfo object and the totalCount field.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看接下来的列表中是如何实现的。我们将向之前的查询添加第一个：2 字段参数，以分页大小为 2 的页面来分页订单。我们还将请求 pageInfo 对象和
    totalCount 字段。
- en: Listing 9.17 Using the pageInfo object to retrieve metadata
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.17 使用 pageInfo 对象检索元数据
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now our results include the first two orders, wrapped in the edges array, as
    well as the pageInfo metadata object that includes a cursor, endCursor, that we
    can use to fetch the next page of results:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在结果包括前两个订单，它们被封装在 edges 数组中，以及包含一个游标 endCursor 的 pageInfo 元数据对象，我们可以使用它来获取下一页的结果：
- en: '[PRE26]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: To request the next page of results, we include the value of the endCursor as
    the value of the after field argument for the ordersConnection field, as shown
    next.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要请求下一页的结果，我们将 endCursor 的值作为 ordersConnection 字段 after 字段参数的值，如下所示。
- en: Listing 9.18 Using cursor pagination to retrieve the next page of orders
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.18 使用游标分页检索下一页的订单
- en: '[PRE27]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This time, we will see in our results that hasNextPage is false, which tells
    us there are no more paginated results for the client to fetch:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们将在结果中看到 hasNextPage 是 false，这告诉我们没有更多分页结果供客户端获取：
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The Relay connection model provides a useful standard for cursor pagination.
    The edge types defined by the Relay specification also introduce a way of representing
    a powerful feature of the property graph model that we have yet to work with:
    relationship properties.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Relay 连接模型提供了一个有用的标准用于游标分页。由 Relay 规范定义的边类型还引入了一种表示属性图模型中我们尚未使用的一个强大功能的方法：关系属性。
- en: 9.3 Relationship properties
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3 关系属性
- en: In the property graph model, *relationship properties* are attributes stored
    on the relationship and are used to represent values that have meaning in the
    context of both end nodes connected by the relationship. For example, in our store
    data model, how would we represent the quantity of a specific item added to an
    order? The best way to represent this concept of quantity is by storing a property
    on the CONTAINS relationship that represents the quantity of that item (book or
    video) added to the order.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在属性图模型中，*关系属性* 是存储在关系上的属性，用于表示在关系连接的两个端节点上下文中具有意义的值。例如，在我们的存储数据模型中，我们如何表示添加到订单中的特定物品的数量？表示这个概念的最佳方式是在
    CONTAINS 关系上存储一个属性，表示添加到订单中的该物品（书籍或视频）的数量。
- en: '![CH09_F03_Lyon](../../OEBPS/Images/CH09_F03_Lyon.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![CH09_F03_Lyon](../../OEBPS/Images/CH09_F03_Lyon.png)'
- en: Figure 9.3 Updating the online store data model to include relationship properties
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 更新在线商店数据模型以包含关系属性
- en: In figure 9.3, we’ve added a quantity integer property to the CONTAINS relationship.
    Now, if, for example, we want to purchase two copies of the *Full Stack GraphQL*
    book when placing an order, we can set a value, 2, for this property. But how
    do we represent this in our GraphQL API?
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在图 9.3 中，我们已向 CONTAINS 关系添加了一个整型属性数量。现在，例如，如果我们想在下单时购买两本 *Full Stack GraphQL*
    书，我们可以为这个属性设置一个值，2。但我们在 GraphQL API 中如何表示这一点呢？
- en: 9.3.1 Interfaces and the @relationship GraphQL schema directive
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.1 接口和 @relationship GraphQL 模式指令
- en: We’ve used the @relationship directive with the Neo4j GraphQL Library to specify
    the property graph relationship type and direction, using the type and direction
    arguments. The @relationship directive also takes an optional argument, properties,
    that can be used to specify relationship properties. The properties argument takes
    the name of an interface type that defines the GraphQL fields to map to the relationship
    properties.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用@relationship指令与Neo4j GraphQL库一起指定属性图关系类型和方向，使用type和direction参数。@relationship指令还接受一个可选参数properties，可以用来指定关系属性。properties参数接受一个接口类型的名称，该类型定义了映射到关系属性的GraphQL字段。
- en: 'To represent the fields for our relationship properties, we first define an
    interface type that includes our relationship property fields. Since we only want
    to add a single relationship property field, quantity, on the CONTAINS relationship,
    we will create a Contains interface with a single field. Next, in the @relationship
    directive used on the Order.products field, we add properties: "Contains" to indicate
    we want to use the Contains interface to represent the relationship properties
    for the CONTAINS relationship. Our updated GraphQL type definitions are shown
    in the following listing; let’s go ahead and update these in index.js.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '为了表示我们的关系属性字段，我们首先定义一个包含我们的关系属性字段的接口类型。由于我们只想在CONTAINS关系上添加单个关系属性字段quantity，我们将创建一个包含单个字段的Contains接口。接下来，在Order.products字段上使用的@relationship指令中，我们添加properties:
    "Contains"，以表明我们想要使用Contains接口来表示CONTAINS关系的属性。我们的更新后的GraphQL类型定义如下所示；让我们继续在index.js中更新这些。'
- en: Listing 9.19 Using an interface to represent relationship properties in GraphQL
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.19 使用接口在GraphQL中表示关系属性
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note that since Product is a union type representing both the Video and Book
    type, we have captured defining the quantity relationship property for both videos
    and books—a great example of the power of abstract types! After updating the GraphQL
    type definitions in index.js, we’ll need to restart our GraphQL Node.js application.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于Product是一个联合类型，代表Video和Book类型，我们已捕获定义视频和图书的数量关系属性——这是抽象类型强大功能的一个绝佳例子！在更新index.js中的GraphQL类型定义后，我们需要重新启动我们的GraphQL
    Node.js应用程序。
- en: 9.3.2 Creating relationship properties
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.2 创建关系属性
- en: 'Now that we have updated our GraphQL type definitions to include the quantity
    relationship property, let’s see how we can make use of this new relationship
    property. First, we’ll create a new order, but this time, we’ll place an order
    for 10 copies of the *Full Stack GraphQL* book. To do this, we’ll include edge:
    { quantity: 10} in the connect object for the input object when using the createOrders
    mutation, as shown next.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我们已经更新了我们的GraphQL类型定义，包括数量关系属性，让我们看看我们如何利用这个新的关系属性。首先，我们将创建一个新的订单，但这次，我们将订购10本*Full
    Stack GraphQL*图书。为此，我们将在使用createOrders突变时，在输入对象的connect对象中包含edge: { quantity:
    10}，如以下所示。'
- en: Listing 9.20 Using relationship properties in a GraphQL mutation
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.20 在GraphQL突变中使用关系属性
- en: '[PRE30]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To retrieve the quantity value, we now have a field quantity on the edge type
    objects in the productsConnection field that indicates this order contains 10
    units of the book, as seen in the query results:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索数量值，我们现在在productsConnection字段中的边缘类型对象上有一个名为quantity的字段，它表示此订单包含10本图书，如查询结果所示：
- en: '[PRE31]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Thanks to the power of the Relay connection specification, we can now represent
    and work with relationship properties in GraphQL!
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了Relay连接规范的力量，我们现在可以在GraphQL中表示并处理关系属性！
- en: 9.4 Wrapping up Full Stack GraphQL
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.4 完成全栈GraphQL
- en: We’ve now learned how to leverage the power of GraphQL, graph databases, React,
    and cloud services to build and secure full stack web applications. The goal of
    this book was largely to show how the pieces of Full Stack GraphQL fit together.
    Let’s review what we’ve covered in the book and outline some paths for further
    learning resources.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经学会了如何利用GraphQL、图数据库、React和云服务构建和保障全栈Web应用程序的力量。本书的目标在很大程度上是展示全栈GraphQL各个部分的结合。让我们回顾一下本书中涵盖的内容，并概述一些进一步学习资源的路径。
- en: In part 1, we introduced graph thinking, GraphQL, and the Neo4j graph database.
    We learned the benefits of GraphQL, how to write GraphQL queries, and the basic
    approach to building GraphQL servers. Our graph thinking expanded to cover graph
    databases, and we introduced Neo4j and the Cypher query language. In part 2, we
    covered the React JavaScript framework for building user interfaces and using
    Apollo Client for GraphQL data fetching with our React application. Finally, in
    part 3, we tackled authentication and authorization in our GraphQL API and React
    application and deployment, using managed cloud services, like Auth0, Neo4j AuraDB,
    Netlify, and serverless functions.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1部分，我们介绍了图思维、GraphQL和Neo4j图数据库。我们学习了GraphQL的好处，如何编写GraphQL查询，以及构建GraphQL服务器的基本方法。我们的图思维扩展到覆盖图数据库，并介绍了Neo4j和Cypher查询语言。在第2部分，我们涵盖了用于构建用户界面的React
    JavaScript框架，以及使用Apollo Client在我们的React应用程序中获取GraphQL数据。最后，在第3部分，我们处理了在GraphQL
    API和React应用程序中的身份验证和授权，以及使用如Auth0、Neo4j AuraDB、Netlify和无服务器函数等托管云服务进行部署。
- en: The Neo4j GraphQL Library is a core component of Full Stack GraphQL, providing
    the ability to create powerful GraphQL APIs backed by Neo4j without writing boilerplate
    code; however, there are many features of the library we didn’t have a chance
    to cover in this book. As you continue your journey building applications with
    GraphQL, I encourage you to learn more about some of these features, such as working
    with aggregations and more of the schema directives, like @cypher and @auth, that
    allow us to enrich our GraphQL APIs. A resource for further learning around the
    Neo4j GraphQL Library is the documentation at [neo4j.com/docs/graphql-manual/current](https://neo4j.com/docs/graphql-manual/current/).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Neo4j GraphQL库是Full Stack GraphQL的核心组件，它提供了创建由Neo4j支持的强大GraphQL API的能力，而不需要编写样板代码；然而，我们在这本书中没有机会涵盖该库的许多功能。随着您继续使用GraphQL构建应用程序的旅程，我鼓励您更多地了解一些这些功能，例如使用聚合和更多的模式指令，如@cypher和@auth，这些指令允许我们丰富我们的GraphQL
    API。关于Neo4j GraphQL库的进一步学习资源是[neo4j.com/docs/graphql-manual/current](https://neo4j.com/docs/graphql-manual/current/)的文档。
- en: 'Another topic I would have liked to include in the book is working with React
    frameworks and tooling to improve the developer experience of building frontend
    applications with React. Next.js is one such framework that builds upon React
    and bundles many common features that are absent from React itself. With its API
    Routes feature, Next.js even includes the ability to build GraphQL APIs, an interesting
    approach to colocating backend logic. The Next.js Getting Started tutorial included
    in the Next.js documentation is an excellent hands-on introduction: [nextjs.org/docs/getting-started](https://nextjs.org/docs/getting-started).'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我还希望将另一个主题包含在本书中，那就是使用React框架和工具来提高使用React构建前端应用程序的开发者体验。Next.js就是这样一种框架，它建立在React之上，并捆绑了许多React本身所缺少的常见功能。凭借其API
    Routes功能，Next.js甚至包括构建GraphQL API的能力，这是一种将后端逻辑 colocated的有趣方法。Next.js文档中的入门教程是一个极好的动手介绍：[nextjs.org/docs/getting-started](https://nextjs.org/docs/getting-started)。
- en: To continue your graph journey with graph databases and Neo4j, the free online
    trainings at Neo4j’s GraphAcademy are an excellent resource and cover many topics,
    including those not covered in this book, such as graph data science and building
    applications using different languages and frameworks. You can get started with
    GraphAcademy at [graphacademy.neo4j.com](https://graphacademy.neo4j.com/).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要继续您的图数据库和Neo4j的图之旅，Neo4j的GraphAcademy提供的免费在线培训是一个极好的资源，涵盖了包括本书未涉及的一些主题，如图数据科学和用不同语言和框架构建应用程序。您可以从[graphacademy.neo4j.com](https://graphacademy.neo4j.com/)开始使用GraphAcademy。
- en: Finally, I publish a blog and newsletter that dive into many of these topics.
    You can find it online at [lyonwj.com](https://lyonwj.com/).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我发布了一个博客和通讯，深入探讨了这些主题中的许多。您可以在[lyonwj.com](https://lyonwj.com/)在线找到它。
- en: 9.5 Exercises
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.5 练习
- en: The price a customer pays for an item can vary. For example, the price may change
    or be temporarily reduced as part of a promotion. Add a relationship property
    to store the price for each item paid in an order.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户为商品支付的价格可能有所不同。例如，价格可能会改变或作为促销活动的一部分暂时降低。为订单中每个支付的商品添加一个关系属性来存储价格。
- en: Write a @cypher directive field to compute the order subtotal. Be sure to take
    into account the quantity of each item included in the order.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个@cypher指令字段来计算订单小计。务必考虑订单中包含的每个项目的数量。
- en: Write a GraphQL query to paginate the items included in an order, first using
    offset pagination and then using cursor-based pagination. Can you navigate from
    the last page to the first page as well?
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个 GraphQL 查询以分页显示订单中包含的项目，首先使用偏移量分页，然后使用基于游标的分页。你能从最后一页导航到第一页吗？
- en: Summary
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'GraphQL supports two abstract types that can be used to represent multiple
    concrete types: unions and interfaces.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraphQL 支持两种抽象类型，可以用来表示多个具体类型：联合和接口。
- en: Interfaces are used when the concrete types share common fields and can be thought
    of as a contract that defines the requirements for implementing the interface.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当具体类型共享公共字段时使用接口，可以将其视为定义实现接口要求的契约。
- en: Unions do not share this idea of a contract and can be used when the concrete
    types do not share common fields.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 联合不共享这种契约的概念，可以在具体类型不共享公共字段时使用。
- en: Two common approaches to pagination with GraphQL include using offsets and cursors.
    Offset pagination uses numeric offsets to chunk results into pages, while cursor
    pagination uses an opaque cursor.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 GraphQL 进行分页的两种常见方法包括使用偏移量和游标。偏移量分页使用数字偏移量将结果分页，而游标分页使用一个不透明的游标。
- en: The Relay specification defines a common *connection* type that can be used
    to enable cursor-based pagination with GraphQL.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Relay 规范定义了一个通用的 *连接* 类型，可以用于在 GraphQL 中启用基于游标的分页。
- en: These Relay connection types can also be used to model relationship properties
    with GraphQL.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些 Relay 连接类型也可以用于使用 GraphQL 模型关系属性。
