- en: 3 Securely storing Secrets
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 安全存储秘密
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Capturing Kubernetes manifests to store in version control systems
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Kubernetes 清单捕获以存储在版本控制系统
- en: Enabling secure secret storage at rest
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用安全的静态秘密存储
- en: Using Kubernetes Operators to manage Kubernetes resources, including Secrets
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Kubernetes Operators 来管理 Kubernetes 资源，包括 Secrets
- en: Incorporating security considerations into Kubernetes package managers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将安全考虑纳入 Kubernetes 软件包管理器
- en: Implementing key rotation to improve your security posture
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施密钥轮换以改善你的安全态势
- en: Chapter 2 provided an overview of the key architectural components of a Kubernetes
    environment as well as the way workloads are deployed and methods for injecting
    configurations via ConfigMaps and Secrets. But once resources have been added
    to a Kubernetes cluster, how are they managed? What happens if they were inadvertently
    removed? It becomes increasingly important for them to be captured and stored
    for potential later use. However, when working with resources that may contain
    sensitive information, careful thought and considerations must be taken into account.
    This chapter introduces tools and approaches that can be used to store Kubernetes
    Secrets securely at rest and illustrates the benefits of declaratively defining
    Kubernetes resources.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 第二章概述了 Kubernetes 环境的关键架构组件，以及工作负载的部署方式和通过 ConfigMaps 和 Secrets 注入配置的方法。但是，一旦资源被添加到
    Kubernetes 集群中，它们是如何被管理的？如果它们被意外删除会发生什么？确保它们被捕获并存储以备将来使用变得越来越重要。然而，当处理可能包含敏感信息的资源时，必须仔细思考和考虑。本章介绍了可以用来安全存储
    Kubernetes Secrets 的工具和方法，并说明了声明性定义 Kubernetes 资源的好处。
- en: 3.1 Storing Kubernetes manifests at rest
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 静态存储 Kubernetes 清单
- en: One of the benefits of cloud-native technologies is that resources can be built,
    deployed, and configured on demand. With only a few clicks of a mouse or keystrokes,
    entire architectures can be constructed with minimal effort. If you are just getting
    started with Kubernetes, excitement blossoms as you realize just how easy it is
    to build complex applications. You may even feel driven to show a parent, friend,
    or co-worker. But as you demonstrate your work, you may be asked how it can be
    replicated. It is at that point that it becomes crucial for each Kubernetes resource,
    including those that contain sensitive values, to be properly managed and stored
    for later use.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生技术的优势之一是资源可以根据需求构建、部署和配置。只需几点击或按键，就可以以最小的努力构建整个架构。如果你刚开始使用 Kubernetes，当你意识到构建复杂应用程序是多么容易时，你会感到兴奋。你甚至可能想要向父母、朋友或同事展示。但是，当你展示你的工作时，你可能会被问到如何复制它。这时，对于每个
    Kubernetes 资源，包括包含敏感值的资源，正确管理和存储以备将来使用变得至关重要。
- en: 'In chapter 2, we covered the two primary methods for creating resources in
    a Kubernetes environment:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二章中，我们介绍了在 Kubernetes 环境中创建资源的两种主要方法：
- en: Using the Kubernetes CLI (kubectl), translating inputs provided via command
    line arguments.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Kubernetes CLI（kubectl），将命令行参数提供的输入进行转换。
- en: Explicitly stating the configuration of resources using a YAML or JSON formatted
    file.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 明确使用 YAML 或 JSON 格式的文件来指定资源配置。
- en: 'The former, in which the Kubernetes CLI provides the translation for you, is
    known as the *imperative method*. For example, when you used the `kubectl` `create`
    `secret` subcommand to create the secret for your deployment in the last chapter,
    the Kubernetes CLI determined how to interpret the input you provided and send
    a request to the Kubernetes API to create the secret. While this approach simplifies
    the initial setup and configuration of resources, it also poses challenges into
    their long-term supportability. The `kubectl` `create` `secret` command is not
    idempotent, and rerunning it a second time will result in an error. This can be
    seen by executing the following, which will attempt to create a secret called
    `greeting-secret` and will result in an error, as a secret with the same name
    in the `default` namespace you created in chapter 2 already exists:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 前者，其中 Kubernetes CLI 为你提供转换，被称为*命令式方法*。例如，当你在上一个章节中使用 `kubectl` `create` `secret`
    子命令创建部署的秘密时，Kubernetes CLI 确定了如何解释你提供的输入并向 Kubernetes API 发送请求以创建秘密。虽然这种方法简化了资源的初始设置和配置，但它也带来了长期支持性的挑战。`kubectl`
    `create` `secret` 命令不是幂等的，再次运行它将导致错误。这可以通过执行以下命令来看到，它将尝试创建一个名为 `greeting-secret`
    的秘密，并将导致错误，因为在第二章中创建的 `default` 命名空间中已经存在具有相同名称的秘密：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: NOTE If no secret was already present in the `default` namespace, running this
    command a second time will result in a similar error.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果默认命名空间中尚未存在密钥，再次运行此命令将导致类似的错误。
- en: Now instead of using the imperative approach, resources can be represented explicitly
    in either YAML or JSON format and applied to the cluster using the `kubectl` tool.
    This approach is known as *declarative configuration* and has benefits to support
    the long-term lifecycle of resources within a Kubernetes environment.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在不再使用强制方法，资源可以明确地以 YAML 或 JSON 格式表示，并使用 `kubectl` 工具应用到集群中。这种方法被称为 *声明性配置*，它对支持
    Kubernetes 环境中资源的长期生命周期有好处。
- en: 'Declarative configuration is a key trait of a concept that has gained popularity
    over the last few years: infrastructure as code (IaC). Instead of manually configuring
    resources or using random scripts, the configurations applied to infrastructure
    or applications are explicitly defined, which results in the following benefits:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 声明性配置是近年来获得流行的一个概念的关键特性：基础设施即代码（IaC）。与手动配置资源或使用随机脚本相比，应用到基础设施或应用程序的配置是明确定义的，这带来了以下好处：
- en: Reduction of errors
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少错误
- en: Repeatability
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可重复性
- en: Auditing and tracking
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审计和跟踪
- en: The ability to audit and track these configurations is made possible especially
    when storing manifests in a version control system (VCS), such as Git. Once resources
    have been captured, their life span, including what and who changed them, can
    be appropriately tracked. So if a disaster occurred, instead of having to determine
    what the state of the Kubernetes cluster was at that point, the manifests that
    have been previously captured and stored can be reapplied, resulting in minimal
    downtime and effort.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 能够审计和跟踪这些配置，尤其是在将清单存储在版本控制系统（VCS）如 Git 中时变得可能。一旦资源被捕获，它们的生命周期，包括更改了什么和谁更改了它们，都可以得到适当的跟踪。因此，如果发生灾难，而无需确定
    Kubernetes 集群在那个时刻的状态，之前捕获并存储的清单可以被重新应用，从而最小化停机时间和努力。
- en: 3.1.1 Capturing resources for declarative configuration
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.1 捕获用于声明性配置的资源
- en: When adopting a declarative-based configuration or transitioning from a primarily
    imperative based approach, there are multiple strategies for capturing the manifests
    (figure 3.1). Recall that the end result will be a series of YAML or JSON files.
    While both file types can be applied to a Kubernetes cluster using the `kubectl`
    command line tool, YAML-based files are preferred due to their readability.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当采用基于声明的配置或从主要基于强制的做法过渡时，有多种策略可以捕获清单（图 3.1）。回想一下，最终结果将是一系列 YAML 或 JSON 文件。虽然这两种文件类型都可以使用
    `kubectl` 命令行工具应用到 Kubernetes 集群，但由于其可读性，基于 YAML 的文件更受欢迎。
- en: '![](../Images/CH03_F01_Sotobueno3.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F01_Sotobueno3.png)'
- en: Figure 3.1 Capturing Kubernetes resources as infrastructure as code (IaC)
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 捕获 Kubernetes 资源作为基础设施即代码（IaC）
- en: 'Two common scenarios can be used to capture manifests for storage in a declarative
    fashion:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用两种常见场景来捕获用于声明性存储的清单：
- en: Capturing the output from an invocation of `kubectl` imperative commands.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 捕获 `kubectl` 强制命令的输出。
- en: Capturing the output of resources already present within a Kubernetes environment.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Kubernetes 环境中捕获已存在的资源输出。
- en: Capturing kubectl imperative commands
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获 kubectl 强制命令
- en: To aid in the storage of manifests in a declarative fashion, the Kubernetes
    CLI provides two helpful flags that can be added when invoking imperative commands,
    such as `kubectl create secret`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助以声明性方式存储清单，Kubernetes CLI 提供了两个有用的标志，可以在调用强制命令时添加，例如 `kubectl create secret`。
- en: '`--dry-run`—Simulating how resources would be applied to the Kubernetes environment.
    Kubernetes versions older than 1.18 did not require the use of a parameter, such
    as `client`, as APIServer dry-run was refactored in newer versions.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--dry-run`—模拟资源如何应用到 Kubernetes 环境中。Kubernetes 版本低于 1.18 不需要使用参数，如 `client`，因为
    APIServer 的 dry-run 在新版本中已被重构。'
- en: '`-o`—Outputting the result of the command in a number of formats, including
    YAML.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-o`—以多种格式输出命令的结果，包括 YAML。'
- en: Adding these flags to the imperative secret creation command will output the
    representation of what would be sent to the Kubernetes cluster without any changes
    being made to the actual state of the cluster.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些标志添加到强制密钥创建命令中，将输出发送到 Kubernetes 集群的内容表示，而不会对集群的实际状态进行任何更改。
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Capturing deployed resources
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获已部署的资源
- en: There is still tremendous value to the imperative capabilities of the Kubernetes
    CLI. It is common to combine imperative invocations and manual configurations
    in the development process while the details of each resource are tested and validated.
    Once the configuration is in place, it is recommended to capture these assets,
    so they can be stored in a version control system to align with IaC principles.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes CLI 的命令式能力仍然具有巨大的价值。在开发过程中，通常将命令式调用和手动配置结合起来，同时测试和验证每个资源的细节。一旦配置就绪，建议捕获这些资产，以便将它们存储在版本控制系统中，以符合基础设施即代码（IaC）原则。
- en: The current state of resources can be queried using the `kubectl` `get` subcommand.
    In a similar fashion shown in listing 3.1, the command can be output in a variety
    of formats. Execute the following command to display the contents of the `greeting-secret`
    created in chapter 2.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `kubectl get` 子命令查询资源的当前状态。与 3.1 列表所示类似，该命令可以以多种格式输出。执行以下命令以显示在第 2 章中创建的
    `greeting-secret` 的内容。
- en: Listing 3.1 `greeting-secret` secret
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.1 `greeting-secret` 机密
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ① Base64 encoded value of the literal that was instantiated when the secret
    was created
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ① 创建机密时实例化的字面值的 Base64 编码值
- en: As you may notice in the output, there are fields, including `status`, and several
    fields within `metadata` (`uid`, `resourceVersion`, and `creationTimestamp`, just
    to name a few) with runtime details from current cluster. These properties are
    not suitable for storage and should be removed. They can be removed manually or
    using a tool, such as `yq`—a lightweight YAML processor. An example of removing
    runtime properties using `yq` is shown in the following listing.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如你可能在输出中注意到的，包括 `status` 在内的字段，以及 `metadata` 中的一些字段（例如 `uid`、`resourceVersion`
    和 `creationTimestamp` 等）都包含来自当前集群的运行时细节。这些属性不适合存储，应该被移除。它们可以手动移除或使用工具，如 `yq`（一个轻量级的
    YAML 处理器）来移除。以下列表展示了使用 `yq` 移除运行时属性的一个示例。
- en: Listing 3.2 Outputting the content of the secret to a file
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.2 将机密内容输出到文件
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'An overview of how to install the `yq` tool on your machine can be found in
    appendix B. The output from the prior command can be redirected to a file to enable
    the storage for versioning within a version control system:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在附录 B 中可以找到如何在您的机器上安装 `yq` 工具的概述。可以将先前命令的输出重定向到文件中，以在版本控制系统中启用版本存储：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With resources now being described in a declarative manner and eligible to be
    tracked and visible in version control systems, it becomes even more important
    for protections to be made to ensure the values cannot be easily determined. Since
    Secrets are merely Base64 encoded, it is crucial for additional mechanisms to
    be employed to obstruct the ability to ascertain their values. The remainder of
    this chapter will introduce and demonstrate tools that can be used to secure Secrets
    at rest.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于资源现在以声明性方式描述，并且有资格在版本控制系统中跟踪和可见，因此确保这些值不易被确定的保护措施变得更加重要。由于机密只是 Base64 编码的，因此采用额外的机制来阻止确定其值的能力至关重要。本章的剩余部分将介绍并演示可以用来在静态存储中保护机密的工具。
- en: 3.2 Tools for securely storing Kubernetes resources
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 安全存储 Kubernetes 资源的工具
- en: While the Kubernetes CLI does not offer any additional native capabilities for
    securing manifests for storage, the popularity of Kubernetes has afforded integration
    with other cloud-native tools to help solve this challenge. These tools include
    those that already have the functionality to secure manifests at rest as well
    as solutions that have been specifically developed for this purpose in a Kubernetes
    context. As a consumer of Kubernetes, you may be tasked with managing resources
    that are either focused on the underlying infrastructure or the applications that
    are deployed within the platform—or maybe both. The tool you will ultimately use
    depends on your use case. Understanding which tools are available and how they
    can be used will help you make an informed decision to select the appropriate
    tool for your specific task.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Kubernetes CLI没有提供任何额外的原生功能来保护存储的清单，但Kubernetes的流行使得与其他云原生工具集成以帮助解决这一挑战成为可能。这些工具包括那些已经具有在静态存储中保护清单的功能的工具，以及专门为在Kubernetes环境中解决此目的而开发的解决方案。作为Kubernetes的消费者，你可能需要管理那些专注于底层基础设施或平台内部署的应用程序，或者两者兼而有之。你最终将使用的工具取决于你的用例。了解哪些工具可用以及如何使用它们将帮助你做出明智的决定，选择适合你特定任务的适当工具。
- en: 3.2.1 Ansible Vault
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.1 Ansible Vault
- en: A typical deployment of Kubernetes (not including minikube) will need considerations
    for both infrastructure and application components. These include the physical
    and virtual resources to support the control plane and worker nodes as well as
    the configuration of Kubernetes manifests. Configuration management tools are
    well positioned for this space, as they not only an manage the sometimes complex
    configurations associated with Kubernetes environments, but they help illustrate
    and implement IaC concepts.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 的典型部署（不包括 minikube）需要对基础设施和应用程序组件都进行考虑。这包括支持控制平面和工作节点的物理和虚拟资源以及 Kubernetes
    清单的配置。配置管理工具在这个领域处于有利位置，因为它们不仅管理与 Kubernetes 环境相关的有时复杂的配置，而且有助于说明和实现基础设施即代码（IaC）的概念。
- en: Ansible is a popular configuration management tool that can be used to manage
    various aspects of the Kubernetes ecosystem. One of the key benefits of Ansible
    compared to other comparable tools is that it is well suited for cloud environments,
    as it is *agentless* (i.e., it does not require a central management server) and
    communicates via Secure Shell (SSH), a common communication protocol. All you
    need is the tool on your local machine, and you can get right to work!
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 是一款流行的配置管理工具，可用于管理 Kubernetes 生态系统的各个方面。与其他类似工具相比，Ansible 的一个关键优势是它非常适合云环境，因为它是无代理的（即，它不需要中央管理服务器）并且通过安全外壳（SSH），一种常见的通信协议进行通信。你只需要在你的本地机器上安装这个工具，就可以立即开始工作了！
- en: Installing Ansible
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Ansible
- en: Ansible is a Python based tool and, as such, is the only prerequisite and can
    be installed on a variety of operating systems. Given the instructions vary depending
    on the target operating system, refer to the official documentation ([http://mng.bz/2rew](http://mng.bz/2rew))
    on installing Ansible for your machine.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 是一个基于 Python 的工具，因此，它是唯一的前提条件，并且可以安装在各种操作系统上。由于安装说明取决于目标操作系统，请参考官方文档（[http://mng.bz/2rew](http://mng.bz/2rew)）以了解如何为您的机器安装
    Ansible。
- en: Ansible 101
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 101
- en: Ansible organizes automation directives in a series of YAML files. Directives
    describing the configurations to be applied to targets are organized into Playbooks,
    which declare the hosts that configurations should be applied to along with a
    series of tasks that define the desired state of each target machine. For example,
    a simple playbook could enforce all Linux machines to have a message of the day
    (MOTD) presented to all users when they log in. An example Playbook is shown in
    the following.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 将自动化指令组织成一系列 YAML 文件。描述要应用于目标配置的指令被组织到 Playbooks 中，这些 Playbooks 声明了配置应该应用到的主机以及一系列定义每个目标机器期望状态的任务。例如，一个简单的
    Playbook 可以强制所有 Linux 机器在用户登录时显示每日消息（MOTD）。以下是一个示例 Playbook。
- en: Listing 3.3 An example Ansible Playbook
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.3 一个示例 Ansible Playbook
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ① The host group that changes should be applied to
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ① 应应用于更改的主机组
- en: ② The copy module will copy content to a remote location.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ② 复制模块将内容复制到远程位置。
- en: ③ The value of the destination file
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 目标文件的值
- en: ④ The location of the destination file
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 目标文件的存储位置
- en: 'Target instances are organized into groups and declared within inventory files;
    they define how Ansible facilitates the connection, along with any variables that
    are used during Playbook invocation. Playbooks are then invoked using the `ansible-playbook`
    command, which will perform the execution of the automation:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 目标实例被组织成组并在清单文件中声明；它们定义了 Ansible 如何促进连接，以及在使用 Playbook 调用期间使用的任何变量。然后使用 `ansible-playbook`
    命令调用 Playbooks，该命令将执行自动化：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Ansible and Kubernetes
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 和 Kubernetes
- en: Ansible’s *bread and butter* is the management and configuration of infrastructure.
    As the popularity of Kubernetes continues to grow, it is becoming a key component
    in the infrastructure of many organizations, and as such, integrations between
    Ansible and Kubernetes are available.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 的“核心”是基础设施的管理和配置。随着 Kubernetes 的普及继续增长，它正成为许多组织基础设施的关键组成部分，因此，Ansible
    和 Kubernetes 之间的集成是可用的。
- en: A useful capability of this integration is managing Kubernetes resources, which
    is achieved using the `k8s` module. Modules are reusable scripts that can be included
    in Playbooks. In the previous MOTD example, the `copy` module was used to copy
    content from the local machine to the remote target.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这种集成的一个有用功能是管理 Kubernetes 资源，这是通过使用 `k8s` 模块实现的。模块是可以包含在 Playbooks 中的可重用脚本。在先前的
    MOTD 示例中，使用了 `copy` 模块将内容从本地机器复制到远程目标。
- en: 'Now you will create an Ansible Playbook to manage the configuration of your
    Kubernetes cluster by using the `greeting-secret` you already have available on
    the local machine. Before you begin, prepare your working environment. First,
    make a copy of the `greeting-secret.yaml` file on your machine and create a new
    file called `greeting-secret_ansible.yaml`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您将创建一个 Ansible Playbook，通过使用您在本地机器上已经可用的 `greeting-secret` 来管理您的 Kubernetes
    集群的配置。在您开始之前，准备您的开发环境。首先，在您的机器上复制 `greeting-secret.yaml` 文件，并创建一个名为 `greeting-secret_ansible.yaml`
    的新文件：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next create a namespace called `kubernetes-secrets-ansible` to use for this
    scenario:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为 `kubernetes-secrets-ansible` 的命名空间，用于此场景：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next change the namespace preference for your kubectl client to target the
    newly created namespace:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，更改您的 kubectl 客户端的命名空间首选项，以指向新创建的命名空间：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: NOTE When setting the namespace preference, all subsequent commands will query
    against the targeted namespace.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在设置命名空间首选项后，所有后续命令都将查询目标命名空间。
- en: Now within the same directory that the file `greeting-secret_ansible.yaml` is
    located, create a new file called `k8s-secret-mgmt.yaml`, with the following content
    to contain the Playbook.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在文件 `greeting-secret_ansible.yaml` 所在的同一目录下，创建一个名为 `k8s-secret-mgmt.yaml`
    的新文件，其中包含以下内容以包含 Playbook。
- en: Listing 3.4 k8s-secret-mgmt.yaml
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.4 k8s-secret-mgmt.yaml
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ① Execute Playbook on the local machine.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ① 在本地机器上执行 Playbook。
- en: ② Disable Ansible’s gathering of information related to target machines.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ② 禁用 Ansible 收集与目标机器相关的信息。
- en: ③ Use a local connection instead of the default SSH to communicate with the
    target machine.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 使用本地连接而不是默认的 SSH 与目标机器通信。
- en: ④ Use the k8s module to manage Kubernetes resources.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 使用 k8s 模块来管理 Kubernetes 资源。
- en: ⑤ The lookup enables querying the control node (where the Playbook is executed)
    for resources. In this case, the value of a file called greeting-secret.yaml is
    sourced from the directory containing the Playbook file.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 查找功能允许查询执行 Playbook 的控制节点（资源所在）的资源。在这种情况下，名为 greeting-secret.yaml 的文件值来源于包含
    Playbook 文件的目录。
- en: ⑥ Apply the resource to kubernetes-secrets-ansible namespace in the Kubernetes
    cluster.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 将资源应用到 Kubernetes 集群的 `kubernetes-secrets-ansible` 命名空间。
- en: ⑦ Since Kubernetes Secrets are being managed as part of this Playbook, do not
    provide any output of the invocation, as it would expose the content of the manifest.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 由于 Kubernetes Secrets 是作为此 Playbook 的一部分进行管理的，因此不要提供调用输出，因为这会暴露清单的内容。
- en: By default, the `k8s` module uses the `kubeconfig` file from the local machine
    to determine the method of communicating with the Kubernetes cluster. Since you
    were already authenticated to the minikube instance, this is already taken care
    of.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`k8s` 模块使用本地机器上的 `kubeconfig` 文件来确定与 Kubernetes 集群通信的方法。由于您已经对 minikube
    实例进行了认证，所以这一点已经处理好了。
- en: 'Before executing the Playbook, the `openshift` python module must be installed
    for Ansible to be able to communicate with the Kubernetes cluster. OpenShift is
    a distribution of Kubernetes, and the `k8s` Ansible module requires the `openshift`
    module prior to execution. This can be accomplished using pip, which, depending
    on your operating system, may have been how Ansible itself was installed. If pip
    is not currently installed, instructions on its installation can be found in appendix
    C. Add the `openshift` Python module by executing the following command:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行 Playbook 之前，必须安装 `openshift` Python 模块，以便 Ansible 能够与 Kubernetes 集群通信。OpenShift
    是 Kubernetes 的一个发行版，`k8s` Ansible 模块在执行前需要 `openshift` 模块。这可以通过 pip 完成，这取决于您的操作系统，可能也是
    Ansible 本身安装的方式。如果 pip 目前尚未安装，有关其安装的说明可以在附录 C 中找到。通过执行以下命令添加 `openshift` Python
    模块：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'With the necessary dependencies installed, run the Playbook:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装了必要的依赖项后，运行 Playbook：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: NOTE You can safely ignore the warnings as they do not affect the execution
    of the Playbook.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您可以安全地忽略警告，因为它们不会影响 Playbook 的执行。
- en: As emphasized in the output, the Playbook ran successfully with the secret defined
    locally, which is now present on the Kubernetes cluster in the `kubernetes-secrets-ansible`
    namespace. This can be confirmed by running `kubectl` `get` `secrets` `greeting-secret`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如输出中强调的，Playbook 在本地定义了密钥后成功运行，现在该密钥已存在于 Kubernetes 集群的 `kubernetes-secrets-ansible`
    命名空间中。这可以通过运行 `kubectl get secrets greeting-secret` 来确认。
- en: Ansible Vault
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible Vault
- en: As you might imagine, configuration management tools, such as Ansible, face
    the same challenges with managing sensitive values. When creating the Ansible
    Playbook in the prior section, the secret being sourced from the `greeting-secret_ansible.yaml`
    file contains the Base64 encoded value, and the values are ultimately susceptible
    to being decoded. Fortunately, Ansible provides the capabilities aid in this situation
    by enabling the encryption of files that can be decoded at runtime via Ansible
    Vault.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想，配置管理工具，如Ansible，在管理敏感值方面面临相同的挑战。在上一节创建Ansible Playbook时，从`greeting-secret_ansible.yaml`文件中获取的秘密包含Base64编码的值，而这些值最终可能被解码。幸运的是，Ansible通过启用文件加密功能来提供帮助，这些文件可以在运行时通过Ansible
    Vault进行解码。
- en: Ansible Vault allows variables and files to be protected, so they can be safely
    stored. Unlike Kubernetes Secrets, Ansible Vault uses encryption—not encoding—to
    avoid being easily reverse engineered (figure 3.2).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible Vault允许保护变量和文件，因此可以安全存储。与Kubernetes Secrets不同，Ansible Vault使用加密而不是编码来避免被轻易逆向工程（图3.2）。
- en: '![](../Images/CH03_F02_Sotobueno3.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F02_Sotobueno3.png)'
- en: Figure 3.2 The encryption and decryption process using Ansible Vault
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 使用Ansible Vault的加密和解密过程
- en: 'As of Ansible 2.10, Ansible Vault only supports `AES256` as the cipher algorithm
    for encrypting sensitive material. To encrypt the content of the `greeting-secret_
    ansible.yaml` file containing the secret with sensitive values, use the `ansible-value
    encrypt` command. You will be prompted to provide a password that can be used
    to encrypt and decrypt the contents of the encrypted password:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 截至Ansible 2.10版本，Ansible Vault仅支持`AES256`作为加密敏感材料的加密算法。要加密包含敏感值的秘密的`greeting-secret_
    ansible.yaml`文件的内容，请使用`ansible-value encrypt`命令。你将被提示提供可以用于加密和解密加密密码内容的密码：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Once the file has been encrypted by Ansible Vault, the resulting file takes
    the following form.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦文件被Ansible Vault加密，生成的文件将采取以下形式。
- en: Listing 3.5 greeting-secret_ansible.yaml
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.5 greeting-secret_ansible.yaml
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The result is a UTF-8-encoded file that contains a new line-terminated header
    followed by the encrypted contents. The header contains up to four elements:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个UTF-8编码的文件，它包含一个以换行符终止的头部，后面跟着加密内容。头部包含最多四个元素：
- en: The format ID (currently only supports `$ANSIBLE_VAULT`)
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格式ID（目前仅支持`$ANSIBLE_VAULT`）
- en: The vault format version
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保险库格式版本
- en: The cypher algorithm
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码算法
- en: The vault ID label (not used in this example)
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保险库ID标签（在此示例中未使用）
- en: The payload of the file is a concatenation of the ciphertext and a SHA256 digest,
    as a result of the `hexlify()` method of the Python `binascii` module. The specific
    details will not be described here, but they are explained thoroughly in the Ansible
    Vault documentation ([http://mng.bz/19rR](http://mng.bz/19rR)).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的负载是密文和SHA256摘要的连接，这是由于Python `binascii`模块的`hexlify()`方法。具体细节在此不详细描述，但它们在Ansible
    Vault文档中有详细解释([http://mng.bz/19rR](http://mng.bz/19rR))。
- en: Once a file has been encrypted using Ansible Vault, the `--ask-vault-password`
    or `--vault-password-file` must be provided when calling the `ansible-playbook`
    command. To make use of the `--vault-password-file` flag, the password must be
    provided as the content within the referenced file.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦使用Ansible Vault加密了文件，在调用`ansible-playbook`命令时必须提供`--ask-vault-password`或`--vault-password-file`。为了使用`--vault-password-file`标志，密码必须作为引用文件中的内容提供。
- en: TIP Instead of providing a flag to the `ansible-playbook` command, the location
    of the Vault password file can be provided by the `ANSIBLE_VAULT_ PASSWORD_FILE`
    environment variable.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：除了向`ansible-playbook`命令提供标志外，还可以通过`ANSIBLE_VAULT_PASSWORD_FILE`环境变量提供Vault密码文件的位置。
- en: Run the Playbook, and add the `--ask-vault-pass` flag, which will prompt for
    the Vault password to be provided. When prompted, enter the password and press
    Enter. If the appropriate password was provided, the Playbook will execute successfully.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 运行Playbook，并添加`--ask-vault-pass`标志，这将提示输入Vault密码。当提示时，输入密码并按Enter键。如果提供了正确的密码，Playbook将成功执行。
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If an incorrect value was provided, a message like the following will appear:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供了错误的值，将显示如下消息：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Since you specified `no_log` in the task, a more descriptive error will not
    be provided. To investigate further, you may temporarily comment out `no_log`
    to ascertain the ultimate cause of the failure.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你在任务中指定了`no_log`，因此不会提供更详细的错误信息。为了进一步调查，你可以暂时注释掉`no_log`以确定失败的根本原因。
- en: By using Ansible Vault to encrypt the contents of the Kubernetes Secret in the
    `greeting-secret_ansible.yaml` file, the Playbook and encrypted file can be safely
    stored in a version control system.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用Ansible Vault加密`greeting-secret_ansible.yaml`文件中Kubernetes Secret的内容，可以将Playbook和加密文件安全地存储在版本控制系统中。
- en: Ansible Vault illustrates how one can manage encrypting and decrypting Kubernetes
    resources from a client-side perspective. The next section will introduce transitioning
    the responsibilities to components running within the Kubernetes cluster instead.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible Vault展示了从客户端的角度如何管理加密和解密Kubernetes资源。下一节将介绍将责任转移到在Kubernetes集群内运行的组件。
- en: 3.3 Kubernetes Operators
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 Kubernetes Operators
- en: 'While Ansible Vault satisfies the need to securely store sensitive Kubernetes
    assets, there are several areas that could be improved upon:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Ansible Vault满足了安全存储敏感Kubernetes资产的需求，但仍有几个方面可以改进：
- en: Those executing the Ansible automation are given the password to decrypt sensitive
    assets.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行Ansible自动化的用户被赋予了解密敏感资产所需的密码。
- en: Decryption occurs on the client side. Any sensitive assets are transmitted either
    in their cleartext value or with a Kubernetes Secret and, thus, are Base64 encoded.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解密在客户端进行。任何敏感资产要么以明文值的形式传输，要么与Kubernetes Secret一起传输，因此是Base64编码的。
- en: An alternate strategy is leveraging a model where the decryption process occurs
    completely within the Kubernetes cluster, abstracting the end user or automation
    process from managing sensitive material as resources are applied. This is the
    approach implemented by the Sealed Secrets project, where decryption is managed
    via an operator running within the cluster.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种策略是利用一个模型，其中解密过程完全在Kubernetes集群内部进行，将最终用户或自动化过程从管理敏感材料中抽象出来，因为资源被应用。这是Sealed
    Secrets项目所采用的方法，其中解密是通过在集群内运行的运算符来管理的。
- en: Recall from chapter 2 that a key component of master nodes is that they contain
    controllers, which are aptly named, as they implement a nonterminating control
    loop to manage and monitor the desired state of at least one resource within the
    cluster. When changes to the targeted resource occur, the controller will ensure
    the state of the cluster matches the desired state.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 回想第2章，主节点的一个关键组件是它们包含控制器，这些控制器名称恰当，因为它们实现了一个非终止的控制循环来管理和监控集群中至少一个资源的期望状态。当目标资源发生变化时，控制器将确保集群的状态与期望状态相匹配。
- en: One of the most common controllers end users are familiar with is a ReplicaSet
    controller. Deployments are a common method for registering workloads into Kubernetes,
    and a ReplicaSet is generated automatically whenever a Deployment is created.
    The ReplicaSet controller will monitor pods associated with the ReplicaSet and
    ensure the number of active Pods matches the desired state, as defined within
    the ReplicaSet.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 用户最熟悉的常见控制器之一是ReplicaSet控制器。部署是将工作负载注册到Kubernetes的常用方法，每当创建一个部署时，都会自动生成一个ReplicaSet。ReplicaSet控制器将监视与ReplicaSet关联的Pod，并确保活动Pod的数量与ReplicaSet中定义的期望状态相匹配。
- en: 3.3.1 Custom resource definitions (CRDs)
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.1 自定义资源定义（CRDs）
- en: Historically, Kubernetes had a fairly small number of resources, such as Pods
    and Secrets. As the popularity of the platform grew, so did the desire for new
    resource types, both from core maintainers as well as from users. As any developer
    can attest to, changes to core APIs are typically a challenging and drawn-out
    process.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，Kubernetes的资源数量相对较少，例如Pod和Secret。随着该平台知名度的提高，对新的资源类型的需求也随之增加，这既来自核心维护者，也来自用户。任何开发者都可以证明，对核心API的更改通常是一个具有挑战性和耗时漫长的过程。
- en: Custom resource definitions (CRDs), a new resource type, were a solution to
    this issue, as they provided developers the opportunity to register their own
    APIs and properties associated with these resources, while being able to take
    advantage of the functionality within the API server without interfering with
    the core set of APIs. For example, a new resource called `CronTabs` could be defined
    with the goal of executing tasks at a particular scheduled point in time. An application
    could be developed to query the API Kubernetes for `CronTabs` resources and execute
    any of the desired business logic. However, instead of routinely querying the
    API, what if you could perform many of the same capabilities of the included set
    of controllers, such as immediately being able to react to state changes, as in
    the creation or modification of a resource? Fortunately, client libraries and,
    in particular, client-go for the Go programming language provide these capabilities.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义资源定义（CRD），作为一种新的资源类型，是解决这一问题的方法，因为它为开发者提供了注册他们自己的API以及与这些资源相关联的属性的机会，同时能够利用API服务器中的功能，而不会干扰核心API集。例如，可以定义一个新的资源`CronTabs`，其目的是在特定的时间点执行任务。可以开发一个应用程序来查询Kubernetes
    API的`CronTabs`资源并执行任何所需的业务逻辑。然而，如果你能够执行许多与包含的控制器集相同的操作，比如能够立即对状态变化做出反应，比如资源的创建或修改，那会怎么样？幸运的是，客户端库，特别是Go编程语言的client-go，提供了这些功能。
- en: This concept of developing an application to monitor a custom resource and take
    action against it is known as an *operator*, and this pattern has been widely
    adopted within the Kubernetes community; it is even implemented by the Sealed
    Secrets project. The process for developing operators and custom controllers was
    once a large feat, as developers needed to have intimate knowledge of Kubernetes
    internals. Fortunately, tools, such as kubebuilder and the Operator Framework
    have simplified this process (figure 3.Figure 3.3 3).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 开发一个应用程序来监控自定义资源并对其实施操作的这一概念被称为*操作员*，这一模式在Kubernetes社区中得到了广泛的应用；Sealed Secrets项目也实现了这一模式。开发操作员和自定义控制器的过程曾经是一项巨大的成就，因为开发者需要深入了解Kubernetes的内部结构。幸运的是，工具，如kubebuilder和Operator
    Framework，简化了这一过程（图3.Figure 3.3）。
- en: '![](../Images/CH03_F03_Sotobueno3.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F03_Sotobueno3.png)'
- en: Figure 3.3  An overview of how operators manage resources in Kubernetes
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3  操作员在Kubernetes中管理资源概述
- en: 3.3.2 Sealed Secrets
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.2 密封秘密
- en: 'Given that the majority of the Sealed Secrets solutions are offloaded to the
    controller or operator, what actions does it perform? Sealed Secrets contains
    three distinct components:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Sealed Secrets的大多数解决方案都卸载到控制器或操作员，那么它执行哪些操作呢？Sealed Secrets包含三个不同的组件：
- en: The operator or controller
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作员或控制器
- en: A CLI tool called *kubeseal*, which is used by the end user to encrypt Kubernetes
    Secrets
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为*kubeseal*的CLI工具，由最终用户用于加密Kubernetes Secrets
- en: A CRD called `SealedSecret`
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`SealedSecret`的CRD
- en: After the CRD is added to the cluster and the controller is deployed to a namespace,
    the controller will create a new 4096-bit RSA public–private key pair if one does
    not exist, which will be saved as a secret within the same namespace the controller
    is deployed within.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在将CRD添加到集群并将控制器部署到命名空间后，如果不存在，控制器将创建一个新的4096位RSA公私钥对，并将其作为秘密保存在控制器部署的同一命名空间中。
- en: 'End users use the kubeseal tool to convert a standard Kubernetes Secret into
    a `SealedSecret` resource. The encryption process takes each value within the
    Kubernetes Secret and performs the following actions (figure 3.4):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 最终用户使用kubeseal工具将标准的Kubernetes Secret转换为`SealedSecret`资源。加密过程对Kubernetes Secret中的每个值执行以下操作（图3.4）：
- en: The value is symmetrically encrypted with a randomly-generated one-time-use
    32-bit session key.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该值使用随机生成的32位一次性会话密钥进行对称加密。
- en: The session key is then asymmetrically encrypted with the public key created
    by the controllers’ previously generated public certificate, using Optimal Asymmetric
    Encryption Padding (RSA-OAEP).
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 会话密钥随后使用控制器先前生成的公共证书创建的公钥，通过最优非对称加密填充（RSA-OAEP）进行非对称加密。
- en: ThFigure 3.4 e result is stored within the `SealedSecret` resource.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果存储在`SealedSecret`资源中。
- en: '![](../Images/CH03_F04_Sotobueno3.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F04_Sotobueno3.png)'
- en: Figure 3.4  The processes and components involved in encrypting and decrypting
    a secret using the Sealed Secrets project
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4  使用Sealed Secrets项目加密和解密秘密的过程和组件
- en: 'NOTE A more detailed overview of the encryption and decryption in use can be
    found on the Sealed Secret project homepage: [https://github.com/bitnami-labs/sealed-secrets](https://github.com/bitnami-labs/sealed-secrets).'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：有关使用的加密和解密更详细的概述，可以在Sealed Secret项目主页上找到：[https://github.com/bitnami-labs/sealed-secrets](https://github.com/bitnami-labs/sealed-secrets)。
- en: Installing Sealed Secrets
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Sealed Secrets
- en: The first step of installing Sealed Secrets is deploying the controller to the
    cluster. While multiple methods are supported, installation via the raw Kubernetes
    manifests will be used here.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Sealed Secrets的第一步是将控制器部署到集群中。虽然支持多种方法，但这里将使用通过原始Kubernetes清单进行安装的方式。
- en: For the purpose of this book, version `v0.13.1` will be used, and steps related
    to the installation of the controller and associated kubeseal command line tool
    can be found on the release page within the project repository ([http://mng.bz/PoP5](http://mng.bz/PoP5)).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本书的目的，将使用版本`v0.13.1`，与控制器和相关kubeseal命令行工具的安装步骤可以在项目存储库中的发布页面上找到（[http://mng.bz/PoP5](http://mng.bz/PoP5)）。
- en: 'Similar to the steps you completed in the prior action covering Ansible Vault,
    create a new namespace called `kubernetes-secrets-sealedsecrets`, and set the
    namespace preference to target this namespace:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前操作Ansible Vault时完成的步骤类似，创建一个名为`kubernetes-secrets-sealedsecrets`的新命名空间，并将命名空间首选项设置为针对此命名空间：
- en: '[PRE17]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Add the controller to the Kubernetes cluster by executing the following command:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行以下命令将控制器添加到Kubernetes集群：
- en: '[PRE18]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'By default, the controller is installed into the `kube-system` namespace. Confirm
    the controller has been deployed successfully by listing the running pods within
    the `kube-system` namespace:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，控制器将安装到`kube-system`命名空间。通过列出`kube-system`命名空间中的运行中的Pod来确认控制器已成功部署：
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next install the kubeseal command line tool. The binary releases along with
    installation steps can be found on the release page previously referenced in this
    section. Be sure to follow the steps detailed for your operating system. Once
    kubeseal has been installed, confirm the CLI has been installed properly and can
    obtain the public certificate generated by the controller, enabling you to encrypt
    secrets:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来安装kubeseal命令行工具。二进制发布和安装步骤可以在本节之前引用的发布页面上找到。务必遵循适用于您操作系统的详细步骤。一旦安装了kubeseal，请确认CLI已正确安装，并且可以获取控制器生成的公钥证书，从而能够加密秘密：
- en: '[PRE20]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ① --fetch-cert obtains the current public key certificate.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ① --fetch-cert 获取当前公钥证书。
- en: Encrypting secrets using Sealed Secrets
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Sealed Secrets加密秘密
- en: Now that Sealed Secrets has been successfully installed, encrypt the contents
    of the `greeting-secret.yaml` created using `kubeseal` in listing 3.2 to create
    a new file called `greeting-secret_sealedsecrets.yaml` as follows.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Sealed Secrets已成功安装，请使用列表3.2中创建的`kubeseal`加密`greeting-secret.yaml`的内容，创建一个名为`greeting-secret_sealedsecrets.yaml`的新文件，如下所示。
- en: Listing 3.6 Encrypting a secret using kubeseal
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.6 使用kubeseal加密秘密
- en: '[PRE21]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Review the contents of the newly generated `greeting-secret-sealedsecrets.yaml`
    file in the following listing.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下列表中新生成的`greeting-secret-sealedsecrets.yaml`文件的内容。
- en: Listing 3.7 greeting-secret-sealedsecrets.yaml
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.7 greeting-secret-sealedsecrets.yaml
- en: '[PRE22]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ① The template property adds fields to the generated secret. Additional properties,
    such as labels and annotations, can be included.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ① 模板属性向生成的秘密添加字段。可以包括其他属性，如标签和注解。
- en: 'As an additional security measure, the namespace and name associated with the
    secret are added as part of the OAEP process, so it is important that the `SealedSecret`
    resource is generated with this in mind. Finally, verify that the newly created
    `SealedSecret` resource can be added to the Kubernetes cluster. Once added, the
    Sealed Secrets controller should decrypt the contents and create a new Secret
    within the same namespace:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外的安全措施，与秘密关联的命名空间和名称作为OAEP过程的一部分被添加，因此重要的是要考虑在生成`SealedSecret`资源时这一点。最后，验证新创建的`SealedSecret`资源是否可以添加到Kubernetes集群。一旦添加，Sealed
    Secrets控制器应解密内容并在同一命名空间中创建一个新的Secret：
- en: '[PRE23]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Confirm that a new secret called `greeting-secret` has been created in the
    `kubernetes-secrets-sealedsecrets` namespace:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 确认已在新创建的`kubernetes-secrets-sealedsecrets`命名空间中创建了一个名为`greeting-secret`的新秘密：
- en: '[PRE24]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The Sealed Secrets controller also emits Kubernetes events based on the actions
    it performs and can be verified by querying for events in the `default` namespace:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Sealed Secrets控制器还会根据其执行的操作发出Kubernetes事件，可以通过查询`default`命名空间中的事件来验证：
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The addition of events provides insight into the lifecycle of resources managed
    by Sealed Secrets.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 事件添加提供了对Sealed Secrets管理的资源生命周期的洞察。
- en: Given the tight connection between the `SealedSecret` resource and the associated
    Secret, if the `SealedSecret` resource is removed, Kubernetes will also remove
    the referenced Secret. This is due to the fact that the Secret is owned by the
    `SealedSecret` resource. Kubernetes Garbage Collection will cascade the deletion
    of resources to any resources that are owned. Additional details related to Kubernetes
    garbage collection can be found in the Kubernetes documentation ([http://mng.bz/JVDQ](http://mng.bz/JVDQ)).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`SealedSecret`资源与相关Secret之间的紧密联系，如果删除`SealedSecret`资源，Kubernetes也会删除引用的Secret。这是因为Secret由`SealedSecret`资源拥有。Kubernetes垃圾回收会将资源删除的删除操作级联到任何拥有的资源。有关Kubernetes垃圾回收的更多详细信息，请参阅Kubernetes文档（[http://mng.bz/JVDQ](http://mng.bz/JVDQ)）。
- en: By demonstrating how to make use of Sealed Secrets in our Kubernetes environment,
    you can feel confident about safely storing the `SealedSecret` resource in your
    version control system, without having to worry about sensitive assets being easily
    discovered. In the next section, we will introduce how to manage sensitive assets
    within Kubernetes package mangers.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 通过展示如何在我们的Kubernetes环境中使用Sealed Secrets，您可以放心地将`SealedSecret`资源存储在版本控制系统中，而无需担心敏感资产容易被发现。在下一节中，我们将介绍如何在Kubernetes包管理器中管理敏感资产。
- en: 3.4 Managing Secrets within Kubernetes package managers
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 在Kubernetes包管理器中管理Secrets
- en: 'As you have seen thus far, Kubernetes provides the primitives for running complex
    applications: ConfigMaps and Secrets for storing configuration assets, Services
    for simplifying network access, and Deployments for managing the desired state
    of container resources. However, one feature Kubernetes does not natively provide
    is a mechanism for easily managing these resources. This issue becomes increasingly
    clear as resources begin to accumulate within IaC repositories. Members of the
    Kubernetes community saw this as a challenge, and there became a desire to better
    manage the lifecycle of Kubernetes applications in a similar fashion to any other
    off-cluster application. Traditionally, these are features facilitated by a package
    manager, such as yum, apt-get, or Homebrew. The result of their efforts led to
    the creation and eventual popularity of Helm, a package manager for Kubernetes.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如您迄今为止所看到的，Kubernetes提供了运行复杂应用程序的原语：ConfigMaps和Secrets用于存储配置资产，Services用于简化网络访问，Deployments用于管理容器资源的期望状态。然而，Kubernetes本身并不提供易于管理这些资源的机制。随着资源开始在IaC存储库中积累，这个问题变得越来越明显。Kubernetes社区成员将此视为挑战，并产生了更好地管理Kubernetes应用程序生命周期的愿望，类似于任何其他集群外应用程序。传统上，这些功能是由包管理器（如yum、apt-get或Homebrew）提供的。他们努力的成果导致了Helm的创建，并最终使其流行起来，Helm是Kubernetes的包管理器。
- en: 'Helm simplifies the lives of application developers and consumers of Kubernetes
    applications by providing the following key features:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Helm通过提供以下关键功能简化了应用程序开发人员和Kubernetes应用程序消费者的生活：
- en: Lifecycle management (e.g., installation, upgrading, and rollback)
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生命周期管理（例如，安装、升级和回滚）
- en: Manifest templating
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清单模板
- en: Dependency management
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖管理
- en: Helm uses a packaging format know as *charts*, which contain the Kubernetes
    manifests that would be associated with an application and deployed as a single
    unit. Manifests are known as *templates* within Helm and are processed through
    Helm’s templating engine (they are go-template based with additional support from
    libraries, such as Sprig) at deployment time.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Helm使用一种称为 *charts* 的打包格式，其中包含与应用程序相关联的Kubernetes清单，并作为一个单一单元部署。在Helm中，清单被称为
    *模板*，并在部署时通过Helm的模板引擎进行处理（它们基于go-template，并从库（如Sprig）中获得额外支持）。
- en: '*Values* are parameters that are injected into the templated resources. The
    combined set of rendered manifests once deployed to Kubernetes is known as a *release*
    (figure 3.5).'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*值* 是注入到模板资源中的参数。一旦部署到Kubernetes，渲染的清单集合被称为 *发布*（图3.5）。'
- en: '![](../Images/CH03_F05_Sotobueno3.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F05_Sotobueno3.png)'
- en: Figure 3.5 A Helm release combines templates and values to create Kubernetes
    resources
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 Helm发布通过组合模板和值来创建Kubernetes资源
- en: Finally, Helm is managed using a command line client tool that helps facilitate
    the entire lifecycle of a chart. This will be the primary tool used starting in
    the next section.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Helm 使用命令行客户端工具进行管理，该工具有助于简化图表的整个生命周期。这将是下一节中使用的首要工具。
- en: TIP Additional information related to Helm can be found on the Helm website
    at [https://helm.sh/](https://helm.sh/).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：有关 Helm 的更多信息，可以在 Helm 网站上找到 [https://helm.sh/](https://helm.sh/)。
- en: 3.4.1 Deploying the Greeting Demo Helm chart
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.1 部署 Greeting Demo Helm 图表
- en: The manifests associated with the greeting demo application we referred to in
    chapter 2 have been packaged into a Helm chart to demonstrate the benefits Helm
    can provide. In this section you will install the Helm CLI tool, review the Greeting
    Demo Helm Chart, and deploy it to your Kubernetes cluster.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第 2 章中提到的问候演示应用程序的清单已被打包成 Helm 图表，以展示 Helm 可以提供的优势。在本节中，你将安装 Helm CLI 工具，审查
    Greeting Demo Helm 图表，并将其部署到你的 Kubernetes 集群。
- en: First download the Helm Command Line tool. Multiple installation options are
    available, depending on your operating system. The steps and instructions can
    be found on the Helm project website ([https://helm.sh/docs/intro/install/](https://helm.sh/docs/intro/install/)).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，下载 Helm 命令行工具。根据你的操作系统，有多种安装选项。步骤和说明可以在 Helm 项目网站上找到（[https://helm.sh/docs/intro/install/](https://helm.sh/docs/intro/install/))。
- en: Once the Helm CLI has been installed, make sure Git is available on your machine,
    as it is needed to manage assets in version control within this chapter as well
    as subsequent chapters. See appendix D for instructions on how Git can be installed
    and configured.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了 Helm CLI，请确保你的机器上安装了 Git，因为在本章以及随后的章节中管理版本控制中的资产需要 Git。有关如何安装和配置 Git 的说明，请参阅附录
    D。
- en: 'Now clone the repository containing the Helm chart to your machine:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在克隆包含 Helm 图表的存储库到你的机器上：
- en: '[PRE26]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ① Clone the repository containing the chart.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ① 克隆包含图表的存储库。
- en: ② Change into the chart directory.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ② 切换到图表目录。
- en: 'Once inside the chart directory, you will notice the following directory structure:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进入图表目录，你会注意到以下目录结构：
- en: '[PRE27]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `Chart.yaml` is the manifest for the Helm chart and contains key metadata,
    including the name of the chart as well as the version. The templates directory
    contains the Kubernetes resources that will be deployed to the cluster when the
    chart is installed. The key difference is they are now templated resources instead
    of the raw manifests you have been working with thus far, as shown in the following
    listing.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`Chart.yaml` 是 Helm 图表的清单，包含关键元数据，包括图表的名称以及版本。模板目录包含在安装图表时将部署到集群中的 Kubernetes
    资源。关键区别在于，它们现在是模板化资源，而不是你迄今为止一直在使用的原始清单，如下所示。'
- en: Listing 3.8 secret.yaml
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.8 secret.yaml
- en: '[PRE28]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ① Content enclosed within {{ }} is processed via Helm’s templating engine.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ① 内容被 {{ }} 包围，将通过 Helm 的模板引擎进行处理。
- en: The `include` function references named templates present within the `_helpers.tpl`
    file. A full overview of templates and the Helm directory structure can be found
    in the Helm documentation ([https://helm.sh/docs/chart_template_guide/named_templates](https://helm.sh/docs/chart_template_guide/named_templates/)/).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`include` 函数引用了 `_helpers.tpl` 文件中存在的命名模板。有关模板和 Helm 目录结构的完整概述，请参阅 Helm 文档（[https://helm.sh/docs/chart_template_guide/named_templates](https://helm.sh/docs/chart_template_guide/named_templates/)/）。'
- en: NOTE Additional Kubernetes resources, such as an Ingress and Service Account,
    are also included in this chart. These are created as part of the typical boilerplate
    when the `helm` `create` command is used. By default, these resources are not
    deployed during typical usage of this chart but can be if desired by setting the
    appropriate values.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：此图表还包括其他 Kubernetes 资源，如 Ingress 和 Service Account。这些资源在执行 `helm create`
    命令时作为典型模板的一部分创建。默认情况下，这些资源在典型使用此图表时不会部署，但如果需要，可以通过设置适当的值来部署。
- en: 'Parameters associated with the templates are located in the `Values.yaml` file.
    By browsing through the file, you will notice many key attributes, including the
    number of replicas as well as the image location and tag. At the bottom of the
    file, you will notice a property called `greeting.message` with no value specified:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 与模板关联的参数位于 `Values.yaml` 文件中。通过浏览该文件，你会注意到许多关键属性，包括副本数量以及镜像位置和标签。在文件底部，你会注意到一个名为
    `greeting.message` 的属性，但没有指定值：
- en: '[PRE29]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If you recall the snippet from listing 3.8, this property is injected by referencing
    the `$.Values.greeting.message` in the `secret.yaml` file in the templates directory.
    Also of note is the `required` function that enforces a value to be set before
    this chart can be installed. Values can be specified in a number of ways, including
    via files or using the command line, and Helm employs precedence to determine
    which property is ultimately applied. Those defined in the `values.yaml` file
    have the lowest priority.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回想起列表 3.8 中的片段，这个属性是通过在模板目录中的 `secret.yaml` 文件中引用 `$.Values.greeting.message`
    来注入的。值得注意的是，`required` 函数强制在安装此图表之前设置一个值。值可以通过多种方式指定，包括通过文件或使用命令行，并且 Helm 使用优先级来确定最终应用哪个属性。在
    `values.yaml` 文件中定义的属性具有最低优先级。
- en: 'Before you install this chart to the Kubernetes cluster, first create a new
    namespace called `kubernetes-secrets-helm`, and change the current content into
    the newly created namespace:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在将此图表安装到 Kubernetes 集群之前，首先创建一个名为 `kubernetes-secrets-helm` 的新命名空间，并将当前内容更改到新创建的命名空间中：
- en: '[PRE30]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Next since a value for `greeting.message` must be provided, create a new file
    called `values-kubernetes-secrets.yaml`, containing the following contents.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 由于必须提供 `greeting.message` 的值，因此创建一个名为 `values-kubernetes-secrets.yaml` 的新文件，包含以下内容。
- en: Listing 3.9 values-kubernetes-secrets.yaml
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.9 values-kubernetes-secrets.yaml
- en: '[PRE31]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next install the Helm chart by providing a name for the release, the chart
    location, and a reference to the values file that contains the required property:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过提供发布名称、图表位置和包含所需属性的值文件的引用来安装 Helm 图表：
- en: '[PRE32]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: NOTE The `helm upgrade` command was used with the `-i` flag, as it provides
    an idempotent method for installing Helm charts. If an existing chart is present,
    it will be upgraded. Otherwise a new installation will occur.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：使用 `-i` 标志执行了 `helm upgrade` 命令，因为它提供了一种幂等的方法来安装 Helm 图表。如果存在现有图表，它将被升级。否则，将发生新的安装。
- en: 'If the installation was successful, an overview of the release is provided
    along with the rendered contents of the `Notes.txt` file contained from the templates.
    Curl the IP address and port exposed by the minikube service to confirm the greeting
    that was set in the Helm value and stored in the `greeting-secret` secret is presented:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果安装成功，将提供发布概述以及从模板中包含的 `Notes.txt` 文件的渲染内容。通过 curl 查询 minikube 服务公开的 IP 地址和端口，以确认在
    Helm 值中设置并在 `greeting-secret` 密钥中存储的问候语是否呈现：
- en: '[PRE33]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 3.4.2 Using Helm Secrets
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.2 使用 Helm Secrets
- en: While we were successful in deploying the application as a Helm chart, we are
    once again faced with the challenge of how to manage sensitive content stored
    within the `values-kubernetes-secrets.yaml` file. As you might expect, other members
    of the Helm and Kubernetes community sought to find a solution to provide security
    to Helm values, so they can be stored at rest. One of the most popular options
    available is Helm Secrets, a Helm plugin that provides integration with various
    secrets management backends. Plugins in Helm are external tools that are not part
    of the Helm code base but can be accessed from the Helm CLI.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们成功将应用程序作为 Helm 图表部署时，我们再次面临如何管理存储在 `values-kubernetes-secrets.yaml` 文件中的敏感内容的挑战。正如你所预期的那样，Helm
    和 Kubernetes 社区的其他成员试图找到一种解决方案，以提供对 Helm 值的安全性，以便它们可以存储在静态状态下。最流行的选项之一是 Helm Secrets，这是一个提供与各种密钥管理后端集成的
    Helm 插件。Helm 中的插件是外部工具，不属于 Helm 代码库的一部分，但可以从 Helm CLI 访问。
- en: Helm Secrets uses Secrets OPerationS (SOPS), from Mozilla, as its default secrets
    management driver. SOPS is a tool that encrypts key–value file types, such as
    YAML, and integrates with cloud (AWS/GCP KMS) and non-cloud secrets management
    solutions.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Helm Secrets 使用来自 Mozilla 的 Secrets OPerationS (SOPS) 作为其默认的密钥管理驱动程序。SOPS 是一个加密键值文件类型（如
    YAML）的工具，并与云（AWS/GCP KMS）和非云密钥管理解决方案集成。
- en: For the integration of SOPS as the backend for Helm Secrets, the most straightforward
    and easiest option to setup for our purposes is leveraging Pretty Good Privacy
    (PGP). PGP, in a similar fashion to Sealed Secrets, uses asymmetric public/private
    key encryption to secure the content of files and has been a popular method for
    transmitting emails securely. At encryption time, a random 256-bit data key is
    used and passed to PGP to encrypt the data key and then the properties within
    the file (figure 3.6).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 对于将 SOPS 作为 Helm Secrets 后端的集成，最直接且最容易为我们目的设置的选项是利用 Pretty Good Privacy (PGP)。PGP
    与 Sealed Secrets 类似，使用非对称公钥/私钥加密来保护文件内容，并且一直是安全传输电子邮件的流行方法。在加密时，使用一个随机的 256 位数据密钥，并将其传递给
    PGP 以加密数据密钥，然后加密文件中的属性（图 3.6）。
- en: '![](../Images/CH03_F06_Sotobueno3.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F06_Sotobueno3.png)'
- en: Figure 3.6 Encrypting secrets and using them as part of a Helm release, using
    Helm Secrets
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 使用 Helm Secrets 加密机密并将其作为 Helm 发布的一部分使用
- en: 'Now prepare your machine with the software and configurations necessary to
    protect the sensitive properties of your Helm chart. GNU Privacy Guard (GPG) is
    an open standards implementation of the proprietary PGP, and the corresponding
    `gpg` tool will enable you to manage your keys appropriately. Check appendix E
    for further instructions on how it can be installed. Once the `gpg` CLI has been
    installed, create a new public/private key pair:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在准备您的机器，安装必要的软件和配置，以保护 Helm 图表的敏感属性。GNU Privacy Guard (GPG) 是专有 PGP 的开放标准实现，相应的
    `gpg` 工具将使您能够适当地管理您的密钥。查看附录 E 以获取有关如何安装的进一步说明。一旦安装了 `gpg` CLI，创建一个新的公钥/私钥对：
- en: '[PRE34]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Enter your name and email address. When prompted to enter a passphrase, do not
    enter any values.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 输入您的姓名和电子邮件地址。当提示输入密码短语时，不要输入任何值。
- en: NOTE While it may seem counterintuitive to leave the GPG passphrase blank, it
    simplifies the integration with automation tools (some do not support passphrases)
    as well as reduces the need to manage yet another sensitive asset.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然留下 GPG 密码短语为空可能看起来有些反直觉，但它简化了与自动化工具的集成（一些不支持密码短语）以及减少了管理另一个敏感资产的需求。
- en: After the public/private key pair is successfully created, you can confirm by
    listing the keys in the keyring as follows.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥/私钥对成功创建后，您可以按以下方式列出密钥环中的密钥以进行确认。
- en: Listing 3.10 Listing GPG Keys
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.10 列出 GPG 密钥
- en: '[PRE35]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: ① GPG Fingerprint
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ① GPG 指纹
- en: 'Make note of the value starting with `5369`, as this is the fingerprint for
    the public key and will be used shortly when configuring SOPS. Next install the
    Helm Secrets plugin using the Helm CLI:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 记录以 `5369` 开头的值，因为这将是公钥的指纹，将在配置 SOPS 时稍后使用。接下来，使用 Helm CLI 安装 Helm Secrets 插件：
- en: '[PRE36]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'SOPS will also be installed as part of the Helm Secrets installation. Values
    files managed by the Helm Secrets plugin, by convention, are located in a directory
    called `helm_vars`. Create this directory within the `greeting-demo` chart repository:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: SOPS 也将作为 Helm Secrets 安装的一部分进行安装。由 Helm Secrets 插件管理的值文件，按照惯例，位于名为 `helm_vars`
    的目录中。在 `greeting-demo` 图表存储库中创建此目录：
- en: '[PRE37]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To complete the integration between Helm Secrets and SOPS, create a new file
    in the `helm_vars` directory named `.sops.yaml`, with the following content:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成 Helm Secrets 和 SOPS 之间的集成，请在 `helm_vars` 目录下创建一个名为 `.sops.yaml` 的新文件，内容如下：
- en: '[PRE38]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Replace the content next to `pgp` with the fingerprint for your own public key
    discovered in listing 3.10.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `pgp` 旁边的内联代码替换为在第 3.10 列表中发现的您自己的公钥指纹。
- en: Next move the `values-kubernetes-secrets.yaml` file to the `helm_vars` directory,
    so it is within the same directory as the `.sops.yaml` file. This will ensure
    SOPS decrypts the file appropriately.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将 `values-kubernetes-secrets.yaml` 文件移动到 `helm_vars` 目录，使其与 `.sops.yaml`
    文件位于同一目录中。这将确保 SOPS 正确解密文件。
- en: '[PRE39]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: With the integration with SOPS complete and the desired values file in the proper
    location, use Helm Secrets to encrypt the file as follows.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在与 SOPS 集成完成并所需值文件位于适当位置后，使用 Helm Secrets 按以下方式加密文件。
- en: Listing 3.11 Encrypting using Helm Secrets
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.11 使用 Helm Secrets 加密
- en: '[PRE40]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Confirm the contents of the `values-kubernetes-secrets.yaml` file are encrypted,
    as in the following listing.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 确认 `values-kubernetes-secrets.yaml` 文件的内容已加密，如下所示列表。
- en: Listing 3.12 values-kubernetes-secrets.yaml
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.12 values-kubernetes-secrets.yaml
- en: '[PRE41]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: ① Encrypted value
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ① 加密值
- en: ② Fingerprint
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ② 指纹
- en: Note that the file has been separated into two primary sections.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，该文件已被分为两个主要部分。
- en: Keys from the original file are retained. Values are now encrypted.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保留原始文件中的密钥。值现在已加密。
- en: SOPS related metadata including enough information to enable the encrypted values
    to be decrypted.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与SOPS相关的元数据，包括足够的信息以启用加密值的解密。
- en: 'The contents can be easily updated as necessary, using the `helm` `secrets`
    `edit` command. To denote you are now using Helm Secrets to manage the content
    of our values file in a secure manner, update the value of the `greeting.message`
    property to read `Hello` `from` `Helm` `Secrets!`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 内容可以很容易地根据需要更新，使用`helm secrets edit`命令。为了表明您现在正在使用Helm Secrets以安全的方式管理我们的值文件的内容，将`greeting.message`属性的值更新为读取`Hello`
    `from` `Helm` `Secrets!`：
- en: '[PRE42]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Update the contents of the file:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 更新文件的内容：
- en: '[PRE43]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now upgrade the chart with the updated encrypted values file using Helm Secrets:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用Helm Secrets升级图表，并使用更新的加密值文件：
- en: '[PRE44]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Revision `2` should be displayed, indicating a successful release. However,
    if you attempt to query the endpoint exposed by the application, it will not reflect
    the updated values, since only the underlying secret was modified and a solution
    similar to the reloader introduced in chapter 2 is not in use.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 应该显示修订版`2`，表示成功发布。然而，如果您尝试查询应用程序公开的端点，它将不会反映更新的值，因为只有底层密钥被修改，并且没有使用类似于第2章中引入的重载器。
- en: 'Delete the running pod, which will allow the updated value to be injected into
    the newly created Pod:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 删除正在运行的Pod，这将允许更新的值被注入到新创建的Pod中：
- en: '[PRE45]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Once the newly created Pod is running, query the application endpoint to confirm
    the response displays the property contained within your encrypted values file:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦新创建的Pod运行，查询应用程序端点以确认响应显示您加密值文件中包含的属性：
- en: '[PRE46]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: One benefit of using Helm Secrets is that it provides an introduction to SOPS,
    a tool that can be used to protect sensitive key–value files for secure storage
    outside the Helm ecosystem. The management of sensitive assets does not end once
    the values have been encrypted. In the next section, we will discuss how rotating
    secrets can be used to improve your overall security posture beyond day one.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Helm Secrets的一个好处是它介绍了SOPS，这是一个可以用于在Helm生态系统之外安全存储敏感键值文件的工具。敏感资产的管理并不随着值的加密而结束。在下一节中，我们将讨论如何使用密钥旋转来提高您整体的安全态势，而不仅仅是第一天。
- en: 3.5 Rotating secrets
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5 旋转密钥
- en: Individuals and organizations go to great lengths to protect sensitive information
    that could potentially enable access to critical systems. However, regardless
    of the strength of any secure value or the tools used to protect access to them,
    there is always the potential for compromise. The key is minimizing or reducing
    the potential.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 个人和组织会不遗余力地保护可能使关键系统访问成为可能的敏感信息。然而，无论任何安全值有多强大或用于保护其访问的工具有多先进，总是存在被破坏的可能性。关键是最大限度地减少或降低这种可能性。
- en: 'With that in mind, one of the methods that can be used to reduce the attack
    vector is implementing some form of secret rotation. Rotation can occur in two
    primary areas:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，可以用来减少攻击向量的一种方法是实现某种形式的密钥旋转。旋转可以在两个主要领域发生：
- en: The actual value being secured
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际上需要保护的值
- en: The keys or values used to generate the encrypted asset
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于生成加密资产的密钥或值
- en: Rotating sensitive assets is a concept most of us should be familiar with—for
    example, resetting passwords on a regular basis. This practice, however, has been
    known to fall short in the context of managed assets, since systems make use of
    the asset instead of a human. Fortunately, each of the tools that has been introduced
    thus far to secure sensitive assets at rest (Ansible Vault, Sealed Secrets, and
    Helm Secrets) support some form of rotation.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转敏感资产是一个我们大多数人应该熟悉的概念——例如，定期重置密码。然而，这种做法在管理资产方面一直存在不足，因为系统使用的是资产而不是人类。幸运的是，到目前为止介绍的所有工具（Ansible
    Vault、Sealed Secrets和Helm Secrets）都支持某种形式的旋转。
- en: 3.5.1 Ansible Vault secret key rotation
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5.1 Ansible Vault密钥旋转
- en: 'Encrypted files generated by Ansible Vault can be rekeyed to allow a different
    password to be used to secure and access the stored asset using the `rekey` subcommand
    of `ansible-vault`. Using the `greeting-secret_ansible.yaml` file that was encrypted
    in listing 3.11, use the `ansible-vault` `rekey` subcommand to start the rekeying
    process, enter the existing password, and then enter a new password when prompted:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 由Ansible Vault生成的加密文件可以通过`ansible-vault`的`rekey`子命令重新加密，以使用不同的密码来保护和访问存储的资产。使用列表3.11中加密的`greeting-secret_ansible.yaml`文件，使用`ansible-vault`的`rekey`子命令开始重新加密过程，输入现有密码，然后根据提示输入新密码：
- en: '[PRE47]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The contents of the `greeting-secret_ansible.yaml` file has been updated.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`greeting-secret_ansible.yaml`文件的内容已更新。'
- en: 3.5.2 Sealed Secrets key rotation
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5.2 Sealed Secrets密钥轮换
- en: 'Whenever the Sealed Secret controller starts, it checks whether an existing
    public/private key pair is available (with the following label: `sealedsecrets.bitnami.com/sealed-secrets-key=active`).
    Otherwise, a new key pair will be generated. Sealing keys themselves are renewed
    automatically (a new secret is created) every 30 days, and the controller will
    consider any secret with the `sealedsecrets.bitnami.com/sealed-secrets-key=active`
    label to be a potential key used for decryption.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 每次Sealed Secret控制器启动时，它会检查是否存在现有的公钥/私钥对（带有以下标签：`sealedsecrets.bitnami.com/sealed-secrets-key=active`）。如果没有，将生成新的密钥对。密封密钥本身会自动更新（创建新的密钥），每30天更新一次，控制器会将带有`sealedsecrets.bitnami.com/sealed-secrets-key=active`标签的任何密钥视为用于解密的潜在密钥。
- en: 'However, rotation can be initiated at any time, whether due to a compromise
    or other reasons, by either setting the `--key-cutoff-time` flag or using the
    `SEALED_ SECRETS_KEY_CUTOFF_TIME` environment variable on the controller deployment.
    Using either method, the value must be in RFC1123 format. Force the Sealed Secrets
    controller to regenerate a new key pair by executing the following command to
    add an environment variable on the `sealed-secrets-controller` deployment:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，无论是因为泄露还是其他原因，都可以在任何时间启动密钥轮换，通过设置`--key-cutoff-time`标志或在控制器部署中使用`SEALED_
    SECRETS_KEY_CUTOFF_TIME`环境变量。使用任何一种方法，值都必须是RFC1123格式。通过在`sealed-secrets-controller`部署中添加环境变量来执行以下命令，强制Sealed
    Secrets控制器重新生成新的密钥对：
- en: '[PRE48]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'A new rollout of the `sealed-secrets-controller` will be initiated. Confirm
    the new key pair was generated:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 将会启动`sealed-secrets-controller`的新部署。确认已生成新的密钥对：
- en: '[PRE49]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: With the new private key available to the controller, secrets associated with
    existing `SealedSecrets` can be reencrypted, or new secrets can be encrypted using
    the kubeseal CLI.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器有了新的私钥后，可以重新加密与现有`SealedSecrets`关联的密钥，或者可以使用kubeseal CLI加密新的密钥。
- en: NOTE Existing keys are not removed whenever a new key is added, as it is added
    to the list of active keys. Old keys can be removed manually only after the new
    key has been created.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：每次添加新键时，现有键不会被删除，因为新键被添加到活动键列表中。只有在创建新键之后，才能手动删除旧键。
- en: 3.5.3 SOPS secret key rotation
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5.3 SOPS密钥轮换
- en: 'SOPS, the secrets management tool underlying Helm Secrets, also supports key
    rotation. There are two mechanisms for which rotation can be implemented within
    SOPS:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Helm Secrets底层密钥管理工具的SOPS也支持密钥轮换。在SOPS中可以实施轮换有两种机制：
- en: The GPG key itself
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GPG密钥本身
- en: The data key used at encryption time
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密时使用的数据密钥
- en: 'The most straightforward option is rotating the data key used to encrypt the
    file. To accomplish this task with your existing Helm values file located within
    the `helm_vars` folder, use the SOPS tool itself, passing the `-r` flag along
    with the location of the file to rotate:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 最直接的方法是轮换用于加密文件的数据密钥。要使用位于`helm_vars`文件夹中的现有Helm值文件完成此任务，请使用SOPS工具本身，传递`-r`标志以及要轮换的文件位置：
- en: '[PRE50]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: You can confirm SOPS has updated the file by verifying the `lastmodified` property
    underneath the `sops` section.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过验证`sops`部分下的`lastmodified`属性来确认SOPS已更新文件。
- en: 'In addition to the data key being rotated, the master GPG key can also be updated.
    To do so, create a new GPG key or reference an existing GPG, and pass the associated
    fingerprint of the key by using the `--add-pgp` flag:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 除了轮换数据密钥外，主GPG密钥也可以更新。要这样做，创建一个新的GPG密钥或引用现有的GPG，并使用`--add-pgp`标志传递相关指纹：
- en: '[PRE51]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: To remove the old key, execute this command, but replace `--add-pgp` with `--rm-pgp`,
    and use the fingerprint of the key you wish to remove. In any event, be sure to
    update the contents of the `helm_vars/.sops.yaml` file with the fingerprint of
    the key you would like Helm Secrets to use to manage the secure assets.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除旧键，执行此命令，但将`--add-pgp`替换为`--rm-pgp`，并使用您希望删除的键的指纹。在任何情况下，请确保更新`helm_vars/.sops.yaml`文件的内容，以包含Helm
    Secrets用于管理安全资产所需的键的指纹。
- en: Regardless of the secrets management tool being used, once rotation has been
    completed, it is important that any systems or applications dependent on the secure
    asset are updated appropriately to reduce the potential of downtime or error due
    to misconfiguration.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 无论使用哪种密钥管理工具，一旦完成轮换，重要的是任何依赖于安全资产的系统或应用程序都应适当更新，以减少因配置错误而导致停机或错误的可能性。
- en: Summary
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Expressing Kubernetes resources declaratively allows them to be captured and
    stored in version control systems.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以声明性方式表达 Kubernetes 资源允许它们被捕获并存储在版本控制系统中。
- en: Tools such as Ansible and Helm have support for storing sensitive resources
    at rest securely.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如 Ansible 和 Helm 等工具支持安全地存储静态的敏感资源。
- en: Operators automate actions in Kubernetes environments and can be used to encrypt
    sensitive values from within the cluster.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作符在 Kubernetes 环境中自动化操作，并可用于从集群内部加密敏感值。
- en: SOPS is a general-purpose tool for encrypting various file formats and includes
    integration with KMS providers.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SOPS 是一种通用工具，用于加密各种文件格式，并包括与 KMS 提供程序的集成。
- en: Secret key rotation replaces existing encryption keys by generating new cryptographic
    keys, which reduces the risk of a compromise.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密钥轮换通过生成新的加密密钥来替换现有的加密密钥，从而降低泄露风险。
