- en: '10 Telephone: Randomly mutating strings'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 电话：随机突变字符串
- en: “What we have here is a failure to communicate.”
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: “我们这里的问题是沟通失败。”
- en: --Captain
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: --船长
- en: '| Now that we’ve played with randomness, let’s apply the idea to randomly mutating
    a string. This is interesting, because strings are actually *immutable* in Python.
    We’ll have to figure out a way around that.To explore these ideas, we’ll write
    a version of the game of Telephone where a secret message is whispered through
    a line or circle of people. Each time the message is transmitted, it’s usually
    changed in some unpredictable way. The last person to receive the message will
    say it out loud to compare it to the original message. Often the results are nonsensical
    and possibly comical. | ![](../Images/10-unnumb-1.png)  |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '| 现在我们已经玩过了随机性，让我们将这个想法应用到随机突变字符串上。这很有趣，因为字符串在 Python 中实际上是 *不可变的*。我们将不得不想出一个解决方案。为了探索这些想法，我们将编写一个电话游戏的版本，其中一条秘密信息通过一排或一圈人悄悄传递。每次传递信息时，它通常都会以某种不可预测的方式改变。最后收到信息的人会大声说出信息，以便与原始信息进行比较。通常结果是无意义的，可能是滑稽的。
    | ![](../Images/10-unnumb-1.png)  |'
- en: 'We will write a program called telephone.py that will mimic this game. It will
    print “You said: ” and the original text, followed by “I heard: ” with a modified
    version of the message. As in chapter 5, the input text may come from the command
    line:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个名为 telephone.py 的程序来模拟这个游戏。它将打印 “你说：” 和原始文本，然后是修改后的消息版本，后面跟着 “我听到：”。正如第
    5 章所述，输入文本可能来自命令行：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Or it may come from a file:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 或者它可能来自一个文件：
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The program should accept an `-m` or `--mutations` option, which should be
    a floating-point number between 0 and 1 with a default value of `0.1` (10%). This
    will be the percentage of the number of letters that should be altered. For instance,
    `.5` means that 50% of the letters should be changed:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 程序应接受 `-m` 或 `--mutations` 选项，该选项应是一个介于 0 和 1 之间的浮点数，默认值为 `0.1`（10%）。这将是要更改的字母数量的百分比。例如，`.5`
    表示 50% 的字母应该被更改：
- en: '[PRE2]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Because we are using the `random` module, we’ll accept an `int` value for the
    `-s` or `--seed` option, so that we can reproduce our pseudo-random selections:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用了 `random` 模块，我们将接受 `-s` 或 `--seed` 选项的 `int` 值，这样我们就可以重现我们的伪随机选择：
- en: '[PRE3]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Figure 10.1 shows a string diagram of the program.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 显示了程序的字符串图。
- en: '![](../Images/10-1.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10-1.png)'
- en: Figure 10.1 The telephone program will accept text and possibly some percentage
    of mutations, along with a random seed. The output will be a randomly mutated
    version of the input text.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 电话程序将接受文本和可能的突变百分比，以及一个随机种子。输出将是输入文本的随机突变版本。
- en: In this exercise, you will learn to
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将学习到
- en: Round numbers
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 圆整数
- en: Use the `string` module
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `string` 模块
- en: Modify strings and lists to introduce random mutations
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改字符串和列表以引入随机突变
- en: 10.1 Writing telephone.py
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1 编写 telephone.py
- en: 'I recommend you use the new.py program to create a new program called telephone.py
    in the 10_telephone directory. You could do this from the top level of the repository
    like so:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你使用 new.py 程序在 10_telephone 目录下创建一个名为 telephone.py 的新程序。你可以从存储库的顶层这样做：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You could also copy template/template.py to 10_telephone/telephone.py. Modify
    the `get_args()` function until your `-h` output matches the following. I would
    recommend you use `type=float` for the mutations parameter:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将 template/template.py 复制到 10_telephone/telephone.py。修改 `get_args()` 函数，直到你的
    `-h` 输出与以下内容匹配。我建议你为突变参数使用 `type=float`：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now run the test suite. You should pass at least the first two tests (the telephone.py
    program exists and prints a usage statement when run with `-h` or `--help`).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行测试套件。你应该至少通过前两个测试（当使用 `-h` 或 `--help` 运行 telephone.py 程序时，程序存在并打印用法说明）。
- en: 'The next two tests check that your `--seed` and `--mutations` options both
    reject non-numeric values. This should happen automatically if you define these
    parameters using the `int` and `float` types, respectively. That is, your program
    should behave like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 下两个测试检查你的 `--seed` 和 `--mutations` 选项都拒绝非数值输入。如果你分别使用 `int` 和 `float` 类型定义这些参数，这应该会自动发生。也就是说，你的程序应该表现得像这样：
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The next test checks if the program rejects values for `--mutations` outside
    the range 0-1 (where both bounds are inclusive). This is not a check that you
    can easily describe to `argparse`, so I suggest you look at how we handled the
    validation of the arguments in abuse.py in chapter 9\. In the `get_args()` function
    of that program, we manually checked the value of the arguments and used the `parser.error()`
    function to throw an error. Note that a `--mutations` value of `0` is acceptable,
    in which case we will print out the input text without modifications. Your program
    should do this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个测试检查程序是否拒绝 `--mutations` 参数在 0-1 范围之外（其中两个边界都是包含的）。这不是一个可以轻易描述给 `argparse`
    的检查，所以我建议您查看第 9 章中 `abuse.py` 中我们如何处理参数验证。在那个程序的 `get_args()` 函数中，我们手动检查参数的值，并使用
    `parser.error()` 函数抛出错误。注意，`--mutations` 的值为 `0` 是可接受的，在这种情况下，我们将打印出未经修改的输入文本。您的程序应该这样做：
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is another program that accepts input text either from the command line
    or from a file, and I suggest you look at the solution in chapter 5\. Inside the
    `get_args()` function, you can use `os.path.isfile()` to detect whether the text
    argument is a file. If it is a file, read the contents of the file for the `text`
    value.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个接受从命令行或文件中输入文本的程序，我建议您查看第 5 章中的解决方案。在 `get_args()` 函数内部，您可以使用 `os.path.isfile()`
    来检测文本参数是否为文件。如果是文件，则读取文件内容作为 `text` 值。
- en: 'Once you have taken care of all the program parameters, start your `main()`
    function with setting the `random.seed()` and echoing back the given text:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您处理完所有程序参数，开始您的 `main()` 函数，设置 `random.seed()` 并回显给定的文本：
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Your program should handle command-line text:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您的程序应该处理命令行文本：
- en: '[PRE9]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And it should handle an input file:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该处理输入文件：
- en: '[PRE10]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: At this point, your code should pass up to `test_for_echo()`. The next tests
    start asking you to mutate the input, so let’s discuss how to do that.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，您的代码应该通过 `test_for_echo()` 测试。接下来的测试开始要求您对输入进行突变，让我们讨论如何进行突变。
- en: 10.1.1 Calculating the number of mutations
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.1 计算突变数量
- en: 'The number of letters that need to be changed can be calculated by multiplying
    the length of the input text by the `args.mutations` value. If we want to change
    20% of the characters in “The quick brown fox...” string, we’ll find that it is
    not a whole number:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 需要更改的字母数量可以通过将输入文本的长度乘以 `args.mutations` 值来计算。如果我们想更改 “The quick brown fox...”
    字符串中的 20% 的字符，我们会发现它不是一个整数：
- en: '[PRE11]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can use the `round()` function to give us the nearest integer value. Read
    `help(round)` to learn how to round floating-point numbers to a specific number
    of digits:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `round()` 函数来给出最近的整数值。阅读 `help(round)` 来了解如何将浮点数四舍五入到特定的小数位数：
- en: '[PRE12]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Note that you could also convert a `float` to an `int` by using the `int` function,
    but this truncates the fractional part of the number rather than rounding it:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您也可以通过使用 `int` 函数将 `float` 转换为 `int`，但这会截断数字的小数部分而不是四舍五入：
- en: '[PRE13]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You will need this value for later, so let’s save it in a variable:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您将需要这个值用于后续操作，所以让我们将其保存到一个变量中：
- en: '[PRE14]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 10.1.2 The mutation space
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.2 突变空间
- en: '| When we change a character, what will we change it to? For this, we’ll use
    the `string` module. I encourage you to take a look at the documentation by importing
    the module and reading `help(string)`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '| 当我们更改一个字符时，我们会将其更改为什么？为此，我们将使用 `string` 模块。我鼓励您通过导入模块并阅读 `help(string)` 来查看文档：'
- en: '[PRE15]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '| ![](../Images/10-unnumb-2.png)  |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| ![图片](../Images/10-unnumb-2.png)  |'
- en: 'We can, for instance, get all the lowercase ASCII letters as follows. Note
    that this is not a method call as there are no parentheses `()` at the end:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以获取所有小写 ASCII 字母如下。注意，这不是一个方法调用，因为末尾没有括号 `()`：
- en: '[PRE16]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This returns a `str`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个 `str`：
- en: '[PRE17]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'For our program, we can use `string.ascii_letters` and `string.punctuation`
    to get strings of all the letters and punctuation. To concatenate the two strings
    together, we can use the `+` operator. We’ll draw from this string to randomly
    select a character to replace another:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的程序，我们可以使用 `string.ascii_letters` 和 `string.punctuation` 来获取所有字母和标点符号的字符串。要将这两个字符串连接起来，我们可以使用
    `+` 操作符。我们将从这个字符串中随机选择一个字符来替换另一个字符：
- en: '[PRE18]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that even if we both use the same random seed, you and I will get different
    results if our letters are in a different order. To ensure our results match,
    we’ll both need to sort the `alpha` characters so they are in a consistent order.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，即使我们使用相同的随机种子，如果我们的字母顺序不同，你和我得到的结果也会不同。为了确保我们的结果一致，我们需要对 `alpha` 字符进行排序，以确保它们处于一致顺序。
- en: 10.1.3 Selecting the characters to mutate
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.3 选择要突变的字符
- en: 'There are at least two approaches we could take to choosing which characters
    to change: a *deterministic approach* where the results are always guaranteed
    to be the same and a *non-deterministic approach* where we employ chance to get
    close to a target. Let’s examine the latter one first.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 至少有两种方法可以选择要更改的字符：一种是一种**确定性方法**，其结果总是保证相同；另一种是**非确定性方法**，我们利用机会来接近目标。让我们首先考察后者。
- en: Non-deterministic selection
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 非确定性选择
- en: 'One way to choose the characters to change would be to mimic method 1 in chapter
    8\. We could iterate through each of the characters in our text and select a random
    number to decide whether to keep the original character or change it to some randomly
    selected value. If our random number is less than or equal to our mutations setting,
    we should change the character:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 选择要更改的字符的一种方法可以模仿第8章中的方法1。我们可以遍历文本中的每个字符，并选择一个随机数来决定是否保留原始字符或将其更改为随机选择的值。如果我们的随机数小于或等于突变设置，我们应该更改字符：
- en: '[PRE19]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ① Initialize new_text as an empty string.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ① 将新文本初始化为一个空字符串。
- en: ② Iterate through each character in the text.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ② 遍历文本中的每个字符。
- en: ③ Use random.random() to generate a floating-point value from a uniform distribution
    between 0 and 1\. If that value is less than or equal to the args.mutation value,
    we randomly choose from alpha; otherwise, we use the original character.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 使用`random.random()`生成一个介于0和1之间的均匀分布的浮点数。如果这个值小于或等于`args.mutation`值，我们就从`alpha`中随机选择；否则，我们使用原始字符。
- en: ④ Print the resulting new_text.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 打印出结果的新文本。
- en: We used the `random.choice()` function in abuse.py in chapter 9 to randomly
    select *one* value from a list of choices. We can use it here to select a character
    from `alpha` if the `random.random()` value falls within the range of the `args.mutation`
    value (which we know is also a `float`).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在第9章的abuse.py中，我们使用了`random.choice()`函数从选择列表中随机选择**一个**值。我们可以在这里使用它来从`alpha`中选择一个字符，如果`random.random()`的值在`args.mutation`值的范围内（我们知道它也是一个`float`）。
- en: The problem with this approach is that, by the end of the `for` loop, we are
    not guaranteed to have made exactly the correct number of changes. That is, we
    calculated that we should change 9 characters out of 44 when the mutation rate
    is 20%. We would expect to end up changing about 20% of the characters with this
    code, because a random value from a uniform distribution of values between 0 and
    1 should be less than or equal to 0.2 about 20% of the time. Sometimes we might
    end up only changing 8 characters or other times we might change 10\. Because
    of this uncertainty, this is approach would be considered *non-deterministic*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是，到`for`循环结束时，我们并不能保证恰好进行了正确的数量更改。也就是说，当突变率为20%时，我们计算出应该更改44个字符中的9个。我们预计使用此代码将更改大约20%的字符，因为从0到1的均匀分布的随机值大约有20%的时间会小于或等于0.2。有时我们可能只更改8个字符，有时我们可能更改10个。由于这种不确定性，这种方法被认为是**非确定性**的。
- en: Still, this is a really useful technique that you should note. Imagine you have
    an input file with millions or potentially billions of lines of text, and you
    want to randomly sample approximately 10% of the lines. The preceding approach
    would be reasonably fast and accurate. A larger sample size will help you get
    closer to the desired number of mutations.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这是一个非常有用的技术，你应该注意。想象一下，你有一个包含数百万或可能数十亿行文本的输入文件，你想要随机抽取大约10%的行。前面提到的方法将会相对快速且准确。更大的样本量将帮助你更接近所需的突变数量。
- en: Randomly sampling characters
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 随机采样字符
- en: A deterministic approach to the million-line file would require first reading
    the entire input to count the number of lines, choosing which lines to take, and
    then going back through the file a second time to take those lines. This approach
    would take *much* longer than the method described above. Depending on how large
    the input file is, how the program is written, and how much memory your computer
    has, the program could possibly even crash your computer!
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对于百万行文件的一种确定性方法是首先读取整个输入来计算行数，选择要取的行，然后再次遍历文件以获取这些行。这种方法将比上面描述的方法花费更长的时间。根据输入文件的大小、程序的编写方式和计算机的内存量，程序甚至可能崩溃你的计算机！
- en: '| Our input is rather small, however, so we will use this algorithm because
    it has the advantages of being exact and testable. Rather than focusing on lines
    of text, though, we’ll consider indexes of characters. You’ve seen the `str .replace()`
    method (in chapter 8), which allows us to change all instances of one string to
    another:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '| 我们输入的相当小，所以我们将会使用这个算法，因为它具有精确和可测试的优点。然而，我们不会专注于文本行，而是会考虑字符索引。你见过`str .replace()`方法（在第8章中），它允许我们将一个字符串的所有实例更改为另一个字符串：'
- en: '[PRE20]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '| ![](../Images/10-unnumb-3.png)  |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| ![](../Images/10-unnumb-3.png)  |'
- en: We can’t use `str.replace()` because it will change every occurrence of some
    character, and we only want to change individual characters. Instead we can use
    the `random .sample()` function to select some indexes of the characters in the
    text. The first argument to `random.sample()` needs to be something like a `list`.
    We can give it a `range()` of numbers up to the length of our `text`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能使用`str.replace()`，因为它会改变某些字符的所有出现，而我们只想改变单个字符。相反，我们可以使用`random .sample()`函数来选择文本中字符的一些索引。`random.sample()`的第一个参数需要是类似`list`的东西。我们可以给它一个`range()`，其数值范围是`text`的长度。
- en: 'Suppose our `text` is 44 characters long:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的`text`有44个字符长：
- en: '[PRE21]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can use the `range()` function to make a `list` of numbers up to 44:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`range()`函数来创建一个包含最多44个数字的`list`：
- en: '[PRE22]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Note that `range()` is a lazy function. It won’t actually produce the 44 values
    until we force it, which we can do in the REPL using the `list()` function:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`range()`是一个惰性函数。它实际上不会产生44个值，直到我们强制它这样做，我们可以在REPL中使用`list()`函数来做到这一点：
- en: '[PRE23]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We calculated earlier that the `num_mutations` value for altering 20% of `text`
    is 9\. Here is one selection of indexes that could be changed:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前计算出，改变`text`的20%的`num_mutations`值是9。这里是一组可能被更改的索引选择：
- en: '[PRE24]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'I suggest you use a `for` loop to iterate through each of these index values:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你使用一个`for`循环来遍历这些索引值：
- en: '[PRE25]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You should replace the character at each index position with a randomly selected
    character from `alpha`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该将每个索引位置的字符替换为从`alpha`中随机选择的字符：
- en: '[PRE26]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: I will introduce one other twist--we don’t want the replacement value to ever
    be the same as the character it is replacing. Can you figure out how to get a
    subset of `alpha` that *does not* include the character at the position?
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我将引入一个额外的转折——我们不希望替换值与被替换的字符相同。你能想出如何得到一个不包含该位置字符的`alpha`子集吗？
- en: 10.1.4 Mutating a string
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.4 修改字符串
- en: 'Python `str` variables are *immutable*, meaning we cannot directly modify them.
    For instance, suppose we want to change the character `''w''` at position `13`
    to a `''b''`. It would be handy to directly modify `text[13]`, but that will create
    an exception:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`str`变量是*不可变的*，这意味着我们无法直接修改它们。例如，如果我们想将位置`13`的字符`'w'`更改为`'b'`，直接修改`text[13]`将会很方便，但这样会抛出异常：
- en: '[PRE27]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The only way to modify the `str` value `text` is to overwrite it with a new
    `str`. We need to create a new `str` with the following, as shown in figure 10.2:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要修改`str`值`text`的唯一方法是用一个新的`str`覆盖它。我们需要创建一个新的`str`，如下所示，如图10.2所示：
- en: The part of `text` before a given index
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`text`给定索引之前的部分'
- en: The randomly selected value from `alpha`
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`alpha`中随机选择的值
- en: The part of `text` after a given index
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`text`给定索引之后的部分'
- en: '![](../Images/10-2.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10-2.png)'
- en: Figure 10.2 Create a new string by selecting the portion of the string up to
    the index, a new character, and the portion of the string after the index.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 通过选择字符串的一部分，一个新字符以及索引之后的部分来创建一个新的字符串。
- en: For 1 and 3, you can use string *slices*. For example, if the index `i` is 13,
    the slice before it is
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于1和3，你可以使用字符串*切片*。例如，如果索引`i`是13，那么它之前的切片是
- en: '[PRE28]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The part after it is
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 它之后的部分是
- en: '[PRE29]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Using the three parts listed earlier, your `for` loop should be
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面列出的三个部分，你的`for`循环应该是
- en: '[PRE30]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Can you figure that out?
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你能理解这个吗？
- en: 10.1.5 Time to write
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.5 写作时间
- en: OK, the lesson is over. You have to go write this now. Use the tests. Solve
    them one at a time. You can do this.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，课程结束了。你现在要去写这个了。使用测试。一次解决一个。你可以做到的。
- en: 10.2 Solution
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2 解决方案
- en: 'How different was your solution from mine? Let’s look at one way to write a
    program that satisfies the tests:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你的解决方案与我的解决方案有多大的不同？让我们看看一种编写满足测试的程序的方法：
- en: '[PRE31]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ① Import the string module we’ll need to select a random character.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ① 导入我们需要用来选择随机字符的字符串模块。
- en: ② Define a positional argument for the text. This could be either a string of
    text or a file that needs to be read.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ② 为文本定义一个位置参数。这可以是文本字符串或需要读取的文件。
- en: ③ The --seed parameter is an integer value with a default of None.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ③ `--seed` 参数是一个默认值为 `None` 的整数值。
- en: ④ The --mutations parameter is a floating-point value with a default of 0.1.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ④ `--mutations` 参数是一个默认值为 0.1 的浮点数值。
- en: ⑤ Process the arguments from the command line. If argparse detects problems,
    such as non-numeric values for the seed or mutations, the program dies here and
    the user sees an error message. If this call succeeds, argparse has validated
    the arguments and converted the values.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 处理命令行中的参数。如果 `argparse` 检测到问题，例如种子或突变值的非数值，程序将在这里终止，用户将看到错误信息。如果此调用成功，则 `argparse`
    已验证参数并转换了值。
- en: ⑥ If args.mutations is not in the acceptable range of 0-1, use parser.error()
    to halt the program and print the given message. Note the use of feedback to echo
    the bad args.mutation value to the user.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 如果 `args.mutations` 不在可接受的 0-1 范围内，使用 `parser.error()` 停止程序并打印给定信息。注意使用反馈来将错误的
    `args.mutation` 值回显给用户。
- en: ⑦ If args.text names an existing file, read that file for the contents and overwrite
    the original value of args.text.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 如果 `args.text` 命名了一个现有文件，则读取该文件的内容并覆盖 `args.text` 的原始值。
- en: ⑧ Return the processed arguments to the caller.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 将处理后的参数返回给调用者。
- en: ⑨ Set the random.seed() to the value provided by the user. Remember that the
    default value for args.seed is None, which is the same as not setting the seed.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 将 `random.seed()` 设置为用户提供的值。记住，`args.seed` 的默认值是 `None`，这与未设置种子相同。
- en: ⑩ Set alpha to be the characters we’ll use for replacements. The sorted() function
    will return a new list of the characters in the right order, and then we can use
    the str.join() function to turn that back into a str value.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ 将 alpha 设置为我们将用于替换的字符。`sorted()` 函数将返回一个新列表，其中包含字符的正确顺序，然后我们可以使用 `str.join()`
    函数将其转换回字符串值。
- en: ⑪ Since we use len(text) more than once, we put it into a variable.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ⑪ 由于我们多次使用 `len(text)`，我们将其放入一个变量中。
- en: ⑫ Figure the num_mutations by multiplying the mutation rate by the length of
    the text.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ⑫ 通过将突变率乘以文本的长度来计算 `num_mutations`。
- en: ⑬ Make a copy of text.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ⑬ 复制文本。
- en: ⑭ Use random.sample () to get num_mutations indexes to change. This function
    returns a list that we can iterate using the for loop.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ⑭ 使用 `random.sample()` 获取要更改的 `num_mutations` 索引。此函数返回一个列表，我们可以使用 `for` 循环进行迭代。
- en: ⑮ Use random.choice () to select a new_char from a string created by replacing
    the current character (text[i]) in the alpha variable with nothing. This ensures
    that the new character cannot be the same as the one we are replacing.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ⑮ 使用 `random.choice()` 从由将 alpha 变量中的当前字符（text[i]）替换为空创建的字符串中选择一个新字符。这确保了新字符不能与我们要替换的字符相同。
- en: ⑯ Overwrite the text by concatenating the slice before the current index with
    the new_char and then the slice after the current index.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ⑯ 通过连接当前索引之前的切片、新字符以及当前索引之后的切片来覆盖文本。
- en: ⑰ Print the text.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ⑰ 打印文本。
- en: 10.3 Discussion
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3 讨论
- en: There’s nothing in `get_args()` that you haven’t seen before. The `--seed` argument
    is an `int` that we will pass to the `random.seed()` function so as to control
    the randomness for testing. The default seed value is `None` so that we can call
    `random.seed(args.seed)` where `None` is the same as not setting it. The `--mutations`
    parameter is a `float` with a reasonable default, and we use `parser.error()`
    to create an error message if the value is not in the proper range. As in other
    programs, we test whether the `text` argument is a file and read the contents
    if it is.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_args()` 函数中没有你之前没有见过的内容。`--seed` 参数是一个 `int` 类型，我们将将其传递给 `random.seed()`
    函数以控制测试中的随机性。默认的种子值是 `None`，这样我们就可以调用 `random.seed(args.seed)`，其中 `None` 与未设置相同。`--mutations`
    参数是一个具有合理默认值的 `float` 类型，如果值不在适当的范围内，我们使用 `parser.error()` 创建错误信息。与其他程序一样，我们测试
    `text` 参数是否是一个文件，如果是，则读取其内容。'
- en: 10.3.1 Mutating a string
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.1 修改字符串
- en: 'You saw earlier that we can’t just change the `text` string:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你之前看到我们不能只是改变 `text` 字符串：
- en: '[PRE32]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We have to create a *new* string using the text before and after `i`, which
    we can get with string slices using `text[start:stop]`. If you leave out `start`,
    Python starts at `0` (the beginning of the string), and if you leave out `stop`,
    it goes to the end, so `text[:]` is a copy of the entire string.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使用文本的 `i` 前后部分创建一个新的字符串，我们可以通过使用字符串切片 `text[start:stop]` 来获取它。如果你省略 `start`，Python
    从 `0`（字符串的开始）开始，如果你省略 `stop`，它将延伸到末尾，所以 `text[:]` 是整个字符串的副本。
- en: If `i` is `13`, the bit before `i` is
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `i` 是 `13`，则 `i` 前的位是
- en: '[PRE33]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The bit after `i` `+` `1` is
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`i` `+` `1` 后的位是'
- en: '[PRE34]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now for what to put in the middle. I noted that we should use `random.choice()`
    to select a character from `alpha`, which is the combination of all the ASCII
    letters and punctuation *without* the current character. I use the `str.replace()`
    method to get rid of the current letter:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来看看中间应该放什么。我注意到我们应该使用 `random.choice()` 从 `alpha` 中选择一个字符，`alpha` 是所有 ASCII
    字母和标点符号的组合，但不包括当前字符。我使用 `str.replace()` 方法来去除当前的字母：
- en: '[PRE35]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then I use that to get a new letter that won’t include what it’s replacing:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我使用它来获取一个新字母，它不会包括它所替换的内容：
- en: '[PRE36]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'There are many ways to join strings together into new strings. The `+` operator
    is perhaps the simplest:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以将字符串连接成新的字符串。`+` 操作符可能是最简单的：
- en: '[PRE37]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: I do this for each index in the `random.sample()` of indexes, each time overwriting
    `text`. After the `for` loop is done, I have mutated all the positions of the
    input string, and I can `print()` it.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我为 `random.sample()` 中的每个索引执行此操作，每次都覆盖 `text`。在 `for` 循环完成后，我已经突变了输入字符串的所有位置，并且可以
    `print()` 它。
- en: 10.3.2 Using a list instead of a str
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.2 使用列表而不是字符串
- en: 'Strings are immutable, but lists are not. You’ve seen that a move like `text[13]`
    `=` `''b''` creates an exception, but we can change `text` into a list and directly
    modify it with the same syntax:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是不可变的，但列表不是。你已经看到像 `text[13]` `=` `'b'` 这样的操作会创建一个异常，但我们可以将 `text` 改成一个列表，并使用相同的语法直接修改它：
- en: '[PRE38]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can then turn that `list` back into a `str` by joining it on the empty string:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以通过在空字符串上连接它来将那个 `list` 转换回一个 `str`：
- en: '[PRE39]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here is a version of `main()` that uses this approach:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用此方法的 `main()` 版本：
- en: '[PRE40]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: ① Initialize new_text as a list of the original text value.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ① 将 new_text 初始化为原始文本值的列表。
- en: ② Now we can directly modify a value in new_text.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ② 现在我们可以直接修改 new_text 中的值。
- en: ③ Join new_list on the empty string to make a new str.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 在空字符串上连接 new_list 以创建一个新的 `str`。
- en: There’s no particular advantage of one approach over the other, but I would
    personally choose the second method because I don’t like messing around with slicing
    strings. To me, modifying a `list` in place makes much more sense than repeatedly
    chopping up and piecing together a `str`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 没有一种方法比另一种方法有特别的优势，但我会个人选择第二种方法，因为我不喜欢与字符串切片打交道。对我来说，就地修改 `list` 比反复切割和拼接 `str`
    要有意义得多。
- en: Mutations in DNA
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: DNA 中的突变
- en: For what it’s worth, this program mimics (kind of, sort of) how DNA changes
    over time. The machinery to copy DNA makes mistakes, and mutations randomly occur.
    Often the change has no deleterious effect on the organism.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，这个程序（某种程度上）模仿了 DNA 随时间变化的方式。复制 DNA 的机制会出错，突变会随机发生。通常，这种变化对生物体没有有害的影响。
- en: Our example only changes characters to other characters--what biologists call
    “point mutations,” “single nucleotide variations” (SNV), or “single nucleotide
    polymorphisms” (SNP). We could instead write a version that would also randomly
    delete or insert new characters, which are called “in-dels” (insertion-deletions).
    Mutations (that don’t result in the demise of the organism) occur at a fairly
    standard rate, so counting the number of mutations between a conserved region
    of any two organisms can allow an estimate of how long ago they diverged from
    a common ancestor.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例仅更改字符为其他字符——生物学家称之为“点突变”、“单核苷酸变异”（SNV）或“单核苷酸多态性”（SNP）。我们可以编写一个版本，它还会随机删除或插入新字符，这些称为“in-dels”（插入-删除）。突变（不会导致生物体死亡）以相当标准的速率发生，因此，通过计算任何两个生物体保守区域之间的突变数量，可以估计它们从共同祖先分离的时间。
- en: 10.4 Going further
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.4 进一步探索
- en: Apply the mutations to randomly selected words instead of the whole string.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将突变应用于随机选择的单词而不是整个字符串。
- en: Perform insertions and deletions in addition to mutations; maybe create arguments
    for the percentage of each, and choose to add or delete characters at the indicated
    frequency.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了突变之外，还要执行插入和删除操作；也许可以为每种操作的百分比创建参数，并选择在指定的频率下添加或删除字符。
- en: Add an option for `-o` or `--output` that names a file to write the output to.
    The default should be to print to `STDOUT`.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加 `-o` 或 `--output` 选项，指定要写入输出的文件名。默认情况下，应打印到 `STDOUT`。
- en: Add a flag to limit the replacements to character values only (no punctuation).
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个标志以限制替换仅限于字符值（不包括标点）。
- en: Add tests to test.py for every new feature, and ensure your program works properly.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 test.py 中的每个新功能添加测试，并确保程序正常工作。
- en: Summary
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: '|'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: A string cannot be directly modified, but the variable containing the string
    can be repeatedly overwritten with new values.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串不能直接修改，但包含字符串的变量可以被新值反复覆盖。
- en: Lists can be directly modified, so it can sometimes help to use `list` on a
    string to turn it into a `list`, modify that list, and then use `str.join()` to
    change it back to a `str`.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表可以直接修改，因此有时使用 `list` 将字符串转换为列表，修改该列表，然后使用 `str.join()` 将其转换回字符串可能会有所帮助。
- en: The `string` module has handy definitions of various strings.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string` 模块提供了各种字符串的便捷定义。'
- en: '| ![](../Images/10-unnumb-4.png)  |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| ![图片](../Images/10-unnumb-4.png)  |'
