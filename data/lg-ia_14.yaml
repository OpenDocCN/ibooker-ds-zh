- en: 10 Logging best practices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 日志最佳实践
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Applying log levels to filter and prioritize actions
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将日志级别应用于过滤和优先处理操作
- en: Identifying characteristics of good logs
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别良好日志的特征
- en: Easing operational activities with good logs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用良好的日志简化操作活动
- en: Understanding the impact of legislation on logs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解立法对日志的影响
- en: Coding practices for improved logging
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高日志记录的编码实践
- en: The technology used is only as good as the log events themselves, regardless
    of how log entries are generated, whether applications write to stdout, stderr,
    OS event frameworks, or logging frameworks. To maximize the technical investment,
    we need to make the log events and their creation as effective as possible.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的这项技术仅与日志事件本身一样好，无论日志条目是如何生成的，无论是应用程序写入stdout、stderr、OS事件框架还是日志框架。为了最大化技术投资，我们需要使日志事件及其创建尽可能有效。
- en: We have delved deeply into the technology, so we need to do the same for log
    events. This chapter will explore what should and should not be logged in terms
    of business data, and it will examine what information can make log events more
    helpful. With that, we’ll identify some practices to help get values from the
    log events. The business data our systems process can be subject to a wide variety
    of contractual and legislative requirements. So we’ll look at some of the better-known
    legislation needs, some options to mitigate their impact, and sources that can
    help us identify any other legislative requirements that can impact the use of
    logging.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经深入探讨了技术，因此我们也需要对日志事件做同样的事情。本章将探讨在业务数据方面应该记录什么，不应该记录什么，并检查哪些信息可以使日志事件更有帮助。有了这些，我们将确定一些实践来帮助从日志事件中获得价值。我们系统处理的业务数据可能受到各种合同和法律要求的影响。因此，我们将探讨一些更知名的立法需求，一些减轻其影响的选项，以及可以帮助我们识别可能影响日志使用其他立法需求的来源。
- en: 10.1 Audit events vs. log events
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1 审计事件与日志事件对比
- en: 'When is an event an audit event, and when is it a log event? Let’s start with
    defining what the two events are (figure 10.1):'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 何时一个事件是审计事件，何时是日志事件？让我们先定义这两个事件是什么（图10.1）：
- en: '*Audit events*—These are typically a record of an action, event, or data state
    that needs to be retained to provide a formal record that may be required at some
    future point to help resolve an issue of compliance (such as accounting processes
    or security). Many of these actions will be user-triggered.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*审计事件*——这些通常是记录一个动作、事件或数据状态，这些状态需要保留以提供可能在未来某个时刻需要解决合规性问题（如会计流程或安全）的正式记录。许多这些动作将由用户触发。'
- en: '*Log events*—These record something that has occurred; the log event will be
    provided for a technical reason, ranging from showing how a transaction has been
    handled to reporting unexpected circumstances to show how code is executing.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*日志事件*——这些记录了已经发生的事情；日志事件将出于技术原因提供，范围从显示交易是如何处理的到报告意外情况以显示代码是如何执行的。'
- en: '![](../Images/CH10_F01_Wilkins.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![Wilkins图](../Images/CH10_F01_Wilkins.png)'
- en: Figure 10.1 Venn diagram showing the relationship between logging and auditing
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 展示日志和审计之间关系的维恩图
- en: From the description, you can see a fair degree of overlap. The overlap comes
    from the fact that logging as a technical mechanism can be used to meet auditing
    requirements, and both have a common core of data. Audit events are often informed
    by well-structured content with a bias to security-related events, such as logging
    in and out. The question is more about whether the tool the events are routed
    to is suited to audit-related tasks. This all points to the fact that a log unification
    tool like Fluentd can support audit needs; we need to concentrate on ensuring
    the information in the event is suitable and that we send it to a suitable tool
    for analysis.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 从描述中，你可以看到相当程度的重叠。这种重叠源于日志作为一种技术机制可以用来满足审计要求，并且两者都有一个共同的数据核心。审计事件通常由结构良好的内容组成，偏向于与安全相关的事件，如登录和注销。问题是关于事件路由到的工具是否适合审计相关任务。所有这些都指向这样一个事实，即像Fluentd这样的日志统一工具可以支持审计需求；我们需要专注于确保事件中的信息是合适的，并且将其发送到合适的工具进行分析。
- en: 10.2 Log levels and severities
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2 日志级别和严重性
- en: Going back to chapter 1, we talked about how log messages will support different
    roles at different times, whether you work in a DevOps organization (the development
    team is also operationally responsible) or on a classic separated operation and
    development team. Some logs help development and testing, others help with troubleshooting,
    and still others help with forgetting audit, security, and performance tracking.
    The simplest thing that can be done is to attribute every log with a log level
    or severity reflecting the impact of what the log event represents. Typical log
    levels are *trace*, *debug*, *info(rmation)*, *warn(ing)*, *error*, and *fatal*.
    The idea of event severity and these severity levels goes back to the ’80s and
    Syslog development. Many aspects of how Syslog does things have become standards
    with the IETF (Internet Engineering Task Force; [https://tools.ietf.org/html/rfc5424](https://tools.ietf.org/html/rfc5424)).
    But there is a correlation between these levels on the associated activities,
    as we’ll see in a moment.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 回到第1章，我们讨论了日志消息将如何在不同时间支持不同的角色，无论你是工作在DevOps组织（开发团队也负责运营）还是在经典分离的运营和开发团队中。一些日志有助于开发和测试，其他日志有助于故障排除，还有一些日志有助于审计、安全和性能跟踪。最简单的事情就是给每个日志分配一个反映日志事件代表影响的日志级别或严重性。典型的日志级别有*追踪*、*调试*、*信息*、*警告*、*错误*和*致命*。事件严重性和这些严重级别可以追溯到20世纪80年代和Syslog的开发。Syslog如何做的许多方面已经随着IETF（互联网工程任务组；[https://tools.ietf.org/html/rfc5424](https://tools.ietf.org/html/rfc5424)）而成为标准。但正如我们稍后将看到的，这些级别与相关活动之间存在关联。
- en: NOTE Should log events be described using terms such as *severity* or *log levels*?
    The IETF talks about severity; however, this carries connotations suggesting the
    log information is linked to something bad. However, logs should legitimately
    be generated to indicate that everything is running as expected. As a result,
    many people, including myself, use the term *log level* to avoid the connotations
    that come with the word *severity*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：是否应该使用诸如*严重性*或*日志级别*之类的术语来描述日志事件？IETF讨论了严重性；然而，这带有暗示日志信息与不良事物相关的含义。然而，日志应该合法地生成以指示一切按预期运行。因此，包括我自己在内，许多人使用*日志级别*这个术语来避免与*严重性*一词相关的含义。
- en: Of course, the key to this is a common understanding of what the log level represents.
    Misclassification of log entries is a common mistake with log events, which is
    why we've mentioned the possibility of correcting those issues using Fluentd in
    previous chapters. But it also means we should be explicit and that teams agree
    on the meaning of the levels. The following sections provide a common set of log
    level definitions.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，关键在于对日志级别所代表内容的共同理解。日志条目的误分类是日志事件中常见的错误，这就是为什么我们在前面的章节中提到了使用Fluentd纠正这些问题的可能性。但这也意味着我们应该明确，并且团队就级别的含义达成一致。以下各节提供了一个共同的日志级别定义集。
- en: 10.2.1 Trace
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.1 追踪
- en: Primarily for development activities, the execution can have simple events written
    to the log to indicate what method is executing. This allows us to confirm/validate
    that execution paths are as expected.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 主要用于开发活动，执行可以写入日志的简单事件，以指示正在执行的方法。这使我们能够确认/验证执行路径是否符合预期。
- en: When it comes to the ideas of *open tracing* and *open telemetry*, we do need
    to separate these from the classification. These technologies collect “trace”
    information showing how a “transaction” has flowed through our environment. Open
    tracing depends on the granularity of the tracing implemented. If the trace reflects
    the technical steps of what is executed during the transactional flow, for example,
    in and out of components, functions, and so on, then we will see a fine-grained
    and comprehensive trace, and it should be logged using a trace categorization.
    If the tracing reflects the business perspectives (e.g., executing all the actions
    related to getting goods into a warehouse), then we’re going to see coarse-grained
    details, and this is best logged at an information level.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到*开放追踪*和*开放遥测*的概念时，我们确实需要将这些技术与分类区分开来。这些技术收集显示“事务”如何在我们环境中流动的“追踪”信息。开放追踪依赖于所实现追踪的粒度。如果追踪反映了事务流程中执行的技术步骤，例如，进入和离开组件、函数等，那么我们将看到一个细粒度和全面的追踪，并且应该使用追踪分类进行记录。如果追踪反映了业务视角（例如，执行与将商品运入仓库相关的所有操作），那么我们将看到粗粒度细节，这最好在信息级别进行记录。
- en: 10.2.2 Debug
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.2 调试
- en: This level is intended for sharing logging data to support any development and
    debugging activities. This logging level should be information-rich to make troubleshooting
    easy or to re-create an operational issue, since it will yield the most insight
    into what the software is doing. The content of such information should be produced
    with both developers and those involved in more detailed troubleshooting. We often
    see this level of logging being used rather than trying to use an IDE debugger
    and attaching it to running software.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此级别旨在共享日志数据以支持任何开发和调试活动。此日志级别应信息丰富，以便轻松进行故障排除或重新创建运营问题，因为它将提供对软件正在做什么的最深入了解。此类信息的生成应涉及开发人员和参与更详细故障排除的人员。我们经常看到此级别的日志记录被使用，而不是试图使用IDE调试器并将其附加到正在运行的软件上。
- en: These log messages are the most vulnerable to accidentally logging too much
    information (e.g., personal or financial data), as whole data objects can be easily
    logged. This shouldn’t be an issue in non-production environments since the data
    is likely to be synthetic. This also means it is easy to overlook the risks for
    production.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这些日志消息最容易被意外记录过多信息（例如，个人或财务数据），因为整个数据对象可以轻松地被记录。在非生产环境中，这通常不会成为问题，因为数据很可能是合成的。这也意味着很容易忽视生产中的风险。
- en: The risk of logging sensitive data could be addressed by
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下方式可以解决记录敏感数据的风险
- en: Developing standards that include details to address what data is or isn’t logged
    and testing processes to ensure synthetic event data isn’t logged.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制定包括如何记录或不记录数据在内的详细标准的规范，并测试流程以确保不会记录合成事件数据。
- en: Putting a blanket ban on enabling debug-level logging in production (production
    should never have debug-level logging). In the event of a serious operational
    issue, the temptation to help diagnose a significant operational issue will be
    high, and the consequences of setting debug-level logging are overlooked until
    it’s too late.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在生产环境中全面禁止启用调试级别的日志记录（生产永远不应该有调试级别的日志记录）。在出现严重的运营问题时，帮助诊断重大运营问题的诱惑会很高，而设置调试级别日志的后果直到太晚才会被忽视。
- en: 10.2.3 Info(rmation)
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.3 信息（信息）
- en: This is the typical threshold for logs in everyday operational environments.
    It should provide sufficient log information that diagnostic tasks can be undertaken
    if a system doesn’t appear to be behaving correctly. The information recorded
    should include details like
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这是日常操作环境中日志的典型阈值。它应该提供足够的日志信息，以便在系统似乎行为不正确时进行诊断任务。记录的信息应包括如下细节
- en: Software versions, and so on, logged during startup and deployment.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在启动和部署期间记录的软件版本等。
- en: Audit logging, such as what and who, through details like session IDs (this
    brings challenges involving personal data security, which we’ll discuss in more
    depth later).
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审计日志，如什么和谁，通过如会话ID等细节（这涉及到个人数据安全的问题，我们将在稍后更深入地讨论）。
- en: Data values that influence decision logic.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 影响决策逻辑的数据值。
- en: Interaction with sources and targets, such as URIs for other services, databases.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与源和目标交互，例如其他服务的URI或数据库。
- en: 10.2.4 Warn(ing)
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.4 警告
- en: When things are not working as expected, there is a risk of an error, but the
    software can continue to execute. For example, database connections fail, and
    the code supports a rollback or a successful retry operation. This may result
    in a warning to say that it failed to connect, and then an error if it retries,
    or a complete rollback and the transaction being abandoned.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当事情没有按预期进行时，存在出现错误的风险，但软件可以继续执行。例如，数据库连接失败，代码支持回滚或成功的重试操作。这可能会导致一个警告，说明它未能连接，然后在重试时出现错误，或者完全回滚并放弃事务。
- en: Warnings should not require immediate intervention but should be indicative
    of the possibility of remediation being needed. This should include handling unexpected
    paths, and therefore assuming an action.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 警告不应需要立即干预，但应表明可能需要补救。这应包括处理意外路径，并因此采取行动。
- en: Warnings ideally are linked to operational guidance documentation such as advising
    that maintenance processes may need to be performed sooner than the maintenance
    schedule would lead us to expect, or that mitigation actions have been automatically
    taken, such as scaling up a resource. Other warning actions may include reviewing
    how a transaction has been completed as the system hasn’t processed it conventionally
    or the code has assumed something incorrectly.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 警告理想情况下应与操作指导文档相关联，例如建议维护流程可能需要比维护计划预期的更早执行，或者已经自动采取了缓解措施，例如增加资源。其他警告操作可能包括审查交易是如何完成的，因为系统没有按常规处理它，或者代码假设了某些不正确的事情。
- en: We should also think about our solutions being defensive, checking if things
    are getting close to dangerous thresholds, and creating warnings. For example,
    this might include ensuring there is disk capacity to cope with the current rate
    of data growth. Other defenses should include validating data received, even if
    it originated from a trusted source.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该考虑我们的解决方案具有防御性，检查事物是否接近危险阈值，并创建警告。例如，这可能包括确保有足够的磁盘容量来应对当前的数据增长速度。其他防御措施应包括验证接收到的数据，即使它来自可信的来源。
- en: 10.2.5 Error
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.5 错误
- en: This is used to record an event that will require intervention; for example,
    performing an operation on an empty data structure that is assumed to always have
    a value can trigger a null pointer exception. This will likely create a situation
    where a process does not complete cleanly and thus needs to reflect as an error.
    For logging to help with error resolution, the log events need to clarify the
    error cause. The location in the code where the error occurred is crucial in order
    to enable improvements to be effectively applied. This means a developer needs
    consumable information in an error log event to help implement improvements, and
    Ops need details to determine what remediation is needed.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这用于记录需要干预的事件；例如，对一个假设始终有值的空数据结构执行操作可能会触发空指针异常。这可能会创建一个进程无法干净完成的情况，因此需要反映为错误。为了帮助解决错误，日志事件需要阐明错误原因。错误发生的代码位置对于有效地应用改进至关重要。这意味着开发人员需要在错误日志事件中获取可消费的信息以帮助实施改进，而运维人员需要详细信息以确定需要哪些修复措施。
- en: When errors occur, not only do we need a fix, but the errors also need to have
    operational corrections applied to data (e.g., dividing by zero results in a calculated
    value not being updated). Therefore, the information must also be clearly understood
    by Ops people and the development/support team. Error codes can be beneficial,
    as the remediation steps can be documented without swamping code with lots of
    text.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生错误时，我们不仅需要一个解决方案，还需要对数据进行操作上的纠正（例如，除以零导致计算值未更新）。因此，信息必须也被运维人员和发展/支持团队清楚地理解。错误代码可能有益，因为修复步骤可以在不淹没代码大量文本的情况下进行记录。
- en: Errors should try to fail gracefully—that is, they are handled and minimize
    the disruption (e.g., record the requested transaction and then allow subsequent
    transactions to be processed without being tainted if possible).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 错误应尽量优雅地失败——也就是说，它们被处理并尽量减少干扰（例如，记录请求的交易然后允许后续交易在没有被污染的情况下处理）。
- en: 10.2.6 Fatal
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.6 致命
- en: This kind of error should only be used in exceptional circumstances, such as
    when the application has to terminate unexpectedly. The termination is likely
    to be ungraceful. As with errors, the information needs to be as comprehensive
    as possible. However, with a fatal error, there may be limitations on the information
    that can be gathered—for example, a fatal error because of a failed file system
    will limit the ability to grab related data values that may have influenced the
    cause of the problem.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这种错误仅在例外情况下使用，例如当应用程序必须意外终止时。终止可能是不优雅的。与错误一样，信息需要尽可能全面。然而，对于致命错误，可能存在可以收集的信息的限制——例如，由于文件系统失败而导致的致命错误将限制获取可能影响问题原因的相关数据值的能力。
- en: Again, error codes can be helpful, both to direct recovery tasks and by providing
    indications to underlying causes without resorting to having to build nice error
    messages.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，错误代码可以是有帮助的，既可以指导恢复任务，又可以通过提供不依赖于构建良好错误消息的底层原因的指示。
- en: 10.2.7 Extending or creating your own log levels
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.7 扩展或创建自己的日志级别
- en: These definitions do not mean you can’t formulate your own levels, but they
    have significant implications in using a framework and ensuring common understanding.
    For example, from time to time, I have wondered whether the error level should
    be split—some errors demand immediate intervention, as they are a precursor to
    a fatal event if you don’t intervene. And some errors mean a bad outcome, but
    they can wait until regular operating hours to be resolved. Consider an overnight
    payroll run—the calculation of the pay for one individual has failed because the
    formula didn’t allow for someone being paid for 0 hours one month, triggering
    an error such as dividing by zero. While this is an error and needs addressing,
    should it stop the payroll run for everyone?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这些定义并不意味着你不能制定自己的级别，但它们在使用框架和确保共同理解方面具有重大影响。例如，我时常在想错误级别是否应该被拆分——一些错误需要立即干预，因为如果不干预，它们可能是致命事件的先兆。而一些错误意味着不良的结果，但它们可以等到正常工作时间再解决。考虑一个夜间的工资发放——由于公式不允许某人在一个月内获得0小时工资，导致了一个除以零的错误。虽然这是一个错误并且需要解决，但它是否应该停止所有人的工资发放？
- en: The log levels have a hierarchy of severity, and with that comes a frequency
    of occurrence. Trace logs are likely to be pretty pervasive, but fatal log events
    should be very rare. We can see this in figure 10.2\. If we add a new log level,
    how does it fit into the hierarchy?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 日志级别具有严重性的层次结构，随之而来的是发生频率。跟踪日志可能非常普遍，但致命的日志事件应该非常罕见。我们可以在图10.2中看到这一点。如果我们添加一个新的日志级别，它将如何融入这个层次结构？
- en: '![](../Images/CH10_F02_Wilkins.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F02_Wilkins.png)'
- en: Figure 10.2 Log levels as a hierarchy of severity and occurrence
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 日志级别作为严重性和发生频率的层次结构
- en: While creating additional or different log levels is possible, I have concluded
    that changing log levels from industry norms is like swimming against the tide
    and have settled on clearly worded definitions of log levels. If you’re considering
    customized log levels, the bottom line is to be prepared for a considerable amount
    of effort, from communicating the log-level details to figuring out everything
    impacted to determining the log framework settings.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然创建额外的或不同的日志级别是可能的，但我得出结论，改变日志级别与行业规范相悖，就像逆流游泳一样，我决定采用清晰定义的日志级别。如果你正在考虑定制日志级别，底线是要准备好投入相当多的努力，从传达日志级别细节到弄清楚所有受影响的内容，再到确定日志框架设置。
- en: Should audit events use log levels, given the overlap previously described?
    Typically, audit events should be benign in nature and as a result should be logged
    at the info level, as indicated in section 10.2.3\. However, if your auditing
    includes financial considerations, then failed transactions such as credits/debits
    to an account balance should form part of the audit trail and reflect the event’s
    significance. As such, events may require manual intervention, which will create
    subsequent audit events showing possible interventions. It is worth considering
    the possibility of linking the log events together to enable better insight.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到之前描述的重叠，审计事件应该使用日志级别吗？通常，审计事件应该是良性的，因此应该记录在info级别，如第10.2.3节所示。然而，如果你的审计包括财务考虑，那么像账户余额的借记/贷记失败交易这样的失败交易应该成为审计跟踪的一部分，并反映事件的重大性。因此，事件可能需要人工干预，这将创建后续的审计事件，显示可能的干预。值得考虑将日志事件链接起来以获得更好的洞察。
- en: 10.3 Clear language
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3 清晰的语言
- en: Writing log entries can at times feel tedious, and searching through log files
    is unexciting. It is tempting to include jokes (or worse) in the messages, making
    logs more entertaining, or add random keywords that are easy to search for when
    it’s our code rather than simple, straightforward language. The problem is that
    there will be a time when you will no longer be the person looking at these messages.
    There is a fair chance that someone who needs to work with the logs may not have
    the language you are using as their first language, so the message’s meaning will
    not be understood. Logging things like `Geronimo ...` or `one giant leap for code`
    when logging about raising an exception is lighthearted for most, but it may cause
    confusion or, worse, may offend someone in the future—so, sorry, it’s time to
    be boring, simple, and direct. Using wording to make log searches easier is good
    but not at the price of risking understanding.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 编写日志条目有时会感觉枯燥乏味，搜索日志文件也不吸引人。在消息中包含笑话（或者更糟）以使日志更有趣，或者添加当我们的代码而不是简单直接的语言时容易搜索的随机关键词，这种诱惑是存在的。问题是，你将不再是查看这些消息的人。有相当大的可能性，需要与日志一起工作的人可能不使用你使用的语言作为他们的第一语言，因此消息的含义将不会被理解。在记录异常时使用像“Geronimo
    ...”或“代码的一大步”这样的轻松话语，对大多数人来说可能是轻松的，但它可能引起混淆，或者更糟，将来可能冒犯到某人——所以，抱歉，现在是时候变得无聊、简单和直接了。使用措辞使日志搜索更容易是好的，但不能以牺牲理解的风险为代价。
- en: In the same vein as this, we should carefully choose the words we use in log
    messages. This is important, as we do often overload the meaning of words. For
    example, when using API, some treat the term as just the interface specification,
    as you would see with technologies like OpenAPI, Blueprint, and Swagger. Others
    actually mean the code that implements the logic behind the Swagger, Open API,
    or Blueprint definition. This problem isn’t just an IT issue; it happens within
    the business domains we are using or in writing software.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 与此类似，我们应该仔细选择我们在日志消息中使用的词语。这很重要，因为我们确实经常使词语的含义超载。例如，当使用API时，有些人将术语视为仅仅是接口规范，就像你在OpenAPI、Blueprint和Swagger等技术中看到的那样。其他人实际上是指实现Swagger、Open
    API或Blueprint定义背后逻辑的代码。这个问题不仅仅是一个IT问题；它发生在我们使用的业务领域或编写软件的过程中。
- en: 10.4 Human and machine-readable
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.4 人类和机器可读性
- en: 'Calling out the need for logs to be both humanly readable and machine-readable
    may seem rather obvious. But when we’re writing log event entries, it is easy
    to focus on what reads well for us humans and forget that perhaps we want to make
    the log event actionable downstream, which means we should ensure the log event
    is as structured as possible. For example, if I had a log entry that said `"received
    12345678 datetime for the schedule that is in the past,"` that could become `{"IncorrectData":
    "12345678", "AttributeImpacted": "schedule", "DataType": "date-time", "Reason":
    "date past"}`. It may require a little more cognitive effort to read the log message,
    but the latter format can be subjected to many possibilities in processing, from
    the error cause to the way we represent values.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '强调日志需要既易于人类阅读又易于机器读取的需求似乎非常明显。但当我们编写日志事件条目时，很容易专注于对我们人类来说读起来好的内容，而忘记我们可能希望使日志事件可操作，这意味着我们应该确保日志事件尽可能结构化。例如，如果我有一个日志条目说“收到了过去的时间戳12345678”，它可以变成`{"IncorrectData":
    "12345678", "AttributeImpacted": "schedule", "DataType": "date-time", "Reason":
    "date past"}`。阅读日志消息可能需要一点更多的认知努力，但后一种格式在处理上可以有很多可能性，从错误原因到我们表示值的方式。'
- en: 10.5 Context is key
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.5 上下文是关键
- en: 'Understanding any log event requires context. When we’re developing and using
    trace and debug logs, the context will, to an extent, be known to us, perhaps
    implicitly, as the position in the code will be part of the context or the test
    scenario being run will be the context. But when we come to production, the context
    is not likely to be implicit, so we need to make it explicit. The key to the context
    is how well we’re answering the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 理解任何日志事件都需要上下文。当我们开发和使用跟踪和调试日志时，上下文在一定程度上是我们所知的，可能是隐含的，因为代码的位置将是上下文的一部分，或者正在运行的测试场景将是上下文。但当我们进入生产环境时，上下文可能不会是隐含的，因此我们需要使其明确。上下文的关键在于我们如何回答以下问题：
- en: '*What*—What is being reported, an error or just a trace?'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*什么*——正在报告什么，是一个错误还是仅仅是一个跟踪？'
- en: '*When*—The date and time. This is the easy bit if you’re using some form of
    logging framework.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*何时*——日期和时间。如果你使用某种形式的日志框架，这部分是容易的。'
- en: '*Where*—Where in the code and where in the infrastructure the source of the
    log event is.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*位置*——日志事件源在代码和基础设施中的位置。'
- en: '*Why*—When it comes to log levels of info and higher, why we provide the information
    is essential. Is there a problem about to occur, or are we reporting something
    you want to track, like a login action?'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*原因*——当涉及到信息和更高日志级别的日志级别时，我们提供信息的原因是至关重要的。是即将发生问题，还是我们在报告你想跟踪的事情，比如登录操作？'
- en: '*Who*—Who triggered the action? Whose data could be impacted?'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*谁*——谁触发了操作？谁的数据可能会受到影响？'
- en: Let’s explore these points in a bit more detail.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地探讨这些点。
- en: '10.5.1 Context: What'
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.5.1 上下文：内容
- en: 'The log event’s “what” is partially addressed by the log level being included
    in the event. For trace log events, the fact that the event is logged is probably
    enough when combined with where. For info log level and above, we’re going to
    provide some additional detail: Is the info record for audit purposes? What kind
    of error has occurred? What does the warning relate to (e.g., shortage of storage)?
    The “what” is best supported with details that allow a transaction to be identified,
    including the type of transaction. The transactional data or a proxy, such as
    a unique ID for a transaction (so we can look up the actual transaction data),
    should provide sufficient insight; for example, if the transaction is missing
    a reference to associated data, we need to see that value isn’t set.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 日志事件的“内容”部分通过在事件中包含日志级别来部分解决。对于跟踪日志事件，当结合位置信息时，事件被记录的事实可能就足够了。对于信息日志级别及以上，我们将提供一些额外的细节：这个信息记录是为了审计目的吗？发生了什么类型的错误？警告与什么相关（例如，存储空间不足）？最佳地支持“内容”的是允许识别事务的细节，包括事务类型。事务数据或代理，如事务的唯一ID（这样我们就可以查找实际的事务数据），应该提供足够的洞察力；例如，如果事务缺少对相关数据的引用，我们需要看到该值没有被设置。
- en: '10.5.2 Context: When'
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.5.2 上下文：何时
- en: Logging frameworks address most of this for you without any effort but are likely
    to go back to the server’s system clock. In chapter 2, we highlighted the implications
    of time zones, clock skew, and so on. These can catch you out if you’re looking
    for a solution that is running in a time zone that applies daylight saving time
    (because someone is looking at the timestamp and it appears to be out because
    they’re applying daylight saving time but the log isn’t) or the solution is globally
    distributed. So you need to know which time zone the server is in. One option
    is to configure the logging framework to include the time zone in the log, but
    better still, align all servers to UTC (Coordinated Universal Time).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 日志框架为您解决了大部分问题，无需任何努力，但很可能会回到服务器的系统时钟。在第2章中，我们强调了时区、时钟偏差等问题的影响。如果你在寻找一个运行在采用夏令时的时区（因为有人查看时间戳，它看起来不正确，因为他们正在应用夏令时，但日志没有）或全球分布式的解决方案时，这些问题可能会让你陷入困境。因此，你需要知道服务器所在的时区。一个选择是将时区配置到日志框架中，但更好的做法是将所有服务器对齐到协调世界时（UTC）。
- en: When trying to align a log analysis with a user error report, you will need
    to be clear about which time zone the user is working in and whether the error
    report is recorded against their time or system time.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试将日志分析与用户错误报告对齐时，你需要明确用户正在工作的时区以及错误报告是按照他们的时间还是系统时间记录的。
- en: '10.5.3 Context: Where'
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.5.3 上下文：位置
- en: Naming the code location requires some awareness of how the code is handled.
    This is especially important when the code is deployed for a commercial solution
    where *obfuscation* and *minifier* tools are likely to be used, particularly on
    script-based solutions such as JavaScript. As a result, relying on reflection
    to get details of where the code is can be unhelpful. Although there are tools,
    some obscurification providers will include mapping information to identify the
    original code given the correct information.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 命名代码位置需要了解代码是如何处理的。当代码被用于商业解决方案，并且可能使用*混淆*和*最小化*工具时，这一点尤为重要，尤其是在基于脚本的解决方案，如JavaScript中。因此，依赖于反射来获取代码位置的细节可能是不有帮助的。尽管有一些工具，但一些混淆提供者会包括映射信息，以便根据正确信息识别原始代码。
- en: 'NOTE For more information on code minifying and obscuring, check out the following
    resources:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：有关代码最小化和混淆的更多信息，请参阅以下资源：
- en: The liveBook version of *Web Performance in Action* by Jeremy L. Wagner (Manning,
    2016) at [http://mng.bz/g4RV](http://mng.bz/g4RV)
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jeremy L. Wagner（Manning，2016年）所著的《Web Performance in Action》的liveBook版本，可在[http://mng.bz/g4RV](http://mng.bz/g4RV)找到
- en: '[http://mng.bz/p26z](http://mng.bz/p26z)'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://mng.bz/p26z](http://mng.bz/p26z)'
- en: Applications are typically either multithreaded (e.g., Java) or context switched
    on an I/O wait (e.g., Node.js) and they are single-threaded. The context switching
    means we don’t handle one transaction at a time, so understanding whether log
    events preceding or following the event of interest are related can become challenging.
    This can be overcome by incorporating transaction IDs or session IDs, or by leveraging
    open tracing or open telemetry IDs as part of the log event. Some logging frameworks
    will help you capture a thread or process ID in their configuration. For example,
    in Fluentd, we can utilize the *WorkerId* in log file output.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序通常是多线程的（例如，Java）或在I/O等待时进行上下文切换（例如，Node.js），并且它们是单线程的。上下文切换意味着我们一次不处理一个事务，因此理解感兴趣事件之前或之后的事件是否相关可能变得具有挑战性。这可以通过包含事务ID或会话ID，或者利用日志事件的一部分开放跟踪或开放遥测ID来克服。一些日志框架会在它们的配置中帮助您捕获线程或进程ID。例如，在Fluentd中，我们可以利用日志文件输出中的*WorkerId*。
- en: “Where” can also be influenced by software versions. We can have multiple versions
    of the same logic in production at one time to support activities such as
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: “Where”也可能受到软件版本的影响。在生产环境中，我们可能同时拥有同一逻辑的多个版本，以支持诸如
- en: Operating A/B deployments to help evaluate whether one implementation improves
    user interaction
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行A/B部署以帮助评估某个实现是否改善了用户体验
- en: Operating with high availability, so software updates require rolling updates
    to occur
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以高可用性运行，因此软件更新需要滚动更新来发生
- en: 'Here’s another way to look at it: you spot an image that has not been rendered
    very well in this book. You contact Manning. To help you, we need to know which
    figure is faulty. What if the issue has been seen before and been fixed in a new
    edition of the book? This isn’t saying that every log event needs to publish every
    aspect of version information, but we do need to make it easy to supply sufficient
    information. Perhaps when we log errors or worse, this information is written
    into the log. This is an area where injecting into log events can be helpful.
    If a log event is identified as reposting something abnormal in the software,
    such as an error, then Fluentd could retrieve the version of the software running
    and inject it into the logs for future reference.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有另一种看待它的方法：你注意到这本书中有一张图像渲染得不是很好。你联系了Manning。为了帮助你，我们需要知道哪个图是错误的。如果这个问题之前已经出现过，并在新版本的书中被修复了呢？这并不是说每个日志事件都需要发布每个版本信息方面，但我们确实需要让它容易提供足够的信息。也许当我们记录错误或更糟的情况时，这些信息会被写入日志。这是一个在日志事件中注入信息可能有所帮助的领域。如果日志事件被识别为软件中异常的重新发布，例如错误，那么Fluentd可以检索正在运行的软件版本并将其注入到日志中供将来参考。
- en: '10.5.4 Context: Why'
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.5.4 上下文：为什么
- en: This comes down to why an event has occurred—is it an error or just a signal
    to show where the code is (trace) or the application’s current state (debug)?
    As we move to the higher levels (warning, error, and fatal in our classification),
    “why” becomes more important and less evident from just the log level. The information-level
    log events could be an audit or a periodic snapshot of the system’s current state
    regardless of whether things are good or bad—for example, logging how deep a message
    queue is. However, the log event consumer needs to be able to understand why the
    event is being generated. With a bit of thought, this is easily solved.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这归结于事件发生的原因——是错误还是仅仅是一个显示代码位置（跟踪）或应用程序当前状态（调试）的信号？随着我们向更高层次（警告、错误和致命在我们的分类中）移动，“为什么”变得更加重要，并且仅从日志级别来看不那么明显。信息级别的日志事件可能是一个审计或系统当前状态的定期快照，无论事情是好是坏——例如，记录消息队列的深度。然而，日志事件消费者需要能够理解事件生成的原因。经过一些思考，这很容易解决。
- en: A simple attribute, such as “current status” or “audit action,” could be included
    along with the shared data. We are, in effect, providing a secondary classification
    in many cases for the log event. Given that we provide additional metadata, we
    might structure it as long as we are consistent within the development organization.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 可以包含一个简单的属性，例如“当前状态”或“审计操作”，以及共享数据。实际上，我们在许多情况下为日志事件提供了一个二级分类。鉴于我们提供了额外的元数据，我们可能会在开发组织内部保持一致性的情况下对其进行结构化。
- en: When it comes to reporting warnings and errors, the why comes back to what triggered
    the warning or error. Is it the primary error, or has something occurred as a
    by-product of a previous issue? Trying to indicate whether an error is cause or
    effect is difficult. If we can be certain, we should be clear; if it isn’t, we
    can perhaps give the log event consumer some hint about the possibility. Coding
    such information can be complicated and hard to test. But it is easy to link to
    an error code and provide steps to confirm cause or effect.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到报告警告和错误时，原因回到了触发警告或错误的原因。这是主要错误，还是之前问题产生的副作用？试图表明错误是原因还是效果是困难的。如果我们能确定，我们应该明确指出；如果不能，我们可能给日志事件消费者一些关于可能性的提示。编码此类信息可能很复杂且难以测试。但很容易链接到错误代码并提供确认原因或效果的步骤。
- en: The record we generate with the event needs to clearly provide the information
    to help perform a diagnosis, not just operationally, but also whether something
    in the code may be needed, such as a more defensive code or better data validation.
    As the solution is now on an unhappy path, we should not be afraid to be generous
    with the information—as long as it doesn’t raise sensitivity issues, which we’ll
    look at shortly. For error-handling paths, we’re in a place where performance
    should not be a consideration, as this part of the codebase should only execute
    infrequently. Generally, too little information is a lot worse than too much.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过事件生成的记录需要清楚地提供信息，以帮助进行诊断，不仅限于操作层面，还包括代码中是否可能需要更多防御性代码或更好的数据验证。由于解决方案目前处于不愉快的路径上，我们不应害怕提供更多信息——只要它不会引发敏感问题，我们将在稍后讨论。对于错误处理路径，我们处于一个性能不应成为考虑因素的位置，因为这部分代码库应该很少执行。一般来说，信息过少比信息过多要糟糕得多。
- en: '10.5.5 Context: Who'
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.5.5 上下文：谁
- en: Logging of “who” can be tricky. As we’ll see a little later, logging information
    that is identifiable to an individual will make our log processing subject to
    legislative, contractual, and commercial requirements. Still, we will explore
    this a bit more later in the chapter. The important thing is to consider when
    the “who” is necessary and whether we can safely use other data as a proxy for
    the true identity. For example, perhaps the “who” is relevant only during the
    logged-in session, so we just need to carry the session ID and use that. If we
    need to attribute the actions in a session back to a specific individual, we record
    that separately in a secure way. That session ID could equally be a transaction
    or order ID, and so on.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 记录“谁”可能会很棘手。正如我们稍后将看到的，记录可识别为个人的信息将使我们的日志处理受到立法、合同和商业要求的约束。尽管如此，我们将在本章稍后更深入地探讨这一点。重要的是要考虑何时需要“谁”，以及我们是否可以安全地使用其他数据作为真实身份的代理。例如，也许“谁”仅在登录会话期间相关，因此我们只需要携带会话ID并使用它。如果我们需要将会话中的操作归因于特定个人，我们将以安全的方式单独记录。那个会话ID同样可以是交易或订单ID等。
- en: When recording events such as failed logins, or application interactions that
    do not require a specific individual, we may still need a value for who, such
    as an originating IP address. For example, a single server ping may be harmless
    (alive service reporting is likely to just do this), but a really rapid repeated
    occurrence from the same location is not good. However, having that IP means it
    is possible to determine that it was the same system calling and therefore who
    to block.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当记录诸如失败的登录或不需要特定个人的应用程序交互等事件时，我们可能仍然需要一个“谁”的值，例如原始IP地址。例如，单个服务器的ping可能无害（活跃服务报告可能只是这样做），但来自同一位置的真正快速重复发生则不好。然而，拥有那个IP意味着可以确定是同一系统在调用，因此可以确定要阻止的对象。
- en: “Who” context in action
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: “谁”上下文的应用
- en: Working with a client’s DevOps team, we discovered the client’s security team
    employed a third-party organization to regularly run probes across all their internet-facing
    servers. We figured out what was happening, as we’d see our API gateway servers
    reporting illegal requests originating from one of several IPs on a regular frequency.
    Once we identified the pattern and the logged details like the IP origin, time,
    and the HTTP request, we raised our suspicions with the security team, who confirmed
    the use of a third party.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 与客户的DevOps团队合作，我们发现客户的安全团队雇佣了一家第三方组织定期对所有面向互联网的服务器进行探测。我们弄清楚了发生了什么，因为我们看到我们的API网关服务器定期报告来自几个IP地址的非法请求。一旦我们确定了模式和记录的详细信息，如IP来源、时间和HTTP请求，我们就向安全团队提出了怀疑，他们确认了第三方组织的使用。
- en: Don’t forget that the “who” could be a system or application component. For
    example, when processing payroll, that activity is triggered by a scheduler. So
    it is helpful to know which schedule or scheduler triggered the process.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记，“谁”可能是一个系统或应用程序组件。例如，在处理工资单时，该活动是由调度器触发的。因此，了解哪个调度器或调度器触发了该过程是有帮助的。
- en: 10.5.6 A practical checklist for capturing context
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.5.6 捕获上下文的一个实用清单
- en: 'Addressing what, when, where, why, and who can be a little abstract. Personally,
    I try to address it using the following questions:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 解决什么、何时、何地、为什么以及谁的问题可能有些抽象。我个人尝试通过以下问题来解决这个问题：
- en: Where in the code is the event coming from?
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件来自代码的哪个位置？
- en: If there is a chance that there are multiple versions of your code in production?
    If so, then which version becomes important.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的代码在生产中有多个版本的可能性？如果是这样，那么哪个版本就变得很重要。
- en: How is the transaction handled? This is especially important if the impact of
    a problem needs to be remediated in the data later.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事务是如何处理的？如果需要修复问题的数据影响，这一点尤为重要。
- en: Which server, process, or thread experienced the problem? If the issue is infrastructure-related,
    you need to know which server, virtual machine, or container it relates to.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪个服务器、进程或线程遇到了问题？如果问题是与基础设施相关的，你需要知道它关联的是哪个服务器、虚拟机或容器。
- en: Is the cause of the error identifiable (e.g., divide by zero as an error identifies
    the values involved in the error)? Can the error log be tracked back to a location
    in the code? At a minimum, express the nature of the error and, if practical,
    the data values associated (e.g., a divide by zero error—say what was being divided
    by zero and the values involved).
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误的原因是否可以识别（例如，除以零作为一个错误标识了参与错误的数据值）？错误日志能否追踪回代码中的某个位置？至少，表达错误的性质，如果可行的话，相关的数据值（例如，除以零错误——说明被除以零的内容以及相关的值）。
- en: What data values led the execution in a specific path?
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在特定路径中执行是由哪些数据值引起的？
- en: 10.6 Error codes
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.6 错误代码
- en: 'As developers, we tend to write log details with ourselves in mind. This is
    fine in a DevOps organization, where the development team also handles the ops.
    But many larger organizations may choose to operate an *Information Technology
    Infrastructure Library (ITIL**)* approach to error- and problem-management, or
    you may have a product that people are deploying in locations beyond your reach;
    we need to think further ahead. One of the important aspects of ITIL for us is
    its definition of a known error:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，我们倾向于从自己的角度来编写日志细节。在一个DevOps组织中，开发团队也处理操作，这是可以的。但许多大型组织可能会选择采用*信息技术基础设施库（ITIL**）的方法来处理错误和问题管理，或者你可能有一个人们在你无法触及的地方部署的产品；我们需要考虑得更长远一些。对我们来说，ITIL的一个重要方面是其对已知错误的定义：
- en: '*A Known Error is a problem that has a documented root cause and a Workaround.
    Known Errors are managed throughout their lifecycle by the Problem Management
    process. The details of each Known Error are recorded in a Known Error Record
    stored in a Known Error Database (KEDB). As a rule, Known Errors are identified
    by Problem Management, but Known Errors may also be suggested by other Service
    Management disciplines, e.g., Incident Management*.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*已知错误是一个有记录的根本原因和解决方案的问题。已知错误在其生命周期内通过问题管理流程进行管理。每个已知错误的详细信息都记录在已知错误记录中，这些记录存储在已知错误数据库（KEDB）中。通常，已知错误由问题管理识别，但已知错误也可能由其他服务管理学科提出，例如事件管理*。'
- en: More information can be found at [http://mng.bz/enpQ](http://mng.bz/enpQ)
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息可以在[http://mng.bz/enpQ](http://mng.bz/enpQ)找到
- en: In simple terms, an organization will keep a record of errors with resolutions.
    This is why we assign errors with error codes. An error code allows us to provide
    a simple lookup for an error that can be linked to the appropriate documentation.
    The documentation should describe the error and provide details, including a remedial
    set of actions to perform (this is essential if this involves bringing the system
    back to an optimal state without corrupting or losing data). If, of course, the
    log event is recorded and acted upon before things really go wrong, then the actions
    could be preventative in nature.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，一个组织将记录错误及其解决方案。这就是我们为什么分配错误代码的原因。错误代码允许我们提供一个简单的查找，以便将错误与适当的文档相关联。文档应描述错误并提供详细信息，包括要执行的一组补救措施（如果这涉及到将系统恢复到最佳状态而不损坏或丢失数据，这是必不可少的）。当然，如果日志事件在真正出错之前被记录并采取行动，那么这些行动可能是预防性的。
- en: The cause of the error could be either from a user action or a bug in the application
    that has been caught; either way, we should add error codes to the log information.
    It is best not to pop up error codes in a UI, as you’re likely to undermine user
    confidence in your product. But that shouldn’t stop you from linking error codes
    to messages suitable for users when a user action triggers a problem.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 错误的原因可能是用户操作或已捕获的应用程序中的错误；无论哪种情况，我们都应该在日志信息中添加错误代码。最好不要在UI中弹出错误代码，因为这可能会削弱用户对产品的信心。但这不应阻止你在用户操作触发问题时将错误代码链接到适合用户的消息。
- en: Error codes make it straightforward to enable customers to look up error codes,
    descriptions, and recommended responses to incorporate into a KEDB (Known Error
    Database). Building such error code content may seem very demanding; this can
    be far from the case. While developing the software, the simplest solution is
    to have a collaborative spreadsheet that allocates error IDs, ensuring the IDs
    are unique. Then capture the expected cause with a brief description from the
    developer. Building out resolution documentation can always follow later.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 错误代码使得客户能够轻松地查找错误代码、描述和推荐响应，以便将其纳入KEDB（已知错误数据库）。构建这样的错误代码内容可能看起来要求很高；但这远非如此。在开发软件时，最简单的解决方案是使用一个协作的电子表格来分配错误ID，确保ID是唯一的。然后，从开发人员那里获取预期的简要描述。构建解决方案文档可以稍后进行。
- en: One of the benefits of using error codes is that it becomes pretty easy to standardize
    and internationalize the documentation about the errors. The error codes are language-
    and locale-agnostic; once you have the code, you can then look up the code documentation
    in an appropriate language.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用错误代码的一个好处是，它使得错误文档的标准化和国际化变得相对容易。错误代码与语言和地区无关；一旦你有了代码，你就可以在适当的语言中查找代码文档。
- en: There are all sorts of additional tricks that you can incorporate into the software
    development processes, such as including the documentation into the code management
    tool. Hence, you release the document with the code so the details are linked
    to your release process. Code quality tooling could look for error or fatal log
    entries and apply a regular expression to see if an error code is linked to it,
    and so on.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在软件开发过程中融入各种额外的技巧，例如将文档包含到代码管理工具中。因此，你可以在代码中发布文档，以便细节与你的发布流程相关联。代码质量工具可以查找错误或致命日志条目，并应用正则表达式来查看是否有错误代码与之相关联，等等。
- en: Error code numbering
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 错误代码编号
- en: 'A few tips for creating your error code numbering:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 创建错误代码编号的一些建议：
- en: Don’t use leading zeros in the number unless prefixed with an alpha character—this
    risks getting truncated if handled numerically or creates additional work for
    formatting (e.g., number string with stipulated length and prefix character).
    Then, if that number is converted back to a string, it won’t match as a key for
    information lookup anymore.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有以字母字符为前缀，不要在数字前使用前导零——这可能会导致数字处理时被截断，或者为格式化（例如，指定长度和前缀字符的数字字符串）增加额外的工作。然后，如果将该数字转换回字符串，它将不再匹配作为信息查找的关键字。
- en: Don’t start at 1; it’s best to start with the lowest digit for the full range
    (e.g., 1000).
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要从1开始；最好从全范围的最低位开始（例如，1000）。
- en: Make the error code easy to find using search tools (e.g., 1000), as a code
    is less likely to be indexed than AppErr1000\. For example, Oracle prefixes their
    DB error codes with ORA, and WebLogic starts with BEA; thus, they’re more likely
    to be indexed and more unique in searches.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用搜索工具（例如，1000）使错误代码易于查找，因为代码不太可能被索引，而AppErr1000则更有可能被索引。例如，Oracle将它们的数据库错误代码以ORA为前缀，而WebLogic以BEA开头；因此，它们更有可能被索引，在搜索中更独特。
- en: It is tempting to simply document all the error codes within a piece of code
    (class, interface, header file, depending on your language); after all, there
    is one place to go, and documentation can be generated from the code. But this
    is not recommended. You will end up with code on which everything will become
    dependent and constantly changing while the system is being developed. Each addition
    to the error code makes a code change with an enormous dependency impact. Code
    changes with that much impact will give rise to concerns (even if they’re not
    justified) and resistance to the change.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 很有诱惑力简单地在一个代码块（类、接口、头文件，取决于你的语言）中记录所有错误代码；毕竟，有一个地方可以查找，并且可以从代码生成文档。但这是不被推荐的。你最终会得到一个所有内容都会依赖且不断变化的代码，而系统正在开发中。每个错误代码的增加都会导致代码变更，并产生巨大的依赖影响。这种影响巨大的代码变更将引发担忧（即使它们没有正当理由）并产生对变更的阻力。
- en: Better to compile the details in a shared knowledge repository, such as a wiki
    or collaborative knowledge base that everyone can maintain without consequence.
    Note that defining a local subset of errors in the code is fine—this applies the
    DRY principle. For example, error codes relating to a specific module could be
    defined together, as adding an error code is likely to go hand in hand with the
    module development.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最好在共享知识库中编译详细信息，例如维基或协作知识库，这样每个人都可以维护而无需担心。请注意，在代码中定义错误代码的本地子集是可以的——这应用了 DRY
    原则。例如，与特定模块相关的错误代码可以一起定义，因为添加错误代码很可能会与模块开发同时进行。
- en: Group error codes together into families, as seen in the HTTP RFC, but be pragmatic
    about it; an error code may logically belong in two groupings (e.g., with a DB
    connection error—is that a DB issue or a network connectivity issue?).
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将错误代码分组为家族，就像在 HTTP RFC 中看到的那样，但对此要实际；一个错误代码可能在逻辑上属于两个分组（例如，与数据库连接错误——这是数据库问题还是网络连接问题？）。
- en: This doesn’t necessarily mean reserving ranges of numbers. Still, the codes
    could be prefixed or postfixed with a shortcode to provide a scope at the product
    or subsystem level; for example, BEA-00000 and ORA-00000 denote error codes for
    two different Oracle products (WebLogic and Oracle Database).
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这并不一定意味着要预留数字范围。然而，代码可以前缀或后缀一个简短代码来在产品或子系统级别提供范围；例如，BEA-00000 和 ORA-00000 表示两个不同
    Oracle 产品（WebLogic 和 Oracle 数据库）的错误代码。
- en: If you use the same error code from different exceptions, try to differentiate
    the point of origin in the supporting information.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你从不同的异常中使用了相同的错误代码，尝试在辅助信息中区分其来源点。
- en: Consider the error code consumer; an error may come from a single location but
    have different causes, so use different error codes for the causes. This will
    make the support team’s job or remediation easier.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑错误代码的消费者；一个错误可能来自单一位置，但有不同的原因，因此为原因使用不同的错误代码。这将使支持团队的工作或修复变得更加容易。
- en: 10.6.1 Using standard errors
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.6.1 使用标准错误
- en: Some technologies provide codes to indicate success and errors, which have been
    well documented, such as those for HTTP (RFC [https://tools.ietf.org/html/rfc7231#section-6](https://tools.ietf.org/html/rfc7231#section-6));
    others include SMTP (email services), Oracle WebLogic Server, and so on. Using
    such codes in our logs helps provide more context through a common meaning and
    understanding as long as they are used correctly. For example, the temptation
    to simply do everything through the standard HTTP 200 or 400 codes doesn’t help.
    Using an HTTP 413 code to tell the requester they sent too much data is far more
    effective and meaningful, not to mention that this will show up in the logs for
    any network routing devices.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一些技术提供代码来表示成功和错误，这些代码已经得到了很好的记录，例如 HTTP（RFC [https://tools.ietf.org/html/rfc7231#section-6](https://tools.ietf.org/html/rfc7231#section-6)）；其他包括
    SMTP（电子邮件服务）、Oracle WebLogic 服务器等。在我们的日志中使用这些代码有助于通过共同的意义和理解提供更多上下文，只要它们被正确使用。例如，简单地使用标准
    HTTP 200 或 400 代码的做法并不帮助。使用 HTTP 413 代码告诉请求者他们发送了过多的数据要有效得多，更有意义，而且这还会在日志中显示任何网络路由设备。
- en: The use of predefined error codes does need to be judged with care, as exception
    classes in software can be considered a special form of error code. But, as we’ll
    see later in the chapter, these circumstances could lead to a loss of clarity.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 预定义错误代码的使用确实需要谨慎判断，因为软件中的异常类可以被视为错误代码的特殊形式。但是，正如我们将在本章后面看到的，这些情况可能导致清晰度下降。
- en: 10.6.2 Codes can be for more than errors
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.6.2 代码不仅可以用于错误
- en: Error codes are the most important messages to be uniquely identifiable. The
    principle of associating codes to documentation for operational processes (rather
    than user ones) means that you can hook the event back to specific operational
    recommendations that could range from performing database optimization processes
    to archiving log files.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 错误代码是最重要的唯一可识别的消息。将代码与操作流程文档（而不是用户流程）关联的原则意味着你可以将事件回溯到特定的操作建议，这些建议可能包括执行数据库优化过程到存档日志文件。
- en: 10.7 Too little logging or too much?
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.7 过少记录或过多记录？
- en: 'What to put into a log can be tricky. It is easy to dump whole data structures/objects
    into a logging event on the off chance that it is all relevant. This approach
    raises two challenges:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 将什么内容放入日志可能会很棘手。有时很容易将整个数据结构/对象整个放入日志事件中，假设它都是相关的。这种方法提出了两个挑战：
- en: The volume of data being logged could become very substantial as a result, excessively
    increasing the computational and storage workload.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，记录的数据量可能会变得非常大，过度增加计算和存储的工作量。
- en: The chances are that you may end up logging sensitive details.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 很可能你最终会记录敏感细节。
- en: When it comes to the point of taking too much effort to process logs, there
    is nothing to stop the code from applying conditional controls, so when we need
    a lot of information, we can get it. What is worse—configuration controlling the
    information logged or modifying code to get enough information? The bottom line
    is tuning log framework configurations to avoid over-chatty logs is preferable
    to modifying code, if for no other reason than that the change cycle will most
    likely be quicker for a configuration file. Software change governance controls
    will likely demand greater diligence in the release, slowing the task that the
    log files will be supporting.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理日志需要付出过多努力时，代码应用条件控制并没有什么可以阻止的，因此当我们需要大量信息时，我们可以获取到。更糟糕的是——是配置控制记录的信息还是修改代码以获取足够的信息？底线是调整日志框架配置以避免过多的日志输出，这比修改代码更可取，至少从配置文件变更周期可能更快这一点来看是这样的。软件变更治理控制可能会在发布时要求更高的谨慎，从而减慢日志文件将支持的任务。
- en: The problem is that logging whole data structures can result in the logs incorporating
    sensitive data, such as personal or credit card data, both of which have strict
    rules about protecting anything that contains this kind of data. The important
    thing is to provide enough context in the log without writing to log any sensitive
    data. If the event is logged early into secure storage, such as a database, we
    have the possibility of attributing an ID to that event. Then the rest of the
    logs can be implemented by logging the recorded event ID. If necessary, this allows
    you to go back to the data context without the values being spread across logs.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于记录整个数据结构可能导致日志包含敏感数据，如个人或信用卡数据，这两者都有严格的规则来保护包含此类数据的任何内容。重要的是在日志中提供足够的信息上下文，而不写入任何敏感数据。如果事件被记录到安全的存储中，例如数据库，我们就有可能为该事件分配一个ID。然后，其余的日志可以通过记录记录的事件ID来实现。如果需要，这允许你在不分散日志值的情况下回到数据上下文。
- en: Part of this problem extends beyond just how we write application logging to
    the design of our solutions. The best illustration of this is the handling of
    HTTP calls. Before the HTTP calls reach our application server, the HTTP traffic
    will pass through firewalls, load balancers, proxies, network routers, and other
    infrastructure elements when we’re implementing a web application. Even if you
    have the best HTTPS configuration ever, header information must be readable to
    route the traffic to its destination. Typically, these components will log the
    URIs and often all of the HTTP headers. The headers may contain details about
    handling the request and response (e.g., headers contain attributes instructing
    infrastructure as to whether content can be cached). The net result is that if
    you put sensitive values into payload URIs or headers, the sensitive information
    may accidentally end up being logged.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分问题不仅涉及到我们如何编写应用程序日志，还涉及到我们解决方案的设计。最好的例子是处理HTTP调用。在我们实施Web应用程序时，在HTTP调用到达我们的应用服务器之前，HTTP流量将穿过防火墙、负载均衡器、代理、网络路由器和其他基础设施元素。即使你有史上最好的HTTPS配置，头部信息也必须可读，以便将流量路由到目的地。通常，这些组件会记录URI和通常所有的HTTP头部。头部可能包含有关处理请求和响应的详细信息（例如，头部包含指示基础设施是否可以缓存内容的属性）。最终结果是，如果你将敏感值放入有效载荷URI或头部，敏感信息可能会意外地被记录。
- en: If you have a local log file capturing sensitive data and there is no means
    to rectify the code, we need to contain the issues this can create. An approach
    to this is to use Fluentd to process the log events with some logic to strip out
    the sensitive data. Implementing this kind of logic before sending the logs on
    or simply writing the logs to a separate local file can help contain the impact
    (some might say the “blast radius” of sensitive data being logged). This strategy
    can be further helped by configuring the application’s logging so that it is as
    short-lived as possible, and the original logs are never backed up or copied anywhere.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个捕获敏感数据的本地日志文件，并且没有修复代码的方法，我们需要控制由此产生的问题。一种方法是使用Fluentd通过一些逻辑处理日志事件，以去除敏感数据。在将日志发送到或简单地写入单独的本地文件之前实施这种逻辑可以帮助控制影响（有些人可能会说是敏感数据被记录的“爆炸半径”）。通过配置应用程序的日志，使其尽可能短暂，并且原始日志永远不会备份或复制到任何地方，这种策略可以得到进一步的帮助。
- en: 10.7.1 What qualifies as sensitive?
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.7.1 什么算是敏感信息？
- en: 'Deciding what data is sensitive can be tricky, as it can be driven by a multitude
    of factors:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 决定什么数据是敏感的可能会很棘手，因为它可能由许多因素驱动：
- en: Business valuation of data
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据的商业估值
- en: Legislative demands
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 立法要求
- en: Consequences of information becoming available in the public domain
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信息公开领域的后果
- en: Many of the complexities come from the patchwork of legislation, not only internationally
    but also within nations. For example, in Europe, all the countries have ratified
    *GDPR* (*General Data Protection Regulation*), and a growing list of countries
    have adopted similar legislation (e.g., Australia). But within the EU, some countries
    have additional legislation, so compliance to just GDPR may be insufficient. In
    the United States, controls are both federal and state-driven, with California
    having taken the lead and adopted GDPR-like legislation, but not all states have
    followed this.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 许多复杂性来自立法的拼凑，不仅在国际上，而且在各国国内。例如，在欧洲，所有国家都批准了*GDPR*（通用数据保护条例），越来越多的国家采用了类似的立法（例如，澳大利亚）。但在欧盟内部，一些国家有额外的立法，因此仅遵守GDPR可能是不够的。在美国，控制措施既有联邦的也有州驱动的，加利福尼亚州领先并采用了类似GDPR的立法，但并非所有州都效仿。
- en: 'Given that GDPR appears to be the starting point for many, it’s worth examining
    what it seeks to achieve and what impact it can have. The central principles are
    the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 由于GDPR似乎是许多人的起点，因此值得探讨它试图实现的目标以及它可能产生的影响。核心原则如下：
- en: Principle of lawfulness, fairness, and transparency
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合法性、公平性和透明度原则
- en: Principle of purpose limitation
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目的限定原则
- en: Principle of data minimization
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据最小化原则
- en: Principle of accuracy
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准确性原则
- en: Principle of storage limitation
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 储存限制原则
- en: Principle of integrity and confidentiality
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完整性和保密性原则
- en: Principle of accountability
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 责任原则
- en: 'These principles cascade down to several entitlements for those we retain data
    about:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这些原则向下延伸，为那些我们保留数据的人赋予了几项权利：
- en: Individuals are entitled to know why their personal data is held and what it
    will be used for.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 个人有权知道为什么保留他们的个人数据以及这些数据将用于什么目的。
- en: Individuals are entitled to ask for the information that is stored about them.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 个人有权要求获取关于他们的存储信息。
- en: Individuals can require the correction of any inaccuracies in the data.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 个人可以要求更正数据中的任何不准确之处。
- en: Individuals can exercise a right to “be forgotten,” which will mean all data
    is erased.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 个人可以行使“被遗忘”的权利，这意味着所有数据都将被删除。
- en: Individuals can ask for their personal data to be restricted in its use.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 个人可以要求限制其个人数据的用途。
- en: 'In addition to this, organizations must be able to justify their actions to
    the body responsible for overseeing GDPR compliance (the *Information Commissioner’s
    Office* in the UK); for example:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，组织必须能够向负责监督GDPR合规性的机构（例如，英国的*信息专员办公室*）证明其行动的合理性；例如：
- en: How long data is stored.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据存储的时间长度。
- en: Demonstrate that actions that ensure integrity and confidentiality are taken.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 证明采取了确保完整性和保密性的行动。
- en: As you can see, this has some far-reaching implications. For example, if your
    system is processing payroll data, then when the data regarding someone’s pay
    was logged, the log file would become subject to a large number of security requirements.
    If this was your own personal data, you’d want it to be treated just as securely
    as the copy in the application. In some countries, there is a legal right to be
    forgotten (i.e., have all records of an individual removed from all systems).
    This would not only create tasks to remove the data from the applications—the
    easy bit—but it could also extend to having to locate and delete log entries for
    an individual from any server that could have executed the processing, along with
    backups, and so on. Just finding such details alone would be very time-consuming.
    This is in addition to the requirements of addressing the need to make sure log
    files are secured and that access to log files is defensible.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这有一些深远的影响。例如，如果您的系统正在处理工资数据，那么当涉及某人工资的数据被记录时，日志文件就会成为大量安全要求的对象。如果这是您自己的个人数据，您希望它得到与应用程序中副本相同的安全处理。在一些国家，有法律权利被遗忘（即，从所有系统中删除个人的所有记录）。这不仅会创建从应用程序中删除数据的任务——这是容易的部分——而且可能还需要定位和删除任何可能执行处理的服务器上的个人日志条目，以及备份等。仅找到这样的细节本身就非常耗时。这还包括确保日志文件安全以及确保对日志文件访问可防御的要求。
- en: All of this leads to the argument that while log data is important for problem
    diagnosis, audit, and so on, we need to minimize the sensitive data put into the
    logs wherever possible. Control the logged data, and we eliminate those logs from
    needing to comply with all the rules.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些导致了一个论点：虽然日志数据对于问题诊断、审计等等很重要，但我们应尽可能减少放入日志中的敏感数据。控制已记录的数据，我们就可以消除这些日志需要遵守所有规则的需求。
- en: If sensitive data is needed to be kept, then keep it separate if you can. When
    you can’t keep it separate, don’t use staging logs between the log data source,
    and secure the final destination. In terms of Fluentd, this means securing the
    “data in-flight” by using the forward plugin configured in a secure manner (e.g.,
    implement TLS, control access to keys and certificates). If the data is stored
    in temporary or staging files, then the setup for the security of the staging
    files (“data at rest”) is a lot more involved. This would cover things like access
    controls for the file system, applying appropriate encryption of the files, and
    all the work of creating and managing the encryption keys. The potential challenge
    could go as far as needing to put in place formal processes to manage the disposal
    of the physical drives storing the data, even if it was temporary. Don’t forget
    that this would also apply to files created when a file-based buffer is being
    used.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要保留敏感数据，那么如果可能的话，请将其单独保存。当您无法将其单独保存时，不要在日志数据源之间使用临时日志，并确保最终目的地安全。在Fluentd方面，这意味着通过以安全方式配置的前向插件来确保“数据在传输中”的安全（例如，实施TLS，控制密钥和证书的访问）。如果数据存储在临时或临时文件中，那么为临时文件的安全设置（“数据静止”）就更加复杂。这包括诸如文件系统的访问控制、对文件应用适当的加密以及创建和管理加密密钥的所有工作。潜在的挑战可能包括需要实施正式流程来管理存储数据的物理驱动器的处置，即使它是临时的。别忘了，这也适用于在文件缓冲区使用时创建的文件。
- en: Going back to the ideas of log analytics and log unification, the underlying
    principle is to log sensitive data only when it is necessary, and only keep it
    in locations that are adequately secured. Minimize the number of “touch” points
    in the log events transmission. Treat logs just as you treat the actual data.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 回到日志分析和日志统一的思想，其基本原理是在必要时才记录敏感数据，并且只将其保存在足够安全的位置。最小化日志事件传输中的“接触”点。对待日志就像对待实际数据一样。
- en: NOTE A global view on data protection law can be freely viewed from global law
    firm DLA Piper ([www.dlapiperdataprotection.com](http://www.dlapiperdataprotection.com)).
    Appendix E contains several links to resources to help jump-start finding what
    legislation might impact your logs (or application, for that matter).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：可以从全球律师事务所DLA Piper（[www.dlapiperdataprotection.com](http://www.dlapiperdataprotection.com)）免费查看关于数据保护法的全球视角。附录E包含多个链接，可以帮助您快速找到可能影响您日志（或应用程序）的立法。
- en: 10.7.2 GDPR is only the start
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.7.2 GDPR只是开始
- en: National legislation isn’t always about where data is being processed or the
    nationality of the company or citizen the data represents. It can come from other
    sources; another well-known origin of security requirements is Payment Card Industry
    (PCI) Data Security Standards (DSS). PCI is focused on the handling of payment
    cards such as credit cards. The level of security required is based upon the total
    value of transactions handled, with specific, detailed requirements that cover
    infrastructure, software, and operational processes. If card data gets captured
    in a log, there is no doubt that the logs will need to comply with PCI rules.
    Like personal data, the rules also apply to the hardware on which the logs reside,
    the applications that process the logs, and the visibility of log information
    to users (i.e., developers and operations).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 国家立法并不总是关于数据处理的地点或数据代表的公司或公民的国籍。它可能来自其他来源；另一个众所周知的安全要求来源是支付卡行业（PCI）数据安全标准（DSS）。PCI专注于处理支付卡，如信用卡。所需的安全级别基于处理的交易总额，有具体、详细的要求，涵盖基础设施、软件和运营流程。如果卡数据被记录在日志中，毫无疑问，日志将需要遵守PCI规则。像个人数据一样，这些规则也适用于存储日志的硬件、处理日志的应用程序以及日志信息对用户的可见性（即开发人员和运维人员）。
- en: 'Many organizations have taken steps to define sensitive data and statements
    of what they consider to be acceptable use (part of compliance). This is a good
    port of call for specific environments. Where a service is provided, the terms
    and conditions may also determine what is deemed sensitive. But as a rule of thumb,
    the following is considered sensitive:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 许多组织已经采取措施来定义敏感数据以及他们认为可接受的使用的声明（合规性的一部分）。这对于特定环境来说是一个很好的参考点。在提供服务的地方，服务条款和条件也可能决定什么被认为是敏感的。但作为一个经验法则，以下被认为是敏感的：
- en: Any data that makes an individual uniquely identifiable, such as personal addresses
    or social security numbers (aka *personally identifiable information*, or *PII*).
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何使个人唯一可识别的数据，例如个人地址或社会保障号码（即*个人可识别信息*，或*PII*）。
- en: Any data that could have a financial impact on an organization or individual,
    as the information leaking could do serious harm. This covers data such as charge
    and credit cards, bank accounts, and fiscal reporting (such information becoming
    known early could result in insider trading on stock exchange–listed companies).
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何可能对组织或个人产生财务影响的数据，因为信息泄露可能会造成严重损害。这包括诸如收费和信用卡、银行账户和财务报告（此类信息提前泄露可能导致在证券交易所上市公司的内部交易）等数据。
- en: Any clinical data relating to an individual.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何与个人相关的临床数据。
- en: So far, we have looked at logs from the viewpoint of trying to minimize their
    security impact. Logs, when well defined and managed, can contribute to showing
    compliance to commercial and legislative requirements—for example, logs recording
    who accessed information and when, and, probably more importantly, when access
    was rejected. This information can be used to demonstrate correct controls and
    can be made operationally actionable.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已从试图最小化其安全影响的角度来查看日志。当日志得到良好定义和管理时，可以有助于证明符合商业和法律要求——例如，记录谁何时访问了信息，以及，可能更重要的是，何时拒绝了访问。这些信息可用于证明正确的控制措施，并且可以使其具有操作上的可执行性。
- en: 'To illustrate the point, the following are just a few examples of other legislation
    or standards where the use of log events can provide an audit trail to address
    aspects of compliance to legislative requirements:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，以下是一些其他立法或标准的例子，其中日志事件的用途可以提供审计轨迹以解决对立法要求的合规性问题：
- en: Sarbanes Oxley Act (SOX) ([http://mng.bz/Bxl8](http://mng.bz/Bxl8)) and variants
    such as J-SOX (Japan), C-SOX (Canada), and TC-SOX (Turkey).
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 萨班斯-奥克斯利法案（SOX）([http://mng.bz/Bxl8](http://mng.bz/Bxl8))及其变体，如J-SOX（日本）、C-SOX（加拿大）和TC-SOX（土耳其）。
- en: Health Insurance Portability and Accountability Act (HIPAA) ([www.hhs.gov/hipaa/index.html](http://www.hhs.gov/hipaa/index.html)).
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 健康保险可携带性和问责法案（HIPAA）([www.hhs.gov/hipaa/index.html](http://www.hhs.gov/hipaa/index.html))。
- en: ISO/IEC 27001\. While not a legislative-driven set of rules, this is a best-practice
    set of standards that can be certified ([www.iso.org/isoiec-27001-information-security.html](http://www.iso.org/isoiec-27001-information-security.html)).
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ISO/IEC 27001。虽然这不是由立法驱动的规则集，但这是一套最佳实践标准，可以认证([www.iso.org/isoiec-27001-information-security.html](http://www.iso.org/isoiec-27001-information-security.html))。
- en: 'Data risks: An analogy'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 数据风险：一个类比
- en: The risks around handling sensitive data are a little abstract, so let’s look
    at an analogy. Think of it as venomous; how sensitive the data is reflects how
    dangerous the venom is. If you like to visualize it, consider a nonvenomous snake
    as a low-risk data item, and very sensitive data like government IDs as jellyfish.
    Yet, with the right equipment, environment, and expertise, the risk of a bite
    or sting is small. A nonvenomous snake bite may be painful and possibly a source
    of infection if left untreated; more venomous stings or bites are serious, but
    if you are prepared and have the antivenin, you’ll survive if treated quickly.
    The problem is not just how venomous the data is; it’s how much venom (how many
    bites or stings) there is—in other words, the amount of data. We can limit the
    amount and the sensitivity of data being handled in log files; the lower the risk,
    the simpler the necessary precautions.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 处理敏感数据的风险有点抽象，所以让我们看看一个类比。想象它是有毒的；数据有多敏感反映了毒液有多危险。如果你喜欢可视化，考虑一个无毒蛇作为低风险数据项，而非常敏感的数据，如政府身份证，就像水母。然而，有了合适的设备、环境和专业知识，被咬或蛰的风险很小。无毒蛇的咬伤可能很痛苦，如果未得到治疗，可能成为感染源；更有毒的蛰或咬伤是严重的，但如果准备充分并且有抗毒血清，你会在及时治疗下存活。问题不仅仅是数据有多有毒；而是有多少毒液（有多少咬或蛰）——换句话说，数据的数量。我们可以限制日志文件中处理的数据的数量和敏感性；风险越低，必要的预防措施就越简单。
- en: 10.8 Log structure and format
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.8 日志结构和格式
- en: By applying structure to the messages, it is possible to make the information
    more actionable because the logic processing the logs can derive meaning from
    the data. Suppose we experienced an error with a database connection, which produced
    a structured log event. It wouldn’t be hard to implement a parser expression to
    retrieve the database connector error code and the database details. This could
    be done by Fluentd, and therefore a signal could be sent to the relevant database
    team. The log analytics tool could act on the same data, but the alert would be
    later, and more problems could have occurred. But the log analytics could help
    us by examining histories to determine if the problem was reoccurring, and, if
    so, at what frequency and if there was a commonality to the nodes(s) registering
    the problem.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对消息应用结构，可以使信息更具可操作性，因为处理日志的逻辑可以从数据中提取意义。假设我们遇到了数据库连接错误，这产生了结构化的日志事件。实现一个解析表达式来检索数据库连接器错误代码和数据库详细信息并不困难。这可以通过Fluentd完成，因此可以向相关的数据库团队发送信号。日志分析工具可以对相同的数据采取行动，但警报会晚些时候发出，可能已经发生了更多问题。但是，日志分析可以通过检查历史记录来确定问题是否重复发生，如果是的话，频率是多少，以及是否有注册问题的节点（s）的共性。
- en: The structuring of logs goes further than that, as we need to also have a structure
    around details such as timestamps, log levels, location, thread IDs, and so on,
    that help provide context. There are some industry-recognized formats. Figure
    10.3 provides details of ones typically associated with application logic.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 日志的结构化不仅限于此，我们还需要在时间戳、日志级别、位置、线程ID等细节周围有一个结构，这些细节有助于提供上下文。有一些行业公认的格式。图10.3提供了与应用逻辑通常相关的一些格式的详细信息。
- en: '![](../Images/CH10_F03_Wilkins.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F03_Wilkins.png)'
- en: Figure 10.3 The aspects that, when combined, will provide excellent log events
    and robust mechanisms to use them as necessary
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 当结合使用时，将提供优秀的日志事件和强大的机制，以便在必要时使用
- en: 10.8.1 Putting making log entries ready for application shipping into action
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.8.1 将制作日志条目以准备应用程序发布投入实际应用
- en: As part of a development team, your server-based application reaches the point
    of being sufficiently well featured. The beta and early adopter customers are
    successfully using your software. The management team recognizes that to provide
    cost-effective support, documentation needs to be provided to avoid frustrated
    system administrators and unnecessary support calls. Also, good support documentation
    will help prevent support requests from coming back to the development team. You’ve
    been asked to identify what needs to be achieved and how long it is likely to
    take to implement, as well as if there is anything that can be done to minimize
    the time before sales can ramp up activities.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发团队的一部分，你的基于服务器的应用程序已经具备了足够的特性。Beta测试和早期采用者客户正在成功使用你的软件。管理层认识到，为了提供成本效益的支持，需要提供文档以避免系统管理员感到沮丧和不必要的支持电话。此外，良好的支持文档将有助于防止支持请求返回到开发团队。你被要求确定需要实现什么，以及实施所需的时间，以及是否可以采取措施来最小化销售活动启动前的等待时间。
- en: Answer
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 答案
- en: There are a great many things that could be done, and there is no single correct
    answer, except to build on what this chapter has discussed. When estimating such
    a task, the simplest thing is to search the currently active code base for log
    events and record the type of event. Then estimate the effort to evaluate the
    log events against the different factors illustrated in figure 10.3\. Being pragmatic,
    if the estimates are squeezed, it is best to adopt a top-down approach (see figure
    10.2.)
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多事情可以做，没有单一的正确答案，除了在本章讨论的基础上进行构建。在估计这样的任务时，最简单的事情是搜索当前活动的代码库中的日志事件，并记录事件类型。然后估计评估日志事件与图10.3中所示的不同因素的努力。务实地说，如果估计被压缩，最好是采用自上而下的方法（见图10.2）。
- en: With the estimated effort of working through the code checking and amending
    the log events, you also need to estimate the effort to produce the supporting
    documentation. If you provide the documentation through channels such as a website
    rather than embedding it in the code, the software release can start before this
    documentation is complete. Obviously, there is a temptation to not complete this
    task and focus on the following product version with this approach. Conversely,
    not addressing this will directly impact the number of support calls, including
    those that get escalated back to the developers, even in a more traditional organizational
    arrangement.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理代码检查和修改日志事件所估计的努力之外，你还需要估计生成支持文档的努力。如果你通过网站等渠道提供文档，而不是将其嵌入到代码中，那么在文档完成之前，软件发布就可以开始了。显然，有一种诱惑是不完成这项任务，而是专注于下一个产品版本。相反，不解决这个问题将直接影响到支持电话的数量，包括那些被升级回开发者的电话，即使在更传统的组织安排中也是如此。
- en: 10.9 Use frameworks if you can
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.9 如果可能，请使用框架
- en: 'Most programming languages provide logging frameworks, either as part of the
    base language or as libraries (we will explain these in more depth in chapter
    11). Adopting a framework for logging can help in several ways to improve your
    logging. Potential benefits include the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言都提供日志框架，要么作为基础语言的一部分，要么作为库（我们将在第11章中更深入地解释这些）。采用日志框架可以帮助以多种方式改进你的日志。潜在的好处包括以下内容：
- en: Consistency in the log data.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志数据的统一性。
- en: Consistency in log levels
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志级别的统一性
- en: Structure of log entries
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志条目的结构
- en: Additional contextual information managed for you (e.g., if the framework understands
    OpenTracing, it can pull trace context values).
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为你管理的附加上下文信息（例如，如果框架理解OpenTracing，它可以拉取跟踪上下文值）。
- en: The framework can allow us to control what is looked at through configuration,
    making it easier to determine how much or how little logging is needed.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架可以让我们通过配置来控制查看的内容，这使得确定需要多少或多少日志变得更加容易。
- en: Importantly, when logging in a containerized environment, we can save a lot
    of effort if we don’t have to reparse text outputs to apply context and meaning.
    This saves processing power, and many log frameworks allow us to direct output
    mechanisms that can help avoid this overhead.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重要的是，在容器化环境中登录时，如果我们不需要重新解析文本输出以应用上下文和意义，我们可以节省大量的努力。这节省了处理能力，许多日志框架允许我们直接输出机制，从而有助于避免这种开销。
- en: Using one of the many third-party or language native solutions is preferable,
    as they will be tried and true. Even a simplified piece of your own code that
    helps drive consistency is valuable. The mission-critical systems I started my
    career working on fell into this category. If you go down the route of using Homebrew,
    we would strongly recommend adopting one of the industry-standard formats to make
    ingestion into other tools a lot easier.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 使用许多第三方或语言原生解决方案之一是首选的，因为它们已被验证并证明有效。即使是帮助你驱动一致性的简化代码片段也是很有价值的。我在职业生涯开始时工作的关键任务系统就属于这一类别。如果你选择使用Homebrew，我们强烈建议采用行业标准格式，以便更容易地将数据导入其他工具。
- en: 10.10 Development practices
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.10 开发实践
- en: We’ve seen a number of things we can do to positively improve the situation.
    But there are some common development practices that can be negative in nature,
    even if the intent is presented positively.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一些可以积极改善情况的方法。但是，有些常见的开发实践在本质上可能是负面的，即使意图是积极表达的。
- en: 10.10.1 Rethrowing exceptions
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.10.1 重新抛出异常
- en: Catching and rethrowing exceptions (the act of having a catch block in code
    and then using throw statements to raise the exception again) is a bad practice
    that can have undesirable impacts on logs, given that typically, when an exception
    is caught, it is logged. This means if you catch and rethrow an exception, the
    odds are you’ll end up with multiple log events for the same problem. When it
    comes to analyzing what is wrong, you’ve increased the workload for determining
    which log event was the first actual occurrence of a problem and have doubled
    up on the number of alerts, moving another step closer to a “notification storm.”
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获并重新抛出异常（在代码中拥有捕获块并使用throw语句再次引发异常的行为）是一种不良实践，可能会对日志产生不希望的影响，因为通常情况下，当捕获到异常时，它会被记录。这意味着如果你捕获并重新抛出异常，你很可能会为同一个问题产生多个日志事件。当分析问题所在时，你增加了确定哪个日志事件是问题首次实际发生的负担，并且增加了警报的数量，这使你更接近于“通知风暴”。
- en: Notification or alert storms
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 通知或警报风暴
- en: Notification or alert storms are something to watch out for if you link your
    log events to a notification mechanism such as email or Slack. If you keep getting
    the same error, such as when logic keeps getting stuck in an infinite loop of
    trying to do something (e.g., writing to a file with no storage space available),
    then you end up with the same message saturating the notification channel. The
    net result is that everyone switches off and unsubscribes to notifications; worse
    still, systems think your application generates spam and it gets blocked. Fortunately,
    there are techniques for suppressing such scenarios, such as filters in Fluentd
    ([http://mng.bz/OG6E](http://mng.bz/OG6E)) or in the logging framework itself.
    For example, Log4j2 provides a BurstFilter ([http://mng.bz/YgKA](http://mng.bz/YgKA)),
    and Log4Net has an extension that does the same sort of thing ([http://mng.bz/GG1O](http://mng.bz/GG1O))
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将日志事件链接到通知机制，如电子邮件或Slack，那么通知或警报风暴是需要警惕的。如果你不断收到相同的错误，例如当逻辑陷入无限循环中尝试做某事（例如，尝试向没有存储空间的文件写入），那么你最终会在通知渠道中饱和相同的消息。最终结果是每个人都关闭并取消订阅通知；更糟糕的是，系统认为你的应用程序生成垃圾邮件，并将其阻止。幸运的是，有一些技术可以抑制此类场景，例如Fluentd中的过滤器([http://mng.bz/OG6E](http://mng.bz/OG6E))或日志框架本身。例如，Log4j2提供了一个BurstFilter([http://mng.bz/YgKA](http://mng.bz/YgKA))，而Log4Net有一个扩展，可以执行类似的功能([http://mng.bz/GG1O](http://mng.bz/GG1O))。
- en: 10.10.2 Using standard exceptions and error structures
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.10.2 使用标准异常和错误结构
- en: My position on using standard exceptions from programming languages is possibly
    a more contentious point, as I don’t agree entirely with the assertion that standard
    exceptions should be thrown. For example, Joshua Bloch’s *Effective Java* (Addison-Wesley
    Professional; 3rd edition, 2017) advocates that if you have defensive code, and
    a value you receive is null (nil in Ruby) but shouldn’t be, then your code should
    use the language’s own `NullPointerException` or `IllegalArgumentException`. The
    argument made is that you can benefit from code reuse and that someone reading
    your API will understand the API more easily. While the reuse consideration may
    have merit, using a language-predefined exception class because it will lend to
    the understandable definition is about good naming conventions, not insight into
    the code.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我对使用编程语言的标准异常的看法可能是一个更有争议的点，因为我并不完全同意标准异常应该被抛出的说法。例如，Joshua Bloch的《Effective
    Java》（Addison-Wesley Professional；第3版，2017年）提倡，如果你有防御性代码，并且你接收到的值是null（在Ruby中是nil）但不应该是，那么你的代码应该使用语言自己的`NullPointerException`或`IllegalArgumentException`。提出的论点是你可以从代码重用中受益，而且阅读你的API的人会更容易理解API。虽然重用考虑可能有其价值，但使用语言预定义的异常类，因为它将有助于可理解的定义，这更多是关于良好的命名约定，而不是对代码的洞察。
- en: The real problems come when looking at log events; it becomes tough to determine
    whether this exception resulted from defensive coding or a potential bug. The
    difference is that defensive coding points to a possible upstream issue. If someone
    has put in defensive checks, then the chances are someone considered the possibility
    of a problem and how to leave things in a recoverable state.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的问题出现在查看日志事件时；很难确定这个异常是由于防御性编码还是潜在的bug导致的。区别在于防御性编码指向一个可能的上游问题。如果有人添加了防御性检查，那么很可能有人考虑了可能出现的问题以及如何使事物处于可恢复状态。
- en: While my example and reference to best practice have focused on Java, the foundation
    principles apply to languages that support exception frameworks, Python and Ruby
    being two examples. Other languages, like Go, have error structures and the ability
    to handle the return of different structure types. So the question begs, what
    is the answer to this?
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我的例子和最佳实践的引用主要集中在Java上，但基础原则适用于支持异常框架的语言，Python和Ruby是两个例子。其他语言，如Go，有错误结构和处理不同结构类型返回的能力。所以，这个问题亟待解决，答案是什么？
- en: Going back to Java for a moment, from my perspective, there is nothing wrong
    with creating a simple one-line class that extends a base class with a clear,
    meaningful name (e.g., `class IllegalBufferConfigurationException extends IllegalArgumentException`).
    After all, this is how languages apply inheritance for the native exceptions in
    Java (e.g., `NullPointerException` extends class `Exception`). Ruby’s approximate
    match is `ArgumentError`, which extends `StandardError`, which in turn extends
    `Exception`. If an exception is well named, it will be clear as to why the exception
    is thrown. It also will tell the reader what specific scenarios are being defended
    against and what the API caller should or should not be doing. So when we see
    a generic exception, like a `NullPointerException`, we’re likely to be looking
    at a more fundamental problem and one that has not been considered. If we have
    considered a problem, we probably know what the remediation might be.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 回到Java，从我的角度来看，创建一个简单的单行类，该类扩展了一个具有清晰、有意义的名称的基础类（例如，`class IllegalBufferConfigurationException
    extends IllegalArgumentException`）并没有什么问题。毕竟，这就是语言如何应用继承来处理Java中的原生异常（例如，`NullPointerException`扩展了`Exception`类）。Ruby的大致对应物是`ArgumentError`，它扩展了`StandardError`，而`StandardError`又扩展了`Exception`。如果一个异常名称很好，那么它将清楚地说明为什么抛出异常。它还会告诉读者正在防御的具体场景以及API调用者应该或不应该做什么。所以当我们看到像`NullPointerException`这样的通用异常时，我们很可能会看到一个更基本的问题，一个尚未考虑过的问题。如果我们已经考虑了一个问题，我们可能知道补救措施可能是什么。
- en: 10.10.3 String construction as a reason not to log
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.10.3 字符串构造作为不记录日志的理由
- en: When logging, we sometimes need to construct a log message by combining several
    elements to produce a practical level of information. Casting data to strings
    and concatenating them together takes a little bit of CPU effort. Let’s assume
    for a moment that we’re creating an info-level log message, so there is a chance
    the log message will get filtered out if someone has set the log filter threshold
    to a warning. In this situation, the CPU effort constructing the log message is
    effectively wasted. This has been used as an argument for not bothering implementing
    logging in the code since the log message construction consumes processing effort
    for no gain.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在日志记录时，我们有时需要通过组合几个元素来构建日志消息，以产生实用的信息级别。将数据转换为字符串并将它们连接起来需要一点 CPU 努力时间。让我们假设一下，我们正在创建一个
    info 级别的日志消息，因此如果有人将日志过滤器阈值设置为警告，那么日志消息可能会被过滤掉。在这种情况下，构建日志消息的 CPU 努力实际上是浪费的。这已经被用作不费心在代码中实现日志记录的论据，因为日志消息的构建消耗了处理努力而没有获得任何收益。
- en: This argument attempts to rationalize not investing in evaluating where logging
    will help implement appropriate code, at least from my perspective. There are
    technical means by which we can minimize the cost. But perhaps, more importantly,
    the cost of a small number of CPU cycles compared to the cost of a developer’s
    time trying to investigate and understand what is going on with someone else’s
    code does weigh in favor of helping the developer. I’m not advocating writing
    grossly inefficient code. Still, the extra costs in compute cycles for having
    supportable and maintainable code (which includes sensible logging) are far smaller
    than the money saved in developer effort.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这个论点试图从我的角度来看合理化不投资评估日志将如何帮助实现适当的代码。我们有技术手段可以最小化成本。但也许更重要的是，与开发者尝试调查和理解他人代码的成本相比，少量
    CPU 循环的成本确实有利于帮助开发者。我并不是提倡编写效率低下的代码。然而，为了支持性和可维护的代码（包括合理的日志记录）而增加的计算周期成本远远小于节省的开发者努力成本。
- en: 'Coming back to the practical technical means to avoid waste, every logging
    framework I know of provides the means to query the logging level currently set,
    allowing the code to decide whether there is any value in constructing the logging
    payload. These are sometimes referred to as “guard” functions and can be applied
    like this:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 回到实际的技术手段以避免浪费，我所知道的每个日志框架都提供了查询当前设置的日志级别的手段，允许代码决定是否构建日志负载有任何价值。这些有时被称为“守卫”函数，可以像这样应用：
- en: '[PRE0]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Obviously, the precise code will differ based on the framework in use and the
    language-specific syntax, but you see the point.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，精确的代码将根据所使用的框架和特定语言的语法而有所不同，但您应该明白这个要点。
- en: 'Over the last 5 to 10 years, we have seen most mainstream languages develop
    to support Lambda or lazy execution capabilities. This means we can now write
    code, so the guard is implicit and if the implicit condition resolves, only then
    are the subsequent expressions evaluated and executed. For example:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去 5 到 10 年中，我们看到大多数主流语言都发展出了支持 Lambda 或惰性执行的能力。这意味着我们现在可以编写代码，守卫是隐式的，如果隐式条件得到解决，那么后续的表达式才会被评估和执行。例如：
- en: '[PRE1]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The result is negligible compute cost and optimization without losing the existence
    of the logging code. Add to that the performance improvements seen with compilers,
    virtual machines, and interpreters. We’re gaining performance—consider GraalVM
    and Quarkus as examples of this. When you consider this, we’re seeing more efficiency
    gains that will far outweigh those from not writing log statements.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是可忽略的计算成本和优化，同时不丢失日志代码的存在。再加上编译器、虚拟机和解释器所看到的性能改进。我们在获得性能——以 GraalVM 和 Quarkus
    作为例子。当你考虑这一点时，我们正在看到更多的效率提升，这远远超过了不编写日志语句所带来的提升。
- en: For more about Quarkus and GraalVM
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 Quarkus 和 GraalVM 的信息
- en: 'Quarkus and microservice development: See the liveBook version of *Kubernetes
    Native Microservices* by John Clingan and Ken Finnigan (Manning, 2022) at [http://mng.bz/zQ5Q](http://mng.bz/zQ5Q).'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Quarkus 和微服务开发：请参阅 John Clingan 和 Ken Finnigan 著的《Kubernetes 原生微服务》的 liveBook
    版本，[http://mng.bz/zQ5Q](http://mng.bz/zQ5Q)。
- en: 'GraalVM introduction: See the liveBook version of *The Well-Grounded Java Developer*,
    2nd ed by Benjamin Evans et al. (Manning, 2022) at [http://mng.bz/0w96](http://mng.bz/0w96).'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraalVM 简介：请参阅 Benjamin Evans 等人著的《扎实的 Java 开发者》（第 2 版）的 liveBook 版本，[http://mng.bz/0w96](http://mng.bz/0w96)。
- en: 'GraalVM home page: [www.graalvm.org/](https://www.graalvm.org/)'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraalVM 主页：[www.graalvm.org/](https://www.graalvm.org/)
- en: 'Quarkus home page: [https://quarkus.io/](https://quarkus.io/)'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Quarkus 主页：[https://quarkus.io/](https://quarkus.io/)
- en: Summary
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: The application of clear, simple language and, when appropriate, attributing
    the log event with error codes will make it significantly easier to understand
    a log and apply any necessary actions as a result of a log event.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用清晰、简单的语言，并在适当的情况下，将错误代码与日志事件关联，将显著简化对日志的理解，并基于日志事件采取任何必要的行动。
- en: Good log events will include contextual information beyond just log levels,
    including details such as indicating on which server the relevant process is running.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 良好的日志事件将包括超出日志级别的上下文信息，包括诸如指示相关进程在哪个服务器上运行等详细信息。
- en: Legislation can impact log events, particularly when the log generation includes
    such things as PII or credit card data. As a result, extensive additional security
    controls and restrictions are imposed on log data.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 立法可能会影响日志事件，尤其是当日志生成包括诸如PII或信用卡数据等内容时。因此，对日志数据施加了广泛的额外安全控制和限制。
- en: Some organizations will also classify internal data such as commercial values
    (e.g., margins on a product or service). It is important to understand organizational
    sensitivities when creating or transferring log events so that the organizational
    requirements relating to such data being logged are observed.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些组织还会将内部数据如商业价值（例如，产品或服务的利润率）进行分类。在创建或传输日志事件时，理解组织的敏感性非常重要，以确保遵守与记录此类数据相关的组织要求。
- en: The value of using error codes with log events is significant, from identifying
    which part of a system the issue originated to making remediation instructions
    easily identifiable.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用错误代码与日志事件结合使用的价值是显著的，从确定问题起源于系统的哪个部分到使修复说明易于识别。
- en: The application of industry standards to the content logged can accelerate understanding
    of data and its meaning.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将行业标准应用于记录的内容可以加速对数据和其含义的理解。
