- en: 9 Serverless compute engine (Knative)
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 无服务器计算引擎（Knative）
- en: Konrad Cłapa
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Konrad Cłapa
- en: This chapter covers
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Introduction to serverless
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无服务器简介
- en: Knative Serving and Eventing components
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Knative Serving 和 Eventing 组件
- en: Knative on Anthos
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Knative 在 Anthos 上
- en: Before we get into the details, let’s set the scene. In this chapter, we’re
    going to talk about Google Cloud Platform’s managed service based on an open source
    project called Knative. The project was started to allow for quicker development
    of Kubernetes applications without the need to understand the complex Kubernetes
    concepts they use. With this service, Google installs and manages Knative serving
    inside your Anthos GKE cluster. One of the benefits of using Knative with Anthos
    instead of open source Knative is that Google’s automation and site reliability
    engineers handle all installation and maintenance. Anthos integrates with numerous
    GCP services like Cloud Load Balancing ([https://cloud.google.com/load-balancing](https://cloud.google.com/load-balancing)),
    Cloud Armor ([https://cloud.google.com/armor](https://cloud.google.com/armor)),
    Cloud CDN ([https://cloud.google.com/cdn/docs/overview](https://cloud.google.com/cdn/docs/overview)),
    and many others, making an enterprise-ready Knative a reality.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入细节之前，让我们设定场景。在本章中，我们将讨论基于名为 Knative 的开源项目构建的 Google Cloud Platform 的托管服务。该项目启动的目的是允许更快地开发
    Kubernetes 应用程序，而无需理解它们使用的复杂 Kubernetes 概念。使用这项服务，Google 会将 Knative serving 安装并管理在您的
    Anthos GKE 集群内部。使用 Knative 与 Anthos 而不是开源 Knative 的一个好处是，Google 的自动化和站点可靠性工程师处理所有安装和维护工作。Anthos
    与众多 GCP 服务集成，如云负载均衡（[https://cloud.google.com/load-balancing](https://cloud.google.com/load-balancing)）、云装甲（[https://cloud.google.com/armor](https://cloud.google.com/armor)）、云
    CDN（[https://cloud.google.com/cdn/docs/overview](https://cloud.google.com/cdn/docs/overview)）等，使企业级的
    Knative 成为现实。
- en: We have already discussed Kubernetes in chapter 3, so we understand how complex
    the installation and maintenance of it can be. This problem is solved for us with
    Google Kubernetes Engine. In addition to Kubernetes, we still need to know how
    to run and operate cloud native applications. What Knative does is abstract those
    implementation details and allow you to serve your serverless container-based
    workloads on any Kubernetes cluster.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在第 3 章中讨论了 Kubernetes，因此我们了解安装和维护它的复杂性。Google Kubernetes Engine 解决了这个问题。除了
    Kubernetes 之外，我们还需要了解如何运行和操作云原生应用程序。Knative 做的是抽象那些实现细节，并允许您在任何 Kubernetes 集群上为无服务器容器化工作负载提供服务。
- en: In this chapter, we will look at what serverless is, introduce you to Knative,
    and discuss how Anthos delivers an enterprise-grade container-based serverless
    platform.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨什么是无服务器，向您介绍 Knative，并讨论 Anthos 如何提供企业级基于容器的无服务器平台。
- en: 9.1 Introduction to serverless
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1 无服务器简介
- en: 'A lot of discussion occurs about what serverless is. Comparisons between serverless
    and function as a service (FaaS) are common—it is almost an ideological dispute.
    To keep this simple, let’s look at the Cloud Native Computing Foundation’s definition:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 关于什么是无服务器的讨论很多。无服务器与函数即服务（FaaS）之间的比较很常见——这几乎是一场意识形态的争论。为了保持简单，让我们看看云原生计算基金会（Cloud
    Native Computing Foundation）的定义：
- en: Serverless computing refers to a new model of cloud-native computing, enabled
    by architectures that do not require server management to build and run applications.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器计算是指一种新的云原生计算模式，它通过不需要服务器管理来构建和运行应用程序的架构来实现。
- en: Google’s fully managed cloud-run service perfectly fits into this definition
    because it abstracts the compute layer from the developer and operator. It allows
    you to deploy the containers that will be serving HTTP(S) requests. The scaling
    of the application is handled by the platform itself.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Google 的完全托管云运行服务完美符合这一定义，因为它从开发者和操作者那里抽象了计算层。它允许您部署将用于服务 HTTP(S) 请求的容器。应用的扩展由平台本身处理。
- en: Although Google Cloud Functions deliver similar capabilities, they are more
    opinionated about the runtime languages you can use. With Cloud Run, you can use
    any language that can run a service that answers HTTPS calls. Cloud Run does not
    require you to use Anthos.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Google Cloud Functions 提供了类似的功能，但它们对您可以使用的服务运行时语言有更多的意见。使用 Cloud Run，您可以使用任何可以运行响应
    HTTPS 调用的服务的语言。Cloud Run 不需要您使用 Anthos。
- en: 'When we think about Cloud Run, we can think about the following set of serverless
    features:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们思考 Cloud Run 时，我们可以考虑以下一组无服务器功能：
- en: '*No server*—Developers don’t need to worry about underlying compute infrastructure.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*无服务器*—开发者无需担心底层计算基础设施。'
- en: '*Multilanguage*—The application can be written in any language.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*多语言*—应用程序可以用任何语言编写。'
- en: '*Event-driven*—The container/function is triggered by an external event.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*事件驱动*—容器/函数由外部事件触发。'
- en: '*Autoscaling*—The container can automatically scale based on requests.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*自动扩展*—容器可以根据请求自动扩展。'
- en: '*Portability*—Your container/application should be able to run on any Kubernetes
    platform.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可移植性*—您的容器/应用程序应该能够在任何 Kubernetes 平台上运行。'
- en: 9.2 Knative
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2 Knative
- en: Because you already know Kubernetes is a platform for building platforms, why
    not use it for building serverless platforms based on containers? Knative runs
    on top of Kubernetes like any other Kubernetes application. You can even see some
    statements from Knative contributors that it should not be called “serverless,”
    so let’s look at Knative as a platform to deliver serverless anywhere where you
    run Kubernetes. Sound fair?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因为您已经知道 Kubernetes 是一个用于构建平台的平台，为什么不使用它来构建基于容器的无服务器平台呢？Knative 就像任何其他 Kubernetes
    应用程序一样运行在 Kubernetes 之上。您甚至可以看到一些 Knative 贡献者的声明，他们认为不应该称之为“无服务器”，那么让我们把 Knative
    看作是一个可以在您运行 Kubernetes 的任何地方提供无服务器平台的平台。听起来公平吗？
- en: 9.2.1 Introduction
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.1 简介
- en: Say you would like to build your own Kubernetes-based serverless platform. You
    might come up with the diagram shown in figure 9.1 showing all the required components.
    Clearly some duplication of effort exists related to building the primitives like
    autoscalablity, observability, rollouts, and many others. What Knative is doing
    is providing all these primitives for you so you have a common experience of running
    a serverless workload on Kubernetes.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想构建自己的基于 Kubernetes 的无服务器平台。您可能会得到图 9.1 所示的图表，显示了所有必需的组件。显然，在构建像自动扩展、可观察性、部署等基本功能方面存在一些重复的工作。Knative
    正在为您提供所有这些基本功能，这样您就可以在 Kubernetes 上运行无服务器工作负载时拥有一个共同的体验。
- en: '![09-01](../../OEBPS/Images/09-01.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![09-01](../../OEBPS/Images/09-01.png)'
- en: Figure 9.1 Kubernetes serverless stack architecture
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 Kubernetes 无服务器堆栈架构
- en: Now think of it from the developer’s perspective. All they have to do is define
    the dependencies, write their code, and put it in a container. Then they deploy
    the application to Knative. The details of how it is served is not their concern.
    This does not mean, however, that they lose the capability to fine tune the service.
    They can set multiple parameters like concurrency (how many requests can be served
    per container), minimum/maximum instances (minimum/maximum container instances
    that can be provisioned for the Knative service), and many others. Knative hides
    all the complexities of Kubernetes involved with scaling and traffic management
    and provides a means to observe the workloads. That is what you call an easy start
    with development of Kubernetes applications, right?
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在从开发者的角度来看思考。他们只需要定义依赖项，编写代码，并将其放入容器中。然后，他们将应用程序部署到 Knative。他们不需要关心如何提供服务的细节。但这并不意味着他们失去了微调服务的能力。他们可以设置多个参数，如并发性（每个容器可以服务的请求数量）、最小/最大实例（为
    Knative 服务可以配置的最小/最大容器实例），以及其他许多参数。Knative 隐藏了与扩展和流量管理相关的所有 Kubernetes 复杂性，并提供了一种观察工作负载的方法。这就是所说的简单开始开发
    Kubernetes 应用程序，对吧？
- en: Knative vs. CaaS, FaaS, and PaaS
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Knative 与 CaaS、FaaS 和 PaaS 的比较
- en: 'In the second section of this chapter, we learn what problems Knative is trying
    to solve: enable serverless workloads to run anywhere with the flexibility of
    Kubernetes but hiding the complexity. Table 9.1 presents a comparison of Knative
    against platform as a service (PaaS; [http://mng.bz/WAKX](http://mng.bz/WAKX)),
    container as a service (CaaS; [http://mng.bz/81gg](http://mng.bz/81gg)), and function
    as a service (FaaS; [https://www.ibm.com/topics/faas](https://www.ibm.com/topics/faas)),
    with various features being supported. Do-it-yourself (DIY) means you need to
    do some development to be able to use that feature.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第二部分，我们了解 Knative 正在尝试解决什么问题：使无服务器工作负载能够在任何地方运行，同时具有 Kubernetes 的灵活性，但隐藏复杂性。表
    9.1 展示了 Knative 与平台即服务（PaaS；[http://mng.bz/WAKX](http://mng.bz/WAKX)）、容器即服务（CaaS；[http://mng.bz/81gg](http://mng.bz/81gg)）和函数即服务（FaaS；[https://www.ibm.com/topics/faas](https://www.ibm.com/topics/faas)）的比较，以及支持的各种功能。DIY
    表示您需要开发一些功能才能使用该功能。
- en: Table 9.1 Knative vs. PaaS, CaaS, and FaaS
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9.1 Knative 与 PaaS、CaaS 和 FaaS 的比较
- en: '| Feature | Knative | PaaS | CaaS | FaaS |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 功能 | Knative | PaaS | CaaS | FaaS |'
- en: '| Simple UX/DX | Yes | Yes |  | Yes |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 简单的用户体验/设计体验 | 是 | 是 |  | 是 |'
- en: '| Event driven | Yes | Yes |  | Yes |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 事件驱动 | 是 | 是 |  | 是 |'
- en: '| Container based | Yes | Yes | Yes | Yes |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 基于容器 | 是 | 是 | 是 | 是 |'
- en: '| Autoscaling | Yes | Yes | DIY | Yes |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 自动扩展 | 是 | 是 | DIY | 是 |'
- en: '| Scale resources to 0 | Yes | Yes |  | Yes |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 资源缩放到0 | 是 | 是 |  | 是 |'
- en: '| Load balancing | Yes | Yes | DIY | Yes |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 负载均衡 | 是 | 是 | DIY | 是 |'
- en: '| Unrestricted execution time | Yes* | Yes | Yes |  |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 无限制的执行时间 | 是* | 是 | 是 |  |'
- en: '| Unrestricted compute/memory limits | Yes** | Yes** | Yes** |  |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 无限制的计算/内存限制 | 是** | 是** | 是** |  |'
- en: '| Variety of programming languages support | Yes | Yes | Yes | Limited |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 支持多种编程语言 | 是 | 是 | 是 | 有限 |'
- en: '| * Might be restricted for managed services like Cloud Run.** Depends on the
    platform. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| * 对于像Cloud Run这样的托管服务可能会有所限制**。取决于平台。 |'
- en: 'As we can see, Knative provides all the advantages of FaaS but also gives you
    the ability to run your application in almost any language. The limits on the
    execution time are much higher compared to FaaS. In many cases, where there is
    a need for longer request-processing time, Knative is a solution. You finally
    have access to advanced features like volumes and networking so you can tweak
    your workload if needed. Like with all compute services with greater flexibility,
    the responsibility demarcation line shifts more toward you. You need to build
    your own container and make sure you can make use of all the advanced features.
    But let’s be honest: who does not like to be in more control of your application
    until you get all the benefits of FaaS?'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，Knative提供了FaaS的所有优势，同时也赋予你几乎在任何语言中运行应用程序的能力。与FaaS相比，执行时间的限制要高得多。在许多需要更长时间请求处理时间的情况下，Knative是一个解决方案。你终于可以访问诸如卷和网络等高级功能，以便在需要时调整你的工作负载。与所有具有更高灵活性的计算服务一样，责任划分线更多地转向了你。你需要构建自己的容器并确保你可以利用所有高级功能。但说真的：谁不喜欢对自己的应用程序有更多的控制，直到你获得FaaS的所有好处？
- en: 9.2.2 Knative history
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.2 Knative历史
- en: 'Google started Knative but now has multiple companies contributing to it, like
    IBM, RedHat, and SAP. The full documentation and source code can be found here:
    [https://github.com/knative](https://github.com/knative). Knative started as a
    set of components that allows you to build and run stateless workloads together
    with subscriptions to events. The following two active projects, shown in figure
    9.2, are in progress on GitHub:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Google启动了Knative，但现在有IBM、RedHat和SAP等多家公司参与其中。完整的文档和源代码可以在以下位置找到：[https://github.com/knative](https://github.com/knative)。Knative最初是一组组件，允许你构建和运行无状态工作负载，同时订阅事件。以下两个活跃的项目，如图9.2所示，正在GitHub上进展：
- en: '*Knative Serving*—Allows you to serve serverless containerized workloads'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Knative服务*—允许你提供无服务器容器化工作负载'
- en: '*Knative Eventing*—Allows subscriptions to external events'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Knative事件*—允许订阅外部事件'
- en: '![09-02](../../OEBPS/Images/09-02.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![09-02](../../OEBPS/Images/09-02.png)'
- en: Figure 9.2 Knative components
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 Knative组件
- en: The third project, *Knative Build*, which helped build containers, was deprecated
    and turned into the Tekton Pipelines ([https://github.com/tektoncd/pipeline](https://github.com/tektoncd/pipeline))
    project. As you will learn in chapter 9, it was used by Google to build Cloud
    Build for Anthos.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个项目，*Knative构建*，它帮助构建容器，已被弃用并转变为Tekton管道([https://github.com/tektoncd/pipeline](https://github.com/tektoncd/pipeline))项目。正如你在第9章中将学到的，它被Google用于构建Anthos的Cloud
    Build。
- en: At the time of writing, both Knative Serving and Eventing are already in version
    1.x, with Eventing being slightly behind Serving. Knative was developed with the
    vision to deliver the simplicity of App Engine ([https://cloud.google.com/appengine](https://cloud.google.com/appengine))
    but allowing for the flexibility that Kubernetes brings. As an example, with Knative
    you can modify the routing to different versions of the application by setting
    the traffic configuration on a Knative Serving[¹](#pgfId-1063511) object rather
    than changing the low-level network object’s configuration (e.g., Istio). This
    setup resembles App Engine, where you simply run one command to perform a task,
    and it can be used for canary deployments and A/B testing. Knative gives you the
    ability to run your serverless containers anywhere, whether in the cloud or in
    an on-prem data center.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Knative服务和事件都已经进入1.x版本，其中事件略落后于服务。Knative的开发愿景是提供App Engine([https://cloud.google.com/appengine](https://cloud.google.com/appengine))的简单性，但允许Kubernetes带来的灵活性。例如，使用Knative，你可以通过在Knative服务[¹](#pgfId-1063511)对象上设置流量配置来修改路由到应用程序的不同版本，而不是更改底层网络对象的配置（例如，Istio）。这种设置类似于App
    Engine，你只需运行一个命令即可执行任务，它可以用于金丝雀部署和A/B测试。Knative赋予你将无服务器容器运行在任何地方的能力，无论是在云中还是在本地数据中心。
- en: As you will shortly learn, multiple Knative-based, fully managed services already
    exist that make it even easier to avoid getting into the complexity of Kubernetes.
    The most interesting one for this book is, of course, Knative for Anthos, which
    is one of the most advanced offerings existing on the market.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您很快就会学到的那样，已经存在多个基于Knative的、完全托管的云服务，这使得避免陷入Kubernetes的复杂性变得更加容易。对于本书来说，最有趣的一个当然是Knative
    for Anthos，这是市场上最先进的提供之一。
- en: 9.3 Knative architecture
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3 Knative架构
- en: Let’s look at Knative architecture, presented in figure 9.3\. As you can see,
    multiple layers exist, with some of the components being plug and play or optional.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看图9.3所示的Knative架构。如您所见，存在多个层级，其中一些组件是即插即用或可选的。
- en: '![09-03](../../OEBPS/Images/09-03.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![09-03](../../OEBPS/Images/09-03.png)'
- en: Figure 9.3 Knative architecture
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 Knative架构
- en: 'Knative can run on any compute platform that can run Kubernetes. It can be
    based on either virtual machines or bare metal servers. For traffic routing, Service
    Mesh Gateway is used. Obviously, the most popular is Istio, but alternative solutions
    are also supported, including Gloo, Ambassador, Contour, and Kourier, with more
    to come. To learn more about Istio, refer to chapter 4\. On top of that, we have
    Knative components installed as a Kubernetes application. Note that each of those
    components can be installed and operated separately. If you are not interested
    in managing the Knative installation yourself, you can use one of the many already
    existing managed services—Google Cloud Run and Google Cloud Run for Anthos, OpenShift
    Serverless, managed Knative for IBM Cloud Kubernetes Service—where both Knative
    and underlying Kubernetes are managed by the provider. A list of those services
    can be found here: [http://mng.bz/El6r](http://mng.bz/El6r).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Knative可以在任何可以运行Kubernetes的计算平台上运行。它既可以基于虚拟机，也可以基于裸金属服务器。对于流量路由，使用Service Mesh
    Gateway。显然，最流行的是Istio，但也支持其他替代方案，包括Gloo、Ambassador、Contour和Kourier，还有更多即将到来。要了解更多关于Istio的信息，请参阅第4章。除此之外，我们还将Knative组件作为Kubernetes应用程序安装。请注意，这些组件可以单独安装和操作。如果您不感兴趣自己管理Knative安装，可以使用许多现有的托管服务之一——Google
    Cloud Run和Google Cloud Run for Anthos、OpenShift Serverless、IBM Cloud Kubernetes
    Service的托管Knative——在这些服务中，Knative及其底层的Kubernetes都由提供商管理。这些服务的列表可以在以下链接找到：[http://mng.bz/El6r](http://mng.bz/El6r)。
- en: 9.3.1 Knative Kubernetes resource types
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.1 Knative Kubernetes资源类型
- en: Knative comes with a set of controllers and custom resource definitions (CRDs)
    that extend the native Kubernetes API. Therefore, integration with Knative is
    very much like interaction with the Kubernetes API itself. We will look at the
    Knative resources in the next section.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Knative附带一组控制器和自定义资源定义（CRDs），它们扩展了原生Kubernetes API。因此，与Knative的集成非常类似于与Kubernetes
    API本身的交互。我们将在下一节中查看Knative资源。
- en: If you think of a simple Kubernetes application, you should have objects like
    Pods, Deployments, and Services. If you include Service Mesh, you will have additional
    resources to handle the traffic management like virtual services and destination
    rules. With Knative, you control your deployment with a single resource—Knative
    Service—which allows you to both deploy the workload and handle the traffic. All
    the required Kubernetes and Service Mesh resources are created for you.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您考虑一个简单的Kubernetes应用程序，您应该有Pods、Deployments和Services等对象。如果您包含Service Mesh，您将拥有额外的资源来处理流量管理，如虚拟服务和目标规则。使用Knative，您可以通过单个资源——Knative
    Service——来控制您的部署，这允许您部署工作负载并处理流量。所有必需的Kubernetes和Service Mesh资源都将为您创建。
- en: 9.3.2 Knative Serving
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.2 Knative Serving
- en: Knative Serving allows you to easily deploy container-based serverless workloads
    and serve them to users via HTTP(s) requests (with gRPC recently announced). As
    an example, you can serve an entire e-commerce website frontend using Knative
    Serving. It automatically scales your workload as per demand (from 0 to N) and
    routes or splits traffic to the version (revision) you choose. To achieve this
    with native Kubernetes, you would need to use additional Kubernetes resources
    like HorizontalPodAutoscaler (HPA; [http://mng.bz/NmaX](http://mng.bz/NmaX)).
    Knative Serving extends the Kubernetes API with new CRDs like Knative Serving
    Service, Configuration, Route, and Revision. Figure 9.4 shows how the Knative
    resources depend on each other.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Knative Serving 允许您轻松部署基于容器的无服务器工作负载，并通过 HTTP(s) 请求（最近宣布支持 gRPC）向用户提供服务。例如，您可以使用
    Knative Serving 提供整个电子商务网站的前端。它根据需求自动扩展您的负载（从 0 到 N），并将流量路由或分割到您选择的版本（修订版）。要使用原生
    Kubernetes 实现这一点，您需要使用额外的 Kubernetes 资源，如 HorizontalPodAutoscaler（HPA；[http://mng.bz/NmaX](http://mng.bz/NmaX)）。Knative
    Serving 通过添加新的 CRDs（如 Knative Serving Service、Configuration、Route 和 Revision）扩展了
    Kubernetes API。图 9.4 展示了 Knative 资源之间的依赖关系。
- en: '![09-04](../../OEBPS/Images/09-04.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![09-04](../../OEBPS/Images/09-04.png)'
- en: Figure 9.4 Knative Serving resources
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 Knative Serving 资源
- en: 'Each of the CRDs is described next:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来将描述每个 CRD：
- en: '*Service (API path service.serving.knative.dev)*—The most important resource
    in Knative Serving. It automatically creates other Knative resources needed for
    the entire life cycle of your workload. With the update of the services, a new
    Revision is created. Within the Knative Service, you define both the container
    version and the traffic rules.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*服务（API路径 service.serving.knative.dev）*—Knative Serving 中最重要的资源。它自动创建您的工作负载整个生命周期所需的其他
    Knative 资源。随着服务的更新，会创建一个新的修订版。在 Knative 服务中，您定义容器版本和流量规则。'
- en: Note This is different from the native Kubernetes Service *object*, which might
    be confusing to new users at first.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：这与原生 Kubernetes 服务 *对象* 不同，这可能会让新用户一开始感到困惑。
- en: 'For example, a Service definition that deploys a simple Hello World workload
    to Knative Serving will automatically create other resources: Revision, Configurations,
    and Route:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个将简单的 Hello World 工作负载部署到 Knative Serving 的服务定义将自动创建其他资源：修订版、配置和路由：
- en: '[PRE0]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Revision (API path* *revision.serving.knative.dev)*—An immutable snapshot
    of the container version and its configuration. It defines what is actually served
    to the user.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*修订版（API路径 revision.serving.knative.dev）*—容器版本及其配置的不可变快照。它定义了实际提供给用户的内容。'
- en: '*Configuration (API path* *configuration.serving.knative.dev**)*—The configuration
    part of your application that enforces the desired state of your workload. It
    allows you to separate your code (container) from the configuration piece. Modification
    of the configuration results in new Revision creation.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*配置（API路径 configuration.serving.knative.dev**）*—强制执行您工作负载所需状态的配置部分。它允许您将代码（容器）与配置部分分离。配置的修改会导致创建新的修订版。'
- en: '*Route (API path* *route.serving.knative.dev)*—Maps the endpoints to one or
    more revisions.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*路由（API路径 route.serving.knative.dev）*—将端点映射到一个或多个修订版。'
- en: When you use Knative, you no longer need to worry about the native Kubernetes
    and Service Mesh resources like Deployments, Services, and VirtualServices. You
    define your application as a Knative Service and all the “backend” resources are
    created for you.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用 Knative 时，您不再需要担心原生 Kubernetes 和服务网格资源，如 Deployments、Services 和 VirtualServices。您将应用程序定义为
    Knative 服务，所有“后端”资源都将为您创建。
- en: Traffic management
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 流量管理
- en: When you want to update your Knative Service with a new image, a new revision
    is created, and by default, the traffic is directed to the new revision, as shown
    in figure 9.5\. You can perform A/B ([http://mng.bz/DZ50](http://mng.bz/DZ50))
    testing on a canary ([https://martinfowler.com/bliki/CanaryRelease.xhtml](https://martinfowler.com/bliki/CanaryRelease.xhtml))
    release, controlling how much traffic should be directed to a particular revision
    by defining the metadata.spec.traffic attribute. You can also just tag a particular
    revision to be accessible by a dedicated URL.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想使用新镜像更新 Knative 服务时，会创建一个新的修订版，并且默认情况下，流量将指向新的修订版，如图 9.5 所示。您可以在金丝雀（[http://mng.bz/DZ50](http://mng.bz/DZ50)）发布上进行
    A/B 测试，通过定义 metadata.spec.traffic 属性来控制应将多少流量路由到特定的修订版。您还可以仅通过专用 URL 标记特定的修订版以使其可访问。
- en: '![09-05](../../OEBPS/Images/09-05.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![09-05](../../OEBPS/Images/09-05.png)'
- en: Figure 9.5 Knative Service traffic flows
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5 Knative 服务流量流向
- en: 'To achieve the routing shown in figure 9.5, you would set up the metadata.spec
    .traffic attribute in the Knative Service:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现图 9.5 中所示的路由，您需要在 Knative Service 中设置 metadata.spec 的 traffic 属性：
- en: '[PRE1]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, with a single Kubernetes object, a developer can control how
    the entire workload is served. There is no need to dive deep into the Kubernetes
    backend.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，通过单个 Kubernetes 对象，开发者可以控制整个工作负载的托管方式。无需深入 Kubernetes 后端。
- en: Knative Serving control plane
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Knative Serving 控制平面
- en: Now let’s look at the Knative Serving control plane, which allows for all this
    magic to happen. As we’ve already said, Kubernetes uses Istio, or any other supported
    service mesh, for traffic management. It also comes with several services that
    take care of running and scaling the workload.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 Knative Serving 控制平面，它允许所有这些魔法发生。正如我们之前所说的，Kubernetes 使用 Istio 或任何其他支持的服务网格进行流量管理。它还附带了一些服务，负责运行和扩展工作负载。
- en: 'To retrieve the list of the services in the knative-serving namespace you installed
    with Knative, use kubectl get services -n knative-serving. It will show the following
    services:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索您使用 Knative 安装的 knative-serving 命名空间中的服务列表，请使用 kubectl get services -n knative-serving。它将显示以下服务：
- en: '[PRE2]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As you can see, for such a complex service, it doesn’t have many supporting
    services. Let’s look at them one by one:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，对于这样一个复杂的服务，它没有很多支持服务。让我们逐一查看：
- en: '*Activator*—Receives and buffers requests for inactive revisions and reporting
    metrics to the Autoscaler. It also retries requests to a Revision after the Autoscaler
    scales the revision based on the reported metrics.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Activator*—接收并缓冲不活跃修订版的请求，并向自动扩展器报告指标。它还会在自动扩展器根据报告的指标扩展修订版后重试对修订版的请求。'
- en: '*Autoscaler*—Sets the number of Pods required to handle the load based on the
    defined parameters.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Autoscaler*—根据定义的参数设置处理负载所需的 Pod 数量。'
- en: '*Controller*—Monitors and reconciles Knative objects defined in CRDs. When
    a new Knative Service is created, it creates Configuration and Route. It will
    create a Revision and corresponding Deployment and Knative Pod Autoscaler.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Controller*—监控和协调在 CRDs 中定义的 Knative 对象。当创建新的 Knative Service 时，它会创建配置和路由。它将创建修订版和相应的部署以及
    Knative Pod 自动扩展器。'
- en: '*Webhook*—Intercepts, validates, and mutates Kubernetes API calls, including
    CRD insertions and updates. Sets the default value and rejects inconsistent and
    invalid objects.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Webhook*—拦截、验证和修改 Kubernetes API 调用，包括 CRD 插入和更新。设置默认值并拒绝不一致和无效的对象。'
- en: 'If you retrieve the list of the deployments in the namespace you installed
    Knative to using kubectl get deployments -n knative-serving, you will see the
    following deployments:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用 kubectl get deployments -n knative-serving 检索您安装 Knative 的命名空间中的部署列表，您将看到以下部署：
- en: '[PRE3]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We have already discussed four of these services, but we have not yet seen
    the following two deployments:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了这四个服务，但我们还没有看到以下两个部署：
- en: '*Networking-certmanager*—Reconciles cluster ingresses into cert manager objects.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Networking-certmanager*—将集群入口与 cert manager 对象进行协调。'
- en: '*Networking-istio*—Reconciles a cluster’s ingress into an Istio virtual service.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Networking-istio*—将集群入口与 Istio 虚拟服务进行协调。'
- en: 9.3.3 Knative Eventing
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.3 Knative Eventing
- en: Eventing is the Knative component that orchestrates events originating from
    various sources inside or outside of the Kubernetes cluster. This important element
    of event-driven architecture allows you to trigger your service using existing
    event sources and build new ones for scenarios where you need a custom source
    not already available. This process is different from FaaS, where the functions
    are triggered using only HTTP requests or other predefined triggers, like Google
    Cloud Storage events.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Eventing 是 Knative 组件，它协调来自 Kubernetes 集群内部或外部的各种来源的事件。这一事件驱动架构的重要元素允许您使用现有的事件源触发您的服务，并为需要自定义源但尚未提供的情况构建新的源。此过程与
    FaaS 不同，在 FaaS 中，函数仅通过 HTTP 请求或其他预定义触发器（如 Google Cloud Storage 事件）触发。
- en: All the Knative Eventing objects are defined as CRDs. This ensures that the
    events are handled as defined in the Knative objects using controllers. Scalability
    is taken care of automatically as events trigger calls to your container. It gives
    you scalability similar to Knative Serving, so you can start with a small load
    of a few events and scale to handle a stream of events.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的 Knative Eventing 对象都定义为 CRDs。这确保了事件按照 Knative 对象中定义的方式使用控制器进行处理。可扩展性会自动处理，因为事件触发对您的容器的调用。它为您提供了类似于
    Knative Serving 的可扩展性，因此您可以从小规模的事件负载开始，并扩展以处理事件流。
- en: You can use around 20 predefined sources, and the list is growing. You can also
    develop your own source. Knative Eventing is also pluggable, so you can choose
    how you want to store your event—whether in memory or persistent storage—while
    it’s being processed. Knative uses an open CNCF standard, CloudEvents, to parse
    the original events. The target for the events can be both Knative and Kubernetes
    Services. The Eventing pipelines are simple—like a simple event being sent to
    a single Service—but they can also get very complex. For the sake of understanding
    Cloud Run, let’s concentrate on the basics first.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用大约 20 个预定义的事件源，而且这个列表还在增长。您也可以开发自己的事件源。Knative Eventing 也是可插拔的，因此您可以选择在处理事件时如何存储事件——是在内存中还是持久存储——Knative
    使用开放的 CNCF 标准 CloudEvents 来解析原始事件。事件的目标可以是 Knative 和 Kubernetes 服务。Eventing 管道很简单——就像一个简单的事件被发送到单个服务一样——但它们也可以变得非常复杂。为了理解
    Cloud Run，我们先集中关注基础知识。
- en: Knative Eventing resources
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Knative Eventing 资源
- en: The most essential component of Knative events are Brokers and Triggers. If
    we look at figure 9.6, we see that the events are generated from external sources
    and are captured by the Broker. There, one or more Triggers receives the events,
    filters them, and passes them to the Service.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Knative 事件的最基本组件是 Broker 和 Trigger。如果我们看图 9.6，我们会看到事件是从外部源生成的，并被 Broker 捕获。在那里，一个或多个
    Trigger 接收事件，过滤它们，并将它们传递到服务。
- en: '![09-06](../../OEBPS/Images/09-06.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![09-06](../../OEBPS/Images/09-06.png)'
- en: Figure 9.6 Knative Eventing resources
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.6 Knative Eventing 资源
- en: The architecture of Knative clearly separates concerns. Knative Eventing Broker
    is an event mesh that pulls or receives events, whereas Knative Trigger filters
    and routes events to targets. Event sources are the control plane of Knative Eventing
    that makes sure events are sent to the Broker. Now let’s look more closely at
    the resources.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Knative 的架构明确地分离了关注点。Knative Eventing Broker 是一个事件网格，它拉取或接收事件，而 Knative Trigger
    则负责过滤和将事件路由到目标。事件源是 Knative Eventing 的控制平面，确保事件被发送到 Broker。现在让我们更仔细地看看这些资源。
- en: The Broker API path broker.eventing.knative.dev is essentially an addressable
    event delivery system that you install by setting a label on your namespace, similar
    to what you do with Istio when you want to do sidecar injections into the Pods.
    Events are received by the Broker and then sent to subscribers. The messages are
    stored in a channel managed by the Broker.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Broker API 路径 broker.eventing.knative.dev 实质上是一个可寻址的事件投递系统，您可以通过在命名空间上设置标签来安装它，这与您在想要对
    Pods 进行旁路注入时对 Istio 所做的操作类似。事件由 Broker 接收，然后发送给订阅者。消息存储在由 Broker 管理的通道中。
- en: 'The channel can be a simple in-memory channel or it can use persistent storage
    for reliability purposes. Examples of these are Pub/Sub and Kafka. The configuration
    of the channels is stored in ConfigMaps. If you want to have different types of
    messages, you can install Broker into multiple namespaces. You can also filter
    which events are accepted by the Broker. An example definition of a Knative Broker
    follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 通道可以是简单的内存通道，也可以为了可靠性目的使用持久存储。这些示例包括 Pub/Sub 和 Kafka。通道的配置存储在 ConfigMaps 中。如果您想有不同的消息类型，您可以将
    Broker 安装到多个命名空间中。您还可以过滤 Broker 接受哪些事件。下面是一个 Knative Broker 的示例定义：
- en: '[PRE4]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The Triggers API path trigger.eventing.knative.dev matches the event with a
    Service, so it is defined for the type of event (e.g., a Cloud Storage object
    sending the event to that Service). Triggers can filter events based on one or
    more attributes. If multiple attributes exist, all attribute values need to match.
    This method can also produce new event types from the received event. This can
    be a nice use case for filtering events with sensitive data. An example definition
    of a Knative Trigger is shown next:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Triggers API 路径 trigger.eventing.knative.dev 将事件与一个服务匹配，因此它定义了事件类型（例如，一个 Cloud
    Storage 对象将事件发送到该服务）。触发器可以根据一个或多个属性过滤事件。如果存在多个属性，所有属性值都需要匹配。这种方法还可以从接收的事件中产生新的事件类型。这可以是一个过滤包含敏感数据事件的不错用例。下面是一个
    Knative 触发器的示例定义：
- en: '[PRE5]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The Source API path <source_name>.eventing.knative.dev is defined as a CRD.
    The list is still growing and includes AWS SQS, Google Cloud Pub/Sub, Google Cloud
    Scheduler, Google Cloud Storage, GitHub, and GitLab. A full list of events appears
    at [https://knative.dev/docs/eventing/sources/](https://knative.dev/docs/eventing/sources/).
    You can either use an existing Source or create your own. The following example
    shows how to configure a CloudPubSubSource event source. The event will be generated
    whenever a message is published to a Pub/Sub topic named testing:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 源 API 路径 `<source_name>.eventing.knative.dev` 被定义为 CRD。列表仍在增长，包括 AWS SQS、Google
    Cloud Pub/Sub、Google Cloud Scheduler、Google Cloud Storage、GitHub 和 GitLab。事件的全列表请参阅
    [https://knative.dev/docs/eventing/sources/](https://knative.dev/docs/eventing/sources/)。你可以使用现有的源或创建自己的源。以下示例展示了如何配置
    CloudPubSubSource 事件源。每当消息被发布到名为 testing 的 Pub/Sub 主题时，将生成事件：
- en: '[PRE6]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In figure 9.7, you can see how an event source works.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在图 9.7 中，你可以看到事件源是如何工作的。
- en: '![09-07](../../OEBPS/Images/09-07.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![09-07](../../OEBPS/Images/09-07.png)'
- en: Figure 9.7 How an event source works
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.7 事件源的工作原理
- en: The events are pulled or pushed to the adapters, depending on whether the source
    is capable of pushing events. If it is not, the events need to be pulled. The
    adapters are developed to understand the events and translate them into a common
    CloudEvents format. Once translated, they are available for the Broker to pick
    them up in the new format.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 事件根据源是否能够推送事件而被拉取或推送。如果不能，则需要拉取事件。适配器被开发出来以理解事件并将它们转换为通用的 CloudEvents 格式。一旦转换，它们就可以供代理在新格式中拾取。
- en: How event sources work
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 事件源的工作原理
- en: Event sources consist of control and data planes. The control plane is responsible
    for configuration of the event delivery with the authoritative source, the setup
    of the data plane, and the cleanup—put simply, it creates the webhooks and subscriptions.
    The data plane performs the push/pull operations, then validates and converts
    the data into CloudEvents.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 事件源由控制平面和数据平面组成。控制平面负责与权威源配置事件交付、数据平面的设置和清理——简单来说，它创建 webhooks 和订阅。数据平面执行推送/拉取操作，然后验证并将数据转换为
    CloudEvents。
- en: On top of existing sources, you can create your own event sources using Kubernetes
    operators, container sources, or existing services. To see how you can develop
    your own source, refer to the Knative Eventing documentation ([http://mng.bz/lJBz](http://mng.bz/lJBz)).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在现有源的基础上，你可以使用 Kubernetes 运算符、容器源或现有服务创建自己的事件源。要了解如何开发自己的源，请参阅 Knative Eventing
    文档 ([http://mng.bz/lJBz](http://mng.bz/lJBz))。
- en: Knative use cases
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Knative 用例
- en: With Knative, you can cover several use cases, from a simple single service
    to very complex multimicroservice applications. Using Knative Serving, you can
    create both HTTP and gRPC ([https://grpc.io/docs/what-is-grpc/introduction/](https://grpc.io/docs/what-is-grpc/introduction/))
    services, webhooks, and APIs. You can also manage rollouts and rollbacks and control
    the traffic to your application. With Knative Eventing, you can create simple
    or very complex eventing pipelines. By combining those two services, you can deliver
    a fully cloud native, event-driven application.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Knative，你可以覆盖从简单的单个服务到非常复杂的多微服务应用的各种用例。通过使用 Knative Serving，你可以创建 HTTP 和
    gRPC ([https://grpc.io/docs/what-is-grpc/introduction/](https://grpc.io/docs/what-is-grpc/introduction/))
    服务、webhooks 和 API。你还可以管理发布和回滚，并控制应用程序的流量。使用 Knative Eventing，你可以创建简单或非常复杂的事件处理管道。通过结合这两个服务，你可以交付一个完全云原生、事件驱动的应用程序。
- en: Let’s look at a simple example of binding running services to a Cloud IoT Core
    ([https://cloud.google.com/iot-core](https://cloud.google.com/iot-core)), as shown
    in figure 9.8\. The messages from the IoT devices are sent to the Google Cloud
    IoT Core and synced to Pub/Sub. The Knative Eventing service uses the Pub/Sub
    source to get the messages from the topic. The messages are sent to a Broker and
    converted to CloudEvents. A Trigger ensures the events are sent to the proper
    service that can further process, log, or display them to the user.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看将运行中的服务绑定到 Cloud IoT Core ([https://cloud.google.com/iot-core](https://cloud.google.com/iot-core))
    的简单示例，如图 9.8 所示。来自 IoT 设备的消息被发送到 Google Cloud IoT Core 并同步到 Pub/Sub。Knative Eventing
    服务使用 Pub/Sub 源从主题获取消息。消息被发送到代理并转换为 CloudEvents。触发器确保事件被发送到可以进一步处理、记录或显示给用户的正确服务。
- en: '![09-08](../../OEBPS/Images/09-08.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![09-08](../../OEBPS/Images/09-08.png)'
- en: Figure 9.8 Binding running services to IoT Core
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.8 将运行中的服务绑定到 IoT Core
- en: If you would like to try the Pub/Sub example yourself, we encourage you to follow
    the step-by-step tutorial at [http://mng.bz/Bljq](http://mng.bz/Bljq).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要尝试Pub/Sub示例，我们鼓励你遵循[http://mng.bz/Bljq](http://mng.bz/Bljq)上的逐步教程。
- en: 9.3.4 Observability
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.4 可观测性
- en: 'Knative comes with logging and tracing capabilities, as shown in figure 9.9\.
    The following open source software is supported:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Knative自带日志和跟踪功能，如图9.9所示。以下开源软件得到支持：
- en: Prometheus and Grafana for metrics
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Prometheus和Grafana用于指标
- en: ELK (Elasticsearch, Logstash, and Kibana) stack for logs
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ELK（Elasticsearch、Logstash和Kibana）堆栈用于日志
- en: Jaeger or Zipkin for distributed tracing
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jaeger或Zipkin用于分布式跟踪
- en: '![09-09](../../OEBPS/Images/09-09.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![09-09](../../OEBPS/Images/09-09.png)'
- en: Figure 9.9 Knative observability ecosystem
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9 Knative可观测性生态系统
- en: To learn more about metrics and tracing, see chapter 4.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于指标和跟踪的信息，请参阅第4章。
- en: You can also integrate with Google Cloud Logging (formerly Stackdriver Logging)
    for logs using the *Fluent Bit* agent. The installation procedure for each of
    the components is well described in the article found at [http://mng.bz/dJlz](http://mng.bz/dJlz).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过使用*Fluent Bit*代理与Google Cloud Logging（以前称为Stackdriver Logging）集成日志。每个组件的安装过程在[http://mng.bz/dJlz](http://mng.bz/dJlz)找到的文章中有详细描述。
- en: 'Because these components are deployed like any other Kubernetes application,
    you can access them by exposing the Kubernetes service. An example of Pods running
    on a cluster after deployment follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这些组件像任何其他Kubernetes应用一样部署，你可以通过暴露Kubernetes服务来访问它们。以下是一个部署后运行在集群中的Pod示例：
- en: '[PRE7]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 9.3.5 Installing Knative
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.5 安装Knative
- en: 'You can install Knative on multiple cloud platforms or on-prem, if you run
    a Kubernetes cluster that includes but is not limited to the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行一个包含但不限于以下内容的Kubernetes集群，你可以在多个云平台或本地安装Knative：
- en: Amazon EKS
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Amazon EKS
- en: Google GKE
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google GKE
- en: IBM IKS
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IBM IKS
- en: Red Hat OpenShift Cloud Platform
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Red Hat OpenShift Cloud Platform
- en: Minikube
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Minikube
- en: 'In the end, Knative is nothing but a Kubernetes application. You can install
    it either using YAML files or an operator. To learn more about operators, see
    [http://mng.bz/rdRE](http://mng.bz/rdRE). The installation process for the Knative
    Serving component consists of the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Knative不过是一个Kubernetes应用。你可以使用YAML文件或操作符来安装它。要了解更多关于操作符的信息，请参阅[http://mng.bz/rdRE](http://mng.bz/rdRE)。Knative
    Serving组件的安装过程如下：
- en: Installation of the custom resource definitions
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义资源定义的安装
- en: Installation of the core components of Serving
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Serving的核心组件
- en: Installation of the networking layer
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装网络层
- en: Configuration of DNS
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DNS配置
- en: Installation of optional Serving extensions
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选Serving扩展的安装
- en: 'Installation of the Knative Eventing component consists of the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Knative Eventing组件的安装包括以下步骤：
- en: Installation of the custom resource definitions
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义资源定义的安装
- en: Installation of the core components of Eventing
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Eventing的核心组件
- en: Installation of the default channel (messaging) layer
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认通道（消息传递）层的安装
- en: Installation of a Broker (Eventing) layer
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装（事件）代理层
- en: Optional Eventing extensions (sources)
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选Eventing扩展（源）
- en: Once you are done with the installation of Serving and Eventing, you can install
    the observability components described in the previous section. The step-by-step
    procedure for end-to-end installation is available at [http://mng.bz/Vp0r](http://mng.bz/Vp0r).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 完成Serving和Eventing的安装后，你可以安装上一节中描述的可观测性组件。端到端安装的逐步过程可在[http://mng.bz/Vp0r](http://mng.bz/Vp0r)找到。
- en: 9.3.6 Deploying to Knative
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.6 将应用部署到Knative
- en: 'You can follow a simple guide to deploy your first application to Knative,
    which is as simple as applying a single Knative Service object, as follows. This
    is assuming you already have a containerized Python application that responds
    with the response “Hello Python Sample v1!” stored in Docker Hub (see [http://mng.bz/xdRq](http://mng.bz/xdRq)
    to check the source code for that application):'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以遵循一个简单的指南将你的第一个应用程序部署到Knative，这就像应用一个单一的Knative服务对象一样简单，如下所示。这假设你已经在Docker
    Hub中存储了一个容器化的Python应用程序，该应用程序响应“Hello Python Sample v1!”（查看[http://mng.bz/xdRq](http://mng.bz/xdRq)以检查该应用程序的源代码）：
- en: 'Run the following command to create a Knative Service:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以创建Knative服务：
- en: '[PRE8]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'where Service is defined in the service.yaml file as follows:'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其中Service在service.yaml文件中定义如下：
- en: '[PRE9]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Once deployed, multiple objects are created for you, including Pods, Knative
    Service, Configuration, Revision, and Route. You can verify them by running the
    next code:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦部署，将为你创建多个对象，包括 Pods、Knative 服务、配置、修订和路由。你可以通过运行以下代码来验证它们：
- en: '[PRE10]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can access the service and get the IP address of the Istio ingress gateway
    as follows:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过以下方式访问服务并获取 Istio 入口网关的 IP 地址：
- en: '[PRE11]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This will return the following URL:'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将返回以下 URL：
- en: '[PRE12]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now test the application by running a curl query:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在通过运行 curl 查询来测试应用程序：
- en: '[PRE13]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note that the xip.io domain is called a magic DNS. You can configure it when
    installing Knative (see [http://mng.bz/Al9E](http://mng.bz/Al9E)).
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，xip.io 域称为魔法 DNS。你可以在安装 Knative 时配置它（见 [http://mng.bz/Al9E](http://mng.bz/Al9E)）。
- en: 'You should see the following output:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '[PRE14]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You have successfully deployed your first Knative application!
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你已成功部署了你的第一个 Knative 应用程序！
- en: To get some hands-on experience with Knative, we suggest you check out the examples
    shown in table 9.2\. They cover end-to-end Knative app development and deployment
    scenarios with multiple language support. We especially recommend the Mete Atamel
    tutorial on Knative, which takes you by hand from a very simple deployment to
    very complex ones, including usage of Google Cloud services like Pub/Sub, AI APIs,
    and BigQuery. We are sure you will have a lot of fun!
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得一些 Knative 的实践经验，我们建议你查看表 9.2 中所示的示例。它们涵盖了支持多种语言的 Knative 应用程序开发和部署场景。我们特别推荐
    Mete Atamel 的 Knative 教程，它从非常简单的部署引导你到非常复杂的部署，包括使用 Google Cloud 服务如 Pub/Sub、AI
    API 和 BigQuery。我们相信你会有很多乐趣！
- en: Table 9.2 References for deploying to Knative
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9.2 部署到 Knative 的参考
- en: '| Title | URL |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| 标题 | URL |'
- en: '| Knative Serving code samples | [https://knative.dev/docs/serving/samples/](https://knative.dev/docs/serving/samples/)
    |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| Knative Serving 代码示例 | [https://knative.dev/docs/serving/samples/](https://knative.dev/docs/serving/samples/)
    |'
- en: '| Knative Eventing code samples | [https://knative.dev/docs/eventing/samples/](https://knative.dev/docs/eventing/samples/)
    |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| Knative Eventing 代码示例 | [https://knative.dev/docs/eventing/samples/](https://knative.dev/docs/eventing/samples/)
    |'
- en: '| Mete Atamel Knative tutorial with multiple examples | [https://github.com/meteatamel/knative-tutorial](https://github.com/meteatamel/knative-tutorial)
    |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| Mete Atamel 带有多个示例的 Knative 教程 | [https://github.com/meteatamel/knative-tutorial](https://github.com/meteatamel/knative-tutorial)
    |'
- en: Knative summary
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Knative 概述
- en: With Knative service, you no longer must choose between the flexibility of Kubernetes
    and the simplicity of function as a service—you get the best of both worlds. You
    can run your serverless workload anywhere. With Knative Eventing, you can subscribe
    and receive events from several predefined sources as well as define your own
    source using cloud native architecture.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Knative 服务，你不再需要在 Kubernetes 的灵活性和函数即服务的简单性之间做出选择——你可以两者兼得。你可以在任何地方运行你的无服务器工作负载。使用
    Knative Eventing，你可以订阅并接收来自多个预定义源的事件，以及使用云原生架构定义自己的源。
- en: Cloud Run vs. Knative on Anthos
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud Run 与 Knative on Anthos 对比
- en: Cloud Run is a fully managed serverless offering, whereas Knative on Anthos
    runs on top of your Anthos clusters, as shown in figure 9.10\. You can interact
    with Cloud Run, whichever version you go for. Cloud Run, however, runs on Google
    infrastructure, so you don’t need to worry about the underlying platform.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud Run 是一个完全管理的无服务器产品，而 Knative on Anthos 在你的 Anthos 集群之上运行，如图 9.10 所示。你可以与任何版本的
    Cloud Run 交互。然而，Cloud Run 在 Google 基础设施上运行，因此你不需要担心底层平台。
- en: '![09-10](../../OEBPS/Images/09-10.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![09-10](../../OEBPS/Images/09-10.png)'
- en: Figure 9.10 Cloud Run and Knative on Anthos architecture
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.10 Cloud Run 和 Knative on Anthos 架构
- en: Note For the purposes of this book, we will refer to Cloud Run (fully managed)
    as Cloud Run.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：为了本书的目的，我们将把 Cloud Run（完全管理）称为 Cloud Run。
- en: Although we know what the main differences are, you still might be wondering
    which service better fulfills your workload needs. Table 9.3 shows a little bit
    more detail on the differences.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们知道主要区别是什么，但你可能仍然想知道哪个服务更好地满足你的工作负载需求。表 9.3 展示了更多关于这些区别的细节。
- en: Cloud Run vs. Knative on Anthos
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud Run 与 Knative on Anthos 对比
- en: '| Feature | Cloud Run | Knative on Anthos |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| 功能 | Cloud Run | Knative on Anthos |'
- en: '| Price | Pay per use | GKE Anthos cost |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| 价格 | 按使用付费 | GKE Anthos 成本 |'
- en: '| Compute | CPU and memory limits | As per GKE cluster nodes capabilities (includes
    GPU) |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| 计算 | CPU 和内存限制 | 根据 GKE 集群节点的能力（包括 GPU）|'
- en: '| Isolation | Based on gVisor or other sandbox | Default GKE isolation |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| 隔离 | 基于 gVisor 或其他沙盒 | 默认 GKE 隔离 |'
- en: '| Scaling | 1,000 containers with extensible quota | As per GKE cluster |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| 缩放 | 1,000 个容器，具有可扩展配额 | 根据 GKE 集群 |'
- en: '| URL/SSL | URL and SSL autogenerated | Can configure custom domain |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| URL/SSL | 自动生成URL和SSL | 可以配置自定义域名 |'
- en: '| Domains | Custom domain can be created |  |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 域名 | 可以创建自定义域名 |  |'
- en: '| Network | Access to VPC via serverless VPC access | Direct access to VPC
    |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 网络 | 通过无服务器VPC访问访问VPC | 直接访问VPC |'
- en: '| Service mesh | Integrated with service mesh | Services connected to Istio
    Service Mesh |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| 服务网格 | 集成服务网格 | 连接到Istio服务网格的服务 |'
- en: '| Execution environment | Google infrastructure | GKE cluster |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| 执行环境 | Google基础设施 | GKE集群 |'
- en: So, when to choose each of the offerings? This very much depends on how much
    control you want to have over your application execution and whether you need
    custom hardware for GKE nodes. As an example, you might want to use GPUs to boost
    the performance of your ML pipelines. In such a case, Knative on Anthos is the
    way to go.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，何时选择每个提供项呢？这很大程度上取决于您希望对应用程序执行有多大的控制权，以及您是否需要为GKE节点定制硬件。例如，您可能想使用GPU来提升您的机器学习管道的性能。在这种情况下，选择在Anthos上运行的Knative是最佳选择。
- en: Summary
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Knative abstracts away the complexity of Kubernetes.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Knative抽象化了Kubernetes的复杂性。
- en: Workloads are portable to any Kubernetes cluster.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作负载可以移植到任何Kubernetes集群。
- en: Knative has multiple components that can address multiple use cases.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Knative拥有多个组件，可以解决多个用例。
- en: Eventing is the component that orchestrates events originating from various
    sources.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件是协调来自各种来源的事件的组件。
- en: Serving is the component that allows you to deploy container-based serverless
    workloads and serve them to users.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 托管是允许您部署基于容器的无服务器工作负载并将其提供给用户的组件。
- en: Serverless Kubernetes workloads can be deployed and served using Knative on
    Anthos.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无服务器Kubernetes工作负载可以使用Anthos上的Knative进行部署和托管。
- en: Versions of the application can be controlled using revisions.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序的版本可以通过修订版进行控制。
- en: Traffic to the application can be managed using revision parameters.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用修订版参数来管理应用程序的流量。
- en: You can get insights into your application using a rich, open source ecosystem
    of tools for monitoring, logging, and tracing.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用丰富的开源生态系统中的工具来监控、记录和跟踪，从而深入了解您的应用程序。
- en: '* * *'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^(1.)Knative Serving is explained in the next section of this chapter.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ^（1.）本章节的下一节将解释Knative Serving。
