- en: 5 Advanced topics on handling collections
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 集合处理的高级主题
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了
- en: Vectorizing your code, aka broadcasting
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量化你的代码，即广播
- en: Understanding subtyping rules for parametric types
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解参数化类型的子类型规则
- en: Integrating Julia with Python
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Julia 与 Python 集成
- en: Performing t-SNE dimensionality reduction
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行 t-SNE 维度缩减
- en: 'You already know from chapter 2 how to process vectors by using loops, the
    map function, and comprehensions. This chapter introduces another way that is
    commonly used in practice: broadcasting.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经从第 2 章中了解到如何使用循环、map 函数和列表推导来处理向量。本章介绍了实践中常用的一种方法：广播。
- en: Section 5.2 explains a more advanced topic related to rules of subtyping for
    parametric types that often raises questions from people learning Julia. This
    issue is closely linked with collections because, as you will learn in this chapter,
    types of the most common collections like arrays or dictionaries are parametric.
    For this reason, you need to learn this topic if you want to know how to correctly
    write method signatures that allow for collections as their arguments.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 5.2 节解释了与参数化类型的子类型规则相关的一个更高级的话题，这通常会引起学习 Julia 的人提出问题。这个问题与集合密切相关，因为，正如你将在本章中学到的，最常见的集合类型，如数组或字典，都是参数化的。因此，如果你想了解如何正确编写允许集合作为其参数的方法签名，你需要学习这个话题。
- en: Section 5.3 is devoted to integrating Julia with Python. You will learn that
    converting collections between the Julia format and the Python format is done
    automatically by the PyCall.jl package. Therefore, you can easily use existing
    Python code that performs operations on collections of data in your Julia projects.
    As an example of such integration, I will show you how to do t-SNE dimensionality
    reduction of data ([https://lvdmaaten.github.io/tsne/](https://lvdmaaten.github.io/tsne/))
    using the scikit-learn library from Python. Running the PyCall.jl examples requires
    having a properly configured Python installation on your computer. Therefore,
    please make sure to follow the environment setup instructions in appendix A.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 5.3 节专注于将 Julia 与 Python 集成。你将了解到在 Julia 格式和 Python 格式之间转换集合是由 PyCall.jl 包自动完成的。因此，你可以轻松地在你的
    Julia 项目中使用现有的执行数据集合操作的 Python 代码。作为一个这样的集成示例，我将向你展示如何使用 Python 的 scikit-learn
    库执行数据 t-SNE 维度缩减（[https://lvdmaaten.github.io/tsne/](https://lvdmaaten.github.io/tsne/)）。运行
    PyCall.jl 示例需要在你的计算机上有一个正确配置的 Python 安装。因此，请确保遵循附录 A 中的环境设置说明。
- en: 5.1 Vectorizing your code using broadcasting
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 使用广播向量化你的代码
- en: 'In the examples we worked through in chapters 2, 3, and 4, we used three ways
    to perform a repeated operation:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们第 2、3 和 4 章中讨论的示例中，我们使用了三种执行重复操作的方法：
- en: for loops iterating a collection
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历集合的 for 循环
- en: The map function applying a function to a collection
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数应用于集合的 map 函数
- en: Comprehension
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表推导
- en: These three syntaxes are powerful and flexible; however, many languages designed
    for data science provide ways to perform *vectorized operations*, also called
    *broadcasting*. In Julia, broadcasting is also supported. In this section, you
    will learn how to use it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种语法功能强大且灵活；然而，许多为数据科学设计的语言提供了执行*向量运算*的方法，也称为*广播操作*。在 Julia 中，广播操作也得到支持。在本节中，你将学习如何使用它。
- en: We will discuss how broadcasting works by going back to Anscombe’s quartet data.
    However, let’s start with an explanation of broadcasting on some toy examples.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过回到 Anscombe 的四重奏数据来讨论广播的工作原理。然而，让我们先从一些玩具示例上的广播解释开始。
- en: 5.1.1 Understanding syntax and meaning of broadcasting in Julia
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.1 理解 Julia 中广播的语法和意义
- en: 'An important design rule of the Julia language is that definitions of functions
    follow the rules of mathematics. You already saw this rule at work in chapter
    4, which showed that the multiplication operator * uses matrix multiplication
    rules. Therefore, the following code follows matrix multiplication rules:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 语言的 重要设计规则是函数的定义遵循数学规则。你已经在第 4 章中看到了这个规则在起作用，该章展示了乘法运算符 * 使用矩阵乘法规则。因此，以下代码遵循矩阵乘法规则：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The operation works as we multiply x, which is bound to a 1 × 3 matrix, and
    a three-element vector y, and in Julia vectors are always interpreted as columnar.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 该操作的效果就像我们乘以 x，它绑定到一个 1 × 3 的矩阵，以及一个三个元素的向量 y，在 Julia 中向量始终被解释为列向量。
- en: 'You might ask, then, how we should multiply two vectors elementwise, an operation
    known as a *Hadamard product* in mathematics. Clearly, this is not possible with
    just the * operator, as it does standard matrix multiplication:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，那么我们应该如何逐元素相乘两个向量，这在数学上被称为 *Hadamard product*。显然，仅使用 * 操作符是不可能的，因为它执行标准的矩阵乘法：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You get an error, as multiplication of a vector by a vector is not a valid
    mathematical operation. Instead, we need to broadcast the multiplication. In Julia,
    adding broadcasting to an operator is easy. You just prefix it with a dot (.),
    like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你会得到一个错误，因为向量与向量的乘法不是一个有效的数学运算。相反，我们需要进行广播。在 Julia 中，向操作符添加广播很容易。你只需在前面加上一个点（.），如下所示：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When a broadcasted operator like .* is used, Julia iterates elements of passed
    collections (in our case, vectors a and b), and applies the operator after the
    dot (in our case, *) elementwise. Therefore, in this case, the broadcasting result
    is the same as that produced by the following operations:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用像 .* 这样的广播操作符时，Julia 会迭代传入的集合的元素（在我们的例子中，是向量 a 和 b），并在点（在我们的例子中，是 *）之后逐元素应用操作符。因此，在这种情况下，广播的结果与以下操作产生的结果相同：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this map example, we are passing two collections (instead of only one, as
    we did before when I explained how map works). The passed function (*, in this
    case) is applied iteratively elementwise to those collections until one of them
    gets exhausted.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 map 示例中，我们正在传递两个集合（而不是像之前解释 map 的工作原理时那样只传递一个）。传入的函数（在这种情况下是 *,）会迭代地逐元素应用到这些集合上，直到其中一个被耗尽。
- en: 'In the comprehension example, it is worth commenting on the eachindex (a, b)
    expression, which produces the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解示例中，值得讨论 eachindex (a, b) 表达式，它会产生以下结果：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The eachindex function produces indices that could be used to index into both
    a and b arguments passed to it. In this case, these are just integers from 1 to
    3\. Therefore, you can index both a and b vectors with these values; for example,
    the following indexing expressions are valid: a[1], b[2], a[3], but a[0] or b[4]
    would not be valid as they are not in the range specified by Base.OneTo(3).'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: eachindex 函数产生可以用于索引传入的 a 和 b 参数的索引。在这种情况下，这些只是从 1 到 3 的整数。因此，你可以使用这些值索引 a 和
    b 向量；例如，以下索引表达式是有效的：a[1]，b[2]，a[3]，但 a[0] 或 b[4] 是无效的，因为它们不在 Base.OneTo(3) 指定的范围内。
- en: 'If the sizes of a and b do not match, we get an error:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 a 和 b 的大小不匹配，我们会得到一个错误：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This is an important difference from the map function, which does not use the
    eachindex function internally, but instead iterates collections until either of
    them is exhausted, as I have explained:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 map 函数的一个重要区别，map 函数内部不使用 eachindex 函数，而是迭代集合，直到其中一个被耗尽，正如我之前解释的那样：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Practical considerations of using map
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 map 的实际考虑
- en: If you pass multiple collections to the map function, you should always check
    beforehand to make sure that they have the same length. Most of the time, using
    collections of unequal lengths with the map function is a bug.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你向 map 函数传递多个集合，你应该事先检查它们是否有相同的长度。大多数情况下，使用与 map 函数长度不等的集合是一个错误。
- en: 'Broadcasting, like the eachindex function, checks to see if the dimensions
    of the passed objects match:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 广播，就像 eachindex 函数一样，会检查传入的对象的维度是否匹配：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 5.1.2 Expanding length-1 dimensions in broadcasting
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.2 广播中扩展长度为 1 的维度
- en: 'There is one exception to the rule that dimensions of all collections taking
    part in broadcasting must match. This exception states that single-element dimensions
    get expanded to match the size of the other collection by repeating the value
    stored in this single element:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 所有参与广播的集合的维度必须匹配的规则有一个例外。这个例外指出，单元素维度会通过重复该单元素中存储的值来扩展，以匹配其他集合的大小：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You might ask why a single-element dimension gets expanded. The reason is practical:
    in most cases, when your collection has a single element in a dimension, you want
    it to get expanded. Here is an example:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问为什么单元素维度会被扩展。原因是实用的：在大多数情况下，当你的集合在某个维度上只有一个元素时，你希望它被扩展。以下是一个例子：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here we are calculating a square of elements of a vector. Since 2 is a scalar,
    it is interpreted as having size 1 in each dimension. Most people agree that in
    such a case, dimension expansion should happen. You will see the same behavior
    in both Python and R.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在计算一个向量元素的平方。由于 2 是一个标量，它被解释为在每个维度上大小为 1。大多数人认为在这种情况下，维度扩展应该发生。你会在 Python
    和 R 中看到相同的行为。
- en: 'Now let’s consider a second example:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑第二个例子：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here we have created a multiplication table. The specified operation works because
    we have a 10-element vector with one column and 10 rows, and a 10-element matrix
    with one row and 10 columns. In this case, dimension expansion happens for both
    the left- and right-hand sides of the operation.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里创建了一个乘法表。指定的操作之所以有效，是因为我们有一个包含 10 个元素、一列和 10 行的向量，以及一个包含一行和 10 列的 10 元素矩阵。在这种情况下，操作的两边都发生了维度扩展。
- en: 'This technique is often used in practice to get a *Cartesian product* of all
    inputs. For instance, in part 2, you will learn that when you write "x" => sum
    in DataFrames.jl, you ask the package to apply the sum function to the column
    x of the data frame. A common scenario is that we want to apply several functions
    to several columns of a data frame. Using broadcasting, this can be written concisely
    as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术在实践中经常被用来获取所有输入的笛卡尔积。例如，在第二部分，你将了解到当你写下 "x" => sum in DataFrames.jl 时，你要求该包将求和函数应用于数据框的
    x 列。一个常见的场景是我们想要将多个函数应用于数据框的多个列。使用广播，这可以简洁地写成以下形式：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This expression asks for computation of sum, minimum, and maximum for columns
    x and y. The reason it works as expected is that we use the same pattern as in
    the multiplication table example. The ["x", "y"] expression creates a two-element
    vector (recall that vectors in Julia are columnar; in this case, the vector has
    one column and two rows), and the [sum minimum maximum] expression creates a matrix
    with one row and three columns.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式要求对 x 和 y 列进行求和、最小值和最大值的计算。它之所以按预期工作，是因为我们使用了与乘法表示例中相同的模式。["x", "y"] 表达式创建了一个包含两个元素的向量（回想一下，Julia
    中的向量是列式的；在这种情况下，向量有一列和两行），而 [sum minimum maximum] 表达式创建了一个包含一行和三列的矩阵。
- en: 'When we apply broadcasting to the => operator, we get a Cartesian product of
    arguments passed to it. A single column of the ["x", "y"] vector is repeated three
    times to match the number of columns in the [sum minimum maximum] matrix. Similarly,
    a single row of the [sum minimum maximum] matrix is repeated two times to match
    the number of rows in the ["x", "y"] vector. Therefore, the ["x", "y"] .=> [sum
    minimum maximum] operation produces the same result as the following more-verbose
    code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将广播应用于 => 操作符时，我们得到传递给它的参数的笛卡尔积。["x", "y"] 向量的单个列被重复三次以匹配 [sum minimum maximum]
    矩阵的列数。同样，[sum minimum maximum] 矩阵的单行被重复两次以匹配 ["x", "y"] 向量的行数。因此，["x", "y"] .=>
    [sum minimum maximum] 操作产生与以下更冗长的代码相同的结果：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Figure 5.1 illustrates the ["x", "y"] .=> [sum minimum maximum] operation.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 阐述了 ["x", "y"] .=> [sum minimum maximum] 操作。
- en: '![CH05_F01_Kaminski2](../Images/CH05_F01_Kaminski2.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![CH05_F01_Kaminski2](../Images/CH05_F01_Kaminski2.png)'
- en: Figure 5.1 The ["x", "y"] .=> [sum minimum maximum] operation results in a 2
    × 3 matrix because we pass a two-element vector and a one-row matrix with three
    columns as arguments.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 ["x", "y"] .=> [sum minimum maximum] 操作的结果是一个 2 × 3 矩阵，因为我们传递了一个包含两个元素的向量和一行三列的矩阵作为参数。
- en: 'You now know that you can add a dot (.) before any operator to broadcast it.
    What about functions that are not operators? Here you also use a dot (.), but
    this time, you suffix it after the function name. Here is an example:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在知道，你可以在任何操作符之前添加一个点 (.) 来广播它。那么对于不是操作符的函数呢？这里你也使用一个点 (.)，但这次，你在函数名之后附加它。这里有一个例子：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let me stress that just applying the abs function to a vector results in an
    error:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我强调一下，仅仅将 abs 函数应用于一个向量会导致错误：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The reason is the same as before: absolute value is mathematically defined
    for numbers but not defined for vectors. Of course, you can conveniently also
    apply broadcasting to a function taking multiple arguments. For example, the string
    function concatenates its arguments into a single string:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 原因与之前相同：绝对值在数学上对数字有定义，但对向量没有定义。当然，你也可以方便地将广播应用于接受多个参数的函数。例如，字符串函数将它的参数连接成一个单一的字符串：
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If we use broadcasting on this function, we get the following result:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对这个函数使用广播，我们会得到以下结果：
- en: '[PRE16]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here we expand the dimension of the scalar x to match the length of the 1:10
    range. This operation is quite common when we want to automatically generate names
    for objects—for example, columns of a data frame or filenames in a folder.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将标量 x 的维度扩展到与 1:10 范围的长度相匹配。当我们想要自动生成对象的名称时，这种操作相当常见——例如，数据框的列或文件夹中的文件名。
- en: 'It is important to highlight here that prefixing a dot before the operator
    or suffixing it to a function name is a fully general solution. It is not a hardcoded
    functionality of specific predefined operations. You can use broadcasting with
    any custom function. For instance:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里强调很重要，即在操作符之前加前缀点或在函数名后加后缀是一个完全通用的解决方案。这并不是特定预定义操作的硬编码功能。你可以使用广播与任何自定义函数。例如：
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here we define two methods for the f function. As you can see, by writing f.,
    we have automatically broadcasted it without having to define anything extra.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为f函数定义了两种方法。正如你所见，通过写入f.，我们自动广播了它，而无需定义任何额外的内容。
- en: 5.1.3 Protecting collections from being broadcasted over
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.3 保护集合不被广播
- en: Before we go back to our Anscombe’s quartet data, let me comment on one common
    case. What should we do if we do not want to broadcast a collection but want to
    force its reuse along all dimensions as if it were a scalar? To explain this issue,
    let me first introduce the in function.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们回到安斯康姆四重奏数据之前，让我先评论一个常见情况。如果我们不想广播一个集合，但想强制它在所有维度上重复使用，就像它是一个标量一样，我们应该怎么做？为了解释这个问题，让我首先介绍in函数。
- en: The in function
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: in函数
- en: 'The in function is used to check whether a certain value is contained in a
    collection. For example:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: in函数用于检查某个值是否包含在集合中。例如：
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As a convenience, in also supports infix notation:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，in也支持中缀表示法：
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You already know this infix notation, as it is used when defining iterations
    in for loops; see section 2.2 for an explanation of how these loops work.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道这种中缀表示法，因为它用于定义for循环中的迭代；请参阅第2.2节了解这些循环的工作原理。
- en: 'Now imagine you have a long vector of values and want to check whether they
    are contained in a vector. When you try the test without broadcasting, it does
    not work as you probably expect:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象你有一个长向量值，并想检查它们是否包含在向量中。当你尝试没有广播的测试时，它可能不会像你预期的那样工作：
- en: '[PRE20]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The problem is that the vector [1, 3, 5, 7, 9] is not an element of vector
    [1, 2, 3, 4], so you get false. For reference, let’s test the scenario where we
    put the [1, 3, 5, 7, 9] vector into the collection in which we look for it:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于向量[1, 3, 5, 7, 9]不是向量[1, 2, 3, 4]的元素，所以你得到false。为了参考，让我们测试将[1, 3, 5, 7,
    9]向量放入我们寻找它的集合中的场景：
- en: '[PRE21]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As expected, this time the in test returns true. Going back to the original
    test, note that broadcasting does not seem to work either:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，这次in测试返回true。回到原始测试，请注意，广播似乎也没有起作用：
- en: '[PRE22]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'How should we resolve this issue? The solution is to wrap the vector that we
    want to be reused as a whole with Ref. In this way, we will protect this object
    from being iterated over. Instead, it will be unwrapped from Ref and treated by
    broadcasting as if it were a scalar, and thus this value will be repeated to match
    the dimension of the other container:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该如何解决这个问题？解决方案是将我们想要整体重复使用的向量用Ref包装起来。这样，我们将保护这个对象不被迭代。相反，它将从Ref中解包，并像标量一样进行广播处理，因此这个值将被重复以匹配其他容器的维度：
- en: '[PRE23]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This time we get the expected result.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们得到了预期的结果。
- en: What is Ref in Julia?
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Julia中的Ref是什么？
- en: In Julia, when you write r = Ref(x), you create a zero-dimensional container
    storing the x value as its only element. You can retrieve the x object from the
    Ref value r by writing r[] (notice that we do not pass any indices in the indexing
    syntax, as the r object is zero-dimensional). The type is named Ref; you can think
    of it as if r is a reference to x.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在Julia中，当你写下r = Ref(x)时，你创建了一个零维容器，它将x值作为其唯一元素存储。你可以通过写入r[]从Ref值r中检索x对象（注意，我们在索引语法中不传递任何索引，因为r对象是零维的）。类型名为Ref；你可以把它想象成r是x的引用。
- en: Since Ref objects are zero-dimensional and store exactly one element, they have
    length 1 in every dimension. Therefore, if you use the r object in broadcasting,
    the x value stored in it is used in all required dimensions, following the expansion
    rules discussed in section 5.1.2.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Ref对象是零维的，并且存储了恰好一个元素，它们在每个维度上的长度都是1。因此，如果你在广播中使用r对象，它存储的x值将在所有所需的维度中使用，遵循第5.1.2节中讨论的扩展规则。
- en: 'In the output, note that Boolean true is printed as 1, and Boolean false is
    printed as 0. This choice of display allows for more convenient visual inspection
    of large matrices containing Boolean values. To see why this is useful, consider
    that we wanted to use the isodd function to check which entries of the multiplication
    table created in section 5.1.2 are odd:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，请注意布尔true被打印为1，布尔false被打印为0。这种显示选择允许更方便地检查包含布尔值的大型矩阵。为了了解为什么这很有用，考虑我们想要使用isodd函数来检查第5.1.2节中创建的乘法表中的哪些条目是奇数：
- en: '[PRE24]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this example, you can see that broadcasting operations can be chained together
    in a single expression. In this case, we broadcast both the multiplication * and
    the isodd function.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你可以看到广播操作可以在单个表达式中链接在一起。在这种情况下，我们广播了乘法*和isodd函数。
- en: 'For reference, let me show you how this matrix would be displayed if we changed
    its element type to Any (section 5.2 provides more details about type parameters):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了参考，让我展示一下如果我们将其元素类型更改为Any（第5.2节提供了更多关于类型参数的详细信息），这个矩阵将如何显示：
- en: '[PRE25]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This time, true and false are printed to avoid potential confusion with integers
    1 and 0 that could be potentially stored in this matrix, since its element type
    is Any. In my opinion, however, analyzing such a printout is less convenient than
    before.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，打印true和false以避免与可能存储在此矩阵中的整数1和0混淆，因为其元素类型是Any。然而，在我看来，分析这样的打印输出比以前不太方便。
- en: To practice what you have learned, try the following exercise, which is a common
    task when processing data.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了练习你所学的，尝试以下练习，这是处理数据时的常见任务。
- en: Exercise 5.1 The parse function can be used to convert a string into a number.
    For instance, if you want to parse a string as an integer, write parse(Int, "10")
    to get the integer 10. Assume you are given a vector of strings ["1", "2", "3"].
    Your task is to create a vector of integers by parsing the strings contained in
    the given vector.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 练习5.1：parse函数可以用来将字符串转换为数字。例如，如果你想将字符串解析为整数，写parse(Int, "10")以获取整数10。假设你被给了一个包含字符串["1",
    "2", "3"]的向量。你的任务是创建一个包含这些字符串中数字的整数向量。
- en: 5.1.4 Analyzing Anscombe’s quartet data using broadcasting
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.4 使用广播分析安斯康姆四重奏数据
- en: 'Now we are ready to go back to our Anscombe’s quartet data. Let’s initialize
    the aq variable first, as we did in listing 4.1:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备回到我们的安斯康姆四重奏数据。首先，让我们初始化aq变量，就像我们在列表4.1中做的那样：
- en: '[PRE26]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We will reproduce two tasks we performed in section 4.1 using broadcasting:
    calculation of the mean of every variable and calculation of the coefficient of
    determination.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用广播来重现我们在4.1节中执行的两个任务：计算每个变量的平均值和计算确定系数。
- en: 'We first start with calculating the mean of the columns of the aq matrix. We
    want to apply the mean function to every column of the matrix. When thinking about
    how to do it, we notice that we need to broadcast the mean function over a collection
    of columns of aq. Fortunately, we know that the eachcol function gives us such
    a collection; therefore, we can write this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从计算aq矩阵的列平均值开始。我们想要将平均值函数应用于矩阵的每一列。在思考如何做到这一点时，我们注意到我们需要将平均值函数广播到aq的列集合上。幸运的是，我们知道eachcol函数给我们提供了这样的集合；因此，我们可以写出这个：
- en: '[PRE27]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Note the dot (.) after mean, which means that we want to broadcast this function
    over the collection produced by eachcol(aq). If we were to forget to write the
    dot, we would get the following result:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意mean后面的点（.），这意味着我们想要将此函数广播到由eachcol(aq)产生的集合上。如果我们忘记写点，我们会得到以下结果：
- en: '[PRE28]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Since eachcol(aq) is a collection of eight vectors constituting columns of the
    aq matrix, the mean function computes their mean; that is, the function takes
    a sum of these eight vectors and divides it by 8\. As a result, we get a vector
    of the means of the aq matrix’s rows (note that the result has 11 elements, which
    is the number of rows of the aq matrix), and we want to compute the means of its
    columns.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于eachcol(aq)是由构成aq矩阵列的八个向量组成的集合，因此平均值函数计算它们的平均值；也就是说，该函数将这八个向量的总和除以8。因此，我们得到一个包含aq矩阵行平均值的向量（注意结果有11个元素，这是aq矩阵的行数），我们想要计算其列的平均值。
- en: 'As a second application, let’s use broadcasting to rewrite the function calculating
    the coefficient of determination. Let me remind you of the original implementation:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第二个应用，让我们使用广播来重写计算确定系数的函数。让我提醒你原始实现：
- en: '[PRE29]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If we wanted to use broadcasting, we could write this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要使用广播，我们可以这样写：
- en: '[PRE30]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you can see, we change formulas for SS_res and SS_tot. In both cases, we
    use the dot (.) twice. For example, in (y .- prediction) .^ 2, we are broadcasting
    both subtraction and exponentiation.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们改变了SS_res和SS_tot的公式。在两种情况下，我们都使用了点（.）两次。例如，在(y .- prediction) .^ 2中，我们广播了减法和指数运算。
- en: Efficiency of broadcasting in Julia
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Julia中广播的效率
- en: An important feature of Julia that differentiates it from R and Python is that
    if it encounters several broadcasting operations chained together in a single
    expression, it performs the operation in one pass without allocating any intermediate
    objects. This feature, called *broadcast fusion*, greatly improves the performance
    of complex broadcasted operations.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Julia的一个重要特性，使其与R和Python区分开来的是，如果它在单个表达式中遇到多个连续的广播操作，它会一次性执行操作而不分配任何中间对象。这个特性被称为*广播融合*，大大提高了复杂广播操作的效率。
- en: Broadcast fusion can be efficient because, as explained in chapter 1, Julia
    compiles your program as a whole, so when a broadcasting operation is encountered,
    the compiler can fully optimize the native code that gets executed. This is different
    from R and Python, where support for broadcasted operations is usually implemented
    in languages like C and stored in precompiled binaries for a limited predefined
    set of functions.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 广播融合可以很高效，因为，如第1章所述，Julia将你的程序作为一个整体编译，所以当遇到广播操作时，编译器可以完全优化要执行的本地代码。这与R和Python不同，在R和Python中，对广播操作的支持通常是用C语言等实现的，并存储在预编译的二进制文件中，用于有限的预定义函数集。
- en: If you would like to learn more about how this feature of the Julia language
    works, I recommend you start with “Extensible Broadcast Fusion” by Matt Bauman
    ([http://mng.bz/G1OR](http://mng.bz/G1OR)).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于Julia语言这个功能如何工作的信息，我建议你从Matt Bauman的“可扩展的广播融合”（[http://mng.bz/G1OR](http://mng.bz/G1OR)）开始阅读。
- en: 'By now you know four ways of iteratively applying operations to elements of
    collections:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你已经知道了四种迭代应用操作到集合元素的方法：
- en: Using for loops
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用for循环
- en: Using comprehensions
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用列表推导式
- en: Using the map function (and other similar higher-order functions that take functions
    as their arguments)
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用map函数（以及其他类似的高阶函数，它们将函数作为它们的参数）
- en: Using broadcasting
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用广播
- en: You’re probably asking yourself in which cases you should use which option.
    Fortunately, this is mostly a matter of convenience and code readability. In your
    projects, use the option that is easiest for you to use and that results in the
    most readable code. One of the great features of Julia is that all these options
    are fast. Most of the time, you won’t sacrifice performance by choosing one over
    the other.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能正在问自己在哪些情况下应该使用哪个选项。幸运的是，这主要是一个方便性和代码可读性的问题。在你的项目中，使用对你来说最容易使用且能产生最易读代码的选项。Julia的一个伟大特性是，所有这些选项都很快。大多数时候，你不会因为选择其中一个而牺牲性能。
- en: I say “most of the time” because exceptions to this rule exist. Apart from the
    differences already discussed in this section, one of the most important exceptions
    is that if you use a for loop or map function, you can optionally make the operation
    take advantage of all cores of your processor by using the Threads module or ThreadsX.jl
    package. The ability to easily support multithreaded execution of your code is
    a feature that distinguishes Julia from R and Python. Part 2 presents examples
    of how to take advantage of multithreading in your projects.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我说“大多数时候”，因为存在这个规则的例外。除了本节中已经讨论的差异之外，最重要的例外之一是，如果你使用for循环或map函数，你可以选择使用Threads模块或ThreadsX.jl包来使操作利用处理器上的所有核心。轻松支持代码的多线程执行是区分Julia与R和Python的一个特性。第二部分将展示如何在项目中利用多线程的例子。
- en: 5.2 Defining methods with parametric types
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 定义具有参数类型的函数
- en: In this section, we will write our own function that will calculate the covariance
    of two vectors. As you might guess, the cov function in the Statistics module
    does this calculation, but it is instructive to write this function as an exercise.
    Our objective is to write a function that takes two vectors holding real values
    and returns the covariance. The crucial part of my requirement is that the function
    should take as parameters two vectors that hold real values. In this section,
    you will learn how to specify such a restriction.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写自己的函数来计算两个向量的协方差。正如你可能猜到的，Statistics模块中的cov函数执行这个计算，但将此函数作为练习来编写是有教育意义的。我们的目标是编写一个函数，该函数接受包含实数值的两个向量作为参数，并返回协方差。我的要求的关键部分是函数应该接受包含实数值的两个向量作为参数。在本节中，你将学习如何指定此类限制。
- en: Defining functions that have complex type restrictions is challenging. Fortunately,
    in most of your code, you will not need to write your own methods and so won’t
    require an advanced understanding of this topic. However, since packages written
    in Julia use these features heavily, you must know these concepts to be able to
    understand which arguments the functions provided by these packages accept and
    how to read error messages produced by Julia if you make a mistake when using
    them.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 定义具有复杂类型限制的函数具有挑战性。幸运的是，在你的大多数代码中，你不需要编写自己的方法，因此不需要对这一主题有深入的了解。然而，由于用Julia编写的包大量使用这些功能，你必须了解这些概念，以便能够理解这些包提供的函数接受哪些参数，以及在使用它们时如何阅读Julia产生的错误消息。
- en: 5.2.1 Most collection types in Julia are parametric
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.1 Julia中大多数集合类型都是参数化的
- en: 'In chapter 3, you learned about Julia’s type system and how to define methods.
    In this chapter, we discuss working with collections. You probably have noticed
    that most types representing collections are *parametric*: they specify the type
    of data that can be stored in them. Here are some examples:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3章中，你学习了Julia的类型系统和如何定义方法。在本章中，我们将讨论与集合一起工作。你可能已经注意到，大多数表示集合的类型都是*参数化的*：它们指定了可以存储在其中的数据类型。以下是一些示例：
- en: '[PRE31]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here, we create an empty vector and an empty dictionary. They can store any
    value, which is signaled by the Any parameter, so they work just like lists and
    dictionaries in Python.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个空向量和空字典。它们可以存储任何值，这由Any参数表示，因此它们就像Python中的列表和字典一样工作。
- en: 'With vectors, you can specify their element type by prefixing the opening square
    bracket with the type:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于向量，你可以通过在开方括号前加上类型来指定它们的元素类型：
- en: '[PRE32]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Note that although we enter 1, 2, and 3 as integers, they get converted to
    Float64 because we request that the resulting vector should contain such values.
    Similarly, for the dictionary, we can write this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管我们输入了1、2和3作为整数，但它们被转换为Float64，因为我们要求结果向量应包含此类值。同样，对于字典，我们可以这样写：
- en: '[PRE33]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'As you can see, we force the conversion of both keys and values to UInt8 and
    Float64 types, respectively. As a side note, observe that Julia prints unsigned
    integers with the 0x prefix, and these values are using hexadecimal representation.
    For example, let’s specify an explicit conversion from Int to UInt32:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们强制将键和值分别转换为UInt8和Float64类型。作为旁注，请注意Julia使用0x前缀打印无符号整数，这些值使用十六进制表示。例如，让我们指定从Int到UInt32的显式转换：
- en: '[PRE34]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As a last example, we create a vector that can store any Real value:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后的例子，我们创建了一个可以存储任何Real值的向量：
- en: '[PRE35]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Notice that this time, no conversion of stored values happens, as Int, Float64
    and UInt8 types are subtypes of Real (as you know from chapter 3). To check this,
    run typeof.(Real[1, 1.0, 0x3]), and you will get an [Int64, Float64, UInt8] vector
    as a result.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这次，没有发生存储值的转换，因为Int、Float64和UInt8类型是Real类型的子类型（正如你在第3章所知）。要检查这一点，请运行typeof.(Real[1,
    1.0, 0x3])，你将得到一个[Int64, Float64, UInt8]向量作为结果。
- en: 'Before we move forward, let me introduce the eltype function. This function
    allows us to extract the type of elements that a collection can store. Here are
    a few examples:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续前进之前，让我介绍一下eltype函数。此函数允许我们提取集合可以存储的元素类型。以下是一些示例：
- en: '[PRE36]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'For vectors, we just get the type. For dictionaries, we get a Pair type since,
    as already discussed, in Julia the key-value combination has a Pair type:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于向量，我们只得到类型。对于字典，我们得到一个Pair类型，因为，如前所述，在Julia中键值组合有一个Pair类型：
- en: '[PRE37]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 5.2.2 Rules for subtyping of parametric types
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.2 参数化类型的子类型规则
- en: Having seen these examples, we are now ready to go back to our task of defining
    a function that takes two vectors holding real values and returns their covariance.
    We want the function to accept any vector.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 看过这些例子后，我们现在准备回到我们的任务，即定义一个函数，该函数接受两个包含实数值的向量并返回它们的协方差。我们希望该函数接受任何向量。
- en: You already know from chapter 3 that we should use the AbstractVector type.
    We also want the function to accept only real values in these vectors. Similarly,
    we know that the element type of these vectors should be Real.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你从第 3 章中已经知道我们应该使用 AbstractVector 类型。我们还希望函数只接受这些向量中的实数值。同样，我们知道这些向量的元素类型应该是
    Real。
- en: 'So, our first assumption is that AbstractVector{Real} should be the right type
    to use. Let’s check this assumption by using the isa test discussed in chapter
    3:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的第一个假设是 AbstractVector{Real} 应该是正确的类型。让我们通过使用第 3 章中讨论的 isa 测试来验证这个假设：
- en: '[PRE38]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We see that, as expected, the type of [1, 2, 3] is a subtype of AbstractVector{Int},
    but surprisingly, it is not a subtype of AbstractVector{Real}. This behavior of
    parameters in Julia is called *invariant* in computer science: although Int is
    a subtype of Real, AbstractVector{Int} is not a subtype of AbstractVector{Real}.
    You can find an in-depth discussion of this design decision in the “Parametric
    Composite Types” section of the Julia Manual ([http://mng.bz/z5EX](http://mng.bz/z5EX)).'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，正如预期的那样，[1, 2, 3] 的类型是 AbstractVector{Int} 的子类型，但令人惊讶的是，它不是 AbstractVector{Real}
    的子类型。这种 Julia 中参数的行为在计算机科学中被称为 *不变性*：尽管 Int 是 Real 的子类型，但 AbstractVector{Int}
    不是 AbstractVector{Real} 的子类型。你可以在 Julia 手册的“参数复合类型”部分找到对这个设计决策的深入讨论（[http://mng.bz/z5EX](http://mng.bz/z5EX)）。
- en: A vector whose type is a subtype of AbstractVector{Real} must allow any Real
    value to be stored in it. You saw the vector Real[1, 1.0, 0x3] in section 5.2.1,
    and we checked there that, indeed, its elements had different types. Hence, for
    example, Vector{Real} cannot be stored in memory as efficiently as Vector{Int}.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 类型为 AbstractVector{Real} 子类型的向量必须允许存储任何实数值。你在 5.2.1 节中看到了向量 Real[1, 1.0, 0x3]，并且我们在那里检查了确实其元素有不同的类型。因此，例如，Vector{Real}
    不能像 Vector{Int} 一样高效地存储在内存中。
- en: 'I will now focus on explaining how to specify a vector type whose element type
    is a subtype of Real. The syntax for this case is AbstractVector{<:Real}. The
    <: sequence means the element type of the vector can be any subtype of Real, not
    just Real. Equivalently, we could have used the where keyword that we already
    discussed in chapter 3:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '我现在将专注于解释如何指定元素类型是 Real 子类型的向量类型。这种情况的语法是 AbstractVector{<:Real}。<: 序列表示向量的元素类型可以是
    Real 的任何子类型，而不仅仅是 Real。等价地，我们也可以使用在第 3 章中讨论过的 where 关键字：'
- en: '[PRE39]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The AbstractVector{T} where T<:Real form is encountered less often, but it can
    be useful if we want to refer to the variable T, which stores the element type
    of our vector, later in the code.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: AbstractVector{T} 其中 T<:Real 的形式遇到得较少，但如果我们想在代码中稍后引用存储向量元素类型的变量 T，它可能是有用的。
- en: 'To summarize our discussion, let me give several specific examples of types
    and their meanings. The example is built around a Vector type:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结我们的讨论，让我给出几个类型及其含义的具体例子。这个例子是围绕 Vector 类型构建的：
- en: Int is a subtype of Real. This is because Real is an abstract concept referring
    to multiple numeric types; similarly, Real is a subtype of Any.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Int 是 Real 的子类型。这是因为 Real 是一个指代多个数值类型的抽象概念；同样，Real 也是 Any 的子类型。
- en: Vector{Int} is not a subtype of Vector{Real}. This is because both Vector{Int}
    and Vector{Real}, as you have seen in this section, can have instances. One is
    a container that can store only integers. The other is a container that can store
    any Real values. These are two concrete and different containers. Neither is a
    subtype of the other.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vector{Int} 不是 Vector{Real} 的子类型。这是因为，正如你在本节中看到的，Vector{Int} 和 Vector{Real}
    都可以有实例。一个是只能存储整数的容器。另一个是可以存储任何实数值的容器。这两个是两个具体且不同的容器。没有一个是从另一个派生的子类型。
- en: Vector{<:Real}, or, equivalently, Vector{T} where T<:Real, is a way to describe
    a union of all containers that can store Real values. Vector{<:Real} is an abstract
    concept referring to multiple containers. Both Vector{Int} and Vector{Real} are
    subtypes of Vector{<:Real}.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vector{<:Real}，或者等价地，Vector{T} 其中 T<:Real，是一种描述可以存储实数值的所有容器的联合的方式。Vector{<:Real}
    是一个抽象概念，指代多个容器。Vector{Int} 和 Vector{Real} 都是 Vector{<:Real} 的子类型。
- en: 'Vector, Vector{<:Any}, and Vector{T} where T are each a way to describe a union
    of all containers having a Vector type without restricting their element type.
    This is different from Vector{Any}, which is a concrete type that can have an
    instance: it is a vector in which you can store any value. Note, though, that
    Vector{Any} is a subtype of Vector{<:Any}, which is in turn a subtype of Any (as
    every type in Julia is a subtype of Any).'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vector、Vector{<:Any} 和 Vector{T}（其中 T 是类型）都是描述所有具有 Vector 类型但没有限制其元素类型的容器联合的方式。这与
    Vector{Any} 不同，Vector{Any} 是一个具体类型，它可以有一个实例：它是一个可以存储任何值的向量。请注意，尽管 Vector{Any}
    是 Vector{<:Any} 的子类型，而 Vector{<:Any} 又是 Any 的子类型（因为 Julia 中的每个类型都是 Any 的子类型）。
- en: Figure 5.2 illustrates these relationships.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 展示了这些关系。
- en: '![CH05_F02_Kaminski2](../Images/CH05_F02_Kaminski2.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![CH05_F02_Kaminski2](../Images/CH05_F02_Kaminski2.png)'
- en: Figure 5.2 In this example of subtype relationships, a box represents a type.
    If a type is a subtype of a given type, it is put inside the box. Note that Vector{Int}
    is not a subtype of Vector{Real}, although Int is a subtype of Real. Similarly,
    Vector{Real} is not a subtype of Vector{Any}, although Real is a subtype of Any.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 在这个子类型关系的示例中，一个框代表一个类型。如果一个类型是给定类型的子类型，它就被放在框内。请注意，尽管 Int 是 Real 的子类型，但
    Vector{Int} 不是 Vector{Real} 的子类型。同样，尽管 Real 是 Any 的子类型，但 Vector{Real} 也不是 Vector{Any}
    的子类型。
- en: 5.2.3 Using subtyping rules to define the covariance function
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.3 使用子类型规则定义协方差函数
- en: 'So, how should we define our covariance function? Here is a full method:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们应该如何定义我们的协方差函数？这里是一个完整的方法：
- en: '[PRE40]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: ❶ Section 3.4 explains how the @assert macro works. Section 2.3.1 explains how
    combining several logical conditions works.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 第 3.4 节解释了 @assert 宏的工作方式。第 2.3.1 节解释了如何组合几个逻辑条件。
- en: 'In the preceding code, we use broadcasting to compute the covariance. Let’s
    first check that the ourcov function works correctly:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用广播来计算协方差。让我们首先检查我们的`ourcov`函数是否正确工作：
- en: '[PRE41]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'It looks like it does work as required. Note that in the code, we mix a range
    of integers with a vector of floating-point values, and they get accepted and
    are handled correctly. However, if we pass a collection whose element type is
    not a subtype of Real, the function will fail, even if we do not change the specific
    values stored by the collection:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来确实按预期工作。请注意，在代码中，我们混合了一系列整数和一个浮点数值向量，它们被接受并正确处理。然而，如果我们传递一个元素类型不是 Real 子类型的集合，即使我们不更改集合存储的具体值，函数也会失败：
- en: '[PRE42]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This time, the function fails, as our second argument is a vector whose element
    type is Any, and Any is not a subtype of Real.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，函数失败了，因为我们的第二个参数是一个元素类型为 Any 的向量，而 Any 不是 Real 的子类型。
- en: 'Before I wrap up this section, let me answer one common question. What if you
    have a container with a wide element type (for example, Any) and want to narrow
    it down to the element type of data stored in a collection? Fortunately, this
    is easy. You just need to broadcast the identity function (which returns its argument)
    over a collection. Then the broadcasting mechanisms that Julia has implemented
    will perform narrowing of the element type for you. Here you can see it in action:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在我总结这一节之前，让我回答一个常见问题。如果你有一个包含宽元素类型（例如，Any）的容器，并且想要将其缩小到存储在集合中的元素类型，该怎么办？幸运的是，这很简单。你只需要将恒等函数（返回其参数）广播到集合上。然后，Julia
    实现的广播机制将为你执行元素类型的缩小。这里你可以看到它是如何工作的：
- en: '[PRE43]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 5.3 Integrating with Python
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3 与 Python 集成
- en: In this section, you will learn how to integrate Julia with Python when working
    with collections. You will see that conversion between collection types in Julia
    and in Python is done automatically. Knowing how to use Python code from Julia
    is useful, as in larger projects, you might need to build software from components
    that were developed using both technologies. I have chosen the example that we
    will use to additionally reinforce your understanding of how you can work with
    arrays in Julia and use broadcasting.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何在处理集合时将 Julia 与 Python 集成。你会发现 Julia 和 Python 之间的集合类型转换是自动完成的。知道如何在
    Julia 中使用 Python 代码是有用的，因为在较大的项目中，你可能需要构建使用这两种技术开发的软件组件。我选择了我们将使用的示例，以进一步强化你对如何在
    Julia 中处理数组和使用广播的理解。
- en: I have chosen to present integration with Python, as it is currently a very
    popular language. In chapter 10, you will learn how Julia and R can be integrated.
    If you would like to call C or Fortran code from Julia, refer to the Julia manual
    at [http://mng.bz/091l](http://mng.bz/091l). Bindings to other languages are provided
    by packages—for example, to C++ with Cxx.jl ([https://github.com/JuliaInterop/Cxx.jl](https://github.com/JuliaInterop/Cxx.jl))
    or to Java with JavaCall.jl ([https://github.com/JuliaInterop/JavaCall.jl](https://github.com/JuliaInterop/JavaCall.jl)).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择展示与 Python 的集成，因为目前它是一种非常流行的语言。在第 10 章中，您将学习如何集成 Julia 和 R。如果您想从 Julia 调用
    C 或 Fortran 代码，请参阅 Julia 手册 [http://mng.bz/091l](http://mng.bz/091l)。其他语言的绑定由包提供——例如，使用
    Cxx.jl ([https://github.com/JuliaInterop/Cxx.jl](https://github.com/JuliaInterop/Cxx.jl))
    与 C++ 集成或使用 JavaCall.jl ([https://github.com/JuliaInterop/JavaCall.jl](https://github.com/JuliaInterop/JavaCall.jl))
    与 Java 集成。
- en: 5.3.1 Preparing data for dimensionality reduction using t-SNE
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.1 使用 t-SNE 进行降维前的数据准备
- en: As an example application of integrating Julia with Python, I will show you
    how to perform dimensionality reduction using the t-SNE algorithm. *t-Distributed
    Stochastic Neighbor Embedding* (*t-SNE*) is a statistical method for giving each
    data point belonging to a high-dimensional space a location in a low-dimensional
    space ([https://lvdmaaten.github.io/tsne/](https://lvdmaaten.github.io/tsne/)).
    In this case, we will use two-dimensional space as a target since it can then
    be easily visualized in a plot. The t-SNE performs a mapping in such a way that
    similar objects in the high-dimensional source space are nearby points in the
    low-dimensional target space, and dissimilar objects are distant points.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 Julia 与 Python 集成的示例应用，我将向您展示如何使用 t-SNE 算法进行降维。*t-Distributed Stochastic
    Neighbor Embedding* (*t-SNE*) 是一种统计方法，它为属于高维空间中的每个数据点在低维空间中分配一个位置 ([https://lvdmaaten.github.io/tsne/](https://lvdmaaten.github.io/tsne/))。在这种情况下，我们将使用二维空间作为目标，因为它可以很容易地在图中可视化。t-SNE
    以一种方式执行映射，使得高维源空间中的相似对象在低维目标空间中是邻近的点，而不相似的对象是远离的点。
- en: 'We start with generating random data in a five-dimensional space that we will
    later want to embed in two dimensions:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从在五维空间中生成随机数据开始，我们稍后希望将其嵌入到二维空间中：
- en: '[PRE44]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: First, we use the Random.seed!(1234) command to set the seed of the random number
    generator in Julia. The name of the function is suffixed with ! because it modifies
    the state of the global random number generator. This will ensure that the data
    I show you is the same as the data you obtain if you run this code under the same
    version of Julia. If you want to get different random numbers generated each time
    you run this code, skip setting the seed of the random number generator.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用 Julia 中的 Random.seed!(1234) 命令来设置随机数生成器的种子。函数名称后缀为 ! 是因为它会修改全局随机数生成器的状态。这将确保我向您展示的数据与您在相同版本的
    Julia 下运行此代码时获得的数据相同。如果您希望在每次运行此代码时都生成不同的随机数，请跳过设置随机数生成器的种子。
- en: Next, using the randn function, we generate two matrices of 100 rows and five
    columns. The values stored in them are randomly sampled from standard normal distribution.
    Using broadcasting, we subtract 1 from all entries of the cluster1 matrix and
    add 1 to all entries of the cluster2 matrix. In this way, we separate points stored
    in both matrices. Data from cluster 1 is mostly negative, while in cluster 2,
    we have mostly positive entries.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用 randn 函数，我们生成两个 100 行 5 列的矩阵。它们存储的值是从标准正态分布中随机抽取的。通过广播，我们从 cluster1 矩阵的所有条目中减去
    1，并将 1 添加到 cluster2 矩阵的所有条目中。这样，我们就将两个矩阵中存储的点分离开了。来自 cluster 1 的数据大多是负数，而在 cluster
    2 中，我们大多数条目是正数。
- en: 'Now, we vertically concatenate these matrices by using the vcat function to
    create a single matrix of 200 rows and five columns. We call the matrix data5,
    as it has five columns:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们使用 vcat 函数垂直连接这些矩阵，创建一个 200 行 5 列的单个矩阵。我们称这个矩阵为 data5，因为它有五个列：
- en: '[PRE45]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We will want to see if, after using the t-SNE algorithm to perform dimensionality
    reduction to two dimensions, we will be able to visually confirm that these two
    clusters are indeed separated.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将想要查看，在使用 t-SNE 算法将维度降低到二维后，我们是否能够通过视觉确认这两个簇确实被分开了。
- en: 5.3.2 Calling Python from Julia
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.2 从 Julia 调用 Python
- en: 'First, we need to load the required Python package by using the pyimport function
    from the PyCall.jl package:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要使用 PyCall.jl 包中的 pyimport 函数加载所需的 Python 包：
- en: '[PRE46]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This operation could fail on your machine. If it does, the reason might be
    that either Python is not properly configured or sklearn from Python is not installed.
    You should receive information telling which operations you need to perform to
    fix this issue. If sklearn from Python is not installed, the following code is
    a standard way to add it:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作可能在你的机器上失败。如果发生这种情况，原因可能是Python配置不正确或Python中的sklearn未安装。你应该会收到有关需要执行哪些操作来修复此问题的信息。如果Python中的sklearn未安装，以下代码是添加它的标准方法：
- en: '[PRE47]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: However, under some operating system configurations, this operation might fail.
    See the following sidebar for more options.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些操作系统配置下，此操作可能会失败。请参阅以下侧边栏以获取更多选项。
- en: Using the PyCall.jl package to configure integration with Python
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 使用PyCall.jl包配置与Python的集成
- en: The PyCall.jl package allows you to interoperate with Python from the Julia
    language. It allows you to import Python modules from Julia, call Python functions
    (with automatic conversion of types), and even evaluate entire code blocks of
    Python code from Julia.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: PyCall.jl包允许你从Julia语言与Python进行交互。它允许你从Julia导入Python模块，调用Python函数（类型自动转换），甚至可以从Julia中评估整个Python代码块。
- en: When you install PyCall.jl, then by default, on Mac and Windows systems, it
    will install a minimal Python distribution that is private to Julia. On GNU/Linux
    systems, the package will use the Python installation available in your PATH.
    Alternatively, you can use a different version of Python than the default, as
    explained on the PyCall.jl GitHub page ([http://mng.bz/vXo1](http://mng.bz/vXo1)).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当你安装PyCall.jl时，默认情况下，在Mac和Windows系统上，它将为Julia安装一个私有的最小Python分布。在GNU/Linux系统上，该包将使用你的PATH中可用的Python安装。或者，你可以使用PyCall.jl
    GitHub页面（[http://mng.bz/vXo1](http://mng.bz/vXo1)）上解释的不同版本的Python。
- en: If you are on Mac or Windows and use the default configuration of Python, you
    can use the Conda.jl package to add packages to the Python distribution private
    to Julia. If you are on GNU/Linux, then, by default, you should be able to add
    packages by using the standard tools you use in your Python installation.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Mac或Windows操作系统，并且使用Python的默认配置，你可以使用Conda.jl包向Julia的Python分布中添加包。如果你使用GNU/Linux系统，那么默认情况下，你应该能够通过使用你在Python安装中使用的标准工具来添加包。
- en: Unfortunately, unlike with Julia, which has a built-in standard package manager,
    properly configuring a Python environment and installing packages on your machine
    can sometimes be challenging. The PyCall.jl package maintainers have tried to
    make this process work automatically in most cases. However, if it fails, I recommend
    you refer to the PyCall.jl ([https://github.com/JuliaPy/PyCall.jl](https://github.com/JuliaPy/PyCall.jl))
    and Conda.jl ([https://github.com/JuliaPy/Conda.jl](https://github.com/JuliaPy/Conda.jl))
    pages for more detailed instructions on resolving them.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，与Julia内置的标准包管理器不同，在机器上正确配置Python环境并安装包有时可能具有挑战性。PyCall.jl包维护者已尝试在大多数情况下使此过程自动运行。但是，如果失败，我建议你参考PyCall.jl（[https://github.com/JuliaPy/PyCall.jl](https://github.com/JuliaPy/PyCall.jl)）和Conda.jl（[https://github.com/JuliaPy/Conda.jl](https://github.com/JuliaPy/Conda.jl)）页面，以获取解决这些问题的更详细说明。
- en: 'After importing sklearn.manifold from Python and binding it to the manifold
    variable, we are ready to use the t-SNE algorithm. We store the result in the
    data2 variable, as the resulting matrix has two columns after dimensionality reduction:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在从Python导入sklearn.manifold并将其绑定到manifold变量后，我们就准备好使用t-SNE算法了。我们将结果存储在data2变量中，因为降维后的结果矩阵有两列：
- en: '[PRE48]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If you refer to the examples of using the t-SNE algorithm in the scikit-learn
    documentation ([http://mng.bz/K0oZ](http://mng.bz/K0oZ)), you can see that using
    Python in Julia is essentially transparent:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你参考了scikit-learn文档中关于使用t-SNE算法的示例（[http://mng.bz/K0oZ](http://mng.bz/K0oZ)），你会发现使用Python在Julia中几乎是透明的：
- en: You can call Python functions in exactly the same way as you would call them
    in Python. In particular, you can use dot (.) to refer to objects in the same
    way as in Python.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以以与在Python中调用它们完全相同的方式调用Python函数。特别是，你可以使用点（.）以与Python中相同的方式引用对象。
- en: An automatic conversion occurs between Julia and Python objects, so you do not
    have to think about it.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Julia和Python对象之间发生自动转换，因此你无需考虑它。
- en: This level of integration means that using Python from Julia requires little
    mental effort for a developer. From my experience, most of the time, fixing the
    syntax differences is enough if you want to port some Python code to Julia, and
    things just work. For example, in Julia, string literals require double quotes
    ("), while typically in Python, a single quote (') is used.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这种集成级别意味着从Julia中使用Python对开发者来说几乎不需要动脑筋。根据我的经验，大多数时候，如果你想把一些Python代码移植到Julia，只需修复语法差异就足够了，而且一切都会正常工作。例如，在Julia中，字符串字面量需要双引号(")，而在Python中通常使用单引号(')。
- en: This section presented only a minimal example of integrating Julia with Python.
    If you would like to learn more details, such as possible integration options,
    check the PyCall.jl package website at [https://github.com/JuliaPy/PyCall.jl](https://github.com/JuliaPy/PyCall.jl).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 本节仅展示了将Julia与Python集成的最小示例。如果你想了解更多细节，例如可能的集成选项，请查看PyCall.jl包网站[https://github.com/JuliaPy/PyCall.jl](https://github.com/JuliaPy/PyCall.jl)。
- en: 5.3.3 Visualizing the results of the t-SNE algorithm
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.3 t-SNE算法结果的可视化
- en: 'To conclude our analysis, let’s plot the data2 matrix by using a scatterplot.
    We will color the first 100 points, representing cluster 1, with a different fill
    color than the last 100 points that are from cluster 2:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结我们的分析，让我们使用散点图来绘制data2矩阵。我们将用不同的填充颜色来着色前100个点，代表簇1，而最后100个点来自簇2：
- en: '[PRE49]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In this code, note the [fill("black", 100); fill("gold", 100)] expression. First,
    using the fill function, we create two vectors storing 100 constant values representing
    colors we want to use. Next, inside square brackets, using the semicolon (;),
    we vertically concatenate these two vectors to create a 200-element vector that
    is passed as a color keyword argument to the scatter function.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，注意[fill("black", 100); fill("gold", 100)]表达式。首先，使用fill函数，我们创建了两个存储100个常量值的向量，代表我们想要使用的颜色。接下来，在方括号内，使用分号（;），我们垂直连接这两个向量，创建一个包含200个元素的向量，并将其作为颜色关键字参数传递给scatter函数。
- en: Figure 5.3 shows the resulting plot. Observe that, as expected, we have a separation
    of points from cluster 1 and cluster 2 (except for one outlier from cluster 1).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3显示了结果图。观察可知，正如预期的那样，我们看到了来自簇1和簇2的点之间的分离（除了簇1中的一个异常值）。
- en: '![CH05_F03_Kaminski2](../Images/CH05_F03_Kaminski2.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![CH05_F03_Kaminski2](../Images/CH05_F03_Kaminski2.png)'
- en: Figure 5.3 Visualization of the result of t-SNE embedding. Data for clusters
    1 and 2 (represented with different fill colors) are separated. The algorithm
    helps us identify one outlier in cluster 1; this is the black point that in embedded
    space is located closer to points from cluster 2.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 t-SNE嵌入结果的可视化。簇1和簇2的数据（用不同的填充颜色表示）被分离。该算法帮助我们识别簇1中的一个异常值；这是在嵌入空间中位于簇2的点更近的黑点。
- en: Exercise 5.2 Repeat the analysis presented in section 5.3, but instead of adding
    and subtracting 1 when creating data for clusters 1 and 2, add and subtract 0.4,
    respectively. This will reduce the separation between two clusters in five-dimensional
    space. Check to see if this will reduce their separation in the two-dimensional
    space generated by t-SNE.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 练习5.2重复5.3节中展示的分析，但在创建簇1和簇2的数据时，不是加1和减1，而是分别加0.4和减0.4。这将减少五维空间中两个簇之间的分离。检查这是否会减少由t-SNE生成的二维空间中的分离。
- en: Summary
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Julia provides four important ways to iterate over collections and transform
    them: loops, the map function (and other similar higher-order functions), comprehensions,
    and broadcasting. Each has slightly different rules of processing data. Therefore,
    you should choose one depending on your needs in a given situation.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Julia提供了四种迭代集合并转换它们的重要方式：循环、map函数（以及其他类似的高阶函数）、列表推导式和广播。每种方法在处理数据时都有略微不同的规则。因此，你应该根据具体情况选择其中一种。
- en: Most functions in Julia are defined to work on scalars. If you want to apply
    a function to a collection elementwise, you have to use one of the methods provided
    by Julia that allow you to iterate over collections.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Julia中的大多数函数都是定义为在标量上工作的。如果你想逐元素应用一个函数到集合上，你必须使用Julia提供的一种允许你迭代集合的方法。
- en: Broadcasting in Julia is a way to apply a function to a collection of values
    (an operation often called *vectorization* in other languages). You can broadcast
    any function (like sin or log) by suffixing it with a dot (.). Similarly, to vectorize
    an operator (like * or /), prefix it with a dot (.).
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Julia 中，广播是一种将函数应用于值集合（在其他语言中通常称为 *向量化* 的操作）。你可以通过在函数后添加一个点 (.) 来广播任何函数（如
    sin 或 log）。同样，要向量化一个运算符（如 * 或 /），在它前面加上一个点 (.)。
- en: Broadcasting in Julia is efficient, as it uses broadcast fusion. Julia does
    not need to allocate objects for storing intermediate results of processing data
    when executing complex broadcasted operations.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Julia 中的广播是高效的，因为它使用了广播融合。在执行复杂的广播操作时，Julia 不需要为存储数据处理中间结果的对象分配内存。
- en: In Julia, similarly to R and Python, broadcasting automatically expands dimensions
    that have length 1\. It is important to remember this rule since, if you forget
    it, you might be surprised by the result of a broadcasting operation.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Julia 中，类似于 R 和 Python，广播会自动扩展长度为 1 的维度。记住这个规则很重要，因为如果你忘记了它，你可能会对广播操作的结果感到惊讶。
- en: If you have a broadcasted operation to which you pass a collection that you
    want to be treated as a scalar, wrap it in Ref. This approach is often used when
    performing a lookup into a reference table using the in function.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你有一个要传递集合的广播操作，而你希望该集合被视为标量，请将其包裹在 Ref 中。这种方法通常在通过 in 函数执行对参考表的查找时使用。
- en: When working with collections, you should understand Julia’s subtyping rules
    for parametric types. Writing Vector{Real} specifies a type that a value can take.
    This value is a Vector that can store any Real number. On the other hand, Vector{<:Real}
    is used to represent a supertype of any Vector whose element type is a subtype
    of Real. No value can have the Vector{<:Real} type, because it is not a leaf type
    and is not concrete. Therefore, Vector{Int} is a subtype of Vector{<:Real} but
    is not a subtype of Vector{Real} (recall from chapter 3 that in Julia, if a type
    can have an instance, it is not allowed to have subtypes).
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当与集合一起工作时，你应该了解 Julia 的参数化类型的子类型规则。编写 Vector{Real} 指定了一个值可以取的类型。这个值是一个可以存储任何实数的
    Vector。另一方面，Vector{<:Real} 用于表示任何元素类型是 Real 子类型的 Vector 的超类型。没有值可以有 Vector{<:Real}
    类型，因为它不是一个叶类型，也不是具体的。因此，Vector{Int} 是 Vector{<:Real} 的子类型，但不是 Vector{Real} 的子类型（回想第
    3 章，在 Julia 中，如果一个类型可以有实例，则不允许它有子类型）。
- en: You can integrate Julia with Python by using the PyCall.jl package. This integration
    is often needed when you want to use Python code in your Julia projects.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过使用 PyCall.jl 包将 Julia 与 Python 集成。当你想在 Julia 项目中使用 Python 代码时，这种集成通常是必需的。
- en: The integration of Julia with Python provided by the PyCall.jl package allows
    you to call Python functions in exactly the same way as you would call them in
    Python, and an automatic conversion of collections between Julia and Python formats
    is performed. This means that using Python functionalities in Julia is easy, and
    only minimal changes in Python code are required to use them in Julia projects.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyCall.jl 包提供的 Julia 与 Python 的集成允许你以与在 Python 中调用它们完全相同的方式调用 Python 函数，并且自动在
    Julia 和 Python 格式之间转换集合。这意味着在 Julia 中使用 Python 功能很容易，并且只需对 Python 代码进行最小更改即可在
    Julia 项目中使用它们。
