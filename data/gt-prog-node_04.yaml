- en: Unit 4\. Building a user model
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第4单元。构建用户模型
- en: In [unit 3](../Text/kindle_split_026.html#part03), you learned how to connect
    your application to a database. You also constructed your first schema and model.
    This unit builds on those lessons by introducing more functionality to your models.
    First, you learn more about how Mongoose schemas and methods can be used to interact
    more reliably with your models. You build a model to represent user data and connectivity.
    Every user needs to create an account, edit, and delete their account. In this
    unit, I discuss create, read, update, and delete (CRUD) functions in application
    development and show what you need to create a robust model. By the end of this
    unit, you’ll have an application that supports three models, each associated with
    one another and manageable from views in your browser.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第3单元](../Text/kindle_split_026.html#part03) 中，您学习了如何将应用程序连接到数据库。您还构建了您的第一个模式和模型。本单元通过向模型引入更多功能来构建这些课程。首先，您将更多地了解如何使用
    Mongoose 模式和方法与模型进行更可靠的交互。您构建了一个表示用户数据和连接性的模型。每个用户都需要创建账户、编辑和删除账户。在本单元中，我讨论了应用程序开发中的创建、读取、更新和删除（CRUD）函数，并展示了您需要创建一个健壮模型的内容。在本单元结束时，您将拥有一个支持三个模型的应用程序，每个模型都与另一个模型相关联，并且可以从浏览器视图中进行管理。
- en: 'This unit covers the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本单元涵盖了以下主题：
- en: '[Lesson 17](../Text/kindle_split_032.html#ch17) dives deeper into Mongoose
    schemas and models. In this lesson, you add database validations to ensure that
    data is saved only if it meets the requirements you set. You also learn how to
    associate models with one another. You start by applying certain techniques to
    the `Subscriber` model and then move to the application’s other models.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第17课](../Text/kindle_split_032.html#ch17) 深入探讨了 Mongoose 模式和模型。在本课中，您添加数据库验证以确保只有满足您设置的要求的数据才会被保存。您还学习了如何将模型相互关联。您首先将某些技术应用于
    `Subscriber` 模型，然后转向应用程序的其他模型。'
- en: '[Lesson 18](../Text/kindle_split_033.html#ch18) shows how to construct a user
    model. This lesson teaches about the core CRUD controller actions to manage model
    data. You start by building a users-index page.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第18课](../Text/kindle_split_033.html#ch18) 展示了如何构建用户模型。本课介绍了管理模型数据的核心 CRUD
    控制器操作。您首先构建了一个用户索引页面。'
- en: '[Lesson 19](../Text/kindle_split_034.html#ch19) guides you through constructing
    the create and read routes, actions, and views for your user model. In this lesson,
    you create everything needed to save user data from browser views.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第19课](../Text/kindle_split_034.html#ch19) 指导您构建用户模型的创建和读取路由、操作和视图。在本课中，您创建了从浏览器视图保存用户数据所需的一切。'
- en: '[Lesson 20](../Text/kindle_split_035.html#ch20) guides you through constructing
    the update and delete routes, actions, and views for your user model. By the end
    of this lesson, your CRUD functionality will be complete.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第20课](../Text/kindle_split_035.html#ch20) 指导您构建用户模型的更新和删除路由、操作和视图。在本课结束时，您的
    CRUD 功能将完整。'
- en: '[Lesson 21](../Text/kindle_split_036.html#ch21) wraps up the unit by guiding
    you through the construction of a user model and the necessary model- associations
    needed for the Confetti Cuisine application.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第21课](../Text/kindle_split_036.html#ch21) 通过指导您构建用户模型和 Confetti Cuisine 应用程序所需的必要模型关联来结束本单元。'
- en: Get ready to collect, store, and associate data in [unit 4](#part04).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 准备在 [第4单元](#part04) 中收集、存储和关联数据。
- en: Lesson 17\. Improving Your Data Models
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第17课。改进您的数据模型
- en: In this lesson, you take advantage of Mongoose’s schema- and model-creation
    tools. To start, you improve on your simple model and add properties to the models
    to restrict what data can be saved to the database. Next, you see how to associate
    data in a NoSQL database such as MongoDB. At the end, you build out static and
    instance methods for the model. You can run these methods directly on Mongoose
    model objects, and create the necessary controller actions for them to work with
    the application.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，您利用 Mongoose 的模式创建和模型创建工具。首先，您改进了您的简单模型，并为模型添加属性以限制可以保存到数据库中的数据。接下来，您将了解如何将数据关联到
    NoSQL 数据库，如 MongoDB。最后，您为模型构建了静态和实例方法。您可以直接在 Mongoose 模型对象上运行这些方法，并为它们创建必要的控制器操作以与应用程序一起工作。
- en: This lesson covers
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本课涵盖以下内容
- en: Adding validations to your models
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的模型中添加验证
- en: Creating static and instance methods for your models
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为您的模型创建静态和实例方法
- en: Testing your models in REPL
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 REPL 中测试您的模型
- en: Implementing data associations on multiple models
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多个模型上实现数据关联
- en: '|  |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Consider this**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: You’ve set up a form for people visiting your recipe application to subscribe
    to a newsletter. Now you want to populate your application with courses in which
    users will be able to enroll and learn to cook.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经为访问您的食谱应用的人设置了一个订阅通讯的表单。现在您想用课程填充您的应用，用户可以在其中注册并学习烹饪。
- en: With the help of Mongoose, you’ll be able to set up your models so that subscribers
    can show interest in a particular program before signing up as users.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mongoose 的帮助下，您将能够设置模型，以便订阅者可以在注册为用户之前对某个特定程序表示兴趣。
- en: '|  |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)17.1\. Adding validations on the model'
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![图 17.1. 在模型上添加验证](../Images/sectionFig.png)'
- en: So far, you’ve built a model with Mongoose. The model you created is an abstraction
    from the data, represented as a document, in your MongoDB database. Because of
    this abstraction, you can create a blueprint of how you want your data to look
    and behave using Mongoose schemas.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经使用 Mongoose 构建了一个模型。您创建的模型是数据的一个抽象，在您的 MongoDB 数据库中以文档的形式表示。由于这种抽象，您可以使用
    Mongoose 模式创建您想要的数据外观和行为蓝图。
- en: Take a look at the subscriber data model for your recipe application in [listing
    17.1](#ch17ex01). The subscriber’s schema lets your application know that it’s
    looking for three properties of a certain data type. It doesn’t specify, however,
    whether the properties can be duplicates, if a size limit exist (the ZIP code
    could be saved as 15 digits, for example), or whether the properties are even
    required for saving to the database. It won’t be any help to have subscriber records
    in your database if they’re mostly blank. Next, you add some ways to validate
    that your properties ensure that your data is consistent.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 查看您的食谱应用在[列表 17.1](#ch17ex01)中的订阅者数据模型。订阅者的模式让您的应用知道它在寻找特定数据类型的三种属性。然而，它并没有指定这些属性是否可以重复，是否存在大小限制（例如，ZIP
    码可以保存为 15 位数字），或者这些属性是否是保存到数据库所必需的。如果数据库中的订阅者记录大部分是空的，那么它们将没有任何帮助。接下来，您添加了一些验证方法，以确保您的属性确保数据的一致性。
- en: Listing 17.1\. Defining a subscriber schema in subscriber.js
  id: totrans-24
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 17.1\. 在 subscriber.js 中定义订阅者模式
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '***1*** **Define a subscriberSchema to contain name, email, and zipCode properties.**'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **定义一个 subscriberSchema 以包含名称、电子邮件和 zipCode 属性。**'
- en: The schema defined so far works, but it also allows you to save an instance
    of the `Subscriber` model without any meaningful data.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止定义的模式是有效的，但它也允许您在没有任何有意义数据的情况下保存 `Subscriber` 模型的一个实例。
- en: '|  |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**SchemaTypes**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**SchemaTypes**'
- en: 'Mongoose provides a set of data types that you can specify in your schema;
    these data types are appropriately called SchemaTypes. The types resemble data
    types in JavaScript, though they have a particular relationship with the Mongoose
    library that normal Java-Script data types don’t have. Here are some SchemaTypes
    you should know about:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose 提供了一组数据类型，您可以在模式中指定这些数据类型；这些数据类型被称为 SchemaTypes。这些类型类似于 JavaScript
    中的数据类型，尽管它们与 Mongoose 库有特定的关系，而常规 JavaScript 数据类型则没有。以下是一些您应该了解的 SchemaTypes：
- en: String—This type, like `Boolean` and `Number`, is straightforward. Specifying
    a schema property of type `String` means that this property will save data presented
    as a JavaScript `String` (not null or undefined).
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: String—此类型，如 `Boolean` 和 `Number`，非常直接。指定为 `String` 类型的模式属性意味着此属性将保存以 JavaScript
    `String`（非 null 或 undefined）形式呈现的数据。
- en: '`Date`—Dates are useful in data documents, as they can tell you when data was
    saved or modified, or when anything involving that model occurred. This type accepts
    a JavaScript Date object.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Date`—日期在数据文档中很有用，因为它们可以告诉您数据何时被保存或修改，或者何时发生了涉及该模型的事情。此类型接受 JavaScript 日期对象。'
- en: Array—The `Array` type allows a property to store a list of items. When specifying
    the `Array` type, use the array literal, enclosing square brackets [] instead
    of its name.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Array—`Array` 类型允许属性存储项目列表。在指定 `Array` 类型时，使用数组字面量，用方括号 [] 封闭，而不是其名称。
- en: '`Mixed`—This type is most similar to a JavaScript object, as it stores key-value
    pairs on a model. To use the `Mixed` type, you need to specify `mongoose.Schema.Types.Mixed`.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mixed`—这种类型与 JavaScript 对象最为相似，因为它在模型上存储键值对。要使用 `Mixed` 类型，您需要指定 `mongoose.Schema.Types.Mixed`。'
- en: ObjectId—Like the `ObjectId` value for each document in your MongoDB database,
    this type references that object. This type is particularly important when associating
    models with one another. To use this type, specify `mongoose.Schema.Types.ObjectId`.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ObjectId—类似于您的 MongoDB 数据库中每个文档的 `ObjectId` 值，此类型引用该对象。当将模型相互关联时，此类型尤为重要。要使用此类型，请指定
    `mongoose.Schema.Types.ObjectId`。
- en: '|  |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: To start improving your model, add some Mongoose validators. *Validators* are
    rules that you apply to model properties, preventing them from saving to your
    database unless those rules are met. See the amended schema in [listing 17.2](#ch17ex02).
    Notice that each model property can have a type assigned directly or a bunch of
    options passed as a JavaScript object.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始改进你的模型，添加一些 Mongoose 验证器。*验证器* 是应用于模型属性的规则，除非满足这些规则，否则它们将阻止数据保存到你的数据库中。参见
    [列表 17.2](#ch17ex02) 中的修改后的模式。注意，每个模型属性可以直接分配一个类型，或者作为 JavaScript 对象传递一串选项。
- en: You want to require the name property and make it type `String`. The email property
    should be required because no two records can have the same email, and it’s also
    of type `String`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要要求名称属性，并使其类型为 `String`。邮箱属性应该是必需的，因为没有任何两个记录可以拥有相同的邮箱，它也是 `String` 类型。
- en: '|  |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-40
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: In this example, *require* means that data must exist for the model instance
    before it can be saved to the database. It’s not the same way I’ve been using
    the term to require modules.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，*require* 表示在模型实例保存到数据库之前，数据必须存在。这与我一直用来要求模块的方式不同。
- en: '|  |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: You also add the `lowercase` property set to true to indicate that all emails
    saved to the database are not case-sensitive. Last, the ZIP code property won’t
    be required, but it has a minimum and maximum number of digits. If a number less
    than 10000 is entered, the error message `"Zip Code too Short"` is used. If the
    number exceeds 99999, or 5 digits in length, you get a generic error from Mongoose,
    and the data won’t save.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你还添加了一个设置为 true 的 `lowercase` 属性，以指示所有保存到数据库的邮箱都不区分大小写。最后，邮编属性不是必需的，但它有一个最小和最大数字位数。如果输入的数字小于
    10000，将使用错误信息 `"邮编太短"`。如果数字超过 99999，或者长度为 5 位，你将收到 Mongoose 的通用错误，并且数据无法保存。
- en: Listing 17.2\. Adding validators to the subscriber schema in subscriber.js
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 17.2\. 在 subscriber.js 中向订阅者模式添加验证器
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '***1*** **Require the name property.**'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **要求名称属性。**'
- en: '***2*** **Require the email property, and add the lowercase property.**'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **需要邮箱属性，并添加小写属性。**'
- en: '***3*** **Set up the zipCode property with a custom error message.**'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **使用自定义错误消息设置 zipCode 属性。**'
- en: '|  |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-50
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The `unique` option used on the `email` property isn’t a validator, but rather
    a Mongoose schema helper. Helpers are like methods that perform tasks that behave
    like a validator in this case.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `email` 属性上使用的 `unique` 选项不是一个验证器，而是一个 Mongoose 模式辅助器。辅助器就像方法一样，执行像验证器一样的任务，在这种情况下。
- en: '|  |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Because the subscriber’s schema defines how instances of the `Subscriber` model
    behave, you can also add instance and static methods to the schema. As in traditional
    objectoriented programming, *instance* methods operate on an instance (a Mongoose
    document) of the `Subscriber` model and are defined by `subscriberSchema.methods`.
    *Static* methods are used for general queries that may relate to many `Subscriber`
    instances and are defined with `subscriberSchema.statics`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因为订阅者模式定义了 `Subscriber` 模型实例的行为，你还可以向模式添加实例和静态方法。在传统的面向对象编程中，*实例* 方法作用于 `Subscriber`
    模型的实例（一个 Mongoose 文档），并由 `subscriberSchema.methods` 定义。*静态* 方法用于与许多 `Subscriber`
    实例相关的通用查询，并由 `subscriberSchema.statics` 定义。
- en: Next, you add two instance methods from [listing 17.3](#ch17ex03) to your recipe
    application.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将 [列表 17.3](#ch17ex03) 中的两个实例方法添加到你的食谱应用程序中。
- en: '`getInfo` can be called on a `Subscriber` instance to return the subscriber’s
    information in one line, which could be useful to get a quick read of the subscribers
    in your database. `findLocalSubscribers` works the same way but returns an array
    of subscribers. This instance method involves a Mongoose query where `this` refers
    to the instance of `Subscriber` on which the method is called. Here, you’re asking
    for all subscribers with the same ZIP code. `exec` ensures that you get a promise
    back instead of needing to add an asynchronous callback here.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`getInfo` 可以在 `Subscriber` 实例上调用，以一行返回订阅者的信息，这可能有助于快速了解数据库中的订阅者。`findLocalSubscribers`
    以相同的方式工作，但返回一个订阅者数组。这个实例方法涉及一个 Mongoose 查询，其中 `this` 指的是调用该方法的 `Subscriber` 实例。在这里，你要求所有具有相同邮编的订阅者。`exec`
    确保你得到一个承诺而不是需要在这里添加异步回调。'
- en: Listing 17.3\. Adding instance methods to the schema in subscriber.js
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 17.3\. 在 subscriber.js 中向模式添加实例方法
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***1*** **Add an instance method to get the full name of a subscriber.**'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **添加一个获取订阅者全名的方法。**'
- en: '***2*** **Add an instance method to find subscribers with the same ZIP code.**'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **添加一个查找具有相同 ZIP 编码的订阅者的方法。**'
- en: '***3*** **Access the Subscriber model to use the find method.**'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **访问 Subscriber 模型以使用 find 方法。**'
- en: '|  |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: As of the writing of this book, when using methods with Mongoose, you won’t
    be able to use ES6 arrow functions without drawbacks. Mongoose makes use of binding
    `this`, which is removed with arrow functions. Inside the function, you can use
    ES6 again.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书编写时，当使用 Mongoose 的方法时，你将无法使用 ES6 箭头函数而不受影响。Mongoose 使用绑定 `this`，而箭头函数会移除它。在函数内部，你可以再次使用
    ES6。
- en: '|  |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-66
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Recall that you need to export the `Subscriber` model by using `module.exports
    = mongoose.model("Subscriber", subscriberSchema)` after setting up these methods.
    This line allows you to `require` the `Subscriber` model directly by importing
    this module in another file.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，在设置这些方法之后，你需要使用 `module.exports = mongoose.model("Subscriber", subscriberSchema)`
    来导出 `Subscriber` 模型。这一行允许你通过在另一个文件中导入此模块直接 `require` `Subscriber` 模型。
- en: '|  |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Mongoose provides dozens of other query methods. You could add more methods
    and validations in subscriber.js, but Mongoose already offers many methods for
    you to query documents. [Table 17.1](#ch17table01) lists a few query methods that
    you may find useful.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose 提供了数十种其他查询方法。你可以在 subscriber.js 中添加更多方法和验证，但 Mongoose 已经为你提供了许多查询文档的方法。[表
    17.1](#ch17table01) 列出了一些你可能觉得有用的查询方法。
- en: Table 17.1\. Mongoose queries
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 17.1\. Mongoose 查询
- en: '| Query | Description |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 查询 | 描述 |'
- en: '| --- | --- |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| find | Returns an array of records that match the query parameters. You can
    search for all subscribers with the name "Jon" by running Subscriber.find({name:
    "Jon"}). |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| find | 返回与查询参数匹配的记录数组。你可以通过运行 Subscriber.find({name: "Jon"}) 来搜索所有名为 "Jon"
    的订阅者。|'
- en: '| findOne | Returns a single record when you don’t want an array of values.
    Running Subscriber.findOne({name: "Jon"}) results in one returned document. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| findOne | 当你不想得到一个值数组时，返回单个记录。运行 Subscriber.findOne({name: "Jon"}) 将返回一个返回的文档。|'
- en: '| findById | Allows you to query the database by an ObjectId. This query is
    your most useful tool for modifying existing records in your database. Assuming
    that you know a subscriber’s ObjectId, you can run Subscriber.findById("598695b29ff27740c5715265").
    |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| findById | 允许你通过 ObjectId 查询数据库。这个查询是你修改数据库中现有记录最有用的工具。假设你知道一个订阅者的 ObjectId，你可以运行
    Subscriber.findById("598695b29ff27740c5715265")。|'
- en: '| remove | Allows you to delete documents in your database by running Subscriber.remove({})
    to remove all documents. Be careful with this query. You can also remove specific
    instances such as subscriber.remove({}). |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| remove | 允许你通过运行 Subscriber.remove({}) 来删除数据库中的文档。小心使用这个查询。你也可以删除特定的实例，例如
    subscriber.remove({})。|'
- en: '|  |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Each of these queries returns a promise, so you need to use `then` and `catch`
    to handle the resulting data or errors.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这些查询每个都返回一个 promise，因此你需要使用 `then` 和 `catch` 来处理结果数据或错误。
- en: '|  |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: For more information about Mongoose queries, visit [http://mongoosejs.com/docs/-queries.html](http://mongoosejs.com/docs/-queries.html).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 Mongoose 查询的更多信息，请访问 [http://mongoosejs.com/docs/-queries.html](http://mongoosejs.com/docs/-queries.html)。
- en: 'Before you get to programming the routes and user interface to interact with
    your new models, try another way to test whether everything is working: REPL.
    In the next section, you apply the code from earlier in this lesson to a new REPL
    session.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始编写路由和用户界面与你的新模型交互之前，尝试另一种测试是否一切正常的方法：REPL。在下一节中，你将应用本课中较早的代码到一个新的 REPL 会话中。
- en: '|  |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 17.1**'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 17.1**'
- en: '**[Q1:](#ch17qa3q0a1)**'
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch17qa3q0a1)**'
- en: ''
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When you use promises with Mongoose queries, what should a query always return?
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当你使用 Mongoose 查询与 promises 一起时，查询应该始终返回什么？
- en: '|  |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 17.1 answer**'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 17.1 答案**'
- en: '**[1:](#ch17qa1q1)**'
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch17qa1q1)**'
- en: ''
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When using promises with Mongoose, you should expect to get a promise as a result
    of a database query. Getting back a promise ensures that a result or error can
    be handled appropriately without having to worry about timing issues with asynchronous
    queries.
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当使用 promises 与 Mongoose 一起时，你应该期望从数据库查询中得到一个 promise。返回一个 promise 确保可以适当地处理结果或错误，而无需担心异步查询的时序问题。
- en: '|  |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '![](../Images/sectionFig.png)17.2\. Testing models in REPL'
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)17.2\. 在 REPL 中测试模型'
- en: To start interacting with your database by using the `Subscriber` model, you
    need to go into REPL by typing the `node` keyword in a new terminal window and
    adding the lines in [listing 17.4](#ch17ex04). Set up the environment by requiring
    Mongoose. (You need to be in your project’s directory in terminal for this procedure
    to work.) Next, set up the connection to MongoDB. Enter the name of your database—in
    this case, `recipe_db`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过使用`Subscriber`模型与数据库交互，你需要通过在新的终端窗口中键入`node`关键字并添加[列表17.4](#ch17ex04)中的行进入REPL。通过引入Mongoose设置环境。（你需要处于终端中的项目目录中，以便此过程生效。）接下来，设置到MongoDB的连接。输入你的数据库名称——在本例中为`recipe_db`。
- en: Listing 17.4\. Set up subscriber model in REPL in terminal
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表17.4\. 在终端REPL中设置订阅者模型
- en: '[PRE3]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1*** **Require Mongoose in REPL.**'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **在REPL中引入Mongoose。**'
- en: '***2*** **Assign the Subscriber model to a variable, using the model name and
    local project file.**'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **使用模型名称和本地项目文件将Subscriber模型分配给一个变量。**'
- en: '***3*** **Set up a database connection, using recipe_db.**'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **使用recipe_db设置数据库连接。**'
- en: '***4*** **Tell Mongoose to use native promises as you did in main.js.**'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **告诉Mongoose使用与main.js中相同的本地承诺。**'
- en: Now you’re all set to test whether your model and its methods work. In REPL,
    run the commands and queries in [listing 17.5](#ch17ex05) to see whether you’ve
    set up your model correctly.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以测试你的模型及其方法是否正常工作了。在REPL中运行[列表17.5](#ch17ex05)中的命令和查询，以查看你是否正确设置了模型。
- en: Create a new subscriber document with the name `"Jon"` and email `"jon@jonwexler.com"`.
    Try running this line twice. The first time, you should see the saved document
    logged back to the console. The second time, you should see an error message saying
    the email already exists in the database, which means that your email validator
    is working.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`"Jon"`和电子邮件`"jon@jonwexler.com"`的新订阅者文档。尝试运行此行两次。第一次，你应该在控制台看到保存的文档被记录。第二次，你应该看到一个错误消息，表明电子邮件已经在数据库中存在，这意味着你的电子邮件验证器正在工作。
- en: Next, set up a variable to which you can assign the following results of your
    query. Using Mongoose’s `findOne` query, you’re searching for the document you
    just created. Then assign the resulting record to your `subscriber` variable.
    You can test that this code works by logging the `subscriber` record or, better,
    the results of your custom `getInfo` method on this instance.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，设置一个变量，你可以将以下查询结果分配给它。使用Mongoose的`findOne`查询，你正在搜索你刚刚创建的文档。然后将结果记录分配给你的`subscriber`变量。你可以通过记录`subscriber`记录或更好的是，记录这个实例上自定义的`getInfo`方法的结果来测试这段代码是否工作。
- en: 'The resulting text should read: `Name: Jon Email: jon@jonwexler.com Zip Code:
    12345`.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '结果文本应读取为：`Name: Jon Email: jon@jonwexler.com Zip Code: 12345`。'
- en: '|  |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Because emails must be unique, you may run into a duplicate key error when saving
    new records with the same information. In that case, you can run `Subscriber .remove({})`
    to clear all subscriber data from your database.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于电子邮件必须是唯一的，当保存具有相同信息的新的记录时，可能会遇到重复键错误。在这种情况下，你可以运行`Subscriber .remove({})`来从数据库中清除所有订阅者数据。
- en: '|  |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Listing 17.5\. Testing model methods and Mongoose queries in REPL in terminal
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表17.5\. 在终端REPL中测试模型方法和Mongoose查询
- en: '[PRE4]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***1*** **Create a new subscriber document.**'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **创建一个新的订阅者文档。**'
- en: '***2*** **Set up a variable to hold query results.**'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **设置一个变量来保存查询结果。**'
- en: '***3*** **Search for the document you just created.**'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **搜索你刚刚创建的文档。**'
- en: '***4*** **Log the subscriber record.**'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **记录订阅者记录。**'
- en: Your terminal console window should resemble the one in [figure 17.1](#ch17fig01).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你的终端控制台窗口应该类似于[图17.1](#ch17fig01)中的那个。
- en: Figure 17.1\. Example response for Mongoose REPL commands
  id: totrans-118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图17.1\. Mongoose REPL命令的示例响应
- en: '![](../Images/17fig01_alt.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/17fig01_alt.jpg)'
- en: Try to create new records with different content. Check that your validators
    for the `zipCode` property are working by creating a new `Subscriber` with ZIP
    code 890876 or 123\. Then try to delete one or all of your subscriber records
    directly from REPL.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试创建不同内容的新的记录。通过创建ZIP代码为890876或123的新`Subscriber`来检查你的`zipCode`属性的验证器是否工作。然后尝试直接从REPL中删除一个或所有订阅者记录。
- en: Next, I show you how to associate this new model with other new models.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将向你展示如何将这个新模型与其他新模型关联起来。
- en: '|  |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: 'The code in this section can be saved and reused. Add your REPL code to a file
    called repl.js in your project directory. The next time you open REPL, you can
    load the contents of this file into the environment. Remember: Node.js runs asynchronously,
    so if you try to create a record in one command and query for that record immediately
    afterward, those two commands run virtually at the same time. To avoid any errors,
    run the commands individually, or nest queries within each other’s `then` blocks.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分代码可以保存并重复使用。将你的 REPL 代码添加到项目目录下名为 repl.js 的文件中。下次你打开 REPL 时，你可以将此文件的 内容加载到环境中。记住：Node.js
    以异步方式运行，所以如果你尝试在一个命令中创建一个记录，并在之后立即查询该记录，这两个命令几乎会同时运行。为了避免任何错误，请单独运行命令，或者在每个命令的
    `then` 块中嵌套查询。
- en: '|  |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 17.2**'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 17.2**'
- en: '**[Q1:](#ch17qa6q0a1)**'
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch17qa6q0a1)**'
- en: ''
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why do you need to require the database connection and Mongoose models into
    REPL to test your code?
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么你需要将数据库连接和 Mongoose 模型引入 REPL 来测试你的代码？
- en: '|  |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 17.2 answer**'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 17.2 答案**'
- en: '**[1:](#ch17qa4q1)**'
  id: totrans-134
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch17qa4q1)**'
- en: ''
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Until you build views to interact with your database, REPL is a great tool to
    run CRUD operations on your models. But you need to require the modules with which
    you’d like to test so that your REPL environment will know which database to save
    to and which `Subscriber` model you’re creating.
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在你构建视图与数据库交互之前，REPL 是运行 CRUD 操作在模型上的一个很好的工具。但你需要引入你想要测试的模块，以便你的 REPL 环境知道要将数据保存到哪个数据库以及你正在创建哪个
    `Subscriber` 模型。
- en: '|  |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '![](../Images/sectionFig.png)17.3\. Creating model associations'
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)17.3\. 创建模型关联'
- en: In [unit 3](../Text/kindle_split_026.html#part03), I discussed how data is structured
    with MongoDB and how Mongoose acts as a layer over the database to map documents
    to JavaScript objects. The Mongoose package saves you a lot of time in development
    by offering methods that make it easy to query the database and generate results
    quickly in an object-oriented way.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [单元 3](../Text/kindle_split_026.html#part03) 中，我讨论了如何在 MongoDB 中结构化数据以及 Mongoose
    如何作为数据库之上的一个层，将文档映射到 JavaScript 对象。Mongoose 包通过提供易于查询数据库并快速以面向对象的方式生成结果的方法，在开发过程中为你节省了大量时间。
- en: If your background is relational databases, you may be familiar with the ways
    you can associate data in your applications, as shown in [figure 17.2](#ch17fig02).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的背景是关系型数据库，你可能熟悉在应用程序中关联数据的方式，如图 17.2 所示。
- en: Figure 17.2\. Relational database associations
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 17.2\. 关系型数据库关联
- en: '![](../Images/17fig02_alt.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/17fig02_alt.jpg)'
- en: Because you’re working with a document-based database, you have no tables—and
    definitely no join tables. But you do have fairly simple ways to use Mongoose
    to set up the data relationships laid out in [table 17.2](#ch17table02).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你在使用基于文档的数据库，所以你没有表格——当然也没有连接表。但你确实有相当简单的方法使用 Mongoose 来设置 [表 17.2](#ch17table02)
    中描述的数据关系。
- en: Table 17.2\. Data relationships
  id: totrans-144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 17.2\. 数据关系
- en: '| Relationship | Description |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 关联 | 描述 |'
- en: '| --- | --- |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| One-to-one | When one model can have an association to another model. This
    association could be a User with one Profile; that profile belongs only to the
    user. |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 一对一 | 当一个模型可以与另一个模型有关联时。这种关联可能是一个具有一个配置文件的 User；该配置文件仅属于该用户。|'
- en: '| One-to-many | When one model can have many associations to another model,
    but the other model can have only a single association back to the first model.
    This association could be a Company with many instances of Employee. In this example,
    the employees work for only one company, and that company has many employees.
    |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 一对多 | 当一个模型可以与另一个模型有多个关联，但另一个模型只能有一个反向关联到第一个模型时。这种关联可能是一个具有多个 Employee 实例的
    Company。在这个例子中，员工只为一家公司工作，而这家公司有多个员工。|'
- en: '| Many-to-many | When many instances of one model can have multiple associations
    to another model, and vice versa. Many Theatre instances could show the same Movie
    instances, and each Movie can be traced to many Theatre instances. Typically,
    a join table is used to map records to one another in a relational database. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 多对多 | 当一个模型的一个实例可以与另一个模型有多个关联，反之亦然时。许多剧院实例可以展示相同的电影实例，每部电影都可以追溯到许多剧院实例。通常，在关系型数据库中，连接表用于将记录映射到彼此。|'
- en: 'If two models are associated in some way—a user has many pictures, an order
    has a single payment, many classes share multiple enrolled students—you add a
    property with the associated model’s name, where the `type` is `Schema.Types.ObjectId`,
    the `ref` attribute is set to the associated model’s name, and `Schema` is `mongoose.Schema`.
    The following code might represent a schema property for users with many pictures:
    `pictures: [{type: Schema.Types .ObjectId, ref: "Picture"}]`.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '如果两个模型以某种方式关联——一个用户有多个图片，一个订单有一个付款，多个班级有多个注册的学生——您添加一个属性，其名称与关联的模型名称相同，其中 `type`
    是 `Schema.Types.ObjectId`，`ref` 属性设置为关联模型的名称，`Schema` 是 `mongoose.Schema`。以下代码可能代表具有多个图片的用户的模式属性：`pictures:
    [{type: Schema.Types.ObjectId, ref: "Picture"}]`。'
- en: Add another model to this recipe application called `Course`, and associate
    it with `Subscriber`. This course model represents recipe courses to choose from
    in the application. Each course has different food offerings in different locations.
    Add the code from [listing 17.6](#ch17ex06) to a new model file called course.js
    in your models folder.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱应用中添加另一个名为 `Course` 的模型，并将其与 `Subscriber` 关联。这个课程模型代表应用中可供选择的食谱课程。每个课程在不同的地点提供不同的食物。将
    [列表 17.6](#ch17ex06) 中的代码添加到您模型文件夹中名为 course.js 的新模型文件中。
- en: Courses have titles that are required and must not match another course’s title.
    Courses have a `description` property to inform users of the site of what the
    course offers. They also have an `items` property, which is an array of strings
    to reflect items and ingredients they include. The `zipCode` property makes it
    easier for people to choose the courses that are nearest them.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 课程必须有标题，且不能与其他课程的标题相同。课程有一个 `description` 属性，用于告知网站用户课程提供的内容。它们还有一个 `items`
    属性，它是一个字符串数组，用于反映包含的项目和成分。`zipCode` 属性使人们更容易选择离他们最近的课程。
- en: Listing 17.6\. Creating a new schema and model in course.js
  id: totrans-153
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 17.6\. 在 course.js 中创建新的模式和模型
- en: '[PRE5]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1*** **Add properties to the course schema.**'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **向课程模式添加属性。**'
- en: 'You could add a `subscribers` property to the `Course` model that stores a
    reference to the subscribers by each subscriber’s `ObjectId`, which comes from
    MongoDB. Then you’d reference the Mongoose model name, `Subscriber`, like so:
    `subscribers: [{type: mongoose.Schema.Types.ObjectId, ref: "Subscriber"}]`. Technically,
    though, you don’t need the models to reference each other; one model referencing
    the other is enough. Therefore, add the association on the `Subscriber` model.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '您可以在 `Course` 模型中添加一个 `subscribers` 属性，该属性存储每个订阅者的 `ObjectId` 引用，该 `ObjectId`
    来自 MongoDB。然后您将像这样引用 Mongoose 模型名称 `Subscriber`：`subscribers: [{type: mongoose.Schema.Types.ObjectId,
    ref: "Subscriber"}]`。技术上讲，您不需要模型相互引用；一个模型引用另一个模型就足够了。因此，在 `Subscriber` 模型上添加关联。'
- en: 'Head back over to subscriber.js, and add the following property to the `subscriberSchema`:
    `courses: [{type: mongoose.Schema.Types.ObjectId, ref: "Course"}]`'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '返回到 subscriber.js，并向 `subscriberSchema` 添加以下属性：`courses: [{type: mongoose.Schema.Types.ObjectId,
    ref: "Course"}]`'
- en: Add a `courses` property to subscribers that stores a reference to each associated
    course by that course’s `ObjectId`. The ID comes from MongoDB. Then reference
    the Mongoose model name, `Course`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 向订阅者添加一个 `courses` 属性，该属性存储每个相关课程的 `ObjectId` 引用。ID 来自 MongoDB。然后引用 Mongoose
    模型名称 `Course`。
- en: '|  |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-160
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Notice how the property’s name is plural to reflect the potential to have many
    associations between subscribers and courses.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 注意属性名称是复数形式，以反映订阅者和课程之间可能存在多个关联的可能性。
- en: '|  |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'If you wanted to restrict subscribers to one course at a time, you could remove
    the brackets around the property. The brackets signify an array of multiple referenced
    objects. If a subscriber could sign up for only a single course, the `course`
    property would look like the following: `course: {type: mongoose.Schema.Types.ObjectId,
    ref: "Course"}`.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '如果您想限制订阅者一次只能选择一个课程，您可以移除属性周围的括号。括号表示多个引用对象的数组。如果订阅者只能注册一个课程，则 `course` 属性将如下所示：`course:
    {type: mongoose.Schema.Types.ObjectId, ref: "Course"}`。'
- en: In this case, each subscriber could be associated with only a single course.
    You can think of this as allowing subscribers to sign up for only one course at
    a time. In a way, this database limitation can also behave like a feature, preventing
    subscribers from signing up for multiple courses at a time. Nothing prevents different
    subscribers from signing up for the same course, however, as long as each subscriber
    has one course association.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，每个订阅者只能与单个课程相关联。你可以将其视为允许订阅者一次只能注册一个课程。从某种意义上说，这种数据库限制也可以作为一种功能，防止订阅者同时注册多个课程。然而，只要每个订阅者有一个课程关联，就不会阻止不同的订阅者注册相同的课程。
- en: To associate two instances of separate models in practice, rely on JavaScript
    assignment operators. Suppose that you have a subscriber assigned to the variable
    `subscriber1` and a course instance represented as `course1`. To associate these
    two instances, assuming the subscriber model can have many course associations,
    you need to run `subscriber1.courses.push(course1)`. Because `subscriber1.courses`
    is an array, use the `push` method to add the new course.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，要关联两个不同模型的两个实例，依赖于JavaScript赋值运算符。假设你有一个分配给变量`subscriber1`的订阅者和一个表示为`course1`的课程实例。要关联这两个实例，假设订阅者模型可以有多个课程关联，你需要运行`subscriber1.courses.push(course1)`。因为`subscriber1.courses`是一个数组，所以使用`push`方法添加新的课程。
- en: 'Alternatively, you can push the `ObjectId` into `subscriber.courses` instead
    of using the whole course object. If `course1` has `ObjectID "5c23mdsnn3k43k2kuu"`,
    for example, your code would look like the following: `subscriber1.courses.push("5c23mdsnn3k43k2kuu")`.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以将`ObjectId`推入`subscriber.courses`而不是使用整个课程对象。例如，如果`course1`有`ObjectID
    "5c23mdsnn3k43k2kuu"`，你的代码将如下所示：`subscriber1.courses.push("5c23mdsnn3k43k2kuu")`。
- en: To retrieve course data from a subscriber, you can use the course’s `ObjectID`
    and query on the `Course` model or use the `populate` method to query the subscriber
    along with the contents of its associated courses. Your `subscriber1` MongoDB
    document would come with the `course1` document nested within it. As a result,
    you get the `ObjectID`s of associated models only.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要从订阅者中检索课程数据，你可以使用课程的`ObjectID`并在`Course`模型上查询，或者使用`populate`方法查询订阅者及其关联的课程内容。你的`subscriber1`
    MongoDB文档将包含嵌套的`course1`文档。因此，你只得到关联模型的`ObjectID`s。
- en: In the next section, you explore the `populate` method a little further.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将进一步探索`populate`方法。
- en: '|  |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 17.3**'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 17.3**'
- en: '**[Q1:](#ch17qa9q0a1)**'
  id: totrans-171
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch17qa9q0a1)**'
- en: ''
  id: totrans-172
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How do you distinguish between a model that’s associated to one instance of
    another model versus many instances?
  id: totrans-173
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你如何区分一个与另一个模型的一个实例相关联的模型与多个实例相关联的模型？
- en: '|  |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 17.3 answer**'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 17.3 答案**'
- en: '**[1:](#ch17qa7q1)**'
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch17qa7q1)**'
- en: ''
  id: totrans-178
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When defining a model’s schema, you can specify that model’s relationship as
    one-to-many by wrapping the associated model in brackets. The brackets indicate
    an array of associated records. Without the brackets, the association is one-to-one.
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在定义模型模式时，你可以通过将关联模型括在括号中来指定该模型的关系为一对多。括号表示关联记录的数组。如果没有括号，关联为一对一。
- en: '|  |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)17.4\. Populating data from associated models'
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)17.4\. 从关联模型中填充数据'
- en: '*Population* is a method in Mongoose that allows you to get all the documents
    associated with your model and add them to your query results. When you `populate`
    query results, you’re replacing the `ObjectId`s of associated documents with the
    documents’ contents. To accomplish this task, you need to chain the `populate`
    method to your model queries. `Subscriber.populate(subscriber, "courses")`, for
    example, takes all the courses associated with the `subscriber` object and replaces
    their `ObjectId`s with the full `Course` document in the subscriber’s `courses`
    array.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*填充*是Mongoose中的一个方法，允许你获取与你的模型关联的所有文档并将它们添加到查询结果中。当你`populate`查询结果时，你正在用关联文档的内容替换它们的`ObjectId`s。要完成这个任务，你需要将`populate`方法链接到你的模型查询。例如，`Subscriber.populate(subscriber,
    "courses")`将获取与`subscriber`对象关联的所有课程，并将它们的`ObjectId`s替换为订阅者`courses`数组中的完整`Course`文档。'
- en: '|  |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-184
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You can find some useful examples at [http://mongoosejs.com/docs/populate.html](http://mongoosejs.com/docs/populate.html).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[http://mongoosejs.com/docs/populate.html](http://mongoosejs.com/docs/populate.html)找到一些有用的示例。
- en: '|  |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: With these two models set up, go back to REPL, and test the model associations.
    See the commands in [listing 17.7](#ch17ex07). First, require the `Course` model
    for use in the REPL environment. Set up two variables outside the promise chain
    scope so that you can assign and use them later. Create a new course instance
    with values that meet the `Course` schema requirements. Upon creation, you’re
    assigning the saved course object to `testCourse`. Alternatively, if you’ve already
    created a course, you can get it from the database with `Course.findOne({}).then(course`
    => `testCourse = course);`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好这两个模型后，返回REPL，并测试模型关联。参见[列表 17.7](#ch17ex07)中的命令。首先，在REPL环境中使用`Course`模型，设置两个变量在promise链作用域之外，以便稍后分配和使用它们。创建一个新的课程实例，其值符合`Course`模式要求。创建后，将保存的课程对象分配给`testCourse`。或者，如果你已经创建了一个课程，你可以使用`Course.findOne({}).then(course
    => testCourse = course);`从数据库中获取它。
- en: Assuming that you created a subscriber earlier in the lesson, this line pulls
    a single subscriber from the database and assigns it to `testSubscriber`. You
    push the `testCourse` course into the `testSubscriber` array of courses. You need
    to make sure to save the model instance again so that changes take effect in the
    database. Last, use `populate` on the `Subscriber` model to locate all the subscriber’s
    courses and fill in their data in the subscriber’s courses array.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你在课程早期创建了一个订阅者，这一行从数据库中拉取一个订阅者并将其分配给`testSubscriber`。你将`testCourse`课程推入`testSubscriber`的课程数组中。你需要确保再次保存模型实例，以便更改在数据库中生效。最后，使用`populate`在`Subscriber`模型上定位所有订阅者的课程，并在订阅者的课程数组中填充它们的数据。
- en: Listing 17.7\. Testing model associations using REPL in terminal
  id: totrans-189
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 17.7\. 使用终端中的REPL测试模型关联
- en: '[PRE6]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1*** **Require the Course model.**'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **引入Course模型。**'
- en: '***2*** **Set up two variables outside the promise chain.**'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **在promise链外部设置两个变量。**'
- en: '***3*** **Create a new course instance.**'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **创建一个新的课程实例。**'
- en: '***4*** **Find a subscriber.**'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **查找订阅者。**'
- en: '***5*** **Push the testCourse course into the courses array of testSubscriber.**'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **将testCourse课程推入testSubscriber的课程数组中。**'
- en: '***6*** **Save the model instance again.**'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **再次保存模型实例。**'
- en: '***7*** **Use populate on the model.**'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7*** **在模型上使用populate。**'
- en: '|  |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: For these examples, you’re not handling potential errors with `catch` to keep
    the code short, though you’ll want to add some error handling while you test.
    Even a simple `catch(error` => `console.log(error.message))` can help you debug
    if some error occurs in the promise pipeline.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些示例，你不会用`catch`处理潜在的错误以保持代码简洁，尽管在测试时你将想要添加一些错误处理。即使是一个简单的`catch(error =>
    console.log(error.message))`也可以帮助你调试如果在promise管道中发生错误。
- en: '|  |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: After running these commands, you should see the results in [listing 17.8](#ch17ex08).
    Notice that the `testSubscriber`’s `courses` array is now populated with the `Tomato
    Land` course’s data. To reveal that course’s items, you can log `subscriber.courses[0].items`
    in the last REPL `populate` command you ran.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这些命令后，你应该会在[列表 17.8](#ch17ex08)中看到结果。注意，`testSubscriber`的`courses`数组现在已填充了`Tomato
    Land`课程的数据。要揭示该课程的项目，你可以在最后运行的REPL `populate`命令中记录`subscriber.courses[0].items`。
- en: Listing 17.8\. Resulting console log from REPL in terminal
  id: totrans-203
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 17.8\. 终端中REPL的结果控制台日志
- en: '[PRE7]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '***1*** **Display results for a populated object.**'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **显示填充对象的查询结果。**'
- en: 'Now that you have access to associated model data, your queries have become
    more useful. Interested in creating a page to show all subscribers subscribed
    for the `Tomato Land` course with `ObjectId 5986b8aad7f31c479a983b42`? The query
    you need is `Subscriber .find({courses: mongoose.Types.ObjectId("5986b8aad7f31c479a983b42")})`.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '现在你有了访问关联模型数据的能力，你的查询变得更加有用。有兴趣创建一个页面来显示所有订阅了`ObjectId 5986b8aad7f31c479a983b42`的`Tomato
    Land`课程的订阅者吗？你需要执行的查询是`Subscriber .find({courses: mongoose.Types.ObjectId("5986b8aad7f31c479a983b42")})`。'
- en: If you want to run all the examples from this lesson in sequence, you can add
    the code in [listing 17.9](#ch17ex09) to repl.js, restart your REPL environment
    by entering `node`, and load this file by running `.load repl.js`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想按顺序运行本课的所有示例，可以将[列表 17.9](#ch17ex09)中的代码添加到repl.js中，通过输入`node`重新启动你的REPL环境，然后通过运行`.load
    repl.js`来加载此文件。
- en: The code in repl.js clears your database of courses and subscribers. Then, in
    an organized promise chain, a new subscriber is created and saved to an external
    variable called `testSubscriber`. The same is done for a course, which is saved
    to `testCourse`. At the end, these two model instances are associated, and their
    association is populated and logged. The commands, in order, demonstrate how powerful
    REPL can be for testing code.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: repl.js 中的代码清除了你的数据库中的课程和订阅者。然后，在一个有组织的承诺链中，创建了一个新的订阅者并将其保存到一个名为 `testSubscriber`
    的外部变量中。同样，也创建了一个课程，并将其保存到 `testCourse` 中。最后，这两个模型实例被关联，它们的关联被填充并记录。按顺序执行的命令展示了
    REPL 在测试代码方面的强大功能。
- en: Listing 17.9\. Series of commands in REPL.js
  id: totrans-209
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 17.9\. REPL.js 中的命令序列
- en: '[PRE8]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '***1*** **Remove all subscribers and courses.**'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **删除所有订阅者和课程。**'
- en: '***2*** **Create a new subscriber.**'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **创建一个新的订阅者。**'
- en: '***3*** **Create a new course.**'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **创建一个新的课程。**'
- en: '***4*** **Associate the course with subscriber.**'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **将课程与订阅者关联。**'
- en: '***5*** **Populate course document in subscriber.**'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **在订阅者中填充课程文档。**'
- en: '***6*** **Query subscribers where ObjectId is same as course.**'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **查询与课程 ObjectId 相同的订阅者。**'
- en: '|  |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-218
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**提示**'
- en: Querying with Mongoose and MongoDB can get complicated. I recommend exploring
    the sample queries for Mongoose and practicing some of the integrated MongoDB
    query syntax. You’ll discover the queries that make the most sense to you as you
    need them in the development process.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Mongoose 和 MongoDB 进行查询可能会变得复杂。我建议探索 Mongoose 的示例查询，并练习一些集成的 MongoDB 查询语法。在开发过程中，当你需要时，你会发现哪些查询对你来说最有意义。
- en: '|  |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: In [lesson 18](../Text/kindle_split_033.html#ch18), you expand on these associations.
    You add some controller actions to manage how you interact with your data.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 18 课](../Text/kindle_split_033.html#ch18)中，你扩展了这些关联。你添加了一些控制器操作来管理你与数据交互的方式。
- en: '|  |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 17.4**'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 17.4**'
- en: '**[Q1:](#ch17qa12q0a1)**'
  id: totrans-224
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch17qa12q0a1)**'
- en: ''
  id: totrans-225
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why wouldn’t you want to populate every associated model on every query?
  id: totrans-226
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你为什么不希望在每次查询时都填充每个关联的模型？
- en: '|  |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 17.4 answer**'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 17.4 答案**'
- en: '**[1:](#ch17qa10q1)**'
  id: totrans-230
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch17qa10q1)**'
- en: ''
  id: totrans-231
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `populate` method is useful for collecting all associated data for a record,
    but if it’s misused, it can increase the overhead time and space needed to make
    a query for a record. Generally, if you don’t need to access the specific details
    of associated records, you don’t need to use `populate`.
  id: totrans-232
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`populate` 方法对于收集记录的所有关联数据很有用，但如果使用不当，会增加查询记录所需的时间和空间开销。通常，如果你不需要访问关联记录的特定细节，你不需要使用
    `populate`。'
- en: '|  |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)Summary'
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)摘要'
- en: In this lesson, you learned how to create more-robust Mongoose models. You also
    created instance methods for your models that can be run from elsewhere in your
    application on specific model instances. Later, you tested your models for the
    first time in REPL and created a new `Course` model with a many-to-many association
    to your existing `Subscriber` model. This relationship allows subscribers on the
    site to show interest in specific recipe courses, allowing you to target your
    users better by location and interest. In [lesson 18](../Text/kindle_split_033.html#ch18),
    you build a user model along with the CRUD methods that any application needs
    to manage its data.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，你学习了如何创建更健壮的 Mongoose 模型。你还为你的模型创建了实例方法，这些方法可以从应用程序的其它地方运行特定的模型实例。稍后，你在
    REPL 中首次测试了你的模型，并创建了一个新的 `Course` 模型，它与现有的 `Subscriber` 模型建立了多对多关联。这种关系允许网站上的订阅者对特定的食谱课程表示兴趣，从而通过位置和兴趣更好地定位你的用户。在[第
    18 课](../Text/kindle_split_033.html#ch18)中，你将构建一个用户模型，以及任何应用程序管理其数据所需的基本 CRUD
    方法。
- en: '|  |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Try this**'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**尝试这个**'
- en: Now that you have two models set up, it’s time to step up your Mongoose methods
    game. First, practice creating a dozen subscribers and half a dozen courses. Then
    run a line of code to randomly associate each subscriber in your database to a
    course. Remember to save your changes after pushing courses into your subscribers’
    courses array.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经设置了两个模型，是时候提升你的 Mongoose 方法技能了。首先，练习创建一打订阅者和六门课程。然后运行一行代码，将数据库中的每个订阅者随机关联到一个课程。记得在将课程推入订阅者的课程数组后保存你的更改。
- en: When you’re done, log each subscriber to your console in REPL, using `populate`
    to see which courses you’ve associated each subscriber with.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成时，使用 `populate` 在 REPL 中将每个订阅者记录到你的控制台，以查看你为每个订阅者关联了哪些课程。
- en: '|  |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Lesson 18\. Building the user model
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 18 课\. 构建用户模型
- en: In [lesson 17](../Text/kindle_split_032.html#ch17), you improved your models
    by adding validators and instance methods. You also made your first model associations
    and populated data from referenced models. In this lesson, you apply some of those
    techniques to the user model. In doing so, you also interact with these models
    through their respective controllers and routes. Last, you build some forms and
    tables to make it easier to visualize all the data in the application.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第17课](../Text/kindle_split_032.html#ch17)中，您通过添加验证器和实例方法改进了您的模型。您还创建了第一个模型关联并从引用模型中填充数据。在本课中，您将应用这些技术到用户模型。这样做的同时，您也会通过各自的控制器和路由与这些模型进行交互。最后，您构建了一些表单和表格，以便更容易地可视化应用程序中的所有数据。
- en: This lesson covers
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 本课涵盖
- en: Creating model associations with a user model
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用用户模型创建模型关联
- en: Using virtual attributes
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用虚拟属性
- en: Implementing a CRUD structure on the user model
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在用户模型上实现CRUD结构
- en: Building an index page to view all users in your database
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个索引页面来查看您数据库中的所有用户
- en: '|  |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Consider this**'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: 'You have two models working with your recipe application: Subscriber and Course.
    You’d still like visitors to create accounts and start signing up for recipe programs.
    The user model is in nearly every modern application, along with a system to create,
    read, update, and delete (CRUD) data from the database. With the help of Mongoose,
    Express.js, and CRUD, your users will soon have a way to sign in to your application.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 您有两个模型与您的食谱应用程序一起工作：订阅者和课程。您仍然希望访客创建账户并开始注册食谱项目。用户模型几乎存在于每个现代应用程序中，以及一个从数据库创建、读取、更新和删除（CRUD）数据的系统。借助Mongoose、Express.js和CRUD，您的用户很快就会有一种登录您应用程序的方式。
- en: '|  |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)18.1\. Building the user model'
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)18.1. 构建用户模型'
- en: 'Now that you have models that protect against unwanted data in your database,
    you need to do the same for the most important model in the application: user.
    Your recipe application currently has a subscriber model and a course model to
    allow prospective users to show interest in certain recipe programs. The next
    step is allowing users to sign up for and enroll in these courses.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经有了防止数据库中不必要数据的模型，您需要为应用程序中最重要的模型：用户，做同样的事情。您的食谱应用程序目前有一个订阅者模型和一个课程模型，允许潜在用户对某些食谱项目表示兴趣。下一步是允许用户注册并加入这些课程。
- en: Like the subscriber model, the user model needs some basic information about
    each person who signs up. The model also needs an association with the course
    and subscriber models. (If a former subscriber decides to sign up as a user, for
    example, you want to connect the two accounts.) Then you want to track all the
    courses in which the user decides to participate.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 与订阅者模型一样，用户模型需要有关每个注册人员的某些基本信息。该模型还需要与课程和订阅者模型建立关联。（例如，如果以前的订阅者决定作为用户注册，您希望连接这两个账户。）然后您想跟踪用户决定参与的课程。
- en: To create the user model, add the code in [listing 18.1](#ch18ex01) to a new
    file in your models folder called user.js. The user schema contains many overlapping
    properties from the subscriber schema. Instead of a `name` property that’s one
    `String`, here, the `name` is an object containing `first` and `last`. This separation
    can help if you want to address the user by first name or last name only. Notice
    that the `trim` property is set to `true` to make sure that no extra whitespace
    is saved to the database with this property. `Email` and `zipCode` are the same
    as in the subscriber schema. The `password` property currently stores the user’s
    password as a string and is required before an account is created.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建用户模型，将[列表18.1](#ch18ex01)中的代码添加到您模型文件夹中的一个新文件中，文件名为user.js。用户模式包含来自订阅者模式的大量重叠属性。在这里，`name`属性不再是单一的`String`，而是包含`first`和`last`的对象。这种分离可以帮助您通过仅使用名字或姓氏来称呼用户。请注意，`trim`属性设置为`true`，以确保不将任何额外的空白保存到数据库中。`Email`和`zipCode`与订阅者模式中的相同。`password`属性目前以字符串形式存储用户的密码，在创建账户之前是必需的。
- en: '|  |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Warning
  id: totrans-257
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: For this unit only, you’ll be saving passwords to the database in plain text.
    This approach isn’t secure or recommended, however, as you’ll learn in [unit 5](../Text/kindle_split_037.html#part05).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本单元，您将只将密码以纯文本形式保存到数据库中。然而，这种方法并不安全或不推荐，您将在[第5单元](../Text/kindle_split_037.html#part05)中了解到。
- en: '|  |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: As in the subscriber schema, you associate the user to many courses. The user
    may also be connected to a single subscriber’s account. You can name the property
    `subscribed-Account` and remove brackets to signify that only one object is associated.
    A new set of properties, `createdAt` and `updatedAt`, populates with dates upon
    the creation of a user instance and any time you change values in the model. The
    `timestamps` property lets Mongoose know to include the `createdAt` and `updatedAt
    values`, which are useful for keeping records on how and when data changes. Add
    the `timestamps` property to the subscriber and course models, too.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 与订阅者模式类似，您将用户与多个课程关联。用户也可能与单个订阅者的账户关联。您可以命名属性为 `subscribed-Account` 并移除括号以表示仅关联一个对象。一组新的属性
    `createdAt` 和 `updatedAt` 会在创建用户实例时以及您在模型中更改值时填充日期。`timestamps` 属性让 Mongoose 知道要包含
    `createdAt` 和 `updatedAt` 值，这对于记录数据如何以及何时更改非常有用。将 `timestamps` 属性添加到订阅者和课程模型中，也是如此。
- en: '|  |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-262
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Notice the use of object destructuring for the Mongoose `Schema` object. `{Schema}`
    assigns the `Schema` object in `mongoose` to a constant by the same name. Later,
    you’ll apply this new format to other models.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 Mongoose `Schema` 对象使用了对象解构。`{Schema}` 将 `mongoose` 中的 `Schema` 对象赋值给同名常量。稍后，您将应用此新格式到其他模型中。
- en: '|  |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Listing 18.1\. Creating a User model in user.js
  id: totrans-265
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 18.1\. 在 user.js 中创建用户模型
- en: '[PRE9]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '***1*** **Create the user schema.**'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **创建用户模式。**'
- en: '***2*** **Add first and last name properties.**'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **添加姓名和姓氏属性。**'
- en: '***3*** **Add a password property.**'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **添加一个密码属性。**'
- en: '***4*** **Add a courses property to connect users to courses.**'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **添加一个课程属性以连接用户和课程。**'
- en: '***5*** **Add a subscribedAccount to connect users to subscribers.**'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **添加一个 subscribedAccount 属性以连接用户和订阅者。**'
- en: '***6*** **Add a timestamps property to record createdAt and updatedAt dates.**'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **添加一个 timestamps 属性以记录 createdAt 和 updatedAt 日期。**'
- en: Given that the first and last name may occasionally be useful in one line, you
    can use a Mongoose virtual attribute to store that data for each instance. A *virtual
    attribute* (also known as a *computed attribute*) is similar to a regular schema
    property but isn’t saved in the database. To create one, use the `virtual` method
    on your schema, and pass the property and new virtual attribute name you’d like
    to use. A virtual attribute for the user’s full name resembles the code in [listing
    18.2](#ch18ex02). This virtual attribute won’t be saved to the database, but it
    will behave like any other property on the user model, such as `user.zipCode`.
    You can retrieve this value with `user.fullName`. Below that is a line to create
    the user model.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 由于姓名和姓氏有时可能在一行中很有用，您可以使用 Mongoose 虚拟属性来为每个实例存储这些数据。*虚拟属性*（也称为*计算属性*）类似于常规模式属性，但不会保存到数据库中。要创建一个虚拟属性，请在您的模式上使用
    `virtual` 方法，并传递属性和您想要使用的新虚拟属性名称。用户全名的虚拟属性类似于[列表 18.2](#ch18ex02)中的代码。这个虚拟属性不会保存到数据库中，但它将像用户模型上的任何其他属性一样表现，例如
    `user.zipCode`。您可以使用 `user.fullName` 获取此值。下面是创建用户模型的代码。
- en: Listing 18.2\. Adding a virtual attribute to the user model in user.js
  id: totrans-274
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 18.2\. 在 user.js 中向用户模型添加虚拟属性
- en: '[PRE10]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '***1*** **Add a virtual attribute to get the user’s full name.**'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **添加一个虚拟属性以获取用户的全名。**'
- en: '|  |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-278
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: As of the writing of this book, you won’t be able to use arrow functions here
    because Mongoose methods use lexical `this`, on which ES6 arrow functions no longer
    depend.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书编写时，您无法在这里使用箭头函数，因为 Mongoose 方法使用词法 `this`，而 ES6 箭头函数不再依赖于它。
- en: '|  |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Test this model right away in REPL. Remember to require Mongoose and everything
    needed for this environment to work with your new model. With a new REPL session,
    you need to require Mongoose again, specify Mongoose to use native promises, and
    connect to your database by typing `mongoose.connect("mongodb://localhost:27017/recipe_db",
    {useNewUrlParser: true})`. Then require the new user model with `const User =
    require ("./models/user")`.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '立即在 REPL 中测试此模型。请记住，为了使用您的新模型，需要重新引入 Mongoose 以及此环境所需的所有内容。在新的 REPL 会话中，您需要再次引入
    Mongoose，指定 Mongoose 使用原生 promises，并通过输入 `mongoose.connect("mongodb://localhost:27017/recipe_db",
    {useNewUrlParser: true})` 连接到您的数据库。然后使用 `const User = require ("./models/user")`
    引入新的用户模型。'
- en: Create a new user instance in REPL, and log the returned user or error to see
    whether the model was set up correctly. [Listing 18.3](#ch18ex03) shows a working
    line to create a sample user. In this example, a user is created and saved to
    the database with all the required properties. Notice the extra space in the `last`
    field, which should be trimmed through Mongoose before saving to the database.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在 REPL 中创建一个新的用户实例，并将返回的用户或错误记录下来，以查看模型是否设置正确。[列表 18.3](#ch18ex03) 显示了一个创建示例用户的有效行。在此示例中，用户被创建并保存到数据库中，具有所有必需的属性。请注意
    `last` 字段中的额外空格，这应该在通过 Mongoose 保存到数据库之前通过修剪。
- en: '|  |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-284
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: You can add the REPL commands in these examples to your REPL.js file for future
    use.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将这些示例中的 REPL 命令添加到您的 REPL.js 文件中以供将来使用。
- en: '|  |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Listing 18.3\. Creating a new user in REPL in terminal
  id: totrans-287
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 18.3\. 在终端的 REPL 中创建新用户
- en: '[PRE11]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '***1*** **Create a new user.**'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **创建新用户。**'
- en: '|  |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-291
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you get an error complaining about unique email addresses, it probably means
    that you’re trying to create a user with the same information as one in your database
    (which isn’t permitted, due to the rules you set in the user schema). To get around
    this restriction, create a user with a different email address or use the `find()`
    method instead of create, like so: `User.findOne({email: "jon@jonwexler.com"}).then(u`=>
    `testUser = u) .catch(e` => `console.log(e.message));`.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '如果您收到关于唯一电子邮件地址的错误，这可能意味着您正在尝试创建一个与数据库中已有的信息相同（由于您在用户模式中设置的规则，这是不允许的）的用户。为了绕过此限制，请使用不同的电子邮件地址创建用户，或者使用
    `find()` 方法而不是 `create`，如下所示：`User.findOne({email: "jon@jonwexler.com"}).then(u
    => testUser = u) .catch(e => console.log(e.message));`。'
- en: '|  |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The `user` variable should now contain the document object shown in the next
    listing. Notice that the `courses` property for this user is an empty array. Later,
    when you associate this user with courses, that property will populate with `ObjectId`s.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`user` 变量现在应包含下一列表中显示的文档对象。请注意，此用户的 `courses` 属性是一个空数组。稍后，当您将此用户与课程关联时，该属性将填充
    `ObjectId`s。'
- en: Listing 18.4\. Showing the results of a saved user object in terminal
  id: totrans-295
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 18.4\. 在终端中显示已保存的用户对象的结果
- en: '[PRE12]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***1*** **Display of query response**'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **查询响应的显示**'
- en: Now you can use the information from this user to link any subscribers in the
    system with the same email. To link a subscriber, see the code in [listing 18.5](#ch18ex05).
    You’re setting up a `targetSubscriber` variable scoped outside of the query and
    assigning it the results of the query on the subscriber model. This way, you can
    use your `targetSubscriber` variable after the query completes. In this query,
    you’re using the user’s email from the `create` command earlier to search over
    subscribers.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用此用户的信息将系统中的任何具有相同电子邮件的订阅者链接起来。要链接订阅者，请参阅 [列表 18.5](#ch18ex05) 中的代码。您正在设置一个
    `targetSubscriber` 变量，其作用域在查询之外，并将查询结果分配给订阅者模型。这样，您可以在查询完成后使用 `targetSubscriber`
    变量。在此查询中，您正在使用之前 `create` 命令中的用户电子邮件来搜索订阅者。
- en: Listing 18.5\. Connecting a subscriber to the user in REPL in terminal
  id: totrans-299
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 18.5\. 在终端的 REPL 中将订阅者连接到用户
- en: '[PRE13]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '***1*** **Set the targetSubscriber variable to a subscriber found with the
    user’s email address.**'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **将 `targetSubscriber` 变量设置为使用用户电子邮件地址找到的订阅者。**'
- en: After you run these commands, your `targetSubscriber` variable should contain
    the value of the subscriber object that shares the user’s email address. You can
    `console.log(target Subscriber);` to see that content in your REPL environment.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 执行这些命令后，您的 `targetSubscriber` 变量应包含与用户共享电子邮件地址的订阅者对象的价值。您可以使用 `console.log(target
    Subscriber);` 在您的 REPL 环境中查看该内容。
- en: With promises, you can condense these two operations into one, as shown in [listing
    18.6](#ch18ex06). By nesting the call to find associated subscribers, you get
    a promise chain that can be moved as a whole into a controller action. First,
    create the new user. You get back the new user whose email you use to search for
    subscribers with the same email. The second query returns any subscribers that
    exist. When you find the subscriber with the same email, you can link it with
    the user by its attribute name on the user model, `subscribedAccount`. Finally,
    save the change.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 使用承诺，您可以将这些两个操作压缩成一个，如 [列表 18.6](#ch18ex06) 中所示。通过嵌套调用关联订阅者的查找，您得到一个可以整体移动到控制器动作中的承诺链。首先，创建新用户。您将返回使用您用于搜索具有相同电子邮件的订阅者的电子邮件的新用户。第二个查询返回任何存在的订阅者。当您找到具有相同电子邮件的订阅者时，您可以通过用户模型上的
    `subscribedAccount` 属性将其与用户链接。最后，保存更改。
- en: Listing 18.6\. Connecting a subscriber to the user in REPL in terminal
  id: totrans-304
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 18.6\. 在终端的 REPL 中将订阅者连接到用户
- en: '[PRE14]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '***1*** **Find a subscriber with the user’s email.**'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **查找具有用户电子邮件的订阅者。**'
- en: '***2*** **Connect a subscriber and user.**'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **连接订阅者和用户。**'
- en: Now that you can create a user and connect it to another model in REPL, the
    next step is moving this interaction to the controllers and views.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以在 REPL 中创建用户并将其连接到另一个模型，下一步是将这种交互移动到控制器和视图中。
- en: '|  |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-310
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You’ve moved to REPL to test your database queries, so you can remove the required
    `subscriber` module from main.js, where it’s no longer needed.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 您已移动到 REPL 以测试数据库查询，因此可以从 main.js 中删除不再需要的 `subscriber` 模块。
- en: '|  |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 18.1**'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 18.1**'
- en: '**[Q1:](#ch18qa3q0a1)**'
  id: totrans-315
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch18qa3q0a1)**'
- en: ''
  id: totrans-316
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How are virtual attributes different from normal model attributes?
  id: totrans-317
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 虚拟属性与正常模型属性有何不同？
- en: '|  |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 18.1 answer**'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 18.1 答案**'
- en: '**[1:](#ch18qa1q1)**'
  id: totrans-321
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch18qa1q1)**'
- en: ''
  id: totrans-322
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Virtual attributes aren’t saved in the database. These attributes, unlike normal
    schema attributes, exist only while the application is running; they can’t be
    extracted from the database or found directly through MongoDB.
  id: totrans-323
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 虚拟属性不会保存到数据库中。这些属性与正常模式属性不同，仅在应用程序运行期间存在；它们不能从数据库中提取或直接通过 MongoDB 找到。
- en: '|  |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '![](../Images/sectionFig.png)18.2\. Adding CRUD methods to your models'
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)18.2\. 将 CRUD 方法添加到您的模型中'
- en: 'In this section, I discuss the next steps you need to take with the user, subscriber,
    and group models. All three models have schemas and associations that work in
    REPL, but you’re going to want to use them in the browser. More specifically,
    you want to manage the data for each model as an admin of the site and allow users
    to create their own user accounts. First, I’ll talk about the four major functions
    in database operations: create, read, update, and delete (CRUD). [Figure 18.1](#ch18fig01)
    illustrates these functions.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将讨论您需要与用户、订阅者和群体模型采取的下一步行动。这三个模型都有在 REPL 中工作的模式和关联，但您可能希望在使用浏览器时使用它们。更具体地说，您希望作为站点的管理员管理每个模型的数据，并允许用户创建自己的用户账户。首先，我将讨论数据库操作中的四个主要功能：创建、读取、更新和删除（CRUD）。[图
    18.1](#ch18fig01) 展示了这些功能。
- en: Figure 18.1\. Views for each CRUD action
  id: totrans-327
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 18.1\. 每个CRUD操作的视图
- en: '![](../Images/18fig01_alt.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/18fig01_alt.jpg)'
- en: In web development, a CRUD application lays the groundwork for any larger or
    more evolved application, because at the root and in some way, you always need
    to perform the actions listed in [table 18.1](#ch18table01) on each model.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络开发中，CRUD 应用程序为任何更大或更进化的应用程序奠定了基础，因为从根本上说，以某种方式，您始终需要在每个模型上执行 [表 18.1](#ch18table01)
    中列出的操作。
- en: Table 18.1\. CRUD actions
  id: totrans-330
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 18.1\. CRUD 操作
- en: '| Action | Description |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 描述 |'
- en: '| --- | --- |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Create | The create function has two parts: new and create. new represents
    the route and action taken to view the form with which you’ll create a new instance
    of your model. To create a new user, for example, you might visit http://localhost:3000/users/
    new to view a user-creation form located in new.ejs. The create route and action
    handle any POST requests from that form. |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| 创建 | 创建功能分为两部分：new 和 create。new 代表查看用于创建模型新实例的表单的路由和操作。例如，要创建新用户，您可能访问 http://localhost:3000/users/
    new 来查看位于 new.ejs 中的用户创建表单。创建路由和操作处理来自该表单的任何 POST 请求。|'
- en: '| Read | The read function has only one route, action, and view. In this book,
    their names are show to reflect that you’re showing that model’s information,
    most likely as a profile page. Although you’re still reading from the database,
    the show action and show.ejs view are more conventional names used for this operation.
    |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| 读取 | 读取功能只有一个路由、操作和视图。在本书中，它们的名称是 show，以反映您正在显示该模型的信息，很可能是作为个人资料页面。尽管您仍在从数据库中读取，但
    show 操作和 show.ejs 视图是用于此操作的更传统的名称。|'
- en: '| Update | The update function has two parts: edit and update. edit, like new,
    handles GET requests to the edit route and edit.ejs view, where you’ll find a
    form to change a model’s attribute values. When you modify the values and submit
    the form by using a PUT request, the update route and action handle that request.
    These functions depend on some instance of the model preexisting in your database.
    |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| 更新 | 更新功能分为两部分：edit 和 update。edit，就像 new 一样，处理对编辑路由和 edit.ejs 视图的 GET 请求，在那里您将找到一个用于更改模型属性值的表单。当您修改值并通过使用
    PUT 请求提交表单时，更新路由和操作处理该请求。这些功能依赖于数据库中预先存在的模型实例。|'
- en: '| Delete | The delete function can be the simplest of the functions. Although
    you can create a view to ask a user whether he’s sure that he wants to delete
    a record, this function is usually implemented with a button that sends a DELETE
    request to a route with a user’s ID. Then the delete route and action remove the
    record from your database. |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| Delete | 删除函数可能是最简单的函数。虽然你可以创建一个视图来询问用户他是否确定要删除记录，但这个函数通常是通过发送一个包含用户ID的DELETE请求到路由的按钮来实现的。然后删除路由和操作会从你的数据库中删除记录。|'
- en: For the new.ejs and edit.ejs forms, you need to route the form submissions to
    `create` and `update` routes, respectively. When you submit a form to create a
    new user, for example, the form data should be posted to the `user/create` route.
    The following examples walk you through the creation of CRUD actions and views
    for the user model, but you should apply the same technique to the course and
    subscriber models.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 对于new.ejs和edit.ejs表单，你需要将表单提交路由到`create`和`update`路由，分别。例如，当你提交表单以创建新用户时，表单数据应该被发送到`user/create`路由。以下示例将指导你创建用户模型的CRUD操作和视图，但你应该将相同的技巧应用到课程和订阅者模型。
- en: '|  |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**CRUD HTTP methods**'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '**CRUD HTTP方法**'
- en: Earlier in this book, you learned about the `GET` and `POST` HTTP methods, which
    account for most of the requests made across the internet. Many other HTTP methods
    are used in specific cases, and with the update and delete functions, you can
    introduce two more, as shown in [table 18.2](#ch18table02).
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的前面，你学习了`GET`和`POST`HTTP方法，这些方法占到了互联网上大多数请求的很大一部分。许多其他HTTP方法在特定情况下使用，并且通过更新和删除功能，你可以引入另外两种，如[表18.2](#ch18table02)所示。
- en: Table 18.2\. PUT and DELETE HTTP methods
  id: totrans-341
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表18.2\. PUT和DELETE HTTP方法
- en: '| HTTP method | Description |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| HTTP方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| PUT | The method used to indicate that you’re submitting data to the application
    server with the intention of modifying or updating an existing record. PUT usually
    replaces the existing record with a new set of attributes, even if some haven’t
    changed. Although PUT is the leading method for updating records, some people
    prefer the PATCH method, which is intended to modify only the attributes that
    have changed. To handle update routes in Express.js, you can use app.put. |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| PUT | 用于指示你向应用程序服务器提交数据，目的是修改或更新现有记录的方法。PUT通常用一组新的属性替换现有记录，即使某些属性没有变化。虽然PUT是更新记录的首选方法，但有些人更喜欢PATCH方法，它旨在仅修改已更改的属性。要处理Express.js中的更新路由，你可以使用app.put。|'
- en: '| DELETE | The method used to indicate that you’re removing a record from your
    database. To handle delete routes in Express.js, you can use app.delete. |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| DELETE | 用于指示你从数据库中删除记录的方法。要处理Express.js中的删除路由，你可以使用app.delete。|'
- en: Although you can get away with using `GET` and `POST` to update and delete records,
    it’s best to follow these best practices when using HTTP methods. With consistency,
    your application will run with fewer problems and better transparency when problems
    arise. I discuss these methods further in [lesson 19](../Text/kindle_split_034.html#ch19).
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以使用`GET`和`POST`来更新和删除记录，但在使用HTTP方法时最好遵循这些最佳实践。一致性可以使你的应用程序在出现问题时运行得更好，并且具有更好的透明度。我在[第19课](../Text/kindle_split_034.html#ch19)中进一步讨论了这些方法。
- en: '|  |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Before you get started, take a look at your controllers, and prepare them for
    a renovation. So far, you’ve created new controller actions by adding them to
    the module’s `exports` object. The more actions you create, the more you repeat
    that `exports` object, which isn’t particularly pretty in the controller module.
    You can clean up your controller actions by exporting them all together with `module.exports`
    in an object literal. Modify your home controller to the code in [listing 18.7](#ch18ex07).
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始之前，查看你的控制器，并为它们准备翻新。到目前为止，你通过将它们添加到模块的`exports`对象中来创建新的控制器操作。你创建的操作越多，你重复的`exports`对象就越多，这在控制器模块中并不特别美观。你可以通过将所有操作一起使用对象字面量中的`module.exports`导出，来清理你的控制器操作。将你的主控制器修改为[列表18.7](#ch18ex07)中的代码。
- en: In this example, your actions are now comma-delimited, which makes the names
    of the actions much easier to identify. After you apply this change in the controller,
    you don’t need to change any other code for the application to function as it
    did before.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你的操作现在是逗号分隔的，这使得操作名称更容易识别。在你将此更改应用到控制器后，你不需要更改任何其他代码，应用程序就可以像以前一样运行。
- en: Listing 18.7\. Modifying your actions in homeController.js
  id: totrans-350
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表18.7\. 修改homeController.js中的操作
- en: '[PRE15]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '***1*** **Export object literal with all controller actions.**'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **导出包含所有控制器操作的字面量对象。**'
- en: Apply this structure to your other controllers (`errorController.js` and `subscribers-Controller.js`)
    and to all controllers moving forward. These modifications will start to become
    important as you build out your CRUD actions and structure your middleware within
    your routes.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 将此结构应用于你的其他控制器（`errorController.js` 和 `subscribers-Controller.js`）以及未来的所有控制器。当你构建
    CRUD 操作并在你路由中组织中间件时，这些修改将变得很重要。
- en: '|  |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-355
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Also create `coursesController.js` and `usersController.js` in your `controllers`
    folder so that you can create the same actions for the course and user models
    over the next few lessons.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 还应在你的 `controllers` 文件夹中创建 `coursesController.js` 和 `usersController.js`，以便在接下来的几节课中为课程和用户模型创建相同的操作。
- en: '|  |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'In the next section, you build the forms you need for the user model. First,
    though, create an often-overlooked view for the application: index.ejs. Also create
    this index page for each application model. The purpose of the `index` route,
    action, and view is to fetch all records and display them on a single page. You
    build the index page in the next section.'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将构建用户模型所需的形式。首先，创建一个经常被忽视的应用视图：index.ejs。还要为每个应用模型创建此索引页面。`index` 路由、操作和视图的目的是获取所有记录并在单个页面上显示它们。你将在下一节中构建索引页面。
- en: '|  |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 18.2**'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 18.2**'
- en: '**[Q1:](#ch18qa6q0a1)**'
  id: totrans-361
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch18qa6q0a1)**'
- en: ''
  id: totrans-362
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What CRUD functions don’t necessarily need a view?
  id: totrans-363
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 哪些 CRUD 函数不一定需要一个视图？
- en: '|  |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 18.2 answer**'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 18.2 答案**'
- en: '**[1:](#ch18qa4q1)**'
  id: totrans-367
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch18qa4q1)**'
- en: ''
  id: totrans-368
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Although every CRUD function can have its own view, some functions could live
    in modals or be accessed through a basic link request. The `delete` function doesn’t
    necessarily need its own view because you’re sending a command to delete a record.
  id: totrans-369
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 虽然每个 CRUD 函数都可以有自己的视图，但某些函数可以存在于模态中或通过基本链接请求访问。`delete` 函数不一定需要自己的视图，因为你正在发送一个删除记录的命令。
- en: '|  |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)18.3\. Building the index page'
  id: totrans-371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)18.3\. 构建索引页面'
- en: To start, create the index.ejs view by creating a new users folder inside the
    views folder and adding the code in [listing 18.8](#ch18ex08).
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过在视图文件夹中创建一个新的用户文件夹并添加 [列表 18.8](#ch18ex08) 中的代码来创建 index.ejs 视图。
- en: In this view, you’re looping through a `users` variable and creating a new table
    row listing each user’s attributes. The same type of table can be used for subscribers
    and courses. You need to populate the `users` variable with an array of users
    at the controller level.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在此视图中，你正在遍历一个 `users` 变量，并为每个用户的属性创建一个新的表格行。相同类型的表格也可以用于订阅者和课程。你需要在控制器级别使用一个用户数组来填充
    `users` 变量。
- en: '|  |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-375
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You should apply the same approach to other models in your application. The
    subscriber model views will now go in the subscribers folder within the views
    folder, for example.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该将相同的方法应用于应用程序中的其他模型。例如，订阅者模型视图现在将放在视图文件夹中的 subscribers 文件夹内。
- en: '|  |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Listing 18.8\. Listing all users in index.js
  id: totrans-378
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 18.8\. 在 index.js 中列出所有用户
- en: '[PRE16]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '***1*** **Loop through an array of users in the view.**'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **在视图中遍历用户数组。**'
- en: To test this code, you need a route and controller action that will load this
    view. Create a `usersController.js` in the controllers folder with the code in
    [listing 18.9](#ch18ex09).
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试此代码，你需要一个路由和控制器操作来加载此视图。在控制器文件夹中创建一个 `usersController.js`，并包含 [列表 18.9](#ch18ex09)
    中的代码。
- en: You need to require the user model in `usersController.js` to have access to
    it in this controller. First, you receive a response from the database with your
    users. Then you render your list of users in your index.ejs view. If an error
    occurs, log the message to the console and redirect the response to the home page.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在 `usersController.js` 中引入用户模型，以便在此控制器中访问它。首先，你从数据库接收一个包含你的用户的响应。然后你在 index.ejs
    视图中渲染你的用户列表。如果发生错误，将消息记录到控制台并将响应重定向到主页。
- en: Listing 18.9\. Creating the index action in usersController.js
  id: totrans-383
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 18.9\. 在 usersController.js 中创建索引操作
- en: '[PRE17]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '***1*** **Require the user model.**'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **引入用户模型。**'
- en: '***2*** **Render the index page with an array of users.**'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **使用用户数组渲染索引页面。**'
- en: '***3*** **Log error messages and redirect to the home page.**'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **记录错误消息并将重定向到主页。**'
- en: '|  |'
  id: totrans-388
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-389
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: In the subscribers controller, the index action replaces your `getAllSubscribers`
    action. Remember to modify the action’s corresponding route in main.js to point
    to `index` and to change the subscribers.ejs file to index.ejs. This view should
    now live in a subscribers folder within views.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在订阅者控制器中，`index` 动作替换了你的 `getAllSubscribers` 动作。记住要修改 main.js 中动作对应的路由，将其指向
    `index`，并将 subscribers.ejs 文件更改为 index.ejs。这个视图现在应该位于 views 中的 subscribers 文件夹内。
- en: '|  |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The last step is introducing the `usersController` to main.js and adding the
    `index` route by adding the code in [listing 18.10](#ch18ex10) to main.js.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将 `usersController` 引入到 main.js 中，并通过在 [清单 18.10](#ch18ex10) 中添加代码到 main.js
    来添加 `index` 路由。
- en: First, require the `usersController` into main.js. Add this line below where
    your `subscribers-Controller` is defined. Creating your first user route, take
    incoming requests to `/users`, and use the `index` action in `usersController`.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将 `usersController` 引入到 main.js 中。在你的 `subscribers-Controller` 定义下方添加此行。创建你的第一个用户路由，将传入的请求发送到
    `/users`，并使用 `usersController` 中的 `index` 动作。
- en: Listing 18.10\. Adding `usersController` and a route to main.js
  id: totrans-394
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 18.10\. 在 main.js 中添加 `usersController` 和路由
- en: '[PRE18]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '***1*** **Require usersController.**'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **需要使用 usersController。**'
- en: '***2*** **Create the index route.**'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **创建索引路由。**'
- en: Fire up your application in terminal, and visit http://localhost:3000/users.
    Your screen should resemble [figure 18.2](#ch18fig02).
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端启动你的应用程序，并访问 http://localhost:3000/users。你的屏幕应该类似于 [图 18.2](#ch18fig02)。
- en: Figure 18.2\. Example of users index page in your browser
  id: totrans-399
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 18.2\. 浏览器中用户索引页面的示例
- en: '![](../Images/18fig02_alt.jpg)'
  id: totrans-400
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/18fig02_alt.jpg)'
- en: This list is your window into the database without revealing any sensitive data
    to the public. Before you continue, though, make one more modification to your
    routes and actions.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表是你查看数据库的窗口，同时不会向公众透露任何敏感数据。在你继续之前，请对路由和动作进行最后一次修改。
- en: '|  |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 18.3**'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 18.3**'
- en: '**[Q1:](#ch18qa9q0a1)**'
  id: totrans-404
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch18qa9q0a1)**'
- en: ''
  id: totrans-405
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the purpose of the index view?
  id: totrans-406
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 索引视图的目的是什么？
- en: '|  |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 18.3 answer**'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 18.3 答案**'
- en: '**[1:](#ch18qa7q1)**'
  id: totrans-410
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch18qa7q1)**'
- en: ''
  id: totrans-411
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The index view displays all documents for a particular model. This view can
    be used internally by a company to see the names and email addresses of everyone
    who subscribed. It can also be visible to all users so that everyone can see who
    signed up.
  id: totrans-412
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: The index view displays all documents for a particular model. This view can
    be used internally by a company to see the names and email addresses of everyone
    who subscribed. It can also be visible to all users so that everyone can see who
    signed up.
- en: '|  |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)18.4\. Cleaning up your actions'
  id: totrans-414
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)18.4\. 清理你的动作'
- en: Right now, your index action is designed to serve only an EJS template view
    with data from your database. You may not always want to serve your data in a
    view, however, as you learn in [unit 6](../Text/kindle_split_042.html#part06).
    To make better use of your actions, break them into an action to run your query
    and an action to serve results through your view.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，你的索引动作被设计为仅提供来自数据库的数据的 EJS 模板视图。然而，正如你在 [单元 6](../Text/kindle_split_042.html#part06)
    中学到的，你并不总是想以视图的形式提供数据。为了更好地使用你的动作，将它们分解为运行查询的动作和通过视图提供结果的动作。
- en: Modify the users controller to the code shown in [listing 18.11](#ch18ex11).
    In this revised code, you have the `index` action, which calls the `find` query
    on the user model. If you successfully produce results, add those results to the
    `res.locals` object—a unique object on the response that lets you define a variable
    to which you’ll have access in your view. By assigning the results to `res.locals.users`,
    you won’t need to change your view; the variable name `users` matches locally
    in the view. Then call the next middleware function. If an error occurs in the
    query, log the error, and pass it to the next middleware function that will handle
    the error. In this case, that function is the `internalServerError` action in
    the errors controller. The `indexView` action renders the index view.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 将用户控制器修改为 [清单 18.11](#ch18ex11) 中显示的代码。在这段修改后的代码中，你有一个 `index` 动作，它会在用户模型上调用
    `find` 查询。如果你成功生成结果，将这些结果添加到 `res.locals` 对象中——这是响应中的一个独特对象，允许你定义一个变量，你将在视图中访问它。通过将结果分配给
    `res.locals.users`，你不需要更改你的视图；变量名 `users` 在视图中本地匹配。然后调用下一个中间件函数。如果在查询中发生错误，记录错误，并将其传递给下一个中间件函数，该函数将处理错误。在这种情况下，该函数是错误控制器中的
    `internalServerError` 动作。`indexView` 动作渲染索引视图。
- en: Listing 18.11\. Revisiting the index action in usersController.js
  id: totrans-417
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 18.11\. 在 usersController.js 中重新访问索引动作
- en: '[PRE19]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '***1*** **Run query in index action only.**'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **仅在索引动作中运行查询。**'
- en: '***2*** **Store the user data on the response and call the next middleware
    function.**'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **在响应中存储用户数据并调用下一个中间件函数。**'
- en: '***3*** **Catch errors, and pass to the next middleware.**'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **捕获错误，并将其传递给下一个中间件。**'
- en: '***4*** **Render view in separate action.**'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **在单独的动作中渲染视图。**'
- en: 'To get your application to load your users on the index page as before, add
    the `indexView` action as the middleware function that follows the `index` action
    in your route. To do so, change the `/users` route in `main.js` to the following
    code: `app.get("/users", usersController.index, usersController.indexView)`. When
    `usersController.index` completes your query and adds your data to the response
    object, `usersController.indexView` is called to render the view. With this change,
    you could later decide to call a different middleware function after the index
    action in another route, which is exactly what you’ll do in [unit 6](../Text/kindle_split_042.html#part06).'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你的应用程序在索引页面上加载用户数据，就像之前一样，将 `indexView` 动作作为中间件函数添加到你的路由中，该函数位于 `index` 动作之后。为此，将
    `main.js` 中的 `/users` 路由更改为以下代码：`app.get("/users", usersController.index, usersController.indexView)`。当
    `usersController.index` 完成查询并将数据添加到响应对象中时，会调用 `usersController.indexView` 来渲染视图。通过这个更改，你可以在另一个路由的索引动作之后决定调用不同的中间件函数，这正是你将在[第
    6 单元](../Text/kindle_split_042.html#part06)中做的。
- en: Now you have a way, other than REPL and the MongoDB shell, to view the users,
    courses, and subscribers in your database. In [lesson 19](../Text/kindle_split_034.html#ch19),
    you pull more functionality into the views.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你除了 REPL 和 MongoDB shell 之外，还有一种方法可以查看数据库中的用户、课程和订阅者。在[第 19 课](../Text/kindle_split_034.html#ch19)中，你将更多的功能引入到视图中。
- en: '|  |'
  id: totrans-425
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 18.4**'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 18.4**'
- en: '**[Q1:](#ch18qa12q0a1)**'
  id: totrans-427
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch18qa12q0a1)**'
- en: ''
  id: totrans-428
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why do you need to log error messages to the console if you’re working mainly
    in the browser?
  id: totrans-429
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你主要在浏览器中工作，为什么你需要将错误消息记录到控制台？
- en: '|  |'
  id: totrans-430
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-431
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 18.4 answer**'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 18.4 答案**'
- en: '**[1:](#ch18qa10q1)**'
  id: totrans-433
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch18qa10q1)**'
- en: ''
  id: totrans-434
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Although you’re moving more data and functionality into the views, your terminal
    is still the heart of your application. Your console window is where you should
    expect to see application errors, requests made, and custom error messages you
    create so that you’ll know where to look to fix the problem.
  id: totrans-435
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 虽然你正在将更多的数据和功能移入视图，但你的终端仍然是应用程序的核心。你的控制台窗口是你应该期望看到应用程序错误、发出的请求以及你创建的自定义错误消息的地方，这样你就可以知道在哪里查找以修复问题。
- en: '|  |'
  id: totrans-436
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '![](../Images/sectionFig.png)Summary'
  id: totrans-437
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)摘要'
- en: In this lesson, you learned how to create a user model and where to get started
    with CRUD functions. You also learned about two new HTTP methods and saw how to
    create an index page to display all your users. With this index page, you started
    to interact with your application from the browser. Finally, you modified your
    controller and routes to make better use of middleware functions and interactivity
    among your actions. In [lesson 19](../Text/kindle_split_034.html#ch19), you apply
    the `create` and `read` functions to your three models.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，你学习了如何创建用户模型以及如何开始使用 CRUD 函数。你还了解了两种新的 HTTP 方法，并看到了如何创建一个索引页面来显示所有用户。有了这个索引页面，你开始从浏览器与你的应用程序进行交互。最后，你修改了控制器和路由，以便更好地使用中间件函数和动作之间的交互性。在[第
    19 课](../Text/kindle_split_034.html#ch19)中，你将 `create` 和 `read` 函数应用于你的三个模型。
- en: '|  |'
  id: totrans-439
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Try this**'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '**尝试这个**'
- en: With your index page set up, try to think about how an administrator of your
    application might use this page. You created the table to display user data, but
    you may want other columns in this table. Create new user instance methods to
    give you the number of characters in each user’s name and then create a new column
    in this table to show that number for each user.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好索引页面后，试着思考你的应用程序管理员可能会如何使用这个页面。你创建了用于显示用户数据的表格，但你可能还想在这个表格中添加其他列。创建新的用户实例方法来获取每个用户名字符的数量，然后在这个表格中创建一个新列来显示每个用户的这个数字。
- en: Try creating a new virtual attribute for the user model.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试为用户模型创建一个新的虚拟属性。
- en: '|  |'
  id: totrans-443
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Lesson 19\. Creating and reading your models
  id: totrans-444
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 19 课。创建和读取你的模型
- en: In [lesson 18](../Text/kindle_split_033.html#ch18), you constructed your user
    model and built an index page to display users on the same page. In this lesson,
    you add more functionality to your application by focusing on the create and read
    functions of CRUD. You start by creating an EJS form that handles a user’s attributes
    as inputs. Then you create the routes and actions to handle that form data. Last,
    you build a `show` page to act as the user’s profile page.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第18课](../Text/kindle_split_033.html#ch18)中，你构建了你的用户模型并构建了一个索引页面来在同一页面上显示用户。在本课中，你通过关注CRUD的创建和读取功能来为你的应用程序添加更多功能。你首先创建了一个EJS表单，该表单将用户的属性作为输入处理。然后你创建了路由和动作来处理该表单数据。最后，你构建了一个`show`页面作为用户的个人资料页面。
- en: This lesson covers
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 本课涵盖
- en: Constructing a model creation form
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建模型创建表单
- en: Saving users to your database from the browser
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从浏览器保存用户到数据库
- en: Displaying associated models in a view
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在视图中显示关联模型
- en: '|  |'
  id: totrans-450
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Consider this**'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: With a new way to create courses for your recipe application, you’re finding
    it tedious to add individual documents to your database on REPL. You decided to
    create dedicated routes to create new model instances, edit them, and display
    their data. These routes are the foundations of CRUD methods that allow interaction
    with your data to flow through your application views.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 在为你的食谱应用程序创建新课程的新方法中，你发现将单个文档添加到REPL数据库中变得繁琐。你决定创建专用路由来创建新的模型实例、编辑它们并显示它们的数据。这些路由是CRUD方法的基础，允许你的数据交互通过应用程序视图进行。
- en: '|  |'
  id: totrans-453
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)19.1\. Building the new user form'
  id: totrans-454
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![图片描述](../Images/sectionFig.png)19.1. 构建新用户表单'
- en: To create a new user instance in your database, you need some way of retrieving
    that user’s data. So far, you’ve been entering that data directly in REPL. Because
    you’re moving all your data interactions to the browser, you need a form through
    which new users can create their accounts. In CRUD terms, that form lives in a
    view called new.ejs.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 要在数据库中创建一个新的用户实例，你需要一种方法来检索该用户的数据。到目前为止，你一直直接在REPL中输入这些数据。因为你正在将所有数据交互移动到浏览器，你需要一个表单，让新用户可以通过它创建他们的账户。在CRUD术语中，该表单位于名为new.ejs的视图中。
- en: To start, build that form by adding the code in [listing 19.1](#ch19ex01) to
    new.js in the views/users folder. The resulting form looks like [figure 19.1](#ch19fig01).
    This form makes a `POST` request to the `/users/create` route upon submission.
    You need to make sure to create that route before you try to submit anything;
    otherwise, your application will crash.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过将[列表19.1](#ch19ex01)中的代码添加到视图中/users文件夹的new.js中，构建该表单。生成的表单看起来像[图19.1](#ch19fig01)。在提交时，该表单会向`/users/create`路由发送一个`POST`请求。你需要确保在尝试提交任何内容之前创建该路由；否则，你的应用程序将会崩溃。
- en: Figure 19.1\. Example of user-creation form in your browser
  id: totrans-457
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图19.1. 浏览器中用户创建表单的示例
- en: '![](../Images/19fig01_alt.jpg)'
  id: totrans-458
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](../Images/19fig01_alt.jpg)'
- en: The form is embellished with bootstrap, but the major takeaways are that each
    user attribute is represented as a form input and that the attribute’s name is
    set to that input’s `name` property—in the case of the first name, `name="first"`.
    You’ll use these name attributes later to identify values in the controller. Notice
    that the `password`, `email`, and `zipCode` fields have some unique properties.
    These HTML validations are some ways that you can prevent invalid or insecure
    information from entering your application from the web page.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 该表单使用了Bootstrap进行装饰，但主要收获是每个用户属性都表示为一个表单输入，并且该属性的名称设置为该输入的`name`属性——在姓氏的情况下，`name="first"`。你将在以后使用这些名称属性来识别控制器中的值。请注意，`password`、`email`和`zipCode`字段有一些独特的属性。这些HTML验证是一些你可以防止无效或不安全信息从网页进入你的应用程序的方法。
- en: Listing 19.1\. Building a user creation form in new.ejs
  id: totrans-460
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表19.1. 在new.ejs中构建用户创建表单
- en: '[PRE20]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '***1*** **Build a form to create user accounts.**'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **构建一个创建用户账户的表单。**'
- en: '***2*** **Add user properties as inputs to the form.**'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **将用户属性作为输入添加到表单中。**'
- en: '***3*** **Apply HTML attributes to protect password and email fields.**'
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **将HTML属性应用于保护密码和电子邮件字段。**'
- en: Now that you have a new view, you need a route and controller actions to serve
    that view. You also add the `create` routes and actions to handle data from that
    view in the next section.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了新的视图，你需要一个路由和控制器动作来服务该视图。你还在下一节中添加了`create`路由和动作来处理来自该视图的数据。
- en: '|  |'
  id: totrans-466
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 19.1**'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查19.1**'
- en: '**[Q1:](#ch19qa3q0a1)**'
  id: totrans-468
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[问题1:](#ch19qa3q0a1)**'
- en: ''
  id: totrans-469
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which form input attribute must have a value for controller actions to identify
    form data?
  id: totrans-470
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 哪个表单输入属性必须有一个值，以便控制器动作能够识别表单数据？
- en: '|  |'
  id: totrans-471
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-472
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 19.1 answer**'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 19.1 答案**'
- en: '**[1:](#ch19qa1q1)**'
  id: totrans-474
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch19qa1q1)**'
- en: ''
  id: totrans-475
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `name` attribute must be filled in on the form to create a new record. Whatever
    value is mapped to the `name` attribute is what the controller uses to compare
    against the model schema.
  id: totrans-476
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在表单中必须填写 `name` 属性以创建新记录。映射到 `name` 属性的任何值都是控制器用于与模型模式进行比较的值。
- en: '|  |'
  id: totrans-477
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '![](../Images/sectionFig.png)19.2\. Creating new users from a view'
  id: totrans-478
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)19.2\. 从视图创建新用户'
- en: The form for new users collects data as it pertains to the user schema. Next,
    you need to create actions for this form. To get your form to render and process
    data, add the code for the user actions in [listing 19.2](#ch19ex02) to `usersController.js`.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 新用户表单收集与用户模式相关的数据。接下来，您需要为该表单创建动作。为了使表单能够渲染和处理数据，将 [列表 19.2](#ch19ex02) 中的用户动作代码添加到
    `usersController.js` 中。
- en: The `new` action takes incoming requests to create a new user and render the
    form in new.ejs. The `create` action receives incoming posted data from the form
    in new.ejs and passes the resulting created user to the next middleware function
    through the response object. The next middleware function, `redirectView`, determines
    which view to show based on the redirect path it receives as part of the response
    object. If a user is created successfully, redirect to the index page.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '`new` 动作将接收到的请求用于创建新用户并在 new.ejs 中渲染表单。`create` 动作接收来自 new.ejs 表单的接收到的已发布数据，并通过响应对象将生成的创建的用户传递给下一个中间件函数。下一个中间件函数
    `redirectView` 根据响应对象中接收到的重定向路径确定要显示的视图。如果用户创建成功，则重定向到索引页面。'
- en: In the `create` action, assign a `userParams` variable to the collected incoming
    data. Then call `User.create` and pass those parameters, redirecting the user
    to the `/users` index page upon success and to the error page in case of a failure.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `create` 动作中，将收集到的传入数据分配给 `userParams` 变量。然后调用 `User.create` 并传递这些参数，在成功时将用户重定向到
    `/users` 索引页面，在失败时重定向到错误页面。
- en: '|  |'
  id: totrans-482
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-483
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: For the subscribers controller, the `new` and `create` actions effectively replace
    the `getSubscriptionPage` and `saveSubscriber` actions you created earlier in
    the book. After swapping in these new actions, you need to change the action names
    in the main.js routes to match.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 对于订阅者控制器，`new` 和 `create` 动作实际上替换了你在本书早期创建的 `getSubscriptionPage` 和 `saveSubscriber`
    动作。在交换这些新动作后，您需要更改 main.js 路由中的动作名称以匹配。
- en: '|  |'
  id: totrans-485
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Listing 19.2\. Adding a create action to usersController.js
  id: totrans-486
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 19.2\. 向 usersController.js 添加创建动作
- en: '[PRE21]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '***1*** **Add the new action to render a form.**'
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **添加新动作以渲染表单。**'
- en: '***2*** **Add the create action to save the user to the database.**'
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **添加创建动作以将用户保存到数据库。**'
- en: '***3*** **Create users with form parameters.**'
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **使用表单参数创建用户。**'
- en: '***4*** **Render the view in a separate redirectView action.**'
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **在单独的重定向视图动作中渲染视图。**'
- en: To see this code work, add the `new` and `create` routes to main.js, as shown
    in [listing 19.3](#ch19ex03). The first route takes incoming `GET` requests to
    `/users/new` and renders new.ejs in the `usersController`. The second route accepts
    `POST` requests to `/users/create` and passes that incoming request body to the
    `create` action, followed by the view redirect with the `redirectView` action
    in `usersController.js`. These routes can go below your user’s index route.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此代码的工作情况，将 `new` 和 `create` 路由添加到 main.js 中，如 [列表 19.3](#ch19ex03) 所示。第一个路由接收指向
    `/users/new` 的 `GET` 请求并在 `usersController` 中渲染 new.ejs。第二个路由接受指向 `/users/create`
    的 `POST` 请求，并将该接收到的请求体传递给 `create` 动作，然后通过 `usersController.js` 中的 `redirectView`
    动作进行视图重定向。这些路由可以放在您的用户索引路由下面。
- en: '|  |'
  id: totrans-493
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-494
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'The addition of the `new` and `create` actions to the subscribers controller
    means that you can remove the `getAllSubscribers` and `saveSubscriber` actions
    in favor of the new CRUD actions. Likewise, the only action you need in the home
    controller is to serve the home page: index.ejs.'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `new` 和 `create` 动作添加到订阅者控制器意味着您可以移除 `getAllSubscribers` 和 `saveSubscriber`
    动作，以支持新的 CRUD 动作。同样，您在主页控制器中需要的唯一动作是提供主页：index.ejs。
- en: '|  |'
  id: totrans-496
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Now that you’re starting to accumulate the number of routes you’re using in
    main.js, you can use the Router module in Express.js by adding `const router =
    express .Router()` to your main.js file`.` This line creates a Router object that
    offers its own middleware and routing alongside the Express.js `app` object. Soon,
    you’ll use this `router` object to organize your routes. For now, modify your
    routes to use `router` instead of `app`. Then add `app.use("/", router)` to the
    top of your routes in main.js. This code tells your Express.js application to
    use the router object as a system for middleware and routing.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你开始在main.js中积累你使用的路由数量，你可以通过在main.js文件中添加`const router = express .Router()`来使用Express.js的Router模块。这一行创建了一个Router对象，它提供了自己的中间件和路由，与Express.js的`app`对象一起使用。很快，你将使用这个`router`对象来组织你的路由。现在，修改你的路由以使用`router`而不是`app`。然后在main.js中的路由顶部添加`app.use("/",
    router)`。这段代码告诉你的Express.js应用程序使用路由对象作为中间件和路由的系统。
- en: Listing 19.3\. Adding new and create routes to main.js
  id: totrans-498
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表19.3\. 在main.js中添加新的和创建路由
- en: '[PRE22]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '***1*** **Handle requests to view the creation form.**'
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **处理查看创建表单的请求。**'
- en: '***2*** **Handle requests to submit data from the creation form, and display
    a view.**'
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **处理从创建表单提交数据的请求，并显示一个视图。**'
- en: Restart your application, fill out the form on http://localhost:3000/users/new,
    and submit the form. If you were successful, you should see your newly created
    user on the index page.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动你的应用程序，填写http://localhost:3000/users/new上的表单，并提交表单。如果你成功了，你应该能在首页上看到你新创建的用户。
- en: When you have users successfully saving to your database, add a finishing touch.
    You’ve already designed the `User` schema with an association to the `Subscriber`
    model. Ideally, whenever a new user is created, you’d like to check for an existing
    subscriber with the same email address and associate the two. You do so with a
    Mongoose `pre("save")` hook.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的用户成功保存到数据库中时，添加一个收尾工作。你已经设计了具有对`Subscriber`模型关联的`User`模式。理想情况下，每当创建新用户时，你都想检查具有相同电子邮件地址的现有订阅者并将两者关联起来。你可以使用Mongoose的`pre("save")`钩子来完成此操作。
- en: Mongoose offers some methods, called *hooks*, that allow you to perform an operation
    before a database change, such as `save`, is run. You can add this hook to user.js
    by adding the code in [listing 19.4](#ch19ex04) after the schema is defined and
    before the model is registered. You need to require the `Subscriber` model into
    user.js for this hook to work. Use `const Subscriber = require("./subscriber")`.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose提供了一些称为*钩子*的方法，允许你在数据库更改（如`save`）运行之前执行操作。你可以通过在定义模式之后和注册模型之前在user.js中添加[列表19.4](#ch19ex04)中的代码来添加此钩子。为此钩子要正常工作，你需要将`Subscriber`模型引入user.js中。使用`const
    Subscriber = require("./subscriber")`。
- en: This hook runs right before a user is created or saved. It takes the `next`
    middleware function as a parameter so that when this step is complete, it can
    call the next middleware function. Because you can’t use arrow functions here,
    you need to define the `user` variable outside the promise chain.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 此钩子在用户创建或保存之前立即运行。它接受`next`中间件函数作为参数，以便在完成此步骤后可以调用下一个中间件函数。由于这里不能使用箭头函数，因此需要在承诺链之外定义`user`变量。
- en: '|  |'
  id: totrans-506
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-507
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: As of the writing of this book, arrow functions don’t work with Mongoose hooks.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 就本书的编写而言，箭头函数不与Mongoose钩子一起工作。
- en: '|  |'
  id: totrans-509
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: You perform this function only if the user doesn’t already have an associated
    subscriber, which saves an unneeded database operation. Search for one subscriber
    account, using the user’s email address. If a subscriber is found with a matching
    email address, assign that subscriber to the user’s `subscribedAccount` attribute.
    Unless an error occurs, continue saving the user in the next middleware function.
    You also need to add a reference to the subscriber model in user.js by adding
    `const Subscriber = require("./subscriber")` to the top.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当用户还没有关联的订阅者时，你才执行此功能，这样可以节省不必要的数据库操作。使用用户的电子邮件地址搜索一个订阅者账户。如果找到一个具有匹配电子邮件地址的订阅者，将该订阅者分配给用户的`subscribedAccount`属性。除非发生错误，否则继续在下一个中间件函数中保存用户。你还需要通过在user.js顶部添加`const
    Subscriber = require("./subscriber")`来在user.js中添加对订阅者模型的引用。
- en: Listing 19.4\. Adding a pre(‘save’) hook to user.js
  id: totrans-511
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表19.4\. 在user.js中添加预(‘save’)钩子
- en: '[PRE23]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '***1*** **Set up the pre(‘save’) hook.**'
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **设置预(‘save’)钩子。**'
- en: '***2*** **Use the function keyword in the callback.**'
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **在回调中使用函数关键字。**'
- en: '***3*** **Add a quick conditional check for existing subscriber connections.**'
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **添加对现有订阅者连接的快速条件检查。**'
- en: '***4*** **Query for a single subscriber.**'
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **查询单个订阅者。**'
- en: '***5*** **Connect the user with a subscriber account.**'
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **将用户与订阅者账户关联。**'
- en: '***6*** **Pass any errors to the next middleware function.**'
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **将任何错误传递给下一个中间件函数。**'
- en: '***7*** **Call next function if user already has an association.**'
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7*** **如果用户已经有关联，则调用下一个函数。**'
- en: Give this new code a shot by creating a new subscriber in REPL (or through the
    subscriber’s `new` page, if you’ve created that already) and then creating a new
    user in your browser with the same email address. Going back to REPL, you can
    check whether that user’s `subscribedAccount` has a value reflecting the associated
    subscriber’s `ObjectId`. This value will come in handy in the next section, when
    you build the user’s `show` page.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在REPL中创建一个新的订阅者（或者如果你已经创建了，通过订阅者的`new`页面）并然后在浏览器中创建一个新的用户，使用相同的电子邮件地址来尝试这段新代码。回到REPL，你可以检查该用户的`subscribedAccount`是否有值反映了关联的订阅者的`ObjectId`。这个值将在下一节构建用户的`show`页面时派上用场。
- en: '|  |'
  id: totrans-521
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 19.2**'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查19.2**'
- en: '**[Q1:](#ch19qa6q0a1)**'
  id: totrans-523
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch19qa6q0a1)**'
- en: ''
  id: totrans-524
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why does the Mongoose `pre("save")` hook take `next` as a parameter?
  id: totrans-525
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么Mongoose的`pre("save")`钩子将`next`作为参数？
- en: '|  |'
  id: totrans-526
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-527
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 19.2 answer**'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 19.2 答案**'
- en: '**[1:](#ch19qa4q1)**'
  id: totrans-529
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch19qa4q1)**'
- en: ''
  id: totrans-530
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `pre("save")` hook is Mongoose middleware, and as with other middleware,
    when the function completes, it moves on to the next middleware function. `next`
    here indicates the next function in the middleware chain to be called.
  id: totrans-531
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`pre("save")`钩子是Mongoose中间件，与其他中间件一样，当函数完成时，它将移动到下一个中间件函数。这里的`next`表示中间件链中要调用的下一个函数。'
- en: '|  |'
  id: totrans-532
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '![](../Images/sectionFig.png)19.3\. Reading user data with show'
  id: totrans-533
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)19.3\. 使用show读取用户数据'
- en: Now that you can create users, you want a way to display a user’s information
    on dedicated pages (such as the user’s profile page). The only operation you need
    to perform on the database is to `read` data, finding a user by a specific ID
    and displaying its contents in the browser.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经可以创建用户，你想要一种方法在专用页面上显示用户信息（例如用户的个人资料页面）。你需要在数据库上执行的唯一操作是`读取`数据，通过特定的ID查找用户并在浏览器中显示其内容。
- en: Start by creating a new view called show.ejs. Call the view and action `show`,
    making it clear that your intention is to show user data. In show.ejs, create
    a table similar to the one in index.ejs, except that you won’t need the loop.
    You want to show all the user’s attributes. Add the code in [listing 19.5](#ch19ex05)
    to show.ejs within the views/users folder.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个新的视图，名为show.ejs。调用视图和动作`show`，使其明确你的意图是展示用户数据。在show.ejs中，创建一个类似于index.ejs中的表格，除了你不需要循环。你想要展示所有用户的属性。将[列表19.5](#ch19ex05)中的代码添加到views/users文件夹中的show.ejs中。
- en: This form uses the `user` variable’s attributes to populate each table data
    box. At the end, check whether that user has a `subscribedAccount`. If not, nothing
    is displayed. If a subscriber is associated, display some text and link to the
    subscriber’s show page.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 此表单使用`user`变量的属性来填充每个表格数据框。最后，检查该用户是否有`subscribedAccount`。如果没有，则不显示任何内容。如果有关联的订阅者，则显示一些文本并链接到订阅者的展示页面。
- en: Listing 19.5\. User show table in show.ejs
  id: totrans-537
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表19.5\. show.ejs中的用户展示表格
- en: '[PRE24]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '***1*** **Add a table to display user data.**'
  id: totrans-539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **添加一个表格来显示用户数据。**'
- en: '***2*** **Check for linked subscriber accounts.**'
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **检查是否有链接的订阅者账户。**'
- en: '|  |'
  id: totrans-541
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-542
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You will need to follow the same steps in creating CRUD functions and views
    for the subscriber simultaneously for this linked page to work. The anchor tag
    href path is `/subscribers/${user.subscribedAccount}`, which represents the subscriber’s
    `show` route.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使此链接页面正常工作，你需要同时为订阅者创建CRUD函数和视图。锚标签的href路径是`/subscribers/${user.subscribedAccount}`，它代表订阅者的`show`路由。
- en: '|  |'
  id: totrans-544
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: To make it easier to get to a user’s `show` page, in index.ejs, wrap the user’s
    name in an anchor tag that links to `users/` plus the user’s ID. The table data
    there should look like the next listing. You embed JavaScript in the anchor tag’s
    `href` as well as in the table data content.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更容易地访问用户的`show`页面，在index.ejs中，将用户的名字包裹在一个链接标签中，链接到`users/`加上用户的ID。那里的表格数据应该看起来像下一个列表。你可以在链接标签的`href`以及表格数据内容中嵌入JavaScript。
- en: Listing 19.6\. Updated name data in index.ejs
  id: totrans-546
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表19.6\. index.ejs中更新的名称数据
- en: '[PRE25]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '***1*** **Embed the user’s name and ID in HTML.**'
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **在HTML中嵌入用户的名字和ID。**'
- en: If you refresh the users index page, you’ll notice that the names have turned
    into links ([figure 19.2](#ch19fig02)). If you click one of those links now, though,
    you’ll get an error because there isn’t a route to handle the request yet.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刷新用户索引页面，你会注意到名字变成了链接（[图19.2](#ch19fig02)）。如果你现在点击其中一个链接，你会得到一个错误，因为没有路由来处理这个请求。
- en: Figure 19.2\. Users’ index page with linked names in your browser
  id: totrans-550
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图19.2\. 浏览器中的用户索引页面，带有链接的名字
- en: '![](../Images/19fig02_alt.jpg)'
  id: totrans-551
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/19fig02_alt.jpg)'
- en: Next, add the `show` action to `usersController.js`, as shown in [listing 19.7](#ch19ex07).
    First, collect the user’s ID from the URL parameters; you can get that information
    from `req.params.id`. This code works only if you define your route by using `:id`
    (see [listing 19.7](#ch19ex07)).
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`usersController.js`中添加`show`动作，如图19.7所示。[列表19.7](#ch19ex07)。首先，从URL参数中收集用户的ID；你可以从`req.params.id`获取这个信息。这段代码只有在使用`:id`定义路由时才有效（参见[列表19.7](#ch19ex07)）。
- en: Use the `findById` query, and pass the user’s ID. Because each ID is unique,
    you should expect a single user in return. If a user is found, add it as a local
    variable on the response object, and call the `next` middleware. Soon, you’ll
    set up the next function to be `showView`, where you render the show page and
    pass the user object to display that user’s information. If an error occurs, log
    the message, and pass the error to the next middleware function.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`findById`查询，并传递用户的ID。因为每个ID都是唯一的，你应该期望返回单个用户。如果找到用户，将其添加为响应对象上的局部变量，并调用`next`中间件。很快，你将设置下一个函数为`showView`，在那里你渲染展示页面并将用户对象传递以显示该用户的信息。如果发生错误，记录消息，并将错误传递给下一个中间件函数。
- en: Listing 19.7\. Show action for a specific user in usersController.js
  id: totrans-554
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表19.7\. `usersController.js`中特定用户的展示动作
- en: '[PRE26]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '***1*** **Collect the user ID from the request params.**'
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **从请求参数中收集用户ID。**'
- en: '***2*** **Find a user by its ID.**'
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **通过ID查找用户。**'
- en: '***3*** **Pass the user through the response object to the next middleware
    function.**'
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **将用户通过响应对象传递给下一个中间件函数。**'
- en: '***4*** **Log and pass errors to next function.**'
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **记录错误并传递给下一个函数。**'
- en: '***5*** **Render show view.**'
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **渲染展示视图。**'
- en: 'Last, add the `show` route for users in main.js with the following code: `router.get
    ("/users/:id", usersController.show, usersController.showView)`. This show route
    uses the `/users` path along with an `:id` parameter. This parameter will be filled
    with the user’s ID passing in from the index page when you click the user’s name
    in the table.'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`main.js`中添加用户的`show`路由，代码如下：`router.get ("/users/:id", usersController.show,
    usersController.showView)`。这个`show`路由使用`/users`路径以及一个`:id`参数。当你点击表格中的用户名时，从索引页面传入的用户ID将被填充到这个参数中。
- en: '|  |'
  id: totrans-562
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-563
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You can group routes that are related to the same model in main.js for better
    organization.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`main.js`中将与同一模型相关的路由分组，以获得更好的组织。
- en: '|  |'
  id: totrans-565
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Restart your application, and click a user’s name. You should be directed to
    that user’s show page, as shown in [figure 19.3](#ch19fig03).
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动你的应用程序，点击一个用户的名字。你应该会被导向该用户的展示页面，如图19.3所示。
- en: Figure 19.3\. Users show page in your browser
  id: totrans-567
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图19.3\. 浏览器中的用户展示页面
- en: '![](../Images/19fig03_alt.jpg)'
  id: totrans-568
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/19fig03_alt.jpg)'
- en: You now have the ability to create data in your application and view it on a
    few web pages. In [lesson 20](../Text/kindle_split_035.html#ch20), you explore
    ways of updating and deleting that data.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以在你的应用程序中创建数据，并在几个网页上查看它。在[第20课](../Text/kindle_split_035.html#ch20)中，你将探索更新和删除这些数据的方法。
- en: '|  |'
  id: totrans-570
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 19.3**'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查19.3**'
- en: '**[Q1:](#ch19qa9q0a1)**'
  id: totrans-572
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch19qa9q0a1)**'
- en: ''
  id: totrans-573
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'True or false: the URL parameter representing the user’s ID must be called
    `:id`.'
  id: totrans-574
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 正误判断：代表用户ID的URL参数必须命名为`:id`。
- en: '|  |'
  id: totrans-575
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-576
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 19.3 answer**'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 19.3 答案**'
- en: '**[1:](#ch19qa7q1)**'
  id: totrans-578
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch19qa7q1)**'
- en: ''
  id: totrans-579
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: False. The `:id` parameter is essential for getting the ID of the user you’re
    trying to display, but this parameter can be referenced by any name you choose.
    If you decide to use `:userId`, make sure that you use that name consistently
    throughout your code.
  id: totrans-580
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 错误。`:id`参数对于获取你想要显示的用户ID是必需的，但你可以选择任何名称来引用这个参数。如果你决定使用`:userId`，确保在整个代码中一致地使用这个名字。
- en: '|  |'
  id: totrans-581
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)Summary'
  id: totrans-582
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![图片](../Images/sectionFig.png)总结'
- en: In this lesson, you learned how to create `index`, `new`, and `show` pages for
    your models. You also created routes and actions to process user data and create
    new accounts. Finally, you customized the user `show` page to show user data and
    an indicator for linked subscriber accounts. You have two of the four CRUD building
    blocks in place. In [lesson 20](../Text/kindle_split_035.html#ch20), you apply
    the `update` and `delete` functions to your three models.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，你学习了如何为你的模型创建`index`、`new`和`show`页面。你还创建了路由和动作来处理用户数据并创建新账户。最后，你自定义了用户`show`页面以显示用户数据和链接的订阅账户的指示器。你已经完成了四个CRUD构建块中的两个。在[第20课](../Text/kindle_split_035.html#ch20)中，你将`update`和`delete`函数应用于你的三个模型。
- en: '|  |'
  id: totrans-584
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Try this**'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: '**尝试这个**'
- en: 'Your user-account creation form is ready to create new accounts, but you’ve
    implemented certain validations on the user model that may allow a form to be
    submitted with no data saved. Try to test some of your validations to ensure that
    they’re working correctly, as follows:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 你的用户账户创建表单已经准备好创建新账户，但你已经在用户模型上实现了某些验证，这可能会允许在没有保存数据的情况下提交表单。尝试测试一些你的验证以确保它们正确工作，如下所示：
- en: What happens when you enter an email address with capital letters?
  id: totrans-587
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你输入带有大写字母的电子邮件地址时会发生什么？
- en: What happens when a required field is missing?
  id: totrans-588
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当缺少必填字段时会发生什么？
- en: It’s good that you get redirected to the `new` page again, but you have improvements
    to make in the error messages shown on the screen.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你再次被重定向到`new`页面是好事，但你需要在屏幕上显示的错误信息中进行改进。
- en: '|  |'
  id: totrans-590
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Lesson 20\. Updating and Deleting your Models
  id: totrans-591
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第20课. 更新和删除你的模型
- en: In [lesson 19](../Text/kindle_split_034.html#ch19), you built `create` and `read`
    functionality for your models. Now it’s time to complete the CRUD methods. In
    this lesson, you add the routes, actions, and views for the `update` and `delete`
    functions. First, you create a form to edit the attributes of existing users.
    Then you manage the modified data in an `update` action. At the end of the lesson,
    you implement a quick way to delete users from your users index page. To start,
    make sure that your MongoDB server is running by entering `mongod` in a terminal
    window.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第19课](../Text/kindle_split_034.html#ch19)中，你为你的模型构建了`create`和`read`功能。现在，是时候完成CRUD方法了。在本课中，你将添加`update`和`delete`功能的路由、动作和视图。首先，你创建一个表单来编辑现有用户的属性。然后，你在一个`update`动作中管理修改后的数据。在本课结束时，你将实现一种快速从用户索引页删除用户的方法。首先，确保你的MongoDB服务器正在运行，通过在终端窗口中输入`mongod`来检查。
- en: This lesson covers
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 本课涵盖
- en: Constructing a model edit form
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建模型编辑表单
- en: Updating user records in your database
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新数据库中的用户记录
- en: Deleting user records
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除用户记录
- en: '|  |'
  id: totrans-597
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Consider this**'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑以下**'
- en: Your recipe application is ready to accept new users, but you’re getting complaints
    that multiple unnecessary accounts were made and that some users accidentally
    typed the wrong email address. With the `update` and `delete` CRUD functions,
    you’ll be able to clear unwanted records and modify existing ones to persist in
    your application.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 你的食谱应用程序已经准备好接受新用户，但你收到了关于创建了多个不必要的账户以及一些用户不小心输入了错误电子邮件地址的投诉。通过`update`和`delete`
    CRUD函数，你将能够清除不需要的记录并修改现有的记录以持久化在你的应用程序中。
- en: '|  |'
  id: totrans-600
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)20.1\. Building the edit user form'
  id: totrans-601
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)20.1. 构建编辑用户表单'
- en: To update a user’s information, you use some Mongoose methods in a specific
    `update` action. First, though, you create a form to edit user information. The
    form looks like the one in create.js, but the form’s action points to `users/:id/update`
    instead of `users/create` because you want your route to indicate that the form’s
    contents are updating an existing user, not creating a new one.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新用户信息，你需要在特定的`update`动作中使用一些Mongoose方法。不过，首先你需要创建一个编辑用户信息的表单。这个表单看起来像create.js中的表单，但表单的动作指向`users/:id/update`而不是`users/create`，因为你希望你的路由表明表单的内容是更新现有用户，而不是创建新用户。
- en: You also want to replace the values in each form input with the user’s existing
    information. The input for the user’s first name might look like the next listing,
    for example. The `value` attribute here uses the existing user’s first name. This
    code works only if a `user` object is being passed into this page.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 你还希望将每个表单输入中的值替换为用户的现有信息。例如，用户名输入可能看起来像下面的列表。这里的`value`属性使用现有用户的姓名。这段代码仅在将`user`对象传递到该页面时才有效。
- en: Listing 20.1\. Input example with user’s data in edit.ejs
  id: totrans-604
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表20.1. edit.ejs中带有用户数据的输入示例
- en: '[PRE27]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '***1*** **Apply the existing user’s attribute values in edit form.**'
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **在编辑表单中应用现有用户的属性值。**'
- en: To ensure that an existing user’s data populates this form, add another column
    to the table in the users index page. Your index page should resemble [figure
    20.1](#ch20fig01).
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保现有用户的数据填充此表单，请向用户索引页面中的表格添加另一列。您的索引页面应类似于[图20.1](#ch20fig01)。
- en: Figure 20.1\. Users index page with edit links in your browser
  id: totrans-608
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图20.1\. 浏览器中带有编辑链接的用户索引页面
- en: '![](../Images/20fig01_alt.jpg)'
  id: totrans-609
  prefs: []
  type: TYPE_IMG
  zh: '![图20.1](../Images/20fig01_alt.jpg)'
- en: This column has a link for editing each specific user. You can add an anchor
    tag, as shown in the next listing. The `href` value for the edit link tag makes
    a `GET` request to the `/users` plus the user’s `Id` plus `/edit` route.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 此列包含一个用于编辑每个特定用户的链接。您可以添加一个锚点标签，如下一列表中所示。编辑链接标签的`href`值会向`/users`加上用户的`Id`加上`/edit`路由发起一个`GET`请求。
- en: Listing 20.2\. Modified table with link to edit users in index.ejs
  id: totrans-611
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表20.2\. 修改后的表格，在index.ejs中添加编辑用户的链接
- en: '[PRE28]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '***1*** **Embed the user’s ID in the edit tag link.**'
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **在编辑标签链接中嵌入用户的ID。**'
- en: Next, you want to modify the form in edit.ejs to submit a `PUT` request with
    modified user data, but your HTML form element supports only `GET` and `POST`
    requests. It’s important to begin using the intended HTTP methods with your CRUD
    functions so that there’s no future confusion about whether a request is adding
    new data or modifying existing data.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您想要修改`edit.ejs`中的表单，以提交带有修改后用户数据的`PUT`请求，但您的HTML表单元素仅支持`GET`和`POST`请求。在您的CRUD函数中使用预期的HTTP方法非常重要，这样就不会在未来对请求是添加新数据还是修改现有数据产生混淆。
- en: One problem you need to address is how Express.js will receive this request.
    Express.js receives your HTML form submissions as `POST` requests, so you need
    some way to interpret the request with the HTTP method you intended. Several solutions
    to this problem exist. The solution you use in this lesson is the `method-override`
    package.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要解决的问题之一是Express.js将如何接收此请求。Express.js将您的HTML表单提交作为`POST`请求接收，因此您需要某种方式来解释具有您意图的HTTP方法的请求。存在几种解决这个问题的方法。本课中您使用的解决方案是`method-override`包。
- en: '`method-override` is middleware that interprets requests according to a specific
    query parameter and HTTP method. With the `_method=PUT` query parameter, you can
    interpret `POST` requests as `PUT` requests. Install this package by running `npm
    i method-override -S` in your project’s terminal window, and add the lines in
    [listing 20.3](#ch20ex03) to main.js.'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: '`method-override`是一个中间件，根据特定的查询参数和HTTP方法解释请求。使用`_method=PUT`查询参数，您可以解释`POST`请求为`PUT`请求。通过在项目终端窗口中运行`npm
    i method-override -S`来安装此包，并将[列表20.3](#ch20ex03)中的行添加到main.js中。'
- en: First, require the `method-override` module into your project. Tell the application
    to use `methodOverride` as middleware. Specifically, you’re telling this module
    to look for the `_method` query parameter in the URL and to interpret the request
    by using the method specified as the value of that parameter. A `POST` request
    that you want processed as a `PUT` request, for example, will have `?_method=PUT`
    appended to the form’s action path.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将`method-override`模块引入到您的项目中。告诉应用程序使用`methodOverride`作为中间件。具体来说，您正在告诉此模块在URL中查找`_method`查询参数，并使用该参数的值指定的方法来解释请求。例如，您想要处理为`PUT`请求的`POST`请求，将会有`?_method=PUT`附加到表单的动作路径上。
- en: Listing 20.3\. Adding `method-override` to your application in main.js
  id: totrans-618
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表20.3\. 在main.js中添加`method-override`到您的应用程序
- en: '[PRE29]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '***1*** **Require the method-override module.**'
  id: totrans-620
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **引入`method-override`模块。**'
- en: '***2*** **Configure the application router to use methodOverride as middleware.**'
  id: totrans-621
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **配置应用程序路由器以使用methodOverride作为中间件。**'
- en: You want to modify the form in edit.ejs to submit the form with a `POST` method
    to the `/users/:id/update?_method=PUT` route. The opening form tag will look like
    [listing 20.4](#ch20ex04).
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要修改`edit.ejs`中的表单，使其以`POST`方法提交到`/users/:id/update?_method=PUT`路由。打开表单标签将看起来像[列表20.4](#ch20ex04)。
- en: The action is dynamic, depending on the user’s ID, and points to the `/users/:id/update`
    route. Your `method-override` module interprets the query parameter and helps
    Express.js match the request’s method with the appropriate route.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 动作是动态的，取决于用户的ID，并指向`/users/:id/update`路由。您的`method-override`模块解释查询参数，并帮助Express.js将请求方法与适当的路由匹配。
- en: Listing 20.4\. Pointing the edit form to the `update` route in edit.ejs
  id: totrans-624
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表20.4\. 将编辑表单指向edit.ejs中的`update`路由
- en: '[PRE30]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '***1*** **Add a form to update user data.**'
  id: totrans-626
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **添加一个更新用户数据的表单。**'
- en: You can reference the complete user edit form in the next listing, which should
    look like [figure 20.2](#ch20fig02) in your browser for an existing user.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在下一个列表中参考完整的用户编辑表单，它应该看起来像浏览器中的 [图 20.2](#ch20fig02) 中的现有用户。
- en: Figure 20.2\. User edit page in your browser
  id: totrans-628
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 20.2\. 浏览器中的用户编辑页面
- en: '![](../Images/20fig02_alt.jpg)'
  id: totrans-629
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/20fig02_alt.jpg)'
- en: Listing 20.5\. Complete user edit form in edit.ejs
  id: totrans-630
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 20.5\. 完整的用户编辑表单在 edit.ejs 中
- en: '[PRE31]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '***1*** **Display the user edit form.**'
  id: totrans-632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **显示用户编辑表单。**'
- en: In the next section, you add the routes and actions that get this form to work,
    as well as the data from the form processed.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将添加使此表单工作以及处理表单数据的路由和操作。
- en: '|  |'
  id: totrans-634
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 20.1**'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 20.1**'
- en: '**[Q1:](#ch20qa3q0a1)**'
  id: totrans-636
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch20qa3q0a1)**'
- en: ''
  id: totrans-637
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why do you use the `PUT` method for the `edit` form and `POST` for the `new`
    form?
  id: totrans-638
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么您使用 `PUT` 方法编辑表单，而使用 `POST` 方法创建新表单？
- en: '|  |'
  id: totrans-639
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-640
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 20.1 answer**'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 20.1 答案**'
- en: '**[1:](#ch20qa1q1)**'
  id: totrans-642
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch20qa1q1)**'
- en: ''
  id: totrans-643
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The edit form is updating data for an existing record. By convention, the request
    to submit data to your server should use an HTTP `PUT` method. To create new records,
    use `POST`.
  id: totrans-644
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编辑表单正在更新现有记录的数据。按照惯例，提交数据到您的服务器的请求应使用 HTTP `PUT` 方法。要创建新记录，请使用 `POST`。
- en: '|  |'
  id: totrans-645
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)20.2\. Updating users from a view'
  id: totrans-646
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![图片](../Images/sectionFig.png)20.2\. 从视图中更新用户'
- en: Now that the user edit form is in its own view, add the controller action and
    route to complement the form. The `edit` route and action send users to view edit.ejs.
    The `update` route and action are used internally to make changes to the user
    in the database. Then the `redirectView` action acts as the action following `update`,
    redirecting you to a view that you specify. Add the actions in [listing 20.6](#ch20ex06)
    to `usersController.js`.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用户编辑表单已经在其自己的视图中，添加控制器操作和路由以补充表单。`edit` 路由和操作将用户发送到 view/edit.ejs 视图。`update`
    路由和操作用于在数据库中内部更改用户。然后 `redirectView` 操作作为 `update` 后的操作，将您重定向到您指定的视图。将 [列表 20.6](#ch20ex06)
    中的操作添加到 `usersController.js`。
- en: The `edit` action, like the `show` action, gets a user from the database by
    the user’s ID and loads a view to //edit the user. Notice that if a user isn’t
    found by the ID parameter, you pass an error to the error-handling middleware
    function. The `update` action is called when the edit form is submitted; like
    the `create` action, it identifies the user’s ID and `userParams`, and passes
    those values into the Mongoose `findByIdAndUpdate` method. This method takes an
    `ID` followed by parameters you’d like to replace for that document by using the
    `$set` command. If the user updates successfully, redirect to the user’s `show`
    path in the next middleware function; otherwise, let the error-handling middleware
    catch any errors.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: '`edit` 操作，就像 `show` 操作一样，通过用户的 ID 从数据库中获取用户信息并加载一个用于编辑用户的视图。注意，如果通过 ID 参数找不到用户，你需要将错误传递给错误处理中间件函数。当编辑表单提交时，会调用
    `update` 操作；与 `create` 操作类似，它会识别用户的 ID 和 `userParams`，并将这些值传递给 Mongoose 的 `findByIdAndUpdate`
    方法。此方法接受一个 `ID` 后跟一些参数，你可以使用 `$set` 命令来替换该文档的参数。如果用户更新成功，则在下一个中间件函数中重定向到用户的 `show`
    路径；否则，让错误处理中间件捕获任何错误。'
- en: Listing 20.6\. Adding `edit` and `update` actions to usersController.js
  id: totrans-649
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 20.6\. 向 usersController.js 添加 `edit` 和 `update` 操作
- en: '[PRE32]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '***1*** **Add the edit action.**'
  id: totrans-651
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **添加编辑操作。**'
- en: '***2*** **Use findById to locate a user in the database by their ID.**'
  id: totrans-652
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **使用 `findById` 通过 ID 在数据库中定位用户。**'
- en: '***3*** **Render the user edit page for a specific user in the database.**'
  id: totrans-653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **渲染数据库中特定用户的用户编辑页面。**'
- en: '***4*** **Add the update action.**'
  id: totrans-654
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **添加更新操作。**'
- en: '***5*** **Collect user parameters from request.**'
  id: totrans-655
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **从请求中收集用户参数。**'
- en: '***6*** **Use findByIdAndUpdate to locate a user by ID and update the document
    record in one command.**'
  id: totrans-656
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **使用 `findByIdAndUpdate` 通过 ID 定位用户并更新文档记录，只需一个命令。**'
- en: '***7*** **Add user to response as a local variable, and call the next middleware
    function.**'
  id: totrans-657
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7*** **将用户添加到响应作为局部变量，并调用下一个中间件函数。**'
- en: Last, you need to add the routes in [listing 20.7](#ch20ex07) to main.js. The
    path to edit a user is a straightforward route with an `id` parameter. The `POST`
    route to update the user from the edit form follows the same path structure but
    uses the `update` action. You’re also going to reuse the `redirectView` action
    to display the view specified in your response’s `locals` object.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您需要将 [列表 20.7](#ch20ex07) 中的路由添加到 main.js 中。编辑用户的路径是一个简单的带有 `id` 参数的路由。从编辑表单更新用户的
    `POST` 路由遵循相同的路径结构，但使用 `update` 操作。您还将重用 `redirectView` 操作来显示您在响应的 `locals` 对象中指定的视图。
- en: Listing 20.7\. Adding `edit` and `update` routes to main.js
  id: totrans-659
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表20.7\. 在`main.js`中添加`edit`和`update`路由
- en: '[PRE33]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '***1*** **Add routes to handle viewing.**'
  id: totrans-661
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **添加处理查看的路由。**'
- en: '***2*** **Process data from the edit form, and display the user show page.**'
  id: totrans-662
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **处理编辑表单中的数据，并显示用户展示页面。**'
- en: Relaunch your application, visit the users index page, and click the edit link
    for a user. Try to update some values, and save.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动您的应用程序，访问用户索引页面，并点击用户的编辑链接。尝试更新一些值，并保存。
- en: With the ability to `create`, `read`, and `update` user data, you’re missing
    only a way to remove records that you don’t want anymore. The next section covers
    the `delete` function.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 在能够`create`、`read`和`update`用户数据之后，您还缺少一种删除不再需要的记录的方法。下一节将介绍`delete`函数。
- en: '|  |'
  id: totrans-665
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 20.2**'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查20.2**'
- en: '**[Q1:](#ch20qa6q0a1)**'
  id: totrans-667
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch20qa6q0a1)**'
- en: ''
  id: totrans-668
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'True or false: `findByIdAndUpdate` is a Mongoose method.'
  id: totrans-669
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 真或假：`findByIdAndUpdate`是Mongoose方法。
- en: '|  |'
  id: totrans-670
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-671
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 20.2 answer**'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 20.2 答案**'
- en: '**[1:](#ch20qa4q1)**'
  id: totrans-673
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch20qa4q1)**'
- en: ''
  id: totrans-674
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: True. `findByIdAndUpdate` is a Mongoose method used to make your query more
    succinct and readable in your server’s code. The method can’t be used unless the
    Mongoose package is installed.
  id: totrans-675
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 真的。`findByIdAndUpdate`是Mongoose方法，用于使您的查询在服务器代码中更加简洁和可读。除非安装了Mongoose包，否则该方法不能使用。
- en: '|  |'
  id: totrans-676
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '![](../Images/sectionFig.png)20.3\. Deleting users with the delete action'
  id: totrans-677
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)20.3\. 使用删除操作删除用户'
- en: To delete a user, you need only one route and a modification to your users index
    page. In index.ejs, add a column titled delete. As you did with the edit column,
    link each user to a `users/:id/delete` route ([figure 20.3](#ch20fig03)).
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除用户，您只需要一个路由和对用户索引页面的修改。在`index.ejs`中，添加一个标题为删除的列。就像您对编辑列所做的那样，将每个用户链接到`users/:id/delete`路由（[图20.3](#ch20fig03)）。
- en: Figure 20.3\. Users index page with delete links in your browser
  id: totrans-679
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图20.3\. 在浏览器中带有删除链接的用户索引页面
- en: '![](../Images/20fig03_alt.jpg)'
  id: totrans-680
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/20fig03_alt.jpg)'
- en: '|  |'
  id: totrans-681
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-682
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You can add some basic security with an HTML `onclick="return confirm('Are you
    sure you want to delete this record?')"`
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用HTML的`onclick="return confirm('Are you sure you want to delete this record?')"`添加一些基本的安全措施。
- en: '|  |'
  id: totrans-684
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Recall that you need to use the `_method=DELETE` query parameter so that your
    application can interpret `GET` requests as `DELETE` requests. Add the code for
    the delete column in the users index page, as shown in [listing 20.8](#ch20ex08).
    With the appended query parameter to send a `DELETE` request, this link passes
    the user’s ID in search of an Express.js route handling `DELETE` requests. The
    confirmation script displays a modal to confirm that you want to submit the link
    and delete the record.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，您需要使用`_method=DELETE`查询参数，这样您的应用程序才能将`GET`请求解释为`DELETE`请求。在用户索引页面中添加删除列的代码，如[列表20.8](#ch20ex08)所示。通过附加的查询参数发送`DELETE`请求，此链接将用户的ID传递给处理`DELETE`请求的Express.js路由。确认脚本显示一个模态框以确认您要提交链接并删除记录。
- en: Listing 20.8\. Delete link in users index.ejs
  id: totrans-686
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表20.8\. 用户索引页面中的删除链接
- en: '[PRE34]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '***1*** **Add a link to the delete action on the index page.**'
  id: totrans-688
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **在索引页面上添加删除操作的链接。**'
- en: Next, add the controller action to `delete` the user record by its ID. Add the
    code in [listing 20.9](#ch20ex09) to `usersController.js`.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将控制器操作添加到`delete`用户记录的ID。将[列表20.9](#ch20ex09)中的代码添加到`usersController.js`。
- en: You’re using the Mongoose `findByIdAndRemove` method to locate the record you
    clicked and remove it from your database. If you’re successful in locating and
    removing the document, log that deleted user to the console and redirect in the
    next middleware function to the users index page. Otherwise, log the error as
    usual, and let your error handler catch the error you pass it.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 您正在使用Mongoose的`findByIdAndRemove`方法来定位您点击的记录并将其从数据库中删除。如果您成功定位并删除了文档，请在控制台记录被删除的用户，并在下一个中间件函数中重定向到用户索引页面。否则，像往常一样记录错误，并让错误处理器捕获您传递给它的错误。
- en: Listing 20.9\. Adding the `delete` action to usersController.js
  id: totrans-691
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表20.9\. 将`delete`操作添加到`usersController.js`
- en: '[PRE35]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '***1*** **Deleting a user with the findByIdAndRemove method**'
  id: totrans-693
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **使用`findByIdAndRemove`方法删除用户**'
- en: 'The only missing piece is the following route, which you add to `main.js`:
    `router.delete ("/users/:id/delete", usersController.delete, usersController.redirectView)`.
    This route handles `DELETE` requests that match the path `users/` plus the user’s
    ID plus `/delete`. Then the route redirects to your specified redirect path when
    the record is deleted.'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一缺少的部分是以下路由，您将其添加到`main.js`中：`router.delete ("/users/:id/delete", usersController.delete,
    usersController.redirectView)`。此路由处理与路径`users/`、用户ID和`/delete`匹配的`DELETE`请求。然后，当记录被删除时，该路由将重定向到指定的重定向路径。
- en: Try this new code by running the application again and visiting the users index
    page. Click the delete link next to one of the users, and watch it disappear from
    your page.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试通过再次运行应用程序并访问用户索引页面来运行这段新代码。点击其中一个用户的删除链接，然后观察它从你的页面上消失。
- en: Last, to make it easier to use your new CRUD actions from a user’s profile page,
    add the links in the following listing to the bottom of show.ejs.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了使用户从其个人资料页面更容易地使用您的新 CRUD 操作，请将以下列表中的链接添加到 show.ejs 的底部。
- en: Listing 20.10\. Adding links for user CRUD actions to show.ejs
  id: totrans-697
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表20.10\. 将用户 CRUD 操作的链接添加到 show.ejs
- en: '[PRE36]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '***1*** **Add links to edit and delete a user’s account from their profile
    page.**'
  id: totrans-699
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **在个人资料页面添加编辑和删除用户账户的链接。**'
- en: The user’s show page should resemble [figure 20.4](#ch20fig04).
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 用户的展示页面应该类似于[图20.4](#ch20fig04)。
- en: Figure 20.4\. User’s show page with links to edit and delete
  id: totrans-701
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图20.4\. 带有编辑和删除链接的用户展示页面
- en: '![](../Images/20fig04_alt.jpg)'
  id: totrans-702
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/20fig04_alt.jpg)'
- en: '|  |'
  id: totrans-703
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 20.3**'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 20.3**'
- en: '**[Q1:](#ch20qa9q0a1)**'
  id: totrans-705
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch20qa9q0a1)**'
- en: ''
  id: totrans-706
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why is `?_method=DELETE` needed at the end of your link’s path?
  id: totrans-707
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么在链接路径的末尾需要`?_method=DELETE`？
- en: '|  |'
  id: totrans-708
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-709
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 20.3 answer**'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 20.3 答案**'
- en: '**[1:](#ch20qa7q1)**'
  id: totrans-711
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch20qa7q1)**'
- en: ''
  id: totrans-712
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`method-override` looks for the `_method` query parameter and its mapped method.
    Because you’re using this package to filter incoming `GET` and `POST` requests
    as alternative methods, you need to append this parameter and value.'
  id: totrans-713
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`method-override`会查找`_method`查询参数及其映射的方法。因为您正在使用此包来过滤传入的`GET`和`POST`请求作为替代方法，您需要添加此参数及其值。'
- en: '|  |'
  id: totrans-714
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '![](../Images/sectionFig.png)Summary'
  id: totrans-715
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)摘要'
- en: In this lesson, you learned how to edit records and delete records from your
    database. You also saw how to use the `method-override` package to assist with
    HTML limitations in submitting certain request methods. With your CRUD functionality
    complete, it’s time to build an application with associated models and a user
    interface to save meaningful data to your database. In the next capstone exercise
    ([lesson 21](../Text/kindle_split_036.html#ch21)), try to apply everything you’ve
    learned in this unit to build the Confetti Cuisine application.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，您学习了如何编辑数据库中的记录和删除记录。您还看到了如何使用`method-override`包来帮助处理 HTML 限制以提交某些请求方法。随着
    CRUD 功能的完成，现在是时候构建一个具有关联模型和用户界面以将有意义的数据保存到数据库中的应用程序了。在下一项综合练习（第21课[lesson 21](../Text/kindle_split_036.html#ch21)）中，尝试将您在本单元中学到的所有内容应用于构建
    Confetti Cuisine 应用程序。
- en: '|  |'
  id: totrans-717
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Try this**'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: '**尝试这个**'
- en: Now that you have each CRUD function working for user accounts, make sure that
    the same setup is in place for groups and subscribers. Before you move on to the
    capstone exercise ([lesson 21](../Text/kindle_split_036.html#ch21)), make sure
    that all three models have working index, new, edit, and show pages. Then, as
    in [lesson 19](../Text/kindle_split_034.html#ch19), try to incorporate associated
    models into each record’s show page.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经为用户账户的每个 CRUD 函数都设置了工作状态，请确保为组和订阅者也设置了相同的设置。在您继续进行综合练习（第21课[lesson 21](../Text/kindle_split_036.html#ch21)）之前，请确保所有三个模型都有工作的索引、新建、编辑和展示页面。然后，就像在第19课[lesson
    19](../Text/kindle_split_034.html#ch19)中一样，尝试将关联模型纳入每个记录的展示页面。
- en: '|  |'
  id: totrans-720
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Lesson 21\. Capstone: Adding CRUD Models to Confetti Cuisine'
  id: totrans-721
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第21课：综合：将 CRUD 模型添加到 Confetti Cuisine
- en: Confetti Cuisine is satisfied with the progress I made connecting their application
    to a database and setting it up to process subscriber information. They’ve sent
    me a list of cooking courses that they’d like to begin to advertise on their site.
    Essentially, they want subscribers to pick the courses they’re most interested
    in attending. Then, if a subscriber later creates a user account, the business
    wants those two accounts to be linked.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: Confetti Cuisine 对我连接他们的应用程序到数据库并设置处理订阅者信息的进展感到满意。他们已经给我发了一份他们想要开始在网站上宣传的烹饪课程列表。本质上，他们希望订阅者选择他们最感兴趣的参加的课程。然后，如果订阅者后来创建了一个用户账户，该业务希望这两个账户能够相互链接。
- en: To accomplish this task, I need to improve the `Subscriber` model and build
    the `User` and `Course` models. I need to keep the relationships between these
    models in mind and populate data from associated models when necessary. Last,
    I need to generate all the functionality needed to allow the creation, reading,
    updating, and deletion (CRUD) of model records. In this capstone, I’m going to
    create a user login form that allows a user to create an account and then edit,
    update, and delete the account. I’ll repeat most of the process for courses and
    subscribers to Confetti Cuisine’s newsletter.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个任务，我需要改进`Subscriber`模型并构建`User`和`Course`模型。我需要记住这些模型之间的关系，并在必要时从关联模型中填充数据。最后，我需要生成所有必要的功能，以允许创建、读取、更新和删除（CRUD）模型记录。在这个项目中，我将创建一个用户登录表单，允许用户创建账户，然后编辑、更新和删除账户。我将重复大部分过程，为Confetti
    Cuisine的通讯录中的课程和订阅者。
- en: When I’m done, I’ll have an application to show the team at Confetti Cuisine
    that allows them to sign up new users and monitor their courses before officially
    launching the program.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 当我完成时，我将有一个应用程序，可以向Confetti Cuisine的团队展示，让他们能够在正式推出项目之前注册新用户并监控他们的课程。
- en: 'For this purpose, I need the following:'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，我需要以下内容：
- en: Schemas for the user, subscriber, and course models
  id: totrans-726
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户、订阅者和课程模型的模式
- en: CRUD actions for all models in the application
  id: totrans-727
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序中所有模型的CRUD操作
- en: Views showing links between models
  id: totrans-728
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示模型之间链接的视图
- en: '![](../Images/sectionFig.png)21.1\. Getting set up'
  id: totrans-729
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![图21.1](../Images/sectionFig.png)21.1. 设置环境'
- en: 'Picking up where I left off, I have a MongoDB database connected to my application,
    with the Mongoose package driving communication between my `Subscriber` model
    and raw documents. I’ll need the same core and external packages moving forward.
    Additionally, I need to install the `method-override` package to assist with HTTP
    methods not currently supported by HTML links and forms. I can install this package
    by running the following code in my project directory in a new terminal window:
    `npm i method-override -S`. Then I require the `method-override` module into main.js
    by adding `const method Override = require("method-override")` to the top of the
    file. I configure the application to use `method-override` to identify `GET` and
    `POST` requests as other methods by adding the following line: `app.use(methodOverride("_method",
    {methods: ["POST", "GET"]}))`.'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: '从我上次停止的地方继续，我已经将MongoDB数据库连接到我的应用程序，使用Mongoose包驱动我的`Subscriber`模型和原始文档之间的通信。在接下来的工作中，我需要相同的核心和外部包。此外，我需要安装`method-override`包来帮助处理HTML链接和表单目前不支持的所有HTTP方法。我可以通过在项目目录的新终端窗口中运行以下代码来安装此包：`npm
    i method-override -S`。然后，我将`method-override`模块引入到main.js中，通过在文件顶部添加`const methodOverride
    = require("method-override")`。我配置应用程序使用`method-override`来识别`GET`和`POST`请求作为其他方法，通过添加以下行：`app.use(methodOverride("_method",
    {methods: ["POST", "GET"]}))`。'
- en: Next, I need to think about how this project’s directory structure will look
    by the time I’m done. Because I’m adding CRUD functionality to three models, I’m
    going to create three new controllers, three new folders within views, and three
    model modules. The structure resembles [figure 21.1](#ch21fig01).
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我需要考虑当我完成时，这个项目的目录结构将是什么样子。因为我将向三个模型添加CRUD功能，所以我将创建三个新的控制器，在视图内创建三个新的文件夹，以及三个模型模块。结构类似于[图21.1](#ch21fig01)。
- en: Figure 21.1\. Capstone file structure
  id: totrans-732
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图21.1. 项目文件结构
- en: '![](../Images/21fig01_alt.jpg)'
  id: totrans-733
  prefs: []
  type: TYPE_IMG
  zh: '![图21.1替代](../Images/21fig01_alt.jpg)'
- en: 'Notice that I’m creating only four views: `index`, `new`, `show`, and `edit`.
    Although `delete` can have its own view as a deletion confirmation page, I’ll
    handle deletion through a link on the `index` page for each model.'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我只创建了四个视图：`index`、`new`、`show`和`edit`。尽管`delete`可以有自己的视图作为删除确认页面，但我将通过每个模型的`index`页面上的链接来处理删除。
- en: Next, I start by improving the `Subscriber` model and simultaneously build out
    my `User` and `Course` models.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我首先改进`Subscriber`模型，并同时构建我的`User`和`Course`模型。
- en: '![](../Images/sectionFig.png)21.2\. Building the models'
  id: totrans-736
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![图21.2](../Images/sectionFig.png)21.2. 构建模型'
- en: My `Subscriber` model collected meaningful data for Confetti Cuisine, but they
    want more security on the data layer. I need to add some validators on the `Subscriber`
    schema to ensure that subscriber data meets the client’s expectations before entering
    the database. My new schema looks like [listing 21.1](#ch21ex01).
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 我的`Subscriber`模型为Confetti Cuisine收集了有意义的数据，但他们希望在数据层上增加安全性。我需要在`Subscriber`模式上添加一些验证器，以确保在数据进入数据库之前，订阅者数据符合客户的要求。我的新模式看起来像[列表21.1](#ch21ex01)。
- en: I start by requiring Mongoose into this module and pulling the Mongoose Schema
    object into its own constant. I create my subscriber schema by using the `Schema`
    constructor and passing some properties for the subscriber. Each subscriber is
    required to enter a name and an email address that doesn’t already exist in the
    database. Each subscriber can opt to enter a five-digit ZIP code. The `timestamps`
    property is an add-on provided by Mongoose to record the `createdAt` and `updatedAt`
    attributes for this model.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 我首先将 Mongoose 引入这个模块，并将 Mongoose Schema 对象拉入其自己的常量。我通过使用 `Schema` 构造函数并传递一些订阅者属性来创建我的订阅者模式。每个订阅者都必须输入一个名称和一个在数据库中不存在的电子邮件地址。每个订阅者可以选择输入一个五位数的
    ZIP 码。`timestamps` 属性是 Mongoose 提供的一个附加功能，用于记录该模型的 `createdAt` 和 `updatedAt` 属性。
- en: Each subscriber may subscribe to show interest in multiple courses, so this
    association allows subscribers to associate with an array of referenced courses.
    I need to create the Course model for this feature to work. `getInfo` is an instance
    method added to the subscriber schema to quickly pull any subscriber’s `name`,
    `email`, and `zipCode` in one line. Exporting the Subscriber model with this new
    schema makes it accessible to other modules in the application.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 每个订阅者可以订阅多个课程，因此这个关联允许订阅者与一系列引用课程相关联。我需要创建课程模型来实现这个功能。`getInfo` 是添加到订阅者模式中的一个实例方法，用于快速检索任何订阅者的
    `name`、`email` 和 `zipCode`。使用这种新模式导出订阅者模型，使其在应用程序的其他模块中可访问。
- en: Listing 21.1\. Improved `Subscriber` schema in subscriber.js
  id: totrans-740
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 21.1\. 改进的 subscriber.js 中的 `Subscriber` 模式
- en: '[PRE37]'
  id: totrans-741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '***1*** **Require mongoose.**'
  id: totrans-742
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **需要 mongoose**。'
- en: '***2*** **Add schema properties.**'
  id: totrans-743
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **添加模式属性**。'
- en: '***3*** **Associate multiple courses.**'
  id: totrans-744
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **关联多个课程**。'
- en: '***4*** **Add a getInfo instance method.**'
  id: totrans-745
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **添加 `getInfo` 实例方法**。'
- en: '***5*** **Export the Subscriber model.**'
  id: totrans-746
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **导出订阅者模型**。'
- en: This model looks good, so I’ll apply some of the same techniques to the `Course`
    and `User` model in course.js and user.js, respectively. Every course is required
    to have a title and description with no initial limitations. A course has `maxStudents`
    and `cost` attributes that default to 0 and can’t be saved as a negative number;
    otherwise, my custom error messages appear.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模型看起来不错，所以我将应用一些相同的技巧到 course.js 和 user.js 中的 `Course` 和 `User` 模型。每个课程都必须有一个标题和描述，没有初始限制。课程有
    `maxStudents` 和 `cost` 属性，默认为 0，不能保存为负数；否则，会出现我的自定义错误消息。
- en: The `Course` schema contains the properties in the following listing.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: '`Course` 模式包含以下列表中的属性。'
- en: Listing 21.2\. Properties for the `Course` schema in course.js
  id: totrans-749
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 21.2\. course.js 中 `Course` 模式的属性
- en: '[PRE38]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '***1*** **Require title and description.**'
  id: totrans-751
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **需要标题和描述**。'
- en: '***2*** **Default maxStudents and cost to 0, and disallow negative numbers.**'
  id: totrans-752
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **默认 `maxStudents` 和 `cost` 为 0，并禁止负数**。'
- en: The `User` model contains the most fields and validations because I want to
    prevent a new user from entering invalid data. This model needs to link to both
    the `Course` and `Subscriber` models. The `User` schema is shown in [listing 21.3](#ch21ex03).
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: '`User` 模型包含最多的字段和验证，因为我希望防止新用户输入无效数据。这个模型需要链接到 `Course` 和 `Subscriber` 模型。`User`
    模式在 [列表 21.3](#ch21ex03) 中显示。'
- en: Each user’s name is saved as a `first` and `last` name attribute. The `email`
    and `zipCode` properties behave the same way as in `Subscriber`. Each user is
    required to have a password. As for subscribers, users are linked to multiple
    courses. Because subscribers may eventually create user accounts, I need to link
    those two accounts here. I also add the `timestamps` property to keep track of
    changes to user records in the database.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 每个用户的姓名保存为 `first` 和 `last` 名称属性。`email` 和 `zipCode` 属性的行为与 `Subscriber` 中相同。每个用户都必须有一个密码。对于订阅者来说，用户与多个课程相关联。因为订阅者最终可能会创建用户账户，所以我需要在这里链接这两个账户。我还添加了
    `timestamps` 属性，以跟踪数据库中用户记录的变化。
- en: Listing 21.3\. Creating the `User` model in `user.js`
  id: totrans-755
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 21.3\. 在 `user.js` 中创建 `User` 模型
- en: '[PRE39]'
  id: totrans-756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '***1*** **Add first and last name attributes.**'
  id: totrans-757
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **添加首名和姓氏属性**。'
- en: '***2*** **Require password.**'
  id: totrans-758
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **需要密码**。'
- en: '***3*** **Associate users with multiple courses.**'
  id: totrans-759
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **将用户与多个课程关联**。'
- en: '***4*** **Associate users with subscribers.**'
  id: totrans-760
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **将用户与订阅者关联**。'
- en: '***5*** **Add timestamps property.**'
  id: totrans-761
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **添加时间戳属性**。'
- en: Two more additions I make to the user model are a virtual attribute to return
    the user’s full name and a Mongoose `pre("save")` hook to link subscribers and
    users with the same email address. Those additions can be added directly below
    the schema definition in user.js and are shown in [listing 21.4](#ch21ex04).
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 我对用户模型所做的两个额外添加是一个返回用户全名的虚拟属性和一个Mongoose `pre("save")`钩子，用于将具有相同电子邮件地址的订阅者和用户链接起来。这些添加可以直接添加到user.js中的模式定义下方，并在[列表21.4](#ch21ex04)中显示。
- en: This first virtual attribute allows me to call `fullName` on a user to get the
    user’s `first` and `last` names as one value. The `pre("save")` hook runs right
    before a user is saved to the database. I’m passing the `next` parameter so that
    when this function is complete, I can call the next step in the middleware chain.
    To link to the current user, I save the user to a new variable outside the scope
    of my next query. I run the query only if the user doesn’t already have a linked
    `subscribedAccount`. I search the Subscriber model for documents that contain
    that user’s email address. If a subscriber exists, I set the returned subscriber
    to the user’s `subscribedAccount` attribute before saving the record and calling
    the next function in the middleware chain.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第一个虚拟属性允许我通过调用用户的`fullName`来获取用户的`first`和`last`名字作为一个值。`pre("save")`钩子在用户被保存到数据库之前运行。我传递`next`参数，以便当这个函数完成时，我可以调用中间件链中的下一个步骤。为了链接到当前用户，我将用户保存到一个新的变量中，这个变量超出了我下一个查询的作用域。我只在用户还没有链接的`subscribedAccount`时运行查询。我在Subscriber模型中搜索包含该用户电子邮件地址的文档。如果存在订阅者，我在保存记录并调用中间件链中的下一个函数之前，将返回的订阅者设置为用户的`subscribedAccount`属性。
- en: Listing 21.4\. Adding a virtual attribute and pre(“save”) hook in user.js
  id: totrans-764
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表21.4\. 在user.js中添加虚拟属性和pre(“save”)钩子
- en: '[PRE40]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '***1*** **Add the fullName virtual attribute.**'
  id: totrans-766
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **添加fullName虚拟属性。**'
- en: '***2*** **Add a pre(‘save’) hook to link a subscriber.**'
  id: totrans-767
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **添加一个pre(‘save’)钩子来链接订阅者。**'
- en: '***3*** **Check for a linked subscribedAccount.**'
  id: totrans-768
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **检查是否有链接的subscribedAccount。**'
- en: '***4*** **Search the Subscriber model for documents that contain that user’s
    email.**'
  id: totrans-769
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **在Subscriber模型中搜索包含该用户电子邮件的文档。**'
- en: '***5*** **Call the next middleware function.**'
  id: totrans-770
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **调用下一个中间件函数。**'
- en: 'With this model set up, I need to build the CRUD functionality. I start by
    creating the views: index.ejs, new.ejs, show.ejs, and edit.ejs.'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好这个模型后，我需要构建CRUD功能。我开始创建视图：index.ejs、new.ejs、show.ejs和edit.ejs。
- en: '![](../Images/sectionFig.png)21.3\. Creating the views'
  id: totrans-772
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)21.3\. 创建视图'
- en: For the Subscriber model, index.ejs lists all the subscribers in the database
    through an HTML table like the one shown in [listing 21.5](#ch21ex05). This view
    is a table with five columns. The first three columns display subscriber data,
    and the last two columns link to edit and delete pages for individual subscribers.
    For my subscribers index page, I added some new styling ([figure 21.2](#ch21fig02)).
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Subscriber模型，index.ejs通过一个HTML表格列出数据库中的所有订阅者，如[列表21.5](#ch21ex05)所示。这个视图是一个包含五列的表格。前三列显示订阅者数据，最后两列链接到单个订阅者的编辑和删除页面。对于我的订阅者索引页面，我添加了一些新的样式([图21.2](#ch21fig02))。
- en: Figure 21.2\. Subscribers index page in the browser
  id: totrans-774
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图21.2\. 浏览器中的订阅者索引页面
- en: '![](../Images/21fig02_alt.jpg)'
  id: totrans-775
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/21fig02_alt.jpg)'
- en: '|  |'
  id: totrans-776
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-777
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Because these views have the same names across different models, I need to organize
    them within separate folders by model name. The views/users folder has its own
    index.ejs, for example.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些视图在不同模型中具有相同的名称，我需要按照模型名称将它们组织在单独的文件夹中。例如，views/users文件夹有自己的index.ejs。
- en: '|  |'
  id: totrans-779
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: To generate a new row for each subscriber, I loop through the `subscribers`
    variable, an array of Subscriber objects, and access each subscriber’s attributes.
    The subscriber’s name is wrapped in an anchor tag that links to that subscriber’s
    `show` page by using the user’s `_id`. The delete link requires the `?_method=DELETE`
    query parameter appended to the path so that my `method-override` middleware can
    process this request as a `DELETE` request. I must remember to close my code block
    in EJS.
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为每个订阅者生成一行新数据，我遍历`subscribers`变量，这是一个Subscriber对象的数组，并访问每个订阅者的属性。订阅者的名字被包裹在一个锚标签中，通过使用用户的不`_id`链接到该订阅者的`show`页面。删除链接需要在路径后附加`?_method=DELETE`查询参数，以便我的`method-override`中间件可以将此请求作为`DELETE`请求处理。我必须记住在EJS中关闭我的代码块。
- en: Listing 21.5\. Listing subscribers in index.ejs
  id: totrans-781
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表21.5\. 在index.ejs中列出订阅者
- en: '[PRE41]'
  id: totrans-782
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '***1*** **Add a table to the index page.**'
  id: totrans-783
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **在索引页面添加一个表格。**'
- en: '***2*** **Generate a new row for each subscriber.**'
  id: totrans-784
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **为每个订阅者生成一行新数据。**'
- en: '***3*** **Wrap the subscriber’s name in an anchor tag.**'
  id: totrans-785
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **将订阅者的名字包裹在锚标签中。**'
- en: '***4*** **Add a delete link.**'
  id: totrans-786
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **添加一个删除链接。**'
- en: I’ll follow this exact same structure for the course and user index pages, making
    sure to swap out the variable names and attributes to match their respective models.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 我将遵循完全相同的结构来构建课程和用户索引页面，确保替换变量名称和属性以匹配相应的模型。
- en: With this index page in place, I need a way to create new records. I start with
    the subscriber’s new.ejs form in [listing 21.6](#ch21ex06). This form will submit
    data to the `/subscribers/- create` path, from which I’ll create new subscriber
    records in the subscriber’s controller. Notice that the form submits data via
    `POST` request. Each input reflects the model’s attributes. The `name` attribute
    of each form input is important, as I’ll use it in the controller to collect the
    data I need to save new records. At the end of the form is a submit button.
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 在有了这个索引页面之后，我需要一种创建新记录的方法。我从[列表 21.6](#ch21ex06)中的订阅者 `new.ejs` 表单开始。此表单将通过
    `POST` 请求提交数据到 `/subscribers/- create` 路径，从该路径我将创建新的订阅者记录在订阅者控制器中。注意，表单通过 `POST`
    请求提交数据。每个输入都反映了模型的属性。每个表单输入的 `name` 属性很重要，因为我将使用它在控制器中收集保存新记录所需的数据。表单的末尾有一个提交按钮。
- en: Listing 21.6\. Creating the new subscriber form in new.ejs
  id: totrans-789
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 21.6\. 在 new.ejs 中创建新的订阅者表单
- en: '[PRE42]'
  id: totrans-790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '***1*** **Add a form to create new subscribers.**'
  id: totrans-791
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **添加一个表单以创建新的订阅者。**'
- en: I re-create this form for users and courses, making sure to replace the form’s
    action and inputs to reflect the model I’m creating. My subscriber edit form looks
    like the one in [figure 21.3](#ch21fig03).
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 我为用户和课程重新创建了此表单，确保替换表单的动作和输入以反映我正在创建的模型。我的订阅者编辑表单看起来像[图 21.3](#ch21fig03)中的那个。
- en: Figure 21.3\. Subscriber edit page in the browser
  id: totrans-793
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 21.3\. 浏览器中的订阅者编辑页面
- en: '![](../Images/21fig03_alt.jpg)'
  id: totrans-794
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/21fig03_alt.jpg)'
- en: 'While I’m working on forms, I create the edit.ejs view, whose form resembles
    the one in new.ejs. The only changes to keep in mind are the following:'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在表单上工作时，我创建了 `edit.ejs` 视图，其表单类似于 `new.ejs`。需要注意的是以下更改：
- en: '*The edit form*—This form needs access to the record I’m editing. In this case,
    a `subscriber` comes from the subscriber’s controller.'
  id: totrans-796
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编辑表单*—此表单需要访问我正在编辑的记录。在这种情况下，`subscriber` 来自订阅者控制器。'
- en: '*The form action*—This action points to `/subscribers/${subscriber._id}/ update?_method=PUT`
    instead of the `create` action.'
  id: totrans-797
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*表单动作*—此动作指向 `/subscribers/${subscriber._id}/ update?_method=PUT` 而不是 `create`
    动作。'
- en: '*Attributes*—Each input’s `value` attribute is set to the `subscriber` variable’s
    attributes, as in `<input type="text" name="name" value="<%= subscriber.name %>">`.'
  id: totrans-798
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*属性*—每个输入的 `value` 属性设置为 `subscriber` 变量的属性，如 `<input type="text" name="name"
    value="<%= subscriber.name %>">`。'
- en: These same points apply to the edit.ejs forms for users and courses. The next
    listing shows my complete subscriber edit page.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 这些相同的点也适用于用户和课程的 edit.ejs 表单。下一个列表显示了完整的订阅者编辑页面。
- en: Listing 21.7\. The edit page for a subscriber in edit.ejs
  id: totrans-800
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 21.7\. `edit.ejs` 中的订阅者编辑页面
- en: '[PRE43]'
  id: totrans-801
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '***1*** **Display the edit form for a subscriber.**'
  id: totrans-802
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **显示订阅者的编辑表单。**'
- en: 'Last, I build the `show` page for each model. For subscribers, this page acts
    like a profile page, detailing each subscriber’s information in their row on the
    index page. This page is fairly straightforward: I show enough data to summarize
    a single subscriber record. The subscribers `show` page has a table, created with
    the EJS template elements shown in the following listing. This page uses attributes
    from a `subscriber` variable to display the `name`, `email`, and `zipCode`.'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我为每个模型构建了 `show` 页面。对于订阅者，这个页面类似于个人资料页面，详细说明了每个订阅者在索引页面上的信息。这个页面相当直接：我展示了足够的数据来总结单个订阅者记录。订阅者的
    `show` 页面有一个表格，使用以下列表中显示的 EJS 模板元素创建。这个页面使用 `subscriber` 变量的属性来显示 `name`、`email`
    和 `zipCode`。
- en: Listing 21.8\. The show page for a subscriber in show.ejs
  id: totrans-804
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 21.8\. `show.ejs` 中的订阅者展示页面
- en: '[PRE44]'
  id: totrans-805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '***1*** **Display subscriber attributes.**'
  id: totrans-806
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **显示订阅者属性。**'
- en: '|  |'
  id: totrans-807
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-808
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: For some of these views, I’ll add links to navigate to other relevant pages
    for that model.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些视图中的某些，我将添加链接以导航到该模型的其他相关页面。
- en: '|  |'
  id: totrans-810
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Something else I want to add to the `show` page is code that shows whether the
    record is associated with any other records in the database. For a user, that
    code showing an associated record could display using an additional tag at the
    bottom of the page to show whether the user has a `subscribedAccount` or associated
    `courses`. For subscribers, I’ll add a line to show the number of subscribed courses,
    as shown in [listing 21.9](#ch21ex09).
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 我还希望在 `show` 页面添加一段代码，以显示记录是否与数据库中的其他记录相关联。对于用户来说，显示相关记录的代码可以在页面底部添加一个额外的标签来显示用户是否有
    `subscribedAccount` 或相关 `courses`。对于订阅者，我将添加一行来显示已订阅课程的数目，如[列表 21.9](#ch21ex09)所示。
- en: This one line gives Confetti Cuisine insight into the number of courses to which
    people are subscribing. I could take this line a step further by using the Mongoose
    `populate` method on this subscriber to show the associated course details.
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行给 Confetti Cuisine 提供了人们订阅课程数目的洞察。我可以通过在这个订阅者上使用 Mongoose 的 `populate` 方法来进一步扩展这一行，以显示相关课程详情。
- en: Listing 21.9\. Show the number of subscribed courses in show.ejs
  id: totrans-813
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 21.9\. 在 show.ejs 中显示已订阅课程的数目
- en: '[PRE45]'
  id: totrans-814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '***1*** **Display the number of associated courses.**'
  id: totrans-815
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **显示相关课程的数目。**'
- en: The last step is bringing the models and views together with the controller
    actions and routes.
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将模型、视图与控制器动作和路由结合起来。
- en: '![](../Images/sectionFig.png)21.4\. Structuring routes'
  id: totrans-817
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![结构化路由](../Images/sectionFig.png)21.4\. 结构化路由'
- en: The forms and links for Confetti Cuisine are ready to be displayed, but there’s
    still no way to reach them via a browser. In main.js, I’m going to add the necessary
    CRUD routes and require the controllers needed to get everything working.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: Confetti Cuisine 的表单和链接已经准备好显示，但仍然没有通过浏览器访问它们的方法。在 main.js 中，我将添加必要的 CRUD 路由并引入所需的控制器，以确保一切正常工作。
- en: First, I add the routes for subscribers from [listing 21.10](#ch21ex10) to main.js.
    To make sure that the `subscribersController` is required near the top of the
    file alongside my other controllers, I add `const subscribersController = require("./controllers/subscribersController")`.
    I also introduce the Express.js Router to my project to help distinguish application
    routes from other configurations in main.js by adding `const router = express.Router()`.
    With this `router` object in place, I change every route and middleware handled
    by my `app` object to use the `router` object. Then I tell my application to use
    this `router` object by adding `app.use("/", router)` to main.js.
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我将从[列表 21.10](#ch21ex10)中添加订阅者的路由到 main.js。为了确保 `subscribersController` 在文件顶部与我的其他控制器一起被引入，我添加了
    `const subscribersController = require("./controllers/subscribersController")`。我还将
    Express.js 的 Router 引入到我的项目中，通过在 main.js 中添加 `const router = express.Router()`
    来帮助区分应用程序的路由和其他配置。有了这个 `router` 对象，我将 `app` 对象处理的每个路由和中间件都改为使用 `router` 对象。然后，我在
    main.js 中添加 `app.use("/", router)` 来告诉应用程序使用这个 `router` 对象。
- en: '`GET` requests to the `/subscribers` path lead me to the `index` action on
    the `subscribers-Controller`. Then I render the index.ejs page through another
    action called `indexView`. The same strategy applies to the other `GET` routes.
    The first `POST` route is for `create`. This route handles requests from forms
    to save new subscriber data. l need to create the logic to save new subscribers
    in the `create` action. Then I use an action called `redirectView` that will redirect
    to one of my views after I successfully create a subscriber record.'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `/subscribers` 路径的 `GET` 请求将我带到 `subscribers-Controller` 的 `index` 动作。然后，通过另一个名为
    `indexView` 的动作渲染 index.ejs 页面。相同的策略也适用于其他 `GET` 路由。第一个 `POST` 路由是用于 `create`
    的。这个路由处理来自表单的请求以保存新的订阅者数据。我需要在 `create` 动作中创建保存新订阅者的逻辑。然后，我使用一个名为 `redirectView`
    的动作，在成功创建订阅者记录后，将重定向到我的某个视图。
- en: The `show` route is the first case in which I need to get the subscriber’s ID
    from the path. In this case, `:id` represents the subscriber’s `ObjectId`, allowing
    me to search for that specific subscriber in the database in the `show` action.
    Then I use a `showView` to display the subscriber’s data in a view. The `update`
    route works like the `create` route, but I’m specifying the router to accept only
    `PUT` requests, indicating that a request is being made specifically to update
    an existing record. Similarly, I use the `redirectView` action after this to display
    a view. The last route, `delete`, accepts only `DELETE` requests. Requests will
    be made from the link on index.ejs and use the `redirectView` to link back to
    the index page.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: '`show` 路由是我需要从路径中获取订阅者 ID 的第一个情况。在这种情况下，`:id` 代表订阅者的 `ObjectId`，这允许我在 `show`
    动作中在数据库中搜索该特定订阅者。然后，我使用 `showView` 在视图中显示订阅者的数据。`update` 路由与 `create` 路由类似，但我指定路由只接受
    `PUT` 请求，这表示正在请求特定更新现有记录。同样，我在此之后使用 `redirectView` 动作来显示视图。最后一个路由 `delete` 只接受
    `DELETE` 请求。请求将从 index.ejs 中的链接发出，并使用 `redirectView` 链接到索引页面。'
- en: Listing 21.10\. Adding subscriber CRUD routes to main.js
  id: totrans-822
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 21.10\. 在 main.js 中添加订阅者 CRUD 路由
- en: '[PRE46]'
  id: totrans-823
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '***1*** **Add GET routes to show views.**'
  id: totrans-824
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **添加 GET 路由以显示视图。**'
- en: '***2*** **Add the first POST route for create.**'
  id: totrans-825
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **添加第一个用于创建的 POST 路由。**'
- en: '***3*** **Add a route to show a subscriber based on ObjectId.**'
  id: totrans-826
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **添加一个基于 ObjectId 显示订阅者的路由。**'
- en: '***4*** **Add a route to update subscribers.**'
  id: totrans-827
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **添加一个更新订阅者的路由。**'
- en: '***5*** **Add a route to delete subscribers.**'
  id: totrans-828
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **添加一个删除订阅者的路由。**'
- en: 'The same seven routes need to be made for users and courses. I’ll also update
    the navigation links: the contact link will point to the subscribers’ new view,
    and the courselistings link will point to the courses’ index view.'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 需要对用户和课程创建相同的七个路由。我还会更新导航链接：联系链接将指向订阅者的新视图，课程列表链接将指向课程的索引视图。
- en: '|  |'
  id: totrans-830
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-831
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: At this point, I can remove some of my deprecated routes, such as the ones that
    point to `getAllSubscribers`, `getSubscriptionPage`, and `saveSubscriber` in the
    subscribers controller, as well as `showCourses` in the home controller. I can
    also move my home-page route to the home controller’s index action. Finally, I
    want to make sure that I update my navigation links to point to `/subscribers/new`
    instead of `/contact`.
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我可以移除一些过时的路由，例如指向 `getAllSubscribers`、`getSubscriptionPage` 和 `saveSubscriber`
    的路由，这些路由位于订阅者控制器中，以及指向主页控制器中 `showCourses` 的路由。我还可以将主页路由移动到主页控制器的 index 动作中。最后，我想确保更新我的导航链接，使其指向
    `/subscribers/new` 而不是 `/contact`。
- en: '|  |'
  id: totrans-833
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: All I have left to do is create the corresponding controllers.
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 我剩下的工作就是创建相应的控制器。
- en: '![](../Images/sectionFig.png)21.5\. Creating controllers'
  id: totrans-835
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)21.5\. 创建控制器'
- en: The routes I created in main.js require a `subscribersController`, `coursesController`,
    and `usersController`. I start by creating those files in the controllers folder.
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 在 main.js 中创建的路由需要 `subscribersController`、`coursesController` 和 `usersController`。我开始在控制器文件夹中创建这些文件。
- en: '|  |'
  id: totrans-837
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-838
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: I’ve also cleaned up my error controller to use `http-status-codes` and an error.ejs
    view, as in previous application examples.
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 我还清理了我的错误控制器，以使用 `http-status-codes` 和 error.ejs 视图，就像之前的应用程序示例中那样。
- en: '|  |'
  id: totrans-840
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Next, for the subscriber’s controller, I add the actions shown in [listing 21.11](#ch21ex11)
    to handle requests made to my existing routes. After requiring the `Subscriber`
    model into this file, I create the `index` action to find all subscriber documents
    in my database and pass them through the `subscribers` variable into index.ejs
    via the `indexView` action. The `new` and `edit` actions also render a view to
    subscribe and edit subscriber data.
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，对于订阅者控制器，我添加了 [列表 21.11](#ch21ex11) 中显示的操作来处理对我的现有路由发出的请求。在将 `Subscriber`
    模型引入此文件后，我创建了 `index` 动作以找到数据库中的所有订阅者文档，并通过 `indexView` 动作将它们传递到 `index.ejs` 中的
    `subscribers` 变量。`new` 和 `edit` 动作也渲染一个视图来订阅和编辑订阅者数据。
- en: The `create` action collects request body parameters in my custom `getSubscriberParams`
    function, listed as the second constant in the code listing, to create a new subscriber
    record. If I’m successful, I’ll pass the user object through the `locals` variables
    object in my response. Then I’ll specify to redirect to the index page in the
    `redirectView` action.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: '`create` 动作通过我的自定义 `getSubscriberParams` 函数收集请求体参数，该函数列在代码列表的第二个常量中，以创建一个新的订阅者记录。如果操作成功，我将通过
    `locals` 变量对象将用户对象传递到我的响应中。然后，我将在 `redirectView` 动作中指定重定向到索引页面。'
- en: The `show` action pulls the subscriber’s ID from the URL with `req.params.id`.
    This value is used to search the database for one matching record and then pass
    that record to the next middleware function through the response object. In `showView`,
    the `show` page displays the contents of this `subscriber` variable. The `update`
    action behaves like `create` and uses the `findByIdAndUpdate` Mongoose method
    to set new values for an existing subscriber document. Here, I also pass the updated
    user object through the response object and specify a view to redirect to in the
    `redirectView` action.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: '`show` 操作从 URL 中通过 `req.params.id` 提取订阅者的 ID。此值用于在数据库中搜索一个匹配的记录，然后将该记录通过响应对象传递给下一个中间件函数。在
    `showView` 中，`show` 页面显示此 `subscriber` 变量的内容。`update` 操作的行为类似于 `create`，并使用 `findByIdAndUpdate`
    Mongoose 方法为现有的订阅者文档设置新值。在这里，我还通过响应对象传递更新后的用户对象，并在 `redirectView` 操作中指定要重定向到的视图。'
- en: The `delete` action uses the subscriber’s ID in the request parameters to `findByIdAndRemove`
    a matching document from the database. The `getSubscriberParams` function is designed
    to have less repetition in my code. Because the `create` and `update` actions
    use form parameters, they can call this function instead. The `redirectView` action
    is also intended to reduce code repetition by allowing multiple actions, including
    the `delete` action, to specify what view to render when the main function is
    complete.
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete` 操作使用请求参数中的订阅者 ID 来从数据库中 `findByIdAndRemove` 一个匹配的文档。`getSubscriberParams`
    函数旨在减少我的代码中的重复。因为 `create` 和 `update` 操作使用表单参数，它们可以调用此函数。`redirectView` 操作也旨在通过允许多个操作（包括
    `delete` 操作）在主函数完成后指定要渲染的视图来减少代码重复。'
- en: Listing 21.11\. Adding subscriber controller actions in subscribersController.js
  id: totrans-845
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 21.11\. 在 subscribersController.js 中添加订阅者控制器操作
- en: '[PRE47]'
  id: totrans-846
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '***1*** **Create a custom function to pull subscriber data from the request.**'
  id: totrans-847
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **创建一个自定义函数以从请求中提取订阅者数据。**'
- en: '***2*** **Create the index action to find all subscriber documents.**'
  id: totrans-848
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **创建索引操作以查找所有订阅者文档。**'
- en: '***3*** **Create the create action to create a new subscriber.**'
  id: totrans-849
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **创建创建操作以创建一个新的订阅者。**'
- en: '***4*** **Create the show action to display subscriber data.**'
  id: totrans-850
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **创建显示操作以显示订阅者数据。**'
- en: '***5*** **Create the update action to set new values for an existing subscriber
    document.**'
  id: totrans-851
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **创建更新操作以设置现有订阅者文档的新值。**'
- en: '***6*** **Create the delete action to remove a subscriber document.**'
  id: totrans-852
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **创建删除操作以移除一个订阅者文档。**'
- en: With these controller actions in place for each model, the application is ready
    to boot and manage records. I load the views for each model and then create new
    subscribers, courses, and users. In [unit 5](../Text/kindle_split_037.html#part05),
    I improve Confetti Cuisine’s site by adding user authentication and a login form.
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 在为每个模型设置这些控制器操作后，应用程序准备启动并管理记录。我加载每个模型的视图，然后创建新的订阅者、课程和用户。在 [单元 5](../Text/kindle_split_037.html#part05)
    中，我通过添加用户身份验证和登录表单来改进 Confetti Cuisine 的网站。
- en: '![](../Images/sectionFig.png)Summary'
  id: totrans-854
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)摘要'
- en: In this capstone exercise, I improved Confetti Cuisine’s application by adding
    CRUD functionality to three new models. These models allow subscribers to sign
    up for Confetti Cuisine’s upcoming course offerings and create user accounts to
    get involved with the cooking class product. In [unit 5](../Text/kindle_split_037.html#part05),
    I clean up these views by adding flash messaging, password security, and user
    authentication with the `passport` module.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个综合练习中，我通过向三个新模型添加 CRUD 功能来改进 Confetti Cuisine 的应用程序。这些模型允许订阅者注册 Confetti
    Cuisine 即将推出的课程，并创建用户账户以参与烹饪课程产品。在 [单元 5](../Text/kindle_split_037.html#part05)
    中，我通过添加闪存消息、密码安全和使用 `passport` 模块的用户身份验证来清理这些视图。
