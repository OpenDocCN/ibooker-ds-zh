- en: '5 Howler: Working with files and STDOUT'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 Howler：处理文件和标准输出
- en: '| In the Harry Potter stories, a “Howler” is a nasty-gram that arrives by owl
    at Hogwarts. It will tear itself open, shout a blistering message at the recipient,
    and then combust. In this exercise, we’re going to write a program that will transform
    text into a rather mild-mannered version of a Howler by MAKING ALL THE LETTERS
    UPPERCASE. The text that we’ll process will be given as a single positional argument.
    | ![](../Images/5-unnumb-1.png)  |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '| 在《哈利·波特》故事中，“Howler”是一种通过猫头鹰送至霍格沃茨的恶毒信件。它会自己撕裂，对着收件人喊出刺耳的信息，然后燃烧。在这个练习中，我们将编写一个程序，将文本转换成一个相当温和的
    Howler 版本，通过将所有字母转换为大写。我们将处理的文本将作为单个位置参数给出。| ![图片 5-unnumb-1.png]'
- en: 'For instance, if our program is given the input, “How dare you steal that car!”
    it should scream back “HOW DARE YOU STEAL THAT CAR!” Remember spaces on the command
    line delimit arguments, so multiple words need to be enclosed in quotes to be
    considered one argument:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们的程序接收到输入，“你怎么敢偷那辆车！”它应该尖叫回“你怎么敢偷那辆车！”记住，命令行上的空格分隔参数，因此多个单词需要用引号括起来才能被视为一个参数：
- en: '|'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The argument to the program may also name a file, in which case we need to
    read the file for the input:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的参数也可能指定一个文件，在这种情况下，我们需要读取文件作为输入：
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '| ![](../Images/5-unnumb-2.png)  |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '![图片 5-unnumb-2.png]'
- en: '| Our program will also accept an `-o` or `--outfile` option that names an
    output file into which the output text should be written. In that case, *nothing*
    will be printed on the command line:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '| 我们的程序还将接受一个 `-o` 或 `--outfile` 选项，指定一个输出文件，输出文本应写入该文件。在这种情况下，命令行上不会打印任何内容：'
- en: '[PRE2]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '| ![](../Images/5-unnumb-3.png)  |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '![图片 5-unnumb-3.png]'
- en: 'There should now be a file called out.txt that has the output:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该有一个名为 out.txt 的文件，其中包含以下输出：
- en: '[PRE3]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this exercise, you will learn to
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将学习到
- en: Accept text input from the command line or from a file
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从命令行或文件接受文本输入
- en: Change strings to uppercase
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将字符串转换为大写
- en: Print output either to the command line or to a file that needs to be created
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将输出打印到命令行或需要创建的文件
- en: Make plain text behave like a file handle
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使纯文本表现得像文件句柄
- en: 5.1 Reading files
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 读取文件
- en: '| This is our first exercise that will involve reading files. The argument
    to the program will be some text that might name an input file, in which case
    you will open and read the file. If the text is not the name of a file, you’ll
    use the text itself. | ![](../Images/5-unnumb-4.png)  |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 这是我们的第一个涉及读取文件的练习。程序的参数将是某些文本，这些文本可能指定一个输入文件，在这种情况下，您将打开并读取该文件。如果文本不是文件名，您将使用文本本身。|
    ![图片 5-unnumb-4.png]'
- en: 'The built-in `os` (operating system) module has a method for detecting whether
    a string is the name of a file. To use it, you must import the `os` module. For
    instance, there’s probably not a file called “blargh” on your system:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的 `os`（操作系统）模块有一个用于检测字符串是否为文件名的方法。要使用它，您必须导入 `os` 模块。例如，您的系统可能没有名为“blargh”的文件：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `os` module contains loads of useful submodules and functions. Consult the
    documentation at [https://docs.python.org/3/library/os.html](https://docs.python.org/3/library/os.html)
    or use `help(os)` in the REPL.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`os` 模块包含大量有用的子模块和函数。请参阅 [https://docs.python.org/3/library/os.html](https://docs.python.org/3/library/os.html)
    的文档或使用 REPL 中的 `help(os)`。'
- en: 'For instance, `os.path.basename()` and `os.path.dirname()` can return a file’s
    name or directory from a path, respectively (see figure 5.1):'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`os.path.basename()` 和 `os.path.dirname()` 可以分别从路径中返回文件名或目录（见图 5.1）：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![](../Images/5-1.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片 5-1](../Images/5-1.png)'
- en: Figure 5.1 The `os` module has handy functions like `os.path.dirname()` and
    `os.path.basename()` for getting parts of file paths.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 `os` 模块包含一些方便的函数，如 `os.path.dirname()` 和 `os.path.basename()`，用于获取文件路径的部分。
- en: In the top level of the GitHub source repository, there is a directory called
    “inputs” that contains several files we’ll use for many of the exercises. Here
    I’ll use a file called inputs/fox.txt. Note that you will need to be in the main
    directory of the repo for this to work.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GitHub 源代码仓库的最高级别中，有一个名为“inputs”的目录，其中包含我们将用于许多练习的几个文件。这里我将使用一个名为 inputs/fox.txt
    的文件。请注意，为了使此操作生效，您需要位于仓库的主目录中。
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Once you’ve determined that the argument is the name of a file, you must `open()`
    it to `read()` it. The return from `open()` is a *file handle*. I usually call
    this variable `fh` to remind me that it’s a file handle. If I have more than one
    open file handle, like both input and output handles, I may call them `in_fh`
    and `out_fh`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你确定参数是文件名，你必须`open()`它来`read()`它。`open()`的返回值是一个*文件句柄*。我通常将这个变量命名为`fh`，以提醒我它是一个文件句柄。如果我有多个打开的文件句柄，比如输入和输出句柄，我可能将它们命名为`in_fh`和`out_fh`。
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note Per PEP 8 ([www.python.org/dev/peps/pep-0008/#function-and-variable-names](http://www.python.org/dev/peps/pep-0008/#function-and-variable-names)),
    function and variable “names should be lowercase, with words separated by underscores
    as necessary to improve readability.”
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：根据PEP 8（[www.python.org/dev/peps/pep-0008/#function-and-variable-names](http://www.python.org/dev/peps/pep-0008/#function-and-variable-names)），函数和变量“名称应该是小写，必要时用下划线分隔单词以提高可读性。”
- en: 'If you try to `open()` a file that does not exist, you’ll get an exception.
    This is unsafe code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试`open()`一个不存在的文件，你会得到一个异常。这是不安全的代码：
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Always check that the file exists!
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 总是检查文件是否存在！
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We will use the `fh.read()` method to get the contents of the file. It might
    be helpful to think of a file as a can of tomatoes. The file’s name, like “inputs/fox.txt,”
    is the label on the can, which is not the same as the *contents*. To get at the
    text inside (or the “tomatoes”), we need to *open* the can.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`fh.read()`方法来获取文件的内容。把文件想象成一个番茄罐可能会有所帮助。文件名，如“inputs/fox.txt”，是罐子的标签，这与*内容*不同。要获取里面的文本（或“番茄”），我们需要*打开*罐子。
- en: 'Take a look at figure 5.2:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 看看图5.2：
- en: The file handle (`fh`) is a mechanism we can use to get at the contents of the
    file. To get at the tomatoes, we need to `open()` the can.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件句柄（`fh`）是我们用来获取文件内容的一种机制。要获取番茄，我们需要打开罐子。
- en: The `fh.read()` method returns what is inside the `file`. With the can opened,
    we can get at the contents.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`fh.read()`方法返回`file`内的内容。打开罐头后，我们可以获取内容。'
- en: Once the file handle has been read, there’s nothing left.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦文件句柄被读取，就没有什么剩余了。
- en: '![](../Images/5-2.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/5-2.png)'
- en: Figure 5.2 A file is a bit like a can of tomatoes. We have to open it first
    so that we can read it, after which the file handle is exhausted.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 文件有点像番茄罐。我们必须先打开它，这样我们才能读取它，之后文件句柄就耗尽了。
- en: Note You can use `fh.seek(0)` to reset the file handle to the beginning if you
    really want to read it again.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你可以使用`fh.seek(0)`将文件句柄重置到开始位置，如果你真的想再次读取它。
- en: 'Let’s see what `type()` the `fh` is:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`fh`的类型：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In computer lingo, “io” means “input/output.” The `fh` object is something that
    handles I/O operations. You can use `help(fh)` (using the name of the variable
    itself) to read the docs on the `class` `TextIOWrapper`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机术语中，“io”代表“输入/输出”。`fh`对象是处理I/O操作的东西。你可以使用`help(fh)`（使用变量的名称本身）来阅读关于`class`
    `TextIOWrapper`的文档。
- en: 'The two methods you’ll use quite often are `read()` and `write()`. Right now,
    we care about `read()`. Let’s see what that gives us:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你将非常频繁使用的两种方法是`read()`和`write()`。现在，我们关注`read()`。让我们看看它给我们带来了什么：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '| Do me a favor and execute that line one more time. What do you see?'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '| 请帮我把那一行再执行一次。你看到了什么？'
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: A file handle is different from something like a `str`. Once you read a file
    handle, it’s empty. It’s like pouring the tomatoes out of the can. Now that the
    can is empty, you can’t empty it again. | ![](../Images/5-unnumb-5.png)  |
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 文件句柄与`str`这样的东西不同。一旦你读取了文件句柄，它就是空的。它就像把番茄从罐头倒出来一样。现在罐子是空的，你不能再次倒空它。| ![](../Images/5-unnumb-5.png)  |
- en: 'We can actually compress `open()` and `fh.read()` into one line of code by
    *chaining* those methods together. The `open()` method returns a file handle that
    can be used for the call to `fh.read()` (see figure 5.3). Run this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上可以通过将那些方法链接在一起，将`open()`和`fh.read()`压缩成一行代码。`open()`方法返回一个文件句柄，可以用于`fh.read()`的调用（见图5.3）。运行这个：
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![](../Images/5-3.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/5-3.png)'
- en: Figure 5.3  The `open()` function returns a file handle, so we can chain it
    to a call to `read()`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3  `open()`函数返回一个文件句柄，因此我们可以将其链接到`read()`的调用。
- en: 'And now run it again:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次运行它：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Each time you `open()` the file, you get a fresh file handle to `read()`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你`open()`文件时，你都会得到一个全新的文件句柄来`read()`。
- en: If we want to preserve the contents, we’ll need to copy them into a variable.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想保留内容，我们需要将它们复制到一个变量中。
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `type()` of the result is a `str`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的`type()`是`str`：
- en: '[PRE16]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you want, you can chain any `str` method onto the end of that. For instance,
    maybe you want to remove the trailing newline. The `str.rstrip()` method will
    remove any whitespace (which includes newlines) from the *right* end of a string
    (see figure 5.4).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，可以将任何`str`方法链接到末尾。例如，你可能想删除尾随的换行符。`str.rstrip()`方法将从字符串的**右侧**删除任何空白字符（包括换行符）（见图5.4）。
- en: '[PRE17]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![](../Images/5-4.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/5-4.png)'
- en: Figure 5.4 The `open()` method returns a file handle, to which we chain `read()`,
    which returns a string, to which we chain the `str.rstrip()` call.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 `open()`方法返回一个文件句柄，我们可以将其与`read()`方法链式调用，`read()`返回一个字符串，然后我们再链式调用`str.rstrip()`。
- en: '| Once you have your input text--whether it is from the command line or from
    a file--you need to UPPERCASE it. The `str.upper()` method is probably what you
    want. | ![](../Images/5-unnumb-6.png)  |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 一旦你有了输入文本——无论它来自命令行还是来自文件——你需要将其转换为大写。`str.upper()`方法可能是你想要的。 | ![](../Images/5-unnumb-6.png)  |'
- en: 5.2 Writing files
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 写入文件
- en: The output of the program should either appear on the command line or be written
    to a file. Command-line output is also called *standard out* or `STDOUT`. (It’s
    the *standard* or normal place for *output* to occur.) Now let’s look at how to
    write the output to a file.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出应该出现在命令行上或写入文件中。命令行输出也称为**标准输出**或`STDOUT`。（它是**标准**或正常**输出**发生的地方。）现在让我们看看如何将输出写入文件。
- en: We still need to `open()` a file handle, but we have to use an optional second
    argument, the string `'w'`, to instruct Python to open it for *writing*. Other
    modes include `'r'` for *reading* (the default) and `'a'` for *appending*, as
    listed in table 5.1.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要打开一个文件句柄，但我们必须使用可选的第二个参数字符串`'w'`来指示Python以**写入**模式打开它。其他模式包括表5.1中列出的`'r'`用于**读取**（默认）和`'a'`用于**追加**。
- en: Table 5.1 File-writing modes
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.1 文件写入模式
- en: '| Mode | Meaning |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 模式 | 含义 |'
- en: '| `w` | Write |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `w` | 写入 |'
- en: '| `r` | Read |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `r` | 读取 |'
- en: '| `a` | Append |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `a` | 追加 |'
- en: You can additionally describe the kind of content, whether `'t'` for *text*
    (the default) or `'b'` for *binary*, as listed in table 5.2.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以描述内容的类型，是`'t'`用于**文本**（默认）还是`'b'`用于**二进制**，如表5.2中所示。
- en: Table 5.2 File-content modes
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.2 文件内容模式
- en: '| Mode | Meaning |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 模式 | 含义 |'
- en: '| `t` | Text |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `t` | 文本 |'
- en: '| `b` | Bytes |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `b` | 字节 |'
- en: '| You can combine the values in these two tables, like `''rb''` to *read* a
    *binary* file or `''at''` to *append* to a *text* file. Here we will use `''wt''`
    to *write* a *text* file.I’ll call my variable `out_fh` to remind me that this
    is the output file handle:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '| 你可以将这两个表中的值组合起来，例如使用`''rb''`来**读取**一个**二进制**文件或使用`''at''`来**追加**到一个**文本**文件。在这里，我们将使用`''wt''`来**写入**一个**文本**文件。我将我的变量命名为`out_fh`以提醒我这是一个输出文件句柄：'
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '| ![](../Images/5-unnumb-7.png)  |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| ![](../Images/5-unnumb-7.png)  |'
- en: If the file does not exist, it will be created. If the file does exist, it will
    be *overwritten*, which means that all the previous data will be lost! If you
    don’t want an existing file to be lost, you can use the `os.path.isfile()` function
    you saw earlier to first check if the file exists, and perhaps use `open()` in
    the “append” mode instead. For this exercise, we’ll use the `'wt'` mode to write
    text.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件不存在，它将被创建。如果文件已存在，它将被**覆盖**，这意味着所有之前的数据都将丢失！如果你不希望现有的文件丢失，你可以使用你之前看到的`os.path.isfile()`函数首先检查文件是否存在，并可能使用“追加”模式的`open()`。对于这个练习，我们将使用`'wt'`模式来写入文本。
- en: You can use the `write()` method of the file handle to put text into the file.
    Whereas the `print()` function will append a newline (`\n`) unless you instruct
    it not to, the `write()` method will *not* add a newline, so you have to explicitly
    add one.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用文件句柄的`write()`方法将文本放入文件。与`print()`函数会追加一个换行符（`\n`）除非你指示它不要这样做不同，`write()`方法**不会**添加换行符，所以你必须显式地添加一个。
- en: 'If you use the `out_fh.write()` method in the REPL, you will see that it returns
    the number of bytes written. Here each character, including the newline (`\n`),
    is a byte:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用REPL中的`out_fh.write()`方法，你会看到它返回写入的字节数。在这里，每个字符，包括换行符（`\n`），都是一个字节：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You can check that this is correct:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以检查这是否正确：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Most code tends to ignore this return value; that is, we don’t usually bother
    to capture the results in a variable or check that we got a nonzero return. If
    `write()` fails, there’s usually some much bigger problem with your system.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数代码通常会忽略这个返回值；也就是说，我们通常不会费心将结果捕获到变量中或检查我们是否得到了非零返回。如果`write()`失败，通常意味着你的系统存在一些更大的问题。
- en: 'You can also use the `print()` function with the optional `file` argument.
    Notice that I don’t include a newline with `print()` because it will add one.
    This method returns `None`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用带有可选 `file` 参数的 `print()` 函数。注意，我没有在 `print()` 中包含换行符，因为它会自动添加一个。这种方法返回
    `None`：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When you are done writing to a file handle, you should `out_fh.close()` it
    so that Python can clean up the file and release the memory associated with it.
    This method also returns `None`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成向文件句柄写入后，你应该调用 `out_fh.close()`，这样 Python 就可以清理文件并释放与之相关的内存。此方法也返回 `None`：
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let’s check if the lines of text we printed to our out.txt file made it by
    opening the file and reading it. Note that the newline appears here as `\n`. We
    need to `print()` the string for it to create an actual newline:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查我们打印到 out.txt 文件中的文本行是否已经写入，通过打开文件并读取它。注意，换行符在这里表示为 `\n`。我们需要 `print()`
    这个字符串，以便它创建一个实际的换行：
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When we `print()` on an open file handle, the text will be appended to any
    previously written data. Look at this code, though:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在打开的文件句柄上 `print()` 时，文本将被追加到之前写入的数据。不过，看看这段代码：
- en: '[PRE24]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If you run that line twice, will the file called hagrid.txt have the line once
    or twice? Let’s find out:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行那行代码两次，名为 hagrid.txt 的文件将包含一行还是两行？让我们来看看：
- en: '[PRE25]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Just once! Why is that? Remember, each call to `open()` gives us a new file
    handle, so calling `open()` twice results in new file handles. Each time you run
    that code, the file is opened anew in *write* mode and the existing data is *overwritten*.
    To avoid confusion, I recommend you write code more along these lines:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 只一次！为什么是那样？记住，每次调用 `open()` 都会给我们一个新的文件句柄，所以调用 `open()` 两次会导致新的文件句柄。每次运行这段代码，文件都会以
    *写入* 模式重新打开，并且现有数据会被 *覆盖*。为了避免混淆，我建议你编写更接近以下这样的代码：
- en: '[PRE26]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 5.3 Writing howler.py
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3 编写 howler.py
- en: You’ll need to create a program called howler.py in the 05_howler directory.
    You can use the new.py program for this, copy template.py, or start however you
    prefer. Figure 5.5 is a string diagram showing an overview of the program and
    some example inputs and outputs.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在 05_howler 目录下创建一个名为 howler.py 的程序。你可以使用新的.py 程序，复制 template.py，或者以你喜欢的任何方式开始。图
    5.5 是一个字符串图，展示了程序的整体概述和一些示例输入和输出。
- en: '![](../Images/5-5.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/5-5.png)'
- en: Figure 5.5 A string diagram showing that our howler.py program will accept strings
    or files as inputs and possibly an output filename.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 一个字符串图，展示了我们的 howler.py 程序将接受字符串或文件作为输入，以及可能的输出文件名。
- en: 'When run with no arguments, it should print a short usage message:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当不带参数运行时，它应该打印一条简短的用法信息：
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'When run with `-h` or `--help`, the program should print a longer usage statement:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行 `-h` 或 `--help` 时，程序应该打印一条较长的用法说明：
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If the argument is a regular string, it should uppercase that:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数是一个普通字符串，它应该将那个字符串转换为大写：
- en: '[PRE29]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If the argument is the name of a file, it should uppercase the *contents of
    the file*:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数是文件名，它应该将文件的 *内容* 转换为大写：
- en: '[PRE30]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If given an `--outfile` filename, the uppercased text should be written to
    the indicated file and nothing should be printed to `STDOUT`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供了 `--outfile` 文件名，则应将大写文本写入指定的文件，并且不应将任何内容打印到 `STDOUT`：
- en: '[PRE31]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here are a few hints:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些提示：
- en: Start with new.py and alter the `get_args()` section until your usage statements
    match the ones above.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 new.py 开始，修改 `get_args()` 部分，直到你的用法说明与上面的一致。
- en: Run the test suite and try to pass just the first test that handles text on
    the command line and prints the uppercased output to `STDOUT`.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行测试套件，并尝试通过只处理命令行上的文本并打印到 `STDOUT` 的第一个测试。
- en: The next test is to see if you can write the output to a given file. Figure
    out how to do that.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个测试是看看你是否能将输出写入指定的文件。找出如何做到这一点。
- en: The next test is for reading input from a file. Don’t try to pass all the tests
    at once!
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个测试是读取文件输入。不要试图一次性通过所有测试！
- en: There is a special file handle that always exists called “standard out” (often
    `STDOUT`). If you `print()` without a `file` argument, it defaults to `sys.stdout`.
    You will need to `import` `sys` in order to use it.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在一个始终存在的特殊文件句柄，称为“标准输出”（通常 `STDOUT`）。如果你 `print()` 时没有提供 `file` 参数，它默认为 `sys.stdout`。你需要
    `import` `sys` 来使用它。
- en: Be sure you really try to write the program and pass all the tests before moving
    on to read the solution. If you get stuck, maybe whip up a batch of Polyjuice
    Potion and freak out your friends.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你真的尝试编写程序并通过所有测试，然后再阅读解决方案。如果你卡住了，也许可以制作一批 Polyjuice Potion（一种虚构的魔法药水），让你的朋友们感到惊讶。
- en: 5.4 Solution
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.4 解决方案
- en: Here is a solution that will pass the tests. It’s rather short because Python
    allows us to express some really powerful ideas very concisely.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个通过测试的解决方案。它相当简短，因为 Python 允许我们非常简洁地表达一些真正强大的想法。
- en: '[PRE32]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: ① The text argument is a string that may be the name of a file.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ① 文本参数是一个字符串，可能是文件名。
- en: ② The --outfile option is also a string that names a file.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ② `--outfile` 选项也是一个字符串，命名一个文件。
- en: ③ Parse the command-line arguments into the variable args so that we can manually
    check the text argument.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 将命令行参数解析到变量 `args` 中，以便我们可以手动检查文本参数。
- en: ④ Check if args.text is the name of an existing file.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 检查 `args.text` 是否是现有文件的名称。
- en: ⑤ If so, overwrite the value of args.text with the results of reading the file.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 如果是，用读取文件的结果覆盖 `args.text` 的值。
- en: ⑥ Return the arguments to the caller.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 将参数返回给调用者。
- en: ⑦ Call get_args () to get the arguments to the program.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 调用 `get_args()` 来获取程序的参数。
- en: ⑧ Use an if expression to choose either sys.stdout or a newly opened file handle
    to write the output.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 使用 if 表达式选择 `sys.stdout` 或新打开的文件句柄来写入输出。
- en: ⑨ Use the opened file handle to write the output converted to uppercase.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 使用打开的文件句柄将输出转换为大写并写入。
- en: ⑩ Close the file handle.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ 关闭文件句柄。
- en: 5.5 Discussion
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.5 讨论
- en: How did it go for you this time? I hope you didn’t sneak into Professor Snape’s
    office again. You really don’t want more Saturday detentions.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你这次进展如何？我希望你没有再次偷偷溜进斯内普教授的办公室。你真的不希望有更多的周六留校。
- en: 5.5.1 Defining the arguments
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.1 定义参数
- en: The `get_args()` function, as always, comes first. Here I define two arguments.
    The first is a positional `text` argument. Since it may or may not name a file,
    all I can know is that it will be a string.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_args()` 函数，一如既往地首先出现。在这里，我定义了两个参数。第一个是一个位置参数 `text`。由于它可能或可能不是文件名，我所知道的就是它将是一个字符串。'
- en: '[PRE33]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note If you define multiple positional parameters, their order *relative to
    each other* is important. The first positional parameter you define will handle
    the first positional argument provided. It’s not important, however, to define
    positional parameters before or after options and flags. You can declare those
    in any order you like.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果你定义了多个位置参数，它们之间的顺序 *相对位置* 是重要的。你定义的第一个位置参数将处理提供的第一个位置参数。然而，在选项和标志之前或之后定义位置参数并不重要。你可以按任何顺序声明它们。
- en: The other argument is an option, so I give it a short name of `-o` and a long
    name of `--outfile`. Even though the default `type` for all arguments is `str`,
    I like to state this explicitly. The `default` value is the empty string. I could
    just as easily use the special `None` type, which is also the default value, but
    I prefer to use a defined argument like the empty string.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个参数是一个选项，所以我给它取了一个简短的名称 `-o` 和一个长名称 `--outfile`。尽管所有参数的默认 `type` 都是 `str`，但我喜欢明确地声明这一点。默认值是空字符串。我同样可以使用特殊的
    `None` 类型，它也是默认值，但我更倾向于使用一个定义明确的参数，比如空字符串。
- en: '[PRE34]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 5.5.2 Reading input from a file or the command line
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.2 从文件或命令行读取输入
- en: 'This is a deceptively simple program that demonstrates a couple of very important
    elements of file input and output. The `text` input might be a plain string, or
    it might be the name of a file. This pattern will come up repeatedly in this book:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个表面上简单的程序，展示了文件输入和输出的几个非常重要的元素。`text` 输入可能是一个普通字符串，也可能是一个文件名。这种模式将在本书中反复出现：
- en: '[PRE35]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `os.path.isfile()` function will tell me if there is a file with the specified
    name in `text`. If that returns `True`, I can safely `open(file)` to get a file
    handle, which has a method called `read` and which will return *all* the contents
    of the file.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`os.path.isfile()` 函数会告诉我 `text` 中是否存在具有指定名称的文件。如果返回 `True`，我可以安全地 `open(file)`
    来获取文件句柄，该句柄有一个名为 `read` 的方法，它将返回文件的所有内容。'
- en: Warning You should be aware that `fh.read()` will return the *entire file* as
    a single string. Your computer must have more memory available than the size of
    the file. For all the programs in this book, you will be safe as the files are
    small. In my day job, I regularly deal with gigabyte-sized files, so calling `fh.read()`
    would likely crash my program if not my whole system, because I would exceed my
    available memory.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：你应该意识到 `fh.read()` 将返回整个文件作为一个单独的字符串。你的计算机必须具有比文件大小更多的可用内存。对于本书中的所有程序，由于文件很小，你将安全无虞。在我的日常工作日，我经常处理吉字节大小的文件，如果不调用
    `fh.read()`，我的程序甚至整个系统可能会崩溃，因为我将超出我的可用内存。
- en: The result of `open(file).read()` is a `str`, which has a method called `str.rstrip()`
    that will return a copy of the string *stripped* of any whitespace on the *right*
    side (see figure 5.6). I call this so that the input text will look the same whether
    it comes from a file or directly from the command line. When you provide the input
    text directly on the command line, you have to press Enter to terminate the command.
    That Enter is a newline, and the operating system automatically removes it before
    passing it to the program.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`open(file).read()`的结果是一个`str`，它有一个名为`str.rstrip()`的方法，将返回一个字符串副本，其右侧的任何空白都被移除（见图5.6）。我这样做是为了使输入文本看起来相同，无论它来自文件还是直接来自命令行。当你直接在命令行上提供输入文本时，你必须按Enter键来终止命令。那个Enter是一个换行符，操作系统在将其传递给程序之前会自动将其移除。'
- en: '![](../Images/5-6.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/5-6.png)'
- en: Figure 5.6 The `open()` function returns a file handle (`fh`). The `fh.read()`
    function returns a `str`. The `str.rstrip()` function returns a new `str` with
    the whitespace removed from the right side. All these functions can be chained
    together.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6 `open()`函数返回一个文件句柄（`fh`）。`fh.read()`函数返回一个`str`。`str.rstrip()`函数返回一个新的`str`，其右侧的空白已被移除。所有这些函数都可以链接在一起。
- en: The longer way to write the preceding statement would be
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 写出前面语句的较长方式会是
- en: '[PRE36]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In my version, I chose to handle this inside the `get_args()` function. This
    is the first time I’ve shown you that you can intercept and alter arguments before
    passing them on to `main()`. We’ll use this idea quite a bit in later exercises.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的版本中，我选择在`get_args()`函数内部处理这个问题。这是我第一次向你展示你可以在将参数传递给`main()`之前拦截和修改参数。我们将在后面的练习中多次使用这个想法。
- en: I like to do all the work to validate the user’s arguments inside `get_args()`.
    I could just as easily do this in `main()` after the call to `get_args()`, so
    this is entirely a style issue.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢在`get_args()`内部完成所有验证用户参数的工作。我也可以在调用`get_args()`之后在`main()`中这样做，所以这完全是一个风格问题。
- en: 5.5.3 Choosing the output file handle
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.3 选择输出文件句柄
- en: 'The following line decides where to put the output of the program:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行决定了程序输出的位置：
- en: '[PRE37]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `if` expression will open args.outfile for writing text (`wt`) if the user
    provided that argument; otherwise, it will use `sys.stdout`, which is a file handle
    to `STDOUT`. Note that I don’t have to call `open()` on `sys.stdout` because it
    is always available and open for business (figure 5.7).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`表达式将根据用户是否提供了该参数来打开`args.outfile`以写入文本（`wt`）；否则，它将使用`sys.stdout`，这是一个指向`STDOUT`的文件句柄。请注意，我不需要调用`open()`在`sys.stdout`上，因为它总是可用且已打开（见图5.7）。'
- en: '![](../Images/5-7.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/5-7.png)'
- en: Figure 5.7 An `if` expression succinctly handles a binary choice. Here we want
    the output file handle to be the result of opening the outfile argument if present;
    otherwise, it should be `sys.stdout`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7 `if`表达式简洁地处理了二选一的情况。在这里，我们希望输出文件句柄是打开outfile参数的结果（如果存在）；否则，它应该是`sys.stdout`。
- en: 5.5.4 Printing the output
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.4 打印输出
- en: 'To get the uppercase text, I can use the `text.upper()` method. Then I need
    to find a way to print it to the output file handle. I chose to do this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取大写文本，我可以使用`text.upper()`方法。然后我需要找到一种方法将其打印到输出文件句柄。我选择这样做：
- en: '[PRE38]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Alternatively, you could do this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以这样做：
- en: '[PRE39]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Finally, I need to close the file handle with `out_fh.close()`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我需要使用`out_fh.close()`关闭文件句柄。
- en: 5.5.5 A low-memory version
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.5 低内存版本
- en: 'There is a potentially serious problem waiting to bite us in this program.
    In `get_args()`, we’re reading the entire file into memory with this line:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，有一个可能严重的问题在等待着我们。在`get_args()`中，我们使用这一行将整个文件读入内存：
- en: '[PRE40]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We could, instead, only `open()` the file:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以只打开文件：
- en: '[PRE41]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Later we could read it line by line:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 之后我们可以逐行读取它：
- en: '[PRE42]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The problem, though, is how to handle the times when the `text` argument is
    actually text and not the name of a file. The `io` (input-output) module in Python
    has a way to represent text as a *stream*:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，问题是如何处理当`text`参数实际上是文本而不是文件名时的情况。Python中的`io`（输入-输出）模块有一种将文本表示为*流*的方法：
- en: '[PRE43]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: ① Import the io module.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ① 导入io模块。
- en: ② Use the io.StringIO() function to turn the given str value into something
    we can treat like an open file handle.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ② 使用`io.StringIO()`函数将给定的str值转换为我们可以像处理打开的文件句柄一样处理的东西。
- en: ③ Use a for loop to iterate through the “lines” of text separated by newlines.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 使用for循环遍历由换行符分隔的文本“行”。
- en: ④ Print the line using the end='' option to avoid having two newlines.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 使用end=''选项打印行，以避免出现两个换行符。
- en: This is the first time you’re seeing that you can treat a regular string value
    as if it were a generator of values similar to a file handle. This is a particularly
    useful technique for testing any code that needs to read an input file. You can
    use the return from `io.StreamIO()` as a “mock” file handle so that your code
    doesn’t have to read an *actual* file, just a given value that can produce “lines”
    of text.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您第一次看到可以将常规字符串值视为类似文件句柄的值生成器。这对于测试需要读取输入文件的任何代码来说是一个特别有用的技术。您可以使用 `io.StringIO()`
    的返回值作为“模拟”文件句柄，这样您的代码就不必读取“实际”文件，只需给定可以产生“行”文本的值。
- en: 'To make this work, we can change how we handle `args.text`, like so:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这可行，我们可以改变处理 `args.text` 的方式，如下所示：
- en: '[PRE44]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: ① Check if args.text is a file.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ① 检查 `args.text` 是否是一个文件。
- en: ② If it is, replace args.text with the file handle created by opening the file.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ② 如果是，将 `args.text` 替换为通过打开文件创建的文件句柄。
- en: ③ Otherwise, replace args.text with an io.StringIO() value that will act like
    an open file handle. Note that we need to add a newline to the text so that it
    will look like the lines of input coming from an actual file.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 否则，将 `args.text` 替换为 `io.StringIO()` 的值，它将像打开的文件句柄一样操作。请注意，我们需要在文本中添加一个换行符，这样它看起来就像来自实际文件的输入行。
- en: ④ Read the input (whether io.StringIO() or a file handle) line by line.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 逐行读取输入（无论是 `io.StringIO()` 还是文件句柄）。
- en: ⑤ Process the line as before.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 如前所述处理该行。
- en: 5.6 Going further
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.6 进一步
- en: Add a flag that will lowercase the input instead. Maybe call it `--ee` for the
    poet e e cummings, who liked to write poetry devoid of uppercase letters.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个标志，将输入转换为小写。也许可以将其命名为 `--ee`，以纪念诗人 e e cummings，他喜欢写没有大写字母的诗。
- en: Alter the program to handle multiple input files. Change `--outfile` to `--outdir`,
    and write each input file to the same filename in the output directory.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改程序以处理多个输入文件。将 `--outfile` 改为 `--outdir`，并将每个输入文件写入输出目录中的相同文件名。
- en: Summary
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: '|'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: To read or write files, you must first `open()` them.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要读取或写入文件，您必须首先 `open()` 它们。
- en: The default mode for `open()` is for reading a file.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`open()` 的默认模式是读取文件。'
- en: To write a text file, you must use `'wt'` as the second argument to `open()`.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要写入文本文件，您必须使用 `'wt'` 作为 `open()` 的第二个参数。
- en: Text is the default type of data that you `write()` to a file handle. You must
    use the `'b'` flag to indicate that you want to write binary data.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本是写入文件句柄的默认数据类型。您必须使用 `'b'` 标志来指示您想要写入二进制数据。
- en: The `os.path` module contains many useful functions, such as `os.path.isfile()`,
    that will tell you if a file exists with a given name.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`os.path` 模块包含许多有用的函数，例如 `os.path.isfile()`，它将告诉您是否存在具有给定名称的文件。'
- en: '`STDOUT` (standard output) is always available via the special `sys.stdout`
    file handle, which is always open.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STDOUT`（标准输出）始终可以通过特殊的 `sys.stdout` 文件句柄获得，该句柄始终处于打开状态。'
- en: The `print()` function takes an optional `file` argument specifying where to
    put the output. That argument must be an open file handle, such as `sys.stdout`
    (the default) or the result of `open()`.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print()` 函数接受一个可选的 `file` 参数，指定输出放置的位置。该参数必须是一个打开的文件句柄，例如 `sys.stdout`（默认）或
    `open()` 的结果。'
- en: '| ![](../Images/5-unnumb-8.png)  |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| ![图片](../Images/5-unnumb-8.png) |'
