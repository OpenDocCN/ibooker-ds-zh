- en: 4 Local differential privacy for machine learning
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 本地微分隐私在机器学习中的应用
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Local differential privacy (LDP)
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地微分隐私 (LDP)
- en: Implementing the randomized response mechanism for LDP
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 LDP 实现随机响应机制
- en: LDP mechanisms for one-dimensional data frequency estimation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于一维数据频率估计的 LDP 机制
- en: Implementing and experimenting with different LDP mechanisms for one-dimensional
    data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现和实验不同 LDP 机制以处理一维数据
- en: In the previous two chapters we discussed centralized differential privacy (DP),
    where there is a trusted data curator who collects data from individuals and applies
    different techniques to obtain differentially private statistics about the population.
    Then the curator publishes privacy-preserving statistics about this population.
    However, these techniques are unsuitable when individuals do not completely trust
    the data curator. Hence, various techniques to satisfy DP in the local setting
    have been studied to eliminate the need for a trusted data curator. In this chapter
    we will walk through the concept, mechanisms, and applications of the local version
    of DP, local differential privacy (LDP).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两章中，我们讨论了集中式微分隐私 (DP)，其中有一个可信的数据管理员从个人那里收集数据并应用不同的技术来获取关于人口的微分隐私统计量。然后，管理员发布关于这个人口的隐私保护统计信息。然而，当个人不完全信任数据管理员时，这些技术是不适用的。因此，为了在本地设置中满足
    DP 而消除对可信数据管理员的需求，已经研究了各种技术。在本章中，我们将介绍本地 DP 版本的原理、机制和应用，即本地微分隐私 (LDP)。
- en: This chapter will mainly look at how LDP can be implemented in ML algorithms
    by looking at different examples and implementation code. In the next chapter
    we’ll also walk you through a case study of applying LDP naive Bayes classification
    for real-world datasets.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将主要探讨如何通过查看不同的示例和实现代码来在机器学习算法中实现 LDP。在下一章中，我们还将向您介绍一个案例研究，展示如何将 LDP 应用到朴素贝叶斯分类以处理现实世界的数据集。
- en: '![CH04_00_UN01_Zhuang](../../OEBPS/Images/CH04_00_UN01_Zhuang.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_00_UN01_Zhuang](../../OEBPS/Images/CH04_00_UN01_Zhuang.png)'
- en: 4.1 What is local differential privacy?
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 什么是本地微分隐私？
- en: DP is a widely accepted standard for quantifying individual privacy. In the
    original definition of DP, there is a trusted data curator who collects data from
    individuals and applies techniques to obtain differentially private statistics.
    This data curator then publishes privacy-preserving statistics about the population.
    We looked at how to satisfy DP in the context of ML in chapters 2 and 3\. However,
    those techniques cannot be applied when individuals do not completely trust the
    data curator.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: DP 是一个广泛接受的用于量化个人隐私的标准。在 DP 的原始定义中，有一个可信的数据管理员从个人那里收集数据并应用技术来获取不同的隐私统计量。然后，该数据管理员发布关于人口的隐私保护统计信息。我们在第
    2 章和第 3 章中探讨了如何在机器学习的背景下满足 DP。然而，当个人不完全信任数据管理员时，这些技术不能应用。
- en: Different techniques have been proposed to ensure DP in the local setting without
    a trusted data curator. In LDP, individuals send their data to the data aggregator
    after privatizing the data by perturbation (see figure 4.1). These techniques
    provide plausible deniability for individuals. The data aggregator collects all
    the perturbed values and makes an estimation of the statistics, such as the frequency
    of each value in the population.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 已经提出了不同的技术来确保在本地设置中实现 DP 而无需可信的数据管理员。在 LDP 中，个人在通过扰动对数据进行隐私化处理后，将数据发送给数据聚合器（见图
    4.1）。这些技术为个人提供了合理的否认可能性。数据聚合器收集所有扰动值并对统计量进行估计，例如人口中每个值的频率。
- en: '![CH04_F01_Zhuang](../../OEBPS/Images/CH04_F01_Zhuang.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F01_Zhuang](../../OEBPS/Images/CH04_F01_Zhuang.png)'
- en: Figure 4.1 Centralized vs. local DP
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 集中式与本地 DP 对比
- en: 4.1.1 The concept of local differential privacy
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.1 本地微分隐私的概念
- en: Many real-world applications, including those from Google and Apple, have adopted
    LDP. Before we discuss the concept of LDP and how it works, let’s look at how
    it’s applied to real-world products.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 许多现实世界的应用，包括来自谷歌和苹果的应用，已经采用了 LDP。在我们讨论 LDP 的概念及其工作原理之前，让我们看看它是如何应用于现实世界产品的。
- en: How Google and Apple use LDP
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌和苹果如何使用 LDP
- en: In 2014 Google introduced Randomized Aggregatable Privacy-Preserving Ordinal
    Response (RAPPOR) [1], a technology for anonymously crowdsourcing statistics from
    end-user client software with strong privacy guarantees. This technology has lately
    been integrated with the Chrome web browser. Over the last five years, RAPPOR
    has processed up to billions of daily, randomized reports in a manner that guarantees
    LDP. The technology is designed to collect statistics on client-side values and
    strings over large numbers of clients, such as categories, frequencies, histograms,
    and other statistics. For any reported value, RAPPOR offers a strong deniability
    guarantee for the reporting client, which strictly limits the private information
    disclosed, as measured by DP, and it even holds for a single client that often
    reports on the same value.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 2014年，谷歌推出了随机可聚合的隐私保护序数响应（RAPPOR）[1]，这是一种从终端用户客户端软件匿名收集统计数据的技术，具有强大的隐私保障。这项技术最近已被集成到Chrome网络浏览器中。在过去五年中，RAPPOR以保证LDP的方式处理了数十亿个每日的随机报告。这项技术旨在收集大量客户端的客户端值和字符串的统计数据，例如类别、频率、直方图和其他统计数据。对于任何报告的值，RAPPOR为报告客户端提供强大的否认保证，严格限制由DP衡量的私人信息泄露，甚至对于经常报告同一值的单个客户端也是如此。
- en: 'In 2017 Apple also released a research paper on how it uses LDP to improve
    the user experience with their products by getting insight into what many of their
    users are doing. For example, what new words are trending and might make the most
    relevant suggestions? What websites have problems that could affect battery life?
    Which emojis are chosen most often? The DP technology used by Apple is rooted
    in the idea that slightly biased statistical noise can mask a user’s data before
    it is shared with Apple. If many people submit the same data, the noise added
    can average out over large numbers of data points, and Apple can see meaningful
    information emerge. Apple details two techniques for collecting data while protecting
    users’ privacy: the Count Mean Sketch and the Hadamard Count Mean Sketch. Both
    approaches insert random information into the data being collected. That random
    information effectively obfuscates any identifying aspects of the data so that
    it cannot be traced back to individuals.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 2017年，苹果也发布了一篇关于它是如何使用LDP通过了解许多用户的做法来改善其产品用户体验的研究论文。例如，哪些新词正在流行，可能会提供最相关的建议？哪些网站的问题可能会影响电池寿命？哪些表情符号被选择得最频繁？苹果使用的DP技术源于这样一个想法：轻微的统计噪声可以在与苹果共享之前掩盖用户数据。如果许多人提交相同的数据，添加的噪声可以在大量数据点上平均，苹果可以看到有意义的信息出现。苹果详细介绍了两种在保护用户隐私的同时收集数据的技术：计数均值草图和哈达玛德计数均值草图。这两种方法都将随机信息插入正在收集的数据中。这种随机信息有效地掩盖了数据的任何识别特征，因此无法追溯到个人。
- en: As you can see in these examples, LDP is usually being applied for mean or frequency
    estimation. Frequency estimation in a survey (or in survey-like problems) is one
    of the most common approaches to utilizing LDP in day-to-day applications. For
    instance, companies, organizations, and researchers often use surveys to analyze
    behavior or assess thoughts and opinions, but collecting information from individuals
    for research purposes is challenging due to privacy reasons. Individuals may not
    trust the data collector to not share sensitive or private information. And although
    an individual may participate in a survey anonymously, it can sometimes still
    be possible to identify the person by using the information provided. On the other
    hand, even though the people conducting the surveys are more interested in the
    distribution of the survey answers, rather than the information about specific
    individuals, it is quite difficult for them to earn the trust of survey participants
    when it comes to sensitive information. This is where LDP comes in.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在这些示例中所见，LDP通常用于均值或频率估计。在调查（或类似调查的问题）中进行频率估计是利用LDP在日常应用中最常见的方法之一。例如，公司、组织和研究人员经常使用调查来分析行为或评估思想和观点，但由于隐私原因，从个人那里收集研究信息具有挑战性。个人可能不相信数据收集者不会共享敏感或私人信息。尽管个人可以匿名参与调查，但有时仍然可以通过提供的信息识别出这个人。另一方面，尽管进行调查的人更感兴趣的是调查答案的分布，而不是特定个人的信息，但在涉及敏感信息时，他们很难赢得调查参与者的信任。这就是LDP发挥作用的地方。
- en: LDP in detail
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: LDP的详细说明
- en: Now that you have some background on how LDP is used, let’s look at the details.
    LDP is a way of measuring individual privacy when the data collector is not trusted.
    LDP aims to guarantee that when an individual provides a value, it should be challenging
    to identify the original value, which provides the privacy protection. Many LDP
    mechanisms also aim to estimate the distribution of the population as accurately
    as possible based on the aggregation of the perturbed data collected from all
    individuals.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对LDP的使用有了背景知识，让我们来看看细节。LDP是在数据收集者不可信时衡量个人隐私的一种方式。LDP旨在保证当个人提供值时，识别原始值应该具有挑战性，这提供了隐私保护。许多LDP机制还旨在尽可能准确地根据从所有个人收集到的扰动数据的聚合来估计人口分布。
- en: Figure 4.2 illustrates the typical use of LDP. First, each individual (data
    owner) generates or collects their own data, such as survey answers or personal
    data. Then, each individual perturbs their data locally using a specific LDP mechanism
    (which we’ll discuss in section 4.2). After conducting the perturbation, each
    individual sends their data to a data collector, who will perform the data aggregation
    and statistics or models estimation. Finally, the estimated statistics or models
    will be published. It would be extremely hard for adversaries to infer an individual’s
    data based on such published information (as guaranteed by the definition of LDP).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2说明了LDP的典型用法。首先，每个个人（数据所有者）生成或收集自己的数据，例如调查答案或个人数据。然后，每个个人使用特定的LDP机制（我们将在第4.2节中讨论）在本地扰动他们的数据。扰动后，每个个人将他们的数据发送给数据收集者，数据收集者将执行数据聚合和统计或模型估计。最后，估计的统计数据或模型将被发布。根据这样的发布信息推断个人的数据将极其困难（如LDP定义所保证的）。
- en: '![CH04_F02_Zhuang](../../OEBPS/Images/CH04_F02_Zhuang.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F02_Zhuang](../../OEBPS/Images/CH04_F02_Zhuang.png)'
- en: Figure 4.2 How local differential privacy works
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 展示了局部差分隐私的工作原理
- en: LDP states that for any published estimated statistics or models using an ϵ-LDP
    mechanism, the probability of distinguishing two input values (i.e., an individual’s
    data) by the data collector (or any other adversaries in the public domain) is
    at most *e*^(-ϵ).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: LDP表明，对于任何使用ϵ-LDP机制的发布估计统计数据或模型，数据收集者（或任何公共领域的其他对手）通过区分两个输入值（即个人的数据）的概率至多为 *e*^(-ϵ)。
- en: A protocol *P* satisfies ϵ-LDP if for any two input values *v[1]* and *v[2]*
    and any output *o* in the output space of *P*, we have
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 协议 *P* 满足 ϵ-LDP，如果对于任何两个输入值 *v[1]* 和 *v[2]* 以及 *P* 的输出空间中的任何输出 *o*，我们有
- en: '![CH04_F02_zhuang-ch4-eqs-0x](../../OEBPS/Images/CH04_F02_zhuang-ch4-eqs-0x.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F02_zhuang-ch4-eqs-0x](../../OEBPS/Images/CH04_F02_zhuang-ch4-eqs-0x.png)'
- en: where Pr[⋅] means probabilities. Pr[*P*(*v*[1]) = *o*] is the probability that
    given input *v*[1] to *P*, it outputs *o*. The ϵ parameter in the definition is
    the privacy parameter or the privacy budget. It helps to tune the amount of privacy
    the definition provides. Small values of ϵ require *P* to provide very similar
    outputs when given similar inputs and therefore provide higher levels of privacy;
    large values of ϵ allow less similarity in the outputs and therefore provide less
    privacy. For instance, as shown in figure 4.3, for a small value of ϵ, given a
    perturbed value *o*, it is (almost) equally likely that *o* resulted from any
    input value, that is, *v*[1] or *v*[2]. In this way, just by observing an output,
    it is hard to infer back to its corresponding input; hence, the privacy of the
    data is ensured.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 Pr[⋅] 表示概率。Pr[*P*(*v*[1]) = *o*] 是给定输入 *v*[1] 到 *P*，它输出 *o* 的概率。定义中的 ϵ 参数是隐私参数或隐私预算。它有助于调整定义提供的隐私量。小的
    ϵ 值要求 *P* 在给定相似输入时提供非常相似的输出，因此提供更高的隐私级别；大的 ϵ 值允许输出之间的相似性更少，因此提供更少的隐私。例如，如图4.3所示，对于小的
    ϵ 值，给定一个扰动值 *o*，它几乎同样可能是由任何输入值产生的，即在这个例子中的 *v*[1] 或 *v*[2]。通过这种方式，仅仅通过观察输出，就很难推断出其对应的输入；因此，数据隐私得到了保证。
- en: '![CH04_F03_Zhuang](../../OEBPS/Images/CH04_F03_Zhuang.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F03_Zhuang](../../OEBPS/Images/CH04_F03_Zhuang.png)'
- en: Figure 4.3 How ϵ-LDP works. Given a perturbed value *o*, it is (almost) equally
    likely that it resulted from any input value—either *v*[1] or *v*[2] in this example.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 展示了 ϵ-LDP 的工作原理。给定一个扰动值 *o*，它几乎同样可能是由任何输入值产生的——在这个例子中是 *v*[1] 或 *v*[2]。
- en: We have now discussed the concept and definition of LDP and looked at how it
    differs from centralized DP. Before we introduce any of the LDP mechanisms, let’s
    look at a scenario where we’ll apply LDP.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经讨论了LDP的概念和定义，并探讨了它与集中式DP的不同之处。在介绍任何LDP机制之前，让我们先看看一个我们将应用LDP的场景。
- en: An LDP scenario with a survey
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一个包含调查的LDP场景
- en: Answering questions in online surveys or social network quizzes via tools like
    SurveyMonkey is a widespread practice today. LDP can protect the answers of these
    surveys before they leave the data owners. Throughout this chapter, we will use
    the following scenario to demonstrate the design and implementation of LDP mechanisms.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通过像SurveyMonkey这样的工具在线调查或社交网络测验中回答问题，现在是一种普遍的做法。LDP可以在这些调查的答案离开数据所有者之前保护这些答案。在本章中，我们将使用以下场景来展示LDP机制的设计和实现。
- en: 'Let’s say company A wants to determine the distribution of its customers (for
    a targeted advertising campaign). It conducts a survey, and sample survey questions
    might look like these:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 假设公司A想要确定其客户（针对定向广告活动）的分布。它进行了一次调查，样本调查问题可能如下所示：
- en: Are you married?
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你已婚吗？
- en: What is your occupation?
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的职业是什么？
- en: How old are you?
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你多大了？
- en: What is your race category?
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的种族类别是什么？
- en: However, these questions are highly sensitive and private. To encourage its
    customers to participate in the survey, company A should provide privacy guarantees
    while still keeping the estimated distribution of its customers as accurate as
    possible when conducting the survey.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些问题非常敏感且私密。为了鼓励其客户参与调查，公司A应在进行调查的同时，尽可能保持其客户估计分布的准确性，并提供隐私保证。
- en: 'Not surprisingly, LDP is one technique that could help the company. There are
    several different LDP mechanisms that deal with different scenarios (i.e., data
    type, data dimensions, etc.). For instance, the answer to the question “Are you
    married?” is simply a categorical binary result: “yes” or “no.” A randomized response
    mechanism would be suitable to solve such scenarios. On the other hand, the answers
    to the questions “What is your occupation?” and “What is your race category?”
    are still categorical but would be single items from a set of possible answers.
    For such scenarios, direct encoding and unary encoding mechanisms would work better.
    Moreover, for questions like “What is your age?” the answer is numerical, and
    the summary of all the answers looks like a histogram. We can use histogram encoding
    in such cases.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 并不出奇，LDP是公司可以使用的几种技术之一。有几种不同的LDP机制可以处理不同的场景（例如，数据类型、数据维度等）。例如，对于“你已婚吗？”这个问题，答案只是一个分类的二进制结果：“是”或“否”。随机响应机制适合解决此类场景。另一方面，对于“你的职业是什么？”和“你的种族类别是什么？”这两个问题，答案仍然是分类的，但将是可能答案集合中的单个项目。对于此类场景，直接编码和一元编码机制会更好。此外，对于像“你多大了？”这样的问题，答案是数值的，所有答案的汇总看起来像直方图。在这种情况下，我们可以使用直方图编码。
- en: Given that simple outline of how LDP can be used in practice, we will introduce
    how LDP works in real-world scenarios by walking through how we could design and
    implement solutions that apply different LDP mechanisms for diverse survey questions.
    We will start with the most straightforward LDP mechanism, the randomized response.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在简单概述了LDP如何在实践中使用之后，我们将通过介绍如何设计和实现适用于不同调查问题的不同LDP机制来解决的实际场景来介绍LDP的工作原理。我们将从最直接的LDP机制——随机响应开始。
- en: 4.1.2 Randomized response for local differential privacy
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.2 随机响应用于本地差分隐私
- en: As discussed in chapter 2, randomized response (binary mechanism) is one of
    the oldest and simplest DP mechanisms, but it also satisfies LDP. In this section
    you will learn how to use the randomized response to design and implement an LDP
    solution for a privacy-preserving binary survey.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如第2章所述，随机响应（二进制机制）是最古老和最简单的DP机制之一，但它也满足LDP。在本节中，你将学习如何使用随机响应来设计和实现一个用于保护二进制调查隐私的LDP解决方案。
- en: Let’s assume we want to survey a group of people to determine the number of
    people more than 50 years old. Each individual will be asked, “Are you more than
    50 years old?” The answer collected from each individual will be either “yes”
    or “no.” The answer is considered a binary response to the survey question, where
    we give a binary value of 1 to each “yes” answer and a binary value of 0 to each
    “no” answer. Thus, the final goal is to determine the number of people who are
    more than 50 years old by counting the number of 1s sent by the individuals as
    their answers. How can we use the randomized response mechanism to design and
    implement a locally differentially private survey to gather the answers to this
    simple “yes” or “no” question?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要调查一组人，以确定50岁以上的人数。每个个体将被问及，“你超过50岁了吗？”从每个个体收集到的答案将是“是”或“否”。答案被视为对调查问题的二元响应，其中我们对每个“是”答案给出二元值1，对每个“否”答案给出二元值0。因此，最终目标是通过对个体发送的作为其答案的1的数量进行计数，来确定超过50岁的人数。我们如何使用随机响应机制来设计和实现一个局部差分隐私调查来收集这个简单的“是”或“否”问题的答案？
- en: Here comes the privacy protection. As shown in listing 4.1, each individual
    will either respond with the true answer or provide a randomized response according
    to the algorithm. Thus, the privacy of the individuals will be well protected.
    Also, since each individual will provide the actual answer with a probability
    of 0.75 (i.e., 1/2 + 1/4 = 0.75) and give the wrong answer with a probability
    of 0.25, more individuals will provide true answers. Therefore, we will retain
    enough essential information to estimate the distribution of the population’s
    statistics (i.e., the number of individuals more than 50 years old).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是隐私保护。如列表4.1所示，每个个体将根据算法以真实答案或提供随机答案进行响应。因此，个人的隐私将得到很好的保护。此外，由于每个个体将以0.75的概率（即1/2
    + 1/4 = 0.75）提供真实答案，以0.25的概率提供错误答案，因此将有更多个体提供真实答案。因此，我们将保留足够的基本信息来估计人口统计分布（即50岁以上的人数）。
- en: Listing 4.1 Randomized response-based algorithm
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.1 基于随机响应的算法
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Flip the first coin.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 抛掷第一枚硬币。
- en: ❷ Return the true answer.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 返回真实答案。
- en: ❸ Flip the second coin and return the randomized answer.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 抛掷第二枚硬币并返回随机答案。
- en: Let’s implement and test our algorithm on the US Census dataset as shown in
    listing 4.2\. In the next section, we will discuss more practical use cases, but
    for now we will use the census dataset to demonstrate how you can estimate the
    aggregated values.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在列表4.2中展示的美国人口普查数据集上实现并测试我们的算法。在下一节中，我们将讨论更多实际用例，但现在我们将使用人口普查数据集来演示您如何估计汇总值。
- en: Listing 4.2 Playing with the US Census dataset
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.2 玩转美国人口普查数据集
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The output will be as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As you can see, there are 32,561 individuals in the US Census dataset: 6,460
    individuals are more than 50 years old, and 26,101 individuals are younger than
    or equal to 50 years old.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，美国人口普查数据集中有32,561个个体：6,460个个体超过50岁，26,101个个体低于或等于50岁。
- en: Now let’s see what will happen if we apply our randomized response-based algorithm
    to the same application.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如果我们将我们的基于随机响应的算法应用于相同的应用程序会发生什么。
- en: Listing 4.3 Data perturbation
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.3 数据扰动
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The result will be as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, after applying our randomized response algorithm, the perturbed
    number of individuals more than 50 years old becomes 11,424, and the perturbed
    number of individuals younger than or equal to 50 years old is 21,137\. In this
    result, the number of people over 50 is still less than those below or equal to
    50, which is in line with the trend of the original dataset. However, this result,
    11,424, seems a bit away from the actual result that we want to estimate, 6,460.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，应用我们的随机响应算法后，50岁以上个体的扰动数量变为11,424，50岁以下或等于50岁的个体扰动数量为21,137。在这个结果中，50岁以上的人数仍然少于50岁以下或等于50岁的人数，这与原始数据集的趋势一致。然而，这个结果，11,424，似乎与我们想要估计的实际结果6,460有些差距。
- en: Now the question is how to estimate the actual number of people over 50 years
    old based on our randomized response-based algorithm and the results we’ve got
    so far. Apparently, directly using the number of 1 or “yes” values is not a precise
    estimation of the actual values.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是，如何根据我们的基于随机响应的算法和迄今为止的结果来估计50岁以上实际人数。显然，直接使用1或“是”的值并不能精确估计实际值。
- en: To precisely estimate the actual value of the number of people more than 50
    years old, we should consider the source of the randomness in our randomized response-based
    algorithm and estimate the number of 1s that are from the people who are actually
    older than 50 years, and the number of 1s that are from the randomized response
    results. In our algorithm, each individual will tell the truth with a probability
    of 0.5 and make a random response again with a probability of 0.5\. Each random
    response will result in a 1 or “yes” with a probability of 0.5\. Thus, the probability
    that an individual replies 1 or “yes” solely based on randomness (rather than
    because they are actually older than 50 years) is 0.5 × 0.5 = 0.25\. Therefore,
    as you can see, 25% of our total 1 or “yes” values are false yesses.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了精确估计50岁以上人数的实际值，我们应该考虑基于随机回答的算法中随机性的来源，并估计来自实际上50岁以上的人的1的数量，以及来自随机回答结果的1的数量。在我们的算法中，每个人以0.5的概率说实话，并以0.5的概率再次进行随机回答。每次随机回答将以0.5的概率产生1或“是”。因此，个人仅基于随机性（而不是因为他们实际上超过50岁）回答1或“是”的概率是0.5
    × 0.5 = 0.25。因此，正如你所见，我们总共有1或“是”值的25%是错误肯定回答。
- en: On the other hand, due to the first flip of the coin, we split the people who
    were telling the truth and those who were giving answers randomly. In other words,
    we can assume there are around the same number of people older than 50 in both
    groups. Therefore, the number of people over 50 years old is roughly twice the
    number of people over 50 years old in the group of people who were telling the
    truth.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，由于硬币的第一次翻转，我们将说实话的人和随机回答的人分开。换句话说，我们可以假设两组中50岁以上的人数大致相同。因此，50岁以上的人数大约是说实话的人组中50岁以上人数的两倍。
- en: Now that we know the problem, we can use the following implementation to estimate
    the total number of people over 50 years old.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了问题，我们可以使用以下实现来估计50岁以上总人数。
- en: Listing 4.4 Data aggregation and estimation
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.4 数据聚合和估计
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Perturbation
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 扰动
- en: ❷ Data aggregation and estimation
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 数据聚合和估计
- en: ❸ One-quarter (0.25) of the answers are expected to be 1s or yesses coming from
    the random answers (false yesses resulting from coin flips).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 预计有四分之一（0.25）的回答是1或肯定回答，这些来自随机回答（由抛硬币产生的错误肯定回答）。
- en: ❹ The total number of yesses received
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 收到的肯定回答总数
- en: ❺ The number of true yesses is the difference between the total number of yesses
    and the false yesses.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 真正的肯定回答数是总肯定回答数与错误肯定回答数之差。
- en: ❻ Because true yesses estimates the total number of yesses in the group that
    was telling the truth, the total number of yesses can be estimated as twice the
    true yesses.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 因为真正的肯定回答估计了说实话的组中肯定回答的总数，所以肯定回答的总数可以估计为真正肯定回答的两倍。
- en: 'You will get output like the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到以下输出：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now we have a much more precise estimation of the number of people over 50 years
    old. How close is the estimate? The relative error is just (6599 - 6460)/6460
    = 2.15%. Our randomized response-based algorithm seems to have done a good job
    of estimating the number of people over 50 years old. Also, based on our analysis
    in chapter 2, the privacy budget of this algorithm is *ln*(3) (i.e., *ln*(3) ≈
    1.099). In other words, our algorithm satisfies *ln*(3)-LDP.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对50岁以上人数的估计更加精确。估计有多接近？相对误差仅为（6599 - 6460）/ 6460 = 2.15%。我们的基于随机回答的算法似乎在估计50岁以上人数方面做得很好。此外，根据我们在第二章的分析，该算法的隐私预算是*ln*(3)（即*ln*(3)
    ≈ 1.099）。换句话说，我们的算法满足*ln*(3)-LDP。
- en: In this section we revisited the randomized response mechanism in the context
    of LDP by designing and implementing a privacy-preserving binary-question survey
    application. As you can see, the randomized response mechanism is only good at
    dealing with problems based on single binary questions, that is, “yes” or “no”
    questions.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们通过设计和实现一个隐私保护的二选一调查应用，回顾了在LDP背景下随机回答机制。正如你所见，随机回答机制仅擅长处理基于单个二进制问题的难题，即“是”或“否”问题。
- en: In practice, most questions or tasks are not simply “yes” or “no” questions.
    They can involve choosing from a finite set of values (such as “What is your occupation?”)
    or returning a histogram of a dataset (such as the distribution of the age of
    a group of people). We need more general and advanced mechanisms to tackle such
    problems. In the next section we will introduce more common LDP mechanisms that
    can be used in more widespread and complex situations.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，大多数问题或任务并非仅仅是“是”或“否”的问题。它们可能涉及从有限集合中选择值（例如“你的职业是什么？”）或返回数据集的直方图（例如一组人的年龄分布）。我们需要更通用和高级的机制来解决这类问题。在下一节中，我们将介绍更多常见的LDP机制，这些机制可以在更广泛和复杂的情况下使用。
- en: 4.2 The mechanisms of local differential privacy
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 本地差分隐私的机制
- en: We’ve discussed the concept and definition of LDP and how it works using the
    randomized response mechanism. In this section we’ll discuss some commonly utilized
    LDP mechanisms that work in more general and complex scenarios. These mechanisms
    will also serve as the building blocks for LDP ML algorithms in the next chapter’s
    case study.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了LDP的概念和定义，以及它是如何通过随机响应机制来工作的。在本节中，我们将讨论一些在更通用和复杂场景下常用的LDP机制。这些机制也将作为下一章案例研究中LDP机器学习算法的构建块。
- en: 4.2.1 Direct encoding
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.1 直接编码
- en: The randomized response mechanism works for binary (yes or no) questions with
    LDP. But how about questions that have more than just two answers? For instance,
    what if we want to determine the number of people with each occupation within
    the US Census dataset? The occupations could be sales, engineering, financial,
    technical support, etc. A decent number of different algorithms have been proposed
    for solving this problem in the local model of differential privacy [2], [3],
    [4]. Here we’ll start with one of the simplest mechanisms, called *direct encoding*.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 随机响应机制适用于具有LDP的二进制（是或否）问题。但对于有多个答案的问题怎么办？例如，如果我们想确定美国人口普查数据集中每个职业的人数，该怎么做？职业可能包括销售、工程、金融、技术支持等。已经提出了相当数量的不同算法来解决在本地差分隐私模型中的这个问题[2]，[3]，[4]。在这里，我们将从一个最简单的机制开始，称为*直接编码*。
- en: Given a problem where we need to utilize LDP, the first step is to define the
    domain of different answers. For example, if we want to learn how many people
    are in each occupation within the US Census dataset, the domain would be the set
    of professions available in the dataset. The following lists all the professions
    in the census dataset.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个需要利用LDP的问题中，第一步是定义不同答案的域。例如，如果我们想了解美国人口普查数据集中每个职业的人数，域将是数据集中可用的职业集合。以下列出了人口普查数据集中的所有职业。
- en: Listing 4.5 Number of people in each occupation domain
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.5 每个职业领域的数量
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Load data.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 加载数据。
- en: ❷ The domains
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 领域
- en: 'The result will look like the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As we discussed in the previous section, LDP mechanisms usually contain three
    functions: encoding, which encodes each answer; perturbation, which perturbs the
    encoded answers; and aggregation and estimation, which aggregates the perturbed
    answers and estimates the final results. Let’s define those three functions for
    the direct encoding mechanism.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在上一节所讨论的，LDP机制通常包含三个功能：编码，用于编码每个答案；扰动，用于扰动编码后的答案；以及聚合和估计，用于聚合扰动后的答案并估计最终结果。让我们为直接编码机制定义这三个功能。
- en: In the direct encoding mechanism, there is usually no encoding of input values.
    We can use each input’s index in the domain set as its encoded value. For example,
    “Armed-Forces” is the second element of the domain, so the encoded value of “Armed-Forces”
    is 1 (the index starts from 0).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在直接编码机制中，通常不需要对输入值进行编码。我们可以使用每个输入在域集中的索引作为其编码值。例如，“Armed-Forces”是域的第二个元素，因此“Armed-Forces”的编码值是1（索引从0开始）。
- en: Listing 4.6 Applying direct encoding
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.6 应用直接编码
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Test the encoding.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 测试编码。
- en: 'The output of the listing 4.6 will be as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.6的输出将如下所示：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As mentioned, “Armed-Forces” is assigned the value 1, “Craft-repair” is assigned
    the value 2, and so on.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，“Armed-Forces”被分配值为1，“Craft-repair”被分配值为2，依此类推。
- en: '![CH04_F04_Zhuang](../../OEBPS/Images/CH04_F04_Zhuang.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F04_Zhuang](../../OEBPS/Images/CH04_F04_Zhuang.png)'
- en: Figure 4.4 The perturbation of direct encoding
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 直接编码的扰动
- en: 'Our next step is the perturbation. Let’s review the perturbation of direct
    encoding (illustrated in figure 4.4). Each person reports their value *v* correctly
    with a probability of the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一步是扰动。让我们回顾直接编码的扰动（如图4.4所示）。每个人以以下概率正确报告他们的值 *v*：
- en: '![CH04_F04_zhuang-ch4-eqs-1x](../../OEBPS/Images/CH04_F04_zhuang-ch4-eqs-1x.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F04_zhuang-ch4-eqs-1x](../../OEBPS/Images/CH04_F04_zhuang-ch4-eqs-1x.png)'
- en: Or they report one of the remaining *d* - 1 values with a probability of
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 或者他们以 *d* - 1 个剩余值的概率报告其中一个
- en: '![CH04_F04_zhuang-ch4-eqs-2x](../../OEBPS/Images/CH04_F04_zhuang-ch4-eqs-2x.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F04_zhuang-ch4-eqs-2x](../../OEBPS/Images/CH04_F04_zhuang-ch4-eqs-2x.png)'
- en: where *d* is the size of the domain set.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *d* 是域集的大小。
- en: For instance, in our example, since there are 14 different professions listed
    in the US Census dataset, the size of the domain set is *d* = 14\. As shown in
    listing 4.7, if we choose ϵ = 5.0, we have *p* = 0.92 and *q* = 0.0062, which
    will output the actual value with a higher probability. If we choose ϵ = 0.1,
    we have *p* = 0.078 and *q* = 0.071, which will generate the actual value with
    a much lower probability, thus providing more privacy guarantees.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我们的例子中，由于美国人口普查数据集中列出了14种不同的职业，域集的大小是 *d* = 14。如列表4.7所示，如果我们选择 ϵ = 5.0，则
    *p* = 0.92 和 *q* = 0.0062，这将以更高的概率输出实际值。如果我们选择 ϵ = 0.1，则 *p* = 0.078 和 *q* = 0.071，这将以更低的概率生成实际值，从而提供更多的隐私保障。
- en: Listing 4.7 Perturbation algorithm in direct encoding
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.7 直接编码中的扰动算法
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Size of the domain set
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 域集的大小
- en: ❷ Return itself with probability p
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 以概率 p 返回自身
- en: ❸ Test the perturbation, epsilon = 5.0.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 测试扰动，epsilon = 5.0。
- en: ❹ Test the perturbation, epsilon = .1.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 测试扰动，epsilon = .1。
- en: 'The output will look like the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将看起来如下：
- en: '[PRE12]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Let’s try to understand what is happening here. When you assign the epsilon
    value to be 5.0 (look at the first four results in the output), you get the actual
    values with a much higher probability. In this case, the accuracy is 100%. However,
    when you assign epsilon to be a much smaller number (in this case 0.1), the algorithm
    will generate actual values with a much lower probability; hence, the privacy
    assurance is better. As can be seen from the latter four results in the output,
    we are getting different occupations as a result. You can play with assigning
    different epsilon values in the code to see how it affects the final results.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试理解这里发生了什么。当你将 epsilon 值设置为 5.0（查看输出中的前四个结果）时，你将以很高的概率得到实际值。在这种情况下，准确率为100%。然而，当你将
    epsilon 设置为一个更小的数字（在这种情况下为0.1）时，算法将以更低的概率生成实际值；因此，隐私保障更好。从输出中的后四个结果可以看出，我们得到了不同的职业作为结果。您可以在代码中尝试分配不同的
    epsilon 值，以查看它如何影响最终结果。
- en: Let’s see what would happen after applying the perturbation to the answers to
    the survey question, “What is your occupation?” as follows.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在将扰动应用于调查问题“你的职业是什么？”的答案后会发生什么。
- en: Listing 4.8 Results of direct encoding after perturbation
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.8 扰动后直接编码的结果
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The result after applying the direct encoding will look like this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 应用直接编码后的结果将看起来像这样：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now that we have the perturbed results, let’s compare them with the actual results.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了扰动结果，让我们将它们与实际结果进行比较。
- en: Listing 4.9 Comparison of actual results and perturbed values
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.9 实际结果与扰动值的比较
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ The number of people in each occupation category
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 每个职业类别的从业人员数量
- en: 'These are the actual results of the number of people in each occupation category:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是每个职业类别人数的实际结果：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: For clarity, let’s compare the results side by side, as shown in table 4.1\.
    As can be seen, some of the aggregations of the perturbed answers have very high
    errors compared to the actual values. For instance, for the number of people with
    the occupation “Armed-Forces,” the perturbed value is 157 but the true value is
    9.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，让我们将结果并排比较，如图4.1所示。可以看出，与实际值相比，一些扰动答案的聚合误差非常高。例如，对于职业为“Armed-Forces”的人数，扰动值为157，但实际值为9。
- en: Table 4.1 Number of people in each profession, before and after perturbation
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.1 扰动前后每个职业的人数
- en: '| Number | Profession | Number of people |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 数量 | 职业 | 人数 |'
- en: '| Original value | After perturbation |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 原始值 | 扰动后 |'
- en: '| 1 | Adm-clerical | 3770 | 3637 |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 1 | Adm-clerical | 3770 | 3637 |'
- en: '| 2 | Armed-Forces | 9 | 157 |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 2 | Armed-Forces | 9 | 157 |'
- en: '| 3 | Craft-repair | 4099 | 3911 |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 3 | Craft-repair | 4099 | 3911 |'
- en: '| 4 | Exec-managerial | 4066 | 3931 |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 4 | Exec-managerial | 4066 | 3931 |'
- en: '| 5 | Farming-fishing | 994 | 1106 |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 农业-渔业 | 994 | 1106 |'
- en: '| 6 | Handlers-cleaners | 1370 | 1419 |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 处理员-清洁工 | 1370 | 1419 |'
- en: '| 7 | Machine-op-inspct | 2002 | 2030 |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 机械操作检查员 | 2002 | 2030 |'
- en: '| 8 | Other-service | 3295 | 3259 |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 其他服务 | 3295 | 3259 |'
- en: '| 9 | Priv-house-serv | 149 | 285 |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 私人住宅服务 | 149 | 285 |'
- en: '| 10 | Prof-specialty | 4140 | 4011 |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 专业教授 | 4140 | 4011 |'
- en: '| 11 | Protective-serv | 649 | 741 |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 11 | 保护服务 | 649 | 741 |'
- en: '| 12 | Sales | 3650 | 3559 |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 12 | 销售 | 3650 | 3559 |'
- en: '| 13 | Tech-support | 928 | 1021 |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 13 | 技术支持 | 928 | 1021 |'
- en: '| 14 | Transport-moving | 1597 | 1651 |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 14 | 运输移动 | 1597 | 1651 |'
- en: 'To overcome such errors, we need to have an aggregation and estimation function
    along with the direct encoding mechanism. In the aggregation and estimation, when
    the aggregator collects the perturbed values from *n* individuals, it estimates
    the frequency of each occupation I ∈ {1,2,...,*d* } as follows: First, *c*[i]
    is the number of times *i* is reported. The estimated number of occurrences of
    value *i* in the population is computed as *E*[i] = (*c*[i] - *n* ⋅*q*)/(*p* -
    *q*). To ensure the estimated number is always a non-negative value, we set *E*[i]
    = max(*E*[i], 1). You can try implementing listing 4.10 to see how it works.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这些错误，我们需要一个聚合和估计函数，以及直接编码机制。在聚合和估计过程中，当聚合器从 *n* 个个体收集扰动值时，它将估计每个职业 I ∈ {1,2,...,*d*
    } 的频率如下：首先，*c*[i] 是 *i* 被报告的次数。在人口中值 *i* 的估计出现次数为 *E*[i] = (*c*[i] - *n* ⋅*q*)/(*p*
    - *q*)。为了确保估计的数值始终为非负值，我们设 *E*[i] = max(*E*[i], 1)。你可以尝试实现列表 4.10 来查看其工作原理。
- en: Listing 4.10 Applying aggregation and estimation to direct encoding
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.10 将聚合和估计应用于直接编码
- en: '[PRE17]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ Data aggregation and estimation
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 数据聚合和估计
- en: 'You will get something like the following as the output:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到以下类似的结果作为输出：
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: With that result, let’s compare the estimated results to the actual results
    as shown in table 4.2\. As you can see, the estimated results of the direct encoding
    mechanism are much more precise than the perturbed results when using the privacy
    budget *x* = 5.0\. You can try changing the privacy budget in this code or apply
    the code to other datasets to see how it works.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个结果，让我们将估计结果与表 4.2 中所示的实际结果进行比较。如图所示，当使用隐私预算 *x* = 5.0 时，直接编码机制的估计结果比使用扰动结果的精度要高得多。你可以尝试更改此代码中的隐私预算或将其应用于其他数据集以查看其工作情况。
- en: Table 4.2 Number of people in each profession, before and after aggregation
    and estimation
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.2 每个职业的人数，聚合和估计前后
- en: '| Number | Profession | Number of people |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 数量 | 职业 | 人数 |'
- en: '| Original value | After aggregation and estimation |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| 原始值 | 聚合和估计后 |'
- en: '| 1 | Adm-clerical | 3770 | 3774 |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 行政-文职 | 3770 | 3774 |'
- en: '| 2 | Armed-Forces | 9 | 1 |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 武装部队 | 9 | 1 |'
- en: '| 3 | Craft-repair | 4099 | 4074 |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 手工艺-修理 | 4099 | 4074 |'
- en: '| 4 | Exec-managerial | 4066 | 4095 |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 执行-管理 | 4066 | 4095 |'
- en: '| 5 | Farming-fishing | 994 | 1002 |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 农业-渔业 | 994 | 1002 |'
- en: '| 6 | Handlers-cleaners | 1370 | 1345 |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 处理员-清洁工 | 1370 | 1345 |'
- en: '| 7 | Machine-op-inspct | 2002 | 2014 |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 机械操作检查员 | 2002 | 2014 |'
- en: '| 8 | Other-service | 3295 | 3360 |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 其他服务 | 3295 | 3360 |'
- en: '| 9 | Priv-house-serv | 149 | 103 |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 私人住宅服务 | 149 | 103 |'
- en: '| 10 | Prof-specialty | 4140 | 4183 |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 专业教授 | 4140 | 4183 |'
- en: '| 11 | Protective-serv | 649 | 602 |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| 11 | 保护服务 | 649 | 602 |'
- en: '| 12 | Sales | 3650 | 3688 |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 12 | 销售 | 3650 | 3688 |'
- en: '| 13 | Tech-support | 928 | 909 |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 13 | 技术支持 | 928 | 909 |'
- en: '| 14 | Transport-moving | 1597 | 1599 |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 14 | 运输移动 | 1597 | 1599 |'
- en: 'You’ve now seen one LDP mechanism that uses direct encoding. Those steps can
    be summarized in the following three components:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经看到了一个使用直接编码的 LDP 机制。这些步骤可以总结为以下三个组件：
- en: 'Encoding: Direct encoding (generalization of binary randomized response)'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码：直接编码（二进制随机响应的推广）
- en: Perturbation: ![CH04_F04_zhuang-ch4-eqs-4x](../../OEBPS/Images/CH04_F04_zhuang-ch4-eqs-4x.png) for
    *ε*-LDP
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扰动：![CH04_F04_zhuang-ch4-eqs-4x](../../OEBPS/Images/CH04_F04_zhuang-ch4-eqs-4x.png)
    用于 *ε*-LDP
- en: Estimation: ![CH04_F04_zhuang-ch4-eqs-5x](../../OEBPS/Images/CH04_F04_zhuang-ch4-eqs-5x.png) where
    *q* = (1 - *p*)/(*>d* - 1)
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 估计：![CH04_F04_zhuang-ch4-eqs-5x](../../OEBPS/Images/CH04_F04_zhuang-ch4-eqs-5x.png)
    其中 *q* = (1 - *p*)/(*>d* - 1)
- en: 4.2.2 Histogram encoding
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.2 直方图编码
- en: The direct encoding mechanism enables us to apply LDP to categorical and discrete
    problems. In contrast, histogram encoding enables us to apply LDP to numerical
    and continuous data.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 直接编码机制使我们能够将 LDP 应用于分类和离散问题。相比之下，直方图编码使我们能够将 LDP 应用于数值和连续数据。
- en: 'Consider a survey question that has numerical and continuous answers. For example,
    suppose someone wants to know the distribution or histogram of people’s ages within
    a group of people, which we cannot achieve with direct encoding. They could conduct
    a survey to ask each individual a survey question: “What is your age?” Let’s take
    the US Census dataset as an example and plot the histogram of people’s ages.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个具有数值和连续答案的调查问题。例如，假设有人想知道一组人群中年龄的分布或直方图，而这无法通过直接编码实现。他们可以开展调查，询问每个人一个问题：“你的年龄是多少？”让我们以美国人口普查数据集为例，绘制人群年龄的直方图。
- en: Listing 4.11 Plotting a histogram with people’s ages
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.11 使用人群年龄绘制直方图
- en: '[PRE19]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Load data.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 加载数据。
- en: ❷ The ages of the people
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 人群的年龄
- en: The output will look like the histogram in figure 4.5, indicating the number
    of people in each age category. As you can see, the largest number of people are
    in the age ranges of ~20 to 40, whereas a lesser number of people are reported
    in the other values. The histogram-encoding mechanism is designed to deal with
    such numerical and continuous data.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将类似于图 4.5 中的直方图，表示每个年龄类别中的人数。正如您所看到的，最多的人数在 20 到 40 岁的年龄范围内，而在其他值中报告的人数较少。直方图编码机制旨在处理此类数值和连续数据。
- en: '![CH04_F05_Zhuang](../../OEBPS/Images/CH04_F05_Zhuang.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F05_Zhuang](../../OEBPS/Images/CH04_F05_Zhuang.png)'
- en: Figure 4.5 Histogram of people’s ages from US Census dataset
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 来自美国人口普查数据集的人群年龄直方图
- en: We first need to define the input domain (i.e., the survey answers). Here, we
    assume all the people taking the survey will be from 10 to 100 years old.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要定义输入域（即调查答案）。在这里，我们假设所有参加调查的人的年龄将在 10 到 100 岁之间。
- en: Listing 4.12 Input domain of the survey people’s ages
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.12 调查人群年龄的输入域
- en: '[PRE20]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ The domain is in the range of 10 to 100.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 域的范围在 10 到 100 之间。
- en: 'Therefore, the domain will look like this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，域将看起来像这样：
- en: '[PRE21]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In histogram encoding, an individual encodes their value *v* as a length-*d*
    vector [0.0,0.0,...,0.0,1.0,0.0,...,0.0] where only the *v*th component is 1.0
    and the remaining components are 0.0\. For example, suppose there are 6 values
    in total ({1,2,3,4,5,6}), that is, *d* = 6, and the actual value to be encoded
    is 6\. In that case, the histogram encoding will output the vector ({0.0,0.0,0.0,0.0,0.0,1.0}),
    where only the sixth position of the vector is 1.0 and all the other positions
    are 0.0 (see figure 4.6).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在直方图编码中，个人将他们的值 *v* 编码为一个长度-*d* 的向量 [0.0,0.0,...,0.0,1.0,0.0,...,0.0]，其中只有 *v*
    个分量是 1.0，其余分量是 0.0。例如，假设总共有 6 个值（{1,2,3,4,5,6}），即 *d* = 6，实际要编码的值是 6。在这种情况下，直方图编码将输出向量
    ({0.0,0.0,0.0,0.0,0.0,1.0})，其中向量的第六位是 1.0，其他所有位置都是 0.0（见图 4.6）。
- en: '![CH04_F06_Zhuang](../../OEBPS/Images/CH04_F06_Zhuang.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F06_Zhuang](../../OEBPS/Images/CH04_F06_Zhuang.png)'
- en: Figure 4.6 How histogram encoding works
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 直方图编码的工作原理
- en: The following listing shows the implementation of the encoding function.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表展示了编码函数的实现。
- en: Listing 4.13 Histogram encoding
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.13 直方图编码
- en: '[PRE22]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ Test the encoding for input age 11.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 测试输入年龄 11 的编码。
- en: ❷ Data encoding plot
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 数据编码图
- en: 'The output of listing 4.13 follows, and the histogram result is shown in figure
    4.7:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.13 的输出如下，直方图结果如图 4.7 所示：
- en: '[PRE23]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![CH04_F07_Zhuang](../../OEBPS/Images/CH04_F07_Zhuang.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F07_Zhuang](../../OEBPS/Images/CH04_F07_Zhuang.png)'
- en: Figure 4.7 Histogram of encoded ages
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 编码年龄的直方图
- en: The data owners perturb their value by adding *Lap*(2/ϵ) to each component in
    the encoded value, where *Lap*(2/ϵ) is a sample from the Laplace distribution
    with mean 0 and scale parameter 2/ϵ. If you need a refresher on the Laplace distribution
    and its properties, look back to section 2.1.2.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '数据所有者通过向编码值中的每个分量添加 *Lap*(2/ϵ) 来扰动他们的值，其中 *Lap*(2/ϵ) 是来自拉普拉斯分布的样本，均值为 0，尺度参数为
    2/ϵ。如果您需要复习拉普拉斯分布及其性质，请回顾第 2.1.2 节。 '
- en: 'When the data aggregator collects all the perturbed values, the aggregator
    has two options for estimation methods:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据聚合器收集所有扰动值后，聚合器有两种估计方法可供选择：
- en: Summation with histogram encoding (SHE)
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直方图编码求和（SHE）
- en: Thresholding with histogram encoding (THE)
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直方图编码阈值（THE）
- en: Summation with histogram encoding (SHE)
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图编码求和（SHE）
- en: Summation with histogram encoding (SHE) calculates the sum of all values reported
    by individuals. To estimate the number of occurrences of value *i* in the population,
    the data aggregator sums the *i*th component of all reported values.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图编码求和（SHE）计算个人报告的所有值的总和。为了估计人口中值 *i* 的发生次数，数据聚合器将所有报告值中的 *i* 个分量求和。
- en: The following listing shows the implementation of the perturbation using SHE.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了使用SHE进行扰动的实现。
- en: Listing 4.14 Summation with histogram encoding
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.14使用直方图编码的求和
- en: '[PRE24]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ Test the perturbation, epsilon = 5.0.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 测试扰动，ε = 5.0。
- en: ❷ Test the perturbation, epsilon = .1.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 测试扰动，ε = .1。
- en: ❸ Data perturbation, aggregation, and estimation
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 数据扰动、聚合和估计
- en: The output of listing 4.14 follows, and figure 4.8 shows a histogram of the
    results.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.14的输出如下，图4.8显示了结果的直方图。
- en: '[PRE25]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '![CH04_F08_Zhuang](../../OEBPS/Images/CH04_F08_Zhuang.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F08_Zhuang](../../OEBPS/Images/CH04_F08_Zhuang.png)'
- en: Figure 4.8 Summation of estimated ages using SHE
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8使用SHE估计年龄的求和
- en: As you can see from figure 4.8, estimated values using SHE have a shape similar
    to the original encoded histogram in figure 4.7\. However, the histogram in figure
    4.8 is generated using an estimation function. Those estimated values have noise
    in them, so they are not real, and they can result in negative values. A negative
    age frequency is invalid for this example, so we can discard those values.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 从图4.8中可以看出，使用SHE估计的值与图4.7中原始编码直方图的形状相似。然而，图4.8中的直方图是使用估计函数生成的。这些估计值中存在噪声，因此它们不是真实的，并且可能导致负值。对于这个例子，负年龄频率是无效的，因此我们可以丢弃这些值。
- en: Thresholding with histogram encoding (THE)
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 使用直方图编码的阈值处理（THE）
- en: In the case of thresholding with histogram encoding (THE), the data aggregator
    sets all values greater than a threshold *θ* to 1, and the remaining values to
    0\. Then it estimates the number of *i*s in the population as *E[i]* = (*c[i]*
    - *n* ⋅ *q*)/(*p* - *q*), where *p* = 1 − 1/2*e*^((ϵ⋅(1-θ)/2)), *q* = *e*^((ϵ⋅(0-θ)/2)),
    and *c[i]* is the number of 1s in the *i*th components of all reported values
    after applying thresholding.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用直方图编码（THE）进行阈值处理的情况下，数据聚合器将所有大于阈值θ的值设置为1，其余值设置为0。然后它估计人口中的*i*数量为*E[i]* =
    (*c[i]* - *n* ⋅ *q*)/(*p* - *q*)，其中*p* = 1 − 1/2*e*^((ϵ⋅(1-θ)/2))，*q* = *e*^((ϵ⋅(0-θ)/2))，而*c[i]*是应用阈值后所有报告值中第*i*个分量的1的数量。
- en: The following listing shows the implementation of the perturbation using THE.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了使用THE进行扰动的实现。
- en: Listing 4.15 Thresholding with histogram encoding
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.15使用直方图编码的阈值处理
- en: '[PRE26]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ Test the perturbation, epsilon = 5.0.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 测试扰动，ε = 5.0。
- en: ❷ Test the perturbation, epsilon = .1.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 测试扰动，ε = .1。
- en: ❸ Total perturbation
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 总扰动
- en: ❹ THE—aggregation and estimation
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ THE—聚合和估计
- en: The output will look like the following for different epsilon values. Figure
    4.9 shows the total perturbation before the THE estimation function.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不同的ε值，输出将如下所示。图4.9显示了THE估计函数前的总扰动。
- en: '[PRE27]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '![CH04_F09_Zhuang](../../OEBPS/Images/CH04_F09_Zhuang.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F09_Zhuang](../../OEBPS/Images/CH04_F09_Zhuang.png)'
- en: Figure 4.9 Histogram of perturbed answers using THE
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9使用THE扰动答案的直方图
- en: 'The estimated values can be obtained as shown in the following code snippet:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 估计值可以通过以下代码片段获得：
- en: '[PRE28]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The output histogram is shown in figure 4.10\. The estimated values of THE follow
    a shape similar to the original encoded histogram in figure 4.7.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的直方图显示在图4.10中。THE的估计值与图4.7中原始编码直方图的形状相似。
- en: '![CH04_F10_Zhuang](../../OEBPS/Images/CH04_F10_Zhuang.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F10_Zhuang](../../OEBPS/Images/CH04_F10_Zhuang.png)'
- en: Figure 4.10 Thresholding estimated ages
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.10阈值估计年龄
- en: 'In summary, histogram encoding enables us to apply LDP for numerical and continuous
    data, and we discussed two estimation mechanisms for LDP under histogram encoding:
    SHE and THE. SHE sums up the reported noisy histograms from all users, whereas
    THE interprets each noisy count above a threshold as 1 and each count below the
    threshold as 0\. When you compare histogram encoding with direct encoding, you’ll
    realize that direct encoding has a more significant variance when the size of
    the domain set *d* becomes larger. With THE, by fixing ε, you can choose a θ value
    to minimize the variance. This means THE can improve the estimation over SHE because
    thresholding limits the effects of large amounts of noise:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，直方图编码使我们能够对数值和连续数据应用LDP，我们讨论了在直方图编码下的LDP的两个估计机制：SHE和THE。SHE汇总了所有用户报告的噪声直方图，而THE将阈值以上的每个噪声计数解释为1，阈值以下的每个计数解释为0。当你将直方图编码与直接编码进行比较时，你会发现当域集大小*d*变大时，直接编码的方差更大。使用THE，通过固定ε，你可以选择一个θ值以最小化方差。这意味着THE可以通过限制大量噪声的影响来提高SHE的估计：
- en: 'Summation with histogram encoding (SHE):'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用直方图编码的求和（SHE）：
- en: 'Encoding: Encode(*v*) = [0.0, 0.0,...,1.0,...,0.0] where only the *v*th component
    is 1.0.'
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码：Encode(*v*) = [0.0, 0.0,...,1.0,...,0.0]，其中只有 *v* 个分量是 1.0。
- en: 'Perturbation: Add *Lap*(2/ε) to each component.'
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扰动：将 *Lap*(2/ε) 添加到每个分量。
- en: 'Estimation: Sums up the reported noisy histograms from all individuals.'
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 估计：将所有个人报告的噪声直方图的总和。
- en: 'Thresholding with histogram encoding (THE):'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 历史编码阈值（THE）：
- en: 'Encoding: Encode(*v*) = [0.0, 0.0,...,1.0,...,0.0] where only the *v* th component
    is 1.0.'
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码：Encode(*v*) = [0.0, 0.0,...,1.0,...,0.0]，其中只有 *v* 个分量是 1.0。
- en: 'Perturbation: Add *Lap*(2/ε) to each component. Set the values > θ to 1, and
    the remaining values to 0.'
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扰动：将 *Lap*(2/ε) 添加到每个分量。将值 > θ 设置为 1，其余值设置为 0。
- en: Estimation: ![CH04_F04_zhuang-ch4-eqs-5x](../../OEBPS/Images/CH04_F04_zhuang-ch4-eqs-5x.png) where ![CH04_F10_zhuang-ch4-eqs-12x](../../OEBPS/Images/CH04_F10_zhuang-ch4-eqs-12x.png) and ![CH04_F10_zhuang-ch4-eqs-13x](../../OEBPS/Images/CH04_F10_zhuang-ch4-eqs-13x.png).
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 估计：![CH04_F04_zhuang-ch4-eqs-5x](../../OEBPS/Images/CH04_F04_zhuang-ch4-eqs-5x.png)，其中
    ![CH04_F10_zhuang-ch4-eqs-12x](../../OEBPS/Images/CH04_F10_zhuang-ch4-eqs-12x.png)
    和 ![CH04_F10_zhuang-ch4-eqs-13x](../../OEBPS/Images/CH04_F10_zhuang-ch4-eqs-13x.png)。
- en: 4.2.3 Unary encoding
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.3 一元编码
- en: The unary encoding mechanism is a more general and efficient LDP mechanism for
    categorical and discrete problems. In this method, an individual encodes their
    value *v* as a length-*d* binary vector [0, ..., 1, ..., 0] where only the *v*
    th bit is 1 and the remaining bits are 0\. Then, for each bit in the encoded vector,
    they report the value correctly with probability *p* and incorrectly with probability
    1 - *p* if the input bit is 1\. Otherwise, they can report correctly with probability
    1 - *q* and incorrectly with probability *q*.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 一元编码机制是一种更通用且高效的 LDP 机制，适用于分类和离散问题。在此方法中，个人将他们的值 *v* 编码为一个长度-*d* 的二进制向量 [0,
    ..., 1, ..., 0]，其中只有 *v* 位是 1，其余位是 0。然后，对于编码向量中的每个位，如果输入位是 1，他们将以概率 *p* 正确报告值，以概率
    1 - *p* 错误报告。否则，他们可以以概率 1 - *q* 正确报告，以概率 *q* 错误报告。
- en: 'In unary encoding, we again have two different options to proceed with:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在一元编码中，我们再次有两个不同的选项进行操作：
- en: Symmetric unary encoding (SUE)
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对称一元编码（SUE）
- en: Optimal unary encoding (OUE)
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最优一元编码（OUE）
- en: In the case of symmetric unary encoding, *p* is selected as ![CH04_F10_zhuang-ch4-eqs-14x](../../OEBPS/Images/CH04_F10_zhuang-ch4-eqs-14x.png) and
    *q* is selected as 1 - *p*. In optimal unary encoding, *p* is selected as 1/2
    and *q* is selected as 1/(*e*^ε + 1). Then the data aggregator estimates the number
    of 1s in the population as *E*[i] = (*c*[i] - *m* ∙ *q*)/(*p* - q), where *c*[i]
    denotes the number of 1s in the *i*^(th) bit of all reported values.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在对称一元编码的情况下，*p* 被选为 ![CH04_F10_zhuang-ch4-eqs-14x](../../OEBPS/Images/CH04_F10_zhuang-ch4-eqs-14x.png)，而
    *q* 被选为 1 - *p*。在最优一元编码中，*p* 被选为 1/2，而 *q* 被选为 1/(e^ε + 1)。然后数据聚合器估计人口中 1 的数量为
    *E*[i] = (*c*[i] - *m* ∙ *q*)/(*p* - q)，其中 *c*[i] 表示所有报告值中第 *i* 位的 1 的数量。
- en: As an example of the unary encoding mechanism, suppose someone wants to determine
    how many people there are of different races. They would need to ask each individual
    the question, “What is your race?” Let’s try to implement SUE on the US Census
    dataset. The OUE implementation would be an extension of the SUE implementation,
    with changes to the definitions of *p* and *q* in the implementation. (You can
    also refer to the sample implementation of OUE in our code repository.)
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一元编码机制的示例，假设有人想确定不同种族的人数。他们需要询问每个人，“你的种族是什么？”让我们尝试在 US Census 数据集上实现 SUE。OUE
    的实现将是 SUE 实现的扩展，需要对实现中 *p* 和 *q* 的定义进行更改。（您也可以参考我们代码仓库中的 OUE 示例实现。）
- en: First, let’s load the data and check the domains.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们加载数据并检查领域。
- en: Listing 4.16 Retrieving different race categories in the dataset
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.16 在数据集中检索不同的种族类别
- en: '[PRE29]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ❶ Load the data.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 加载数据。
- en: ❷ The domains
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 领域
- en: The output of listing 4.16 will look like the following
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.16 的输出将如下所示
- en: '[PRE30]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you can see, there are five different races in the dataset.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，数据集中有五种不同的种族。
- en: Now let’s look at the actual numbers of people of different races in the US
    Census dataset.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看美国人口普查数据集中不同种族的实际人数。
- en: Listing 4.17 Number of people of each race
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.17 每个种族的人数
- en: '[PRE31]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here is the output with the actual numbers in the dataset:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是数据集中实际数字的输出：
- en: '[PRE32]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can see, we have 311 people in the category of “Amer-Indian-Eskimo,”
    1,039 people in “Asian-Pac-Islander,” and so on.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们类别“美洲印第安人-爱斯基摩人”中有 311 人，类别“亚洲-太平洋岛民”中有 1,039 人，等等。
- en: Now let’s look into the implementation of the SUE mechanism.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 SUE 机制的实现。
- en: Listing 4.18 Symmetric unary encoding
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.18 对称单值编码
- en: '[PRE33]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: ❶ Test the encoding.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 测试编码。
- en: 'You should get an output similar to the following:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到以下类似的输出：
- en: '[PRE34]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As we discussed at the beginning of this section, the idea is that each individual
    encodes their value *v* as a length-*d* binary vector [0,....,1,...,0] where only
    the *v* th bit is 1 and the remaining bits are 0.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本节开头讨论的那样，想法是每个个体将他们的值*v*编码为一个长度*d*的二进制向量[0,...,1,...,0]，其中只有*v*位是1，其余位是0。
- en: The following listing shows how you could implement the perturbation of the
    SUE mechanism. It is mostly self-explanatory.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了如何实现SUE机制的扰动。它主要是一目了然的。
- en: Listing 4.19 Perturbation of the symmetric unary encoding
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.19 对称单值编码的扰动
- en: '[PRE35]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: ❶ Symmetric unary encoding—perturbation
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 对称单值编码—扰动
- en: ❷ Test the perturbation, epsilon = 5.0.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 测试扰动，epsilon = 5.0。
- en: ❸ Test the perturbation, epsilon = .1.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 测试扰动，epsilon = .1。
- en: 'The output of listing 4.19 will look like the following:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.19的输出将如下所示：
- en: '[PRE36]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This shows two sets of vectors, similar to what we had in earlier mechanisms.
    The first set is with epsilon assigned 5.0, and the other is with epsilon assigned
    0.1.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了两组向量，类似于我们在早期机制中拥有的。第一组是epsilon分配为5.0，另一组是epsilon分配为0.1。
- en: 'Now we can test it to see the perturbed answers:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以测试它以查看扰动的答案：
- en: '[PRE37]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You will have results similar to these:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到类似的结果：
- en: '[PRE38]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Remember, these are only the values after the perturbation. We are not done
    yet!
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这些只是扰动后的值。我们还没有完成！
- en: Next comes the aggregation and estimation of the SUE mechanism.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是SUE机制的聚合和估计。
- en: Listing 4.20 Estimation of the symmetric unary encoding
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.20 对称单值编码的估计
- en: '[PRE39]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: ❶ Symmetric unary encoding—aggregation and estimation
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 对称单值编码—聚合和估计
- en: ❷ Data aggregation and estimation
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 数据聚合和估计
- en: 'The final values of the estimation will look like these:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 估计的最终值将如下所示：
- en: '[PRE40]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now you know how SUE works. Let’s compare the actual and estimated values side
    by side to see what the difference looks like. If you pay close attention to table
    4.3, you will understand that SUE works better with this kind of categorical data.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了SUE是如何工作的。让我们将实际值和估计值并排比较，看看差异是什么样子。如果你仔细查看表4.3，你会理解SUE在这种类型的分类数据上工作得更好。
- en: Table 4.3 Number of people in each race, before and after applying SUE
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.3 在应用SUE之前和之后每个种族的人数
- en: '| Number | Race | Number of people |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| 数字 | 种族 | 人数 |'
- en: '| Original value | After applying SUE |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| 原始值 | 应用SUE后 |'
- en: '| 1 | Amer-Indian-Eskimo | 311 | 215 |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 美洲印第安人-爱斯基摩人 | 311 | 215 |'
- en: '| 2 | Asian-Pac-Islander | 1039 | 1082 |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 亚洲-太平洋岛民 | 1039 | 1082 |'
- en: '| 3 | Black | 3124 | 3180 |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 黑人 | 3124 | 3180 |'
- en: '| 4 | Other | 271 | 196 |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 其他 | 271 | 196 |'
- en: '| 5 | White | 27816 | 27791 |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 白人 | 27816 | 27791 |'
- en: 'In this section we introduced two LDP mechanisms with unary encoding:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了两种具有单值编码的LDP机制：
- en: 'Symmetric unary encoding (SUE):'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对称单值编码（SUE）：
- en: 'Encoding: Encode(*v*) = [0, 0, ..., 1, ..., 0] where only the *v*th bit is
    1.'
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码：Encode(*v*) = [0, 0, ..., 1, ..., 0]，其中只有*v*位是1。
- en: 'Perturbation: Each bit is perturbed as in the binary randomized response mechanism. ![CH04_F10_zhuang-ch4-eqs-17x](../../OEBPS/Images/CH04_F10_zhuang-ch4-eqs-17x.png) for
    ε-LDP.'
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扰动：每个位都像在二元随机响应机制中那样扰动。![CH04_F10_zhuang-ch4-eqs-17x](../../OEBPS/Images/CH04_F10_zhuang-ch4-eqs-17x.png)对于ε-LDP。
- en: 'Estimation: For each value, use the estimation formula in the binary randomized
    response mechanism.'
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 估计：对于每个值，使用二元随机响应机制中的估计公式。
- en: 'Optimized unary encoding (OUE):'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化的单值编码（OUE）：
- en: 'Encoding: Encode(*v*) = [0, 0, ..., 1, ..., 0] where only the *v*th bit is
    1.'
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码：Encode(*v*) = [0, 0, ..., 1, ..., 0]，其中只有*v*位是1。
- en: 'Perturbation: *p* = 1/2, *q* = 1/(*e*^ε + 1) (as shown in figure 4.11).'
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扰动：*p* = 1/2，*q* = 1/(*e*^ε + 1)（如图4.11所示）。
- en: Estimation: ![CH04_F04_zhuang-ch4-eqs-5x](../../OEBPS/Images/CH04_F04_zhuang-ch4-eqs-5x.png).
  id: totrans-311
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 估计：![CH04_F04_zhuang-ch4-eqs-5x](../../OEBPS/Images/CH04_F04_zhuang-ch4-eqs-5x.png)。
- en: '![CH04_F11_Zhuang](../../OEBPS/Images/CH04_F11_Zhuang.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F11_Zhuang](../../OEBPS/Images/CH04_F11_Zhuang.png)'
- en: Figure 4.11 The perturbation of optimized unary encoding
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11 优化单值编码的扰动
- en: This chapter mainly focused on how different LDP mechanisms work, particularly
    for one-dimensional data. In chapter 5, we will extend our discussion and look
    at how we can work with multidimensional data using more advanced mechanisms.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要关注不同LDP机制的工作方式，特别是对于一维数据。在第5章中，我们将扩展我们的讨论，看看我们如何使用更高级的机制来处理多维数据。
- en: Summary
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Unlike centralized DP, LDP eliminates the need for a trusted data curator; thus,
    individuals can send their data to the data aggregator after privatizing it using
    perturbation techniques.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与集中式 DP 不同，LDP 消除了对可信数据管理者的需求；因此，个人可以在使用扰动技术对数据进行隐私化处理后，将其发送给数据聚合器。
- en: In many practical use cases, LDP is applied for mean or frequency estimation.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在许多实际应用场景中，LDP 用于均值或频率估计。
- en: The randomized response mechanism can also be used with LDP through the design
    and implementation of privacy-preserving algorithms.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机响应机制也可以通过设计和实现隐私保护算法与 LDP 结合使用。
- en: While direct encoding helps us apply LDP for categorical and discreet data,
    histogram encoding can be used to apply LDP for numerical and continuous variables.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然直接编码有助于我们为分类和离散数据应用 LDP，但直方图编码可以用于应用 LDP 到数值和连续变量。
- en: 'When the data aggregator collects the perturbed values, the aggregator has
    two options for estimation methods: summation with histogram encoding (SHE) and
    thresholding with histogram encoding (THE).'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当数据聚合器收集扰动值时，聚合器有两种估计方法可供选择：使用直方图编码（SHE）的求和和阈值处理（THE）。
- en: Summation with histogram encoding (SHE) calculates the sum of all values reported
    by individuals.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用直方图编码（SHE）的求和计算个人报告的所有值的总和。
- en: In the case of thresholding with histogram encoding (THE), the data aggregator
    sets all values greater than a threshold *θ* to 1, and the remaining values to
    0.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用直方图编码（THE）进行阈值处理的情况下，数据聚合器将所有大于阈值 *θ* 的值设置为 1，其余的值设置为 0。
- en: The unary encoding mechanism is a more general and efficient LDP mechanism for
    categorical and discrete problems.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单值编码机制是一种更通用且高效的 LDP 机制，适用于分类和离散问题。
