- en: 9 Readability
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 可读性
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Naming conventions for unit tests
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试的命名规范
- en: Writing readable tests
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写可读的测试
- en: Without readability, the tests you write are almost meaningless to whoever reads
    them later on. Readability is the connecting thread between the person who wrote
    the test and the poor soul who must read it a few months or years later. Tests
    are stories you tell the next generation of programmers on a project. They allow
    a developer to see exactly what an application is made of and where it started.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 没有可读性，你编写的测试对后来阅读它们的人来说几乎毫无意义。可读性是编写测试的人和几个月或几年后必须阅读它的可怜人之间的联系纽带。测试是你向项目的下一代程序员讲述的故事。它们允许开发者确切地看到应用程序由什么组成以及它从哪里开始。
- en: This chapter is all about making sure the developers who come after you will
    be able to maintain the production code and the tests that you write. They’ll
    need to understand what they’re doing and where they should be doing it.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这章主要确保在你之后的开发者能够维护你编写的生产代码和测试。他们需要理解他们在做什么以及他们应该在何处做。
- en: 'There are several facets to readability:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性有几个方面：
- en: Naming unit tests
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名单元测试
- en: Naming variables
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名变量
- en: Separating asserts from actions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将断言与操作分离
- en: Setting up and tearing down
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置和拆除
- en: Let’s go through these one by one.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一分析。
- en: 9.1 Naming unit tests
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1 命名单元测试
- en: 'Naming standards are important because they give you comfortable rules and
    templates that outline what you should explain about the test. No matter how I
    order them, or what specific framework or language I am using, I try to make sure
    these three important pieces of information are present in the name of the test
    or in the structure of the file in which the test exists:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 命名标准很重要，因为它们为你提供了舒适的规则和模板，概述了你应该解释关于测试的内容。无论我如何排序，或者我使用什么特定的框架或语言，我都试图确保这三个重要的信息点存在于测试的名称中或在测试存在的文件结构中：
- en: The entry point to the unit of work (or the name of the feature being tested)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单位工作入口点（或正在测试的功能的名称）
- en: The scenario under which you’re testing the entry point
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试入口点的测试场景
- en: The expected behavior of the exit point of the unit of work
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单位工作出口点的预期行为
- en: The name of the entry point (or unit of work) is essential, so that you can
    easily understand the starting scope of the logic being tested. Having this as
    the first part of the test name also allows for easy navigation and as-you-type
    completion (if your IDE supports it) in the test file.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 入口点（或工作单元）的名称至关重要，这样你可以轻松理解正在测试的逻辑的起始范围。将此作为测试名称的第一部分也允许在测试文件中进行轻松导航和即写即完成的操作（如果您的IDE支持的话）。
- en: 'The scenario under which it’s being tested gives you the “with” part of the
    name: “When I call entry point X *with* a null value, then it should do Y.”'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的场景给出了名称的“with”部分：“当我调用入口点X *with*一个null值时，它应该执行Y。”
- en: 'The expected behavior from the exit point of the unit of work is where the
    test specifies in plain English what the unit of work should do or return, or
    how it should behave, based on the current scenario: “When I call entry point
    X with a null value, then *it should* do Y as visible from this exit point of
    the unit of work.”'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 单位工作出口点的预期行为是测试在平实的英语中指定单位工作应该做什么或返回什么，或者根据当前场景它应该如何表现：“当我调用入口点X *with*一个null值时，它应该从这个单位工作的出口点可见地执行Y。”
- en: These three elements have to exist somewhere close to the eyes of the person
    reading the test. Sometimes they can all be encapsulated in the test’s function
    name, and sometimes you can include them with nested `describe` structures. Sometimes
    you can simply use a string description as a parameter or annotation for the test.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个元素必须位于阅读测试的人的视线附近。有时它们都可以封装在测试函数的名称中，有时你可以通过嵌套的`describe`结构来包含它们。有时你可以简单地使用字符串描述作为参数或注释来表示测试。
- en: Some examples are shown in the following listing, all with the same pieces of
    information, but laid out differently.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列出了一些示例，所有示例都包含相同的信息，但布局不同。
- en: Listing 9.1 Same information, different variations
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.1 相同的信息，不同的变体
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can, of course, come up with other ways to structure this. (Who says you
    have to use underscores? That’s just my own preference for reminding me and others
    that there are three pieces of information.). The key point to take away is that
    if you remove one of these pieces of information, you’re forcing the person reading
    the test to read the code inside the test to find out the answer, wasting precious
    time.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你当然可以想出其他方法来组织这个结构。（谁说一定要用下划线？那只是我用来提醒自己和别人有三个方面信息的个人偏好。）需要记住的关键点是，如果你移除这些信息中的一个，你就是在迫使阅读测试的人阅读测试内部的代码来找出答案，浪费宝贵的时间。
- en: The following listing shows examples of tests with missing information.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表展示了缺少信息的测试示例。
- en: Listing 9.2 Test names with missing information
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.2 缺少信息的测试名称
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ What is the thing under test?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 要测试的是什么？
- en: ❷ When is this supposed to happen?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 这应该在什么时候发生？
- en: ❸ What’s supposed to happen then?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 那接下来会发生什么？
- en: Your main goal with readability is to release the next developer from the burden
    of reading the test code in order to understand what the test is testing.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你在可读性方面的主要目标是让下一个开发者从阅读测试代码的负担中解脱出来，以便理解测试在测试什么。
- en: Another great reason to include all these pieces of information in the name
    of the test is that the name is usually the only thing that shows up when an automated
    build pipeline fails. You’ll see the names of the failed tests in the log of the
    build that failed, but you won’t see any comments or the code of the tests. If
    the names are good enough, you might not need to read the code of the tests or
    debug them; you may understand the cause of the failure simply by reading the
    log of the failed build. This can save precious debugging and reading time.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些信息包含在测试名称中的另一个很好的理由是，名称通常是自动化构建管道失败时唯一出现的东西。你会在构建失败的日志中看到失败的测试名称，但你看不到任何注释或测试代码。如果名称足够好，你可能不需要阅读测试代码或调试它们；你只需阅读失败的构建日志，就可能理解失败的原因。这可以节省宝贵的调试和阅读时间。
- en: A good test name also serves to contribute to the idea of executable documentation—if
    you can ask a developer who is new to the team to read the tests so they can understand
    how a specific component or application works, that’s a good sign of readability.
    If they can’t make sense of the application or the component’s behavior from the
    tests alone, it might be a red flag for readability.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的测试名称也有助于可执行文档的概念——如果你可以让一个刚加入团队的开发者阅读测试，以便他们可以理解特定组件或应用程序的工作方式，那么这是一个可读性的好迹象。如果仅从测试中无法理解应用程序或组件的行为，那么这可能是可读性的一个红旗。
- en: 9.2 Magic values and naming variables
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2 魔法值和变量命名
- en: Have you heard the term “magic values”? It sounds awesome, but it’s the opposite
    of that. It should really be “witchcraft values” to convey the negative effects
    of using them. What are they, you ask? They are hardcoded, undocumented, or poorly
    understood constants or variables. The reference to magic indicates that these
    values work, but you have no idea why.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你听说过“魔法值”这个术语吗？听起来很酷，但它恰恰相反。它应该真正被称为“巫术值”，以传达使用它们的负面影响。它们是什么？它们是硬编码的、未记录的或理解不佳的常量或变量。魔法一词的引用表明这些值是有效的，但你不知道为什么。
- en: Consider the following test.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下测试。
- en: Listing 9.3 A test with magic values
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.3 包含魔法值的测试
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Magic values
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 魔法值
- en: 'This test contains three magic values. Can a person who didn’t write the test
    and doesn''t know the API being tested easily understand what the `0` value means?
    How about the `[]` array? The first parameter to that function kind of looks like
    a password, but even that has a magical quality to it. Let’s discuss:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试包含三个魔法值。一个没有编写测试且不了解被测试 API 的人能轻易理解 `0` 值的含义吗？`[]` 数组呢？那个函数的第一个参数看起来有点像密码，但甚至这一点也有一种神奇的感觉。让我们来讨论一下：
- en: The `0` could mean so many things. As the reader, I might have to search around
    in the code, or jump into the signature of the called function, to understand
    that this specifies the day of the week.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0` 可能意味着很多事。作为读者，我可能需要在代码中四处搜索，或者跳到被调用函数的签名中，才能理解这指定的是星期几。'
- en: The `[]` forces me to look at the signature of the called function to understand
    that the function expects a password verification rule array, which means the
    test verifies the case with no rules.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[]` 强迫我查看被调用函数的签名，以理解该函数期望一个密码验证规则数组，这意味着测试验证的是没有规则的用例。'
- en: '`jhGGu78!` seems to be an obvious password value, but the big question I’ll
    have as a reader is, why this specific value? What’s important about this specific
    password? It’s obviously important to use this value and not any other for this
    test, because it seems so damned specific. In reality it isn’t, but the reader
    won’t know this. They’ll likely end up using this password in other tests just
    to be safe. Magic values tend to propagate themselves in tests.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jhGGu78!`看起来是一个明显的密码值，但作为一个读者，我会有的一个大问题是，为什么是这个特定的值？这个特定密码值有什么重要之处？显然，使用这个值而不是其他任何值对这个测试来说很重要，因为它看起来如此具体。实际上并不是这样，但读者不会知道这一点。他们可能会在其他测试中使用这个密码值只是为了安全起见。魔法值往往会自行在测试中传播。'
- en: The following listing shows the same test with the magic values fixed.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了具有固定魔法值的相同测试。
- en: Listing 9.4 Fixing magic values
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.4 修复魔法值
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: By putting magic values into meaningfully named variables, we can remove the
    questions people will have when reading our test. For the password value, I’ve
    decided to simply change the direct value to explain to the reader what is *not*
    important about this test.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将具有意义名称的变量中放入魔法值，我们可以消除人们在阅读我们的测试时可能会有的疑问。对于密码值，我决定简单地改变直接值来向读者解释这个测试中*不*重要的事情。
- en: Variable names and values are just as much about explaining to the reader what
    they should *not* care about as they are about explaining what *is* important.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 变量名称和值同样重要的是向读者解释他们*不应该*关心的事情，就像它们是解释*什么*重要的一样。
- en: 9.3 Separating asserts from actions
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3 将断言与操作分离
- en: For the sake of readability and all that is holy, avoid writing assertions and
    the method call in the same statement. The following listing shows what I mean.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可读性和所有神圣的东西，避免在同一语句中编写断言和方法调用。以下列表显示了我是指什么。
- en: Listing 9.5 Separating asserts from actions
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.5 将断言与操作分离
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Bad example
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 不好的例子
- en: ❷ Good example
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 优秀的例子
- en: See the difference between the two examples? The first example is much harder
    to read and understand in the context of a real test because of the length of
    the line and the nesting of the act and assert parts.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这两个例子之间的区别？第一个例子由于行长度和操作和断言部分的嵌套，在真实测试的上下文中阅读和理解起来要困难得多。
- en: It’s also much easier to debug the second example than the first one, if you
    wanted to focus on the result value after the call. Don’t skimp on this small
    tip. The people after you will whisper a small thank you when your test doesn’t
    make them feel stupid for not understanding it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要在调用后专注于结果值，那么调试第二个例子比第一个例子要容易得多。不要忽视这个小技巧。当你的测试没有让他们因为不理解而感到愚蠢时，他们会在你之后低声说一声小小的感谢。
- en: 9.4 Setting up and tearing down
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.4 设置和销毁
- en: Setup and teardown methods in unit tests can be abused to the point where the
    tests or the setup and teardown methods are unreadable. The situation is usually
    worse in the setup method than in the teardown method.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试中的设置和销毁方法可能会被滥用到测试或设置和销毁方法本身变得难以阅读的程度。这种情况在设置方法中通常比在销毁方法中更糟糕。
- en: 'The following listing shows one possible abuse that is very common: using the
    setup (or `beforeEach` function) for setting up mocks or stubs.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了一种非常常见的滥用方式：使用设置（或`beforeEach`函数）来设置模拟或存根。
- en: Listing 9.6 Using a setup (`beforeEach`) function for mock setup
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.6 使用设置（`beforeEach`）函数进行模拟设置
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Setting up a mock
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 设置模拟
- en: ❷ Using the mock
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用模拟
- en: If you set up mocks and stubs in a setup method, that means they don’t get set
    up in the actual test. That, in turn, means that whoever is reading your test
    may not even realize that there are mock objects in use, or what the test expects
    from them.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个设置方法中设置模拟和存根，这意味着它们在实际测试中不会被设置。这反过来意味着，阅读你的测试的人可能甚至都没有意识到正在使用模拟对象，或者测试期望它们做什么。
- en: The test in listing 9.6 uses the `mockLog` variable, which is initialized in
    the `beforeEach` function (a setup method). Imagine you have dozens or more of
    these tests in the file. The setup function is at the beginning of the file, and
    you are stuck reading a test way down in the file. You come across the `mockLog`
    variable and you have to start asking questions such as, “Where is this initialized?
    How will it behave in the test?” and more.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.6中的测试使用了`mockLog`变量，该变量在`beforeEach`函数（一个设置方法）中初始化。想象一下，如果你在文件中有数十个或更多的这些测试，设置函数位于文件的开头，而你却卡在阅读文件底部的测试。你遇到了`mockLog`变量，你必须开始提出问题，例如，“这个是如何初始化的？它在测试中会如何表现？”等等。
- en: Another problem that can arise if multiple mocks and stubs are used in various
    tests in the same file is that the setup function becomes a dumping group for
    all the various states used by your tests. It becomes a big mess, a soup of many
    parameters, some used by one test and others used somewhere else. It becomes difficult
    to manage and understand such a setup.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在同一个文件中的各种测试中使用了多个模拟和存根，可能会出现另一个问题，那就是设置函数变成了所有测试使用的各种状态的垃圾桶。这会变得一团糟，像是一锅混合了众多参数的大杂烩，有些参数被一个测试使用，而其他参数则被用在其他地方。管理和理解这样的设置变得困难。
- en: It’s much more readable to initialize mock objects directly in the test, with
    all their expectations. The following listing is an example of initializing the
    mock in each test.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 直接在测试中初始化模拟对象及其所有期望，这样更易于阅读。以下列表是一个在每个测试中初始化模拟的示例。
- en: Listing 9.7 Avoiding a setup function
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.7 避免设置函数
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Initializing the mock in the test
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在测试中初始化模拟
- en: When I look at this test, everything is clear as day. I can see when the mock
    is created, its behavior, and anything else I need to know.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当我看这个测试时，一切都很清晰。我可以看到模拟何时被创建，它的行为，以及我需要知道的其他任何信息。
- en: If you’re worried about maintainability, you can refactor the creation of the
    mock into a helper function that each test would call. That way, you’re avoiding
    the generic setup function and are instead calling the same helper function from
    multiple tests. As the following listing shows, you keep the readability and gain
    more maintainability.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你担心可维护性，可以将模拟的创建重构为一个辅助函数，每个测试都会调用它。这样，你避免了通用的设置函数，而是从多个测试中调用相同的辅助函数。如下所示，你保持了可读性并获得了更多的可维护性。
- en: Listing 9.8 Using a helper function
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.8 使用辅助函数
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Using a helper function to initialize the mock
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用辅助函数初始化模拟
- en: And yes, if you follow this logic, you can see that I’m perfectly OK with you
    not having *any* setup functions in your tests. I’ve often written full test suites
    that don’t have a setup function, instead calling helper methods from each test,
    for the sake of maintainability. The tests were still readable and maintainable.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 并且是的，如果你遵循这个逻辑，你会发现我对你在测试中没有任何设置函数感到非常满意。我经常编写没有设置函数的完整测试套件，而是从每个测试中调用辅助方法，为了维护性。这些测试仍然可读且易于维护。
- en: Summary
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: When naming a test, include the name of the unit of work under test, the current
    test scenario, and the expected behavior of the unit of work.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当命名一个测试时，包括正在测试的工作单元的名称、当前的测试场景以及工作单元的预期行为。
- en: Don’t leave magic values in your tests. Either wrap them in variables with meaningful
    names, or put the description into the value itself, if it’s a string.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要在测试中留下魔法值。要么用有意义的变量将它们包裹起来，要么如果是一个字符串，将描述放入值本身。
- en: Separate assertions from actions. Merging the two shortens the code but makes
    it significantly harder to understand.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将断言与操作分开。合并两者缩短了代码，但会使代码理解难度显著增加。
- en: Try not to use test setups at all (such as `beforeEach` methods). Introduce
    helper methods to simplify the test’s arrange part, and use those helper methods
    in each test.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽量不要使用任何测试设置（例如`beforeEach`方法）。引入辅助方法来简化测试的安排部分，并在每个测试中使用这些辅助方法。
