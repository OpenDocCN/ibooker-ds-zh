- en: 4 Time points, duration, and literals
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 时间点、持续时间和文字
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Using `std::chrono` time points and durations
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::chrono`时间点和持续时间
- en: Using ratios
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用比率
- en: Using literal suffixes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用文字后缀
- en: Using the overloaded `operator/` to create dates
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用重载的`operator/`创建日期
- en: Input and output of time points and durations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间点和持续时间的输入和输出
- en: Using different time zones
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用不同的时区
- en: In this chapter, we will make a short program to create a countdown to an event.
    To do this, we will use time points and durations from the `chrono` header. This
    feature was introduced in C++11, and although the essence has remained the same,
    several useful additions have been made over time. Howard Hinnant is the main
    author and designer of this feature. In his Meeting C++ talk in 2019, he gave
    a lot of background to its design ([https://www.youtube.com/watch?v=adSAN282YIw](https://www.youtube.com/watch?v=adSAN282YIw)).
    As we use `chrono`, we will learn several important idioms and approaches applicable
    to many other situations.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将编写一个简短的程序来创建一个事件倒计时。为此，我们将使用`chrono`头文件中的时间点和持续时间。这个特性是在C++11中引入的，尽管本质保持不变，但随着时间的推移，已经添加了几个有用的功能。霍华德·欣南特是这个特性的主要作者和设计师。在2019年的Meeting
    C++演讲中，他提供了很多关于其设计的背景信息（[https://www.youtube.com/watch?v=adSAN282YIw](https://www.youtube.com/watch?v=adSAN282YIw)）。随着我们使用`chrono`，我们将学习到许多适用于许多其他情况的重要惯用和途径。
- en: We will build a simple countdown in the first section and then dig deeper into
    the types we used. We will discover how to use the ratio templates so that we
    can understand durations. We’ll then learn how to read dates in so we can count
    down to any event and print out countdowns in various units. We will learn about
    literal suffixes to specify days, months, and so on and why they are useful. We
    will also encounter the idea of *requirements* and touch on concepts. Having covered
    these newer C++ features, we’ll finish with a countdown using a zoned time.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分，我们将构建一个简单的倒计时，然后更深入地探讨我们所使用的类型。我们将发现如何使用比率模板来理解持续时间。然后我们将学习如何读取日期，以便我们可以为任何事件倒计时并打印出各种单位的倒计时。我们将了解用于指定天数、月份等的文字后缀及其用途。我们还将遇到*需求*的概念，并触及相关概念。在涵盖了这些新的C++特性之后，我们将使用时区时间完成一个倒计时。
- en: 4.1 How long until the last day of the year?
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 一年最后一天还有多久？
- en: We will start by finding out how long it is until the end of a specific year
    to get a basic countdown. We only need a small amount of code, so this chapter’s
    project is small in terms of lines of code. However, we will expand our knowledge
    as we code.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先找出距离特定年份结束还有多久，以获得基本的倒计时。我们只需要少量代码，所以本章的项目在代码行数上很小。然而，随着我们编写代码，我们将扩展我们的知识。
- en: 'To find how far off a date is, such as New Year’s Eve, we need to know the
    current time. The `chrono` header gives us a way to do this, providing us with
    date and time:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出日期距离某个事件有多远，例如除夕夜，我们需要知道当前时间。`chrono`头文件为我们提供了这样做的方法，提供了日期和时间：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Several details are hiding in there, which we will unpack further in this chapter.
    The `time_point` is a class template, using a clock and a duration. We have a
    choice of clocks, each able to work out the time and date for us. We will look
    at the duration details in the next section, but at a high level, it specifies
    the units of time, such as seconds or days. We have applied class template argument
    deduction (CTAD) to avoid specifying these template parameters, so we need to
    use at least C++17\. Without it, we would need to spell out the full type, `std::chrono::time_point<std::chrono::
    system_clock>` or just use `auto`.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 其中隐藏着几个细节，我们将在本章中进一步展开。`time_point`是一个类模板，使用时钟和持续时间。我们有选择时钟的选项，每个选项都能为我们计算出时间和日期。我们将在下一节中查看持续时间细节，但就高层次而言，它指定了时间单位，例如秒或天。我们已应用类模板参数推导（CTAD）来避免指定这些模板参数，因此我们需要至少使用C++17。如果没有它，我们就需要写出完整的类型，`std::chrono::time_point<std::chrono::system_clock>`，或者直接使用`auto`。
- en: What is a clock? The `system_clock` we are using is based on the operating system’s
    time. Now, an administrator can change the system’s time, so calling `now` might
    appear to go back in time if the system time gets changed. That is not a problem,
    but it’s worth knowing. Each clock provides a member variable called `is_steady`,
    which tells us if this might happen. We could use a `steady_clock` instead, although
    that is better suited for timing intervals. There are other clocks as well, for
    example, the `high_ resolution_clock`, which provides the finest grain tick. Be
    warned that despite the name, this clock might be a `system_clock` or `steady_clock`,
    rather than a clock with a super-small tick size. There is also a `file_clock`
    for use with timestamps on files. Different file systems support different resolutions,
    so this provides a consistent way to access such information, regardless of the
    resolution used by the file system. We will stick with the `system_clock` in this
    chapter. It provides a systemwide real-time wall clock based on coordinated universal
    time (UTC) and maps easily to C’s `time_t`, allowing us to interact with a C library
    if required.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是时钟？我们正在使用的`system_clock`是基于操作系统的时钟。现在，管理员可以更改系统的时钟，如果系统时间被更改，调用`now`可能会看起来像是回到了过去。这不是问题，但这是值得知道的。每个时钟都有一个名为`is_steady`的成员变量，它告诉我们这种情况是否可能发生。我们可以使用`steady_clock`代替，尽管它更适合计时间隔。还有其他时钟，例如，`high_resolution_clock`提供了最细粒度的滴答声。警告：尽管名字如此，这个时钟可能是一个`system_clock`或`steady_clock`，而不是具有超级小滴答大小的时钟。还有一个`file_clock`用于文件的戳记。不同的文件系统支持不同的分辨率，因此这提供了一种一致的方式来访问此类信息，无论文件系统使用的分辨率如何。在本章中，我们将坚持使用`system_clock`。它提供了一个基于协调世界时（UTC）的全局实时墙钟，并且很容易映射到C的`time_t`，允许我们在需要时与C库交互。
- en: Armed with another time point, we can find the difference between each to get
    a time interval or *duration*. For example, if we create a time point at the last
    day of the year, we can find how long it is until the last day of the year. New
    Year’s Eve is always on the 31st of December, so we can specify a specific year,
    month, and day using C++20’s `std::chrono::year_month_day.`
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有另一个时间点，我们可以找到它们之间的差异，从而得到一个时间间隔或*持续时间*。例如，如果我们创建一个在年底最后一天的时间点，我们可以找到距离年底最后一天还有多长时间。除夕夜总是在12月31日，因此我们可以使用C++20的`std::chrono::year_month_day`指定一个特定的年份、月份和日期。
- en: Listing 4.1 Creating a specific date
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.1 创建特定日期
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We will see how to get the year from the `time_point` `now` shortly so we can
    write a more general and useful countdown. First, we will find the difference
    between the fixed date in listing 4.1 and the current `time_point`. Before we
    find the difference between our two dates, notice that `year_month_day` uses the
    *whole value idiom*. The whole value idiom has roots in Ward Cunningham’s CHECKS
    pattern language ([http://c2.com/ppr/checks.html](http://c2.com/ppr/checks.html)),
    which mentions whole values to represent the meaningful quantities and is further
    explored by Martin Fowler’s quantity pattern ([https://martinfowler.com/eaaDev/Quantity.html](https://martinfowler.com/eaaDev/Quantity.html))
    that represents dimensioned values with both their amount and unit. Rather than
    using integers for each parameter and trying to remember which order the constructor
    parameters are in, even though there is a big clue in the name, we have to explicitly
    pass an `std::chrono::year` to the year parameter and so on. The whole value idiom
    creates lightweight types to ensure parameters are passed correctly. A compiler
    error will ensue if we try to pass a month where a day is required, pinpointing
    a problem early and precisely.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快就会看到如何从`time_point` `now`获取年份，这样我们就可以编写一个更通用和有用的倒计时。首先，我们将找到列表4.1中的固定日期和当前`time_point`之间的差异。在我们找到两个日期之间的差异之前，请注意`year_month_day`使用的是*整值习语*。整值习语起源于Ward
    Cunningham的CHECKS模式语言([http://c2.com/ppr/checks.html](http://c2.com/ppr/checks.html))，其中提到整值来表示有意义的数量，并由Martin
    Fowler的量模式([https://martinfowler.com/eaaDev/Quantity.html](https://martinfowler.com/eaaDev/Quantity.html))进一步探索，该模式用数量和单位来表示有尺寸的值。我们不是为每个参数使用整数并试图记住构造函数参数的顺序，尽管名字中有一个很大的提示，我们必须显式地将`std::chrono::year`传递给年份参数等等。整值习语创建轻量级类型以确保参数正确传递。如果我们尝试传递一个需要日期的月份，将会产生编译器错误，这可以早期和精确地定位问题。
- en: 'To compare the `new_years_eve` with the current date time, we need to convert
    the date to another `time_point`. We only have days without a time, so we specify
    days as the duration of the `time_point` for the conversion:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要比较 `new_years_eve` 与当前日期时间，我们需要将日期转换为另一个 `time_point`。我们只有没有时间的日期，因此我们指定天数作为转换的
    `time_point` 的持续时间：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We could use one of two type aliases from `chrono` to make our `event` definition
    more succinct. First, whenever we need a time point based on a system clock, we
    can use `sys_time` and specify the duration. Thus, we could say
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `chrono` 中的两个类型别名之一来使我们的 `event` 定义更简洁。首先，每当我们需要基于系统时钟的时间点时，我们可以使用 `sys_time`
    并指定持续时间。因此，我们可以说
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Second, if we need days specifically, we can use `sys_days` as a shorthand:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，如果我们需要具体的日期，我们可以使用 `sys_days` 作为缩写：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Either way, we now have two `time_point`s, so we can subtract them to find the
    difference and stream the value out, using `chrono`’s `operator<<`, which was
    introduced in C++20\.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，我们现在都有两个 `time_point`，因此我们可以从中减去以找到差异，并使用 `chrono` 的 `operator<<` 将值流出，该操作符是在
    C++20 中引入的。
- en: Listing 4.2 Duration between two time points
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.2 两个时间点之间的持续时间
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Hardcodes a year for now
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 现在硬编码一个年份
- en: ❷ Converts to a time point
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 转换为时间点
- en: ❸ Finds the difference
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 查找差异
- en: ❹ Finds operator<< for duration
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 查找持续时间的 `operator<<`
- en: 'If you have an older compiler that does not support `operator<<` for durations
    yet, you can use the `count` method to send a value to `cout` in the last line
    of the function:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个不支持持续时间 `operator<<` 的旧编译器，你可以在函数的最后一行使用 `count` 方法将值发送到 `cout`：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Alternatively, you can clone Howard Hinnant’s date library ([https://github.com/HowardHinnant/date](https://github.com/HowardHinnant/date))
    somewhere sensible:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以在一个合理的位置克隆 Howard Hinnant 的日期库 ([https://github.com/HowardHinnant/date](https://github.com/HowardHinnant/date))：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Include "`date/date.h"` from the library and add
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 从库中包含 "`date/date.h"` 并添加
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: when you need to use the stream insertion operator. When you build your code,
    don’t forget to use the `-I` switch to point to the `date/include` directory.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要使用流插入操作符时。当你构建代码时，别忘了使用 `-I` 开关指向 `date/include` 目录。
- en: The exact output will depend on when we run listing 4.2, but we get a number
    and some units. Using Visual Studio 2022 gave
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 实际输出将取决于我们何时运行列表 4.2，但我们会得到一个数字和一些单位。使用 Visual Studio 2022 给出
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The number is in fractions of a second, indicated by `[1/10000000]s` in the
    output. Using the Compiler Explorer and either GCC 12.2 ([https://godbolt.org/z/8Gj345e3d](https://godbolt.org/z/8Gj345e3d))
    or Clang 15.0 ([https://godbolt.org/z/9zGvqfhPs](https://godbolt.org/z/9zGvqfhPs)),
    we get
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 数字表示秒的分数，输出中用 `[1/10000000]s` 表示。使用 Compiler Explorer 和 GCC 12.2 ([https://godbolt.org/z/8Gj345e3d](https://godbolt.org/z/8Gj345e3d))
    或 Clang 15.0 ([https://godbolt.org/z/9zGvqfhPs](https://godbolt.org/z/9zGvqfhPs))，我们得到
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It would be nice to decide the granularity for ourselves and use the actual
    year, rather than hardcoding 2022\. We will take a deeper dive into durations
    in the next section to achieve this.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 自己决定粒度并使用实际的年份，而不是硬编码 2022 年，会更好。我们将在下一节更深入地探讨持续时间以实现这一点。
- en: Let’s take a moment to remind ourselves precisely what we have used so far.
    If we try the code on C++ Insights, mentioned in the first chapter ([https://cppinsights.io/s/7a85b40e](https://cppinsights.io/s/7a85b40e)),
    we can see the full types spelled out. Your compiler may use slightly different
    types and values, but the insight gives an idea of how much is happening in the
    code. The insight for the two lines
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花点时间来提醒自己我们已经使用了什么。如果我们尝试在第一章中提到的 C++ Insights 上运行代码 ([https://cppinsights.io/s/7a85b40e](https://cppinsights.io/s/7a85b40e))，我们可以看到完整的类型展开。你的编译器可能使用稍微不同的类型和值，但洞察力给出了代码中发生的事情的大致想法。对于这两行
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: near the end of the function in listing 4.2 is as follows.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 4.2 的末尾是以下内容。
- en: Listing 4.3 C++ Insights showing the full types
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.3 C++ Insights 显示完整类型
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Time point using a system clock
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用系统时钟的时间点
- en: ❷ A duration of 60*60*24 seconds
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 60*60*24 秒的持续时间
- en: ❸ Conversion to sys_days i.e. time_point in days
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 转换为 sys_days 即天的时间点
- en: ❹ Insight uses a long and nanoseconds.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ Insight 使用长秒和纳秒。
- en: ❺ Overload for operator- on time points
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 对时间点进行操作符重载
- en: We can see from the C++ Insights output that durations are using ratios, so
    we need to start with ratios; then we can unpack durations in more detail.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 从 C++ Insights 的输出中我们可以看到，持续时间正在使用比率，因此我们需要从比率开始；然后我们可以更详细地展开持续时间。
- en: 4.2 Understanding durations in detail
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 详细理解持续时间
- en: 'We obtained a time interval or `duration` when we subtracted two time points,
    and we displayed the value. A `duration` counts *ticks*, either as whole numbers
    or floating-point numbers, in a unit, such as microseconds. A `duration` is therefore
    defined as a template taking two types, one for each part:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从两个时间点中减去时，我们得到了一个时间间隔或`duration`，并显示了其值。`duration`计算一个单位中的*滴*，无论是整数还是浮点数。因此，`duration`被定义为模板，它接受两个类型，每个部分一个：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The representation, `Rep`, will be a numeric type such as an `integer` or a
    `float`. The `Period` is a `ratio` telling us how to convert the ticks to seconds.
    It’s worth taking a moment to understand the `ratio` type in more detail; then
    we will be better prepared to work with various durations.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 表示，`Rep`，将是一个数值类型，例如`integer`或`float`。`Period`是一个`ratio`，告诉我们如何将滴转换为秒。花点时间详细了解`ratio`类型是值得的；然后我们将更好地准备处理各种持续时间。
- en: 4.2.1 Ratios
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.1 比率
- en: 'A minute has 60 seconds. We could divide seconds by 60 whenever we need minutes,
    but littering code with magic numbers is asking for trouble. We might not find
    every place they are used if we decide we want hours instead. We could write a
    utility function to do the conversion, or we could rely on something more generic.
    A ratio of 60:1 would be very useful. Fortunately, C++ provides exactly what we
    need in the `ratio` header. A `ratio` can be used to represent any rational number,
    so it needs two numbers: a numerator and a denominator. C++ defines this as a
    `template` using the two numbers:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一分钟有60秒。当我们需要分钟时，我们可以将秒数除以60，但代码中充斥着魔法数字会带来麻烦。如果我们决定想要小时而不是分钟，我们可能找不到它们被使用的所有地方。我们可以编写一个实用函数来完成转换，或者我们可以依赖更通用的东西。60:1的比率将非常有用。幸运的是，C++在`ratio`头文件中正好提供了我们所需的功能。`ratio`可以用来表示任何有理数，因此它需要两个数字：分子和分母。C++使用这两个数字定义了一个`template`：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `intmax_t` is the largest signed integer type, which can vary between implementations.
    Using a `template` allows arithmetic with ratios to happen at compile time. Notice
    that the numerator and denominator are both *nontype template parameters*; in
    this case, numbers rather than types. We could create a ratio of 3:6 using `std::ratio<3,`
    `6>`. If we look at the numerator and denominator
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`intmax_t`是最大的有符号整数类型，它在不同的实现中可能有所不同。使用`template`允许在编译时进行比率的算术运算。注意，分子和分母都是*非类型模板参数*；在这种情况下，是数字而不是类型。我们可以使用`std::ratio<3,
    6>`创建一个3:6的比率。如果我们查看分子和分母'
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'we find that the ratio has been reduced to the simplest form, 1/2\. In fact,
    the helper method `ratio_equal` tells us the two ratios are equivalent:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会发现比率已经被简化为最简形式，1/2。事实上，辅助方法`ratio_equal`告诉我们两个比率是等价的：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `ratio` header also provides arithmetic functions, such as `ratio_add`,
    allowing us to perform compile-time arithmetic with fractions such as
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`ratio`头文件还提供了算术函数，例如`ratio_add`，允许我们使用分数等在编译时进行算术运算，例如'
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: which gives 1/1.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了1/1。
- en: The default duration we saw at the start of this section uses a ratio of 1:1,
    `Period` `=` `std::ratio<1>`, equating to 1 second per tick. The `chrono` header
    provides various periods, from nanoseconds to years, each based on definitions
    in the `ratio` header. A nanosecond is 1/1,000,000,000 seconds. Counting how many
    zeros there are in such a number is error prone. Fortunately, the `ratio` header
    defines `std::nano` for us as
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 本节开头我们看到的默认持续时间使用1:1的比率，`Period` `=` `std::ratio<1>`，相当于每滴1秒。`chrono`头文件提供了各种周期，从纳秒到年，每个周期都基于`ratio`头文件中的定义。纳秒是1/1,000,000,000秒。计算这样一个数字中有多少个零是容易出错的。幸运的是，`ratio`头文件为我们定义了`std::nano`：
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We can use this instead of creating our own constant. The `ratio` header also
    defines milli-, kilo-, and other International System of Units (SI) ratios.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个而不是创建我们自己的常量。`ratio`头文件还定义了毫、千以及其他国际单位制（SI）比率。
- en: In listing 4.3, we saw C++ Insights using a duration with a `long` for the representation
    and a period of `std::ratio<1,` `1000000000>`. The representation and period used
    for a `system_clock` can vary between compilers, but that does not matter. Whatever
    is in use, we can ask for seconds between time points or any other duration. We
    can now change our countdown to provide the duration in whatever units we choose.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在4.3列表中，我们看到了C++ Insights使用`long`表示持续时间和`std::ratio<1, 1000000000>`的周期。对于`system_clock`使用的表示和周期可能因编译器而异，但这并不重要。无论使用什么，我们都可以要求在时间点之间或任何其他持续时间中提供秒数。现在我们可以更改我们的倒计时，以提供我们选择的任何单位。
- en: 4.2.2 Durations
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.2 持续时间
- en: Our countdown was in fractions of a second, but we might want to report it in
    days or minutes instead. So how do we convert between durations? To get a duration
    in minutes, we employ `std::chrono::minutes`, which uses a ratio of 60:1\. Various
    periods are available. Hours use 3,600:1, milliseconds 1:1,000, and microseconds
    1:1,000,000\. C++20 introduced days, weeks, months, and years as well. Days and
    weeks are straightforward enough, but how many days are there in a month or a
    year? It depends. C++20 uses 365.2425 days for a year and 30.436875 days, exactly
    1/12 of a year, for a month. The *civil* calendar models the solar system approximately,
    and `chrono` models the civil calendar precisely. We could even write our own
    calendars that can interoperate with `chrono`. Howard Hinnant gives examples including
    the Julian and Islamic calendars on his GitHub pages ([http://mng.bz/A89Q](http://mng.bz/A89Q)).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的倒计时是以秒为单位的分数，但我们可能希望以天或分钟为单位报告。那么我们如何转换持续时间？要获取分钟的持续时间，我们使用 `std::chrono::minutes`，它使用
    60:1 的比例。有各种周期可供选择。小时使用 3,600:1，毫秒使用 1:1,000，微秒使用 1:1,000,000。C++20 还引入了天、周、月和年。天和周相对简单，但一个月或一年有多少天？这取决于。C++20
    使用 365.2425 天作为一年，30.436875 天作为一个月，正好是 1/12 年。*公历*模型太阳系大约，而 `chrono` 模型公历精确。我们甚至可以编写自己的日历，这些日历可以与
    `chrono` 交互操作。霍华德·欣南特在他的 GitHub 页面上提供了示例，包括儒略历和伊斯兰历（[http://mng.bz/A89Q](http://mng.bz/A89Q)）。
- en: 'We can switch between durations implicitly or explicitly. Assigning a finer-grained
    interval from a coarser-grained one will not round, so an implicit cast works:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以隐式或显式地在持续时间之间切换。从粗粒度到细粒度的时间间隔赋值不会四舍五入，所以隐式转换是有效的：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Getting back to the finer-grained milliseconds may involve rounding, so we
    need to use a named cast:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 回到更细粒度的毫秒可能涉及四舍五入，因此我们需要使用命名转换：
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This example will give us back the original 2 hours. In most cases, going from
    milliseconds to hours might lose some precision. Two hours is 7,200,000 milliseconds.
    If we only had 7,199,999 milliseconds, we would be a millisecond under 2 hours,
    so we would get 1 hour instead of 2\. Similarly, 23 hours is nearly a day, but
    transforming this into a day will round toward zero, so we get 0 hours if we round
    trip.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子将返回原始的 2 小时。在大多数情况下，从毫秒到小时可能会丢失一些精度。两小时是 7,200,000 毫秒。如果我们只有 7,199,999 毫秒，我们就会低于两小时一个毫秒，所以我们会得到
    1 小时而不是 2。同样，23 小时几乎是一个整天，但将其转换为天会四舍五入到零，所以如果我们来回转换，我们会得到 0 小时。
- en: Let’s try this out. We will add a `using` directive so we no longer need to
    fully qualify the types and functions in `std::chrono`. However, be wary of doing
    this thoughtlessly and never do this in a header file. ISOCpp’s core guideline
    SF.7 tells us not to write `using` `namespace` at global scope in a header file
    (see [http://mng.bz/xjR6](http://mng.bz/xjR6)). Doing so might bring two names
    into scope and cause ambiguity. In our case, we have a small function, so we will
    not introduce naming collisions.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试这个。我们将添加一个 `using` 指令，这样我们就不需要完全限定 `std::chrono` 中的类型和函数了。然而，不要无意识地这样做，并且永远不要在头文件中这样做。ISOCpp
    的核心指南 SF.7 告诉我们不要在头文件的全局作用域中写入 `using namespace`（见 [http://mng.bz/xjR6](http://mng.bz/xjR6)）。这样做可能会将两个名称引入作用域，并导致歧义。在我们的情况下，我们有一个小的函数，所以我们不会引入命名冲突。
- en: So how many days is 23 hours? We need a `duration_cast` to find out.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 那么 23 小时是多少天？我们需要一个 `duration_cast` 来找出。
- en: Listing 4.4 Using `duration` to move to a coarser representation
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.4 使用 `duration` 进行更粗粒度的表示
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ Starts with almost a day
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 几乎是一个整天
- en: ❷ Casts to days
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 转换为天
- en: ❸ Gets 0 hours back
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 回退 0 小时
- en: Call `durations` from `main` to see
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `main` 中调用 `durations` 来查看
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `operator<<` reports `0d`, meaning 0 days, which is `0h`, or 0 hours. Don’t
    forget you can use the duration’s `count` method instead or `using date::operator<<`
    if you need to. A value in days can be assigned to hours without an explicit cast
    because we do not drop precision. So given one whole day `a_day{1}`, we can assign
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`operator<<` 报告 `0d`，表示 0 天，也就是 `0h`，或 0 小时。别忘了你可以使用持续时间的 `count` 方法，或者如果你需要，可以使用
    `using date::operator<<`。由于我们不会丢失精度，所以可以直接将天数赋值给小时。所以给定一个整天 `a_day{1}`，我们可以赋值'
- en: '[PRE23]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'and check that they are the same:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 并检查它们是否相同：
- en: '[PRE24]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We could use an explicit `duration_cast` instead of the direct assignment, but
    reserving the use of `duration_cast` for only those conversions that lose precision
    is a good approach. This makes it easy to find such lossy conversions in our code
    if we suspect a lossy conversion is the source of an error. Needing to use a `duration_cast`
    when we might lose precision is a good thing because the cast makes the potential
    loss explicit, as figure 4.1 shows.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用显式的`duration_cast`而不是直接赋值，但将`duration_cast`的使用仅限于那些会丢失精度的转换是一种很好的方法。这使得如果我们怀疑丢失精度的转换是错误的来源，我们很容易在我们的代码中找到这样的丢失精度转换。当我们可能丢失精度时需要使用`duration_cast`是好事，因为转换使潜在的丢失变得明确，如图4.1所示。
- en: '![CH04_F01_Buontempo](../Images/CH04_F01_Buontempo.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F01_Buontempo](../Images/CH04_F01_Buontempo.png)'
- en: Figure 4.1 Transforming 23 hours to days loses precision, so it needs a `duration_cast`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 将23小时转换为天数会丢失精度，因此需要使用`duration_cast`。
- en: 'We can even write our own `duration`; for example, a century. We need to provide
    a type for the period. A century has 100 times as many seconds as a year, so we
    need the ratio 1:100, or `std::hecto`. We can then use `ratio_multiply` from the
    `ratio` header to get the type we need. The `multiply` function calculates the
    appropriate numerator and denominator for us, so we can define centuries using
    a *type alias*, with the keyword `using`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以编写自己的`duration`；例如，一个世纪。我们需要提供一个周期类型。一个世纪比一年多100倍秒，所以我们需要1:100的比例，或者`std::hecto`。然后我们可以使用`ratio`头文件中的`ratio_multiply`来获取所需的类型。`multiply`函数为我们计算适当的分子和分母，因此我们可以使用*类型别名*，即`using`关键字来定义世纪：
- en: '[PRE25]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `using` statement works like a generalization of `typedef`, and we will
    see more details in chapter 8\. We can use our century duration just like any
    of the `chrono` durations; for example, converting centuries to seconds, hours,
    or days. Seconds and hours can be converted without a cast, but to get days, we
    need a `duration_cast`. This might be surprising because a century is 100 years,
    and a year has either 365 or 366 whole days. However, C++ defines a year as 365.2425
    days, so one century is 36,524.25, which has a partial day. We therefore need
    the explicit `duration_cast`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`using`语句类似于`typedef`的泛化，我们将在第8章中看到更多细节。我们可以像使用任何`chrono`持续时间一样使用我们的世纪持续时间；例如，将世纪转换为秒、小时或天数。秒和小时可以不进行转换直接转换，但要得到天数，我们需要使用`duration_cast`。这可能会令人惊讶，因为一世纪是100年，而一年有365或366个完整的日。然而，C++将一年定义为365.2425天，所以一世纪是36524.25天，这包含了一部分天数。因此，我们需要显式地使用`duration_cast`。'
- en: Listing 4.5 Defining a duration
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.5 定义一个持续时间
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ Defines and uses a duration
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义和使用一个持续时间
- en: ❷ Converts to seconds or hours
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 转换为秒或小时
- en: ❸ Casts for days
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 持续数日
- en: If we run this code, we see
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这段代码，我们会看到
- en: '[PRE27]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The predefined convenience durations are sufficient for counting down to an
    event, but the careful design of this library allows us so much flexibility. In
    fact, there is even more in the library to make our lives easier. We do not need
    to spell out `std::chrono::month(12)` in full because the durations and other
    types support *literal suffixes*. Let’s look at the literal suffixes in more detail.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 预定义的便利持续时间足以用于倒计时到某个事件，但这个库的精心设计给了我们很大的灵活性。实际上，这个库中还有更多功能可以使我们的生活更轻松。我们不需要完全拼写`std::chrono::month(12)`，因为持续时间和其他类型支持*字面后缀*。让我们更详细地看看字面后缀。
- en: 4.2.3 Literal suffixes and operator / for readable code
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.3 字面后缀和运算符/使代码更易读
- en: 'We noted that trying to read numbers with many zeros, such as 1000000000, can
    be error prone, but adding a digit separator, such as 1,000,000,000, helps. C++
    now supports a digit separator, but a comma is an operator, so we use a single
    quote instead:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到尝试读取包含许多零的数字，如1000000000，可能会出错，但添加一个数字分隔符，如1,000,000,000，有助于。C++现在支持数字分隔符，但逗号是一个运算符，所以我们使用单引号：
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is a small but useful addition to the language. In listing 4.4, we used
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对语言的一个小但有用的补充。在列表4.4中，我们使用了
- en: '[PRE29]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: which is perfectly readable, but `chrono` supports literal suffixes too. By
    adding `h` for hours, we can also write
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常易于阅读，但`chrono`也支持字面后缀。通过添加`h`表示小时，我们也可以这样写
- en: '[PRE30]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The literal suffix of `''h''` for hours is quite intuitive. Either approach
    is fine. How does this work? The seemingly magic `''h''` is using the `operator""h`
    from `chrono`. The operator takes a number and returns the stronger type of hours,
    implemented along these lines:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 小时字面后缀`'h'`非常直观。两种方法都行。这是怎么工作的？看似神奇的`'h'`是使用了`chrono`中的`operator""h`。这个运算符接受一个数字并返回小时类型的更强类型，实现方式如下：
- en: '[PRE31]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When `23h` is encountered, this function is called, giving us the hours we wanted.
    We need to be using a suitable namespace for this to work. We have a choice here.
    We can either use one of the namespaces
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当遇到 `23h` 时，这个函数会被调用，给出我们想要的小时数。我们需要使用一个合适的命名空间才能使这个操作生效。我们在这里有选择。我们可以使用以下命名空间之一
- en: '`std::literals`,'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::literals`,'
- en: '`std::chrono_literals`,'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::chrono_literals`,'
- en: '`std::literals::chrono_literals`,'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::literals::chrono_literals`,'
- en: 'or, more simply, use `std::chrono`, which makes `chrono_literals` visible via
    the directive:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，更简单地说，使用 `std::chrono`，它通过指令使 `chrono_literals` 可见：
- en: '[PRE32]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `operator""h` is an example of a *user-defined literal*, providing a conversion
    to hours when we use an `'h'` as a suffix on a number. Other literals are supported,
    including minutes with `'min'` and seconds with `'s'`. These were introduced in
    C++11, and C++14 added milli-, micro- and nanoseconds. This gives us two ways
    to define durations, as shown in table 4.1.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`operator""h` 是一个 *用户定义的文法* 的例子，当我们使用 `''h''` 作为数字后缀时，它提供了转换为小时的转换。其他文法也受到支持，包括带有
    `''min''` 的分钟和带有 `''s''` 的秒。这些是在 C++11 中引入的，而 C++14 添加了毫秒、微秒和纳秒。这给了我们两种定义持续时间的方法，如表
    4.1 所示。'
- en: Table 4.1 Two ways to define a specific duration
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.1 定义特定持续时间的两种方法
- en: '| Duration | Literals example |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 持续时间 | 文法示例 |'
- en: '| `hours{12}` | `12h` |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `hours{12}` | `12h` |'
- en: '| `minutes{34}` | `34min` |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `minutes{34}` | `34min` |'
- en: '| `seconds{1}` | `1s` |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `seconds{1}` | `1s` |'
- en: '| `millisecond{1}` | `1ms` |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `millisecond{1}` | `1ms` |'
- en: '| `microsecond{1}` | `1us` |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `microsecond{1}` | `1us` |'
- en: '| `nanosecond{1}` | `1ns` |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `nanosecond{1}` | `1ns` |'
- en: There are no literals to help construct the durations days, months, or years.
    However, there are literals for a day, month, or year in a calendar. Notice that
    all the predefined `chrono::duration` types are plural, while the calendar types
    are singular. They behave differently. We can add months but cannot add January
    and December. To specify a month, we can spell out the name of the month in full;
    for example, using the named constant `December`. A conversion from a numeric
    type would mean arguing over whether to start at `0` or `1`. As it happens, C++20
    uses `1` for January, but if we type `January` in full, we don’t need to remember
    where to start. Day, month, and year are *calendrical specifiers*, and they can
    also be defined in two ways, as shown in table 4.2.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 没有文法可以帮助构建天数、月数或年数。然而，日历中有天、月或年的文法。注意，所有预定义的 `chrono::duration` 类型都是复数形式，而日历类型是单数形式。它们的行为不同。我们可以添加月份，但不能添加一月和十二月。要指定月份，我们可以完整地拼写月份的名称；例如，使用命名常量
    `December`。从数值类型进行转换意味着争论是否从 `0` 开始。实际上，C++20 使用 `1` 作为一月的值，但如果我们完整地键入 `January`，我们就不需要记住从哪里开始。日、月和年是
    *日历指定符*，它们也可以以两种方式定义，如表 4.2 所示。
- en: Table 4.2 Two ways to define a specific day, month, or year
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.2 定义特定日、月或年的两种方法
- en: '| Civil calendar | Literals example |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 公历 | 文法示例 |'
- en: '| `year{2023}` | `2023y` |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `year{2023}` | `2023y` |'
- en: '| `month{1}` | `January` |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `month{1}` | `January` |'
- en: '| `day{23}` | `23d` |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `day{23}` | `23d` |'
- en: User-defined literals extend the idea of writing `1u` to mean an unsigned or
    `1.0f` to mean a float. The C++ standard library provides literals for time, which
    we just saw. We also have `'i'` for complex numbers; for example, `2` `+` `3i`,
    or `'s'` for `std::string`. Yes, that is another `operator""s`, which is in the
    `string_literals` namespace, but it takes a `const char*`, while `chrono`’s seconds
    literal takes a numeric type, so they are unambiguous. The string literal is useful.
    If we initialize a variable with `"Hello"`, we are using a `char` array. If we
    use `"Hello"s` instead, we have an `std::string` directly. We are allowed to define
    our own literals too by providing an appropriate operator; however, we have to
    begin our suffix with an underscore to avoid potentially clashing with standard
    literal operators.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 用户定义的文法扩展了将 `1u` 写作无符号或 `1.0f` 写作浮点数的概念。C++ 标准库提供了时间文法，我们刚刚看到了。我们还有 `'i'` 用于复数；例如，`2`
    `+` `3i`，或者 `'s'` 用于 `std::string`。是的，还有一个 `operator""s`，它在 `string_literals`
    命名空间中，但它接受一个 `const char*`，而 `chrono` 的秒文法接受一个数值类型，所以它们是不含糊的。字符串文法很有用。如果我们用 `"Hello"`
    初始化一个变量，我们正在使用一个 `char` 数组。如果我们使用 `"Hello"s` 代替，我们就有了一个直接的 `std::string`。我们也可以通过提供适当的操作符来定义自己的文法；然而，我们必须以下划线开始我们的后缀，以避免与标准文法操作符可能发生的冲突。
- en: 'At the beginning of this chapter, in listing 4.1, we created a date explicitly
    stating the year, month, and day without using these literals:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，在列表 4.1 中，我们创建了一个日期，明确地指出了年、月和日，而没有使用这些文法：
- en: '[PRE33]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We could rewrite this as
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将它重写为
- en: '[PRE34]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In fact, we have a further option. Another trick the `chrono` library uses
    for readable code is overloading the `operator` `/` to create a year, month, and
    day. CppReference ([http://mng.bz/rjRj](http://mng.bz/rjRj)) lists about 40 overloads
    to create a variety of different dates. We want a full year, month, and day, so
    we can spell out the month in English, use the `''y''` suffix to specify a year,
    and give the day separated with `''/''`. For example:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们还有一个更进一步的选项。`chrono` 库为了使代码可读，使用了一个技巧，那就是重载了 `operator /` 来创建年、月和日。CppReference
    ([http://mng.bz/rjRj](http://mng.bz/rjRj)) 列出了大约 40 种重载方式来创建各种不同的日期。我们想要一个完整的年、月和日，因此我们可以用英文拼写月份，使用
    `'y'` 后缀来指定年份，并用 `'/'` 来分隔日期。例如：
- en: '[PRE35]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `31`^(st) does not need a `''d''` at the end because it must be the day
    once the year and month have been specified. A `year_month_day` can be constructed
    in a vast number of ways, but three orders work for a full date:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`31`^(st) 在指定了年和月之后不需要 `''d''` 后缀，因为它必须是那一天。`year_month_day` 可以用无数种方式构建，但以下三种顺序适用于完整的日期：'
- en: Year/month/day
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 年/月/日
- en: Month/day/year
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 月/日/年
- en: Day/month/year
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日/月/年
- en: We will use this shortly to find out how many days until the end of the current
    year. Before we do that, we will revisit the `time_point` used at the start of
    the chapter. We know a `time_point` is defined by a `clock` and a `duration`.
    We saw a few different clocks, and we now know how durations work. Although we
    have enough knowledge to finish our small countdown project, the documentation
    for `chrono` uses C++ features that crop up in many places. In particular, requirements
    are mentioned, and the innocuous-seeming phrase *as if* is used. What do they
    mean?
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将很快使用它来找出距离当前年结束还有多少天。在我们这样做之前，我们将回顾一下章节开头使用的 `time_point`。我们知道 `time_point`
    是由 `clock` 和 `duration` 定义的。我们看到了几种不同的时钟，现在我们也知道了 `duration` 的工作方式。尽管我们已经有足够的知识来完成我们的小型倒计时项目，但
    `chrono` 的文档使用了 C++ 在许多地方都会出现的特性。特别是，提到了需求，并且使用了看似无害的短语 *as if*。它们是什么意思？
- en: 4.2.4 Requirements and concepts
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.4 需求和概念
- en: We started this chapter by finding out the current time using
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从使用
- en: '[PRE36]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `time_point` is a class template comprising two types, a `clock` and a
    `duration`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`time_point` 是一个包含两种类型的类模板，一个是 `clock`，另一个是 `duration`：'
- en: '[PRE37]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: When we found the current time, we used a `system_clock`, and the `duration`
    defaulted to that clock’s `duration`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们找到当前时间时，我们使用了 `system_clock`，而 `duration` 默认为该时钟的 `duration`。
- en: CppReference ([https://en.cppreference.com/w/cpp/chrono/time_point](https://en.cppreference.com/w/cpp/chrono/time_point))
    says `time_point` is implemented *as if* it stores a value of type `duration`
    indicating the time interval from the start of the `Clock`’s epoch. We haven’t
    seen the word *epoch* yet. If you have used C’s `time_t` before, you will be familiar
    with the idea of counting ticks since the start of a given moment, or epoch, such
    as the start of January 1970\. Other systems start at different instants. For
    example, Excel for Windows uses the start of January 1900 ([http://mng.bz/ddl1](http://mng.bz/ddl1)).
    More importantly, notice the phrase *as if*, which crops up frequently in C++.
    The as if *rule* allows the compiler to reorder instructions or completely remove
    them under some circumstances, provided the observable behavior of the program
    will not differ. For a clock, the actual implementation can store whatever it
    likes, as long as it behaves as if it stores a duration. The compiler can also
    reorder or remove instructions under other circumstances too. If a program reads
    an uninitialized variable, the compiler can also do anything because this is undefined
    behavior, usually shortened to UB. Ovle Maudel wrote a short piece called “Demons
    may fly out of your nose” a while ago ([http://mng.bz/BAjl](http://mng.bz/BAjl)),
    referencing the phrase “nasal demons” (from the Usenet group `comp.std.c`) used
    to mean “unexpected behavior of a C compiler on encountering an undefined construct.”
    No one has ever reported demons flying out of their nose because of undefined
    behavior, but strange things do happen. Sometimes the as if rule means the compiler
    can optimize our code, which is a good thing, while sometimes it means we have
    undefined behavior, which is a bad thing. In either case, notice as if in the
    documentation.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: CppReference ([https://en.cppreference.com/w/cpp/chrono/time_point](https://en.cppreference.com/w/cpp/chrono/time_point))
    表示 `time_point` 是 *仿佛* 存储了一个 `duration` 类型的值，表示从 `Clock` 的纪元开始的时间间隔。我们还没有见过 *纪元*
    这个词。如果你之前使用过 C 的 `time_t`，你将熟悉从给定时刻（或纪元）开始计数滴答的想法，比如 1970 年 1 月的开始。其他系统从不同的时刻开始。例如，Windows
    上的 Excel 使用 1900 年 1 月的开始（[http://mng.bz/ddl1](http://mng.bz/ddl1)）。更重要的是，注意 *仿佛*
    这个短语，它在 C++ 中经常出现。仿佛 *规则* 允许编译器在某些情况下重新排序指令或完全删除它们，只要程序的观察行为不会改变。对于一个时钟，实际的实现可以存储任何它喜欢的东西，只要它表现得仿佛存储了一个持续时间。编译器也可以在其他情况下重新排序或删除指令。如果一个程序读取了一个未初始化的变量，编译器也可以做任何事情，因为这通常是未定义的行为，通常简称为
    UB。Ovle Maudel 之前写了一篇名为“Demons may fly out of your nose”的短文（[http://mng.bz/BAjl](http://mng.bz/BAjl)），引用了“nasal
    demons”（来自 Usenet 群组 `comp.std.c`）这个短语，用来表示“C 编译器在遇到未定义构造时的意外行为。”没有人报告过因为未定义行为而鼻子里的鬼飞出来，但奇怪的事情确实发生了。有时仿佛规则意味着编译器可以优化我们的代码，这是好事，而有时它意味着我们有未定义的行为，这是坏事。在两种情况下，注意文档中的“仿佛”。
- en: The `time_point` also uses a `Clock` class, and CppReference says this must
    meet the *requirements* for `Clock`. Now it is down to us to ensure the clock
    we use does this; otherwise, we might end up with nasal demons. Some of the operations
    could work if a “not-quite-clock” is used, so this requirement will be dropped
    by C++23 ([http://mng.bz/lVBR](http://mng.bz/lVBR)).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`time_point` 也使用了一个 `Clock` 类，根据 CppReference 的说明，这必须满足 `Clock` 的 *要求*。现在，确保我们使用的时钟满足这些要求的责任就落在了我们身上；否则，我们可能会遇到鼻涕鬼。如果使用一个“不太像时钟”的东西，一些操作可能仍然可以工作，因此这个要求将在
    C++23 中被取消（[http://mng.bz/lVBR](http://mng.bz/lVBR)）。'
- en: The word *requirements* also crops up frequently and forms part of the *concepts*
    language feature. We saw the separation between containers, such as a `vector`
    and algorithms, back in chapter 2\. The separation is possible through templates.
    The algorithms are generic and therefore able to be used for different types,
    operating on a range of elements. Templates allow a form of *duck typing*, a phrase
    often applied to dynamic languages, but equally applicable when we use templates
    at compile time in C++. Stack Overflow ([http://mng.bz/D95g](http://mng.bz/D95g))
    gives a splendid example
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 词语 *要求* 也经常出现，并构成了 *概念* 语言特性的一个部分。我们在第 2 章中看到了容器，如 `vector` 和算法之间的分离。这种分离是通过模板实现的。算法是通用的，因此可以用于不同类型，在一系列元素上操作。模板允许一种形式的
    *鸭子类型*，这是一个经常应用于动态语言的短语，但在我们使用 C++ 中的编译时模板时也同样适用。Stack Overflow ([http://mng.bz/D95g](http://mng.bz/D95g))
    提供了一个精彩的例子。
- en: '[PRE38]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: to illustrate the phrase “If it looks like a duck and quacks like a duck, it’s
    a duck,” hence the name duck typing. If we try to pass an object without a `Quack`
    function, we get a compiler error, which may or may not be helpful. If we had
    a way to specify that the object requires a `Quack` function, along the lines
    of
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 来说明“如果它看起来像鸭子，叫声像鸭子，那么它就是鸭子”的短语，因此得名鸭子类型。如果我们尝试传递一个没有 `Quack` 函数的对象，我们会得到编译器错误，这可能是有用的，也可能不是。如果我们有方法来指定对象需要
    `Quack` 函数，类似于
- en: '[PRE39]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: the compiler could stop immediately and let us know if the object used had no
    `Quack` method.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用的对象没有 `Quack` 方法，编译器可以立即停止并通知我们。
- en: Using a clearer function name than `f`, if we have
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用比 `f` 更清晰的函数名，如果我们有
- en: '[PRE40]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: and call it like this
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 并这样调用它
- en: '[PRE41]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: we will get an error. According to Visual Studio 2022, "`left` `of` `'.Quack'`
    `must` `have` `class/struct/union".` In this case, it isn’t so hard to track down
    what the problem is, but a requirement, specified by using a `requires` clause,
    will make the problem clearer. To specify that the `Quack` function must exist,
    we can write a *concept*, giving a name to our *requirement* and adding it to
    the function signature.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到错误。根据 Visual Studio 2022，错误信息是 "`left` `of` `'.Quack'` `must` `have` `class/struct/union"`。在这种情况下，找到问题并不那么困难，但使用
    `requires` 子句指定的要求会使问题更清晰。为了指定 `Quack` 函数必须存在，我们可以在函数签名中写一个 *概念*，为我们的 *要求* 命名并将其添加到函数签名中。
- en: Listing 4.6 Writing and using a concept
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.6 编写和使用概念
- en: '[PRE42]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: ❶ Names our requirement
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 命名我们的要求
- en: ❷ Specifies what we require
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 指定我们所需的内容
- en: ❸ States T must Quack
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 声明 T 必须实现 Quack
- en: The concept names the idea “`T` must have a `Quack` function” we wanted. When
    we use it, we do not need to spell out
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 概念命名了我们想要的想法“`T` 必须有一个 `Quack` 函数”。当我们使用它时，我们不需要明确
- en: '[PRE43]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'in full. We can be more succinct if we use `auto`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 完整地。如果我们使用 `auto`，我们可以更简洁地表达：
- en: '[PRE44]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In either case, `must_be_a_duck(42)` and `also_must_be_a_duck(42)` still cause
    an error, but this time, Visual Studio 2022 says
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，`must_be_a_duck(42)` 和 `also_must_be_a_duck(42)` 仍然会导致错误，但这次，Visual Studio
    2022 会说
- en: '[PRE45]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The message is much more helpful. Let’s get back to times and countdowns.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 消息会更加有用。让我们回到时间和倒计时。
- en: C++20 introduced several named requirements in the `concepts` header. To satisfy
    the clock requirements, the following four types must be defined
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: C++20 在 `concepts` 头文件中引入了几个命名要求。为了满足时钟要求，必须定义以下四种类型
- en: '`rep`'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rep`'
- en: '`period`'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`period`'
- en: '`duration`'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`duration`'
- en: '`time_point`'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`time_point`'
- en: and the clock must also support `is_steady` and `now()`. `chrono` provides a
    *type trait* called `is_clock` to check whether the requirements are met. Traits
    describe properties of a type, and we will revisit them in chapter 6\. The `is_clock`
    trait has a Boolean member called `value`, which reports if a type satisfies the
    requirements. If we apply this to an `int`
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 时钟还必须支持 `is_steady` 和 `now()`。`chrono` 提供了一个名为 `is_clock` 的类型特性，用于检查是否满足要求。特性描述了类型的属性，我们将在第
    6 章中重新讨论它们。`is_clock` 特性有一个名为 `value` 的布尔成员，它报告类型是否满足要求。如果我们将其应用于一个 `int`
- en: '[PRE46]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: the `value` is false because `int` is not a clock. Although the `time_point`
    itself does not enforce the requirement, other functions using `time_points` might.
    When the requirements are used, the compiler can indicate the problem with a message
    such as `'Clock` `type` `required'` exactly where the wrong type is used. The
    clock requirements can therefore give clearer compiler error messages.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`value` 是错误的，因为 `int` 不是一个时钟。尽管 `time_point` 本身并不强制要求，但使用 `time_points` 的其他函数可能会强制要求。当使用这些要求时，编译器可以通过类似
    `''Clock` `type` `required''` 这样的消息来指出错误类型的使用位置。因此，时钟要求可以提供更清晰的编译器错误信息。'
- en: 'More generally, requirements and concepts help to give better diagnostics when
    code using templates does not compile. In the last chapter, we used `auto` in
    listing 3.15 to pass a message provider:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 更普遍地，要求和概念有助于在模板代码无法编译时提供更好的诊断。在上一章中，我们在列表 3.15 中使用了 `auto` 来传递消息提供者：
- en: '[PRE47]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We started with an `std::function` but needed something more general. The function
    tries to call or *invoke* the `message` parameter. If we passed something that
    is not invocable, we would get an error when the message is used, a distance from
    where we passed something inappropriate. For example, calling
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 `std::function` 开始，但需要更通用的东西。函数尝试调用或 *调用* `message` 参数。如果我们传递了一个不可调用的东西，当使用消息时，我们会得到错误，错误发生在我们传递不适当的东西的地方。例如，调用
- en: '[PRE48]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'from `main` would complain inside the function. Visual Studio 2022 says, `"term
    does not evaluate to a function taking two arguments"`; the term being “Help!”
    We can add `invocable` from the `concept` header to the function signature, stating
    the message should be callable with two `ints`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数内部会报错。Visual Studio 2022会说，“`term does not evaluate to a function taking
    two arguments`”；这里的术语是“Help！”我们可以从`concept`头文件中添加`invocable`到函数签名中，表示消息应该可以用两个`int`调用：
- en: '[PRE49]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: With this addition, the compiler pinpoints the problem more precisely. Visual
    Studio 2022 says, `"message` `:` `'guess_number_with_clues':` `the associated
    constraints are` `not` `satisfied"`. Rather than just telling us a term is wrong,
    it has stated which parameter is wrong and why.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个添加，编译器可以更精确地定位问题。Visual Studio 2022会说，“`message`：`guess_number_with_clues`：`the
    associated constraints are not satisfied`”。它不仅告诉我们一个术语是错误的，而且还指出了哪个参数是错误的以及原因。
- en: We have only scratched the surface here. Watch out for the word requirements,
    try out some of the other concepts, and try writing your own. Now that we have
    a better understanding of clocks and durations, we will improve our countdown
    to the last day of the year by reporting back the duration in various units.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里只是触及了表面。注意要求，尝试一些其他的概念，并尝试编写自己的代码。现在我们更好地理解了时钟和持续时间，我们将通过报告各种单位的时间来改进到年底的最后一天的倒计时。
- en: 4.2.5 How many days until the last day of the year?
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.5 到年底的最后一天还有多少天？
- en: In listing 4.2, we found the current time and used a `year_month_day`, hardcoding
    each value, including the year, to calculate
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在4.2列表中，我们找到了当前时间并使用`year_month_day`，包括年份在内的每个值都进行了硬编码，来计算
- en: '[PRE50]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We printed out the value, but we got a huge number in fractions of a second.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打印出了这个值，但得到了一个以秒为单位的巨大数字。
- en: We can now convert this to a duration in days and also use the current year
    instead of hardcoding 2022\. Starting with the current `time_point` from `system_clock`’s
    `now` method gives us a date and time. We cannot assign this directly to a `year_month_day`
    because this would lose the time part. We can explicitly truncate the time part
    by flooring `now` first; then we can create another `year_month_day` object and
    find out the current year. Pulling this together, we can find out how many days
    there are until the last day of the year.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将这个时间转换为天数，并且可以使用当前年份而不是硬编码2022年。从`system_clock`的`now`方法开始的当前`time_point`给我们一个日期和时间。我们不能直接将其分配给`year_month_day`，因为这会丢失时间部分。我们可以通过先对`now`进行下取整来显式截断时间部分；然后我们可以创建另一个`year_month_day`对象并找出当前年份。将这些组合起来，我们可以找出一年中最后一天还有多少天。
- en: Listing 4.7 Finding how many days there are until the last day of the year
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.7 查找到年底的最后一天还有多少天
- en: '[PRE51]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: ❶ Floors now to days
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将`now`下取整到天数
- en: ❷ Uses the current year
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用当前年份
- en: ❸ Converts to days
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 转换为天数
- en: 'Running this code tells us how many days there are until the last day of the
    year:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这段代码会告诉我们离年底的最后一天还有多少天：
- en: '[PRE52]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Calling the stream insertion `operator<<` adds a `''d''`suffix to the number.
    As we noted earlier, just after listing 4.2, some older compilers do not support
    the `operator <<`, so we would either need to use the `date` library instead or
    call `count` and spell out the units ourselves:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 调用流插入`operator<<`会给数字添加一个`'d'`后缀。正如我们之前在4.2列表之后所提到的，一些较旧的编译器不支持`operator <<`，所以我们可能需要使用`date`库或者调用`count`并自己拼写单位：
- en: '[PRE53]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We have our countdown to the last day of the year, but there is still more to
    learn. We can now write a different countdown, using the `last` operator from
    `chrono`, to find the last Friday in a month. Maybe you get paid then, so finding
    out how many days to payday could be useful.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有了到年底的最后一天的倒计时，但还有更多东西要学习。现在我们可以使用`chrono`中的`last`运算符来编写不同的倒计时，以找到一个月中的最后一天星期五。也许你那时会收到工资，所以找出离发工资还有多少天可能很有用。
- en: 4.2.6 Using last to find how long to payday
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.6 使用`last`来查找到发工资还有多少天
- en: 'December always has 31 days, but we could use `last` instead:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 12月总是有31天，但我们可以使用`last`来代替：
- en: '[PRE54]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This is useful if we want to find the last day of February, which could be
    the 28^(th) or 29^(th). We could try to work this out ourselves, but `chrono`
    does the work for us. `last` was introduced in C++20\. It is an instance of a
    very simple `struct`, known as a *tag type* ([http://mng.bz/NVax](http://mng.bz/NVax)):'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想找到2月的最后一天，这可能是28号或29号。我们可以尝试自己解决这个问题，但`chrono`会为我们完成这项工作。`last`是在C++20中引入的。它是一个非常简单的`struct`实例，称为*标签类型*
    ([http://mng.bz/NVax](http://mng.bz/NVax))：
- en: '[PRE55]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Tag types are used to help pick overloads of functions. Operator slash—`operator/`—has
    many overloads, including several taking a `last_spec`. For example:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 标签类型用于帮助选择函数的重载。运算符斜杠—`operator/`—有多个重载，包括几个接受`last_spec`的。例如：
- en: '[PRE56]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Each `operator/` takes two parameters. We had a year, month, and `last`, so
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`operator/`接受两个参数。我们有一个年份、月份和`last`，所以
- en: '[PRE57]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'is using the operator twice:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 使用运算符两次：
- en: '[PRE58]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: First, we combine the year and month to get a `year_month`, and that value is
    used with the `last` struct to create a `year_month_day_last`. We can use C++
    Insights again to hint at what’s hiding under the hood when we use
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将年份和月份组合起来得到`year_month`，然后这个值与`last`结构一起用于创建`year_month_day_last`。我们可以再次使用C++
    Insights来提示当我们使用
- en: '[PRE59]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The insight generated is
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的洞察是
- en: '[PRE60]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: (See [https://cppinsights.io/s/84b34f6d](https://cppinsights.io/s/84b34f6d).)
    The two `operator/` calls are made obvious, and they give us a `year_month_day_last`
    type. C++ Insights has a link to the Compiler Explorer, which will show us more
    ([https://godbolt.org/z/qroM6xoT1](https://godbolt.org/z/qroM6xoT1)). In figure
    4.2, we can see that the value of the day has not been calculated.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: （见[https://cppinsights.io/s/84b34f6d](https://cppinsights.io/s/84b34f6d)。）两个`operator/`调用是明显的，并且它们给我们一个`year_month_day_last`类型。C++
    Insights有一个链接到编译器探索器，它将显示更多（[https://godbolt.org/z/qroM6xoT1](https://godbolt.org/z/qroM6xoT1)）。在图4.2中，我们可以看到日期的值尚未计算。
- en: '![CH04_F02_Buontempo](../Images/CH04_F02_Buontempo.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F02_Buontempo](../Images/CH04_F02_Buontempo.png)'
- en: Figure 4.2 Output for GCC 12.2 on the Compiler Explorer
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 GCC 12.2在编译器探索器上的输出
- en: We can see instructions on the left and operands on the right. The actual instructions
    vary between dialects. In figure 4.2, move, spelled `mov`, moves data between
    a register and memory, so `mov` `rbp`, `rsp` moves what was pushed to `rbp` to
    `rsp`. `eax` is another register, used for returned values. `push` pushes operands
    onto the stack. `pop` pops them. The instruction `ret` returns from a function.
    Jason Turner’s C++ Weekly episode 34 introduces reading assembly language, if
    you want more details (see [https://www.youtube.com/watch?v=my39Gpt6bvY](https://www.youtube.com/watch?v=my39Gpt6bvY)).
    You don’t need to be able to read assembly code to see that we have a 2023 and
    a 12, but no 31\. The value 31 is not required when `year_month_day_last` is created.
    Until we try to find out the day or stream this out, we do not care. The `chrono`
    library makes a huge effort to be as efficient as possible.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在左侧看到指令，在右侧看到操作数。实际的指令在不同方言之间有所不同。在图4.2中，`mov`（移动）指令在寄存器和内存之间移动数据，所以`mov
    rbp, rsp`将`rbp`中推入的数据移动到`rsp`。`eax`是另一个寄存器，用于返回值。`push`将操作数推入堆栈。`pop`弹出它们。指令`ret`从函数返回。Jason
    Turner的C++ Weekly第34集介绍了阅读汇编语言，如果您想了解更多细节（见[https://www.youtube.com/watch?v=my39Gpt6bvY](https://www.youtube.com/watch?v=my39Gpt6bvY)）。您不需要能够阅读汇编代码就能看出我们有一个2023和一个12，但没有31。当创建`year_month_day_last`时，31这个值是不需要的。除非我们试图找出这一天或将其流出，否则我们并不关心。`chrono`库做出了巨大的努力，以尽可能高效。
- en: 'Having looked briefly under the hood for a few more details on how to create
    a date, we will now use `last` a bit more for practice. The `last struct` will
    tell us the date of the last day of February, as we noted:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在简要查看内部细节以获取更多关于如何创建日期的详细信息后，我们现在将使用`last`进行更多练习。`last struct`将告诉我们二月的最后一天，正如我们之前所提到的：
- en: '[PRE61]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The 28^(th) or 29^(th) is not calculated unless used. We can use `last` in other
    ways too. Chrono also provides a `weekday_last`, which can be used in conjunction
    with a `weekday_indexed`. We can use these directly or use the `operator[]` ([http://mng.bz/E96D](http://mng.bz/E96D))
    to find the first Monday of the year or the last Friday of a month. To find the
    last Friday, or indeed any specific day of a month, we say
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 28^(th)或29^(th)除非使用，否则不会计算。我们也可以以其他方式使用`last`。Chrono还提供了一个`weekday_last`，它可以与`weekday_indexed`一起使用。我们可以直接使用这些，或者使用`operator[]`
    ([http://mng.bz/E96D](http://mng.bz/E96D))来找到一年的第一个星期一或一个月的最后一天星期五。要找到最后一天星期五，或者确实任何一个月的特定一天，我们可以说
- en: '[PRE62]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: If we stream this out, we get
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将其流出，我们得到
- en: '[PRE63]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Again, the `last` is used to pick an appropriate overload and does no calculations.
    We still need to say the month because `last` applies to days or weekdays. We
    could also say `Friday[1]` to find the first Friday. A `weekday_indexed` takes
    a value in the `range[1,` `5]` to mean the first, second, third, fourth, or fifth
    weekday of some month, so it is 1 rather than 0 based.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，`last`用于选择合适的重载，并不进行计算。我们仍然需要说出月份，因为`last`适用于天数或星期。我们也可以说`Friday[1]`来找到第一个星期五。`weekday_indexed`接受一个在`range[1,`
    `5]`中的值，表示某个月份的第一、第二、第三、第四或第五个工作日，因此它是基于1而不是0。
- en: Let’s write another countdown. Suppose you get paid on the last Friday of the
    month. How many days until payday? We have all the parts we need. Armed with the
    current time and the last Friday of the current month, we can use `sys_days` like
    we did before to make a date and then find the duration.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再写一个倒计时。假设你每月的最后一天周五领取工资。距离发工资还有多少天？我们已经有了所有需要的部分。有了当前时间和本月的最后一个周五，我们可以像之前一样使用
    `sys_days` 来创建一个日期，然后找到持续时间。
- en: Listing 4.8 Days until payday
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.8 发工资前的天数
- en: '[PRE64]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: ❶ Current year, month, day
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 当前年份、月份、日期
- en: ❷ Last Friday of the current month
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 当前月份的最后一个周五
- en: ❸ Subtract to find the days until payday.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 减去以找到发工资的天数。
- en: Five days to go at the time of writing, and possibly a few hours, but we rounded
    down by using `duration_cast`. We have two countdowns and have covered a lot of
    ground. We haven’t written any tests, though. Let’s pause to think about how to
    test code using times and dates.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 写作时还有五天，可能还有几个小时，但我们使用 `duration_cast` 进行了向下取整。我们有两个倒计时，已经覆盖了很多内容。尽管如此，我们还没有编写任何测试。让我们停下来思考如何使用时间和日期来测试代码。
- en: 4.2.7 Writing testable code
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.7 编写可测试的代码
- en: We could stop here, as we have the countdown we set out to make and more. However,
    this code writes the output straight to the screen, which makes it hard to test.
    It also uses the current date and time directly, which often causes problems in
    tests. We can do better. Once we have improved the code, we will call it in a
    loop to watch time ticking down to the end of the year.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这里停止，因为我们已经得到了我们想要制作的倒计时以及更多。然而，这段代码直接将输出写入屏幕，这使得测试变得困难。它还直接使用当前日期和时间，这在测试中经常引起问题。我们可以做得更好。一旦我们改进了代码，我们将在循环中调用它，以观察时间倒计时到年底。
- en: If we return the duration, the calling code can do what it wants with the value,
    and this makes testing the code easier. If we also pass in the value of `now`,
    we can vary the time for tests. Calling the current time inside a function makes
    it notoriously hard to test. At the extreme, I watched someone write a test that
    they claimed would take 24 hours to run because they wanted to check the difference
    between results over a day in a financial calculation. I suggested passing in
    the required times, rather than calling `now` and waiting for a day. You probably
    have similar stories too.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们返回持续时间，调用代码可以使用该值做任何它想做的事情，这使得测试代码更容易。如果我们还传入 `now` 的值，我们可以改变测试的时间。在函数内部调用
    `now` 是众所周知地难以测试的。在极端情况下，我见过有人写了一个他们声称需要 24 小时才能运行的测试，因为他们想在金融计算中检查一天内结果之间的差异。我建议传入所需的时间，而不是调用
    `now` 并等待一天。你可能也有类似的故事。
- en: Our testable countdown will return the duration. In addition, if we mark the
    function as `constexpr`, we can use a static assert in some tests. Let’s use `last`
    instead of 31 this time for practice. Apart from sending in the current date-time,
    the code is similar to the code in listing 4.7, but more flexible.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的可测试倒计时将返回持续时间。此外，如果我们将函数标记为 `constexpr`，我们可以在某些测试中使用静态断言。这次我们用 `last` 代替
    31 来练习。除了发送当前日期和时间之外，代码与列表 4.7 中的代码类似，但更加灵活。
- en: Listing 4.9 A testable countdown
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.9 一个可测试的倒计时
- en: '[PRE65]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: ❶ Possible at compile time
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在编译时可能
- en: ❷ Passes in a time point
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 传入一个时间点
- en: ❸ Returns a duration
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 返回一个持续时间
- en: We can now test our function more easily and even use `static_assert` to provoke
    compile time errors like we have done before.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以更容易地测试我们的函数，甚至可以使用 `static_assert` 来引发编译时错误，就像我们之前做的那样。
- en: Listing 4.10 Checking the countdown function
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.10 检查倒计时函数
- en: '[PRE66]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: ❶ Uses constexpr for compile time expressions
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 constexpr 进行编译时表达式
- en: ❷ Uses static_assert to test at compile time
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用 static_assert 在编译时进行测试
- en: We have covered several central C++ ideas so far. We can sit back and watch
    some time tick by if we call our countdown on a loop and show seconds instead
    of days. If we include the `thread` header, we can `sleep` for a while between
    each call, using the `chrono` literals to specify how long for (e.g., `5000ms)`.
    That’s quite nice, don’t you think? Try it out!
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了几个核心的 C++ 概念。如果我们在一个循环中调用我们的倒计时并显示秒而不是天数，我们可以坐下来观看时间的流逝。如果我们包含 `thread`
    头文件，我们可以在每次调用之间 `sleep` 一段时间，使用 `chrono` 文字面量来指定多长时间（例如，`5000ms`）。这相当不错，不是吗？试试看！
- en: Listing 4.11 Calling the countdown in a loop
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.11 在循环中调用倒计时
- en: '[PRE67]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: ❶ Uses ms from std::chrono
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 std::chrono 中的 ms
- en: ❷ Shows how many seconds
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 显示多少秒
- en: 'If we run this, we see seconds until the end of the year tick down for a while:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个程序，我们会看到距离年底的秒数逐渐减少：
- en: '[PRE68]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We hardcoded New Year’s Eve, initially with a fixed year, and then learned how
    to generalize to the current year. We also saw how to find how long it is until
    the last Friday of a month. We haven’t read in a date yet, though.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最初使用固定的年份硬编码了新年除夕，然后学习了如何将其泛化到当前年份。我们还看到了如何找到到一个月最后一个星期五的时间。尽管如此，我们还没有读取日期。
- en: 4.3 Input, output, and formatting
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 输入、输出和格式化
- en: If we input an event date, we can make our countdown more general. How do we
    read a date from a stream?
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们输入一个事件日期，我们可以使倒计时更加通用。我们如何从流中读取日期？
- en: 4.3.1 Parsing a date
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.1 解析日期
- en: We can use the `parse` method from `chrono` to read a date. This is supported
    in Visual Studio 2022, but the latest Clang and GCC do not support the method,
    so you will need to use the date library mentioned at the end of section 4.1\.
    Again, include "`date/date.h"` from the library and change `std::chrono::parse`
    to `date::parse` in what follows. Don’t forget to use the `-I` switch to point
    to your cloned `date/include` directory.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用来自 `chrono` 的 `parse` 方法来读取日期。这在 Visual Studio 2022 中受支持，但最新的 Clang 和
    GCC 不支持此方法，因此您需要使用 4.1 节末提到的日期库。再次提醒，包含库中的 "`date/date.h"` 并将接下来的 `std::chrono::parse`
    改为 `date::parse`。别忘了使用 `-I` 开关指向您克隆的 `date/include` 目录。
- en: 'We can choose the format required; for example, `%Y-%m-%d` for a hyphen-separated
    four-digit year, month, and day:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以选择所需的格式；例如，使用 `%Y-%m-%d` 格式来表示用连字符分隔的四位年份、月份和日期：
- en: '[PRE69]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: If the format entered does not match the expected format, the stream is in error,
    which we can check for.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入的格式与预期格式不匹配，则流处于错误状态，我们可以检查这一点。
- en: 'We could also use the `from_stream` method, which takes the stream as a parameter,
    like this:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用 `from_stream` 方法，该方法接受流作为参数，如下所示：
- en: '[PRE70]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: There are several overloads for `parse` and `from_stream` to cover times, including
    `sys_time`, and the year, a month, a day, and so on. In essence, each overload
    of `parse` maps to a corresponding `from_stream`, so you can use whichever suits
    you.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`parse` 和 `from_stream` 函数有几个重载，用于处理时间，包括 `sys_time` 以及年、月、日等。本质上，每个 `parse`
    重载都映射到相应的 `from_stream`，因此您可以使用适合您的方法。'
- en: We can add a function using the `parse` method to allow a user to enter an event
    date and report back how long until this happens. The input might be invalid,
    so we need a way to deal with that situation. In listing 3.4, we wrote a function
    called `read_number`, taking an `std::istream` and returning an `std::optional<int>`
    to handle invalid input. We can use a similar pattern here, clearing invalid input
    if something goes wrong. While we have literals fresh in our mind, we will use
    the `operator""s` to make the format an `std::string.` We do not *need* to do
    this because a format specifier of `"%Y-%m-%d"` works, but it’s worth knowing
    how to make a string directly. This operator lives in the `std::string_literals`
    namespace in the `string` header, so we need to include this header. We also need
    to include the `optional` header so we can write the following function to read
    a date.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加一个使用 `parse` 方法的函数，允许用户输入事件日期并报告还有多长时间发生。输入可能无效，因此我们需要一种处理这种情况的方法。在列表
    3.4 中，我们编写了一个名为 `read_number` 的函数，它接受一个 `std::istream` 并返回一个 `std::optional<int>`
    来处理无效输入。我们可以在这里使用类似的模式，如果出现问题，清除无效输入。当我们在脑海中保留字面量时，我们将使用 `operator""s` 来使格式成为一个
    `std::string`。我们并不 *需要* 做这件事，因为 `"%Y-%m-%d"` 格式指定符就可以工作，但了解如何直接创建字符串是有价值的。此操作符位于
    `string` 头文件中的 `std::string_literals` 命名空间中，因此我们需要包含此头文件。我们还需要包含 `optional` 头文件，以便我们可以编写以下函数来读取日期。
- en: Listing 4.12 Reading a date
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.12 读取日期
- en: '[PRE71]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: ❶ Uses ""s to create a string
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 ""s 创建字符串
- en: ❷ Is the input valid?
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 输入是否有效？
- en: ❸ Returns a valid date
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 返回有效日期
- en: ❹ Clears invalid input
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 清除无效输入
- en: ❺ Returns optional with no value
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 返回无值的可选类型
- en: In listing 4.9, we used a hardcoded event date in the `countdown` function,
    so we need a new function that takes the date a user provides. If you are using
    the `date` library instead of `chrono`, switch the `using` namespace in the next
    listing to
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 4.9 中，我们在 `countdown` 函数中使用了硬编码的事件日期，因此我们需要一个新函数来接受用户提供的日期。如果您正在使用 `date`
    库而不是 `chrono`，则在下一个列表中将 `using` 命名空间切换为
- en: '[PRE72]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: instead. Pass in the chosen date as a second parameter.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是。将选定的日期作为第二个参数传递。
- en: Listing 4.13 Countdown to any event
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.13 到任何事件的倒计时
- en: '[PRE73]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: By reading in a date, we can make a general-purpose countdown. We should think
    about how we want to display the output because this gives us another opportunity
    to use `format`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 通过读取日期，我们可以创建一个通用的倒计时。我们应该考虑我们想要如何显示输出，因为这给我们另一个使用 `format` 的机会。
- en: 4.3.2 Formatting time points and durations
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.2 格式化时间点和持续时间
- en: We can call the countdown from listing 4.13 from `main` once we have read in
    the chosen event date. If we get input into a string, we don’t need to mop up
    any invalid characters, as they have been read into the string. Because we get
    an optional value back, we check that this is okay before calling our countdown.
    If we want the output in days, we need to cast the duration to days.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们读取了所选事件日期后，我们可以从`main`中调用列表4.13中的倒计时。如果我们把输入读入一个字符串，我们不需要清理任何无效字符，因为它们已经被读入字符串中。因为我们返回的是一个可选值，我们在调用我们的倒计时之前检查这个值是否正确。如果我们想要以天为单位输出，我们需要将持续时间转换为天数。
- en: Listing 4.14 A general-purpose countdown
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.14 一个通用倒计时
- en: '[PRE74]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: ❶ Reads all input into a string
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将所有输入读入一个字符串
- en: ❷ Checks that we got a valid date
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 检查我们是否得到了一个有效的日期
- en: ❸ Casts to days
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 转换为天数
- en: 'Of course, we could use any other time period. Furthermore, we can use `std::format`
    instead of a `duration` or `time_point`. This gives us a choice about how to report
    the duration, as well as how to display the date. If we want the duration in seconds,
    we use `:%S`, and for a four-digit year, followed by a month, then a day, we can
    either use `:%Y-%m-%d` or the shortcut `:%F`:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也可以使用任何其他时间段。此外，我们可以使用`std::format`而不是`duration`或`time_point`。这让我们可以选择如何报告持续时间，以及如何显示日期。如果我们想要以秒为单位报告持续时间，我们使用`:%S`，而对于四位数的年份，然后是月份，然后是日期，我们可以使用`:%Y-%m-%d`或快捷方式`:%F`：
- en: '[PRE75]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Several format strings are available for durations and time points (see [http://mng.bz/84gW).](http://mng.bz/84gW)
    If you can’t find what you need, you can drop back to the duration casts we initially
    used or pull out parts of the date you need from a time point. The `chrono` library
    is powerful and flexible, and there is usually more than one way to do what you
    need.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 可用于持续时间和时间点的格式字符串有很多（见[http://mng.bz/84gW)）。](http://mng.bz/84gW) 如果找不到所需的内容，可以退回到最初使用的持续时间转换，或者从时间点中提取所需的日期部分。`chrono`库功能强大且灵活，通常有多种方法可以实现所需的功能。
- en: We have a countdown; in fact, we have a few countdowns. Now, it’s all very well
    reporting how many seconds until an event; however, if daylight savings happens
    between now and then, our output will be incorrect. The system clock works in
    coordinated universal time (UTC), so we need to use a time zone to take local
    time into account.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个倒计时；实际上，我们有几个倒计时。现在，报告事件还有多少秒是非常好的；然而，如果在这之间发生夏令时，我们的输出将是不正确的。系统时钟使用协调世界时（UTC），因此我们需要使用时区来考虑本地时间。
- en: 4.4 Time zones
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 时区
- en: British Summer Time (BST) began at 2 a.m. on March 27 in 2022\. If we call our
    general `countdown_to` method to find out how many hours there are between 3 a.m.
    on 27^(th) and the next day
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 2022年3月27日凌晨2点开始实行英国夏令时（BST）。如果我们调用我们的通用`countdown_to`方法来找出从27日凌晨3点到第二天之间有多少小时
- en: '[PRE76]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: we get 21 hours, 3 hours less than a full 24-hour day. On the face of it, this
    is fine; however, our countdown is taking the current time in UTC. In BST, it
    would be 4 a.m., and so there would only be 20 hours left. C++20 introduced time
    zones, but they are not widely supported. Visual Studio 2022 and GCC 13.2.0 do
    support them, but at the time of writing, Clang does not as yet. If you cloned
    the date library earlier, you need to use the `tz.cpp` file from the library to
    use the time zones. We have only used features in the header file so far, but
    the time zones need this source file too. Rainer Grimm’s website has instructions
    for compiling and using the library ([http://mng.bz/9Qe0](http://mng.bz/9Qe0)),
    as do Howard Hinnant’s GitHub pages ([http://mng.bz/K9XE](http://mng.bz/K9XE)).
    You also need to use namespace `date` instead of `chrono`.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到21小时，比一个完整的24小时少3小时。表面上看起来这是可以的；然而，我们的倒计时正在使用UTC的当前时间。在BST（英国夏令时）中，这将是在凌晨4点，因此只剩下20小时。C++20引入了时区，但它们并不被广泛支持。Visual
    Studio 2022和GCC 13.2.0支持它们，但在撰写本文时，Clang还没有支持。如果您之前克隆了日期库，您需要使用库中的`tz.cpp`文件来使用时区。到目前为止，我们只使用了头文件中的功能，但时区也需要这个源文件。Rainer
    Grimm的网站上有编译和使用库的说明([http://mng.bz/9Qe0](http://mng.bz/9Qe0))，同样，Howard Hinnant的GitHub页面也有([http://mng.bz/K9XE](http://mng.bz/K9XE))。您还需要使用`date`命名空间而不是`chrono`。
- en: 'We can convert a system time to a `zoned_time` using a time zone and calling
    `get_local_time`. We can choose a time zone by name and pair that with a time
    point to make a zoned time:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用时区将系统时间转换为`zoned_time`，通过调用`get_local_time`来实现。我们可以通过名称选择时区，并将其与一个时间点配对来创建一个时区时间：
- en: '[PRE77]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The names come from the Internet Assigned Numbers Authority (IANA) time zone
    (tz) database ([https://www.iana.org/time-zones](https://www.iana.org/time-zones)).
    If the location does not exist, we get an exception. Alternatively, we can use
    `current_zone()` to get the local time for the current time zone. If we stick
    with a function taking a system time and event date, and returning a duration
    like we had in listing 4.13, we need to convert the event to a `zoned_time` and
    find the difference in `sys_time`. Arithmetic with `local_time` ignores time shifts.
    For example, if we have a meeting at 9 a.m. local time every day, then adding
    one day in `local_time` gives 9 a.m. local the next day, even if there is an intervening
    UTC offset shift. We want to know the physical difference in time, so we use `sys_time`.
    The return type has the precision of the difference between the `event` and `now`,
    which is `system_clock::duration`:.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这些名称来自互联网名称与数字地址分配机构（IANA）的时间区域（tz）数据库（[https://www.iana.org/time-zones](https://www.iana.org/time-zones)）。如果位置不存在，我们将得到一个异常。或者，我们可以使用
    `current_zone()` 来获取当前时区的本地时间。如果我们坚持使用一个接受系统时间和事件日期的函数，并返回一个类似于列表 4.13 中的持续时间的函数，我们需要将事件转换为
    `zoned_time` 并在 `sys_time` 中找到差异。使用 `local_time` 的算术忽略了时间变化。例如，如果我们每天在当地时间上午 9
    点有一个会议，那么在 `local_time` 中添加一天将给出第二天上午 9 点的当地时间，即使存在中间的 UTC 偏移变化。我们想知道时间的物理差异，所以使用
    `sys_time`。返回类型具有 `event` 和 `now` 之间差异的精度，这是 `system_clock::duration`：
- en: Listing 4.15 Countdown in local time
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.15 本地时间倒计时
- en: '[PRE78]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: ❶ Event in local time converted to sys_time
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将本地时间事件转换为 sys_time
- en: ❷ Difference in physical time
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 物理时间的差异
- en: This countdown takes daylight savings into account.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这个倒计时考虑了夏令时。
- en: We have only scratched the surface of `chrono`. Howard Hinnant has written a
    list of examples ([http://mng.bz/0lnW](http://mng.bz/0lnW)) if you need to work
    out how to do something not covered here.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是刚刚触及了 `chrono` 的表面。如果需要了解如何完成这里未涵盖的内容，霍华德·欣南特（Howard Hinnant）已经编写了一个示例列表（[http://mng.bz/0lnW](http://mng.bz/0lnW)）。
- en: We practiced reading `input` and using `format` for output. We also used the
    literal suffix. One thing we have not done yet is written our own class, so we
    will do that in the next chapter, creating a deck of playing cards to make another
    game.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们练习了读取 `input` 和使用 `format` 进行输出。我们还使用了字面量后缀。我们还没有做过的事情是编写我们自己的类，所以我们将在下一章中这样做，创建一副扑克牌来制作另一个游戏。
- en: Summary
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: There are various clocks, each supporting a `now` method that returns a `time_point.`
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有各种时钟，每个都支持一个 `now` 方法，该方法返回一个 `time_point`。
- en: The system clock is not steady, so it might go backward if the system time is
    changed.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统时钟是不稳定的，所以如果系统时间发生变化，它可能会倒退。
- en: Use a `year_month_day` to access `year`, `month`, or `date` fields and turn
    it into a `time_point` using `sys_days`.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `year_month_day` 来访问 `year`、`month` 或 `date` 字段，并使用 `sys_days` 将其转换为 `time_point`。
- en: Durations are defined by a numeric type and a `ratio`, telling us which units
    they are in. An `std::ratio<1>` means seconds, while `std::ratio<60>` means minutes.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续时间由一个数值类型和一个 `ratio` 定义，告诉我们它们在哪个单位中。`std::ratio<1>` 表示秒，而 `std::ratio<60>`
    表示分钟。
- en: Durations can be implicitly converted if the conversion will not lose precision;
    otherwise, we must use a `duration_cast`.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果转换不会丢失精度，持续时间可以隐式转换；否则，我们必须使用 `duration_cast`。
- en: We can define our own durations.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以定义我们自己的持续时间。
- en: '`chrono` provides literal suffixes, such as `operator""s` for seconds.'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chrono` 提供了字面量后缀，例如 `operator""s` 用于秒。'
- en: We can use `operator/` to form a `year_month_day` using the literals to create
    dates, such as `2022y / December / last`.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用 `operator/` 通过字面量创建 `year_month_day` 来形成日期，例如 `2022y / December / last`。
- en: A time point consists of a clock and a duration.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间点由一个时钟和一个持续时间组成。
- en: Requirements can be used for templates to help provide clearer diagnostic messages
    when template code fails to compile.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用需求来为模板提供帮助，以便在模板代码无法编译时提供更清晰的诊断信息。
- en: A concept is a named set of requirements.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 概念是一组命名的需求。
- en: We can write dates and durations to streams using `operator<<`. Durations append
    the literal for their units; for example, `'d'` for days.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用 `operator<<` 将日期和持续时间写入流。持续时间附加其单位的字面量；例如，`'d'` 表示天数。
- en: Use `parse` or `from_stream` to read a date or time.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `parse` 或 `from_stream` 读取日期或时间。
- en: The `format` library also supports `time_point` and `duration`.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`format` 库还支持 `time_point` 和 `duration`。'
- en: System times can be converted to local zones using `current_zone()` or a named
    time zone and take daylight savings into account.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用 `current_zone()` 或一个命名时区将系统时间转换为本地时区，并考虑夏令时。
