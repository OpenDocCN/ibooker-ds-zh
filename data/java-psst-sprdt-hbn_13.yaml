- en: 10 Managing data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 管理数据
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了
- en: Examining the lifecycle and states of objects
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查对象的生命周期和状态
- en: Working with the EntityManager interface
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `EntityManager` 接口
- en: Working with detached state
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用分离状态
- en: You now understand how ORM solves the static aspects of the object/relational
    mismatch. With what you know so far, you can create a mapping between Java classes
    and an SQL schema, solving the structural mismatch problem. As you’ll recall,
    the paradigm mismatch covers the problems of granularity, inheritance, identity,
    association, and data navigation. For a deeper review, take a look back at section
    1.2.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经理解了 ORM 如何解决对象/关系不匹配的静态方面。根据你目前所知，你可以创建 Java 类和 SQL 模式之间的映射，从而解决结构不匹配问题。正如你将记得的，范式不匹配涵盖了粒度、继承、标识、关联和数据导航等问题。为了更深入地了解，请回顾第
    1.2 节。
- en: 'Beyond that, though, an efficient application solution requires something more:
    you must investigate strategies for runtime data management. These strategies
    are crucial to the performance and correct behavior of the applications.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，除此之外，一个高效的应用程序解决方案还需要更多：你必须研究运行时数据管理的策略。这些策略对于应用程序的性能和正确行为至关重要。
- en: In this chapter, we’ll analyze the lifecycle of entity instances—how an instance
    becomes persistent, and how it stops being considered persistent—and the method
    calls and management operations that trigger these transitions. The JPA `EntityManager`
    is the primary interface for accessing data.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将分析实体实例的生命周期——实例如何变得持久，以及它如何停止被视为持久，以及触发这些转换的方法调用和管理操作。JPA 的 `EntityManager`
    是访问数据的主要接口。
- en: Before we look at JPA, let’s start with entity instances, their lifecycle, and
    the events that trigger a change of state. Although some of this material may
    be formal, a solid understanding of the persistence lifecycle is essential.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看 JPA 之前，让我们从实体实例、其生命周期以及触发状态变化的触发事件开始。尽管其中一些材料可能是正式的，但对持久化生命周期的深入了解是必不可少的。
- en: Major new features in JPA 2
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: JPA 2 中的主要新特性
- en: We can get a vendor-specific variation of the persistence manager API with `EntityManager#unwrap()`,
    such as the `org.hibernate.Session` API. Use the already demonstrated `EntityManagerFactory#unwrap()`
    method to obtain an instance of `org.hibernate.SessionFactory` `(`see section
    2.5).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 `EntityManager#unwrap()` 获取持久化管理器 API 的供应商特定变体，例如 `org.hibernate.Session`
    API。使用已演示的 `EntityManagerFactory#unwrap()` 方法获取 `org.hibernate.SessionFactory`
    实例（参见第 2.5 节）。
- en: The new `detach()` operation provides fine-grained management of the persistence
    context, evicting individual entity instances.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `detach()` 操作提供了对持久化上下文的细粒度管理，可以逐个移除实体实例。
- en: From an existing `EntityManager`, we can obtain the `EntityManagerFactory` used
    to create the persistence context with `getEntityManagerFactory()`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 从现有的 `EntityManager` 中，我们可以通过 `getEntityManagerFactory()` 获取用于创建持久化上下文的 `EntityManagerFactory`。
- en: The new static `PersistenceUtil` and `PersistenceUnitUtil` helper methods determine
    whether an entity instance (or one of its properties) was fully loaded or is an
    uninitialized reference (a Hibernate proxy or an unloaded collection wrapper).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 新的静态 `PersistenceUtil` 和 `PersistenceUnitUtil` 辅助方法确定实体实例（或其实例的属性）是否已完全加载或是一个未初始化的引用（Hibernate
    代理或未加载的集合包装器）。
- en: 10.1 The persistence lifecycle
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1 持久化生命周期
- en: Because JPA is a transparent persistence mechanism, where classes are unaware
    of their own persistence capability, it is possible to write application logic
    that is unaware of whether the data it operates on represents a persistent state
    or a temporary state that exists only in memory. The application shouldn’t necessarily
    need to care that an instance is persistent when invoking its methods. We can,
    for example, invoke the `Item#calculateTotalPrice()` business method without having
    to consider persistence at all (such as in a unit test). The method may be unaware
    of any persistence concept while its executing.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 JPA 是一种透明的持久化机制，其中类对其自身的持久化能力一无所知，因此可以编写不知道其操作的数据代表持久状态还是仅存在于内存中的临时状态的逻辑。应用程序在调用其方法时不必一定关心实例是否持久。例如，我们可以调用
    `Item#calculateTotalPrice()` 业务方法而不必考虑任何持久化（例如在单元测试中）。在执行过程中，该方法可能对任何持久化概念一无所知。
- en: Any application with a persistent state must interact with the persistence service
    whenever it needs to propagate the state held in memory to the database (or vice
    versa). In other words, we have to call the Jakarta Persistence interfaces to
    store and load data.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 任何具有持久化状态的应用程序都必须在需要将内存中持有的状态传播到数据库（或反之亦然）时与持久化服务交互。换句话说，我们必须调用Jakarta Persistence接口来存储和加载数据。
- en: 'When interacting with the persistence mechanism that way, the application must
    concern itself with the state and lifecycle of an entity instance with respect
    to persistence. We refer to this as the *persistence lifecycle* : the states an
    entity instance goes through during its life, and we’ll analyze them in a moment.
    We also use the term *unit of work*: a set of (possibly) state-changing operations
    considered one (usually atomic) group. Another piece of the puzzle is the *persistence
    context* provided by the persistence service. Think of the persistence context
    as a service that remembers all the modifications and state changes we made to
    the data in a particular unit of work (this is somewhat simplified, but it’s a
    good starting point).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当以这种方式与持久化机制交互时，应用程序必须关注实体实例相对于持久化的状态和生命周期。我们称这为**持久化生命周期**：实体实例在其生命周期中经历的状态，我们将在稍后分析它们。我们还使用术语**工作单元**：一组（可能）改变状态的运算，被视为一个（通常是原子）组。拼图中的另一部分是持久化服务提供的**持久化上下文**。将持久化上下文想象成一个服务，它记得我们在特定工作单元中对数据进行的所有修改和状态变化（这有些简化，但是一个好的起点）。
- en: 'We’ll now dissect the following terms: *entity states*, *persistence contexts*,
    and *managed scope*. You’re probably more accustomed to thinking about which SQL
    statements you have to manage to get stuff in and out of the database, but one
    of the key factors of the success of Java Persistence is the analysis of *state
    management*, so stick with us through this section.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将剖析以下术语：**实体状态**、**持久化上下文**和**管理范围**。你可能更习惯于思考你需要管理哪些SQL语句来将数据放入和取出数据库，但Java持久化成功的关键因素之一是**状态管理**的分析，所以请跟随我们通过这一节。
- en: 10.1.1 Entity instance states
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.1 实体实例状态
- en: Different ORM solutions use different terminology and define different states
    and state transitions for the persistence lifecycle. Moreover, the states used
    internally may be different from those exposed to the client application. JPA
    defines four states, hiding the complexity of Hibernate’s internal implementation
    from the client code. Figure 10.1 shows these states and their transitions.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的ORM解决方案使用不同的术语，并为持久化生命周期定义不同的状态和状态转换。此外，内部使用的状态可能与客户端应用程序暴露的状态不同。JPA定义了四种状态，隐藏了Hibernate内部实现的复杂性，从而避免了客户端代码的复杂性。图10.1显示了这些状态及其转换。
- en: '![](../../OEBPS/Images/CH10_F01_Tudose2.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH10_F01_Tudose2.png)'
- en: Figure 10.1 Entity instance states and their transitions
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 实体实例状态及其转换
- en: Figure 10.1 also includes the method calls to the `EntityManager` (and `Query`)
    API that triggers transitions. We’ll discuss this chart in this chapter; refer
    to it whenever you need an overview.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1还包括调用`EntityManager`（和`Query`）API的方法调用，这些调用触发转换。我们将在本章中讨论此图表；在需要概述时请参考它。
- en: Now, let’s explore the states and transitions in more detail.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更详细地探讨状态和转换。
- en: Transient state
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 瞬时状态
- en: Instances created with the `new` Java operator are *transient*, which means
    their state is lost and garbage-collected as soon as they’re no longer referenced.
    For example, `new Item()` creates a transient instance of the `Item` class, just
    like `new Long``()` and `new BigDecimal()` create transient instances of those
    classes. Hibernate doesn’t provide any rollback functionality for transient instances;
    if we modify the price of a transient `Item`, we can’t automatically undo the
    change.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`new` Java运算符创建的实例是**瞬时的**，这意味着一旦不再被引用，它们的状态就会丢失并被垃圾回收。例如，`new Item()`创建了一个`Item`类的瞬时实例，就像`new
    Long()`和`new BigDecimal()`创建那些类的瞬时实例一样。Hibernate不提供任何对瞬时实例的回滚功能；如果我们修改瞬时`Item`的价格，我们无法自动撤销更改。
- en: For an entity instance to transition from transient to *persistent* state requires
    either a call to the `EntityManager#persist()` method or the creation of a reference
    from an already-persistent instance and enabled cascading of state for that mapped
    association.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要使实体实例从瞬时状态转换为**持久**状态，需要调用`EntityManager#persist()`方法或从已持久化的实例创建引用，并启用该映射关联的状态级联。
- en: Persistent state
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 持久化状态
- en: A *persistent* entity instance has a representation in the database. It’s stored
    in the database—or it will be stored when the unit of work completes. It’s an
    instance with a database identity, as defined in section 5.2; its database identifier
    is set to the primary key value of the database representation.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*持久*实体实例在数据库中有表示。它存储在数据库中——或者当工作单元完成时将被存储。它是一个具有数据库身份的实例，如第5.2节中定义的；其数据库标识符被设置为数据库表示的主键值。
- en: The application may have created instances and then made them persistent by
    calling `EntityManager#persist()`. Instances may have also become persistent when
    the application created a reference to the object from another persistent instance
    that the JPA provider already manages. A persistent entity instance may be an
    instance retrieved from the database by executing a query, an identifier lookup,
    or navigating the object graph starting from another persistent instance.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可能通过调用`EntityManager#persist()`方法创建了实例，并使它们持久化。实例也可能在应用程序创建了一个指向JPA提供者已管理的另一个持久实例的对象引用时变得持久。一个持久实体实例可能是一个通过执行查询、标识符查找或从另一个持久实例开始导航对象图检索的实例。
- en: Persistent instances are always associated with a persistence context. We’ll
    see more about this in a moment.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 持久实例始终与持久化上下文相关联。我们稍后将了解更多关于这一点。
- en: Removed state
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 移除状态
- en: We can delete a persistent entity instance from the database in several ways.
    For example, we can remove it with `EntityManager#remove()`. It may also become
    available for deletion if we remove a reference to it from a mapped collection
    with *orphan removal* enabled.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过几种方式从数据库中删除一个持久实体实例。例如，我们可以使用`EntityManager#remove()`方法将其删除。如果启用了*孤儿删除*，从映射集合中删除对其的引用也可能使其可删除。
- en: 'An entity instance is then in the *removed* state: the provider will delete
    it at the end of a unit of work. We should discard any references we may hold
    to it in the application after we finish working with it—for example, after we’ve
    rendered the removal-confirmation screen the users see.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，实体实例将处于*移除*状态：提供者将在工作单元结束时删除它。我们在完成与其实例的工作后——例如，在用户看到的移除确认屏幕渲染后——应该丢弃我们可能持有的任何引用。
- en: Detached state
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 分离状态
- en: To understand *detached* entity instances, consider loading an instance. We
    call `EntityManager#find()` to retrieve an entity instance by its (known) identifier.
    Then we end our unit of work and close the persistence context. The application
    still has a *handle*—a reference to the instance we loaded. It’s now in a detached
    state, and the data is becoming stale. We could discard the reference and let
    the garbage collector reclaim the memory. Or, we could continue working with the
    data in the detached state and later call the `merge()` method to save our modifications
    in a new unit of work. We’ll discuss detachment and merging in section 10.3.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解*分离*的实体实例，考虑加载一个实例。我们调用`EntityManager#find()`通过其（已知）标识符检索实体实例。然后我们结束我们的工作单元并关闭持久化上下文。应用程序仍然有一个*处理*——即对我们加载的实例的引用。现在它处于分离状态，数据正在变得过时。我们可以丢弃引用并让垃圾回收器回收内存。或者，我们可以在分离状态下继续处理数据，稍后调用`merge()`方法以新工作单元保存我们的修改。我们将在第10.3节中讨论分离和合并。
- en: 'You should now have a basic understanding of entity instance states and their
    transitions. Our next topic is the persistence context: an essential service of
    any Jakarta Persistence provider.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该对实体实例状态及其转换有一个基本理解。我们接下来要讨论的主题是持久化上下文：任何Jakarta Persistence提供者的一项基本服务。
- en: 10.1.2 The persistence context
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.2 持久化上下文
- en: In a Java Persistence application, an `EntityManager` has a persistence context.
    We create a persistence context when we call `EntityManagerFactory#createEntityManager()`.
    The context is closed when we call `EntityManager#close()`. In JPA terminology,
    this is an *application-managed* persistence context; our application defines
    the scope of the persistence context, demarcating the unit of work.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java Persistence应用程序中，`EntityManager`有一个持久化上下文。当我们调用`EntityManagerFactory#createEntityManager()`时创建持久化上下文。上下文在调用`EntityManager#close()`时关闭。在JPA术语中，这是一个*应用程序管理*的持久化上下文；我们的应用程序定义了持久化上下文的范围，界定工作单元。
- en: The persistence context monitors and manages all entities in the persistent
    state. The persistence context is the centerpiece of much of the functionality
    of a JPA provider.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 持久化上下文监控和管理所有处于持久状态中的实体。持久化上下文是JPA提供者功能的核心。
- en: The persistence context also allows the persistence engine to perform *automatic
    dirty checking*, detecting which entity instances the application modified. The
    provider then synchronizes with the database the state of instances monitored
    by a persistence context, either automatically or on demand. Typically, when a
    unit of work completes, the provider propagates state that’s held in memory to
    the database through the execution of SQL `INSERT`, `UPDATE`, and `DELETE` statements
    (all part of the Data Manipulation Language, DML). This *flushing* procedure may
    also occur at other times. For example, Hibernate may synchronize with the database
    before the execution of a query. This ensures that queries are aware of changes
    made earlier during the unit of work.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 持久化上下文还允许持久化引擎执行*自动脏检查*，检测应用程序修改了哪些实体实例。然后提供者将与持久化上下文监控的实例的状态与数据库同步，无论是自动的还是按需的。通常，当工作单元完成时，提供者通过执行SQL
    `INSERT`、`UPDATE`和`DELETE`语句（所有都是数据操作语言，DML的一部分）将内存中持有的状态传播到数据库。此*刷新*过程也可能在其他时间发生。例如，Hibernate可能在查询执行之前与数据库同步。这确保查询了解工作单元早期所做的更改。
- en: The persistence context also acts as a *first-level cache*; it remembers all
    entity instances handled in a particular unit of work. For example, if we ask
    Hibernate to load an entity instance using a primary key value (a lookup by identifier),
    Hibernate can first check the current unit of work in the persistence context.
    If Hibernate finds the entity instance in the persistence context, no database
    hit occurs—this is a repeatable read for an application. Consecutive `em.find(Item.class,`
    `ITEM_ID)` calls with the same persistence context will yield the same result.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 持久化上下文还充当*一级缓存*；它记住特定工作单元中处理的所有实体实例。例如，如果我们要求Hibernate使用主键值（通过标识符查找）加载实体实例，Hibernate首先会检查持久化上下文中的当前工作单元。如果Hibernate在持久化上下文中找到实体实例，则不会发生数据库访问——这是应用程序的可重复读。具有相同持久化上下文的连续`em.find(Item.class,
    ITEM_ID)`调用将产生相同的结果。
- en: This cache also affects the results of arbitrary queries, such as those executed
    with the `javax.persistence.Query` API. Hibernate reads the SQL result set of
    a query and transforms it into entity instances. This process first tries to resolve
    every entity instance in the persistence context by identifier lookup. Only if
    an instance with the same identifier value can’t be found in the current persistence
    context does Hibernate read the rest of the data from the result-set row. Hibernate
    ignores any potentially newer data in the result set, due to read-committed transaction
    isolation at the database level, if the entity instance is already present in
    the persistence context.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 此缓存还会影响任意查询的结果，例如使用`javax.persistence.Query` API执行的查询。Hibernate读取查询的SQL结果集并将其转换为实体实例。此过程首先尝试通过标识符查找解决持久化上下文中的每个实体实例。只有当无法在当前持久化上下文中找到具有相同标识符值的实例时，Hibernate才会从结果集行中读取其余数据。由于数据库级别的读已提交事务隔离，如果实体实例已在持久化上下文中，Hibernate会忽略结果集中任何可能更新的数据。
- en: 'The persistence context cache is always on—it can’t be turned off. It ensures
    the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 持久化上下文缓存始终开启——无法关闭。它确保以下内容：
- en: The persistence layer isn’t vulnerable to stack overflows in the case of circular
    references in an object graph.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在对象图中的循环引用情况下，持久化层不会受到栈溢出的影响。
- en: There can never be conflicting representations of the same database row at the
    end of a unit of work. The provider can safely write all changes made to an entity
    instance to the database.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在工作单元结束时，同一数据库行的冲突表示永远不会出现。提供者可以安全地将对实体实例所做的所有更改写入数据库。
- en: Likewise, changes made in a particular persistence context are always immediately
    visible to all other code executed inside that unit of work and its persistence
    context. JPA guarantees repeatable entity-instance reads.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，在特定持久化上下文中做出的更改总是立即对所有在该工作单元及其持久化上下文中执行的代码可见。JPA保证了可重复的实体实例读取。
- en: The persistence context provides a *guaranteed scope of object identity*; in
    the scope of a single persistence context, only one instance represents a particular
    database row. Consider the comparison of references `entityA == entityB`. This
    is `true` only if both are references to the same Java instance on the heap. Now
    consider the comparison `entityA.getId().equals(entityB.getId())`. This is `true`
    if both have the same database identifier value. Within one persistence context,
    Hibernate guarantees that both comparisons will yield the same result. This solves
    one of the fundamental object/relational mismatch problems we discussed in section
    1.2.3.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 持久化上下文提供了一个*保证的对象身份作用域*；在单个持久化上下文的范围内，只有一个实例代表特定的数据库行。考虑引用`entityA == entityB`的比较。这只有在两者都是堆上同一Java实例的引用时才为`true`。现在考虑比较`entityA.getId().equals(entityB.getId())`。如果两者都有相同的数据库标识符值，则为`true`。在单个持久化上下文中，Hibernate保证这两个比较将产生相同的结果。这解决了我们在1.2.3节中讨论的基本对象/关系不匹配问题之一。
- en: The lifecycle of entity instances and the services provided by the persistence
    context can be difficult to understand at first. Let’s look at some code examples
    of dirty checking, caching, and how the guaranteed identity scope works in practice.
    To do this, we’ll work with the persistence manager API.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 实体实例的生命周期和持久化上下文提供的服务一开始可能难以理解。让我们看看一些关于脏检查、缓存以及保证身份作用域在实际中如何工作的代码示例。为此，我们将与持久化管理器API一起工作。
- en: Would process-scoped identity be better?
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 处理作用域的身份是否更好？
- en: For a typical web or enterprise application, persistence context-scoped identity
    is preferred. Process-scoped identity, where only one in-memory instance represents
    the row in the entire process (JVM), offers some potential advantages in terms
    of cache utilization. In a pervasively multithreaded application, though, the
    cost of always synchronizing shared access to persistent instances in a global
    identity map is too high a price to pay. It’s simpler and more scalable to have
    each thread work with a distinct copy of the data in each persistence context.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个典型的Web或企业应用程序，持久化上下文作用域的身份更受欢迎。处理作用域的身份，其中只有内存中的一个实例代表整个过程中的行（JVM），在缓存利用率方面提供了一些潜在的优势。然而，在一个广泛的多线程应用程序中，始终同步对持久实例的共享访问的代价太高。每个线程在持久化上下文中使用各自的数据副本，这更简单且更具可扩展性。
- en: 10.2 The EntityManager interface
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2 EntityManager接口
- en: Any transparent persistence tool includes a persistence manager API. This persistence
    manager usually provides services for basic CRUD (create, read, update, delete)
    operations, query execution, and controlling the persistence context. In Jakarta
    Persistence applications, the main interface we interact with is the `EntityManager`
    to create units of work.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 任何透明的持久化工具都包括一个持久化管理器API。这个持久化管理器通常提供基本CRUD（创建、读取、更新、删除）操作、查询执行和控制持久化上下文的服务。在Jakarta
    Persistence应用程序中，我们与之交互的主要接口是`EntityManager`以创建单元工作。
- en: Note To execute the examples from the source code, you’ll first need to run
    the Ch10.sql script. The source code that follows can be found in the managing-data
    and managing-data2 folders.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：要执行源代码中的示例，您首先需要运行Ch10.sql脚本。接下来的源代码可以在`managing-data`和`managing-data2`文件夹中找到。
- en: We will not use Spring Data JPA in this chapter, not even the Spring framework.
    The examples that follow will use JPA and, sometimes, the Hibernate API, without
    any Spring integration—they are finer-grained for our demonstrations and analysis.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '在本章中，我们不会使用Spring Data JPA，甚至不会使用Spring框架。接下来的示例将使用JPA，有时还会使用Hibernate API，而不进行任何Spring集成——它们对我们的演示和分析来说粒度更细。 '
- en: 10.2.1 The canonical unit of work
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.1 规范的单元工作
- en: In Java SE and some EE architectures (if we only have plain servlets, for example),
    we get an `EntityManager` by calling `EntityManagerFactory#createEntityManager()`.
    The application code shares the `EntityManagerFactory`, representing one persistence
    unit, or one logical database. Most applications have only one shared `EntityManagerFactory`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java SE和某些EE架构中（如果我们只有普通的servlets，例如），我们通过调用`EntityManagerFactory#createEntityManager()`来获取`EntityManager`。应用程序代码共享`EntityManagerFactory`，代表一个持久化单元，或一个逻辑数据库。大多数应用程序只有一个共享的`EntityManagerFactory`。
- en: We use the `EntityManager` for a single unit of work in a single thread, and
    it’s inexpensive to create. The following listing shows the canonical, typical
    form of a unit of work.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在一个线程中使用`EntityManager`进行单个单元工作，创建它并不昂贵。以下列表显示了单元工作的规范、典型形式。
- en: Listing 10.1 A typical unit of work
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.1 一个典型的单元工作
- en: '[PRE0]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Everything between `em.getTransaction().begin()` and `em.getTransaction() .commit()`
    occurs in one transaction. For now, keep in mind that all database operations
    in a transaction scope, such as the SQL statements executed by Hibernate, either
    completely succeed or completely fail. Don’t worry too much about the transaction
    code for now; you’ll read more about concurrency control in the next chapter.
    We’ll look at the same example there with a focus on the transaction and exception-
    handling code. Don’t write empty `catch` clauses in the code, though—you’ll have
    to roll back the transaction and handle exceptions.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `em.getTransaction().begin()` 和 `em.getTransaction().commit()` 之间的所有操作都在一个事务中完成。现在，请记住，在事务作用域内的所有数据库操作，例如
    Hibernate 执行的 SQL 语句，要么完全成功，要么完全失败。现在不必过于担心事务代码；你将在下一章中了解更多关于并发控制的内容。我们将在那里用同样的例子，重点关注事务和异常处理代码。不过，不要在代码中编写空的
    `catch` 块——你将不得不回滚事务并处理异常。
- en: Creating an `EntityManager` starts its persistence context. Hibernate won’t
    access the database until necessary; the `EntityManager` doesn’t obtain a JDBC
    `Connection` from the pool until SQL statements have to be executed. We can even
    create and close an `EntityManager` without hitting the database. Hibernate executes
    SQL statements when we look up or query data and when it flushes changes detected
    by the persistence context to the database. Hibernate joins the in-progress system
    transaction when an `EntityManager` is created and waits for the transaction to
    commit. When Hibernate is notified of the commit, it performs dirty checking of
    the persistence context and synchronizes with the database. We can also force
    dirty checking synchronization manually by calling `EntityManager#flush()` at
    any time during a transaction.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `EntityManager` 会启动其持久化上下文。Hibernate 不会在必要时访问数据库；`EntityManager` 不会从连接池中获取
    JDBC `Connection`，直到需要执行 SQL 语句。我们甚至可以在不接触数据库的情况下创建和关闭 `EntityManager`。当我们在持久化上下文中查找或查询数据以及当
    Hibernate 将检测到的更改刷新到数据库时，Hibernate 执行 SQL 语句。当创建 `EntityManager` 时，Hibernate 会加入正在进行的系统事务并等待事务提交。当
    Hibernate 被通知提交时，它会执行持久化上下文的脏检查并与数据库同步。我们还可以通过在任何时候调用 `EntityManager#flush()`
    来手动强制执行脏检查同步。
- en: We determine the scope of the persistence context by choosing when to `close()`
    the `EntityManager`. We have to close the persistence context at some point, so
    always place the `close()` call in a `finally` block.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过选择何时 `close()` `EntityManager` 来确定持久化上下文的范围。我们必须在某个时候关闭持久化上下文，所以总是将 `close()`
    调用放在 `finally` 块中。
- en: How long should the persistence context be open? Let’s assume for the following
    examples that we’re writing a server, and each client request will be processed
    with one persistence context and system transaction in a multithreaded environment.
    If you’re familiar with servlets, imagine the code in listing 10.1 embedded in
    a servlet’s `service()` method. Within this unit of work, you access the `EntityManager`
    to load and store data.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 持久化上下文应该保持多长时间开放？让我们假设以下示例中我们正在编写一个服务器，并且每个客户端请求都将在一个多线程环境中使用一个持久化上下文和系统事务进行处理。如果你熟悉
    servlet，可以想象列表 10.1 中的代码嵌入在 servlet 的 `service()` 方法中。在这个工作单元内，你通过访问 `EntityManager`
    来加载数据和存储数据。
- en: 10.2.2 Making data persistent
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.2 使数据持久化
- en: Let’s create a new instance of an entity and bring it from transient into persistent
    state. You will do this whenever you want to save the information from a newly
    created object to the database. We can see the same unit of work and how the `Item`
    instances change state in figure 10.2.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个实体的新实例，并将其从临时状态转换为持久状态。你将在想要将新创建的对象的信息保存到数据库时这样做。我们可以在图 10.2 中看到相同的工作单元以及
    `Item` 实例如何改变状态。
- en: '![](../../OEBPS/Images/CH10_F02_Tudose2.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH10_F02_Tudose2.png)'
- en: Figure 10.2 Making an instance persistent in a unit of work
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 在工作单元中使实例持久化
- en: 'To make an instance persistent, you can use a piece of code like the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要使一个实例持久化，你可以使用以下类似的代码：
- en: '[PRE1]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A new transient `Item` is instantiated as usual. Of course, we could also instantiate
    it before creating the `EntityManager`. A call to `persist()` makes the transient
    instance of `Item` persistent. It’s then managed by and associated with the current
    persistence context.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 按照常规，会实例化一个新的临时 `Item` 对象。当然，我们也可以在创建 `EntityManager` 之前就实例化它。调用 `persist()`
    方法会使 `Item` 的临时实例变为持久化。然后，它将由当前持久化上下文管理和关联。
- en: To store the `Item` instance in the database, Hibernate has to execute an SQL
    `INSERT` statement. When the transaction of this unit of work commits, Hibernate
    flushes the persistence context, and the `INSERT` occurs at that time. Hibernate
    may even batch the `INSERT` at the JDBC level with other statements. When we call
    `persist()`, only the identifier value of the `Item` is assigned. Alternatively,
    if the identifier generator isn’t *pre-insert*, the `INSERT` statement will be
    executed immediately when `persist()` is called. You may want to review section
    5.2.5 for a refresher on the identifier generator strategies.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要将`Item`实例存储到数据库中，Hibernate必须执行一个SQL `INSERT`语句。当这个工作单元的事务提交时，Hibernate刷新持久化上下文，`INSERT`就在那时发生。Hibernate甚至可能将`INSERT`与其他语句一起在JDBC级别批量执行。当我们调用`persist()`时，只有`Item`的标识符值被分配。或者，如果标识符生成器不是`pre-insert`，则`INSERT`语句将在调用`persist()`时立即执行。你可能想回顾第5.2.5节，以刷新对标识符生成器策略的了解。
- en: Detecting entity state using the identifier
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标识符检测实体状态
- en: Sometimes we need to know whether an entity instance is persistent, transient,
    or detached.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们需要知道一个实体实例是持久化的、瞬时的还是分离的。
- en: '*Persistent*—An entity instance is in persistent state if `EntityManager# contains(e)`
    returns `true`.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*持久状态*——如果`EntityManager#contains(e)`返回`true`，实体实例就处于持久状态。'
- en: '*Transient*—It’s in transient state if `PersistenceUnitUtil#getIdentifier(e)`
    returns `null`.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*瞬时状态*——如果`PersistenceUnitUtil#getIdentifier(e)`返回`null`，它就处于瞬时状态。'
- en: '*Detached*—It’s in the detached state if it’s not persistent, and `PersistenceUnitUtil#getIdentifier(e)`
    returns the value of the entity’s identifier property.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分离状态*——如果它不是持久的，它就处于分离状态，`PersistenceUnitUtil#getIdentifier(e)`将返回实体标识符属性的值。'
- en: We can get to `PersistenceUnitUtil` from the `EntityManagerFactory`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从`EntityManagerFactory`获取到`PersistenceUnitUtil`。
- en: There are two concerns to look out for. First, be aware that the identifier
    value may not be assigned and available until the persistence context is flushed.
    Second, Hibernate (unlike some other JPA providers) never returns `null` from
    `PersistenceUnitUtil#getIdentifier()` if the identifier property is a primitive
    (a `long` and not a `Long`).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个需要注意的问题。首先，要注意标识符值可能直到持久化上下文刷新后才被分配和可用。其次，Hibernate（与一些其他JPA提供者不同）如果标识符属性是原始类型（一个`long`而不是`Long`），则从`PersistenceUnitUtil#getIdentifier()`永远不会返回`null`。
- en: It’s better (but not required) to fully initialize the `Item` instance before
    managing it with a persistence context. The SQL `INSERT` statement contains the
    values that were held by the instance at the point when `persist()` was called.
    If we don’t set the `name` of the `Item` before making it persistent, a `NOT NULL`
    constraint may be violated. We can modify the `Item` after calling `persist()`,
    and the changes will be propagated to the database with an additional SQL `UPDATE`
    statement.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用持久化上下文管理`Item`实例之前完全初始化该实例更好（但不是必需的）。SQL `INSERT`语句包含在调用`persist()`时实例持有的值。如果我们不在使`Item`持久化之前设置其`name`，可能会违反`NOT
    NULL`约束。我们可以在调用`persist()`之后修改`Item`，并且这些更改将通过额外的SQL `UPDATE`语句传播到数据库。
- en: If one of the `INSERT` or `UPDATE` statements fails during flushing, Hibernate
    causes a rollback of changes made to persistent instances in this transaction
    at the database level. But Hibernate doesn’t roll back in-memory changes to persistent
    instances. If we change the `Item#name` after `persist()`, a commit failure won’t
    roll back to the old name. This is reasonable, because a failure of a transaction
    is normally non-recoverable, and we have to discard the failed persistence context
    and `EntityManager` immediately. We’ll discuss exception handling in the next
    chapter.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在刷新过程中`INSERT`或`UPDATE`语句中的任何一个失败，Hibernate将在数据库级别回滚此事务中对持久化实例所做的更改。但Hibernate不会回滚对持久化实例的内存更改。如果我们更改`Item#name`之后`persist()`，提交失败不会回滚到旧名称。这是合理的，因为事务的失败通常是不可恢复的，我们必须立即丢弃失败的持久化上下文和`EntityManager`。我们将在下一章讨论异常处理。
- en: Next, we’ll load and modify the stored data.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将加载和修改存储的数据。
- en: 10.2.3 Retrieving and modifying persistent data
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.3 检索和修改持久化数据
- en: We can retrieve persistent instances from the database with the `EntityManager`.
    In a real-life use case, we would have kept the identifier value of the `Item`
    stored in the previous section somewhere, and we are now looking up the same instance
    in a new unit of work by identifier. Figure 10.3 shows this transition graphically.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `EntityManager` 从数据库检索持久实例。在实际应用中，我们会在上一节中某处保存 `Item` 的标识符值，现在我们通过标识符在新工作单元中查找相同的实例。图
    10.3 以图形方式展示了这一转换。
- en: '![](../../OEBPS/Images/CH10_F03_Tudose2.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH10_F03_Tudose2.png)'
- en: Figure 10.3 Making an instance persistent in a unit of work
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 在工作单元中使实例持久化
- en: 'To make an instance persistent in a unit of work, you can use a piece of code
    like the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要在一个工作单元中使一个实例持久化，你可以使用以下代码片段：
- en: '[PRE2]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Ⓐ The instruction will hit the database if `item` is not already in the persistence
    context.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 如果 `item` 已经不在持久上下文中，指令将击中数据库。
- en: Ⓑ Then we modify the name.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 然后我们修改名称。
- en: We don’t need to cast the returned value of the `find()` operation; it’s a generified
    method, and its return type is set as a side effect of the first parameter. The
    retrieved entity instance is in a persistent state, and we can now modify it inside
    the unit of work.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要将 `find()` 操作的返回值进行类型转换；它是一个泛型方法，其返回类型是第一个参数的副作用。检索到的实体实例处于持久状态，现在我们可以在工作单元内对其进行修改。
- en: If no persistent instance with the given identifier value can be found, `find()`
    returns `null`. The `find()` operation always hits the database if there is no
    hit for the given entity type and identifier in the persistence context cache.
    The entity instance is always initialized during loading. We can expect to have
    all of its values available later in a detached state, such as when rendering
    a screen after we close the persistence context. (Hibernate may not hit the database
    if its optional second-level cache is enabled.)
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找不到具有给定标识符值的持久实例，`find()` 方法将返回 `null`。如果持久上下文缓存中没有给定实体类型和标识符的匹配项，`find()`
    操作总是会击中数据库。在加载实体实例时，实例总是被初始化。我们可以期待在分离状态下稍后获得其所有值，例如在关闭持久上下文后渲染屏幕时。（如果启用了可选的二级缓存，Hibernate
    可能不会击中数据库。）
- en: We can modify the `Item` instance, and the persistence context will detect these
    changes and record them in the database automatically. When Hibernate flushes
    the persistence context during commit, it executes the necessary SQL DML statements
    to synchronize the changes with the database. Hibernate propagates state changes
    to the database as late as possible, toward the end of the transaction. DML statements
    usually create locks in the database that are held until the transaction completes,
    so Hibernate keeps the lock duration in the database as short as possible.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以修改 `Item` 实例，持久上下文将检测这些更改并将它们自动记录在数据库中。当 Hibernate 在提交期间刷新持久上下文时，它执行必要的
    SQL DML 语句以同步数据库中的更改。Hibernate 尽可能晚地将状态更改传播到数据库，即在事务结束时。DML 语句通常会在数据库中创建锁，直到事务完成才释放，因此
    Hibernate 尽可能缩短数据库中的锁持续时间。
- en: Hibernate writes the new `Item#name` to the database with an SQL `UPDATE`. By
    default, Hibernate includes all columns of the mapped `ITEM` table in the SQL
    `UPDATE` statement, updating unchanged columns to their old values. Hence, Hibernate
    can generate these basic SQL statements at startup, not at runtime. If we want
    to include only modified (or non-nullable for `INSERT`) columns in SQL statements,
    we can enable dynamic SQL generation as demonstrated in section 5.3.2.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate 使用 SQL `UPDATE` 将新的 `Item#name` 写入数据库。默认情况下，Hibernate 将映射的 `ITEM`
    表的所有列包括在 SQL `UPDATE` 语句中，更新未更改的列到其旧值。因此，Hibernate 可以在启动时生成这些基本 SQL 语句，而不是在运行时。如果我们只想在
    SQL 语句中包含已修改的（或对于 `INSERT` 为非可空的）列，我们可以启用动态 SQL 生成，如第 5.3.2 节中所示。
- en: Hibernate detects the changed `name` by comparing the `Item` with a snapshot
    copy it took when the `Item` was loaded from the database. If the `Item` is different
    from the snapshot, an `UPDATE` is necessary. This snapshot in the persistence
    context consumes memory. Dirty checking with snapshots can also be time-consuming
    because Hibernate has to compare all instances in the persistence context with
    their snapshots during flushing.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate 通过比较 `Item` 与它在从数据库加载 `Item` 时所拍摄的快照来检测更改的 `name`。如果 `Item` 与快照不同，则需要执行
    `UPDATE`。持久上下文中的这个快照消耗内存。使用快照的脏检查也可能很耗时，因为 Hibernate 必须在刷新期间将持久上下文中的所有实例与其快照进行比较。
- en: 'We mentioned earlier that the persistence context enables repeatable reads
    of entity instances and provides an object-identity guarantee:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到，持久化上下文使实体实例的可重复读成为可能，并提供对象身份保证：
- en: '[PRE3]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Ⓐ The first `find()` operation hits the database and retrieves the `Item` instance
    with a `SELECT` statement.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 第一次`find()`操作击中数据库，并使用`SELECT`语句检索`Item`实例。
- en: Ⓑ The second `find()` is a repeatable read and is resolved in the persistence
    context, and the same cached `Item` instance is returned.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 第二次`find()`是一个可重复读操作，并在持久化上下文中解决，并返回相同的缓存`Item`实例。
- en: Sometimes we need an entity instance but we don’t want to hit the database.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们需要一个实体实例，但我们不想击中数据库。
- en: 10.2.4 Getting a reference
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.4 获取引用
- en: If we don’t want to hit the database when loading an entity instance, because
    we aren’t sure we need a fully initialized instance, we can tell the `EntityManager`
    to attempt the retrieval of a hollow placeholder—a proxy.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不想在加载实体实例时击中数据库，因为我们不确定是否需要一个完全初始化的实例，我们可以告诉`EntityManager`尝试检索一个空白的占位符——一个代理。
- en: 'If the persistence context already contains an `Item` with the given identifier,
    that `Item` instance is returned by `getReference()` without hitting the database.
    Furthermore, if *no* persistent instance with that identifier is currently managed,
    Hibernate produces the hollow placeholder: the proxy. This means `getReference()`
    won’t access the database, and it doesn’t return `null`, unlike `find()`. JPA
    offers the `PersistenceUnitUtil` helper methods. The isLoaded() helper method
    is used to detect whether we’re working with an uninitialized proxy.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果持久化上下文已经包含具有给定标识符的`Item`，则`getReference()`会返回该`Item`实例，而不会击中数据库。此外，如果当前没有管理具有该标识符的持久实例，Hibernate将生成空白的占位符：代理。这意味着`getReference()`不会访问数据库，并且它不会返回`null`，与`find()`不同。JPA提供了`PersistenceUnitUtil`辅助方法。`isLoaded()`辅助方法用于检测我们是否正在处理一个未初始化的代理。
- en: As soon as we call any method, such as `Item#getName()`, on the proxy, a `SELECT`
    is executed to fully initialize the placeholder. The exception to this rule is
    a mapped database identifier getter method, such as `getId()`. A proxy may look
    like the real thing, but it’s only a placeholder carrying the identifier value
    of the entity instance it represents. If the database record no longer exists
    when the proxy is initialized, an `EntityNotFoundException` is thrown. Note that
    the exception can be thrown when `Item#getName()` is called. The Hibernate class
    has a convenient static `initialize()` method that loads the proxy’s data.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们调用任何方法，例如`Item#getName()`，在代理上，就会执行一个`SELECT`来完全初始化占位符。这个规则的例外是一个映射的数据库标识符获取方法，例如`getId()`。代理可能看起来像是真实的东西，但它只是一个携带实体实例标识值占位符。如果代理初始化时数据库记录已不存在，则会抛出`EntityNotFoundException`。请注意，异常可能在调用`Item#getName()`时抛出。Hibernate类有一个方便的静态`initialize()`方法，可以加载代理的数据。
- en: 'After the persistence context is closed, `item` is in a detached state. If
    we don’t initialize the proxy while the persistence context is still open, we
    get a `LazyInitializationException` if we access the proxy, as demonstrated in
    the following code. We can’t load data on demand once the persistence context
    is closed. The solution is simple: load the data before closing the persistence
    context.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在持久化上下文关闭后，`item`处于分离状态。如果我们不在持久化上下文仍然打开时初始化代理，当我们访问代理时，会抛出`LazyInitializationException`，如下面的代码所示。一旦持久化上下文关闭，我们就不能按需加载数据。解决方案很简单：在关闭持久化上下文之前加载数据。
- en: '[PRE4]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Ⓐ The persistence context.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 持久化上下文。
- en: Ⓑ The helper methods.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 辅助方法。
- en: Ⓒ Detecting an uninitialized proxy.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 检测未初始化的代理。
- en: Ⓓ Mapping the exception to the rule.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 将异常映射到规则。
- en: Ⓔ Load the proxy data.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓔ 加载代理数据。
- en: Ⓕ `item` is in a detached state.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓕ `item`处于分离状态。
- en: Ⓖ Load data after closing the persistence context.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓖ 在关闭持久化上下文后加载数据。
- en: We’ll have much more to say about proxies, lazy loading, and on-demand fetching
    in chapter 12.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第12章中详细介绍代理、延迟加载和按需获取。
- en: Next, if we want to remove the state of an entity instance from the database,
    we have to make it transient.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，如果我们想从数据库中删除实体实例的状态，我们必须将其设置为瞬态。
- en: 10.2.5 Making data transient
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.5 使数据瞬态
- en: To make an entity instance transient and delete its database representation,
    we can call the `remove()` method on the `EntityManager`. Figure 10.4 shows this
    process.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要使实体实例瞬态并删除其数据库表示，我们可以在`EntityManager`上调用`remove()`方法。图10.4显示了此过程。
- en: '![](../../OEBPS/Images/CH10_F04_Tudose2.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH10_F04_Tudose2.png)'
- en: Figure 10.4 Removing an instance in a unit of work
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 在工作单元中移除一个实例
- en: If we call `find()`, Hibernate executes a `SELECT` to load the `Item`. If we
    call `getReference()`, Hibernate attempts to avoid the `SELECT` and returns a
    proxy. Calling `remove()` queues the entity instance for deletion when the unit
    of work completes; it’s now in *removed* state. If `remove()` is called on a proxy,
    Hibernate executes a `SELECT` to load the data. An entity instance must be fully
    initialized during lifecycle transitions. We may have lifecycle callback methods
    or an entity listener enabled (see section 13.2), and the instance must pass through
    these interceptors to complete its full lifecycle.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们调用`find()`，Hibernate将执行`SELECT`来加载`Item`。如果我们调用`getReference()`，Hibernate试图避免`SELECT`并返回一个代理。调用`remove()`将在工作单元完成时将实体实例排队以供删除；它现在处于*移除*状态。如果对代理调用`remove()`，Hibernate将执行`SELECT`来加载数据。实体实例必须在生命周期转换期间完全初始化。我们可能启用了生命周期回调方法或实体监听器（见第13.2节），并且实例必须通过这些拦截器来完成其完整生命周期。
- en: An entity in a removed state is no longer in a persistent state. We can check
    this with the `contains()` operation. We can make the removed instance persistent
    again, canceling deletion.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 已移除状态的实体不再处于持久状态。我们可以通过`contains()`操作来检查这一点。我们可以使已移除的实例再次持久化，取消删除操作。
- en: 'When the transaction commits, Hibernate synchronizes the state transitions
    with the database and executes the SQL `DELETE`. The JVM garbage collector detects
    that the `item` is no longer referenced by anything and finally deletes the last
    trace of the data. We can finally close `EntityManager`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当事务提交时，Hibernate将状态转换与数据库同步并执行SQL `DELETE`。JVM垃圾回收器检测到`item`不再被任何东西引用，最终删除数据的最后痕迹。我们最终可以关闭`EntityManager`：
- en: '[PRE5]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Ⓐ Call `find()`; Hibernate executes a `SELECT` to load the `Item`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 调用`find()`；Hibernate执行`SELECT`来加载`Item`。
- en: Ⓑ Call `remove()`; Hibernate queues the entity instance for deletion when the
    unit of work completes.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 调用`remove()`；Hibernate在工作单元完成时将实体实例排队以供删除。
- en: Ⓒ An entity in a removed state is no longer contained in the persistence context.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 已移除状态中的实体不再包含在持久化上下文中。
- en: Ⓓ Canceling deletion makes the removed instance persistent again.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 取消删除操作使已移除的实例再次持久化。
- en: Ⓔ `item` will now look like a transient instance.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓔ `item`现在将看起来像一个瞬态实例。
- en: Ⓕ The transaction commits; Hibernate synchronizes the state transitions with
    the database and executes the SQL `DELETE`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓕ 事务提交；Hibernate将状态转换与数据库同步并执行SQL `DELETE`。
- en: Ⓖ Close `EntityManager`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓖ 关闭`EntityManager`。
- en: 'By default, Hibernate won’t alter the identifier value of a removed entity
    instance. This means the `item.getId()` method still returns the now outdated
    identifier value. Sometimes it’s useful to work with the “deleted” data further:
    for example, we might want to save the removed `Item` again if our user decides
    to undo. As shown in the example, we can call `persist()` on a removed instance
    to cancel the deletion before the persistence context is flushed. Alternatively,
    if we set the property `hibernate .use_identifier_rollback` to `true` in persistence.xml,
    Hibernate will reset the identifier value after the removal of an entity instance.
    In the previous code example, the identifier value is reset to the default value
    of `null` (it’s a `Long`). The `Item` is now the same as in a transient state,
    and we can save it again in a new persistence context.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Hibernate不会更改已移除实体实例的标识符值。这意味着`item.getId()`方法仍然返回现在过时的标识符值。有时进一步处理“已删除”的数据是有用的：例如，如果我们用户决定撤销，我们可能希望再次保存已移除的`Item`。如示例所示，我们可以在持久化上下文刷新之前对已移除的实例调用`persist()`来取消删除。或者，如果我们将在persistence.xml中将属性`hibernate.use_identifier_rollback`设置为`true`，Hibernate将在实体实例删除后重置标识符值。在先前的代码示例中，标识符值重置为默认值`null`（它是一个`Long`）。现在`Item`与瞬态状态相同，我们可以在新的持久化上下文中再次保存它。
- en: Let’s say we load an entity instance from the database and work with the data.
    For some reason, we know that another application or maybe another thread of the
    application has updated the underlying row in the database. Next we’ll see how
    to refresh the data held in memory.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们从数据库中加载一个实体实例并处理数据。由于某种原因，我们知道另一个应用程序或可能是应用程序的另一个线程已更新数据库中的底层行。接下来我们将看到如何刷新内存中持有的数据。
- en: 10.2.6 Refreshing data
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.6 刷新数据
- en: 'It is possible that, after you have loaded an entity instance, some other process
    changes the information corresponding to the instance in the database. The following
    example demonstrates refreshing a persistent entity instance:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在您加载实体实例之后，可能存在其他进程更改了数据库中与该实例对应的信息。以下示例演示了刷新持久化实体实例：
- en: '[PRE6]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: After we load the entity instance, we realize (it isn’t important how) that
    someone else changed the data in the database. Calling `refresh()` causes Hibernate
    to execute a `SELECT` to read and marshal a whole result set, overwriting changes
    we already made to the persistent instance in application memory. As a result,
    the `item`’s `name` is updated with the value set from the other side. If the
    database row no longer exists (if someone deleted it), Hibernate throws an `EntityNotFoundException`
    on `refresh()`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们加载实体实例后，我们意识到（不重要的是如何）有人更改了数据库中的数据。调用`refresh()`会导致Hibernate执行一个`SELECT`来读取和序列化整个结果集，覆盖我们在应用程序内存中持久实例所做的更改。因此，`item`的`name`被更新为另一侧设置的值。如果数据库行不再存在（如果有人删除了它），则在`refresh()`时Hibernate会抛出`EntityNotFoundException`。
- en: Most applications don’t have to manually refresh the in-memory state; concurrent
    modifications are typically resolved at transaction commit time. The best use
    case for refreshing is with an extended persistence context, which might span
    several request/response cycles or system transactions. While we wait for user
    input with an open persistence context, data gets stale, and selective refreshing
    may be required depending on the duration of the conversation and the dialogue
    between the user and the system. Refreshing can be useful to undo changes made
    in memory during a conversation if the user cancels the dialogue.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序不需要手动刷新内存中的状态；并发修改通常在事务提交时解决。刷新的最佳用例是与扩展的持久化上下文一起使用，这可能跨越几个请求/响应周期或系统事务。当我们等待用户输入并保持持久化上下文打开时，数据会变得过时，并且根据对话的持续时间和用户与系统之间的对话，可能需要选择性地刷新。如果用户取消对话，刷新可以用来撤销在对话期间在内存中做出的更改。
- en: Another infrequently used operation is the replication of an entity instance.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个不常用的操作是复制实体实例。
- en: 10.2.7 Replicating data
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.7 复制数据
- en: Replication is useful, for example, when we need to retrieve data from one database
    and store it in another. Replication takes detached instances loaded in one persistence
    context and makes them persistent in another persistence context. We usually open
    these contexts from two different `EntityManagerFactory` configurations, enabling
    two logical databases. We have to map the entity in both configurations.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 复制在需要从数据库检索数据并将其存储在另一个数据库中时很有用。复制将一个持久上下文中加载的分离实例使其在另一个持久上下文中持久化。我们通常从两个不同的`EntityManagerFactory`配置中打开这些上下文，从而启用两个逻辑数据库。我们必须在这两个配置中映射实体。
- en: 'The `replicate()` operation is only available on the Hibernate `Session` API.
    Here is an example that loads an `Item` instance from one database and copies
    it into another:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`replicate()`操作仅在Hibernate `Session` API上可用。以下是一个示例，它从一个数据库中加载一个`Item`实例并将其复制到另一个数据库中：'
- en: '[PRE7]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`ReplicationMode` controls the details of the replication procedure:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReplicationMode`控制复制过程的细节：'
- en: '`IGNORE`—Ignores the instance when there is an existing database row with the
    same identifier in the database.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IGNORE`—当数据库中存在具有相同标识符的现有数据库行时忽略该实例。'
- en: '`OVERWRITE`—Overwrites any existing database row with the same identifier in
    the database.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OVERWRITE`—覆盖数据库中具有相同标识符的任何现有数据库行。'
- en: '`EXCEPTION`—Throws an exception if there is an existing database row with the
    same identifier in the target database.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXCEPTION`—如果在目标数据库中存在具有相同标识符的现有数据库行，则抛出异常。'
- en: '`LATEST_VERSION`—Overwrites the row in the database if its version is older
    than the version of the given entity instance, or ignores the instance otherwise.
    Requires enabled optimistic concurrency control with entity versioning (discussed
    in section 11.2.2).'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LATEST_VERSION`—如果数据库中的行版本比给定实体实例的版本旧，则覆盖数据库中的该行，否则忽略该实例。需要启用具有实体版本控制的乐观并发控制（在第11.2.2节中讨论）。'
- en: 'We may need replication when we reconcile data entered into different databases.
    One use case is a product upgrade: if the new version of the application requires
    a new database (schema), we may want to migrate and replicate the existing data
    once.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们协调不同数据库中输入的数据时，可能需要复制。一个用例是产品升级：如果应用程序的新版本需要新的数据库（模式），我们可能希望迁移并复制现有数据一次。
- en: 'The persistence context does many things for you: automatic dirty checking,
    guaranteed scope of object identity, and so on. It’s equally important that you
    know some of the details of its management, and that you sometimes influence what
    goes on behind the scenes.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 持久化上下文为您做了很多事情：自动脏检查、保证对象身份的范畴，等等。同样重要的是，您需要了解其管理的一些细节，有时您还需要影响幕后发生的事情。
- en: 10.2.8 Caching in the persistence context
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.8 持久化上下文中的缓存
- en: The persistence context is a cache of persistent instances. Every entity instance
    in a persistent state is associated with the persistence context.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 持久化上下文是持久实例的缓存。每个处于持久状态的实体实例都与持久化上下文相关联。
- en: Many Hibernate users who ignore this simple fact run into an `OutOfMemoryError`.
    This is typically the case when we load thousands of entity instances in a unit
    of work but never intend to modify them. Hibernate still has to create a snapshot
    of each instance in the persistence context cache, which can lead to memory exhaustion.
    (Obviously, we should execute a bulk data operation if we modify thousands of
    rows.)
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 许多忽视这一简单事实的 Hibernate 用户会遇到 `OutOfMemoryError`。这通常发生在我们在工作单元中加载了成千上万的实体实例，但从未打算修改它们的情况下。Hibernate
    仍然需要在持久化上下文缓存中为每个实例创建一个快照，这可能导致内存耗尽。（显然，如果我们修改了成千上万行，我们应该执行批量数据操作。）
- en: The persistence context cache never shrinks automatically, so you should keep
    the size of the persistence context to the minimum necessary. Often, many persistent
    instances in the context are there by accident—for example, because we needed
    only a few items but queried for many. Extremely large graphs can have a serious
    performance consequence and require significant memory for state snapshots. Check
    that queries return only the data you need, and consider the following ways to
    control Hibernate’s caching behavior.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 持久化上下文缓存永远不会自动缩小，因此您应该将持久化上下文的大小保持在最小必要范围内。通常，上下文中的许多持久实例都是意外存在的——例如，因为我们只需要几个项目，但查询了多个。极大的图可能对性能有严重影响，并需要大量内存来存储状态快照。请确保查询返回您所需的数据，并考虑以下方法来控制
    Hibernate 的缓存行为。
- en: You can call `EntityManager#detach(i)` to evict a persistent instance manually
    from the persistence context. You can call `EntityManager#clear()` to detach all
    persistent entity instances, leaving you with an empty persistence context.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以调用 `EntityManager#detach(i)` 手动将持久实例从持久化上下文中驱逐。您还可以调用 `EntityManager#clear()`
    来断开所有持久实体实例，使持久化上下文为空。
- en: 'The native `Session` API has some extra operations you might find useful. You
    can set the entire persistence context to read-only mode. This disables state
    snapshots and dirty checking, and Hibernate won’t write modifications to the database:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 原生的 `Session` API 有一些额外的操作，您可能会觉得很有用。您可以将整个持久化上下文设置为只读模式。这将禁用状态快照和脏检查，Hibernate
    不会将修改写入数据库：
- en: '[PRE8]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Ⓐ Set the persistence context to read-only.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 将持久化上下文设置为只读。
- en: Ⓑ Consequently, `flush()` will not update the database.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 因此，`flush()` 不会更新数据库。
- en: 'You can disable dirty checking for a single entity instance:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以禁用单个实体实例的脏检查：
- en: '[PRE9]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Ⓐ Set `item` in the persistence context to read-only.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 在持久化上下文中将 `item` 设置为只读。
- en: Ⓑ Consequently, `flush()` will not update the database.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 因此，`flush()` 不会更新数据库。
- en: 'A query with the `org.hibernate.Query` interface can return read-only results,
    which Hibernate doesn’t check for modifications:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `org.hibernate.Query` 接口的查询可以返回只读结果，Hibernate 不会检查修改：
- en: '[PRE10]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Ⓐ Set the query to read-only.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 将查询设置为只读。
- en: Ⓑ Consequently, `flush()` will not update the database.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 因此，`flush()` 不会更新数据库。
- en: 'With query hints you can also disable dirty checking for instances obtained
    with the JPA standard `javax.persistence.Query` interface:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用查询提示，您还可以禁用使用 JPA 标准的 `javax.persistence.Query` 接口获得的实例的脏检查：
- en: '[PRE11]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Be careful with read-only entity instances: you can still delete them, and
    modifications to collections are tricky! The Hibernate manual has a long list
    of special cases you need to read if you use these settings with mapped collections.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 对于只读实体实例要小心：您仍然可以删除它们，对集合的修改也很棘手！如果您使用这些设置与映射集合一起使用，Hibernate 手册中有一个很长的特殊案例列表，您需要阅读。
- en: So far, flushing and synchronization of the persistence context have occurred
    automatically, when the transaction commits. In some cases, though, we need more
    control over the synchronization process.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，持久化上下文的刷新和同步是在事务提交时自动发生的。然而，在某些情况下，我们需要对同步过程有更多的控制。
- en: 10.2.9 Flushing the persistence context
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.9 刷新持久化上下文
- en: By default, Hibernate flushes the persistence context of an `EntityManager`
    and synchronizes changes with the database whenever the joined transaction is
    committed. All the previous code examples, except some in the last section, have
    used that strategy. JPA allows implementations to synchronize the persistence
    context at other times if they wish.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Hibernate在联合事务提交时刷新`EntityManager`的持久化上下文，并将更改与数据库同步。所有之前的代码示例，除了最后一节的一些示例，都使用了那种策略。JPA允许实现选择在其它时间同步持久化上下文。
- en: 'Hibernate, as a JPA implementation, synchronizes at the following times:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 作为JPA实现，Hibernate在以下时间同步：
- en: When a joined Java Transaction API (JTA) system transaction is committed.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个联合的Java事务API (JTA) 系统事务提交时。
- en: Before a query is executed—we don’t mean a lookup with `find()` but a query
    with `javax.persistence.Query` or the similar Hibernate API.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在执行查询之前——我们这里说的不是使用`find()`进行的查找，而是使用`javax.persistence.Query`或类似的Hibernate
    API进行的查询。
- en: When the application calls `flush()` explicitly.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当应用程序显式调用`flush()`时。
- en: 'We can control this behavior with the `FlushModeType` setting of an `EntityManager`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`EntityManager`的`FlushModeType`设置来控制此行为：
- en: '[PRE12]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we load an `Item` instance and change its name. Then we query the database,
    retrieving the item’s name. Usually, Hibernate recognizes that data has changed
    in memory and synchronizes these modifications with the database before the query.
    This is the behavior of `FlushModeType.AUTO`, the default if we join the `EntityManager`
    with a transaction. With `FlushModeType.COMMIT` we disable flushing before queries,
    so we may see different data returned by the query than what we have in memory.
    The synchronization then occurs only when the transaction commits.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们加载一个`Item`实例并更改其名称。然后我们查询数据库，检索项目的名称。通常，Hibernate会识别内存中数据已更改，并在查询之前将这些修改与数据库同步。这是`FlushModeType.AUTO`的行为，如果我们用事务连接`EntityManager`，这是默认设置。使用`FlushModeType.COMMIT`我们禁用在查询之前的刷新，因此我们可能会看到查询返回的数据与内存中的数据不同。同步仅在事务提交时发生。
- en: We can, at any time while a transaction is in progress, force dirty checking
    and synchronization with the database by calling `EntityManager#flush()`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在事务进行过程中，我们可以通过调用`EntityManager#flush()`来强制进行脏检查和与数据库的同步。
- en: This concludes our discussion of the *transient*, *persistent*, and *removed*
    entity states, and the basic usage of the `EntityManager` API. Mastering these
    state transitions and API methods is essential; every JPA application is built
    with these operations.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对*临时*、*持久*和*已移除*实体状态的讨论，以及`EntityManager` API的基本用法。掌握这些状态转换和API方法是至关重要的；每个JPA应用程序都是通过这些操作构建的。
- en: Next we’ll look at the *detached* entity state. We already mentioned some problems
    we’ll see when entity instances aren’t associated with a persistence context anymore,
    such as disabled lazy initialization. Let’s explore the detached state with some
    examples, so we know what to expect when we work with data outside of a persistence
    context.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨*分离*的实体状态。我们已经提到了当实体实例不再与持久化上下文关联时会出现的一些问题，例如禁用延迟初始化。让我们通过一些示例来探索分离状态，以便我们知道在处理持久化上下文之外的数据时可以期待什么。
- en: 10.3 Working with detached state
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3 与分离状态一起工作
- en: If a reference leaves the scope of guaranteed identity, we call it a *reference*
    to a *detached entity instance*. When the persistence context is closed, it no
    longer provides an identity-mapping service. You’ll run into aliasing problems
    when you work with detached entity instances, so make sure you understand how
    to handle the identity of detached instances.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个引用离开了保证身份的作用域，我们称它为*分离实体实例*的*引用*。当持久化上下文关闭时，它不再提供身份映射服务。当你处理分离的实体实例时，会遇到别名问题，所以请确保你理解如何处理分离实例的身份。
- en: 10.3.1 The identity of detached instances
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.1 分离实例的标识
- en: If we look up data using the same database identifier value in the same persistence
    context, the result is two references to the same in-memory instance on the JVM
    heap. When different references are obtained from the same persistence context,
    they have the same Java identity. The references may be equal because by default
    `equals()` relies on Java identity comparison. They obviously have the same database
    identity. They reference the same instance, in persistent state, managed by the
    persistence context for that unit of work.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在相同的持久化上下文中使用相同的数据库标识符值查找数据，结果将是两个指向JVM堆上相同内存实例的引用。当从相同的持久化上下文中获取不同的引用时，它们具有相同的Java身份。这些引用可能相等，因为默认情况下`equals()`依赖于Java身份比较。它们显然具有相同的数据库身份。它们引用的是由该工作单元的持久化上下文管理的相同实例的持久状态。
- en: References are in a detached state when the first persistence context is closed.
    We may be dealing with instances that live outside of a guaranteed scope of object
    identity.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当第一个持久化上下文关闭时，引用处于分离状态。我们可能正在处理存在于对象身份保证范围之外的实例。
- en: Listing 10.2 Guaranteed scope of object identity in Java Persistence
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.2 Java持久性中对象身份的保证范围
- en: '[PRE13]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Ⓐ Create a persistence context.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 创建持久化上下文。
- en: Ⓑ Begin the transaction.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 开始事务。
- en: Ⓒ Load some entity instances.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 加载一些实体实例。
- en: Ⓓ References `a` and `b` are obtained from the same persistence context; they
    have the same Java identity.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 引用`a`和`b`是从相同的持久化上下文中获得的；它们具有相同的Java身份。
- en: Ⓔ `equals()` relies on Java identity comparison.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓔ `equals()`依赖于Java身份比较。
- en: Ⓕ `a` and `b` reference the same `Item` instance, in persistent state, managed
    by the persistence context for that unit of work.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓕ `a`和`b`引用的是由该工作单元的持久化上下文管理的相同`Item`实例，处于持久状态。
- en: Ⓖ Commit the transaction.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓖ 提交事务。
- en: Ⓗ Close the persistence context. References `a` and `b` are in a detached state
    when the first persistence context is closed.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓗ 关闭持久化上下文。当第一个持久化上下文关闭时，引用`a`和`b`处于分离状态。
- en: Ⓘ `a` and `c`, loaded in different persistence contexts, aren’t identical.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓘ 在不同的持久化上下文中加载的`a`和`c`并不相同。
- en: Ⓙ `a.equals(c)` is also `false`, because the `equals()` method has not been
    overridden, which means it uses instance equality (`==`).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓙ `a.equals(c)`也是`false`，因为`equals()`方法没有被重写，这意味着它使用实例相等性(`==`)。
- en: Ⓚ A test for database identity still returns `true`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓚ 对数据库身份的测试仍然返回`true`。
- en: 'If we treat entity instances as equal in detached state, this can lead to problems.
    For example, consider the following extension of the code, after the second unit
    of work has ended:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在分离状态下将实体实例视为相等，这可能会导致问题。例如，考虑以下代码的扩展，在第二个工作单元结束后：
- en: '[PRE14]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This example adds all three references to a `Set`, and all are references to
    detached instances. Now if we check the size of the collection—the number of elements—what
    result should we expect?
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例将所有三个引用添加到`Set`中，并且所有都是分离实例的引用。现在，如果我们检查集合的大小——元素的数量——我们应该期待什么结果？
- en: A `Set` doesn’t allow duplicate elements. Duplicates are detected by the `Set`;
    whenever we add a reference to a `HashSet`, the `Item#equals()` method is called
    automatically against all other elements already in the collection. If `equals()`
    returns `true` for any element already in the collection, the addition doesn’t
    occur.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`Set`不允许重复元素。重复项通过`Set`检测；每次我们向`HashSet`添加引用时，都会自动调用`Item#equals()`方法与集合中已存在的所有其他元素进行比较。如果`equals()`对集合中任何已存在的元素返回`true`，则不会发生添加。'
- en: By default, all Java classes inherit the `equals()` method of `java.lang.Object`.
    This implementation uses a double-equals (`==`) comparison to check whether two
    references refer to the same in-memory instance on the Java heap.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，所有Java类都继承自`java.lang.Object`的`equals()`方法。此实现使用双等号(`==`)比较来检查两个引用是否指向Java堆上的相同内存实例。
- en: You might guess that the number of elements in the collection will be 2\. After
    all, `a` and `b` are references to the same in-memory instance; they were loaded
    in the same persistence context. We obtained reference `c` from another persistence
    context; it refers to a different instance on the heap. We have three references
    to two instances, but we know this only because we’ve seen the code that loaded
    the data. In a real application, we may not know that `a` and `b` are loaded in
    a different context than `c`. Furthermore, we might expect that the collection
    has exactly one element because `a`, `b`, and `c` represent the same database
    row, the same `Item`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会猜测集合中的元素数量将是 2。毕竟，`a` 和 `b` 是对同一内存实例的引用；它们是在同一个持久化上下文中加载的。我们从另一个持久化上下文中获得了引用
    `c`；它指向堆上的不同实例。我们有三个引用指向两个实例，但我们之所以知道这一点，仅仅是因为我们看到了加载数据的代码。在实际应用中，我们可能不知道 `a`
    和 `b` 是在不同于 `c` 的上下文中加载的。此外，我们可能会期望集合恰好有一个元素，因为 `a`、`b` 和 `c` 代表相同的数据库行，相同的 `Item`。
- en: 'Whenever we work with instances in a detached state and test them for equality
    (usually in hash-based collections), we need to supply our own implementation
    of the `equals``()` and `hashCode()` methods for our mapped entity class. This
    is an important issue: if we don’t work with entity instances in a detached state,
    no action is needed, and the default `equals()` implementation of `java.lang.Object`
    is fine. We’ll rely on Hibernate’s guaranteed scope of object identity within
    a persistence context. Even if we work with detached instances, if we never check
    whether they’re equal, or we never put them in a `Set` or use them as keys in
    a `Map`, we don’t have to worry. If all we do is render a detached `Item` on the
    screen, we aren’t comparing it to anything.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时我们与分离状态的实例一起工作并测试它们的相等性（通常在基于哈希的集合中），我们都需要为我们的映射实体类提供自己的 `equals()` 和 `hashCode()`
    方法实现。这是一个重要的问题：如果我们不与分离状态的实体实例一起工作，则不需要采取任何行动，`java.lang.Object` 的默认 `equals()`
    实现就足够好了。我们将依赖 Hibernate 在持久化上下文中保证的对象身份范围。即使我们与分离实例一起工作，如果我们从不检查它们是否相等，或者从不将它们放入
    `Set` 中或用作 `Map` 中的键，我们也不必担心。如果我们所做的只是将分离的 `Item` 在屏幕上渲染出来，我们并没有将它与任何东西进行比较。
- en: Let’s assume that we want to use detached instances and that we have to test
    them for equality with our own method.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要使用分离的实例，并且必须使用我们自己的方法来测试它们的相等性。
- en: 10.3.2 Implementing equality methods
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.2 实现相等性方法
- en: We can implement `equals``()` and `hashCode()` methods several ways. Keep in
    mind that when we override `equals()`, we also need to override `hashCode()` so
    the two methods are consistent. If two instances are equal, they must have the
    same hash value.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以多种方式实现 `equals()` 和 `hashCode()` 方法。记住，当我们重写 `equals()` 方法时，我们也需要重写 `hashCode()`
    方法，以确保这两个方法的一致性。如果两个实例相等，它们必须具有相同的哈希值。
- en: A seemingly clever approach is to implement `equals``()` to compare just the
    database identifier property, which is often a surrogate primary key value. Basically,
    if two `Item` instances have the same identifier returned by `getId()`, they must
    be the same. If `getId()` returns `null`, it must be a transient `Item` that hasn’t
    been saved.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 一种看似聪明的做法是实现 `equals()` 来仅比较数据库标识符属性，这通常是代理主键值。基本上，如果两个 `Item` 实例通过 `getId()`
    返回相同的标识符，它们必须是相同的。如果 `getId()` 返回 `null`，它必须是一个尚未保存的瞬态 `Item`。
- en: 'Unfortunately, this solution has one huge problem: identifier values aren’t
    assigned by Hibernate until an instance becomes persistent. If a transient instance
    were added to a `Set` before being saved, then when we save it, its hash value
    would change while it’s contained by the `Set`. This is contrary to the contract
    of `java.util.Set`, breaking the collection. In particular, this problem makes
    cascading persistent states useless for mapped associations based on sets. We
    strongly discourage database identifier equality.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这个解决方案有一个巨大的问题：标识符值是在实例变得持久化之前由 Hibernate 分配的。如果在保存之前将一个瞬态实例添加到 `Set` 中，那么当我们保存它时，它的哈希值会在它被
    `Set` 包含时发生变化。这与 `java.util.Set` 的契约相矛盾，破坏了集合。特别是，这个问题使得基于集合的映射关联的级联持久化状态变得无用。我们强烈反对使用数据库标识符相等性。
- en: To get to the solution that we recommend, you need to understand the notion
    of a *business key*. A business key is a property or some combination of properties,
    that is unique for each instance with the same database identity. Essentially,
    it’s the natural key that we would use if we weren’t using a surrogate primary
    key instead. Unlike a natural primary key, it isn’t an absolute requirement that
    the business key never changes—as long as it changes rarely, that’s enough.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要得到我们推荐的解决方案，你需要理解*业务键*的概念。业务键是一个属性或一些属性的组合，对于具有相同数据库身份的每个实例都是唯一的。本质上，如果我们不使用代理主键，它就是我们会使用的自然键。与自然主键不同，业务键永远不会改变并不是一个绝对的要求——只要它很少改变，这就足够了。
- en: We argue that essentially every entity class should have a business key, even
    if it includes all properties of the class (which would be appropriate for some
    immutable classes). If our users are looking at a list of items on the screen,
    how do they differentiate between items A, B, and C? The same property, or combination
    of properties, is our business key. The business key is what the user thinks of
    as uniquely identifying a particular record, whereas the surrogate key is what
    the application and database systems rely on. The business key property or properties
    are most likely constrained `UNIQUE` in our database schema.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们认为，本质上每个实体类都应该有一个业务键，即使它包括类的所有属性（这对于某些不可变类可能是合适的）。如果我们的用户正在查看屏幕上的项目列表，他们如何区分项目A、B和C？相同的属性或属性组合是我们的业务键。业务键是用户认为可以唯一标识特定记录的东西，而代理键是应用程序和数据库系统所依赖的。业务键属性或属性在我们的数据库模式中最可能是受约束的`UNIQUE`。
- en: Let’s write custom equality methods for the `User` entity class; this is easier
    than comparing `Item` instances. For the `User` class, `username` is a great candidate
    business key. It’s always required, it’s unique with a database constraint, and
    it changes rarely, if ever.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为`User`实体类编写自定义的相等性方法；这比比较`Item`实例要容易。对于`User`类，`username`是一个很好的业务键候选。它总是必需的，它与数据库约束唯一，并且很少改变，如果有的话。
- en: Listing 10.3 Custom implementation of `User` equality
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.3 `User`的相等性自定义实现
- en: '[PRE15]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You may have noticed that the `equals()` method code always accesses the properties
    of the “other” reference via getter methods. This is extremely important because
    the reference passed as `other` may be a Hibernate proxy, not the actual instance
    that holds the persistent state. We can’t access the `username` field of a `User`
    proxy directly. To initialize the proxy to get the property value, we need to
    access it with a getter method. This is one point where Hibernate isn’t *completely*
    transparent, but it’s good practice anyway to use getter methods instead of direct
    instance variable access.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，`equals()`方法的代码总是通过getter方法访问“其他”引用的属性。这一点非常重要，因为作为`other`传递的引用可能是一个Hibernate代理，而不是实际持有持久状态的实例。我们无法直接访问`User`代理的`username`字段。为了初始化代理以获取属性值，我们需要使用getter方法来访问它。这是Hibernate不是*完全*透明的一个地方，但无论如何，使用getter方法而不是直接访问实例变量是一个好的实践。
- en: Check the type of the `other` reference with `instanceof`, rather than by comparing
    the values of `getClass()`. Again, the `other` reference may be a proxy, which
    is a runtime-generated subclass of `User`, so `this` and `other` may not be exactly
    the same type but a valid supertype or subtype. You’ll learn more about proxies
    in section 12.1.1.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`instanceof`检查`other`引用的类型，而不是通过比较`getClass()`的值。再次强调，`other`引用可能是一个代理，它是运行时生成的`User`的子类，因此`this`和`other`可能不是完全相同的类型，但可以是有效的超类型或子类型。你将在第12.1.1节中了解更多关于代理的信息。
- en: 'We can now safely compare `User` references in persistent state:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以安全地比较持久状态中的`User`引用：
- en: '[PRE16]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We also, of course, get correct behavior if we compare references to instances
    in the persistent and detached state:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果我们比较持久状态和分离状态中实例的引用，我们也会得到正确的行为：
- en: '[PRE17]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Ⓐ Comparing the two references will, of course, still be false.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 比较这两个引用当然仍然是假的。
- en: Ⓑ Now they are equal.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 现在它们是相等的。
- en: Ⓒ The size of the set is finally correct.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 集合的大小最终是正确的。
- en: 'For some other entities, the business key may be more complex, consisting of
    a combination of properties. Here are some hints that should help you identify
    a business key in the domain model classes:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些其他实体，业务键可能更复杂，由属性的组合组成。以下是一些可以帮助你在领域模型类中识别业务键的提示：
- en: Consider what attributes users of the application will refer to when they have
    to identify an object (in the real world). How do users tell the difference between
    one element and another if they’re displayed on the screen? This is probably the
    business key to look for.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑当应用程序的用户需要识别一个对象（在现实世界中）时会参考哪些属性。如果它们在屏幕上显示，用户如何区分一个元素与另一个元素？这可能是你寻找的业务键。
- en: Every immutable attribute is probably a good candidate for the business key.
    Mutable attributes may be good candidates, too, if they’re updated rarely or if
    you can control the case when they’re updated, such as by ensuring the instances
    aren’t in a `Set` at the time.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个不可变属性可能是业务键的良好候选者。如果它们很少更新或者你可以控制它们更新的情况，例如确保实例不在 `Set` 中，那么可变属性也可能是好的候选者。
- en: Every attribute that has a `UNIQUE` database constraint is a good candidate
    for the business key. Remember that the precision of the business key has to be
    good enough to avoid overlaps.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个具有 `UNIQUE` 数据库约束的属性都是业务键的良好候选者。记住，业务键的精度必须足够高，以避免重叠。
- en: Any date or time-based attribute, such as the creation timestamp of the record,
    is usually a good component of a business key, but the accuracy of `System .currentTimeMillis()`
    depends on the virtual machine and operating system. Our recommended safety buffer
    is 50 milliseconds, which may not be accurate enough if the time-based property
    is the single attribute of a business key.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何基于日期或时间的属性，例如记录的创建时间戳，通常是业务键的一个良好组成部分，但 `System .currentTimeMillis()` 的准确性取决于虚拟机和操作系统。我们推荐的安全缓冲区是
    50 毫秒，如果基于时间的属性是业务键的唯一属性，这可能不够准确。
- en: You can use database identifiers as part of the business key. This seems to
    contradict our previous statements, but we aren’t talking about the database identifier
    value of the given entity. You may be able to use the database identifier of an
    associated entity instance. For example, a candidate business key for the `Bid`
    class is the identifier of the `Item` it matches, together with the bid amount.
    You may even have a unique constraint that represents this composite business
    key in the database schema. You can use the identifier value of the associated
    `Item` because it never changes during the lifecycle of a `Bid`—the `Bid` constructor
    can require an already-persistent `Item`.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以将数据库标识符作为业务键的一部分。这似乎与我们的先前声明相矛盾，但我们讨论的并不是给定实体的数据库标识符值。你可能能够使用关联实体实例的数据库标识符。例如，`Bid`
    类的一个候选业务键是与它匹配的 `Item` 的标识符，以及投标金额。你甚至可以在数据库模式中有一个唯一约束来表示这个复合业务键。你可以使用关联的 `Item`
    的标识符值，因为它在 `Bid` 的生命周期中永远不会改变——`Bid` 构造函数可以要求一个已经持久化的 `Item`。
- en: If you follow this advice, you shouldn’t have much difficulty finding a good
    business key for all your business classes. If you encounter a difficult case,
    try to solve it without considering Hibernate. After all, it’s purely an object-oriented
    problem. Notice that it’s extremely rarely correct to override `equals()` on a
    subclass and include another property in the comparison. It’s a little tricky
    to satisfy the `Object` identity and equality requirements that equality is both
    symmetric and transitive in this case, and more important, the business key may
    not correspond to any well-defined candidate natural key in the database (subclass
    properties may be mapped to a different table). For more information on customizing
    equality comparisons, see *Effective Java*, third edition, by Joshua Bloch (Bloch,
    2017), a mandatory book for all Java programmers.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遵循这些建议，你不太会遇到为所有业务类找到好的业务键的困难。如果你遇到困难的情况，尝试在不考虑 Hibernate 的情况下解决它。毕竟，这是一个纯粹面向对象的问题。请注意，在子类上重写
    `equals()` 并在比较中包含另一个属性的情况极为罕见。在这种情况下，满足 `Object` 标识和相等要求有点棘手，即相等既是对称的也是传递的，更重要的是，业务键可能不对应于数据库中的任何定义良好的候选自然键（子类属性可能映射到不同的表）。有关自定义相等比较的更多信息，请参阅
    Joshua Bloch 所著的第三版《Effective Java》（Bloch，2017），这是所有 Java 程序员必读的书籍。
- en: The `User` class is now prepared for the detached state; we can safely put instances
    loaded in different persistence contexts into a `Set`. Next we’ll look at some
    examples that involve the detached state, and you’ll see some of the benefits
    of this concept.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`User` 类现在已准备好进入分离状态；我们可以安全地将不同持久化上下文中加载的实例放入一个 `Set` 中。接下来，我们将查看一些涉及分离状态的示例，你将看到这个概念的一些好处。'
- en: 10.3.3 Detaching entity instances
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.3 分离实体实例
- en: 'Sometimes we might want to detach an entity instance manually from the persistence
    context. We don’t have to wait for the persistence context to close. We can evict
    entity instances manually:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们可能想手动将实体实例从持久化上下文中分离出来。我们不必等待持久化上下文关闭。我们可以手动驱逐实体实例：
- en: '[PRE18]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This example also demonstrates the `EntityManager#contains()` operation, which
    returns `true` if the given instance is in the managed persistent state in this
    persistence context.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例还演示了 `EntityManager#contains()` 操作，如果给定实例在此持久化上下文中处于管理持久状态，则返回 `true`。
- en: We can now work with the `user` reference in a detached state. Many applications
    only read and render the data after the persistence context is closed.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以以分离状态使用 `user` 引用了。许多应用程序只在持久化上下文关闭后读取和渲染数据。
- en: Modifying the loaded `user` after the persistence context is closed has no effect
    on its persistent representation in the database. JPA allows us to merge any changes
    back into the database in a new persistence context, though.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在持久化上下文关闭后修改加载的 `user` 对其在数据库中的持久化表示没有影响。尽管如此，JPA 允许我们在新的持久化上下文中合并任何更改回数据库。
- en: 10.3.4 Merging entity instances
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.4 合并实体实例
- en: 'Let’s assume we’ve retrieved a `User` instance in a previous persistence context,
    and now we want to modify it and save these modifications:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在之前的持久化上下文中检索了一个 `User` 实例，现在我们想修改它并保存这些修改：
- en: '[PRE19]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Consider the graphical representation of this procedure in figure 10.5\. The
    goal is to record the new `username` of the detached `User`. It’s not as difficult
    as it seems.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑图 10.5 中此过程的图形表示。目标是记录分离的 `User` 的新 `username`。这并不像看起来那么困难。
- en: '![](../../OEBPS/Images/CH10_F05_Tudose2.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH10_F05_Tudose2.png)'
- en: Figure 10.5 Making an instance persistent in a unit of work
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.5 在工作单元中使实例持久化
- en: First, when we call `merge()`, Hibernate checks whether a persistent instance
    in the persistence context has the same database identifier as the detached instance
    we merging. In this example, the persistence context is empty; nothing has been
    loaded from the database. Hibernate, therefore, loads an instance with this identifier
    from the database. Then `merge()` copies the detached entity instance *onto* this
    loaded persistent instance. In other words, the new `username` we have set on
    the detached `User` is also set on the persistent merged `User`, which `merge()`
    returns to us.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，当我们调用 `merge()` 时，Hibernate 会检查持久化上下文中的持久实例是否具有与我们要合并的分离实例相同的数据库标识符。在这个例子中，持久化上下文是空的；什么都没有从数据库中加载。因此，Hibernate
    从数据库中加载具有此标识符的实例。然后 `merge()` 将分离的实体实例 *复制到* 这个已加载的持久实例上。换句话说，我们在分离的 `User` 上设置的新
    `username` 也被设置在持久合并的 `User` 上，这是 `merge()` 返回给我们的。
- en: Now we discard the old reference to the stale and outdated detached state; the
    `detachedUser` no longer represents the current state. We can continue modifying
    the returned `mergedUser`; Hibernate will execute a single `UPDATE` when it flushes
    the persistence context during commit.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们丢弃了旧的、过时的分离状态的引用；`detachedUser` 不再代表当前状态。我们可以继续修改返回的 `mergedUser`；在提交期间，Hibernate
    将在刷新持久化上下文时执行单个 `UPDATE`。
- en: If there is no persistent instance with the same identifier in the persistence
    context, and a lookup by identifier in the database is negative, Hibernate instantiates
    a fresh `User`. Hibernate then copies our detached instance onto this fresh instance,
    which it inserts into the database when we synchronize the persistence context
    with the database.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果持久化上下文中没有具有相同标识符的持久实例，并且数据库中的按标识符查找为负，Hibernate 会实例化一个新的 `User`。然后 Hibernate
    将我们的分离实例复制到这个新实例上，当我们同步持久化上下文与数据库时，它会将这个新实例插入到数据库中。
- en: If the instance we’re giving to `merge()` is not detached but rather is transient
    (it doesn’t have an identifier value), Hibernate instantiates a fresh `User`,
    copies the values of the transient `User` onto it, and then makes it persistent
    and returns it to us. In simpler terms, the `merge()` operation can handle detached
    *and* transient entity instances. Hibernate always returns the result to us as
    a persistent instance.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们传递给 `merge()` 的实例不是分离的，而是临时的（它没有标识符值），Hibernate 会实例化一个新的 `User`，将临时 `User`
    的值复制到它上面，然后使其持久化并返回给我们。用更简单的话说，`merge()` 操作可以处理分离的 *和* 临时的实体实例。Hibernate 总是作为持久化实例返回结果给我们。
- en: An application architecture based on detachment and merging may not call the
    `persist()` operation. We can merge new and detached entity instances to store
    data. The important difference is the returned current state and how we handle
    this switch of references in our application code. We have to discard the `detachedUser`
    and from now on reference the current `mergedUser`. Every other component in our
    application still holding on to `detachedUser` has to switch to `mergedUser`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 基于分离和合并的应用程序架构可能不会调用`persist()`操作。我们可以合并新的和分离的实体实例以存储数据。重要的区别是返回的当前状态以及我们在应用程序代码中如何处理这种引用切换。我们必须丢弃`detachedUser`，从现在开始引用当前的`mergedUser`。我们应用程序中的其他任何其他组件仍然持有`detachedUser`的，都必须切换到`mergedUser`。
- en: Can I reattach a detached instance?
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我能否重新附加一个分离实例？
- en: The Hibernate `Session` API has a method for reattachment called `saveOrUpdate()`.
    It accepts either a transient or a detached instance and doesn’t return anything.
    The given instance will be in a persistent state after the operation, so we don’t
    have to switch references. Hibernate will execute an `INSERT` if the given instance
    was transient or an `UPDATE` if it was detached. We recommend that you rely on
    merging instead, because it’s standardized and therefore easier to integrate with
    other frameworks. In addition, instead of an `UPDATE`, merging may only trigger
    a `SELECT` if the detached data wasn’t modified. If you’re wondering what the
    `saveOrUpdateCopy()` method of the `Session` API does, it’s the same as `merge()`
    on the `EntityManager`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate `Session` API有一个名为`saveOrUpdate()`的重新附加方法。它接受瞬态或分离实例，并且不返回任何内容。操作后，给定实例将处于持久化状态，因此我们不需要切换引用。如果给定实例是瞬态的，Hibernate将执行`INSERT`；如果是分离的，将执行`UPDATE`。我们建议您依赖合并，因为它标准化了，因此更容易与其他框架集成。此外，合并可能只会触发`SELECT`而不是`UPDATE`，如果分离的数据没有被修改。如果您想知道`Session`
    API的`saveOrUpdateCopy()`方法做什么，它与`EntityManager`上的`merge()`相同。
- en: If we want to delete a detached instance, we have to merge it first. Then we
    can call `remove()` on the persistent instance returned by `merge()`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要删除一个分离实例，我们必须先合并它。然后我们可以在`merge()`方法返回的持久化实例上调用`remove()`。
- en: Summary
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: The lifecycle of entity instances includes the transient, persistent, detached,
    and removed states.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体实例的生命周期包括瞬态、持久化、分离和移除状态。
- en: The most important interface in JPA is `EntityManager`.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JPA中最重要的接口是`EntityManager`。
- en: We can use the `EntityManager` to make data persistent, retrieve and modify
    persistent data, get a reference, make data transient, refresh and replicate data,
    cache in the persistence context, and flush the persistence context.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`EntityManager`来使数据持久化，检索和修改持久化数据，获取引用，使数据瞬态，刷新和复制数据，在持久化上下文中缓存，以及刷新持久化上下文。
- en: We can work with the detached state, using the identity of detached instances
    and implementing equality methods.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以处理分离状态，使用分离实例的身份并实现相等方法。
