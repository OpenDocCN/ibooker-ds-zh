- en: appendix B Â Glossary and quick reference
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: é™„å½•B æœ¯è¯­è¡¨å’Œå¿«é€Ÿå‚è€ƒ
- en: This appendix provides a quick reference to many of the quantum concepts covered
    in this book, as well as to the Q# language (version 0.15). Most of the contents
    of this appendix are covered in the main body but are collected here for convenience.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: æœ¬é™„å½•æä¾›äº†å¯¹æœ¬ä¹¦ä¸­æ¶µç›–çš„è®¸å¤šé‡å­æ¦‚å¿µä»¥åŠQ#è¯­è¨€ï¼ˆç‰ˆæœ¬0.15ï¼‰çš„å¿«é€Ÿå‚è€ƒã€‚æœ¬é™„å½•çš„å¤§éƒ¨åˆ†å†…å®¹å·²åœ¨æ­£æ–‡ä¸­æœ‰è¦†ç›–ï¼Œä½†åœ¨æ­¤æ”¶é›†ä»¥æ–¹ä¾¿æŸ¥é˜…ã€‚
- en: B.1 Glossary
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.1 æœ¯è¯­è¡¨
- en: '**adjoint operation** A quantum operation that perfectly reverses or undoes
    the action of another quantum operation. Operations that are their own adjoint,
    such as `X` and `H`, are self-adjoint. If an operation can be simulated by the
    unitary matrix *U*, its adjoint operation can be simulated by the complex transpose
    of *U*, also known as the adjoint of *U* and written *U*â€ . In Q#, operations that
    have adjoint operations are denoted by `is Adj`.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**ä¼´éšæ“ä½œ** å®Œç¾åè½¬æˆ–å–æ¶ˆå¦ä¸€ä¸ªé‡å­æ“ä½œä½œç”¨çš„é‡å­æ“ä½œã€‚ä¾‹å¦‚ï¼Œ`X`å’Œ`H`è¿™æ ·çš„æ“ä½œæ˜¯è‡ªä¼´éšçš„ã€‚å¦‚æœä¸€ä¸ªæ“ä½œå¯ä»¥è¢«å•ä½çŸ©é˜µ *U* æ¨¡æ‹Ÿï¼Œé‚£ä¹ˆå®ƒçš„ä¼´éšæ“ä½œå¯ä»¥é€šè¿‡
    *U* çš„å¤å…±è½­æ¨¡æ‹Ÿï¼Œä¹Ÿç§°ä¸º *U* çš„ä¼´éšï¼Œè®°ä½œ *U*â€ ã€‚åœ¨Q#ä¸­ï¼Œå…·æœ‰ä¼´éšæ“ä½œçš„è¿ç®—ç”¨`is Adj`è¡¨ç¤ºã€‚'
- en: '**algorithm** A procedure for solving a problem, typically specified as a sequence
    of steps.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**ç®—æ³•** è§£å†³é—®é¢˜çš„ç¨‹åºï¼Œé€šå¸¸æŒ‡å®šä¸ºä¸€ç³»åˆ—æ­¥éª¤ã€‚'
- en: '**BB84** Short for â€œBennett and Brassard 1984.â€ A protocol for performing quantum
    key distribution (QKD) by sending single qubits at a time.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**BB84** â€œBennett and Brassard 1984â€çš„ç¼©å†™ã€‚ä¸€ç§é€šè¿‡æ¯æ¬¡å‘é€ä¸€ä¸ªé‡å­æ¯”ç‰¹æ¥æ‰§è¡Œé‡å­å¯†é’¥åˆ†å‘ï¼ˆQKDï¼‰çš„åè®®ã€‚'
- en: '**Bornâ€™s rule** A mathematical expression that can be used to predict the probability
    of a quantum measurement, given a description of that measurement and of the state
    of the register being measured.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**æ³¢æ©è§„åˆ™** ä¸€ä¸ªæ•°å­¦è¡¨è¾¾å¼ï¼Œå¯ä»¥ç”¨æ¥é¢„æµ‹é‡å­æµ‹é‡çš„æ¦‚ç‡ï¼Œç»™å®šå¯¹è¯¥æµ‹é‡çš„æè¿°ä»¥åŠè¢«æµ‹é‡çš„å¯„å­˜å™¨çŠ¶æ€ã€‚'
- en: '**classical bit** The smallest functional unit of storage and processing in
    a classical computer. A classical bit can be in either the â€œ0â€ or â€œ1â€ state.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**ç»å…¸æ¯”ç‰¹** ç»å…¸è®¡ç®—æœºä¸­æœ€å°çš„å­˜å‚¨å’Œå¤„ç†åŠŸèƒ½å•å…ƒã€‚ç»å…¸æ¯”ç‰¹å¯ä»¥æ˜¯â€œ0â€æˆ–â€œ1â€çŠ¶æ€ä¹‹ä¸€ã€‚'
- en: '**classical computer** A conventional computer that uses the laws of classical
    physics to perform computations.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**ç»å…¸è®¡ç®—æœº** ä½¿ç”¨ç»å…¸ç‰©ç†å®šå¾‹è¿›è¡Œè®¡ç®—çš„ä¼ ç»Ÿè®¡ç®—æœºã€‚'
- en: '**controlled operation** A quantum operation applied based on the state of
    a control register without measuring, such that superpositions are correctly preserved.
    For example, the CNOT operation is a controlled-NOT or controlled-X operation.
    Similarly, the Fredkin operation is a controlled-SWAP operation. In Q#, operations
    that can be controlled are denoted by `is Ctl`.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**æ§åˆ¶æ“ä½œ** åŸºäºæ§åˆ¶å¯„å­˜å™¨çš„çŠ¶æ€åº”ç”¨çš„ä¸€ç§é‡å­æ“ä½œï¼Œä¸è¿›è¡Œæµ‹é‡ï¼Œä»è€Œæ­£ç¡®åœ°ä¿ç•™å åŠ æ€ã€‚ä¾‹å¦‚ï¼ŒCNOTæ“ä½œæ˜¯ä¸€ä¸ªæ§åˆ¶éæˆ–æ§åˆ¶Xæ“ä½œã€‚åŒæ ·ï¼ŒFredkinæ“ä½œæ˜¯ä¸€ä¸ªæ§åˆ¶äº¤æ¢æ“ä½œã€‚åœ¨Q#ä¸­ï¼Œå¯ä»¥æ§åˆ¶çš„æ“ä½œç”¨`is
    Ctl`è¡¨ç¤ºã€‚'
- en: '**complex number** A number of the form *z = a + bi*, where *i*Â² = â€“1.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**å¤æ•°** å½¢å¦‚ *z = a + bi* çš„æ•°ï¼Œå…¶ä¸­ *i*Â² = â€“1ã€‚'
- en: '**computational basis state** A state labeled by a string of classical bits.
    For example, |01101ã€‰ is a computational basis state on a five-qubit register.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**è®¡ç®—åŸºæ€** ç”±ç»å…¸æ¯”ç‰¹å­—ç¬¦ä¸²æ ‡è®°çš„çŠ¶æ€ã€‚ä¾‹å¦‚ï¼Œ|01101ã€‰æ˜¯ä¸€ä¸ªäº”æ¯”ç‰¹å¯„å­˜å™¨ä¸Šçš„è®¡ç®—åŸºæ€ã€‚'
- en: '**computer** A device that takes data as input and does some sort of operations
    on that data.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**è®¡ç®—æœº** ä¸€ç§æ¥æ”¶æ•°æ®ä½œä¸ºè¾“å…¥å¹¶åœ¨è¯¥æ•°æ®ä¸Šæ‰§è¡ŒæŸç§æ“ä½œçš„è®¾å¤‡ã€‚'
- en: '**coprime** Two positive integers that share no prime factors. For instance,
    21 = 3 Ã— 7 and 10 = 2 Ã— 5 are coprime, while 21 = 3 Ã— 7 and 15 = 3 Ã— 5 share 3
    as a factor and thus are not coprime.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**äº’è´¨** æ²¡æœ‰å…¬å› æ•°çš„ä¸¤ä¸ªæ­£æ•´æ•°ã€‚ä¾‹å¦‚ï¼Œ21 = 3 Ã— 7 å’Œ 10 = 2 Ã— 5 æ˜¯äº’è´¨çš„ï¼Œè€Œ 21 = 3 Ã— 7 å’Œ 15 = 3 Ã—
    5 å…±äº«3ä½œä¸ºå…¬å› æ•°ï¼Œå› æ­¤ä¸æ˜¯äº’è´¨çš„ã€‚'
- en: '**entanglement** When the states of two or more qubits cannot be written out
    independently. For example, if two qubits are in the state (|00ã€‰ + |11ã€‰) / âˆš2,
    then there are no two single-qubit states |*Î¨*ã€‰ and |*Ï•*ã€‰ such that (|00ã€‰ + |11ã€‰)
    / âˆš2 = |*Î¨*ã€‰ âŠ— |*Ï•*ã€‰, and the two qubits are entangled.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**çº ç¼ ** å½“ä¸¤ä¸ªæˆ–æ›´å¤šé‡å­æ¯”ç‰¹çš„çŠ¶æ€ä¸èƒ½ç‹¬ç«‹å†™å‡ºæ—¶ã€‚ä¾‹å¦‚ï¼Œå¦‚æœä¸¤ä¸ªé‡å­æ¯”ç‰¹å¤„äº (|00ã€‰ + |11ã€‰) / âˆš2 çŠ¶æ€ï¼Œé‚£ä¹ˆä¸å­˜åœ¨ä¸¤ä¸ªå•é‡å­æ¯”ç‰¹çŠ¶æ€
    |*Î¨*ã€‰ å’Œ |*Ï•*ã€‰ ä½¿å¾— (|00ã€‰ + |11ã€‰) / âˆš2 = |*Î¨*ã€‰ âŠ— |*Ï•*ã€‰ï¼Œå¹¶ä¸”è¿™ä¸¤ä¸ªé‡å­æ¯”ç‰¹æ˜¯çº ç¼ çš„ã€‚'
- en: '**eigenphase** The global phase assigned to an eigenstate by a quantum operation.
    For example, the |âˆ’ã€‰ = (|0ã€‰ âˆ’ |1ã€‰) / âˆš2 eigenstate of the `X` operation has an
    eigenphase of â€“1, since *X*|â€“ã€‰ = (|1ã€‰ âˆ’ |0ã€‰) / âˆš2 = â€“|â€“ã€‰.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**æœ¬å¾ç›¸** é‡å­æ“ä½œèµ‹äºˆæœ¬å¾æ€çš„å…¨å±€ç›¸ã€‚ä¾‹å¦‚ï¼Œ`X`æ“ä½œçš„ |âˆ’ã€‰ = (|0ã€‰ âˆ’ |1ã€‰) / âˆš2 æœ¬å¾æ€å…·æœ‰æœ¬å¾ç›¸ â€“1ï¼Œå› ä¸º *X*|â€“ã€‰
    = (|1ã€‰ âˆ’ |0ã€‰) / âˆš2 = â€“|â€“ã€‰ã€‚'
- en: '**eigenstate** A state that is unmodified by application of a quantum operation,
    up to a possible global phase. For example, the |+ã€‰ state is an eigenstate of
    the `X` operation since *X*|+ã€‰ = |+ã€‰.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**æœ¬å¾æ€** ä¸€ä¸ªåœ¨åº”ç”¨é‡å­æ“ä½œåæœªè¢«ä¿®æ”¹çš„çŠ¶æ€ï¼Œç›´åˆ°å¯èƒ½çš„å…¨å±€ç›¸ä½ã€‚ä¾‹å¦‚ï¼Œ|+ã€‰ çŠ¶æ€æ˜¯ `X` æ“ä½œçš„æœ¬å¾æ€ï¼Œå› ä¸º *X*|+ã€‰ = |+ã€‰ã€‚'
- en: '**eigenvalue** Given a matrix *A*, a number *Î»* is an eigenvalue of *A* if
    *A*![](../Images/AR_x.png) = *Î»*![](../Images/AR_x.png) for some vector ![](../Images/AR_x.png).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**ç‰¹å¾å€¼** ç»™å®šä¸€ä¸ªçŸ©é˜µ *A*ï¼Œä¸€ä¸ªæ•° *Î»* æ˜¯ *A* çš„ç‰¹å¾å€¼ï¼Œå¦‚æœå¯¹äºæŸä¸ªå‘é‡ ![](../Images/AR_x.png)ï¼Œæœ‰ *A*![](../Images/AR_x.png)
    = *Î»*![](../Images/AR_x.png)ã€‚'
- en: '**eigenvector** Given a matrix *A*, a vectorÂ ![](../Images/AR_x.png) of *A*
    if *A*![](../Images/AR_x.png) = *Î»*![](../Images/AR_x.png) for some number *Î»*.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**æœ¬å¾å‘é‡** ç»™å®šä¸€ä¸ªçŸ©é˜µ *A*ï¼Œä¸€ä¸ªå‘é‡ ![](../Images/AR_x.png) æ˜¯ *A* çš„æœ¬å¾å‘é‡ï¼Œå¦‚æœå¯¹äºæŸä¸ªæ•° *Î»*ï¼Œæœ‰
    *A*![](../Images/AR_x.png) = *Î»*![](../Images/AR_x.png)ã€‚'
- en: '**global phase** Any two quantum states that are equal up to multiplication
    by a complex number of magnitude 1 differ by a global phase. In that case, the
    two states are completely equivalent. For example, (|0ã€‰ âˆ’ |1ã€‰) / âˆš2 and (|1ã€‰ âˆ’
    |0ã€‰) / âˆš2 represent the same state, as they differ by a phase of â€“1 = *e^(iÏ€)*.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**å…¨å±€ç›¸ä½** ä»»ä½•ä¸¤ä¸ªé‡å­æ€ï¼Œåªè¦ä¹˜ä»¥æ¨¡ä¸º1çš„å¤æ•°ï¼Œå®ƒä»¬å°±æ˜¯ç­‰ä»·çš„ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œè¿™ä¸¤ä¸ªæ€æ˜¯å®Œå…¨ç­‰æ•ˆçš„ã€‚ä¾‹å¦‚ï¼Œ(|0ã€‰ âˆ’ |1ã€‰) / âˆš2 å’Œ
    (|1ã€‰ âˆ’ |0ã€‰) / âˆš2 ä»£è¡¨ç›¸åŒçš„æ€ï¼Œå› ä¸ºå®ƒä»¬ç›¸å·®ä¸€ä¸ªç›¸ä½ â€“1 = *e^(iÏ€)*ã€‚'
- en: '**measurement** A quantum operation that returns classical data about the state
    of a quantum register.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**æµ‹é‡** ä¸€ä¸ªè¿”å›å…³äºé‡å­å¯„å­˜å™¨çŠ¶æ€çš„ç»å…¸æ•°æ®çš„é‡å­æ“ä½œã€‚'
- en: '**no-cloning theorem** The mathematical theorem proving that there cannot exist
    a quantum operation that perfectly copies quantum information. For example, it
    is impossible to make an operation that transforms the state |*Î¨*ã€‰ âŠ— |0ã€‰ to |*Î¨*ã€‰
    âŠ— |*Î¨*ã€‰ for arbitrary quantum states |*Î¨*ã€‰.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**æ— å…‹éš†å®šç†** ä¸€ä¸ªæ•°å­¦å®šç†ï¼Œè¯æ˜ä¸å­˜åœ¨ä¸€ä¸ªå¯ä»¥å®Œç¾å¤åˆ¶é‡å­ä¿¡æ¯çš„é‡å­æ“ä½œã€‚ä¾‹å¦‚ï¼Œä¸å¯èƒ½åˆ¶ä½œä¸€ä¸ªå°†çŠ¶æ€ |*Î¨*ã€‰ âŠ— |0ã€‰ è½¬æ¢ä¸º |*Î¨*ã€‰
    âŠ— |*Î¨*ã€‰ çš„æ“ä½œï¼Œå¯¹äºä»»æ„çš„é‡å­çŠ¶æ€ |*Î¨*ã€‰ã€‚'
- en: '**oracle** A quantum operation that implements a classical function applied
    to quantum registers.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**ç®—å­** å®ç°åº”ç”¨äºé‡å­å¯„å­˜å™¨çš„ç»å…¸å‡½æ•°çš„é‡å­æ“ä½œã€‚'
- en: '**Pauli matrices** The single-qubit unitary matrices ğŸ™, *X*, *Y*, andÂ *Z*.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**æ³¡åˆ©çŸ©é˜µ** å•é‡å­æ¯”ç‰¹å•ä½çŸ©é˜µ ğŸ™, *X*, *Y*, å’Œ *Z*ã€‚'
- en: '**phase** A complex number of magnitude 1 (i.e., *a* + *bi*, where |*a*|Â² +
    |*b*|Â² = 1). A phase can be written as *e^(iÎ¸)*, where *Î¸* is a real number. Note
    that as a shorthand, when it is clear from context, sometimes *Î¸* itself is known
    as a phase.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**ç›¸ä½** ä¸€ä¸ªæ¨¡ä¸º1çš„å¤æ•°ï¼ˆå³ *a* + *bi*ï¼Œå…¶ä¸­ |*a*|Â² + |*b*|Â² = 1ï¼‰ã€‚ç›¸ä½å¯ä»¥å†™æˆ *e^(iÎ¸)*ï¼Œå…¶ä¸­ *Î¸*
    æ˜¯ä¸€ä¸ªå®æ•°ã€‚æ³¨æ„ï¼Œä½œä¸ºä¸€ä¸ªç¼©å†™ï¼Œå½“ä¸Šä¸‹æ–‡æ¸…æ¥šæ—¶ï¼Œæœ‰æ—¶ *Î¸* æœ¬èº«ä¹Ÿè¢«ç§°ä¸ºç›¸ä½ã€‚'
- en: '**phase estimation** Any quantum algorithm for learning the eigenphase associated
    with a given eigenstate of a quantum operation.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**ç›¸ä½ä¼°è®¡** ä»»ä½•å­¦ä¹ ä¸é‡å­æ“ä½œç»™å®šæœ¬å¾æ€ç›¸å…³çš„æœ¬å¾ç›¸çš„é‡å­ç®—æ³•ã€‚'
- en: '**phase kickback** A quantum programming technique for associating the phase
    applied by a controlled quantum operation to the state of the control register
    instead of the state of the target register. This technique can be used to convert
    what would otherwise be a global phase applied by a unitary operation into a physically
    observable phase.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**ç›¸ä½å›å¼¹** ä¸€ç§é‡å­ç¼–ç¨‹æŠ€æœ¯ï¼Œç”¨äºå°†å—æ§é‡å­æ“ä½œåº”ç”¨çš„ç›¸ä½ä¸æ§åˆ¶å¯„å­˜å™¨çš„çŠ¶æ€ç›¸å…³è”ï¼Œè€Œä¸æ˜¯ç›®æ ‡å¯„å­˜å™¨çš„çŠ¶æ€ã€‚è¿™é¡¹æŠ€æœ¯å¯ä»¥å°†æœ¬åº”é€šè¿‡å•ä½æ“ä½œåº”ç”¨çš„å…¨çƒç›¸ä½è½¬æ¢ä¸ºå¯è§‚å¯Ÿçš„ç‰©ç†ç›¸ä½ã€‚'
- en: '**program** A sequence of instructions that can be interpreted by a classical
    computer to perform a desired task.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**ç¨‹åº** ä¸€ç³»åˆ—å¯ä»¥è¢«ç»å…¸è®¡ç®—æœºè§£é‡Šä»¥æ‰§è¡Œæ‰€éœ€ä»»åŠ¡çš„æŒ‡ä»¤ã€‚'
- en: '**quantum computer** A quantum device designed and used to solve computational
    problems that are difficult for classical computers.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**é‡å­è®¡ç®—æœº** ä¸€ç§é‡å­è®¾å¤‡ï¼Œè®¾è®¡å’Œä½¿ç”¨æ¥è§£å†³ç»å…¸è®¡ç®—æœºéš¾ä»¥è§£å†³çš„é—®é¢˜ã€‚'
- en: '**quantum device** A quantum system built to achieve some purpose or to perform
    some task.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**é‡å­è®¾å¤‡** ä¸€ä¸ªæ„å»ºæ¥è¾¾åˆ°æŸäº›ç›®çš„æˆ–æ‰§è¡ŒæŸäº›ä»»åŠ¡çš„é‡å­ç³»ç»Ÿã€‚'
- en: '**quantum key distribution (QKD)** A communication protocol to share random
    numbers between two parties such that, when performed by devices that operate
    correctly, the security of the protocol is guaranteed by quantum mechanics (in
    particular, by the no-cloning theorem).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**é‡å­å¯†é’¥åˆ†å‘ (QKD**) ä¸€ç§é€šä¿¡åè®®ï¼Œç”¨äºåœ¨ä¸¤ä¸ªå½“äº‹äººä¹‹é—´å…±äº«éšæœºæ•°ï¼Œå½“ç”±æ­£ç¡®æ“ä½œçš„è®¾å¤‡æ‰§è¡Œæ—¶ï¼Œè¯¥åè®®çš„å®‰å…¨æ€§ç”±é‡å­åŠ›å­¦ï¼ˆç‰¹åˆ«æ˜¯æ— å…‹éš†å®šç†ï¼‰ä¿è¯ã€‚'
- en: '**quantum operation** A subroutine in a quantum program, representing a sequence
    of instructions sent to a quantum device and classical control flow. Some quantum
    operations, such as `X` and `H`, are built into a quantum device and are said
    to be *intrinsic*.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**é‡å­æ“ä½œ** é‡å­ç¨‹åºä¸­çš„ä¸€ä¸ªå­ä¾‹ç¨‹ï¼Œä»£è¡¨å‘é€åˆ°é‡å­è®¾å¤‡å’Œç»å…¸æ§åˆ¶æµçš„ä¸€ç³»åˆ—æŒ‡ä»¤ã€‚ä¸€äº›é‡å­æ“ä½œï¼Œå¦‚ `X` å’Œ `H`ï¼Œæ˜¯å†…ç½®åˆ°é‡å­è®¾å¤‡ä¸­çš„ï¼Œè¢«ç§°ä¸º
    *å†…åœ¨çš„*ã€‚'
- en: '**quantum program** A classical program that controls a quantum device by sending
    instructions to that device and processing measurement data returned by the device.
    Typically, quantum programs are written in a quantum programming language such
    as Q#.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**é‡å­ç¨‹åº** é€šè¿‡å‘è¯¥è®¾å¤‡å‘é€æŒ‡ä»¤å¹¶å¤„ç†è®¾å¤‡è¿”å›çš„æµ‹é‡æ•°æ®æ¥æ§åˆ¶é‡å­è®¾å¤‡çš„ç»å…¸ç¨‹åºã€‚é€šå¸¸ï¼Œé‡å­ç¨‹åºæ˜¯ç”¨Q#ç­‰é‡å­ç¼–ç¨‹è¯­è¨€ç¼–å†™çš„ã€‚'
- en: '**quantum register** A collection of qubits. The register can be in any computational
    basis state, labeled by strings of classical bits, or any superposition thereof.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**é‡å­å¯„å­˜å™¨** é‡å­æ¯”ç‰¹çš„é›†åˆã€‚å¯„å­˜å™¨å¯ä»¥å¤„äºä»»ä½•è®¡ç®—åŸºæ€ï¼Œç”±ç»å…¸æ¯”ç‰¹çš„å­—ç¬¦ä¸²æ ‡è®°ï¼Œæˆ–ä»»ä½•å åŠ æ€ã€‚'
- en: '**quantum state** The state of a quantum register (that is, a register of qubits),
    typically written as a vector of 2^(*n*) complex numbers, where *n* is the number
    of qubits in the register.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**é‡å­æ€** é‡å­å¯„å­˜å™¨ï¼ˆå³é‡å­æ¯”ç‰¹å¯„å­˜å™¨ï¼‰çš„çŠ¶æ€ï¼Œé€šå¸¸è¡¨ç¤ºä¸º2^(*n*)ä¸ªå¤æ•°å‘é‡çš„å½¢å¼ï¼Œå…¶ä¸­*n*æ˜¯å¯„å­˜å™¨ä¸­é‡å­æ¯”ç‰¹çš„æ•°é‡ã€‚'
- en: '**quantum system** A physical system that requires quantum mechanics to describe
    and simulate.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**é‡å­ç³»ç»Ÿ** éœ€è¦é‡å­åŠ›å­¦æ¥æè¿°å’Œæ¨¡æ‹Ÿçš„ç‰©ç†ç³»ç»Ÿã€‚'
- en: '**qubit** The smallest functional unit in a quantum computer. A single qubit
    can be in the |0ã€‰ state, the |1ã€‰ state, or any superposition thereof.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**é‡å­æ¯”ç‰¹** é‡å­è®¡ç®—æœºä¸­æœ€å°çš„åŠŸèƒ½å•å…ƒã€‚å•ä¸ªé‡å­æ¯”ç‰¹å¯ä»¥å¤„äº |0ã€‰ çŠ¶æ€ã€|1ã€‰ çŠ¶æ€æˆ–ä»»ä½•å åŠ æ€ã€‚'
- en: '**reversible** A classical function that can be perfectly inverted. For example,
    *f*(*x*) = Â¬*x* can be inverted, since *f*(*f*(*x*)) = *x*. Similarly, *g*(*x,y*)
    = (*x,x âŠ• y*) is reversible since *g*(*g*(*x,y*)) = (*x,y*). On the other hand,
    *h*(*x,y*) = (*x,x* AND *y*) is not reversible, since *h*(0,0) = *h*(0,1) = (0,0),
    so that we cannot determine the input to *H* given the output (0,0).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**å¯é€†** å¯ä»¥å®Œç¾åè½¬çš„ç»å…¸å‡½æ•°ã€‚ä¾‹å¦‚ï¼Œ*f*(*x*) = Â¬*x* å¯ä»¥åè½¬ï¼Œå› ä¸º *f*(*f*(*x*)) = *x*ã€‚åŒæ ·ï¼Œ*g*(*x,y*)
    = (*x,x âŠ• y*) æ˜¯å¯é€†çš„ï¼Œå› ä¸º *g*(*g*(*x,y*)) = (*x,y*)ã€‚å¦ä¸€æ–¹é¢ï¼Œ*h*(*x,y*) = (*x,x* AND *y*)
    ä¸å¯é€†ï¼Œå› ä¸º *h*(0,0) = *h*(0,1) = (0,0)ï¼Œå› æ­¤æˆ‘ä»¬æ— æ³•æ ¹æ®è¾“å‡ºï¼ˆ0,0ï¼‰ç¡®å®š *H* çš„è¾“å…¥ã€‚'
- en: '**semiprime** A positive integer with exactly two prime factors. For example,
    21 = 3 Ã— 7 is semiprime, while 105 = 3 Ã— 5 Ã— 7 has three prime factors and thus
    is not semiprime.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**åŠç´ æ•°** æ°æœ‰ä¸¤ä¸ªç´ å› å­çš„æ­£æ•´æ•°ã€‚ä¾‹å¦‚ï¼Œ21 = 3 Ã— 7 æ˜¯åŠç´ æ•°ï¼Œè€Œ 105 = 3 Ã— 5 Ã— 7 æœ‰ä¸‰ä¸ªç´ å› å­ï¼Œå› æ­¤ä¸æ˜¯åŠç´ æ•°ã€‚'
- en: '**state** A description of a physical system or device that is complete enough
    to allow simulating that device.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**çŠ¶æ€** å¯¹ç‰©ç†ç³»ç»Ÿæˆ–è®¾å¤‡çš„æè¿°ï¼Œè¶³ä»¥å…è®¸æ¨¡æ‹Ÿè¯¥è®¾å¤‡ã€‚'
- en: '**superposition** A quantum state that can be written as a linear combination
    of other states is in a superposition of those states. For example, |+ã€‰ = (|0ã€‰
    +|1ã€‰) / âˆš2 is a superposition of the states |0ã€‰ and |1ã€‰, while |0ã€‰ is a superposition
    of |+ã€‰ and |âˆ’ã€‰ = (|0ã€‰ âˆ’ |1ã€‰) / âˆš2.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**å åŠ æ€** å¯ä»¥è¡¨ç¤ºä¸ºå…¶ä»–çŠ¶æ€çš„çº¿æ€§ç»„åˆçš„é‡å­æ€å¤„äºè¿™äº›çŠ¶æ€çš„å åŠ ã€‚ä¾‹å¦‚ï¼Œ|+ã€‰ = (|0ã€‰ +|1ã€‰) / âˆš2 æ˜¯ |0ã€‰ å’Œ |1ã€‰ çŠ¶æ€çš„å åŠ ï¼Œè€Œ
    |0ã€‰ æ˜¯ |+ã€‰ å’Œ |âˆ’ã€‰ = (|0ã€‰ âˆ’ |1ã€‰) / âˆš2 çš„å åŠ ã€‚'
- en: '**unitary matrix** A matrix *U* such that *UU*â€  = ğŸ™, where *U*â€  is the conjugate
    transform, or adjoint of *U*. Similar to a classical truth table, a unitary matrix
    is a matrix that describes how a quantum operation transforms the state of its
    input so that it can be used to simulate that operation for arbitrary inputs.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**å¹ºæ­£çŸ©é˜µ** æ»¡è¶³ *UU*â€  = ğŸ™ çš„çŸ©é˜µ *U*ï¼Œå…¶ä¸­ *U*â€  æ˜¯å…±è½­å˜æ¢ï¼Œæˆ– *U* çš„ä¼´éšã€‚ç±»ä¼¼äºç»å…¸çœŸå€¼è¡¨ï¼Œå¹ºæ­£çŸ©é˜µæ˜¯æè¿°é‡å­æ“ä½œå¦‚ä½•å˜æ¢å…¶è¾“å…¥çŠ¶æ€ä»¥ä¾¿å¯ä»¥ç”¨äºæ¨¡æ‹Ÿä»»æ„è¾“å…¥çš„çŸ©é˜µã€‚'
- en: '**unitary operation** A quantum operation that can be represented by a unitary
    matrix. In Q#, unitary operations are adjointable and controllable (`is Adj +
    Ctl`).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**å¹ºæ­£æ“ä½œ** å¯ä»¥ç”¨å¹ºæ­£çŸ©é˜µè¡¨ç¤ºçš„é‡å­æ“ä½œã€‚åœ¨Q#ä¸­ï¼Œå¹ºæ­£æ“ä½œæ˜¯å¯é€†çš„å’Œå¯æ§çš„ï¼ˆ`is Adj + Ctl`ï¼‰ã€‚'
- en: B.2 Dirac notation
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.2 ç‹„æ‹‰å…‹ç¬¦å·
- en: Often, in quantum computing, we use a kind of compressed notation for vectors
    and matrices known as Dirac notation. This is covered in more detail throughout
    the book, but a few key points of Dirac notation are summarized in this table.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨é‡å­è®¡ç®—ä¸­ï¼Œæˆ‘ä»¬é€šå¸¸ä½¿ç”¨ä¸€ç§ç§°ä¸ºç‹„æ‹‰å…‹ç¬¦å·çš„å‹ç¼©è¡¨ç¤ºæ³•æ¥è¡¨ç¤ºå‘é‡å’ŒçŸ©é˜µã€‚æœ¬ä¹¦ä¸­å¯¹æ­¤æœ‰æ›´è¯¦ç»†çš„ä»‹ç»ï¼Œä½†æœ¬è¡¨æ€»ç»“äº†ç‹„æ‹‰å…‹ç¬¦å·çš„ä¸€äº›å…³é”®ç‚¹ã€‚
- en: '![](../Images/B-table1.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/B-table1.png)'
- en: B.3 Quantum operations
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.3 é‡å­æ“ä½œ
- en: This section summarizes some common quantum operations that you see throughout
    the book. In particular, we show how to call each operation from Q# by passing
    qubits as inputs; how to simulate that operation in QuTiP with a matrix that acts
    on states, the unitary matrix that we use to simulate each operation; and some
    examples of how that operation behaves mathematically.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: æœ¬èŠ‚æ€»ç»“äº†ä¹¦ä¸­å¸¸è§çš„ä¸€äº›é‡å­æ“ä½œã€‚ç‰¹åˆ«æ˜¯ï¼Œæˆ‘ä»¬å±•ç¤ºäº†å¦‚ä½•é€šè¿‡ä¼ é€’é‡å­æ¯”ç‰¹ä½œä¸ºè¾“å…¥ä»Q#è°ƒç”¨æ¯ä¸ªæ“ä½œï¼›å¦‚ä½•ä½¿ç”¨ä½œç”¨äºçŠ¶æ€çš„çŸ©é˜µã€æˆ‘ä»¬ç”¨äºæ¨¡æ‹Ÿæ¯ä¸ªæ“ä½œçš„å¹ºæ­£çŸ©é˜µåœ¨QuTiPä¸­æ¨¡æ‹Ÿè¯¥æ“ä½œï¼›ä»¥åŠè¯¥æ“ä½œåœ¨æ•°å­¦ä¸Šçš„è¡Œä¸ºçš„ä¸€äº›ç¤ºä¾‹ã€‚
- en: Note For a complete listing of all built-in Q# operations, see the Q# API reference
    at [https://docs.microsoft.com/qsharp/api](https://docs.microsoft.com/qsharp/api).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼šè¦æŸ¥çœ‹æ‰€æœ‰å†…ç½® Q# æ“ä½œçš„å®Œæ•´åˆ—è¡¨ï¼Œè¯·å‚é˜… Q# API å‚è€ƒ[https://docs.microsoft.com/qsharp/api](https://docs.microsoft.com/qsharp/api)ã€‚
- en: 'For all Q# examples, we have assumed the following `open` statement:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºæ‰€æœ‰ Q# ç¤ºä¾‹ï¼Œæˆ‘ä»¬å‡è®¾ä»¥ä¸‹ `open` è¯­å¥ï¼š
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For all Python/QuTiP examples, we have assumed the following `import` statements:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºæ‰€æœ‰ Python/QuTiP ç¤ºä¾‹ï¼Œæˆ‘ä»¬å‡è®¾ä»¥ä¸‹ `import` è¯­å¥ï¼š
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The second convention is not used in the book but is used here for brevity.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬äºŒç§çº¦å®šåœ¨ä¹¦ä¸­æœªä½¿ç”¨ï¼Œä½†åœ¨æ­¤å¤„ä¸ºäº†ç®€æ´è€Œä½¿ç”¨ã€‚
- en: Q# operations act on *qubits*, while QuTiP represents operations by unitary
    matrices that multiply *states*. Thus, in contrast with Q# operations, QuTiP objects
    do not explicitly list their inputs.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Q# æ“ä½œä½œç”¨äº *é‡å­æ¯”ç‰¹*ï¼Œè€Œ QuTiP é€šè¿‡ä¹˜ä»¥ *çŠ¶æ€* çš„å•ä½ç®—å­æ¥è¡¨ç¤ºæ“ä½œã€‚å› æ­¤ï¼Œä¸ Q# æ“ä½œç›¸æ¯”ï¼ŒQuTiP å¯¹è±¡ä¸æ˜ç¡®åˆ—å‡ºå®ƒä»¬çš„è¾“å…¥ã€‚
- en: '![](../Images/B-table2ab.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/B-table2ab.png)'
- en: B.4 Q# Language
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.4 Q# è¯­è¨€
- en: B.4.1 Types
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.4.1 ç±»å‹
- en: In the following table, we use `*italic monospace font*` to indicate a placeholder.
    For example, the `*BaseType*` placeholder in `*BaseType*``[]` can mean `Int`,
    `Double`, `Qubit`, `(Qubit, Qubit[])`, or any other Q# type.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ä¸‹è¡¨ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨ `*italic monospace font*` æ¥è¡¨ç¤ºå ä½ç¬¦ã€‚ä¾‹å¦‚ï¼Œåœ¨ `*BaseType*``[]` ä¸­çš„ `*BaseType*`
    å ä½ç¬¦å¯ä»¥è¡¨ç¤º `Int`ã€`Double`ã€`Qubit`ã€`(Qubit, Qubit[])` æˆ–ä»»ä½•å…¶ä»– Q# ç±»å‹ã€‚
- en: 'For emphasis, we have added the type of each example as an annotation after
    each value in some of the examples. For instance, `Sin : Double -> Double` indicates
    that `Sin` is a value whose type is `Double -> Double`.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 'ä¸ºäº†å¼ºè°ƒï¼Œæˆ‘ä»¬åœ¨ä¸€äº›ç¤ºä¾‹ä¸­åœ¨æ¯ä¸ªå€¼ä¹‹åæ·»åŠ äº†æ¯ä¸ªç¤ºä¾‹çš„ç±»å‹ä½œä¸ºæ³¨é‡Šã€‚ä¾‹å¦‚ï¼Œ`Sin : Double -> Double` è¡¨ç¤º `Sin` æ˜¯ä¸€ä¸ªç±»å‹ä¸º
    `Double -> Double` çš„å€¼ã€‚'
- en: '| Description | Q# type | Examples |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| æè¿° | Q# ç±»å‹ | ç¤ºä¾‹ |'
- en: '| Integers | `Int` | `3``-42``108` |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| æ•´æ•° | `Int` | `3``-42``108` |'
- en: '| Float | `Double` | `-3.1415``2.17` |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| æµ®ç‚¹æ•° | `Double` | `-3.14152.17` |'
- en: '| Booleans | `Bool` | `true``false` |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| å¸ƒå°”å€¼ | `Bool` | `true``false` |'
- en: '| Ranges of integers | `Range` | `0..3``0..Length(arr)``12..-1..0` |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| æ•´æ•°èŒƒå›´ | `Range` | `0..3``0..Length(arr)``12..-1..0` |'
- en: '| Empty tuple | `Unit` | `()` |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| ç©ºå…ƒç»„ | `Unit` | `()` |'
- en: '| Measurement results | `Result` | `Zero``One` |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| æµ‹é‡ç»“æœ | `Result` | `Zero``One` |'
- en: '| Pauli operators | `Pauli` | `PauliI``PauliX``PauliY``PauliZ` |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| æ³Šæ¾ç®—å­ | `Pauli` | `PauliI``PauliX``PauliY``PauliZ` |'
- en: '| Strings | `String` | "`Hello, world!`" |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| å­—ç¬¦ä¸² | `String` | "`Hello, world!`" |'
- en: '| Qubits | `Qubit` | (See `use` statement) |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| é‡å­æ¯”ç‰¹ | `Qubit` | (å‚è§ `use` è¯­å¥) |'
- en: '| Arrays | `BaseType[]` | `new Qubit[0]``[42, -101]` |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| æ•°ç»„ | `BaseType[]` | `new Qubit[0]``[42, -101]` |'
- en: '| Tuples | `(``*T1*``)`, `(``*T1*``,` `*T2*``)`, `(``*T1*``,` `*T2*``,` `*T3*``)`,
    and so forth | `(PauliX,` "`X`"`)``(1, true, Zero)` |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| å…ƒç»„ | `(``*T1*``)`, `(``*T1*``,` `*T2*``)`, `(``*T1*``,` `*T2*``,` `*T3*``)`,
    ä»¥åŠæ›´å¤š | `(PauliX,` "`X`"`)``(1, true, Zero)` |'
- en: '| Functions | `*InputType*` -> `*OutputType*` | `Sin : Double -> Double``Message
    : String -> Unit` |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| å‡½æ•° | `*InputType*` -> `*OutputType*` | `Sin : Double -> Double``Message :
    String -> Unit` |'
- en: '| Operations | `InputType` => `*OutuptTypeInputType* => Unit is Adj` (if adjointable)`*InputType*
    => Unit is Ctl` (if controllable)`*InputType* => Unit is Adj + Ctl` (if both adjointable
    and controllable) | `H : Qubit => Unit is Adj + Ctl``CNOT : (Qubit, Qubit) =>
    UnitÂ ``is Adj + Ctl``M : Qubit => Result``Measure : (Pauli[], Qubit[]) => Result`
    |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| æ“ä½œ | `InputType` => `*OutuptTypeInputType*` => Unit is Adj` (å¦‚æœå¯ä¼´éš)`*InputType*`
    => Unit is Ctl` (å¦‚æœå¯æ§)`*InputType*` => Unit is Adj + Ctl` (å¦‚æœæ—¢å¯ä¼´éšåˆå¯æ§) | `H : Qubit
    => Unit is Adj + Ctl``CNOT : (Qubit, Qubit) => UnitÂ ``is Adj + Ctl``M : Qubit
    => Result``Measure : (Pauli[], Qubit[]) => Result` |'
- en: B.4.2 Q# declarations and statements
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.4.2 Q# å£°æ˜å’Œè¯­å¥
- en: 'In the following table, we use `italic monospace` `*font*` to indicate a placeholder.
    For example, the `FunctionName` placeholder in `function FunctionName``(``input1
    : InputType1``) : OutputType` stands for the name of the function being defined,
    while the `InputType1` and `OutputType` placeholders stand for types from the
    table above.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 'åœ¨ä¸‹è¡¨ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨ `æ–œä½“ç­‰å®½å­—ä½“` `*font*` æ¥è¡¨ç¤ºå ä½ç¬¦ã€‚ä¾‹å¦‚ï¼Œåœ¨ `function FunctionName``(``input1 :
    InputType1``) : OutputType` ä¸­çš„ `FunctionName` å ä½ç¬¦è¡¨ç¤ºæ­£åœ¨å®šä¹‰çš„å‡½æ•°åç§°ï¼Œè€Œ `InputType1` å’Œ
    `OutputType` å ä½ç¬¦è¡¨ç¤ºæ¥è‡ªä¸Šè¡¨çš„ç±»å‹ã€‚'
- en: Q# keywords are indicated in `bold`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Q# å…³é”®å­—ä»¥ `ç²—ä½“` è¡¨ç¤ºã€‚
- en: '| Description | Q# syntax |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| æè¿° | Q# è¯­æ³• |'
- en: '| Comment until end of line | `//` `*comment text*` |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| è¡Œæ³¨é‡Šè‡³è¡Œå°¾ | `//` `*comment text*` |'
- en: '| Documentation comment (before operation or function) | `/// # Summary``///`
    `*summary body*``///``/// # Description``///` `*description body*``///``/// #
    Input``/// ##` `*input1*``///` `*description of input*` |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| æ“ä½œæˆ–å‡½æ•°å‰çš„æ–‡æ¡£æ³¨é‡Š | `/// # Summary``///` `*summary body*``///``/// # Description``///`
    `*description body*``///``/// # Input``/// ##` `*input1*``///` `*description of
    input*` |'
- en: '| Namespace declaration | `**namespace**` `*NamespaceName* {Â ``Â Â  // ...``}`
    |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| å‘½åç©ºé—´å£°æ˜ | `**namespace**` `*NamespaceName* {Â ``Â Â  // ...``}` |'
- en: '| Function declaration | `**function**` `*FunctionName*``(``*Â Â  Â input1* :`
    `*InputType1*``,`Â `*Â Â  Â input2* :` `*InputType2*``,Â ``Â Â  Â ...``) :` `*OutputType*
    {Â ``Â Â  Â // function body``}` |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| å‡½æ•°å£°æ˜ | `**function**` `*FunctionName*``(``*Â Â  Â input1* :` `*InputType1*``,`Â `*Â Â 
    Â input2* :` `*InputType2*``,Â ``Â Â  Â ...``) :` `*OutputType* {Â ``Â Â  Â // å‡½æ•°ä½“``}`
    |'
- en: '| Operation declaration | `**operation**` `*OperationName*``(`Â `*Â Â  Â input1*
    :` `*InputType1*``,`Â `*Â Â  Â input2* :` `*InputType2*``,Â ``Â Â  Â ...``) :` `*OutputType*
    {Â ``Â Â  Â // operation body``}` |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| æ“ä½œå£°æ˜ | `**operation**` `*OperationName*``(`Â `*Â Â  Â input1* :` `*InputType1*``,`Â `*Â Â 
    Â input2* :` `*InputType2*``,Â ``Â Â  Â ...``) :` `*OutputType* {Â ``Â Â  Â // æ“ä½œä½“``}`
    |'
- en: '| Operation declaration (adjointable and controllable) | `**operation**` `*OperationName*``(`Â `*Â Â 
    Â input1* :` `*InputType1*``,`Â `*Â Â  Â input2* :` `*InputType2*``,Â ``Â Â  Â ...``) :
    Unit` `**is** Adj + Ctl {Â ``Â Â  Â // operation body``}` |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| å¯é€†å’Œå¯æ§çš„æ“ä½œå£°æ˜ | `**operation**` `*OperationName*``(`Â `*Â Â  Â input1* :` `*InputType1*``,`Â `*Â Â 
    Â input2* :` `*InputType2*``,Â ``Â Â  Â ...``) : Unit` `**is** Adj + Ctl {Â ``Â Â  Â //
    æ“ä½œä½“``}` |'
- en: '| User-defined type declaration | `**newtype**` `*TypeName* = (`Â `*Â Â  Â ItemType1*``,`Â `*Â Â 
    Â ItemType2*``,Â ``Â Â  Â ...Â ``);` |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| ç”¨æˆ·å®šä¹‰ç±»å‹å£°æ˜ | `**newtype**` `*TypeName* = (`Â `*Â Â  Â ItemType1*``,`Â `*Â Â  Â ItemType2*``,Â ``Â Â 
    Â ...Â ``);` |'
- en: '| User-defined type declaration with named items | `**newtype**` `*TypeName*
    = (`Â `*Â Â  Â ItemName1*``:` `*ItemType1*``,`Â `*Â Â  Â ItemName2*``:` `*ItemType2*``,Â ``Â Â 
    Â ...Â ``);` |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| å¸¦æœ‰å‘½åé¡¹çš„ç”¨æˆ·å®šä¹‰ç±»å‹å£°æ˜ | `**newtype**` `*TypeName* = (`Â `*Â Â  Â ItemName1*``:` `*ItemType1*``,`Â `*Â Â 
    Â ItemName2*``:` `*ItemType2*``,Â ``Â Â  Â ...Â ``);` |'
- en: '| Open namespace (makes items in namespace available in a Q# file or notebook
    cell) | `**open**` `*NamespaceName*``**;**` |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| æ‰“å¼€å‘½åç©ºé—´ï¼ˆä½¿å‘½åç©ºé—´ä¸­çš„é¡¹åœ¨Q#æ–‡ä»¶æˆ–ç¬”è®°æœ¬å•å…ƒä¸­å¯ç”¨ï¼‰ | `**open**` `*NamespaceName*``**;**` |'
- en: '| Open namespace with alias | `**open**` `*NamespaceName*` `**as**` `*AliasName*``**;**`*Example:*`**open**
    Microsoft.Quantum.Diagnostics as Diag`; |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| ä½¿ç”¨åˆ«åæ‰“å¼€å‘½åç©ºé—´ | `**open**` `*NamespaceName*` `**as**` `*AliasName*``**;**`*ç¤ºä¾‹:*`**open**
    Microsoft.Quantum.Diagnostics as Diag`; |'
- en: '| Local variable declaration | `**let**` `*name* =` `*value*``;`*Example:*`**let**
    foo = "Bar"`; |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| å±€éƒ¨å˜é‡å£°æ˜ | `**let**` `*name* =` `*value*``;`*ç¤ºä¾‹:*`**let** foo = "Bar"`; |'
- en: '| Mutable variable declaration | `**mutable**` `*name* =` `*value*``;` |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| å¯å˜å˜é‡å£°æ˜ | `**mutable**` `*name* =` `*value*``;` |'
- en: '| Reassign (update) mutable variable | `**set**` `*name* =` `*newValue*``;`
    |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| é‡æ–°åˆ†é…ï¼ˆæ›´æ–°ï¼‰å¯å˜å˜é‡ | `**set**` `*name* =` `*newValue*``;` |'
- en: '| Apply-and-reassign mutable variable | `**set**` `*name*` `*operator*``=`
    `*expression*``;`*Examples:*`**set** count += 1;``**set** array w/= 2 <- PauliX;`(see
    `w/` operator) |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| åº”ç”¨å¹¶é‡æ–°åˆ†é…å¯å˜å˜é‡ | `**set**` `*name*` `*operator*``=` `*expression*``;`*ç¤ºä¾‹:*`**set**
    count += 1;``**set** array w/= 2 <- PauliX;`(æŸ¥çœ‹`w/`è¿ç®—ç¬¦) |'
- en: '| Classical conditional statement | `**if**` `*condition*` {Â Â Â  Â // ...} |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| ç»å…¸æ¡ä»¶è¯­å¥ | `**if**` `*condition*` {Â Â Â  Â // ...} |'
- en: '| `**if**` `*condition*` {Â Â Â  Â // ...}Â `**else**` {Â Â Â  Â // ...} |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `**if**` `*condition*` {Â Â Â  Â // ...}Â `**else**` {Â Â Â  Â // ...} |'
- en: '| `**if**` `*condition*` {Â Â Â  Â // ...} `**elseif**` `*condition*` {Â Â Â  Â //
    ...}Â `**else**` {Â Â Â  Â // ...} |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `**if**` `*condition*` {Â Â Â  Â // ...} `**elseif**` `*condition*` {Â Â Â  Â //
    ...}Â `**else**` {Â Â Â  Â // ...} |'
- en: '| Iterate over array | `**for**` `*element*` `**in**` `*array* {Â ``Â Â  Â // loop
    body``}`Note: `*array*` must be a value of an array type. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| éå†æ•°ç»„ | `**for**` `*element*` `**in**` `*array* {Â ``Â Â  Â // å¾ªç¯ä½“``}`æ³¨æ„ï¼š`*array*`å¿…é¡»æ˜¯æ•°ç»„ç±»å‹çš„å€¼ã€‚
    |'
- en: '| Iterate over range | `**for**` `*index*` `**in**` `*range* {Â ``Â Â  Â // loop
    body``}`Note: `*array*` must be a value of type `Range`. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| éå†èŒƒå›´ | `**for**` `*index*` `**in**` `*range* {Â ``Â Â  Â // å¾ªç¯ä½“``}`æ³¨æ„ï¼š`*array*`å¿…é¡»æ˜¯`Range`ç±»å‹çš„å€¼ã€‚
    |'
- en: '| Repeat-until-success loop | `**repeat** {Â ``Â Â  Â // loop body``}``**until**`
    `*condition*``;` |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| é‡å¤ç›´åˆ°æˆåŠŸå¾ªç¯ | `**repeat** {Â ``Â Â  Â // å¾ªç¯ä½“``}``**until**` `*condition*``;` |'
- en: '| Repeat-until-success loop with fixup block | `**repeat** {Â ``Â Â  Â // loop
    body``}``**until**` `*condition*``**fixup** {Â ``Â Â  Â // fixup body``}` |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| å¸¦æœ‰ä¿®å¤å—çš„é‡å¤ç›´åˆ°æˆåŠŸå¾ªç¯ | `**repeat** {Â ``Â Â  Â // å¾ªç¯ä½“``}``**until**` `*condition*``**fixup**
    {Â ``Â Â  Â // ä¿®å¤ä½“``}` |'
- en: '| While-loop(only in functions) | `**while**` `*condition* {Â ``Â Â  Â // loop
    body``}` |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| å½“å¾ªç¯ï¼ˆä»…é™äºå‡½æ•°ä¸­ï¼‰ | `**while**` `*condition* {Â ``Â Â  Â // å¾ªç¯ä½“``}` |'
- en: '| Terminate with error | `**fail** "message";` |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| æŠ¥é”™ç»ˆæ­¢ | `**fail** "message";` |'
- en: '| Return value from function or operation | `**return**` `*value*``;` |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| ä»å‡½æ•°æˆ–æ“ä½œè¿”å›å€¼ | `**return**` `*value*``;` |'
- en: '| Apply shoes-and-socks pattern(see chapter 7 for detail) | `**within** {Â ``Â Â 
    Â // outer body``}` `**apply** {Â ``Â Â  Â // inner body``}` |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| åº”ç”¨é‹è¢œæ¨¡å¼ï¼ˆè¯¦è§ç¬¬7ç« ï¼‰ | `**within** {Â ``Â Â  Â // å¤–éƒ¨ä½“``}` `**apply** {Â ``Â Â  Â // å†…éƒ¨ä½“``}`
    |'
- en: '| Allocate single new qubit(only in operations) | `**use**` `*name* = Qubit();`
    |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| åˆ†é…å•ä¸ªæ–°é‡å­æ¯”ç‰¹ï¼ˆä»…é™äºæ“ä½œä¸­ï¼‰ | `**use**` `*name* = Qubit();` |'
- en: '| Allocate array of qubits(only in operations) | `**use**` `*name* = Qubit[``*size*``];`
    |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| åˆ†é…é‡å­æ¯”ç‰¹æ•°ç»„ï¼ˆä»…é™äºæ“ä½œä¸­ï¼‰ | `**use**` `*name* = Qubit[``*size*``];` |'
- en: '| Allocate a tuple of qubits and registers(only in operations) | `**use** (``*name1*``,`
    `*name2*``, ...) = (Q``*ubitOrArray1*``,` `*QubitOrArray2*``, ...);` |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| åœ¨æ“ä½œä¸­åˆ†é…é‡å­æ¯”ç‰¹å’Œå¯„å­˜å™¨çš„å…ƒç»„ï¼ˆä»…é™æ“ä½œï¼‰ | `**use** (``*åç§°1*``,` `*åç§°2*``, ...) = (Q``*æ¯”ç‰¹æˆ–æ•°ç»„1*``,`
    `*QubitOrArray2*``, ...);` |'
- en: '| Allocate a single qubit with an explicit scope(only in operations) | `**use**`
    `*name* = Qubit() {Â ``Â Â  Â // ...`Â Â Â  Â // `*name*` is released here.} |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| åœ¨æ˜¾å¼ä½œç”¨åŸŸä¸­åˆ†é…å•ä¸ªé‡å­æ¯”ç‰¹ï¼ˆä»…é™æ“ä½œï¼‰ | `**use**` `*åç§°*` = Qubit() {Â ``Â Â  Â // ...`Â Â Â  Â //
    `*åç§°*` åœ¨æ­¤å¤„é‡Šæ”¾ã€‚} |'
- en: B.4.3 Q# expressions and operators
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.4.3 Q# è¡¨è¾¾å¼å’Œè¿ç®—ç¬¦
- en: In the following table, we use `*italic monospace font*` to indicate a placeholder.
    For example, the `*Type*` placeholder in `new` `*Type*``[``*length*``]` indicates
    the base type of the new array, while `*length*` indicates its length.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ä»¥ä¸‹è¡¨ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨ `*æ–œä½“ç­‰å®½å­—ä½“*` æ¥è¡¨ç¤ºå ä½ç¬¦ã€‚ä¾‹å¦‚ï¼Œ`new` `*ç±»å‹*``[``*é•¿åº¦*``]` ä¸­çš„ `*ç±»å‹*` å ä½ç¬¦è¡¨ç¤ºæ–°æ•°ç»„çš„åŸºç±»å‹ï¼Œè€Œ
    `*é•¿åº¦*` è¡¨ç¤ºå…¶é•¿åº¦ã€‚
- en: Q# keywords are indicated in `**bold**`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Q# å…³é”®å­—ä»¥ `**ç²—ä½“**` è¡¨ç¤ºã€‚
- en: '| Description | Q# syntax |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| æè¿° | Q# è¯­æ³• |'
- en: '| Arithmetic | `+`, `-`, `*`, ... |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| ç®—æœ¯ | `+`ã€`-`ã€`*`ã€... |'
- en: '| Format values as a string | `$"... {``*expression*``} ..."`*Example:*`$"Measurement
    result was {result}"` |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: å°†æ ¼å¼å€¼ä½œä¸ºå­—ç¬¦ä¸²è¡¨ç¤ºä¸º `$"... {``*è¡¨è¾¾å¼*``} ..."` *ç¤ºä¾‹:* `$"æµ‹é‡ç»“æœä¸º {result}"` |
- en: '| Concatenate two arrays | `*array*``1 +` `*array2*` |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| è¿æ¥ä¸¤ä¸ªæ•°ç»„ | `*æ•°ç»„1*` `+` `*æ•°ç»„2*` |'
- en: '| Allocate array | `**new**` `*Type*``[``*length*``]` |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| åˆ†é…æ•°ç»„ | `**new**` `*ç±»å‹*``[``*é•¿åº¦*``]` |'
- en: '| Get element of array | `*array*``[``*index*``]` |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| è·å–æ•°ç»„ä¸­çš„å…ƒç´  | `*æ•°ç»„*``[``*ç´¢å¼•*``]` |'
- en: '| Slice array | `*array*``[``*start*``...]``*array*``[...``*end*``]``*array*``[``*start*``..``*end*``]``*array*``[``*start*``..``*step*``..``*end*``]`
    |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| åˆ‡ç‰‡æ•°ç»„ | `*æ•°ç»„*``[``*èµ·å§‹*``...]``*æ•°ç»„*``[...``*ç»“æŸ*``]``*æ•°ç»„*``[``*èµ·å§‹*``..``*ç»“æŸ*``]``*æ•°ç»„*``[``*èµ·å§‹*``..``*æ­¥é•¿*``..``*ç»“æŸ*``]`
    |'
- en: '| Copy-and-update item in array | `*array* w/` `*index* <-` `*newValue*`*Example:*`[10,
    100, 1000] w/ 1 <- 200// [10, 200, 1000]` |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| å¤åˆ¶å¹¶æ›´æ–°æ•°ç»„ä¸­çš„é¡¹ | `*æ•°ç»„*` w/ `*ç´¢å¼•*` <- `*æ–°å€¼*` *ç¤ºä¾‹:* `[10, 100, 1000] w/ 1 <- 200//
    [10, 200, 1000]` |'
- en: '| Access named item of user-defined type | `*value*``::``*itemName*`*Example:*`let
    imagUnit = Complex(0.0, 1.0);``Message($"{imagUnit::Real}");``Â Â // prints 1.0`
    |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| è®¿é—®ç”¨æˆ·å®šä¹‰ç±»å‹çš„å‘½åé¡¹ | `*å€¼*``::``*é¡¹å*` *ç¤ºä¾‹:* `let imagUnit = Complex(0.0, 1.0);``Message($"{imagUnit::Real}");``Â Â //
    æ‰“å° 1.0` |'
- en: '| Unwrap user-defined type | `*value*``!`*Example:*`**let** imagUnit = Complex(0.0,
    1.0);``Message($"{imagUnit!}");``Â Â // prints (0.0, 1.0)` |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| è§£åŒ…ç”¨æˆ·å®šä¹‰ç±»å‹ | `*å€¼*``!` *ç¤ºä¾‹:* `**let** imagUnit = Complex(0.0, 1.0);``Message($"{imagUnit!}");``Â Â //
    æ‰“å° (0.0, 1.0)` |'
- en: '| Copy-and-update named item of user-defined type | `*value*` w/ `*itemName*`
    <- `*newValue*`*Example:*`**let** imagUnit = Complex(0.0, 1.0);``**let** onePlusI
    = imagUnit w/ Real <- 1.0;``Message($"{onePlusI!}");``Â Â // prints (1.0, 1.0)`
    |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| å¤åˆ¶å¹¶æ›´æ–°ç”¨æˆ·å®šä¹‰ç±»å‹çš„å‘½åé¡¹ | `*å€¼*` w/ `*é¡¹å*` <- `*æ–°å€¼*` *ç¤ºä¾‹:* `**let** imagUnit = Complex(0.0,
    1.0);``**let** onePlusI = imagUnit w/ Real <- 1.0;``Message($"{onePlusI!}");``Â Â //
    æ‰“å° (1.0, 1.0)` |'
- en: B.4.4 Q# standard libraries
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.4.4 Q# æ ‡å‡†åº“
- en: 'We have assumed the following open statements:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å‡è®¾ä»¥ä¸‹å¼€æ”¾å£°æ˜ï¼š
- en: '[PRE2]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: For a complete list of Q# functions, operations, and user-defined types, see
    [https://docs.microsoft.com/qsharp/api/](https://docs.microsoft.com/qsharp/api/).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: è¦è·å– Q# å‡½æ•°ã€æ“ä½œå’Œç”¨æˆ·å®šä¹‰ç±»å‹çš„å®Œæ•´åˆ—è¡¨ï¼Œè¯·å‚é˜… [https://docs.microsoft.com/qsharp/api/](https://docs.microsoft.com/qsharp/api/).
- en: The suffixes `A`, `C`, and `CA` denote operations that support inputs that are
    adjointable, controllable, or both (respectively).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: åç¼€ `A`ã€`C` å’Œ `CA` è¡¨ç¤ºæ”¯æŒå¯å¯¹å¶ã€å¯æ§åˆ¶æˆ–ä¸¤è€…éƒ½æ”¯æŒçš„è¿ç®—ï¼ˆåˆ†åˆ«å¯¹åº”ï¼‰ã€‚
- en: '| Description | Function or operation | Examples |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| æè¿° | å‡½æ•°æˆ–æ“ä½œ | ç¤ºä¾‹ |'
- en: '| Apply an operation to every element of an array | `ApplyToEachCA` | `ApplyToEachCA(H,
    register);` |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| å°†æ“ä½œåº”ç”¨äºæ•°ç»„çš„æ¯ä¸ªå…ƒç´  | `ApplyToEachCA` | `ApplyToEachCA(H, register);` |'
- en: '| Call an operation several times | `Repeat` | `Repeat(PrintRandomNumber, 10,
    ());` |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| è°ƒç”¨ä¸€ä¸ªæ“ä½œå¤šæ¬¡ | `Repeat` | `Repeat(PrintRandomNumber, 10, ());` |'
- en: '| Return the first or second item in a pair | `Fst` or `Snd` |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| è·å–ä¸€å¯¹ä¸­çš„ç¬¬ä¸€ä¸ªæˆ–ç¬¬äºŒä¸ªå…ƒç´  | `Fst` æˆ– `Snd` |'
- en: '`Fst((1.0, false)) // 1.0`'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Fst((1.0, false)) // 1.0`'
- en: '`Snd((1.0, false)) // false`'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Snd((1.0, false)) // false`'
- en: '|'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Apply an operation to every element of an array, and collect results | `Arrays.ForEach`
    | `let results = ForEach(M, register);` |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| å°†æ“ä½œåº”ç”¨äºæ•°ç»„çš„æ¯ä¸ªå…ƒç´ ï¼Œå¹¶æ”¶é›†ç»“æœ | `Arrays.ForEach` | `let results = ForEach(M, register);`
    |'
- en: '| Call a function with each element of an array, and collect results | `Arrays.Mapped`
    | `let sines = Mapped(Sin, angles);` |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| ä½¿ç”¨æ•°ç»„çš„æ¯ä¸ªå…ƒç´ è°ƒç”¨å‡½æ•°ï¼Œå¹¶æ”¶é›†ç»“æœ | `Arrays.Mapped` | `let sines = Mapped(Sin, angles);`
    |'
- en: '| Fail if a condition is false | `Diag.Fact` | `Fact(2 == 2, "Expected two
    to equal two.");` |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| å¦‚æœæ¡ä»¶ä¸ºå‡åˆ™å¤±è´¥ | `Diag.Fact` | `Fact(2 == 2, "æœŸæœ›ä¸¤ä¸ªç›¸ç­‰ã€‚");` |'
- en: '| Fail if two measurement results are not equal | `Diag.EqualityFactR` | `EqualityFactR(M(qubit),
    Zero, "Expected qubit to be in &#124;0`ã€‰ `state.");` |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| å¦‚æœä¸¤ä¸ªæµ‹é‡ç»“æœä¸ç›¸ç­‰åˆ™å¤±è´¥ | `Diag.EqualityFactR` | `EqualityFactR(M(qubit), Zero, "Expected
    qubit to be in &#124;0`ã€‰ `state.");` |'
- en: '| Fail if a hypothetical measurement does not have an expected resultNotes:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '| å¦‚æœå‡è®¾çš„æµ‹é‡æ²¡æœ‰é¢„æœŸçš„ç»“æœåˆ™å¤±è´¥Notes: |'
- en: Only physically possible on simulators
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä»…åœ¨æ¨¡æ‹Ÿå™¨ä¸Šç‰©ç†ä¸Šå¯èƒ½
- en: Does not actually apply measurement, leaving qubit unaffected
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å®é™…ä¸Šä¸æ‰§è¡Œæµ‹é‡ï¼Œä¸ä¼šå½±å“é‡å­æ¯”ç‰¹
- en: '| `Diag.AssertMeasurement` | `AssertMeasement([PauliZ],``[target], Zero,``"Expected
    qubit to be in &#124;0`ã€‰ `state.â€);` |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `Diag.AssertMeasurement` | `AssertMeasement([PauliZ],``[target], Zero,``"Expected
    qubit to be in &#124;0`ã€‰ `state.â€);` |'
- en: '| Fail if two operations are different | `Diag.AssertOperationsEqualReferenced`
    | `AssertOperationsEqualReferenced(2,``Â Â  Â actualOperation,``Â Â  Â expectedOperation``);`
    |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| å¦‚æœä¸¤ä¸ªæ“ä½œä¸åŒåˆ™å¤±è´¥ | `Diag.AssertOperationsEqualReferenced` | `AssertOperationsEqualReferenced(2,``Â Â 
    Â actualOperation,``Â Â  Â expectedOperation``);` |'
- en: '| Ask simulator to display diagnostic info about all allocated qubits | `Diag.DumpMachine`
    | `DumpMachine();` |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| è¯·æ±‚æ¨¡æ‹Ÿå™¨æ˜¾ç¤ºæ‰€æœ‰åˆ†é…é‡å­æ¯”ç‰¹çš„è¯Šæ–­ä¿¡æ¯ | `Diag.DumpMachine` | `DumpMachine();` |'
- en: '| Ask simulator to display diagnostic info about a particular register | `Diag.DumpRegister`
    | `DumpRegister((),Â ``register);` |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| è¯·æ±‚æ¨¡æ‹Ÿå™¨æ˜¾ç¤ºç‰¹å®šå¯„å­˜å™¨çš„è¯Šæ–­ä¿¡æ¯ | `Diag.DumpRegister` | `DumpRegister((),Â ``register);`
    |'
- en: B.4.5 IQ# magic commands
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.4.5 IQ# é­”æ³•å‘½ä»¤
- en: For a complete list of IQ# magic commands, see [https://docs.microsoft.com/qsharp/api/iqsharp-magic](https://docs.microsoft.com/qsharp/api/iqsharp-magic).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: è¦æŸ¥çœ‹ IQ# é­”æ³•å‘½ä»¤çš„å®Œæ•´åˆ—è¡¨ï¼Œè¯·å‚é˜… [https://docs.microsoft.com/qsharp/api/iqsharp-magic](https://docs.microsoft.com/qsharp/api/iqsharp-magic)ã€‚
- en: '| Description | Magic command | Example |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| æè¿° | é­”æ³•å‘½ä»¤ | ç¤ºä¾‹ |'
- en: '| Simulate a function or operation | `%simulate` | `%simulate PlayMorganasGame
    winProbability=0.999` |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| æ¨¡æ‹Ÿå‡½æ•°æˆ–æ“ä½œ | `%simulate` | `%simulate PlayMorganasGame winProbability=0.999`
    |'
- en: '| Add new package to IQ# session | `%package` | `%package Microsoft.Quantum.Numerics`
    |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| å°†æ–°åŒ…æ·»åŠ åˆ° IQ# ä¼šè¯ | `%package` | `%package Microsoft.Quantum.Numerics` |'
- en: '| Reload Q# files with current packages | `%workspace reload` |  |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| ä½¿ç”¨å½“å‰åŒ…é‡æ–°åŠ è½½ Q# æ–‡ä»¶ | `%workspace reload` |  |'
- en: '| List all available magic commands | `%lsmagic` |  |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| åˆ—å‡ºæ‰€æœ‰å¯ç”¨çš„é­”æ³•å‘½ä»¤ | `%lsmagic` |  |'
- en: '| List currently open namespaces | `%lsopen` |  |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| åˆ—å‡ºå½“å‰æ‰“å¼€çš„å‘½åç©ºé—´ | `%lsopen` |  |'
- en: '| Run resources estimator on an operation | `%estimate` | `%estimate FindMarkedItem`
    |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| å¯¹æ“ä½œè¿è¡Œèµ„æºä¼°ç®—å™¨ | `%estimate` | `%estimate FindMarkedItem` |'
- en: '| Set IQ# configuration options | `%config` | `%config dump.truncateSmallAmplitudes
    = true` |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| è®¾ç½® IQ# é…ç½®é€‰é¡¹ | `%config` | `%config dump.truncateSmallAmplitudes = true` |'
- en: '| List all currently defined functions and operations | `%who` |  |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| åˆ—å‡ºæ‰€æœ‰å½“å‰å®šä¹‰çš„å‡½æ•°å’Œæ“ä½œ | `%who` |  |'
