- en: 2 Cloud native patterns and technologies
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 云原生模式和科技
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Understanding development principles for cloud native applications
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解云原生应用的开发原则
- en: Building cloud native applications with Spring Boot
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring Boot构建云原生应用
- en: Containerizing applications with Docker and Buildpacks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker和Buildpacks容器化应用
- en: Deploying applications to the cloud with Kubernetes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Kubernetes将应用部署到云端
- en: Introducing patterns and technologies used in the book
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍本书中使用的模式和科技
- en: The way we design applications for the cloud is different from traditional approaches.
    The 12-Factor methodology, consisting of best practices and development patterns,
    is a good starting point for building applications that can be considered cloud
    native. I’ll explain the methodology in the first part of this chapter, and I’ll
    expand on it throughout the book.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为云设计应用的方式与传统方法不同。由最佳实践和开发模式组成的12-Factor方法，是构建可被视为云原生应用的应用的良好起点。我将在本章的第一部分解释该方法，并在整本书中对其进行扩展。
- en: Later in this chapter, we’ll build a simple Spring Boot application and run
    it with Java, Docker, and Kubernetes, as shown in figure 2.1\. Throughout the
    book I’ll go deeper into each of those topics, so don’t worry if something is
    not entirely clear. This chapter aims to provide you with a mental map of the
    journey we’ll undertake from code to production in a cloud environment, while
    familiarizing you with patterns and technologies that we’ll use in the rest of
    the book.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将构建一个简单的Spring Boot应用，并使用Java、Docker和Kubernetes运行它，如图2.1所示。在整个书中，我将深入探讨这些主题中的每一个，所以如果你觉得某些内容不是完全清楚，请不要担心。本章旨在为你提供从代码到云环境中生产的旅程的心理地图，同时让你熟悉我们将在本书的其余部分使用的模式和科技。
- en: '![02-01](../Images/02-01.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![02-01](../Images/02-01.png)'
- en: Figure 2.1 The journey of a Spring application from Java to container to Kubernetes
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 Spring应用从Java到容器再到Kubernetes的旅程
- en: Finally, I’ll introduce you to the cloud native project we’ll build throughout
    this book using Spring and Kubernetes. We’ll employ all the properties and patterns
    for cloud native applications introduced in this first part of the book.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我将向你介绍我们将在整本书中使用Spring和Kubernetes构建的云原生项目。我们将采用本书第一部分中介绍的云原生应用的属性和模式。
- en: '2.1 Cloud native development principles: 12 Factors and beyond'
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 云原生开发原则：12要素及其超越
- en: 'The engineers working at the Heroku cloud platform have proposed the 12-Factor
    methodology as a collection of development principles for designing and building
    cloud native applications.[¹](#pgfId-1011877) They have distilled their experience
    into best practices for building web applications with the following characteristics:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在Heroku云平台工作的工程师们提出了12-Factor方法，作为设计和构建云原生应用的开发原则集合。[¹](#pgfId-1011877) 他们将他们的经验提炼为构建具有以下特性的Web应用的最佳实践：
- en: Suitable to be deployed on cloud platforms
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适合部署在云平台上
- en: Scalable by design
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计即具有可扩展性
- en: Portable across systems
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可跨系统移植
- en: Enablers of continuous deployment and agility
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续部署和敏捷性的推动者
- en: The goal was to help developers build applications for the cloud, highlighting
    the significant factors that should be considered to achieve the best results.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是帮助开发者构建云应用，强调实现最佳结果应考虑的重要因素。
- en: Later, the methodology was revised and expanded by Kevin Hoffman in his book
    *Beyond the Twelve-Factor App*, refreshing the contents of the original factors
    and adding three extra ones.[²](#pgfId-1011989) From now on, I will refer to this
    expanded set of principles as the *15-Factor methodology*.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，该方法由Kevin Hoffman在他的书《超越十二要素应用》中修订和扩展，刷新了原始要素的内容，并增加了三个额外的要素。[²](#pgfId-1011989)
    从现在起，我将把这一扩展的原则集合称为“15要素方法”。
- en: These 15 factors will guide you throughout the book since they are a good starting
    point for developing cloud native applications. If you are building a new application
    from scratch or migrating a traditional system to the cloud, these principles
    can help you on your journey. I will elaborate more on them when relevant, and
    I’ll illustrate how to apply them to Spring applications. It’s essential that
    you become familiar with them.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这15个因素将贯穿整本书，因为它们是开发云原生应用的良好起点。如果你是从零开始构建新应用或迁移传统系统到云端，这些原则可以帮助你在旅途中。当相关时，我会进一步阐述它们，并展示如何将它们应用到Spring应用中。熟悉它们是至关重要的。
- en: Let’s dig into each of these factors.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨这些因素。
- en: 2.1.1 One codebase, one application
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.1 一个代码库，一个应用程序
- en: The 15-Factor methodology establishes a one-to-one mapping between an application
    and its codebase, so there’s one codebase for each application. Any shared code
    should be tracked in its own codebase as a library that can be included as a dependency
    or service that can be run in standalone mode, acting as a backing service for
    other applications. Each codebase can optionally be tracked in its own repository.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 15-Factor方法在应用程序与其代码库之间建立一对一的映射，因此每个应用程序都有一个代码库。任何共享的代码都应该在其自己的代码库中跟踪，作为一个库可以包含为依赖项，或者作为一个可以独立运行的服务，作为其他应用程序的后备服务。每个代码库可以选择在其自己的存储库中进行跟踪。
- en: 'A *deployment* is a running instance of the application. Many deployments are
    possible in different environments, all sharing the same application artifact.
    There is no need to rebuild the codebase to deploy an application to a specific
    environment: any aspect that changes between deployments (such as configuration)
    should be outside the application codebase.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*部署*是应用程序的运行实例。在不同的环境中，可以存在多个部署，它们共享相同的应用程序工件。不需要重新构建代码库来将应用程序部署到特定环境：任何在部署之间发生变化的方面（如配置）都应该位于应用程序代码库之外。'
- en: 2.1.2 API first
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.2 API优先
- en: A cloud native system is usually made up of different services that communicate
    through APIs. Using an *API first* approach while designing a cloud native application
    encourages you to think about fitting it into a distributed system and favors
    the distribution of the work across different teams. By designing the API first,
    another team using that application as a backing service could create their solution
    against that API. By designing the contract up front, integration with other systems
    will be more robust and testable as part of the deployment pipeline. Internally,
    the API implementation can be changed without affecting other applications (and
    teams) depending on it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生系统通常由不同的服务组成，这些服务通过API进行通信。在设计云原生应用程序时采用*API优先*方法，鼓励您考虑将其适应到分布式系统中，并有利于将工作分配给不同的团队。通过首先设计API，另一个使用该应用程序作为后备服务的团队可以针对该API创建他们的解决方案。通过提前设计合同，与其他系统的集成将更加健壮且易于作为部署管道的一部分进行测试。内部，API实现可以更改，而不会影响依赖于它的其他应用程序（和团队）。
- en: 2.1.3 Dependency management
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.3 依赖项管理
- en: All application dependencies should be declared explicitly in a manifest and
    be available for the dependency manager to download from a central repository.
    In the context of Java applications, we are usually well-equipped to follow this
    principle using tools like Maven or Gradle. The only implicit dependencies an
    application can have on the surrounding environment are the language runtime and
    the dependency manager tool. This means that private dependencies should be resolved
    via the dependency manager.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 所有应用程序依赖项都应在清单中明确声明，并可供依赖项管理器从中央存储库下载。在Java应用程序的上下文中，我们通常使用Maven或Gradle等工具很好地遵循这一原则。应用程序对周围环境的唯一隐式依赖是语言运行时和依赖项管理工具。这意味着私有依赖项应通过依赖项管理器解决。
- en: 2.1.4 Design, build, release, run
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.4 设计、构建、发布、运行
- en: 'A codebase goes through different stages in its journey from design to deployment
    in production:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 代码库在其从设计到生产部署的旅程中会经历不同的阶段：
- en: '*Design stage*—Technologies, dependencies, and tools needed by a specific application
    feature are decided.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*设计阶段*—确定特定应用程序功能所需的技术、依赖项和工具。'
- en: '*Build stage*—The codebase is compiled and packaged together with its dependencies
    as an immutable artifact called a *build*. The build artifact must be uniquely
    identified.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*构建阶段*—代码库与其依赖项一起编译和打包，形成一个不可变的工件，称为*构建*。构建工件必须具有唯一标识。'
- en: '*Release stage*—The build is combined with a specific configuration for the
    deployment. Each release is immutable and should be uniquely identifiable, such
    as by using semantic versioning (for example, 3.9.4) or a timestamp (for example,
    2022-07-07_17:21). Releases should be stored in a central repository for easy
    access, like when a rollback to a previous version is required.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*发布阶段*—构建与特定部署的配置相结合。每个发布都是不可变的，并且应该具有唯一标识，例如使用语义版本（例如，3.9.4）或时间戳（例如，2022-07-07_17:21）。发布应存储在中央存储库中，以便于访问，例如在需要回滚到先前版本时。'
- en: '*Run stage*—The application runs in the execution environment from a specific
    release.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*运行阶段*—应用程序从特定发布在执行环境中运行。'
- en: The 15-Factor methodology requires a strict separation of these stages and doesn’t
    allow changes to the code at runtime, since that would result in a mismatch with
    the build stage. The build and the release artifacts should be immutable and labeled
    with a unique identifier to guarantee reproducibility.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 15-Factor 方法要求这些阶段有严格的分离，并且不允许在运行时更改代码，因为这会导致与构建阶段的冲突。构建和发布工件应该是不可变的，并带有唯一的标识符，以确保可重复性。
- en: 2.1.5 Configuration, credentials, and code
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.5 配置、凭证和代码
- en: The 15-Factor methodology defines configuration as everything likely to change
    between deployments. Whenever you need to change the configuration for an application,
    you should be able to do so without any changes in the code, and without building
    the application again.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 15-Factor 方法将配置定义为部署之间可能发生变化的任何内容。每次你需要更改应用程序的配置时，你应该能够在不更改代码的情况下这样做，并且不需要再次构建应用程序。
- en: The configuration might include resource handles to backing services like a
    database or a messaging system, credentials to access third-party APIs, and feature
    flags. Ask yourself if any credential or environment-specific information would
    be compromised should your codebase suddenly become public. That will tell you
    whether you have correctly externalized the configuration.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 配置可能包括对数据库或消息系统等后端服务的资源句柄、访问第三方API的凭证以及功能标志。问问自己，如果代码库突然公开，任何凭证或特定环境的信息是否会受到损害。这将告诉你是否正确地将配置外部化了。
- en: To be compliant with this factor, the configuration can’t be included in the
    code or tracked in the same codebase. The only exception is the default configuration,
    which can be packaged with the application codebase. You can still use configuration
    files for any other type of configuration, but you should store them in a separate
    repository.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了符合这个因素，配置不能包含在代码中或与同一代码库跟踪。唯一的例外是默认配置，它可以与应用程序代码库一起打包。你仍然可以使用配置文件来存储任何其他类型的配置，但你应该将它们存储在单独的存储库中。
- en: The methodology recommends storing configuration as environment variables. By
    doing so, you can have the same application deployed in different environments
    but with different behaviors depending on the environment’s configuration.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法建议将配置存储为环境变量。通过这样做，你可以将相同的应用程序部署在不同的环境中，但根据环境的配置具有不同的行为。
- en: 2.1.6 Logs
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.6 日志
- en: A cloud native application isn’t concerned with routing and storage of logs.
    Applications should log to the standard output, treating logs as events emitted
    in a sequence ordered by time. Log storage and rotation are not application responsibilities
    anymore. An external tool (a *log aggregator*) will fetch, collect, and make logs
    available for inspection.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生应用程序不关心日志的路由和存储。应用程序应将日志记录到标准输出，将日志视为按时间顺序排放的事件。日志存储和轮换不再是应用程序的责任。外部工具（日志聚合器）将检索、收集并使日志可供检查。
- en: 2.1.7 Disposability
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.7 可丢弃性
- en: 'In a traditional environment, you would take much care of your applications,
    ensuring they stay up and running and never terminate. In a cloud environment,
    you don’t need to care that much: applications are ephemeral. If a failure happens
    and the application doesn’t respond anymore, you terminate it and start a new
    instance. If you have a high-load peak, you can spin up more instances of your
    applications to sustain the increased workload. We say that an application is
    disposable if it can be started or stopped at any time.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统环境中，你会非常关心你的应用程序，确保它们保持运行状态，永远不会终止。在云环境中，你不需要那么关心：应用程序是短暂的。如果发生故障并且应用程序不再响应，你可以终止它并启动一个新的实例。如果你有一个高负载峰值，你可以启动更多应用程序实例以维持增加的工作负载。我们说，如果一个应用程序可以随时启动或停止，那么它是可丢弃的。
- en: To handle application instances in such a dynamic way, you should design them
    to start up quickly whenever you need a new instance and gracefully shut down
    when you don’t need them anymore. A fast startup enables the elasticity of the
    system, ensuring robustness and resilience. Without a fast startup, you will have
    performance and availability issues.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以这种方式处理应用程序实例，你应该设计它们，以便在需要新实例时快速启动，并在不再需要时优雅地关闭。快速的启动使系统的弹性得以实现，确保系统的健壮性和弹性。如果没有快速的启动，你将面临性能和可用性问题。
- en: A *graceful shutdown* is when an application, on receiving a signal to terminate,
    stops accepting new requests, completes the ones already in progress, and finally
    exits. In the case of web processes, that is straightforward. In other cases,
    such as with worker processes, the jobs they were responsible for must be returned
    to the work queue, and only afterward can they exit.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**优雅关闭**是指当应用程序收到终止信号时，停止接受新的请求，完成正在进行的请求，并最终退出。在Web进程的情况下，这很简单。在其他情况下，例如与工作进程一起，它们负责的工作必须返回到工作队列，然后它们才能退出。'
- en: 2.1.8 Backing services
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.8 后端服务
- en: Backing services can be defined as external resources that an application uses
    to deliver its functionality. Examples of backing services are databases, message
    brokers, caching systems, SMTP servers, FTP servers, or RESTful web services.
    Treating them as attached resources means that you can easily change them without
    modifying the application code.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 后端服务可以被定义为应用程序用来提供其功能的外部资源。后端服务的例子包括数据库、消息代理、缓存系统、SMTP服务器、FTP服务器或RESTful Web服务。将它们视为附加资源意味着你可以轻松地更改它们，而无需修改应用程序代码。
- en: 'Consider how you use databases throughout the software development life cycle.
    Chances are that you’ll use a different database depending on the stage: development,
    testing, or production. If you treat the database as an attached resource, you
    can use a different service depending on the environment. The attachment is done
    through resource binding. For example, resource binding for a database could consist
    of a URL, a username, and a password.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑你在软件开发生命周期中如何使用数据库。很可能根据阶段的不同：开发、测试或生产，你会使用不同的数据库。如果你将数据库视为一个附加资源，你可以根据环境使用不同的服务。附加是通过资源绑定完成的。例如，数据库的资源绑定可能包括一个URL、用户名和密码。
- en: 2.1.9 Environment parity
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.9 环境一致性
- en: 'Environment parity is about keeping all your environments as similar as possible.
    In reality, there are three gaps that this factor tries to address:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 环境一致性是指尽可能保持所有环境相似。实际上，有三个差距是这个因素试图解决的：
- en: '*Time gap*—The period between a code change and its deployment can be quite
    large. The methodology strives to promote automation and continuous deployment
    to reduce the period between when a developer writes code to when it’s deployed
    in production.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*时间差距*——代码更改与其部署之间的时间可能相当长。该方法努力促进自动化和持续部署，以减少开发人员编写代码到其在生产中部署之间的时间。'
- en: '*People gap*—Developers build applications, and operators manage their deployment
    in production. This gap can be resolved by embracing a DevOps culture, improving
    collaboration between developers and operators, and embracing the “you build it,
    you run it” philosophy.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*人员差距*——开发者构建应用程序，而操作员在生产中管理它们的部署。这个差距可以通过拥抱DevOps文化、改善开发者和操作员之间的协作以及拥抱“你构建它，你运行它”的哲学来解决。'
- en: '*Tools gap*—One of the main differences between environments is how backing
    services are handled. For example, developers might use the H2 database in their
    local environment but PostgreSQL in production. In general, the same type and
    version of backing services should be used in all environments.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*工具差距*——环境之间主要区别之一是处理后端服务的方式。例如，开发者可能在本地环境中使用H2数据库，但在生产中使用PostgreSQL。一般来说，所有环境中都应该使用相同类型和版本的备份服务。'
- en: 2.1.10 Administrative processes
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.10 管理过程
- en: Some management tasks are usually needed to support applications. Tasks like
    database migrations, batch jobs, or maintenance jobs should be treated as one-off
    processes. Just like application processes, the code for administrative tasks
    should be tracked in revision control, delivered with the application they support,
    and executed in the same environment as the application.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一些管理任务通常需要支持应用程序。像数据库迁移、批量作业或维护作业这样的任务应该被视为一次性过程。就像应用程序进程一样，管理任务的代码应该在版本控制中进行跟踪，与它们支持的应用程序一起交付，并在与应用程序相同的环境中执行。
- en: It’s usually a good idea to frame administrative tasks as small standalone services
    that run once and then are thrown away or as functions configured in a stateless
    platform to be triggered when certain events happen, or you can embed them in
    the application itself, activating them by calling a specific endpoint.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通常将管理任务作为一次运行后即丢弃的小型独立服务来构建，或者作为在特定事件发生时触发的无状态平台上的函数来配置，或者你可以将它们嵌入到应用程序本身中，通过调用特定的端点来激活它们。
- en: 2.1.11 Port binding
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.11 端口绑定
- en: Applications following the 15-Factor methodology should be self-contained and
    export their services via port binding. In production, there might be some routing
    services that translate requests from public endpoints to the internal port-bound
    services.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循15个要素方法的应用程序应该是自包含的，并通过端口绑定导出其服务。在生产环境中，可能会有一些路由服务将来自公共端点的请求转换为内部端口绑定服务。
- en: 'An application is self-contained if it doesn’t depend on an external server
    in the execution environment. A Java web application would probably run inside
    a server container like Tomcat, Jetty, or Undertow. A cloud native application,
    in contrast, would not require the environment to have a Tomcat server available;
    it would manage it itself as any other dependency. Spring Boot, for example, lets
    you use an embedded server: the application will contain the server rather than
    depending on one being available in the execution environment. One of the consequences
    of this approach is that there is always a one-to-one mapping between application
    and server, unlike the traditional method where multiple applications are deployed
    to the same server.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序在执行环境中不依赖于外部服务器，则该应用程序是自包含的。一个Java Web应用程序可能会在Tomcat、Jetty或Undertow等服务器容器中运行。相比之下，云原生应用程序不需要环境中有Tomcat服务器可用；它会像处理其他依赖项一样自行管理。例如，Spring
    Boot允许您使用嵌入式服务器：应用程序将包含服务器，而不是依赖于执行环境中可用的服务器。这种方法的后果之一是，应用程序和服务器之间始终存在一对一的映射，这与传统方法不同，在传统方法中，多个应用程序部署到同一服务器上。
- en: The services provided by the application are then exported via port binding.
    A web application would bind HTTP services to a specific port and potentially
    become a backing service for another application. That’s what usually happens
    in a cloud native system.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序提供的服务随后通过端口绑定导出。一个Web应用程序会将HTTP服务绑定到特定端口，并可能成为另一个应用程序的后端服务。这就是在云原生系统中通常发生的情况。
- en: 2.1.12 Stateless processes
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.12 无状态进程
- en: 'In the previous chapter, you saw that high scalability is one reason why we
    move to the cloud. To ensure scalability, we design applications as stateless
    processes and adopt a *share-nothing architecture* : no state should be shared
    among different application instances. Ask yourself if any data would be lost
    should an instance of your application be destroyed and recreated. If the answer
    is affirmative, then your application is not stateless.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您了解到高可扩展性是我们迁移到云的一个原因。为了确保可扩展性，我们设计应用程序为无状态进程，并采用*无共享架构*：不同应用程序实例之间不应共享任何状态。问问自己，如果您的应用程序实例被销毁并重新创建，是否会有数据丢失。如果答案是肯定的，那么您的应用程序就不是无状态的。
- en: No matter what, we will always need to save some state, or our applications
    will be useless in most cases. As a result, we design applications to be stateless
    and then only handle the state in specific stateful services like data stores.
    In other words, a stateless application delegates the state management and storage
    to a backing service.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 无论怎样，我们总是需要保存一些状态，否则我们的应用程序在大多数情况下将变得无用。因此，我们设计应用程序为无状态，然后只在特定的有状态服务（如数据存储）中处理状态。换句话说，无状态应用程序将状态管理和存储委托给后端服务。
- en: 2.1.13 Concurrency
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.13 并发
- en: Creating stateless applications is not enough to ensure scalability. If you
    need to scale, that means you need to serve more users. Therefore, your applications
    should allow concurrent processing to serve many users at the same time.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 仅创建无状态应用程序不足以确保可扩展性。如果您需要扩展，这意味着您需要服务更多的用户。因此，您的应用程序应该允许并发处理，以同时服务多个用户。
- en: The 15-Factor methodology defines processes as first-class citizens. Those processes
    should be horizontally scalable, distributing the workload across many processes
    on different machines, and this concurrent processing is only possible if the
    applications are stateless. In JVM applications, we handle concurrency through
    multiple threads, available from thread pools.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 15个要素方法将进程定义为第一类公民。这些进程应该是水平可扩展的，将工作负载分布在多台机器上的多个进程之间，而这种并发处理只有在应用程序是无状态的情况下才可能。在JVM应用程序中，我们通过多个线程处理并发，这些线程来自线程池。
- en: Processes can be classified according to their types. For example, you might
    have web processes that handle HTTP requests and worker processes that execute
    scheduled jobs in the background.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 进程可以根据其类型进行分类。例如，您可能有处理HTTP请求的Web进程和执行后台计划作业的工作进程。
- en: 2.1.14 Telemetry
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.14 遥测
- en: 'Observability is one of the properties of cloud native applications. Managing
    a distributed system in the cloud is complex, and the only way to manage such
    complexity is by ensuring that every system component provides the correct data
    to monitor the system’s behavior remotely. Examples of telemetry data are logs,
    metrics, traces, health status, and events. Hoffman uses a very catchy image to
    stress the importance of telemetry: treat your applications like space probes.
    What kind of telemetry would you need to monitor and control your applications
    remotely?'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 可观测性是云原生应用的一个特性。在云中管理分布式系统是复杂的，而管理这种复杂性的唯一方法是通过确保每个系统组件提供正确数据来远程监控系统的行为。遥测数据的例子包括日志、指标、跟踪、健康状态和事件。霍夫曼使用一个非常吸引人的形象来强调遥测的重要性：将你的应用程序视为太空探测器。你需要什么样的遥测来远程监控和控制你的应用程序呢？
- en: 2.1.15 Authentication and authorization
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.15 认证和授权
- en: Security is one of the essential qualities of a software system, but it often
    doesn’t get the necessary attention. Following a *zero-trust* approach, we must
    secure any interaction within the system at any architectural and infrastructural
    levels. There is undoubtedly more to security than just authentication and authorization,
    but those are a good starting point.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性是软件系统的一个基本特性，但它往往没有得到必要的关注。遵循 *零信任* 方法，我们必须在任何架构和基础设施级别确保系统内任何交互的安全性。安全性远不止认证和授权，但这些是一个良好的起点。
- en: With authentication, we can keep track of who is using the application. Knowing
    that, we can then check the user permissions to verify whether the user is allowed
    to perform specific actions. A few standards are available for implementing identity
    and access management, including OAuth 2.1 and OpenID Connect, which we will use
    in this book.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通过认证，我们可以跟踪谁在使用应用程序。了解这一点后，我们可以检查用户权限，以验证用户是否被允许执行特定操作。有几个标准可用于实现身份和访问管理，包括
    OAuth 2.1 和 OpenID Connect，我们将在本书中使用它们。
- en: 2.2 Building cloud native applications with Spring
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 使用 Spring 构建云原生应用程序
- en: It’s time to get more concrete now and start talking about technologies. So
    far, you have learned about the cloud native approach and the main development
    practices we’ll follow. Now let’s have a look at Spring. If you are reading this
    book, you have probably had some previous experience with Spring, and you’d like
    to learn how to use it to build cloud native applications.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候更加具体一些，开始讨论技术了。到目前为止，你已经了解了云原生方法以及我们将遵循的主要开发实践。现在让我们来看看 Spring。如果你正在阅读这本书，你可能已经有一些
    Spring 的先前经验，并且你想要学习如何使用它来构建云原生应用程序。
- en: The Spring ecosystem provides features for handling almost any requirement your
    applications might have, including those of cloud native applications. Spring
    is by far the most used Java framework. It’s been around for many years, and it’s
    robust and reliable. The community behind Spring is fantastic and willing to move
    it forward and make it consistently better. Technologies and development practices
    evolve continuously, and Spring is very good at keeping up with them. Therefore,
    using Spring for your next cloud native project is an excellent choice.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 生态系统提供了处理你应用程序可能需要的几乎所有功能，包括云原生应用程序的功能。Spring 是迄今为止最常用的 Java 框架。它已经存在很多年了，它强大且可靠。Spring
    背后的社区非常出色，愿意推动它向前发展并使其持续改进。技术和开发实践不断演变，Spring 在跟上它们方面做得非常好。因此，使用 Spring 来进行你的下一个云原生项目是一个非常好的选择。
- en: This section will highlight some interesting features of the Spring landscape.
    Then we will start to create a Spring Boot application.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将突出展示 Spring 生态系统的一些有趣特性。然后我们将开始创建一个 Spring Boot 应用程序。
- en: 2.2.1 Overview of the Spring landscape
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.1 Spring 生态系统概述
- en: 'Spring comprises several projects that address many different aspects of software
    development: web applications, security, data access, integration, batch processing,
    configuration, messaging, big data, and many more. The beauty of the Spring platform
    is that it’s designed to be modular, so you can use and combine just the projects
    you need. It doesn’t matter which type of application you need to build. Chances
    are that Spring can help you with it.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 包含了多个项目，涵盖了软件开发的不同方面：Web 应用程序、安全、数据访问、集成、批处理、配置、消息传递、大数据等等。Spring 平台的魅力在于它被设计成模块化的，因此你可以使用和组合你需要的项目。无论你需要构建哪种类型的应用程序，Spring
    都有可能帮助你。
- en: '*Spring Framework* is the core of the Spring platform, the project that started
    it all. It supports dependency injection, transaction management, data access,
    messaging, web applications, and more. The framework establishes the “plumbing”
    of enterprise applications so you can focus on the business logic.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*Spring框架*是Spring平台的核心，是所有一切开始的项目。它支持依赖注入、事务管理、数据访问、消息传递、Web应用程序等。框架建立了企业应用的“管道”，这样你就可以专注于业务逻辑。'
- en: Spring Framework provides an execution context (called *Spring context* or *container*),
    where beans, properties, and resources are managed throughout the entire application
    life cycle. I’ll assume you are already familiar with the framework’s core features,
    so I will not spend too much time on it. In particular, you should be aware of
    the Spring context’s role and be comfortable working with Spring beans, annotation-based
    configuration, and dependency injection. We will rely on those features, so you
    should have them sorted out.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Spring框架提供了一个执行上下文（称为*Spring上下文*或*容器*），在应用程序的生命周期中管理bean、属性和资源。我将假设你已经熟悉框架的核心功能，因此我不会在这方面花费太多时间。特别是，你应该了解Spring上下文的作用，并且能够舒适地与Spring
    bean、基于注解的配置和依赖注入一起工作。我们将依赖这些功能，所以你应该已经弄清楚它们。
- en: Based on the framework, *Spring Boot* makes it possible to build standalone,
    production-ready applications quickly. Spring Boot takes an opinionated view of
    Spring and third-party libraries, and it comes bundled with a sensible default
    configuration that lets developers get started with minimal up-front work while
    still providing full customization possibilities.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 基于*Spring Boot*框架，可以快速构建独立的生产级应用程序。Spring Boot对Spring和第三方库持有一种有见地的观点，并附带合理的默认配置，这使得开发者可以以最小的前期工作开始，同时仍然提供完整的自定义可能性。
- en: Throughout this book, you’ll have a chance to use several Spring projects to
    implement patterns and best practices for cloud native applications, including
    Spring Boot, Spring Cloud, Spring Data, Spring Security, Spring Session, and Spring
    Native.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，你将有机会使用几个Spring项目来实施云原生应用程序的模式和最佳实践，包括Spring Boot、Spring Cloud、Spring Data、Spring
    Security、Spring Session和Spring Native。
- en: 'Note If you are interested in learning more about the core Spring features,
    you can find a few books on the subject in the Manning catalog, including *Spring
    Start Here* by Laurențiu Spilcă (Manning, 2021) and *Spring in Action*, sixth
    edition, by Craig Walls (Manning, 2022). You can also refer to *Spring Boot: Up
    & Running* by Mark Heckler (O’Reilly, 2021).'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '注意：如果你对学习更多关于Spring核心功能感兴趣，你可以在Manning目录中找到一些关于这个主题的书籍，包括Laurențiu Spilcă的*Spring
    Start Here*（Manning，2021）和Craig Walls的*Spring in Action*第六版（Manning，2022）。你也可以参考Mark
    Heckler的*Spring Boot: Up & Running*（O’Reilly，2021）。'
- en: 2.2.2 Building a Spring Boot application
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.2 构建Spring Boot应用程序
- en: Imagine that you have been hired to build a Polar Bookshop application for Polarsophia.
    This organization manages a specialized bookshop and wants to sell its books about
    the North Pole and the Arctic online. A cloud native approach is being considered.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你被雇佣来为Polarsophia构建一个极地书店应用程序。这个组织管理一家专门的书店，并希望在网上销售关于北极和北冰洋的书籍。正在考虑采用云原生方法。
- en: 'As a pilot project, your boss has assigned you to demonstrate to your colleagues
    how to go from implementation to production in the cloud. The web application
    you are asked to build is Catalog Service, and for now it will only have one responsibility:
    welcoming users to the book catalog. This pilot project will be the foundation
    for actual products built as cloud native applications, should it be successful
    and well-received.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 作为试点项目，你的老板分配给你一个任务，向你的同事展示如何在云中从实现到生产的整个过程。你被要求构建的Web应用程序是目录服务，目前它只有一个职责：欢迎用户进入图书目录。如果这个试点项目成功并且受到好评，它将成为作为云原生应用程序构建的实际产品的基石。
- en: Considering the task’s goal, you might decide to implement the application as
    a RESTful service with a single HTTP endpoint responsible for returning a welcome
    message. Surprisingly enough, you choose to adopt Spring as the primary technology
    stack for the one service (Catalog Service) composing the application. The architecture
    of the system is shown in figure 2.2, and you’ll be trying your hand at building
    and deploying the application in the upcoming sections.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到任务的目标，您可能会决定将应用程序实现为一个 RESTful 服务，该服务具有单个 HTTP 端点，负责返回欢迎信息。令人惊讶的是，您选择采用 Spring
    作为应用程序（由一个服务组成，即目录服务）的主要技术栈。系统的架构如图 2.2 所示，您将在接下来的章节中尝试构建和部署应用程序。
- en: '![02-02](../Images/02-02.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![02-02](../Images/02-02.png)'
- en: Figure 2.2 Architecture diagram for the Polar Bookshop application, following
    the C4 model
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 Polar Bookshop 应用程序的架构图，遵循 C4 模型
- en: 'In figure 2.2, you can see the notation that I’ll use to represent architectural
    diagrams throughout the book, following the C4 model created by Simon Brown ([https://c4model.com](https://c4model.com)).
    To describe the architecture for the Polar Bookshop project, I’m relying on three
    abstractions from the model:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在图 2.2 中，您可以看到我将使用以下符号来表示本书中使用的架构图，遵循由 Simon Brown 创建的 C4 模型 ([https://c4model.com](https://c4model.com))。为了描述
    Polar Bookshop 项目的架构，我依赖于模型中的三个抽象：
- en: '*Person*—This represents one of the human users of the software system. In
    our example, it’s a customer of the bookshop.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*人员*——这代表软件系统的人类用户之一。在我们的例子中，它是书店的客户。'
- en: '*System*—This represents the overall application you will build to deliver
    value to its users. In our example, it’s the Polar Bookshop system.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*系统*——这代表您将构建的整个应用程序，以向其用户提供价值。在我们的例子中，它是 Polar Bookshop 系统。'
- en: '*Container*—This represents a service, either application or data. It’s not
    to be confused with Docker. In our example, it’s the Catalog Service.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*容器*——这代表一个服务，无论是应用程序还是数据。它不要与 Docker 混淆。在我们的例子中，它是目录服务。'
- en: 'For this task we’ll use the Spring Framework and Spring Boot to do the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个任务，我们将使用 Spring 框架和 Spring Boot 来完成以下操作：
- en: Declare the dependencies needed to implement the application.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明实现应用程序所需的依赖项。
- en: Bootstrap the application with Spring Boot.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Spring Boot 引导应用程序。
- en: Implement a controller to expose an HTTP endpoint for returning a welcome message.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个控制器以公开一个 HTTP 端点，用于返回欢迎信息。
- en: Run and try the application.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行并尝试应用程序。
- en: All the examples in this book are based on Java 17, the latest long-term release
    of Java at the time of writing. Before moving on, follow the instructions in section
    A.1 of appendix A to install an OpenJDK 17 distribution. Then ensure you have
    an IDE with support for Java, Gradle, and Spring. I’ll be using IntelliJ IDEA,
    but feel free to choose another one, such as Visual Studio Code. Finally, create
    a free account on GitHub if you don’t have one yet ([https://github.com](https://github.com)).
    You’ll use it to store your code and define continuous delivery pipelines.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的所有示例都基于 Java 17，这是撰写时的最新长期发布版 Java。在继续之前，请按照附录 A 的 A.1 节中的说明安装 OpenJDK 17
    分发版。然后确保您有一个支持 Java、Gradle 和 Spring 的 IDE。我将使用 IntelliJ IDEA，但您也可以选择其他 IDE，例如
    Visual Studio Code。最后，如果您还没有，请创建一个免费的 GitHub 账户 ([https://github.com](https://github.com))。您将使用它来存储您的代码并定义持续交付管道。
- en: Initializing the project
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化项目
- en: Throughout the book, we’ll build several cloud native applications. I recommend
    you define a Git repository for each of them and use GitHub to store them. In
    the next chapter, I’ll talk more about managing codebases. For now, go ahead and
    create a catalog-service Git repository.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们将构建几个云原生应用程序。我建议您为每个应用程序定义一个 Git 仓库，并使用 GitHub 来存储它们。在下一章中，我将更多地讨论代码库的管理。现在，请继续创建一个
    catalog-service Git 仓库。
- en: Next, you can generate the project from Spring Initializr ([https://start.spring.io](https://start.spring.io))
    and store it in the catalog-service Git repository you just created. Spring Initializr
    is a convenient service you can use from a browser or through its REST API to
    generate JVM-based projects. It’s even integrated into popular IDEs such as IntelliJ
    IDEA and Visual Studio Code. The initialization parameters for Catalog Service
    are shown in figure 2.3.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您可以从 Spring Initializr ([https://start.spring.io](https://start.spring.io))
    生成项目，并将其存储在您刚刚创建的 catalog-service Git 仓库中。Spring Initializr 是一个方便的服务，您可以通过浏览器或其
    REST API 使用它来生成基于 JVM 的项目。它甚至集成到流行的 IDE 中，如 IntelliJ IDEA 和 Visual Studio Code。目录服务的初始化参数如图
    2.3 所示。
- en: '![02-03](../Images/02-03.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![02-03](../Images/02-03.png)'
- en: Figure 2.3 The parameters for initializing the Catalog Service project from
    Spring Initializr
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 从Spring Initializr初始化Catalog Service项目的参数
- en: During the initialization, you can provide a few details about the application
    you want to build, as shown in table 2.1.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化过程中，你可以提供一些关于你想要构建的应用程序的相关细节，如表2.1所示。
- en: Table 2.1 The main parameters you can configure to generate a project from Spring
    Initializr
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.1 从Spring Initializr生成项目时可以配置的主要参数
- en: '| Parameter | Description | Value for Catalog Service |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 描述 | Catalog Service的值 |'
- en: '| Project | You can decide whether you want to use Gradle or Maven as the build
    tool for your project. All the examples in this book will use Gradle. | Gradle
    |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| 项目 | 你可以决定是否想使用Gradle或Maven作为项目的构建工具。本书中的所有示例都将使用Gradle。 | Gradle |'
- en: '| Language | Spring supports the three main JVM languages: Java, Kotlin, and
    Groovy. All the examples in this book will use Java. | Java |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| 语言 | Spring支持三种主要的JVM语言：Java、Kotlin和Groovy。本书中的所有示例都将使用Java。 | Java |'
- en: '| Spring Boot | You can choose which version of Spring Boot you want to use.
    All the examples in this book will use Spring Boot 2.7.3, but any subsequent patch
    should be fine. | Spring Boot 2.7.3 |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| Spring Boot | 你可以选择想要使用的Spring Boot版本。本书中的所有示例都将使用Spring Boot 2.7.3，但任何后续补丁版本都应没问题。
    | Spring Boot 2.7.3 |'
- en: '| Group | The group ID for the project, as used in a Maven repository. | com.polarbookshop
    |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 组 | 项目的组ID，如Maven仓库中使用的。 | com.polarbookshop |'
- en: '| Artifact | The artifact ID for the project, as used in a Maven repository.
    | catalog-service |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 工件 | 项目的工件ID，如Maven仓库中使用的。 | catalog-service |'
- en: '| Name | The project name. | catalog-service |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 项目名称。 | catalog-service |'
- en: '| Package name | The base Java package for the project. | com.polarbookshop.catalogservice
    |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 包名 | 项目的基Java包。 | com.polarbookshop.catalogservice |'
- en: '| Packaging | How to package the project: WAR (for deployment on application
    servers) or JAR (for standalone applications). Cloud native applications should
    be packaged as JARs, so all the examples in this book will use that option. |
    JAR |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 打包 | 如何打包项目：WAR（用于在应用服务器上部署）或JAR（用于独立应用程序）。云原生应用程序应打包为JAR，因此本书中的所有示例都将使用该选项。
    | JAR |'
- en: '| Java | The Java version you want to use to build the project. All the examples
    in this book will use Java 17. | 17 |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| Java | 你想用于构建项目的Java版本。本书中的所有示例都将使用Java 17。 | 17 |'
- en: '| Dependencies | Which dependencies to include in the project. | Spring Web
    |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 依赖项 | 要包含在项目中的依赖项。 | Spring Web |'
- en: The structure of the newly generated project is shown in figure 2.4\. I’ll guide
    you through it in the upcoming sections.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 新生成的项目结构如图2.4所示。在接下来的章节中，我将引导你了解它。
- en: '![02-04](../Images/02-04.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![02-04](../Images/02-04.png)'
- en: Figure 2.4 The structure of a new Spring Boot project generated from Spring
    Initializr
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 从Spring Initializr生成的Spring Boot项目结构
- en: In the code repository accompanying this book ([https://github.com/ThomasVitale/cloud-native-spring-in-action](https://github.com/ThomasVitale/cloud-native-spring-in-action)),
    you can find “begin” and “end” folders for each chapter, so that you can always
    start with the same setup as me and check the final result. For example, you are
    currently reading chapter 2, so you will find the related code in Chapter02/02-begin
    and Chapter02/02-end.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书配套的代码仓库（[https://github.com/ThomasVitale/cloud-native-spring-in-action](https://github.com/ThomasVitale/cloud-native-spring-in-action)）中，你可以找到每个章节的“begin”和“end”文件夹，这样你就可以始终以与我相同的设置开始，并检查最终结果。例如，你目前正在阅读第2章，因此你将在Chapter02/02-begin和Chapter02/02-end中找到相关的代码。
- en: Tip In the “begin” folder for this chapter, you’ll find a curl command that
    you can run in a Terminal window to download a zip file containing all the code
    you need to get started, without going through the manual project generation on
    the Spring Initializr website.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：在本章的“begin”文件夹中，你可以找到一个curl命令，你可以在终端窗口中运行它来下载一个包含所有启动所需代码的zip文件，无需通过Spring
    Initializr网站上的手动项目生成。
- en: Gradle or Maven?
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle还是Maven？
- en: I’m using Gradle in this book, but feel free to use Maven instead. In the code
    repository accompanying this book, you can find a table mapping the Gradle commands
    to Maven so that you can easily follow along, should you use the second option
    ([https://github.com/ThomasVitale/cloud-native-spring-in-action](https://github.com/ThomasVitale/cloud-native-spring-in-action)).
    Each project has different needs that might lead you to choose one build tool
    over another.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这本书中使用Gradle，但你可以自由选择使用Maven。在本书附带的代码仓库中，你可以找到一个将Gradle命令映射到Maven的表格，这样你就可以轻松地跟随，如果你选择第二个选项的话（[https://github.com/ThomasVitale/cloud-native-spring-in-action](https://github.com/ThomasVitale/cloud-native-spring-in-action)）。每个项目都有不同的需求，这可能导致你选择一个构建工具而不是另一个。
- en: My choice of using Gradle is a personal preference and is due to two main reasons.
    Building and testing a Java project with Gradle takes less time than Maven, thanks
    to its incremental and parallel builds and caching system. Also, I find the Gradle
    build language (Gradle DSL) to be more readable, expressive, and maintainable
    than Maven XML. In the Spring ecosystem, you can find projects using Gradle and
    others using Maven. They’re both good choices. I recommend you try them both and
    pick the tool that makes you more productive.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择使用Gradle是基于个人偏好，并且有两个主要原因。使用Gradle构建和测试Java项目比Maven更快，这得益于其增量构建、并行构建和缓存系统。此外，我发现Gradle构建语言（Gradle
    DSL）比Maven XML更易读、更易于表达和维护。在Spring生态系统中，你可以找到使用Gradle的项目和使用Maven的项目。它们都是不错的选择。我建议你尝试两者，并选择让你更高效的工具。
- en: Exploring the build configuration
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 探索构建配置
- en: Open the project you have just initialized in your favorite IDE, and look at
    the Gradle build configuration for the Catalog Service application, defined in
    the build.gradle file. You can find there all the information you provided to
    Spring Initializr.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你在最喜欢的IDE中刚刚初始化的项目，查看目录服务应用的Gradle构建配置，该配置在build.gradle文件中定义。你可以在那里找到你提供给Spring
    Initializr的所有信息。
- en: Listing 2.1 The build configuration for Catalog Service
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.1 目录服务的构建配置
- en: '[PRE0]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Provides Spring Boot support in Gradle and declares which version to use
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在Gradle中提供Spring Boot支持并声明要使用的版本
- en: ❷ Provides dependency management features for Spring
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 为Spring提供依赖管理功能
- en: ❸ Provides Java support in Gradle, setting up tasks to compile, build, and test
    the application
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在Gradle中提供Java支持，设置任务以编译、构建和测试应用
- en: ❹ The group ID for the Catalog Service project
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 目录服务项目的组ID
- en: ❺ The version of the application. By default, it’s 0.0.1-SNAPSHOT.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 应用的版本。默认情况下，它是0.0.1-SNAPSHOT。
- en: ❻ The Java version used to build the project
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 构建项目使用的Java版本
- en: ❼ Artifact repositories to search for dependencies
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 搜索依赖项的工件仓库
- en: ❽ The dependencies used by the application
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 应用使用的依赖项
- en: ❾ Enables testing with the JUnit Platform provided by JUnit 5
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 启用JUnit 5提供的JUnit平台进行测试
- en: 'The project contains the following main dependencies:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 项目包含以下主要依赖项：
- en: '*Spring Web* (org.springframework.boot:spring-boot-starter-web) provides the
    necessary libraries for building web applications with Spring MVC and includes
    Tomcat as the default embedded server.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Spring Web*（org.springframework.boot:spring-boot-starter-web）提供了构建Spring MVC
    Web应用所需的库，并包括Tomcat作为默认的嵌入式服务器。'
- en: '*Spring Boot Test* (org.springframework.boot:spring-boot-starter-test) provides
    several libraries and utilities for testing applications, including Spring Test,
    JUnit, AssertJ, and Mockito. It’s automatically included in every Spring Boot
    project.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Spring Boot Test*（org.springframework.boot:spring-boot-starter-test）提供了用于测试应用的多个库和实用工具，包括Spring
    Test、JUnit、AssertJ和Mockito。它自动包含在每一个Spring Boot项目中。'
- en: Note Spring Boot offers convenient starter dependencies that bundle together
    all the libraries necessary for a specific use case, taking care to choose versions
    that are compatible with each other. This feature significantly simplifies your
    build configuration.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 注意Spring Boot提供了方便的入门级依赖项，这些依赖项将所有必要的库捆绑在一起，用于特定的用例，并确保选择兼容的版本。这个特性显著简化了你的构建配置。
- en: 'The name of the project is defined in a second file called settings.gradle:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 项目的名称定义在第二个名为settings.gradle的文件中：
- en: '[PRE1]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Bootstrapping the application
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 启动应用
- en: In a previous section, you initialized the Catalog Service project and chose
    the JAR packaging option. Any Java application packaged as a JAR must have a public
    static void main(String[] args) method that is executed at startup, and Spring
    Boot is no different. In Catalog Service, a CatalogServiceApplication class was
    autogenerated during the initialization; that’s where the main() method is defined,
    and it’s how the Spring Boot application is run.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，您初始化了 Catalog Service 项目并选择了 JAR 打包选项。任何打包为 JAR 的 Java 应用程序都必须有一个公共静态
    void main(String[] args) 方法，该方法在启动时执行，Spring Boot 也不例外。在 Catalog Service 中，在初始化过程中自动生成了一个
    CatalogServiceApplication 类；这就是 main() 方法定义的地方，也是 Spring Boot 应用程序运行的方式。
- en: Listing 2.2 The bootstrap class for Catalog Service
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.2 Catalog Service 的引导类
- en: '[PRE2]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Defines a Spring configuration class and triggers component scanning and Spring
    Boot auto-configuration
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义一个 Spring 配置类并触发组件扫描和 Spring Boot 自动配置
- en: ❷ The method used to launch the application. It registers the current class
    to be run during the application’s bootstrap phase.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 用于启动应用程序的方法。它在应用程序的引导阶段注册要运行的当前类。
- en: 'The @SpringBootApplication annotation is a shortcut that includes three different
    annotations:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '@SpringBootApplication 注解是一个包含三个不同注解的快捷方式：'
- en: '@Configuration marks the class as a source of beans definitions.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '@Configuration 标记该类为 beans 定义源。'
- en: '@ComponentScan enables component scanning to find and register beans in the
    Spring context automatically.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '@ComponentScan 启用组件扫描以自动在 Spring 上下文中查找和注册 beans。'
- en: '@EnableAutoConfiguration enables the auto-configuration capabilities offered
    by Spring Boot.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '@EnableAutoConfiguration 启用 Spring Boot 提供的自动配置功能。'
- en: Spring Boot auto-configuration is triggered by several conditions, such as the
    presence of certain classes in the classpath, the existence of specific beans,
    or the values of some properties. Since the Catalog Service project depends on
    spring-boot-starter-web, Spring Boot will initialize an embedded Tomcat server
    instance and apply the minimal configuration required to get a web application
    up and running in almost zero time.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 自动配置由多个条件触发，例如类路径中存在某些类、存在特定的 beans 或某些属性的值。由于 Catalog Service 项目依赖于
    spring-boot-starter-web，Spring Boot 将初始化一个嵌入的 Tomcat 服务器实例，并应用几乎零时间即可启动和运行 Web
    应用程序所需的最小配置。
- en: That’s it for the application setup. Let’s go ahead and expose an HTTP endpoint
    from Catalog Service.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序设置到此结束。让我们继续从 Catalog Service 暴露一个 HTTP 端点。
- en: Implementing the controller
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 实现控制器
- en: So far, we have looked at the project as generated by Spring Initializr. It’s
    time to implement the business logic for the application.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经查看由 Spring Initializr 生成的项目。现在是时候实现应用程序的业务逻辑了。
- en: Catalog Service will expose an HTTP GET endpoint to return a friendly greeting
    to the user to welcome them to the book catalog. You can define a handler for
    it in a controller class. Figure 2.5 shows the interaction flow.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Catalog Service 将暴露一个 HTTP GET 端点，向用户返回友好的问候语，欢迎他们来到图书目录。您可以在控制器类中定义一个处理程序。图
    2.5 显示了交互流程。
- en: '![02-05](../Images/02-05.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![02-05](../Images/02-05.png)'
- en: Figure 2.5 Interaction between user and application to get a welcome message
    from the HTTP endpoint exposed by Catalog Service
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 用户与应用程序之间的交互，以从 Catalog Service 暴露的 HTTP 端点获取欢迎信息
- en: In the Catalog Service project, create a new HomeController class, and implement
    a method responsible for handling GET requests to the root endpoint (/).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Catalog Service 项目中，创建一个新的 HomeController 类，并实现一个负责处理根端点 (/) 的 GET 请求的方法。
- en: Listing 2.3 Defining an HTTP endpoint to return a welcome message
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.3 定义 HTTP 端点以返回欢迎信息
- en: '[PRE3]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Identifies a class defining handlers for REST/HTTP endpoints
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 识别一个定义 REST/HTTP 端点处理程序的类
- en: ❷ Handles GET requests to the root endpoint
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 处理根端点的 GET 请求
- en: The @RestController annotation identifies a class as a controller handling incoming
    HTTP requests. Using the @GetMapping annotation, you can mark the getGreeting()
    method as a handler for GET requests arriving at the root endpoint (/). Any GET
    request to that endpoint will be processed by this method. In the next chapter,
    I’ll cover how to build RESTful services with Spring in more detail.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '@RestController 注解标识了一个类，该类处理传入的 HTTP 请求。使用 @GetMapping 注解，您可以标记 getGreeting()
    方法为处理到达根端点 (/) 的 GET 请求的处理程序。任何对该端点的 GET 请求都将由该方法处理。在下一章中，我将更详细地介绍如何使用 Spring
    构建 RESTful 服务。'
- en: Testing the application
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 测试应用程序
- en: A basic test setup is included when you create a Spring project from Spring
    Initializr. In the build.gradle file you automatically get the dependencies needed
    for testing a Spring application. Furthermore, a test class is automatically generated.
    Let’s look at what the CatalogServiceApplicationTests class might look like after
    you initialize the project.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从Spring Initializr创建Spring项目时，会包含一个基本的测试设置。在build.gradle文件中，你自动获得测试Spring应用程序所需的依赖项。此外，还会自动生成一个测试类。让我们看看初始化项目后，CatalogServiceApplicationTests类可能的样子。
- en: Listing 2.4 The auto-generated test class verifying the Spring context
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.4 自动生成的测试类，用于验证Spring上下文
- en: '[PRE4]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Provides a setup for testing Spring Boot applications
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 为测试Spring Boot应用程序提供设置
- en: ❷ Identifies a test case
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 识别测试用例
- en: ❸ Empty test used to verify that the application context is loaded correctly
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 空测试用例，用于验证应用程序上下文是否正确加载
- en: 'The default test class is identified by the @SpringBootTest annotation, which
    provides many helpful features for testing Spring Boot applications. I’ll present
    them in more detail throughout the book. For now, it’s enough to know that it
    loads a full Spring application context for the tests to be run in. There is currently
    only one test case, which is empty: it’s used to verify that the Spring context
    is loaded correctly.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 默认测试类由@SpringBootTest注解标识，它为测试Spring Boot应用程序提供了许多有用的功能。我将在本书中更详细地介绍它们。现在，只需知道它为要运行的测试加载了完整的Spring应用程序上下文即可。目前只有一个测试用例，它是空的：它用于验证Spring上下文是否正确加载。
- en: Open a Terminal window, navigate to the application root folder (catalog-service),
    and run the test Gradle task to execute the application’s tests.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个终端窗口，导航到应用程序根目录（catalog-service），并运行测试Gradle任务以执行应用程序的测试。
- en: '[PRE5]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The task should be successful and the test green, meaning that the Spring application
    can start up without errors. What about the HTTP endpoint? Let’s find out.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 任务应该成功，测试结果为绿色，这意味着Spring应用程序可以无错误地启动。那么HTTP端点呢？让我们来看看。
- en: Running the application
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: 'You are done implementing the application, so you can go ahead and run it.
    There are different ways to do that, and I will show you some of them later. For
    now, you can use the task provided by the Spring Boot Gradle plugin: bootRun.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你已完成应用程序的实现，因此可以继续运行它。有几种不同的方法可以做到这一点，我将在稍后向你展示其中一些。现在，你可以使用Spring Boot Gradle插件提供的任务：bootRun。
- en: 'From the same Terminal window where you launched the tests, run this command:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 从启动测试的同一终端窗口中，运行以下命令：
- en: '[PRE6]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The application should be up and running in a second and ready to accept requests.
    In figure 2.6 you can see the logs streamed during the startup phase.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序应在瞬间启动并准备好接受请求。在图2.6中，你可以看到启动阶段流出的日志。
- en: '![02-06](../Images/02-06.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![02-06](../Images/02-06.png)'
- en: Figure 2.6 The startup logs from the Catalog Service application
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 目录服务应用程序的启动日志
- en: 'From the logs in figure 2.6, you’ll notice that the startup phase is composed
    of two main steps:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 从图2.6中的日志中，你会注意到启动阶段由两个主要步骤组成：
- en: Initialization and running of the embedded Tomcat server (which, by default,
    listens to port 8080 over HTTP)
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内嵌Tomcat服务器的初始化和运行（默认情况下，通过HTTP监听8080端口）
- en: Initialization and running of the Spring application context
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring应用程序上下文的初始化和运行
- en: At this point, you can finally verify whether your HTTP endpoint is working
    as intended. Open a browser window, navigate to http://localhost:8080/, and be
    ready to be welcomed to the Polar Bookshop’s book catalog.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你终于可以验证你的HTTP端点是否按预期工作。打开一个浏览器窗口，导航到http://localhost:8080/，准备被Polar Bookshop的图书目录欢迎。
- en: '[PRE7]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The development part of the Polar Bookshop application is done: you have a
    Catalog Service application welcoming users to the book catalog. Remember to terminate
    the bootRun process (Ctrl-C) to stop the application execution before moving on.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Polar Bookshop应用程序的开发部分已完成：你有一个目录服务应用程序欢迎用户进入图书目录。记住在继续之前，终止bootRun进程（Ctrl-C）以停止应用程序执行。
- en: The next step is deploying the application to the cloud. To make it portable
    on any cloud infrastructure, you should containerize it first. Enter Docker.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将应用程序部署到云中。为了使其在任何云基础设施上都具有可移植性，你应该首先将其容器化。进入Docker。
- en: 2.3 Containerizing applications with Docker
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 使用Docker容器化应用程序
- en: The Catalog Service application is working. Before deploying it to the cloud,
    however, you should containerize it. Why? Containers provide isolation from the
    surrounding environment, and they’re equipped with all the dependencies required
    by the application to run.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 目录服务应用程序正在运行。然而，在将其部署到云之前，你应该将其容器化。为什么？容器提供了与周围环境的隔离，并且它们配备了应用程序运行所需的所有依赖项。
- en: In our case, most of the dependencies are managed by Gradle and are packaged
    together with the application (JAR artifact). But the Java runtime is not included.
    Without a container, you would have to install the Java runtime on any machine
    where you want to deploy the application. Containerizing the application means
    it will be self-contained and portable across any cloud environment. With containers
    you can manage all applications in a standard way, no matter the language or framework
    used to implement them.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，大多数依赖项由Gradle管理，并与应用程序（JAR工件）一起打包。但是Java运行时不包括在内。没有容器，你必须在任何你想部署应用程序的机器上安装Java运行时。将应用程序容器化意味着它将是自包含的，并且可以在任何云环境中移植。使用容器，你可以以标准方式管理所有应用程序，无论它们是用什么语言或框架实现的。
- en: The *Open Container Initiative* (OCI), a Linux Foundation project, defines industry
    standards for working with containers ([https://opencontainers.org](https://opencontainers.org)).
    In particular, the OCI Image Specification defines how to build container images,
    the OCI Runtime Specification defines how to run those container images, and the
    OCI Distribution Specification defines how to distribute them. The tool we’ll
    use to work with containers is Docker ([www.docker.com](http://www.docker.com)),
    which is compliant with the OCI specifications.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*开放容器倡议*（OCI），一个Linux基金会项目，为与容器一起工作定义了行业标准（[https://opencontainers.org](https://opencontainers.org)）。特别是，OCI镜像规范定义了如何构建容器镜像，OCI运行时规范定义了如何运行这些容器镜像，而OCI分发规范定义了如何分发它们。我们将用于与容器一起工作的工具是Docker（[www.docker.com](http://www.docker.com)），它符合OCI规范。'
- en: Docker is an open source platform that “provides the ability to package and
    run an application in a loosely isolated environment called a container” ([https://docs.docker.com](https://docs.docker.com)).
    *Docker* is also the name of the company behind this technology, which is a founding
    member of the OCI. The same term is used in several of their commercial products,
    too. Whenever I write *Docker*, unless specified otherwise, I am referring to
    the open source platform we’ll use to build and run containers.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Docker是一个开源平台，它“提供了在称为容器的松散隔离环境中打包和运行应用程序的能力”([https://docs.docker.com](https://docs.docker.com))。*Docker*也是这个技术背后的公司的名字，该公司是OCI的创始成员。这个术语也用于他们的一些商业产品中。除非另有说明，每次我写*Docker*时，我指的是我们将用于构建和运行容器的开源平台。
- en: Before moving on, follow the instructions in section A.2 of appendix A to install
    and configure Docker in your development environment.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请按照附录A中的A.2节中的说明在你的开发环境中安装和配置Docker。
- en: '2.3.1 Introducing Docker: Images and containers'
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.1 介绍Docker：镜像和容器
- en: When you install the Docker platform on your machine, you get the Docker Engine
    package characterized by a client/server architecture. The *Docker server* contains
    the *Docker daemon*, a background process responsible for creating and managing
    Docker objects like images, containers, volumes, and networks. The machine where
    the Docker server runs is called the *Docker host*. Each machine where you want
    to run containers should be a Docker host, so it should have a Docker daemon running.
    The portability of containers is made possible by the daemon process itself.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在你的机器上安装Docker平台时，你会得到一个具有客户端/服务器架构的Docker引擎包。*Docker服务器*包含*Docker守护进程*，这是一个负责创建和管理Docker对象（如镜像、容器、卷和网络）的后台进程。运行Docker服务器的机器被称为*Docker主机*。你想要运行容器的每台机器都应该是一个Docker主机，因此它应该有一个正在运行的Docker守护进程。容器的可移植性是由守护进程本身实现的。
- en: The Docker daemon exposes an API you can use to send instructions, such as to
    run a container or create a volume. The *Docker client* talks to the daemon through
    that API. The client is command-line based and can be used to interact with the
    Docker daemon either through scripting (for example, Docker Compose) or through
    the Docker CLI directly.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Docker守护进程提供了一个API，你可以使用它来发送指令，例如运行一个容器或创建一个卷。*Docker客户端*通过该API与守护进程通信。客户端是基于命令行的，可以用来通过脚本（例如Docker
    Compose）或直接通过Docker CLI与Docker守护进程交互。
- en: Besides the client and server components characterizing the Docker Engine, another
    essential element of the platform is a *container registry*, which has a similar
    function to a Maven repository. While Maven repositories are used to host and
    distribute Java libraries, container registries do the same for container images,
    and they follow the OCI Distribution Specification. We distinguish between public
    and private registries. The Docker company provides a public registry called Docker
    Hub ([https://hub.docker.com](https://hub.docker.com)), which is configured by
    default with your local Docker installation and hosts images for many popular
    open source projects, like Ubuntu, PostgreSQL, and OpenJDK.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 除了表征Docker引擎的客户端和服务器组件之外，平台的一个基本元素是 *容器注册库*，它具有类似于Maven仓库的功能。虽然Maven仓库用于托管和分发Java库，但容器注册库为容器镜像执行相同的操作，并遵循OCI分发规范。我们区分公共和私有注册库。Docker公司提供了一个名为Docker
    Hub的公共注册库([https://hub.docker.com](https://hub.docker.com))，默认情况下与您的本地Docker安装配置，并托管许多流行的开源项目的镜像，如Ubuntu、PostgreSQL和OpenJDK。
- en: Based on the architecture description included in the Docker documentation ([https://docs.docker.com](https://docs.docker.com)),
    figure 2.7 shows how the Docker client, Docker server, and container registry
    interact.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Docker文档([https://docs.docker.com](https://docs.docker.com))中包含的架构描述，图2.7显示了Docker客户端、Docker服务器和容器注册库之间的交互。
- en: '![02-07](../Images/02-07.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![02-07](../Images/02-07.png)'
- en: Figure 2.7 The Docker Engine has a client/server architecture, and it interacts
    with a registry.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 Docker引擎具有客户端/服务器架构，并与注册库交互。
- en: The Docker daemon manages different objects. For now we’ll focus on images and
    containers.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Docker守护进程管理不同的对象。目前我们将重点关注镜像和容器。
- en: A *container image* (or, simply, an *image*) is a lightweight executable package
    that includes everything needed to run the application inside. The *Docker image*
    format is the most used one for creating container images, and it has been standardized
    by the OCI project (in the OCI Image Specification). OCI images can be created
    from scratch by defining instructions in a Dockerfile, a text-based file containing
    all the steps to generate the image. Usually, images are created based on another
    image. For example, you might build an image based on the OpenJDK one, on top
    of which you can add a Java application. After it’s created, the image can be
    pushed to a container registry like Docker Hub. A base name and a tag identify
    each image, where the tag is usually the version number. For example, the Ubuntu
    image for version 22.04 is called ubuntu:22.04. A colon separates the base name
    and version.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '*容器镜像*（或简单地称为 *镜像*）是一个轻量级的可执行包，它包含运行应用程序所需的一切。*Docker镜像*格式是创建容器镜像最常用的格式，它已被OCI项目（在OCI镜像规范中）标准化。可以从头开始创建OCI镜像，通过在Dockerfile中定义指令来实现，这是一个包含生成镜像所需所有步骤的基于文本的文件。通常，镜像基于另一个镜像创建。例如，您可能基于OpenJDK构建一个镜像，在其上您可以添加Java应用程序。创建后，镜像可以推送到容器注册库，如Docker
    Hub。每个镜像都有一个基本名称和标签来标识，其中标签通常是版本号。例如，版本22.04的Ubuntu镜像称为ubuntu:22.04。冒号分隔基本名称和版本。'
- en: 'A *container* is a runnable instance of a container image. You can manage the
    container life cycle from the Docker CLI or Docker Compose: you can start, stop,
    update, and delete containers. Containers are defined by the image on which they
    are based and the configuration provided at startup time (for example, environment
    variables used to customize the container). By default, containers are isolated
    from each other and the host machine, but you can make them expose services to
    the outside world through specific ports with a process called *port forwarding*
    or *port mapping*. Containers can have any name. If you don’t specify one, the
    Docker server will assign a random one, like bazinga_schrodinger. To run OCI images
    as containers, you’ll need Docker or any other container runtime compatible with
    the OCI specifications.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '*容器* 是容器镜像的可运行实例。您可以通过Docker CLI或Docker Compose管理容器的生命周期：您可以启动、停止、更新和删除容器。容器由其基于的镜像和启动时提供的配置（例如，用于自定义容器的环境变量）定义。默认情况下，容器彼此之间以及与主机机器是隔离的，但您可以通过称为
    *端口转发* 或 *端口映射* 的过程使它们通过特定端口向外部世界公开服务。容器可以有任意名称。如果您没有指定，Docker服务器将分配一个随机的名称，例如bazinga_schrodinger。要作为容器运行OCI镜像，您需要Docker或任何与OCI规范兼容的其他容器运行时。'
- en: When you want to run a new container, you can use the Docker CLI to interact
    with the Docker daemon, which checks whether the specified image is already present
    on the local server. If not, it will find the image on a registry, download it,
    and then use it to run a container. The workflow, again, is shown in figure 2.7.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想要运行一个新的容器时，您可以使用Docker CLI与Docker守护进程交互，该守护进程会检查指定的镜像是否已经存在于本地服务器上。如果没有，它将在注册表中找到该镜像，下载它，然后使用它来运行一个容器。该工作流程再次在图2.7中显示。
- en: Docker on macOS and Windows. How does it work?
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: macOS和Windows上的Docker。它是如何工作的？
- en: In the previous chapter, you learned that containers share the same operating
    system kernel and rely on Linux features such as namespaces and cgroups. We’ll
    use Docker to run Spring Boot applications in Linux containers, but how is Docker
    supposed to work on a macOS or Windows machine?
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您了解到容器共享相同的操作系统内核，并依赖于Linux功能，如命名空间和cgroups。我们将使用Docker在Linux容器中运行Spring
    Boot应用程序，但Docker如何在macOS或Windows机器上运行呢？
- en: When you install Docker on a Linux operating system, you get the full Docker
    Engine on your Linux host. However, if you install either *Docker Desktop for
    Mac* or *Docker Desktop for Windows*, only the Docker client is installed on your
    macOS/Windows host. Under the hood, a lightweight virtual machine is configured
    with Linux, and the Docker server component is installed on that machine. As a
    user, you will get almost the same experience as on a Linux machine; you will
    hardly notice any difference. But in reality, whenever you use the Docker CLI
    to perform operations, you are actually interacting with a Docker server on a
    different machine (the virtual machine running Linux).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在Linux操作系统上安装Docker时，您将在Linux主机上获得完整的Docker Engine。然而，如果您安装了*Mac*或*Windows*上的*Docker
    Desktop*，则只有Docker客户端安装在了您的macOS/Windows主机上。在底层，配置了一个带有Linux的轻量级虚拟机，并且Docker服务器组件安装在该机器上。作为用户，您将获得几乎与Linux机器上相同的体验；您几乎不会注意到任何差异。但事实上，每当您使用Docker
    CLI执行操作时，您实际上是在与另一台机器上的Docker服务器（运行Linux的虚拟机）交互。
- en: You can verify this yourself by starting Docker and running the docker version
    command. You’ll notice that the Docker client is running on a darwin/amd64 architecture
    (on macOS) or on windows/amd64 (on Windows), while the Docker server is running
    on linux/amd64.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过启动Docker并运行docker version命令来验证这一点。您会注意到Docker客户端正在darwin/amd64架构上运行（在macOS上）或windows/amd64（在Windows上），而Docker服务器正在linux/amd64上运行。
- en: '[PRE8]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Docker provides support for architectures other than AMD64\. For example, if
    you use a MacBook with Apple Silicon (ARM-based chips), you’ll find your Docker
    client running on a darwin/arm64 architecture and the Docker server on linux/arm64.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Docker支持除了AMD64以外的架构。例如，如果您使用搭载苹果硅（ARM架构芯片）的MacBook，您会发现您的Docker客户端运行在darwin/arm64架构上，而Docker服务器运行在linux/arm64上。
- en: 2.3.2 Running a Spring application as a container
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.2 将Spring应用程序作为容器运行
- en: Let’s go back to Catalog Service and see how you can run it as a container.
    There are different ways to achieve that, but here you will use the out-of-the-box
    integration of Spring Boot with Cloud Native Buildpacks ([https://buildpacks.io](https://buildpacks.io)),
    a project initiated by Heroku and Pivotal and now hosted by the CNCF. It provides
    a high-level abstraction for automatically transforming application source code
    into container images instead of using a low-level Dockerfile.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到目录服务，看看您如何将其作为容器运行。有几种不同的方法可以实现这一点，但在这里您将使用Spring Boot与Cloud Native Buildpacks的即插即用集成（[https://buildpacks.io](https://buildpacks.io)），这是一个由Heroku和Pivotal发起并由CNCF托管的项目。它为自动将应用程序源代码转换为容器镜像提供了一个高级抽象，而不是使用低级的Dockerfile。
- en: The Paketo Buildpacks (an implementation of the Cloud Native Buildpacks specification)
    are fully integrated with the Spring Boot Plugin, both for Gradle and Maven. This
    means that you can containerize your Spring Boot applications without downloading
    any additional tools, providing any extra dependencies, or writing a Dockerfile.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Paketo Buildpacks（Cloud Native Buildpacks规范的实现）与Spring Boot插件完全集成，适用于Gradle和Maven。这意味着您可以在不下载任何额外工具、不提供任何额外依赖项或编写Dockerfile的情况下容器化您的Spring
    Boot应用程序。
- en: Chapter 6 will describe how the Cloud Native Buildpacks project works and how
    you can configure it to containerize your Spring Boot applications. For now, I’ll
    give you a little preview of its features.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 第6章将描述Cloud Native Buildpacks项目的工作原理以及如何配置它以容器化您的Spring Boot应用程序。现在，我将为您展示其功能的一些预览。
- en: Open a Terminal window, navigate to the root folder of your Catalog Service
    project (catalog-service), and run the bootBuildImage Gradle task. That’s all
    you need to do to package your application as a container image, using Cloud Native
    Buildpacks under the hood.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个终端窗口，导航到你的 Catalog Service 项目（catalog-service）的根目录，并运行 bootBuildImage Gradle
    任务。这就是你需要做的，以使用底层的 Cloud Native Buildpacks 将你的应用程序打包成容器镜像。
- en: '[PRE9]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Warning As I write this, the Paketo project is working on adding support for
    ARM64 images. You can follow the feature’s progress on the Paketo Buildpacks project
    on GitHub: [https://github.com/paketo-buildpacks/stacks/issues/51](https://github.com/paketo-buildpacks/stacks/issues/51).
    Until that’s complete, you can still use Buildpacks to build containers and run
    them via Docker Desktop on Apple Silicon computers, but the build process and
    the application startup phase will be slower than usual. Until official support
    is added, you can alternatively use the following command, which points to an
    experimental version of Paketo Buildpacks with ARM64 support: ./gradlew bootBuildImage
    --builder ghcr.io/thomasvitale/java -builder-arm64. Be aware that it’s experimental
    and not ready for production. For more information, you can refer to the documentation
    on GitHub: [https://github.com/ThomasVitale/paketo-arm64](https://github.com/ThomasVitale/paketo-arm64).'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：在我撰写本文时，Paketo 项目正在努力添加对 ARM64 镜像的支持。你可以在 GitHub 上的 Paketo Buildpacks 项目中跟踪该功能的进展：[https://github.com/paketo-buildpacks/stacks/issues/51](https://github.com/paketo-buildpacks/stacks/issues/51)。在完成之前，你仍然可以使用
    Buildpacks 来构建容器并通过 Docker Desktop 在 Apple Silicon 计算机上运行它们，但构建过程和应用程序启动阶段将比通常慢。在官方支持添加之前，你可以使用以下命令，它指向一个带有
    ARM64 支持的实验性 Paketo Buildpacks 版本：./gradlew bootBuildImage --builder ghcr.io/thomasvitale/java
    -builder-arm64。请注意，这是实验性的，并不适合生产环境。更多信息，请参考 GitHub 上的文档：[https://github.com/ThomasVitale/paketo-arm64](https://github.com/ThomasVitale/paketo-arm64)。
- en: 'The first time you run the task, it will take a minute to download the packages
    used by Buildpacks to create the container image. The second time it will take
    only a few seconds. The resulting image will be named catalog-service:0.0.1-SNAPSHOT
    by default (<project_name>:<version>). You can run the following command to get
    the details of the newly created image:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次运行任务时，将花费一分钟下载用于创建容器镜像的 Buildpacks 所使用的包。第二次运行时，只需几秒钟。默认情况下，生成的镜像将被命名为 catalog-service:0.0.1-SNAPSHOT（<project_name>:<version>）。你可以运行以下命令来获取新创建镜像的详细信息：
- en: '[PRE10]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note You might have noticed in the previous command’s output that it looks like
    the image was created 42 years ago. That’s a convention used by Cloud Native Buildpacks
    to achieve reproducible builds. Subsequent execution of the build command should
    give the same output if nothing is changed in the input. Using an accurate creation
    timestamp would make that impossible, so Cloud Native Buildpacks uses a conventional
    timestamp (January 1, 1980).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你可能在之前的命令输出中注意到，镜像看起来像是 42 年前创建的。这是 Cloud Native Buildpacks 用于实现可重复构建的惯例。如果输入没有变化，后续的构建命令应该会给出相同的输出。使用准确的创建时间戳将使这变得不可能，因此
    Cloud Native Buildpacks 使用传统的日期时间戳（1980 年 1 月 1 日）。
- en: 'The last thing to do is run the image and verify that the containerized application
    is working correctly. Open a Terminal window and run the following command:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是运行镜像并验证容器化应用程序是否正常工作。打开一个终端窗口并运行以下命令：
- en: '[PRE11]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Warning If you’re running the container on an Apple Silicon computer, the previous
    command might return a message like “WARNING: The requested image’s platform (linux/amd64)
    does not match the detected host platform (linux/arm64/v8) and no specific platform
    was requested.” In that case, you’ll need to include an additional argument to
    the preceding command (before the image name) until support for ARM64 is added
    to Paketo Buildpacks: --platform linux/amd64.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '警告：如果你在 Apple Silicon 计算机上运行容器，之前的命令可能会返回类似“WARNING: 请求的镜像的平台（linux/amd64）与检测到的宿主平台（linux/arm64/v8）不匹配，且未请求特定平台。”的消息。在这种情况下，你需要向之前的命令（在镜像名称之前）添加一个额外的参数，直到
    Paketo Buildpacks 添加对 ARM64 的支持：--platform linux/amd64。'
- en: You can refer to figure 2.8 for a description of the command.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以参考图 2.8 来了解该命令的描述。
- en: '![02-08](../Images/02-08.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![02-08](../Images/02-08.png)'
- en: Figure 2.8 The Docker command to start a containerized application from an image
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8 从镜像启动容器化应用程序的 Docker 命令
- en: Open a browser window, navigate to http://localhost:8080/, and verify that you
    still get the same greeting you got earlier.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个浏览器窗口，导航到 http://localhost:8080/，并验证你是否仍然收到之前得到的问候。
- en: '[PRE12]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When you are done, stop the container with Ctrl-C.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，使用Ctrl-C停止容器。
- en: In chapter 6, you’ll learn more about how Docker works, how container images
    are built from a Spring Boot application, and how to use a container registry.
    I’ll also show you how to use Docker Compose to manage containers instead of using
    the Docker CLI.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在第6章中，您将了解Docker的工作原理，如何从Spring Boot应用程序构建容器镜像，以及如何使用容器注册库。我还会向您展示如何使用Docker
    Compose来管理容器，而不是使用Docker CLI。
- en: 2.4 Managing containers with Kubernetes
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4 使用Kubernetes管理容器
- en: 'So far, you have built a web application with Spring Boot (Catalog Service),
    containerized it with Cloud Native Buildpacks, and run it with Docker. To complete
    the pilot project for Polar Bookshop, you must perform one last step: deploy the
    application to a cloud environment. To do that, you will use Kubernetes, which
    has become the de facto standard for container orchestration. I will provide more
    details about Kubernetes in later chapters, but I want you to have a first taste
    of how it works and how you can use it to deploy a web application.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经使用Spring Boot（目录服务）构建了一个Web应用程序，使用Cloud Native Buildpacks对其进行容器化，并使用Docker运行它。为了完成Polar
    Bookshop的试点项目，您必须执行最后一步：将应用程序部署到云环境。为此，您将使用已成为容器编排事实标准的Kubernetes。我将在后面的章节中提供更多关于Kubernetes的详细信息，但我想让您先尝尝它的运作方式以及您如何使用它来部署Web应用程序。
- en: '*Kubernetes* (often shortened as *K8s*) is an open source system for automating
    the deployment, scaling, and management of containerized applications ([https://kubernetes.io](https://kubernetes.io)).
    When you are working with containers in Docker, your deployment target is a machine.
    In the example from the previous section, it was your computer. In other scenarios
    it might be a virtual machine (VM). In any case, it’s about deploying containers
    to a specific machine. However, when it comes to deploying containers without
    downtime, scaling them by leveraging the cloud’s elasticity, or connecting them
    across different hosts, you’ll need something more than a container engine. Instead
    of deploying to a specific machine, you are deploying to a cluster of machines,
    and Kubernetes, among other things, manages a cluster of machines for you. I covered
    this distinction in the previous chapter in the context of topologies. Figure
    2.9 will remind you of the different deployment targets in a container topology
    and an orchestration topology.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '*Kubernetes*（通常简称为*K8s*）是一个开源系统，用于自动化容器化应用的部署、扩展和管理([https://kubernetes.io](https://kubernetes.io))。当您在Docker中使用容器时，您的部署目标是机器。在前一节的例子中，它是您的电脑。在其他情况下，它可能是虚拟机（VM）。无论如何，这都是将容器部署到特定机器的过程。然而，当涉及到无停机时间部署容器、利用云的弹性进行扩展或在不同主机之间连接容器时，您需要比容器引擎更多的东西。您不是部署到特定的机器，而是部署到机器集群，而Kubernetes（以及其他一些东西）为您管理机器集群。我在上一章的拓扑结构上下文中讨论了这种区别。图2.9将提醒您容器拓扑结构和编排拓扑结构中的不同部署目标。'
- en: '![02-09](../Images/02-09.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![02-09](../Images/02-09.png)'
- en: Figure 2.9 The deployment target of containers is a machine, whereas for orchestrators
    it’s a cluster.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9 容器部署的目标是机器，而对于编排器来说，则是集群。
- en: 'Before moving on, follow the instructions in section A.3 of appendix A to install
    minikube and set up a Kubernetes cluster in your local development environment.
    Once you are done with the installation procedure, you can start a local Kubernetes
    cluster with the following command:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请按照附录A中的A.3节说明安装minikube并在您的本地开发环境中设置Kubernetes集群。完成安装过程后，您可以使用以下命令启动本地Kubernetes集群：
- en: '[PRE13]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '2.4.1 Introducing Kubernetes: Deployments, Pods, and Services'
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.1 Kubernetes简介：部署、Pod和Service
- en: Kubernetes is an open source container orchestrator hosted by the CNCF. In just
    a few years, it has become the most used solution for container orchestration,
    and all the major cloud providers have offerings for Kubernetes as a service.
    Kubernetes can run on a desktop, on a data center on premises, in the cloud, and
    even on an IoT device.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes是由CNCF托管的开放源代码容器编排器。仅在几年内，它已成为最常用的容器编排解决方案，所有主要的云提供商都提供了Kubernetes作为服务的解决方案。Kubernetes可以在桌面、本地数据中心、云中，甚至物联网设备上运行。
- en: When using a container topology, you need a machine with a container runtime.
    With Kubernetes, however, you switch to an orchestration topology, meaning that
    you need a cluster. A Kubernetes *cluster* is a set of worker machines (*nodes*)
    that run containerized applications. Every cluster has at least one worker node.
    With minikube. you can easily create a single-node cluster on your local machine.
    In production, you’ll use a cluster managed by a cloud provider.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用容器拓扑时，你需要一台具有容器运行时的机器。然而，使用Kubernetes时，你切换到编排拓扑，这意味着你需要一个集群。Kubernetes *集群*是一组运行容器化应用程序的工作机器（*节点*）。每个集群至少有一个工作节点。使用minikube，你可以在本地机器上轻松创建一个单节点集群。在生产环境中，你将使用由云提供商管理的集群。
- en: A Kubernetes cluster comprises machines called *worker nodes* on which your
    containerized applications are deployed. They provide capacity such as CPU, memory,
    network, and storage so that the containers can run and connect to a network.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes集群由称为*工作节点*的机器组成，你的容器化应用程序在这些机器上部署。它们提供CPU、内存、网络和存储等容量，以便容器可以运行并连接到网络。
- en: The *control plane* is the container orchestration layer that manages the worker
    nodes. It exposes the API and interfaces to define, deploy, and manage the life
    cycle of containers. It offers all the essential elements that implement the typical
    features of an orchestrator, like cluster management, scheduling, and health monitoring.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '*控制平面*是管理工作节点的容器编排层。它公开API和接口来定义、部署和管理容器的生命周期。它提供了实现编排器典型功能的所有基本元素，如集群管理、调度和健康监控。'
- en: Note In the context of container orchestration, *scheduling* means matching
    a container instance with a node where it will be run. The matching is based on
    a set of criteria, including the availability of enough computational resources
    to run the container on the node.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在容器编排的背景下，*调度*意味着将容器实例与将要运行的节点进行匹配。这种匹配基于一系列标准，包括节点上是否有足够的计算资源来运行容器。
- en: You can interact with Kubernetes through a CLI client, kubectl, which communicates
    with the control plane to perform some operations on the worker nodes. A client
    doesn’t interact with the worker nodes directly. Figure 2.10 shows the high-level
    components of the Kubernetes architecture.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过CLI客户端kubectl与Kubernetes交互，kubectl与控制平面通信以在工作节点上执行某些操作。客户端不直接与工作节点交互。图2.10显示了Kubernetes架构的高级组件。
- en: '![02-10](../Images/02-10.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![02-10](../Images/02-10.png)'
- en: Figure 2.10 Kubernetes’ main components are the API, the control plane, and
    the worker nodes.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10 Kubernetes的主要组件是API、控制平面和工作节点。
- en: Kubernetes can manage many different objects, either built-in or custom. In
    this section, you will use Pods, Deployments, and Services.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes可以管理许多不同的对象，无论是内置的还是定制的。在本节中，你将使用Pod、Deployment和Service。
- en: '*Pod*—The smallest deployable unit, which can include one or more containers.
    A Pod usually contains only one of your applications. It might also include extra
    containers supporting the primary application (such as containers providing additional
    functionality like logging or administrative tasks to run during the initialization
    step). Kubernetes manages Pods rather than containers directly.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Pod*——最小的可部署单元，可以包含一个或多个容器。Pod通常只包含你的一个应用程序。它也可能包含支持主要应用程序的额外容器（例如，在初始化步骤中运行提供额外功能如日志记录或管理任务的容器）。Kubernetes直接管理Pod而不是容器。'
- en: '*Deployment*—A Deployment informs Kubernetes about the desired deployment state
    for your application. For each instance, it creates a Pod and keeps it healthy.
    Among other things, a Deployment allows you to manage Pods as a set.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Deployment*——Deployment向Kubernetes通知你应用程序期望的部署状态。对于每个实例，它创建一个Pod并保持其健康。除了其他功能外，Deployment允许你将Pod作为一个集合来管理。'
- en: '*Service*—A Deployment (a set of Pods) can be exposed to other nodes in the
    cluster or outside by defining a Service that also takes care of balancing the
    load between Pod instances.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Service*——可以通过定义一个Service来将Deployment（一组Pod）暴露给集群中的其他节点或外部，该Service还负责在Pod实例之间平衡负载。'
- en: Note Throughout the book, I will write Kubernetes resources with capital letters
    to distinguish them from when the same terms are used with different meanings.
    For example, I’ll use *service* when referring to an application, whereas I’ll
    write *Service* when I mean the Kubernetes object.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在整个书中，我将使用大写字母来书写Kubernetes资源，以区分它们与在不同含义下使用时的相同术语。例如，当提到应用程序时，我会使用*service*，而当我指的是Kubernetes对象时，我会写*Service*。
- en: When you want to run a new application, you can define a *resource manifest*,
    a file that describes the desired state for the application. For example, you
    might specify that it should be replicated five times and exposed to the outside
    world through port 8080\. Resource manifests are usually written using YAML. You
    can then use the kubectl client to ask the control plane to create the resources
    described by the manifest. In the end, the control plane processes the request
    using its internal components and creates the resources in the worker nodes. The
    control plane still relies on a container registry to fetch the image defined
    in the resource manifest. The workflow, again, is shown in figure 2.10\.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想运行一个新的应用程序时，你可以定义一个*资源清单*，这是一个描述应用程序所需状态的文件。例如，你可能指定它应该被复制五次，并通过端口8080公开给外部世界。资源清单通常使用YAML编写。然后，你可以使用kubectl客户端请求控制平面创建清单中描述的资源。最后，控制平面使用其内部组件处理请求，并在工作节点上创建资源。控制平面仍然依赖于容器注册库来检索资源清单中定义的镜像。工作流程，再次，如图2.10所示。
- en: 2.4.2 Running a Spring application on Kubernetes
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.2 在Kubernetes上运行Spring应用程序
- en: Let’s go back to the Polar Bookshop project. In the previous section, you containerized
    the Catalog Service application. Now it’s time to deploy it to a cluster using
    Kubernetes. You already have a cluster up and running in your local environment.
    What you need is a resource manifest.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到Polar Bookshop项目。在上一个章节中，你将Catalog Service应用程序容器化了。现在，是时候使用Kubernetes将其部署到集群中。你已经在本地环境中有一个运行中的集群。你需要的是一个资源清单。
- en: The standard way to interact with Kubernetes is through declarative instructions
    that you can define in a YAML or JSON file. I will show you how to write resource
    manifests in chapter 7\. Until then, you can use the Kubernetes CLI as you did
    with Docker earlier.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 与Kubernetes交互的标准方式是通过你在YAML或JSON文件中定义的声明性指令。我将在第7章中向你展示如何编写资源清单。在此之前，你可以像之前使用Docker一样使用Kubernetes
    CLI。
- en: 'First you need to tell Kubernetes to deploy Catalog Service from a container
    image. You built one previously (catalog-service:0.0.1-SNAPSHOT). By default,
    minikube uses the Docker Hub registry to pull images, and it doesn’t have access
    to your local ones. Therefore, it will not find the image you built for the Catalog
    Service application. But don’t worry: you can manually import it into your local
    cluster.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要告诉Kubernetes从容器镜像部署Catalog Service。你之前已经构建了一个（catalog-service:0.0.1-SNAPSHOT）。默认情况下，minikube使用Docker
    Hub注册库来拉取镜像，并且它无法访问你本地的镜像。因此，它将找不到你为Catalog Service应用程序构建的镜像。但别担心：你可以手动将其导入到你的本地集群中。
- en: 'Open a Terminal window, and run the following command:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个终端窗口，并运行以下命令：
- en: '[PRE14]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The deployment unit will be a Pod, but you will not manage Pods directly. Instead,
    you’ll want to let Kubernetes handle that. Pods are application instances, and
    as such they are ephemeral. To achieve the cloud native goals, you want the platform
    to take care of instantiating Pods so that if one goes down, it can be replaced
    by another one. What you need is a *Deployment* resource that will make Kubernetes
    create application instances as *Pod* resources.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 部署单元将是一个Pod，但你不会直接管理Pod。相反，你希望让Kubernetes来处理。Pod是应用程序实例，因此它们是短暂的。为了实现云原生目标，你希望平台负责实例化Pod，以便如果一个Pod失败，它可以被另一个Pod替换。你需要的是一个*Deployment*资源，这样Kubernetes就能创建应用程序实例作为*Pod*资源。
- en: 'From a Terminal window, run the following command:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 从终端窗口运行以下命令：
- en: '[PRE15]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can refer to figure 2.11 for a description of the command.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以参考图2.11来了解命令的描述。
- en: '![02-11](../Images/02-11.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![02-11](../Images/02-11.png)'
- en: Figure 2.11 The Kubernetes command to create a Deployment from a container image.
    Kubernetes will take care of creating Pods for the application.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11：从容器镜像创建Deployment的Kubernetes命令。Kubernetes将负责为应用程序创建Pod。
- en: 'You can verify the creation of the Deployment object as follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以按照以下方式验证Deployment对象的创建：
- en: '[PRE16]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Behind the scenes, Kubernetes created a Pod for the application defined in
    the Deployment resource. You can verify the creation of the Pod object as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，Kubernetes为在Deployment资源中定义的应用程序创建了一个Pod。你可以按照以下方式验证Pod对象的创建：
- en: '[PRE17]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Tip You can check the application logs by running kubectl logs deployment/ catalog-service.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：你可以通过运行`kubectl logs deployment/catalog-service`来检查应用程序日志。
- en: 'By default, applications running in Kubernetes are not accessible. Let’s fix
    that. First, you can expose Catalog Service to the cluster through a Service resource
    by running the following command:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，在Kubernetes中运行的应用程序是不可访问的。让我们解决这个问题。首先，你可以通过运行以下命令通过Service资源将目录服务暴露给集群：
- en: '[PRE18]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Figure 2.12 provides a description of the command.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12提供了该命令的描述。
- en: '![02-12](../Images/02-12.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![02-12](../Images/02-12.png)'
- en: Figure 2.12 The Kubernetes command to expose a Deployment as a Service. The
    Catalog Service application will be exposed to the cluster network through port
    8080.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12 将Deployment作为Service暴露的Kubernetes命令。目录服务应用程序将通过端口8080暴露给集群网络。
- en: 'The Service object exposes the application to other components inside the cluster.
    You can verify that it’s been created correctly with the following command:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: Service对象将应用程序暴露给集群内的其他组件。你可以使用以下命令验证它是否已正确创建：
- en: '[PRE19]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You can then forward the traffic from a local port on your computer (for example,
    8000) to the port exposed by the Service inside the cluster (8080). Remember the
    port mapping in Docker? This works in a similar way. The output of the command
    will tell you if the port forwarding is configured correctly:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以将来自你电脑上本地端口的流量（例如，8000）转发到集群内Service暴露的端口（8080）。还记得Docker中的端口映射吗？这与此类似。命令的输出将告诉你端口转发是否配置正确：
- en: '[PRE20]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You can refer to figure 2.13 for a description of the command.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以参考图2.13来了解该命令的描述。
- en: '![02-13](../Images/02-13.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![02-13](../Images/02-13.png)'
- en: Figure 2.13 The Kubernetes command for forwarding a port from your localhost
    to a Service inside the cluster. The Catalog Service application will be exposed
    to your localhost through port 8000.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.13 将本地主机的端口转发到集群内Service的Kubernetes命令。目录服务应用程序将通过端口8000暴露给本地主机。
- en: Now whenever you access port 8000 on your localhost, you will be forwarded to
    the Service inside the Kubernetes cluster responsible for exposing the Catalog
    Service application. Open a browser window, navigate to http://localhost:8000/
    (make sure you use 8000 and not 8080), and verify that you still get the same
    greeting as before.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，无论何时你访问本地主机的端口8000，你都会被转发到负责暴露目录服务应用程序的Kubernetes集群内的Service。打开一个浏览器窗口，导航到http://localhost:8000/（确保使用8000而不是8080），并验证你是否仍然得到之前相同的问候。
- en: '[PRE21]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Well done! You started with a Java application implemented using Spring Boot.
    Then you containerized it with Cloud Native Buildpacks and ran it on Docker. Finally,
    you used Kubernetes to get the application deployed to a cluster. Sure, it was
    a local cluster, but it could have been a remote one in the cloud. The beauty
    of this process is that it works the same way regardless of the environment. You
    could use the exact same approach to deploy Catalog Service to a cluster in a
    public cloud infrastructure. Isn’t it great?
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！你从一个使用Spring Boot实现的Java应用程序开始。然后你使用Cloud Native Buildpacks对其进行容器化，并在Docker上运行它。最后，你使用Kubernetes将应用程序部署到集群中。当然，这是一个本地集群，但它也可以是云中的远程集群。这个过程的美丽之处在于，它无论在什么环境中工作方式都是一样的。你可以使用完全相同的方法将目录服务部署到公共云基础设施中的集群。这不是很棒吗？
- en: In chapter 7, you will work more with Kubernetes. For now, terminate the port-forwarding
    process with Ctrl-C, delete the Service with kubectl delete service catalog -service,
    and delete the Deployment with kubectl delete deployment catalog -service. Finally,
    you can stop the Kubernetes cluster with minikube stop.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在第7章中，你将更多地使用Kubernetes。现在，使用Ctrl-C终止端口转发过程，使用kubectl delete service catalog
    -service删除Service，并使用kubectl delete deployment catalog -service删除Deployment。最后，你可以使用minikube
    stop停止Kubernetes集群。
- en: '2.5 Polar Bookshop: A cloud native application'
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.5 极地书店：一个云原生应用程序
- en: 'In this book, I aim to provide real-world code examples as often as possible.
    Now that you have explored some of the key concepts and have tried your hand at
    building, containerizing, and deploying a Spring application, let’s take on a
    slightly more complicated project: an online bookshop. In the rest of the book,
    I’ll guide you through developing a complete cloud native system based on Spring
    applications, containerizing it, and deploying it with Kubernetes in a public
    cloud.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我旨在尽可能多地提供现实世界的代码示例。现在你已经探索了一些关键概念，并尝试过构建、容器化和部署一个Spring应用程序，让我们承担一个稍微复杂一些的项目：一个在线书店。在本书的其余部分，我将指导你开发一个基于Spring应用程序的完整云原生系统，将其容器化，并在公共云中使用Kubernetes进行部署。
- en: For each concept we cover in the following chapters, I’ll show you how to apply
    it to a real-world cloud native scenario for a complete hands-on learning experience.
    Remember that all the code used in this book is available on the book’s GitHub
    repository.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们在以下章节中涵盖的每个概念，我将向你展示如何将其应用于实际的云原生场景，以获得完整的动手学习体验。请记住，本书中使用的所有代码都可在本书的GitHub仓库中找到。
- en: This section will define the requirements for the cloud native project we’ll
    build, and it will describe its architecture. Then I’ll outline the main technologies
    and patterns we’ll use to implement it.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将定义我们将构建的云原生项目的需求，并描述其架构。然后我将概述我们将用于实现它的主要技术和模式。
- en: 2.5.1 Understanding the requirements of the system
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.1 理解系统的需求
- en: 'Polar Bookshop is a specialized bookshop whose mission is to spread knowledge
    and information about the North Pole and the Arctic, where the bookshop is located:
    the Arctic’s history, geography, animals, and so on. The organization managing
    the bookshop, Polarsophia, has decided to start selling its books online to spread
    them worldwide, but that is only the beginning. The project is very ambitious,
    and the vision includes a suite of software products to fulfill the Polarsophia
    mission. After the successful pilot project earlier in this chapter, the organization
    has decided to embark on a cloud native journey.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: Polar Bookshop是一家专门的书店，其使命是传播关于北极和北极地区的知识和信息，书店就位于那里：北极的历史、地理、动物等等。管理书店的Polarsophia组织决定开始在线销售书籍，以将它们传播到世界各地，但这只是开始。该项目非常雄心勃勃，愿景包括一系列软件产品，以实现Polarsophia的使命。在本章前面的成功试点项目之后，该组织决定开始云原生之旅。
- en: Throughout the book, you’ll build the core part of a system with endless possibilities
    in terms of functionality and integration. The management plans to deliver new
    features in short iterations, reducing the time to market and getting early feedback
    from users. Their goal is to bring the bookshop close to everyone, everywhere,
    so the application should be highly scalable. With a worldwide audience, such
    a system needs to be highly available, so resilience is essential.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，你将构建一个系统的基础部分，这个系统在功能和集成方面具有无限的可能性。管理层计划通过短周期迭代交付新功能，缩短上市时间，并从用户那里获得早期反馈。他们的目标是让书店接近每个人，无论身在何处，因此应用应该具有高度的可扩展性。由于面向全球受众，这样一个系统需要高度可用，因此弹性是必不可少的。
- en: Polarsophia is a small organization, and they need to optimize costs, especially
    those regarding infrastructure. They can’t afford to build their own data center,
    so they have decided to rent IT hardware from a third party.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: Polarsophia是一个小型组织，他们需要优化成本，特别是与基础设施相关的成本。他们负担不起建立自己的数据中心，因此他们决定从第三方租赁IT硬件。
- en: By now, you can probably recognize some of the reasons why companies move to
    the cloud. That’s what we’ll do for the Polar Bookshop application. Of course,
    it will be a cloud native application.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能已经能够识别出一些公司为何要迁移到云的原因。这就是我们将为Polar Bookshop应用程序所做的事情。当然，它将是一个云原生应用程序。
- en: 'Books will be available for sale through the application. When a customer purchases
    a book, they should be able to check on the status of their order. Two categories
    of people will use the Polar Bookshop application:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 书籍将通过应用程序出售。当客户购买书籍时，他们应该能够检查他们订单的状态。将有两类人使用Polar Bookshop应用程序：
- en: Customers can browse books in the catalog, buy some, and check their orders.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户可以在目录中浏览书籍，购买一些，并检查他们的订单。
- en: Employees can manage books, update existing ones, and add new items to the catalog.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 员工可以管理书籍，更新现有书籍，并向目录中添加新项目。
- en: Figure 2.14 describes the architecture of the Polar Bookshop cloud native system.
    As you can see, it’s made up of several services. Some will implement the business
    logic of the system to provide the functionality already mentioned. Other services
    will implement shared concerns like centralized configuration. For clarity, the
    figure doesn’t show the services responsible for the security and observability
    concerns. You’ll learn about them later in the book.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.14描述了Polar Bookshop云原生系统的架构。如图所示，它由几个服务组成。其中一些将实现系统的业务逻辑，以提供已提到的功能。其他服务将实现共享关注点，如集中式配置。为了清晰起见，该图没有显示负责安全和可观察性的服务。你将在本书后面的章节中了解它们。
- en: In the following chapters, I’ll guide you through figure 2.14 in more detail,
    adding more information about specific services and adopting different points
    of view to visualize the system in its deployment stage. For now, let’s look at
    the patterns and technologies we’ll use in the project.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我将更详细地引导你了解图2.14，添加有关特定服务的更多信息，并采用不同的视角来可视化系统的部署阶段。现在，让我们看看我们在项目中将使用的模式和技术的概述。
- en: 2.5.2 Exploring patterns and technologies used in the project
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.2 探索项目中使用的模式和技术的探索
- en: I’ll show you how to apply specific technologies or patterns to the Polar Bookshop
    project when I introduce each new topic in the book. Here I’ll give you an overview
    of the main concerns we will address and the technologies and patterns we’ll use
    to accomplish them.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在书中介绍每个新主题时，我会向你展示如何将特定的技术或模式应用于Polar Bookshop项目。在这里，我将为你概述我们将要解决的主要问题以及我们将使用的技术和模式来完成它们。
- en: '![02-14](../Images/02-14.png)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![02-14](../Images/02-14.png)'
- en: Figure 2.14 Architecture of Polar Bookshop. The cloud native system comprises
    application and data services with different responsibilities. For clarity, the
    security and observability services are not shown.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.14 Polar Bookshop的架构。云原生系统包含具有不同责任的应用程序和数据服务。为了清晰起见，安全和可观察性服务未显示。
- en: Web and interactions
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 网络和交互
- en: Polar Bookshop comprises several services that will have to communicate with
    each other to provide their functionality. You’ll build RESTful services that
    interact synchronously over HTTP, both in a blocking way (using traditional servlets)
    and non-blocking ways (using reactive programming). Spring MVC and Spring WebFlux
    (on top of Project Reactor) will be your main tools for accomplishing such a result.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: Polar Bookshop包含几个服务，这些服务必须相互通信以提供其功能。你将构建RESTful服务，这些服务通过HTTP以同步方式交互，包括阻塞方式（使用传统的servlets）和非阻塞方式（使用响应式编程）。Spring
    MVC和Spring WebFlux（基于Project Reactor）将是实现这种结果的主要工具。
- en: 'When building cloud native applications, you should design loosely coupled
    services and consider how you can keep data consistent in a distributed system
    context. Synchronous communications can generate problems when multiple services
    are involved in accomplishing a function. That’s why event-driven programming
    is getting very popular in the cloud: it allows you to overcome the issues of
    synchronous communications.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建云原生应用程序时，你应该设计松耦合的服务，并考虑如何在分布式系统环境中保持数据一致性。当多个服务参与完成一个功能时，同步通信可能会产生问题。这就是为什么事件驱动编程在云中变得越来越受欢迎：它允许你克服同步通信的问题。
- en: I’ll show you how to use events and messaging systems to decouple services and
    ensure data consistency. You’ll use Spring Cloud Stream to implement data streams
    between services and Spring Cloud Function to define message handlers as functions.
    The latter approach could naturally evolve in serverless applications deployed
    to platforms like Azure Functions, AWS Lambda, or Knative.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我将向你展示如何使用事件和消息系统来解耦服务并确保数据一致性。你将使用Spring Cloud Stream在服务之间实现数据流，并使用Spring Cloud
    Function将消息处理器定义为函数。后者在部署到Azure Functions、AWS Lambda或Knative等平台的无服务器应用程序中可以自然地演进。
- en: Data
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 数据
- en: Data is a crucial part of software systems. In Polar Bookshop you’ll use the
    PostgreSQL relational database to permanently store the data processed by the
    application. I’ll show you how to integrate an application with a data source
    using Spring Data JDBC (imperative) and Spring Data R2DBC (reactive). You’ll then
    learn how to evolve a data source and manage schema migrations with Flyway.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 数据是软件系统的重要组成部分。在Polar Bookshop中，你将使用PostgreSQL关系数据库永久存储应用程序处理的数据。我将向你展示如何使用Spring
    Data JDBC（命令式）和Spring Data R2DBC（响应式）将应用程序与数据源集成。然后，你将学习如何使用Flyway演进数据源和管理模式迁移。
- en: Cloud native applications should be stateless, but the state needs to be stored
    somewhere. In Polar Bookshop you’ll use Redis to externalize the session storage
    to a data store and keep applications stateless and scalable. Spring Session makes
    it easy to implement clustered user sessions. In particular, I’ll show you how
    to use Spring Session Data Redis to integrate the application session management
    with Redis.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生应用程序应该是无状态的，但状态需要存储在某个地方。在Polar Bookshop中，你将使用Redis将会话存储外部化到数据存储中，以保持应用程序无状态和可扩展。Spring
    Session使得实现集群用户会话变得简单。特别是，我将向你展示如何使用Spring Session Data Redis将应用程序会话管理集成到Redis中。
- en: Besides persisted data and session data, you’ll also deal with messages to implement
    event-driven programming patterns. Spring AMQP and RabbitMQ will be the technologies
    you’ll use to do so.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 除了持久化数据和会话数据外，您还将处理消息以实现事件驱动编程模式。您将使用Spring AMQP和RabbitMQ来完成这项工作。
- en: Locally, you’ll run these data services in Docker containers. In production,
    you’ll rely on the managed services offered by a cloud provider like DigitalOcean
    or Azure, which take care of critical concerns like high availability, clustering,
    storage, and data replication.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地，您将在Docker容器中运行这些数据服务。在生产环境中，您将依赖由云提供商（如DigitalOcean或Azure）提供的托管服务，这些服务负责处理高可用性、集群、存储和数据复制等关键问题。
- en: Configuration
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 配置
- en: Throughout the book I’ll show you how to configure the services in Polar Bookshop
    in different ways. I’ll start by exploring the options offered by Spring Boot
    properties and profiles, and when to use them. You’ll then learn how to apply
    external configuration by using environment variables when running a Spring application
    as a JAR and as a container. Then you’ll see how to centralize the configuration
    management through a configuration server with Spring Cloud Config. Finally, I’ll
    teach you how to use ConfigMaps and Secrets in Kubernetes.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我将向您展示如何以不同的方式配置Polar Bookshop中的服务。我将首先探讨Spring Boot属性和配置文件提供的选项，以及何时使用它们。然后您将学习如何在以JAR或容器形式运行Spring应用程序时使用环境变量来应用外部配置。然后您将看到如何通过Spring
    Cloud Config配置服务器来集中管理配置。最后，我将教您如何在Kubernetes中使用ConfigMaps和Secrets。
- en: Routing
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 路由
- en: 'Polar Bookshop, being a distributed system, will need some routing configuration.
    Kubernetes has a built-in service discovery feature that can help you decouple
    services from their physical addresses and hostnames. Cloud native applications
    are scalable, so any interactions between them should take that into account:
    which instance should you call? Once again, Kubernetes offers you a load-balancing
    feature natively, so you don’t need to implement anything in your application.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Polar Bookshop是一个分布式系统，它将需要一些路由配置。Kubernetes具有内置的服务发现功能，可以帮助您将服务与其物理地址和主机名解耦。云原生应用是可扩展的，因此它们之间的任何交互都应该考虑到这一点：您应该调用哪个实例？Kubernetes再次为您提供原生的负载均衡功能，因此您不需要在应用程序中实现任何内容。
- en: Using Spring Cloud Gateway, I’ll guide you through implementing a service that
    will act as an API gateway to shield the outside from any internal API changes.
    It will also be an edge service that you’ll use to address cross-cutting concerns,
    like security and resilience, in one place. Such a service will be the entry point
    to Polar Bookshop, and it will have to be highly available, performant, and fault-tolerant.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Spring Cloud Gateway，我将指导您实现一个作为API网关的服务，以保护外部不受任何内部API更改的影响。它还将是一个边缘服务，您将使用它来处理诸如安全性和弹性等横切关注点。此类服务将是Polar
    Bookshop的入口点，它必须具有高可用性、高性能和容错性。
- en: Observability
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察性
- en: The services in the Polar Bookshop system should be observable to be defined
    as cloud native. I’ll show you how to use Spring Boot Actuator to set up health
    and info endpoints and expose metrics with Micrometer to be fetched and processed
    by Prometheus. You’ll then use Grafana to visualize the most critical metrics
    in informative dashboards.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: Polar Bookshop系统中的服务应该是可观察的，才能被定义为云原生。我将向您展示如何使用Spring Boot Actuator设置健康和info端点，并使用Micrometer暴露指标，以便Prometheus可以抓取和处理。然后您将使用Grafana在信息仪表板中可视化最关键的指标。
- en: Requests can be handled by more than one service, so you’ll need distributed
    tracing functionality to follow the request flow from one service to another.
    You’ll set that up with OpenTelemetry. Then Grafana Tempo will fetch, process,
    and visualize the traces to give you a complete picture of how the system accomplishes
    its functions.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 请求可以由多个服务处理，因此您需要分布式跟踪功能来跟踪请求从一个服务到另一个服务的流程。您将使用OpenTelemetry来设置该功能。然后Grafana
    Tempo将抓取、处理和可视化跟踪，以向您展示系统如何完成其功能的全貌。
- en: Finally you’ll need a logging strategy in place. We should handle logs as event
    streams, so you’ll make your Spring applications stream log events to the standard
    output without considering how they are processed or stored. Fluent Bit will take
    care of collecting logs from all services, Loki will store and process them, and
    Grafana will let you browse them.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您需要实施一个日志策略。我们应该将日志作为事件流来处理，因此您将使您的Spring应用程序将日志事件流式传输到标准输出，而不考虑它们是如何被处理或存储的。Fluent
    Bit将负责从所有服务中收集日志，Loki将存储和处理它们，而Grafana将允许您浏览它们。
- en: Resilience
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 弹性
- en: Cloud native applications should be resilient. For the Polar Bookshop project,
    I’ll show you various techniques for making an application resilient using Project
    Reactor, Spring Cloud Circuit Breaker, and Resilience4J to implement circuit breakers,
    retries, timeouts, and other patterns.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生应用应该具有弹性。在Polar Bookshop项目中，我将向您展示使用Project Reactor、Spring Cloud Circuit
    Breaker和Resilience4J实现断路器、重试、超时和其他模式的多种技术，以使应用程序具有弹性。
- en: Security
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性
- en: Security is a vast subject that I won’t be able to cover deeply in this book.
    Still, I recommend exploring the topic, since it’s one of the most critical software
    concerns nowadays. It’s a pervasive concern that should be addressed continuously
    from the very beginning of the project.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性是一个庞大的主题，我无法在这本书中深入探讨。尽管如此，我仍然建议您探索这个主题，因为它现在是软件领域最关键的担忧之一。这是一个从项目一开始就需要持续关注的问题。
- en: For Polar Bookshop, I’ll show you how to add authentication and authorization
    functionality to cloud native applications. You’ll see how to secure communications
    between services, and between users and applications. OAuth 2.1 and OpenID Connect
    will be the standards you’ll rely on to implement such functionality. Spring Security
    supports those standards and integrates seamlessly with external services to provide
    authentication and authorization. You’ll use Keycloak for identity and access
    control management.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Polar Bookshop，我将向您展示如何向云原生应用程序添加身份验证和授权功能。您将了解如何保护服务之间的通信，以及用户与应用程序之间的通信。OAuth
    2.1和OpenID Connect将是您实现此类功能所依赖的标准。Spring Security支持这些标准，并与外部服务无缝集成以提供身份验证和授权。您将使用Keycloak进行身份和访问控制管理。
- en: Also, I’ll introduce the concepts of secrets management and encryption. I won’t
    be able to go too deep into those topics, but I’ll show you how to manage secrets
    to configure Spring Boot applications.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我将介绍秘密管理和加密的概念。我无法对这些主题进行深入探讨，但我将向您展示如何管理秘密以配置Spring Boot应用程序。
- en: Testing
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 测试
- en: Automated testing is paramount for the success of a cloud native application.
    A few levels of automated tests will cover the Polar Bookshop application. I’ll
    show you how to use JUnit5 to write unit tests. Spring Boot adds many convenient
    utilities that improve integration testing, and you will use them to ensure the
    quality of your services. You’ll write tests for the various features used in
    Polar Bookshop, including REST endpoints, messaging streams, data integrations,
    and security.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试对于云原生应用程序的成功至关重要。几个自动化测试级别将涵盖Polar Bookshop应用程序。我将向您展示如何使用JUnit5编写单元测试。Spring
    Boot添加了许多方便的实用工具，这些工具可以改善集成测试，您将使用它们来确保服务的质量。您将为Polar Bookshop中使用的各种功能编写测试，包括REST端点、消息流、数据集成和安全。
- en: Keeping parity across environments is essential to ensure the quality of your
    applications. This is especially true when it comes to backing services. In production,
    you will use services such as PostgreSQL and Redis. During testing, you should
    use similar services rather than mocks or test-specific tools like the H2 in-memory
    database. The Testcontainers framework will help you use real services as containers
    in your automated tests.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 保持环境之间的平衡对于确保应用程序的质量至关重要。这在备份服务方面尤其如此。在生产环境中，您将使用PostgreSQL和Redis等服务。在测试期间，您应该使用类似的服务，而不是模拟或特定于测试的工具，如H2内存数据库。Testcontainers框架将帮助您在自动化测试中使用真实服务作为容器。
- en: Build and deployment
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 构建和部署
- en: Polar Bookshop’s primary services will use Spring. You’ll see how to package
    a Spring application, run it as a JAR file, containerize it with Cloud Native
    Buildpacks, run it with Docker, and finally deploy containers with Kubernetes.
    You’ll also see how to compile Spring applications to native images using Spring
    Native and GraalVM, and use them in serverless architectures, taking advantage
    of their instant startup time, instant peak performance, reduced memory consumption,
    and reduced image size. Then you’ll deploy them on a serverless platform built
    on top of Kubernetes with Knative.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: Polar Bookshop的主要服务将使用Spring。您将了解如何打包Spring应用程序，将其作为JAR文件运行，使用Cloud Native Buildpacks进行容器化，使用Docker运行，并最终使用Kubernetes部署容器。您还将了解如何使用Spring
    Native和GraalVM将Spring应用程序编译为原生镜像，并在无服务器架构中使用它们，利用它们的即时启动时间、即时峰值性能、降低内存消耗和减少镜像大小。然后，您将在基于Kubernetes的Knative无服务器平台上部署它们。
- en: I’ll show you how to automate the build stage by setting up a deployment pipeline
    with GitHub Actions. The pipeline will build the application at every commit,
    run the tests, and package it ready for deployment. Such automation will support
    a continuous delivery culture to bring value to customers quickly and reliably.
    In the end, you’ll also automate the deployment of Polar Bookshop to the production
    Kubernetes cluster using GitOps practices and Argo CD.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我会向你展示如何通过设置 GitHub Actions 部署管道来自动化构建阶段。该管道将在每次提交时构建应用程序，运行测试，并将其打包为就绪状态以供部署。这种自动化将支持持续交付文化，快速且可靠地为客户带来价值。最后，你还将使用
    GitOps 实践和 Argo CD 自动化 Polar Bookshop 的生产 Kubernetes 集群部署。
- en: UI
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: UI
- en: This book is focused on backend technologies, so I won’t teach you any frontend
    subjects. Of course, your application will need a frontend for the users to interact
    with. In the case of Polar Bookshop, you’ll rely on a client application using
    the Angular framework. I won’t show you the UI application code in this book because
    it’s out of scope, but I’ve included it in the code repository accompanying the
    book.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书专注于后端技术，所以我不会教你任何前端主题。当然，你的应用程序需要前端供用户与之交互。在 Polar Bookshop 的情况下，你将依赖于使用
    Angular 框架的客户端应用程序。我不会在这本书中展示 UI 应用程序代码，因为它超出了范围，但我已经将它包含在随书附带的代码仓库中。
- en: Summary
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: The 15-Factor methodology identifies development principles for building applications
    that offer maximum portability across execution environments, are suitable to
    be deployed on cloud platforms, can be scaled, guarantee environment parity between
    development and production, and enable continuous delivery.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 15-Factor 方法确定了构建应用程序的开发原则，这些应用程序在执行环境中提供最大可移植性，适合部署在云平台上，可扩展，保证开发和生产环境之间的环境一致性，并支持持续交付。
- en: Spring is a suite of projects that provide all of the most common functionality
    for building modern applications in Java.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring 是一套项目，为使用 Java 构建现代应用程序提供所有最常用的功能。
- en: Spring Framework provides an application context in which beans and properties
    are managed throughout the entire life cycle.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring 框架提供了一个应用程序上下文，在其中管理着整个生命周期中的 beans 和属性。
- en: Spring Boot lays the foundation for cloud native development by speeding up
    the building of production-ready applications, including embedded servers, auto-configuration,
    monitoring, and containerization features.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot 通过加速构建生产就绪应用程序，包括嵌入式服务器、自动配置、监控和容器化功能，为云原生开发奠定了基础。
- en: Container images are lightweight executable packages that include everything
    needed to run the applications inside.
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器镜像是一种轻量级的可执行包，包含运行应用程序所需的一切。
- en: Docker is an OCI-compliant platform for building and running containers.
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 是一个符合 OCI 标准的平台，用于构建和运行容器。
- en: A Spring Boot application can be packaged as a container image with Cloud Native
    Buildpacks, a CNCF project that specifies how to convert application source code
    into production-ready container images.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot 应用程序可以打包为容器镜像，使用 Cloud Native Buildpacks，这是一个 CNCF 项目，它指定了如何将应用程序源代码转换为生产就绪的容器镜像。
- en: When dealing with several containers, as is usually the case in a cloud native
    system, you need to manage this complex system. Kubernetes provides functionality
    to orchestrate, schedule, and manage containers.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当处理多个容器时，这在云原生系统中通常是情况，你需要管理这个复杂的系统。Kubernetes 提供了编排、调度和管理容器的功能。
- en: Kubernetes Pods are the minimum deployment units.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes Pods 是最小的部署单元。
- en: Kubernetes Deployments describe how to create application instances as Pods,
    starting from container images.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 部署描述了如何从容器镜像开始创建应用程序实例作为 Pods。
- en: Kubernetes Services allow you to expose application endpoints outside the cluster.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 服务允许你将应用程序端点暴露在集群外部。
- en: '* * *'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^(1.) A. Wiggins, “The Twelve-Factor App,” [https://12factor.net](https://12factor.net).
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: ^(1.) A. Wiggins, “十二要素应用*”，[https://12factor.net](https://12factor.net)。
- en: ^(2.) K. Hoffman, *Beyond the Twelve-Factor App* (O’Reilly, 2016).
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: ^(2.) K. Hoffman, 《超越十二要素应用*》（O’Reilly，2016年）。
