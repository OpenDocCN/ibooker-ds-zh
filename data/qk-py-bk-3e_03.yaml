- en: Chapter 3\. The Quick Python overview
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 3 章. 快速 Python 概览
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Surveying Python
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 概览 Python
- en: Using built-in data types
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内置数据类型
- en: Controlling program flow
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制程序流程
- en: Creating modules
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建模块
- en: Using object-oriented programming
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用面向对象编程
- en: The purpose of this chapter is to give you a basic feeling for the syntax, semantics,
    capabilities, and philosophy of the Python language. It has been designed to provide
    you an initial perspective or conceptual framework on which you’ll be able to
    add details as you encounter them in the rest of the book.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目的是让你对 Python 语言的语法、语义、功能和哲学有一个基本的认识。它被设计成为你提供一个初步的视角或概念框架，随着你在本书的其余部分遇到它们时，你将能够添加细节。
- en: On an initial read, you needn’t be concerned about working through and understanding
    the details of the code segments. You’ll be doing fine if you pick up a bit of
    an idea about what’s being done. The subsequent chapters walk you through the
    specifics of these features and don’t assume previous knowledge. You can always
    return to this chapter and work through the examples in the appropriate sections
    as a review after you’ve read the later chapters.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在初次阅读时，你不需要担心深入理解和处理代码段的具体细节。如果你对正在做的事情有一个大致的了解，你就能做得很好。后续章节将引导你了解这些特性的具体细节，并且不假设你有先前的知识。你可以在阅读了后续章节之后，回到本章并在适当的部分复习示例。
- en: 3.1\. Python synopsis
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1\. Python 概述
- en: Python has several built-in data types, such as integers, floats, complex numbers,
    strings, lists, tuples, dictionaries, and file objects. These data types can be
    manipulated using language operators, built-in functions, library functions, or
    a data type’s own methods.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有几个内置数据类型，如整数、浮点数、复数、字符串、列表、元组、字典和文件对象。这些数据类型可以通过语言运算符、内置函数、库函数或数据类型自己的方法进行操作。
- en: Programmers can also define their own classes and instantiate their own class
    instances.^([[1](#ch03fn01)]) These class instances can be manipulated by programmer-defined
    methods, as well as the language operators and built-in functions for which the
    programmer has defined the appropriate special method attributes.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员也可以定义自己的类并实例化自己的类实例.^([[1](#ch03fn01)]) 这些类实例可以通过程序员定义的方法进行操作，以及程序员为它们定义了适当特殊方法属性的编程语言运算符和内置函数。
- en: ¹
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The Python documentation and this book use the term object to refer to instances
    of any Python data type, not just what many other languages would call *class
    instances*. This is because all Python objects are instances of one class or another.
  id: totrans-14
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Python 文档和本书使用术语“对象”来指代任何 Python 数据类型的实例，而不仅仅是许多其他语言所说的 *类实例*。这是因为所有 Python
    对象都是某个类的实例。
- en: Python provides conditional and iterative control flow through an `if-elif-else`
    construct along with `while` and `for` loops. It allows function definition with
    flexible argument-passing options. Exceptions (errors) can be raised by using
    the `raise` statement, and they can be caught and handled by using the `try-except-else-finally`
    construct.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Python 通过 `if-elif-else` 构造以及 `while` 和 `for` 循环提供条件性和迭代性控制流。它允许以灵活的参数传递选项定义函数。可以通过使用
    `raise` 语句引发异常（错误），并且可以使用 `try-except-else-finally` 构造来捕获和处理它们。
- en: Variables (or identifiers) don’t have to be declared and can refer to any built-in
    data type, user-defined object, function, or module.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 变量（或标识符）不必声明，可以引用任何内置数据类型、用户定义对象、函数或模块。
- en: 3.2\. Built-in data types
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2\. 内置数据类型
- en: Python has several built-in data types, from scalars such as numbers and Booleans
    to more complex structures such as lists, dictionaries, and files.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有几个内置数据类型，从标量如数字和布尔值到更复杂的数据结构如列表、字典和文件。
- en: 3.2.1\. Numbers
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.1\. 数字
- en: 'Python’s four number types are integers, floats, complex numbers, and Booleans:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的四种数字类型是整数、浮点数、复数和布尔值：
- en: '*Integers*—1, –3, 42, 355, 888888888888888, –7777777777 (integers aren’t limited
    in size except by available memory)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*整数*—1, –3, 42, 355, 888888888888888, –7777777777（整数的大小除了受可用内存限制外没有限制）'
- en: '*Floats*—3.0, 31e12, –6e-4'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*浮点数*—3.0, 31e12, –6e-4'
- en: '*Complex numbers*—3 + 2j, –4- 2j, 4.2 + 6.3j'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*复数*—3 + 2j, –4- 2j, 4.2 + 6.3j'
- en: '*Booleans*—True, False'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*布尔值*—True, False'
- en: 'You can manipulate them by using the arithmetic operators: + (addition), `–`
    (subtraction), `*` (multiplication), `/` (division), `**` (exponentiation), and
    `%` (modulus).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用算术运算符来操作它们：+（加法）、`–`（减法）、`*`（乘法）、`/`（除法）、`**`（指数）和 `%`（取模）。
- en: 'The following examples use integers:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用整数：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Division of integers with `/` ***1*** results in a float (new in Python 3.x),
    and division of integers with `//` ***2*** results in truncation. Note that integers
    are of unlimited size ***3***; they grow as large as you need them to, limited
    only by the memory available.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 整数除法使用`/` ***1*** 进行，结果为浮点数（Python 3.x中的新特性），而整数除法使用`//` ***2*** 进行截断。请注意，整数的大小是无限的
    ***3***；它们会根据需要增长，仅受可用内存的限制。
- en: 'These examples work with floats, which are based on the doubles in C:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例使用浮点数，这些浮点数基于C中的双精度数：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'These examples use complex numbers:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例使用复数：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Complex numbers consist of both a real element and an imaginary element, suffixed
    with `j`. In the preceding code, variable `x` is assigned to a complex number
    ***1***. You can obtain its “real” part by using the attribute notation `x.real`
    and obtain the “imaginary” part with `x.imag`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 复数由一个实数元素和一个虚数元素组成，后缀为`j`。在前面代码中，变量`x`被赋值为一个复数 ***1***。您可以使用属性符号`x.real`获取其实部，使用`x.imag`获取其虚部。
- en: 'Several built-in functions can operate on numbers. There are also the library
    module `cmath` (which contains functions for complex numbers) and the library
    module `math` (which contains functions for the other three types):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 几个内置函数可以操作数字。还有库模块`cmath`（包含复数函数）和库模块`math`（包含其他三种类型的函数）：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Built-in functions are always available and are called by using a standard function-calling
    syntax. In the preceding code, `round` is called with a float as its input argument
    ***1***.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 内置函数始终可用，并且通过使用标准函数调用语法来调用。在前面代码中，`round`函数使用浮点数作为其输入参数 ***1*** 被调用。
- en: 'The functions in library modules are made available via the `import` statement.
    At ***2***, the `math` library module is imported, and its `ceil` function is
    called using attribute notation: *`module.function`*`(`*`arguments`*`)`.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 库模块中的函数通过`import`语句提供。在**2**处，导入了`math`库模块，并使用属性符号调用其`ceil`函数：*`module.function`*`(`*`arguments`*`)`。
- en: 'The following examples use Booleans:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用布尔值：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Other than their representation as `True` and `False`, Booleans behave like
    the numbers 1 (True) and 0 (False) ***1***.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 除了表示为`True`和`False`之外，布尔值的行为类似于数字1（True）和0（False） ***1***。
- en: 3.2.2\. Lists
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.2\. 列表
- en: 'Python has a powerful built-in list type:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Python有一个强大的内置列表类型：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: A list can contain a mixture of other types as its elements, including strings,
    tuples, lists, dictionaries, functions, file objects, and any type of number ***1***.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 列表可以包含其他类型的元素，包括字符串、元组、列表、字典、函数、文件对象以及任何类型的数字 ***1***。
- en: 'A list can be indexed from its front or back. You can also refer to a subsegment,
    or *slice*, of a list by using slice notation:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 列表可以从其前端或后端进行索引。您还可以通过使用切片符号来引用列表的子段，或*切片*：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Index from the front ***1*** using positive indices (starting with 0 as the
    first element). Index from the back ***2*** using negative indices (starting with
    -1 as the last element). Obtain a slice using `[m:n]` ***3***, where `m` is the
    inclusive starting point and `n` is the exclusive ending point (see [table 3.1](#ch03table01)).
    An `[:n]` slice ***4*** starts at its beginning, and an `[m:]` slice goes to a
    list’s end.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用正索引从前端 ***1*** 索引（从0开始作为第一个元素）。使用负索引从后端 ***2*** 索引（从-1开始作为最后一个元素）。使用`[m:n]`
    ***3*** 获取切片，其中`m`是包含的起始点，`n`是不包含的结束点（见[表3.1](#ch03table01)）。`[:n]`切片 ***4***
    从其开始处开始，而`[m:]`切片延伸到列表的末尾。
- en: Table 3.1\. List indices
  id: totrans-48
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表3.1\. 列表索引
- en: '| x= | [ | "first" , | "second" , | "third" , | "fourth" | ] |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| x= | [ | "first" , | "second" , | "third" , | "fourth" | ] |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| Positive indices |   | 0 | 1 | 2 | 3 |   |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 正索引 |   | 0 | 1 | 2 | 3 |   |'
- en: '| Negative indices |   | –4 | –3 | –2 | –1 |   |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 负索引 |   | –4 | –3 | –2 | –1 |   |'
- en: 'You can use this notation to add, remove, and replace elements in a list or
    to obtain an element or a new list that’s a slice from it:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用此符号在列表中添加、删除和替换元素，或者从中获取元素或新的列表切片：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The size of the list increases or decreases if the new slice is bigger or smaller
    than the slice it’s replacing ***1***.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果新切片比替换的切片大或小，则列表的大小会增加或减少 ***1***。
- en: 'Some built-in functions (`len`, `max`, and `min`), some operators (`in`, `+`,
    and `*`), the `del` statement, and the list methods (`append`, `count`, `extend`,
    `index`, `insert`, `pop`, `remove`, `reverse`, and `sort`) operate on lists:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一些内置函数（`len`、`max`和`min`）、一些运算符（`in`、`+`和`*`）、`del`语句以及列表方法（`append`、`count`、`extend`、`index`、`insert`、`pop`、`remove`、`reverse`和`sort`）作用于列表：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The operators `+` and `*` each create a new list, leaving the original unchanged
    ***1***. A list’s methods are called by using attribute notation on the list itself:
    `x.`*`method`* `(`*`arguments`*`)` ***2***.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符 `+` 和 `*` 各自创建一个新的列表，而不会改变原始列表 ***1***。通过在列表本身上使用属性表示法来调用列表的方法：`x.`*`method`*
    `(`*`arguments`*`)` ***2***。
- en: Some of these operations repeat functionality that can be performed with slice
    notation, but they improve code readability.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作中的一些与切片表示法可以执行的功能重复，但它们提高了代码的可读性。
- en: 3.2.3\. Tuples
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.3\. 元组
- en: '*Tuples* are similar to lists but are *immutable*—that is, they can’t be modified
    after they’ve been created. The operators (`in`, `+`, and `*`) and built-in functions
    (`len`, `max`, and `min`) operate on them the same way as they do on lists because
    none of them modifies the original. Index and slice notation work the same way
    for obtaining elements or slices but can’t be used to add, remove, or replace
    elements. Also, there are only two tuple methods: `count` and `index`. An important
    purpose of tuples is for use as keys for dictionaries. They’re also more efficient
    to use when you don’t need modifiability.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*元组* 与列表类似，但它们是不可变的——也就是说，一旦创建后就不能修改。运算符（`in`、`+` 和 `*`）和内置函数（`len`、`max` 和
    `min`）对它们的作用方式与对列表的作用方式相同，因为它们都不会修改原始数据。索引和切片表示法以相同的方式用于获取元素或切片，但不能用于添加、删除或替换元素。此外，元组只有两种方法：`count`
    和 `index`。元组的一个重要用途是作为字典的键。当不需要可修改性时，它们的使用效率更高。'
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: A one-element tuple ***1*** needs a comma. A tuple, like a list, can contain
    a mixture of other types as its elements, including strings, tuples, lists, dictionaries,
    functions, file objects, and any type of number ***2***.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一个单元素元组 ***1*** 需要一个逗号。与列表一样，元组可以包含其他类型的混合元素，包括字符串、元组、列表、字典、函数、文件对象以及任何类型的数字
    ***2***。
- en: 'A list can be converted to a tuple by using the built-in function `tuple`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用内置函数 `tuple` 将列表转换为元组：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Conversely, a tuple can be converted to a list by using the built-in function
    `list`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，可以使用内置函数 `list` 将元组转换为列表：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 3.2.4\. Strings
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.4\. 字符串
- en: 'String processing is one of Python’s strengths. There are many options for
    delimiting strings:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串处理是 Python 的一个优势。有许多选项可以用来分隔字符串：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Strings can be delimited by single (`' '`), double (`" "`), triple single (`'''
    '''`), or triple double (`""" """`) quotations and can contain tab (`\t`) and
    newline (`\n`) characters.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串可以用单引号（`' '`）、双引号（`" "`）、三单引号（`''' '''`）或三双引号（`""" """`）分隔，并且可以包含制表符（`\t`）和换行符（`\n`）字符。
- en: Strings are also immutable. The operators and functions that work with them
    return new strings derived from the original. The operators (`in`, `+`, and `*`)
    and built-in functions (`len`, `max`, and `min`) operate on strings as they do
    on lists and tuples. Index and slice notation works the same way for obtaining
    elements or slices but can’t be used to add, remove, or replace elements.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串也是不可变的。与它们一起工作的运算符和函数返回由原始字符串派生的新字符串。运算符（`in`、`+` 和 `*`）和内置函数（`len`、`max`
    和 `min`）对字符串的作用方式与对列表和元组的作用方式相同。索引和切片表示法以相同的方式用于获取元素或切片，但不能用于添加、删除或替换元素。
- en: 'Strings have several methods to work with their contents, and the `re` library
    module also contains functions for working with strings:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串有几个用于处理其内容的方法，`re` 库模块也包含用于处理字符串的函数：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `re` module ***1*** provides regular-expression functionality. It provides
    more sophisticated pattern extraction and replacement capabilities than the `string`
    module.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`re` 模块 ***1*** 提供正则表达式功能。它提供的模式提取和替换功能比 `string` 模块更复杂。'
- en: 'The `print` function outputs strings. Other Python data types can be easily
    converted to strings and formatted:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`print` 函数输出字符串。其他 Python 数据类型可以轻松转换为字符串并格式化：'
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Objects are automatically converted to string representations for printing ***1***.
    The `%` operator ***2*** provides formatting capability similar to that of C’s
    `sprintf`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对象在打印时会自动转换为字符串表示 ***1***。`%` 运算符 ***2*** 提供了类似于 C 的 `sprintf` 的格式化功能。
- en: 3.2.5\. Dictionaries
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.5\. 字典
- en: Python’s built-in dictionary data type provides associative array functionality
    implemented by using hash tables. The built-in `len` function returns the number
    of key-value pairs in a dictionary. The `del` statement can be used to delete
    a key-value pair. As is the case for lists, several dictionary methods (`clear`,
    `copy`, `get`, `items`, `keys`, `update`, and `values`) are available.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Python的内置字典数据类型通过使用哈希表实现了关联数组功能。内置的`len`函数返回字典中键值对的数量。`del`语句可以用来删除键值对。与列表类似，字典有几种方法（`clear`、`copy`、`get`、`items`、`keys`、`update`和`values`）可用。
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '***1* Sets the value of a new key, “first”, to “one”**'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 设置新键“first”的值为“one”**'
- en: Keys must be of an immutable type ***2***, including numbers, strings, and tuples.
    Values can be any kind of object, including mutable types such as lists and dictionaries.
    If you try to access the value of a key that isn’t in the dictionary, a `KeyError`
    exception is raised. To avoid this error, the dictionary method `get` ***3***
    optionally returns a user-definable value when a key isn’t in a dictionary.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是不可变类型 ***2***，包括数字、字符串和元组。值可以是任何类型的对象，包括列表和字典这样的可变类型。如果您尝试访问字典中不存在的键的值，将引发`KeyError`异常。为了避免这种错误，字典方法`get`
    ***3*** 在键不在字典中时可选地返回一个用户定义的值。
- en: 3.2.6\. Sets
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.6\. 集合
- en: 'A *set* in Python is an unordered collection of objects, used in situations
    where membership and uniqueness in the set are the main things you need to know
    about that object. Sets behave as collections of dictionary keys without any associated
    values:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的*集合*是无序的对象集合，用于需要了解对象在集合中的成员资格和唯一性的情况。集合的行为类似于没有关联值的字典键集合：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You can create a set by using `set` on a sequence, like a list ***1***. When
    a sequence is made into a set, duplicates are removed ***2***. The `in` keyword
    ***3*** is used to check for membership of an object in a set.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在序列上使用`set`来创建一个集合，例如列表 ***1***。当将序列转换为集合时，会移除重复项 ***2***。使用`in`关键字 ***3***
    来检查对象是否在集合中。
- en: 3.2.7\. File objects
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.7\. 文件对象
- en: 'A file is accessed through a Python file object:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Python文件对象访问文件：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `open` statement ***1*** creates a file object. Here, the file myfile in
    the current working directory is being opened in write (`"w"`) mode. After writing
    two lines to it and closing it ***2***, you open the same file again, this time
    in read (`"r"`) mode. The `os` module ***3*** provides several functions for moving
    around the filesystem and working with the pathnames of files and directories.
    Here, you move to another directory ***4***. But by referring to the file by an
    absolute pathname ***5***, you’re still able to access it.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`open`语句 ***1*** 创建一个文件对象。在这里，当前工作目录中的文件`myfile`以写入（`"w"`）模式打开。写入两行后关闭它 ***2***，然后再次以读取（`"r"`）模式打开相同的文件。`os`模块
    ***3*** 提供了用于在文件系统中移动和操作文件和目录路径名的多个函数。在这里，您移动到另一个目录 ***4***。但是，通过使用绝对路径名 ***5***
    来引用文件，您仍然可以访问它。'
- en: Several other input/output capabilities are available. You can use the built-in
    `input` function to prompt and obtain a string from the user. The `sys` library
    module allows access to `stdin`, `stdout`, and `stderr`. The `struct` library
    module provides support for reading and writing files that were generated by,
    or are to be used by, C programs. The Pickle library module delivers data persistence
    through the ability to easily read and write the Python data types to and from
    files.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他输入/输出功能可用。您可以使用内置的`input`函数提示并从用户那里获取字符串。`sys`库模块允许访问`stdin`、`stdout`和`stderr`。`struct`库模块提供了对由C程序生成或将要使用的文件的支持。Pickle库模块通过能够轻松地将Python数据类型读写到文件中，实现了数据持久性。
- en: 3.3\. Control flow structures
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3\. 控制流结构
- en: Python has a full range of structures to control code execution and program
    flow, including common branching and looping structures.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了一系列结构来控制代码执行和程序流程，包括常见的分支和循环结构。
- en: 3.3.1\. Boolean values and expressions
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.1\. 布尔值和表达式
- en: Python has several ways of expressing Boolean values; the Boolean constant `False`,
    `0`, the Python nil value `None`, and empty values (for example, the empty list
    `[]` or empty string `""`) are all taken as `False`. The Boolean constant `True`
    and everything else is considered `True`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Python有几种表示布尔值的方法；布尔常量`False`、`0`、Python的空值`None`以及空值（例如，空列表`[]`或空字符串`""`）都被视为`False`。布尔常量`True`和所有其他内容都被认为是`True`。
- en: You can create comparison expressions by using the comparison operators (`<`,
    `<=`, `==`, `>`, `>=`, `!=`, `is`, `is not`, `in`, `not in`) and the logical operators
    (`and`, `not`, `or`), which all return `True` or `False`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用比较运算符（`<`, `<=`, `==`, `>`, `>=`, `!=`, `is`, `is not`, `in`, `not in`）和逻辑运算符（`and`,
    `not`, `or`）来创建比较表达式，这些运算符都返回`True`或`False`。
- en: 3.3.2\. The if-elif-else statement
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.2\. if-elif-else语句
- en: 'The block of code after the first `True` condition (of an `if` or an `elif`)
    is executed. If none of the conditions is `True,` the block of code after the
    `else` is executed:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个`True`条件（`if`或`elif`）之后的代码块被执行。如果没有条件为`True`，则执行`else`之后的代码块：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `elif` and `else` clauses are optional ***1***, and there can be any number
    of `elif` clauses. Python uses indentation to delimit blocks ***2***. No explicit
    delimiters, such as brackets or braces, are necessary. Each block consists of
    one or more statements separated by newlines. All these statements must be at
    the same level of indentation. The output in the example would be `5 0 10.`
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`elif`和`else`子句是可选的 ***1***，可以有任意数量的`elif`子句。Python使用缩进来界定代码块 ***2***。不需要显式的界定符，如括号或花括号。每个代码块由一个或多个通过换行符分隔的语句组成。所有这些语句必须在相同的缩进级别。示例中的输出将是`5
    0 10.`。'
- en: 3.3.3\. The while loop
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.3\. 循环语句
- en: 'The `while` loop is executed as long as the condition (which here is `x > y`)
    is `True`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当条件（这里为`x > y`）为`True`时，执行`while`循环：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is a shorthand notation. Here, `u` and `v` are assigned a value of 0, `x`
    is set to 100, and `y` obtains a value of 30 ***1***. This is the loop block ***2***.
    It’s possible for a loop to contain `break` (which ends the loop) and `continue`
    statements (which abort the current iteration of the loop). The output would be
    `60 40.`
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简写符号。在这里，`u`和`v`被赋予0的值，`x`被设置为100，`y`获得30的值 ***1***。这是循环块 ***2***。循环中可以包含`break`（结束循环）和`continue`语句（终止当前循环迭代）。输出将是`60
    40.`。
- en: 3.3.4\. The for loop
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.4\. for循环
- en: 'The `for` loop is simple but powerful because it’s possible to iterate over
    any iterable type, such as a list or tuple. Unlike in many languages, Python’s
    `for` loop iterates over each of the items in a sequence (for example, a list
    or tuple), making it more of a `foreach` loop. The following loop finds the first
    occurrence of an integer that’s divisible by 7:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环简单但强大，因为它可以遍历任何可迭代类型，如列表或元组。与许多语言不同，Python的`for`循环遍历序列中的每个项目（例如，列表或元组），使其更像是一个`foreach`循环。以下循环查找第一个能被7整除的整数：'
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`x` is sequentially assigned each value in the list ***1***. If `x` isn’t an
    integer, the rest of this iteration is aborted by the `continue` statement ***2***.
    Flow control continues with `x` set to the next item from the list. After the
    first appropriate integer is found, the loop is ended by the `break` statement
    ***3***. The output would be'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`x`按顺序被分配列表中的每个值 ***1***。如果`x`不是整数，则通过`continue`语句终止这次迭代的其余部分 ***2***。控制流继续，`x`设置为列表的下一个项目。在找到第一个合适的整数后，通过`break`语句结束循环
    ***3***。输出将是'
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 3.3.5\. Function definition
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.5\. 函数定义
- en: 'Python provides flexible mechanisms for passing arguments to functions:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了灵活的机制来传递参数给函数：
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Functions are defined by using the `def` statement ***1***. The `return` statement
    ***2*** is what a function uses to return a value. This value can be of any type.
    If no `return` statement is encountered, Python’s `None` value is returned. Function
    arguments can be entered either by position or by name (keyword). Here, `z` and
    `y` are entered by name ***3***. Function parameters can be defined with defaults
    that are used if a function call leaves them out ***4***. A special parameter
    can be defined that collects all extra positional arguments in a function call
    into a tuple ***5***. Likewise, a special parameter can be defined that collects
    all extra keyword arguments in a function call into a dictionary ***6***.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 函数通过使用`def`语句定义 ***1***。`return`语句 ***2*** 是函数用来返回值的方式。这个值可以是任何类型。如果没有遇到`return`语句，Python将返回`None`值。函数参数可以通过位置或名称（关键字）输入。在这里，`z`和`y`是通过名称
    ***3*** 输入的。函数参数可以定义默认值，如果函数调用省略了它们，则使用这些默认值 ***4***。可以定义一个特殊参数，它将函数调用中所有额外的位置参数收集到一个元组中
    ***5***。同样，可以定义一个特殊参数，它将函数调用中所有额外的关键字参数收集到一个字典中 ***6***。
- en: 3.3.6\. Exceptions
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.6\. 异常
- en: Exceptions (errors) can be caught and handled by using the `try-except-else-finally`
    compound statement. This statement can also catch and handle exceptions you define
    and raise yourself. Any exception that isn’t caught causes the program to exit.
    This listing shows basic exception handling.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `try-except-else-finally` 复合语句捕获和处理异常（错误）。此语句还可以捕获和处理你自己定义和引发的异常。任何未被捕获的异常都会导致程序退出。此列表展示了基本的异常处理。
- en: Listing 3.1\. File exception.py
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.1\. 文件 exception.py
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, you define your own exception type inheriting from the base `Exception`
    type ***1***. If an `IOError` or `EmptyFileError` occurs during the execution
    of the statements in the `try` block, the associated `except` block is executed
    ***2***. This is where an `IOError` might be raised ***3***. Here, you raise the
    `EmptyFileError` ***4***. The `else` clause is optional ***5***; it’s executed
    if no exception occurs in the `try` block. (Note that in this example, `continue`
    statements in the `except` blocks could have been used instead.) The `finally`
    clause is optional ***6***; it’s executed at the end of the block whether an exception
    was raised or not.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你定义自己的异常类型，继承自基类 `Exception` 类型 ***1***。如果在 `try` 块中的语句执行期间发生 `IOError`
    或 `EmptyFileError`，则执行相关的 `except` 块 ***2***。这就是可能引发 `IOError` 的地方 ***3***。在这里，你引发
    `EmptyFileError` ***4***。`else` 子句是可选的 ***5***；如果没有在 `try` 块中发生异常，则执行它。（注意，在这个例子中，`except`
    块中可以使用 `continue` 语句代替。）`finally` 子句是可选的 ***6***；无论是否引发异常，它都在块的末尾执行。
- en: 3.3.7\. Context handling using the with keyword
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.7\. 使用 with 关键字进行上下文处理
- en: A more streamlined way of encapsulating the `try-except-finally` pattern is
    to use the `with` keyword and a context manager. Python defines context managers
    for things like file access, and it’s possible for the developer to define custom
    context managers. One benefit of context managers is that they may (and usually
    do) have default clean-up actions defined, which always execute whether or not
    an exception occurs.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `with` 关键字和上下文管理器封装 `try-except-finally` 模式的一种更简洁的方法。Python 为文件访问等事物定义了上下文管理器，并且开发者可以定义自定义上下文管理器。上下文管理器的一个好处是它们可能（并且通常确实）定义了默认的清理操作，无论是否发生异常，这些操作都会执行。
- en: This listing shows opening and reading a file by using `with` and a context
    manager.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表展示了使用 `with` 和上下文管理器打开和读取文件。
- en: Listing 3.2\. File with.py
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.2\. 文件 with.py
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here, `with` establishes a context manager which wraps the `open` function
    and the block that follows. In this case, the context manager’s predefined clean-up
    action closes the file, even if an exception occurs, so as long as the expression
    in the first line executes without raising an exception, the file is always closed.
    That code is equivalent to this code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`with` 建立了一个上下文管理器，它包装了 `open` 函数和随后的代码块。在这种情况下，上下文管理器的预定义清理操作会关闭文件，即使发生异常也是如此，因此只要第一行的表达式执行时没有引发异常，文件总是会关闭。这段代码等同于以下代码：
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 3.4\. Module creation
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4\. 模块创建
- en: It’s easy to create your own modules, which can be imported and used in the
    same way as Python’s built-in library modules. The example in this listing is
    a simple module with one function that prompts the user to enter a filename and
    determines the number of times that words occur in this file.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自己的模块很容易，这些模块可以像 Python 的内置库模块一样导入和使用。此列表中的示例是一个简单的模块，其中包含一个函数，提示用户输入文件名，并确定该文件中单词出现的次数。
- en: Listing 3.3\. File wo.py
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.3\. 文件 wo.py
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Documentation strings, or *docstrings*, are standard ways of documenting modules,
    functions, methods, and classes ***1***. Comments are anything beginning with
    a # character ***2***. `read` returns a string containing all the characters in
    a file ***3***, and `split` returns a list of the words of a string “split out”
    based on whitespace. You can use a `\` to break a long statement across multiple
    lines ***4***. This `if` statement allows the program to be run as a script by
    typing `python wo.py` at a command line ***5***.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '文档字符串，或称为 *docstrings*，是记录模块、函数、方法和类的标准方式 ***1***。注释是以 # 字符开头的任何内容 ***2***。`read`
    返回一个包含文件中所有字符的字符串 ***3***，而 `split` 返回一个列表，其中包含基于空白分隔的字符串中的单词。你可以使用 `\` 在多行中拆分长语句
    ***4***。此 `if` 语句允许程序作为脚本运行，通过在命令行中键入 `python wo.py` 来执行 ***5***。'
- en: 'If you place a file in one of the directories on the module search path, which
    can be found in `sys.path`, it can be imported like any of the built-in library
    modules by using the `import` statement:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将文件放置在模块搜索路径上的某个目录中，该路径可以在 `sys.path` 中找到，它可以通过使用 `import` 语句像任何内置库模块一样导入：
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This function is called ***1*** by using the same attribute syntax used for
    library module functions.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是通过使用与库模块函数相同的属性语法调用的 ***1***。
- en: 'Note that if you change the file wo.py on disk, `import` won’t bring your changes
    into the same interactive session. You use the `reload` function from the `imp`
    library in this situation:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你更改磁盘上的 wo.py 文件，`import` 不会将你的更改引入相同的交互会话。在这种情况下，你使用 `imp` 库中的 `reload`
    函数：
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: For larger projects, there is a generalization of the module concept called
    *packages*, which allows you to easily group modules in a directory or directory
    subtree and then import and hierarchically refer to them by using a *`package.subpackage.module`*
    syntax. This entails little more than creating a possibly empty initialization
    file for each package or subpackage.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更大的项目，有一个模块概念的泛化称为 *包*，它允许你轻松地将模块分组在目录或目录子树中，然后使用 *`package.subpackage.module`*
    语法导入和分层引用它们。这仅仅意味着为每个包或子包创建一个可能为空的初始化文件。
- en: 3.5\. Object-oriented programming
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5\. 面向对象编程
- en: Python provides full support for OOP. [Listing 3.4](#ch03ex04) is an example
    that might be the start of a simple shapes module for a drawing program. It’s
    intended mainly to serve as a reference if you’re already familiar with OOP. The
    callout notes relate Python’s syntax and semantics to the standard features found
    in other languages.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Python 完全支持面向对象编程（OOP）。[列表 3.4](#ch03ex04) 是一个示例，可能是绘图程序中简单形状模块的起点。它主要用作参考，如果你已经熟悉
    OOP。调用注释将 Python 的语法和语义与在其他语言中找到的标准功能联系起来。
- en: Listing 3.4\. File sh.py
  id: totrans-140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[列表 3.4\. 文件 sh.py]'
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Classes are defined by using the `class` keyword ***1***. The instance initializer
    method (constructor) for a class is always called `__init__` ***2***. Instance
    variables `x` and `y` are created and initialized here ***3***. Methods, like
    functions, are defined by using the `def` keyword ***4***. The first argument
    of any method is by convention called `self`. When the method is invoked, `self`
    is set to the instance that invoked the method. Class `Circle` inherits from class
    `Shape` ***5*** and is similar to, but not exactly like, a standard class variable
    ***6***. A class must, in its initializer, explicitly call the initializer of
    its base class ***7***. The `__str__` method is used by the `print` function ***8***.
    Other special method attributes permit operator overloading or are employed by
    built-in methods such as the length (`len`) function.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 类是通过使用 `class` 关键字定义的 ***1***。类的实例初始化方法（构造函数）始终称为 `__init__` ***2***。在这里创建了实例变量
    `x` 和 `y` 并进行了初始化 ***3***。与函数一样，方法是通过使用 `def` 关键字定义的 ***4***。任何方法的第一个参数按照惯例称为
    `self`。当方法被调用时，`self` 被设置为调用该方法的实例。类 `Circle` 从类 `Shape` 继承 ***5***，与标准类变量相似，但并不完全相同。一个类必须在它的初始化器中显式地调用其基类的初始化器
    ***7***。`__str__` 方法被 `print` 函数使用 ***8***。其他特殊方法属性允许操作符重载，或被内置方法（如长度函数 `len`）使用。
- en: 'Importing this file makes these classes available:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 导入此文件使这些类可用：
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The initializer is implicitly called, and a circle instance is created ***1***.
    The `print` function implicitly uses the special `__str__` method ***2***. Here,
    you see that the `move` method of `Circle`’s parent class `Shape` is available
    ***3***. A method is called by using attribute syntax on the object instance:
    `object.method()`. The first (`self`) parameter is set implicitly.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化器被隐式调用，并创建了一个圆实例 ***1***。`print` 函数隐式地使用了特殊的 `__str__` 方法 ***2***。在这里，你可以看到
    `Circle` 的父类 `Shape` 的 `move` 方法是可用的 ***3***。通过在对象实例上使用属性语法调用方法：`object.method()`。任何方法的第一（`self`）参数都是隐式设置的。
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter is a rapid and very high-level overview of Python; the following
    chapters provide more detail. This chapter ends the book’s overview of Python.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章对 Python 进行了快速且非常高级的概述；接下来的章节将提供更多细节。本章结束了本书对 Python 的概述。
- en: You may find it valuable to return to this chapter and work through the appropriate
    examples as a review after you read about the features covered in subsequent chapters.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你在阅读了后续章节中介绍的功能后，可能会发现回顾本章并适当练习示例是有价值的。
- en: If this chapter was mostly a review for you, or if you’d like to learn more
    about only a few features, feel free to jump around, using the index or table
    of contents.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果本章对你来说主要是复习，或者如果你想只了解几个功能，请随意跳转，使用索引或目录。
- en: You should have a solid understanding of the Python features in this chapter
    before skipping ahead to [part 4](kindle_split_032.html#part04).
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在跳转到 [第 4 部分](kindle_split_032.html#part04) 之前，你应该对本章中介绍的 Python 功能有一个扎实的理解。
