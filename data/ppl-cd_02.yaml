- en: 1 What’s CI/CD?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1 什么是 CI/CD？
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: The path organizations have taken to evolve from monolith to cloud-native applications
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织从单体应用向云原生应用演变的路径
- en: The challenges of implementing CI/CD practices for cloud-native architectures
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施 CI/CD 实践对云原生架构的挑战
- en: An overview of continuous integration, deployment, and delivery
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续集成、部署和交付概述
- en: How CI/CD tools like Jenkins can bring business value to organizations that
    undertake the journey of continuous everything
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过像 Jenkins 这样的 CI/CD 工具为进行持续一切旅程的组织带来商业价值
- en: 'Software development and operations have experienced several paradigm shifts
    recently. These shifts have presented the industry with innovative approaches
    for building and deploying applications. More importantly, two significant paradigm
    shifts have consolidated capabilities for developing, deploying, and managing
    scalable applications: cloud-native architecture and DevOps.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发和运维最近经历了几次范式转变。这些转变为行业提供了构建和部署应用的创新方法。更重要的是，两次重大的范式转变巩固了开发、部署和管理可扩展应用的能力：云原生架构和
    DevOps。
- en: '*Cloud-native architecture* emerged with cloud adoption, with cloud providers
    like Amazon Web Services (AWS), Google Cloud Platform (GCP), and Microsoft Azure
    taking ownership of the infrastructure. Open source tools like Kubernetes, Docker,
    and Istio offer horizontal scaling ability, letting developers build and run modern
    scalable applications without worrying about the underlying infrastructure. As
    a result, operational overhead is reduced, and the development velocity of applications
    is increased.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*云原生架构* 随着云的采用而出现，云服务提供商如亚马逊网络服务（AWS）、谷歌云平台（GCP）和微软 Azure 拥有基础设施的所有权。开源工具如
    Kubernetes、Docker 和 Istio 提供了横向扩展能力，让开发者能够构建和运行现代可扩展应用，无需担心底层基础设施。因此，运营开销降低，应用的开发速度提高。'
- en: '*DevOps* bridged the divide between developers and ops teams, and brought back
    harmony through collaboration, automated tools, and iterative and Agile development
    and deployment.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*DevOps* 桥梁了开发者和运维团队之间的鸿沟，通过协作、自动化工具以及迭代和敏捷开发和部署恢复了和谐。'
- en: 'With these two significant, powerful approaches combined, organizations now
    have the capability to create scalable, robust, and reliable applications with
    a high level of collaboration and information sharing among small teams. However,
    to build, test, and safely deploy cloud-native applications, two essential DevOps
    practices must be implemented in a cloud-native manner: continuous integration
    (CI) and continuous deployment/delivery (CD).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 结合这两种重大且强大的方法，组织现在有能力创建具有高度团队协作和信息共享的、可扩展、稳健和可靠的应用程序。然而，为了构建、测试和安全地部署云原生应用，必须在云原生方式下实施两个基本的
    DevOps 实践：持续集成（CI）和持续部署/交付（CD）。
- en: The first part of this book takes you through the evolution of cloud-native
    applications. You’ll learn about the main principles of CI/CD and how automation
    invented the way those principles are implemented through the *pipeline-as-code*
    approach. This first chapter lays the foundation. It introduces basic principles
    of DevOps and cloud-native approaches, in addition to selecting the tools for
    implementing CI/CD pipelines.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的第一部分将带您了解云原生应用的演变。您将了解 CI/CD 的主要原则以及自动化如何通过 *代码即管道* 方法实现这些原则。本章奠定了基础。它介绍了
    DevOps 和云原生方法的基本原则，以及选择用于实现 CI/CD 管道的工具。
- en: 1.1 Going cloud native
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1 走向云原生
- en: Before exploring the essential characteristics of cloud-native applications
    and how CI/CD practices contribute to standardizing feedback loops for developers
    and enabling fast product iterations, we will cover the changes the software development
    model went through and the challenges associated with each model, starting with
    the monolithic approach.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索云原生应用的基本特性和 CI/CD 实践如何有助于为开发者标准化反馈循环以及实现快速产品迭代之前，我们将介绍软件开发模型所经历的变革以及每个模型所面临的挑战，从单体方法开始。
- en: 1.1.1 Monolithic
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.1 单体
- en: 'In the past, organizations used to build their software in a *monolithic* way:
    all functionalities were packaged in a single artifact and deployed in a single
    server running one process. This architecture comes with many drawbacks and limitations:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，组织通常以 *单体* 方式构建他们的软件：所有功能都打包在一个单一的项目中，并在运行一个进程的单个服务器上部署。这种架构存在许多缺点和限制：
- en: '*Development velocity*—Adding new features on top of an existing application
    is next to impossible. Application modules are tightly coupled and, most of the
    time, not documented. As a result, adding new features is often slow, expensive,
    and requires extra synchronization when working with multiple developers within
    distributed teams on a large codebase. Moreover, the release cycle can take months,
    if not several years, because of the application’s large codebase. This delay
    puts companies at risk of being surpassed by new competitors and ultimately undercuts
    the company’s profits.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开发速度*—在现有应用程序上添加新功能几乎是不可能的。应用程序模块紧密耦合，并且大多数情况下没有文档。因此，添加新功能通常很慢、成本高昂，并且在与分布式团队中的多个开发者合作时，在大型代码库上工作需要额外的同步。此外，由于应用程序的大型代码库，发布周期可能需要数月甚至数年。这种延迟使公司面临被新竞争对手超越的风险，并最终损害公司的利润。'
- en: '*Maintainability*—Modules in a monolithic architecture are frequently tightly
    coupled, which makes them hard to maintain and test. Plus, upgrading to new technology
    is limited to the framework used to develop the application (no polyglot programming).'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可维护性*—单体架构中的模块通常紧密耦合，这使得它们难以维护和测试。此外，升级到新技术仅限于用于开发应用程序的框架（没有多语言编程）。'
- en: '*Scaling and resiliency*—Applications are designed with no scalability in mind,
    and the application may face downtime if traffic increases. The monolithic application
    works as a single unit and is developed in a single programming language using
    a single tech stack. As a result, to achieve partial horizontal scaling, the whole
    application needs to be scaled (inefficient usage of server resources).'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可扩展性和弹性*—应用程序在设计时没有考虑到可扩展性，如果流量增加，应用程序可能会面临停机。单体应用程序作为一个单一单元运行，并使用单一编程语言和单一技术栈进行开发。因此，为了实现部分水平扩展，整个应用程序都需要进行扩展（服务器资源的低效使用）。'
- en: '*Cost-effectiveness*—The application is expensive to maintain in the long run
    (for example, finding an experienced COBOL developer is time-consuming and expensive).'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*成本效益*—从长远来看，应用程序的维护成本很高（例如，寻找经验丰富的COBOL开发者既耗时又昂贵）。'
- en: In the late 2000s, many web giants (including Facebook, Netflix, Twitter, and
    Amazon) came onto the tech scene with innovative ideas, aggressive strategies,
    and a “move fast” approach that led to the exponential growth of their platforms.
    These companies introduced a new architecture pattern that is known today as *microservices*.
    So, what exactly is microservices architecture?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在2000年代后期，许多网络巨头（包括Facebook、Netflix、Twitter和Amazon）带着创新的想法、积极的策略和“快速行动”的方法进入科技界，这导致了他们平台的指数级增长。这些公司引入了一种新的架构模式，今天被称为*微服务*。那么，微服务架构究竟是什么呢？
- en: 1.1.2 Microservices
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.2 微服务
- en: 'James Lewis and Martin Fowler defined microservices architecture as follows
    in 2014:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: James Lewis和Martin Fowler在2014年如下定义了微服务架构：
- en: '*In short, the microservice architectural style is an approach to developing
    a single application as a suite of small services, each running in its own process
    and communicating with lightweight mechanisms, often an HTTP resource API. These
    services are built around business capabilities and independently deployable by
    fully automated deployment machinery. There is a bare minimum of centralized management
    of these services, which may be written in different programming languages and
    use different data storage technologies*.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*简而言之，微服务架构是将单个应用程序作为一系列小型服务集来开发的方法，每个服务都在自己的进程中运行，并通过轻量级机制（通常是HTTP资源API）进行通信。这些服务围绕业务能力构建，并且可以由完全自动化的部署机器独立部署。对这些服务的集中式管理最少，这些服务可能使用不同的编程语言，并使用不同的数据存储技术*。'
- en: This architecture uses the same technique of “divide and conquer” to tackle
    the complexity of an application. An application is split into smaller, independent,
    and composable services/fragments, each responsible for a specific functionality
    or task of the application (organized around business capabilities).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构使用“分而治之”的相同技术来解决应用程序的复杂性。应用程序被分割成更小、独立且可组合的服务/片段，每个服务负责应用程序的特定功能或任务（围绕业务能力组织）。
- en: Those microservices communicate using an application programming interface (API),
    typically over HTTP or HTTP/2 (for example, gRPC, RESTful APIs, Google Protocol
    Buffers, or Apache Thrift), or through message brokers (such as Apache ActiveMQ
    or Kafka). Each microservice can be implemented in a different programming language
    running on a different OS platform.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这些微服务通过应用程序编程接口（API）进行通信，通常是通过HTTP或HTTP/2（例如gRPC、RESTful API、Google Protocol
    Buffers或Apache Thrift），或者通过消息代理（如Apache ActiveMQ或Kafka）。每个微服务都可以在不同的编程语言和不同的操作系统平台上实现。
- en: In contrast to microservices, the monolithic architecture means the code’s components
    are designed to work together as one cohesive unit, sharing the same server resources
    (memory, CPU, disk, and so forth). Figure 1.1 illustrates the differences between
    monolith and microservices architectures.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 与微服务架构相比，单体架构意味着代码的组件被设计成作为一个统一的整体协同工作，共享相同的服务器资源（内存、CPU、磁盘等）。图1.1展示了单体架构与微服务架构之间的差异。
- en: '![](Images/CH01_F01_Labouardy.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH01_F01_Labouardy.png)'
- en: Figure 1.1 Comparing monolith and microservices architectures
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 比较单体架构与微服务架构
- en: 'Microservices architecture is an extension of *service-oriented architecture*
    (SOA). Both architectures rely on services as the main component, but they vary
    greatly in terms of service characteristics:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构是*面向服务架构*（SOA）的扩展。这两种架构都依赖于服务作为主要组件，但在服务特性方面存在很大差异：
- en: '*Granularity*—Service components within a microservices architecture are generally
    single-purpose services that do one thing. In SOA, service components can range
    in size, anywhere from small application services to very large enterprise services.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*粒度*——微服务架构中的服务组件通常是单一用途的服务，只做一件事。在SOA中，服务组件的大小可以从小的应用服务到非常大的企业服务不等。'
- en: '*Sharing*—SOA enhances component sharing, whereas microservices architecture
    tries to minimize sharing through bounded context (loosely coupled services or
    modules) with minimal dependencies.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*共享*——SOA增强了组件共享，而微服务架构试图通过边界上下文（松散耦合的服务或模块）和最小依赖来最小化共享。'
- en: '*Communication*—Microservices rely on lightweight protocols such as HTTP/REST
    and simple messaging, while SOA architectures rely on enterprise service bus (ESB)
    for communication; early versions of SOA used object-oriented protocols to communicate
    with each other, such as Distributed Component Object Model (DCOM) and object
    request brokers (ORBs). Later versions used messaging services such as Java Message
    Service (JMS) or Advanced Message Queuing Protocol (AMQP).'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通信*——微服务依赖于轻量级协议，如HTTP/REST和简单消息传递，而SOA架构依赖于企业服务总线（ESB）进行通信；SOA的早期版本使用面向对象的协议进行通信，例如分布式组件对象模型（DCOM）和对象请求代理（ORBs）。后期版本则使用消息服务，如Java消息服务（JMS）或高级消息队列协议（AMQP）。'
- en: '*Deployment*—SOA services are deployed to application servers (IBM WebSphere
    Application Server, WildFly, Apache Tomcat) and virtual machines. On the other
    hand, microservices are deployed in containers. This makes microservices more
    flexible and lighter than SOA.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*部署*——SOA服务部署到应用服务器（如IBM WebSphere Application Server、WildFly、Apache Tomcat）和虚拟机。另一方面，微服务部署在容器中。这使得微服务比SOA更加灵活和轻量。'
- en: Note For more details about microservices architecture, I recommend reading
    *Microservices in Action* by Morgan Bruce and Paulo A. Perreira (Manning, 2018).
    It covers what makes a microservice, how it can be composed by an individual or
    a dedicated team, the constant back-and-forth comparison between a monolithic
    application, and things to consider when deploying your microservices.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：关于微服务架构的更多细节，我推荐阅读Morgan Bruce和Paulo A. Perreira合著的《Microservices in Action》（Manning，2018）。它涵盖了微服务的定义，以及个人或专业团队如何对其进行组合，单体应用与微服务之间的持续比较，以及部署微服务时需要考虑的事项。
- en: 'The advantages of microservices convinced some big enterprise players such
    as Amazon, Netflix, and Uber to adopt the methodology. Following their footsteps,
    other companies are working in the same direction: evolving from monolithic to
    flexible microservice-based architecture.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务的优势说服了一些大型企业玩家，如亚马逊、Netflix和Uber，采用这种方法。跟随他们的脚步，其他公司也在同一方向努力：从单体架构向灵活的基于微服务的架构演变。
- en: 'But what makes it so special? Compared to more monolithic design structures,
    microservices architecture comes with the following benefits:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 但是什么让它如此特别呢？与更传统的单体设计结构相比，微服务架构具有以下优势：
- en: '*Scalability*—Applications built as microservices can be broken into multiple
    components so that each component can be deployed and scaled independently without
    service interruption. Also, for stateless microservices, usage of Docker or Kubernetes
    can offer horizontal scaling within seconds.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可伸缩性*—作为微服务构建的应用程序可以被分解成多个组件，这样每个组件都可以独立部署和扩展，而不会中断服务。对于无状态的微服务，使用Docker或Kubernetes可以在几秒钟内提供水平扩展。'
- en: '*Fault tolerance*—If one microservice fails, the others will continue to work
    because of loosely coupled components. A single microservice can be easily replaced
    by a new one without affecting the whole system. As a result, modernization in
    microservices architecture can be incremental, while modernization in monolithic
    architecture can cause service outages.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*容错性*—如果一个微服务失败，由于组件松散耦合，其他微服务将继续工作。单个微服务可以很容易地被新的一个所替代，而不会影响整个系统。因此，微服务架构的现代化可以逐步进行，而单体架构的现代化可能会导致服务中断。'
- en: '*Development velocity*—Microservices can be written in different languages
    (polyglot programming) and use different databases or OS environments. If one
    microservice is, for example, CPU intensive, it could be implemented in highly
    productive languages such as Golang or C++, while other components could be implemented
    in lightweight programming languages such as JavaScript or Python. So companies
    can easily hire more developers and scale development. Also, because microservices
    are autonomous, developers have the freedom to independently develop and deploy
    services without bumping into each other’s code (avoiding synchronization hell
    within the organization) and having to wait for one team to finish a chunk of
    work before starting theirs. As a result, team productivity increases, and vendor
    or technology stack lock-in reduces.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开发速度*—微服务可以用不同的语言（多语言编程）编写，并使用不同的数据库或操作系统环境。例如，如果一个微服务是CPU密集型的，它可以由像Golang或C++这样高度生产力的语言实现，而其他组件可以由像JavaScript或Python这样的轻量级编程语言实现。因此，公司可以轻松地雇佣更多的开发者并扩展开发。此外，由于微服务是自治的，开发者可以独立开发和部署服务，而不会相互干扰代码（避免组织内部的同步地狱），也不必等待一个团队完成其工作后再开始自己的工作。结果，团队的生产力提高，供应商或技术堆栈锁定减少。'
- en: '*Continuous everything*—Microservices architecture combined with Agile software
    development enable continuous delivery. The software release cycle in microservice
    applications becomes much smaller, and many features can be released per day through
    CI/CD pipelines with open source CI tools like Jenkins.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*持续一切*—微服务架构与敏捷软件开发相结合，可以实现持续交付。在微服务应用程序中的软件发布周期变得非常小，许多功能可以通过CI/CD管道每天发布，使用像Jenkins这样的开源CI工具。'
- en: 'To summarize, microservices make solving big problems easier, increase productivity,
    offer flexibility in choosing technologies, and are great for cross-functional
    teams. At the same time, running microservices in a distributed cloud environment
    can be a tough challenge for organizations. Here are some of the potential pain
    areas associated with microservices designs:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，微服务使解决大问题变得更容易，提高了生产力，提供了选择技术的灵活性，非常适合跨职能团队。同时，在分布式云环境中运行微服务可能对组织来说是一个严峻的挑战。以下是与微服务设计相关的潜在痛点：
- en: '*Complexity*—Increased complexity over a monolithic application due to the
    number of services involved. As a result, enormous effort, synchronization, and
    automation are required to handle interservice communication, monitoring, testing,
    and deployment.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*复杂性*—由于涉及的服务数量增加，比单体应用程序增加了复杂性。因此，需要巨大的努力、同步和自动化来处理服务间通信、监控、测试和部署。'
- en: '*Operational overhead*—Deploying a microservice-based application can be complex.
    It needs a lot of coordination among multiple services. Each service must be isolated
    with its own runtime environment and resources. Hence, traditional deployment
    solutions like virtualization can’t be used and must be replaced with containerization
    solutions like Docker.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*运营开销*—部署基于微服务的应用程序可能很复杂。它需要在多个服务之间进行大量协调。每个服务都必须与其自己的运行时环境和资源隔离。因此，传统的部署解决方案，如虚拟化，不能使用，必须用容器化解决方案，如Docker，来替代。'
- en: '*Synchronization*—Microservices require cultural changes in organizations seeking
    to adopt them. Having multiple development teams working on different services
    requires a huge effort to ensure that communication, coordination, and automated
    processes are in place. Cultures like Agile and DevOps practices are mandatory
    to take on microservice-based applications.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*同步*——微服务需要寻求采用它们的组织进行文化变革。拥有多个开发团队在不同的服务上工作，需要巨大的努力来确保沟通、协调和自动化流程到位。像敏捷和DevOps实践这样的文化是强制性的，以承担基于微服务的应用程序。'
- en: Note While Docker comes with no learning curve, it can quickly become a nightmare
    when handling deploying microservices among a cluster of machines or nodes.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：虽然Docker没有学习曲线，但在处理在机器或节点集群中部署微服务时，它很快就会变成一场噩梦。
- en: 'Most of these drawbacks were addressed with the consumption of cloud computing
    services offered by AWS and with the rise of open source tools—particularly Kubernetes.
    It brought a completely new approach to managing infrastructure and enabled applications
    to be architected in a distributed manner. As a result, a new software architecture
    style arose in 2014: cloud-native applications.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数这些缺点都通过使用AWS提供的云计算服务以及开源工具（尤其是Kubernetes）的兴起得到了解决。它带来了一种完全新的基础设施管理方法，并使应用程序能够以分布式的方式进行架构设计。因此，在2014年出现了一种新的软件架构风格：云原生应用程序。
- en: 1.1.3 Cloud native
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.3 云原生
- en: 'The Cloud Native Computing Foundation (CNCF), a Linux Foundation project founded
    in 2015 to help advance container technology, defines *cloud native* as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生计算基金会（Cloud Native Computing Foundation，CNCF），是一个成立于2015年的Linux基金会项目，旨在帮助推进容器技术，它将*云原生*定义为如下：
- en: '*Cloud-native technologies empower organizations to build and run scalable
    applications in modern, dynamic environments such as public, private, and hybrid
    clouds. Containers, service meshes, microservices, immutable infrastructure, and
    declarative APIs exemplify this approach. These techniques enable loosely coupled
    systems that are resilient, manageable, and observable. Combined with robust automation,
    they allow engineers to make high-impact changes frequently and predictably with
    minimal toil*.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*云原生技术使组织能够在现代、动态的环境中构建和运行可扩展的应用程序，如公共、私有和混合云。容器、服务网格、微服务、不可变基础设施和声明式API是这种方法的例证。这些技术使系统松散耦合，具有弹性、可管理和可观察性。结合强大的自动化，它们允许工程师频繁且可预测地做出高影响的变化，而工作量最小化*。'
- en: Cloud native is a paradigm for building applications as microservices and running
    them on containerized and dynamically orchestrated platforms that fully exploit
    the advantage of the cloud computing model. These applications are developed using
    the language and framework best suited for the functionality. They’re designed
    as loosely coupled systems, optimized for cloud scale and performance, use managed
    services, and take advantage of continuous delivery to achieve reliability and
    faster time to market.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生是构建应用程序为微服务并在容器化和动态编排平台上运行的一种范例，这些平台充分利用了云计算模型的优势。这些应用程序使用最适合其功能的语言和框架进行开发。它们被设计为松散耦合的系统，针对云规模和性能优化，使用托管服务，并利用持续交付来实现可靠性和更快的上市时间。
- en: The overall objective is to improve the speed, scalability, and finally, profit
    margin. Figure 1.2 illustrates an example of a cloud-native application.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 总体目标是提高速度、可扩展性和最终，利润率。图1.2展示了云原生应用程序的一个示例。
- en: '![](Images/CH01_F02_Labouardy.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH01_F02_Labouardy.png)'
- en: Figure 1.2 Overview of a cloud-native application
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 云原生应用程序概述
- en: Cloud-native applications are packaged in lightweight containers and efficiently
    deployed as microservices. They use a lightweight API to expose their functionality,
    and binary and nonbinary protocols to communicate with each other internally.
    A step further, the applications are managed on elastic cloud infrastructure through
    Agile DevOps processes having continuous delivery workflows.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生应用程序以轻量级容器打包，并作为微服务高效部署。它们使用轻量级API来公开其功能，并使用二进制和非二进制协议进行内部通信。更进一步，应用程序通过具有持续交付工作流程的敏捷DevOps流程在弹性云基础设施上管理。
- en: Note Docker has become the standard for container technology. It has revolutionized
    the way we think about developing microservices, and enables us to easily deploy
    microservices locally, on premises, or in the cloud.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Docker已成为容器技术的标准。它彻底改变了我们思考开发微服务的方式，并使我们能够轻松地在本地、本地或云中部署微服务。
- en: '*Kubernetes* ([https://kubernetes.io/](https://kubernetes.io/)) is one of the
    preferred platforms for running workloads that function as cloud-native applications.
    It’s an open source container orchestration platform originally developed at Google.
    It ensures high-end automated deployment, scaling, and management of containerized
    applications. This new paradigm of building and deploying applications comes with
    many benefits:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*Kubernetes* ([https://kubernetes.io/](https://kubernetes.io/)) 是运行作为云原生应用的工作负载的首选平台之一。它是一个开源的容器编排平台，最初由谷歌开发。它确保了容器化应用的自动化部署、扩展和管理的高端功能。这种构建和部署应用的新范式带来了许多好处：'
- en: '*No operational overhead*—Developers can focus on developing features and adding
    business value instead of dealing with infrastructure provisioning and management.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*无运营开销*—开发者可以专注于开发功能和增加商业价值，而不是处理基础设施的配置和管理。'
- en: '*Security compliance*—Simplified security monitoring is required because the
    various parts of an application are isolated. A security problem could happen
    in one container without affecting other areas of the application.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*安全合规性*—由于应用程序的各个部分是隔离的，因此需要简化的安全监控。一个容器中的安全问题可能发生，而不会影响应用程序的其他区域。'
- en: '*Autoscaling*—Containers can be deployed into a fleet of servers in different
    availability zones or even multiple isolated data centers (regions). As a result,
    cloud-native apps can take advantage of the elasticity of the cloud by scaling
    resources in or out during a use spike without the need to procure and provision
    physical servers. Also, by adopting cloud services, the business can go global
    in minutes with lower adaptation costs and increased revenue and without worrying
    about scalability.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*自动扩展*—容器可以被部署到不同可用区或多个隔离数据中心（区域）的服务器集群中。因此，云原生应用可以通过在高峰使用期间动态扩展或缩减资源来利用云的弹性，而无需采购和配置物理服务器。此外，通过采用云服务，企业可以在几分钟内实现全球化，降低适应成本，增加收入，同时无需担心可扩展性。'
- en: '*Development speed*—The application architecture is easy to understand since
    each container represents a small piece of functionality, and is easy for developers
    to modify, so they can help a new team member become productive quickly. Also,
    adopting cloud-native technologies and practices enables companies to create software
    in-house, allowing business people to closely partner with IT people, keep up
    with competitors, and deliver better services to their customers.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开发速度*—由于每个容器代表一小块功能，因此应用程序架构易于理解，并且易于开发者修改，因此他们可以帮助新团队成员快速变得高效。此外，采用云原生技术和实践使公司能够内部创建软件，使业务人员能够与IT人员紧密合作，跟上竞争对手，并向客户提供更好的服务。'
- en: '*Resiliency*—Cloud-native microservices allow for failure at a granular level.
    They do this by providing adequate isolation between each service and offer multiple
    design patterns that might improve the components’ availability and resilience
    such as Circuit Breaker ([https://martinfowler.com/bliki/CircuitBreaker.html](https://martinfowler.com/bliki/CircuitBreaker.html)),
    Throttling ([www.redhat.com/architect/pros-and-cons-throttling](http://www.redhat.com/architect/pros-and-cons-throttling)),
    and Retry patterns. Companies like Netflix used it to develop a new approach called
    *chaos engineering* to build a resilient streaming platform.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*弹性*—云原生微服务允许在细粒度级别上进行故障。它们通过在每个服务之间提供足够的隔离来实现这一点，并提供多种可能提高组件可用性和弹性的设计模式，例如断路器
    ([https://martinfowler.com/bliki/CircuitBreaker.html](https://martinfowler.com/bliki/CircuitBreaker.html))、节流
    ([www.redhat.com/architect/pros-and-cons-throttling](http://www.redhat.com/architect/pros-and-cons-throttling))
    和重试模式。像Netflix这样的公司使用它来开发一种名为 *混沌工程* 的新方法，以构建一个弹性的流媒体平台。'
- en: Figure 1.3 shows the differences between monolithic, microservices, and cloud-native
    architectures.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 展示了单体架构、微服务架构和云原生架构之间的差异。
- en: '![](Images/CH01_F03_Labouardy.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH01_F03_Labouardy.png)'
- en: Figure 1.3 Monolith, microservices, and cloud-native architectures
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 单体架构、微服务架构和云原生架构
- en: To summarize, cloud-native architecture allows you to dynamically scale and
    support large numbers of users, events, and requests on distributed applications.
    A real-world example of the adoption of cloud-native architecture is the serverless
    model.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，云原生架构允许你在分布式应用上动态扩展并支持大量用户、事件和请求。云原生架构在实际应用中的真实例子是无服务器模型。
- en: 1.1.4 Serverless
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.4 无服务器
- en: The *serverless* computing model was kicked off with AWS Lambda in 2014\. In
    this architecture, developers can write cost-efficient applications without provisioning
    or maintaining a complex infrastructure.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器计算模型始于2014年的AWS Lambda。在这个架构中，开发者可以编写成本效益高的应用程序，而无需配置或维护复杂的基础设施。
- en: Cloud providers deploy customers’ code to fully managed, ephemeral, time-boxed
    containers that live only during the invocation of the functions. Therefore, businesses
    can grow without customers having to worry about horizontal scaling or maintaining
    complex infrastructure.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 云服务提供商将客户的代码部署到完全托管、短暂、时间限制的容器中，这些容器仅在函数调用期间存在。因此，企业可以增长，而客户无需担心水平扩展或维护复杂的基础设施。
- en: Note Serverless doesn’t mean “no ops.” You’re just outsourcing sysadmin with
    serverless services. You will still deal with monitoring, deployment, and security.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：无服务器并不意味着“无运维”。你只是将系统管理员外包给了无服务器服务。你仍然需要处理监控、部署和安全问题。
- en: An application built based on serverless architecture may end up looking like
    fig- ure 1.4.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 基于无服务器架构构建的应用程序最终可能看起来像图1.4。
- en: '![](Images/CH01_F04_Labouardy.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH01_F04_Labouardy.png)'
- en: Figure 1.4 An example of a serverless application
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 无服务器应用程序的示例
- en: 'Instead of maintaining a dedicated container or instance to host your static
    web application, you can combine an Amazon Simple Storage Service (S3) bucket
    to benefit from scalability at a cheaper cost. The HTTP requests coming from the
    website go through Amazon API Gateway HTTP endpoints that trigger the right AWS
    Lambda function to handle the application logic and persist data to a fully managed
    database service such as DynamoDB. For particular use cases, going serverless
    can make sense for several reasons:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 与维护一个专门的容器或实例来托管你的静态Web应用程序相比，你可以结合使用Amazon Simple Storage Service (S3)存储桶，以更低的成本获得可伸缩性。来自网站的HTTP请求将通过Amazon
    API Gateway HTTP端点，触发正确的AWS Lambda函数来处理应用程序逻辑并将数据持久化到完全托管的数据库服务，如DynamoDB。对于特定的用例，采用无服务器架构可能有几个原因：
- en: '*Less operational overhead*—The infrastructure is managed by the cloud provider,
    and this reduces the overhead and increases developer velocity. OS updates are
    taken care of, and patching is done by the function-as-a-service (FaaS) provider.
    This results in decreased time to market and faster software releases and eliminates
    the need for a system administrator.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*减少运维开销*——基础设施由云服务提供商管理，这减少了开销并提高了开发速度。操作系统更新由函数即服务（FaaS）提供商负责，补丁修复也由他们完成。这导致上市时间缩短，软件发布速度加快，并消除了系统管理员的需求。'
- en: '*Horizontal autoscaling*—Function becomes the unit of scale that leads to small,
    loosely coupled, stateless components that, in the long run, lead to scalable
    applications. Plus, the scaling mechanism is shifted to the cloud provider, which
    decides how to use its infrastructure effectively to serve the client’s requests.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*水平自动扩展*——函数成为扩展的单位，导致小型、松散耦合、无状态的组件，从长远来看，这些组件可以扩展成可伸缩的应用程序。此外，扩展机制转移到云服务提供商，它决定如何有效地使用其基础设施来服务客户端请求。'
- en: '*Cost optimization*—You pay for only the compute time and resources that you
    consume. As a result, you don’t pay for idle resources, which significantly reduces
    infrastructure costs.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*成本优化*——你只需为使用的计算时间和资源付费。因此，你不需要为闲置资源付费，这显著降低了基础设施成本。'
- en: '*Polyglot*—Another benefit is the ability to choose a different language runtime
    depending on the use case. One part of the application can be written in Java,
    while another in Python; it doesn’t really matter as long as the job gets done.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*多语言支持*——另一个好处是能够根据用例选择不同的语言运行时。应用程序的一部分可以是用Java编写的，而另一部分可以用Python编写；只要工作能完成，这并不重要。'
- en: Note A big concern while going serverless is vendor lock-in. Although you should
    favor development speed and efficiency above all, it’s important to choose a vendor
    based on your use case.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在采用无服务器架构时，一个主要担忧是供应商锁定。尽管你应该首先考虑开发速度和效率，但根据你的用例选择供应商是很重要的。
- en: Cloud-native architectures, in general, are gaining massive adoption, but the
    learning curve for many teams is steep. Plus, the shift to cloud-native architecture
    can be a double-edged sword for many organizations, and one of the challenges
    when moving to a fully cloud-native approach can be CI/CD.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生架构通常正在获得广泛的应用，但许多团队的学习曲线很陡峭。此外，转向云原生架构对于许多组织来说可能是一把双刃剑，而在完全采用云原生方法时可能面临的挑战之一是CI/CD。
- en: But what do these practices mean? And how can they be applied when you’re building
    cloud-native applications?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 但这些实践意味着什么？当您构建云原生应用程序时，它们如何应用？
- en: 1.2 Defining continuous integration
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2 定义持续集成
- en: '*Continuous* *integration* (CI) is the practice of having a shared and centralized
    code repository, and directing all changes and features through a complex pipeline
    before integrating them into the central repository (such as GitHub, Bitbucket,
    or GitLab). A classic CI pipeline is as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*持续集成*（CI）是指在共享和集中的代码仓库中，在将更改和功能集成到中央仓库（如GitHub、Bitbucket或GitLab）之前，通过复杂的管道指导所有更改和功能。一个经典的CI管道如下：'
- en: Triggers a build whenever a code commit occurs
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每当发生代码提交时触发构建
- en: Runs the unit tests and all pre-integration tests (quality and security tests)
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行单元测试和所有预集成测试（质量和安全测试）
- en: Builds the artifact (for example, Docker image, zip file, machine learning training
    model)
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建工件（例如，Docker镜像、zip文件、机器学习训练模型）
- en: Runs acceptance tests and pushes the result to an artifact-management repository
    (such as a Docker Registry, Amazon S3 bucket, Sonatype’s Nexus, or JFrog Artifactory)
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行验收测试并将结果推送到一个工件管理存储库（如Docker Registry、Amazon S3存储桶、Sonatype的Nexus或JFrog Artifactory）
- en: Figure 1.5 shows an example of a CI pipeline for a containerized application.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5显示了容器化应用程序的CI管道示例。
- en: '![](Images/CH01_F05_Labouardy.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH01_F05_Labouardy.png)'
- en: Figure 1.5 Basic CI workflow for cloud-native applications
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5 云原生应用程序的基本CI工作流程
- en: Basically, CI automatically monitors the commits that each developer makes and
    launches automated tests. Automated testing is an integral part of CI/CD pipelines.
    Without automated tests, CI/CD pipelines will lack quality checks, which are important
    in order for the application to be released.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，持续集成（CI）会自动监控每个开发者做出的提交，并启动自动化测试。自动化测试是CI/CD管道的组成部分。没有自动化测试，CI/CD管道将缺少质量检查，这对于应用程序的发布非常重要。
- en: 'You can implement various types of testing to ensure that your software meets
    all the initial requirements. Here are the most famous ones:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以实施各种类型的测试以确保您的软件满足所有初始要求。以下是最著名的几种：
- en: '*Unit tests*—These test each piece of the source code. They consist of testing
    individual functions and methods. You could also output your test coverage and
    validate that you’re meeting your code coverage requirements.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*单元测试*—这些测试源代码的每一部分。它们包括测试单个函数和方法。您还可以输出测试覆盖率并验证您是否满足代码覆盖率要求。'
- en: '*Quality tests*—Check that the code is well formatted, follows best practices,
    and has no serious coding errors. This is also called *static code analysis*,
    as it helps to produce high-quality code by looking for patterns in code that
    might generate bugs.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*质量测试*—检查代码是否格式良好，遵循最佳实践，并且没有严重的编码错误。这也被称为*静态代码分析*，因为它通过寻找可能产生错误的代码模式来帮助产生高质量的代码。'
- en: '*Security tests*—Inspect source code to uncover common security vulnerabilities
    and common security flaws (for example, leaked usernames and passwords).'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*安全测试*—检查源代码以发现常见的安全漏洞和常见的安全缺陷（例如，泄露的用户名和密码）。'
- en: '*UI tests*—Simulate user behavior through the system to ensure that the application
    works correctly in all supported browsers (including Google Chrome, Mozilla Firefox,
    and Microsoft Internet Explorer) and platforms (such as Windows, Linux, and macOS)
    and that it delivers the functionality promised in user stories.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*UI测试*—通过系统模拟用户行为，以确保应用程序在所有支持的浏览器（包括Google Chrome、Mozilla Firefox和Microsoft
    Internet Explorer）和平台（如Windows、Linux和macOS）上都能正确工作，并且提供用户故事中承诺的功能。'
- en: '*Integration tests*—Check that services or components used by the application
    work well together and no defects exist. For example, an integration test might
    test an application’s interaction with the database.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*集成测试*—检查应用程序使用的服务或组件是否协同工作且不存在缺陷。例如，集成测试可能会测试应用程序与数据库的交互。'
- en: Manually executing all these tests can be time-consuming and counterproductive.
    Therefore, you should always use a testing framework that suits your application
    requirements to perform those tests on a scale in a repeatable and reliable way.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 手动执行所有这些测试可能会耗时且效率低下。因此，您应该始终使用适合您应用程序要求的测试框架，以可重复和可靠的方式在规模上执行这些测试。
- en: Note Chapter 8 covers how to run automated tests with Jenkins and Headless Chrome,
    as well as how to integrate SonarQube for code analysis.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意第8章介绍了如何使用Jenkins和Headless Chrome运行自动化测试，以及如何集成SonarQube进行代码分析。
- en: Once tests are successful, the application will be compiled and packaged, and
    a releasable artifact will be generated and versioned in a remote repository.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦测试成功，应用程序将被编译和打包，并在远程仓库中生成和版本化可发布的工件。
- en: 1.3 Defining continuous deployment
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3 定义持续部署
- en: '*Continuous* *deployment* (CD) is an extension of continuous integration. Every
    change that passes all stages of your continuous integration pipeline is released
    automatically to your staging/preproduction environment.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*持续* *部署*（CD）是持续集成的扩展。每个通过您持续集成管道所有阶段的更改都会自动发布到您的预发布/生产环境。'
- en: In such a process, there’s no need to decide what will be deployed and when.
    The pipeline will automatically deploy whatever build components/packages successfully
    exit the pipeline. Figure 1.6 illustrates a typical CI/CD pipeline for microservices
    running in Kubernetes.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样的过程中，无需决定部署什么以及何时部署。管道将自动部署成功通过管道的任何构建组件/包。图 1.6 展示了在 Kubernetes 中运行的微服务的典型
    CI/CD 管道。
- en: '![](Images/CH01_F06_Labouardy.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH01_F06_Labouardy.png)'
- en: Figure 1.6 Basic CI/CD workflow for cloud-native applications
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.6 云原生应用的基本 CI/CD 工作流程
- en: This CI workflow has four steps, and the CD pipeline is the deployment to Kubernetes
    (step 5). However, a pure continuous deployment approach is not always appropriate
    for everyone.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 CI 工作流程有四个步骤，CD 管道是部署到 Kubernetes（步骤 5）。然而，纯持续部署方法并不总是适合所有人。
- en: For example, many clients would not appreciate new versions falling into their
    laps several times a week, and prefer a more predictable and transparent release
    cycle. Commercial and marketing considerations might also play a role in when
    a new release should actually be deployed.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，许多客户可能不会欣赏每周几次新版本落入他们手中，他们更喜欢更可预测和透明的发布周期。商业和营销考虑因素也可能在何时实际部署新版本时发挥作用。
- en: While continuous deployment may not be right for every company, continuous delivery
    is an absolute requirement of DevOps practices. Only when you continuously deliver
    your code can you have true confidence that your changes will be serving value
    to your customers within minutes of pushing the “go” button, and that you can
    actually push that button any time the business is ready for it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然持续部署可能不适合每家公司，但持续交付是 DevOps 实践的绝对要求。只有当您持续交付代码时，您才能真正有信心，您的更改在按下“启动”按钮后的几分钟内将为您的客户提供价值，并且您实际上可以在业务准备好时随时按下该按钮。
- en: 1.4 Defining continuous delivery
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.4 定义持续交付
- en: '*Continuous* *delivery* (CD) is similar to continuous deployment but requires
    human intervention or a business decision before deploying the release to production.
    Figure 1.7 shows how the CI/CD practices relate to each other.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*持续* *交付*（CD）与持续部署类似，但在将发布部署到生产之前需要人工干预或业务决策。图 1.7 展示了 CI/CD 实践之间的关系。'
- en: '![](Images/CH01_F07_Labouardy.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH01_F07_Labouardy.png)'
- en: Figure 1.7 The continuous deployment maturity model
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.7 持续部署成熟度模型
- en: Note A Monitor and Optimize stage can occur in a sophisticated CI/CD workflow.
    This step consists of collecting and analyzing metrics and feedback to eliminate
    risks and waste and to optimize the release time.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在复杂的 CI/CD 工作流程中，可能存在监控和优化阶段。这一步骤包括收集和分析指标和反馈，以消除风险和浪费并优化发布时间。
- en: 1.5 Embracing CI/CD practices
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.5 接受 CI/CD 实践
- en: 'CI/CD and continuous delivery can bring more agility to cloud-native applications
    through daily builds, which leads to the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: CI/CD 和持续交付可以通过每日构建为云原生应用带来更多敏捷性，从而导致以下结果：
- en: Detecting anomalies at an earlier stage (reducing the risk) and minimizing technical
    debt through unit and functional tests. According to Atlassian ([www.atlassian.com/software-development/practices](http://www.atlassian.com/software-development/practices)),
    75% of development teams face issues with bugs, defects, or delays when it’s time
    to release.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在早期阶段检测异常（降低风险）以及通过单元和功能测试最小化技术债务。根据 Atlassian ([www.atlassian.com/software-development/practices](http://www.atlassian.com/software-development/practices))
    的数据，75% 的开发团队在发布时都会遇到与虫子、缺陷或延迟相关的问题。
- en: Building features your users actually want. This often results in better user
    interaction and quicker feedback regarding released features, which can help the
    product team focus on the most demanded features and build a high-quality product.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建用户真正需要的特性。这通常会导致更好的用户交互和关于发布特性的更快反馈，这有助于产品团队专注于最受欢迎的特性并构建高质量的产品。
- en: Having a production-ready package available. This is an excellent way to accelerate
    the time to market.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有一个可用于生产的软件包。这是加速上市时间的一个极好方法。
- en: Increasing product quality and reliability through quality and stress tests,
    and tracking with better visibility into project status and health.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过质量测试和压力测试提高产品质量和可靠性，并通过更好的可见性跟踪项目状态和健康状况。
- en: Driving innovation from feedback while building high-quality products through
    each iteration.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过每次迭代构建高质量产品的同时，从反馈中驱动创新。
- en: However, the journey from a manual to a highly automated deployment process
    can take several months. Therefore, companies need to be iterative in adopting
    CI/CD, as illustrated in figure 1.8.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从手动到高度自动化的部署过程的转变可能需要几个月的时间。因此，公司需要迭代地采用CI/CD，如图1.8所示。
- en: '![](Images/CH01_F08_Labouardy.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH01_F08_Labouardy.png)'
- en: Figure 1.8 Introducing CI/CD to an organization
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.8 向组织引入CI/CD
- en: You should always prioritize the steps in CI/CD. First and foremost, automate
    the process for compiling the source code. Ideally, you will develop new features
    and fix multiple bugs per day. Manually, this process takes a few minutes to a
    couple of hours. Also, you should prioritize functional testing before UI testing,
    as it often changes and thus requires frequent pipeline changes. So make sure
    to break your CI/CD steps into smaller segments and automate in patches to make
    the best use of your resources.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该始终优先考虑CI/CD中的步骤。首先，自动化源代码编译的过程。理想情况下，你将每天开发新功能并修复多个错误。手动这个过程可能需要几分钟到几个小时。此外，你应该在UI测试之前优先进行功能测试，因为它经常发生变化，因此需要频繁的管道更改。所以确保将CI/CD步骤分解成更小的部分，并分批自动化，以最大限度地利用你的资源。
- en: Another concern is that the complexity of CI/CD will be increasing, from handling
    singular applications to dozens of microservices (multiple pipelines). Therefore,
    adapting your CI/CD tools and processes is mandatory to keep pace.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个担忧是CI/CD的复杂性将会增加，从处理单一应用程序到数十个微服务（多个管道）。因此，适应你的CI/CD工具和流程是必要的，以保持同步。
- en: Moreover, you need to have a clear road map of your product with a proven track
    record of development success. Your end customers should be able to consume constant
    product changes. Therefore, using CI/CD requires a high degree of discipline,
    dedication to quality, and a learning curve (new skill sets). If you can’t handle
    that, stop thinking about CI/CD immediately.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你需要有一个清晰的产品路线图，并有一个经过验证的开发成功记录。你的最终客户应该能够消费持续的产品变化。因此，使用CI/CD需要高度的纪律性，对质量的奉献精神，以及一个学习曲线（新的技能集）。如果你无法处理这些，立即停止考虑CI/CD。
- en: As a result, moving to CI/CD should not be an isolated decision, made alone
    by the DevOps team. A successful rollout of CI/CD must be a decision for your
    whole organization and should be made only when your entire organization agrees
    to it.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，转向CI/CD不应是一个孤立的决定，仅由DevOps团队做出。CI/CD的成功推广必须是整个组织的决定，并且只有当整个组织都同意时才能做出。
- en: Although you need to keep some concerns in mind, the benefits of CI/CD almost
    always outweigh the challenges. To realize the full promise of cloud-native applications,
    you must implement CI/CD practices that are best suited to your unique business
    goals.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你需要考虑一些担忧，但CI/CD的好处几乎总是超过挑战。为了实现云原生应用的全部承诺，你必须实施最适合你独特业务目标的CI/CD实践。
- en: In this book, we will go through some real-world use cases for building CI/CD
    pipelines for most adopted cloud-native architectures, such as Dockerized microservices
    with both Docker Swarm and Kubernetes, as well as Lambda-based serverless applications.
    We will also cover how to manage and scale a CI tool with less maintenance hassle
    to help you increase deployment speed. But first, what makes a modern CI tool,
    and which one are we going to use?
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将探讨为大多数采用的云原生架构构建CI/CD管道的一些真实世界用例，例如同时使用Docker Swarm和Kubernetes的Docker化微服务，以及基于Lambda的无服务器应用程序。我们还将介绍如何以更少的维护麻烦来管理和扩展CI工具，以帮助你提高部署速度。但首先，是什么让现代CI工具变得独特，我们将使用哪一个？
- en: Note While monoliths may not be trendy, many companies still have monolith flagship
    products and can still benefit tremendously from a well-architected CI/CD solution.
    So most of the examples in the book can also be applied to modernizing monolithic
    applications.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：虽然单体架构可能不再流行，但许多公司仍然拥有单体旗舰产品，并且仍然可以从一个精心设计的CI/CD解决方案中受益巨大。所以书中的大部分例子也可以应用于单体应用的现代化。
- en: 1.6 Using essential CI/CD tools
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.6 使用基本的CI/CD工具
- en: 'A lot of excellent CI tools are out there. Some have been here for a long time,
    and others are relatively new. It’s a bit redundant to say that a modern CI tool
    must be fast, user-friendly, and flexible, since those are the features we already
    expect out of the box. CI tools can be divided into the following three main categories:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有许多优秀的 CI 工具。一些已经存在很长时间，而另一些则是相对较新的。说一个现代 CI 工具必须是快速、用户友好和灵活的有点多余，因为这些是我们已经期望的功能。CI
    工具可以分为以下三个主要类别：
- en: Cloud-managed solutions like AWS CodePipeline ([https://aws.amazon.com/codepipeline/](https://aws.amazon.com/codepipeline/)),
    Google Cloud Build ([https://cloud.google.com/build](https://cloud.google.com/build)),
    and Microsoft Azure Pipelines ([https://azure.microsoft.com/services/devops/pipelines/](https://azure.microsoft.com/en-us/services/devops/pipelines/)).
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云托管解决方案，如 AWS CodePipeline ([https://aws.amazon.com/codepipeline/](https://aws.amazon.com/codepipeline/))、Google
    Cloud Build ([https://cloud.google.com/build](https://cloud.google.com/build))
    和 Microsoft Azure Pipelines ([https://azure.microsoft.com/services/devops/pipelines/](https://azure.microsoft.com/en-us/services/devops/pipelines/))。
- en: Open source solutions such as Jenkins ([www.jenkins.io](http://www.jenkins.io/)),
    Spinnaker ([https://spinnaker.io/](https://spinnaker.io/)), or GoCD ([www.gocd.org](http://www.gocd.org)).
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开源解决方案，例如 Jenkins ([www.jenkins.io](http://www.jenkins.io/))、Spinnaker ([https://spinnaker.io/](https://spinnaker.io/))
    或 GoCD ([www.gocd.org](http://www.gocd.org))。
- en: Software-as-a-service (SaaS) solutions like Travis CI ([https://travis-ci.org/](https://travis-ci.org/)),
    CircleCI ([https://circleci.com/](https://circleci.com/)), and TeamCity ([www.jetbrains.com/teamcity/](http://www.jetbrains.com/teamcity/)).
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件即服务 (SaaS) 解决方案，如 Travis CI ([https://travis-ci.org/](https://travis-ci.org/))、CircleCI
    ([https://circleci.com/](https://circleci.com/)) 和 TeamCity ([www.jetbrains.com/teamcity/](http://www.jetbrains.com/teamcity/))。
- en: 1.6.1 Choosing a CI/CD tool
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.6.1 选择 CI/CD 工具
- en: Figure 1.9 shows the most popular CI/CD tools on the market today. These tools
    are the mature ones, with the essential capabilities for your project.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.9 展示了当今市场上最受欢迎的 CI/CD 工具。这些工具是成熟的，具备您项目所需的基本功能。
- en: '![](Images/CH01_F09_Labouardy.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH01_F09_Labouardy.png)'
- en: Figure 1.9 Top CI/CD tools in 2021
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.9 2021 年最受欢迎的 CI/CD 工具
- en: 'Plenty of excellent CI tools are available, so you need to pick the best one
    based on the following factors:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多优秀的 CI 工具可供选择，因此您需要根据以下因素选择最佳工具：
- en: '*Team experience and skills*—While many tools use configuration YAML files
    to declare the CI/CD pipeline, they might require some sysadmin skills to set
    up and provision the needed infrastructure to run the CI/CD platform. Also, maintaining
    the underlying infrastructure might cause a lot of headaches and become a bottleneck
    for your company’s growth once your project codebase becomes bigger (scaling capabilities),
    as you need to maintain distributed CI/CD complex pipelines across multiple nodes
    or servers.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*团队经验和技能*—虽然许多工具使用配置 YAML 文件来声明 CI/CD 管道，但它们可能需要一些系统管理员技能来设置和提供所需的基础设施以运行 CI/CD
    平台。此外，维护底层基础设施可能会引起很多麻烦，并成为您公司增长瓶颈，一旦您的项目代码库变得更大（扩展能力），因为您需要维护跨多个节点或服务器的分布式 CI/CD
    复杂管道。'
- en: '*Target platform*—Consider the operating system your application or project
    is running on (some CI tools don’t support macOS and ARM architecture), and the
    use of a self-hosted infrastructure or a cloud provider.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*目标平台*—考虑您的应用程序或项目运行在哪个操作系统上（一些 CI 工具不支持 macOS 和 ARM 架构），以及使用自托管基础设施或云提供商。'
- en: '*Programming language and architecture*—Most CI tools support the top cutting-edge
    languages including Java, Ruby, Python, PHP, and JavaScript. However, some tools
    like TeamCity offer better integration and support for Java and .NET projects.
    Similarly, Bamboo, as a creation of Atlassian, has native support for Jira and
    Bitbucket. Additionally, the deployment solution can be a factor in choosing the
    right CI tool for your project. Tools like Drone ([www.drone.io](http://www.drone.io))
    and GitLab CI ([https://docs.gitlab.com/ee/ci/](https://docs.gitlab.com/ee/ci/))
    offer native Docker support with an integrated Docker registry.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编程语言和架构*—大多数 CI 工具支持最前沿的语言，包括 Java、Ruby、Python、PHP 和 JavaScript。然而，一些工具如 TeamCity
    提供了更好的 Java 和 .NET 项目的集成和支持。同样，Bamboo 作为 Atlassian 的作品，具有对 Jira 和 Bitbucket 的原生支持。此外，部署解决方案可以是选择适合您项目的正确
    CI 工具的一个因素。像 Drone ([www.drone.io](http://www.drone.io)) 和 GitLab CI ([https://docs.gitlab.com/ee/ci/](https://docs.gitlab.com/ee/ci/))
    这样的工具提供了集成的 Docker 注册表和原生 Docker 支持。'
- en: 1.6.2 Introducing Jenkins
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.6.2 介绍 Jenkins
- en: Although no single tool can satisfy the needs of every project, in this book,
    we will rely heavily on *Jenkins.* It’s considered one of the most popular CI
    tools on the market today, with over one million users. It was written in Java,
    making it a cross-platform (Windows, Linux, and macOS) continuous integration
    tool.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管没有单个工具能够满足每个项目的需求，但在本书中，我们将大量依赖 *Jenkins*。它被认为是市场上最受欢迎的 CI 工具之一，拥有超过一百万用户。它是用
    Java 编写的，使其成为一个跨平台（Windows、Linux 和 macOS）的持续集成工具。
- en: Originally a part of the Hudson project, the community and codebase split following
    trademark conflicts with Oracle after it acquired Sun Microsystems. Hudson was
    originally released in 2005, while the first release as Jenkins was made in 2011.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最初是 Hudson 项目的组成部分，在 Sun Microsystems 被甲骨文公司收购后，由于商标冲突，社区和代码库分开了。Hudson 最初于
    2005 年发布，而 Jenkins 的首次发布是在 2011 年。
- en: Note Hosted SaaS platforms can be beneficial if you’re willing to pay a bit
    of extra money for someone else to maintain and update the solution. Businesses
    tend to choose this option when they need a UI superior to what Jenkins offers
    and when they lack infrastructure skills. But a major benefit of self-hosting
    solutions like Jenkins is that you have more control and flexibility over your
    own data security and job pipelines.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果您愿意为他人维护和更新解决方案支付一些额外费用，托管 SaaS 平台可能是有益的。当企业需要比 Jenkins 提供的更好的 UI 并且缺乏基础设施技能时，往往会选择这种选项。但自托管解决方案（如
    Jenkins）的主要好处是，您对自己的数据安全和作业流程有更多的控制和灵活性。
- en: 'A rich set of plugins enables Jenkins to support any type of language or technology
    such as Docker, Maven, Git, Mercurial, and AWS. Being an open source project makes
    it customizable and easy for developers to extend by creating custom plugins.
    Here are some of Jenkins key features:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一套丰富的插件集使 Jenkins 能够支持任何类型的语言或技术，例如 Docker、Maven、Git、Mercurial 和 AWS。作为一个开源项目，它使得开发者可以通过创建自定义插件来定制和扩展它。以下是
    Jenkins 的关键特性：
- en: Extensible with a huge community-contributed plugin resource (more than 1,400
    plugins).
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可通过庞大的社区贡献的插件资源（超过 1,400 个插件）进行扩展。
- en: A free and open source tool as well as a paid enterprise edition offered by
    CloudBees ([www.cloudbees.com/jenkins](http://www.cloudbees.com/jenkins)) with
    speedy customer support.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一款免费和开源的工具，以及 CloudBees 提供的付费企业版（[www.cloudbees.com/jenkins](http://www.cloudbees.com/jenkins)），提供快速的客户支持。
- en: Has an active community that helps developers reduce the time to build a working
    CI/CD workflow.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有一个活跃的社区，帮助开发者减少构建工作 CI/CD 工作流程的时间。
- en: Can be deployed on premises or in the cloud with an easy configuration through
    the user interface or the command line.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过用户界面或命令行轻松配置，在本地或云端部署。
- en: Supports distributed builds with master-worker architecture with a built-in
    parallelism mechanism.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持具有内置并行机制的主从架构的分布式构建。
- en: A powerful and flexible tool with complete control over workflow that can serve
    every CI/CD need.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个强大且灵活的工具，可以完全控制工作流程，满足每个 CI/CD 需求。
- en: Works on many platforms and has the support for a wide variety of tools and
    frameworks.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在许多平台上运行，并支持广泛的工具和框架。
- en: Supports containers as build agents for teams planning to use Docker.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持容器作为构建代理，适用于计划使用 Docker 的团队。
- en: Seamless integration with GitHub, GitLab, Bitbucket, and most of the source
    code management (SCM) systems and Apache Subversion (SVN).
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 GitHub、GitLab、Bitbucket 以及大多数源代码管理（SCM）系统和 Apache Subversion（SVN）无缝集成。
- en: Flexible user management, user roles assignment, sorting users into groups,
    different ways of user authentication (including LDAP, GitHub OAuth, and Active
    Directory).
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 灵活的用户管理，用户角色分配，将用户分类到不同的组中，不同的用户认证方式（包括 LDAP、GitHub OAuth 和 Active Directory）。
- en: The CI process can be defined using the Groovy language in files within the
    repository itself or through text fields in the Jenkins web UI, thanks to the
    Jenkins pipeline workflow.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于 Jenkins 管道工作流程，CI 流程可以使用存储库内的文件或 Jenkins 网页 UI 中的文本字段使用 Groovy 语言定义。
- en: Note If you like to test a small application for one particular platform, you
    won’t need the complexity of running a Jenkins server.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果您只想测试特定平台上的一个小型应用程序，您不需要运行 Jenkins 服务器的复杂性。
- en: Another key feature of Jenkins is *pipeline as code*. We’re going to use this
    approach to create Jenkins jobs. The cool part of using this approach is that
    our entire Jenkins jobs configuration can be created, updated, and version-controlled
    along with the rest of the application source code.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins 的另一个关键特性是 *代码化流水线*。我们将使用这种方法来创建 Jenkins 作业。使用这种方法的好处是，我们的整个 Jenkins
    作业配置可以与应用程序源代码的其他部分一起创建、更新和版本控制。
- en: It is helpful to note that Jenkins must be hosted on a server, so it often needs
    the attention of someone with infrastructure skills. You can’t just set it up
    and then expect it to run itself; the system requires frequent updates and maintenance.
    The main barrier to entry for most teams is the initial setup, procrastination,
    or failed previous attempts to set it up. People tend to know it’s good, but many
    teams neglect it for more urgent coding work. Perhaps someone on your team tried
    to deploy Jenkins at some point but did not successfully maintain it. Maybe the
    wasted effort gave your boss a bad impression about it.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 有助于注意的是，Jenkins 必须托管在服务器上，因此它通常需要具有基础设施技能的人的关注。你不能只是设置好然后期望它自行运行；系统需要频繁的更新和维护。大多数团队进入的主要障碍是初始设置、拖延或之前设置失败的尝试。人们往往知道它是好的，但许多团队却忽视了它，转而去做更紧急的编码工作。也许你的团队中有人试图部署
    Jenkins，但没有成功维护它。也许这种浪费的努力给你的老板留下了不好的印象。
- en: The reasons people do not implement Jenkins are usually very practical. That’s
    why, throughout this book, we will be using the magical power of infrastructure
    as code with open source tools like Terraform and Packer to set up our entire
    CI infrastructure out of thin air on most popular public cloud providers such
    as AWS, GCP, and Microsoft Azure.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 人们不实施 Jenkins 的原因通常非常实际。这就是为什么，在这本书中，我们将使用基础设施即代码的神奇力量，结合像 Terraform 和 Packer
    这样的开源工具，在大多数流行的公共云提供商（如 AWS、GCP 和微软 Azure）上从无到有地设置我们的整个 CI 基础设施。
- en: Another problem we will tackle in this book is how to write tests. Writing tests
    is something most developers want to do, but often don’t find the time to do.
    Understandably, coding the actual application is usually a higher priority for
    the business. Also, tests break, meaning when the functionality under test changes,
    it needs to be updated. If functionality is not updated, it stops delivering value.
    We will cover how to run various types of tests within CI/CD pipelines and how
    to integrate external code analysis tools.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们还将解决另一个问题，那就是如何编写测试。编写测试是大多数开发者想要做的事情，但往往没有时间去做。可以理解的是，编写实际的应用程序对于业务来说通常是优先级更高的任务。此外，测试会出错，这意味着当被测试的功能发生变化时，它需要更新。如果功能没有更新，它就停止提供价值。我们将介绍如何在
    CI/CD 管道中运行各种类型的测试，以及如何集成外部代码分析工具。
- en: To sum up, implementing CI/CD for cloud-native architecture requires a cultural
    and mindset shift, especially from management. Managers have to allow time for
    this “unproductive stuff” to be done.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，为云原生架构实施 CI/CD 需要文化和心态的转变，尤其是从管理层来说。管理者必须为这项“低效的工作”留出时间。
- en: Still, the brief sacrifice of time translates into long-term benefits for the
    whole company. With Jenkins, your code becomes easier to maintain, and fewer bugs
    sneak into production. Your team becomes more integrated, and builds take less
    time. Your business can ship faster and keep up with the changing needs of your
    customers (by shipping code faster, organizations can quickly respond to changes
    and keep products on the market).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，短暂的牺牲时间对于整个公司来说会带来长期的好处。使用 Jenkins，你的代码变得更容易维护，更少的错误会悄悄进入生产环境。你的团队变得更加紧密，构建所需的时间更少。你的业务可以更快地发货，并跟上客户不断变化的需求（通过更快地发货代码，组织可以迅速响应变化并保持产品在市场上）。
- en: CI/CD is not an expense but an investment. And the return on investment (ROI)
    for implementation can be counted in time saved, errors avoided, and higher-quality
    products delivered more easily to your clients.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: CI/CD 不是一个开销，而是一种投资。实施的投资回报率（ROI）可以通过节省的时间、避免的错误以及更容易交付给客户的更高品质的产品来衡量。
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Cloud-native architectures are changing the landscape, forcing organizations
    to think about new models and new delivery methods.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云原生架构正在改变格局，迫使组织思考新的模型和新的交付方法。
- en: Continuous integration, delivery, and deployment are practices designed to help
    increase the velocity of development and the release of well-tested, usable products.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续集成、交付和部署是旨在帮助提高开发速度和发布经过良好测试、可用的产品的实践。
- en: Choosing the right CI/CD tool is critical to the long-term success of cloud-native
    applications and should be based on platform complexity, integration, learning
    curve, pricing, and work-time efficiency.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择合适的 CI/CD 工具对于云原生应用的长期成功至关重要，应基于平台复杂性、集成、学习曲线、定价和工作时间效率来考虑。
- en: Jenkins can leverage the team’s current workflow to best exploit the automation
    features and create a solid CI/CD pipeline.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins 可以利用团队当前的流程，最大限度地利用自动化功能，并创建一个稳固的 CI/CD 流水线。
