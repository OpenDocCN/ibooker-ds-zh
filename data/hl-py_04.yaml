- en: Chapter 5\. Business-oriented programming
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第5章\. 以业务为导向的编程
- en: '|  |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**This chapter covers**'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: '*Writing programs for the real world*'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*为现实世界编写程序*'
- en: '*Interacting with existing systems*'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*与现有系统交互*'
- en: '*How to handle errors in your program*'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*如何处理程序中的错误*'
- en: '|  |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In this chapter, we’re going to take a look at how Python can be used in the
    real world to help you to do your job better and faster. As a sample project,
    you’ll take some stock data from a web page on the internet, extract the figures
    you’re interested in, and then see how you can make use of that data, report on
    it, and send those reports to interested parties. To make your life easier, all
    of this will be written so it’s easy to automate.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨Python如何在现实世界中使用，以帮助您更好地更快地完成工作。作为一个示例项目，您将从互联网上的网页中提取一些股票数据，提取您感兴趣的数据，然后看看您如何可以使用这些数据，报告这些数据，并将这些报告发送给感兴趣的相关方。为了使您的生活更加轻松，所有这些都将编写得易于自动化。
- en: 'One of the critical tasks facing many programmers and system administrators
    is to make many different systems talk to each other. You might need to do the
    following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 许多程序员和系统管理员面临的一个关键任务是让许多不同的系统相互通信。你可能需要做以下事情：
- en: Read some data from one system
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从一个系统中读取一些数据
- en: Compare it with the results from a second
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其与第二个的结果进行比较
- en: Check that both of them make sense (often referred to as a *sanity check*)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保两者都合理（通常称为*合理性检查*）
- en: Save the results for later use
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将结果保存以供以后使用
- en: Email relevant people with a report about what you found or any problems you
    encountered
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用报告将你发现的内容或遇到的问题发送给相关人士
- en: People are depending on the information from these systems, so whatever you
    write has to be robust. You can’t try something and hope for the best. Sound daunting?
    Don’t worry—Python is at its heart a practical language, and has a number of features
    and library modules to make interfacing with the real world and all of its quirks
    much easier.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 人们依赖于这些系统中的信息，所以你写的任何东西都必须是健壮的。你不能尝试一些东西并希望一切顺利。听起来令人畏惧吗？别担心——Python本质上是一种实用的语言，它有许多特性和库模块，可以使得与真实世界及其所有怪癖的交互变得更加容易。
- en: '|  |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Why Automate?
  id: totrans-16
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 为什么自动化？
- en: The more selfish reason for wanting to automate is that once you’ve set up your
    program, you don’t have to worry about it anymore, which frees you up to think
    about more important and interesting things.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 想要自动化的更多自私的理由是，一旦你设置了你的程序，你就不必再担心它了，这让你有更多时间去思考更重要和有趣的事情。
- en: '|  |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: You’ll start by building your reporting program, and then we’ll look at what
    steps you can take to anticipate errors and make the program bulletproof.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你将从构建你的报告程序开始，然后我们将探讨你可以采取哪些步骤来预测错误并使程序无懈可击。
- en: Making programs talk to each other
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 让程序相互通信
- en: How do you make programs talk to each other? Typically, programs will have some
    sort of data input and output, so integrating two programs is normally a question
    of taking the output of one program, reading its data, and then presenting that
    data in a format that the second program will understand. Ultimately, you can
    chain lots of different programs together with Python acting as an interpreter.
    The system you’ll be building looks something like [figure 5.1](#ch05fig01).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何让程序相互通信？通常，程序将有一些数据输入和输出，因此集成两个程序通常是一个问题，即获取一个程序的输出，读取其数据，然后将这些数据以第二程序能理解的形式呈现。最终，你可以使用Python作为解释器将许多不同的程序连接在一起。你将构建的系统看起来就像[图5.1](#ch05fig01)。
- en: Programs for tasks like this are normally referred to as *glue code*, because
    you’re gluing two or more programs together into one system.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的程序通常被称为*粘合代码*，因为你正在将两个或更多程序粘合在一起形成一个系统。
- en: Figure 5.1\. Python as a glue language, helping other programs “talk” to each
    other
  id: totrans-23
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.1\. Python作为粘合语言，帮助其他程序“交谈”
- en: '![](05fig01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](05fig01.jpg)'
- en: CSV to the rescue!
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: CSV来拯救！
- en: The process of gluing programs together is much easier if you have a common
    data format—a data “language” that all of the programs in question speak. The
    format that’s closest to being a lingua franca of data exchange is the humble
    comma-separated value (CSV) file, which is a simple spreadsheet format consisting
    of a header line and a number of rows afterward. The items on the rows are separated
    by commas, hence the term *comma-separated value*. Some CSV files will use other
    character values, such as tabs, to separate their values, but the principle is
    the same.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个通用的数据格式——一个所有相关程序都能说的数据“语言”，那么将程序粘合在一起的过程会容易得多。最接近数据交换通用语言的是简单的逗号分隔值（CSV）文件，它是一种由标题行和随后的行数组成的简单电子表格格式。行上的项目由逗号分隔，因此得名*逗号分隔值*。一些CSV文件将使用其他字符值，如制表符，来分隔它们的值，但原理是相同的。
- en: '![](f0145-01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](f0145-01.jpg)'
- en: There are many advantages to using CSV files. CSV is a simple and straightforward
    format, which is important when developing or debugging your system. If you run
    into problems, you can read the file in a text editor. Most programming languages
    will have a library to read and write CSV, and a lot of programs also use CSV
    as an import or export format, so you can reuse all the routines you write for
    one program on the next one. Finally, it also maps reasonably well onto most data—you
    can even think of it as an SQL table—so it’s generally useful in most cases.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CSV文件有许多优点。CSV是一种简单直接格式，这在开发或调试你的系统时很重要。如果你遇到问题，你可以在文本编辑器中读取文件。大多数编程语言都将有一个库来读取和写入CSV，许多程序也将CSV用作导入或导出格式，因此你可以重用为一个程序编写的所有例程。最后，它也很好地映射到大多数数据——你甚至可以将其视为一个SQL表——因此它在大多数情况下都很有用。
- en: '![](f0145-02.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](f0145-02.jpg)'
- en: 'A nice feature of using CSV is that most spreadsheet programs, such as Excel,
    can import it easily, and you can then use them to generate graphs or color-coded
    charts. An important warning, though: many spreadsheet programs will convert data
    into their internal formats when they import, which means your data may get silently
    corrupted. This is particularly important for anything that looks like a date,
    or a string that looks like a number. An employee ID of 00073261, for example,
    would get converted to the number 73,261\. Wherever possible, it’s best to use
    Excel to view data and consider any data that it outputs as tainted. Don’t use
    it for any further work—just the original CSV file.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CSV的一个优点是，大多数电子表格程序，如Excel，可以轻松导入它，然后你可以使用它们来生成图表或彩色编码的图表。不过，有一个重要的警告：许多电子表格程序在导入时会将数据转换为它们的内部格式，这意味着你的数据可能会无声地损坏。这尤其重要对于看起来像日期的任何内容，或者看起来像数字的字符串。例如，员工ID
    00073261会被转换为数字73,261。 wherever possible，最好使用Excel来查看数据，并认为它输出的任何数据都是受污染的。不要用它进行任何进一步的工作——只使用原始的CSV文件。
- en: '|  |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-32
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: If you need to get work done quickly, it’s often quicker to build on systems
    that already exist. Python will let you email a report from one system to your
    program, along with some data from a web page, and dump it into a CSV file or
    database.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要快速完成工作，通常在现有的系统上构建会更快。Python允许你从一个系统将报告通过电子邮件发送到你的程序，以及一些来自网页的数据，并将其导入CSV文件或数据库。
- en: '|  |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Other formats
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 其他格式
- en: In addition to CSV, Python has libraries to read many other formats, all of
    which can be used in data exchange in some way. Here’s a quick list of the most
    common ones; many others are available either in Python’s standard library or
    as add-on packages you can install.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 除了CSV之外，Python还有库可以读取许多其他格式，所有这些格式都可以以某种方式用于数据交换。以下是一个快速列表，其中最常见的一些；许多其他格式要么在Python的标准库中可用，要么作为你可以安装的附加包。
- en: Html
  id: totrans-37
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Html
- en: You might not realize it, but HTML is a data format, and most programming languages
    have libraries that let you write programs that behave as if they were web browsers,
    reading HTML and posting data back via HTTP, POST, or GET requests. Python has
    several libraries available to download and interpret web pages and send data
    back in this way. In the next section, we’ll look at how you can download a web
    page using Python’s built-in *urllib* library and then extract stock prices from
    it using an add-on module called Beautiful Soup.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能没有意识到，但HTML是一种数据格式，大多数编程语言都有库允许你编写表现得像网络浏览器的程序，读取HTML并通过HTTP、POST或GET请求发送数据。Python有几个库可用于下载和以这种方式解释网页，并发送数据。在下一节中，我们将探讨如何使用Python内置的*urllib*库下载网页，然后使用名为Beautiful
    Soup的附加模块从中提取股票价格。
- en: Json, Yaml, and Microformats
  id: totrans-39
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Json, Yaml, and Microformats
- en: If you need more structured data, such as a nested tree or a network of object,
    then CSV might not be the best fit. Other formats, such as JSON and YAML, are
    more general.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要更结构化的数据，例如嵌套树或对象网络，那么CSV可能不是最佳选择。其他格式，如JSON和YAML，更为通用。
- en: Sqlite
  id: totrans-41
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Sqlite
- en: If you might be upgrading your data storage to a database or you need your data
    access to be fast, then you might want to consider SQLite, which is included in
    the Python standard library as of version 2.6\. It provides a subset of the SQL
    commands that you would expect to find in databases such as MySQL or PostgreSQL,
    and saves its data to a local file. Many programs such as Mozilla, Skype, and
    the iPhone use SQLite as a data-storage format.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你可能需要将数据存储升级到数据库，或者你需要快速访问数据，那么你可能想要考虑SQLite，自Python 2.6版本起它包含在Python标准库中。它提供了你预期在MySQL或PostgreSQL等数据库中找到的SQL命令的子集，并将数据保存到本地文件。许多程序，如Mozilla、Skype和iPhone，都使用SQLite作为数据存储格式。
- en: Mailboxes (Mbox)
  id: totrans-43
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 邮箱（Mbox）
- en: Python is also capable of reading most common mailbox formats, such as mbox
    and maildir, and parsing the messages within them, including extracting attachments
    and reading multipart MIME messages. Anything you receive via email can be read,
    interpreted, and acted on. Python is also capable of acting as a normal mail reader,
    via add-on libraries like getmail, and can send emails back out via SMTP.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Python也能够读取大多数常见的邮箱格式，如mbox和maildir，并解析其中的邮件，包括提取附件和读取多部分MIME消息。通过电子邮件接收到的任何内容都可以被读取、解释并采取行动。Python还可以通过附加库如getmail作为普通邮件阅读器，并通过SMTP发送邮件。
- en: '![](f0147-01.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](f0147-01.jpg)'
- en: Xml
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Xml
- en: Python supports reading, writing, and parsing XML files, as well as XML Remote
    Procedure Call (XMLRPC) services. The latest version of Python, version 2.6, includes
    ElementTree, which is an easy and powerful library for dealing with XML.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Python支持读取、写入和解析XML文件，以及XML远程过程调用（XMLRPC）服务。Python的最新版本，2.6版本，包括ElementTree，这是一个处理XML的简单而强大的库。
- en: Any program you need to interface with will have its own way of doing things,
    so it’s important to know what libraries are available to output the formats the
    program wants, and, conversely, to read in the formats it outputs. Fortunately,
    Python can handle a wide variety of formats very easily. Let’s move on and take
    a look at the tools you’ll be using in this chapter.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要与之交互的任何程序都会有自己的操作方式，因此了解可用于输出程序所需格式的库以及相反地读取它输出的格式是很重要的。幸运的是，Python可以轻松处理各种格式。让我们继续前进，看看你将在本章中使用到的工具。
- en: Getting started
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开始使用
- en: 'Your first task is to look at the data that’s exported by the program you want
    to interface with. In this case, you’d like to interface with Yahoo’s stock-tracking
    site, which you can access at [http://finance.yahoo.com/q?s=GOOG](http://finance.yahoo.com/q?s=GOOG),
    and report on some of the statistics of the stock price over time. That link gives
    you the results for Google, but feel free to pick a different one, such as IBM
    or AAPL (Apple). You might be called on to interface with an entirely different
    site, but the general principles here will hold. You’ll be using two main tools
    when parsing: Beautiful Soup, to let Python read HTML, and Firebug, to help you
    inspect the site’s HTML and figure out which elements you want to extract.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你的第一个任务是查看你想要与之交互的程序导出的数据。在这种情况下，你希望与雅虎的股票跟踪网站交互，你可以通过[http://finance.yahoo.com/q?s=GOOG](http://finance.yahoo.com/q?s=GOOG)访问它，并报告股票价格随时间的一些统计数据。该链接提供了谷歌的结果，但你可以自由选择不同的股票，如IBM或AAPL（苹果）。你可能需要与一个完全不同的网站交互，但这里的一般原则仍然适用。在解析时，你将使用两个主要工具：Beautiful
    Soup，让Python读取HTML，以及Firebug，帮助你检查网站的HTML并确定你想要提取的元素。
- en: Installing Beautiful Soup
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安装Beautiful Soup
- en: Beautiful Soup is a Python library that’s designed to be easy to use, but it
    also handles a wide variety of HTML markup, including “pathologically bad” markup.
    Often, you won’t have a choice about which page you want to scrape, so it pays
    to pick a library like Beautiful Soup that isn’t too fussy about the HTML it’s
    given.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Beautiful Soup是一个设计得易于使用的Python库，但它也能处理各种HTML标记，包括“病态的坏”标记。通常，你不会有选择你想要抓取的页面的自由，所以选择一个对所提供的HTML不太挑剔的库，如Beautiful
    Soup，是值得的。
- en: Beautiful Soup is available from [www.crummy.com/software/BeautifulSoup/](http://www.crummy.com/software/BeautifulSoup/).
    To install it, download the file to your desktop and unzip it; then, from within
    a command prompt window, *cd* into the directory and run *python setup.py install*.
    If you’re on Linux or Mac, you’ll need to prefix this with *sudo*; and if you
    use Windows, you’ll need to run the terminal application with administrator privileges.
    Beautiful Soup will then install itself into Python’s site-packages folder so
    you can use it from anywhere. To make sure it’s installed properly, open a Python
    command prompt and type *import BeautifulSoup*. If there’s no error, you’re good
    to go!
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[Beautiful Soup](http://www.crummy.com/software/BeautifulSoup/) 可以从 [www.crummy.com/software/BeautifulSoup/](http://www.crummy.com/software/BeautifulSoup/)
    获取。要安装它，请将文件下载到您的桌面并解压；然后，在命令提示符窗口中，使用 *cd* 命令进入该目录并运行 *python setup.py install*。如果您使用的是
    Linux 或 Mac，您需要在命令前加上 *sudo*；如果您使用的是 Windows，您需要以管理员权限运行终端应用程序。Beautiful Soup
    将会自动安装到 Python 的 site-packages 文件夹中，这样您就可以在任何地方使用它了。为了确保它已正确安装，打开 Python 命令提示符并输入
    *import BeautifulSoup*。如果没有错误，您就可以开始了！'
- en: Installing Firefox and Firebug
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安装 Firefox 和 Firebug
- en: The other tool you need is Firefox, which is a more open and standards-compliant
    browser than Internet Explorer. That will help you when you’re looking at the
    code of web pages. You can get Firefox from [http://getfirefox.com/](http://getfirefox.com/).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要另一个工具，那就是 Firefox，它比 Internet Explorer 更开放、更符合标准。当您查看网页代码时，这将很有帮助。您可以从 [http://getfirefox.com/](http://getfirefox.com/)
    获取 Firefox。
- en: '![](f0148-01.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](f0148-01.jpg)'
- en: Firebug provides a lot of extra development features for the Firefox web browser.
    It isn’t essential for your task, but it does make interacting with the HTML of
    web pages a lot easier. You can download it by visiting [http://getfirebug.com/](http://getfirebug.com/)
    in Firefox and clicking the big Install Firebug button. You might need to change
    your settings to allow Firefox to install from that particular site, but other
    than that, everything should be automatic. When you’re done and Firefox has restarted,
    you’ll see a small bug icon in the lower-right corner of your Firefox window,
    and you’ll have extra options when you right-click some elements of your page.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Firebug 为 Firefox 网络浏览器提供了许多额外的开发功能。它对您的任务不是必需的，但它确实使与网页 HTML 的交互变得更加容易。您可以通过访问
    Firefox 中的 [http://getfirebug.com/](http://getfirebug.com/) 并点击大型的“安装 Firebug”按钮来下载它。您可能需要更改设置以允许
    Firefox 从该特定网站安装，但除此之外，一切应该都是自动的。当您完成操作并且 Firefox 重新启动后，您将在 Firefox 窗口的右下角看到一个小的虫子图标，当您右键单击页面的一些元素时，您将会有额外的选项。
- en: Examining the page
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 检查页面
- en: Now that you’ve got Firebug installed, you can look at the elements you’d like
    to be able to export in your Python script. If you right-click a section of one
    of Yahoo’s finance pages, such as the title of the stock, and select Inspect Element,
    the bottom half of the window should open and show you the HTML corresponding
    to the title. It will be something like
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经安装了 Firebug，您可以查看您想在 Python 脚本中导出的元素。如果您在雅虎财经页面的一部分（如股票标题）上右键单击，并选择“检查元素”，窗口的下半部分应该会打开并显示与标题对应的
    HTML。它看起来可能像这样
- en: '[PRE0]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[Figure 5.2](#ch05fig02) shows what it looks like in my browser.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5.2](#ch05fig02) 展示了在我的浏览器中的样子。'
- en: Figure 5.2\. Examining elements using Firebug
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.2\. 使用 Firebug 检查元素
- en: '![](05fig02_alt.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](05fig02_alt.jpg)'
- en: You can use a similar process when examining other elements of the page to find
    out what their HTML looks like. If you’re not sure which parts of the HTML correspond
    to particular elements of the page, you can hover your mouse over either the HTML
    or the element you’re interested in. Firebug will highlight the relevant sections
    of the page, as you can see in [figure 5.3](#ch05fig03).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用类似的过程检查页面上的其他元素，以找出它们的 HTML 看起来是什么样子。如果您不确定 HTML 的哪些部分对应于页面的特定元素，您可以将鼠标悬停在
    HTML 或您感兴趣的元素上。Firebug 将突出显示页面上的相关部分，正如您在 [图 5.3](#ch05fig03) 中可以看到的那样。
- en: Figure 5.3\. Using Firebug with highlighting
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.3\. 使用 Firebug 并突出显示
- en: '![](05fig03_alt.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](05fig03_alt.jpg)'
- en: Now that you know how to use Firebug to examine a page and find the elements
    you’re looking for, extracting data from the HTML will be a lot easier.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经知道如何使用 Firebug 检查页面并找到您要查找的元素，从 HTML 中提取数据将会容易得多。
- en: '![](f0150-01.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](f0150-01.jpg)'
- en: Downloading the page with Python
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Python 下载页面
- en: You’ll start out by downloading the entire page using Python’s *urllib2* module,
    as shown in the following listing. You’ll do this by writing a function that will
    return the HTML code for any stock page you name. This will be an easily reusable
    function that you can paste directly into the final script.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你将开始使用 Python 的 *urllib2* 模块下载整个页面，如下面的列表所示。你将通过编写一个函数来实现，该函数将返回任何你命名的股票页面的
    HTML 代码。这将是一个易于重用的函数，你可以直接将其粘贴到最终的脚本中。
- en: Listing 5.1\. Downloading a web page
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.1\. 下载网页
- en: '![](05list01_alt.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![05list01_alt.jpg](05list01_alt.jpg)'
- en: '*urllib* uses *opener* objects to read web pages. Here, you’re creating one
    ![](one.jpg) and feeding it two handlers, which are objects that handle certain
    types of HTTP responses from the web server. *HTTPRedirectHandler* will automatically
    follow redirects, so if a page has moved temporarily, you don’t have to worry
    about writing code to follow it. *HTTPHandler* will read any web pages that are
    returned.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*urllib* 使用 *opener* 对象来读取网页。在这里，你创建了一个 ![one.jpg](one.jpg) 并向它提供了两个处理器，这些处理器是处理来自网络服务器特定类型
    HTTP 响应的对象。*HTTPRedirectHandler* 将自动跟随重定向，所以如果一个页面临时移动了，你不必担心编写代码来跟随它。*HTTPHandler*
    将读取返回的任何网页。'
- en: '![](f0152-01.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![f0152-01.jpg](f0152-01.jpg)'
- en: Unfortunately, some websites like to block automated agents like this, so to
    be on the safe side you’re being sneaky here and setting the user agent you send
    to the server so you appear to be a completely different web browser ![](three.jpg).
    In this case, you’re pretending to be Internet Explorer 7 running on Windows XP.
    You can find other user agent strings by doing a web search for “user agent strings.”
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，一些网站喜欢阻止这样的自动化代理，所以为了安全起见，你在这里要小心行事，并设置发送给服务器的用户代理，以便你看起来像是一个完全不同的网络浏览器
    ![three.jpg](three.jpg)。在这种情况下，你假装在 Windows XP 上运行 Internet Explorer 7。你可以通过在网络上搜索“用户代理字符串”来找到其他用户代理字符串。
- en: Now all you need to do to be able to read a web page is call the opener’s *open()*
    method with a URL ![](three.jpg). That method returns a file-like object that
    which responds exactly like an open file, so you can get the text of the web page
    by calling *readlines()* and joining its response together.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你只需要调用打开器的 *open()* 方法并传入一个 URL ![three.jpg](three.jpg)，就可以读取网页了。该方法返回一个类似文件的对象，它响应方式与打开的文件完全一样，因此你可以通过调用
    *readlines()* 并将其响应拼接起来来获取网页的文本。
- en: It’s easy to call the function now ![](four.jpg), and all the tricky *urllib*
    parts are hidden away. If you run this script, it will print out the entire contents
    of the [http://finance.yahoo.com/q?s=GOOG](http://finance.yahoo.com/q?s=GOOG)
    page on the screen.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在调用这个函数很容易 ![four.jpg](four.jpg)，并且所有复杂的 *urllib* 部分都被隐藏起来了。如果你运行这个脚本，它将在屏幕上打印出
    [http://finance.yahoo.com/q?s=GOOG](http://finance.yahoo.com/q?s=GOOG) 页面的全部内容。
- en: '|  |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: In Python 3.0, the *urllib*, *urllib2*, *urlparse*, and *robotparse* modules
    have all been merged into *urllib*, and several improvements have been made. The
    methods you’re using here have been moved into the *urllib.request* module, but
    other than that, they’re the same.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 3.0 中，*urllib*、*urllib2*、*urlparse* 和 *robotparse* 模块都被合并到了 *urllib*
    中，并且进行了一些改进。你在这里使用的方法已经被移动到了 *urllib.request* 模块中，但除此之外，它们是相同的。
- en: '|  |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The entire content of the page is a little much for what you’re trying to do.
    You’re only interested in the part that has the stock price. You need to limit
    the result to the section of the page you’re interested in.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 页面的全部内容对于你想要做的事情来说有点多。你只对包含股价的部分感兴趣。你需要将结果限制在页面中你感兴趣的部分。
- en: Chopping out the bit you need
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 切割出你需要的内容
- en: Let’s get your feet wet with Beautiful Soup and parse out only the quote element
    you’re interested in and print it. Once you’ve done that, you can start pulling
    out individual elements for the final output.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用 Beautiful Soup 来练习，只解析出你感兴趣的报价元素并打印出来。一旦你完成了这个操作，你就可以开始提取单个元素以生成最终的输出。
- en: Most of the time, you can simplify your parsing by looking for landmarks in
    the web page’s HTML. Normally there will be ID and class attributes that you can
    use to pinpoint a particular section and then narrow down your search from there.
    In this case, it looks like there’s a *<div>* element with a class of *yfi_quote_summary*
    that contains all the information you need. The following listing features a function
    that uses Beautiful Soup to pull only that section out of your stock page.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，你可以通过在网页的 HTML 中寻找地标来简化你的解析。通常会有 ID 和 class 属性，你可以使用它们来定位特定的部分，然后从那里缩小搜索范围。在这种情况下，看起来有一个
    *<div>* 元素，其类为 *yfi_quote_summary*，包含了你需要的所有信息。下面的列表展示了一个使用 Beautiful Soup 从股票页面中提取该部分的函数。
- en: Listing 5.2\. Finding the quote section
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.2\. 查找报价部分
- en: '![](05list02_alt.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![05list02_alt.jpg](05list02_alt.jpg)'
- en: The first thing you need to do when parsing HTML is to create a Beautiful Soup
    object ![](one.jpg). This object looks at all of the HTML it’s fed and provides
    lots of methods for you to examine, search through, and navigate it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 解析HTML时，你需要做的第一件事是创建一个Beautiful Soup对象 ![one.jpg](one.jpg)。这个对象会查看所有输入的HTML，并提供许多方法供你检查、搜索和导航。
- en: The *soup* object provides a *find()* method, which can quickly search through
    the HTML. Here, you’re finding all the *<div>* elements that also have a class
    of *yfi_quote_summary* ![](three.jpg). The *find()* command returns the first
    element it finds that matches the criteria, but as another *soup* object, so you
    can perform further searching if you need to.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*soup*对象提供了一个*find()*方法，可以快速搜索HTML。在这里，你正在寻找所有具有*yfi_quote_summary*类的*<div>*元素
    ![three.jpg](three.jpg)。*find()*命令返回第一个符合标准的元素，但作为另一个*soup*对象，因此如果你需要进一步搜索，可以继续使用。'
- en: '![](f0153-01.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![f0153-01.jpg](f0153-01.jpg)'
- en: As a shortcut, if you print a *soup* object ![](three.jpg) it will return a
    string containing its HTML. In your case, this is exactly what you’re looking
    for—the HTML of the *yfi_quote_summary* *<div>*.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 作为快捷方式，如果你打印一个*soup*对象 ![three.jpg](three.jpg)，它将返回包含其HTML的字符串。在你的情况下，这正是你想要的——*yfi_quote_summary*
    *<div>*的HTML。
- en: If you run this script, it should print out a much shorter piece of HTML, which
    is the quote section you’re looking for. You should be able to see some sections
    like the stock name and price, and some of the other *<div>* elements. Let’s now
    add another function that will take the *soup* object for the summary *<div>*
    and produce more meaningful data.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个脚本，它应该会打印出一个更短的HTML片段，这就是你正在寻找的报价部分。你应该能看到一些部分，如股票名称和价格，以及其他*<div>*元素。现在让我们添加另一个函数，它将接受摘要*<div>*的*soup*对象并生成更有意义的数据。
- en: Adding extra information
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加额外信息
- en: Now that you have the smaller section of HTML, you can examine it further and
    pull out the specific parts you need. The *find()* command will return another
    *soup* object, so you don’t have to worry about parsing it again—you can call
    the *find()* method on the results to extract the data you need. The following
    listing shows a function that uses a number of *find()* calls to build a dictionary
    of data from your stock page.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了更小的HTML部分，你可以进一步检查它并提取所需的特定部分。*find()*命令将返回另一个*soup*对象，因此你不必担心再次解析它——你可以在结果上调用*find()*方法来提取所需的数据。以下列表显示了一个使用多个*find()*调用从股票页面构建数据字典的函数。
- en: Listing 5.3\. Extracting the data for the stock
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.3\. 提取股票数据
- en: '![](ch05list3-0.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![ch05list3-0.jpg](ch05list3-0.jpg)'
- en: '![](ch05list3-1.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![ch05list3-1.jpg](ch05list3-1.jpg)'
- en: 'Does this look familiar? It’s the old divide-and-conquer strategy again: write
    something simple that works, and then refine it a bit at a time until you have
    the data you need.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来熟悉吗？这又是古老的分而治之策略：先写一个简单的能工作的东西，然后逐步改进，直到你得到所需的数据。
- en: You might find it helpful to include the HTML you’re trying to match as comments,
    like ![](one.jpg). It saves switching back and forth between your editor window
    and your web browser to remind yourself what the HTML looks like.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会发现将你试图匹配的HTML作为注释很有帮助，就像 ![one.jpg](one.jpg) 这样。这可以节省在编辑器窗口和网页浏览器之间切换来回提醒自己HTML看起来像什么。
- en: Next, you run a simple find over your quote summary to find the first *h2* element
    ![](two.jpg). Once you’ve done that, you get the first element from the. *contents*
    attribute, which in this case will be the name of your stock. The .*contents*
    attribute returns all the sub-elements within a particular element as a list of
    *soup* objects.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以在报价摘要上运行一个简单的find命令来找到第一个*h2*元素 ![two.jpg](two.jpg)。一旦完成，你就可以从.*contents*属性中获取第一个元素，在这个例子中将是股票名称。.*contents*属性返回特定元素内的所有子元素，作为一个*soup*对象列表。
- en: Notice that in the HTML, the IDs you’re looking for are named after the company.
    That’s not much of a problem, because you can pass in the ticker name and make
    it lowercase ![](three.jpg). You’re also using the *.string* method. If you’re
    certain there will only ever be one text node within your search results, you
    can use the *.string* shortcut, which will return that node as text.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在HTML中，你正在寻找的ID是以公司命名的。这并不是什么大问题，因为你可以传入股票代码并将其转换为小写 ![three.jpg](three.jpg)。你还在使用*.string*方法。如果你确定搜索结果中只有一个文本节点，你可以使用*.string*快捷方式，它将返回该节点作为文本。
- en: If you have a close look at the search here and the corresponding HTML in Firebug
    ![](four.jpg), you might notice they’re different. The code seems to be ignoring
    the extra span you can see in the browser. The answer is that sometimes, when
    HTML is invalid, Firebug will insert extra elements to make the HTML code valid.
    That’s not a problem for Beautiful Soup, though, which returns both the image
    and text as two elements. If in doubt, you can always view the source of the page
    from the browser itself and search for the ID or class of the element to see the
    HTML exactly as you received it from the server.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细查看这里的搜索结果和Firebug中的相应HTML ![图片](four.jpg)，你可能会注意到它们是不同的。代码似乎忽略了浏览器中可以看到的额外span。答案是，有时当HTML无效时，Firebug会插入额外的元素以使HTML代码有效。但对于Beautiful
    Soup来说，这并不是问题，因为它将图像和文本作为两个元素返回。如果有疑问，你总是可以从浏览器本身查看页面的源代码并搜索元素的ID或类，以查看从服务器接收到的HTML的确切内容。
- en: '![](f0155-01.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图片](f0155-01.jpg)'
- en: If you need more flexibility in how you search, then another way you can use
    Beautiful Soup’s *find()* method is to use a function instead of a string ![](five.jpg).
    Beautiful Soup will feed the function the attribute name—if the function returns
    *True*, then the element is included.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要更多的搜索灵活性，那么你可以使用Beautiful Soup的 *find()* 方法的一种方式是使用一个函数而不是一个字符串 ![图片](five.jpg)。Beautiful
    Soup会将属性名称传递给函数——如果函数返回 *True*，则该元素被包含。
- en: 'Using the function from ![](five.jpg) when searching is easy: just use the
    function ![](six.jpg) instead of the string. In this section you’re also chaining
    *find()* calls together. The first *find()* looks for elements with an ID of *yfs_c10_goog*
    and returns another Beautiful Soup object, which you use to immediately run another
    *find()* command. The whole set of calls is contained in brackets so you can wrap
    it over multiple lines and make it easier to understand.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在搜索时使用 ![图片](five.jpg) 中的函数很简单：只需使用函数 ![图片](six.jpg) 而不是字符串。在本节中，你还将链式调用 *find()*。第一个
    *find()* 查找ID为 *yfs_c10_goog* 的元素，并返回另一个Beautiful Soup对象，然后你立即运行另一个 *find()* 命令。整个调用集包含在括号中，这样你可以将其展开到多行，使其更容易理解。
- en: 'You can continue in this vein until you’ve extracted all the data you need
    from the page. Be careful that your parsing doesn’t grow too unwieldy. If it does,
    you may want to consider breaking *parse_stock_html* into functions, one per data
    value, and looping over a dictionary of data value names and functions when you’re
    parsing:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以继续这样做，直到从页面中提取出所有你需要的数据。注意，你的解析过程不要变得过于复杂。如果变得复杂，你可能需要考虑将 *parse_stock_html*
    分解成函数，每个数据值一个函数，并在解析时遍历一个包含数据值名称和函数的字典：
- en: '[PRE1]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Caveats for web scraping
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 网络爬取的注意事项
- en: Although reading data directly from the web is a useful tool, it’s not without
    its drawbacks. The main issue is that web pages change frequently, and your parsing
    code may need to change with it. You can lessen the risk somewhat by focusing
    on the elements of the page least likely to change, such as ID or class variables,
    but you’re still at the mercy of whoever creates the page. If at all possible,
    it’s usually much better in the long term if you can rely on official channels,
    such as a published API for accessing data, rather than doing it all yourself.
    Later, we’ll look at strategies for dealing with failures in your script and how
    you can mitigate them.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然直接从网络读取数据是一个有用的工具，但它并非没有缺点。主要问题是网页经常变化，你的解析代码可能需要随之改变。你可以通过关注页面最不可能变化的元素来降低风险，例如ID或类变量，但你仍然受制于创建网页的人。如果可能的话，从长远来看，通常更好的做法是依靠官方渠道，例如使用发布的API来访问数据，而不是自己全部完成。稍后，我们将探讨处理脚本失败的战略以及如何减轻它们。
- en: But first, you need to add some complexity to your tool.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，你需要给你的工具增加一些复杂性。
- en: Writing out to a CSV file
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 写入CSV文件
- en: An individual stock price isn’t useful. To make any recommendations about whether
    it’s good to buy or sell, or what the stock is likely to do in the future, you’d
    like some history of the stock price and its movement. That means you need to
    save the data you’ve just read so you can use it again in future. As we said in
    the section “CSV to the rescue!,” the most common data format is a CSV file. The
    following listing will save your results dictionary to a row in a CSV file.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 单个股票价格没有用处。为了对是否购买或出售提出建议，或者预测股票未来的走势，你需要一些股票价格及其变动的历史记录。这意味着你需要保存你刚刚读取的数据，以便将来再次使用。正如我们在“CSV来帮忙！”一节中所述，最常见的数据格式是CSV文件。下面的代码将把你的结果字典保存到CSV文件中的一行。
- en: Listing 5.4\. Writing a CSV file
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.4\. 编写CSV文件
- en: '![](ch05list4-0.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch05list4-0.jpg)'
- en: '![](ch05list4-1.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch05list4-1.jpg)'
- en: Before you start creating your CSV file, you need to know which key-value pairs
    in the dictionary correspond to which headers in the CSV file ![](one.jpg). Storing
    them in a dictionary means you can easily access them later. Dictionaries aren’t
    guaranteed to be in a specific order, though, so there’s another list to tell
    you what order the columns should be in.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始创建CSV文件之前，你需要知道字典中的哪些键值对对应于CSV文件中的哪些标题 ![图片](one.jpg)。将它们存储在字典中意味着你可以轻松地稍后访问它们。不过，字典不保证有特定的顺序，所以还有一个列表告诉你列应该以什么顺序出现。
- en: '![](f0158-01.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](f0158-01.jpg)'
- en: When you write the file, you’ll name it after the stock you’re tracking so it’s
    easier to find and so any other scripts will be able to easily access it. You
    also need to know whether you’ve written to this file before, so you can add the
    headers to it if necessary. *os.access* does the trick, and you need to know whether
    it exists ![](two.jpg).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当你写入文件时，你会根据你正在跟踪的股票给它命名，这样更容易找到，并且任何其他脚本都可以轻松访问它。你还需要知道你是否已经向此文件写入过，这样你就可以在必要时向它添加标题。*os.access*可以做到这一点，你需要知道它是否存在
    ![图片](two.jpg)。
- en: '*csv.DictWriter* is a class that writes dictionaries into a CSV file ![](three.jpg).
    It needs two arguments to function: a file opened in binary mode and a list of
    the fields in the order that they should appear in the CSV file. I’ve also added
    an *extrasaction* argument, which tells *DictWriter* whether it should ignore
    extra values in the dictionary or raise an exception. In this case, you have an
    extra *stock_name* field that you’d rather not have appear over and over again
    in the CSV file, so you’ll ignore it.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*csv.DictWriter*是一个将字典写入CSV文件的类 ![图片](three.jpg)。它需要两个参数来运行：以二进制模式打开的文件和一个列表，其中包含它们在CSV文件中应该出现的顺序。我还添加了一个*extrasaction*参数，它告诉*DictWriter*是否应该忽略字典中的额外值或引发异常。在这种情况下，你有一个额外的*stock_name*字段，你希望它不要在CSV文件中反复出现，所以你会忽略它。'
- en: 'Once the *DictWriter* object is created, using it to write a row is easy ![](four.jpg):
    feed it a dictionary to write. If any keys are missing, though, an error will
    be raised.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了*DictWriter*对象，使用它来写入一行就很简单 ![图片](four.jpg)：给它提供一个字典来写入。但是，如果任何键缺失，则会引发错误。
- en: You’re also interested in when a particular stock record was retrieved. In Python,
    here’s how you output the current local time and date ![](five.jpg). The *%Y*
    *%H* parts of the string will be replaced with the current year, hour, and so
    on. You can arrange them in any order you like, as long as you keep the *%* signs
    together with their corresponding character.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你也对特定股票记录的检索时间感兴趣。在Python中，这是输出当前本地时间和日期的方法 ![图片](five.jpg)。字符串中的*%Y* *%H*部分将被当前年份、小时等替换。你可以按任何顺序排列它们，只要保持*%*符号与其对应字符在一起。
- en: Now you have a CSV file that will be updated every time you run your script.
    If you run it several times, you’ll see extra lines being appended to the end.
    Typically, you’d automate this script using cron (if you’re using Linux or Mac),
    or Windows Scheduler or similar if you’re running on Windows. You can stop at
    this point for some scripts, but if the results are important, you’ll want to
    make sure other people know about them.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有一个CSV文件，每次运行你的脚本时都会更新。如果你多次运行它，你会在末尾看到额外的行被附加。通常，你会使用cron（如果你使用Linux或Mac）或Windows
    Scheduler或类似的工具来自动化这个脚本。对于一些脚本，你可以在这里停止，但如果结果很重要，你想要确保其他人知道这些结果。
- en: Next, let’s figure out how to create an email with your CSV file.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何使用你的CSV文件创建电子邮件。
- en: Emailing the CSV file
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发送CSV文件
- en: If you need to do anything with email, the `email` module is normally the place
    to start. It contains classes and functions for parsing email and extracting their
    information as well as tools for creating and encoding emails, even the creation
    of multipart emails containing HTML, text (if the recipient can’t read HTML),
    and attachments. Normally you’d start with a simple section and build up, but
    when creating an email it’s easier to remove the sections you don’t need.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要用电子邮件做任何事情，通常情况下，`email`模块是开始的地方。它包含了解析电子邮件和提取其信息的类和函数，以及创建和编码电子邮件的工具，甚至包括包含HTML、文本（如果收件人不能阅读HTML）和附件的多部分电子邮件。通常，你会从一个简单的部分开始，逐步构建，但在创建电子邮件时，删除不需要的部分会更简单。
- en: Creating an email is straightforward, but it definitely helps if you have some
    background knowledge of how emails work. Let’s take a look at that first, and
    then you’ll see how to put it into practice in your program.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 创建电子邮件很简单，但如果你对电子邮件的工作原理有一些背景知识，那就更有帮助了。让我们先看看这一点，然后你将看到如何在你的程序中将其付诸实践。
- en: Email structure
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 电子邮件结构
- en: Most emails, other than the simplest plain-text emails, are composed of containers,
    with parts within them. These parts can be text, HTML, or any other part that
    can be described with a MIME type. When the email is sent, the email structure
    will be converted into a plain text format that can be reassembled when it reaches
    its destination.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数电子邮件，除了最简单的纯文本电子邮件外，都是由容器组成的，其中包含部分内容。这些部分可以是文本、HTML或任何可以用MIME类型描述的部分。当电子邮件发送时，电子邮件结构将被转换为纯文本格式，以便在到达目的地时重新组装。
- en: 'Normally, there will be at least two parts: one that contains your email in
    HTML, and another that contains a text version—but an email can in theory contain
    as many different parts as you need. The structure I’ve found most useful, and
    that displays the best across a variety of email programs, is in [figure 5.4](#ch05fig04).'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，至少会有两个部分：一个包含HTML格式的电子邮件，另一个包含文本版本——但理论上，一封电子邮件可以包含你需要的任意多个不同部分。我发现最有用，并且在各种电子邮件程序中显示效果最好的结构是[图5.4](#ch05fig04)中的结构。
- en: Figure 5.4\. The structure of a HTML email
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.4\. HTML电子邮件的结构
- en: '![](05fig04.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![05fig04.jpg](05fig04.jpg)'
- en: '![](f0159-01.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![f0159-01.jpg](f0159-01.jpg)'
- en: This structure has two containers. The outside one contains the message part
    and any number of attachments, and the inside container has the two versions of
    your email. If you need extra attachments, attach them to the outside container.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构有两个容器。外部容器包含消息部分和任意数量的附件，内部容器包含你电子邮件的两个版本。如果你需要额外的附件，可以将它们附加到外部容器中。
- en: Creating an email
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建电子邮件
- en: Now that you know how MIME messages are constructed, let’s take a look at the
    corresponding program in the following listing. This function will take an email
    address and a stock ticker name, such as “GOOG,” and construct an email ready
    to be sent.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何构建MIME消息，让我们看看下面列表中相应的程序。这个函数将接受一个电子邮件地址和一个股票代码名称，例如“GOOG”，并构建一个准备发送的电子邮件。
- en: Listing 5.5\. Creating a MIME email
  id: totrans-136
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.5\. 创建MIME电子邮件
- en: '![](ch05list5-0.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![ch05list5-0.jpg](ch05list5-0.jpg)'
- en: '![](ch05list5-1.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![第五章列表5-1](ch05list5-1.jpg)'
- en: The first thing you need to do is to create the external container ![](one.jpg)
    that will contain all the other parts. It’s also where you put all the message
    headers—the Subject, To, and From lines.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 首先你需要做的是创建一个外部容器 ![one.jpg](one.jpg)，它将包含所有其他部分。这也是放置所有消息头——主题、收件人和发件人——的地方。
- en: Next up is the body of the email ![](two.jpg), the HTML and text parts. Normally
    an email program will display the last part of this container as the body, and
    fall back on the others if it can’t handle it, so you put the HTML last.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是电子邮件的正文 ![two.jpg](two.jpg)，包括HTML和文本部分。通常，电子邮件程序会显示这个容器的最后一部分作为正文，如果无法处理，则会回退到其他部分，所以你应该把HTML放在最后。
- en: '![](f0161-01.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![f0161-01.jpg](f0161-01.jpg)'
- en: Now you can create *MIMEText* objects to hold the email body. They’ll automatically
    be of type text/something, and the second argument tells what that something will
    be. Once you have those objects, you call *attach* to insert them into the inner
    container, and then attach the inner container to the outer one ![](three.jpg).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以创建*MIMEText*对象来保存电子邮件正文。它们将自动成为text/something类型，第二个参数告诉了那“something”是什么。一旦你有了这些对象，你可以调用*attach*方法将它们插入到内部容器中，然后将内部容器附加到外部容器上
    ![three.jpg](three.jpg)。
- en: You do the same thing for the CSV section that you did for the body of the email.
    Once you’ve read in the CSV file, you create a text/csv part and insert it into
    the outer section ![](four.jpg). The only extra thing you need to do is add a
    *Content-Disposition* header to say that it’s an attachment, and give it a file
    name. Without a file name, you’ll get a default name like “Part 1.2,” which doesn’t
    look friendly or professional.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为CSV部分做与电子邮件正文相同的事情。一旦你读取了CSV文件，你创建一个text/csv部分并将其插入到外部部分 ![four.jpg](four.jpg)。唯一需要额外做的事情是添加一个*Content-Disposition*头来说明它是一个附件，并给它一个文件名。如果没有文件名，你将得到一个默认名称，如“Part
    1.2”，这看起来既不友好也不专业。
- en: If you want to see what you’ve created, use the *as_string()* method on your
    outer message object, and it will print out the email exactly as it will be sent
    ![](five.jpg). You’ll be writing a *send_message()* function in the next section,
    which you’ll use to send the email via an SMTP server.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要查看你创建的内容，使用你的外部消息对象的*as_string()*方法，它将打印出电子邮件的准确内容，就像它将被发送一样 ![five.jpg](https://example.com/five.jpg)。你将在下一节中编写一个*send_message()*函数，你将使用它通过SMTP服务器发送电子邮件。
- en: That’s all you need to do with the report email; it’s ready to be sent. If you’d
    like to reuse this function, there are a number of things you can do to extend
    it. The first obvious one is to pass in the subject, and text and HTML content,
    as arguments, instead of hard-coding them in the body. Another is to be able to
    pass in more than one attachment, as a list. An important function for this second
    part is *mimetypes.guess_type*, which will give you a MIME type and an encoding
    (such as zip, gzip, or compress) based on the filename of the attachment. From
    there, you can create the right type of MIME object, such as *MIMEApplication*
    or *MIMEImage*, and attach it to the email.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你需要对报告电子邮件所做的所有操作；它已经准备好可以发送了。如果你想要重用这个功能，你可以做很多事情来扩展它。第一个显而易见的做法是将主题、文本和HTML内容作为参数传递，而不是在正文中硬编码它们。另一个做法是能够传递多个附件，作为一个列表。对于这部分的一个重要功能是*mimetypes.guess_type*，它将根据附件的文件名给出一个MIME类型和一个编码（例如zip、gzip或compress）。从那里，你可以创建正确的MIME对象，例如*MIMEApplication*或*MIMEImage*，并将其附加到电子邮件中。
- en: 'By the way, if you’re attaching images, you can link to them from within the
    HTML body by using a *cid:* URL, like this: *<img src= "cid:image_name.gif">*.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，如果你正在附加图片，你可以通过使用一个*cid:* URL从HTML正文中链接到它们，就像这样：<img src="cid:image_name.gif">。
- en: Sending email
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 发送电子邮件
- en: The last thing you need to do with your email is send it. This is the most straightforward
    part of the email sending process and only needs a From address, a list of To
    addresses, and the email itself.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要对你的电子邮件做的最后一件事就是发送它。这是发送电子邮件过程中最直接的部分，只需要一个发件人地址、一个收件人地址列表以及电子邮件本身。
- en: Listing 5.6\. Sending an email
  id: totrans-149
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.6\. 发送电子邮件
- en: '![](05list06_alt.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![05list06_alt.jpg](https://example.com/05list06_alt.jpg)'
- en: First you create an SMTP object, which will handle the sending of your email
    ![](one.jpg). This will normally be enough if you’re connecting to your internet
    service provider’s mail server, normally something like mail.yourisp.com or smtp.yourisp.com—you
    can get it from the “sending email” section of your email program if you don’t
    know what it is. Some ISPs require a username and password for SMTP that you can
    include with a line like *s.login('user', 'password')*.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你创建一个SMTP对象，它将处理你的电子邮件发送 ![one.jpg](https://example.com/one.jpg)。如果你连接到你的互联网服务提供商的邮件服务器，这通常就足够了，通常像mail.yourisp.com或smtp.yourisp.com这样的东西——如果你不知道是什么，你可以从你的电子邮件程序的“发送电子邮件”部分获取它。一些ISP要求SMTP用户名和密码，你可以通过像*s.login('user',
    'password')*这样的行来包含它们。
- en: Once you have an SMTP object, you can call its *sendmail()* method to send email
    ![](two.jpg). You’re pulling the email addresses as well as the body of the email
    out of the message; that way, you don’t have to specify them as separate arguments,
    and your code stays neater. You can call the *sendmail()* method multiple times
    if you need to.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了SMTP对象，你可以调用它的*sendmail()*方法来发送电子邮件 ![two.jpg](https://example.com/two.jpg)。你正在从消息中提取电子邮件地址以及电子邮件正文；这样，你就不需要将它们作为单独的参数指定，你的代码也更整洁。如果你需要，你可以多次调用*sendmail()*方法。
- en: When you’re done you can close the connection ![](three.jpg). This saves some
    load on the SMTP server, because it will have one less connection to keep track
    of—but if you have multiple email messages to send, it’s better to reuse the connection.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成时，你可以关闭连接 ![three.jpg](https://example.com/three.jpg)。这可以节省SMTP服务器的一些负载，因为它将少一个要跟踪的连接——但是如果你有多个电子邮件要发送，最好重用连接。
- en: To create an email to send, you use your *mail_report()* function and feed it
    your email address and the name of the stock . Then you pass it to the *send_message()*
    function to send it ![](four.jpg). If you prefer a weekly report, then you can
    run this on a separate schedule to the script, which reads the web page. If you’d
    like to email multiple people at once, then you still feed one string to *mail_report()*—but
    with commas separating the email addresses.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个要发送的电子邮件，你使用你的*mail_report()*函数，并给它你的电子邮件地址和股票名称。然后你将它传递给*send_message()*函数来发送它
    ![four.jpg](https://example.com/four.jpg)。如果你更喜欢周报，那么你可以运行一个单独的脚本，该脚本读取网页。如果你想要一次性给多个人发邮件，那么你仍然给*mail_report()*函数传递一个字符串——但是用逗号分隔电子邮件地址。
- en: 'That’s all you need to do for your script. It scrapes data from a web page,
    posts it into a CSV file, and then emails a report to someone who can make use
    of the information. A surprisingly large amount of business programming boils
    down to a roughly similar process: gather some data, process it, and then send
    or store the results somewhere, either to a human who needs the information, or
    to another program.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你需要为你的脚本做的所有事情。它从网页上抓取数据，将其发布到CSV文件中，然后将报告通过电子邮件发送给可以利用这些信息的人。出人意料的是，大量的商业编程归结为大致相似的过程：收集一些数据，处理它，然后将结果发送或存储到某个地方，无论是给需要信息的人，还是给另一个程序。
- en: Other email modules
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 其他电子邮件模块
- en: Although you didn’t need them in this script, there are other email-related
    modules you can make use of if you need more flexibility when dealing with email,
    or if you need to do something outside what this script can do. The two that I
    most commonly use, other than the modules in this script, are the *mailbox* module
    and getmail.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在这个脚本中你不需要它们，但如果你在处理电子邮件时需要更多灵活性，或者需要做一些这个脚本无法做到的事情，你可以使用其他与电子邮件相关的模块。除了这个脚本中的模块，我最常用的两个是*邮箱*模块和getmail。
- en: '![](f0163-01.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图片](f0163-01.jpg)'
- en: The *mailbox* module contains classes to read several different types of mailbox,
    including the two most common, *mbox* and *maildir*, and provides an easy way
    to loop over each message in the file. Parsing *mbox* files is relatively easy,
    but there are several catches to it, and it’s easier to use a library. In addition
    to writing emails, the *email* module provides *email.parser* to read the header
    lines, body, and attachments out of a flat text file. Together they provide everything
    you need to be able to handle email.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*邮箱*模块包含用于读取多种不同类型邮箱的类，包括最常用的两种，*mbox*和*maildir*，并提供了一种轻松遍历文件中每条消息的方法。解析*mbox*文件相对简单，但也有一些陷阱，使用库会更方便。除了编写电子邮件，*email*模块还提供了*email.parser*来从平面文本文件中读取标题行、正文和附件。它们一起提供了你处理电子邮件所需的一切。'
- en: Getmail is an add-on module written by Charles Cazabon and available from [http://pyropus.ca/software/getmail/](http://pyropus.ca/software/getmail/).
    It handles POP and IMAP4, including via SSL, and can save messages to mbox or
    maildir storage as well as passing them to another program. It’s also easy to
    use and only requires one configuration file to work.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Getmail是一个由Charles Cazabon编写的附加模块，可以从[http://pyropus.ca/software/getmail/](http://pyropus.ca/software/getmail/)获取。它处理POP和IMAP4，包括通过SSL，可以将消息保存到mbox或maildir存储，也可以将它们传递给另一个程序。它也很容易使用，并且只需要一个配置文件即可工作。
- en: Between Python’s built-in email modules and getmail, you should be able to deal
    with almost any email programming problem that comes your way, whether you need
    to read, download, parse, or analyze email.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python的内置电子邮件模块和getmail之间，你应该能够处理几乎所有你遇到的电子邮件编程问题，无论你需要读取、下载、解析还是分析电子邮件。
- en: A simple script—what could possibly go wrong?
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个简单的脚本——可能出什么问题？
- en: 'There’s a useful question you can ask yourself when completing a project like
    this: “Am I done?”'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成类似这样的项目时，你可以问自己一个有用的问题：“我完成了吗？”
- en: Try it now and see what you think the answer is. Are you done? Would you be
    confident that you could run this script every day and not have to worry about
    it? Would it ever break? If the CEO or director of your company was relying on
    the results of your script, would you be able to sleep at night? Even if your
    script isn’t vital, how would you know it was working? Would you have to babysit
    your script to make sure it worked, perhaps checking the results every few days
    to make sure nothing had gone wrong?
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下，看看你认为答案是什么。你完成了吗？你是否有信心每天运行这个脚本而不用担心它？它会不会出问题？如果你的公司CEO或董事依赖于你脚本的输出结果，你能否安心入睡？即使你的脚本不是至关重要的，你如何知道它在工作？你是否需要像照顾孩子一样照顾你的脚本，可能每隔几天检查一下结果，以确保一切正常？
- en: It’s possible to write a program that works at first but needs so much assistance
    to run that you might as well have not written it in the first place. To keep
    your sanity, try to analyze your program and find as many potential failure points
    as you can.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能编写一个一开始就能工作的程序，但需要如此多的帮助才能运行，以至于你几乎可以认为你一开始就不应该编写它。为了保持你的理智，尝试分析你的程序，并尽可能多地找出潜在的故障点。
- en: '|  |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-167
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: This is the toughest part of writing programs—anything and everything might
    fail in some way, and you have to be ready for the potential consequences. If
    you’ve ever wondered why a lot of programmers and system admins seem like cagey
    pessimists, now you know.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最具挑战性的编程部分——任何事物都有可能以某种方式失败，你必须准备好应对潜在的后果。如果你曾经好奇为什么许多程序员和系统管理员看起来像谨慎的悲观主义者，现在你应该知道了。
- en: '|  |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '![](f0165-01.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](f0165-01.jpg)'
- en: Here’s a list of some possible issues that might break your script. Then, in
    the next section, we’ll look at how you can go about fixing them.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些可能导致你的脚本崩溃的可能问题的列表。然后，在下一节中，我们将探讨如何解决这些问题。
- en: No internet
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 没有互联网
- en: Obviously, if there’s no internet connection, the script won’t be able to download
    the stock page or send email, and there will be nothing you can do about it. But
    what happens exactly? Will your script fail immediately, or will it get halfway
    through and corrupt your data? If you can’t connect for a day, what should appear
    in the CSV file?
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，如果没有互联网连接，脚本将无法下载股票页面或发送电子邮件，对此你无能为力。但具体会发生什么？脚本会立即失败，还是会进行到一半时损坏你的数据？如果你无法连接一天，CSV文件中应该出现什么内容？
- en: Invalid data
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 无效数据
- en: If Yahoo decided to change the design of their site, what would happen to your
    script? If it’s expecting a particular ID within the HTML and that ID is removed,
    then your script will break. Alternately, there could be a partial outage and
    you’ll see null or zero values. Or if the server is under load, you might see
    timeout errors or only receive half a page. How does your script handle that?
    Does it try to parse the error page and fail? Or does it recognize what’s happened?
    In the worst case, it will have data that looks similar to the data you’re expecting,
    you won’t notice it’s changed, and your data will be silently corrupted.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果雅虎决定更改其网站的设计，你的脚本会发生什么？如果它期望在HTML中找到特定的ID，而这个ID被移除了，那么你的脚本将会崩溃。或者，可能会有部分中断，你将看到空值或零值。或者如果服务器负载过高，你可能会看到超时错误或只收到半页内容。你的脚本如何处理这种情况？它会尝试解析错误页面并失败，还是会识别发生了什么？在最坏的情况下，它可能会得到看起来与你期望的数据相似的数据，你不会注意到它已经改变，你的数据将会被无声地损坏。
- en: Data you haven’t thought of
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 你未考虑到的数据
- en: 'There’s another failure mode related to invalid data: sometimes you can be
    given data that’s valid, but only within the range you’re expecting. It might
    also be formatted or presented differently if it’s within a certain range or currently
    unknown. These sorts of values are generally known as *edge cases*. They don’t
    happen often, so they can be harder to predict, but they still have a large effect
    on the stability of your program. The best way to deal with edge cases is to try
    to consider the entirety of the range of your data and include any cases that
    are in doubt into your test suite.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 与无效数据相关的另一种故障模式是：有时你可能会得到一些看似有效但仅在你期望的范围内有效的数据。如果它处于某个特定范围内或目前未知，它的格式或呈现方式可能也会不同。这类值通常被称为*边缘情况*。它们并不经常发生，因此可能更难以预测，但它们仍然会对程序稳定性产生重大影响。处理边缘情况的最佳方式是尝试考虑你数据的整个范围，并将任何存疑的案例纳入你的测试套件中。
- en: Unable to write data
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 无法写入数据
- en: 'When you’re processing, you’re assuming you’ll be able to write to the CSV
    file. This is normally the case, but there are some circumstances where you might
    not be able to: if an administrator on the site has set the wrong permissions,
    or your computer is out of space. You might want to consider rotating your CSV
    files every so often: zip the old ones and delete those that have been around
    the longest (or download and archive them). The exact timeframe will depend on
    both the amount of free space you have on your server and the requirements of
    your program.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在处理数据时，你假设你将能够写入CSV文件。这通常是情况，但在某些情况下，你可能无法做到：如果网站管理员设置了错误的权限，或者你的电脑空间不足。你可能想要考虑不时地轮换你的CSV文件：压缩旧文件，删除那些存在时间最长的文件（或下载并归档它们）。确切的时间表将取决于你服务器上的可用空间以及你程序的要求。
- en: No mail server
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 没有邮件服务器
- en: You can also run into problems when trying to send your email. Most of the time,
    email is pretty foolproof, but it’s possible for a mail server to be down. If
    that’s the case, what happens to your script? It might be enough for it to store
    the row in the CSV file and resend it the next night, or you might need to check
    that the mail server is up and try an alternative route if it isn’t.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试发送电子邮件时，也可能遇到问题。大多数情况下，电子邮件相当可靠，但邮件服务器可能宕机。如果是这种情况，你的脚本会发生什么？可能只是存储CSV文件中的行并在第二天晚上重新发送，或者你可能需要检查邮件服务器是否运行正常，如果不行，尝试其他路线。
- en: You don’t have to fix them
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 你不必修复它们
- en: These are by no means the only things that can go wrong with your script, but
    they’re the most likely. Depending upon your script, its purpose, and the environment
    it runs in, these might be more or less of an issue. Or you might not need to
    worry about them at all. But you still need to consider them.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这些绝不是你脚本可能出错的唯一原因，但它们是最可能发生的。根据你的脚本、其目的以及运行的环境，这些问题可能更多或更少。或者你可能根本不需要担心它们。但无论如何，你仍然需要考虑它们。
- en: Let’s move on and take a look at ways you might solve, or at least mitigate,
    some of these issues.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续前进，看看你可能会解决，或者至少减轻一些这些问题的方法。
- en: How to deal with breaking scripts
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何处理脚本中断问题
- en: There are a number of strategies for dealing with the weak points you’ve seen
    so far in your script. Which one you choose depends on the nature of your script
    and its purpose. First, let’s examine two factors that affect how you program
    your script as well as how you look at potential failures and how you solve them.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多策略可以用来处理你在脚本中看到的弱点。你选择哪种取决于你脚本的性质和目的。首先，让我们考察两个影响你如何编写脚本以及你如何看待潜在失败和如何解决它们的因素。
- en: Communication
  id: totrans-187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 沟通
- en: When you’re building software for other people, communication is vital. It’s
    important to know the overall goals of your project, how it impacts on other aspects
    of the business, what the likely effects of a failure are, and how people in the
    business will use your final product. Although, strictly speaking, a program that
    doesn’t do what’s needed isn’t a bug, it might as well not have been written.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当你为其他人构建软件时，沟通至关重要。了解你项目的整体目标、它如何影响业务的各个方面、失败的预期影响以及业务中的人们将如何使用你的最终产品是很重要的。尽管严格来说，一个不执行所需功能的程序不是错误，但它几乎可以视为没有编写。
- en: It’s also important to keep people informed as you build your program, because
    the problem you’re solving can change at any point. There’s nothing worse than
    finishing a program only to find that it’s no longer required and that weeks of
    effort have been wasted.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建程序的过程中，保持人们知情也很重要，因为你要解决的问题可能在任何时刻发生变化。没有什么比完成一个程序后才发现它不再需要，而且几周的努力都白费了更糟糕的事情了。
- en: Tolerance of failure
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 失败容忍度
- en: There are many different ways to deal with a potential error, and they all have
    varying costs. Which ones you choose will depend on the business’s tolerance of
    failure.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 处理潜在错误的方法有很多种，它们都有不同的成本。你选择哪种取决于企业对失败的容忍度。
- en: '![](f0167-01.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](f0167-01.jpg)'
- en: The Expensive Case
  id: totrans-193
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 贵重案例
- en: For example, if the business were using your script to buy and sell millions
    of dollars worth of stock, then it would have a low tolerance of any possible
    failure. You might host the script on a dedicated server or multiple servers in
    separate locations—an extra several thousand dollars would be a small price compared
    to the risk of losing millions of dollars worth of trades. You’d also want to
    pay a few hundred dollars a month to access an API specifically provided for the
    purpose rather than scraping web pages, and have a full suite of functional and
    unit tests to catch any errors.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果企业使用你的脚本买卖价值数百万美元的股票，那么它对任何可能的失败都有很低的容忍度。你可能会在专用服务器或多个不同位置的服务器上托管脚本——与损失数百万美元的交易风险相比，额外几千美元只是小菜一碟。你还会想每月支付几百美元来访问专门为此目的提供的API，而不是抓取网页，并拥有完整的功能和单元测试套件来捕捉任何错误。
- en: The Cheaper Case
  id: totrans-195
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 便宜案例
- en: If, instead, you were using your script as a more general business intelligence
    application, a stock failing here or there or taking a day to propagate through
    the system might not be so bad. Cost is more of an issue, so you’d run your script
    on a server with several other applications. This opens you up to the possibility
    of extra errors, like running out of disk space or having one application use
    so much CPU that nothing else can get anything done—but the impact of any errors
    like this is minor compared to the relative cost of separate servers.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果相反，你将脚本用作更通用的商业智能应用，那么这里或那里的股票失败或需要一天时间通过系统可能并不是那么糟糕。成本是更大的问题，因此你会在服务器上运行你的脚本，同时还有其他几个应用程序。这让你面临额外的错误可能性，比如磁盘空间不足或某个应用程序使用了过多的CPU，以至于其他什么也做不了——但与单独服务器的相对成本相比，任何此类错误的冲击都是微不足道的。
- en: Don’t break in the first place
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 首先不要出错
- en: It might sound obvious, but the easiest way to avoid bugs in your program is
    to not write them in the first place. It’s easy to throw together a script that
    looks like it works, but often you’ll find there are all sorts of issues lurking
    in your code, waiting for an opportunity to crash your program.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然听起来很明显，但避免程序中错误的最简单方法就是一开始就不编写它们。很容易拼凑出一个看起来像能工作的脚本，但通常你会发现代码中隐藏着各种问题，等待着机会让你的程序崩溃。
- en: First, consider all of the possible data, including weird pathological cases,
    when you write your program. Look for edge cases and things that “can’t possibly
    happen,” and make sure they can’t. If you’re working with numbers, what happens
    when the number is zero? Or negative? Or enormous? Should the program throw an
    error? Ignore that particular value? Thinking about this ahead of time is easier
    than thinking about it when your program crashes and you have to fix it *right
    now*.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，当你编写程序时，考虑所有可能的数据，包括奇怪的非典型情况。寻找边缘情况以及那些“不可能发生”的事情，并确保它们不会发生。如果你正在处理数字，当数字为零、负数或巨大时会发生什么？程序应该抛出错误吗？忽略那个特定的值？提前考虑这些问题比程序崩溃时你必须立即修复它们要容易得多。
- en: Once you know what data you can and can’t handle, you can include it in your
    tests. Your unit tests and functional tests can verify what happens when you give
    a program data that’s either invalid (“fruit” when you were expecting a number)
    or likely to be a problem (zero, negative, or very large). If you find input that
    gives you an error while you’re testing or when your program goes live, you can
    add it to your test suite to ensure that it doesn’t happen again.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你知道你可以处理和不能处理哪些数据，你就可以将其包含在测试中。你的单元测试和功能测试可以验证当你向程序提供无效数据（当你期望数字时却得到“fruit”）或可能成为问题（零、负数或非常大）的数据时会发生什么。如果你在测试或程序上线时发现输入导致错误，你可以将其添加到测试套件中，以确保它不再发生。
- en: '![](f0168-01.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图片](f0168-01.jpg)'
- en: Fail early and loudly
  id: totrans-202
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 早期且大声地失败
- en: If at some point in your program there’s an error, normally the best way to
    deal with it is for your program to stop immediately and start “yelling” (via
    email or by printing to the screen). This is particularly true during development
    or if the problem is unexpected. Trying to soldier on in the face of errors is
    dangerous, because you can overwrite important data with nonsense results.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在程序的某个地方出现错误，通常最好的处理方式是程序立即停止并开始“尖叫”（通过电子邮件或打印到屏幕上）。这在开发期间或问题意外出现时尤其正确。面对错误继续前进是危险的，因为你可能会用无意义的结果覆盖重要数据。
- en: 'Wherever possible, check data and any error codes returned from the libraries
    you’re using. If you’re trying to load data from the web, you can check the response
    code: anything other than 200 (success) means there’s been an error somewhere
    and you should stop. If you have trouble parsing the data returned, it’s possible
    you’re seeing a different type of page, or the data isn’t what you’re expecting.
    In that case, it’s also a good idea to log it somewhere and skip processing. Don’t
    forget to include relevant data in the error so you can replicate the problem.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，检查你使用的库返回的数据和任何错误代码。如果你正在尝试从网络上加载数据，你可以检查响应代码：除了200（成功）之外的其他任何代码都意味着某个地方出现了错误，你应该停止。如果你在解析返回的数据时遇到麻烦，可能你看到的是不同类型的页面，或者数据不是你预期的。在这种情况下，将错误记录下来并跳过处理也是一个好主意。别忘了在错误中包含相关数据，这样你就可以复制问题。
- en: Belt and braces
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 双保险
- en: To mitigate the effects of any errors, it can often help to have multiple fallbacks
    if things go wrong. For example, you might have two copies of your script running
    on separate servers. If something goes wrong with one script, such as the network
    being unavailable, the other script may still be able to access the data.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减轻任何错误的影响，如果事情出错，通常有多个后备方案会很有帮助。例如，你可能在不同的服务器上运行你的脚本的两个副本。如果一个脚本出现问题，比如网络不可用，另一个脚本可能仍然能够访问数据。
- en: Another tip is to save intermediate copies of the data whenever possible. In
    your script, you might want to consider saving the HTML you download from the
    server before you analyze it. If some of the data looks odd, or you have an error
    when parsing, you can double-check your results and see what’s gone wrong.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个技巧是在可能的情况下保存数据的中间副本。在你的脚本中，你可能想在分析之前保存从服务器下载的HTML文件。如果某些数据看起来很奇怪，或者你在解析时出现错误，你可以双重检查你的结果，看看出了什么问题。
- en: Stress and performance testing
  id: totrans-208
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 压力和性能测试
- en: A common problem when your program goes live is that it works well on small
    amounts of data but fails or runs too slowly when used on real data. Make sure
    your program can handle the workload in the volumes that are expected when it
    goes live, and use real data when testing wherever possible.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的程序上线时，一个常见的问题是它在少量数据上运行良好，但在使用真实数据时失败或运行得太慢。确保你的程序能够处理上线时预期的数据量，并在可能的情况下使用真实数据进行测试。
- en: '![](f0169-01.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![f0169-01.jpg](f0169-01.jpg)'
- en: Try again later
  id: totrans-211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 尝试稍后再试
- en: If your program fails due to an outside source not being available, you can
    often try again several times before giving up. Perhaps the site you’re trying
    to load is having some temporary downtime and will be back up in a few minutes.
    If you take this route, be sure to wait a while between queries, and wait a little
    longer between them if they’re failing. If you want five retries, you might wait
    1 minute, then 3, 5, 7, and then finally give up. If you need to send data via
    email, a queue can simplify your error-handling. Instead of sending emails directly
    to the server, queue them to a directory on disk instead. A second process reads
    the files that are saved and tries to send them. If the mail is sent successfully,
    then you delete the mail file or move it to a separate directory, but if it fails
    you leave it ready for next time. The following listing shows how you might add
    that sort of logic to your stock-tracking script.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的程序因为外部资源不可用而失败，你通常可以在放弃之前尝试多次。也许你试图加载的网站正在经历一些临时停机，几分钟后将恢复。如果你选择这条路，确保在查询之间等待一段时间，如果它们失败，则在它们之间等待更长的时间。如果你想重试五次，你可能等待1分钟，然后是3、5、7分钟，最后放弃。如果你需要通过电子邮件发送数据，队列可以简化你的错误处理。与其直接将电子邮件发送到服务器，不如将它们排队到磁盘上的目录。第二个进程读取保存的文件并尝试发送。如果邮件发送成功，那么你删除邮件文件或将它移动到另一个目录，如果失败，你让它准备好下次使用。下面的列表显示了如何将这种逻辑添加到你的股票跟踪脚本中。
- en: Listing 5.7\. Queuing email to a temporary file
  id: totrans-213
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.7\. 将电子邮件排队到临时文件
- en: '![](05list07_alt.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![05list07_alt.jpg](05list07_alt.jpg)'
- en: First, you check that the mail queue directory exists. If it doesn’t, then you
    need to create it ![](one.jpg).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你检查邮件队列目录是否存在。如果不存在，那么你需要创建它 ![one.jpg](one.jpg)。
- en: Next, you use the *tempfile* module to create the mail file ![](two.jpg). By
    doing it this way instead of figuring out the filename yourself, you’re much less
    likely to run into a conflict with naming if you’re running multiple scripts at
    once.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你使用 *tempfile* 模块来创建邮件文件 ![two.jpg](two.jpg)。通过这种方式而不是自己确定文件名，如果你同时运行多个脚本，你遇到命名冲突的可能性会小得多。
- en: 'Now that you have your file, you can write all the information you need when
    it’s time to send your email: To, From, and the body of the email itself ![](three.jpg).'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了文件，你可以在发送邮件时写入所有需要的信息：收件人、发件人和邮件正文本身 ![three.jpg](three.jpg)。
- en: Once you have the email queued to disk, you can use a second process to read
    it and send it out. The next listing shows how the second process might be written.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦邮件被排队到磁盘，你可以使用第二个进程来读取并发送它。下一个列表显示了第二个进程可能如何编写。
- en: Listing 5.8\. Sending email from a mail queue directory
  id: totrans-219
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.8\. 从邮件队列目录发送电子邮件
- en: '![](05list08_alt.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![05list08_alt.jpg](05list08_alt.jpg)'
- en: This part of the process is the opposite of the one you just looked at. Given
    a directory, you want to read in all of the files in it ![](one.jpg) and, for
    each of them, read out the To and From lines and then the mail body.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程的部分与刚才你看到的相反。给定一个目录，你想要读取其中的所有文件 ![one.jpg](one.jpg)，然后对于每个文件，读取收件人和发件人行，然后是邮件正文。
- en: The *smtplib* server will generate an error for anything that means the mail
    can’t be sent, so you try to send the email ![](two.jpg). If it succeeds, then
    you know the mail has been sent and you can delete the mail file and continue.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '*smtplib*服务器会对任何意味着无法发送邮件的情况生成错误，所以你尝试发送邮件![图片](two.jpg)。如果成功，那么你知道邮件已经发送，你可以删除邮件文件并继续。'
- en: '![](f0171-01.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图片](f0171-01.jpg)'
- en: Now you don’t have to worry about mail being lost if the mail server is down
    for maintenance, or if you can’t reach it via the network. All mail will be queued
    in the *mail_queue* directory and will only be deleted after it’s been sent.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你不必担心邮件服务器因维护而宕机或无法通过网络访问时邮件丢失。所有邮件都将排队在*mail_queue*目录中，只有在发送后才会被删除。
- en: There are still a few limitations, though. The main one is that the first error
    your program runs into will abort the entire mail-sending process. For your purposes
    it works well enough, because if one email fails the others are likely to fail
    as well. But you’d like your program to be as robust as you can make it. A malformed
    email address, for example, can cause the SMTP server to reject your connection
    request, and then that email will be repeated over and over again, blocking all
    the others queued up behind it.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，仍然存在一些限制。最主要的一个是，程序遇到的第一个错误将会终止整个邮件发送过程。对于你的目的来说，这已经足够好了，因为如果一封邮件失败，其他邮件也很可能失败。但你希望你的程序尽可能健壮。例如，一个格式不正确的电子邮件地址可能会导致SMTP服务器拒绝你的连接请求，然后这封邮件会反复发送，阻塞其后所有等待的邮件。
- en: '|  |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-227
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Gracefully handling errors is even more important if your program takes a while
    to return or is a batch process that runs overnight. If you have to wait six hours
    to find out whether it ran properly, it can take a week or more to shake out all
    the errors. Detailed error reports help, but you can also work on smaller data
    sets until you’re confident your program works.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的程序需要一段时间才能返回结果，或者是一个需要整夜运行的批处理程序，那么优雅地处理错误就尤为重要。如果你需要等待六个小时才能知道程序是否正常运行，那么可能需要一周或更长时间才能排除所有错误。详细的错误报告会有所帮助，但你也可以在数据集较小的情况下工作，直到你对程序的工作有信心。
- en: '|  |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'One error shouldn’t bring your whole program grinding to a halt, so what you
    need are exceptions: a feature in Python designed to help you react to errors
    like this as they occur and recover gracefully.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 一个错误不应该让你的整个程序停止运行，所以你需要的是异常：Python中设计用来帮助你处理这种错误并在发生时优雅恢复的功能。
- en: Exceptions
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异常
- en: Whenever Python runs into a problem that it can’t handle, it triggers an error
    called an *exception*. There are a wide variety of exceptions, and you can even
    define your own to suit particular types of errors if a built-in one doesn’t fit
    your exact error. Exceptions aren’t final, though—you can write code to catch
    them, interpret their results, and take whatever action you need.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当Python遇到它无法处理的问题时，会触发一个称为*异常*的错误。有各种各样的异常，如果你找不到合适的内置异常，你甚至可以定义自己的来适应特定类型的错误。然而，异常并不是最终的——你可以编写代码来捕获它们，解释它们的结果，并采取所需的任何行动。
- en: Why use exceptions?
  id: totrans-233
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为什么使用异常？
- en: Exceptions, when used well, make your program much easier to understand. You
    don’t need as much error-checking and handling, particularly for error codes and
    return results, because you can generally assume that anything that goes wrong
    will raise an exception. Not having error-handling code means the part of your
    program that does things stands out a lot more and is easier to understand because
    it’s not being interrupted by checking return codes.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用得当，异常可以使你的程序更容易理解。你不需要进行太多的错误检查和处理，尤其是对于错误代码和返回结果，因为你通常可以假设任何出错的情况都会引发一个异常。没有错误处理代码意味着程序中执行任务的这部分会显得更加突出，更容易理解，因为它不会被检查返回代码所中断。
- en: What it means when your program goes “bang!”
  id: totrans-235
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 当你的程序“爆炸”时意味着什么
- en: Before we get into how to use exceptions, let’s take a look at a few examples
    and see how they work. When you get an error in your program, you’ll see what’s
    called a *traceback*. This will give you the whole function “stack,” from the
    part of your program that triggered the error through intermediate functions to
    the one that originally started in the core of your program.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解如何使用异常之前，让我们看看一些示例，看看它们是如何工作的。当你在程序中遇到错误时，你会看到一个称为*跟踪回溯*的东西。这将给出整个函数“堆栈”，从触发错误的程序部分到中间函数，再到最初在程序核心中启动的函数。
- en: Let’s start with a traceback from the mail sender you wrote in the previous
    section. It shows the most recent error last, so you’ll be working backward.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从上一节中编写的邮件发送者的 traceback 开始。它显示最近的错误在最后，所以你需要从后往前工作。
- en: Listing 5.9\. A traceback when sending mail
  id: totrans-238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.9\. 发送邮件时的 traceback
- en: '![](f0173-01_alt.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![f0173-01_alt.jpg]'
- en: You start at the end of the listing with the name of the exception and a short
    description of the error that occurred ![](five.jpg). If you can’t figure out
    what’s going wrong with your program, doing a web search for the exception and
    description can often give you a clue.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 你从列表的末尾开始，以异常的名称和错误发生的简要描述 ![](five.jpg)。如果你无法找出程序中出了什么问题，通过在网络上搜索异常和描述通常可以给你一些线索。
- en: The last line that was executed is the one where the exception was raised ![](four.jpg).
    Note, though, that the bug may be earlier on in the program, if a variable wasn’t
    set properly or a function is being called with the wrong parameters.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 最后执行的一行是异常抛出的地方 ![](four.jpg)。不过，如果变量没有正确设置或函数被错误地调用，bug 可能出现在程序更早的部分。
- en: '![](three.jpg) is the file, line number, and function name where the exception
    in ![](four.jpg)was raised. Notice that this is within Python’s standard library,
    so you probably haven’t found the problem yet. When in doubt, always assume there’s
    a bug in your program, rather than Python’s standard library.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '![文件](three.jpg) 是异常在 ![异常](four.jpg) 中抛出的文件、行号和函数名。请注意，这位于 Python 的标准库中，所以你可能还没有找到问题。当怀疑时，总是假设程序中存在一个错误，而不是
    Python 的标准库。'
- en: The traceback ![](two.jpg) will continue to the function that called your original
    one. Notice how the function name you’re calling, *self.connect*, is the same
    as the function listed in ![](three.jpg), the last part of the traceback.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: traceback ![](two.jpg) 将继续到调用你的原始函数的函数。注意你调用的函数名，*self.connect*，与 traceback
    中的最后部分 ![](three.jpg) 中列出的函数名相同。
- en: 'Now that you get into the code, the error is obvious. You’ve forgotten to take
    out the example ISP mail server and substitute your own ![](one.jpg). There’s
    no web address at mail.yourisp.com, hence the original error: “name or service
    not known.” Often the root cause of an exception might be several layers deep
    in the traceback, and it’s a case of tracing the function calls back until you
    find the source of the error.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经进入代码，错误很明显。你忘记移除示例 ISP 邮件服务器并替换你自己的 ![](one.jpg)。在 mail.yourisp.com 没有网络地址，因此原始错误是：“名称或服务未知。”通常，异常的根本原因可能在
    traceback 中深达几层，这是一个追踪函数调用直到找到错误来源的过程。
- en: 'Python handles exceptions by propagating them *up the stack*: that is, it will
    first look for an exception handler in the current function. If it can’t find
    one, it will look in the function which called the current one, then that function’s
    parent, and so on, all the way back to the top of your program. If there’s still
    no handler, Python will halt and print out the unhandled exception and the stack
    trace. Bang!'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Python 通过向上传播异常来处理异常：也就是说，它首先会在当前函数中寻找异常处理程序。如果找不到，它会在调用当前函数的函数中查找，然后是那个函数的父函数，依此类推，直到程序顶部。如果仍然没有处理程序，Python
    将停止并打印出未处理的异常和堆栈跟踪。砰！
- en: '[Figure 5.5](#ch05fig05) shows how the stack trace from [listing 5.9](#ch05list9)
    is generated, with the function calls on the left side and the traceback rewinding
    on the right side.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.5](#ch05fig05) 展示了从 [列表 5.9](#ch05list9) 生成的堆栈跟踪，左侧是函数调用，右侧是 traceback
    回溯。'
- en: Figure 5.5\. A diagram of a stack trace
  id: totrans-247
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.5\. 栈跟踪的示意图
- en: '![](05fig05.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![05fig05.jpg]'
- en: For a different point of reference, here’s another traceback, from *parse_stock_html*.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 为了不同的参考点，这里还有一个来自 *parse_stock_html* 的 traceback。
- en: Listing 5.10\. A traceback when parsing an HTML page
  id: totrans-250
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.10\. 解析 HTML 页面时的 traceback
- en: '![](05list10_alt.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![05list10_alt.jpg]'
- en: The exception that was triggered ![](one.jpg) is an *IndexError*, which means
    you’ve tried to access an index of an array that doesn’t exist. Something like
    *['foo'][1]* will trigger a similar exception, because there’s no second element
    of that array.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 触发的异常是一个 *IndexError*，这意味着你尝试访问一个不存在的数组索引。类似 *['foo'][1]* 这样的操作也会触发类似的异常，因为那个数组没有第二个元素。
- en: If you look at the line above it, you can see what might be causing the problem.
    You’re running a find in Beautiful Soup and are trying to access the second element
    ![](two.jpg). There’s obviously some data for which the HTML only has one element,
    and the parsing code doesn’t handle it.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看上面的那一行，你可以看到可能引起问题的原因。你正在运行Beautiful Soup中的查找，并尝试访问第二个元素！[](two.jpg)。显然，有一些数据，其HTML只有一个元素，解析代码没有处理它。
- en: The error in this case is due to the up or down arrow image not being shown
    when the stock price hasn’t moved, which is changing the number of elements returned
    from .*contents()*. The following figure shows the two versions of the HTML side
    by side so you can see what I mean.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，错误是由于当股票价格没有变动时，上或下箭头图像没有显示，这改变了从 .*contents()* 返回的元素数量。以下图显示了两种HTML版本并排，以便你可以看到我的意思。
- en: Figure 5.6\. The HTML changes if there’s no movement in the stock.
  id: totrans-255
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.6。如果没有股票价格变动，HTML会发生变化。
- en: '![](05fig06_alt.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![图片](05fig06_alt.jpg)'
- en: 'This problem is fixed relatively easily by using a negative index, like this:
    *.contents[-1]*. Now Python will access the last element of the list: either the
    second element, if there are two, or the first one if there’s only one. You can
    be pretty sure there won’t be more than two elements in that particular span.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用负索引，这个问题相对容易解决，例如：*.contents[-1]*。现在Python将访问列表的最后一个元素：如果有两个元素，则是第二个元素；如果只有一个元素，则是第一个元素。你可以相当确信在那个特定范围内不会有超过两个元素。
- en: Now you should have some pointers in using tracebacks to help you troubleshoot
    errors. The main thing to bear in mind is to work backward carefully, looking
    for potential errors or odd results. If that doesn’t help, you might need more
    traditional checks, such as print or assert statements. Once you’ve tracked down
    the error, you should add it to your testing suite if possible.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该有一些使用回溯来帮助你调试错误的提示。要记住的主要事情是仔细地反向工作，寻找潜在的错误或异常结果。如果这没有帮助，你可能需要进行更传统的检查，例如打印或断言语句。一旦追踪到错误，如果可能的话，你应该将其添加到你的测试套件中。
- en: Catching errors
  id: totrans-259
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 捕获错误
- en: The main reason for having exceptions is to catch them if they are raised and
    deal with them appropriately. You do this by using a *try..except* block, commonly
    known as an *exception handler*. The code within the *try* part is run, and if
    an exception is raised, Python looks at the *except* part to see how to deal with
    the error. The following listing shows how you how you might catch some common
    exceptions in your mail-sending program.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 异常的主要原因是如果它们被抛出，就要捕捉它们并适当地处理它们。这是通过使用 *try..except* 块来完成的，通常称为 *异常处理程序*。在 *try*
    部分运行的代码，如果抛出异常，Python会查看 *except* 部分以确定如何处理错误。以下列表显示了如何在你的邮件发送程序中捕获一些常见的异常。
- en: Listing 5.11\. A mail sender with exception handling
  id: totrans-261
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.11。一个带有异常处理的邮件发送程序
- en: '![](05list11_alt.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![图片](05list11_alt.jpg)'
- en: You start with the part of your program you’d like to wrap ![](one.jpg), to
    catch any exceptions. It behaves much like any normal indented block, so you can
    include *if* statements, loops, function calls, and whatever else you need to.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 你从你想要包装的部分开始你的程序！[](one.jpg)，以捕获任何异常。它表现得非常像任何正常的缩进块，所以你可以包括 *if* 语句、循环、函数调用以及你需要的一切。
- en: '![](two.jpg) is how you handle a single exception, which is how most exception-handling
    is done. The handler works a little like a function in that you give it the type
    of exception it needs to handle and a variable to store the error message. When
    an exception is raised, you can print an error message and the error message you’ve
    received.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](two.jpg) 是处理单个异常的方法，这也是大多数异常处理的方式。处理程序的工作方式有点像函数，你给它需要处理的异常类型和一个变量来存储错误信息。当抛出异常时，你可以打印错误信息和你收到的错误信息。'
- en: You can also handle multiple types of exception with one handler by putting
    the exceptions you’re expecting into a tuple, instead of having one by itself
    ![](three.jpg).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过将你期望的异常放入一个元组中，而不是单独一个，用一个处理程序来处理多种类型的异常！[](three.jpg)。
- en: If you need to catch every exception that’s raised, use *Exception*, which is
    a generic exception object ![](four.jpg). It’s generally considered poor form
    to use a generic handler like this, because you may end up masking errors you’d
    rather have propagate up. If possible, you should handle specific errors, but
    there are occasions where you don’t know what exceptions you’ll need to handle.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要捕获引发的每个异常，请使用 *Exception*，这是一个通用的异常对象 ![four.jpg](four.jpg)。通常认为使用这种通用处理程序是不好的做法，因为你可能最终会掩盖你希望传播的错误。如果可能，你应该处理特定的错误，但在某些情况下，你可能不知道需要处理哪些异常。
- en: You can also use *else:* to include a section of code to execute if the *try..except*
    block ran successfully and didn’t raise any exception ![](five.jpg). In this case,
    you’re deleting the mail you’ve just sent. There’s also a *finally:* option that
    you can use if you have something that needs to be run all the time, regardless
    of whether you had any exceptions.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 *else:* 来包含一段代码，如果 *try..except* 块成功运行且未引发任何异常，则执行该段代码 ![five.jpg](five.jpg)。在这种情况下，你正在删除你刚刚发送的邮件。还有一个
    *finally:* 选项，如果你有一些需要始终运行的内容，无论是否发生异常，都可以使用它。
- en: Exception handling like this should handle most of your needs and allow you
    to write programs that can recover from error conditions, or at least fail gracefully,
    and you can use it wherever you need to handle errors. Where that is depends on
    the nature of the program and the errors you’re trying to catch. A program that
    handles user input might have one high-level exception handler that wraps your
    entire program in a *try..except* clause. That way, no matter what the user types,
    you can handle it and return a reasonable error message. You can also use error
    handlers around subsections of your program, or around specific modules that throw
    exceptions.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的异常处理应该可以满足你的大部分需求，并允许你编写能够从错误条件中恢复的程序，或者至少优雅地失败，你可以在需要处理错误的地方使用它。具体在哪里取决于程序的性质和你要尝试捕获的错误。处理用户输入的程序可能有一个高级异常处理程序，它将整个程序包裹在一个
    *try..except* 子句中。这样，无论用户输入什么，你都可以处理它并返回合理的错误消息。你还可以在程序的部分子句或抛出异常的特定模块周围使用错误处理程序。
- en: 'But handling exceptions on servers doesn’t give you a lot of information about
    what went wrong. Especially in the case of critical production systems, it’s extremely
    helpful to know where the error occurred and in what file. You’d like to be able
    to see tracebacks as if you were running the program locally. Fortunately, there’s
    a Python module that can help you to print out detailed debugging messages and
    find out what when wrong: the *traceback* module.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 但在服务器上处理异常并不能给你太多关于出错原因的信息。特别是在关键的生产系统中，知道错误发生的位置和文件非常有帮助。你希望能够看到跟踪回执，就像你在本地运行程序一样。幸运的是，有一个
    Python 模块可以帮助你打印出详细的调试消息并找出出了什么问题：*traceback* 模块。
- en: The traceback module
  id: totrans-270
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: traceback 模块
- en: The *traceback* module gives you a number of functions for handling exceptions
    as well as formatting and extracting tracebacks and error messages. The two key
    ones are *print_exc()* and *format_exc()*, which print out a traceback and return
    a traceback as a string, respectively. You can extract this information from the
    *sys* module, via *sys.exc_type*, *sys.exc_value*, and *sys.exc_traceback*, but
    it’s much more straightforward to use *traceback*. Let’s extend the error handling
    in the last section to print out a nice traceback if you get an unknown error,
    as shown in the following listing.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '*traceback* 模块为你提供了一系列处理异常、格式化和提取跟踪回调和错误消息的函数。其中两个关键函数是 *print_exc()* 和 *format_exc()*，分别打印跟踪回调和将跟踪回调作为字符串返回。你可以通过
    *sys* 模块提取这些信息，通过 *sys.exc_type*、*sys.exc_value* 和 *sys.exc_traceback*，但使用 *traceback*
    要简单得多。让我们扩展最后部分的错误处理，以便在出现未知错误时打印出漂亮的跟踪回执，如下所示。'
- en: Listing 5.12\. Using the traceback module
  id: totrans-272
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.12\. 使用 traceback 模块
- en: '![](05list12_alt.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![05list12_alt.jpg](05list12_alt.jpg)'
- en: 'Let’s start with a shortcut: you don’t have to specify *Exception* for a generic
    handler. If you omit any exception types at all, it behaves in exactly the same
    way ![](one.jpg).'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从捷径开始：对于通用处理程序，你不必指定 *异常*。如果你完全省略任何异常类型，它将以完全相同的方式执行 ![one.jpg](one.jpg)。
- en: The *print_exc()* function will print a formatted traceback ![](two.jpg). This
    is useful if you’re running the program interactively or if you use something
    like cron, which will email you with the output of any programs you run.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '*print_exc()* 函数将打印格式化的跟踪回执 ![two.jpg](two.jpg)。如果你以交互式方式运行程序或使用类似 cron 的工具，它会通过电子邮件发送你运行的任何程序的输出，这很有用。'
- en: If you need to log to a file, then you can use the *format_exc()* function to
    return a string with the traceback ![](three.jpg). Other than that difference,
    it’s exactly the same output.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要将日志记录到文件中，那么你可以使用`format_exc()`函数来返回一个包含回溯信息的字符串 ![three.jpg](three.jpg)。除此之外，输出完全相同。
- en: Now you have everything you need to be able to handle any errors that crop up
    in your program. You can extend the code in this section to handle most situations
    you’ll run into in practice, and if not, then at least leave enough data behind
    for you to be able to figure out what’s gone wrong.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经拥有了处理程序中出现的任何错误所需的一切。你可以扩展本节中的代码来处理实践中遇到的大多数情况，如果没有，至少留下足够的数据，以便你能找出出了什么问题。
- en: Where to from here?
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接下来是什么？
- en: The scripts in this chapter are self-contained, so there aren’t any specific
    suggestions as to how you can extend them. Instead, try applying the lessons (and
    code) from this chapter to automate something you do frequently, either at work
    or home. Good candidates are anything you find dull and boring, or which requires
    detailed steps and is difficult to do properly.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的脚本都是自包含的，因此没有关于如何扩展它们的特定建议。相反，尝试将本章的教训（和代码）应用于自动化你经常在工作或家中做的事情。合适的候选者是你觉得无聊和乏味的事情，或者需要详细步骤且难以正确完成的事情。
- en: If you can’t automate all of your process, you can at least cover part of them—for
    example, download required data so it’s all in one place, or send out several
    emails from a central data store.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不能自动化整个过程，至少可以覆盖其中的一部分——例如，下载所需数据，使其集中在一个地方，或者从中央数据存储发送多封电子邮件。
- en: Often, a good script can save you several hours of work over the course of a
    month, so you can use all the new free time you have to write another script.
    Eventually, you might not have to do any work at all!
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个好的脚本可以在一个月内为你节省几个小时的工作时间，这样你就可以用所有新获得的空闲时间来编写另一个脚本。最终，你可能根本不需要做任何工作！
- en: Summary
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: 'The first half of this chapter covered some of the basic but important libraries
    in Python that you can use to connect to the outside world and get real work done.
    We covered a number of technologies:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的前半部分涵盖了Python中一些基本但重要的库，你可以使用这些库连接到外部世界并完成实际工作。我们介绍了几项技术：
- en: Downloading HTML from the web
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从网络下载HTML
- en: Parsing HTML using Beautiful Soup
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Beautiful Soup解析HTML
- en: Writing data out to a CSV file
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据写入CSV文件
- en: Composing email, including writing HTML email and attaching documents
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写电子邮件，包括编写HTML电子邮件和附加文档
- en: Sending email via SMTP
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过SMTP发送电子邮件
- en: In the second half of the chapter, we took a step back and looked at how you
    can make your programs more reliable—after all, this is the real world, and other
    people might have a lot of money riding on your programs.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后半部分，我们退后一步，探讨了如何使你的程序更加可靠——毕竟，这是现实世界，其他人可能有很多钱依赖于你的程序。
- en: We first looked at how you can find areas of a program are at risk. Then, we
    considered whether you should fix them, based on the costs of doing so and the
    fallout from any potential failures. Finally, we covered some simple strategies
    to make your programs more reliable, and we also took a look at ways to reduce
    the damage done if a program fails.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先探讨了如何识别程序中存在风险的区域。然后，我们考虑了是否应该修复这些问题，基于修复的成本以及任何潜在失败的影响。最后，我们介绍了一些简单的策略来提高程序的可靠性，并探讨了在程序失败时如何减少损害。
- en: Finally, we covered exceptions and tracebacks, which are Python’s way of handling
    errors when they occur, and how you can catch exceptions, examine them, and deal
    with the problem if you’re able to.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们介绍了异常和回溯，这是Python处理错误的方式，以及当你能够时，如何捕获异常、检查它们并解决问题。
- en: In the next chapter, we’ll take a break and write your own adventure game, with
    monsters, treasure, danger, and excitement!
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将休息一下，编写你自己的冒险游戏，包括怪物、宝藏、危险和兴奋！
