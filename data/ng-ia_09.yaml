- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Testing your application
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 测试你的应用程序
- en: '**This chapter covers**'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: The value of testing your Angular applications
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试你的Angular应用程序的价值
- en: How to set up and create unit tests to test individual pieces
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何设置和创建单元测试以测试单个部分
- en: Unit test strategies for directives, services, components, and pipes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指令、服务、组件和管道的单元测试策略
- en: How to implement e2e tests to test the application as a whole
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何实现端到端测试以测试整个应用程序
- en: Additional testing strategies
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他测试策略
- en: All the applications we’ve built could benefit from testing. Some developers
    dread writing tests, whereas others are probably wondering why I didn’t cover
    testing from the start. I consider testing essential, though it requires a set
    of new concepts and tools, which is why I waited till now.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建的所有应用程序都能从测试中受益。有些开发者害怕编写测试，而另一些开发者可能想知道为什么我没有从一开始就涵盖测试。我认为测试是必不可少的，尽管它需要一套新的概念和工具，这就是为什么我等到现在才讲。
- en: Angular was designed to be highly testable, and projects created using the Angular
    CLI automatically set up basic testing scaffolding and tools for us to use. We’ll
    use the CLI provided tools and configuration in this chapter. Developers with
    experience using other tools can choose to set up something else on their own
    and use the ideas and concepts from this chapter with those tools.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Angular被设计成高度可测试的，使用Angular CLI创建的项目会自动为我们设置基本的测试脚手架和工具。在本章中，我们将使用CLI提供的工具和配置。有使用其他工具经验的开发者可以选择自己设置其他东西，并使用本章中的思想和概念与这些工具一起使用。
- en: When developers talk about *testing*, they often mean *unit tests*. If you aren’t
    familiar with unit tests, these are ways of testing individual pieces (units)
    of your application in isolation. For example, we’ll test a single component without
    being rendered in the entire app and a pipe without being used in a template.
    If we compare unit tests to making a car, it would be analogous to testing each
    part, such as the wheel, electronics, engine, and so on, on its own, before it’s
    assembled as a whole car. This is the first type of testing we’ll look at in detail.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发者谈论*测试*时，他们通常指的是*单元测试*。如果你不熟悉单元测试，这些是在隔离状态下测试应用程序单个部分（单元）的方法。例如，我们将测试一个组件，而无需在完整的应用程序中渲染，以及一个管道在没有在模板中使用的情况下进行测试。如果我们将单元测试与制造汽车进行比较，它就像在组装成整车之前，单独测试每个部分，如轮子、电子设备、引擎等。这是我们将在本章中详细探讨的第一种测试类型。
- en: '*End-to-end* (e2e) testing, also called *integration* testing, is a way of
    testing the application as a whole. In contrast to isolating each unit individually,
    these tests are used to ensure that everything works together in concert. In our
    car analogy, it would be like running a test drive and asserting that all the
    parts were indeed working well together.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*端到端*（e2e）测试，也称为*集成*测试，是一种测试整个应用程序的方法。与单独隔离每个单元相反，这些测试用于确保所有部分协同工作。在我们的汽车类比中，这就像进行一次试驾并断言所有部件确实协同工作得很好。'
- en: If you’ve never tested your code in the past, writing good tests will decrease
    the level of effort required to maintain an application and give you more confidence
    that it’s behaving as expected. Different projects have different requirements,
    but performing *no* tests generally means that you’re either manually testing
    everything with every change or that people can’t depend on your application.
    Depending on who determines the testing strategy for your application, you should
    be sure to argue for taking the time and effort to write quality tests to ensure
    that everything is working.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以前从未测试过你的代码，编写好的测试将降低维护应用程序所需的努力水平，并让你更有信心它按预期运行。不同的项目有不同的要求，但进行*无*测试通常意味着你要么每次更改都手动测试所有内容，要么人们无法依赖你的应用程序。根据谁决定你应用程序的测试策略，你应该确保主张花时间和精力编写高质量的测试，以确保一切正常工作。
- en: Testing is such a big topic in Angular that there’s an entire book devoted to
    it, called *Testing Angular Applications* (Manning, 2018). I cover a lot of the
    basics here very quickly, but there’s more to dive into, and I suggest you take
    a look at it. You can find it at [https://www.manning.com/books/testing-angular-applications](https://www.manning.com/books/testing-angular-applications).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 测试在Angular中是一个如此大的主题，以至于有一本专门介绍它的书，名为《Testing Angular Applications》（Manning，2018）。我在这里非常快速地涵盖了大量的基础知识，但还有更多可以深入研究的内容，我建议你看看这本书。你可以在[https://www.manning.com/books/testing-angular-applications](https://www.manning.com/books/testing-angular-applications)找到它。
- en: In this chapter, we’ll focus on how to write unit tests for components, services,
    pipes, and directives. We’ll also create a few e2e tests that navigate and check
    elements on pages. It will be very hands on, so to get us going, let’s set up
    the example.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点介绍如何为组件、服务、管道和指令编写单元测试。我们还将创建一些端到端测试，以导航和检查页面上的元素。这将非常实用，因此为了让我们开始，让我们设置示例。
- en: 10.1 Testing tools and setting up the chapter example
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1 测试工具和设置本章示例
- en: The stock tracker application makes an appearance once again, because it has
    the best mix of things to test. We’re going to use the version from chapter 8
    where we created custom pipes and directives, so we can test them too.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 股票跟踪应用程序再次出现，因为它具有最佳的测试组合。我们将使用第8章中创建的自定义管道和指令的版本，这样我们也可以测试它们。
- en: We won’t modify the behavior of the application (except for a couple of examples
    where the tests show us ways to improve our code)—we’ll only be adding code into
    the various test files. The Angular CLI already generated the test files for us
    when we generated a new component, pipe, directive, or whatever, so we’ll just
    need to implement the tests.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会修改应用程序的行为（除了几个示例，测试会向我们展示如何改进我们的代码）——我们只会将代码添加到各种测试文件中。当我们生成新的组件、管道、指令或其他内容时，Angular
    CLI已经为我们生成了测试文件，因此我们只需实现测试即可。
- en: 'This code lives in a different repo, and you can get it using Git like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码位于不同的仓库中，你可以使用Git如下获取它：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Otherwise, you can download the archived files from [https://github.com/angular-in-action/testing/archive/start.zip](https://github.com/angular-in-action/testing/archive/start.zip)
    and unzip the files.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，你可以从[https://github.com/angular-in-action/testing/archive/start.zip](https://github.com/angular-in-action/testing/archive/start.zip)下载归档文件并解压文件。
- en: As usual, you’ll need to run `npm install` to download all the dependencies,
    and then you can run `ng` `serve` to start the local development server. I’ve
    cleared out all the tests so they’ll run, just so you can run the commands easily.
    It will mention an error like “Executed 0 of 0,” but once we create a test, that
    will go away—so you can ignore it for now.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，你需要运行`npm install`来下载所有依赖项，然后你可以运行`ng serve`来启动本地开发服务器。我已经清除了所有测试，这样你就可以轻松运行命令。它将提到一个错误，例如“Executed
    0 of 0”，但一旦我们创建了一个测试，这个错误就会消失——所以现在你可以忽略它。
- en: Let’s take a look at the various testing tools that are used by Angular out
    of the box.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看Angular自带的各种测试工具。
- en: 10.1.1 Testing tools
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.1 测试工具
- en: Angular provides an opinionated set of tooling choices for creating and running
    tests. Some tools apply to only unit or e2e tests, whereas some apply to both.
    Tests have to run in a real browser, because that’s the environment where web
    applications execute, so there are a few pieces of technology that enable tests
    to execute JavaScript code.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Angular提供了一套有见地的工具选择，用于创建和运行测试。一些工具仅适用于单元测试或端到端测试，而另一些则适用于两者。测试必须在真实浏览器中运行，因为这是Web应用程序执行的环境，因此有一些技术能够使测试执行JavaScript代码。
- en: Jasmine is the first tool. It’s a framework for writing tests. Jasmine is JavaScript
    (or TypeScript in our case), but it’s capable of connecting with a browser to
    execute tests using the browser’s JavaScript engine. When we write our tests in
    this chapter, you’ll always be using the Jasmine framework. A *test* ultimately
    consists of any code required to set up and tear down the specific test case,
    and then a set of expectations that verify that your code behaves as expected.
    For example, you’ll transform some text with a pipe to see if it returns the expected
    result. You can learn more about Jasmine at [https://jasmine.github.io/](https://jasmine.github.io/).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine是第一个工具。它是一个用于编写测试的框架。Jasmine是JavaScript（或在我们的情况下是TypeScript），但它能够连接到浏览器，使用浏览器的JavaScript引擎执行测试。当我们在本章中编写测试时，你将始终使用Jasmine框架。一个*测试*最终由任何设置和拆除特定测试案例所需的代码组成，然后是一组期望，以验证你的代码按预期行为。例如，你将使用管道转换一些文本，以查看它是否返回预期的结果。你可以在[https://jasmine.github.io/](https://jasmine.github.io/)了解更多关于Jasmine的信息。
- en: Next we have Karma, a tool originally created by the Angular team to help execute
    unit tests. Karma can control any type of framework, but it’s already configured
    to control Jasmine out of the box with the Angular CLI. It can do some interesting
    things, like run your tests on multiple browsers at once and provide features
    for continuous integration tools. You can learn more about Karma at [https://karma-runner.github.io/1.0/index.html](https://karma-runner.github.io/1.0/index.html).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是Karma，这是一个最初由Angular团队创建的工具，用于帮助执行单元测试。Karma可以控制任何类型的框架，但它已经配置好了，可以直接与Angular
    CLI一起控制Jasmine。它可以做一些有趣的事情，比如同时运行多个浏览器的测试，并为持续集成工具提供功能。你可以在[https://karma-runner.github.io/1.0/index.html](https://karma-runner.github.io/1.0/index.html)了解更多关于Karma的信息。
- en: Protractor is the next tool. It’s geared at helping run e2e-type tests by helping
    manage the way that tests run (like Karma), but also by providing an additional
    testing framework that you use with Jasmine to test and control the browser like
    a real user might. It’s built on WebDriver, a specification for how to control
    a browser through automation. Learn more at [www.protractortest.org](http://www.protractortest.org).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Protractor是下一个工具。它旨在通过帮助管理测试运行方式（如Karma）以及通过提供一个额外的测试框架，该框架与Jasmine一起使用来测试和控制浏览器，就像真实用户可能做的那样来帮助运行端到端类型的测试。它是基于WebDriver的，这是一个关于如何通过自动化控制浏览器的规范。更多了解请访问[www.protractortest.org](http://www.protractortest.org)。
- en: You may have noticed that all these tools require a browser, and you have some
    options on which browsers to use. I generally recommend using Chrome for local
    development, because it’s set up out of the box, but you should also read about
    how to use each of these tools to test on different browsers to be more certain
    things work. Not all browsers support the same features or behave in exactly the
    same ways, so keep that in mind.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，所有这些工具都需要浏览器，你有一些选择可以使用哪些浏览器。我通常推荐使用Chrome进行本地开发，因为它开箱即用，但你也应该了解如何使用这些工具在不同的浏览器上测试，以确保一切正常。不是所有浏览器都支持相同的功能或以完全相同的方式表现，所以请记住这一点。
- en: There are a few other minor tools used behind the scenes; they’re plugins for
    these primary tools. This chapter doesn’t intend to cover all the potential ways
    these tools can be configured. We’re going to focus on what works out of the box,
    and you can expand to more complex scenarios as your needs change.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后还有一些其他的小工具；它们是这些主要工具的插件。本章的目的不是涵盖所有可能的配置方式。我们将专注于开箱即用的功能，随着你的需求变化，你可以扩展到更复杂的场景。
- en: 10.2 Unit testing
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2 单元测试
- en: I’ll begin with unit testing, because it’s likely that you’ll write more unit
    tests than other types of tests. They’re the lowest-level test you can write for
    your application—they verify that the smallest pieces work as expected. Remember
    from earlier the analogy of testing each component of the car before it’s assembled
    to ensure that quality parts are being used in the vehicle.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从单元测试开始，因为很可能你会编写比其他类型的测试更多的单元测试。它们是你可以为应用程序编写的最低级别的测试——它们验证最小的部分是否按预期工作。记得之前提到的在汽车组装前测试每个组件的类比，以确保车辆使用的是高质量零件。
- en: 'You can write unit tests in a wide variety of ways, but Angular has some general
    guidelines that work in most scenarios. Fundamentally, there are two ways to write
    unit tests:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用多种方式编写单元测试，但Angular有一些在大多数场景中都适用的通用指南。从根本上说，编写单元测试有两种方式：
- en: Creating truly isolated unit tests in which you construct the entities yourself
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建真正隔离的单元测试，其中你自己构建实体
- en: Rendering a test bed module to render the entity with Angular and verify behavior
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Angular渲染测试床模块以渲染实体并验证行为
- en: Truly isolated unit tests are best for pipes and, often, services, where you
    create a new instance of the class outside of Angular. That means you wouldn’t
    have access to using dependency injection, and you’ll see how you can either mock
    or manually inject dependencies. These tests are extremely fast and reduce the
    surface area of your tests to the lowest level. If you can write a test using
    this approach, it’s recommended that you do so.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 真正隔离的单元测试最适合管道和，通常，服务，其中你在Angular之外创建类的实例。这意味着你将无法使用依赖注入，你将看到你可以如何模拟或手动注入依赖项。这些测试非常快，并将你的测试表面积减少到最低水平。如果你可以使用这种方法编写测试，建议你这样做。
- en: Test bed module testing is more involved, but it’s more appropriate for components
    and sometimes directives when you need to verify how things are rendered in the
    context of an Angular application. In this case, you’re essentially creating a
    temporary Angular application that has the minimal amount of stuff needed to run.
    As you can imagine, these are a little bit slower to run but provide more capabilities
    for building tests.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 测试床模块测试更为复杂，但更适合在需要验证在 Angular 应用程序上下文中渲染内容时使用组件和有时是指令。在这种情况下，你实际上是在创建一个临时的
    Angular 应用程序，它包含运行所需的最小数量的东西。正如你可以想象的那样，这些运行速度略慢，但提供了更多构建测试的能力。
- en: 10.2.1 Anatomy of unit tests
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.1 单元测试的结构
- en: All unit tests share a few basic concepts, so let’s start by taking a closer
    look at the basic anatomy of a unit test. Each test has a few pieces, some of
    which are optional. This all comes from the Jasmine testing framework as well,
    so if you need any more context about a certain part, you can always review the
    Jasmine documentation.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 所有单元测试都共享一些基本概念，所以让我们先从更仔细地查看单元测试的基本结构开始。每个测试都有几个部分，其中一些是可选的。这一切都来自 Jasmine
    测试框架，所以如果你需要更多关于某个部分的背景信息，你总是可以查看 Jasmine 文档。
- en: 'The parts are as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 部分如下：
- en: '`describe`—A container for a set of tests that cover the same overall entity,
    such as describing the test suite for a pipe.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`describe`—一个用于包含覆盖相同整体实体的测试集的容器，例如描述管道的测试套件。'
- en: '`it`—A container for a single test that is used to describe a single feature,
    such as testing a specific component method that handles saving.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`it`—一个用于描述单个功能的单个测试的容器，例如测试处理保存的特定组件方法。'
- en: '`expect`—A way to assert that a value meets expected requirements, such as
    the response from a method must equal true.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expect`—一种断言值满足预期要求的方式，例如方法响应必须等于 true。'
- en: '`beforeEach`*/*`beforeAll`—These are a way to execute code before each individual
    test, or before all tests, such as setup logic to construct a new instance of
    the entity for each test. They only apply within the Describe block in which they’re
    defined.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`beforeEach`/`beforeAll`—这些是在每个单独的测试之前或所有测试之前执行代码的一种方式，例如设置逻辑来为每个测试构造实体的新实例。它们只适用于定义它们的
    Describe 块内。'
- en: '`afterEach`*/*`afterAll`—These allow you to execute after each test or all
    tests, such as cleaning up anything between tests or resetting any shared state.
    They also apply only within the Describe block in which they are defined.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`afterEach`/`afterAll`—这些允许你在每个测试之后或所有测试之后执行代码，例如在测试之间清理任何内容或重置任何共享状态。它们只适用于定义它们的
    Describe 块内。'
- en: In most tests you’ll use all of these, with the exception of the `afterEach`/`afterAll`
    blocks. You’ll want to ensure that each test is set up with a clean instance of
    the object you want to test, and the `beforeEach` tends to be the most practical
    way to do that.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数测试中，你会使用所有这些，除了 `afterEach`/`afterAll` 块。你将想要确保每个测试都使用你想要测试的对象的干净实例来设置，而
    `beforeEach` 通常是最实际的方法。
- en: Let’s start writing some tests to see everything in action. We’ll focus first
    on a pure pipe so we can see the most basic type of test and how these pieces
    work together.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始编写一些测试，看看一切是如何运作的。我们首先关注纯管道，这样我们可以看到最基本的测试类型以及这些部分是如何一起工作的。
- en: 10.2.2 Testing pipes
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.2 测试管道
- en: Pipes are often the easiest thing to test, especially pure pipes. Because they’re
    simple classes that implement a single function, we can easily run them without
    creating a full Angular application.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 管道通常是测试中最容易的事情，尤其是纯管道。因为它们是只实现一个函数的简单类，我们可以轻松地运行它们，而无需创建一个完整的 Angular 应用程序。
- en: I think it’s best to jump right into a test and walk through the basic steps.
    We’ll start by writing a test for our Change pipe, which can be found at src/app/pipes/change.pipe.ts.
    The pipe is pure, and the only difficult aspect is that it injects two other pipes
    as services. Open up the test spec file at src/app/pipes/change.pipe.spec.ts and
    replace its contents with what’s shown in the following listing.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为直接进入测试并逐步了解基本步骤是最好的。我们将从编写我们的 Change 管道测试开始，该测试可以在 src/app/pipes/change.pipe.ts
    找到。这个管道是纯的，唯一困难的地方是它作为服务注入了两个其他管道。打开 src/app/pipes/change.pipe.spec.ts 中的测试规范文件，并用以下列表中的内容替换其内容。
- en: '**Listing 10.1** Change pipe test'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 10.1** 修改管道测试'
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This test begins by importing the required pieces to construct the Change pipe,
    and because it depends on the Currency and Percent pipes, those are imported as
    well. Then you create the `describe` block to wrap the rest of the file, because
    all the rest will be inside of the context of the Change pipe. Notice the `describe`
    block takes two parameters: a string and a function. The string is used in the
    test suite logging to help pinpoint how tests ran, and the function is executed
    when the test is slated to run.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试首先导入构建 Change 管道所需的组件，因为它依赖于 Currency 和 Percent 管道，所以这些也被导入。然后你创建一个 `describe`
    块来包裹文件的其余部分，因为所有其余的内容都将位于 Change 管道的上下文中。注意，`describe` 块接受两个参数：一个字符串和一个函数。字符串用于测试套件日志记录，以帮助确定测试是如何运行的，而函数则在测试计划运行时执行。
- en: Inside of the `describe` block, you set up a number of variables that are used
    to manually create an instance of the Change pipe. When constructing these entities
    individually, you have to create them using the new operator to instantiate the
    instance, and pass any configuration into the object constructor. There’s also
    a variable to hold a sample stock object that you’ll use later to verify behavior.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `describe` 块内部，你设置了一些变量，用于手动创建 Change 管道的实例。在单独构建这些实体时，你必须使用新操作符来实例化实例，并将任何配置传递给对象构造函数。还有一个变量用于存储样本
    `stock` 对象，你稍后会用它来验证行为。
- en: The first `it` block describes a simple test to ensure that the pipe was created
    successfully. It’s often useful to have a simple test that verifies that nothing
    threw an error during creation. Notice that the `it` statement takes two parameters,
    a string and a function, just like the `describe` block. In this case, when the
    test runs, the string is added to the `describe` block in the console output so
    you can track the `describe` block and the specific test that passes or fails.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 `it` 块描述了一个简单的测试，以确保管道创建成功。通常，有一个简单的测试来验证在创建过程中没有抛出错误是非常有用的。注意，`it` 语句接受两个参数，一个字符串和一个函数，就像
    `describe` 块一样。在这种情况下，当测试运行时，字符串会被添加到控制台输出的 `describe` 块中，这样你就可以跟踪 `describe`
    块和通过或失败的特定测试。
- en: Inside of the `it` block, there’s a single `expect` statement. This is the test
    statement that will trigger a success or failure. If the pipe was incorrectly
    constructed, it will mark this test as failed and provide the relevant error message.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `it` 块内部，有一个单独的 `expect` 语句。这是触发成功或失败的测试语句。如果管道构建不正确，它将标记此测试为失败，并提供相关的错误信息。
- en: The next `it` block tests the `transform` method by passing the sample `stock`
    object and expecting it to equal a particular string. I also changed the values
    of the `stock` object and tested it with a negative value to verify that case
    as well. You could write a large series of assertions to test various scenarios,
    which is useful when there’s more complexity in the `transform` method.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个 `it` 块通过传递样本 `stock` 对象并期望它等于特定的字符串来测试 `transform` 方法。我还更改了 `stock` 对象的值，并用负值测试它，以验证这种情况。你可以编写一系列断言来测试各种场景，这在
    `transform` 方法更复杂时非常有用。
- en: Now you need to run the test, which you do from the command line by running
    the `ng test` command. This will open up a new browser window that will show the
    results of the tests (similar to what you see in [figure 10.1](#figure10.1)),
    as well as the results in the command line. Congratulations, you’ve written your
    first test!
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在需要运行测试，你可以通过在命令行中运行 `ng test` 命令来完成。这将打开一个新的浏览器窗口，显示测试结果（类似于你在[图 10.1](#figure10.1)中看到的结果），以及命令行中的结果。恭喜你，你已经编写了你的第一个测试！
- en: 'This test tests every line of the Change pipe, which we can view by generating
    a test coverage report. You can generate a coverage report by running the test
    command with the `–cc` flag, like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试测试了 Change 管道的每一行，我们可以通过生成测试覆盖率报告来查看。你可以通过运行带有 `–cc` 标志的测试命令来生成覆盖率报告，如下所示：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It will generate a new directory called coverage, and you can view the report
    in the browser. That allows you to see what lines of code were executed or not
    in a visual format and can help identify areas that you’ve missed. But it doesn’t
    necessarily mean your tests are comprehensive. You might test the code in such
    a way that it only executes with a passing condition, but it might fail if you
    provide different parameters. Keep an eye out for this as you write tests.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 它将生成一个名为 coverage 的新目录，您可以在浏览器中查看报告。这允许您以可视化的方式查看哪些代码行被执行或未执行，并有助于识别您可能遗漏的区域。但这并不一定意味着您的测试是全面的。您可能以某种方式测试代码，使其仅在通过条件下执行，但如果您提供不同的参数，它可能会失败。在编写测试时，请注意这一点。
- en: There isn’t anything particularly special about testing an impure pipe, except
    that you have to keep track of some state. You can look at the final version of
    the chapter example to view the other pipe tests and see a few more examples in
    action.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 测试一个不纯的管道并没有什么特别之处，除了您必须跟踪一些状态。您可以通过查看章节示例的最终版本来查看其他管道测试，并看到更多示例的实际操作。
- en: 10.2.3 Testing services, stubs, and mocking HTTP requests
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.3 测试服务、存根和模拟 HTTP 请求
- en: Services are the other type of entity that can sometimes be tested by creating
    an isolated entity yourself. We’ll do that for our service, though you’ll start
    to see why this can be a tricky thing to do for many of your tests.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 服务是另一种类型的实体，有时可以通过创建一个隔离的实体来测试。我们将为我们的服务这样做，尽管您将开始看到为什么这对许多测试来说可能是一个棘手的事情。
- en: 'Some services have few, if any, dependencies. In this case, our Stocks service
    has just one: the HttpClient service from Angular. The trick is that I have to
    manually construct the HttpClient service as well, which is possible, but is the
    kind of thing that can get out of hand if you have a lot of dependencies. We’ll
    look at how to use testing modules in the next section, and you can also see the
    final version of this project, which has the testing module version of this test
    in the comments.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一些服务可能几乎没有依赖项。在这种情况下，我们的 Stocks 服务只有一个：Angular 的 HttpClient 服务。技巧在于我必须手动构建 HttpClient
    服务，这是可能的，但如果您有很多依赖项，这可能会变得难以控制。我们将在下一节中查看如何使用测试模块，您还可以查看这个项目的最终版本，其中包含测试模块版本的此测试的注释。
- en: '![c10-1.png](image_fi/293313c10/c10-1.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![c10-1.png](image_fi/293313c10/c10-1.png)'
- en: '[**Figure 10.1**](#figureanchor10.1) The complete test spec report from the
    chapter example'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图10.1**](#figureanchor10.1) 完整的测试规范报告来自章节示例'
- en: Because this service uses the HttpClient service, we also have to provide a
    solution to mocking HTTP requests. We don’t want to make real HTTP calls during
    our unit tests, because they’re slow, unpredictable, and require a real API to
    be available. Luckily, Angular provides a way to intercept HTTP requests and lets
    us send back a mock response body that we can test. Because Angular tests the
    HttpClient service extensively, we want to trust that Angular’s tests are more
    than sufficient to ensure the HttpClient service is working, but this lets us
    test to ensure that the way we’re using the HttpClient service is correctly implemented.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这项服务使用 HttpClient 服务，所以我们还需要提供一个模拟 HTTP 请求的解决方案。我们不希望在单元测试中执行真实的 HTTP 调用，因为它们速度慢、不可预测，并且需要可用的真实
    API。幸运的是，Angular 提供了一种拦截 HTTP 请求的方法，并允许我们发送回一个我们可以测试的模拟响应体。因为 Angular 对 HttpClient
    服务进行了广泛的测试，我们希望相信 Angular 的测试足以确保 HttpClient 服务正常工作，但这让我们可以测试以确保我们使用 HttpClient
    服务的正确实现。
- en: Before we create this test, let’s take a look at the mock objects I’ve included
    ahead of time. The file src/app/services/stocks.mock.ts contains several variables
    that have values we can reuse throughout the application. A snippet of the file
    appears in the following listing. You’ll need to have actual objects that match
    the expected responses from the API, so I’ve stored them in this file. You’ll
    import the various mocks many times over the remaining tests.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建这个测试之前，让我们看看我提前包含的模拟对象。文件 src/app/services/stocks.mock.ts 包含几个我们可以在整个应用程序中重用的变量。文件的一个片段如下所示。您需要具有与
    API 预期响应相匹配的实际对象，因此我将它们存储在这个文件中。您将在剩余的测试中多次导入各种模拟。
- en: '**Listing 10.2** Stocks mock data sample'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表10.2** 股票模拟数据样本'
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We’ll use these objects in various tests, depending on the things we’re testing.
    They’re real objects that I’ve included in the project so that there are known
    pieces of data we can use to test against. They’re JSON objects, so they’re the
    same as the raw data used, and not a mock of anything more.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在各种测试中使用这些对象，具体取决于我们要测试的内容。它们是真实对象，我已经将它们包含在项目中，以便我们可以使用已知的数据来测试。它们是 JSON
    对象，因此与使用的原始数据相同，而不是任何其他内容的模拟。
- en: Now let’s get to the test. Open up src/app/services/stocks.service.spec.ts and
    replace its contents with the code from the following listing. This test will
    create an instance of the service, intercept HTTP requests, and provide mock responses.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下测试。打开 src/app/services/stocks.service.spec.ts 并将其内容替换为以下列表中的代码。这个测试将创建服务的一个实例，拦截
    HTTP 请求，并提供模拟响应。
- en: '**Listing 10.3** Stocks service test'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 10.3** 股票服务测试'
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: There’s a lot more going on in this test, but most of it has to do with the
    setup required for mocking Http. The `describe` block starts by declaring some
    variables that are contained in these tests only. Then the `beforeEach` block
    constructs a testing module, so that we can properly instantiate the services
    using dependency injection (it’s usually difficult to try to manually set up a
    test for things that inject dependencies). We’ll talk more about this testing
    module in the next section, but for now consider it a helpful way to create a
    temporary Angular module and then get a reference to the services for the test
    to consume.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中还有更多的事情在进行，但其中大部分都与模拟 Http 所需的设置有关。`describe` 块首先声明了一些仅在这些测试中包含的变量。然后
    `beforeEach` 块构建了一个测试模块，这样我们就可以使用依赖注入（手动设置需要注入依赖项的测试通常很困难）来正确实例化服务。我们将在下一节中更详细地讨论这个测试模块，但到目前为止，可以将其视为创建一个临时的
    Angular 模块并获取服务引用以便测试消费的有用方式。
- en: The `afterEach` block is used to run a test to verify that there are no extra
    HTTP requests that haven’t been properly resolved. This is helpful to avoid a
    test making an HTTP request that wasn’t expected, because that could indicate
    an issue with a test or that the methods called weren’t fully tested.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`afterEach` 块用于运行一个测试来验证没有未正确解决的额外 HTTP 请求。这有助于避免测试发起一个未预期的 HTTP 请求，因为这可能表明测试存在问题或调用的方法没有得到充分测试。'
- en: Then we have a simple test that checks that the service was instantiated, and
    another one to test the manipulation of the symbols. If the service failed to
    load, that’s probably because of a change in the dependencies or a coding error
    that will get caught here. The symbol manipulation methods are easy to test because
    they mutate the list of symbols. The test starts by testing that the service gets
    the expected default list of stocks, adds a new item and validates that it was
    retained, and finally removes it with verification.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有一个简单的测试来检查服务是否已实例化，还有一个测试来检查符号的操作。如果服务未能加载，那可能是因为依赖项发生了变化或是一个在此处会被捕获的编码错误。由于符号操作方法会改变符号列表，因此它们很容易测试。测试首先检查服务是否获取到预期的默认股票列表，添加一个新项目并验证它是否被保留，最后将其删除并进行验证。
- en: Mocking HTTP requests
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 模拟 HTTP 请求
- en: The last two tests are very similar because they both deal with making HTTP
    requests. Let’s walk through the first one closely, and the second one will also
    become clear as we go.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个测试非常相似，因为它们都涉及发起 HTTP 请求。让我们仔细地走过第一个，第二个随着我们的进行也会变得清晰。
- en: When we declare the `it` block, we start by also passing the `done` parameter
    into the test function. We’ll use this to tell the test when it has finished—otherwise
    it would be out of sync. What we’ll be doing is triggering an HTTP request using
    our service, and then later calling a service that will fire the response, allowing
    us to handle some setup before the HTTP request is made.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们声明 `it` 块时，我们首先也将 `done` 参数传递给测试函数。我们将使用它来告诉测试何时完成——否则它就会不同步。我们将做的是通过我们的服务触发一个
    HTTP 请求，然后稍后调用一个将触发响应的服务，这样我们就可以在发起 HTTP 请求之前处理一些设置。
- en: 'The first step is to make an HTTP request using the service, as you see here:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是使用服务发起一个 HTTP 请求，就像你在这里看到的那样：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is saying that we want to call the `load` method, subscribe to the response,
    and when it returns, verify that it matches our expectations. Finally it calls
    the `done` function to tell the test it has finished. This will make the observable
    subscribe immediately, but since we imported the `HttpClientTestingModule`, it
    won’t fire a request yet allowing the code after this block to execute.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们想要调用`load`方法，订阅响应，并在它返回时验证它是否符合我们的预期。最后，它调用`done`函数来告诉测试已完成。这将使可观察者立即订阅，但由于我们导入了`HttpClientTestingModule`，它不会立即发起请求，从而允许此代码块之后的代码执行。
- en: 'Then we use the `HttpTestingController` (part of the `HttpClientTestingModule`,
    which we injected in the `beforeEach` earlier), and we declare that we expect
    one URL to be called. We build the expected URL, pass it to `http.expectOne`,
    and then the test will know to look out for this URL. If it fails to be requested
    for some reason, the `afterEach` would verify that it wasn’t called and throw
    an error. That’s the first line of the following code, and the second line tells
    the test to finally `flush`, or resolve, any pending requests for this URL, and
    takes an argument with the payload to send:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`HttpTestingController`（它是`HttpClientTestingModule`的一部分，我们在`beforeEach`中注入了它），并声明我们期望调用一个URL。我们构建预期的URL，将其传递给`http.expectOne`，然后测试将知道要寻找这个URL。如果由于某种原因未能请求，`afterEach`将验证它没有被调用并抛出错误。这是以下代码的第一行，第二行告诉测试最终`flush`或解决此URL的任何挂起请求，并带有一个要发送的有效负载参数：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Because our service should have made this request, at this point the result
    should be returned like a real response. The subscribe method would emit the `MocksStockResponse`
    object (because that’s what the `flush` method sends), and then the test would
    verify the match to complete the test. The news test follows the same pattern.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的服务应该已经发起了这个请求，在这个时候，结果应该像真实响应一样返回。订阅方法将发出`MocksStockResponse`对象（因为`flush`方法发送的就是这个），然后测试将验证匹配以完成测试。新闻测试遵循相同的模式。
- en: That completes our test for the service. You could extend this suite to test
    different edge cases, such as the server sending back a 500 status error, or the
    server sending back an invalid body. Those additional tests would help you identify
    weaknesses in the service. As it stands, this service mostly assumes that everything
    works correctly and could be made more resilient.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们对服务的测试。你可以扩展这个测试套件来测试不同的边缘情况，例如服务器返回500状态错误，或者服务器返回无效的正文。这些额外的测试将帮助你识别服务的弱点。就目前而言，这个服务主要假设一切正常工作，并且可以使其更加健壮。
- en: Stubbing a service
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 模拟服务
- en: Before we write tests for components, we will want to stub the Stocks service.
    This will help simplify our other tests because our stub won’t call HTTP, and
    that allows us to avoid having to do the HTTP mocking in every component that
    calls the service for data.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们为组件编写测试之前，我们希望模拟`Stocks`服务。这将有助于简化我们的其他测试，因为我们的模拟不会调用HTTP，这使我们能够避免在每个调用服务获取数据的组件中进行HTTP模拟。
- en: Stubs can be created and used in a variety of ways. Angular allows us to substitute
    a mock in place of the real thing using dependency injection, making mocks very
    easy to use. It’s even possible to stub entities other than just services, though
    they’re less common and not covered in this chapter.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟可以以多种方式创建和使用。Angular允许我们使用依赖注入在真实事物的地方替换模拟，这使得模拟非常容易使用。甚至可以模拟除了服务之外的其他实体，尽管它们不太常见，且本章未涉及。
- en: There are many perspectives on how and what to stub, and I don’t want to get
    into that debate here. I typically suggest keeping it simple and only building
    what’s necessary at first. Stubs are additional code to maintain, because they
    need to stay in sync with your service, so keep them simple and light. Some argue
    that you should stub any dependency for a particular test, but you should realize
    that comes with a cost to build and maintain.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何和什么要模拟有许多观点，我不想在这里陷入争论。我通常建议保持简单，最初只构建必要的部分。模拟是额外的代码，需要维护，因为它们需要与你的服务保持同步，所以请保持它们简单和轻量。有些人认为你应该为特定的测试模拟任何依赖项，但你应该意识到这会带来构建和维护的成本。
- en: Let’s create our stub by adding a new file to src/app/services/stocks.service.stub.ts
    and including the content from the following listing. It will craft a new class
    that uses the mock data and expose the same methods as the real service.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过向`src/app/services/stocks.service.stub.ts`添加一个新文件并包含以下列表中的内容来创建我们的模拟。它将创建一个新的类，使用模拟数据，并公开与真实服务相同的方法。
- en: '**Listing 10.4** Stub Stocks service'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 10.4** 占位符 Stocks 服务'
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This stub is crafted by extending the Stocks service, so that we don’t have
    to implement all the methods. This allows us to focus on writing code only for
    the methods that we need to change. Because we’re extending the method, we also
    need to call the `super` method in the constructor to pass in the dependencies.
    What’s of interest here is that we’re passing a blank object but casting it as
    the HttpClient service, so the compiler is happy, but it doesn’t need to use the
    real thing. We create the same behavior as well for getNewsSnapshot.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个占位符是通过扩展 Stocks 服务创建的，这样我们就不必实现所有方法。这使我们能够专注于仅编写我们需要更改的方法的代码。因为我们正在扩展方法，所以我们还需要在构造函数中调用
    `super` 方法来传递依赖项。这里有趣的是，我们传递了一个空对象，但将其转换为 HttpClient 服务，这样编译器就会高兴，但实际上并不需要使用真实的服务。我们同样为
    getNewsSnapshot 创建了相同的行为。
- en: 'The Stocks service defines the `add`, `remove`, and `get` methods, which don’t
    need to be stubbed because they work just fine as they are without side effects.
    Often you can get away with using the real service or its methods in your tests.
    Here’s a list of some common side effects of a service and why you would stub
    them:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Stocks 服务定义了 `add`、`remove` 和 `get` 方法，这些方法不需要进行占位符处理，因为它们在没有副作用的情况下工作得很好。通常，你可以在测试中使用真实服务或其方法。以下是一些常见服务副作用及其原因的列表：
- en: '*Asynchronous* —If there are async events, tests have to be written in a way
    that handles that behavior. This can make them harder to test, but writing a stub
    for these can eliminate that.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*异步* — 如果存在异步事件，测试必须以处理该行为的方式进行编写。这可能会使测试变得更具挑战性，但为这些事件编写占位符可以消除这种挑战。'
- en: '*External dependencies* —When an entity requires an external dependency (such
    as the Http service), it may require jumping through additional hoops to set up,
    and that can be avoided by stubbing it.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*外部依赖项* — 当实体需要外部依赖项（如 Http 服务）时，可能需要跳过额外的步骤来设置，而占位符可以避免这种情况。'
- en: '*Internal state* —Sometimes services or entities have internal state that you
    need to manipulate in your tests, but the service doesn’t expose. A stub can expose
    additional logic to allow you to mutate that state.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*内部状态* — 有时服务或实体具有需要你在测试中操作的内部状态，但服务没有公开。占位符可以公开额外的逻辑，允许你修改该状态。'
- en: '*Redirects* —Anytime an entity tries to redirect the user away from the current
    context, this usually breaks the test. Stubbing can prevent the location changes.
    This is usually a challenge for tests that deal with user authentication, for
    example.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*重定向* — 任何实体试图将用户从当前上下文重定向的情况通常都会破坏测试。占位符可以防止位置变化。这对于处理用户身份验证等测试通常是一个挑战。'
- en: Carefully consider whether you need a stub before creating one. Most applications
    will benefit from having stubs for at least some of the services, but not everything
    makes sense as a stub. Imagine, for example, that you have a service that reads
    and sets from localStorage; the scope of this service is very focused and doesn’t
    have any of the side effects given in the preceding list, so it’s a good candidate
    for something that might not need to be stubbed.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建占位符之前仔细考虑是否需要它。大多数应用程序将受益于至少为一些服务提供占位符，但并非所有内容都适合作为占位符。例如，假设你有一个从 localStorage
    读取和设置的服务；这个服务的范围非常集中，并且没有前述列表中给出的任何副作用，因此它是一个很好的候选者，可能不需要进行占位符处理。
- en: If you prefer to always use strict typing with TypeScript, you may run into
    issues if the stub doesn’t implement the exact same interface as the real service.
    You can rectify this by writing the stub to return values with the same types,
    or you can loosen the type safety of your code in the tests.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢始终使用 TypeScript 的严格类型，如果占位符没有实现与真实服务完全相同的接口，你可能会遇到问题。你可以通过编写占位符以返回具有相同类型的值来纠正这一点，或者你可以在测试中放宽代码的类型安全性。
- en: 10.2.4 Testing components and using testing modules
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.4 测试组件和使用测试模块
- en: 'Components are the building blocks of your application, and they have two key
    parts that we’re interested in testing: the controller and the view. We can test
    individual methods in the controller (such as methods that load data from a service),
    but we also want to validate behaviors on the template (such as whether the correct
    data was displayed). Because our tests are comprised of testing both things, setting
    up a component test requires an additional step.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是应用程序的构建块，它们有两个我们感兴趣测试的关键部分：控制器和视图。我们可以测试控制器中的单个方法（例如从服务加载数据的方法），但我们还想要验证模板上的行为（例如是否正确显示了数据）。因为我们的测试包括测试这两者，设置组件测试需要额外的步骤。
- en: When we want to test a component, we need to start by creating a test module
    that’s a miniature Angular application with the bare minimum required to set up
    and run. The more you import and include in the test module, the slower it will
    be to run the test, and the less isolated the test becomes. Technically, you could
    bootstrap the normal Angular application before each test, but that’s in opposition
    to the concepts of unit testing and will make your tests significantly slower.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要测试一个组件时，我们需要首先创建一个测试模块，这是一个微型Angular应用程序，包含设置和运行所需的最小内容。你导入和包含在测试模块中的内容越多，运行测试的速度就越慢，测试的隔离性就越低。技术上，你可以在每个测试之前引导正常的Angular应用程序，但这与单元测试的概念相悖，并且会使你的测试显著变慢。
- en: Setting up the test module happens in a `beforeEach` statement of your test
    and is quite similar to defining a regular Angular module. You’re able to declare
    a list of providers, imports, declarations, and so forth, and then can get some
    references to the target component for easy testing.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 测试模块的设置发生在测试的`beforeEach`语句中，并且与定义常规Angular模块非常相似。你可以声明一系列提供者、导入、声明等，然后可以获取一些目标组件的引用，以便于测试。
- en: To see this in action, let’s write our first test for a component. The Manage
    component is a good one to start with, so open the src/app/components/manage/manage.component.spec.ts
    file and include the code from the following listing.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到这个功能在实际中的运用，让我们为组件编写第一个测试。管理组件是一个很好的起点，所以打开src/app/components/manage/manage.component.spec.ts文件，并包含以下列表中的代码。
- en: '**Listing 10.5** Manage component test'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表10.5** 管理组件测试'
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This test contains the usual `import` block, which contains the `ComponentFixture`
    and `TestBed` objects from Angular. These are what we’ll use to create the test
    module and bootstrap the component. When the Angular CLI generates component tests,
    it will create the test with a test module for you, similar to what you see here.
    The `describe` block contains a few variable references, which we’ll assign values
    to later. Then you’ll need to add any additional pieces into the test module that
    your component requires. In this example, we require the Forms module, because
    we use NgModel, and the Stocks service, and the stub service is injected as the
    Stocks service.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试包含通常的`import`块，其中包含来自Angular的`ComponentFixture`和`TestBed`对象。我们将使用这些对象来创建测试模块并引导组件。当Angular
    CLI生成组件测试时，它将为你创建一个具有测试模块的测试，类似于你在这里看到的那样。`describe`块包含一些变量引用，稍后我们将为它们赋值。然后你需要在测试模块中添加任何额外的组件所需的组件。在这个例子中，我们要求表单模块，因为我们使用了NgModel，以及股票服务，并且存根服务作为股票服务注入。
- en: The `TestBed.configureTestingModule` method will set up a module with the base
    Angular services (like default pipes and directives), and returns a `TestBed`
    object. If you’re not using the Angular CLI, you might need to call the `compileComponents`
    method (see the Angular documentation for details).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestBed.configureTestingModule`方法将设置一个包含基本Angular服务（如默认管道和指令）的模块，并返回一个`TestBed`对象。如果你没有使用Angular
    CLI，你可能需要调用`compileComponents`方法（有关详细信息，请参阅Angular文档）。'
- en: The next `beforeEach` block uses the `TestBed` to create an instance of the
    component to test and assigns the instance of the component and the native DOM
    element to variables. The `fixture.detectChanges` method is used to manually trigger
    change detection and make sure that the components reflect their current state—otherwise
    the state might not be accurate. The first test is another simple check to see
    if the component was created correctly.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个`beforeEach`块使用`TestBed`创建要测试的组件的实例，并将组件实例和原生DOM元素分配给变量。`fixture.detectChanges`方法用于手动触发变更检测并确保组件反映了它们当前的状态——否则状态可能不准确。第一个测试是另一个简单的检查，以查看组件是否正确创建。
- en: 'The second test exercises the component methods that are used to manipulate
    the list of symbols. The Manage component implementation is calling the mock service
    instead of the real one in this case, because we declared that in the testing
    module providers. The test is simple: It checks the default array of symbols against
    the mock values, adding and then removing an item, and checks whether the list
    of symbols is built as expected. I like to call this kind of test a *controller
    unit test*, because it directly uses the controller methods.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个测试练习了用于操作符号列表的组件方法。在这种情况下，Manage组件实现调用模拟服务而不是真实服务，因为我们已经在测试模块提供者中声明了这一点。测试很简单：它检查默认的符号数组与模拟值，添加然后删除一个项目，并检查符号列表是否按预期构建。我喜欢将这种测试称为*控制器单元测试*，因为它直接使用控制器方法。
- en: The final test looks at the rendered view to see if the component has displayed
    data as expected. It uses the DOM element to query for all the rows and verify
    that each of the symbols is being displayed in the DOM. I like to refer to this
    kind of test as a *view unit test*, because it observes the rendered output of
    the view. Sometimes a test does both things, but I attempt to keep them focused.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最终测试检查渲染视图，以查看组件是否按预期显示了数据。它使用DOM元素查询所有行，并验证每个符号是否在DOM中显示。我喜欢将这种测试称为*视图单元测试*，因为它观察视图的渲染输出。有时一个测试会做两件事，但我试图保持它们集中。
- en: That summarizes the primary tenets of a component test, the creation of a testing
    module, including or stubbing dependencies, rendering the component, and testing
    either the controller or view.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这总结了组件测试的主要原则，包括创建测试模块、包括或模拟依赖项、渲染组件以及测试控制器或视图。
- en: Stubbing directives or components and using DebugElement
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 模拟指令或组件和使用DebugElement
- en: There are times where you don’t want a directive or child component to render
    in the test. In this example, our Delay directive gives us a little bit of trouble
    because it delays the rendering of items, and our tests either have to wait for
    it to complete or work around it some other way. But we can stub the Delay directive
    and have it display immediately. We’ll get the test coverage that the Delay directive
    works when we test it directly.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你不想在测试中渲染指令或子组件。在这个例子中，我们的Delay指令给我们带来了一些麻烦，因为它延迟了项目的渲染，我们的测试要么等待它完成，要么以其他方式绕过它。但我们可以模拟Delay指令，让它立即显示。当我们直接测试它时，我们会得到Delay指令工作的测试覆盖率。
- en: We want to test the Dashboard component, which loads a few things. In order
    to focus on just the Dashboard component, we’ll also stub the Summary component,
    because it has animations that can get in the way.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想测试仪表盘组件，它加载了一些内容。为了只关注仪表盘组件，我们还将模拟Summary组件，因为它有动画可能会妨碍测试。
- en: There’s also another way to look at the rendered view, by using the Angular
    `DebugElement`. Instead of using the native DOM element directly, the `DebugElement`
    gives us a few additional options, the most powerful of which allows us to query
    the element based on a directive instead of only CSS selectors. We’ll see how
    to use that in this example.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种方法可以查看渲染视图，即使用Angular的`DebugElement`。与直接使用原生DOM元素相比，`DebugElement`给我们提供了一些额外的选项，其中最强大的是允许我们根据指令而不是仅CSS选择器查询元素。我们将在本例中看到如何使用它。
- en: Let’s create our test for the Dashboard component. Open up the src/app/components/dashboard/dashboard.component.spec.ts
    file and replace it with what’s shown in the following listing. We’ll stub the
    Summary component and the `Delay` directive, and query using the `DebugElement`
    and a directive.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为仪表盘组件创建测试。打开src/app/components/dashboard/dashboard.component.spec.ts文件，并用以下列表中的内容替换它。我们将模拟Summary组件和`Delay`指令，并使用`DebugElement`和指令进行查询。
- en: '**Listing 10.6** Dashboard component test'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 10.6** 仪表盘组件测试'
- en: '[PRE32]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: I’ve put the `Delay` directive stub inline for this test, because I won’t use
    it anywhere else. I find it useful to keep it localized unless you’re reusing
    the stub in multiple places, like the Stocks service. All this stub does is implement
    a directive that immediately renders the view without the delay, but it does have
    the same selector to ensure that it’s used in the component. The real Delay component
    causes a problem with tests because it doesn’t render immediately, and if we waited
    for it to finish it could take a while, depending on the number of items.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这个测试中将`Delay`指令占位符内联放置，因为我在其他地方不会用到它。我发现除非你需要在多个地方重用占位符，比如在股票服务中，否则保留它在本地是有用的。这个占位符所做的只是实现一个立即渲染视图而不延迟的指令，但它确实有相同的选择器以确保它在组件中使用。真正的延迟组件在测试中会引起问题，因为它不会立即渲染，如果我们等待它完成，可能需要一段时间，这取决于项目数量。
- en: Likewise, we declare the Summary component stub inline because it isn’t used
    anywhere else, and it’s a simple component that implements the smallest interface
    for the component. The component accepts a single input (it would not compile
    if we didn’t add the input), and there’s an expectation that there’s an element
    with the `mdl-card` class on it.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们也将摘要组件占位符内联声明，因为它在其他地方没有使用，它是一个实现组件最小接口的简单组件。该组件接受单个输入（如果我们没有添加输入，它将无法编译），并且期望有一个带有`mdl-card`类的元素。
- en: Because this is an isolated test, we declare the stubs as part of the test module
    and also include the real version of other directives that don’t have an asynchronous
    nature to them. If we didn’t include them, the test would complain about not being
    able to render those directives. In the `beforeEach`, we also put a couple of
    `expect` statements that check that the stocks are loaded after the component
    has rendered.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这是一个隔离的测试，我们将占位符作为测试模块的一部分声明，并包括其他没有异步特性的指令的真实版本。如果我们不包括它们，测试会抱怨无法渲染这些指令。在`beforeEach`中，我们还放置了几个`expect`语句，检查组件渲染后股票是否已加载。
- en: The primary test here runs two expect assertions against the view. The Dashboard
    component doesn’t have a lot of methods to test the controller with, except the
    `OnInit`, which loads data. Because that’s checked in a `beforeEach` block, we
    can focus on the view. The test uses `DebugElement` from the `TestBed` instance,
    and uses the query capability to inspect the element based on a CSS selector.
    The first query checks that the Loading text doesn’t display any more. The second
    query looks for all elements that are of the stub Summary component type (remember,
    components are directives). These queries use the `By` object to construct the
    selector for you based on directive or CSS selector. `DebugElement` also gives
    you access to element properties like the `innerHTML` property.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要测试对视图运行两个`expect`断言。仪表板组件没有很多方法可以用来测试控制器，除了`OnInit`，它加载数据。因为那是在`beforeEach`块中检查的，所以我们可以专注于视图。测试使用`TestBed`实例中的`DebugElement`，并使用查询能力根据CSS选择器检查元素。第一个查询检查加载文本不再显示。第二个查询查找所有属于占位符摘要组件类型的元素（记住，组件是指令）。这些查询使用`By`对象为您构造选择器，基于指令或CSS选择器。`DebugElement`还允许您访问元素属性，如`innerHTML`属性。
- en: I recommend choosing to use either the native DOM element or `DebugElement`
    approach to inspect the component views. Mixing them works all right, but consistency
    is a good goal.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议选择使用原生的DOM元素或`DebugElement`方法来检查组件视图。混合使用是可以的，但一致性是一个良好的目标。
- en: Testing components with inputs and animations
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用输入和动画测试组件
- en: Sometimes our components have inputs, and we need to handle those in our tests.
    For example, the Summary component accepts an input of the stock value, and we
    want to ensure that it renders as expected, even if the stock price has gone up
    or down.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们的组件有输入，我们需要在测试中处理这些输入。例如，摘要组件接受股票价值的输入，我们想要确保它按预期渲染，即使股票价格已经上涨或下跌。
- en: The Summary component also has an animation to allow it to fade in, and our
    testing module needs to be able to handle that scenario. Angular allows us to
    bypass the animations so they don’t interfere with fast-running tests.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要组件也有一个动画，允许它淡入，我们的测试模块需要能够处理这种情况。Angular允许我们绕过动画，这样它们就不会干扰快速运行的测试。
- en: Most of the Summary component test is familiar by now, so we’ll focus only on
    the new pieces. Open src/app/components/summary/summary.component.spec.ts and
    use the code from the following listing.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，摘要组件的测试已经很熟悉了，所以我们只关注新的部分。打开 `src/app/components/summary/summary.component.spec.ts`
    并使用以下列表中的代码。
- en: '**Listing 10.7** Summary component test'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 10.7**  摘要组件测试'
- en: '[PRE38]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `NoopAnimationsModule` is used to support the animations dependencies that
    are required by the component, but when it runs, the animations don’t animate.
    This is good for test cases, because animations take time and slow down the test.
    If you want to test animations, you’ll probably want to do that using e2e style
    testing.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `NoopAnimationsModule` 来支持组件所需的动画依赖项，但在运行时，动画不会动画化。这对于测试用例来说很好，因为动画需要时间并且会减慢测试速度。如果你想要测试动画，你可能希望使用端到端风格测试来执行测试。
- en: In order to handle testing the input, we treat it just like a normal property.
    In fact, it is a normal property, except it has the ability to receive data from
    a binding when used. During our test we’re focused primarily on how it works,
    and not on whether the binding works. We tested the binding in our Dashboard component,
    so we can trust that it will have a binding. In the test, we set the `stock` property
    to a known value and then run change detection to update the view.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理输入的测试，我们将它当作一个普通属性来处理。实际上，它确实是一个普通属性，只不过当它被使用时，它有从绑定接收数据的能力。在我们的测试中，我们主要关注它是如何工作的，而不是绑定是否工作。我们在仪表板组件中测试了绑定，所以我们可以相信它将有一个绑定。在测试中，我们将
    `stock` 属性设置为一个已知值，然后运行变更检测来更新视图。
- en: Then we check the view by inspecting the content of the view and checking whether
    the values rendered as expected based on the stock data. We have another test
    to verify that different stock data still renders the result as expected.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过检查视图的内容并检查根据股票数据渲染的值是否符合预期来检查视图。我们还有一个测试来验证不同的股票数据仍然可以按预期渲染结果。
- en: Testing components with the router
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用路由测试组件
- en: There’s one last component to test, the App component, and it contains a router
    outlet that we need to handle in our tests. The App component also has the navbar,
    which renders out the latest news item that we’d like to test. It’s not much different
    from any other component in how we need to test it. Anything that this component
    directly uses will need to be imported or stubbed in some way, and that includes
    setting up the router and using the stub service.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最后还有一个组件需要测试，那就是 App 组件，它包含一个我们需要在测试中处理的路由出口。App 组件还有一个导航栏，它渲染了我们要测试的最新新闻条目。在测试它时，它与任何其他组件没有太大区别。这个组件直接使用的任何东西都需要以某种方式导入或模拟，包括设置路由和使用模拟服务。
- en: Let’s take a look at the App component test and see what’s different for a component
    containing a router outlet. Open src/app/app.component.spec.ts and replace its
    contents with those in the following listing.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看包含路由出口的组件测试，看看它与其他组件有什么不同。打开 `src/app/app.component.spec.ts` 并将其内容替换为以下列表中的内容。
- en: '**Listing 10.8** App component test'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 10.8**  App 组件测试'
- en: '[PRE43]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This test is set up just like the rest, with the exception that it has the Router
    module set up. The Router module makes the router outlet and router link directives
    available for the test module to render. It also requires us to provide the `APP_BASE_HREF`,
    but override it with a value. It can be any valid path, but almost always you’ll
    want to use `/`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试的设置与其他测试类似，只是它设置了路由模块。路由模块使路由出口和路由链接指令对测试模块可用，以便渲染。它还要求我们提供 `APP_BASE_HREF`，但需要用值覆盖它。它可以是一个有效的路径，但几乎总是希望使用
    `/`。
- en: Then, inside of the test, we check that the component has the mock news title
    rendered somewhere in the view. This is quick way to verify that the News pipe
    has run and used the stub Stocks service to return the mock news data.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在测试中，我们检查组件是否在视图中渲染了模拟新闻标题。这是一种快速验证新闻管道是否运行并使用模拟股票服务返回模拟新闻数据的方法。
- en: That wraps up the tests for our components in this example. As you build more
    complex components, the tests will also become more complex. This is a good reason
    to create many smaller components instead of a few large ones, so keep that in
    mind. Also, if you have good separation of concerns (such as data access is in
    services, and rendering views is in components), you can more easily stub those
    different aspects and write tests to focus on a smaller surface area.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们在这个示例中组件的测试。随着你构建更复杂的组件，测试也将变得更加复杂。这是一个很好的理由，要创建许多较小的组件而不是几个大的组件，所以请记住这一点。此外，如果你有良好的关注点分离（例如数据访问在服务中，渲染视图在组件中），你可以更容易地存根这些不同的方面并编写针对较小范围的测试。
- en: 10.2.5 Testing directives
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.5 指令测试
- en: Directives can be the trickiest thing to test because they’re modifiers of elements.
    Directives are tested by attaching them to an element or component and verifying
    that the view has changed accordingly. They can be attached to a real component
    from your application, but I prefer to make a stub component for the test to simplify
    the testing scenarios.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 指令可能是最难测试的东西，因为它们是元素的修饰符。通过将它们附加到元素或组件上并验证视图是否相应地更改来测试指令。它们可以附加到你的应用程序中的真实组件上，但我更喜欢为测试创建一个存根组件以简化测试场景。
- en: We’ll test with two different approaches. The first is to create the directive
    ourselves by passing in a constructed component. The second is to allow the testing
    module to construct it for us.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用两种不同的方法进行测试。第一种是通过传递一个构造的组件来创建指令。第二种是允许测试模块为我们构造它。
- en: The reason you might opt to construct it yourself is that you can call elements
    on the directive directly that way. Otherwise, the directive isn’t easily accessible
    to you in the testing module.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能选择自己构建它的原因是你可以直接在指令上调用元素。否则，指令在测试模块中不易访问。
- en: We’re going to look at two of the three directives to test in this section.
    The third doesn’t provide anything new, but you can review the test in the GitHub
    repository. The first test will be for the CardHover attribute directive, and
    the second will be for the Delay structural directive.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这个部分查看三个指令中的两个进行测试。第三个指令没有提供任何新内容，但你可以查看GitHub仓库中的测试。第一个测试将是针对CardHover属性指令，第二个将是针对Delay结构指令。
- en: Let’s start with the CardHover directive. In this test, we’ll create the directive
    ourselves, but we’ll still need a testing module to set up the stub component.
    Recall that this is to help us encapsulate the logic needed to determine if a
    card is being hovered, and also to modify the default colors of the Summary component.
    Open src/app/directives/card-hover.directive.spec.ts and use the code from the
    following listing to complete the test.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从CardHover指令开始。在这个测试中，我们将自己创建指令，但仍然需要一个测试模块来设置存根组件。回想一下，这是为了帮助我们封装确定卡片是否被悬停的逻辑，以及修改Summary组件的默认颜色。打开`src/app/directives/card-hover.directive.spec.ts`并使用以下列表中的代码来完成测试。
- en: '**Listing 10.9** CardHover directive test'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表10.9** CardHover指令测试'
- en: '[PRE47]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: There are a lot of familiar aspects to this test when you compare it with a
    component, but the differences are important. First, we create a stub component
    that has the expected classes and structure, as well as the directive applied.
    The testing module is created and set up so that the stub component can be properly
    instantiated.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 与组件相比，当你比较这个测试时，有很多熟悉的部分，但差异很重要。首先，我们创建一个具有预期类和结构以及应用了指令的存根组件。测试模块被创建并设置，以便可以正确实例化存根组件。
- en: In the next `beforeEach` block, we do two important tasks. First we get the
    compiled component from the testing module, and then we create a new instance
    of the CardHover directive. Notice that the directive expects a parameter that
    contains an `ElementRef`, which is a wrapper around the component native DOM element.
    The directive exists outside of the testing module, so we have to call the lifecycle
    methods directly ourselves, like `directive.ngOnInit`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个`beforeEach`块中，我们执行两个重要任务。首先，我们从测试模块获取编译后的组件，然后创建一个新的CardHover指令实例。请注意，指令期望一个包含`ElementRef`的参数，`ElementRef`是对组件原生DOM元素的包装。指令存在于测试模块之外，因此我们必须直接调用生命周期方法，例如`directive.ngOnInit`。
- en: Now that we have the directive ready, we can test it by looking at the rendered
    card and seeing if the background color matches the expected values based on the
    current classes applied to the card. We’re directly manipulating the element and
    then running the `ngOnInit` lifecycle hook again in order to simulate the change.
    Notice that we don’t use the fixture to run change detection, because we’ve bypassed
    the testing module by creating the directive ourselves.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这个指令，我们可以通过查看渲染的卡片并检查其背景颜色是否与当前应用于卡片的预期值匹配来测试它。我们直接操作元素，然后再次运行 `ngOnInit`
    生命周期钩子来模拟变化。请注意，我们不需要使用 fixture 来运行变更检测，因为我们通过自己创建指令绕过了测试模块。
- en: The last test calls the two mouse event methods directly and verifies that when
    they fire, the card styling is as expected. Any methods that you need to test
    can be called directly like this, but only if you can get the reference of the
    directive when you create it manually.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个测试直接调用两个鼠标事件方法，并验证当它们触发时，卡片的样式是否符合预期。任何需要测试的方法都可以像这样直接调用，但前提是在手动创建时能够获取指令的引用。
- en: Although we’ve tested this directive by creating it ourselves, using a testing
    module to set things up is usually preferred. That ensures things are plumbed
    and can make life a little easier, but at the cost of calling directive methods
    directly. You may want to create a set of tests that call the directive directly
    if you want to validate the internals of a method, and then use a testing module
    for the rest.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们通过自己创建它来测试了这个指令，但通常更喜欢使用测试模块来设置环境。这确保了事物被正确连接，可以使生活变得稍微容易一些，但代价是直接调用指令方法。如果你想要验证方法内部，可能需要创建一组直接调用指令的测试，然后使用测试模块进行其余部分的测试。
- en: Handling asynchronous tasks in tests
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在测试中处理异步任务
- en: The last test we’ll write also shows us two ways we can handle asynchronous
    tasks in our tests. We’ll be testing the Delay directive, which waits to render
    the component for a certain number of milliseconds. Unlike the way the Http service
    allows us to mock the response and handle it in the test, we need to use one of
    two options from Angular that help ensure that tests have executed everything
    properly even when things happen async.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要编写的最后一个测试还展示了我们在测试中处理异步任务的两个方法。我们将测试延迟指令，该指令等待渲染组件一定数量的毫秒。与 Http 服务允许我们模拟响应并在测试中处理它的方式不同，我们需要使用
    Angular 的两个选项之一来确保测试在异步事件发生时也能正确执行所有操作。
- en: Angular provides a way to fake async events, specifically intervals and timeouts,
    and provides a way to wait for async events to finalize before continuing execution.
    We’ll write the same test twice using both approaches so you can see them side
    by side. By default, Jasmine assumes that tests are synchronous but does provide
    an optional `done` callback object that you can use to handle async tasks, but
    with Angular’s testing utilities, that shouldn’t be necessary, and using the two
    options demonstrated here is recommended.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 提供了一种模拟异步事件的方法，特别是间隔和超时，并提供了一种在继续执行之前等待异步事件最终完成的方法。我们将使用这两种方法各写两次相同的测试，以便你可以并排看到它们。默认情况下，Jasmine
    假设测试是同步的，但确实提供了一个可选的 `done` 回调对象，你可以使用它来处理异步任务，但使用 Angular 的测试工具，这通常是不必要的，并且建议使用这里展示的两个选项。
- en: The Delay directive test is located at src/app/directives/delay.directive.spec.ts.
    Open it and replace its contents with the code from the following listing.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟指令测试位于 src/app/directives/delay.directive.spec.ts。打开它，并用以下列表中的代码替换其内容。
- en: '**Listing 10.10** Delay directive test'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 10.10** 延迟指令测试'
- en: '[PRE54]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In this example, we’re creating a stub component and ensuring that it implements
    the Delay directive. We’re setting the delay to 10 milliseconds, so it doesn’t
    make for a long delay when running the test. If we made this 1 second, it would
    halt test execution for 1 second—not desirable. The testing module is then configured
    by declaring both the mock component and Delay directive.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个存根组件，并确保它实现了延迟指令。我们将延迟设置为 10 毫秒，这样在运行测试时不会造成长时间的延迟。如果我们将其设置为 1
    秒，测试执行将暂停 1 秒——这是不希望的。然后通过声明模拟组件和延迟指令来配置测试模块。
- en: The first test uses the `fakeAsync` handler to wrap the execution of the test.
    It works by returning a synchronous function for the test to run and also exposes
    the additional `tick` object. Inside of the `fakeAsync` handler, you can run expectations
    to validate that on initialization, the directive doesn’t display the content
    of the component, and then call `tick` to trigger any timer events. We pass `tick(10)`
    to trigger the timer events at 10 milliseconds, which is the value configured
    in our mock component. If you have multiple timer events, you can use `tick` to
    step through the different timer events and verify behavior between each step.
    The `tick` function is only available inside of the `fakeAsync` handler.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次测试使用`fakeAsync`处理程序来包装测试的执行。它通过为测试返回一个同步函数来运行，同时也暴露了额外的`tick`对象。在`fakeAsync`处理程序内部，你可以运行期望来验证在初始化时，指令不会显示组件的内容，然后调用`tick`来触发任何计时器事件。我们传递`tick(10)`来在10毫秒处触发计时器事件，这是我们在模拟组件中配置的值。如果你有多个计时器事件，你可以使用`tick`来逐步通过不同的计时器事件并验证每个步骤之间的行为。`tick`函数仅在`fakeAsync`处理程序内部可用。
- en: The second test uses the `async` handler, which handles telling the test to
    wait until some async activity has resolved. Here we use `fixture.whenStable().then()`
    to handle waiting the 10 milliseconds for the component to fully render, since
    the directive delays the rendering. Inside of the `then` promise handler, we run
    our expectation to see that the component has rendered. The drawback to this approach
    is that the time­out waits for however long the delay is set, and if you had a
    lot of tests doing similar things, this would slow your tests down considerably.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次测试使用`async`处理程序，它处理告诉测试等待某些异步活动解决。在这里，我们使用`fixture.whenStable().then()`来处理等待10毫秒，以便组件完全渲染，因为指令延迟了渲染。在`then`承诺处理程序内部，我们运行我们的期望来查看组件是否已渲染。这种方法的一个缺点是超时等待延迟设置的时间，如果你有很多测试做类似的事情，这会大大减慢你的测试速度。
- en: I recommend using `fakeAsync` when you can, but note that it doesn’t help you
    deal with HTTP calls. When you use asynchronous calls in your code, be sure to
    consider how to best test that and avoid making lots of nested or simultaneous
    asynchronous calls, if possible. These increase test complexity and probably also
    make your component more difficult to implement.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议尽可能使用`fakeAsync`，但请注意，它不能帮助你处理HTTP调用。当你使用代码中的异步调用时，确保考虑如何最好地测试它，并尽量避免尽可能多地嵌套或同时进行异步调用。这些会增加测试复杂性，也可能使你的组件更难实现。
- en: That wraps up the unit tests for this application. It now has 25 tests, and
    if you run the code coverage analysis, it claims to have tested 100% of the code.
    An experienced developer knows that this doesn’t mean the tests cover every scenario
    or edge case, because many of these tests could be expanded to validate more error
    conditions, for example.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了这个应用的单元测试。现在它有25个测试，如果你运行代码覆盖率分析，它声称已经测试了100%的代码。经验丰富的开发者知道这并不意味着测试覆盖了每个场景或边缘情况，因为许多这些测试可以扩展以验证更多的错误条件，例如。
- en: Now we’ll step out of unit testing and focus on how to test the whole application
    at once using e2e to mimic a real user launching the application.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将退出单元测试，并专注于如何使用端到端测试一次性测试整个应用，以模拟真实用户启动应用。
- en: 10.3 e2e testing
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3端到端测试
- en: Just because all the units of your application are working smoothly in isolation
    doesn’t necessarily guarantee they’ll work together as a whole or with real-world
    data sources. e2e testing is the way you can test your application as a whole
    by controlling it like a real user would.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你应用的所有单元都在独立运行时工作得很好，但这并不一定保证它们作为一个整体或与真实世界的数据源一起工作。端到端测试是通过像真实用户一样控制应用来测试应用整体的方式。
- en: e2e is meant to emulate the same experiences from the user perspective, where
    they click links, type in input fields, and otherwise engage with the application.
    It’s important to keep your mind focused on this as you write e2e tests, because
    this means you should only write tests in a way that are realistic options for
    users. For example, when you navigate between pages, you should have the test
    click the link in the navbar instead of changing the URL in the browser.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试旨在从用户的角度模拟相同的体验，其中他们点击链接、在输入字段中输入，以及其他方式与应用交互。在编写端到端测试时，保持你的注意力集中在这个点上很重要，因为这意味着你应该只编写用户真实可行的测试。例如，当你在不同页面之间导航时，你应该让测试点击导航栏中的链接，而不是在浏览器中更改URL。
- en: I find the best way to think about e2e testing is to consider several of the
    paths through the applications that are important for a user to be successful
    with your application. For example, if your application is based around creating
    invoices, consider testing the primary paths for users to create, edit, manage,
    or delete their invoices. You may also want to focus on key paths such as signing
    up for the service, login flows, and other similar critical tasks.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为思考端到端测试的最佳方式是考虑用户在使用你的应用程序时成功所必需的几个应用程序路径。例如，如果你的应用程序是基于创建发票的，那么考虑测试用户创建、编辑、管理或删除他们发票的主要路径。你可能还希望关注关键路径，如注册服务、登录流程和其他类似的临界任务。
- en: It may not be obvious at first, but there’s a larger cost to creating and maintaining
    e2e tests. These tests may sound like the most comprehensive type of tests to
    write, but the reality is they’re much more difficult to write and maintain than
    unit tests. They also don’t provide clear guarantees like unit tests—a failure
    in an e2e test might or might not mean there’s an issue. They can be hard to repeat
    consistently because they have more variables, such as a real back end and state
    changes that are controlled in unit testing. e2e tests are also much slower to
    execute than unit tests, because they require loading the entire application,
    so expect them to require more time.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 起初可能并不明显，但创建和维护端到端测试的成本可能更高。这些测试可能听起来是编写最全面的测试类型，但现实是它们比单元测试更难编写和维护。它们也不像单元测试那样提供明确的保证——端到端测试中的失败可能或可能不意味着存在问题。由于它们有更多变量，如真实的后端和单元测试中受控的状态变化，因此它们可能难以一致地重复。端到端测试的执行速度也比单元测试慢得多，因为它们需要加载整个应用程序，因此预期它们需要更多时间。
- en: I like to caution that e2e tests are difficult because you have to control so
    many variables, not because they’re inherently difficult to write. Imagine you’re
    testing an application for a forum. You’ll need a test user you can rely on who
    can log in and post messages. But what happens when this test user posts? Does
    it appear on the site? Perhaps you can run the tests on a test or staging environment
    instead of the real production site, but that requires having a test or staging
    site available. Considerations like these make it challenging to orchestrate the
    tests. The larger the system, the more important it is to consult with all parties
    involved in the application about how this testing can be set up and managed.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢提醒大家，端到端测试之所以困难，是因为你必须控制许多变量，而不是因为它们本质上难以编写。想象一下你正在测试一个论坛应用程序。你需要一个可以信赖的测试用户，该用户可以登录并发布消息。但是当这个测试用户发布消息时会发生什么？它是否出现在网站上？也许你可以在一个测试或预发布环境中运行测试，而不是在真实的生产网站上，但这需要有一个测试或预发布网站可用。这样的考虑使得测试的编排变得具有挑战性。系统越大，与所有参与应用程序的各方就如何设置和管理这种测试进行协商就越重要。
- en: Given these potential challenges, you may be less interested in testing flows
    that aren’t vital or are rarely used. The cost might be simply too much for you
    to worry about testing parts of the site that are used 1% of the time.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些潜在的挑战，你可能对测试非关键或很少使用的流程不太感兴趣。成本可能对你来说太高，以至于你不必担心测试那些仅使用1%的网站部分。
- en: Let’s forge ahead anyway and write a few e2e tests for our stock application.
    We’re lucky that our application is simple and stateless. Every time we reload,
    the application is reset, but that’s not typical for most applications, so keep
    that in mind as well.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，让我们继续前进，为我们的股票应用程序编写一些端到端测试。我们很幸运，我们的应用程序简单且无状态。每次我们重新加载，应用程序都会重置，但这对于大多数应用程序来说并不典型，所以也要记住这一点。
- en: Angular CLI provides built-in scaffolding for running e2e tests using Protractor,
    a tool that uses the WebDriver API to remotely control a browser. Protractor was
    written for AngularJS and has a few features that aren’t supported for Angular
    2+ applications (consult the Protractor documentation to see more details, at
    [http://protractortest.org](http://protractortest.org)). Remember that if you
    try to use something from Protractor that doesn’t work, it might be a feature
    that only works for AngularJS.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Angular CLI为使用Protractor运行端到端测试提供了内置的脚手架，Protractor是一个使用WebDriver API远程控制浏览器的工具。Protractor是为AngularJS编写的，有一些功能不支持Angular
    2+应用程序（有关更多详细信息，请参阅Protractor文档，见[http://protractortest.org](http://protractortest.org)）。记住，如果你尝试使用Protractor中不工作的功能，它可能只适用于AngularJS。
- en: When the Angular CLI generates a project, it creates a directory called e2e
    that contains a basic set of tests that work for the default app. We’ll update
    it in a moment with four tests that will verify that both the Dashboard and Manage
    pages load correctly, and then test adding and deleting a stock.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Angular CLI 生成项目时，它会创建一个名为 e2e 的目录，其中包含一组适用于默认应用的基本测试。我们将稍后更新它，包含四个测试，以验证仪表盘和管理页面是否正确加载，然后测试添加和删除股票。
- en: Before we write the tests, we’re going to create something called a *page object*,
    which is a way to define aspects of the pages you want to test in a way that allows
    you to write cleaner-looking tests. We’ll have to write things that are similar
    to CSS selectors, called *page locators*, which are responsible for finding elements
    on the page to interact with.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写测试之前，我们将创建一个名为 *页面对象* 的东西，这是一种定义你想要测试的页面方面的一种方式，它允许你编写看起来更干净的测试。我们不得不编写类似于
    CSS 选择器的东西，称为 *页面定位器*，它们负责在页面上找到与页面交互的元素。
- en: 'Protractor provides two important objects to use for finding elements: `element`
    and `by`. Using them in various combinations, you can find a single element on
    the page, find multiple ones, find a list and then select a specific item from
    it, and more. The `element` object returns an element inside a wrapper (similar
    to what jQuery does to an element) and exposes helpful methods to do things like
    click the element. `element` also accepts an argument that should use the `by`
    object, which helps you construct something like an element query. You can use
    `by.css(''.someClass'')` to locate an element by a CSS selector. This is called
    a *page locator*.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Protractor 提供了两个重要的对象用于查找元素：`element` 和 `by`。通过使用它们的各种组合，你可以在页面上找到一个元素，找到多个元素，找到一个列表然后从中选择一个特定的项目，等等。`element`
    对象返回一个包装器内的元素（类似于 jQuery 对元素所做的操作）并暴露了一些有用的方法来执行点击元素等操作。`element` 还接受一个参数，应该使用
    `by` 对象，这有助于你构建类似元素查询的东西。你可以使用 `by.css('.someClass')` 通过 CSS 选择器定位一个元素。这被称为 *页面定位器*。
- en: Let’s see this in action by writing some code. Create a new file at e2e/dashboard.po.ts
    and use the code from the following listing. This is the `DashboardPage` object,
    and it’s simple. The larger the page, the more things it might contain.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过编写一些代码来看看这个动作。在 e2e 目录下创建一个新的文件 dashboard.po.ts，并使用以下列表中的代码。这是 `DashboardPage`
    对象，它很简单。页面越大，它可能包含的东西就越多。
- en: '**Listing 10.11** DashboardPage object'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 10.11** 仪表盘页面对象'
- en: '[PRE59]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: As a standalone piece of code, this might seem a little strange at first, but
    it’s pretty straightforward. Protractor gives us the `element` and `by` objects,
    which are used to find elements on the page. `element` is like an element wrapper
    object, and the `by` object exposes several methods to find elements based on
    criteria like a CSS selector, link text, button name, or input name. These are
    the fundamental calls you’ll be making to interact like a real user.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一段独立的代码，这可能会在最初看起来有些奇怪，但它相当直接。Protractor 给我们 `element` 和 `by` 对象，这些对象用于在页面上查找元素。`element`
    类似于一个元素包装器对象，而 `by` 对象暴露了基于 CSS 选择器、链接文本、按钮名称或输入名称等标准查找元素的方法。这些是你将用来像真实用户一样交互的基本调用。
- en: We’re defining a class that gives us a few methods that help us navigate or
    select elements. First, the `navigateTo` method looks for the `Dashboard` link
    in the navbar and triggers a `click` event on it, which triggers the navigation
    to the page. The `getCards` method looks for all elements on the page that have
    the `mdl-cell` class, which happens to be all the cards that contain stock items.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个类，它给我们一些帮助我们导航或选择元素的方法。首先，`navigateTo` 方法在导航栏中查找 `Dashboard` 链接并触发其上的
    `click` 事件，这会触发导航到该页面。`getCards` 方法查找页面上所有具有 `mdl-cell` 类的元素，这恰好是包含股票项目的所有卡片。
- en: Let’s go ahead and create another one of these for `ManagePage`. Create another
    file at e2e/manage.po.ts and include the code from the following listing.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续创建另一个 `ManagePage`。在 e2e 目录下创建另一个文件 manage.po.ts，并包含以下列表中的代码。
- en: '**Listing 10.12** ManagePage object'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 10.12** 管理页面对象'
- en: '[PRE63]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: There are a couple more things in this page object, because we have the ability
    to add and remove stocks on this page. The class starts with a `navigate` method
    that clicks the Manage link in the navbar. The next method, `getSymbols`, finds
    all the table cells that contain a stock symbol. Then the `getRemoveButton` method
    accepts an index value and will click the Remove button of the symbol based on
    that row. Finally, `getAdd­Input` finds the stock name input field.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个页面对象中还有一些其他的东西，因为我们有在这个页面上添加和删除股票的能力。类以一个`navigate`方法开始，该方法点击导航栏中的管理链接。下一个方法`getSymbols`找到包含股票符号的所有表格单元格。然后`getRemoveButton`方法接受一个索引值，并将基于该行的符号的删除按钮点击。最后，`getAdd­Input`找到股票名称输入字段。
- en: There are more options for what Protractor provides in its API, so I suggest
    you consult the documentation for full details. Harnessing the page locators can
    give you many options on how to find elements on the page to engage with.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Protractor在其API中提供了更多选项，所以我建议你查阅文档以获取完整详情。利用页面定位器可以给你提供许多在页面上查找元素以进行交互的选项。
- en: All right—now we can write the test. The idea is that our tests are easy to
    read and the code reads very similar to the user’s actions; they should cover
    user expectations as they use the application. Open up the e2e/app.e2e-spec.ts
    file and replace its contents with the code from the following listing.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧——现在我们可以编写测试了。想法是测试易于阅读，代码读起来非常类似于用户的操作；它们应该覆盖用户在使用应用程序时的期望。打开`e2e/app.e2e-spec.ts`文件，并用以下列表中的代码替换其内容。
- en: '**Listing 10.13** App e2e tests'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表10.13** 应用程序端到端测试'
- en: '[PRE68]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Notice how the test is written using the same `describe`, `beforeEach`, and
    `it` blocks we used in unit tests. That’s because we’re using Jasmine as the testing
    framework for describing tests, which helps keep things familiar. During the `beforeEach`
    phase, we construct a new page object for the manage and dashboard pages, and
    then tell the browser to load the main page.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 注意测试是如何使用与单元测试中相同的`describe`、`beforeEach`和`it`块编写的。这是因为我们正在使用Jasmine作为测试框架来描述测试，这有助于保持事情熟悉。在`beforeEach`阶段，我们为管理和仪表板页面构造一个新的页面对象，然后告诉浏览器加载主页面。
- en: The first test checks that the dashboard itself loads with the expected number
    of cards. It does this by navigating to the page and querying for the list of
    cards. Notice how it’s a promise, because there may be some time waiting for tasks
    to trigger. Protractor is usually smart enough to wait for the page to settle
    down before executing code, and then we run our expectation in the callback. The
    second test is similar, except it goes to the manage page and checks the list
    of symbols.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个测试检查仪表板本身是否以预期的卡片数量加载。它是通过导航到页面并查询卡片列表来做到这一点的。注意它是一个承诺，因为可能需要等待一些时间以触发任务。Protractor通常足够智能，会在执行代码之前等待页面稳定下来，然后我们在回调中运行我们的期望。第二个测试类似，但它会转到管理页面并检查符号列表。
- en: The third and fourth tests manipulate state and verify that it renders properly
    after adding or removing a symbol. They both start by verifying that the dashboard
    has the expected number of cards and then navigate to the manage page. The tests
    either add or remove a symbol and then navigate back to the dashboard to verify
    whether it’s reflected the change.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个和第四个测试操作状态并验证在添加或删除符号后它是否正确渲染。它们都从验证仪表板具有预期的卡片数量开始，然后导航到管理页面。测试要么添加或删除符号，然后导航回仪表板以验证是否反映了更改。
- en: 'Often you’ll break apart your tests based upon features. In this application,
    there’s one primary feature: to view and manage a list of stocks. If you had additional
    features, like creating an account, a login process, or perhaps a news page, each
    of those would probably be best organized into its own file.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 通常你会根据功能将测试拆分。在这个应用程序中，有一个主要功能：查看和管理股票列表。如果你有额外的功能，比如创建账户、登录过程，或者可能是一个新闻页面，那么每个功能最好都组织到自己的文件中。
- en: This gets us through the basics of writing e2e tests and demonstrates their
    primary role and value. Though they have some drawbacks and can be challenging
    to maintain, they test the system as a real user would and allow you to codify
    the primary user flows and objectives into a suite of tests.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们了解了编写端到端测试的基本知识，并展示了它们的主要作用和价值。尽管它们有一些缺点并且可能难以维护，但它们像真实用户一样测试系统，并允许你将主要用户流程和目标编码到一系列测试中。
- en: Before closing the chapter, I want to cover a few common questions that people
    ask about testing in real-world scenarios. All too often developers don’t invest
    in tests or get hung up on the proper approach to testing. Although the answers
    are my opinions, I think they’re useful to consider.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本章之前，我想讨论一些人们在现实场景中关于测试的常见问题。过于频繁地，开发者没有投资于测试或陷入测试正确方法的困境。尽管这些答案是我的观点，但我认为它们值得考虑。
- en: 10.4 Additional testing strategies
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.4 附加测试策略
- en: When I teach about testing, sometimes the response by students is that testing
    is a lot of work. Many questions boil down to asking whether testing is worth
    the effort. Assuming you believe that testing is important as I do, how do you
    decide which strategy and tests to implement and which can you safely ignore?
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当我教授测试时，有时学生的反应是测试工作量很大。许多问题归结为询问测试是否值得努力。假设你像我一样认为测试很重要，那么你如何决定要实施哪些策略和测试，哪些可以安全地忽略？
- en: 'Depending on your experience and project requirements, you likely have a number
    of questions, such as these:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的经验和项目要求，你可能有很多问题，例如以下这些：
- en: How much testing is enough?
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试多少才算足够？
- en: When do I write the tests?
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我什么时候编写测试？
- en: What do I write, e2e or unit tests?
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我应该写端到端测试还是单元测试？
- en: What if I don’t have time to write tests?
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我没有时间编写测试怎么办？
- en: What about other types of testing?
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他类型的测试呢？
- en: 'I can’t give you definitive answers that will apply to all projects, but I’d
    like to offer you some of my strategies for testing. There are many strategies
    and perspectives on testing. The two extremes are as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我不能给你提供适用于所有项目的明确答案，但我愿意分享我的一些测试策略。关于测试有许多策略和观点。两个极端如下：
- en: People who argue for writing tests for every line of code before you even create
    the actual code
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那些主张在创建实际代码之前为每一行代码编写测试的人
- en: People who argue that tests are a waste of time and slow down development
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认为测试是浪费时间并减缓开发的人
- en: On this spectrum, I fall closer to the former, but I also recognize that some
    tests have little value and that there are alternative ways to ensure code behavior.
    You’ll find most of my perspectives to be pragmatic and between the extremes.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个范围内，我更接近前者，但我也认识到有些测试价值很小，而且有其他确保代码行为的方法。你会发现我的大多数观点都是务实的，介于两个极端之间。
- en: 10.4.1 How much testing is enough?
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.1 测试多少才算足够？
- en: This is the kind of question that’s asked a lot, but few know how to answer
    it. Sometimes people want specific code coverage metrics and consider that enough,
    whereas others want tests to cover the important aspects of the application. I
    don’t believe in a magic formula, but I think there’s a simple way to determine
    whether you have enough testing.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个经常被问及的问题，但很少有人知道如何回答。有时人们想要具体的代码覆盖率指标，并认为这已经足够，而其他人则希望测试覆盖应用程序的重要方面。我不相信有魔法公式，但我认为有一个简单的方法可以确定你是否进行了足够的测试。
- en: Imagine your application is currently being used by 100 people on average per
    day. The application is relatively simple, has been in use for at least a few
    months, and has only had a couple of bug reports. You may feel confident in the
    application and its behavior—but that’s your gut, which shouldn’t be how you decide
    whether you have enough testing.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你的应用程序目前平均每天有100人使用。该应用程序相对简单，已经使用了几个月，并且只有几个错误报告。你可能会对应用程序及其行为感到自信——但这只是你的直觉，这不应该是你决定是否进行足够测试的方式。
- en: What you should do instead is employ usage metrics and error-logging tools to
    analyze the data to see whether users are successful using your application or
    receive errors. Use data to inform you about the quality of your application and
    to get insights into how people use it. You can use something like Google Analytics
    to track users and report metrics to you; it requires some setup and paying attention
    to the reports. There are many great tools out there—look for web analytics and
    error-tracking tools that fit your needs best.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该做的是使用使用指标和错误记录工具来分析数据，看看用户是否成功使用你的应用程序或收到错误。用数据来告诉你应用程序的质量，以及了解人们如何使用它。你可以使用类似Google
    Analytics这样的工具来跟踪用户并向你报告指标；这需要一些设置并关注报告。有许多优秀的工具——寻找最适合你需求的网络分析和错误跟踪工具。
- en: Developers are notorious for IWFM syndrome (*it works for me*). I imagine you’ve
    been guilty of this syndrome, as have I. This is why your gut feeling about quality
    is really an excuse to ignore testing instead of measuring quality. You have to
    remember that your users are using different computers, browsers, and network
    connection speeds than you.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者以IWFM综合症（“对我有效”）而闻名。我想你和我一样，都曾犯过这种综合症的错。这就是为什么你对质量的直觉实际上是一个借口，用来忽视测试而不是衡量质量。你必须记住，你的用户正在使用与你不同的计算机、浏览器和网络连接速度。
- en: When you use data to measure, you can better understand your users and capture
    errors as they happen. Also, users are more likely to leave your application than
    to report a bug, so just because nobody complains doesn’t mean it’s working right.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用数据来衡量时，你可以更好地了解你的用户，并在错误发生时捕捉到它们。此外，用户更有可能离开你的应用程序而不是报告一个错误，所以并不是因为没有人抱怨就意味着它运行正确。
- en: 10.4.2 When do I write tests?
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.2 我应该在什么时候编写测试？
- en: Which came first, the chicken or the egg? The test or the implementation? Strategies
    like TDD (test-driven development) propose that you should write your tests before
    you implement any actual code. Other approaches advocate writing the implementation
    first and then figuring out how to write tests to support the implementation.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 鸡生蛋还是蛋生鸡？测试在前还是实现在前？像TDD（测试驱动开发）这样的策略建议你在编写任何实际代码之前应该先编写测试。其他方法则主张先编写实现，然后再想出如何编写测试来支持实现。
- en: Writing tests before implementation aims to ensure that you think through the
    implementation clearly before you write it. The assumption is that you’ll imagine
    the implementation correctly in your mind, write the test first, and then write
    the implementation. To me, the biggest drawback here is that it assumes that you
    can clearly imagine the implementation—and if you’re wrong, you have to rework
    your tests.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现之前编写测试的目的是确保你在编写代码之前清楚地思考实现过程。假设你能在心中正确地想象出实现过程，先编写测试，然后再编写实现。对我来说，这里最大的缺点是它假设你能够清楚地想象出实现过程——如果你错了，你不得不重新编写测试。
- en: Writing the implementation and then writing the tests aims to save you time
    because you focused on the implementation first, and then the tests. You may not
    have to plan as carefully before you start coding, and therefore it’s often faster.
    The biggest drawback there is that you can miss nuances and write tests that confirm
    flawed behavior. For example, if your code doesn’t handle an edge case and you
    don’t write a test to check it, the tests will still pass.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 先编写实现再编写测试的目的是为了节省你的时间，因为你首先关注的是实现，然后才是测试。你可能不需要在开始编码之前计划得那么仔细，因此这通常更快。那里最大的缺点是可能会错过细微之处，并编写出确认有缺陷行为的测试。例如，如果你的代码没有处理边缘情况，而你又没有编写测试来检查它，测试仍然会通过。
- en: My take on it is somewhere in the middle. I tend to write a test as I build
    a specific piece of functionality, but I don’t worry about always writing it ahead
    of time. That’s often because I’m also working with APIs that have complex responses,
    and they’re being developed simultaneously with my work. I suggest you don’t wait
    until the end and then go back and write a bunch of tests. When you do that, you
    tend to write tests that verify your implementation, and that could mean you write
    tests that verify buggy behavior if you don’t think about the potential cases
    properly.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我对此的看法是介于两者之间。我倾向于在构建特定功能时编写测试，但我不担心总是提前编写。这通常是因为我还在与具有复杂响应的API一起工作，它们与我的工作同时进行。我建议你不要等到最后再回头写一大堆测试。当你这样做时，你往往会编写出验证你实现的测试，这可能意味着如果你没有正确考虑潜在的情况，你可能会编写出验证有缺陷行为的测试。
- en: 10.4.3 What do I write, e2e or unit tests?
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.3 我应该编写端到端测试还是单元测试？
- en: I’ve heard the argument that an application doesn’t need different types of
    tests if you write one type really well. This perspective typically means that
    the developer is confident in creating a particular type of test and doesn’t feel
    like other types are going to be as valuable.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我听说过这样的论点，如果你写好了一种类型的测试，那么应用程序不需要不同类型的测试。这种观点通常意味着开发者对创建特定类型的测试有信心，并且不觉得其他类型的测试会同样有价值。
- en: I believe you should write at least some e2e tests, but focus mostly on unit
    tests. Keep in mind the role of each type of test and write the type that best
    verifies that behavior. For example, if you want to verify that the API is returning
    the data as expected, you need to write e2e tests. Likewise, if you want to be
    sure that a pipe works given a wide range of input values, a unit test is most
    sensible.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你应该至少编写一些端到端测试，但主要关注单元测试。记住每种类型测试的作用，并编写最能验证该行为的类型。例如，如果你想验证API是否按预期返回数据，你需要编写端到端测试。同样，如果你想确保在广泛的输入值下管道能够正常工作，单元测试是最合理的。
- en: e2e tests can be challenging because they’re run against a real data source,
    and if you’re creating or deleting objects from the database, you have to handle
    that properly without messing up the system. If an e2e test fails, it can leave
    test data in the system and not properly clean up.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试可能具有挑战性，因为它们是在真实数据源上运行的，如果你正在创建或删除数据库中的对象，你必须正确处理，以免搞乱系统。如果一个端到端测试失败，它可能会在系统中留下测试数据，并且没有正确清理。
- en: In short, favor unit tests unless it becomes too complex—then create e2e tests.
    e2e tests should focus on user flows, and unit tests should focus on the specific
    entity’s behavior.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，除非变得过于复杂，否则优先考虑单元测试——然后创建端到端测试。端到端测试应专注于用户流程，单元测试应专注于特定实体的行为。
- en: 10.4.4 What if I don’t have time to write tests?
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.4 如果我没有时间写测试怎么办？
- en: Usually this argument only comes if you’re writing a fairly small application
    by yourself and you know the code very well. The reality is that your memory is
    limited, and it’s hard to be confident in making changes that won’t break anything
    else without doing extensive manual testing.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 通常这种论点只会在你独自编写一个相当小的应用程序，并且你对代码非常了解时出现。现实是，你的记忆是有限的，没有进行广泛的手动测试，很难对不会破坏其他任何东西的更改有信心。
- en: If you think about this a little differently, you probably don’t have time to
    waste *not* having tests, if you think about the potential loss of time spent
    testing the application manually, or the cost of support for dealing with customer-reported
    bugs.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你稍微换一种思维方式，你可能没有时间浪费在不写测试上，如果你考虑手动测试应用程序可能花费的时间损失，或者处理客户报告的bug的支持成本。
- en: Perhaps you finish a project and have to come back to it after a few months,
    or even years. Your memory about that project will have faded considerably, and
    your coding style will likely have changed. Without tests, you’re changing the
    code blindly and hoping for the best. I think of it as *cowboy* coding.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 可能你完成了一个项目，几个月甚至几年后需要再次回到它。你对这个项目的记忆可能会大大减弱，你的编码风格也可能发生了变化。没有测试，你就是在盲目地更改代码，并寄希望于最好的结果。我认为这就像*牛仔式编程*。
- en: I don’t like dealing with support issues or manually testing my application.
    When I fix a bug, I try to write a test to verify that the bug won’t happen again.
    I suggest you make it a habit, too, and you can slowly add tests where you don’t
    have them.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我不喜欢处理支持问题或手动测试我的应用程序。当我修复一个bug时，我会尝试编写一个测试来验证该bug不会再次发生。我建议你也养成这个习惯，并且你可以慢慢地添加测试，在你没有测试的地方。
- en: I know that sometimes projects are just proof-of-concepts and that sometimes
    clients don’t have enough budget to cover the time to properly test the app. But
    proof-of-concepts tend to turn into production applications, and customers keep
    coming back for changes, and soon the app grows out of control. I encourage you
    to fight for the time or budget to make testing a priority. Your future self (and
    boss or client) will thank you.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道有时项目只是概念验证，有时客户没有足够的预算来覆盖适当测试应用程序的时间。但概念验证往往会变成生产应用程序，客户会不断回来要求更改，很快应用程序就会失去控制。我鼓励你争取时间或预算，将测试作为优先事项。你的未来自己（以及老板或客户）会感谢你的。
- en: 10.4.5 What about other types of testing?
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.5 关于其他类型的测试怎么办？
- en: There are other testing types, not covered here, that could be useful for you.
    These include things like *usability* testing (observing your users accomplishing
    a set of tasks to see if they can do so easily), *cross-browser compatibility*
    testing (analyzing how the application renders in various browsers and noting
    any differences), and *performance* testing (analyzing the efficiency of the application,
    how long it takes to load, and other factors that influence actual and perceived
    performance).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有涵盖的其他测试类型可能对你很有用。这些包括诸如*可用性*测试（观察用户完成一系列任务以查看他们是否可以轻松完成）、*跨浏览器兼容性*测试（分析应用程序在各种浏览器中的渲染方式，并记录任何差异）、以及*性能*测试（分析应用程序的效率，加载所需时间以及其他影响实际和感知性能的因素）。
- en: 'There are so many things you can test that you could easily spend all your
    time writing tests and not improving the application. Instead of telling you which
    types of testing you need to adopt, I offer the following thoughts for your consideration:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以测试的事情如此之多，以至于你可能会轻易地花所有时间编写测试而不是改进应用程序。而不是告诉你需要采用哪些类型的测试，我提供以下想法供你考虑：
- en: '*Automate slow or manual processes* —This is usually related to testing, but
    it can also apply to other aspects, like building the application. For example,
    if you’re spending significant energy trying to validate that code runs properly
    in different browsers, you’d likely be better off in the long term building a
    testing infrastructure that can automatically run your tests in more than one
    browser (such as using a selenium grid service).'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*自动化缓慢或手动流程* — 这通常与测试相关，但也适用于其他方面，如构建应用程序。例如，如果你在验证代码在不同浏览器中正确运行上花费了大量精力，那么从长远来看，构建一个能够在多个浏览器（如使用selenium网格服务）中自动运行测试的测试基础设施可能会更好。'
- en: '*Test areas that cannot fail* —Think about the process of login or sign up.
    If those fail, you lose users very fast, and that can be a major issue. You might
    consider how to constantly test for failure, such as doing automated tests that
    attempt to log in a user every five minutes and report on failure.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*测试不能失败的区域* — 考虑登录或注册的过程。如果这些失败，你会很快失去用户，这可能会成为一个重大问题。你可能会考虑如何持续测试失败，例如进行自动测试，每五分钟尝试登录一个用户，并报告失败情况。'
- en: '*Track errors and activity* —Very few users will bother to report bugs or contact
    support, even on a paid product. You can’t assume that users will let you know
    about errors, so you should consider tracking errors in your application (front
    end and back end) so you can see what issues users are facing and figure out how
    to fix them.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*跟踪错误和活动* — 很少有用户会麻烦报告错误或联系支持，即使在付费产品上也是如此。你不能假设用户会告诉你关于错误的信息，因此你应该考虑跟踪应用程序中的错误（前端和后端），以便你可以看到用户面临的问题，并找出如何修复它们。'
- en: '*Add other types of testing as necessary* —There’s no need to start a new project
    and build every type of testing possible. Instead, apply new types of testing
    when pain points are found. For example, if you get reports that some pages look
    different in different browsers, you might employ *visual diff* testing that helps
    automate what the pages look like so you can identify when things are inconsistent
    or change.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*根据需要添加其他类型的测试* — 没有必要启动一个新项目并构建所有可能的测试类型。相反，当发现痛点时，应用新的测试类型。例如，如果你收到报告称某些页面在不同浏览器中看起来不同，你可能会采用*视觉差异*测试，这有助于自动化页面的外观，以便你可以识别出不一致或变化的情况。'
- en: '*Test based on users and outcomes* —Understand your users and what outcomes
    you expect them to have, and figure out what tests help increase your confidence
    that users’ needs are being met. If you expect the outcome for users is that they’ll
    sign up for your service, then test the marketing and signup pages extensively.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基于用户和结果进行测试* — 了解你的用户以及你期望他们获得的结果，并找出哪些测试有助于增加你对用户需求得到满足的信心。如果你期望用户的结果是他们会注册你的服务，那么你应该广泛测试营销和注册页面。'
- en: Testing is a big subject that extends far beyond Angular. Web applications have
    many potential areas to test and validate. Good applications will find the right
    mix of testing across the spectrum to test the most critical and weakest areas
    first and then extend that test coverage over time.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是一个很大的主题，它远远超出了Angular的范畴。Web应用程序有许多潜在的测试和验证区域。好的应用程序将找到测试范围的正确组合，首先测试最关键和最薄弱的区域，然后随着时间的推移扩展测试覆盖范围。
- en: Summary
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'We’ve taken a whirlwind tour of testing in this chapter, and gotten a realistic
    amount of testing done to our stock tracking application:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们对测试进行了快速浏览，并对我们的库存跟踪应用程序进行了实际数量的测试：
- en: Unit tests and e2e tests are the two primary types of tests you can write for
    Angular. Unit tests are written to verify that the individual parts of the application
    work in isolation, and e2e tests verify that the application works together as
    a whole.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试和端到端测试是你可以为Angular编写的两种主要测试类型。单元测试是为了验证应用程序的各个部分在独立工作时是否正常工作，而端到端测试则是验证应用程序作为一个整体是否正常工作。
- en: Pipes are usually the easiest to unit test because they’re usually pure functions
    that are easy to pass arguments to.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道通常是最容易进行单元测试的，因为它们通常是纯函数，容易传递参数。
- en: Services can be easy to test, especially if they have minimal dependencies.
    Manually constructing a service for testing is preferred if possible, and it’s
    best to also write stub services for other tests to use.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务可以很容易地进行测试，特别是如果它们的依赖性最小的话。如果可能的话，手动构建服务进行测试是首选的，并且最好也为其他测试编写存根服务。
- en: Components are the major building blocks that you’ll be testing—by either testing
    the controller methods directly or testing how the view is rendered—and they depend
    on using testing modules to instantiate a lightweight Angular application.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件是你将要测试的主要构建块——通过直接测试控制器方法或测试视图的渲染方式——并且它们依赖于使用测试模块来实例化一个轻量级的Angular应用程序。
- en: Testing directives is very similar to components except that you’re testing
    how they modify a component by observing changes to the rendered component.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试指令与组件测试非常相似，只是你需要测试它们如何通过观察渲染组件的变化来修改组件。
- en: e2e tests can be written to interact with the application as a typical user
    would, by clicking or typing into fields. e2e tests are challenging to maintain,
    so they should be designed to test the most critical features first.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端到端测试可以编写成以典型用户的方式与应用程序交互，通过点击或输入字段。端到端测试维护起来比较困难，因此它们应该设计成首先测试最关键的功能。
- en: There are many other types of testing and considerations, but most general web-development
    practices can be applied easily to an Angular application and are recommended
    to be added when necessary.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有许多其他类型的测试和考虑因素，但大多数通用的Web开发实践都可以轻松应用于Angular应用程序，并且在必要时推荐添加。
