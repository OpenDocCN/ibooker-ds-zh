- en: '19 Workout of the Day: Parsing CSV files, creating text table output'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 19 每日锻炼：解析 CSV 文件，创建文本表格输出
- en: '| Several years ago, I joined a workout group. We meet several times a week
    in our coach’s unpaved driveway. We pick up and drop heavy things and run around
    trying to keep Death at bay for another day. I’m no paragon of strength and fitness,
    but it’s been a nice way to exercise and visit with friends. One of my favorite
    parts of going is that our coach will write a “Workout of the Day” or “WOD” on
    the board. Whatever it says is what I do. It doesn’t matter if I actually want
    to do 200 push-ups that day, I just get them done no matter how long it takes.[1](#pgfId-1037819)
    | ![](../Images/19-unnumb-1.png)  |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '| 几年前，我加入了一个锻炼小组。我们每周在教练未铺路的车道上见面几次。我们拿起和放下重物，四处跑动，试图让死神再远离我们一天。我不是力量和健康的典范，但这是锻炼和与朋友交流的好方法。我最喜欢的部分之一是教练会在黑板上写一个“每日锻炼”或“WOD”。无论上面写的是什么，我都会做。如果那天我实际上不想做
    200 个俯卧撑，我也会不管花多长时间都完成它们。[1](#pgfId-1037819) | ![图片](../Images/19-unnumb-1.png)
    |'
- en: 'In that spirit, we’ll write a program called wod.py to help us create a random
    daily workout that we have to do, no questions asked:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这个精神，我们将编写一个名为 wod.py 的程序，帮助我们创建一个随机每日锻炼计划，无需提问：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note Each time you run the program, you are required to perform all the exercises
    *immediately*. Heck, even just *reading* them means you have to do them. Like
    *NOW*. Sorry, I don’t make the rules. Better get going on those sit-ups!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：每次运行程序时，你都必须立即执行所有练习。嘿，甚至只是 *阅读* 它们就意味着你必须做。就像 *现在* 一样。抱歉，我制定不了规则。还是开始做仰卧起坐吧！
- en: 'We’ll choose from a list of exercises stored in a *delimited text file*. In
    this case, the “delimiter” is the comma, and it will separate each field value.
    Data files that use commas as delimiters are often described as *comma-separated
    values* or CSV files. Usually the first line of the file names the columns, and
    each subsequent line represents a row in the table:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从存储在分隔文本文件中的一系列练习中选择。在这种情况下，“分隔符”是逗号，它将分隔每个字段值。使用逗号作为分隔符的数据文件通常被称为 *逗号分隔值*
    或 CSV 文件。通常，文件的第一个行命名列，每个后续行代表表格中的一行：
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this exercise, you will
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将
- en: Parse delimited text files using the `csv` module
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `csv` 模块解析分隔文本文件
- en: Coerce text values to numbers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将文本值强制转换为数字
- en: Print tabular data using the `tabulate` module
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `tabulate` 模块打印表格数据
- en: Handle missing and malformed data
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理缺失和格式不正确的数据
- en: This chapter and the next are meant to be a step up in how challenging they
    are. You will be applying many of the skills you’ve learned in previous chapters,
    so get ready!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章和下一章的难度将有所提高。你将应用在前几章中学到的许多技能，所以准备好吧！
- en: 19.1 Writing wod.py
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 19.1 编写 wod.py
- en: 'You will be creating a program called wod.py in the 19_wod directory. Let’s
    start by taking a look at the usage that should print when it’s run with `-h`
    or `--help`. Modify your program’s parameters until it produces this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在 19_wod 目录下创建一个名为 wod.py 的程序。让我们先看看当它用 `-h` 或 `--help` 运行时应该打印的用法。修改你的程序参数，直到它产生以下内容：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Our program will read an input `-f` or `--file`, which should be a readable
    text file (default, inputs/exercises.csv). The output will be some `-n` or `--num`
    number of exercises (default, `4`). There might be an `-e` or `--easy` flag to
    indicate that the repetitions of each exercise should be cut in half. Since we’ll
    be using the `random` module to choose the exercises, we’ll need to accept an
    `-s` or `--seed` option (`int` with a default of `None`) to pass to `random.seed()`
    for testing purposes.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们程序将读取一个输入 `-f` 或 `--file`，它应该是一个可读的文本文件（默认，inputs/exercises.csv）。输出将是一定数量的
    `-n` 或 `--num` 练习（默认，`4`）。可能有一个 `-e` 或 `--easy` 标志来指示每个练习的重复次数应该减半。由于我们将使用 `random`
    模块来选择练习，我们需要接受一个 `-s` 或 `--seed` 选项（默认为 `None` 的 `int`）来传递给 `random.seed()` 以进行测试目的。
- en: 19.1.1 Reading delimited text files
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.1.1 读取分隔文本文件
- en: 'We’re going to use the `csv` module to parse the input file. This is a standard
    module that should already be installed on your system. You can verify that by
    opening a `python3` REPL and trying to import it. If this works, you’re all set:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `csv` 模块来解析输入文件。这是一个标准模块，应该已经安装在你的系统上。你可以通过打开一个 `python3` REPL 并尝试导入它来验证。如果这成功了，你就准备好了：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We’ll also look at two other modules that you probably will need to install:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将查看两个你可能需要安装的其他模块：
- en: Tools from the `csvkit` module to look at the input file on the command line
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `csvkit` 模块的工具查看命令行上的输入文件
- en: The `tabulate` module to format the output table
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `tabulate` 模块来格式化输出表格
- en: 'Run this command to install these modules:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令来安装这些模块：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'There is also a requirements.txt file, which is a common way to document the
    dependencies for a program. Instead of the previous command, you can install all
    the modules with this one:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个 requirements.txt 文件，这是记录程序依赖项的常见方式。您可以使用以下命令安装所有模块，而不是之前的命令：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '| Despite having “csv” in the name, the `csvkit` module can handle just about
    any delimited text file. For instance, it’s typical to use the tab (`\t`) character
    as a delimiter, too. The module includes many tools that you can read about in
    its documentation ([https://csvkit.readthedocs.io/en/1.0.3/](https://csvkit.readthedocs.io/en/1.0.3/)).
    I’ve included several delimited files in the 19_wod/inputs directory that you
    can use to test your program. | ![](../Images/19-unnumb-2.png)  |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: 尽管名字中有“csv”，但 `csvkit` 模块可以处理几乎所有分隔文本文件。例如，通常也使用制表符（`\t`）作为分隔符。该模块包括许多工具，您可以在其文档中了解更多信息（[https://csvkit.readthedocs.io/en/1.0.3/](https://csvkit.readthedocs.io/en/1.0.3/)）。我在
    19_wod/inputs 目录中包含了一些分隔文件，您可以使用它们来测试您的程序。 | ![](../Images/19-unnumb-2.png)  |
- en: 'After installing `csvkit`, you should be able to use `csvlook` to parse the
    inputs/exercises.csv file into a table structure showing the columns:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 `csvkit` 后，您应该可以使用 `csvlook` 将 inputs/exercises.csv 文件解析为显示列的表格结构：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The “reps” column of the input file will have two numbers separated by a dash,
    like `10-20` meaning “from 10 to 20 reps.” To select the final value for the reps,
    you will use the `random.randint()` function to select an integer value between
    the low and high values. When run with a seed, your output should exactly match
    this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 输入文件的“重复”列将包含由破折号分隔的两个数字，例如 `10-20` 表示“从 10 到 20 次重复。”要选择最终的重复次数，您将使用 `random.randint()`
    函数在低值和高值之间选择一个整数值。当使用种子运行时，您的输出应与以下内容完全匹配：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When run with the `--easy` flag, the reps should be halved:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `--easy` 标志运行时，重复次数应减半：
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `--file` option should default to the inputs/exercises.csv file, or we
    can indicate a different input file:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`--file` 选项应默认为 inputs/exercises.csv 文件，或者我们可以指定不同的输入文件：'
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Figure 19.1 shows our trusty string diagram to help you think about it.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19.1 显示了我们信任的字符串图，以帮助您思考。
- en: '![](../Images/19-1.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/19-1.png)'
- en: Figure 19.1 The WOD program will randomly select exercises and reps from a CSV
    file to create a table listing the workout of the day.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19.1 WOD 程序将随机从 CSV 文件中选择练习和重复次数，以创建列出每日锻炼的表格。
- en: 19.1.2 Manually reading a CSV file
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.1.2 手动读取 CSV 文件
- en: First I’m going to show you how to manually parse each record from a CSV file
    into a list of dictionaries, and then I’ll show you how to use the `csv` module
    to do this more quickly. The reason we want to make a dictionary from each record
    is so that we can get at the values for each exercise and the number of reps (repetitions,
    or how many times to repeat a given exercise). We’re going to need to split the
    reps into low and high values so that we can get a range of numbers from which
    we’ll randomly select the number of reps. Finally, we’ll randomly select some
    exercises along with their reps to make a workout. Whew, just describing that
    was a workout!
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我将向您展示如何手动解析 CSV 文件中的每个记录到字典列表中，然后我会向您展示如何使用 `csv` 模块更快地完成这项工作。我们想要将每个记录转换为字典的原因是，这样我们可以获取每个练习的值和重复次数（重复，或重复给定练习的次数）。我们需要将重复次数分为低值和高值，以便从其中随机选择重复次数。最后，我们将随机选择一些练习及其重复次数来制定锻炼计划。哇，仅仅描述这个过程就已经是一项锻炼了！
- en: 'Notice that reps is given as a range from a low number to a high number, separated
    by a dash:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，重复次数是以一个低数到高数的范围给出的，由破折号分隔：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It would be convenient to read this as a list of dictionaries where the column
    names in the first line are combined with each line of data, like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 读取为字典列表会更方便，其中第一行的列名与数据行的每一行结合，如下所示：
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It may seem like overkill to use a dictionary for records that contain just
    two columns, but I regularly deal with records that contain dozens to *hundreds*
    of columns, and then field names are essential. A dictionary is really the only
    sane way to handle most delimited text files, so it’s good to learn with a small
    example like this.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 对于只包含两列的记录使用字典似乎有些过度，但我经常处理包含数十甚至数百列的记录，这时字段名就变得至关重要。字典实际上处理大多数分隔文本文件的唯一合理方式，因此学习这样的小例子是很好的。
- en: 'Let’s look at the manual1.py code that will do this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看将执行此操作的 manual1.py 代码：
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ① We will use the pretty-print module to print the data structure.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们将使用 pretty-print 模块来打印数据结构。
- en: ② Use the “with” construct to open the exercises as the fh variable. One advantage
    of using “with” is that the file handle will be closed automatically when the
    code moves beyond the block.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ② 使用 “with” 构造来以 fh 变量打开练习。使用 “with” 的一个优点是，当代码超出代码块时，文件句柄将自动关闭。
- en: ③ Use fh.readline() to read only the first line of the file. Remove the whitespace
    from the right side (str.rstrip()), and then use str.split() to split the resulting
    string on commas to create a list of strings, which are the column headers.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 使用 `fh.readline()` 只读取文件的第一行。从右侧移除空格（`str.rstrip()`），然后使用 `str.split()` 在逗号处拆分结果字符串，创建一个字符串列表，这些字符串是列标题。
- en: ④ Initialize records as an empty list.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 将记录初始化为一个空列表。
- en: ⑤ Use a for loop to read the rest of the lines of fh.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 使用 for 循环读取 fh 的其余行。
- en: ⑥ Strip and split the line of text into a list of field values. Use the zip()
    function to create a new list of tuples containing each of the headers paired
    with each of the values. Use the dict() function to turn this list of tuples into
    a dictionary.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 去除空格并拆分文本行为一个字段值的列表。使用 `zip()` 函数创建一个包含每个标题与每个值配对的元组的新列表。使用 `dict()` 函数将这个元组列表转换为字典。
- en: ⑦ Append the resulting dictionary to the records.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 将生成的字典追加到记录中。
- en: ⑧ Pretty-print the records.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 美化打印记录。
- en: 'Let’s break this down a bit more. First we’ll `open()` the file and read the
    first line:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地分析一下。首先我们将 `open()` 文件并读取第一行：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '| The line still has a newline stuck to it, so we can use the `str.rstrip()`
    function to remove that:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '| 这行仍然有一个换行符，所以我们可以使用 `str.rstrip()` 函数来移除它：'
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '| ![](../Images/19-unnumb-3.png)  |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '![图片 19-unnumb-3.png]'
- en: Note Note that I need to keep reopening this file for this demonstration, or
    each subsequent call to `fh.readline()` would read the next line of text.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：为了演示，我需要不断重新打开这个文件，否则每次调用 `fh.readline()` 都会读取下一行的文本。
- en: 'Now let’s use `str.split()` to split that line on the comma to get a `list`
    of strings:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用 `str.split()` 来根据逗号拆分该行，以获取一个字符串 `list`：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can likewise read the next `line` of the file to get a `list` of the field
    values:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们同样可以读取文件的下一 `line`，以获取字段值的 `list`：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next we use the `zip()` function to merge the two lists into one list where
    the elements of each list have been mated with their counterparts in the same
    positions. That might seem complicated, but think about the end of a wedding ceremony
    when the bride and groom turn around to face the assembled crowd. Usually they
    will hold hands and start walking down the aisle to leave the ceremony. Imagine
    three groomsmen (`''G''`) and three bridesmaids (`''B''`) left standing on their
    respective sides facing each other:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们使用 `zip()` 函数将两个列表合并成一个列表，其中每个列表的元素都与其在相同位置的对应元素配对。这听起来可能很复杂，但想想婚礼仪式结束时，新娘和新郎转身面对聚集的人群。通常他们会手牵手，开始沿着通道走下，离开仪式。想象有三名伴郎
    (`'G'`) 和三名伴娘 (`'B'`) 分别站在各自的两侧面对面站立：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If there are two lines each containing three people, then we end up with a
    single line containing three pairs:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有两行，每行包含三个人，那么我们最终会得到一行包含三个配对的行：
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '| Or think of two lines of cars merging to exit a parking lot. It’s customary
    for one car from one lane (say, “A”) to merge into traffic, then a car from the
    other lane (say, “B”). The cars are combining like the teeth of a zipper, and
    the result is “A,” “B,” “A,” “B,” and so forth. | ![](../Images/19-unnumb-4.png)  |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 或者想象两行车辆合并出停车场。通常情况下，一个车道（比如说，“A”）的一辆车会并入交通，然后是另一个车道（比如说，“B”）的一辆车。车辆就像拉链的牙齿一样合并，结果是“A”，“B”，“A”，“B”，以此类推。|
    ![图片 19-unnumb-4.png] |'
- en: 'The `zip()` function will group the elements of the lists into tuples, grouping
    all the elements in the first position together, then the second position, and
    so on, as shown in figure 19.2\. Note that this is another *lazy* function, so
    I will use `list` to coerce this in the REPL:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`zip()` 函数会将列表的元素组合成元组，将第一个位置的所有元素组合在一起，然后是第二个位置，以此类推，如图 19.2 所示。请注意，这是一个另一个
    *lazy* 函数，所以我在 REPL 中会使用 `list` 来强制转换：'
- en: '[PRE19]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '![](../Images/19-2.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片 19-2](../Images/19-2.png)'
- en: Figure 19.2 Zipping two lists creates a new list with pairs of elements.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19.2 将两个列表“zipping”会创建一个包含元素对的新的列表。
- en: 'The `zip()` function can handle more than two lists. Note that it will only
    create groupings for the shortest list. In the following example, the first two
    lists have four elements (“abcd” and “1234”), but the last has only three (“xyz”),
    so only three tuples are created:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`zip()` 函数可以处理超过两个列表。请注意，它只为最短的列表创建分组。在以下示例中，前两个列表有四个元素（“abcd”和“1234”），但最后一个只有三个（“xyz”），因此只创建了三个元组：'
- en: '[PRE20]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In our data, `zip()` will combine the header “exercise” with the value “Burpees”
    and then the header “reps” with the value “20-50” (see figure 19.3):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的数据中，`zip()` 将标题“exercise”与值“Burpees”以及标题“reps”与值“20-50”组合（见图 19.3）：
- en: '[PRE21]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '![](../Images/19-3.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/19-3.png)'
- en: Figure 19.3 Zipping the headers and values together to create a list of tuples
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19.3 将标题和值一起压缩以创建元组列表
- en: 'That created a `list` of `tuple` values. Instead of `list()`, we can use `dict()`
    to create a dictionary:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个 `tuple` 值的 `list`。而不是 `list()`，我们可以使用 `dict()` 来创建一个字典：
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Recall that the `dict.items()` function will turn a `dict` into a `list` of
    `tuple` (key/value) pairs, so you can think of these two data structures as being
    fairly interchangeable:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，`dict.items()` 函数将 `dict` 转换为 `tuple`（键/值）对的 `list`，因此你可以将这些数据结构视为相当可互换的：
- en: '[PRE23]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can drastically shorten our code by replacing the `for` loop with a list
    comprehension:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过用列表推导式替换 `for` 循环来大大缩短我们的代码：
- en: '[PRE24]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ① We still need to break out the headers separately by reading the first line.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们仍然需要通过读取第一行来单独提取标题。
- en: ② This combines the three lines of the for loop into a single list comprehension.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ② 这将 for 循环的三个行合并为一个列表推导式。
- en: 'We can use `map()` to write equivalent code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `map()` 来编写等效的代码：
- en: '[PRE25]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ① Flake8 will complain about assigning this lambda expression. I generally write
    my code so as to produce no warnings, but I do tend to disagree with this suggestion.
    I quite like writing one-line functions using a lambda assignment.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ① Flake8 会抱怨这个 lambda 表达式的赋值。我通常编写代码以产生无警告，但我确实不同意这个建议。我相当喜欢使用 lambda 赋值编写单行函数。
- en: In the next section, I’m going to show you how to use the `csv` module to handle
    much of this code, which may lead you to wonder why I bothered showing you how
    to handle this yourself. Unfortunately, I often have to handle data that is terribly
    formatted, such that the first line is not the header, or there are other rows
    of information between the header row and the actual data. When you’ve seen as
    many badly formatted Excel files as I have, you’ll come to appreciate that you
    sometimes have no choice but to parse the file yourself.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我将向您展示如何使用 `csv` 模块来处理大部分代码，这可能会让您想知道为什么我费心向您展示如何自己处理。不幸的是，我经常不得不处理格式极差的文件，以至于第一行不是标题，或者在标题行和实际数据之间有其他信息行。当你看到像我一样多的格式糟糕的
    Excel 文件时，你会开始欣赏有时你别无选择，只能自己解析文件。
- en: 19.1.3 Parsing with the csv module
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.1.3 使用 csv 模块进行解析
- en: Parsing delimited text files in this way is extremely common, and it would not
    make sense to write or copy this code every time you needed to parse a file. Luckily,
    the `csv` module is a standard module installed with Python, and it can handle
    all of this very gracefully.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式解析分隔文本文件非常常见，每次需要解析文件时都编写或复制此代码是没有意义的。幸运的是，`csv` 模块是 Python 预装的标准模块，并且可以非常优雅地处理所有这些。
- en: 'Let’s look at how our code can change if we use `csv.DictReader()` (see using_csv1.py
    in the repo):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果我们使用 `csv.DictReader()`（请参阅仓库中的 using_csv1.py）我们的代码会如何改变：
- en: '[PRE26]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ① Import the csv module.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ① 导入 csv 模块。
- en: ② Create a csv.DictReader() that will create a dictionary for each record in
    the file. It zips the headers in the first line with the data values in the subsequent
    lines. It uses the delimiter to indicate the string value for splitting the columns
    of text.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ② 创建一个 `csv.DictReader()`，它将为文件中的每条记录创建一个字典。它将第一行的标题与随后的行中的数据值进行压缩。它使用分隔符来指示用于分割文本列的字符串值。
- en: ③ Initialize an empty list to hold the records.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 初始化一个空列表来保存记录。
- en: ④ Use a for loop to iterate through each record returned by the reader.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 使用 for 循环遍历由读取器返回的每条记录。
- en: ⑤ The records will be a dictionary that is appended to the list of records.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 记录将是一个字典，它将被添加到记录列表中。
- en: 'The following code creates the same `list` of `dict` values as before, but
    with far less code. Note that each record is shown as an `OrderedDict`, which
    is a type of dictionary where the keys are maintained in their insertion order:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码创建了与之前相同的 `dict` 值的 `list`，但代码更少。注意，每个记录都显示为 `OrderedDict`，这是一种字典类型，其中键保持其插入顺序：
- en: '[PRE27]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can remove the entire `for` loop and use the `list()` function to coerce
    the `reader` to give us that same `list`. This code (in using_csv2.py) will print
    the same output:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以移除整个 `for` 循环，并使用 `list()` 函数强制 `reader` 给我们相同的列表。这段代码（在 `using_csv2.py`
    中使用）将打印相同的输出：
- en: '[PRE28]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ① Open the file.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ① 打开文件。
- en: ② Create a csv.DictReader() to read fh, using the comma for the delimiter.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ② 创建一个 `csv.DictReader()` 来读取 `fh`，使用逗号作为分隔符。
- en: ③ Use the list() function to coerce all the values from the reader.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 使用 `list()` 函数强制转换读取器中的所有值。
- en: ④ Pretty-print the records.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 美化打印记录。
- en: 19.1.4 Creating a function to read a CSV file
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.1.4 创建读取 CSV 文件的函数
- en: 'Let’s try to imagine how we could write and test a function we might call `read_csv()`
    to read in our data. Let’s start with a placeholder for our function and the `test_read
    _csv()` definition:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试想象如何编写和测试一个可能称为 `read_csv()` 的函数来读取我们的数据。让我们从函数的占位符和 `test_read_csv()`
    定义开始：
- en: '[PRE29]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ① Use io.StringIO() to create a mock file handle to wrap around a valid text
    that we might read from a file. The \n represents the newlines that break each
    line in the input data, and each line uses commas to separate the fields. We previously
    used io.StringIO() in the low-memory version of chapter 5’s program.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ① 使用 `io.StringIO()` 创建一个模拟文件句柄来包装可能从文件中读取的有效文本。`\n` 代表输入数据中每行的换行符，并且每行使用逗号来分隔字段。我们之前在第五章低内存版本的程序中使用了
    `io.StringIO()`。
- en: ② Affirm that our imaginary read_csv() file would turn this text into a list
    of tuple values with the name of the exercise and the reps, which have been split
    into low and high values. Note that these values have been converted to integers.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ② 确认我们的假想 `read_csv()` 文件会将此文本转换为包含练习名称和已拆分为低和高值的 `reps` 的元组值的列表。注意，这些值已被转换为整数。
- en: Hey, we just did all that work to make a `list` of `dict` values, so why am
    I suggesting that we now create a `list` of `tuple` values? I’m looking ahead
    here to how we might use the `tabulate` module to print out the result, so just
    trust me here. This is a good way to go!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿，我们刚刚做了所有这些工作来创建一个 `dict` 值的 `list`，所以我为什么建议我们现在创建一个 `tuple` 值的 `list` 呢？我在这里向前看，考虑我们如何使用
    `tabulate` 模块来打印结果，所以请在这里相信我。这是一个很好的方法！
- en: 'Let’s go back to using `csv.DictReader()` to parse our file and think about
    how we can break the `reps` value into `int` values for the low and high:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到使用 `csv.DictReader()` 解析我们的文件，并思考如何将 `reps` 值拆分为 `int` 类型的低和高值：
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You have a couple of tools at your disposal. Imagine `reps` is this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你有几个工具可以使用。想象一下 `reps` 是这样的：
- en: '[PRE31]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `str.split()` function could break that into two strings, “20” and “50”:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`str.split()` 函数可以将它拆分为两个字符串，“20”和“50”：'
- en: '[PRE32]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How could you turn each of the `str` values into integers?
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何将每个 `str` 值转换为整数？
- en: 'Another way you could go is to use a regular expression. Remember that `\d`
    will match a digit, so `\d+` will match one or more digits. (Refer back to chapter
    15 to refresh your memory on `\d` as a shortcut to the character class of digits.)
    You can wrap that expression in parentheses to capture the “low” and “high” values:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用正则表达式。记住，`\d` 匹配一个数字，所以 `\d+` 匹配一个或多个数字。（参考第 15 章，以刷新你对 `\d` 作为数字字符类的快捷方式的记忆。）你可以将这个表达式包裹在括号中，以捕获“低”和“高”值：
- en: '[PRE33]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Can you write a `read_csv()` function that passes the previous `test_read_csv()`?
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你能编写一个 `read_csv()` 函数，使其通过之前的 `test_read_csv()` 测试吗？
- en: 19.1.5 Selecting the exercises
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.1.5 选择练习
- en: 'By this point, I’m hoping you’ve got `get_args()` straight and your `read_csv()`
    passes the given test. Now we can start in `main()` with printing out the data
    structure:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我希望你已经完全理解了 `get_args()` 并使 `read_csv()` 通过了给定的测试。现在我们可以在 `main()` 中开始打印数据结构：
- en: '[PRE34]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: ① Get the command-line arguments.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ① 获取命令行参数。
- en: ② Set the random.seed() with the args.seed value.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ② 使用 `args.seed` 值设置 `random.seed()`。
- en: ③ Read the args.file (which will be an open file handle) using the read_csv()
    function and print the resulting data structure. Note that I’ve imported the pprint()
    function for demonstration purposes.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 使用 `read_csv()` 函数读取 `args.file`（它将是一个打开的文件句柄）并打印结果数据结构。注意，我为了演示目的导入了 `pprint()`
    函数。
- en: 'If you run the preceding code, you should see this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行前面的代码，你应该看到这个：
- en: '[PRE35]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We will use the `random.sample()` function to select the `--num` of exercises
    indicated by the user. Add `import` `random` to your program and modify your `main`
    to match this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `random.sample()` 函数来选择用户指定的 `--num` 个练习。将 `import` `random` 添加到你的程序中，并修改你的
    `main` 以匹配以下内容：
- en: '[PRE36]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: ① Always set your random seed before calling random functions.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ① 在调用随机函数之前，始终设置随机种子。
- en: ② Read the input file.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ② 读取输入文件。
- en: ③ Randomly select the given number of exercises.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 随机选择指定数量的练习。
- en: 'Now instead of printing all the exercises, it should print a random sample
    of the correct number of exercises. In addition, your sampling should exactly
    match this output if you set the `random.seed()` value:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它应该打印正确的练习数量的随机样本，而不是打印所有练习。此外，如果你的 `random.seed()` 值设置正确，你的采样应该与以下输出完全匹配：
- en: '[PRE37]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We need to iterate through the sample and select a single “reps” value using
    the `random.randint()` function. The first exercise is push-ups, and the range
    is between 25 and 75 reps:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要遍历样本，并使用 `random.randint()` 函数选择一个单独的“reps”值。第一个练习是俯卧撑，范围是25到75次：
- en: '[PRE38]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If `args.easy` is `True`, you will need to halve that value. Unfortunately,
    we cannot have a fraction of a rep:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `args.easy` 是 `True`，你需要将这个值减半。不幸的是，我们不能有分数的俯卧撑：
- en: '[PRE39]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You can use the `int()` function to truncate the number to the integer component:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `int()` 函数将数字截断到整数部分：
- en: '[PRE40]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 19.1.6 Formatting the output
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.1.6 格式化输出
- en: 'Modify your program until it can reproduce this output:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 修改你的程序，直到它能够重现这个输出：
- en: '[PRE41]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We will use the `tabulate()` function from the `tabulate` module to format
    this `list` of `tuple` values into a text table:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `tabulate()` 函数从 `tabulate` 模块中格式化这个 `tuple` 值列表为文本表：
- en: '[PRE42]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If you read `help(tabulate)`, you will see that there is a `headers` option
    where you can specify a `list` of strings to use for the headers:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你阅读 `help(tabulate)`，你会看到有一个 `headers` 选项，你可以指定用于标题的字符串列表：
- en: '[PRE43]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: If you synthesize all these ideas, you should be able to pass the provided tests.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你综合所有这些想法，你应该能够通过提供的测试。
- en: 19.1.7 Handling bad data
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.1.7 处理坏数据
- en: 'None of the tests will give your program bad data, but I have provided several
    “bad” CSV files in the 19_wod/inputs directory that you might be interested in
    figuring out how to handle:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 没有测试会给你的程序提供坏数据，但我已经在 19_wod/inputs 目录中提供了几个“坏”CSV文件，你可能想找出如何处理这些文件：
- en: bad-headers-only.csv is well-formed but has no data. It only has headers.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: bad-headers-only.csv 格式良好，但没有数据。它只有标题。
- en: bad-empty.csv is empty. That is, it is a zero-length file that I created with
    `touch` `bad-empty.csv`, and it has no data at all.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: bad-empty.csv 是空的。也就是说，它是一个零长度的文件，我用 `touch` `bad-empty.csv` 创建的，而且没有任何数据。
- en: bad-headers.csv has headers that are capitalized, so “Exercise” instead of “exercise,”
    “Reps” instead of “reps.”
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: bad-headers.csv 的标题是大写的，所以“Exercise”而不是“exercise”，“Reps”而不是“reps”。
- en: bad-delimiter.tab uses the tab character (`\t`) instead of the comma (`,`) as
    the field delimiter.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: bad-delimiter.tab 使用制表符（`\t`）而不是逗号（`,`）作为字段分隔符。
- en: bad-reps.csv contains reps that are not in the format `x-y` or which are not
    numeric or integer values.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: bad-reps.csv 包含不符合 `x-y` 格式或不是数字或整数值的 reps。
- en: Once your program passes the given tests, trying running it on the “bad” files
    to see how your program breaks. What should your program do when there is no usable
    data? Should your program print error messages when it encounters bad or missing
    values, or should it quietly ignore errors and only print the usable data? These
    are all real-world concerns that you will encounter, and it’s up to you to decide
    what your program will do. After the solution, I will show you ways I might deal
    with these files.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的程序通过了给定的测试，尝试在“坏”文件上运行它，看看你的程序是如何崩溃的。当没有可用的数据时，你的程序应该做什么？当程序遇到坏或缺失的值时，它应该打印错误消息，还是应该安静地忽略错误并只打印可用的数据？这些都是你将在现实生活中遇到的实际问题，由你决定你的程序将做什么。在解决方案之后，我将向你展示我可能处理这些文件的方法。
- en: 19.1.8 Time to write
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.1.8 开始编写
- en: OK, enough lollygagging. Time to write this program. You must do 10 push-ups
    every time you find a bug!
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，别磨蹭了。是时候写这个程序了。每次你发现一个错误时，你必须做10个俯卧撑！
- en: 'Here are a few hints:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些提示：
- en: Use `csv.DictReader()` to parse the input CSV files.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `csv.DictReader()` 解析输入CSV文件。
- en: Break the `reps` field on the `-` character, coerce the low/high values to `int`
    values, and then use `random.randint()` to choose a random integer in that range.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `-` 字符上断开 `reps` 字段，将低/高值强制转换为 `int` 值，然后使用 `random.randint()` 在该范围内选择一个随机整数。
- en: Use `random.sample()` to select the correct number of exercises.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `random.sample()` 来选择正确的练习数量。
- en: Use the `tabulate` module to format the output into a text table.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `tabulate` 模块将输出格式化为文本表。
- en: 19.2 Solution
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 19.2 解决方案
- en: How did that go for you? Did you manage to modify your program to gracefully
    handle all the bad input files?
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你感觉怎么样？你成功修改了程序，使其优雅地处理所有不良输入文件了吗？
- en: '[PRE44]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: ① Import the tabulate function we will use to format the output table.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ① 导入我们将用于格式化输出表的 tabulate 函数。
- en: ② The --file option, if provided, must be a readable text file.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ② 如果提供了 --file 选项，则必须是一个可读文本文件。
- en: ③ Ensure that args.num is a positive value.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 确保 args.num 是一个正数。
- en: ④ Initialize wod as an empty list.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 将 wod 初始化为空列表。
- en: ⑤ Read the input file into a list of exercises.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 将输入文件读取到练习列表中。
- en: ⑥ Randomly sample the given number of exercises. The result will be a list of
    tuples that each contain three values, which can be unpacked directly into the
    variables name and low and high values.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 随机抽取给定数量的练习。结果将是一个包含三个值的元组的列表，可以直接解包到变量 name 和 low 以及 high 值中。
- en: ⑦ Randomly select a value for reps that is in the provided range.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 随机选择一个在提供的范围内的 reps 值。
- en: ⑧ If args.easy is “truthy,” cut the reps in half.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 如果 args.easy 是 “truthy”，则将 reps 减半。
- en: ⑨ Append a tuple containing the name of the exercise and the reps to the wod.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 将包含练习名称和 reps 的元组附加到 wod 上。
- en: ⑩ Use the tabulate() function to format the wod into a text table using the
    appropriate headers.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ 使用 tabulate() 函数将 wod 格式化为一个使用适当标题的文本表。
- en: ⑪ Define a function to read an open CSV file handle.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ⑪ 定义一个函数来读取一个打开的 CSV 文件句柄。
- en: ⑫ Initialize exercises to an empty list.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ⑫ 将练习初始化为空列表。
- en: ⑬ Iterate through the file handle using the csv.DictReader() to create a dictionary
    combining the column names from the first row with the field values from the rest
    of the file. Use the comma as the field delimiter.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ⑬ 使用 csv.DictReader() 遍历文件句柄，创建一个将第一行的列名与文件其余部分中的字段值结合的字典。使用逗号作为字段分隔符。
- en: ⑭ Split the “reps” column on the dash, turn those values into integers, and
    assign to low and high variables.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ⑭ 在 dash 上拆分 “reps” 列，将这些值转换为整数，并分配给 low 和 high 变量。
- en: ⑮ Append a tuple containing the name of the exercise with the low and high values.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ⑮ 将包含练习名称以及 low 和 high 值的元组附加到 wod 上。
- en: ⑯ Return the list of exercises to the caller.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: ⑯ 将练习列表返回给调用者。
- en: ⑰ Define a function that Pytest will use to test the read_csv() function.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ⑰ 定义一个函数，Pytest 将使用它来测试 read_csv() 函数。
- en: ⑱ Create a mock file handle containing valid sample data.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ⑱ 创建一个包含有效样本数据的模拟文件句柄。
- en: ⑲ Verify that read_csv() can handle valid input data.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ⑲ 验证 read_csv() 是否可以处理有效输入数据。
- en: 19.3 Discussion
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 19.3 讨论
- en: Almost half the lines of the program are found within the `get_args()` function!
    Even though there’s nothing new to discuss, I really want to point out how much
    work is being done to validate the inputs, provide defaults, create the usage
    statement, and so forth. Let’s dig into the program, starting with the `read_csv()`
    function.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 程序中近一半的行都在 `get_args()` 函数中！尽管没有什么新内容可以讨论，但我真的想指出，为了验证输入、提供默认值、创建用法说明等，做了多少工作。让我们深入程序，从
    `read_csv()` 函数开始。
- en: 19.3.1 Reading a CSV file
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.3.1 读取 CSV 文件
- en: 'Earlier in the chapter, I left you with one line where you needed to split
    the reps column and convert the values to integers. Here is one way:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期，我给你留下一行代码，需要拆分 reps 列并转换值为整数。这里有一种方法：
- en: '[PRE45]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: ① Split the reps field on the dash, map the values through the int() function,
    and assign to low and high.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ① 在 dash 上拆分 reps 字段，通过 int() 函数映射值，并将它们分配给 low 和 high。
- en: 'The annotated line works as follows. Assume a reps value like so:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 注释行的工作原理如下。假设有一个 reps 值如下：
- en: '[PRE46]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We need to turn each of those into an `int` value, which is what the `int()`
    function will do. We could use a list comprehension:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将每个值转换为 `int` 类型，这正是 `int()` 函数要做的。我们可以使用列表推导式：
- en: '[PRE47]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'But the `map()` is much shorter and easier to read, in my opinion:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我看来，`map()` 更短且更容易阅读：
- en: '[PRE48]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Since that produces exactly two values, we can assign them to two variables:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这会产生正好两个值，我们可以将它们分配给两个变量：
- en: '[PRE49]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 19.3.2 Potential runtime errors
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.3.2 可能的运行时错误
- en: 'This code makes many, many assumptions that will cause it to fail miserably
    when the data doesn’t match the expectations. For instance, what happens if the
    `reps` field contains no dash? It will produce one value:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码做出了许多假设，当数据不符合预期时会导致它失败。例如，如果 reps 字段不包含 dash 会发生什么？它将产生一个值：
- en: '[PRE50]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'That will cause a *runtime* exception when we try to assign one value to two
    variables:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试将一个值分配给两个变量时，这将导致 *运行时* 异常：
- en: '[PRE51]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'What if one or more of the values cannot be coerced to an `int`? It will cause
    an exception, and, again, you won’t discover this until you run the program with
    bad data:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个或多个值不能被强制转换为`int`，它将引发异常，而且，同样，你只有在用坏数据运行程序时才会发现这一点：
- en: '[PRE52]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: What happens if there is no `reps` field in the record, as is the case when
    the field names are capitalized?
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果记录中没有`reps`字段，比如字段名是大写的情况下，会发生什么？
- en: '[PRE53]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Then the dictionary access `rec[''reps'']` will cause an exception:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，字典访问`rec['reps']`将引发异常：
- en: '[PRE54]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The `read_csv()` function seems to work just fine as long as we pass it well-formed
    data, but the real world does not always give us clean datasets. An unfortunately
    large part of my job, in fact, is finding and correcting errors like this.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们传递格式良好的数据，`read_csv()`函数似乎就能正常工作，但现实世界并不总是给我们干净的数据集。实际上，我的工作中很大一部分是寻找和纠正这类错误。
- en: 'Earlier in the chapter, I suggested you might use a regular expression to extract
    the low and high values from the `reps` field. A regex has the advantage of inspecting
    the entire field, ensuring that it looks correct. Here is a more robust way to
    implement `read_csv()`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期，我建议你可能使用正则表达式从`reps`字段中提取低值和高值。正则表达式的优点是检查整个字段，确保它看起来是正确的。这里是一个更健壮的`read_csv()`实现方式：
- en: '[PRE55]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: ① Initialize exercises as an empty list.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ① 将练习初始化为一个空列表。
- en: ② Iterate through the rows of the data.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ② 遍历数据的行。
- en: ③ Use the dict.get() function to try to retrieve the values for “exercise” and
    “reps.”
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 使用dict.get()函数尝试检索“exercise”和“reps”的值。
- en: ④ Check if we have “truthy” values for the exercise name and reps.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 检查练习名称和重复次数是否有“真值”。
- en: ⑤ Use a regex to look for one or more digits, followed by a dash, followed by
    one or more digits. Use capturing parentheses for the digits so they can be extracted.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 使用正则表达式查找一个或多个数字，后面跟一个破折号，再跟一个或多个数字。使用捕获括号来提取数字。
- en: ⑥ Check if there was a match. Remember that re.match() will return None to indicate
    a failure to match.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 检查是否有匹配项。请记住，re.match()将返回None以指示匹配失败。
- en: ⑦ Unpack the low and high values from the two capture groups and map them through
    the int() function to coerce the str values. This is safe because we use a regex
    to verify that they look like digits.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 从两个捕获组中提取低值和高值，并通过int()函数将它们映射为整数，以强制转换字符串值。这是安全的，因为我们使用正则表达式来验证它们看起来像数字。
- en: ⑧ Append the name and low and high values as a tuple to the exercises.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 将名称和低值和高值作为一个元组添加到练习中。
- en: ⑨ Return the exercises to the caller. If no valid data was found, we will return
    an empty list.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 将练习返回给调用者。如果没有找到有效数据，我们将返回一个空列表。
- en: 19.3.3 Using pandas.read_csv() to parse the file
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.3.3 使用pandas.read_csv()解析文件
- en: Many people familiar with statistics and data science will likely know the Python
    module called `pandas`, which mimics many ideas from the R programming language.
    I specifically chose the function name `read_csv()` because this is similar to
    a built-in function in R called `read.csv`, which was in turn used as the model
    for the `pandas.read_csv()` function. Both R and `pandas` tend to think of the
    data in delimited/CSV files in terms of a “data frame”--a two-dimensional object
    that allows you to deal with columns and rows of data.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 许多熟悉统计学和数据科学的人可能会知道Python模块`pandas`，它模仿了许多R编程语言的思想。我特意选择了函数名`read_csv()`，因为这类似于R中内置的函数`read.csv`，而`read.csv`又反过来作为`pandas.read_csv()`函数的模型。R和`pandas`都倾向于将分隔/CSV文件中的数据视为“数据框”——一个二维对象，允许你处理数据的列和行。
- en: 'To run the using_pandas.py version, you’ll need to install `pandas` like so:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行using_pandas.py版本，你需要像这样安装`pandas`：
- en: '[PRE56]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now you can try running this program:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以尝试运行这个程序：
- en: '[PRE57]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You’ll see this output:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到以下输出：
- en: '[PRE58]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Learning how to use `pandas` is far beyond the scope of this book. Mostly I
    just want you to be aware that this is a very popular way to parse delimited text
    files, especially if you intend to run statistical analyses over various columns
    of the data.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 学习如何使用`pandas`远远超出了本书的范围。我主要想让你知道，这是一种非常流行的解析分隔文本文件的方法，特别是如果你打算对数据的各个列进行统计分析的话。
- en: 19.3.4 Formatting the table
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.3.4 格式化表格
- en: 'Let’s look at the `main()` function I included in the solution. You may notice
    a runtime exception waiting to happen:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看解决方案中包含的`main()`函数。你可能注意到一个运行时异常正在等待发生：
- en: '[PRE59]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: ① This line will fail if args.num is greater than the number of elements in
    exercises, such as if read_csv() returns None or an empty list.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ① 如果args.num大于练习中的元素数量，例如read_csv()返回None或空列表，则此行将失败。
- en: 'If you test the given solution with the bad-headers-only.csv file, you will
    see this error:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 bad-headers-only.csv 文件测试给定的解决方案，你会看到这个错误：
- en: '[PRE60]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'A safer way to handle this is to check that `read_csv()` returns enough data
    to pass to `random.sample()`. We have a couple of possible errors:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这个问题的一个更安全的方法是检查 `read_csv()` 是否返回足够的数据传递给 `random.sample()`。我们有一些可能的错误：
- en: No usable data was found in the input file.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在输入文件中没有找到可用的数据。
- en: We are trying to sample too many records from the file.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在尝试从文件中采样过多的记录。
- en: 'Here is a possible way to handle these problems. Remember that calling `sys.exit()`
    with a string value will cause the program to print the message to `sys.stderr`
    and exit with a value of `1` (which is an error value):'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是处理这些问题的可能方法。记住，使用字符串值调用 `sys.exit()` 将导致程序将消息打印到 `sys.stderr` 并以值 `1`（错误值）退出：
- en: '[PRE61]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: ① Read the input file into exercises. The function should only return a list,
    possibly empty.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ① 将输入文件读入 exercises。该函数应仅返回一个列表，可能为空。
- en: ② Check if exercises is “falsey,” such as an empty list.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: ② 检查 exercises 是否为“假”，例如空列表。
- en: ③ Check if we are trying to sample too many records.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 检查我们是否尝试采样过多的记录。
- en: ④ Continue after we verify that we have enough valid data.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 在我们验证有足够有效数据后继续。
- en: The version in solution2.py has these updated functions and gracefully handles
    all the bad input files. Note that I moved the `test_read_csv()` function to the
    unit.py file because it became much longer as I tested with various bad inputs.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: solution2.py 中的版本有这些更新的函数，并且优雅地处理了所有不良输入文件。注意，我将 `test_read_csv()` 函数移动到 unit.py
    文件中，因为随着我用各种不良输入进行测试，它变得很长。
- en: 'You can run `pytest` `-xv` `unit.py` to run the unit tests. Let’s inspect unit.py
    to see a more rigorous testing scheme:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以运行 `pytest` `-xv` `unit.py` 来运行单元测试。让我们检查 unit.py 以查看更严格的测试方案：
- en: '[PRE62]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: ① Remember that you can import your own functions from your own modules into
    other programs. Here we are bringing in our read_csv() function. If we had instead
    used import wod, we could call wod.read_csv().
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ① 记住你可以从自己的模块中导入自己的函数到其他程序中。这里我们引入了我们的 read_csv() 函数。如果我们使用了 import wod，我们就可以调用
    wod.read_csv()。
- en: ② The original, valid input
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ② 原始、有效的输入
- en: ③ Testing with no data at all
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 测试没有任何数据的情况
- en: ④ Well-formed file (correct headers and delimiter), but no data
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 文件格式正确（正确的头和分隔符），但没有数据
- en: ⑤ The headers are capitalized, but only lowercase headers are expected.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 标题是大写的，但只期望小写标题。
- en: ⑥ A string (“forty”) that cannot be coerced by int() to a numeric value
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 一个无法通过 int() 强制转换为数值的字符串（“forty”）
- en: ⑦ A “reps” value (“20”) missing a dash
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 缺少连字符的 “reps” 值（“20”）
- en: ⑧ Well-formed data with correct headers, but using a tab for the delimiter
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 格式正确且带有正确头部的数据，但使用制表符作为分隔符
- en: 19.4 Going further
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 19.4 进一步学习
- en: '|'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Add an option to use a different delimiter, or guess that the delimiter is a
    tab if the input file extension is “.tab” as in the bad-delimiter.tab file.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个选项来使用不同的分隔符，或者如果输入文件扩展名为 “.tab”，如 bad-delimiter.tab 文件，则猜测分隔符为制表符。
- en: The `tabulate` module supports many table formats, including plain, simple,
    grid, pipe, orgtbl, rst, mediawiki, latex, latex_raw, and latex_booktabs. Add
    an option to choose a different `tabulate` format using these as the valid choices.
    Choose a reasonable default value.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tabulate` 模块支持许多表格格式，包括纯文本、简单、网格、管道、orgtbl、rst、mediawiki、latex、latex_raw 和
    latex_booktabs。添加一个选项来选择不同的 `tabulate` 格式，使用这些作为有效选择。选择一个合理的默认值。'
- en: '| ![](../Images/19-unnumb-5.png)  |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| ![图片](../Images/19-unnumb-5.png)  |'
- en: Summary
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: The `csv` module is useful for parsing delimited text data such as CSV and tab-delimited
    files.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`csv` 模块用于解析分隔文本数据，如 CSV 和制表符分隔的文件。'
- en: Text values representing numbers must be coerced to numeric values using `int()`
    or `float()` in order to be used as numbers inside your program.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示数字的文本值必须使用 `int()` 或 `float()` 转换为数值，才能在程序内部用作数字。
- en: The `tabulate` module can be used to create text tables to format tabular output.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tabulate` 模块可以用来创建文本表格，以格式化表格输出。'
- en: Great care must be taken to anticipate and handle bad and missing data values.
    Tests can help you imagine all the ways in which your code might fail.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须非常小心地预测和处理不良和缺失的数据值。测试可以帮助你想象出你的代码可能会失败的所有方式。
- en: '* * *'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '1 See “More Isn’t Always Better” by Barry Schwartz ([https://hbr.org/2006/06/more-isnt-always-better](https://hbr.org/2006/06/more-isnt-always-better)).
    He notes that increasing the number of choices given to people actually creates
    more distress and feelings of dissatisfaction, whatever choice is made. Imagine
    an ice cream shop with three flavors: chocolate, vanilla, and strawberry. If you
    choose chocolate, you’ll likely be happy with that choice. Now imagine that the
    shop has 60 flavors of ice cream, including 20 different fruit creams and sorbets
    and 12 different chocolate varieties from Rocky Road to Fudgetastic Caramel Tiramisu
    Ripple. Now when you choose a “chocolate” variety, you may leave with remorse
    about the 11 other kinds you could have chosen. Sometimes having no choice at
    all provides a sense of calm. Call it fatalism or whatnot.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 1 请参阅巴里·施瓦茨的《更多并不总是更好》（[https://hbr.org/2006/06/more-isnt-always-better](https://hbr.org/2006/06/more-isnt-always-better)）。他指出，给人们提供的选项数量增加实际上会带来更多的困扰和不满，无论做出何种选择。想象一下一家有三种口味的冰淇淋店：巧克力、香草和草莓。如果你选择了巧克力，你可能会对那个选择感到满意。现在想象一下，这家店有60种冰淇淋口味，包括20种不同的水果奶油和冰沙，以及从Rocky
    Road到Fudgetastic Caramel Tiramisu Ripple的12种不同的巧克力品种。现在当你选择“巧克力”口味时，你可能会因为错过了其他11种可以选择的口味而感到后悔。有时，没有选择本身就能带来一种平静感。称之为宿命论或其他什么都可以。
