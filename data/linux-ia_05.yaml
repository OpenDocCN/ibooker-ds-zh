- en: 'Chapter 5\. Automated administration: Configuring automated offsite backups'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 5 章. 自动化管理：配置自动远程备份
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Automating administrative tasks with scripts
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用脚本自动化管理任务
- en: Increasing security and system efficiency
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高安全性和系统效率
- en: Backing up local data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 备份本地数据
- en: Scheduling automated tasks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安排自动化任务
- en: If there’s one thing that I’d hope I made sufficiently clear in the previous
    chapter, it’s that regular and reliable system backups are absolutely *critical*.
    But, in many ways, the hard part is the *regular*. Keeping up with important tasks
    with immediate consequences is hard enough; remembering to run some dull daily
    or weekly backup is pretty much a nonstarter.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我在上一章中已经足够清晰地说明了某一点，那就是定期且可靠的系统备份绝对是**关键**。但是，从许多方面来看，困难的部分在于**定期**。跟上具有直接后果的重要任务已经足够困难；记得运行一些无聊的每日或每周备份几乎是不可能的。
- en: 'It’s no secret: the single best solution to the problem is to configure an
    automated scheduler to perform the task for you and then forget about it. Until
    recently, the scheduler you’d use on Linux would almost certainly have been some
    variation of the software utility cron; and, in fact, that’s still a great choice.
    But the systemd process manager you learned about back in [chapter 3](kindle_split_011.xhtml#ch03)
    has added systemd timers into the mix.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么秘密：解决这个问题的最佳方案是配置一个自动调度器来为你执行任务，然后忘记它。直到最近，Linux 上使用的调度器几乎肯定是一些软件工具 cron
    的变体；实际上，这仍然是一个很好的选择。但是，你在第 3 章（kindle_split_011.xhtml#ch03）中学到的 systemd 进程管理器已经将
    systemd 定时器添加到其中。
- en: I’m going to cover both approaches in this chapter, but I’ll also show you how
    to package backups and any other administration task into scripts, which can themselves
    be put on an automated schedule. To demonstrate how it all works in the real world,
    I’ll craft a command to backup some data to an AWS Simple Storage Solution (S3)
    bucket and then use the command to create schedulers using both cron and systemd
    timers.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在本章中介绍这两种方法，但也会向你展示如何将备份和其他管理任务打包到脚本中，这些脚本本身也可以被安排在自动化的时间表中。为了展示这一切在实际世界中的工作原理，我将创建一个命令，将一些数据备份到
    AWS 简单存储解决方案（S3）桶中，然后使用该命令通过 cron 和 systemd 定时器创建调度器。
- en: 5.1\. Scripting with Bash
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1. 使用 Bash 脚本
- en: A Linux *script* is a plain text file containing one or more commands compliant
    with Bash (or some other shell interpreter). Being able to string together multiple
    commands within a single file makes it possible to create executable routines
    that can rival programming languages in their complexity and versatility.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 的 *脚本* 是一个包含一个或多个符合 Bash（或某些其他 shell 解释器）命令的纯文本文件。能够在单个文件中串联多个命令，使得创建可以与编程语言在复杂性和多功能性上相媲美的可执行例程成为可能。
- en: 5.1.1\. A sample script for backing up system files
  id: totrans-11
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.1. 系统文件备份的示例脚本
- en: 'To illustrate what a working script might look like, let me show you a short,
    nicely written example that’s probably already active on your machine. Once we’ve
    worked through the script one line at a time, I’ll tell you what it all has to
    do with this chapter. And don’t forget the other important takeaway from this
    exercise: if you can read scripts, you can also write them. It’s the exact same
    skill set.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明一个工作脚本可能的样子，让我给你展示一个简短、写得很好的例子，这个例子可能已经在你的机器上运行了。一旦我们逐行分析完脚本，我会告诉你这一切与本章有什么关系。而且别忘了这个练习的另一个重要收获：如果你能读懂脚本，你也能编写它们。这是完全相同的技能集。
- en: 'This script uses a series of powerful tools to do something that’s actually
    quite simple: create secure backups of four important system files to ensure a
    usable replacement in case the originals are somehow corrupted. [Figure 5.1](#ch05fig01)
    illustrates the script’s actions as a flow chart. Note that `$FILE` is a variable
    used to represent a set of filenames processed by the script.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本使用一系列强大的工具来完成实际上相当简单的事情：创建四个重要系统文件的加密备份，以确保在原始文件被意外损坏时有一个可用的替代品。[图 5.1](#ch05fig01)
    说明了脚本的操作流程图。请注意，`$FILE` 是一个用于表示脚本处理的文件集的变量。
- en: Figure 5.1\. The decision flow traced by the passwd script
  id: totrans-14
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.1. passwd 脚本跟踪的决策流程
- en: '![](Images/05fig01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/05fig01.jpg)'
- en: 'Head over to the /etc/cron.daily/ directory and list the contents. You’ll probably
    see a file called passwd. Display the file using `less` (or `cat` or `nano` or
    `vim`). It’s your choice. If it doesn’t happen to be there, this is what it looks
    like:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 转到 /etc/cron.daily/ 目录并列出内容。你可能会看到一个名为 passwd 的文件。使用 `less`（或 `cat`、`nano` 或
    `vim`）显示该文件。由你选择。如果它恰好不在那里，它看起来是这样的：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Normally the `#` character introduces a comment that wouldn’t be read by the
    interpreter. In this particular case, where both `#` and `!` are used, Linux will
    read the comment and use its value (/bin/sh) as the active shell. The string is
    popularly known as the *shebang line*, though don’t ask me why. Although `sh`
    is an alternative to `bash`, for our purposes right now, there aren’t any practical
    differences between the two.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通常 `#` 字符引入的注释不会被解释器读取。在这个特定的例子中，由于同时使用了 `#` 和 `!`，Linux 将读取注释并使用其值（/bin/sh）作为活动
    shell。这个字符串通常被称为 *shebang 行*，尽管我不清楚为什么。虽然 `sh` 是 `bash` 的一个替代品，但就我们现在的目的而言，两者之间没有实际的区别。
- en: 'The next line in the script changes the directory to /var/backups/. If no such
    directory exists, it exits the script and issues an exit status code of `0`, which
    signifies the command was successful:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的下一行将更改目录到 /var/backups/。如果不存在这样的目录，它将退出脚本并发出退出状态码 `0`，这表示命令成功：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `||` sequence (sometimes known as a double pipe) can be read as though
    it’s the word *or*. So this line means: either change directory to /var/backups/
    or exit the script. If everything goes according to plan, subsequent script operations
    will take place in the /var/backups/ directory.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`||` 序列（有时被称为双竖线）可以读作单词 *or*。所以这一行意味着：要么更改目录到 /var/backups/，要么退出脚本。如果一切按计划进行，后续的脚本操作将在
    /var/backups/ 目录中进行。'
- en: '|  |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-23
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Exit codes are passed when a Linux command completes. A `0` will be passed to
    indicate success, whereas different numbers can be configured to specify some
    kind of error.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Linux 命令完成时，会传递退出码。`0` 将被传递以表示成功，而不同的数字可以配置来指定某种错误。
- en: '|  |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'In the next part of the code, the line starting with `for` introduces a loop.
    Those of you with programming experience will have no trouble understanding what’s
    going on here: the script will assign in turn each of the following four strings
    (`passwd`, `group`, and so forth) as the value of the variable `FILE`. It then
    executes the code block between the reserved words `do` and `done`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的下一部分，以 `for` 开头的行引入了一个循环。对于有编程经验的你们来说，理解这里发生的事情不会有任何困难：脚本将依次将以下四个字符串（`passwd`、`group`
    等等）作为变量 `FILE` 的值。然后它执行 `do` 和 `done` 保留词之间的代码块：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here’s a brief definition of some of those concepts:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些概念的简要定义：
- en: '*Loop*—A sequence of actions delimited by reserved words to be repeated until
    a specified condition is met'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*循环*—由保留词分隔的一系列操作，直到满足指定条件为止'
- en: '*String*—A contiguous sequence of characters'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*字符串*—字符的连续序列'
- en: '*Variable*—A value that can change and can be dynamically incorporated into
    script actions'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*变量*—一个可以更改并且可以动态地纳入脚本操作中的值'
- en: '*Reserved word*—A term interpreted according to a predefined meaning by the
    shell'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*保留词*—由 shell 根据预定义的含义解释的术语'
- en: 'Getting back to the script, the first of the following lines will test for
    the existence of a file in the /etc/ directory whose name matches the current
    value of the variable `$FILE`. If there isn’t a file with that name in /etc/,
    then the script will continue by assigning the next string (the next filename)
    to the `$FILE` variable and testing for its existence:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 回到脚本，下面第一行将检查 /etc/ 目录中是否存在一个文件，其名称与变量 `$FILE` 的当前值匹配。如果 /etc/ 中没有以该名称命名的文件，则脚本将继续通过将下一个字符串（下一个文件名）分配给
    `$FILE` 变量并检查其存在性来继续：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If there is such a file in /etc/, then the script will compare (`cmp`) the
    contents of the file with the contents of a file of the exact same name plus the
    .bak filename extension in the current directory (/var/backups/). If the comparison
    operation (`&&`) is successful, the shell will continue the `for` loop and try
    the next string. If, on the other hand, the content of the two files isn’t identical,
    then it will move to the next line:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 /etc/ 中存在这样的文件，则脚本将比较该文件的内容与当前目录（/var/backups/）中具有相同名称加上 .bak 文件扩展名的文件的内容。如果比较操作（`&&`）成功，shell
    将继续 `for` 循环并尝试下一个字符串。另一方面，如果两个文件的内容不匹配，则它将移动到下一行：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, at last, the script will deliver its payload: it copies the current version
    in the /etc/ directory to the /var/backups/ directory, adds .bak to its name,
    and tightens the file’s permissions to prevent unauthorized users from reading
    it. The operation will overwrite any existing files with that same name. The `-p`
    flag in the example preserves the source file’s original ownership attributes
    and timestamp:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，最后，脚本将交付其有效载荷：它将 /etc/ 目录中的当前版本复制到 /var/backups/ 目录，将其名称添加 .bak，并调整文件权限以防止未经授权的用户读取它。此操作将覆盖具有相同名称的任何现有文件。示例中的
    `-p` 标志保留源文件的原始所有权属性和时间戳：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'What does that script do? It’s designed to create copies of specified configuration
    files that have been updated since their last backup. Here’s how it works: if
    files with the specified names exist in the active /etc/ directory and their contents
    are different from similarly named files in the /var/backups/ directory, then
    those in /etc/ will be copied to /var/backups/ and appropriately renamed and secured.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 那个脚本做什么？它旨在创建指定配置文件的副本，这些文件自上次备份以来已更新。以下是工作原理：如果指定的名称在活动 /etc/ 目录中存在，并且其内容与
    /var/backups/ 目录中类似名称的文件不同，那么 /etc/ 中的文件将被复制到 /var/backups/，并适当地重命名和加密。
- en: 'But what’s the deal with those four files (passwd, group, shadow, and gshadow)?
    They’re the files whose contents determine how individual users and groups will
    be able to access particular resources. For instance, if you were to look at the
    contents of /etc/passwd, you’d see a single line for every account that exists.
    In the following extract, you can see regular user accounts are assigned user
    and group IDs (`1000`, in the case of ubuntu), a home directory (/home/ubuntu/),
    and a default shell (bash). Some system users like syslog also have a default
    shell that is, curiously, set to /bin/false. This is a way of preventing a human
    user from logging in to the system using that account, which would be insecure:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 但那四个文件（passwd、group、shadow 和 gshadow）是怎么回事？它们的内容决定了单个用户和组如何能够访问特定资源。例如，如果你查看
    /etc/passwd 的内容，你会看到每个账户都有一行。在下面的摘录中，你可以看到常规用户账户被分配了用户和组 ID（例如 ubuntu 的 `1000`），家目录（/home/ubuntu/），以及默认的
    shell（bash）。一些系统用户（如 syslog）也有一个默认的 shell，奇怪的是，设置为 /bin/false。这是一种防止人类用户使用该账户登录系统的方法，这会不安全：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1* ubuntu’s user ID (1000), home directory (/home/ubuntu), and default shell
    (bash)**'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* ubuntu 的用户 ID（1000）、家目录（/home/ubuntu）和默认 shell（bash）**'
- en: '***2* Non-user accounts shouldn’t be used for login (/bin/false).**'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 不应使用非用户账户进行登录 (/bin/false)。**'
- en: When you add a new user to your system using
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用以下方式将新用户添加到你的系统时
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: new lines will be added to each of the passwd, shadow, and group files. In fact,
    all related user administration operations can be performed from the command line
    (or through scripts) without the need to directly edit these files.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 将在新添加的 passwd、shadow 和 group 文件中添加新行。实际上，所有相关的用户管理操作都可以从命令行（或通过脚本）执行，而无需直接编辑这些文件。
- en: '|  |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-48
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Ubuntu prefers you use `adduser username` over `useradd username`, although
    both will work. One advantage of `adduser` is that a home directory will be automatically
    created, whereas `useradd` requires the `-m` argument. The command `adduser` will
    also prompt for a password for your new user. If you use `useradd`, you’ll need
    to run `sudo passwd new-user-name` separately to set up a password.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Ubuntu 倾向于使用 `adduser username` 而不是 `useradd username`，尽管两者都可以工作。`adduser` 的一个优点是会自动创建家目录，而
    `useradd` 需要使用 `-m` 参数。`adduser` 命令还会为新用户提示输入密码。如果你使用 `useradd`，你需要单独运行 `sudo
    passwd new-user-name` 来设置密码。
- en: '|  |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Once upon a time, an encrypted version of each user’s password would also have
    been included here. For practical reasons, because the passwd file must remain
    readable by anyone on the system, it was felt that including even encrypted passwords
    was unwise. Those passwords were moved to /etc/shadow. Using `sudo` permissions,
    you should take a look at that file with its encrypted passwords on your own system.
    Here’s how:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，每个用户的密码的加密版本也会包含在这里。出于实际原因，因为 passwd 文件必须由系统上的任何人可读，所以包括加密密码被认为是不明智的。那些密码被移动到了
    /etc/shadow。使用 `sudo` 权限，你应该在自己的系统上查看包含加密密码的该文件。以下是方法：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The /etc/group file contains basic information about all currently existing
    system and user groups. You can manually edit the group file to manage group membership.
    You could, for instance, give administrative rights to new users joining your
    team by adding their names to the sudo group. That line would look like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: /etc/group 文件包含有关所有当前存在的系统和用户组的基本信息。您可以手动编辑组文件来管理组成员。例如，您可以通过将新加入团队的用户姓名添加到
    sudo 组中来授予他们管理权限。该行将看起来像这样：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Don’t add any spaces between names and commas. Doing so will result in immediate
    unhappiness.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在名称和逗号之间不要添加任何空格。这样做会导致立即的不愉快。
- en: 'One last file: The /etc/gshadow file contains encrypted versions of group passwords
    for use if you sometimes want to allow group resource access to non-group users.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个文件：/etc/gshadow 文件包含用于在您有时想允许非组成员访问组资源时使用的加密组密码版本。
- en: 'As you might already have guessed, that script was a great example for this
    chapter because of where it lives: the /etc/cron.daily/ directory. Scripts saved
    to the /cron.daily/ directory will be executed each day. We’ll get back to all
    that soon. For now, as another simple example, here’s a script file called upgrade.sh
    to have `apt` automate updates to all my installed software:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已经猜到的，这个脚本是这个章节的一个很好的例子，因为它位于：/etc/cron.daily/ 目录。保存到 /cron.daily/ 目录的脚本将每天执行。我们很快就会回到所有这些。现在，作为另一个简单的例子，这里有一个名为
    upgrade.sh 的脚本文件，用于让 `apt` 自动更新所有已安装的软件：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you no doubt recall, the `apt update` command will sync with indexes on the
    online repositories, ensuring that APT is aware of all the most recent packages
    and versions available. `apt upgrade` will download and install any relevant upgrades.
    `-y` will automatically answer Yes when asked to confirm the operation.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所无疑问地回忆起，`apt update` 命令将与在线仓库的索引同步，确保 APT 了解所有最新的软件包和版本。`apt upgrade` 将下载并安装任何相关的更新。`-y`
    将在询问确认操作时自动回答是。
- en: 'You’re still not quite ready to run your script. Because you’re going to be
    running the script as a program, you’ll need to change the file attributes to
    make it executable. `chmod +x` followed by the filename will do that:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您仍然还没有准备好运行您的脚本。因为您将以程序的方式运行脚本，您需要更改文件属性使其可执行。`chmod +x` 后跟文件名即可完成此操作：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'That’s it. You’re now free to copy the file to the /etc/cron.daily/ directory
    where it can join passwd and others as they’re run each day:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。现在您可以自由地将文件复制到 /etc/cron.daily/ 目录中，这样它就可以与 passwd 和其他文件一起每天运行：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Because it runs `apt`, the new script requires administrator permissions, but
    there’s no need to include `sudo` in the command itself. Cron, by default, will
    always run as root. If you did want to run the script directly from the command
    line, you’d need to add `sudo` and preface the filename with a dot and forward
    slash to tell Linux that the command you’re referencing is in the current directory:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它运行 `apt`，新的脚本需要管理员权限，但不需要在命令本身中包含 `sudo`。默认情况下，Cron 总是以 root 身份运行。如果您想直接从命令行运行脚本，则需要添加
    `sudo` 并在文件名前加上点号和正斜杠，以告诉 Linux 您引用的命令位于当前目录中：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 5.1.2\. A sample script for changing filenames
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.2\. 一个用于更改文件名的示例脚本
- en: 'Let me throw a couple more scripting tools at you. You’ve probably already
    come face to face with the fact that the Linux shell can sometimes misinterpret
    filenames that include spaces. Here’s what it’d look like if you tried to `cat`
    the contents of a file called big name:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我再向您介绍一些脚本工具。您可能已经遇到了这样一个事实，即 Linux shell 有时可能会错误地解释包含空格的文件名。如果您尝试 `cat` 一个名为
    big name 的文件的 内容，它看起来会是这样：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The simple workaround is to enclose the complete filename in either single
    or double quotation marks like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的解决方案是将完整的文件名用单引号或双引号括起来，如下所示：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'But that option won’t always be available. In that case, you could automate
    a process to convert spaces within filenames to, say, underscore characters. Then,
    in the course of your journeys, when you came across a directory containing lots
    of offending filenames, you’d be able to execute a script to fix things fast.
    Well, here it is:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 但这个选项并不总是可用。在这种情况下，您可以通过将文件名中的空格自动转换为，例如，下划线字符来自动化一个过程。然后，在您的旅途中，当您遇到包含大量违规文件名的目录时，您将能够执行一个脚本来快速修复问题。好吧，这就是它：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `echo` line prints its text to the screen and then waits for user input.
    The user will type in a valid directory like /home/ubuntu/files/, which will be
    assigned as the value of the variable `directory`. The `find` command will be
    invoked to return all file objects (`-type f`) in the specified directory. The
    set of filenames from `find` will be read, one at a time in a `while` loop, with
    each one tested for the presence of a space. If a space is found, `then` any spaces
    (‘ ’) in the filename will be changed (`mv`) to underscores (‘_’). And `fi;` stops
    the loop when there are no more filenames in the directory.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`echo` 行将文本打印到屏幕上，然后等待用户输入。用户将输入一个有效的目录，如 /home/ubuntu/files/，它将被分配为变量 `directory`
    的值。`find` 命令将被调用以返回指定目录中的所有文件对象 (`-type f`)。`find` 的文件名集将逐个在 `while` 循环中读取，每个文件都会检查是否存在空格。如果找到空格，`then`
    将文件名中的任何空格（‘ ’）更改为下划线（‘_’）。`fi;` 当目录中没有更多文件名时停止循环。'
- en: To try this out, create a directory with a few files containing spaces in their
    filenames, and then run the script for yourself. A directory that did look like
    this
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试这个，创建一个包含带有空格的文件名的几个文件的目录，然后运行脚本。一个看起来像这样的目录
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'should now look like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 应该看起来像这样：
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '|  |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Think carefully about each of the steps that make up the script and be sure
    you understand exactly what’s going on.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细思考组成脚本的每个步骤，并确保你确切地了解正在发生什么。
- en: '|  |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Let’s spend a moment reminding ourselves of exactly where we are. It’s always
    a good idea to make sure you’re not staring at the trees and missing the forest.
    Here’s what’s happened so far:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花一点时间提醒自己我们现在在哪里。确保你不是只盯着树木而错过了整个森林总是一个好主意。到目前为止发生的事情如下：
- en: The chapter is about using scripts to create automated backups.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章是关于使用脚本创建自动备份。
- en: You explored the script for backing up user admin files from /etc/ to /var/backup/.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你探索了从 /etc/ 到 /var/backup/ 的用户管理员文件的备份脚本。
- en: You learned about the care and feeding of those user admin files.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你学习了那些用户管理员文件的照顾和喂养。
- en: You wrote your own simple script.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你编写了自己的简单脚本。
- en: 'Here’s what’s still to come:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来还将发生什么：
- en: You’ll back up your own data to an AWS S3 bucket.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将把自己的数据备份到AWS S3存储桶。
- en: You’ll use cron and anacron to schedule regular backups.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将使用cron和anacron来安排定期备份。
- en: You’ll learn how that’s also done using systemd timers.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将学习如何使用systemd定时器来完成这项工作。
- en: Scripts can be used for much more than backups and filenames. With the ever-increasing
    demands on servers and network environments, environments that sometimes require
    hundreds or even thousands of dynamically generated virtual microservices, manual
    administration is pretty much impossible. Through your career as a system administrator,
    you’re probably going to need to create scripts to provision and launch individual
    and swarms of VMs, and to monitor massive and constantly changing environments.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本可以用于比备份和文件名多得多的用途。随着对服务器和网络环境需求的不断增长，有时需要数百甚至数千个动态生成的虚拟微服务，手动管理几乎是不可能的。在你作为系统管理员的职业生涯中，你可能会需要创建脚本来配置和启动单个和成群的虚拟机，以及监控庞大且不断变化的环境。
- en: 5.2\. Backing up data to AWS S3
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2\. 将数据备份到AWS S3
- en: 'Here are two reasons that I chose Amazon’s AWS S3 as the target of the backup
    example I’m going to use:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择亚马逊的AWS S3作为我将要使用的备份示例的目标，有以下两个原因：
- en: It’s crucial to always keep copies of important data off-site.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是保持重要数据离线副本至关重要。
- en: Archiving to S3 is something that’s popular right now, and it’s crazy easy.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将存档到S3是目前流行的事情，而且非常简单。
- en: That’s it. The fact that this would be a great opportunity to shamelessly promote
    my book *Learn Amazon Web Services in a Month of Lunches* (Manning, 2017) that’s
    chock full of everything you could possibly need to know about AWS had absolutely
    no impact on my choice. None. Well, maybe just a little.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。这个事实是，这是一个极好的机会来毫不掩饰地推广我的书《一个月午餐时间学习亚马逊网络服务》（Manning，2017），这本书充满了你可能需要知道的所有关于AWS的知识，这绝对没有影响我的选择。没有。好吧，也许只是有一点。
- en: At any rate, if you don’t happen to have an AWS account of your own yet, you
    can still follow along with the next section and substitute a backup script of
    your own for the AWS one I’m going to show you. Alternatively, you could also
    visit [https://aws.amazon.com](https://aws.amazon.com) and sign up for a new account.
    It won’t cost you anything to open the account and, under the Free Tier, many
    services (including 5 GB of S3 storage) are available at no cost for the first
    year.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，如果您还没有自己的 AWS 账户，您仍然可以跟随下一节，并用您自己的备份脚本替换我将向您展示的 AWS 脚本。或者，您也可以访问 [https://aws.amazon.com](https://aws.amazon.com)
    并注册一个新账户。开设账户不会花费您任何费用，并且根据免费层，许多服务（包括 5 GB 的 S3 存储）在第一年都是免费的。
- en: By the way, even after your Free Tier rights on AWS are over, storage still
    only costs around $0.025 per GB per month. That’s probably cheap enough to make
    you change the way you think about off-site archives in general.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，即使您的 AWS 免费层权限已经结束，存储费用仍然大约为每月每 GB 0.025 美元。这可能足够便宜，足以让您改变对异地存档的一般看法。
- en: 5.2.1\. Installing the AWS command-line interface (CLI)
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.1\. 安装 AWS 命令行界面 (CLI)
- en: There’s a lot of AWS administration you can do from your browser in the AWS’s
    console, but that’s not how real Linux admins get things done. If you’re going
    to incorporate your backups to S3 into a script, it’s going to have to be something
    that’ll work on the command line. For that, look no further than Amazon’s own
    AWS CLI. Because it runs on Python, you’ll need to run at least Python 2 (version
    2.6.5) or Python 3 (version 3.3). In addition, you’ll need the pip Python package
    manager to handle the installation. As of this writing, Ubuntu is pushing to make
    Python 3 its default version, although other distributions might still favor Python
    2.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 AWS 控制台中通过浏览器执行许多 AWS 管理任务，但这并不是真正的 Linux 管理员完成任务的方式。如果您打算将备份到 S3 的操作集成到脚本中，那么它必须在命令行上工作。为此，您无需寻找其他选择，只需使用亚马逊自己的
    AWS CLI。因为它运行在 Python 上，所以您至少需要运行 Python 2（版本 2.6.5）或 Python 3（版本 3.3）。此外，您还需要
    pip Python 包管理器来处理安装。截至本文撰写时，Ubuntu 正在努力将 Python 3 作为其默认版本，尽管其他发行版可能仍然更倾向于 Python
    2。
- en: 'If the following install command doesn’t work, then you probably need to install
    pip. (Use either `apt install python-pip` or `apt install python3-pip`.) Here’s
    the ultra-secret, insiders-only, I-can-reveal-it-to-you-but-then-I’ll-have-to-kill-you
    hidden code that tells you which pip instalation you’ll need. If it works, that’s
    the right one. If it doesn’t, try the other one:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果以下安装命令不起作用，那么您可能需要安装 pip。（使用 `apt install python-pip` 或 `apt install python3-pip`。）以下是超秘密、内部人士专属、我可以向您透露但之后我必须杀掉您的隐藏代码，它告诉您需要哪种
    pip 安装。如果它有效，那就是正确的。如果不起作用，请尝试另一个：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '***1* pip nicely displays real-time progress details.**'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* pip 可以很好地显示实时进度详情。**'
- en: '***2* A summary of all the packages installed by pip**'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* pip 安装的包的摘要**'
- en: 5.2.2\. Configuring your AWS account
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.2\. 配置您的 AWS 账户
- en: You’re now ready to link the local AWS CLI with your AWS account. To do that,
    you’ll need to retrieve some access keys. From any page in the console, click
    the drop-down menu header with your account name on it (top right on the page),
    and then click the My Security Credentials link ([figure 5.2](#ch05fig02)).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经准备好将本地 AWS CLI 与您的 AWS 账户链接。为此，您需要检索一些访问密钥。在控制台中的任何页面，点击带有您账户名称的下拉菜单标题（页面右上角），然后点击“我的安全凭证”链接（[图
    5.2](#ch05fig02)）。
- en: Figure 5.2\. The AWS console with direct links to dozens of AWS services. Here
    the My Security Credentials link is visible.
  id: totrans-107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.2\. AWS 控制台，直接链接到数十个 AWS 服务。这里可以看到“我的安全凭证”链接。
- en: '![](Images/05fig02_alt.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig02_alt.jpg)'
- en: 'Once you’re on the Your Security Credentials page, click to expand the Access
    Keys (Access Key ID and Secret Access Key) section and note the warning that might
    appear: Existing Root Keys Cannot Be Retrieved. Then click the Create New Access
    Key button. You’ll be shown your new access key ID and its accompanying secret
    access key. The former serves the same function as a login name, and the latter
    acts like its password. You can either download the access key and save it to
    a secure location on your computer or select, copy, and paste it somewhere.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您进入“我的安全凭证”页面，点击展开“访问密钥”（访问密钥 ID 和秘密访问密钥）部分，并注意可能出现的警告：现有根密钥无法检索。然后点击“创建新访问密钥”按钮。您将看到您的新访问密钥
    ID 和其相应的秘密访问密钥。前者与登录名具有相同的功能，后者则像密码一样。您可以将访问密钥下载并保存到计算机上的安全位置，或者选择、复制并粘贴到其他地方。
- en: 'To set things up, open a terminal on your local machine and run `aws configure`
    from the command line. You’ll be asked for your access key ID, your secret access
    key, the AWS region you’d like to make default, and the format you’d like to use
    for output. You can leave those final two values blank if you like. The following
    example from the AWS documentation uses fake credentials (you should never publicly
    display a real key set):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置这些，在你的本地机器上打开一个终端，并从命令行运行 `aws configure`。你将被要求输入你的访问密钥 ID、你的秘密访问密钥、你想要设置为默认的
    AWS 区域，以及你想要使用的输出格式。如果你愿意，可以留出最后两个值。以下 AWS 文档中的示例使用了假凭证（你永远不应该公开显示真实的密钥集）：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '***1* Determines the AWS geographic center from which resources will be launched**'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 确定资源将从中启动的 AWS 地理中心**'
- en: '***2* Choose to have output displayed in text (default), JSON, or table format.**'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 选择以文本（默认）、JSON 或表格格式显示输出。**'
- en: '|  |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: When setting the default region name, bear in mind that local regulatory regimens
    can restrict the backup of some data to offshore servers.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置默认区域名称时，请记住，地方监管制度可能会限制将某些数据备份到海外服务器。
- en: '|  |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: You should now be all set to get to work. The following command line
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该已经准备好开始工作了。以下命令行
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: will list all the S3 buckets in your account. *Bucket* is the term AWS uses
    for what we would call a directory.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 将列出你账户中的所有 S3 存储桶。*存储桶* 是 AWS 用于我们称之为目录的术语。
- en: 5.2.3\. Creating your first bucket
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.3\. 创建你的第一个存储桶
- en: 'Assuming this is a brand-new account, nothing will be displayed. You should
    create a new bucket with the make bucket command: `mb`. One thing to keep in mind
    when choosing a bucket name is that it must be unique across the entire S3 system.
    As shown, something like mybucket probably won’t be accepted:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 假设这是一个全新的账户，将不会显示任何内容。你应该使用创建存储桶命令 `mb` 创建一个新的存储桶。在选择存储桶名称时要注意的是，它必须在整个 S3 系统中是唯一的。如图所示，像
    mybucket 这样的名称可能不会被接受：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Instead, using less common words and adding a few numbers will probably work
    a lot better:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，使用不太常见的词汇并添加几个数字可能会效果更好：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'One more step and we’ve got ourselves an off-site backup job. Assuming that
    the files you need to back up are in a directory called /dir2backup, located in
    your home directory, here’s how it’ll go:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 再多一步，我们就有了离线备份工作。假设你需要备份的文件位于名为 /dir2backup 的目录中，该目录位于你的主目录中，以下是它的工作方式：
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`s3 sync` works a lot like the `rsync` tool you met in [chapter 4](kindle_split_012.xhtml#ch04).
    The first time you run it, everything in the source directory will be uploaded
    to your S3 bucket; subsequently, only new or changed files will be transferred.
    Creating a script to run that `sync` command will be pretty much straightforward.
    Here’s how it might look:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`s3 sync` 工具的工作方式与你在第 4 章中遇到的 `rsync` 工具非常相似。第一次运行它时，源目录中的所有内容都将上传到你的 S3 存储桶；随后，只有新文件或更改的文件将被传输。创建一个运行该
    `sync` 命令的脚本将非常直接。下面是如何看起来：'
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Note how I added the full path to the `aws` command (/usr/local/bin/aws). This
    is to make sure that Bash knows where on the system to find the command. You can
    confirm the location of `aws` using `whereis`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我添加了 `aws` 命令的完整路径 (/usr/local/bin/aws)。这是为了确保 Bash 知道在系统中的哪个位置可以找到该命令。你可以使用
    `whereis` 命令来确认 `aws` 的位置：
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Having a great backup tool in place doesn’t mean you’ll use it. That requires
    some kind of task scheduler. You’ll learn about a couple of those schedulers next.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然已经部署了优秀的备份工具，但这并不意味着你会使用它。这需要某种类型的任务调度器。你将在下一节中了解几个这样的调度器。
- en: 5.3\. Scheduling regular backups with cron
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3\. 使用 cron 定期安排备份
- en: 'Cron comes in a number of flavors. Because that number is greater than one,
    you can expect that there’s often more than one way to get a particular task done.
    To get a feel for what’s there, list the objects in the /etc/ directory that include
    the letters *cron*:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Cron有多种风味。因为那个数字大于一，你可以预期通常有不止一种方法来完成特定的任务。为了了解有哪些内容，列出 /etc/ 目录中包含字母 *cron*
    的对象：
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Of those, only anacrontab and crontab are files; the rest are directories. Let’s
    begin by seeing how the directories work.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些中，只有 anacrontab 和 crontab 是文件；其余的是目录。让我们先看看这些目录是如何工作的。
- en: 'If you’ve got, say, a file system backup script in an executable file you want
    run at set intervals, you copy it to the appropriate directory: cron.hourly/ for
    execution each hour, cron.daily/ to be run daily, and so on. The cron.d/ directory
    is a bit different. It’s meant for files whose contents precisely time the execution
    of commands.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个文件系统备份脚本，你希望它在设定的时间间隔内运行，你可以将其复制到相应的目录：`cron.hourly/` 以每小时执行一次，`cron.daily/`
    以每天执行一次，依此类推。`cron.d/` 目录略有不同。它是为那些内容精确控制命令执行时间的文件设计的。
- en: 'Suppose you wanted to run that software upgrade job I scripted earlier once
    each Monday, but without the script. You could create a file in the /etc/cron.d
    directory with these contents:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要运行我之前编写的那个软件升级任务，但不需要脚本，每周一运行一次。你可以在 `/etc/cron.d` 目录中创建一个包含以下内容的文件：
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This example will run the upgrade at 5:21 each Monday morning. How does that
    work? Look at the first characters: `21 5`. The first field (`21`) represents
    the number of minutes into the hour that you want the command run. In this case,
    it will run 21 minutes in. The next field is where you can specify which hour
    of the day (for example, 8 or 23). This one is `5`, which means 5:00 a.m. The
    next two asterisks followed by a `1` indicate that you want the schedule followed
    on every day of the month, in every month of the year, on each Monday (1 represents
    Monday). To avoid confusion, either 0 or 7 can be used for Sunday. The `root`
    argument means that the command will be run as the root user.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子将在每周一早上 5:21 运行升级。这是怎么工作的？看看前几个字符：`21 5`。第一个字段（`21`）代表你希望命令运行的每小时中的分钟数。在这种情况下，它将在
    21 分钟后运行。下一个字段是你可以指定一天中的哪个小时（例如，8 或 23）。这个是 `5`，意味着早上 5:00。接下来的两个星号后面跟着一个 `1`
    表示你想要在每月的每一天、每年的每个月、每周的每个星期一（1 代表星期一）遵循该计划。为了避免混淆，可以使用 0 或 7 来表示星期日。`root` 参数意味着命令将以
    root 用户身份运行。
- en: Why so early? Because, presumably, competing demand for network bandwidth will
    be lower before everyone gets into the office. Why 5:21 rather than 5:00? Because
    you don’t want to fall into the habit of scheduling all of your scripts for exactly
    the top of the hour (or any one time), as that might eventually cause a conflict.
    Better to stagger them.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这么早？因为，假设在每个人都进入办公室之前，对网络带宽的竞争需求会较低。为什么是 5:21 而不是 5:00？因为你不想养成将所有脚本都安排在每小时顶点（或任何特定时间）的习惯，因为这可能会最终导致冲突。最好是错开时间。
- en: You could add that line directly into the /etc/crontab file, and it would run
    the same way but without the need to create a separate file. But I wouldn’t. Doing
    so might not unleash a zombie apocalypse on the world, but it’s still a bad idea.
    You see, the crontab file is likely to be overwritten during system upgrades,
    and your custom commands will be lost.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以直接将那一行添加到 `/etc/crontab` 文件中，它将以相同的方式运行，但不需要创建一个单独的文件。但我不建议这样做。这样做可能不会在世界范围内引发僵尸末日，但仍然是一个糟糕的想法。你看，在系统升级期间，crontab
    文件可能会被覆盖，你的自定义命令将会丢失。
- en: Then what’s the point of the crontab file? As you should be able to see from
    the file contents ([figure 5.3](#ch05fig03)), this is the scheduler that executes
    the scripts within the /cron.? directories. Take a minute or two to look through
    each command for yourself.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，crontab 文件有什么用呢？正如你应该能够从文件内容中看到的那样（[图5.3](#ch05fig03)），这是执行 `/cron.?` 目录中脚本的调度器。花一两分钟自己查看每个命令。
- en: Figure 5.3\. The well-documented /etc/crontab file showing four jobs, each designed
    to launch the contents of an /etc/cron.? directory
  id: totrans-144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.3。详细说明的 `/etc/crontab` 文件，展示了四个任务，每个任务都旨在启动 `/etc/cron.?` 目录的内容
- en: '![](Images/05fig03_alt.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/05fig03_alt.jpg)'
- en: The `test -x` leading off the final three commands in [figure 5.3](#ch05fig03)
    confirms that a binary program called anacron exists and is executable. If either
    of those is not true, then the scripts in the /cron.? directories will be run.
    The `text -x` command can be useful for scripting, in general, when you need to
    confirm to status of an object before launching a related operation.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.3](#ch05fig03) 中最后三个命令开头的 `test -x` 确认了一个名为 anacron 的二进制程序存在且可执行。如果其中任何一个不成立，那么
    `/cron.?` 目录中的脚本将会运行。`test -x` 命令在脚本编写中通常很有用，当你需要在启动相关操作之前确认对象的状态时。'
- en: You’re definitely going to want to leave the /etc/crontab file for the professionals.
    But because Linux cares about both you and your feelings, they’ve given you your
    own crontab to play with. That one will run commands as your user rather than
    as root, with only the permissions available to you—and won’t be overwritten during
    upgrades.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你肯定不想把/etc/crontab文件留给专业人士。但鉴于Linux关心你的感受，他们给了你自己的crontab来玩。这个crontab将以你的用户身份而不是root身份运行命令，只有你拥有的权限——并且在升级过程中不会被覆盖。
- en: 'Care to see what you’ve already got scheduled? Run `crontab -l`. If you haven’t
    added any commands yet, you’ll probably get the No Crontab for *yourname* message
    shown in the following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 想看看你已经安排了什么？运行`crontab -l`。如果你还没有添加任何命令，你可能会看到以下消息：没有为*yourname*设置Crontab。
- en: '[PRE29]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You can edit your crontab using `crontab -e`. The first time you edit it, you’ll
    be asked to choose a text editor. If you’re already comfortable with Nano, go
    with that, as it’s probably the easiest of the three listed:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`crontab -e`编辑你的crontab。第一次编辑时，你会被要求选择一个文本编辑器。如果你已经熟悉Nano，就选择它，因为它可能是列表中三个中最容易使用的：
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '***1* Checks for existing jobs**'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 检查现有任务**'
- en: '***2* Choose a text editor.**'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 选择一个文本编辑器。**'
- en: '***3* The Nano editor selection**'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* Nano编辑器选择**'
- en: '|  |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: By default, on some systems a user won’t be able to create crontab jobs unless
    a file called /etc/cron.allow containing their username is created. Debian/Ubuntu,
    however, allow individual crontab jobs right out of the box.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，在某些系统上，如果没有创建包含用户名的文件/etc/cron.allow，用户将无法创建crontab任务。然而，Debian/Ubuntu允许直接使用单个crontab任务。
- en: '|  |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Those cron-based tools all work well for computers (like production servers)
    that are likely to be left running all the time. But what about executing important
    jobs on, say, your laptop, which is often turned off? It’s all very nice telling
    cron (or cron.daily and so forth) to back up your files at 5:21 on a Monday morning,
    but how likely is it that you’ll remember to get up to boot your laptop in time?
    Exactly—not likely at all. It’s time to talk about anacron.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 所有基于cron的工具对于可能一直运行的计算机（如生产服务器）都工作得很好。但如果你想在经常关闭的笔记本电脑上执行重要任务怎么办？告诉cron（或cron.daily等）在周一早上5:21备份你的文件听起来很好，但你有多可能记得及时开机？正好——几乎不可能。是时候谈谈anacron了。
- en: 5.4\. Scheduling irregular backups with anacron
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4\. 使用anacron安排不规则的备份
- en: The one cron file we haven’t yet discussed is *anacrontab*, which is where you
    schedule operations to run at a set time after each system boot. If you wanted
    to back up those files on your laptop but couldn’t guarantee that it would be
    powered on at any given time during the day, you could add a line to anacrontab.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有讨论的一个cron文件是*anacrontab*，这是你安排在每次系统启动后固定时间运行操作的地方。如果你想在笔记本电脑上备份这些文件，但又不能保证在一天中的任何给定时间都能开机，你可以在anacrontab中添加一行。
- en: 'What should catch your attention in the anacrontab file is that entries have
    only two columns to control timing, rather than the five used in `cron` commands.
    That’s because anacron doesn’t work on absolute time, but relative to the most
    recent system boot. Here’s the file in all its glory:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在anacrontab文件中，你应该注意到的就是条目只有两列用于控制时间，而不是`cron`命令中使用的五列。这是因为anacron不是基于绝对时间工作，而是相对于最近的系统启动。以下是文件的全部内容：
- en: '[PRE31]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '***1* The directories within anacrontab’s PATH. Files in these locations can
    be referenced without a full directory tree.**'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* anacrontab的PATH中的目录。这些位置中的文件可以在不引用完整目录树的情况下进行引用。**'
- en: '***2* This job executes any scripts in the /etc/cron.daily/ directory once
    a day.**'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 此任务每天执行一次/etc/cron.daily/目录中的任何脚本。**'
- en: The `cron.daily` line in the anacrontab file, for instance, runs at one-day
    intervals, exactly 5 minutes after boot, whenever that happens to take place.
    The `cron.weekly` command, on the other hand, runs on seven-day intervals (meaning,
    when at least seven days have lapsed since the last run), 10 minutes after boot.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，anacrontab文件中的`cron.daily`行在启动后每隔一天运行，正好在启动后5分钟，无论何时发生。另一方面，`cron.weekly`命令在每隔七天（即自上次运行以来至少过去了七天）后运行，启动后10分钟。
- en: 'You might also be curious about those `cron.?` commands; weren’t they already
    run through the /etc/crontab file? Yes, but only if anacron isn’t active on the
    system. As you can see from the crontab file, anacron is given priority over cron.
    With all that in mind, here’s how a backup script could be run for your laptop:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也对那些`cron.?`命令感到好奇；它们不是已经通过`/etc/crontab`文件运行了吗？是的，但前提是系统上anacron没有激活。正如你从crontab文件中看到的，anacron被赋予了比cron更高的优先级。考虑到所有这些，下面是如何为你的笔记本电脑运行备份脚本的方法：
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This command runs the backup.sh script no more than once a day, 10 minutes after
    system boot. The job identifier is `myBackupJob`, and a log file of that name
    with job status information will be saved to the /var/spool/anacron/ directory.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令每天在系统启动后10分钟内最多运行一次`backup.sh`脚本。作业标识符是`myBackupJob`，一个包含作业状态信息的同名日志文件将被保存到`/var/spool/anacron/`目录中。
- en: 5.4.1\. Running the S3 sync job
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.1. 运行S3同步任务
- en: 'Now, at last, with everything you’ve learned about scripting—AWS S3, cron,
    and anacron—you’re finally ready to make a smart choice: what’s the best way to
    schedule your backup? And, as always, the correct answer depends on context.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，最后，你已经学习了关于脚本的所有知识——AWS S3、cron和anacron——你终于准备好做出明智的选择：安排备份的最佳方式是什么？而且，像往常一样，正确答案取决于上下文。
- en: 'If you want to make sure the backup will get done even on a machine that’s
    not always running, you can add a line like this to your anacrontab file (assuming
    that you’ve already got an executable script file of that name in /etc/):'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要确保备份即使在机器不总是运行的情况下也能完成，你可以在anacrontab文件中添加类似这样的行（假设你已经在`/etc/`中有一个同名的可执行脚本文件）：
- en: '[PRE33]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This example runs the script each day (`1`), 10 minutes (`10`) after the system
    boots. For your 24/7 servers, syntax-specific directives could be added to your
    user’s crontab or, within a file, to the /etc/cron.d/ directory (although you’d
    need to add a username like root to the cron.d version).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子每天都会运行脚本（`1`），在系统启动后10分钟（`10`）执行。对于24/7的服务器，你可以将特定于语法的指令添加到用户的crontab中，或者在一个文件中添加到`/etc/cron.d/`目录中（尽管你可能需要将用户名如root添加到cron.d版本中）。
- en: 'The next example runs the script at 5:47 each morning, every day of every month,
    every day of the week (`* * *`):'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个例子每天早上5:47运行脚本，每个月每一天，每周每一天（`* * *`）：
- en: '[PRE34]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '***1* crontab syntax to run a script each day at 5:47 a.m.**'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1. crontab语法每天早上5:47运行脚本**'
- en: 'In this case, because we’re talking about a simple script, you can also do
    that just as effectively by inserting the `aws` command itself into a cron file
    like anacrontab:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，因为我们谈论的是一个简单的脚本，你也可以通过将`aws`命令本身插入到cron文件（如anacrontab）中来同样有效地做到这一点：
- en: '[PRE35]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: A specific command like this backup operation can be inserted directly into
    the crontab file. Note the username and the absolute location of `aws`. This clearly
    establishes both the ownership of the process you want to run and the file system
    location of the binary that will run it.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 可以直接将像这种备份操作的具体命令插入到crontab文件中。注意用户名和`aws`的绝对位置。这清楚地确立了你要运行的过程的所有权和运行它的二进制文件的文件系统位置。
- en: 5.5\. Scheduling regular backups with systemd timers
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5. 使用systemd定时器安排定期备份
- en: If there’s a criticism of the new systemd timer alternative to cron, it’d probably
    be that it’s noticeably more complicated and involves a few more steps to set
    up. Instead of simply creating your script and then copying the file into the
    right cron directory, you’ll need to create and save two separate files to an
    obscure directory location (that’s not yet standard across all Linux distros)
    and then run two `systemctl` commands.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对新的systemd定时器替代cron有批评，那可能是因为它明显更复杂，需要更多步骤来设置。你不仅需要创建你的脚本，然后将文件复制到正确的cron目录中，你还需要创建并保存两个单独的文件到不为人知的目录位置（这还不是所有Linux发行版的行业标准），然后运行两个`systemctl`命令。
- en: Complicated, perhaps. But definitely not insurmountable. And systemd timers
    come with some significant advantages, including deeper integration with other
    system services (including logs) and the ability to execute commands based on
    changes to system state (for instance, someone connecting a USB device), rather
    than just set times.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 可能复杂，但绝对不是不可逾越的。systemd定时器带来了一些显著的优势，包括与其他系统服务的更深层次集成（包括日志）以及根据系统状态的变化执行命令的能力（例如，有人连接USB设备），而不仅仅是设定时间。
- en: I’ll leave you to explore the specific, in-depth features that interest you
    on your own time. But I’ll walk you through the steps it’ll take to put together
    a simple backup. Your mission? Generate a dynamically named tar archive of the
    Apache-powered website running on your server. For the purposes of this demo,
    you can choose any directories to back up, and you don’t have to configure and
    launch a website for this.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我会留给你时间去探索那些你感兴趣的特定、深入的功能。但我会带你一步步完成一个简单的备份。你的任务？生成一个动态命名的tar归档文件，用于备份你服务器上运行的Apache网站。为了演示目的，你可以选择任何目录进行备份，而且你不需要配置和启动一个网站来完成这个任务。
- en: First off, take a look at the timers you might already have running. Mine are
    displayed in [figure 5.4](#ch05fig04) through the `systemctl list-timers --all`
    command.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，看看你可能已经运行的所有定时器。我的定时器通过`systemctl list-timers --all`命令显示在[图5.4](#ch05fig04)中。
- en: Figure 5.4\. The command `systemctl list-timers --all` provides a rich range
    of historical data for all existing systemd timer jobs.
  id: totrans-186
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.4\. `systemctl list-timers --all`命令为所有现有的systemd定时器作业提供了丰富的历史数据。
- en: '![](Images/05fig04_alt.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig04_alt.jpg)'
- en: 'Those timers were all created automatically by the system. To create your own,
    start with a backup script. Digging deeply into my colorful and creative inner
    personality, I’ll call my script file site-backup.sh. Here’s how it looks:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这些定时器都是系统自动创建的。要创建你自己的，从一个备份脚本开始。深入挖掘我丰富多彩、富有创意的内心世界，我会把我的脚本文件命名为site-backup.sh。下面是这个脚本的样子：
- en: '[PRE36]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '***1* Assigns the system date to an environment variable $NOW**'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将系统日期分配给环境变量$NOW**'
- en: 'It would make identifying archives a lot easier if my archive filenames always
    included the date they were created. To do that, I assigned the current system
    date as the value of the `$NOW` variable and included it in the filename of the
    new archive. Here’s how the resulting filename might look:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我的归档文件名总是包含创建日期，那么识别归档文件会容易得多。为了做到这一点，我将当前系统日期分配给`$NOW`变量的值，并将其包含在新归档的文件名中。下面是结果文件名可能的样子：
- en: '[PRE37]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Don’t forget to make your script file executable (`chmod +x site-backup-11_28_2017.tar.gz`).
    In fact, never forget to make your script file executable!
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记使你的脚本文件可执行（`chmod +x site-backup-11_28_2017.tar.gz`）。实际上，永远不要忘记使你的脚本文件可执行！
- en: '[PRE38]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now you’ll need to create your .service and .timer files. As I wrote previously,
    there’s no single location where all service files are kept, but /lib/systemd/system/
    and /etc/systemd/system/ will both work. Given a choice, I prefer /etc/systemd/
    system/ because, for me, it’s an easy-to-remember and logical place. Your mileage
    may vary.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你需要创建你的.service和.timer文件。正如我之前所写的，没有单一的位置来保存所有的服务文件，但/lib/systemd/system/和/etc/systemd/system/都可以工作。如果可以选择，我更喜欢/etc/systemd/system/，因为对我来说，这是一个容易记住且逻辑上合理的地方。你的体验可能会有所不同。
- en: 'I’ll begin with the .service file, which I’ll call site-backup.service. *Service
    files* are common across systemd operations. They’re meant to describe and define
    a system service in a uniform, predictable way. The `Description` value should
    contain whatever text you feel will accurately describe the service, and the `ExecStart`
    line points to the location of an executable resource: the script, in this case.
    This is all the information systemd needs to figure out what it is you want done:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从.service文件开始，我将称之为site-backup.service。*服务文件*在systemd操作中是通用的。它们旨在以统一、可预测的方式描述和定义系统服务。`Description`值应包含你认为可以准确描述服务的任何文本，而`ExecStart`行指向可执行资源的位置：在这个例子中是脚本。这是systemd需要了解你想要做什么的所有信息：
- en: '[PRE39]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '***1* The executable resource to be run by the service**'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 服务要运行的可执行资源**'
- en: 'The .timer file, which is specific to systemd timers, tells systemd when you
    want the associated service to run. The association is set through the `Unit`
    line in the `[Timer]` section, which, in this case, points to my site-backup.service
    file. Note that, also in this case, the value of `OnCalendar` is set to execute
    every day (`*-*-*`) at 5:51 a.m., and the value of `Unit` is the site-backup.service
    file:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: .timer文件，这是systemd定时器特有的，告诉systemd何时运行关联的服务。关联是通过`[Timer]`部分的`Unit`行设置的，在这个例子中，它指向我的site-backup.service文件。请注意，在这个例子中，`OnCalendar`的值被设置为每天早上5:51执行（`*-*-*`），而`Unit`的值是site-backup.service文件：
- en: '[PRE40]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '***1* The schedule settings to control the service execution**'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 控制服务执行的计划设置**'
- en: '***2* The service unit with which to associate this timer**'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 与此定时器关联的服务单元**'
- en: 'With those files in place, you start the service using `systemctl start`. Additionally,
    you set it to load automatically every time the system boots with `systemctl enable`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 有这些文件在位，您可以使用 `systemctl start` 启动服务。此外，您可以使用 `systemctl enable` 将其设置为每次系统启动时自动加载：
- en: '[PRE41]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Curious about the status of your service? `is-enabled` and `is-active` should
    be good for starters:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 对您服务的状态感到好奇？`is-enabled` 和 `is-active` 应该是一个好的开始：
- en: '[PRE42]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Finally, when you edit your .timer file, you’ll need to update the system.
    In the process of practicing what you’ve learned in this chapter, you’ll probably
    be doing a lot of editing. Naturally, you’ll want to know how to do that. Well,
    here you go:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当您编辑您的 .timer 文件时，您需要更新系统。在练习本章所学内容的过程中，您可能需要进行大量的编辑。当然，您会想知道如何做到这一点。好吧，这里就是：
- en: '[PRE43]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Summary
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Well-written Bash scripts can efficiently and reliably automate both complex
    and simple administrative tasks.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写良好的 Bash 脚本可以高效且可靠地自动化复杂和简单的管理任务。
- en: Linux keeps user account and authentication information in plain text files
    (named passwd, group, shadow, and gshadow) in the /etc/ directory.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux 在 /etc 目录中用纯文本文件（名为 passwd、group、shadow 和 gshadow）存储用户账户和认证信息。
- en: You can back up local data to a S3 bucket and manage it through its life cycle
    directly from the command line.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以将本地数据备份到 S3 存储桶，并通过命令行直接管理其生命周期。
- en: Copying an executable script to one of the /etc/cron.? directories causes it
    to be run at the appropriate interval.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将可执行脚本复制到 /etc/cron.? 中的一个目录会导致它以适当的间隔运行。
- en: Adding a directive to the anacrontab file executes commands relative to system
    boots, rather than at absolute times.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 anacrontab 文件中添加指令将执行与系统启动相关的命令，而不是在绝对时间。
- en: systemd timers can be set to run based on both absolute time and in reaction
    to system events, like changes to hardware states.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: systemd 计时器可以根据绝对时间和系统事件（如硬件状态的变化）来设置运行。
- en: Key terms
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关键术语
- en: 'All Linux commands output *exit codes* upon completion: 0 represents a successful
    execution, but all positive integers can be set by a program to represent various
    failed states.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有 Linux 命令在完成时都会输出 *退出代码*：0 表示成功执行，但所有正整数都可以由程序设置来表示各种失败状态。
- en: Command-line access to AWS resources is secured by the use of *access keys*
    (Access Key ID and Secret Access Key).
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用 *访问密钥*（访问密钥 ID 和秘密访问密钥）来保护对 AWS 资源的命令行访问。
- en: A *bucket* is an AWS object that works much the same way as a directory on an
    operating system.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*存储桶* 是 AWS 对象，它在操作系统目录中工作方式几乎相同。'
- en: Security best practices
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全最佳实践
- en: Lock down your system accounts (like syslog and, ideally, even root) to prevent
    their being used for remote logins.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将系统账户（如 syslog 和理想情况下甚至 root）锁定，以防止它们被用于远程登录。
- en: Include off-site backups in your security planning, which adds another layer
    of data reliability.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的安全规划中包含异地备份，这为数据可靠性增加了另一层。
- en: Always protect your (AWS) access keys, not to mention passwords and encryption
    key pairs, from public exposure of any kind.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是保护您的（AWS）访问密钥，不用说密码和加密密钥对，免得任何形式的公开暴露。
- en: Command-line review
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命令行审查
- en: '`#!/bin/bash` (the so-called “shebang line”) tells Linux which shell interpreter
    you’re going to be using for a script.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#!/bin/bash`（所谓的“shebang 行”）告诉 Linux 您将使用哪个 shell 解释器来执行脚本。'
- en: '`||` inserts an *or* condition into a script. Think of this as either “the
    command to the left is successul” or “execute the command to the right.”'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`||` 在脚本中插入一个 *或* 条件。想想看，这是“左边的命令成功”或“执行右边的命令”。'
- en: '`&&` - inserts an *and* condition into a script. Think of this as “if the command
    to the left is successful” and “execute the command to the right.”'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`&&` - 在脚本中插入一个 *和* 条件。想想看，这是“如果左边的命令成功”然后“执行右边的命令”。'
- en: '`test -f /etc/filename` tests for the existence of the specified file or directory
    name.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test -f /etc/filename` 检查指定的文件或目录名是否存在。'
- en: '`chmod +x upgrade.sh` makes a script file executable.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chmod +x upgrade.sh` 使脚本文件可执行。'
- en: '`pip3 install --upgrade --user awscli` installs the AWS command-line interface
    using Python’s pip package manager.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pip3 install --upgrade --user awscli` 使用 Python 的 pip 软件包管理器安装 AWS 命令行界面。'
- en: '`aws s3 sync /home/username/dir2backup s3://linux-bucket3040` synchronizes
    the contents of a local directory with the specified S3 bucket.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aws s3 sync /home/username/dir2backup s3://linux-bucket3040` 将本地目录的内容与指定的
    S3 存储桶同步。'
- en: '`21 5 * * 1 root apt update && apt upgrade` (a cron directive) executes two
    `apt` commands at 5:21 each morning.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`21 5 * * 1 root apt update && apt upgrade`（一个 cron 指令）在每天早晨 5:21 执行两个 `apt`
    命令。'
- en: '`NOW=$(date +"%m_%d_%Y")` assigns the current date to a script variable.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NOW=$(date +"%m_%d_%Y")` 将当前日期分配给脚本变量。'
- en: '`systemctl start site-backup.timer` activates a systemd system timer.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`systemctl start site-backup.timer` 激活一个systemd系统定时器。'
- en: Test yourself
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试自己
- en: '**[1](#ch05qa2q0a1)**'
  id: totrans-236
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch05qa2q0a1)**'
- en: ''
  id: totrans-237
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the character used to introduce a comment in a Linux script?
  id: totrans-238
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Linux脚本中用于引入注释的字符是什么？
- en: ''
  id: totrans-239
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '!'
  id: totrans-240
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '!'
- en: //
  id: totrans-241
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: //
- en: '#'
  id: totrans-242
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '#'
- en: ^
  id: totrans-243
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: ^
- en: '**[2](#ch05qa2q0a2)**'
  id: totrans-244
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch05qa2q0a2)**'
- en: ''
  id: totrans-245
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the purpose of `||` in a Linux script?
  id: totrans-246
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Linux脚本中`||`的作用是什么？
- en: ''
  id: totrans-247
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Or
  id: totrans-248
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者
- en: And
  id: totrans-249
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 和
- en: If
  id: totrans-250
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: If
- en: Comment
  id: totrans-251
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: Comment
- en: '**[3](#ch05qa2q0a3)**'
  id: totrans-252
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[3](#ch05qa2q0a3)**'
- en: ''
  id: totrans-253
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the data type kept in the /etc/shadow file?
  id: totrans-254
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: /etc/shadow文件中保存的数据类型是什么？
- en: ''
  id: totrans-255
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Account group and shell data
  id: totrans-256
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 账户组及shell数据
- en: Group membership data
  id: totrans-257
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组成员数据
- en: Encrypted account passwords
  id: totrans-258
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加密账户密码
- en: Encrypted group passwords
  id: totrans-259
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加密组密码
- en: '**[4](#ch05qa2q0a4)**'
  id: totrans-260
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[4](#ch05qa2q0a4)**'
- en: ''
  id: totrans-261
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following will create a new bucket on your AWS S3 account?
  id: totrans-262
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪个操作将在你的AWS S3账户中创建一个新的存储桶？
- en: ''
  id: totrans-263
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`s3 mb s3://mybucket`'
  id: totrans-264
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`s3 mb s3://mybucket`'
- en: '`aws s3 mb s3://mybucket`'
  id: totrans-265
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`aws s3 mb s3://mybucket`'
- en: '`aws s3 cb s3://mybucket`'
  id: totrans-266
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`aws s3 cb s3://mybucket`'
- en: '`aws s3 sync mb s3://mybucket`'
  id: totrans-267
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`aws s3 sync mb s3://mybucket`'
- en: '**[5](#ch05qa2q0a5)**'
  id: totrans-268
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[5](#ch05qa2q0a5)**'
- en: ''
  id: totrans-269
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following commands will allow you to enter a cron directive that
    will be run as your own user?
  id: totrans-270
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 哪个命令可以让你输入一个以你自己的用户身份运行的cron指令？
- en: ''
  id: totrans-271
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`nano anacrontab`'
  id: totrans-272
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`nano anacrontab`'
- en: '`crontab -l`'
  id: totrans-273
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`crontab -l`'
- en: '`nano /etc/crontab`'
  id: totrans-274
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`nano /etc/crontab`'
- en: '`crontab -e`'
  id: totrans-275
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`crontab -e`'
- en: '**[6](#ch05qa2q0a6)**'
  id: totrans-276
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[6](#ch05qa2q0a6)**'
- en: ''
  id: totrans-277
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following will run the command each Monday morning?
  id: totrans-278
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪个将在每周一早上运行命令？
- en: ''
  id: totrans-279
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`21 * 1 * * root apt update && apt upgrade`'
  id: totrans-280
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`21 * 1 * * root apt update && apt upgrade`'
- en: '`21 5 * * 1 root apt update && apt upgrade`'
  id: totrans-281
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`21 5 * * 1 root apt update && apt upgrade`'
- en: '`21 1 * * 0 root apt update && apt upgrade`'
  id: totrans-282
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`21 1 * * 0 root apt update && apt upgrade`'
- en: '`21 5 * 4 * root apt update && apt upgrade`'
  id: totrans-283
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`21 5 * 4 * root apt update && apt upgrade`'
- en: '**[7](#ch05qa2q0a7)**'
  id: totrans-284
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[7](#ch05qa2q0a7)**'
- en: ''
  id: totrans-285
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following won’t work well for computers that aren’t always running?
  id: totrans-286
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪个选项不适用于始终运行的计算器？
- en: ''
  id: totrans-287
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: crontab
  id: totrans-288
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: crontab
- en: anacron
  id: totrans-289
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: anacron
- en: systemd timer
  id: totrans-290
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: systemd timer
- en: anacrontab
  id: totrans-291
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: anacrontab
- en: '**[8](#ch05qa2q0a8)**'
  id: totrans-292
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[8](#ch05qa2q0a8)**'
- en: ''
  id: totrans-293
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the purpose of the `systemctl enable site-backup.timer` command?
  id: totrans-294
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`systemctl enable site-backup.timer`命令的作用是什么？'
- en: ''
  id: totrans-295
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Loads the site-backup timer manually
  id: totrans-296
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 手动加载网站备份定时器
- en: Configures the site-backup timer to load on system boot
  id: totrans-297
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置网站备份定时器在系统启动时加载
- en: Displays the current status of the site-backup timer
  id: totrans-298
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示网站备份定时器的当前状态
- en: Forces the site-backup timer to run before the computer can close down
  id: totrans-299
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 强制网站备份定时器在计算机关闭前运行
- en: Answer key
  id: totrans-300
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 答案键
- en: '**[1.](#ch05qa1q1)**'
  id: totrans-301
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1.](#ch05qa1q1)**'
- en: ''
  id: totrans-302
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: c
  id: totrans-303
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c
- en: '**[2.](#ch05qa1q2)**'
  id: totrans-304
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2.](#ch05qa1q2)**'
- en: ''
  id: totrans-305
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a
  id: totrans-306
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a
- en: '**[3.](#ch05qa1q3)**'
  id: totrans-307
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[3.](#ch05qa1q3)**'
- en: ''
  id: totrans-308
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: c
  id: totrans-309
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c
- en: '**[4.](#ch05qa1q4)**'
  id: totrans-310
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[4.](#ch05qa1q4)**'
- en: ''
  id: totrans-311
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: b
  id: totrans-312
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b
- en: '**[5.](#ch05qa1q5)**'
  id: totrans-313
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[5.](#ch05qa1q5)**'
- en: ''
  id: totrans-314
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: d
  id: totrans-315
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d
- en: '**[6.](#ch05qa1q6)**'
  id: totrans-316
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[6.](#ch05qa1q6)**'
- en: ''
  id: totrans-317
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: b
  id: totrans-318
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b
- en: '**[7.](#ch05qa1q7)**'
  id: totrans-319
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[7.](#ch05qa1q7)**'
- en: ''
  id: totrans-320
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a
  id: totrans-321
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a
- en: '**[8.](#ch05qa1q8)**'
  id: totrans-322
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[8.](#ch05qa1q8)**'
- en: ''
  id: totrans-323
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: b
  id: totrans-324
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b
