- en: 10 Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 微服务
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: The basics of microservices
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务的基础
- en: The backend-for-frontend pattern
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后端-for-前端模式
- en: Using asyncio to handle microservice communication
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 asyncio 处理微服务通信
- en: Using asyncio to handle failures and retries
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 asyncio 处理失败和重试
- en: Many web applications are structured as monoliths. A *monolith* generally refers
    to a medium-to-large-sized application containing multiple modules that are independently
    deployed and managed as one unit. While there is nothing inherently wrong with
    this model (monoliths are perfectly fine, and even preferable, for most web applications,
    as they are generally simpler), it does have its drawbacks.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 许多网络应用程序都是作为单体构建的。一个“单体”通常指一个中等或大型的应用程序，包含多个模块，这些模块作为单个单元独立部署和管理。虽然这种模型本身并没有什么错误（对于大多数网络应用程序来说，单体是完全可以接受的，甚至更受欢迎，因为它们通常更简单），但它确实有其缺点。
- en: As an example, if you make a small change to a monolithic application, you need
    to deploy the entire application, even parts that may be unaffected by your change.
    For instance, a monolithic e-commerce application may have order management and
    product listing endpoints in one application, meaning a tweak to a product endpoint
    would require a redeploy of order management code. A microservice architecture
    can help with such pain points. We could create separate services for orders and
    products, then a change in one service wouldn’t affect the other.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你对一个单体应用程序进行小的修改，你需要部署整个应用程序，即使可能不受你修改影响的部分。例如，一个单体电子商务应用程序可能在一个应用程序中包含订单管理和产品列表端点，这意味着对产品端点的调整将需要重新部署订单管理代码。微服务架构可以帮助解决这些痛点。我们可以为订单和产品创建单独的服务，然后一个服务的更改不会影响另一个服务。
- en: In this chapter, we’ll learn a bit more about microservices and the motivations
    behind them. We’ll learn a pattern called *backend-for-frontend* and apply this
    to an e-commerce microservice architecture. We’ll then implement this API with
    aiohttp and asyncpg, learning how to employ concurrency to help us improve the
    performance of our application. We’ll also learn how to properly deal with failure
    and retries with the circuit breaker pattern to build a more robust application.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更深入地了解微服务和其背后的动机。我们将学习一种称为“后端-for-前端”的模式，并将其应用于电子商务微服务架构。然后我们将使用 aiohttp
    和 asyncpg 实现此 API，学习如何利用并发来提高我们应用程序的性能。我们还将学习如何使用断路器模式正确处理失败和重试，以构建更健壮的应用程序。
- en: 10.1 Why microservices?
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1 为什么需要微服务？
- en: 'First, let’s define what microservices are. This is a rather tricky question,
    as there is no standardized definition, and you’ll probably get different answers
    depending on who you ask. Generally, *microservices* follow a few guiding principles:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义一下什么是微服务。这是一个相当棘手的问题，因为没有标准化的定义，而且你可能会根据你问的人得到不同的答案。一般来说，“微服务”遵循一些指导原则：
- en: They are loosely coupled and independently deployable.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是松散耦合且可独立部署的。
- en: They have their own independent stack, including a data model.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们有自己的独立堆栈，包括数据模型。
- en: They communicate with one another over a protocol such as REST or gRPC.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们通过 REST 或 gRPC 等协议进行通信。
- en: They follow the “single responsibility” principle; that is, a microservice should
    “do one thing and do it well.”
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们遵循“单一职责”原则；也就是说，微服务应该“只做一件事，做好这件事。”
- en: Let’s apply these principles to a concrete example of an e-commerce storefront.
    An application like this has users that provide shipping and payment information
    to our hypothetical organization who then buy our products. In a monolithic architecture,
    we’d have one application with one database to manage user data, account data
    (such as their orders and shipping information), and our available products. In
    a microservice architecture, we would have multiple services, each with their
    own database for separate concerns. We might have a product API with its own database,
    which only handles data around products. We might have a user API with its own
    database, which handles user account information, and so on.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这些原则应用到电子商务店面这个具体的例子中。这样的应用程序有用户向我们的假设组织提供运输和支付信息，然后购买我们的产品。在单体架构中，我们会有一个应用程序和一个数据库来管理用户数据、账户数据（如他们的订单和运输信息）以及我们的可用产品。在微服务架构中，我们将有多个服务，每个服务都有自己的数据库来处理不同的关注点。我们可能有一个产品
    API 和其自己的数据库，它只处理与产品相关的数据。我们可能有一个用户 API 和其自己的数据库，它处理用户账户信息，等等。
- en: Why would we choose this architectural style over monoliths? Monoliths are perfectly
    fine for most applications; they are simpler to manage. Make a code change, and
    run all the test suites to make sure your seemingly small change does not affect
    other areas of the system. Once you’ve run tests, you deploy the application as
    one unit. Is your application not performing well under load? In this case you
    can scale horizontally or vertically, either deploying more instances of your
    application or deploying to more powerful machines to handle the additional users.
    While managing a monolith is operationally simpler, this simplicity has drawbacks
    that may matter a lot, depending on which tradeoffs you want to make.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么选择这种架构风格而不是单体架构？对于大多数应用来说，单体架构是完全可以接受的；它们更容易管理。进行代码更改，并运行所有测试套件以确保看似微小的更改不会影响系统的其他区域。一旦运行了测试，你就可以作为一个单元部署应用程序。如果你的应用程序在负载下表现不佳？在这种情况下，你可以水平或垂直扩展，要么部署更多应用程序实例，要么部署到更强大的机器上以处理额外的用户。虽然管理单体架构在操作上更简单，但这种简单性有其缺点，这些缺点可能非常重要，具体取决于你想要做出哪些权衡。
- en: 10.1.1 Complexity of code
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.1 代码的复杂性
- en: As the application grows and acquires new features its complexity grows. Data
    models may become more coupled, causing unforeseen and hard-to-understand dependencies.
    Technical debt gets larger and larger, making development slower and more complicated.
    While this is true of any growing system, a large codebase with multiple concerns
    can exacerbate this.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用的扩展和新增功能，其复杂性也在增长。数据模型可能会变得更加耦合，导致不可预见且难以理解的依赖关系。技术债务越来越大，使得开发速度变慢且更加复杂。虽然这对于任何增长中的系统都是真实的，但一个具有多个关注点的庞大代码库可能会加剧这种情况。
- en: 10.1.2 Scalability
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.2 可扩展性
- en: In a monolithic architecture, if you need to scale you need to add more instances
    of your *entire* application, which can lead to technology cost inefficiencies.
    In the context of an e-commerce application, you will typically get much fewer
    orders than people just browsing products. In a monolithic architecture, to scale
    up to handle more people viewing your products, you’ll need to scale up your order
    capabilities as well. In a microservice architecture, you can just scale the product
    service and leave the order service untouched if it has no issues.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在单体架构中，如果你需要扩展，你需要添加你**整个**应用的更多实例，这可能导致技术成本效率低下。在电子商务应用的背景下，你通常会收到比仅仅浏览产品的用户少得多的订单。在单体架构中，为了扩展以处理更多查看产品的用户，你还需要扩展你的订单处理能力。在微服务架构中，你只需扩展产品服务，如果订单服务没有问题，则无需对其进行扩展。
- en: 10.1.3 Team and stack independence
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.3 团队和堆栈独立性
- en: As a development team grows, new challenges emerge. Imagine you have five teams
    working on the same monolithic codebase with each team committing code several
    times per day. Merge conflicts will become an increasing issue that everyone needs
    to handle, as will coordinating deploys across teams. With independent, loosely
    coupled microservices, this becomes less of an issue. If a team owns a service,
    they can work on it and deploy it mostly independently. This also allows for teams
    to use different tech stacks if desired, one service can be in Java and one in
    Python.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 随着开发团队的壮大，新的挑战也随之出现。想象一下，你有五个团队在同一个单体代码库上工作，每个团队每天提交代码几次。合并冲突将成为一个日益严重的问题，每个人都需要处理，跨团队协调部署也是如此。使用独立且松耦合的微服务，这个问题就会小得多。如果一个团队拥有一个服务，他们可以独立地工作并部署它。这也允许团队在需要时使用不同的技术堆栈，一个服务可以是Java，另一个是Python。
- en: 10.1.4 How can asyncio help?
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.4 asyncio 如何帮助？
- en: Microservices generally need to communicate with one another over a protocol
    such as REST or gRPC. Since we may be talking to multiple microservices at the
    same time, this opens up the possibility to run requests concurrently, creating
    an efficiency that we otherwise wouldn’t have in a synchronous application.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务通常需要通过REST或gRPC等协议相互通信。由于我们可能同时与多个微服务进行通信，这打开了并发运行请求的可能性，从而创建了一种在同步应用中不会拥有的效率。
- en: In addition to the resource efficiency benefits we get from an async stack,
    we also get the error-handling benefits of the asyncio APIs, such as `wait` and
    `gather`, which allow us to aggregate exceptions from a group of coroutines or
    tasks. If a particular group of requests takes too long or a portion of that group
    has an exception, we can handle them gracefully. Now that we understand the basic
    motivations behind microservices, let’s learn one common microservice architecture
    pattern and see how to implement it.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 除了从异步堆栈中获得的资源效率优势之外，我们还获得了asyncio API的错误处理优势，例如`wait`和`gather`，这些API允许我们从一组协程或任务中聚合异常。如果某个特定组请求耗时过长或该组的一部分出现异常，我们可以优雅地处理它们。现在我们已经了解了微服务背后的基本动机，让我们学习一种常见的微服务架构模式，并看看如何实现它。
- en: 10.2 Introducing the backend-for-frontend pattern
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2 介绍后端-for-前端模式
- en: When we’re building UIs in a microservice architecture, we’ll typically need
    to get data from multiple services to create a particular UI view. For example,
    if we’re building a user order history UI, we’ll probably have to get the user’s
    order history from an order service and merge that with product data from a product
    service. Depending on requirements, we may need data from other services as well.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在微服务架构中构建UI时，我们通常需要从多个服务中获取数据以创建特定的UI视图。例如，如果我们正在构建用户订单历史UI，我们可能需要从订单服务获取用户的订单历史，并将其与产品服务的产品数据合并。根据需求，我们可能还需要从其他服务获取数据。
- en: This poses a few challenges for our frontend clients. The first is a user experience
    issue. With standalone services, our UI clients will have to make one call to
    each service over the internet. This poses issues with latency and time to load
    the UI. We can’t assume all our users will have a good internet connection or
    fast computer; some may be on a mobile phone in a poor reception area, some may
    be on older computers, and some may be in developing countries without access
    to high-speed internet at all. If we make five slow requests to five services,
    there is the potential to cause more issues than making one slow request.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们的前端客户端带来了一些挑战。首先是用户体验问题。在独立服务中，我们的UI客户端将不得不通过互联网对每个服务进行一次调用。这会带来延迟和UI加载时间的问题。我们不能假设所有用户都有良好的互联网连接或快速的计算机；有些人可能在使用信号差的手机，有些人可能在使用较旧的计算机，还有些可能处于无法访问高速互联网的发展中国家。如果我们向五个服务发出五个缓慢的请求，可能会引起比发出一个缓慢请求更多的问题。
- en: In addition to network latency challenges, we also have challenges related to
    good software design principles. Imagine we have both web-based UIs as well as
    iOS and Android mobile UIs. If we directly call each service and merge the resulting
    responses, we need to replicate the logic to do so across three different clients,
    which is redundant and puts us at risk of having inconsistent logic across clients.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 除了网络延迟的挑战之外，我们还有与良好的软件设计原则相关的挑战。想象一下，我们既有基于网络的UI，也有iOS和Android移动UI。如果我们直接调用每个服务并合并结果响应，我们需要在三个不同的客户端中复制执行此操作的逻辑，这既冗余又使我们面临客户端之间逻辑不一致的风险。
- en: '![10-01](Images/10-01.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![10-01](Images/10-01.png)'
- en: Figure 10.1 The backend-for-frontend pattern
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 后端-for-前端模式
- en: While there are many microservice design patterns, one that can help us address
    the above issues is the *backend-for-frontend pattern*. In this design pattern,
    instead of our UIs directly communicating with our services, we create a new service
    that makes these calls and aggregates the responses. This addresses our issues,
    and instead of making multiple requests we can just make one, cutting down on
    our round trips across the internet. We can also embed any logic related to failovers
    or retries inside of this service, saving our clients the work of having to repeat
    the same logic and introducing one place for us to update the logic when we need
    to change it. This also enables multiple backend-for-frontend services for different
    types of clients. The services we need to communicate with may need to vary depending
    on if we’re a mobile client versus a web-based UI. This is illustrated in figure
    10.1\. Now that we understand the backend-for-frontend design pattern and the
    problems it addresses, let’s apply it to build a backend-for-frontend service
    for an e-commerce storefront.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有许多微服务设计模式，但其中一种可以帮助我们解决上述问题的是后端前端模式。在这个设计模式中，我们的UI不是直接与我们的服务通信，而是创建一个新的服务来执行这些调用并聚合响应。这解决了我们的问题，我们不再需要多次请求，而只需一次，从而减少了互联网上的往返次数。我们还可以在这个服务中嵌入任何与故障转移或重试相关的逻辑，从而节省我们的客户端重复相同逻辑的工作，并在我们需要更改逻辑时为我们提供一个更新逻辑的地方。这还使我们能够为不同类型的客户端提供多个后端前端服务。我们需要与之通信的服务可能需要根据我们是一个移动客户端还是基于Web的UI而有所不同。图10.1展示了这一点。现在我们理解了后端前端设计模式及其解决的问题，让我们将其应用于构建一个电子商务店面后端前端服务。
- en: 10.3 Implementing the product listing API
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3 实现产品列表API
- en: Let’s implement the backend-for-frontend pattern for an *all products* page
    of our e-commerce storefront’s desktop experience. This page displays all products
    available on our site, along with basic information about our user’s cart and
    favorited items in a menu bar. To increase sales, the page has a low inventory
    warning when only a few items are left available. This page also has a navigation
    bar up on top with information about our user’s favorite products as well as what
    data is in their cart. Figure 10.2 illustrates our UI.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现后端前端模式，为我们的电子商务店面桌面体验的“所有产品”页面。此页面显示我们网站上所有可用的产品，以及用户购物车和菜单栏中收藏项目的基本信息。为了增加销售额，当只有少量商品可用时，页面会有低库存警告。此页面顶部还有一个导航栏，包含有关用户收藏产品和购物车中数据的详细信息。图10.2展示了我们的UI。
- en: '![10-02](Images/10-02.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![10-02](Images/10-02.png)'
- en: Figure 10.2 A mockup of the products listing page
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 产品列表页面的原型
- en: Given a microservice architecture with several independent services, we’ll need
    to request the appropriate data from each service and stitch them together to
    form a cohesive response. Let’s first start by defining the base services and
    data models we’ll need.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个包含多个独立服务的微服务架构中，我们需要从每个服务中请求适当的数据并将它们拼接起来以形成一个连贯的响应。让我们首先定义我们将需要的基服务和数据模型。
- en: 10.3.1 User favorite service
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.1 用户收藏服务
- en: This service keeps track of a mapping from a user to the product IDs they have
    put in their favorites list. Next, we’ll need to implement these services to support
    our backend-for-frontend product, inventory, user cart, and user favorites.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务跟踪用户到他们放入收藏夹的产品ID的映射。接下来，我们需要实现这些服务以支持我们的后端前端产品、库存、用户购物车和用户收藏。
- en: User cart service
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 用户购物车服务
- en: This contains a mapping from user ID to product IDs they have put in the cart;
    the data model is the same as the user favorite service.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这包含用户ID到他们放入购物车的产品ID的映射；数据模型与用户收藏服务相同。
- en: Inventory service
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 库存服务
- en: This contains a mapping from a product ID to the available inventory for that
    product.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这包含了一个从产品ID到该产品可用库存的映射。
- en: Product service
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 产品服务
- en: This contains product information, such as descriptions and SKUs. This is similar
    to the service we implemented in chapter 9 around our products database.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这包含产品信息，如描述和SKU。这与我们在第9章围绕我们的产品数据库实现的服务类似。
- en: 10.3.2 Implementing the base services
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.2 实现基服务
- en: Let’s start by implementing an aiohttp application for our inventory service,
    as we’ll make this our simplest service. For this service we won’t create a separate
    data model; instead, we’ll just return a random number from 0 to 100 to simulate
    available inventory. We’ll also add a random delay to simulate our service being
    intermittently slow, and we’ll use this to demonstrate how to handle timeouts
    in our product list service. We’ll host this service on port 8001 for development
    purposes, so it does not interfere with our product service from chapter 9, which
    runs on port 8000.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从实现我们的库存服务的aiohttp应用程序开始，因为这将是我们最简单的服务。对于此服务，我们不会创建单独的数据模型；相反，我们只需返回0到100之间的随机数来模拟可用库存。我们还将添加随机延迟来模拟我们的服务间歇性缓慢，我们将使用此来演示如何在我们的产品列表服务中处理超时。出于开发目的，我们将此服务托管在端口8001上，以免干扰在第9章中运行的我们的产品服务，该服务在端口8000上运行。
- en: Listing 10.1 The inventory service
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.1 库存服务
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Next, let’s implement the user cart and user favorite service. The data model
    for these two is identical, so the services will be almost the same, with the
    difference being table names. Let’s start with the two data models, “user cart”
    and “user favorite.” We’ll also insert a few records in these tables, so we have
    some data to start with. First, we’ll start with the user cart table.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们实现用户购物车和用户收藏服务。这两个服务的数据库模型是相同的，因此服务几乎相同，区别在于表名。让我们从这两个数据模型开始，即“用户购物车”和“用户收藏”。我们还将在这两个表中插入一些记录，以便我们有一些数据可以开始。首先，我们将从用户购物车表开始。
- en: Listing 10.2 User cart table
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.2 用户购物车表
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Next, we’ll create the user favorite table and insert a few values; this will
    look very similar to the previous table.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建用户收藏表并插入一些值；这将与之前的表非常相似。
- en: Listing 10.3 User favorite table
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.3 用户收藏表
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To simulate multiple databases, we’ll want to create these tables each in their
    own Postgres database. Recall from chapter 5 that we can run arbitrary SQL with
    the psql command-line utility, meaning that we can create two databases for user
    favorites and user cart with the following two commands:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟多个数据库，我们希望在每个Postgres数据库中创建这些表。回想一下第5章，我们可以使用psql命令行工具运行任意SQL，这意味着我们可以使用以下两个命令为用户收藏和用户购物车创建两个数据库：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Since we’ll now need to set up and tear down connections to multiple different
    databases, let’s create some reusable code across our services to create asyncpg
    connection pools. We’ll reuse this in our aiohttp `on_startup` and `on_cleanup`
    hooks.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在需要设置和断开与多个不同数据库的连接，让我们在服务之间创建一些可重用的代码来创建asyncpg连接池。我们将在aiohttp的`on_startup`和`on_cleanup`钩子中重用它。
- en: Listing 10.4 Creating and tearing down database pools
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.4 创建和销毁数据库池
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding listing should look similar to code we wrote in chapter 5 to set
    up database connections. In `create_database_pool`, we create a connection pool
    and then put it in our `Application` instance. In `destroy_database_pool`, we
    grab the connection pool from the application instance and close it.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 上述列表应类似于我们在第5章中编写的用于设置数据库连接的代码。在`create_database_pool`中，我们创建一个连接池并将其放入我们的`Application`实例中。在`destroy_database_pool`中，我们从应用程序实例中获取连接池并将其关闭。
- en: 'Next, let’s create the services. In REST terms, both favorites and cart are
    a subentity of a particular user. This means that each endpoint’s root will be
    users and will accept a user ID as an input. For example, `/users/3/favorites`
    will fetch the favorite products for user `id` `3`. First, we’ll create the user
    favorite service:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建服务。在REST术语中，收藏和购物车都是特定用户的子实体。这意味着每个端点的根将是用户，并将接受一个用户ID作为输入。例如，`/users/3/favorites`将获取用户`id`为`3`的收藏产品。首先，我们将创建用户收藏服务：
- en: Listing 10.5 The user favorite service
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.5 用户收藏服务
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Next, we’ll create the user cart service. This code will look mostly similar
    to our previous service with the main difference being we’ll interact with the
    `user_cart` table.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建用户购物车服务。此代码将主要与我们的前一个服务相似，主要区别在于我们将与`user_cart`表交互。
- en: Listing 10.6 The user cart service
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.6 用户购物车服务
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Finally, we’ll implement the product service. This will be similar to the API
    we built in chapter 9 with the difference being that we’ll fetch all products
    from our database instead of just one. With the following listing, we’ve created
    four services to power our theoretical e-commerce storefront!
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将实现产品服务。这将与我们在第9章中构建的API类似，不同之处在于我们将从数据库中获取所有产品而不是一个。通过以下列表，我们创建了四个服务来为我们的理论电子商务店面提供动力！
- en: Listing 10.7 The product service
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.7 产品服务
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 10.3.3 Implementing the backend-for-frontend service
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.3 实现后端前端服务
- en: 'Next, let’s build the backend-for-frontend service. We’ll first start with
    a few requirements for our API based on the needs of our UI. Product load times
    are crucial for our application, as the longer our users must wait, the less likely
    they are to continue browsing our site and the less likely they are to buy our
    products. This makes our requirements center around delivering the minimum viable
    data to the user as quickly as possible:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们构建后端前端服务。我们首先从基于UI需求的一些API要求开始。产品加载时间对我们应用程序至关重要，因为我们的用户等待时间越长，他们继续浏览我们网站的可能性就越小，他们购买我们产品的可能性也就越小。这使得我们的要求集中在尽可能快地向用户提供最小可行数据：
- en: The API should never wait for the product service more than 1 second. If it
    takes longer than 1 second, we should respond with a timeout error (HTTP code
    504), so the UI does not hang indefinitely.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API不应该等待产品服务超过1秒。如果超过1秒，我们应该响应超时错误（HTTP代码504），这样UI就不会无限期地挂起。
- en: The user cart and favorites data is optional. If we can get it in within 1 second,
    that’s great! If not, we should just return what product data we have.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户购物车和收藏夹数据是可选的。如果我们能在1秒内获取到，那就太好了！如果不行，我们只需返回我们拥有的产品数据。
- en: The inventory data for products is optional as well. If we can’t get it, just
    return the product data.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品库存数据也是可选的。如果我们无法获取它，只需返回产品数据。
- en: With these requirements, we’ve given ourselves a few ways to short-circuit around
    slow services or services that have crashed or have other network issues. This
    makes our service, and therefore the user interfaces that consume it, more resilient.
    While it may not always have all the data to provide a complete user experience,
    it has enough to create a usable experience. Even if the result is a catastrophic
    failure of the product service, we won’t leave the user hanging indefinitely with
    a busy spinner or some other poor user experience.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些要求的基础上，我们为自己提供了一些绕过缓慢服务或已崩溃服务或存在其他网络问题的方法。这使得我们的服务，以及因此使用它的用户界面，更加健壮。虽然它可能不会总是提供所有数据以提供完整的用户体验，但它有足够的数据来创建一个可用的体验。即使结果是产品服务的灾难性故障，我们也不会让用户无限期地挂起，使用忙碌的旋转器或其他糟糕的用户体验。
- en: 'Next, let’s define what we want our response to look like. All we need for
    the navigation bar is the number of items in our cart and in our favorites list,
    so we’ll have our response just represent these as scalar values. Since our cart
    or favorite service could time out or could have an error, we’ll allow this value
    to be `null`. For our product data, we’ll just want our normal product data augmented
    with the inventory value, so we’ll add this data in a products array. This means
    we’ll have a response similar to the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们定义我们希望我们的响应看起来像什么。导航栏只需要我们购物车和收藏夹中的项目数量，因此我们的响应将只表示这些为标量值。由于我们的购物车或收藏夹服务可能会超时或出现错误，我们将允许此值为`null`。对于我们的产品数据，我们只想在我们的正常产品数据中添加库存值，因此我们将添加此数据到产品数组中。这意味着我们的响应将类似于以下内容：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this case, the user has one item in their cart. They may have favorite items,
    but the result is `null` because there was an issue reaching the favorite service.
    Finally, we have two products to display with 4 and 65 items in stock respectively.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，用户购物车中有一件商品。他们可能有收藏的商品，但结果为`null`，因为无法访问收藏夹服务。最后，我们有两种产品要显示，库存分别为4件和65件。
- en: So how should we begin implementing this functionality? We’ll need to communicate
    with our REST services over HTTP, so aiohttp’s web client functionality is a natural
    choice for this, as we’re already using the framework’s web server. Next, what
    requests do we make, and how do we group them and manage timeouts? First, we should
    think about the most requests we can run concurrently. The more we can run concurrently,
    the faster we can theoretically return a response to our clients. In our case,
    we can’t ask for inventory before we have product IDs, so we can’t run that concurrently,
    but our products, cart, and favorite services are not dependent on one another.
    This means we can run them concurrently with an asyncio API such as `wait`. Using
    `wait` with a timeout will give us a `done` set where we can check which requests
    finished with error and which are still running after the timeout, giving us a
    chance to handle any failures. Then, once we have product IDs and potentially
    user favorite and cart data, we can begin to stitch together our final response
    and send that back to the client.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们应该如何开始实现这个功能呢？我们需要通过 HTTP 与我们的 REST 服务进行通信，因此 aiohttp 的网络客户端功能是这一点的自然选择，因为我们已经在使用框架的网络服务器。接下来，我们发送哪些请求，如何对它们进行分组和管理超时？首先，我们应该考虑我们可以并发运行的最大请求数。我们可以并发运行的请求数越多，理论上我们返回客户端响应的速度就越快。在我们的情况下，在我们获得产品
    ID 之前，我们不能请求库存，因此我们不能并发运行，但我们的产品、购物车和收藏服务之间没有相互依赖。这意味着我们可以使用 `wait` 这样的 asyncio
    API 并发运行它们。使用 `wait` 并设置超时将给我们一个 `done` 集合，我们可以检查哪些请求因错误而完成，哪些在超时后仍在运行，这给了我们处理任何失败的机会。然后，一旦我们有了产品
    ID 以及可能的用户收藏和购物车数据，我们就可以开始拼接我们的最终响应并将其发送回客户端。
- en: We’ll create an endpoint `/products/all` to do this that will return this data.
    Normally, we’d want to accept the currently logged-in user’s ID somewhere in the
    URL, the request headers, or a cookie, so we can use that when making requests
    to our downstream services. In this example, for simplicity’s sake, we’ll just
    hardcode this ID to the user for whom we’ve already inserted data into our database.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个 `/products/all` 端点来完成此操作，该端点将返回这些数据。通常，我们希望在 URL、请求头或 cookie 中接受当前登录用户的
    ID，以便我们可以在向我们的下游服务发出请求时使用它。在这个例子中，为了简单起见，我们将把这个 ID 硬编码到我们已经将数据插入我们数据库的用户身上。
- en: Listing 10.8 The product backend-for-frontend
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.8 产品后端-前端
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Create tasks to query the three services we have and run them concurrently.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建任务以并发查询我们拥有的三个服务。
- en: ❷ If the products request times out, return an error, as we can’t proceed.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果产品请求超时，则返回错误，因为我们无法继续。
- en: ❸ Extract data from the product response, and use it to get inventory data.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 从产品响应中提取数据，并使用它来获取库存数据。
- en: ❹ Given a product response, make requests for inventory.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 给定一个产品响应，请求库存。
- en: ❺ Convenience method to get the number of items in a JSON array response
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 获取 JSON 数组响应中项目数量的便捷方法
- en: In the preceding listing, we first define a route handler named `all_products`.
    In `all_products`, we send requests to our products, cart, and favorite services
    concurrently, giving these requests 1 second to complete with `wait`. Once either
    all of them finish, or we have waited for 1 second, we begin to process the results.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的列表中，我们首先定义了一个名为 `all_products` 的路由处理程序。在 `all_products` 中，我们并发地向我们的产品、购物车和收藏服务发送请求，并使用
    `wait` 给这些请求 1 秒的时间来完成。一旦它们全部完成，或者我们等待了 1 秒，我们就开始处理结果。
- en: Since the product response is critical, we check its status first. If it is
    still pending or has an exception, we cancel any pending requests and return an
    error to the client. If there was an exception, we respond with a HTTP 500 error,
    indicating a server issue. If there was a timeout, we respond with a 504 error,
    indicating we couldn’t reach the service. This specificity gives our clients a
    hint as to whether they should try again and also gives us more information useful
    for any monitoring and altering we may have (we can have alerts specifically to
    watch 504 response rates, for example).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于产品响应至关重要，我们首先检查其状态。如果它仍然处于挂起状态或出现异常，我们将取消任何挂起的请求并向客户端返回错误。如果出现异常，我们将以 HTTP
    500 错误响应，表示服务器问题。如果出现超时，我们将以 504 错误响应，表示我们无法访问服务。这种具体性为我们提供了关于他们是否应该再次尝试的线索，同时也为我们提供了更多有用的信息，这些信息可用于任何监控和调整（例如，我们可以设置专门用于监控
    504 响应率的警报）。
- en: If we have a successful response from the product service, we can now start
    to process it and ask for inventory numbers. We do this work in a helper function
    called `get_products_with_inventory`. In this helper function, we pull product
    IDs from the response body and use these to construct requests to the inventory
    service. Since our inventory service only accepts one product ID at a time (ideally,
    you would be able to batch these into a single request, but we’ll pretend the
    team that manages the inventory service has issues with this approach), we’ll
    create a list of tasks to request inventory per each product. We’ll again pass
    these into the `wait` coroutine, giving them all 1 second to complete.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从产品服务中获得成功的响应，我们现在可以开始处理它并请求库存编号。我们在一个名为 `get_products_with_inventory` 的辅助函数中做这项工作。在这个辅助函数中，我们从响应体中提取产品ID，并使用这些ID向库存服务构造请求。由于我们的库存服务一次只接受一个产品ID（理想情况下，你可能会将这些批量到一个请求中，但我们将假设管理库存服务的团队在这个方法上存在问题），我们将为每个产品创建一个请求库存的任务列表。我们将再次将这些任务传递给
    `wait` 协程，给它们1秒钟的时间来完成。
- en: Since inventory numbers are optional, once our timeout is up, we begin processing
    everything in both the `done` and `pending` sets of inventory requests. If we
    have a successful response from the inventory service, we create a dictionary
    with the product information alongside the inventory number. If there was either
    an exception or the request is still in the `pending` set, we create a record
    with the inventory as `None`, indicating we couldn’t retrieve it. Using `None`
    will give us a `null` value when we turn our response into JSON.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于库存编号是可选的，一旦我们的超时时间到达，我们就开始处理 `done` 和 `pending` 两个库存请求集中的所有内容。如果我们从库存服务获得成功的响应，我们将创建一个包含产品信息和库存编号的字典。如果有异常或请求仍在
    `pending` 集中，我们将创建一个库存为 `None` 的记录，表示我们无法检索它。使用 `None` 将在我们将响应转换为JSON时给我们一个 `null`
    值。
- en: Finally, we check the cart and favorite responses. All we need to do for both
    these requests is count the number of items returned. Since this logic is nearly
    identical for both services, we create a helper method to count items named `get_response_item_`
    `count`. In `get_response_item_count`, if we have a successful result from either
    the cart or favorite service, it will be a JSON array, so we count and return
    the number of items in that array. If there was an exception or the request took
    longer than 1 second, we set the result to `None,` so we get a `null` value in
    our JSON response.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们检查购物车和收藏夹的响应。对于这两个请求，我们只需要计算返回的项目数量。由于这种逻辑对两个服务几乎是相同的，我们创建了一个名为 `get_response_item_count`
    的辅助方法来计数。在 `get_response_item_count` 中，如果我们从购物车或收藏夹服务获得成功的响应，它将是一个JSON数组，因此我们计算并返回该数组中的项目数量。如果有异常或请求超过1秒，我们将结果设置为
    `None`，这样我们就可以在我们的JSON响应中获得一个 `null` 值。
- en: This implementation provides us with a reasonably robust way to deal with failures
    and timeouts of our non-critical services, ensuring that we give a sensible response
    quickly even in the result of downstream issues. No single request to a downstream
    service will take longer than 1 second, creating an approximate upper bound for
    how slow our service can be. However, while we’ve created something fairly robust,
    there are still a few ways we can make this even more resilient to issues.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现为我们提供了一种合理稳健的方式来处理非关键服务的失败和超时，确保即使在下游问题的情况下，我们也能快速给出合理的响应。对下游服务的任何单个请求都不会超过1秒，这为我们服务的速度提供了一个大致的上限。然而，虽然我们已经创建了一些相当稳健的东西，但我们仍然有几种方法可以使它对问题更加有弹性。
- en: 10.3.4 Retrying failed requests
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.4 重试失败的请求
- en: One issue with our first implementation is that it pessimistically assumes that
    if we get an exception from a service, we assume we can’t get results and we move
    on. While this can make sense, it is the case that an issue with a service could
    be transient. For example, there may be a networking hiccup that disappears rather
    quickly, there may be a temporary issue with any load balancers we’re using, or
    there could be any other host of temporary issues.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们第一次实现的一个问题是它悲观地假设如果我们从服务中获得异常，我们假设我们无法获取结果并继续前进。虽然这可能是合理的，但服务的问题可能是瞬时的。例如，可能有网络中断很快就会消失，可能有我们使用的任何负载均衡器的临时问题，或者可能有其他一系列的临时问题。
- en: In these cases, it can make sense to retry a few times with a short delay in
    between retries. This gives the error a chance to clear up and can give our users
    more data than they would otherwise have if we were pessimistic about our failures.
    This of course comes with the tradeoff of having our users wait longer, potentially
    just to see the same failure they would have otherwise.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，在重试之间有短暂的延迟重试几次是有意义的。这给错误一个清除的机会，并且可以给我们用户提供比我们悲观地看待失败时更多的数据。当然，这也伴随着我们的用户需要等待更长的时间，可能只是为了看到他们本可以避免的相同失败。
- en: To implement this functionality, the `wait_for` coroutine function is a perfect
    candidate. It will raise any exception we get, and it lets us specify a timeout.
    If we surpass that timeout, it raises a `TimeoutException` and cancels the task
    we started. Let’s try and create a reusable retry coroutine that does this for
    us. We’ll create a `retry` coroutine function that takes in coroutine as well
    as a number of times to retry. If the coroutine we pass in fails or times out,
    we’ll retry up to the number of times we specified.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个功能，`wait_for`协程函数是一个完美的候选者。它将抛出我们遇到的任何异常，并允许我们指定一个超时。如果我们超过了那个超时，它将抛出一个`TimeoutException`并取消我们开始的任务。让我们尝试创建一个可重用的重试协程，为我们做这件事。我们将创建一个`retry`协程函数，它接受协程以及重试的次数。如果我们传递的协程失败或超时，我们将重试直到达到我们指定的次数。
- en: Listing 10.9 A retry coroutine
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.9 重试协程
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Wait for a response for the specified timeout.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 等待指定超时时间内的响应。
- en: ❷ If we get an exception, log it and sleep for the retry interval.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果我们遇到异常，记录它并等待重试间隔。
- en: ❸ If we’ve failed too many times, raise an exception to indicate that.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果我们失败次数过多，抛出异常以表示这一点。
- en: In the preceding listing, we first create a custom exception class that we’ll
    raise when we are still failing after the maximum amount of retries. This will
    let any callers catch this exception and handle this specific issue as they see
    fit. The `retry` coroutine takes in a few arguments. The first argument is a callable
    that returns an awaitable; this is the coroutine that we’ll retry. The second
    argument is the number of times we’d like to retry, and the final arguments are
    the timeout and the interval to wait to retry after a failure. We create a loop
    that wraps the coroutine in `wait_for`, and if this completes successfully, we
    return the results and exit the function. If there was an error, timeout or otherwise,
    we catch the exception, log it, and sleep for the specified interval time, retrying
    again after we’ve slept. If our loop finishes without an error-free call of our
    coroutine, we raise a `TooManyRetries` exception.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的列表中，我们首先创建了一个自定义异常类，当我们在最大重试次数后仍然失败时，我们将抛出这个异常。这将允许任何调用者捕获这个异常，并按他们的方式处理这个特定问题。`retry`协程接受几个参数。第一个参数是一个返回可等待对象的调用项；这是我们将会重试的协程。第二个参数是我们想要重试的次数，最后的参数是失败后等待重试的间隔和超时。我们创建了一个循环，将协程包装在`wait_for`中，如果这个循环成功完成，我们返回结果并退出函数。如果有错误、超时或其他情况，我们捕获异常，记录它，并在等待指定的时间间隔后再次重试。如果我们的循环在没有无错误调用我们的协程的情况下完成，我们将抛出一个`TooManyRetries`异常。
- en: We can test this out by creating a couple of coroutines that exhibit the failure
    behavior we’d like to handle. First, one which always throws an exception and
    second, one which always times out.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过创建几个表现出我们想要处理的失败行为的协程来测试这一点。首先是一个总是抛出异常的协程，其次是总是超时的协程。
- en: Listing 10.10 Testing the retry coroutine
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.10 测试重试协程
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For both retries, we define a timeout and retry interval of 100 milliseconds
    and a max retry amount of three. This means we give the coroutine 100 milliseconds
    to complete, and if it doesn’t complete within that time, or it fails, we wait
    100 milliseconds before trying again. Running this listing, you should see each
    coroutine try to run three times and finally print `Retried` `too` `many` `times!`,
    leading to output similar to the following (tracebacks omitted for brevity):'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对于两次重试，我们定义了100毫秒的超时和重试间隔，以及最大重试次数为三次。这意味着我们给协程100毫秒的时间来完成，如果它没有在规定时间内完成，或者失败了，我们将在尝试再次之前等待100毫秒。运行此列表，你应该看到每个协程尝试运行三次，最后打印出`Retried`
    `too` `many` `times!`，输出类似于以下内容（为了简洁省略了跟踪回溯）：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Using this, we can add some simple retry logic to our product backend-for-frontend.
    For example, let’s say we wanted to retry our initial requests to the products,
    cart, and favorite services a few times before considering their error unrecoverable.
    We can do this by wrapping each request in the retry coroutine like so:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个方法，我们可以在我们的产品后端前端添加一些简单的重试逻辑。例如，假设我们想在将产品、购物车和收藏服务初始请求的重试次数达到几次之前，才认为它们的错误是不可恢复的。我们可以通过将每个请求包裹在重试协程中来实现这一点：
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this example, we try each service a maximum of three times. This lets us
    recover from issues with our services that may be transient. While this is an
    improvement, there is another potential issue that can hurt our service. For example,
    what happens if our product service always times out?
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们尝试每个服务最多三次。这使我们能够从可能短暂的服务问题中恢复过来。虽然这是一个改进，但还有一个可能损害我们服务的潜在问题。例如，如果我们的产品服务总是超时怎么办？
- en: 10.3.5 The circuit breaker pattern
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.5 断路器模式
- en: One issue we still have in our implementation occurs when a service is consistently
    slow enough such that it always times out. This can happen when a downstream service
    is under load, there is some other network issue happening, or a multitude of
    other application or network errors.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现中仍然存在的问题是，当一个服务持续缓慢到总是超时。这可能会发生在下游服务负载过高、存在其他网络问题或众多其他应用程序或网络错误的情况下。
- en: You may be tempted to ask, “Well, our application handles the timeout gracefully;
    the user won’t wait for more than 1 second before seeing an error or getting partial
    data, so what is the problem?” And you’re not wrong to ask. However, while we’ve
    designed our system to be robust and resilient, consider the user experience.
    For example, if the cart service is experiencing an issue such that it always
    takes 1 second to time out, this means that all users will be stuck waiting for
    1 second for results from the service.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想问，“嗯，我们的应用程序优雅地处理了超时；用户在看到错误或获取部分数据之前不会等待超过1秒钟，那问题在哪里？”你提出这个问题是正确的。然而，尽管我们已经设计我们的系统具有鲁棒性和弹性，但请考虑用户体验。例如，如果购物车服务遇到问题，总是需要1秒钟才能超时，这意味着所有用户都将被困在等待1秒钟以获取服务结果。
- en: In this instance, since this issue with the cart service could last for some
    time, anyone who hits our backend-for-frontend will be stuck waiting for 1 second
    when we *know* that this issue is highly likely to happen. Is there a way we can
    short-circuit a call that is likely to fail, so we don’t cause unneeded delays
    to our users?
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，由于购物车服务的问题可能会持续一段时间，任何撞击我们的后端前端的人都会被困在等待1秒钟，而我们*知道*这个问题极有可能发生。我们有没有一种方法可以短路一个可能失败的调用，这样我们就不必给用户造成不必要的延迟？
- en: There is an aptly named pattern to handle this called the *circuit breaker pattern*.
    Popularized by Michael Nygard’s book *Release It* (The Pragmatic Bookshelf, 2017),
    this pattern lets us “flip a circuit breaker,” and when we have a specified number
    of errors in each time period, we can use this to bypass the slow service until
    the issues with it clear up, ensuring our response to our users remains as fast
    as possible.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这种情况有一个恰如其分的模式，称为*断路器模式*。这个模式由Michael Nygard的书籍《Release It*》（The Pragmatic
    Bookshelf，2017年）普及，它允许我们“断开电路”，当我们在每个时间段内遇到指定数量的错误时，我们可以使用这个模式绕过缓慢的服务，直到它的问题得到解决，确保我们对用户的响应尽可能快。
- en: 'Much like an electrical circuit breaker, a basic circuit breaker pattern has
    two states associated with it that are the same as a normal circuit breaker on
    your electrical panel: an open state and a closed state. The closed state is a
    happy path; we make a request to a service and it returns normally. The open state
    happens when the circuit is tripped. In this state, we don’t bother to call the
    service, as we know it has a problem; instead, we instantly return an error. The
    circuit breaker pattern stops us from sending electricity to the bad service.
    In addition to these two states there is a “half-open” state. This happens when
    we’re in the open state after a certain time interval. In this state we issue
    a single request to check if the issue with the service is fixed. If it is, we
    close the circuit breaker, and if not, we keep it open. For the sake of keeping
    our example simple, we’ll skip the half-open state and just focus on the closed
    and open states, as shown in figure 10.3.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 与电气断路器类似，基本的断路器模式有两个与其相关的状态，这与您电气面板上的正常断路器相同：开启状态和关闭状态。关闭状态是一个愉快的路径；我们向服务发出请求，它正常返回。开启状态发生在电路跳闸时。在这个状态下，我们不会麻烦去调用服务，因为我们知道它有问题；相反，我们立即返回一个错误。断路器模式阻止我们将电力发送到不良服务。除了这两个状态之外，还有一个“半开启”状态。这发生在我们在开启状态一段时间后。在这个状态下，我们发出单个请求来检查服务的问题是否已解决。如果是，我们关闭断路器；如果不是，我们保持它开启。为了使我们的示例简单，我们将跳过半开启状态，只关注关闭和开启状态，如图
    10.3 所示。
- en: '![10-03](Images/10-03.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![10-03](Images/10-03.png)'
- en: Figure 10.3 A circuit breaker that opens after two failures. Once opened, all
    requests will fail instantly.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 在两次失败后打开的断路器。一旦打开，所有请求将立即失败。
- en: Let’s implement a simple circuit breaker to understand how this works. We’ll
    allow the users of the circuit breaker to specify a time window and a maximum
    number of failures. If more than the maximum number of errors happens within the
    time window, we’ll open the circuit breaker and fail any other calls. We’ll do
    this with a class that takes the coroutine we wish to run and keeps track if we
    are in the open or closed state.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个简单的断路器来理解它是如何工作的。我们将允许断路器的用户指定一个时间窗口和最大失败次数。如果在时间窗口内发生的错误超过最大次数，我们将打开断路器并使其他任何调用失败。我们将通过一个类来实现这一点，该类接受我们希望运行的协程并跟踪我们处于开启还是关闭状态。
- en: Listing 10.11 A simple circuit breaker
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.11 一个简单的断路器
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ Make the request, failing fast if we’ve exceeded the failure count.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 发出请求，如果我们的失败计数超过，则快速失败。
- en: ❷ Reset our counters and last failure time.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 重置我们的计数器和最后失败时间。
- en: ❸ Make the request, keeping track of how many failures we’ve had and when they
    last happened.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 发出请求，同时跟踪我们发生的失败次数和它们最后一次发生的时间。
- en: Our circuit breaker class takes five constructor parameters. The first two are
    the callback we wish to run with the circuit breaker and a `timeout` which represents
    how long we’ll allow the callback to run before failing with a timeout. The next
    three are related to handling failures and resets. The `max_failure` parameter
    is the maximum number of failures we’ll tolerate within `time_window` seconds
    before opening the circuit. The `reset_interval` parameter is how many seconds
    we wait to reset the breaker from the open to closed state after `max_failure`
    failures have occurred.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的断路器类接受五个构造函数参数。前两个是我们希望与断路器一起运行的回调和一个 `timeout`，它表示我们允许回调运行多长时间，如果超时则失败。接下来的三个参数与处理失败和重置有关。`max_failure`
    参数是在 `time_window` 秒内我们将在打开断路器之前容忍的最大失败次数。`reset_interval` 参数是在发生 `max_failure`
    次失败后，我们等待多少秒将断路器从开启状态重置为关闭状态。
- en: We then define a coroutine method `request`, which calls our callback and keeps
    track of how many failures we’ve had, returning the result of the callback if
    there were no errors. When we have a failure, we keep track of this in a counter
    `failure_count`. If the failure count exceeds the `max_failure` threshold we set
    within the specified time interval, any further calls to `request` will raise
    a `CircuitOpenException`. If the reset interval has elapsed, we reset the `failure_count`
    to zero and begin making requests again (if our breaker was closed, which it may
    not be).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义一个协程方法 `request`，它调用我们的回调并跟踪我们发生的失败次数。如果没有错误，它将返回回调的结果。当我们有失败时，我们在计数器
    `failure_count` 中跟踪这一点。如果失败计数超过我们在指定时间间隔内设置的 `max_failure` 阈值，任何进一步的 `request`
    调用将引发 `CircuitOpenException`。如果重置间隔已过，我们将 `failure_count` 重置为零并再次开始发出请求（如果我们的断路器是关闭的，这可能是未知的）。
- en: Now, let’s see our breaker in action with a simple example application. We’ll
    create a `slow_callback` coroutine that sleeps for just 2 seconds. We’ll then
    use that in our breaker, setting a short timeout that will let us easily trip
    the breaker.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过一个简单的示例应用程序来看看我们的断路器是如何工作的。我们将创建一个`slow_callback`协程，它将暂停2秒钟。然后我们将在断路器中使用它，设置一个短暂的超时，这将使我们能够轻松地触发断路器。
- en: Listing 10.12 The breaker in action
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.12 断路器的工作情况
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the preceding listing, we create a breaker with a 1-second timeout that
    tolerates two failures within a 5-second interval and resets after 5 seconds once
    the breaker is open. We then try to make four requests rapidly to the breaker.
    The first two should take 1 second before failing with a timeout, then every subsequent
    call will fail instantly as the breaker is open. We then sleep for 5 seconds;
    this lets the breaker’s `reset_interval` elapse, so it should move back to the
    closed state and start to make calls to our callback again. Running this, you
    should see output as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的列表中，我们创建了一个具有1秒超时的断路器，它在5秒间隔内容忍两次失败，并在断路器打开后5秒重置。然后我们尝试快速向断路器发送四个请求。前两个应该在1秒后因超时而失败，然后后续的每次调用都会立即失败，因为断路器是打开的。然后我们暂停5秒；这允许断路器的`reset_interval`过期，因此它应该回到关闭状态并开始再次调用我们的回调。运行此程序，您应该看到以下输出：
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now that we have a simple implementation, we can combine this with our retry
    logic and use it in our backend-for-frontend. Since we’ve purposefully made our
    inventory service slow to simulate a real-life legacy service, this is a natural
    place to add our circuit breaker. We’ll set a timeout of 500 milliseconds and
    tolerate five failures within 1 second, after which we’ll set a reset interval
    of 30 seconds. We’ll need to rewrite our `get_inventory` function into a coroutine
    to do this like so:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个简单的实现，我们可以将其与我们的重试逻辑结合起来，并在我们的后端前端中使用它。由于我们故意使我们的库存服务运行缓慢以模拟现实生活中的遗留服务，这是添加断路器的自然位置。我们将设置500毫秒的超时，并在1秒内容忍五次失败，之后我们将设置30秒的重置间隔。我们需要将我们的`get_inventory`函数重写为一个协程来完成此操作，如下所示：
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, in our `all_products` coroutine we’ll need to change how we create our
    inventory service requests. We’ll create a task with a call to our inventory circuit
    breaker instead of the `get_inventory` coroutine:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们的`all_products`协程中，我们需要更改我们创建库存服务请求的方式。我们将创建一个任务，调用我们的库存断路器而不是`get_inventory`协程：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Once we’ve made these changes, you should see call time decrease to the products’
    backend-for-frontend after a few calls. Since we’re simulating an inventory service
    that is slow under load, we’ll eventually trip the circuit breaker with a few
    timeouts and then any subsequent call won’t make any more requests to the inventory
    service until the breaker resets. Our backend-for-frontend service is now more
    robust in the face of a slow and failure-prone inventory service. We could also
    apply this to all our other calls if desired to increase the stability of these
    as well.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们做出这些更改，您应该在几次调用后看到调用时间降低到产品的后端前端。由于我们正在模拟一个在负载下运行缓慢的库存服务，我们最终会因几个超时而触发断路器，然后任何后续的调用都不会再向库存服务发送请求，直到断路器重置。现在，我们的后端前端服务在面对缓慢且易出错的库存服务时更加健壮。如果需要，我们也可以将其应用于所有其他调用，以提高它们的稳定性。
- en: In this example, we’ve implemented a very simple circuit breaker to demonstrate
    how it works and how to build it with asyncio. There are several existing implementations
    of this pattern with many other features to tune to your specific needs. If you’re
    considering this pattern, take some time to do research on the circuit breaker
    libraries available before implementing it yourself.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们实现了一个非常简单的断路器来演示它是如何工作的以及如何使用 asyncio 来构建它。这个模式有几种现有的实现，具有许多其他可调整以适应您特定需求的功能。如果您正在考虑这个模式，请在自己实现之前花些时间研究可用的断路器库。
- en: Summary
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Microservices have several benefits over monoliths, including, but not limited
    to, independent scalability and deployability.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与单体应用相比，微服务具有许多优势，包括但不限于独立可伸缩性和可部署性。
- en: The backend-for-frontend pattern is a microservice pattern that aggregates the
    calls from several downstream services. We’ve learned how to apply a microservice
    architecture to an e-commerce use case, creating multiple independent services
    with aiohttp.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后端前端模式是一种微服务模式，它聚合了来自多个下游服务的调用。我们已经学习了如何将微服务架构应用于电子商务用例，使用 aiohttp 创建了多个独立的服务。
- en: We’ve used asyncio utility functions such as `wait` to ensure that our backend-for-frontend
    service remains resilient and responsive to failures of downstream services.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经使用了 `asyncio` 实用函数，如 `wait`，以确保我们的前后端服务在面对下游服务失败时仍保持弹性和响应能力。
- en: We’ve created a utility to manage retries of HTTP requests with asyncio and
    aiohttp.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个实用工具，用于管理使用 `asyncio` 和 `aiohttp` 的 HTTP 请求的重试。
- en: We’ve implemented a basic circuit breaker pattern to ensure a service failure
    does not negatively impact other services.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们实现了一个基本的断路器模式，以确保服务故障不会对其他服务产生负面影响。
