- en: 7 Secrets
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 秘密
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了
- en: Kubernetes Secrets
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes Secrets
- en: GitOps strategies for managing Secrets
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitOps 管理秘密的策略
- en: Tooling for managing Secrets
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理秘密的工具
- en: Kubernetes provides a mechanism allowing users to store small bits of sensitive
    information in a protected resource object, called a Secret. A Secret is anything
    that you want to tightly control access to. Common examples of data you would
    want to store in a Secret include things like username and password credentials,
    API keys, SSH keys, and TLS certificates. In this chapter, you will learn about
    different Secret management strategies when using a GitOps system. You will also
    have a brief introduction to several different tools that can be used for storing
    and managing Secrets.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 提供了一种机制，允许用户在称为 Secret 的受保护资源对象中存储少量敏感信息。Secret 是您想要严格控制访问权限的任何内容。您可能希望存储在
    Secret 中的常见数据包括用户名和密码凭证、API 密钥、SSH 密钥和 TLS 证书。在本章中，您将了解在使用 GitOps 系统时不同的秘密管理策略。您还将简要介绍一些可用于存储和管理秘密的不同工具。
- en: We recommend you read chapters 1 and 2 before reading this chapter.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议您在阅读本章之前先阅读第 1 章和第 2 章。
- en: 7.1 Kubernetes Secrets
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1 Kubernetes Secrets
- en: 'A simple *Kubernetes Secret* is a data structure composed of three pieces of
    information:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的 *Kubernetes Secret* 是一个由三部分信息组成的数据结构：
- en: The name of the Secret
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 秘密的名称
- en: The type of the Secret (optional)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 秘密的类型（可选）
- en: A map of field names to sensitive data, encoded in Base64
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字段名到敏感数据的映射，以 Base64 编码
- en: A basic Secret looks like the following.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一个基本的秘密看起来如下。
- en: Listing 7.1 example-secret.yaml
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.1 example-secret.yaml
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Type of the Secret, used to facilitate programmatic handling of Secret data
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 秘密的类型，用于简化对秘密数据的程序化处理
- en: ❷ The string “admin” Base64 encoded
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 字符串“admin”Base64 编码
- en: ❸ The string “P@55w0rd” Base64 encoded
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 字符串“P@55w0rd”Base64 编码
- en: When looking at the values of a Secret for the first time, at first glance you
    might mistakenly think that the Secret values were protected with encryption,
    since the fields are not readable by a human and are not presented in plain text.
    But you would be mistaken, and it is important to understand that
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当第一次查看秘密的值时，您可能会错误地认为秘密值是用加密保护的，因为字段对人类不可读，并且不以纯文本形式呈现。但您是错误的，并且重要的是要理解
- en: Secret values are Base64 encoded.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 秘密值是 Base64 编码的。
- en: Base64 encoding is not the same thing as encryption.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Base64 编码与加密不同。
- en: Viewing should be considered the same as plain text.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应将查看视为与纯文本相同。
- en: Base64 encoding Base64 is an encoding algorithm that allows you to transform
    any characters into an alphabet that consists of Latin letters, digits, plus,
    and slash. It allows binary data to be represented in an ASCII string format.
    Base64 does *not* provide encryption.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Base64 编码 Base64 是一种编码算法，它允许您将任何字符转换成一个由拉丁字母、数字、加号和斜杠组成的字母表。它允许二进制数据以 ASCII
    字符串格式表示。Base64 编码**不**提供加密。
- en: The reason Kubernetes Base64 encodes the data at all is that it allows Secrets
    to store binary data. This is important for storing things like certificates as
    Secrets. Without Base64 encoding, it would be impossible to store binary configurations
    as a Secret.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 对数据进行 Base64 编码的原因是它允许秘密存储二进制数据。这对于将证书等存储为秘密非常重要。如果没有 Base64 编码，将无法将二进制配置作为秘密存储。
- en: 7.1.1 Why use Secrets?
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.1 为什么使用秘密？
- en: Using Secrets is optional in Kubernetes, but more convenient, flexible, and
    secure than other techniques, such as placing the sensitive values directly in
    the Pod specification or baking the values into the container image during build
    time. Just as with ConfigMaps, Secrets allow the separation of the configuration
    of an application from the build artifact.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中使用秘密是可选的，但比其他技术（如直接在 Pod 规范中放置敏感值或在构建时将值烘焙到容器镜像中）更方便、更灵活、更安全。就像
    ConfigMaps 一样，秘密允许将应用程序的配置与构建工件分离。
- en: 7.1.2 How to use Secrets
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.2 如何使用秘密
- en: 'Kubernetes Secrets, like ConfigMaps, can be used in several ways:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes Secrets，就像 ConfigMaps 一样，可以用几种方式使用：
- en: As files mounted as files in the Pod
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为 Pod 中挂载的文件
- en: As environment variables in the Pod
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为 Pod 中的环境变量
- en: Kubernetes API access
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes API 访问
- en: '![](Images/CH07_F01_Yuen.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH07_F01_Yuen.png)'
- en: Figure 7.1 A Secret volume is used to pass sensitive information, such as passwords,
    to Pods. Secret volumes are backed by tmpfs (a RAM-backed filesystem) so they
    are never written to nonvolatile storage.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 使用机密卷传递敏感信息，如密码，到Pod。机密卷由tmpfs（一个基于RAM的文件系统）支持，因此它们永远不会写入非易失性存储。
- en: Volume-mounting Secrets as files in a Pod
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Pod中的文件卷挂载机密信息
- en: The first technique of utilizing Secrets is mounting them into a Pod as a volume.
    To do this, you first declare the following.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 利用机密的第一种技术是将它们挂载到Pod中作为卷。为此，你首先声明以下内容。
- en: Listing 7.2 secret-volume.yaml
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.2 secret-volume.yaml
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ A volume of type Secret is declared in the Pod, with an arbitrary name.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在Pod中声明了一个类型为Secret的卷，具有任意名称。
- en: ❷ The container that needs the Secrets specifies a path for where to mount the
    Secret data volume.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 需要机密信息的容器指定了挂载机密数据卷的路径。
- en: When projecting a Secret (or ConfigMap) into a Pod as a volume of files, changes
    to the underlying Secret will eventually update the files mounted in the Pod.
    This allows the opportunity for the application to reconfigure itself, or hot-reload,
    without a restart of the container/Pod.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当将机密（或ConfigMap）投影到Pod作为文件卷时，底层机密的变化最终会更新Pod中挂载的文件。这为应用程序提供了重新配置自己或热重载的机会，而无需重启容器/Pod。
- en: Using Secrets as environment variables
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 将机密作为环境变量使用
- en: The second way of utilizing Kubernetes Secrets is by setting them as environment
    variables.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 利用Kubernetes机密的第二种方式是将它们设置为环境变量。
- en: Listing 7.3 secret-environment-variable.yaml
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.3 secret-environment-variable.yaml
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Name of the Secret
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 机密的名称
- en: ❷ The key of the Secret data map
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 机密数据映射的键
- en: Exposing Secrets to containers as environment variables, while convenient, is
    arguably not the optimal way to consume Secrets, since it is less secure than
    consuming them as volume-mounted files. When a Secret is set as an environment
    variable, all processes in the container (including child processes) will inherit
    the OS environment and be able to read the environment variable values, and thus
    the Secret data. For example, a forked shell script would be able to read the
    environment variables by running the `env` utility.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 将机密作为环境变量暴露给容器，虽然方便，但可能不是消费机密的最佳方式，因为它比将其作为卷挂载文件消费的安全性更低。当机密被设置为环境变量时，容器中的所有进程（包括子进程）都将继承操作系统环境并能够读取环境变量值，从而读取机密数据。例如，一个分叉的shell脚本可以通过运行`env`实用程序来读取环境变量。
- en: Disadvantage of Secret environment variables A second disadvantage of using
    Secrets as environment variables is that, unlike Secrets projected into volumes,
    values of Secret environment variables will not be updated if the Secret is ever
    updated after the container starts. A container or Pod restart would be necessary
    to notice changes.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 机密环境变量的缺点 使用机密作为环境变量的第二个缺点是，与投影到卷中的机密不同，如果容器启动后机密被更新，机密环境变量的值将不会更新。需要容器或Pod重启才能注意到变化。
- en: Using Secrets from the K8s API
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用K8s API中的机密
- en: Finally, Kubernetes Secrets can also be retrieved directly from the Kubernetes
    API. Suppose you had the following Secret with a password field.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Kubernetes机密也可以直接从Kubernetes API中检索。假设你有一个以下带有密码字段的机密。
- en: Listing 7.4 secret.yaml
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.4 secret.yaml
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To retrieve the Secret, the Pod itself could retrieve the Secret value directly
    from Kubernetes, for example, by using a `kubectl` command or REST API call. The
    following `kubectl` command retrieves the Secret named `my-secret`, Base64 decodes
    the password field, and prints the plain-text value to standard out:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索机密，Pod本身可以直接从Kubernetes中检索机密值，例如，通过使用`kubectl`命令或REST API调用。以下`kubectl`命令检索名为`my-secret`的机密，对密码字段进行Base64解码，并将纯文本值打印到标准输出：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This technique requires that the Pod has privileges to retrieve the Secret.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术要求Pod有权限检索机密。
- en: Secret types
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 机密类型
- en: The Secret type field is an indication of what type of data is contained inside
    the Secret. It is primarily used by software programs to identify relevant Secrets
    they might be interested in, as well as safely make assumptions about what available
    fields inside the Secret are set.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 机密类型字段是数据包含在机密中的类型的指示。它主要用于软件程序识别它们可能感兴趣的相关的机密，以及安全地做出关于机密内部可用的字段设置的假设。
- en: The following table describes the built-in Kubernetes Secret types, as well
    as the required fields for each type.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格描述了内置的Kubernetes机密类型，以及每种类型所需的字段。
- en: Table 7.1 Built-in Secret types
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.1 内置机密类型
- en: '| Type | Description | Required fields |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 描述 | 必需字段 |'
- en: '| Opaque | The default type. Contains arbitrary user-defined data. |  |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| Opaque | 默认类型。包含任意用户定义的数据。 |  |'
- en: '| kubernetes.io/service-account-token | Contains a token that identifies a
    service account to the Kubernetes API. | data["token"] |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| kubernetes.io/service-account-token | 包含一个标识 Kubernetes API 中服务账户的令牌。 | data["token"]
    |'
- en: '| kubernetes.io/dockercfg | Contains a serialized ~/.dockercfg file. | data[".dockercfg"]
    |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| kubernetes.io/dockercfg | 包含一个序列化的 ~/.dockercfg 文件。 | data[".dockercfg"]
    |'
- en: '| kubernetes.io/dockerconfigjson | Contains a serialized ~/.docker/config.json
    file. | data[".dockerconfigjson"] |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| kubernetes.io/dockerconfigjson | 包含一个序列化的 ~/.docker/config.json 文件。 | data[".dockerconfigjson"]
    |'
- en: '| kubernetes.io/basic-auth | Contains basic username/password credentials.
    | data["username"]data["password"] |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| kubernetes.io/basic-auth | 包含基本的用户名/密码凭证。 | data["username"]data["password"]
    |'
- en: '| kubernetes.io/ssh-auth | Contains a private SSH key needed for authentication.
    | data["ssh-privatekey"] |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| kubernetes.io/ssh-auth | 包含用于身份验证所需的私有 SSH 密钥。 | data["ssh-privatekey"] |'
- en: '| kubernetes.io/tls | Contains a TLS private key and certificate. | data["tls.key"]data["tls.crt"]
    |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| kubernetes.io/tls | 包含 TLS 私钥和证书。 | data["tls.key"]data["tls.crt"] |'
- en: 7.2 GitOps and Secrets
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2 GitOps 和密钥
- en: 'Kubernetes GitOps practitioners will invariably come to the same problem: while
    users are perfectly comfortable with storing configuration in Git, when it comes
    to sensitive data, they are unwilling to store that data in Git due to security
    concerns. Git was designed as a collaborative tool, making it easy for multiple
    people and teams to gain access to code and view each other’s changes. But these
    same properties are also what make using Git to hold Secrets an extremely dangerous
    practice. There are many concerns and reasons why it is inappropriate to store
    Secrets in Git, which we cover next.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes GitOps 实践者不可避免地会遇到相同的问题：虽然用户在 Git 中存储配置时感到非常舒适，但当涉及到敏感数据时，由于安全顾虑，他们不愿意在
    Git 中存储这些数据。Git 被设计为一个协作工具，使得多人团队可以轻松访问代码并查看彼此的更改。但正是这些相同的属性使得使用 Git 来存储密钥成为一种极其危险的做法。有许多担忧和原因说明为什么在
    Git 中存储密钥是不合适的，我们将在下面进行说明。
- en: 7.2.1 No encryption
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.1 没有加密
- en: As we learned earlier, Kubernetes provides no encryption on the contents of
    a Secret, and the Base64 encoding of the values should be considered the same
    as plain text. Additionally, Git alone does not provide any form of built-in encryption.
    So when storing Secrets in a Git repository, the Secrets are laid bare to anyone
    with access to the Git repository.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所学的，Kubernetes 并不对 Secret 的内容进行加密，值的 Base64 编码应被视为与纯文本相同。此外，Git 本身也不提供任何形式的内置加密。因此，当在
    Git 仓库中存储密钥时，密钥对任何有权访问 Git 仓库的人来说都是公开的。
- en: 7.2.2 Distributed Git repos
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.2 分布式 Git 仓库
- en: With GitOps, you and your colleagues will be locally cloning the Git repository
    to your laptops and workstations, for the purposes of managing the configuration
    of the applications. But by doing so, you would also be proliferating and distributing
    Secrets to many systems, without adequate auditing or tracking. If any of these
    systems were to become compromised (hacked or even physically lost), someone would
    gain access to all of your Secrets.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 GitOps，你和你的同事将本地克隆 Git 仓库到你的笔记本电脑和工作站，目的是管理应用程序的配置。但这样做的同时，你也会在许多系统中传播和分发密钥，而没有足够的审计或跟踪。如果其中任何系统遭到破坏（被黑客攻击或甚至物理丢失），有人将能够访问你所有的密钥。
- en: 7.2.3 No granular (file-level) access control
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.3 没有细粒度（文件级）访问控制
- en: Git does not provide read protection of a subpath or subfile of a Git repository.
    In other words, it is not possible to restrict access to some files in the Git
    repository but not others. When dealing with Secrets, you ideally should be granting
    read access to the Secrets on a need-to-know basis. For example, if you had a
    temporary worker who needed partial access to the Git repository, you would want
    to give the least amount of access to the content as possible to that user. Unfortunately,
    Git does not provide any facilities to accomplish this, and it is an all-or-nothing
    decision when giving permissions to a repo.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Git 不提供对 Git 仓库子路径或子文件的读取保护。换句话说，不可能限制对某些文件的访问，而不限制对其他文件的访问。在处理密钥时，理想情况下应根据需要了解情况来授予读取访问权限。例如，如果你有一个需要部分访问
    Git 仓库的临时工作人员，你希望尽可能少地给予该用户访问内容。不幸的是，Git 不提供任何实现此目的的设施，在授予仓库权限时是一个全有或全无的决定。
- en: 7.2.4 Insecure storage
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.4 不安全存储
- en: Git was never intended to be used in the capacity of a Secret management system.
    As a result, it did not design into the system standard security features such
    as encryption at rest. Therefore, a compromised Git server would have the potential
    of also leaking the Secrets of all the repositories it manages, making it a prime
    target for attack.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Git 从来没有打算用作 Secret 管理系统。因此，它没有将标准安全功能（如静态加密）设计到系统中。因此，如果 Git 服务器被入侵，它可能会泄露它所管理的所有存储库的
    Secrets，使其成为攻击的主要目标。
- en: Git provider features Although Git in itself does not provide security features
    such as encryption at rest, Git providers often do provide these features on top
    of Git. For example, GitHub does claim to encrypt repositories at rest. But this
    functionality may vary from provider to provider.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Git 提供商功能 虽然Git本身不提供静态加密等安全功能，但Git提供商通常会在Git之上提供这些功能。例如，GitHub 声称会对存储库进行静态加密。但此功能可能因提供商而异。
- en: 7.2.5 Full commit history
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.5 完整提交历史
- en: Once a Secret is added to the Git commit history, it is very difficult to remove.
    If the Secret is checked into Git and then later deleted, that Secret can still
    be retrieved by checking out an earlier point in the repository history before
    the Secret was deleted. Even if the Secret is encrypted, when the key used to
    encrypt the Secret is later rotated and the Secret is reencrypted with a new key,
    the Secret encrypted with the old keys is still present in the repository history.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Secret 被添加到 Git 提交历史中，就很难删除。如果 Secret 被检查到 Git 中，然后后来被删除，那么在 Secret 被删除之前的存储库历史中的早期点仍然可以检索到该
    Secret。即使 Secret 被加密，当用于加密 Secret 的密钥后来被轮换，并且使用新密钥重新加密 Secret 时，使用旧密钥加密的 Secret
    仍然存在于存储库历史中。
- en: 7.3 Secrets management strategies
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3 Secrets 管理策略
- en: There are many different strategies for dealing with Secrets in GitOps with
    trade-offs in flexibility, manageability, and security. Before going into the
    application of tools to implement these strategies, we’ll first go over some of
    the strategies at a conceptual level.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GitOps 中处理 Secrets 有许多不同的策略，这些策略在灵活性、可管理性和安全性方面存在权衡。在介绍实现这些策略的工具之前，我们首先从概念层面概述一些策略。
- en: 7.3.1 Storing Secrets in Git
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.1 在 Git 中存储 Secrets
- en: The first strategy of GitOps and Secrets is to not have a strategy at all. In
    other words, you would simply commit and manage your Secrets in Git like any other
    Kubernetes resource and accept the security consequences.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: GitOps 和 Secrets 的第一策略就是根本不制定策略。换句话说，你只需像管理其他 Kubernetes 资源一样，将 Secrets 提交到
    Git 并接受其安全后果。
- en: You might be thinking, “What is so wrong about storing my Secrets in Git?” Even
    if you have a private GitHub repository, which is only accessible by trusted members
    of your team, you might want to allow third-party access to the Git repo—CI/CD
    systems, security scanners, static analysis, and so on. By providing your Git
    repository of Secrets to these third-party software systems, you are in turn entrusting
    them with your Secrets.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，“将我的 Secrets 存储在 Git 中有什么不好？”即使你有私有 GitHub 存储库，只有你的团队成员可以访问，你也可能希望允许第三方访问
    Git 仓库——CI/CD 系统、安全扫描器、静态分析等。通过向这些第三方软件系统提供你的 Secrets Git 仓库，你实际上是在将你的 Secrets
    交托给他们。
- en: So in practice, the only real acceptable scenarios where Secrets could be stored
    as is in Git are when the Secrets do not contain any truly sensitive data, such
    as dev and test environments.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在实践中，唯一真正可以接受的将 Secrets 以原样存储在 Git 中的场景是当 Secrets 不包含任何真正敏感数据时，例如开发和测试环境。
- en: 7.3.2 Baking Secrets into the container image
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.2 将 Secrets 集成到容器镜像中
- en: One naive strategy that might come to mind to avoid storing Secrets in Git is
    to bake the sensitive data directly into the container image. In this approach,
    the Secret data is directly copied into the container image as part of the Docker
    build process.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可能想到的简单策略是直接将敏感数据集成到容器镜像中，以避免在 Git 中存储 Secrets。在这种方法中，Secret 数据作为 Docker 构建过程的一部分直接复制到容器镜像中。
- en: '![](Images/CH07_F02_Yuen.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH07_F02_Yuen.png)'
- en: Figure 7.2 Baking a Secret into the container image. The Docker build process
    bakes the sensitive data into the image (such as by copying the sensitive file
    into the container). No Secret store is used (Kubernetes or external), but the
    container registry becomes sensitive since it is effectively a Secret store.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 将 Secret 集成到容器镜像中。Docker 构建过程将敏感数据（例如，通过将敏感文件复制到容器中）集成到镜像中。没有使用任何 Secret
    存储库（Kubernetes 或外部），但容器注册库变得敏感，因为它实际上是一个 Secret 存储库。
- en: A simplistic Dockerfile that bakes Secrets into the image might look like this.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的 Dockerfile，将秘密烘焙到镜像中可能看起来像这样。
- en: Listing 7.5 Dockerfile with a Secret
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.5 带有秘密的 Dockerfile
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: An advantage of this approach is that it removes Git and even Kubernetes itself
    from the equation. In fact, with the Secret data baked into the container image,
    the image can be run anywhere, not just Kubernetes, and work without any configuration.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点是它消除了 Git 和甚至 Kubernetes 本身。实际上，由于秘密数据被烘焙到容器镜像中，该镜像可以在任何地方运行，而不仅仅是 Kubernetes，并且无需任何配置即可工作。
- en: However, baking the sensitive data directly into the container image has some
    very bad drawbacks, which should automatically rule it out as a viable option.
    The first issue is that the container image *itself* is now sensitive. Due to
    the fact that the sensitive data was baked into the image, anyone or anything
    that has access to the container image (such as via a `docker` `pull`), can now
    trivially copy out and retrieve the Secret.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，将敏感数据直接烘焙到容器镜像中有一些非常严重的缺点，这应该自动将其排除为可行的选项。第一个问题是容器镜像本身现在变得敏感。由于敏感数据被烘焙到镜像中，现在任何或任何可以访问容器镜像的人或事物（例如通过
    `docker pull`），现在可以轻易地复制和检索秘密。
- en: Another problem is that because the Secret is baked into the image, updates
    to the Secret data are extremely burdensome. Whenever credentials need to be rotated,
    it will require a complete rebuild of the container image.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是因为秘密被烘焙到镜像中，秘密数据的更新非常繁琐。每当需要轮换凭证时，都需要完全重建容器镜像。
- en: 'A third problem is that the container image is not flexible enough to accommodate
    when the same image needs to run using different Secret datasets. Suppose you
    have three environments where this container image will be deployed:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个问题是容器镜像不够灵活，无法适应需要使用不同秘密数据集运行相同镜像的情况。假设你有三个环境，这个容器镜像将被部署到这些环境中：
- en: A developer environment
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发环境
- en: A test environment
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试环境
- en: A production environment
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生产环境
- en: Each of these environments needs a different set of credentials because it connects
    to three different databases. The approach of baking the Secret data into the
    container image would not work here, because it can choose only one of the database
    credentials to bake into the image.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这些环境都需要一组不同的凭证，因为它们连接到三个不同的数据库。将秘密数据烘焙到容器镜像中的方法在这里不起作用，因为它只能选择将其中一个数据库凭证烘焙到镜像中。
- en: 7.3.3 Out-of-band management
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.3 非带管理
- en: A second approach for dealing with Secrets in GitOps is to manage Secrets completely
    *out-of-band* from GitOps. With this approach, everything *except* Kubernetes
    Secrets would be defined in Git and deployed via GitOps, but some other mechanism
    would be used for deploying Secrets, even if it was manual.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 处理 GitOps 中秘密的另一种方法是完全在 GitOps 之外管理秘密。采用这种方法，除了 Kubernetes 秘密之外的所有内容都将定义在 Git
    中并通过 GitOps 部署，但将使用某种其他机制来部署秘密，即使它是手工的。
- en: For example, a user could store their Secrets in a database, a cloud provider’s
    managed Secret store, even a text file on their local workstation. When it came
    time to deploy, the user would manually run `kubectl` `apply` to deploy the Secret
    into the cluster and then let a GitOps operator deploy everything else.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，用户可以将他们的秘密存储在数据库中，云提供商管理的秘密存储中，甚至是在他们本地工作站上的文本文件中。当部署时，用户将手动运行 `kubectl apply`
    将秘密部署到集群中，然后让 GitOps 运营商部署其他所有内容。
- en: '![](Images/CH07_F03_Yuen.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH07_F03_Yuen.png)'
- en: Figure 7.3 With out-of-band management, GitOps is used to deploy normal resources.
    But some other mechanism (such as manual `kubectl` `apply`) is used to deploy
    the Secret.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 在非带管理中，GitOps 用于部署常规资源。但使用某种其他机制（如手动 `kubectl apply`）来部署秘密。
- en: 'The obvious disadvantage of this approach is that you would need to have two
    different mechanisms for deploying resources to the cluster: one for normal Kubernetes
    resources via GitOps and another strictly for Secrets.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的明显缺点是，你需要有两种不同的机制来将资源部署到集群中：一种是通过 GitOps 部署常规 Kubernetes 资源，另一种专门用于部署秘密。
- en: 7.3.4 External Secrets management systems
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.4 外部秘密管理系统
- en: Another strategy for dealing with Secrets in GitOps is to use an external Secret
    management system *other than* Kubernetes. In this strategy, rather than using
    the native Kubernetes features to store and load Secrets into the container, the
    application containers themselves retrieve the Secret values dynamically at run-time,
    at the point of use.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在GitOps中处理密钥的另一种策略是使用除Kubernetes之外的外部密钥管理系统。在这种策略中，而不是使用Kubernetes的本地功能将密钥存储和加载到容器中，应用程序容器本身在运行时、使用点动态检索密钥值。
- en: A variety of Secret management systems exist, but the most popular and widely
    used one is HashiCorp Vault, which is the tool that we will primarily focus on
    when discussing external Secret management systems. Individual cloud providers
    also provide their own Secret management services such as AWS Secrets Manager,
    Google Cloud Secret Manager, and Microsoft Azure Key Vault. The tools may differ
    in capabilities and feature sets, but the general principles are the same and
    should be applicable to all.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 存在着各种密钥管理系统，但最流行和最广泛使用的是HashiCorp Vault，这是我们讨论外部密钥管理系统时将主要关注的工具。各个云服务提供商也提供了自己的密钥管理服务，例如AWS
    Secrets Manager、Google Cloud Secret Manager和Microsoft Azure Key Vault。这些工具在功能和特性集上可能有所不同，但基本原则是相同的，并且应该适用于所有情况。
- en: '![](Images/CH07_F04_Yuen.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH07_F04_Yuen.png)'
- en: Figure 7.4 Retrieval of a Secret from an external Secret store. In this approach,
    sensitive data is not stored as Kubernetes Secrets. Instead, it is stored in an
    external system, which would be retrieved by a container at run-time (such as
    via an API call).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 从外部密钥存储检索密钥。在这种方法中，敏感数据不是作为Kubernetes密钥存储的。相反，它存储在外部系统中，该系统将在运行时由容器检索（例如通过API调用）。
- en: By choosing to use an external Secret management system (such as Vault) to manage
    your Secrets, you are also effectively making a decision not to use Kubernetes
    Secrets. This is because when using this strategy, you are relying on the external
    secret management system to store and retrieve your Secrets, and not Kubernetes.
    A large consequence is that you also would not be able to leverage some of the
    conveniences that Kubernetes Secrets provide, such as setting the value of an
    environment variable from a Secret or mapping the Secret as files in a volume.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择使用外部密钥管理系统（如Vault）来管理您的密钥，您实际上是在做出一个决定，即不使用Kubernetes密钥。这是因为当使用这种策略时，您依赖于外部密钥管理系统来存储和检索您的密钥，而不是Kubernetes。一个重要的后果是，您也无法利用Kubernetes密钥提供的一些便利，例如从密钥设置环境变量的值或将密钥映射为卷中的文件。
- en: When using an external Secret store, it is the responsibility of the application
    to retrieve the Secrets from the store securely. For example, when the application
    starts, it could dynamically retrieve the Secret values from the Secret store
    at run-time, as opposed to using the Kubernetes mechanisms (environment variables,
    volume mounts, and so on). This shifts the burden of safekeeping of Secrets to
    both the application developers who must retrieve the Secret safely and administrators
    of the external Secret store.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用外部密钥存储时，应用程序有责任安全地从存储中检索密钥。例如，当应用程序启动时，它可以在运行时动态地从密钥存储中检索密钥值，而不是使用Kubernetes机制（环境变量、卷挂载等）。这把保管密钥的责任转移给了必须安全检索密钥的应用程序开发人员和外部密钥存储的管理员。
- en: Another consequence of this technique is that because Secrets are managed in
    a separate database, you do not have the same history/record of when Secrets were
    changed as you do for your configuration managed in Git. This could even affect
    your ability to roll back in a predictable manner. For example, during a rollback,
    applying the manifests at the previous Git commit might not be enough. You would
    additionally have to roll back the Secret to a previous value at the same time
    of the Git commit. Depending on what Secret store was used, this might be inconvenient
    in the best case, or downright impossible in the worst.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术的另一个后果是，由于密钥是在单独的数据库中管理的，因此您无法像Git中管理的配置那样拥有密钥更改的历史/记录。这甚至可能影响您以可预测的方式回滚的能力。例如，在回滚过程中，应用上一个Git提交的清单可能不足以完成。您还必须同时回滚密钥到Git提交时的先前值。根据所使用的密钥存储，这可能在最好情况下不方便，在最坏情况下甚至不可能。
- en: 7.3.5 Encrypting Secrets in Git
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.5 在Git中加密密钥
- en: Since Git is considered unsafe for storing plain-text Secrets, one strategy
    is to encrypt the sensitive data so that it *is* safe to store in Git and then
    decrypt the encrypted data closer to its point of use. The actor performing the
    decryption would have to have the necessary keys to decrypt the encrypted Secret.
    This might be the application itself, an init container that populates a volume
    used by the application, or a controller to handle these tasks for the application
    seamlessly.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '由于Git被认为不适合存储纯文本Secrets，一种策略是加密敏感数据，使其在Git中存储是安全的，然后在接近使用点的地方解密加密数据。执行解密的操作者必须拥有解密加密Secret所需的密钥。这可能是由应用程序本身、填充应用程序使用的卷的init容器，或者是一个控制器，以无缝地处理这些任务。 '
- en: '![](Images/CH07_F05_Yuen.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH07_F05_Yuen.png)'
- en: Figure 7.5 Secrets are encrypted and safely stored in Git alongside other Kubernetes
    resources. At run-time, the application can decrypt the contents before using.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 Secrets与其他Kubernetes资源一起在Git中加密并安全存储。在运行时，应用程序可以在使用之前解密内容。
- en: One popular tool that aids in this technique of encrypting Secrets in Git is
    Bitnami SealedSecrets, which we will cover in depth later in this chapter.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一个流行的工具，有助于在Git中加密Secrets的技术是Bitnami SealedSecrets，我们将在本章后面详细讨论。
- en: The challenges of encrypting Secrets in Git is that there still is one last
    Secret involved, and that is the encryption key used to encrypt those Secrets.
    Without adequate protection of the encryption key, this technique is meaningless,
    as anyone with access to the encryption key now has the ability to decrypt and
    gain access to the sensitive data in the manifests.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Git中加密Secrets的挑战在于，仍然涉及一个最后的Secret，那就是用于加密这些Secrets的加密密钥。如果没有对加密密钥的充分保护，这种技术就毫无意义，因为任何能够访问加密密钥的人现在都有能力解密并获取清单中的敏感数据。
- en: 7.3.6 Comparison of strategies
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.6 策略比较
- en: There are many different approaches to managing Secrets in Kubernetes, each
    with trade-offs. Consider the following advantages and disadvantages before deciding
    on a solution and/or tool that fits your needs.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes中管理Secrets有许多不同的方法，每种方法都有其权衡。在决定适合您需求的解决方案和/或工具之前，请考虑以下优点和缺点。
- en: Table 7.2 GitOps Secrets management strategies
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.2 GitOps Secrets管理策略
- en: '| Type | Advantages | Disadvantages |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 优点 | 缺点 |'
- en: '| Store in Git | Simple and convenientSecrets and configuration are managed
    in the same place (Git) | Completely insecure |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 存储在Git中 | 简单方便Secrets和配置在同一个地方（Git）管理 | 完全不安全 |'
- en: '| Bake into image | Simple and convenient | Container images are sensitive.Rotating
    Secrets requires rebuilding.Images are not portable.Secrets are not sharable across
    Pods. |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 将其嵌入到镜像中 | 简单方便 | 容器镜像敏感。轮换Secrets需要重新构建镜像。镜像不可移植。Secrets不能在Pod之间共享。 |'
- en: '| Out-of-band management | Still able to leverage native Kubernetes Secrets
    faculties (such as volume mounts andenvironment variables) | Different processes
    for deploying Secrets and configModifications to Secrets are not recorded in Git
    history, possibly affecting the ability to roll back. |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 离线管理 | 仍然能够利用原生Kubernetes Secrets功能（如卷挂载和环境变量） | 部署Secrets和配置修改到Secrets的过程不同，Git历史记录中未记录，可能会影响回滚的能力。
    |'
- en: 7.4 Tooling
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.4 工具
- en: Both within and outside the Kubernetes ecosystem, numerous projects have emerged
    to help users deal with the problem of Secrets. All of the projects use one of
    the strategies to Secret management discussed previously. In this section, we
    cover some of the more popular tools that can complement a Kubernetes environment
    with a GitOps-focused approach.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes生态系统内外，已经出现了许多项目来帮助用户解决Secrets的问题。所有这些项目都使用之前讨论过的Secret管理策略之一。在本节中，我们将介绍一些更受欢迎的工具，这些工具可以通过GitOps方法补充Kubernetes环境。
- en: 7.4.1 HashiCorp Vault
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.1 HashiCorp Vault
- en: Vault, by HashiCorp, is a purpose built, open source tool for storing and managing
    Secrets in a secure manner. Vault provides a CLI and a UI, as well as an API for
    programmatic access to the Secret data. Vault is not specific to Kubernetes and
    is popular as a standalone Secret management system.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: HashiCorp的Vault是一个专为以安全方式存储和管理Secrets而构建的开源工具。Vault提供命令行界面（CLI）、用户界面（UI）以及用于以编程方式访问Secret数据的API。Vault不仅限于Kubernetes，并且作为独立的Secret管理系统而广受欢迎。
- en: Vault installation and setup
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Vault安装和设置
- en: 'There are many ways to install and run Vault. But if you are new to Vault,
    the recommended and easiest way to get started is to install Vault using the official
    Helm chart maintained by HashiCorp. For the purposes of simplifying our tutorial,
    we will be installing Vault in dev mode, which is meant for experimentation, development,
    and testing. Additionally, the command also installs the Vault Agent Sidecar Injector,
    which we will cover and use in the following section:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 安装和运行Vault有许多方法。但如果你是Vault的新手，推荐且最简单的方法是使用由HashiCorp维护的官方Helm图表安装Vault。为了简化我们的教程，我们将以开发模式安装Vault，这种模式适用于实验、开发和测试。此外，该命令还安装了Vault
    Agent Sidecar Injector，我们将在下一节中介绍并使用：
- en: '[PRE6]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Non-Kubernetes installation Note that it is not necessary to run Vault in a
    Kubernetes environment. Vault is a general purpose Secret management system, useful
    for applications and platforms other than Kubernetes. Many enterprises choose
    to run a centrally managed Vault instance for their company, so a single Vault
    instance can service multiple Kubernetes clusters and virtual machines, as well
    as be accessed by developers and operators from the corporate network and workstations.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 非Kubernetes安装注意：在Kubernetes环境中运行Vault并非必需。Vault是一个通用的密钥管理系统，适用于Kubernetes以外的应用程序和平台。许多企业选择为公司运行一个集中管理的Vault实例，因此单个Vault实例可以为多个Kubernetes集群和虚拟机提供服务，同时也可以被来自企业网络和工作站的开发人员和运维人员访问。
- en: 'The Vault CLI can be downloaded from [https://www.vaultproject.io/downloads](https://www.vaultproject.io/downloads)
    or (for macOS) by using the `brew` package manager:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Vault CLI可以从[https://www.vaultproject.io/downloads](https://www.vaultproject.io/downloads)下载，或者（对于macOS）通过使用`brew`软件包管理器：
- en: '[PRE7]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once installed, Vault can be accessed through standard port forwarding, and
    visiting the UI at http://localhost:8200:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，Vault可以通过标准端口转发访问，并访问http://localhost:8200的UI：
- en: '[PRE8]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Vault use
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Vault使用
- en: 'Once Vault is installed in your cluster, it’s time to store your first Secret
    in Vault:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Vault安装到您的集群中，就是时候在Vault中存储您的第一个密钥了：
- en: '[PRE9]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To retrieve the Secret, run the `vault` `kv` `get` command:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索密钥，运行`vault kv get`命令：
- en: '[PRE10]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'By default, `vault` `kv` `get` will print Secrets in a tabular format. While
    this format is presented in an easy-to-read way and is great for humans, it’s
    not as easy to parse via automation and to be consumed by an application. To aid
    in this, Vault provides some additional ways of formatting the output and extracting
    specific fields of the Secret:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`vault kv get`将以表格格式打印密钥。虽然这种格式以易于阅读的方式呈现，并且非常适合人类阅读，但它不太容易通过自动化解析，也不太容易被应用程序消费。为了帮助解决这个问题，Vault提供了一些额外的输出格式化方法和提取密钥特定字段的方法：
- en: '[PRE11]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This makes it easy for the Vault CLI to be used in a startup script, which might
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得Vault CLI在启动脚本中使用变得容易，这可能
- en: Run the `vault` `kv` `get` command to retrieve the value of a Secret.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`vault kv get`命令以检索密钥的值。
- en: Set the Secret value as an environment variable or file.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将密钥值设置为环境变量或文件。
- en: Start the main application, which can now read the Secret from env var or file.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动主应用程序，现在它可以从环境变量或文件中读取密钥。
- en: An example of such a startup script might look like the following.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的启动脚本可能看起来如下所示。
- en: Listing 7.6 vault-startup.sh
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.6 vault-startup.sh
- en: '[PRE12]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To integrate this with a Kubernetes application, this startup script would be
    used as the entry point to the container, replacing the normal application command
    with the startup script, which starts the application *after* the Secret has been
    retrieved and set to an environment variable.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要将其与Kubernetes应用程序集成，此启动脚本将用作容器的入口点，用启动脚本替换正常的应用程序命令，启动脚本会在密钥被检索并设置为环境变量之后启动应用程序**之后**。
- en: One thing to notice about this approach is that the `vault` `kv` `get` command
    *itself* needs privileges to access Vault. So for this script to work, `vault`
    `kv` `get` needs to securely communicate with the Vault server, typically using
    a Vault token. Another way of saying this is that you still need a Secret to get
    more Secrets. This presents a chicken-and-egg problem, where you now need to somehow
    securely configure and store the Vault secret needed to retrieve the application
    Secrets. The solution lies in a Kubernetes-Vault integration, which we will cover
    in the next section.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这种方法需要注意的一点是，`vault` `kv` `get` 命令*本身*需要权限来访问 Vault。因此，为了使此脚本工作，`vault` `kv`
    `get` 需要安全地与 Vault 服务器通信，通常使用 Vault 令牌。另一种说法是，您仍然需要一个机密来获取更多机密。这提出了一个“先有鸡还是先有蛋”的问题，即您现在需要以某种方式安全地配置和存储用于检索应用程序机密的
    Vault 机密。解决方案在于 Kubernetes-Vault 集成，我们将在下一节中介绍。
- en: 7.4.2 Vault Agent Sidecar Injector
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.2 Vault Agent 侧边注入器
- en: Due to Vault’s popularity, many Vault and Kubernetes integrations have been
    created to make it easier to use. The official Kubernetes integration, developed
    and supported by HashiCorp, is the Vault Agent Sidecar Injector.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Vault 的流行，已经创建了众多 Vault 和 Kubernetes 集成，以使其更容易使用。由 HashiCorp 开发并支持的官方 Kubernetes
    集成是 Vault Agent 侧边注入器。
- en: 'As explained in the previous section, for an application to retrieve Secrets
    from Vault, a specialized script was used, which performed some prerequisite steps
    before launching the application. This involved retrieving and preparing the application
    Secrets. There were a few problems with that approach:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如前节所述，为了从 Vault 中检索机密，使用了专门的脚本，该脚本在启动应用程序之前执行了一些先决步骤。这包括检索和准备应用程序的机密。这种方法存在一些问题：
- en: Although application Secret(s) were retrieved in a secure manner, the technique
    still needed to deal with protecting the Vault Secret used to access the application
    Secrets.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管以安全的方式检索了应用程序机密，但该技术仍需要处理保护用于访问应用程序机密的 Vault 机密。
- en: The container needed to be Vault aware, in the sense that the container needed
    to be built with a specialized script that understood how to retrieve a specific
    Vault Secret and pass it to the application.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器需要是 Vault 意识的，也就是说，容器需要使用一个专门的脚本构建，该脚本了解如何检索特定的 Vault 机密并将其传递给应用程序。
- en: To solve this problem, HashiCorp developed the Vault Agent Sidecar Injector,
    which solves these two problems in a generic way. The Vault Agent Sidecar Injector
    automatically modifies Pods that are annotated a specific way, and securely retrieves
    annotated Secret references (application Secrets) and renders those values into
    a shared volume accessible to the application container. By rendering Secrets
    to a shared volume, containers within the Pod can consume Vault Secrets without
    being Vault aware.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，HashiCorp 开发了 Vault Agent 侧边注入器，以通用方式解决了这两个问题。Vault Agent 侧边注入器自动修改以特定方式注释的
    Pods，并安全地检索注释的机密引用（应用程序机密）并将这些值渲染到应用程序容器可访问的共享卷中。通过将机密渲染到共享卷中，Pod 内的容器可以在不了解 Vault
    的情况下消费 Vault 机密。
- en: How it works
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 工作原理
- en: The Vault Agent Injector alters Pod specifications to include Vault Agent containers
    that populate Vault Secrets to a shared memory volume accessible to the application.
    To achieve this, you use a feature in Kubernetes called mutating admission webhooks.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Vault Agent 注入器修改 Pod 规范以包含 Vault Agent 容器，这些容器将 Vault 机密填充到应用程序可访问的共享内存卷中。为了实现这一点，您使用
    Kubernetes 中的一个功能，称为修改性准入网关。
- en: Mutating admission webhooks Mutating admission webhooks are one of the many
    ways to extend the Kubernetes API server with additional functionality. Mutating
    webhooks are implemented as HTTP callbacks, which intercept admission requests
    (create, update, patch requests) and modify the object in some way.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 修改性准入网关修改性准入网关是扩展 Kubernetes API 服务器以添加额外功能的方式之一。修改性网关作为 HTTP 回调实现，它拦截准入请求（创建、更新、补丁请求）并以某种方式修改对象。
- en: Figure 7.6 explains how the Vault Agent Injector works.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 解释了 Vault Agent 注入器的工作原理。
- en: '![](Images/CH07_F06_Yuen.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH07_F06_Yuen.png)'
- en: Figure 7.6 A Pod is created normally but has special annotations that are understood
    by the Vault Agent Sidecar Injector. Based on the annotations, a directory containing
    the desired Secrets will be mounted into the container for use by the application.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 正常创建了一个 Pod，但它具有 Vault Agent 侧边注入器可以理解的特殊注释。根据这些注释，包含所需机密的目录将被挂载到容器中，以便应用程序使用。
- en: 'The series of steps involved in this approach are as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种方法涉及的一系列步骤如下：
- en: A workload resource (Deployment, Job, ReplicaSet, and so on) is deployed to
    the cluster. This eventually creates a Kubernetes Pod.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将工作负载资源（Deployment、Job、ReplicaSet 等）部署到集群中。这最终会创建一个 Kubernetes Pod。
- en: As the Pod is being created, the Kubernetes API server invokes a mutating webhook
    call to the Vault Agent Sidecar Injector. The Vault Agent Sidecar Injector modifies
    the Pod by injecting an init container to the Pod (and, optionally, a sidecar).
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随着 Pod 的创建，Kubernetes API 服务器调用 Vault Agent Sidecar Injector 的修改 webhook 调用。Vault
    Agent Sidecar Injector 通过向 Pod 注入一个 init 容器（以及可选的 sidecar）来修改 Pod。
- en: When the Vault Agent Init Container runs, it securely communicates with Vault
    to retrieve the Secret.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 Vault Agent Init 容器运行时，它会安全地与 Vault 通信以检索 Secret。
- en: The Secret is written to a shared memory volume, which is shared between the
    init container and the application container.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Secret 被写入共享内存卷，该卷由 init 容器和应用容器共享。
- en: When the application container runs, it is now able to retrieve the Secret from
    the shared memory volume.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当应用容器运行时，它现在能够从共享内存卷中检索 Secret。
- en: Vault Agent Sidecar Injector installation and setup
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Vault Agent Sidecar Injector 安装和设置
- en: 'Earlier in the chapter, we describe how to install Vault using the official
    Helm chart. This chart also includes the Agent Sidecar Injector. The instructions
    are repeated here. Note that the examples assume your current kubectl context
    is pointing at the default Namespace:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面的部分，我们描述了如何使用官方 Helm 图表安装 Vault。此图表还包括 Agent Sidecar Injector。以下重复了这些说明。请注意，示例假设您的当前
    kubectl 上下文指向默认命名空间：
- en: '[PRE13]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Use
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: When an application desires to retrieve its Secrets from Vault, the Pod spec
    needs to have at a minimum the following Vault agent annotations.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序希望从 Vault 中检索其 Secrets 时，Pod 规范至少需要包含以下 Vault 代理注解。
- en: Listing 7.7 vault-agent-inject-annotations.yaml
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.7 vault-agent-inject-annotations.yaml
- en: '[PRE14]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Breaking this down, these annotations convey several pieces of information:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 分解来看，这些注解传达了几个信息点：
- en: The annotation key `vault.hashicorp.com/agent-inject:` `"true"` informs the
    Vault Agent Sidecar Injector that Vault Secret injection should occur for this
    Pod.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注解键 `vault.hashicorp.com/agent-inject:` `"true"` 通知 Vault Agent Sidecar Injector，对于这个
    Pod 应该进行 Vault 秘密注入。
- en: The annotation value `secret/hello` indicates which Vault Secret key to inject
    into the Pod.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注解值 `secret/hello` 指示要将哪个 Vault 秘密键注入到 Pod 中。
- en: The suffix `hello.txt` of the annotation, `vault.hashicorp.com/agent-inject-secret-hello.txt`,
    indicates that the Secret should be populated under a file named hello.txt in
    the shared memory volume with the final path being /vault/secrets/hello.txt.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注解 `vault.hashicorp.com/agent-inject-secret-hello.txt` 的后缀 `hello.txt` 指示在共享内存卷中应该在一个名为
    hello.txt 的文件下填充 Secret，最终路径为 /vault/secrets/hello.txt。
- en: The annotation value from the `vault.hashicorp.com/role` indicates which Vault
    role should be used when retrieving the Secret.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自 `vault.hashicorp.com/role` 的注解值指示在检索 Secret 时应使用哪个 Vault 角色。
- en: 'Now let’s try with a real example. To run all the Vault commands in this tutorial,
    you will need to first gain console access inside Vault. Run `kubectl` `exec`
    to access the interactive console of the Vault server:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们用一个真实示例来尝试。要运行本教程中的所有 Vault 命令，您首先需要获取 Vault 内部的控制台访问权限。运行 `kubectl exec`
    以访问 Vault 服务器的交互式控制台：
- en: '[PRE15]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you haven’t already, follow the earlier guide on creating your first Secret
    named “hello” in Vault:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有这样做，请遵循之前关于在 Vault 中创建第一个名为“hello”的 Secret 的指南：
- en: '[PRE16]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, we need to configure Vault to allow Kubernetes Pods to authenticate and
    retrieve Secrets. To do so, run the following Vault commands to enable the Kubernetes
    `auth` method:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要配置 Vault 以允许 Kubernetes Pods 进行身份验证并检索 Secrets。为此，运行以下 Vault 命令以启用 Kubernetes
    `auth` 方法：
- en: '[PRE17]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: These two commands configure Vault to use the Kubernetes authentication method
    to use the service account token, the location of the Kubernetes host, and its
    certificate.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个命令配置 Vault 使用 Kubernetes 认证方法，使用服务账户令牌、Kubernetes 主机的位置及其证书。
- en: 'Next, we define a policy named “app,” as well as a role named “app,” which
    will have read privileges to the “hello” Secret:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个名为“app”的策略以及一个名为“app”的角色，该角色将具有对“hello”Secret 的读取权限：
- en: '[PRE18]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now it’s time to deploy a Pod that will automatically get our injected Vault
    Secret. Apply the following Deployment manifest, which has the Vault annotations
    we described earlier on the Pod.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候部署一个 Pod，该 Pod 将自动获取我们注入的 Vault Secret。应用以下 Deployment 清单，其中包含我们在 Pod 上描述的
    Vault 注解。
- en: Listing 7.8 vault-agent-inject-example.yaml
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.8 vault-agent-inject-example.yaml
- en: '[PRE19]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When the deployment is up and running, we can access the console of the Pod
    and verify that the Pod does indeed have the Secret mounted in it:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当部署运行时，我们可以访问 Pod 的控制台并验证 Pod 确实已经将 Secret 挂载在其中：
- en: '[PRE20]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Aso you can see, using the Vault Agent Sidecar Injector is one of the easiest
    ways to get Vault Secrets seamlessly into your Pods in a secure manner.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，使用 Vault Agent Sidecar Injector 是将 Vault Secrets 无缝安全地注入到你的 Pods 中的最简单方法之一。
- en: 7.4.3 Sealed Secrets
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.3 Sealed Secrets
- en: Sealed Secrets, by Bitnami, is another solution to the GitOps Secret problem
    and aptly describes the problem as “I can manage all my K8s config in Git, except
    Secrets.” While not the only tool, currently Sealed Secrets is the most popular
    and widely used tool for teams who would prefer to encrypt their Secrets in Git.
    This allows everything, including Secrets, to be completely and wholly managed
    in Git.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Sealed Secrets，由 Bitnami 提供，是 GitOps Secret 问题的另一种解决方案，并恰当地描述了问题为“我可以管理我在 Git
    中的所有 K8s 配置，除了 Secrets。”虽然不是唯一的工具，但目前 Sealed Secrets 是那些更愿意在 Git 中加密他们的 Secrets
    的团队中最受欢迎和最广泛使用的工具。这允许包括 Secrets 在内的一切都可以在 Git 中完全和彻底地管理。
- en: Sealed Secrets follows the strategy of encrypting the sensitive data so that
    it can be safely stored in Git, and decrypting it inside the cluster. What makes
    it unique is that it provides a controller and command-line interface, which help
    automate this process.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Sealed Secrets 采用加密敏感数据以安全存储在 Git 中的策略，并在集群内部解密。使其独特的是，它提供了一个控制器和命令行界面，有助于自动化此过程。
- en: How it works
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'Sealed Secrets consists of the following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Sealed Secrets 由以下内容组成：
- en: A new CustomResourceDefinition, called a SealedSecret, which will produce a
    normal Secret
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个新的 CustomResourceDefinition，称为 SealedSecret，它将生成一个正常的 Secret
- en: A controller that runs in the cluster responsible for decrypting a SealedSecret,
    and produces a normal Kubernetes Secret with the decrypted data
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个在集群中运行的控制器，负责解密 SealedSecret，并生成一个包含解密数据的正常 Kubernetes Secret
- en: A command-line tool, kubeseal, which encrypts sensitive data into a SealedSecret
    for safe storage in Git
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个命令行工具，kubeseal，它将敏感数据加密到 SealedSecret 中，以在 Git 中安全存储
- en: When a user wishes to manage a Secret using Git, they will seal or encrypt the
    Secret into a SealedSecret custom resource using the kubeseal CLI, which they
    will store in Git alongside other application resources (Deployments, ConfigMaps,
    and so on). The SealedSecret is deployed like any other Kubernetes resource.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户希望使用 Git 管理一个 Secret 时，他们将通过 kubeseal CLI 将 Secret 封装或加密为 SealedSecret 自定义资源，并将其存储在
    Git 中，与其他应用程序资源（Deployments、ConfigMaps 等）一起。SealedSecret 的部署就像任何其他 Kubernetes
    资源一样。
- en: When a SealedSecret is deployed, the `sealed-secrets-controller` will decrypt
    the data and produce a normal Kubernetes Secret with the same name. At this point,
    there is no difference in the experience with a SealedSecret and a normal Kubernetes
    Secret, since a regular Kubernetes Secret is available to be used by Pods.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个 SealedSecret 部署时，`sealed-secrets-controller` 将解密数据并生成一个具有相同名称的正常 Kubernetes
    Secret。此时，与 SealedSecret 和正常 Kubernetes Secret 的体验没有区别，因为常规 Kubernetes Secret
    可供 Pods 使用。
- en: '![](Images/CH07_F07_Yuen.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH07_F07_Yuen.png)'
- en: Figure 7.7 A user will encrypt a Secret into a SealedSecret to store in Git.
    The Sealed Secrets controller decrypts the SealedSecret and formulates a corresponding
    Kubernetes Secret to be used by a Pod using normal Kubernetes faculties.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7 用户将 Secret 加密为 SealedSecret 并存储在 Git 中。Sealed Secrets 控制器解密 SealedSecret，并制定一个相应的
    Kubernetes Secret，供 Pod 使用常规 Kubernetes 功能。
- en: Installation
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 安装
- en: 'CRD and controller:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: CRD 和控制器：
- en: '[PRE21]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Kubeseal CLI:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Kubeseal CLI：
- en: Download the binary from https://github.com/bitnami-labs/sealed-secrets/releases.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 https://github.com/bitnami-labs/sealed-secrets/releases 下载二进制文件。
- en: Use
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: To use SealedSecrets, you first create a regular Kubernetes Secret like you
    normally would using your preferred technique, and place it at some local file
    path. For this simple example, we will use the `kubectl create secret` command
    to create a password Secret. The `--dry-run` flag is used to print the value to
    stdout, which is then redirected to a temporary file. We store it in a temporary
    location, since the Secret containing the unencrypted data should be discarded
    and not persisted in Git (or anywhere else).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 SealedSecrets，你首先创建一个常规 Kubernetes Secret，就像你通常使用你喜欢的技术一样，并将其放置在某个本地文件路径。在这个简单的例子中，我们将使用
    `kubectl create secret` 命令创建一个密码 Secret。`--dry-run` 标志用于将值打印到 stdout，然后重定向到临时文件。我们将其存储在临时位置，因为包含未加密数据的
    Secret 应该被丢弃，不应持久化在 Git（或任何其他地方）。
- en: '[PRE22]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Don’t use kubectl create secret --from-literal The use of `--from-literal` in
    the previous example is only for demo and exercise purposes, and it should never
    be used with any sensitive data. This is because your shell records recently run
    commands into a history file for convenient retrieval. If you wish to use kubectl
    to generate a Secret, consider using `--from-file` instead.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用 kubectl create secret --from-literal 在前面的例子中，使用 `--from-literal` 只是为了演示和练习目的，它永远不应该与任何敏感数据一起使用。这是因为你的
    shell 将最近运行的命令记录到历史文件中，以便方便检索。如果你希望使用 kubectl 生成 Secret，请考虑使用 `--from-file` 代替。
- en: The preceding command will produce the following temporary Kubernetes Secret
    file.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个命令将生成以下临时 Kubernetes Secret 文件。
- en: Listing 7.9 my-password.yaml
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.9 my-password.yaml
- en: '[PRE23]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The next step is to seal or encrypt the temporary Secret using the kubeseal
    CLI. The following command creates a SealedSecret object, based on the temporary
    Secret file that we just created:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使用 kubeseal CLI 对临时 Secret 进行密封或加密。以下命令基于我们刚刚创建的临时 Secret 文件创建一个 SealedSecret
    对象：
- en: '[PRE24]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This will produce the following SealedSecret resource, which can be safely stored
    in Git.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下 SealedSecret 资源，可以安全地存储在 Git 中。
- en: Listing 7.10 my-sealed-password.yaml
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.10 my-sealed-password.yaml
- en: '[PRE25]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The SealedSecret can now be stored alongside your other application manifests
    and deployed like a normal resource without any special treatment.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: SealedSecret 现在可以存储在与你的其他应用程序清单一起，并像正常资源一样部署，无需任何特殊处理。
- en: Sealing Secrets without cluster access By default, kubeseal will encrypt the
    Secret using the certificate of the `sealed-secrets-controller`. To do so, it
    needs access to the Kubernetes cluster to retrieve the certificate directly from
    the `sealed-secrets-controller`. It is possible to seal Secrets offline without
    direct access to the cluster. Alternatively, the certificate could be provided
    using different means, by using the `kubeseal` `--cert` flag, which allows you
    to specify a local path to a certificate or even URL.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 无集群访问权限密封 Secret 默认情况下，kubeseal 将使用 `sealed-secrets-controller` 的证书加密 Secret。为此，它需要访问
    Kubernetes 集群以直接从 `sealed-secrets-controller` 获取证书。可以在不直接访问集群的情况下离线密封 Secret。或者，可以使用不同的方式提供证书，通过使用
    `kubeseal` 的 `--cert` 标志，该标志允许你指定证书的本地路径或甚至 URL。
- en: One thing you might have noticed when comparing the original Kubernetes Secret
    and the SealedSecret is that the SealedSecret has a Namespace specified in the
    metadata, whereas the original Secret does not. This means that the SealedSecret
    is much less portable than the original Secret, since it cannot be deployed in
    different Namespaces. This is actually a security feature of SealedSecrets, in
    what is referred to as a *strict scope*. With a strict scope, SealedSecrets encrypts
    the Secret in such a way that it can only be used for the Namespace that it was
    encrypted for, and also with the exact same Secret name (my-password, in our example).
    This feature prevents an attack where an attacker could deploy a SealedSecret
    to a different Namespace or name that the attacker has privileges to, in order
    to view the sensitive data of the resulting Secret.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当你比较原始 Kubernetes Secret 和 SealedSecret 时，你可能已经注意到，SealedSecret 在元数据中指定了命名空间，而原始
    Secret 没有指定。这意味着 SealedSecret 比原始 Secret 的可移植性要低得多，因为它不能在不同的命名空间中部署。这实际上是 SealedSecret
    的一个安全特性，被称为 *严格范围*。在严格范围内，SealedSecret 以一种方式加密 Secret，使其只能用于加密的命名空间，并且与完全相同的 Secret
    名称（在我们的例子中是 my-password）。这个特性防止了攻击者将 SealedSecret 部署到不同的命名空间或名称，该攻击者有权访问，以查看 Secret
    的敏感数据。
- en: 'In non-multitenant environments, the strict scope can be relaxed so that the
    same SealedSecret can be used in any Namespace in the cluster. To do so, you can
    specify the `--scope cluster-wide` flag during the sealing process:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在非多租户环境中，严格的范围可以被放宽，使得相同的 SealedSecret 可以在集群中的任何命名空间中使用。为此，你可以在密封过程中指定 `--scope
    cluster-wide` 标志：
- en: '[PRE26]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This produces a slightly different cluster-scope SealedSecret, which now no
    longer contains the Namespace.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个略微不同的集群范围 SealedSecret，现在它不再包含命名空间。
- en: Listing 7.11 my-clusterwide-sealed-password.yaml
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.11 my-clusterwide-sealed-password.yaml
- en: '[PRE27]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: One of the consequences of a clusterwide SealedSecret scope is that the SealedSecret
    can now be deployed and decrypted in *any* Namespace of the cluster. This means
    that anyone with privileges to a single Namespace in the cluster can simply deploy
    the SealedSecret in their Namespace for the purposes of viewing the sensitive
    data.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 集群范围内的SealedSecret作用域的一个后果是，SealedSecret现在可以在集群的任何命名空间中部署和解密。这意味着任何拥有集群中单个命名空间权限的人都可以简单地在自己的命名空间中部署SealedSecret，以便查看敏感数据。
- en: One challenge to using SealedSecrets is that the encryption key that is used
    to encrypt the Secrets is different for every cluster. When a `sealed-secrets-controller`
    converts and encrypts a normal Kubernetes Secret into a SealedSecret, that SealedSecret
    object is only valid for the signing controller, and nowhere else. This means
    that there is a different SealedSecret object in Git for every cluster. If you
    are dealing with a single cluster, this challenge may not be an issue for you.
    However, if the same Secret needs to be deployed to more clusters, then this becomes
    a configuration management problem, since the SealedSecret would need to be produced
    for each environment.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SealedSecrets的一个挑战是，用于加密Secrets的加密密钥对于每个集群都是不同的。当`sealed-secrets-controller`将普通Kubernetes
    Secret转换为SealedSecret并加密时，该SealedSecret对象仅对签名控制器有效，其他地方无效。这意味着每个集群在Git中都有一个不同的SealedSecret对象。如果您只处理单个集群，这个挑战可能不会成为问题。然而，如果同一个Secret需要部署到更多集群，那么这就会成为一个配置管理问题，因为需要为每个环境生成SealedSecret。
- en: 'Although it is possible to use the same encryption key for multiple clusters,
    this presents a different challenge: it then becomes difficult to safely distribute,
    manage, and secure that key in all clusters. The encryption key would be distributed
    across many locations, presenting more opportunities for it to become compromised,
    and ultimately allowing an attacker to gain access to every Secret in every cluster.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以为多个集群使用相同的加密密钥，但这会带来不同的挑战：它变得难以在所有集群中安全地分发、管理和保护该密钥。加密密钥将分布到许多位置，提供了更多机会使其被破坏，最终允许攻击者访问每个集群中的每个Secret。
- en: 7.4.4 Kustomize Secret generator plugin
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.4 Kustomize Secret生成插件
- en: Users who are managing their Kubernetes configurations using Kustomize have
    a unique feature available to them, Kustomize plugins, which can be leveraged
    for retrieving Secrets. Kustomize’s plugin feature allows Kustomize to invoke
    user-defined logic to generate or transform Kubernetes resources during the build
    process. Plugins are very powerful, and could be written to retrieve Secrets from
    an external source, such as a database, RPC calls, or even an external Secret
    store such as Vault. The plugin could even be written to perform decryption of
    encrypted data and transform it into a Kubernetes Secret. The important takeaway
    is that Kustomize plugins provide a very flexible mechanism for producing Secrets,
    and can be implemented with any logic that suits your needs.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Kustomize管理Kubernetes配置的用户可以访问一个独特的功能，即Kustomize插件，这些插件可以用于检索Secrets。Kustomize的插件功能允许Kustomize在构建过程中调用用户定义的逻辑来生成或转换Kubernetes资源。插件非常强大，可以编写为从外部源检索Secrets，例如数据库、RPC调用，甚至外部Secret存储库，如Vault。该插件甚至可以编写为执行加密数据的解密并将其转换为Kubernetes
    Secret。重要的是要记住，Kustomize插件提供了一种非常灵活的机制来生成Secrets，并且可以根据您的需求实现任何逻辑。
- en: '![](Images/CH07_F08_Yuen.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH07_F08_Yuen.png)'
- en: Figure 7.8 Instead of storing a Secret in Git, the recipe for formulating or
    retrieving that Secret is stored (as a Kustomize Secret generator). This approach
    implies the rendered Secret will be applied to the cluster immediately after rendering
    (the Kustomize build).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8 与将Secret存储在Git中不同，生成或检索该Secret的配方（作为Kustomize Secret生成器）被存储。这种方法意味着渲染后的Secret将在渲染后立即应用于集群（Kustomize构建）。
- en: How it works
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: As we learned in previous chapters, Kustomize is a configuration management
    tool, and is not normally in the business of managing or retrieving Secrets. But
    by using the plugin functionality of Kustomize, it is possible to inject some
    user-defined logic to generate Kubernetes manifests as part of a `kustomize` `build`
    command. Since `kustomize` `build` is often the last step to occur before the
    actual deployment of the rendered manifests, it is a perfect opportunity to perform
    a secure retrieval of a Secret before it is deployed, and ultimately avoid storing
    Secrets in Git.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的章节中学到的，Kustomize 是一个配置管理工具，通常不涉及管理或检索 Secrets。但是，通过使用 Kustomize 的插件功能，可以在
    `kustomize build` 命令中注入一些用户定义的逻辑来生成 Kubernetes 清单。由于 `kustomize build` 常常是渲染清单实际部署之前发生的最后一步，因此这是一个在部署之前安全检索
    Secret 的完美机会，并最终避免在 Git 中存储 Secrets。
- en: 'Kustomize has two types of plugins: exec plugins and Go plugins. An exec plugin
    is simply an executable that accepts a single command-line argument: the path
    of the plugin YAML configuration file. Also supported are Go plugins, which are
    written in Golang but are more complex to develop. In the following exercise,
    we will be writing an exec plugin, since it is simpler to write and understand.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Kustomize 有两种类型的插件：exec 插件和 Go 插件。exec 插件简单地说是一个可执行文件，它接受单个命令行参数：插件 YAML 配置文件的路径。还支持
    Go 插件，这些插件是用 Golang 编写的，但开发起来更复杂。在接下来的练习中，我们将编写一个 exec 插件，因为它更容易编写和理解。
- en: For this exercise, we will be implementing a Kustomize Secret retriever plugin,
    which will “retrieve” a specific Secret by a key name and generate a Kubernetes
    Secret from it. The word “retrieve” is in quotes because in reality, this example
    will simply pretend to retrieve a Secret, and will use a hardwired value instead.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将实现一个 Kustomize Secret 检索插件，该插件将通过密钥名称“检索”特定的 Secret，并从中生成 Kubernetes
    Secret。这里的“检索”一词加了引号，因为在现实中，这个例子将仅仅假装检索一个 Secret，并使用硬编码的值。
- en: To use a Kustomize generator plugin, we simply reference the plugin configuration
    in kustomization.yaml.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Kustomize 生成器插件，我们只需在 kustomization.yaml 中引用插件配置。
- en: Listing 7.12 kustomization.yaml
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.12 kustomization.yaml
- en: '[PRE28]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The contents of the referenced plugin configuration YAML is specific to the
    plugin. There is no standard for what belongs in a Kustomize plugin manifest specification.
    In this exercise, our plugin specification is very simple and contains only two
    pieces of necessary information:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 引用的插件配置 YAML 的内容特定于插件。Kustomize 插件规范中包含的内容没有标准。在这个练习中，我们的插件规范非常简单，只包含两件必要的信息：
- en: The name of the Kubernetes Secret to create (we will use the same name as the
    plugin configuration name)
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 Kubernetes Secret 的名称（我们将使用与插件配置名称相同的名称）
- en: The key in an external Secret store to retrieve (which the plugin will pretend
    to get)
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要从外部 Secret 存储中检索的密钥（插件将假装获取）
- en: Listing 7.13 my-password.yaml
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.13 my-password.yaml
- en: '[PRE29]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ❶ The apiVersion and kind fields are used by Kustomize to discover which plugin
    to run.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `apiVersion` 和 `kind` 字段被 Kustomize 用于发现要运行哪个插件。
- en: ❷ In this example, the plugin will choose to use the configuration name as the
    resulting K8s Secret name. However, Kustomize plugins are free to ignore metadata.name.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在这个例子中，插件将选择使用配置名称作为生成的 K8s Secret 名称。然而，Kustomize 插件可以自由忽略 `metadata.name`。
- en: ❸ keyName will be the key that will be “retrieved” from the external store.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ `keyName` 将是“从外部存储检索”的密钥。
- en: Finally, we get to the actual plugin implementation, which we will be writing
    as a shell script. This plugin accepts the path of the plugin configuration and
    parses out the Secret name and key to retrieve to generate a final Kubernetes
    Secret to deploy.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们到达实际的插件实现，我们将以 shell 脚本的形式编写它。此插件接受插件配置的路径，解析出 Secret 名称和密钥以生成最终要部署的 Kubernetes
    Secret。
- en: Listing 7.14 gitopsbook/secretretriever/SecretRetriever
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.14 gitopsbook/secretretriever/SecretRetriever
- en: '[PRE30]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ❶ The first argument to a Kustomize plugin is the path to the plugin configuration
    file, referenced in the kustomization.yaml. This line simply grabs its contents.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Kustomize 插件的第一参数是插件配置文件的路径，该路径在 kustomization.yaml 中被引用。这一行只是简单地获取其内容。
- en: ❷ Parse the plugin config, and use the name of the config as the name of the
    resulting K8s Secret.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 解析插件配置，并使用配置的名称作为生成的 K8s Secret 的名称。
- en: ❸ Parse the keyName from the plugin config, and use it as a key in the K8s Secret.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 从插件配置中解析 `keyName`，并将其用作 K8s Secret 中的密钥。
- en: ❹ For demo purposes, we use a hard-wired value. This would typically be replaced
    with logic that retrieves and/or decrypts Secrets.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 为了演示目的，我们使用一个硬编码的值。这通常会被替换为检索和/或解密秘密的逻辑。
- en: ❺ Kubernetes Secrets need to be Base64 encoded.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ Kubernetes 秘密需要 Base64 编码。
- en: ❻ Print the final Kubernetes Secret to standard out.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 将最终的 Kubernetes 秘密打印到标准输出。
- en: 'This example can also be run from the GitOps resources Git repository:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例也可以从 GitOps 资源 Git 仓库中运行：
- en: '[PRE31]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Using Kustomize plugins, it’s possible to choose virtually any technique to
    generate a Secret, including all of the different strategies mentioned in this
    chapter. This includes retrieving a Secret by a reference, decrypting an encrypted
    Secret in Git, accessing a Secret management system, and so on. The options are
    left to the user to decide which strategy makes the most sense for their situation.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Kustomize 插件，可以选择几乎任何技术来生成秘密，包括本章中提到的所有不同策略。这包括通过引用检索秘密、在 Git 中解密加密的秘密、访问秘密管理系统等。选项留给用户决定哪种策略对他们的情况最有意义。
- en: Summary
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Kubernetes Secrets are simple data structures that allow the separation of the
    configuration of an application from the build artifact.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 秘密是简单的数据结构，允许将应用程序的配置与构建工件分离。
- en: Kubernetes Secrets can be used by Pods in various ways, including volume mounts,
    environment variables, or direct retrieval from the Kubernetes API.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 秘密可以通过多种方式被 Pod 使用，包括卷挂载、环境变量或直接从 Kubernetes API 中检索。
- en: Git is not appropriate for Secrets due to lack of encryption and path-level
    access control.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于缺乏加密和路径级访问控制，Git 不适合用于秘密。
- en: Baking Secrets into the container means the container itself is also sensitive
    and there is no separation of configuration from the build artifact.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将烘焙秘密嵌入容器意味着容器本身也是敏感的，配置与构建工件之间没有分离。
- en: Out-of-band Secret management allows native Kubernetes faculties to be used,
    but results in different mechanisms to manage/deploy Secrets and config.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 离线秘密管理允许使用原生 Kubernetes 功能，但会导致管理/部署秘密和配置的不同机制。
- en: External Secret management allows flexibility, but loses the ability to use
    Kubernetes native Secret faculties.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部秘密管理提供了灵活性，但失去了使用 Kubernetes 原生秘密功能的可能性。
- en: HashiCorp Vault is a secured external Secret store and can be installed using
    `brew`. Vault also provides a CLI vault to manage the Secret in the store. Pods
    on startup can fetch Secrets from the external store using the CLI and scripting.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HashiCorp Vault 是一个安全的外部秘密存储库，可以使用 `brew` 安装。Vault 还提供了一个 CLI 工具 vault 来管理存储中的秘密。Pod
    启动时可以使用 CLI 和脚本从外部存储库检索秘密。
- en: The Vault Agent Sidecar Injector can automate the injection of Secrets into
    the Pods without the CLI and scripting.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vault Agent Sidecar 注入器可以在不使用 CLI 和脚本的情况下自动化将秘密注入到 Pod 中。
- en: Sealed Secrets is a CustomResourceDefinition (CRD) for securing the data in
    Kubernetes Secrets. Sealed Secrets can be installed to the cluster by applying
    the Sealed Secrets manifest. Sealed Secrets comes with a CLI tool, kubeseal, to
    encrypt the data in Kubernetes Secrets.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sealed Secrets 是一个用于保护 Kubernetes 秘密数据的自定义资源定义 (CRD)。Sealed Secrets 可以通过应用 Sealed
    Secrets 清单安装到集群中。Sealed Secrets 随附一个 CLI 工具 kubeseal，用于加密 Kubernetes 秘密中的数据。
- en: The Kustomize Secret generator plugin enables user-defined logic to inject Secrets
    in the manifest during the build process.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kustomize 秘密生成插件允许用户在构建过程中定义逻辑以注入秘密。
