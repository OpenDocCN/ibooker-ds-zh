- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Exploratory coding
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 探索性编码
- en: '**This chapter covers**'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: Understanding how having a fast feedback loop makes you more productive
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解快速反馈循环如何使您更高效
- en: Prototyping to explore our data and develop our understanding
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原型设计以探索我们的数据并加深我们的理解
- en: Starting prototyping with Excel
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Excel 开始原型设计
- en: Continuing prototyping with Node.js and the browser
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继续使用 Node.js 和浏览器进行原型设计
- en: Setting up a *live reload* coding pipeline, where code changes automatically
    flow through to data and visual output
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置一个 *实时重载* 编码管道，其中代码更改会自动流向数据和可视化输出
- en: In this chapter, we’ll use exploratory coding to delve into your data and build
    your knowledge and understanding. We’ll use a small example data set that’s easy
    to understand, but in the real world the need to explore and understand our data
    grows with larger and larger data sets.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用探索性编码深入挖掘您的数据，构建您的知识和理解。我们将使用一个易于理解的小型示例数据集，但在现实世界中，探索和理解我们数据的需求随着数据集的不断扩大而增长。
- en: This chapter is a microcosm of the data-wrangling process. We’ll move through
    acquisition, then exploration and understanding, then analysis, and finally arrive
    at visualization. Our focus here though is on fast prototyping, with an emphasis
    on having a streamlined and effective feedback loop so that we can code quickly
    and see results immediately.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是数据处理过程的缩影。我们将经历获取、探索和理解、分析，最终到达可视化。不过，我们的重点在于快速原型设计，强调拥有一个简化和有效的反馈循环，以便我们可以快速编码并立即看到结果。
- en: The output from the exploration phase of the data-wrangling process is
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 数据处理过程探索阶段的输出
- en: An improved understanding of your data
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对您数据的更深入理解
- en: JavaScript code that’s potentially usable in production
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能在生产中使用的 JavaScript 代码
- en: 5.1 Expanding your toolkit
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 扩展您的工具集
- en: In this chapter we’ll expand our data-wrangling toolkit in a number of ways.
    We’ll use Excel for initial prototyping and visualization. Once we reach the limits
    of Excel, we’ll move to Node.js for exploration and analysis and later still to
    the browser for visualization.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将以多种方式扩展我们的数据处理工具集。我们将使用 Excel 进行初始原型设计和可视化。一旦达到 Excel 的极限，我们将转向 Node.js
    进行探索和分析，然后最终转向浏览器进行可视化。
- en: Our main mental tool for this chapter is the *fast feedback loop*. Having quick
    iterations and reducing the trip around the feedback loop are vital for your productivity.
    In this chapter, I’ll take this idea to the extreme to make a point, so this is
    more extreme than my usual real-world process, but it’s not far off and is similar
    to the way that I normally work.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要心理工具是 *快速反馈循环*。快速迭代和减少反馈循环的往返是提高您生产力的关键。在本章中，我将把这个想法推向极致来说明问题，所以这比我的通常现实世界流程更为极端，但它并不遥远，并且与我通常的工作方式相似。
- en: To streamline our feedback loop, we’ll use *Nodemon* and *live-server*, both
    of which automatically watch and execute our code. This gives us the freedom to
    write code and watch the results as we progress. The list of all tools we’ll use
    in this chapter is in [table 5.1](#table5.1).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化我们的反馈循环，我们将使用 *Nodemon* 和 *live-server*，这两个工具都会自动监视并执行我们的代码。这给了我们编写代码并观察结果进展的自由。我们将在本章中使用的所有工具列表见
    [表 5.1](#table5.1)。
- en: Table 5.1 Tools used in chapter 5
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.1 第 5 章中使用的工具
- en: '| **Platform** | **Tool** | **Used for** |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| **平台** | **工具** | **用途** |'
- en: '| --- | --- | --- |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Excel | Viewer/editor | Viewing and editing the data |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| Excel | 查看器/编辑器 | 查看和编辑数据 |'
- en: '|  | Excel charts | Visualizing the data |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '|  | Excel 图表 | 可视化数据 |'
- en: '|  | Excel formulas | Exploratory coding |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '|  | Excel 公式 | 探索性编码 |'
- en: '| JavaScript | console.log | Not to be underrated, console logging is your
    most important debugging tool. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| JavaScript | console.log | 不要低估，控制台日志是您最重要的调试工具。 |'
- en: '|  | Data-Forge | JavaScript data-wrangling toolkit |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '|  | Data-Forge | JavaScript 数据处理工具包 |'
- en: '| Node.js | Formula.js | Node.js implementation of Excel formulas |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| Node.js | Formula.js | Node.js 实现的 Excel 公式 |'
- en: '|  | Nodemon | Live code reload |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '|  | Nodemon | 实时代码重载 |'
- en: '| Browser | live-server | Simple web server and live code reload |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 浏览器 | live-server | 简单的 Web 服务器和实时代码重载 |'
- en: '|  | Flot | Visualization |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '|  | Flot | 可视化 |'
- en: 5.2 Analyzing car accidents
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 分析交通事故
- en: 'The data theme of this chapter is *Queensland car accidents*. Let’s say that
    we’ve been asked the following question: Are fatal car accidents rising or declining
    in Queensland? We’d like to bring this data into our pipeline, explore it, understand
    it, plot the trend, and forecast into the future.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的数据主题是*昆士兰州车祸*。假设我们被问到以下问题：昆士兰州的致命车祸是上升还是下降？我们希望将此数据引入我们的管道，探索它，理解它，绘制趋势，并预测未来。
- en: Through Excel and later coding, we’ll progress our understanding of the data.
    We’ll create a process for fast iterative coding with almost instant results and
    a visualization that’s automatically updated as we type code or modify data.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Excel和后来的编码，我们将加深对数据的理解。我们将创建一个快速迭代编码的过程，几乎可以立即得到结果，并且当我们在编写代码或修改数据时，可视化会自动更新。
- en: 'Our aim is to understand the trend of fatalities in these car accidents and
    forecast either a rise or decline into the future. Spoiler alert: [figure 5.1](#figure5.1)
    shows our end result for this chapter—the simple visualization that we’ll produce
    in the browser.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目的是理解这些车祸中的死亡趋势，并预测未来是上升还是下降。剧透一下：[图5.1](#figure5.1) 展示了本章的最终结果——我们将在浏览器中产生的简单可视化。
- en: '![c05_01.png](Images/c05_01.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![c05_01.png](Images/c05_01.png)'
- en: '[Figure 5.1](#figureanchor5.1) Prototype web visualization showing the trend
    of fatalities over the years 2001 and 2002'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.1](#figureanchor5.1) 展示了2001年和2002年死亡趋势的原型网络可视化'
- en: 5.3 Getting the code and data
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3 获取代码和数据
- en: The data for this chapter was downloaded from the Queensland Government data
    website. The raw data set is large and includes all individual car crashes. To
    make the data easy for you to work with and to keep this chapter simple, I’ve
    summarized the data into monthly buckets. The code and the summarized data are
    available in the Data Wrangling with JavaScript Chapter-5 repository in GitHub
    at [https://github.com/data-wrangling-with-javascript/chapter-5](https://github.com/data-wrangling-with-javascript/chapter-5).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的数据是从昆士兰州政府数据网站下载的。原始数据集很大，包括所有单个车祸。为了使数据易于您使用并使本章保持简单，我已经将数据总结为月度桶。代码和总结后的数据可在GitHub上的Data
    Wrangling with JavaScript Chapter-5存储库中找到，网址为[https://github.com/data-wrangling-with-javascript/chapter-5](https://github.com/data-wrangling-with-javascript/chapter-5)。
- en: 'Because we’re also working in the browser in this chapter, you must install
    Bower dependencies as follows in the root directory of the repository:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在本章中我们也在浏览器中工作，所以你必须按照以下步骤在存储库的根目录中安装Bower依赖项：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As npm is a package manager for Node.js development, Bower is a package manager
    for browser development.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于npm是Node.js开发的包管理器，Bower是浏览器开发的包管理器。
- en: If you want to play with the full raw data, you can find it at [https://data.qld.gov.au/dataset/crash-data-from-queensland-roads](https://data.qld.gov.au/dataset/crash-data-from-queensland-roads).
    Refer to “Getting the code and data”*in chapter 2 for general help in getting
    the code and data.*
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想玩完整的原始数据，你可以在[https://data.qld.gov.au/dataset/crash-data-from-queensland-roads](https://data.qld.gov.au/dataset/crash-data-from-queensland-roads)找到它。有关获取代码和数据的通用帮助，请参阅第2章中的“获取代码和数据”。
- en: '*## 5.4 Iteration and your feedback loop'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*## 5.4 迭代与你的反馈循环'
- en: The focus of this chapter is on having a fast feedback loop. What exactly is
    this, and why is it important?
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的重点是拥有一个快速的反馈循环。这究竟是什么，为什么它很重要？
- en: Have you ever written a large body of code and then suffered a feeling of dread
    before testing it? Larger bodies of code hide more bugs and are more difficult
    to test. While coding, bugs creep in and hide. The longer we code without feedback,
    the more bugs we accumulate. The process of troubleshooting and debugging our
    code is often time consuming. We can claw back significant amounts of productivity
    by catching bugs at the earliest possible time—in the moments immediately after
    the bug was created.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾经编写了大量代码，然后在测试之前感到恐惧？大量的代码隐藏了更多的错误，并且更难测试。在编码时，错误会悄悄进入并隐藏。我们编码的时间越长，没有反馈，积累的错误就越多。我们调试代码的过程通常很耗时。我们可以在错误被创建后的第一时间抓住错误，从而挽回大量的生产力。
- en: 'We should typically code in a fast loop that extends through many iterations
    ([figure 5.2](#figure5.2)): write code, get feedback, solve problems, and so on.
    Each iteration of the loop must be small, and it must be easy to test the new
    code we’ve written.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常应该编写一个快速循环，通过多次迭代来扩展（[图5.2](#figure5.2)）：编写代码，获取反馈，解决问题等等。循环的每一次迭代都必须很小，并且我们必须能够轻松测试我们编写的新代码。
- en: '![c05_02.eps](Images/c05_02.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![c05_02.eps](Images/c05_02.png)'
- en: '[Figure 5.2](#figureanchor5.2) Exploratory coding is a sequence of iterations
    that drives you toward your goal and helps you stay on target.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5.2](#figureanchor5.2) 探索性编码是一系列迭代，它推动你朝着目标前进，并帮助你保持目标方向。'
- en: It’s the many small iterations that are important. The output of each iteration
    is working code, so we go from working code, to working code, to working code,
    and so on. We don’t allow broken code to move forward in this process. Issues
    are exposed quickly, and bugs don’t accumulate. This sequence of small changes
    and feedback ultimately sums up to a large, but reliable, body of code. It gives
    us confidence that the code will function correctly in production. It’s also rewarding
    and motivating to see our code working continuously throughout this process.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是许多小的迭代。每个迭代的输出都是可工作的代码，所以我们从可工作的代码到可工作的代码，再到可工作的代码，如此循环。我们不允许有错误的代码在这个过程中前进。问题迅速暴露，错误不会累积。这些小变化和反馈的序列最终汇总成大量但可靠的代码。它让我们有信心代码在生产中能正确运行。在整个过程中看到我们的代码持续工作也是令人满意和有动力的。
- en: Anything we can do to reduce the time for an iteration will boost productivity.
    Automation and streamlining will help, and in this chapter, we’ll look at how
    to do that using Nodemon (for Node.js) and live-server (for the browser).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以采取任何措施来减少迭代的时长，这将提高生产力。自动化和流程简化将有所帮助，在本章中，我们将探讨如何使用 Nodemon（用于 Node.js）和
    live-server（用于浏览器）来实现这一点。
- en: 'The feedback loop is all about seeing our code working and having practical
    results as soon as possible. It also helps us stay focused on our goals: in each
    iteration we have a natural opportunity to assess where we are and where we’re
    going. This allows us to hone in on our target and take a more direct route to
    achieving our goals. It prompts us to work around problems and move through roadblocks
    quickly. It helps us put aside distractions and stay on track.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 反馈循环全在于尽快看到我们的代码运行并得到实际结果。它还帮助我们保持对目标的关注：在每次迭代中，我们都有机会自然地评估我们的位置和方向。这使我们能够专注于我们的目标，并采取更直接的途径实现我们的目标。它促使我们解决问题并快速克服障碍。它帮助我们排除干扰并保持进度。
- en: 5.5 A first pass at understanding your data
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.5 对数据理解的第一步
- en: Let me introduce a simple thinking tool that I call the *data understanding
    table*. Let’s fill out this table as we build our understanding of the data. As
    a first pass, we look at the data in a viewer to understand its structure.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我介绍一个简单的思维工具，我称之为“数据理解表”。让我们在构建对数据的理解过程中填写这个表格。作为初步尝试，我们查看数据查看器中的数据以了解其结构。
- en: At the outset, we know nothing about the data, except that we can expect rows
    and columns. Initially, our data understanding table is empty. After working with
    the data, I filled out the table as shown in [table 5.2](#table5.2).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始时，我们对数据一无所知，除了我们可以预期有行和列。最初，我们的数据理解表是空的。在处理数据后，我填写了如表 5.2 所示的表格。
- en: 'Table 5.2 Data understanding table: what we know about the data after viewing
    in Excel'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.2 数据理解表：在 Excel 中查看数据后我们所了解的数据
- en: '| **Columns** | **Data Type** | **Expected Values** | **Description** |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| **列** | **数据类型** | **预期值** | **描述** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Year | Integer | 2001, 2002, and so on | The year when crashes occurred |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| Year | Integer | 2001、2002 等 | 崩溃发生的年份 |'
- en: '| Month | String | January, February, and so on | The month when crashes occurred
    |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| Month | String | 一月、二月等 | 崩溃发生的月份 |'
- en: '| Crashes | Integer | Zero or positive values No negative values | The number
    of crashes that occurred in this year/month |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| Crashes | Integer | 零或正数，没有负数 | 本年/月发生的崩溃次数 |'
- en: '| Fatalities | Integer | Zero or positive values No negative values | The number
    of fatal crashes that occurred in this year/month |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| Fatalities | Integer | 零或正数，没有负数 | 本年/月发生的致命事故次数 |'
- en: '| etc. | etc. | etc. | etc. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| etc. | etc. | etc. | etc. |'
- en: '[Figure 5.3](#figure5.3) shows monthly_crashes_full.csv as viewed in Excel.
    When first looking at this file, we scan the header line and learn the column
    names for our tabular data. Next, we scan the initial rows in the data and make
    an educated guess about the types of data and ranges of values that we can expect.
    We fill out our data understanding table as we learn about our data.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5.3](#figure5.3) 展示了在 Excel 中查看的 monthly_crashes_full.csv。当我们第一次查看这个文件时，我们扫描标题行并了解表格数据的列名。接下来，我们扫描数据中的初始几行，并对我们可以预期的数据类型和值范围做出合理的猜测。我们在了解数据的过程中填写我们的数据理解表。'
- en: '![c05_03.eps](Images/c05_03.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![c05_03.eps](Images/c05_03.png)'
- en: '[Figure 5.3](#figureanchor5.3) Using Excel to develop an initial understanding
    of your data'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5.3](#figureanchor5.3) 使用 Excel 开发对数据的初步理解'
- en: In this rather simple example, we learned almost everything we need to know
    by looking at the data in a viewer. But the rest of the file is under no obligation
    to follow these rules! For this example, the input data is already rather clean.
    In other projects, the data won’t be so well behaved and could have plenty of
    problems! We’ll address this issue in chapter 6.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个相当简单的例子中，我们通过查看查看器中的数据几乎学到了我们需要知道的一切。但文件的其他部分没有义务遵循这些规则！对于这个例子，输入数据已经相当干净。在其他项目中，数据可能不会表现得那么好，可能会有很多问题！我们将在第
    6 章中解决这个问题。
- en: 5.6 Working with a reduced data sample
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.6 处理缩减后的数据样本
- en: When we start working with a data set, it’s often best to begin with a cut-down
    sample. This is especially so when we’re working with a mountain of data, something
    we’ll discuss more in chapters 7 and 8\. A large data set can be unwieldy and
    will bog down our iterations, making us less productive. We should therefore aim
    to prototype using only a small sample of the data. We can develop our understanding
    and code at the same time, and ultimately, when we’re sure that our code is robust
    and reliable, we can scale up to the full data set.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始处理数据集时，通常最好从一个缩减的样本开始。当我们处理大量数据时，这一点尤其如此，我们将在第 7 章和第 8 章中更详细地讨论这一点。大型数据集可能难以处理，会拖慢我们的迭代速度，使我们效率降低。因此，我们应该旨在仅使用数据的一小部分来原型设计。我们可以在同时开发我们的理解和代码，最终，当我们确信我们的代码是健壮和可靠的，我们可以扩展到完整的数据集。
- en: The raw data file downloaded from the Queensland Government was more than 138
    MB. It’s not easy working with such large files. I’ve prepared and aggregated
    that raw data into the file monthly_crashes_full.csv. With the data I’ve prepared
    for you, we’re already working with a smaller data sample in this chapter. The
    monthly_crashes_full.csv file*weighs in at 13 KB. Our data is already small, but
    it doesn’t hurt to cut it down even more. We can do that by loading the data in
    Excel (or a text editor) and removing everything after the first 200 rows.*
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 从昆士兰州政府下载的原始数据文件超过 138 MB。处理这样大的文件并不容易。我已经将原始数据整理并汇总到 monthly_crashes_full.csv
    文件中。使用我为你们准备的数据，我们已经在本章中处理了一个较小的数据样本。monthly_crashes_full.csv 文件*的重量为 13 KB。我们的数据已经很小，但进一步缩减它也无妨。我们可以通过在
    Excel（或文本编辑器）中加载数据并删除前 200 行之后的所有内容来实现这一点。
- en: '*Save the cut-down data as new file monthly_crashes-cut-down.csv. Always be
    careful*not to overwrite your original data! You don’t want to lose your source
    data! We can also use Excel to quickly delete any columns that we don’t need.
    Extraneous data is extra baggage that we don’t need.*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*将缩减后的数据保存为新的文件 monthly_crashes-cut-down.csv。始终要小心*不要覆盖你的原始数据！你不想丢失你的源数据！我们也可以使用
    Excel 快速删除我们不需要的任何列。多余的数据是我们不需要的额外负担。'
- en: '*We’ve cut down the data significantly. The file size of monthly_crashes-cut-down.csv*is
    now around 1 KB. Working with a lightweight data set means we can work quickly,
    and we won’t be slowed down waiting for any process or tools that might be overwhelmed
    by the size of the data.*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们已经显著减少了数据量。文件大小为 monthly_crashes-cut-down.csv* 现在约为 1 KB。使用轻量级数据集意味着我们可以快速工作，而且我们不会因为等待可能被数据量压垮的任何过程或工具而减慢速度。'
- en: '*## 5.7 Prototyping with Excel'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*## 5.7 使用 Excel 进行原型设计'
- en: We start our prototyping and data exploration with Excel. We’re only using Excel
    for quick prototyping before we move to Node.js, which can save time initially.
    We already used it for viewing and cutting down our data. Now let’s use Excel
    to prototype a formula and a visualization.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从使用 Excel 进行原型设计和数据探索开始。我们只在使用 Node.js 之前使用 Excel 进行快速原型设计，这可以节省初始时间。我们已经用它来查看和缩减我们的数据。现在让我们使用
    Excel 来原型设计一个公式和可视化。
- en: 'We’ll create a new Trend column in our data set. Using Excel’s FORECAST function,
    we’ll forecast fatalities based on six months of data. The FORECAST function requires
    `x` and `y` values as input. We already have our `y` values: that’s the existing
    Fatalities column. But we have no obvious column to use as the `x` values, so
    we must generate a new column that’s a sequence of numbers. I’ve called the column
    Month# because it identifies the number of the month in the sequence.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在数据集中创建一个新的趋势列。使用 Excel 的预测函数，我们将根据六个月的数据预测死亡人数。预测函数需要输入 `x` 和 `y` 值。我们已经有我们的
    `y` 值：那就是现有的死亡人数列。但我们没有明显的列可以用作 `x` 值，因此我们必须生成一个新的列，它是一个数字序列。我称这个列为 Month#，因为它标识了序列中月份的编号。
- en: We can create this column in Excel by entering a short sequence (1, 2, 3, 4),
    selecting the sequence, and then dragging it out for the length of the column.
    Excel will extrapolate our number sequence to fill the entire column.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 Excel 中通过输入一个短序列（1, 2, 3, 4），选择该序列，然后将其拖动到列的长度来创建这个列。Excel 将会外推我们的数字序列以填充整个列。
- en: Now we can go ahead and add our new Trend column. Create a new column and enter
    the FORECAST formula after six empty rows, as shown in [figure 5.4](#figure5.4).
    Each row in the Trend column is offset by six rows because it’s computed from
    the previous six months of data.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续添加我们的新趋势列。创建一个新列，在六行空行之后输入预测公式，如图 5.4 所示。趋势列中的每一行都偏移了六行，因为它是由前六个月的数据计算得出的。
- en: '![c05_04.eps](Images/c05_04.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![c05_04.eps](Images/c05_04.png)'
- en: '[Figure 5.4](#figureanchor5.4) Using the FORECAST formula to predict next month’s
    fatalities'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5.4](#figureanchor5.4) 使用预测公式预测下个月的死亡人数'
- en: Now we select the cell with the FORECAST formula and drag it out until the end
    of the Trend. [Figure 5.5](#figure5.5) shows the completed Trend column. Each
    value in the column is the predicted fatalities for that month based on the previous
    six months.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们选择包含预测公式的单元格，并将其拖动到趋势的末尾。[图 5.5](#figure5.5) 展示了完成的趋势列。列中的每个值都是基于前六个月预测的该月死亡人数。
- en: '![c05_05.eps](Images/c05_05.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![c05_05.eps](Images/c05_05.png)'
- en: '[Figure 5.5](#figureanchor5.5) Monthly crashes with addition of the Trend column'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5.5](#figureanchor5.5) 添加趋势列后的月度事故'
- en: We can now use Excel’s charting capabilities to visualize the trend of fatalities
    from car crashes over the period 2001 to 2002, as shown in [figure 5.6](#figure5.6).
    We can see from this graph that fatalities were decreasing through half of the
    period before rising again, and then it looks as though the trend is starting
    to turn around again at the end of the graph.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 Excel 的图表功能来可视化 2001 年至 2002 年期间汽车事故死亡趋势，如图 5.6 所示。从这张图中我们可以看出，在半数期间内死亡人数在下降，然后看起来趋势在图表的末尾又开始逆转。
- en: '![c05_06.png](Images/c05_06.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![c05_06.png](Images/c05_06.png)'
- en: '[Figure 5.6](#figureanchor5.6) Fatal car crashes Trend column visualized in
    an Excel chart'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5.6](#figureanchor5.6) 在 Excel 图表中可视化的致命汽车事故趋势列'
- en: We know so much more about our data already, and we haven’t even touched any
    code yet! This is an extremely fast way to get started with your data and is much
    quicker to go from data to visualization than diving directly into the deep end
    and attempting to produce a web-based visualization. We can do so much more with
    Excel, so we shouldn’t undervalue it. Sometimes it’s all you need.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经对我们的数据有了更多的了解，而且我们甚至还没有接触任何代码！这是一种极快的方式开始你的数据，并且从数据到可视化比直接跳入深水区并尝试制作基于网络的可视化要快得多。我们可以用
    Excel 做很多事情，所以我们不应该低估它。有时，它就是你所需要的全部。
- en: Why turn to code at all? Well, to start with the basics, you may have noticed
    manual preparation of the data was needed when using Excel. We had to drag out
    the Month# and Trend columns, and this kind of thing becomes rather tedious on
    large amounts of data, but we can make short work of it in code. In addition,
    I had to manually tweak the data to produce the nice-looking chart in [figure
    5.6](#figure5.6).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要转向代码呢？首先，你可能已经注意到在使用 Excel 时需要手动准备数据。我们必须拖动月份编号和趋势列，而在大量数据中这类事情变得相当繁琐，但我们可以用代码轻松完成。此外，我还必须手动调整数据以生成图
    5.6 中的漂亮图表。
- en: However, the main reason to turn to code is so that you can scale up and automate
    tedious and laborious data preparation. We also probably want to deliver an interactive
    visualization using the web. Ultimately, we need to have our code run in production.
    We want to run our data analysis code on a Node.js server or display an interactive
    chart in a web browser. Now is the time to move on from Excel and turn our attention
    to exploratory coding using JavaScript.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，转向代码的主要原因是你可以扩展并自动化繁琐且费力的数据准备。我们可能还希望使用网络提供交互式可视化。最终，我们需要让我们的代码在生产环境中运行。我们希望在
    Node.js 服务器上运行我们的数据分析代码或在网络浏览器中显示交互式图表。现在是时候从 Excel 转移注意力，转向使用 JavaScript 进行探索性编码了。
- en: 5.8 Exploratory coding with Node.js
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.8 使用 Node.js 进行探索性编码
- en: As we work toward scaling up and processing large amounts of data, we now move
    to Node.js for exploratory coding. In this section, we’ll take our Excel prototype
    and make it work in Node.js. While doing that, we’ll explore our data with code.
    We can build our understanding of the data and at the same time write useful code.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们努力扩展并处理大量数据的过程中，我们现在转向Node.js进行探索性编码。在这一节中，我们将把我们的Excel原型转换为在Node.js中工作。在这样做的同时，我们将用代码探索我们的数据。我们可以构建我们对数据的理解，同时编写有用的代码。
- en: As we work through this section, we’ll evolve a Node.js script. Because the
    focus of this chapter is on iterative coding, we’ll go through each small step
    of the process by successively upgrading the script until we achieve our objective,
    which is the output of the CSV file with the computed Trend column similar to
    what was shown in [figure 5.5](#figure5.5). You can follow along with the evolving
    script by looking at and running listing-5.1.js, then listing-5.2.js, and so on
    up to listing-5.12.js as we progress through this chapter. The code files are
    available in the GitHub repository.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们通过这一节工作时，我们将逐步发展一个Node.js脚本。由于本章的重点是迭代编码，我们将通过逐步升级脚本的过程来逐步完成每个小步骤，直到我们达到目标，即输出与[图5.5](#figure5.5)中所示类似的计算趋势列的CSV文件。你可以通过查看和运行listing-5.1.js，然后是listing-5.2.js，依此类推，直到listing-5.12.js，随着我们通过这一章的进展来跟随脚本的发展。代码文件可在GitHub仓库中找到。
- en: We’ll reproduce the Trend column that we prototyped in Excel. We’ll run our
    Node.js script from the command line. It will take monthly_crashes-cut-down.csv
    as input and produce a new CSV file called trend_output.csv that contains the
    computed Trend column.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重现我们在Excel中原型化的趋势列。我们将从命令行运行我们的Node.js脚本。它将以monthly_crashes-cut-down.csv作为输入，并产生一个名为trend_output.csv的新CSV文件，其中包含计算出的趋势列。
- en: The important tool that we’ll use here is called Nodemon.*This is a tool (built
    on Node.js) that watches our code and automatically executes it as we work. This
    automates the *run code* part of our feedback loop. Such automation streamlines
    our iterations and allows us to move quickly.*
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里将使用的重要工具称为Nodemon。*这是一个工具（基于Node.js构建），它会监视我们的代码，并在我们工作时自动执行它。这自动化了反馈循环中的*运行代码*部分。这种自动化简化了我们的迭代过程，并使我们能够快速行动。*
- en: '*[Figure 5.7](#figure5.7) shows my basic setup for coding. On the left is my
    code window (using Visual Studio Code). On the right is the command line running
    Nodemon (using ConEmu on Windows). As I edit and save code on the left, I watch
    the code automatically execute on the right. Usually I run this setup on multiple
    monitors on my desktop PC. I often work on my laptop as well, although it’s more
    difficult to pull off the side-by-side layout due to having less screen real estate.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*[图5.7](#figure5.7)展示了我的基本编码设置。左侧是我的代码窗口（使用Visual Studio Code）。右侧是运行Nodemon的命令行（在Windows上使用ConEmu）。当我编辑并保存左侧的代码时，我会看到右侧的代码自动执行。通常我会在我台式机的多个显示器上运行这个设置。我也经常在我的笔记本电脑上工作，尽管由于屏幕空间较小，实现并排布局更困难。*'
- en: '![c05_07.eps](Images/c05_07.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![c05_07.eps](Images/c05_07.png)'
- en: '[Figure 5.7](#figureanchor5.7) Coding on the left, watching output on the right'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.7](#figureanchor5.7) 左侧编码，右侧查看输出'
- en: Nodemon constantly watches the script file for changes. When changes are detected,
    it automatically executes the code and produces new output (this process is illustrated
    in [figure 5.8](#figure5.8)). This allows us to code and watch the result.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Nodemon持续监视脚本文件的变化。当检测到变化时，它会自动执行代码并产生新的输出（这个过程在[图5.8](#figure5.8)中展示）。这使我们能够在编码的同时查看结果。
- en: 5.8.1 Using Nodemon
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.8.1 使用Nodemon
- en: 'Up to now in the book we’ve worked with npm modules that are installed *into*
    our Node.js projects. Nodemon and, soon, live-server are the first tools that
    we’ll install *globally* on our system rather than *locally* in our project. To
    do this, we add the `–g` (global) parameter when we use npm to install. Let’s
    run npm and globally install Nodemon:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本书中，我们一直在使用安装到我们的Node.js项目中的npm模块。Nodemon和很快的live-server是我们将在系统上全局安装而不是在项目中本地安装的第一个工具。为此，我们在使用npm安装时添加`–g`（全局）参数。让我们运行npm并全局安装Nodemon：
- en: '[PRE1]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![c05_08.png](Images/c05_08.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![c05_08.png](Images/c05_08.png)'
- en: '[Figure 5.8](#figureanchor5.8) Nodemon watches your code and executes it automatically
    when you make changes.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.8](#figureanchor5.8) Nodemon监视你的代码，并在你进行更改时自动执行它。'
- en: 'Now we can use Nodemon from the command line in place of Node.js. For example,
    normally you’d run a Node.js script as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用命令行中的Nodemon代替Node.js。例如，通常你会这样运行一个Node.js脚本：
- en: '[PRE2]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We then replace Node.js with Nodemon like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后将Node.js替换为Nodemon，如下所示：
- en: '[PRE3]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Normally when we run Node.js, it will exit once our script runs to completion.
    Nodemon, however, doesn’t exit; instead, it pauses once the script has completed
    and then waits for the script to be modified. When Nodemon detects that the file
    has changed, it executes the code again. This cycle continues until you quit Nodemon
    with Ctrl-C.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，当我们运行 Node.js 时，一旦脚本运行完成，它就会退出。然而，Nodemon 不会退出；相反，一旦脚本完成，它会暂停，然后等待脚本被修改。当
    Nodemon 检测到文件已更改时，它会再次执行代码。这个循环会一直持续到你使用 Ctrl-C 退出 Nodemon。
- en: Now let’s look at our first script file listing-5.1.js that we’ll evolve over
    the course of this section. Our focus here is on the *evolution* of the script.
    We’ll start with something simple (outputting text), and we’ll incrementally evolve
    the code until we arrive at our destination and output the CSV file trend_output.csv.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们的第一个脚本文件 listing-5.1.js，我们将在本节的过程中逐步改进它。我们这里的重点是脚本的*演变*。我们将从一个简单的东西（输出文本）开始，然后逐步改进代码，直到我们到达目的地并输出
    CSV 文件 trend_output.csv。
- en: Listing 5.1 Outputting to the console (listing-5.1.js)
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.1 输出到控制台（listing-5.1.js）
- en: '[PRE4]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[Listing 5.1](#listing5.1) is about as simple as it gets. I believe it’s always
    a good idea to start somewhere simple and then build up to something more complex.
    You can run this code and easily verify that it works.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5.1](#listing5.1) 的代码非常简单。我相信始终从一个简单的地方开始，然后逐步构建到更复杂的东西是一个好主意。你可以运行这段代码，并轻松验证它是否工作。'
- en: I wouldn’t usually start with code *this* simple, but I wanted to start with
    `console.log` because it’s an important tool. The `console.log` function is your
    best friend. We’ve already used it extensively in chapters 3 and 4 to verify our
    data, and we’ll continue to use it throughout the book.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我通常不会从这么简单的代码开始，但我想要从 `console.log` 开始，因为它是一个重要的工具。`console.log` 函数是你的好朋友。我们已经在第
    3 章和第 4 章中广泛使用了它来验证我们的数据，并且我们将在整本书中继续使用它。
- en: 'Now run the script from the command line using Nodemon:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用 Nodemon 从命令行运行脚本：
- en: '[PRE5]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Make sure you’re set up to make code changes and see the output from Nodemon.
    You might want to arrange your editor and output windows side by side, as was
    shown in [figure 5.7](#figure5.7).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你已经设置好环境以便进行代码更改并查看 Nodemon 的输出。你可能需要将编辑器和输出窗口并排排列，就像在[图 5.7](#figure5.7)中展示的那样。
- en: Now change the text `Hello world` to something else, say `Hello data analysis`.
    Nodemon will pick up the change, execute the code, and you should see output similar
    to [figure 5.9](#figure5.9). This simple test allows you to check that your live-reload
    coding pipeline works.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将文本 `Hello world` 改成其他内容，比如 `Hello data analysis`。Nodemon 会检测到这个更改，执行代码，你应该会看到类似于[图
    5.9](#figure5.9)的输出。这个简单的测试让你可以检查你的实时重新加载编码管道是否工作。
- en: '![c05_09.eps](Images/c05_09.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![c05_09.eps](Images/c05_09.png)'
- en: '[Figure 5.9](#figureanchor5.9) Nodemon automatically executes your code as
    you work.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5.9](#figureanchor5.9) Nodemon 会自动在你工作时执行你的代码。'
- en: 5.8.2 Exploring your data
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.8.2 探索你的数据
- en: Let’s do some actual data analysis. First, we’ll load the input CSV file (monthly_crashes-cut-down.csv)
    using our `importCsvFile` toolkit function that we created in chapter 3\. We’ll
    print the content using `console.log`, as shown in the following listing. Run
    this code and check the output on the console.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做一些实际的数据分析。首先，我们将使用我们在第 3 章中创建的 `importCsvFile` 工具函数来加载输入 CSV 文件（monthly_crashes-cut-down.csv）。我们将使用
    `console.log` 打印内容，如下面的列表所示。运行此代码并检查控制台上的输出。
- en: Listing 5.2 Loading your input CSV file and printing its contents to the console
    (listing-5.2.js)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.2 加载你的输入 CSV 文件并将其内容打印到控制台（listing-5.2.js）
- en: '[PRE6]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Printing the data to the console gives us our first look at the data from the
    code’s perspective. Unfortunately, we have too much data here, and our output
    goes offscreen. We’re already working with a cut-down sample of the data, but
    still it’s too much and we want to look at only a few records at a time, as you
    can see in [figure 5.10](#figure5.10).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据打印到控制台让我们从代码的角度首次看到数据。不幸的是，这里的数据太多了，我们的输出超出了屏幕。我们已经在处理一个数据样本的裁剪版本，但仍然太多了，我们只想一次查看几条记录，就像你在[图
    5.10](#figure5.10)中看到的那样。
- en: Let’s now use the JavaScript array `slice` function to chop out a small section
    of the data for inspection. You should run the code in the following listing to
    see the cut-down data sample. This is the code that produced the output shown
    in [figure 5.10](#figure5.10).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用 JavaScript 数组的 `slice` 函数来截取一小部分数据进行检查。你应该运行以下列表中的代码来查看裁剪的数据样本。这是产生[图
    5.10](#figure5.10)中所示输出的代码。
- en: '![c05_10.png](Images/c05_10.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![c05_10.png](Images/c05_10.png)'
- en: '[Figure 5.10](#figureanchor5.10) Instead of being overwhelmed with output,
    we want to look at only a few records at a time.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5.10](#figureanchor5.10) 我们不想被输出淹没，我们只想一次查看几个记录。'
- en: Listing 5.3 Chopping out and printing a small portion of the data for inspection
    (listing-5.3.js)
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.3 切割并打印数据的一部分以进行检查（listing-5.3.js）
- en: '[PRE7]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can also use the `slice` function to extract data from the middle of our
    data by specifying the starting index like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `slice` 函数通过指定起始索引来从数据中间提取数据，如下所示：
- en: '[PRE8]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `slice` function also accepts a negative index to extract data from the
    end of the array. This allows us to peek at the records at the end of the data
    set. For example, let’s use a negative 3 index to look at the final three records
    in the data set:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`slice` 函数还接受一个负索引来从数组的末尾提取数据。这允许我们查看数据集末尾的记录。例如，让我们使用负 3 索引来查看数据集中的最后三个记录：'
- en: '[PRE9]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now let’s dive in and examine the data in more detail. We can look at the output
    (for example, see the output in [figure 5.11](#figure5.11)), and we can check
    against our data understanding table to see if records from the start, middle,
    and end of the data set align with our current understanding of the data. If they
    don’t, you may have to update your data understanding table.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入探讨并更详细地检查数据。我们可以查看输出（例如，参见[图 5.11](#figure5.11)中的输出），并对照我们的数据理解表来查看数据集的开始、中间和结束部分是否与我们对数据的当前理解一致。如果不一致，你可能需要更新你的数据理解表。
- en: Let’s now examine the data types that are present in our data. We can use JavaScript’s
    `typeof` operator to display the type of each field. [Figure 5.11](#figure5.11)
    shows the types for the first record.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查我们数据中存在的数据类型。我们可以使用 JavaScript 的 `typeof` 操作符来显示每个字段的类型。[图 5.11](#figure5.11)显示了第一条记录的类型。
- en: '![c05_11.png](Images/c05_11.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![c05_11.png](Images/c05_11.png)'
- en: '[Figure 5.11](#figureanchor5.11) Examining the types in the first record using
    JavaScript''s `typeof` operator'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5.11](#figureanchor5.11) 使用 JavaScript 的 `typeof` 操作符检查第一条记录中的类型'
- en: The code that produces the output in [figure 5.11](#figure5.11) is shown in
    [listing 5.4](#listing5.4). Look at the first record and use the `typeof` operator
    to check the JavaScript type for each of the fields in the first record. We’re
    starting to verify our assumptions about the data. You can run the following listing,
    and you’ll see the data types that are present in the data set.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 生成[图 5.11](#figure5.11)中输出的代码显示在[列表 5.4](#listing5.4)中。查看第一条记录，并使用 `typeof`
    操作符检查第一条记录中每个字段的 JavaScript 类型。我们开始验证我们对数据的假设。你可以运行以下列表，并会看到数据集中存在的数据类型。
- en: Listing 5.4 Using code to examine your data types (listing-5.4js)
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.4 使用代码检查你的数据类型（listing-5.4js）
- en: '[PRE10]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We’ve checked that the first row of the data meets our initial assumptions and
    that the data types are exactly what we expected. This is only the first row of
    data; however, the rest of the file may not meet your assumptions! It’s worthwhile
    to run a quick check to make sure we don’t run into any problems further down
    the line. In the following listing we’ve modified our script to iterate over *all*
    the data and check each row using the Node.js `assert` function.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经检查了数据的第一行符合我们的初始假设，并且数据类型与我们预期的完全一致。这仅仅是数据的第一行；然而，文件中的其余部分可能不符合你的假设！进行快速检查以确保我们不会在后续遇到任何问题是有价值的。在下面的列表中，我们已经修改了我们的脚本，以便使用
    Node.js 的 `assert` 函数迭代 *所有* 数据并检查每一行。
- en: Listing 5.5 Using assert to check that the data set conforms to your assumptions
    (listing-5.5.js)
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.5 使用 assert 检查数据集是否符合你的假设（listing-5.5.js）
- en: '[PRE11]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can run the code for [listing 5.5](#listing5.5) to validate assumptions,
    which is an important step, but in this case, it doesn’t do much. That’s because
    our data is already clean and well behaved. We’ll revisit assumption checking
    scripts in chapter 6.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以运行[列表 5.5](#listing5.5)中的代码来验证假设，这是一个重要的步骤，但在这种情况下，它并没有做什么。这是因为我们的数据已经干净且表现良好。我们将在第
    6 章中重新访问假设检查脚本。
- en: Our data already conforms to our assumptions, but we couldn’t have known this
    ahead of time. Running a data checking script like this can save us from running
    into problems further down the line. This script will be useful again in the future
    when we scale up to the full data set. It will also be useful in the future if
    you need to accept updated data because we have no guarantee that future data
    we receive will follow the same rules!
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据已经符合我们的假设，但我们事先无法知道这一点。运行这样的数据检查脚本可以防止我们在后续过程中遇到问题。这个脚本在将来当我们扩展到完整数据集时也会很有用。如果需要接受更新的数据，这个脚本也会很有用，因为我们无法保证我们将来收到的数据将遵循相同的规则！
- en: 5.8.3 Using Data-Forge
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.8.3 使用Data-Forge
- en: '![c05_12.tif](Images/c05_12.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![c05_12.tif](Images/c05_12.png)'
- en: '[Figure 5.12](#figureanchor5.12) Using Data-Forge to output column names from
    the CSV file'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.12](#figureanchor5.12) 使用Data-Forge从CSV文件输出列名'
- en: At this point I’d like to introduce Data-Forge, my open source data-wrangling
    toolkit for JavaScript. It’s like a Swiss Army knife for dealing with data and
    has many useful functions and features, especially when it comes to exploring
    our data. We’ll use Data-Forge in this chapter specifically for its `rollingWindow`
    function, which we’ll use to compute our Trend column. We’ll learn more about
    Data-Forge later in the book.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我想介绍Data-Forge，这是我为JavaScript编写的开源数据处理工具包。它就像瑞士军刀一样，用于处理数据，并具有许多有用的函数和功能，尤其是在探索我们的数据时。在本章中，我们将特别使用Data-Forge的`rollingWindow`函数来计算我们的趋势列。我们将在本书的后面部分了解更多关于Data-Forge的信息。
- en: 'If you installed dependencies for the Chapter-5 code repository, you already
    have Data-Forge installed; otherwise, you can install it in a fresh Node.js project
    as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您为第5章代码仓库安装了依赖项，您已经安装了Data-Forge；否则，您可以在一个新的Node.js项目中按照以下步骤安装它：
- en: '[PRE12]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The first thing we’ll do with Data-Forge is to read the CSV file and print the
    column names. The output of this is shown in [figure 5.12](#figure5.12).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Data-Forge做的第一件事是读取CSV文件并打印列名。此输出的显示如[图5.12](#figure5.12)所示。
- en: Data-Forge has a `readFile` function that we use to load our data set. Data-Forge
    can read both JSON and CSV files, so we need to call `parseCSV` to explicitly
    tell Data-Forge to deal with the file as CSV data. Then we call `getColumnNames`
    to retrieve the column names. You can run the code for the following listing,
    and it will print the column names as shown in [figure 5.12](#figure5.12).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Data-Forge有一个`readFile`函数，我们用它来加载数据集。Data-Forge可以读取JSON和CSV文件，因此我们需要调用`parseCSV`来明确告诉Data-Forge将文件作为CSV数据处理。然后我们调用`getColumnNames`来检索列名。您可以运行以下列表的代码，它将打印出如图5.12所示的列名。
- en: Listing 5.6 Using Data-Forge to load the CSV file and list the column names
    (listing-5.6.js)
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.6 使用Data-Forge加载CSV文件并列出列名（listing-5.6.js）
- en: '[PRE13]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When we read the CSV file using Data-Forge, it gives us a DataFrame object that
    contains the data set. DataFrame contains many functions that can slice, dice,
    and transform our data. Let’s extract and display data rows from the start and
    end of the data set using Data-Forge’s `head` and `tail` functions. Data-Forge
    gives nicely formatted output, as shown in [figure 5.13](#figure5.13).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用Data-Forge读取CSV文件时，它给我们一个包含数据集的DataFrame对象。DataFrame包含许多函数，可以对我们的数据进行切片、切块和转换。让我们使用Data-Forge的`head`和`tail`函数从数据集的开始和结束提取并显示数据行。Data-Forge提供了格式良好的输出，如[图5.13](#figure5.13)所示。
- en: '![c05_13.png](Images/c05_13.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![c05_13.png](Images/c05_13.png)'
- en: '[Figure 5.13](#figureanchor5.13) Using Data-Forge to peek at rows at the head
    and tail of the data set'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.13](#figureanchor5.13) 使用Data-Forge查看数据集头部和尾部的行'
- en: '[Listing 5.7](#listing5.7) uses the `head` and `tail` functions to peek into
    our data. Use of these functions produces a new DataFrame object containing only
    the first or last X rows of data. The `toString` function is then used to produce
    the nicely formatted tables shown in [figure 5.13](#figure5.13). You can run this
    code and see the output for yourself.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表5.7](#listing5.7) 使用`head`和`tail`函数查看我们的数据。这些函数的使用会产生一个新的DataFrame对象，其中只包含数据集的前X行或最后X行数据。然后使用`toString`函数生成[图5.13](#figure5.13)中显示的格式良好的表格。您可以运行此代码并亲自查看输出。'
- en: Listing 5.7 Using Data-Forge to peek at rows at the head and tail of the data
    set (listing-5.7.js)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.7 使用Data-Forge查看数据集头部和尾部的行（listing-5.7.js）
- en: '[PRE14]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: One useful thing that Data-Forge does is summarize the types that are in our
    data set. [Figure 5.14](#figure5.14) shows a nicely presented Data-Forge summary
    of the data types.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Data-Forge做的一件有用的事情是总结我们数据集中存在的类型。[图5.14](#figure5.14)显示了格式良好的Data-Forge数据类型总结。
- en: '![c05_14.png](Images/c05_14.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![c05_14.png](Images/c05_14.png)'
- en: '[Figure 5.14](#figureanchor5.14) Using Data-Forge to summarize data types in
    your data set—they’re all strings!'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.14](#figureanchor5.14) 使用Data-Forge总结数据集中的数据类型——它们都是字符串！'
- en: The output in [figure 5.14](#figure5.14) is produced by the Data-Forge function
    `detectTypes,` which scans the data set and produces a new table that shows the
    frequency of different types in our data.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.14](#figure5.14)中的输出是由Data-Forge函数`detectTypes`产生的，它扫描数据集并生成一个新的表格，显示我们数据中不同类型的频率。'
- en: 'You may have noticed in [figure 5.14](#figure5.14) that 100% of our data types
    are strings! Surely, that’s not correct! Previously, when we used our `importCsvFile`
    toolkit function, our data was loaded with the types we expected: Crashes, Fatalities,
    and Hospitalized columns were all numbers. That’s because we used Papa Parse to
    parse the CSV, and we used its automatic type detection.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到[图5.14](#figure5.14)中，我们所有的数据类型都是字符串！这肯定是不正确的！之前，当我们使用我们的`importCsvFile`工具函数时，我们的数据被加载为我们预期的类型：Crashes、Fatalities和Hospitalized列都是数字。这是因为我们使用了Papa
    Parse来解析CSV，并使用了它的自动类型检测。
- en: 'The CSV data format, unlike JSON, doesn’t have any special support for data
    types; every field is just a string. Papa Parse has extra intelligence built in
    that looks at the values to try to figure out what type they *look like*, but
    the CSV data format itself has no built-in understanding of data types, and so
    Data-Forge doesn’t automatically detect them. (Note: You can now enable `dynamicTyping`
    in the latest version of Data-Forge; it uses Papa Parse under the hood.) We must
    explicitly decide how we want our data to be interpreted and instruct Data-Forge
    accordingly using the `parseFloats` function, as shown in [listing 5.8](#listing5.8).'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: CSV数据格式，与JSON不同，没有对数据类型提供任何特殊支持；每个字段只是一个字符串。Papa Parse内置了额外的智能，它会查看值以尝试确定它们*看起来像什么*的类型，但CSV数据格式本身并没有内置对数据类型的理解，因此Data-Forge不会自动检测它们。（注意：现在您可以在Data-Forge的最新版本中启用`dynamicTyping`；它底层使用Papa
    Parse。）我们必须明确决定我们希望如何解释我们的数据，并使用`parseFloats`函数相应地指导Data-Forge，如[列表5.8](#listing5.8)所示。
- en: Listing 5.8 Parsing data types with Data-Forge (listing-5.8.js)
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.8 使用Data-Forge解析数据类型（listing-5.8.js）
- en: '[PRE15]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[Figure 5.15](#figure5.15) shows what our output looks like now after parsing
    the number columns with Data-Forge. All columns are 100% numbers with the exception
    of the Month column.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.15](#figure5.15) 显示了解析数字列后的输出结果。所有列都是100%的数字，除了月份列。'
- en: '![c05_15.png](Images/c05_15.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![c05_15.png](Images/c05_15.png)'
- en: '[Figure 5.15](#figureanchor5.15) After parsing data types with Data-Forge,
    we see the types we expect from the data set.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.15](#figureanchor5.15) 解析数据类型后，我们看到数据集中我们预期的类型。'
- en: 5.8.4 Computing the trend column
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.8.4 计算趋势列
- en: We’ve explored and understood our data. We’ve checked our assumptions about
    the data. It’s now time for the interesting part. We’re going to compute the Trend
    column. I introduced Data-Forge in this chapter not only because it’s good for
    exploring our data, but also because it makes our next task easier.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探索并理解了我们的数据。我们已经检查了关于数据的假设。现在是时候进行有趣的部分了。我们将计算趋势列。我在本章介绍Data-Forge不仅是因为它适合探索我们的数据，还因为它使我们的下一个任务更容易。
- en: The Trend column is computed from the Fatalities column, so we need to extract
    the Fatalities column and run our Excel FORECAST formula on it. This generates
    the Trend column, but then we must plug the column back into the data set and
    save it as the new CSV file trend_output.csv.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 趋势列是从Fatalities列计算出来的，因此我们需要提取Fatalities列并在其上运行我们的Excel FORECAST公式。这生成了趋势列，但然后我们必须将列放回数据集中，并将其保存为新的CSV文件trend_output.csv。
- en: We can start by extracting the Fatalities column and printing it to the console.
    We don’t need to print the entire column, so we use the Data-Forge `head` function
    again to display only the first few rows of data. The output is shown in [figure
    5.16](#figure5.16).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以先提取Fatalities列并将其打印到控制台。我们不需要打印整个列，所以我们再次使用Data-Forge的`head`函数来仅显示数据的前几行。输出结果如[图5.16](#figure5.16)所示。
- en: '![c05_16.png](Images/c05_16.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![c05_16.png](Images/c05_16.png)'
- en: '[Figure 5.16](#figureanchor5.16) First few rows of the Fatalities column extracted
    and displayed using Data-Forge'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.16](#figureanchor5.16) 使用Data-Forge提取并显示的Fatalities列的前几行'
- en: We extract the Trend column from the DataFrame using the `getSeries` function.
    This returns a Data-Forge `Series` object that contains the data from the column.
    The `head` function then extracts the first few rows or data, and we use `toString`
    to format the output nicely for display. You can run [listing 5.9](#listing5.9)
    and you’ll see the same output from [figure 5.16](#figure5.16).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `getSeries` 函数从 DataFrame 中提取趋势列。这返回一个包含该列数据的 Data-Forge `Series` 对象。然后
    `head` 函数提取前几行或数据，我们使用 `toString` 格式化输出，以便于显示。你可以运行 [代码列表 5.9](#listing5.9)，你将看到与图
    5.16 相同的输出。
- en: Listing 5.9 Using Data-Forge to extract and display the first few rows of the
    Fatalities column (listing-5.9.js)
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.9 使用 Data-Forge 提取并显示死亡人数列的前几行（listing-5.9.js）
- en: '[PRE16]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now that we’ve extracted the Fatalities series, we can compute the trend. We
    can easily port Excel formulas to Node.js using the excellent npm module Formula.js.
    If you installed dependencies for the Chapter-5 GitHub repository, you already
    have Formula.js installed. If not, you can install in in a fresh Node.js project
    as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经提取了死亡人数序列，我们可以计算趋势。我们可以轻松地将 Excel 公式移植到 Node.js，使用优秀的 npm 模块 Formula.js。如果你为第
    5 章的 GitHub 仓库安装了依赖项，你已经有 Formula.js。如果没有，你可以在新的 Node.js 项目中安装它，如下所示：
- en: '[PRE17]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Formula.js is a JavaScript implementation of most Excel formula functions. It’s
    convenient for prototyping data analysis in Excel and then reproducing it exactly
    in Node.js.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Formula.js 是 Excel 公式函数的 JavaScript 实现。它方便在 Excel 中原型化数据分析，然后在 Node.js 中精确地重现。
- en: Using Formula.js, we can recreate the FORECAST formula that we prototyped earlier
    in Excel. Our first step is to test the formula on the first six months of data
    and get a single forecasted value, as shown by the output in [figure 5.17](#figure5.17).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Formula.js，我们可以重新创建我们在 Excel 中之前原型化的预测公式。我们的第一步是在前六个月的数据上测试这个公式，并得到一个预测值，如图
    5.17 所示。
- en: '![c05_17.png](Images/c05_17.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![c05_17.png](Images/c05_17.png)'
- en: '[Figure 5.17](#figureanchor5.17) Forecasting fatalities from the first six
    months of data using Formula.js'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5.17](#figureanchor5.17) 使用 Formula.js 从前六个月的数据预测死亡人数'
- en: We extract Month# and Fatalities series from the DataFrame, taking six rows
    of each (for the first six months of data) and using these as input to the `FORECAST`
    function. The code for this is shown in [listing 5.10](#listing5.10). Run this
    code, and it will forecast future fatalities from six months of records and display
    the result shown in [figure 5.17](#figure5.17).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 DataFrame 中提取 Month# 和死亡人数序列，取每个序列的前六行（对于前六个月的数据）并将这些作为 `FORECAST` 函数的输入。这段代码显示在
    [代码列表 5.10](#listing5.10) 中。运行此代码，它将预测未来六个月的死亡人数，并显示图 5.17 中的结果。
- en: Listing 5.10 Using Formula.js to reproduce the Excel FORECAST formula and forecast
    the next month’s fatalities based on the previous six months of data (listing-5.10.js)
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.10 使用 Formula.js 重新生成 Excel 的 FORECAST 公式并基于前六个月的死亡人数预测下个月的死亡人数（listing-5.10.js）
- en: '[PRE18]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We aren’t finished yet, though. We’ve only computed a single forecasted value,
    and you still need to compute the entire Trend column.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们还没有完成。我们只计算了一个预测值，你还需要计算整个趋势列。
- en: In a moment we’re going to cover more ground and Data-Forge is going to do much
    of the heavy lifting. Please don’t worry too much if you have trouble understanding
    what’s going on here; we’ll cover Data-Forge in more detail in later chapters.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的时间里，我们将覆盖更多内容，Data-Forge 将承担大部分繁重的工作。如果你在这里遇到困难，请不要过于担心；我们将在后面的章节中更详细地介绍
    Data-Forge。
- en: For the moment, understand only that we’re using Data-Forge’s `rollingWindow`
    function to iterate our data in six-month chunks (known as data windows), and
    for each six-month chunk of data, we’ll forecast a new value, building a rolling
    forecast of future values. The output of this process will be our computed Trend
    column.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，只需了解我们正在使用 Data-Forge 的 `rollingWindow` 函数以六个月为一个数据块（称为数据窗口）迭代我们的数据，对于每个六个月的数据块，我们将预测一个新的值，构建未来值的滚动预测。这个过程的结果将是我们的计算出的趋势列。
- en: This is something we did manually earlier in Excel, and we’re now going to use
    code to do the work. The computed Trend column will then be integrated back into
    the DataFrame and output to the console, as you can see in [figure 5.18](#figure5.18).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们之前在 Excel 中手动完成的事情，现在我们将使用代码来完成这项工作。计算出的趋势列将集成回 DataFrame 并输出到控制台，如图 5.18
    所示。
- en: '![c05_18.png](Images/c05_18.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![c05_18.png](Images/c05_18.png)'
- en: '[Figure 5.18](#figureanchor5.18) The DataFrame with computed Trend column'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5.18](#figureanchor5.18) 计算出的趋势列的 DataFrame'
- en: Note in [listing 5.11](#listing5.11) how we use `setIndex` to set the Month#
    column as the index for the DataFrame. Having an index on the DataFrame allows
    the new Trend column to be integrated into it using the `withSeries` function
    that you can see toward the end of the code listing. Again, don’t try too hard
    to understand how `rollingWindow` is used here; we’ll come back to it in later
    chapters. You can run this code, and you will see the output shown in [figure
    5.18](#figure5.18).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在 [列表 5.11](#listing5.11) 中我们如何使用 `setIndex` 将月份数列设置为 DataFrame 的索引。在 DataFrame
    上有索引可以允许使用 `withSeries` 函数（您可以在代码列表的末尾看到）将其新趋势列集成到 DataFrame 中。再次提醒，不要过于努力地理解
    `rollingWindow` 在这里的使用；我们将在后面的章节中回到它。您可以运行此代码，您将看到图 5.18 所示的输出。
- en: Listing 5.11 Using Data-Forge rollingWindow to compute the Trend column (listing-5.11.js)
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.11 使用 Data-Forge 的 rollingWindow 计算趋势列（listing-5.11.js）
- en: '[PRE19]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 5.8.5 Outputting a new CSV file
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.8.5 输出新的 CSV 文件
- en: We almost have our result! The final thing we must do is to output the data
    as a new CSV file. This is made simple with Data-Forge’s `asCSV` and `writeFile`
    functions, as shown in the following listing. If you run this code, it will output
    a CSV file called trend_output.csv.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎得到了我们的结果！我们必须做的最后一件事是将数据输出为一个新的 CSV 文件。这可以通过 Data-Forge 的 `asCSV` 和 `writeFile`
    函数简化，如下所示。如果您运行此代码，它将输出一个名为 trend_output.csv 的 CSV 文件。
- en: Listing 5.12 Computing the Trend column with the help of Data-Forge and outputting
    a new CSV file (listing-5.12.js)
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.12 在 Data-Forge 的帮助下计算趋势列并输出新的 CSV 文件（listing-5.12.js）
- en: '[PRE20]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now that we’ve generated our new CSV file trend_output.csv complete with computed
    Trend column, we can take it back to Excel to see what it looks like! Open the
    CSV file in Excel, as shown in [figure 5.19](#figure5.19), and check that it’s
    well formed and that the new column looks as we expect.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经生成了包含计算出的趋势列的新 CSV 文件 trend_output.csv，我们可以将其带回到 Excel 中查看其外观！如图 5.19
    所示，在 Excel 中打开 CSV 文件，并检查其格式良好，以及新列看起来是否符合预期。
- en: '![c05_19.png](Images/c05_19.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![c05_19.png](Images/c05_19.png)'
- en: '[Figure 5.19](#figureanchor5.19) Final CSV that we generated from Node.js with
    the help of Data-Forge. Notice the computed Trend column.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5.19](#figureanchor5.19) 我们使用 Data-Forge 从 Node.js 生成的最终 CSV 文件。注意计算出的趋势列。'
- en: You could even create a chart from this generated data to quickly see what it
    looks like in a visualization. We won’t do this now; we’re going to take this
    CSV file and display it in a web visualization. Let’s shift our focus to the browser!
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以从这些生成数据创建图表，以快速查看其可视化效果。我们现在不会这样做；我们将使用这个 CSV 文件并在网页上显示它。让我们将注意力转向浏览器！
- en: 5.9 Exploratory coding in the browser
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.9 浏览器中的探索性编码
- en: After using Node.js to produce the new CSV file trend_output.csv with the computed
    Trend column, let’s now create an interactive web visualization for this data.
    To produce the visualization, we’ll use the simple and effective Flot charting
    library for JavaScript.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Node.js 生成包含计算出的趋势列的新 CSV 文件 trend_output.csv 之后，我们现在将为这些数据创建一个交互式网页可视化。为了生成可视化，我们将使用简单而有效的
    Flot JavaScript 图表库。
- en: Throughout this section, we’ll evolve our web visualization through an HTML
    file. As we did in the previous section, we’ll start simple and evolve our code
    toward our objectives. Our aim is to produce the visualization shown in [figure
    5.20](#figure5.20). You can follow along with the evolution of the code by looking
    at listing-5.13.html, listing-5.14.html, and listing-5.15.html as we work through
    the remainder of this chapter. These files are available in the GitHub repository.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过 HTML 文件逐步完善我们的网页可视化。正如我们在上一节中所做的那样，我们将从简单开始，逐步将代码向我们的目标发展。我们的目标是生成图
    5.20 所示的可视化。您可以通过查看 listing-5.13.html、listing-5.14.html 和 listing-5.15.html 来跟随代码的演变，我们在本章剩余部分进行工作。这些文件可在
    GitHub 仓库中找到。
- en: Our main tool for this section is called live-server. Live-server is a simple
    command-line web server; although not intended for use in production, it’s fantastic
    for fast prototyping.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的主要工具称为 live-server。Live-server 是一个简单的命令行网页服务器；尽管它不是为了生产使用而设计的，但它对于快速原型设计非常出色。
- en: Live-server gives you an instant web server that works as illustrated in [figure
    5.21](#figure5.21). We don’t need to hand-code a web server to start prototyping
    our web-based visualization—this is great because we’re prototyping and we want
    to move quickly.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Live-server 提供了一个即时网页服务器，其工作方式如图 5.21 所示。我们不需要手动编写网页服务器代码来开始原型设计我们的基于网页的可视化——这真是太好了，因为我们正在原型设计，我们希望快速进行。
- en: Live-server, like Nodemon, helps automate our workflow. It watches our code
    and automatically refreshes our web page when changes to the code are detected.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Live-server，就像 Nodemon 一样，有助于自动化我们的工作流程。它监视我们的代码，并在检测到代码更改时自动刷新我们的网页。
- en: My coding setup for this section is shown in [figure 5.22](#figure5.22). On
    the left is the visualization code that we’re developing. On the right is the
    browser that displays our web page. As we work on the left, our visualization
    is automatically refreshed by live-server on the right to display the updated
    results.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这个部分使用的编码设置如图 5.22 所示。左边是我们正在开发的可视化代码。右边是显示我们网页的浏览器。当我们专注于左边时，live-server
    会自动在右边刷新我们的可视化以显示更新后的结果。
- en: '![c05_20.png](Images/c05_20.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![c05_20.png](Images/c05_20.png)'
- en: '[Figure 5.20](#figureanchor5.20) Final output from your web visualization.
    Fatalities trend over time.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5.20](#figureanchor5.20) 你的网页可视化的最终输出。伤亡趋势随时间变化。'
- en: '![c05_21.eps](Images/c05_21.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![c05_21.eps](Images/c05_21.png)'
- en: '[Figure 5.21](#figureanchor5.21) Run live-server for an instant web server
    to quickly prototype web visualizations.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5.21](#figureanchor5.21) 运行 live-server 以快速原型化网页可视化。'
- en: 'To use live-server, you should install it globally as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 live-server，你应该按照以下方式全局安装它：
- en: '[PRE21]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now you can run live-server from the command line, although before we start
    our instant web server, we need to create a simple web page. In the continued
    spirit of evolutionary coding where we start simple, make sure it works, and then
    keep it working as we iterate on our code, we’ll start with the simplest possible
    web page, as shown in [listing 5.13](#listing5.13). We’ll use JavaScript to create
    our web visualization, so the web page contains a script section that writes “Hello
    world!” into the web page.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以从命令行运行 live-server，尽管在我们启动即时网页服务器之前，我们需要创建一个简单的网页。在进化编码的持续精神中，我们从简单开始，确保它工作，然后在我们迭代代码时保持其工作状态，我们将从最简单的网页开始，如图
    [清单 5.13](#listing5.13) 所示。我们将使用 JavaScript 创建我们的网页可视化，因此网页包含一个脚本部分，将“Hello world!”写入网页。
- en: '![c05_22.eps](Images/c05_22.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![c05_22.eps](Images/c05_22.png)'
- en: '[Figure 5.22](#figureanchor5.22) With live-server, you can edit your code and
    see the web page instantly refresh as you make changes.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5.22](#figureanchor5.22) 使用 live-server，你可以编辑代码，并在你进行更改时立即看到网页刷新。'
- en: Listing 5.13 Simplest web page to kick-start iterative coding for your web visualization
    (listing-5.13.html)
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.13 最简单的网页，用于启动你的网页可视化迭代编码（listing-5.13.html）
- en: '[PRE22]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now let’s start the web server. Run live-server from the command line in the
    directory for our code repository:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们启动网页服务器。在代码仓库目录中从命令行运行 live-server：
- en: '[PRE23]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: It’s that easy to create a web page for prototyping! Live-server automatically
    opens our default browser, and we can browse to listing-5.13.html to view the
    web page.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 创建用于原型化的网页就这么简单！Live-server 自动打开我们的默认浏览器，我们可以浏览到 listing-5.13.html 来查看网页。
- en: 'Now let’s update our code. We’re going to need jQuery and Flot. If you installed
    the Bower dependencies in the Chapter-5 code repository, then you already have
    them. Otherwise, you can install them into a fresh web project as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更新我们的代码。我们需要 jQuery 和 Flot。如果你在第五章代码仓库中安装了 Bower 依赖项，那么你已经有它们了。否则，你可以按照以下方式将它们安装到一个新的网页项目中：
- en: '[PRE24]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now that we have jQuery installed, we can include it in our web page so that
    we can use its `get` function to retrieve our CSV file trend_output.csv that was
    generated earlier using HTTP GET (shown in the following listing). As we modify
    our code, live-server detects the changes and refreshes the web page, so we can
    sit back, code, and watch the browser automatically refresh to run our latest
    code.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了 jQuery，我们可以在我们的网页中包含它，以便我们可以使用它的 `get` 函数来检索之前使用 HTTP GET 生成的 CSV
    文件 trend_output.csv（如下所示）。当我们修改代码时，live-server 会检测到变化并刷新网页，因此我们可以坐下来编码，并观察浏览器自动刷新以运行我们的最新代码。
- en: Listing 5.14 Using HTTP GET to retrieve the data from your CSV file (listing-5.14.html)
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.14 使用 HTTP GET 从 CSV 文件中检索数据（listing-5.14.html）
- en: '[PRE25]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We’re still doing evolutionary coding here. We’re doing one small thing at a
    time and testing as we go. Remember that we’re aiming to move from working code
    to working code in small manageable increments. The code in [listing 5.14](#listing5.14)
    outputs our data to the browser’s console. We do this to check that our code in
    the browser has received the data correctly.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然在这里进行进化编码。我们一次做一件小事情，并在进行中测试。记住，我们的目标是从小块可管理的增量中移动到工作的代码。列表 5.14 中的代码将我们的数据输出到浏览器的控制台。我们这样做是为了检查浏览器中的代码是否正确接收了数据。
- en: With live-server still running, navigate to the web page for [listing 5.14](#listing5.14)
    in your browser and open the dev tools to check the output on the console. For
    example, in Chrome you can open devtools by pressing F12 and looking at the Console
    tab (as shown in [figure 5.23](#figure5.23)).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当live-server仍在运行时，在浏览器中导航到[列表5.14](#listing5.14)的网页，并打开开发者工具以检查控制台输出。例如，在Chrome中，你可以通过按F12并查看控制台标签（如[图5.23](#figure5.23)所示）来打开开发者工具。
- en: '![c05_23.eps](Images/c05_23.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![c05_23.eps](Images/c05_23.png)'
- en: '[Figure 5.23](#figureanchor5.23) Viewing console.log output in Chrome''s devtools
    console'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.23](#figureanchor5.23) 在Chrome的开发者工具控制台中查看console.log输出'
- en: We should have the devtools open whenever we’re coding in the browser. This
    allows us to see any JavaScript errors that might come from our code, and we can
    use logging to verify that our code is working as intended.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在浏览器编码时始终打开开发者工具。这允许我们看到可能来自我们代码的任何JavaScript错误，并且我们可以使用日志验证我们的代码是否按预期工作。
- en: Another option we have for checking our data is to add it to the web page using
    `document.write`, although the output of this looks rather messy, as you can see
    in [figure 5.24](#figure5.24).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查数据的另一个选项是将它添加到网页中使用`document.write`，尽管如[图5.24](#figure5.24)所示，这种输出的外观相当杂乱。
- en: '![c05_24.png](Images/c05_24.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![c05_24.png](Images/c05_24.png)'
- en: '[Figure 5.24](#figureanchor5.24) Outputting CSV data directly into the web
    page—not the nicest visualization!'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.24](#figureanchor5.24) 直接将CSV数据输出到网页中——这不是最吸引人的可视化！'
- en: 'Okay, it’s high time we get this data into a chart! To make things easier,
    we’re going to install Data-Forge for the browser and use it to transform our
    data for the Flot charting library. If you installed Bower dependencies for the
    repository, then Data-Forge is already installed; otherwise, install it in a fresh
    web project as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，现在是时候将数据放入图表中了！为了使事情变得简单，我们将为浏览器安装Data-Forge并使用它来转换我们的数据，以便用于Flot图表库。如果你为存储库安装了Bower依赖项，那么Data-Forge已经安装；否则，在新的Web项目中按照以下方式安装它：
- en: '[PRE26]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: After we include the Data-Forge script in our web page, we can now create a
    DataFrame from our data, index it by Month#, then extract the Trend column from
    the CSV we produced in [listing 5.12](#listing5.12). Next, we use Flot to chart
    the Trend column. We’re using the `toPairs` function to get an array of index/value
    pairs. Each pair includes the index (we used Month# as the index) and the data
    (from the Trend column). We then use the Flot `plot` function to plot the chart
    into the placeholder element of our web page, as shown in the following listing.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的网页中包含Data-Forge脚本之后，我们现在可以从我们的数据中创建一个DataFrame，按月份编号索引它，然后从我们在[列表5.12](#listing5.12)中产生的CSV中提取趋势列。接下来，我们使用Flot绘制趋势列。我们使用`toPairs`函数获取一个索引/值对的数组。每个对包括索引（我们使用了月份编号作为索引）和数据（来自趋势列）。然后我们使用Flot的`plot`函数将图表绘制到我们网页的占位符元素中，如下面的列表所示。
- en: Listing 5.15 Using Data-Forge to extract the Trend column from the data set
    and visualize it in a Flot chart (listing-5.15.html)
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.15 使用Data-Forge从数据集中提取趋势列并在Flot图表中可视化它（listing-5.15.html）
- en: '[PRE27]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: With live-server running, navigate to the web page for [listing 5.15](#listing5.15),
    and you should now see the final result that’s shown in [figure 5.25](#figure5.25).
    We’ve plotted the Trend column using the Flot charting library. This is a basic
    visualization as far as these things go, but it’s a great result from a short
    and fast-paced prototyping session.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当live-server运行时，导航到[列表5.15](#listing5.15)的网页，你现在应该能看到[图5.25](#figure5.25)中显示的最终结果。我们使用Flot图表库绘制了趋势列。就这些内容而言，这是一个基本的可视化，但它是从短暂且快速的原型设计会议中得出的一个很好的结果。
- en: In case you’re wondering why the placeholder `div` for the chart in [listing
    5.15](#listing5.15) is embedded within a `table`, this is purely for cosmetic
    reasons. The `table` is used to arrange the chart’s title and the labels for the
    X axis and the Y axis.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道为什么[列表5.15](#listing5.15)中图表的占位符`div`嵌入在一个`table`中，这纯粹是出于美观原因。`table`用于排列图表的标题以及X轴和Y轴的标签。
- en: '![c05_25.png](Images/c05_25.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![c05_25.png](Images/c05_25.png)'
- en: '[Figure 5.25](#figureanchor5.25) Final product of your prototyping—a basic
    visualization of the Fatalities data in the Flot charting library'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.25](#figureanchor5.25) 你原型设计的最终产品——Flot图表库中关于伤亡数据的初步可视化'
- en: Putting it all together
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整合所有内容
- en: '![c05_26.eps](Images/c05_26.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![c05_26.eps](Images/c05_26.png)'
- en: '[Figure 5.26](#figureanchor5.26) The complete pipeline—from Node.js through
    to browser with automated code execution by Nodemon and live-server'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.26](#figureanchor5.26) 从Node.js到浏览器完整的管道——通过Nodemon和live-server的自动化代码执行'
- en: We’ve tackled the coding for this chapter separated into Node.js and browser
    coding. In practice, though, there’s no reason to separate these two activities.
    We can run Nodemon and be coding in Node.js at the same time we’re running live-server
    and coding the web visualization. This makes for a complete coding pipeline, as
    illustrated in [figure 5.26](#figure5.26). Nodemon picks up changes to the Node.js
    code, which automatically flow through to the output CSV file. Live-server detects
    changes to the CSV file and the code for the web page, which automatically flow
    through to the browser visualization.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将本章的编码工作分为 Node.js 和浏览器编码两部分。然而，在实践中，并没有理由将这两项活动分开。我们可以同时运行 Nodemon 并在 Node.js
    中编码，同时运行 live-server 并编码网页可视化。这形成了一个完整的编码流程，如图 5.26 所示。Nodemon 会捕捉到 Node.js 代码的更改，这些更改会自动流向输出
    CSV 文件。Live-server 会检测 CSV 文件和网页代码的更改，这些更改会自动流向浏览器可视化。
- en: You did good work here, although this isn’t the whole story. Recall that in
    this chapter you’re only working with a cut-down sample of the data. The aim was
    to better understand the data and better understand the problem you’re trying
    to solve.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这里做得很好，尽管这并不是全部的故事。回想一下，在本章中你只处理了数据的一个缩减样本。目标是更好地理解数据和你试图解决的问题。
- en: 'Through this chapter you’ve built up your knowledge while coding. Along the
    way you built code that’s going to be useful later when you scale up to the full
    data set and put this web visualization into production. But for now, you’ve achieved
    your goal: better understanding through exploratory coding and with useful code
    produced along the way. In chapter 6, you’ll dig deeper into potential issues
    in your data and learn how you can correct problems or work around them.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章的学习，你在编码的过程中积累了知识。在这个过程中，你编写了将来在扩展到完整数据集并将此网页可视化投入生产时将非常有用的代码。但就目前而言，你已经实现了目标：通过探索性编码和产生的有用代码更好地理解了问题。在第
    6 章中，你将更深入地探讨数据中可能存在的问题，并学习如何纠正这些问题或绕过它们。
- en: Summary
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: You learned how to build a fast and streamlined feedback loop for quick iterations
    and improved productivity.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你学习了如何构建快速且高效的反馈循环，以实现快速迭代和提升生产力。
- en: You discovered how to prototype data analysis and visualization in Excel before
    getting to coding.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开始编码之前，你发现了如何在 Excel 中原型化数据分析与可视化。
- en: You reproduced Excel data analysis in Node.js using Formulajs.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你使用 Formulajs 在 Node.js 中重现了 Excel 数据分析。
- en: You practiced how to build a quick web-based visualization using Flot.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你练习了如何使用 Flot 快速构建基于网页的可视化。
- en: You learned that you can use Nodemon and live-server to build a coding pipeline
    that automatically refreshes as you work.*****
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你了解到可以使用 Nodemon 和 live-server 构建一个编码管道，该管道在你工作时自动刷新。
