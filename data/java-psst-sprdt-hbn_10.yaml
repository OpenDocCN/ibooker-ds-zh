- en: 8 Mapping collections and entity associations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 映射集合和实体关联
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Mapping persistent collections
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射持久集合
- en: Examining collections of basic and embeddable types
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查基本类型和可嵌入类型的集合
- en: Investigating simple many-to-one and one-to-many entity associations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调查简单的多对一和一对多实体关联
- en: The first thing many developers try to do when they begin using Hibernate or
    Spring Data JPA is to map a *parent/child relationship*. This is usually the first
    time they encounter collections. It’s also the first time they have to think about
    the differences between entities and value types or get lost in the complexity
    of ORM.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者在开始使用 Hibernate 或 Spring Data JPA 时，首先尝试做的事情是映射一个 *父/子关系*。这通常是它们第一次遇到集合。这也是他们第一次必须考虑实体和价值类型之间的区别，或者陷入
    ORM 的复杂性中。
- en: Managing the associations between classes and the relationships between tables
    is at the heart of ORM. Most of the difficult problems involved in implementing
    an ORM solution relate to collections and entity association management. We’ll
    start this chapter with some basic collection-mapping concepts and simple examples.
    After that, you’ll be prepared for the first collection in an entity association—we’ll
    come back to more complicated entity association mappings in the next chapter.
    To get the full picture, we recommend you read both this chapter and the next.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 管理类之间的关联和表之间的关系是 ORM 的核心。在实现 ORM 解决方案时遇到的许多难题都与集合和实体关联管理有关。我们将从一些基本的集合映射概念和简单示例开始本章。之后，你将准备好处理实体关联中的第一个集合——我们将在下一章回到更复杂的实体关联映射。为了全面了解，我们建议你阅读本章和下一章。
- en: Major new features in JPA 2
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: JPA 2 中的主要新功能
- en: Support was added for collections and maps of basic and embeddable types.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 增加了基本类型和可嵌入类型集合和映射的支持。
- en: Support was added for persistent lists where the index of each element is stored
    in an additional database column.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 增加了持久列表的支持，其中每个元素的索引存储在额外的数据库列中。
- en: One-to-many associations now have an orphan removal option.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一对多关联现在有一个孤儿删除选项。
- en: 8.1 Sets, bags, lists, and maps of value types
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1 值类型的集合、包、列表和映射
- en: Java has a rich collection API, from which we can choose the interface and implementation
    that best fits the domain model design. We’ll use the Java Collections framework
    for our implementation in this chapter, and we’ll walk through the most common
    collection mappings, repeating the same `Image` and `Item` example with minor
    variations.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Java 拥有一个丰富的集合 API，我们可以从中选择最适合领域模型设计的接口和实现。在本章中，我们将使用 Java 集合框架来实现，并介绍最常见的集合映射，包括对
    `Image` 和 `Item` 的相同示例进行细微的修改。
- en: 'We’ll start by looking at the database schema and creating and mapping a collection
    property in general. The database goes first, as it is generally designed first
    and our programs must work with it. Then we’ll proceed to selecting a specific
    collection interface and mapping various collection types: a set, an identifier
    bag, a list, a map, and finally sorted and ordered collections.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将查看数据库模式，并创建和映射一个集合属性。数据库通常是首先设计的，我们的程序必须与之协同工作。然后我们将继续选择特定的集合接口，并映射各种集合类型：一个集合、一个标识符包、一个列表、一个映射，最后是排序和有序集合。
- en: 8.1.1 The database schema
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.1 数据库模式
- en: We’ll extend CaveatEmptor to support attaching images to auction items. An item
    with an associated image is more interesting for the potential buyer. We’ll ignore
    the Java code for now and consider only the database schema. The source code that
    follows can be found in the mapping-collections folder.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将扩展 CaveatEmptor 以支持将图像附加到拍卖物品上。带有相关图像的物品对潜在买家更有吸引力。现在我们将忽略 Java 代码，只考虑数据库模式。随后的源代码可以在
    mapping-collections 文件夹中找到。
- en: Note To execute the examples from the source code, you will first need to run
    the Ch08.sql script.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：要执行源代码中的示例，你首先需要运行 Ch08.sql 脚本。
- en: For the auction item and images example, assume that the image is stored somewhere
    on the filesystem and that we store just the filename in the database. When an
    image is deleted from the database, a separate process must delete the file from
    the disk.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于拍卖物品和图像示例，假设图像存储在文件系统中的某个位置，我们只将文件名存储在数据库中。当从数据库中删除图像时，必须有一个单独的过程从磁盘上删除文件。
- en: We need an `IMAGE` table in the database to hold the images, or maybe just the
    filenames of images. This table will also have a foreign key column, say `ITEM_ID`,
    referencing the `ITEM` table. Look at the schema shown in figure 8.1.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在数据库中有一个`IMAGE`表来存储图像，或者可能只是存储图像的文件名。此表还将有一个外键列，例如`ITEM_ID`，它引用`ITEM`表。参见图8.1所示的架构。
- en: '![](../../OEBPS/Images/CH08_F01_Tudose2.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH08_F01_Tudose2.png)'
- en: Figure 8.1 The `IMAGE` table holds image filenames, each referencing an `ITEM_ID`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 `IMAGE`表存储图像文件名，每个文件名都引用一个`ITEM_ID`。
- en: That’s all there is to the schema—no collections or composition.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是所有模式的内容——没有集合或组合。
- en: 8.1.2 Creating and mapping a collection property
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.2 创建和映射集合属性
- en: How would we map this `IMAGE` table with what we know so far? We’d probably
    map it as an `@Entity` class named `Image`. Later in this chapter we’ll map a
    foreign key column with a `@ManyToOne` property to make the association between
    entities. We’d also need a composite primary key mapping for the entity class,
    as we’ll first demonstrate in section 10.2.2\. What we need to know for now is
    that a composite primary key is a combination of more than one column to uniquely
    identify a row in a table. Individual columns may not be unique, but their combination
    must be unique.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将如何使用我们目前所知道的信息来映射这个`IMAGE`表？我们可能会将其映射为一个名为`Image`的`@Entity`类。在本章的后面，我们将映射一个外键列与`@ManyToOne`属性相关联，以建立实体之间的关联。我们还需要为实体类创建一个复合主键映射，我们将在第10.2.2节中首先演示。我们现在需要知道的是，复合主键是多个列的组合，用于在表中唯一标识一行。单个列可能不是唯一的，但它们的组合必须是唯一的。
- en: 'There are no mapped collections of images; they aren’t necessary. When we need
    an item’s images, we can write and execute a query in the JPA query language:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 没有映射的图像集合；它们不是必需的。当我们需要某个项目的图像时，我们可以用JPA查询语言编写和执行一个查询：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Persistent collections are *always* optional.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 持久化集合总是**可选的**。
- en: 'A collection we could create is `Item#images`, referencing all images for a
    particular item. We could create and map this collection property to do the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个`Item#images`集合，它引用特定项目的所有图像。我们可以创建并映射这个集合属性来完成以下操作：
- en: Execute the SQL query `SELECT` `*` `from` `IMAGE` `where` `ITEM_ID` `=` `?`
    automatically when we call `someItem.getImages()`. As long as the domain model
    instances are in a *managed* state (more on that later), we can read from the
    database on demand while navigating the associations between the classes. We don’t
    have to manually write and execute a query to load data. On the other hand, when
    we start iterating the collection, the collection query is always “all images
    for this item,” never “only images that match criteria XYZ.”
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们调用`someItem.getImages()`时，会自动执行SQL查询`SELECT * from IMAGE where ITEM_ID =
    ?`。只要域模型实例处于**管理**状态（稍后会有更多介绍），我们就可以在导航类之间的关联时按需从数据库中读取。我们不必手动编写和执行查询来加载数据。另一方面，当我们开始迭代集合时，集合查询始终是“此项目的所有图像”，而不是“仅匹配XYZ条件的图像。”
- en: Avoid saving each `Image` with `entityManager.persist()` or `imageRepository
    .save()`. If we have a mapped collection, adding the `Image` to the collection
    with `someItem.getImages().add()` will make it persistent automatically when the
    `Item` is saved. This cascading persistence is convenient because we can save
    instances without calling the repository or the `EntityManager`.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免使用`entityManager.persist()`或`imageRepository .save()`来保存每个`Image`。如果我们有一个映射的集合，通过`someItem.getImages().add()`将`Image`添加到集合中，当保存`Item`时，它将自动持久化。这种级联持久化很方便，因为我们可以在不调用存储库或`EntityManager`的情况下保存实例。
- en: Have a dependent lifecycle of `Image`s. When an `Item` is deleted, Hibernate
    deletes all attached `Image`s with an extra SQL `DELETE`. We don’t have to worry
    about the lifecycle of images and cleaning up orphans (assuming the database foreign
    key constraint doesn’t `ON DELETE CASCADE`). The JPA provider handles the composition
    lifecycle.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Image`具有依赖的生命周期。当一个`Item`被删除时，Hibernate会通过额外的SQL `DELETE`删除所有附加的`Image`。我们不必担心图像的生命周期和清理孤儿（假设数据库外键约束没有`ON
    DELETE CASCADE`）。JPA提供者处理组合生命周期。'
- en: It’s important to realize that although these benefits sound great, the price
    we’ll pay is additional mapping complexity. Many JPA beginners struggle with collection
    mappings, and frequently the answer to “Why are you doing this?” has been “I thought
    this collection was required.”
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要认识到，尽管这些好处听起来很棒，但我们付出的代价是额外的映射复杂性。许多JPA初学者在集合映射上挣扎，而且经常有人问“你为什么要这样做？”答案是“我以为这个集合是必需的。”
- en: If we analyze how we can treat the scenario with images for auction items, we’ll
    find that we’ll benefit from a collection mapping. The images have a dependent
    lifecycle; when an item is deleted, all the attached images should be deleted.
    When an item is stored, all attached images should be stored. And when an item
    is displayed, we’ll often also display all images, so `someItem.getImages()` is
    convenient in UI code—this is rather an eager loading of the information. We don’t
    have to call the persistence service again to get the images; they’re just *there*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们分析如何处理拍卖物品的图像场景，我们会发现我们可以从集合映射中受益。图像具有依赖的生命周期；当删除一个项目时，所有附加的图像都应该被删除。当存储一个项目时，所有附加的图像都应该被存储。当显示一个项目时，我们通常会显示所有图像，因此
    `someItem.getImages()` 在 UI 代码中很方便——这实际上是一种信息的需求加载。我们不需要再次调用持久化服务来获取图像；它们只是“在那里”。
- en: Now we’ll move on to choosing the collection interface and implementation that
    best fits the domain model design. Let’s walk through the most common collection
    mappings, repeating the same `Image` and `Item` example with minor variations.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将继续选择最适合领域模型设计的集合接口和实现。让我们通过最常用的集合映射来探讨，以微小的变化重复使用相同的 `Image` 和 `Item`
    示例。
- en: 8.1.3 Selecting a collection interface
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.3 选择集合接口
- en: 'This is the idiom for a collection property in the Java domain model:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Java 领域模型中集合属性的惯用方法：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Use an interface to declare the type of the property, not an implementation.
    Pick a matching implementation, and initialize the collection right away; doing
    so avoids uninitialized collections. We don’t recommend initializing collections
    late in constructors or setter methods.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用接口来声明属性的类型，而不是实现。选择一个匹配的实现，并立即初始化集合；这样做可以避免未初始化的集合。我们不推荐在构造函数或设置方法中较晚初始化集合。
- en: 'Using generics, here’s a typical `Set`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用泛型，这是一个典型的 `Set`：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Raw collections without generics
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 不使用泛型的原始集合
- en: If we don’t specify the type of collection elements with generics, or the key/value
    types of a map, we need to tell Hibernate the type (or types). For example, instead
    of a `Set<String>`, we can map a raw `Set` with `@ElementCollection(targetClass=
    String.class)`. This also applies to type parameters of a `Map`. Specify the key
    type of a `Map` with `@MapKeyClass`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有使用泛型指定集合元素的类型，或者映射的键/值类型，我们需要告诉 Hibernate 类型（或类型）。例如，我们可以使用 `@ElementCollection(targetClass=
    String.class)` 将原始 `Set` 映射为 `Set<String>`。这也适用于 `Map` 的类型参数。使用 `@MapKeyClass`
    指定 `Map` 的键类型。
- en: All the examples in this book use generic collections and maps, and so should
    you.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的所有示例都使用泛型集合和映射，你们也应该这样做。
- en: Out of the box, Hibernate supports the most important JDK collection interfaces
    and preserves the semantics of JDK collections, maps, and arrays in a persistent
    fashion. Each JDK interface has a matching implementation supported by Hibernate,
    and it’s important that we use the right combination. Hibernate wraps the already
    initialized collection on the declaration of the field or sometimes replaces it
    if it’s not the right one. It does that to enable, among other things, lazy loading
    and dirty checking of collection elements.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate 默认支持最重要的 JDK 集合接口，并以持久化的方式保留了 JDK 集合、映射和数组语义。每个 JDK 接口都有一个由 Hibernate
    支持的对应实现，并且使用正确的组合非常重要。Hibernate 在字段声明时封装已初始化的集合，有时如果它不是正确的类型，则会替换它。这样做是为了实现诸如延迟加载和集合元素的脏检查等功能。
- en: 'Without extending Hibernate, we can choose from the following collections:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在不扩展 Hibernate 的情况下，我们可以从以下集合中进行选择：
- en: A `java.util.Set` property, initialized with a `java.util.HashSet`. The order
    of elements isn’t preserved, and duplicate elements aren’t allowed. All JPA providers
    support this type.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个使用 `java.util.HashSet` 初始化的 `java.util.Set` 属性。元素顺序不被保留，不允许重复元素。所有 JPA 提供商都支持此类型。
- en: 'A `java.util.SortedSet` property, initialized with a `java.util.TreeSet`. This
    collection supports a stable order of elements: sorting occurs in memory after
    Hibernate loads the data. This is a Hibernate-only extension; other JPA providers
    may ignore the “sorted” aspect of the set.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个使用 `java.util.TreeSet` 初始化的 `java.util.SortedSet` 属性。此集合支持元素的稳定顺序：排序发生在 Hibernate
    加载数据之后。这是 Hibernate 独有的扩展；其他 JPA 提供商可能会忽略集合的“排序”方面。
- en: A `java.util.List` property, initialized with a `java.util.ArrayList`. Hibernate
    preserves the position of each element with an additional index column in the
    database table. All JPA providers support this type.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个使用 `java.util.ArrayList` 初始化的 `java.util.List` 属性。Hibernate 使用数据库表中的额外索引列来保留每个元素的位置。所有
    JPA 提供商都支持此类型。
- en: A `java.util.Collection` property, initialized with a `java.util.ArrayList`.
    This collection has *bag* semantics; duplicates are possible, but the order of
    elements isn’t preserved. All JPA providers support this type.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个使用 `java.util.ArrayList` 初始化的 `java.util.Collection` 属性。这个集合具有 *包* 语义；可能存在重复项，但元素的顺序不会被保留。所有
    JPA 提供商都支持此类型。
- en: A `java.util.Map` property, initialized with a `java.util.HashMap`. The key
    and value pairs of a map can be preserved in the database. All JPA providers support
    this type.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个使用 `java.util.HashMap` 初始化的 `java.util.Map` 属性。映射中的键值对可以在数据库中保留。所有 JPA 提供商都支持此类型。
- en: 'A `java.util.SortedMap` property, initialized with a `java.util.TreeMap`. It
    supports a stable order of elements: sorting occurs in memory after Hibernate
    loads the data. This is a Hibernate-only extension; other JPA providers may ignore
    the “sorted” aspect of the map.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个使用 `java.util.TreeMap` 初始化的 `java.util.SortedMap` 属性。它支持元素的稳定顺序：排序发生在 Hibernate
    加载数据后。这是一个仅 Hibernate 扩展；其他 JPA 提供商可能会忽略映射的“排序”方面。
- en: Hibernate supports persistent arrays, but JPA doesn’t. They’re rarely used,
    and we won’t show them in this book. Hibernate can’t wrap array properties, so
    many benefits of collections, such as on-demand lazy loading, won’t work. Only
    use persistent arrays in your domain model if you’re sure you won’t need lazy
    loading. (You can load arrays on demand, but this requires interception with bytecode
    enhancement, as explained in section 12.1.3.)
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hibernate 支持持久化数组，但 JPA 不支持。它们很少使用，本书中不会展示它们。Hibernate 不能包装数组属性，因此集合的许多好处，如按需懒加载，将不会工作。只有在你确定不需要懒加载时，才在你的领域模型中使用持久化数组。（你可以按需加载数组，但这需要通过字节码增强进行拦截，如
    12.1.3 节中所述。）
- en: If we want to map collection interfaces and implementations that are not directly
    supported by Hibernate, we need to tell Hibernate about the semantics of the custom
    collections. The extension point in Hibernate is the `PersistentCollection` interface
    in the `org.hibernate.collection.spi` package, where we usually extend one of
    the existing `PersistentSet`, `PersistentBag`, and `PersistentList` classes. Custom
    persistent collections aren’t easy to write, and we don’t recommend doing this
    if you aren’t an experienced Hibernate user.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要映射 Hibernate 直接不支持集合接口和实现，我们需要告诉 Hibernate 关于自定义集合的语义。Hibernate 的扩展点是
    `org.hibernate.collection.spi` 包中的 `PersistentCollection` 接口，我们通常扩展现有的 `PersistentSet`、`PersistentBag`
    和 `PersistentList` 中的一个类。自定义持久化集合不易编写，我们不推荐如果你不是经验丰富的 Hibernate 用户就进行此操作。
- en: Transactional filesystems
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 事务性文件系统
- en: If we only keep the filenames of images in the SQL database, we have to store
    the binary data of each picture—the files—somewhere. We could store the image
    data in the SQL database in `BLOB` columns (see “Binary and large value types”
    in section 6.3.1).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只将图像的文件名存储在 SQL 数据库中，我们必须将每张图片的二进制数据——文件——存储在某个地方。我们可以在 SQL 数据库的 `BLOB`
    列中存储图像数据（参见 6.3.1 节中的“二进制和大型值类型”）。
- en: If we decide not to store the images in the database, but as regular files,
    we should be aware that the standard Java filesystem APIs, `java.io.File` and
    `java.nio .file.Files`, aren’t transactional. Filesystem operations aren’t enlisted
    in a Java Transaction API (JTA) system transaction; a transaction might successfully
    complete with Hibernate writing the filename into the SQL database, but the storing
    or deleting of the file in the filesystem might fail. We won’t be able to roll
    back these operations as one atomic unit, and we won’t get proper isolation of
    operations.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定不将图像存储在数据库中，而是作为常规文件，我们应该意识到标准的 Java 文件系统 API，`java.io.File` 和 `java.nio.file.Files`，不是事务性的。文件系统操作不会被纳入
    Java 事务 API (JTA) 系统事务；一个事务可能成功完成，Hibernate 将文件名写入 SQL 数据库，但文件在文件系统中的存储或删除可能会失败。我们无法将这些操作作为一个原子单元回滚，并且我们无法获得操作的正确隔离性。
- en: You could use a separate system transaction manager such as Bitronix. File operations
    are then enlisted, committed, and rolled back together with Hibernate’s SQL operations
    in the same transaction.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用一个单独的系统事务管理器，如 Bitronix。然后，文件操作将与 Hibernate 的 SQL 操作一起在同一个事务中注册、提交和回滚。
- en: Let’s map a collection of image filenames for an `Item`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们映射一个 `Item` 的图像文件名集合。
- en: 8.1.4 Mapping a set
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.4 映射集合
- en: The simplest implementation of mapping a set is a `Set` of `String` image filenames.
    Add a collection property to the `Item` class, as demonstrated in the following
    listing.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 映射集合的最简单实现是 `String` 图像文件名的 `Set`。向 `Item` 类中添加一个集合属性，如下所示列表中所示。
- en: Listing 8.1 Images mapped as a simple set of strings
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.1 将图像映射为简单的字符串集合
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Ⓐ Declare the `images` field as an `@ElementCollection`. We refer here to image
    paths on the system, but for brevity we’ll use the names of the fields and columns,
    such as `image` or `images`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 将 `images` 字段声明为 `@ElementCollection`。在这里，我们指的是系统中的图像路径，但为了简洁起见，我们将使用字段和列的名称，例如
    `image` 或 `images`。
- en: Ⓑ The collection table will be named `IMAGE`. Otherwise it would default to
    `ITEM_ IMAGES`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 集合表将被命名为 `IMAGE`。否则，它将默认为 `ITEM_IMAGES`。
- en: Ⓒ The join column between the `ITEM` and the `IMAGE` tables will be `ITEM_ID`
    (the default name, in fact).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ `ITEM` 表和 `IMAGE` 表之间的连接列将是 `ITEM_ID`（实际上是默认名称）。
- en: Ⓓ The name of the column that will contain the string information from the `images`
    collection will be `FILENAME`. Otherwise it would default to `IMAGES`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 将包含 `images` 集合中的字符串信息的列命名为 `FILENAME`。否则，它将默认为 `IMAGES`。
- en: Ⓔ Initialize the `images` collection as a `HashSet`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓔ 将 `images` 集合初始化为 `HashSet`。
- en: 'The `@ElementCollection` JPA annotation in the preceding listing is required
    for a collection of value-typed elements. Without the `@CollectionTable` and `@Column`
    annotations, Hibernate would use default schema names. Look at the schema in figure
    8.2: the primary key columns are underlined.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的列表中，`@ElementCollection` JPA 注解对于值类型元素的集合是必需的。如果没有 `@CollectionTable` 和
    `@Column` 注解，Hibernate 将使用默认的模式名称。查看图 8.2 中的模式：主键列被下划线标注。
- en: '![](../../OEBPS/Images/CH08_F02_Tudose2.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH08_F02_Tudose2.png)'
- en: Figure 8.2 Table structure and example data for a set of strings
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 字符串集合的表结构和示例数据
- en: 'The `IMAGE` table has a composite primary key of both the `ITEM_ID` and `FILENAME`
    columns. That means we can’t have duplicate rows: each image file can only be
    attached once to one item. Also, the order of images isn’t stored. This fits the
    domain model and `Set` collection. The image is stored somewhere on the filesystem,
    and we keep just the filename in the database.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`IMAGE` 表具有由 `ITEM_ID` 和 `FILENAME` 列组成的复合主键。这意味着我们不能有重复的行：每个图像文件只能附加到一项上一次。此外，图像的顺序没有存储。这符合领域模型和
    `Set` 集合。图像存储在文件系统中的某个位置，我们只保留数据库中的文件名。'
- en: To interact with the `Item` entities, we’ll create the following Spring Data
    JPA repository.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与 `Item` 实体交互，我们将创建以下 Spring Data JPA 仓库。
- en: Listing 8.2 The `ItemRepository` interface
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.2 `ItemRepository` 接口
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Ⓐ Declare a `findItemWithImages` method that will get the `Item` by `id`, including
    the `images` collection. To fetch this collection eagerly, we’ll use the `inner
    join fetch` capability of Jakarta Persistence Query Language (JPQL).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 声明一个名为 `findItemWithImages` 的方法，该方法将通过 `id` 获取 `Item`，包括 `images` 集合。为了 eager
    获取此集合，我们将使用 Jakarta Persistence Query Language (JPQL) 的 `inner join fetch` 功能。
- en: Ⓑ Declare the `findImagesNative` method, which is annotated as a native query
    and will get the set of strings representing the `images` of a given `id`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 声明 `findImagesNative` 方法，该方法被注解为原生查询，并将获取表示给定 `id` 的 `images` 的字符串集合。
- en: We’ll also create the following test.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将创建以下测试。
- en: Listing 8.3 The `MappingCollectionsSpringDataJPATest` class
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.3 `MappingCollectionsSpringDataJPATest` 类
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Ⓐ Create an `Item`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 创建一个 `Item`。
- en: Ⓑ Add 4 image paths to it.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 向其中添加 4 个图像路径。
- en: Ⓒ Save it to the database.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 将其保存到数据库中。
- en: Ⓓ Access the repository to get the item together with the `images` collection.
    As we specified in the JPQL query with which the `findItemWithImages` method is
    annotated, the collection will also be fetched from the database.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 访问仓库以获取包含 `images` 集合的项。正如我们在 `findItemWithImages` 方法上注解的 JPQL 查询中所指定的，该集合也将从数据库中获取。
- en: Ⓔ Get all `Item`s from the database.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓔ 从数据库中获取所有 `Item`。
- en: Ⓕ Get the set of strings representing the images, using the `findImagesNative`
    method.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓕ 使用 `findImagesNative` 方法获取表示图像的字符串集合。
- en: Ⓖ Check the sizes of the different collections we have obtained.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓖ 检查我们获取的不同集合的大小。
- en: It doesn’t seem likely that we’d allow the user to attach the same image more
    than once to the same item, but let’s suppose we did. What kind of mapping would
    be appropriate in that case?
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们不太可能允许用户将相同的图像多次附加到同一项上，但让我们假设我们确实这样做了。在这种情况下，哪种映射是合适的？
- en: 8.1.5 Mapping an identifier bag
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.5 映射标识符包
- en: A *bag* is an unordered collection that allows duplicate elements, like the
    `java.util .Collection` interface. Curiously, the Java Collections framework doesn’t
    include a bag implementation. We can initialize the property with an `ArrayList`,
    and Hibernate ignores the index of elements when storing and loading elements.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*包*是一个无序集合，允许重复元素，就像`java.util.Collection`接口一样。奇怪的是，Java集合框架没有包含包实现。我们可以用`ArrayList`初始化属性，Hibernate在存储和加载元素时忽略元素的索引。
- en: Listing 8.4 Bag of strings, allowing duplicate elements
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.4 字符串包，允许重复元素
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Ⓐ Declare a `@GenericGenerator` with the name `"sequence_gen"` and the `"sequence"`
    strategy to take care of the surrogate keys in the `IMAGE` table.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 声明一个名为`"sequence_gen"`的`@GenericGenerator`，使用`"sequence"`策略来处理`IMAGE`表中的代理键。
- en: Ⓑ The `IMAGE` collection table needs a different primary key to allow duplicate
    `FILENAME` values for each `ITEM_ID`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ `IMAGE`集合表需要一个不同的主键，以便为每个`ITEM_ID`允许重复的`FILENAME`值。
- en: Ⓒ Introduce a surrogate primary key column named `IMAGE_ID`. You may retrieve
    all images at the same time or store them all at the same time, but a database
    table still needs a primary key.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 引入一个名为`IMAGE_ID`的代理主键列。你可以同时检索所有图片或同时存储它们，但数据库表仍然需要一个主键。
- en: Ⓓ Use a Hibernate-only annotation.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 使用仅Hibernate的注解。
- en: Ⓔ Configure how the primary key is generated.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓔ 配置主键的生成方式。
- en: Ⓕ There is no bag implementation in JDK. We initialize the collection as `ArrayList`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓕ JDK中没有包实现。我们初始化集合为`ArrayList`。
- en: Usually you’ll want the system to generate a primary key value when you save
    an entity instance. If you need to refresh your memory about key generators, refer
    to section 5.2.4\. The modified schema is shown in figure 8.3\. The Spring Data
    JPA repository and the test will be just like in the previous example.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当你保存实体实例时，你希望系统生成一个主键值。如果你需要刷新关于键生成器的记忆，请参阅第5.2.4节。修改后的模式如图8.3所示。Spring Data
    JPA仓库和测试将与前一个示例相同。
- en: '![](../../OEBPS/Images/CH08_F03_Tudose2.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH08_F03_Tudose2.png)'
- en: Figure 8.3 Surrogate primary key column for a bag of strings
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 包字符串的代理主键列
- en: 'Here’s an interesting question: if all you see is this schema, can you tell
    how the tables are mapped in Java? The `ITEM` and `IMAGE` tables look the same:
    each has a surrogate primary key column and some other normalized columns. Each
    table could be mapped with an `@Entity` class. However, we could decide to use
    a JPA feature and map a collection to `IMAGE`, even with a composition lifecycle.
    This is, effectively, a design decision that some predefined query and manipulation
    rules are all we need for this table instead of the more generic `@Entity` mapping.
    When you make such a decision, be sure you know the reasons why and the consequences.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个有趣的问题：如果你只看到这个模式，你能说出Java中表是如何映射的吗？`ITEM`和`IMAGE`表看起来很相似：每个表都有一个代理主键列和一些其他规范化列。每个表都可以用一个`@Entity`类来映射。然而，我们可以决定使用JPA的一个特性，将一个集合映射到`IMAGE`，即使有组合生命周期。这实际上是一个设计决策，即对于这个表，我们只需要一些预定义的查询和操作规则，而不是更通用的`@Entity`映射。当你做出这样的决定时，一定要知道为什么以及会有什么后果。
- en: The next mapping technique preserves the order of images within a list.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个映射技术保留列表中图片的顺序。
- en: 8.1.6 Mapping a list
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.6 映射列表
- en: If you haven’t used ORM software before, a persistent list seems to be a very
    powerful concept; imagine how much work storing and loading a `java.util.List
    <String>` is with plain JDBC and SQL. If we add an element to the middle of the
    list, the list shifts all subsequent elements to the right or rearranges pointers,
    depending on the list implementation. If we remove an element from the middle
    of the list, something else happens, and so on. If the ORM software can do all
    of this automatically for database records, a persistent list starts to look more
    appealing than it actually is.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前没有使用过ORM软件，持久化列表似乎是一个非常强大的概念；想象一下，使用纯JDBC和SQL存储和加载`java.util.List<String>`需要多少工作。如果我们向列表中间添加一个元素，列表会将其后的所有元素向右移动或重新排列指针，具体取决于列表的实现。如果我们从列表中间删除一个元素，会发生其他事情，依此类推。如果ORM软件可以自动为数据库记录做所有这些事情，持久化列表开始看起来比它实际上更有吸引力。
- en: As we noted in section 3.2.4, the first reaction is often to preserve the order
    of data elements as users enter them because you’ll often have to show them later
    in the same order. But if another criterion can be used for sorting the data,
    like an entry timestamp, you should sort the data when querying rather than store
    the display order. What if the display order you need to use changes? The order
    in which data is displayed is usually not an integral part of the data but an
    orthogonal concern, so think twice before mapping a persistent `List`; Hibernate
    isn’t as smart as you might think, as you’ll see in the next example.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 3.2.4 节中提到的，最初的反应通常是保留用户输入的数据元素的顺序，因为你通常会按相同的顺序稍后显示它们。但如果可以使用其他标准对数据进行排序，如条目时间戳，那么在查询时应对数据进行排序，而不是存储显示顺序。如果你需要使用的显示顺序发生变化怎么办？数据显示的顺序通常不是数据的一个组成部分，而是一个正交的关注点，所以在映射持久化
    `List` 之前要三思，因为 Hibernate 并不像你想象中那么聪明，你将在下一个例子中看到。
- en: Let’s change the `Item` entity and its collection property.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更改 `Item` 实体及其集合属性。
- en: Listing 8.5 Persistent list, preserving the order of elements in the database
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.5 持久化列表，保留数据库中元素顺序
- en: '[PRE7]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'There is a new annotation in this example: `@OrderColumn`. This column stores
    an index in the persistent list, starting at zero. The column name will default
    to `IMAGES_ ORDER`. Note that Hibernate stores the index to be contiguous in the
    database and expects it to be that way. If there are gaps, Hibernate will add
    `null` elements when loading and constructing the `List`. Look at the schema in
    figure 8.4.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中有一个新的注解：`@OrderColumn`。这个列存储持久化列表中的索引，从零开始。列名默认为 `IMAGES_ ORDER`。请注意，Hibernate
    将索引存储在数据库中，并期望它是连续的。如果有空隙，Hibernate 在加载和构建 `List` 时会添加 `null` 元素。查看图 8.4 中的模式。
- en: '![](../../OEBPS/Images/CH08_F04_Tudose2.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH08_F04_Tudose2.png)'
- en: Figure 8.4 The collection table preserves the position of each list element.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 集合表保留每个列表元素的位置。
- en: The primary key of the `IMAGE` table is a composite of `ITEM_ID` and `IMAGES_ORDER`.
    This allows duplicate `FILENAME` values, which is consistent with the semantics
    of a `List`. Remember, the image is stored somewhere on the filesystem, and we
    keep just the filename in the database. The Spring Data JPA repository and the
    test will be just like the previous example.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`IMAGE` 表的主键是 `ITEM_ID` 和 `IMAGES_ORDER` 的组合。这允许重复的 `FILENAME` 值，这与 `List`
    的语义一致。记住，图像存储在文件系统中的某个位置，我们只保留数据库中的文件名。Spring Data JPA 仓库和测试将与上一个例子相同。'
- en: 'We said earlier that Hibernate isn’t as smart as you might think. Consider
    making modifications to the list: say the list has three images, A, B, and C,
    in that order. What happens if you remove A from the list? Hibernate executes
    one SQL `DELETE` for that row. Then it executes two `UPDATE`s, for B and C, shifting
    their positions to the left to close the gap in the index. For each element to
    the right of the deleted element, Hibernate executes an `UPDATE`. If we wrote
    SQL for this by hand, we could do it with one `UPDATE`. The same is true for insertions
    in the middle of the list—Hibernate shifts all existing elements to the right
    one by one. At least Hibernate is smart enough to execute a single `DELETE` when
    we `clear()` the list.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到过，Hibernate 并不像你想象中那么聪明。考虑对列表进行修改：假设列表中有三个图像，A、B 和 C，按此顺序排列。如果你从列表中删除
    A 会发生什么？Hibernate 为该行执行一个 SQL `DELETE` 操作。然后它执行两个 `UPDATE` 操作，针对 B 和 C，将它们的位移动到左边以关闭索引中的空隙。对于删除元素右侧的每个元素，Hibernate
    执行一个 `UPDATE` 操作。如果我们手动编写 SQL，我们可以用一个 `UPDATE` 操作来完成。对于列表中间的插入也是如此——Hibernate
    会逐个将所有现有元素向右移动。至少，Hibernate 足够聪明，在我们调用 `clear()` 清除列表时执行单个 `DELETE` 操作。
- en: Now suppose the images for an item have user-supplied names in addition to the
    filename. One way to model this in Java is with a map, using key/value pairs.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设一个项目的图像除了文件名外还有用户提供的名称。在 Java 中，可以通过使用键/值对映射来实现这种模型。
- en: 8.1.7 Mapping a map
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.7 映射映射
- en: To accommodate user-supplied names for the image files, we’ll change the Java
    class to use a `Map` property.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适应用户提供的图像文件名称，我们将更改 Java 类以使用 `Map` 属性。
- en: Listing 8.6 Persistent map storing its key and value pairs
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.6 持久化映射存储其键和值对
- en: '[PRE8]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Ⓐ Each map entry is a key/value pair. Here the key is mapped with `@MapKeyColumn`
    to `FILENAME`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 每个映射条目都是一个键/值对。在这里，键通过 `@MapKeyColumn` 映射到 `FILENAME`。
- en: Ⓑ The value is the `IMAGENAME` column. This means the user can only use a file
    once because a `Map` doesn’t allow duplicate keys.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 值是 `IMAGENAME` 列。这意味着用户只能使用一个文件一次，因为 `Map` 不允许重复的键。
- en: As you can see from the schema in figure 8.5, the primary key of the collection
    table is a composite of `ITEM_ID` and `FILENAME`. The example uses a `String`
    as the key for the map, but Hibernate supports any basic type, such as `BigDecimal`
    or `Integer`. If the key is a Java `enum`, we must use `@MapKeyEnumerated`. With
    any temporal types such as `java.util.Date`, use `@MapKeyTemporal`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从图 8.5 中的模式中看到的那样，集合表的键是 `ITEM_ID` 和 `FILENAME` 的组合。示例使用 `String` 作为映射的键，但
    Hibernate 支持任何基本类型，例如 `BigDecimal` 或 `Integer`。如果键是 Java `enum`，则必须使用 `@MapKeyEnumerated`。对于任何时间类型，如
    `java.util.Date`，使用 `@MapKeyTemporal`。
- en: '![](../../OEBPS/Images/CH08_F05_Tudose2.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../../OEBPS/Images/CH08_F05_Tudose2.png)'
- en: Figure 8.5 Tables for a map, using strings as indexes and elements
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 使用字符串作为索引和元素的映射表
- en: The map in the previous example was unordered. If the list of files is long,
    and we would like to quickly look for something at a glance, how can we always
    sort map entries by filename?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，映射是无序的。如果文件列表很长，我们想要快速浏览寻找某个东西，我们如何始终按文件名对映射条目进行排序？
- en: 8.1.8 Sorted and ordered collections
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.8 有序和排序集合
- en: We can *sort* a collection in memory by using a Java comparator. We can *order*
    a collection when it’s loaded from the database by using an SQL query with an
    `ORDER` `BY` clause.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Java 比较器在内存中对集合进行排序。当从数据库加载集合时，我们可以使用带有 `ORDER BY` 子句的 SQL 查询来排序集合。
- en: Let’s make the map of images a sorted map. We need to change the Java property
    and the mapping.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将图像映射转换为有序映射。我们需要更改 Java 属性和映射。
- en: Listing 8.7 Sorting map entries in memory using a comparator
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.7 使用比较器在内存中对映射条目进行排序
- en: '[PRE9]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Sorted collections are a Hibernate feature; hence the annotation `org.hibernate
    .annotations.SortComparator` with an implementation of `java.util.Comparator <String>`—the
    one shown here sorts strings in reverse order. The database schema doesn’t change,
    which is also the case for all the following examples. Look at figures 8.1–8.5
    in the previous sections if you need a reminder.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 有序集合是 Hibernate 的功能；因此使用 `org.hibernate.annotations.SortComparator` 注解，该注解实现了
    `java.util.Comparator <String>`——这里显示的是按逆序排序字符串。数据库模式不会改变，所有以下示例也是如此。如果需要提醒，请查看前几节中的图
    8.1–8.5。
- en: 'We’ll add the following two lines to the test, which will check that the keys
    are now in reverse order:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在测试中添加以下两行，这将检查键现在是否为逆序：
- en: '[PRE10]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We’ll map a `java.util.SortedSet` as demonstrated next. You can find it in the
    sortedsetofstrings example in the mapping-collections folder.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下面的示例中将 `java.util.SortedSet` 进行映射。您可以在映射集合文件夹中的 sortedsetofstrings 示例中找到它。
- en: Listing 8.8 Sorting set elements in memory with `String#compareTo()`
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.8 使用 `String#compareTo()` 在内存中对集合元素进行排序
- en: '[PRE11]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here natural sorting is used, falling back on the `String#compareTo()` method.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用了自然排序，回退到 `String#compareTo()` 方法。
- en: Unfortunately, we can’t sort a bag; there is no `TreeBag`. The indexes of list
    elements predefine their order. Alternatively, instead of switching to `Sorted*`
    interfaces, we may want to retrieve the elements of a collection in the right
    order from the database, rather than sorting in memory. Instead of a `java.util.SortedSet`,
    we’ll use a `java.util.LinkedHashSet` in the following listing.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们无法对包进行排序；没有 `TreeBag`。列表元素的索引预先定义了它们的顺序。或者，我们可能想要从数据库中检索集合元素的正确顺序，而不是在内存中进行排序。在下面的列表中，我们将使用
    `java.util.LinkedHashSet` 而不是切换到 `Sorted*` 接口。而不是使用 `java.util.SortedSet`，我们将使用
    `java.util.LinkedHashSet`。
- en: Listing 8.9 `LinkedHashSet` offers insertion order for iteration
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.9 `LinkedHashSet` 提供了迭代顺序
- en: '[PRE12]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `LinkedHashSet` class has a stable iteration order over its elements, and
    Hibernate will fill it in the right order when loading a collection. To do this,
    Hibernate applies an `ORDER BY` clause to the SQL statement that loads the collection.
    We must declare this SQL clause with the proprietary `@org.hibernate.annotations.OrderBy`
    annotation. We could call an SQL function, like `@OrderBy("substring(FILENAME,
    0, 3) desc")`, which would sort by the first three letters of the filename, but
    be careful to check that the DBMS supports the SQL function you’re calling. Furthermore,
    you can use the SQL:2003 syntax `ORDER BY . . . NULLS FIRST|LAST`, and Hibernate
    will automatically transform it into the dialect supported by your DBMS.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinkedHashSet` 类在其元素上具有稳定的迭代顺序，当加载集合时，Hibernate 将以正确的顺序填充它。为此，Hibernate 将
    `ORDER BY` 子句应用于加载集合的 SQL 语句。我们必须使用专有的 `@org.hibernate.annotations.OrderBy` 注解声明此
    SQL 子句。我们可以调用一个 SQL 函数，例如 `@OrderBy("substring(FILENAME, 0, 3) desc")`，这将按文件名的第一个三个字母进行排序，但请注意检查所调用的
    DBMS 是否支持该 SQL 函数。此外，您可以使用 SQL:2003 语法 `ORDER BY . . . . NULLS FIRST|LAST`，Hibernate
    将自动将其转换为您的 DBMS 所支持的方言。'
- en: If the expression is just a column name with `ASC` or `DESC`, a `@javax .persistence.OrderBy`
    annotation works fine as well. If you need a more elaborate clause (such as the
    `substring()` example in the previous paragraph), an `@org .hibernate.annotations.OrderBy`
    annotation is required.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表达式只是一个带有 `ASC` 或 `DESC` 的列名，则 `@javax.persistence.OrderBy` 注解也适用。如果您需要一个更复杂的子句（如前一段中的
    `substring()` 示例），则需要 `@org.hibernate.annotations.OrderBy` 注解。
- en: Hibernate’s `@OrderBy` vs. JPA’s `@OrderBy`
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate 的 `@OrderBy` 与 JPA 的 `@OrderBy`
- en: You can apply the annotation `@org.hibernate.annotations.OrderBy` to any collection;
    its parameter is a plain SQL fragment that Hibernate attaches to the SQL statement
    loading the collection.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将 `@org.hibernate.annotations.OrderBy` 注解应用于任何集合；其参数是一个简单的 SQL 片段，Hibernate
    会将其附加到加载集合的 SQL 语句中。
- en: Java Persistence has a similar annotation, `@javax.persistence.OrderBy`. Its
    only parameter is not SQL but `someProperty DESC|ASC`. A `String` or `Integer`
    element value has no properties, so when we apply JPA’s `@OrderBy` annotation
    on a collection of a basic type, as in listing 8.9 with `Set<String>`, “the ordering
    will be by value of the basic objects,” according to the specification. This means
    we can’t change the ordering value (just the direction, `asc` or `desc`). We’ll
    use the JPA annotation in section 8.2.2 when the element value class has persistent
    properties and isn’t of basic/scalar type.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Java 持久性有一个类似的注解，`@javax.persistence.OrderBy`。它的唯一参数不是 SQL，而是 `someProperty
    DESC|ASC`。`String` 或 `Integer` 元素值没有属性，因此当我们对基本类型集合应用 JPA 的 `@OrderBy` 注解时，例如列表
    8.9 中的 `Set<String>`，根据规范，“排序将按基本对象的值进行”。这意味着我们无法更改排序值（只是方向，`asc` 或 `desc`）。当元素值类具有持久属性且不是基本/标量类型时，我们将在
    8.2.2 节中使用 JPA 注解。
- en: The next example from `bagofstringsorderby` demonstrates the same ordering at
    load time with a bag mapping. You can find it in the mapping-collections folder.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`bagofstringsorderby` 的下一个示例展示了使用映射包在加载时的相同排序。您可以在映射集合文件夹中找到它。'
- en: Listing 8.10 `ArrayList` provides a stable iteration order
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.10 `ArrayList` 提供稳定的迭代顺序
- en: '[PRE13]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Finally, we can load ordered key/value pairs with a `LinkedHashMap`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用 `LinkedHashMap` 加载有序键/值对。
- en: Listing 8.11 `LinkedHashMap` keeps key/value pairs in order
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.11 `LinkedHashMap` 保持键/值对顺序
- en: '[PRE14]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Keep in mind that the elements of ordered collections are only in the desired
    order when they’re loaded. As soon as we add or remove elements, the iteration
    order of the collections might be different than “by filename”; they behave like
    regular linked sets, maps, or lists. We demonstrated the technical approach, but
    we need to be aware of its shortcomings and to conclude that these make it a somewhat
    unreliable solution.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，有序集合的元素只有在加载时才处于所需顺序。一旦我们添加或删除元素，集合的迭代顺序可能与“按文件名”不同；它们的行为类似于常规的链接集合、映射或列表。我们展示了技术方法，但我们需要意识到其不足之处，并得出结论，这些使其成为一种不太可靠的解决方案。
- en: In a real system, it’s likely that we’ll need to store more than just the image
    name and filename. We’ll probably need to create an `Image` class for extra information
    (such as title, width, and height). This is the perfect use case for a collection
    of components.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际系统中，我们可能需要存储的不仅仅是图像名称和文件名。我们可能需要创建一个 `Image` 类来存储额外信息（如标题、宽度和高度）。这是一个组件集合的完美用例。
- en: 8.2 Collections of components
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2 组件集合
- en: 'We mapped an embeddable component earlier: the `address` of a `User`. The example
    we’re working with in this chapter is different because an `Item` has many references
    to an `Image`, as shown in figure 8.6\. The association in the UML diagram is
    a composition (the black diamond); hence, the referenced `Image`s are bound to
    the lifecycle of the owning `Item`.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前映射了一个可嵌入组件：`User` 的 `address`。我们本章正在处理的示例是不同的，因为 `Item` 有许多对 `Image` 的引用，如图
    8.6 所示。UML 图中的关联是组合（黑色菱形）；因此，引用的 `Image` 与拥有 `Item` 的生命周期绑定。
- en: '![](../../OEBPS/Images/CH08_F06_Tudose2.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH08_F06_Tudose2.png)'
- en: Figure 8.6 Collection of `Image` components in `Item`
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6 `Item` 中的 `Image` 组件集合
- en: The code in the following listing demonstrates the new `Image` embeddable class,
    capturing all the properties of an image that interest us.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表中的代码演示了新的 `Image` 可嵌入类，捕获了我们感兴趣的图像的所有属性。
- en: Listing 8.12 Encapsulating all properties of an image
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.12 封装图像的所有属性
- en: '[PRE15]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: First, note that all the properties are non-optional, `NOT NULL`. The size properties
    are non-nullable because their values are primitives. Second, we have to consider
    equality, and how the database and Java tier compare two images.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请注意，所有属性都是非可选的，`NOT NULL`。大小属性是非可空的，因为它们的值是原始数据类型。其次，我们必须考虑相等性，以及数据库和 Java
    层如何比较两个图像。
- en: 8.2.1 Equality of component instances
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.1 组件实例的相等性
- en: Let’s say we want to keep several `Image` instances in a `HashSet`. We know
    that sets don’t allow duplicate elements, but how do sets detect duplicates? The
    `HashSet` calls the `equals()` method on each `Image` we put in the `Set`. (It
    also calls the `hashCode()` method to get a hash, obviously.)
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想在 `HashSet` 中保留几个 `Image` 实例。我们知道集合不允许重复元素，但集合是如何检测重复的呢？`HashSet` 会调用我们放入
    `Set` 中的每个 `Image` 的 `equals()` 方法。（显然，它也会调用 `hashCode()` 方法来获取哈希值。）
- en: How many images are in the following collection?
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下集合中有多少个图像？
- en: '[PRE16]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Did you expect four images instead of three? You’re right: the regular Java
    equality check relies on identity. The `java.lang.Object#equals()` method compares
    instances with `a==b`. Using this procedure, we’d have four instances of `Image`
    in the collection. Clearly, three is the “correct” answer for this use case.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你预期有四个图像而不是三个吗？你说对了：常规的 Java 相等性检查依赖于标识符。`java.lang.Object#equals()` 方法通过 `a==b`
    比较实例。使用这个程序，我们会在集合中有四个 `Image` 实例。显然，对于这个用例，三个是“正确”的答案。
- en: For the `Image` class, we don’t rely on Java identity—we override the `equals``()`
    and `hashCode()` methods.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Image` 类，我们不依赖于 Java 的标识符——我们覆盖了 `equals()` 和 `hashCode()` 方法。
- en: Listing 8.13 Implementing custom equality with `equals()` and `hashCode()`
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.13 使用 `equals()` 和 `hashCode()` 实现自定义相等性
- en: '[PRE17]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Ⓐ This custom equality check in `equals()` compares all values of one `Image`
    to the values of another `Image`. If all values are the same, the images must
    be the same.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 在 `equals()` 中的这个自定义相等性检查比较了一个 `Image` 的所有值与另一个 `Image` 的值。如果所有值都相同，则图像必须相同。
- en: Ⓑ The `hashCode()` method has to fulfill the contract requiring that if two
    instances are equal, they must have the same hash code.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ `hashCode()` 方法必须满足合同要求，即如果两个实例相等，它们必须具有相同的哈希码。
- en: Why didn’t we override equality in section 6.2, when we mapped the `Address`
    of a `User`? Well, the truth is, we probably should have done that. Our only excuse
    is that we won’t have any problems with the regular identity equality unless we
    put embeddable components into a `Set` or use them as keys in a `Map` that uses
    `equals()` and `hashCode()` for storing and comparison (this means it is not a
    `TreeMap`, which compares items with one another to sort and locate them). We
    should also redefine equality based on values, not identity. It’s best if we override
    these methods on every `@Embeddable` class; all value types should be compared
    “by value.”
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么在第 6.2 节我们没有覆盖相等性，当我们映射 `User` 的 `Address` 时？事实上，我们可能真的应该这么做。我们唯一的借口是，除非我们将可嵌入组件放入
    `Set` 或将它们用作使用 `equals()` 和 `hashCode()` 进行存储和比较的 `Map` 的键（这意味着它不是一个 `TreeMap`，它通过比较项目来排序和定位它们），否则我们不会遇到常规的标识符相等性问题。我们还应该根据值而不是标识符重新定义相等性。最好是在每个
    `@Embeddable` 类上覆盖这些方法；所有值类型都应该按值进行比较。
- en: 'Now consider the database primary key: Hibernate will generate a schema that
    includes all non-nullable columns of the `IMAGE` collection table in a composite
    primary key. The columns have to be non-nullable because we can’t identify what
    we don’t know. This reflects the equality implementation in the Java class. We’ll
    look at the schema in the next section, with more details about the primary key.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑数据库主键：Hibernate 将生成一个包含 `IMAGE` 集合表所有非空列的复合主键的模式。这些列必须是不可为空的，因为我们无法识别我们不知道的东西。这反映了
    Java 类中的等价实现。我们将在下一节中查看模式，并详细介绍主键。
- en: 'Note There is a minor problem with Hibernate’s schema generator: if we annotate
    an embeddable’s property with `@NotNull` instead of `@Column (nullable=false)`,
    Hibernate won’t generate a `NOT` `NULL` constraint for the collection table’s
    column. A Bean Validation check of an instance works as expected, but the database
    schema is missing the integrity rule. Use `@Column(nullable=false)` if the embeddable
    class is mapped in a collection and the property should be part of the primary
    key.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Hibernate 的模式生成器存在一个小的问题：如果我们用 `@NotNull` 而不是 `@Column (nullable=false)`
    注解一个可嵌入属性的属性，Hibernate 不会为集合表的列生成 `NOT NULL` 约束。实例的 Bean Validation 检查按预期工作，但数据库模式缺少完整性规则。如果可嵌入类在集合中映射，并且属性应该是主键的一部分，请使用
    `@Column(nullable=false)`。
- en: The component class is now ready, and we can use it in collection mappings.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 组件类现在已准备就绪，我们可以在集合映射中使用它。
- en: 8.2.2 Set of components
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.2 组件的 `Set`
- en: We can map a `Set` of components as shown next. Keep in mind that a `Set` is
    a type of collection that allows only unique items.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以映射一个如以下所示组件的 `Set`。请记住，`Set` 是一种只允许唯一项的集合类型。
- en: Listing 8.14 A `Set` of embeddable components with an override
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.14 带覆盖的嵌入组件 `Set`
- en: '[PRE18]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Ⓐ As before, the `@ElementCollection` annotation is required. Hibernate automatically
    knows that the target of the collection is an `@Embeddable` type from the declaration
    of a generic collection.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 如前所述，需要 `@ElementCollection` 注解。Hibernate 自动知道集合的目标是一个 `@Embeddable` 类型，这是从泛型集合的声明中得知的。
- en: Ⓑ The `@CollectionTable` annotation overrides the default name for the collection
    table, which would have been `ITEM_IMAGES`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ `@CollectionTable` 注解覆盖了集合表的默认名称，原本应该是 `ITEM_IMAGES`。
- en: The `Image` mapping defines the columns of the collection table. Just as for
    a single embedded value, we can use `@AttributeOverride` to customize the mapping
    without modifying the target embeddable class.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`Image` 映射定义了集合表的列。正如对于单个内嵌值一样，我们可以使用 `@AttributeOverride` 注解来定制映射，而不需要修改目标可嵌入类。'
- en: 'Look at the database schema in figure 8.7\. We’re mapping a set, so the primary
    key of the collection table is a composite of the foreign key column `ITEM_ID`
    and all “embedded” non-nullable columns: `FNAME`, `WIDTH`, and `HEIGHT`.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 查看图 8.7 中的数据库模式。我们正在映射一个集合，因此集合表的主键是由外键列 `ITEM_ID` 和所有“内嵌”的非空列 `FNAME`、`WIDTH`
    和 `HEIGHT` 组成的复合键。
- en: '![](../../OEBPS/Images/CH08_F07_Tudose2.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH08_F07_Tudose2.png)'
- en: Figure 8.7 Example data tables for a collection of components
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.7 组件集合的示例数据表
- en: The `ITEM_ID` value wasn’t included in the overridden `equals``()` and `hashCode()`
    methods of `Image`, as discussed in the previous section. Therefore, if we mix
    images of different items in one set, we’ll run into equality problems in the
    Java tier. In the database table, we obviously can distinguish the images of different
    items because the item’s identifier is included in primary key equality checks.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`ITEM_ID` 值没有包含在 `Image` 的覆盖 `equals()` 和 `hashCode()` 方法中。因此，如果我们在一个集合中混合不同项目的图像，我们将在
    Java 层遇到等价问题。在数据库表中，我们可以区分不同项目的图像，因为项目的标识符包含在主键等价检查中。
- en: 'If we want to include the `Item` in the equality routine of the `Image`, to
    be symmetric with the database primary key, we’ll need an `Image#item` property.
    This is a simple back-pointer provided by Hibernate when `Image` instances are
    loaded:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在 `Image` 的等价例程中包含 `Item`，以与数据库主键保持对称，我们需要一个 `Image#item` 属性。这是 Hibernate
    在加载 `Image` 实例时提供的一个简单回指针：
- en: '[PRE19]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We can now include the parent `Item` value in the `equals``()` and `hashCode()`
    implementations.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将父 `Item` 值包含在 `equals()` 和 `hashCode()` 实现中。
- en: 'In the next code snippet, we’ll match the `FILENAME` field to the `FNAME` column
    using the `@AttributeOverride` annotation:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个代码片段中，我们将使用 `@AttributeOverride` 注解将 `FILENAME` 字段匹配到 `FNAME` 列：
- en: '[PRE20]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We’ll similarly have to change the native query in the `ItemRepository` interface:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须在 `ItemRepository` 接口中更改原生查询：
- en: '[PRE21]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If we need load-time ordering of elements and a stable iteration order with
    a `LinkedHashSet`, we can use the JPA `@OrderBy` annotation:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要在加载时对元素进行排序，并使用 `LinkedHashSet` 保持稳定的迭代顺序，我们可以使用 JPA `@OrderBy` 注解：
- en: '[PRE22]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The arguments of the `@OrderBy` annotation are properties of the `Image` class,
    followed by either `ASC` for ascending or `DESC` for descending order. The default
    is ascending. This example sorts descending by image filename and then descending
    by the width of each image. Note that this is different from the proprietary `@org.hibernate.annotations
    .OrderBy` annotation, which takes a plain SQL clause, as discussed in section
    8.1.8.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`@OrderBy` 注解的参数是 `Image` 类的属性，后面跟着 `ASC` 表示升序或 `DESC` 表示降序。默认是升序。此示例按图像文件名降序排序，然后按每个图像的宽度降序排序。请注意，这与在第
    8.1.8 节中讨论的专有 `@org.hibernate.annotations.OrderBy` 注解不同，它接受一个纯 SQL 子句。'
- en: Declaring all properties of `Image` as `@NotNull` may not be something we want.
    If any of the properties are optional, we’ll need a different primary key for
    the collection table.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `Image` 的所有属性声明为 `@NotNull` 可能不是我们想要的。如果任何属性是可选的，我们需要为集合表提供一个不同的主键。
- en: 8.2.3 Bag of components
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.3 组件包
- en: 'We used the `@org.hibernate.annotations.CollectionId` annotation before adding
    a surrogate key column to the collection table. The collection type, however,
    was not a `Set` but a general `Collection`, a bag. This is consistent with our
    updated schema: if we have a surrogate primary key column, duplicate element values
    are allowed. Let’s walk through this with the `bagofembeddables` example.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在向集合表添加代理键列之前，我们使用了 `@org.hibernate.annotations.CollectionId` 注解。然而，集合类型不是一个
    `Set`，而是一个通用的 `Collection`，一个包。这与我们的更新模式一致：如果我们有一个代理主键列，允许重复的元素值。让我们通过 `bagofembeddables`
    示例来了解这一点。
- en: 'First, the `Image` class can now have nullable properties, as we’ll have a
    surrogate key:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`Image` 类现在可以有可空属性，因为我们会有一个代理键：
- en: '[PRE23]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Remember to account for the optional `title` of the `Image` in the overridden
    `equals``()` and `hashCode()` methods when comparing instances by value. For example,
    the comparison of the title fields will be done in the equals method like this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在通过值比较实例时，考虑 `Image` 的可选 `title` 在重写的 `equals()` 和 `hashCode()` 方法中的情况。例如，标题字段的比较将在
    `equals` 方法中这样进行：
- en: '[PRE24]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, take a look at the mapping of the bag collection in `Item`. As before,
    in section 8.1.5, we declare an additional surrogate primary key column, `IMAGE_ID`,
    with the proprietary `@org.hibernate.annotations.CollectionId` annotation:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，查看 `Item` 中的包集合映射。和之前一样，在第 8.1.5 节中，我们声明了一个额外的代理主键列，`IMAGE_ID`，使用专有的 `@org.hibernate.annotations.CollectionId`
    注解：
- en: '[PRE25]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Figure 8.8 shows the database schema. The `title` of the `Image` with identifier
    2 is `null`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.8 显示了数据库模式。标识符为 2 的 `Image` 的 `title` 是 `null`。
- en: '![](../../OEBPS/Images/CH08_F08_Tudose2.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH08_F08_Tudose2.png)'
- en: Figure 8.8 Collection of components table with a surrogate primary key column
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.8 带有代理主键列的组件集合表
- en: Next, we’ll analyze another way to change the primary key of the collection
    table with a `Map`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将分析使用 `Map` 改变集合表主键的另一种方法。
- en: 8.2.4 Map of component values
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.4 组件值映射图
- en: 'A map keeps the information as pairs of keys and values. If the `Image`s are
    stored in a `Map`, the filename can be the map key:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 一个映射将信息保持为键值对的组合。如果 `Image` 存储在映射中，文件名可以是映射键：
- en: '[PRE26]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Ⓐ The key column of the map is set to `TITLE`. Otherwise, it will default to
    `IMAGES_KEY`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 映射的关键列设置为 `TITLE`。否则，它将默认为 `IMAGES_KEY`。
- en: 'The test will set the `TITLE` column by executing instructions of this kind:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 测试将通过执行此类指令来设置 `TITLE` 列：
- en: '[PRE27]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The primary key of the collection table, as shown in figure 8.9, is now the
    foreign key column `ITEM_ID` and the key column of the map, `TITLE`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 集合表的主键，如图 8.9 所示，现在是外键列 `ITEM_ID` 和映射的关键列 `TITLE`。
- en: '![](../../OEBPS/Images/CH08_F09_Tudose2.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH08_F09_Tudose2.png)'
- en: Figure 8.9 Database tables for a map of components
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.9 组件映射的数据库表
- en: 'The embeddable `Image` class maps all other columns, which may be nullable:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 可嵌入的 `Image` 类映射所有其他列，这些列可能是可空的：
- en: '[PRE28]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Ⓐ The `filename` field can now be null; it is not part of the primary key.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ `filename` 字段现在可以是 null；它不是主键的一部分。
- en: Here the values in the map are instances of an embeddable component class and
    the keys of the map a basic string. Next we’ll use embeddable types for both key
    and value.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，映射中的值是可嵌入组件类的实例，而键是基本字符串。接下来，我们将为键和值都使用可嵌入类型。
- en: 8.2.5 Components as map keys
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.5 组件作为映射键
- en: Our final example is mapping a `Map`, with both keys and values of embeddable
    type, as you can see in figure 8.10.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最终示例是将一个`Map`映射，如图8.10所示，其中键和值都是可嵌入类型。
- en: '![](../../OEBPS/Images/CH08_F10_Tudose2.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH08_F10_Tudose2.png)'
- en: Figure 8.10 The `Item` has a `Map` keyed by `Filename`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10 `Item`有一个按`Filename`键的`Map`。
- en: Instead of a string representation, we can represent a filename with a custom
    type.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用自定义类型来表示文件名，而不是字符串表示。
- en: Listing 8.15 Representing a filename with a custom type
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.15 使用自定义类型表示文件名
- en: '[PRE29]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Ⓐ The `name` field must not be null, as it is part of the primary key. If we
    want to use this class for the keys of a map, the mapped database columns can’t
    be nullable because they’re all part of a composite primary key. We also have
    to override the `equals``()` and `hashCode()` methods because the keys of a map
    are a set, and each `Filename` must be unique within a given key set.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ `name`字段不能为空，因为它是主键的一部分。如果我们想用这个类作为映射的键，映射的数据库列不能为可空，因为它们都是复合主键的一部分。我们还必须重写`equals()`和`hashCode()`方法，因为映射的键是一个集合，每个`Filename`必须在给定的键集中是唯一的。
- en: 'We don’t need any special annotations to map the collection:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要任何特殊的注解来映射集合：
- en: '[PRE30]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In fact, we can’t apply `@MapKeyColumn` and `@AttributeOverrides`; they have
    no effect when the map’s key is an `@Embeddable` class.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们不能应用`@MapKeyColumn`和`@AttributeOverrides`；当映射的键是一个`@Embeddable`类时，它们没有任何效果。
- en: The composite primary key of the `IMAGE` table includes the `ITEM_ID` and `NAME`
    columns, as you can see in figure 8.11\. A composite embeddable class like `Image`
    isn’t limited to simple properties of basic types. You’ve already seen how to
    nest other components, such as `City` in `Address`. We could extract and encapsulate
    the `width` and `height` properties of `Image` in a new `Dimensions` class.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`IMAGE`表的复合主键包括`ITEM_ID`和`NAME`列，如图8.11所示。像`Image`这样的复合可嵌入类不仅限于基本类型的基本属性。您已经看到了如何嵌套其他组件，例如`Address`中的`City`。我们可以在新的`Dimensions`类中提取和封装`Image`的`width`和`height`属性。'
- en: '![](../../OEBPS/Images/CH08_F11_Tudose2.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH08_F11_Tudose2.png)'
- en: Figure 8.11 Database tables for a `Map` of `Image`s keyed on `Filename`s
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11 `Image`s的`Filename`s键的`Map`数据库表
- en: An embeddable class can also have its own collections.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 可嵌入类也可以有自己的集合。
- en: 8.2.6 Collection in an embeddable component
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.6 可嵌入组件中的集合
- en: 'Suppose that for each `Address`, we want to store a list of contacts. This
    is a simple `Set<String>` in the embeddable class:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 假设对于每个`Address`，我们想要存储一个联系人列表。在可嵌入类中，这是一个简单的`Set<String>`：
- en: '[PRE31]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Ⓐ The `@ElementCollection` is the only required annotation; the table and column
    names have default values. The table name would default to `USER_CONTACTS`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ `@ElementCollection`是唯一必需的注解；表和列名有默认值。表名默认为`USER_CONTACTS`。
- en: Ⓑ The join column would be `USER_ID` by default.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 连接列默认为`USER_ID`。
- en: Ⓒ The column name would default to `CONTACTS`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 列名默认为`CONTACTS`。
- en: 'Look at the schema in figure 8.12: the `USER_ID` column has a foreign key constraint
    referencing the owning entity’s table, `USERS`. The primary key of the collection
    table is a composite of the `USER_ID` and `NAME` columns, preventing duplicate
    elements, so a `Set is` appropriate.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 看图8.12中的模式：`USER_ID`列有一个外键约束，引用拥有实体的表`USERS`。集合表的主键是`USER_ID`和`NAME`列的复合，防止重复元素，因此`Set`是合适的。
- en: '![](../../OEBPS/Images/CH08_F12_Tudose2.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH08_F12_Tudose2.png)'
- en: Figure 8.12 `USER_ID` has a foreign key constraint referencing `USERS`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12 `USER_ID`有一个外键约束，引用`USERS`。
- en: Instead of a `Set`, we could map a list, bag, or map of basic types. Hibernate
    also supports collections of embeddable types, so instead of a simple contact
    string, we could write an embeddable `Contact` class and have `Address` hold a
    collection of `Contacts`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用列表、包或基本类型的映射来代替`Set`。Hibernate还支持可嵌入类型的集合，因此我们可以写一个可嵌入的`Contact`类，让`Address`持有`Contacts`的集合。
- en: Although Hibernate gives a lot of flexibility with component mappings and fine-grained
    models, be aware that code is read more often than it’s written. Think about the
    next developer who will have to maintain this in a few years.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Hibernate在组件映射和细粒度模型方面提供了很多灵活性，但请注意，代码的阅读次数往往多于编写次数。想想几年后将要维护这个项目的下一个开发者。
- en: 'Switching focus, let’s turn our attention to entity associations: in particular,
    simple *many-to-one* and *one-to-many* associations.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 转移焦点，让我们将注意力转向实体关联：特别是简单的*多对一*和*一对多*关联。
- en: 8.3 Mapping entity associations
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3 映射实体关联
- en: 'At the beginning of this chapter, we promised to talk about parent/child relationships.
    So far, we’ve looked at the mapping of an entity, `Item`. Let’s say this is the
    parent, and it has a collection of children: the collection of `Image` instances.
    The term *parent/child* implies some kind of lifecycle dependency, so a collection
    of strings or embeddable components is appropriate. The children are fully dependent
    on the parent; they will always be saved, updated, and removed with the parent,
    never alone.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们承诺要讨论父子关系。到目前为止，我们已经研究了实体`Item`的映射。假设这是父实体，并且它有一个子实体的集合：`Image`实例的集合。术语*父子*意味着某种生命周期依赖性，因此字符串集合或可嵌入组件是合适的。子实体完全依赖于父实体；它们将始终与父实体一起保存、更新和删除，而不会单独存在。
- en: We’ve already mapped a parent/child relationship! The parent was an entity,
    and the many children were of value type. When an `Item` is removed, its collection
    of `Image` instances will also be removed. (The actual images may be removed in
    a transactional way, meaning we’ll either delete the rows from the database together
    with the files from the disk, or nothing at all. This is, however, a separate
    problem that we won’t deal with here.)
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经映射了一个父子关系！父实体是一个实体，而许多子实体是值类型。当删除一个`Item`时，其`Image`实例的集合也将被删除。（实际的图像可能会以事务方式删除，这意味着我们将一起从数据库中删除行和从磁盘上的文件，或者什么都不做。然而，这却是一个独立的问题，我们在这里不会处理。）
- en: 'We now want to map relationships of a different kind: associations between
    two entity classes. Their instances won’t have dependent lifecycles—one instance
    can be saved, updated, and removed without affecting another. Naturally, *sometimes*
    there will be dependencies, even between entity instances, but we’ll need more
    fine-grained control over how the relationship between the two classes affects
    instance state, unlike with completely dependent (embedded) types. Are we still
    talking about a parent/ child relationship here? It turns out that the *parent/child*
    term is vague, and everyone has their own definition. We’ll try not to use that
    term from now on, and we’ll instead rely on more precise, or at least well-defined,
    vocabulary.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要映射不同类型的关联：两个实体类之间的关联。它们的实例不会具有依赖的生命周期——一个实例可以保存、更新和删除，而不会影响另一个实例。当然，*有时*实体实例之间也会有依赖关系，但我们需要对两个类之间的关系如何影响实例状态有更细粒度的控制，这与完全依赖（嵌入）类型不同。我们在这里还在讨论父子关系吗？事实证明，*父子*这个术语是模糊的，每个人都有自己的定义。我们将尽量不再使用这个术语，而将依靠更精确的，或者至少是定义良好的，词汇。
- en: '![](../../OEBPS/Images/CH08_F13_Tudose2.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH08_F13_Tudose2.png)'
- en: Figure 8.13 Relationship between `Item` and `Bid`
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.13 `Item`和`Bid`之间的关系
- en: 'The relationship we’ll explore in the following sections will remain the same:
    a relationship between the `Item` and `Bid` entity classes, as shown in figure
    8.13\. The association from `Bid` to `Item` is a *many-to-one* association. Later
    we’ll make this association bidirectional, so the inverse association from `Item`
    to `Bid` will be *one-to-many*.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将探讨的关系将保持不变：`Item`和`Bid`实体类之间的关系，如图8.13所示。从`Bid`到`Item`的关联是一个*多对一*关联。稍后我们将使这个关联双向，因此从`Item`到`Bid`的反向关联将是*一对多*。
- en: The *many-to-one* association is the simplest, so we’ll talk about it first.
    The other associations, *many-to-many* and *one-to-one*, are more complex, and
    we’ll discuss them in the next chapter.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '*多对一*关联是最简单的，所以我们将首先讨论它。其他关联，*多对多*和*一对多*，更复杂，我们将在下一章讨论。'
- en: Let’s start with the *many-to-one* association that we need to implement in
    the CaveatEmptor application, and let’s see what alternatives we have. The source
    code that follows can be found in the mapping-associations folder.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从需要在CaveatEmptor应用程序中实现的*多对一*关联开始，并看看我们有哪些替代方案。下面的源代码可以在mapping-associations文件夹中找到。
- en: 8.3.1 The simplest possible association
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.1 最简单的关联
- en: We call the mapping of the `Bid#item` property a *unidirectional many-to-one
    association*. Before we analyze this mapping, look at the database schema in figure
    8.14 and the code in listing 8.16.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称 `Bid#item` 属性的映射为 *单向多对一关联*。在我们分析这个映射之前，看看图 8.14 中的数据库模式和列表 8.16 中的代码。
- en: '![](../../OEBPS/Images/CH08_F14_Tudose2.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH08_F14_Tudose2.png)'
- en: Figure 8.14 A many-to-one relationship in the SQL schema
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.14 SQL 模式中的一种多对一关系
- en: Listing 8.16 `Bid` has a single reference to an `Item`
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.16 `Bid` 对 `Item` 有单一引用
- en: '[PRE32]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Ⓐ The `@ManyToOne` annotation marks a property as an entity association, and
    it’s required. Its fetch parameter defaults to `EAGER`, which means the associated
    Item is loaded whenever the `Bid` is loaded. We usually prefer lazy loading as
    a default strategy, and we’ll talk more about it later in section 12.1.1.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ `@ManyToOne` 注解将一个属性标记为实体关联，并且是必需的。它的获取参数默认为 `EAGER`，这意味着当加载 `Bid` 时，关联的 `Item`
    也会被加载。我们通常更喜欢将懒加载作为默认策略，我们将在第 12.1.1 节中进一步讨论。
- en: 'A *many-to-one* entity association maps naturally to a foreign key column:
    `ITEM_ID` in the `BID` table. In JPA, this is called the *join column*. We don’t
    need anything but the `@ManyToOne` annotation on the property. The default name
    for the join column is `ITEM_ID`: Hibernate automatically uses a combination of
    the target entity name and its identifier property, separated with an underscore.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *多对一* 实体关联自然映射到外键列：`BID` 表中的 `ITEM_ID`。在 JPA 中，这被称为 *连接列*。我们只需要在属性上使用 `@ManyToOne`
    注解。连接列的默认名称是 `ITEM_ID`：Hibernate 自动使用目标实体名称及其标识属性的组合，用下划线分隔。
- en: 'We can override the foreign key column with the `@JoinColumn` annotation, but
    we used it here for a different reason: to make the foreign key column `NOT NULL`
    when Hibernate generates the SQL schema. A bid always has to have a reference
    to an item; it can’t survive on its own. (Note that this already indicates some
    kind of lifecycle dependency we have to keep in mind.) Alternatively, we could
    mark this association as non-optional with either `@ManyToOne(optional = false)`
    or, as usual, with Bean Validation’s `@NotNull`.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用 `@JoinColumn` 注解覆盖外键列，但在这里我们使用它的另一个原因：当 Hibernate 生成 SQL 模式时，使外键列 `NOT
    NULL`。一个出价总是必须有一个对项目的引用；它不能独立存在。（注意，这已经表明我们必须注意某种生命周期依赖。）或者，我们可以用 `@ManyToOne(optional
    = false)` 或通常的 Bean Validation 的 `@NotNull` 标记这个关联为非可选。
- en: That was easy. It’s critically important to realize that we can write a complete
    and complex application without using anything else.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单。重要的是要意识到，我们可以编写一个完整且复杂的应用程序，而不需要使用任何其他东西。
- en: 'We don’t need to map the other side of this relationship; we can ignore the
    *one-to-many* association from `Item` to `Bid`. There is only a foreign key column
    in the database schema, and we’ve already mapped it. We are serious about this:
    when you see a foreign key column and two entity classes involved, you should
    probably map it with `@ManyToOne` and nothing else.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要映射这个关系的另一边；我们可以忽略从 `Item` 到 `Bid` 的 *一对多* 关联。数据库模式中只有一个外键列，我们已经映射了它。我们对此是认真的：当你看到一个外键列和两个实体类时，你可能应该用
    `@ManyToOne` 来映射，而不用其他任何东西。
- en: We can now get the `Item` of each `Bid` by calling `someBid.getItem()`. The
    JPA provider will dereference the foreign key and load the `Item` for us, and
    it will also take care of managing the foreign key values. How can we get all
    of an item’s bids? We can write a query and execute it with `EntityManager` or
    `JpaRepository` in whatever query language Hibernate supports. For example, in
    JPQL, we’d use `select b from Bid` `b` `where` `b.item` `=` `:itemParameter`.
    One of the reasons we use Hibernate or Spring Data JPA is, of course, that in
    most cases we don’t want to write and execute that query ourselves.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过调用 `someBid.getItem()` 来获取每个 `Bid` 的 `Item`。JPA 提供商会取消引用外键并为我们加载 `Item`，它还会负责管理外键值。我们如何获取一个项目的所有出价？我们可以编写一个查询，并用
    `EntityManager` 或 `JpaRepository` 在 Hibernate 支持的任何查询语言中执行它。例如，在 JPQL 中，我们会使用
    `select b from Bid` `b` `where` `b.item` `=` `:itemParameter`。我们使用 Hibernate 或
    Spring Data JPA 的一个原因当然是，在大多数情况下，我们不想自己编写和执行那个查询。
- en: 8.3.2 Making it bidirectional
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.2 使其双向
- en: 'At the beginning of this chapter, in section 8.1.2, we had a list of reasons
    why a mapping of the `Item#images` collection was a good idea. Let’s do the same
    for the `Item#bids` collection. This collection will implement the *one-to-many*
    association between `Item` and `Bid` entity classes. If we create and map this
    collection property, we’ll get the following:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，在第8.1.2节中，我们列出了为什么将`Item#images`集合映射为一个好主意的原因。让我们为`Item#bids`集合做同样的事情。这个集合将实现`Item`和`Bid`实体类之间的*一对一*关联。如果我们创建并映射这个集合属性，我们将得到以下内容：
- en: Hibernate executes the SQL query `SELECT` `*` `from` `BID` `where` `ITEM_ID`
    `=` `?` automatically when we call `someItem.getBids()` and start iterating through
    the collection elements.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们调用`someItem.getBids()`并开始遍历集合元素时，Hibernate会自动执行SQL查询`SELECT * FROM BID WHERE
    ITEM_ID = ?`。
- en: We can *cascade* state changes from an `Item` to all referenced `Bid`s in the
    collec- tion. We can select what lifecycle events should be transitive; for example,
    we could declare that all referenced `Bid` instances should be saved when an `Item`
    is saved, so we don’t have to call `EntityManager#persist()` or `ItemRepository#save()`
    repeatedly for all bids.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以从一个`Item`对象级联状态变化到集合中所有引用的`Bid`对象。我们可以选择哪些生命周期事件应该是可传递的；例如，我们可以声明当保存`Item`时，所有引用的`Bid`实例都应该被保存，这样我们就不必反复调用`EntityManager#persist()`或`ItemRepository#save()`来保存所有竞标。
- en: 'Well, that isn’t a very long list. The primary benefit of one-to-many mappings
    is navigational access to data. It’s one of the core promises of ORM, enabling
    us to access data by calling only methods of our Java domain model. The ORM engine
    is supposed to take care of loading the required data in a smart way while we
    work with a high-level interface of our own design: `someItem.getBids().iterator().next().getAmount()`,
    and so on.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这不是一个非常长的列表。一对一映射的主要好处是数据导航访问。这是ORM的核心承诺之一，它使我们能够通过仅调用我们的Java域模型的方法来访问数据。ORM引擎应该在我们使用自己设计的高级接口工作时，以智能的方式加载所需的数据：`someItem.getBids().iterator().next().getAmount()`，等等。
- en: The fact that you can optionally cascade some state changes to related instances
    is a nice bonus. Consider, though, that some dependencies indicate value types
    at the Java level, and they do not indicate entities. Ask yourself if any table
    in the schema will have a `BID_ID` foreign key column. If not, map the `Bid` class
    as `@Embeddable`, not `@Entity`, using the same tables as before but with a different
    mapping with fixed rules for transitive state changes. If any other table has
    a foreign key reference on any `BID` row, we’ll need a shared `Bid` entity; it
    can’t be mapped embedded with an `Item`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择级联一些状态变化到相关实例，这是一个很好的额外功能。然而，请考虑，某些依赖在Java级别指示了值类型，而没有指示实体。问问自己，模式中的任何表是否将有一个`BID_ID`外键列。如果没有，使用与之前相同的表映射`Bid`类为`@Embeddable`，而不是`@Entity`，但对于传递状态变化的映射使用不同的规则。如果有任何其他表在`BID`行的任何地方有外键引用，我们需要一个共享的`Bid`实体；它不能与`Item`一起嵌入映射。
- en: So should we map the `Item#bids` collection at all? We’ll get navigational data
    access, but the price we’ll pay is additional Java code and significantly more
    complexity. This is frequently a difficult decision; the choice of mapping the
    collection should rarely be taken. How often will we call `someItem.getBids()`
    in the application and then access or display all bids in a predefined order?
    If we only want to display a subset of the bids, or if we need to retrieve them
    in a different order every time, we’d need to write and execute queries manually
    anyway. The one-to-many mapping and its collection would only be maintenance baggage.
    In our experience, this is a frequent source of problems and bugs, especially
    for ORM beginners.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们是否应该映射`Item#bids`集合呢？我们将获得导航数据访问，但我们必须付出的代价是额外的Java代码和显著增加的复杂性。这通常是一个困难的决策；很少应该选择映射集合。在应用程序中，我们多久会调用一次`someItem.getBids()`，然后按预定义的顺序访问或显示所有竞标？如果我们只想显示竞标的一个子集，或者如果我们每次都需要以不同的顺序检索它们，我们无论如何都需要手动编写和执行查询。一对一映射及其集合将只是一种维护负担。根据我们的经验，这是常见的问题和错误来源，尤其是对于ORM初学者。
- en: '![](../../OEBPS/Images/CH08_F15_Tudose2.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH08_F15_Tudose2.png)'
- en: Figure 8.15 Bidirectional association between `Item` and `Bid`
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.15 `Item`和`Bid`之间的双向关联
- en: In CaveatEmptor’s case, the answer is yes, we’ll frequently call `someItem.getBids()`
    and then show a list to the user who wants to participate in an auction. Figure
    8.15 shows the updated UML diagram with the bidirectional association that we
    need to implement.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CaveatEmptor 的情况下，答案是肯定的，我们经常会调用 `someItem.getBids()` 然后向想要参加拍卖的用户展示一个列表。图
    8.15 显示了我们需要实现的具有双向关联的更新后的 UML 图。
- en: The mapping of the collection and the one-to-many side is as follows.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 集合映射和一对一映射的映射如下。
- en: Listing 8.17 `Item` has a collection of `Bid` references
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.17 `Item` 拥有一组 `Bid` 引用
- en: '[PRE33]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Ⓐ The `@OneToMany` annotation is required to make the association bidirectional.
    In this case, we also have to set the `mappedBy` parameter.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 要使关联双向，需要使用 `@OneToMany` 注解。在这种情况下，我们还需要设置 `mappedBy` 参数。
- en: Ⓑ The argument is the name of the property on the “other side.” The fetching
    will be `LAZY` by default.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 参数是“另一边”属性的名称。默认情况下，获取将是 `LAZY`。
- en: Look again at the other side—the many-to-one mapping in listing 8.16\. The property
    name in the `Bid` class is `item`. The bid side is responsible for the foreign
    key column, `ITEM_ID`, which we mapped with `@ManyToOne`. Here, `mappedBy` tells
    Hibernate to “load this collection using the foreign key column already mapped
    by the given property”—in this case, `Bid#item`. The `mappedBy` parameter is always
    required when the one-to-many is bidirectional and we’ve already mapped the foreign
    key column. We’ll talk about that again in the next chapter.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 再次看看另一边——列表 8.16 中的多对一映射。`Bid` 类中的属性名是 `item`。出价方负责外键列，`ITEM_ID`，我们使用 `@ManyToOne`
    进行了映射。在这里，`mappedBy` 告诉 Hibernate 使用给定属性已映射的外键列来“加载此集合”——在这种情况下，`Bid#item`。当一对一双向且已映射外键列时，`mappedBy`
    参数始终是必需的。我们将在下一章再次讨论这一点。
- en: The default for the `fetch` parameter of a collection mapping is always `FetchType
    .LAZY`, so we won’t need this option in the future. It’s a good default setting;
    the opposite would be the rarely needed `EAGER`. We don’t want all the `bids`
    eagerly loaded every time we load an `Item`. They should be loaded when accessed,
    on demand.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 集合映射的 `fetch` 参数的默认值始终是 `FetchType.LAZY`，因此我们将来不需要此选项。这是一个好的默认设置；相反，很少需要的 `EAGER`。我们不希望在每次加载
    `Item` 时都懒加载所有 `bids`。它们应该在访问时按需加载。
- en: We can now create the following two Spring Data JPA repositories.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以创建以下两个 Spring Data JPA 仓库。
- en: Listing 8.18 The `ItemRepository` interface
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.18 `ItemRepository` 接口
- en: '[PRE34]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Listing 8.19 The `BidRepository` interface
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.19 `BidRepository` 接口
- en: '[PRE35]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: These are regular Spring Data JPA repositories, with the `BidRepository` adding
    a method to get the bids by `Item`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是常规的 Spring Data JPA 仓库，`BidRepository` 添加了一个通过 `Item` 获取出价的方法。
- en: The second reason for mapping the `Item#bids` collection is the ability to cascade
    state changes, so let’s look at that.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `Item#bids` 集合映射的第二个原因是能够级联状态变化，让我们看看这一点。
- en: 8.3.3 Cascading state
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.3 级联状态
- en: If an entity state change can be cascaded across an association to another entity,
    we need fewer lines of code to manage relationships. But this may have a serious
    performance consequence.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果实体状态变化可以通过关联级联到另一个实体，我们需要的代码行数会更少来管理关系。但这可能带来严重的性能影响。
- en: 'The following code creates a new `Item` and a new `Bid` and then links them:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码创建了一个新的 `Item` 和一个新的 `Bid`，然后将它们链接起来：
- en: '[PRE36]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We have to consider both sides of this relationship: the `Bid` constructor
    accepts an item that’s used to populate `Bid#item`. To maintain the integrity
    of the instances in memory, we need to add the bid to `Item#bids`. Now the link
    is complete from the perspective of the Java code; all the references are set.
    If you aren’t sure why you need this code, please refer to section 3.2.4.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须考虑这个关系的两个方面：`Bid` 构造函数接受一个用于填充 `Bid#item` 的项目。为了保持内存中实例的完整性，我们需要将出价添加到 `Item#bids`。现在从
    Java 代码的角度来看，链接已经完成；所有引用都已设置。如果你不确定为什么需要这段代码，请参阅第 3.2.4 节。
- en: Let’s save the item and its bids in the database, first without and then with
    transitive persistence.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先保存项目及其出价到数据库，首先是无需传递性持久化，然后是有传递性持久化。
- en: Enabling transitive persistence
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 启用传递性持久化
- en: With the current mapping of `@ManyToOne` and `@OneToMany`, we need to write
    the following code to save a new `Item` and several `Bid` instances.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 使用当前的 `@ManyToOne` 和 `@OneToMany` 映射，我们需要编写以下代码来保存一个新的 `Item` 和几个 `Bid` 实例。
- en: Listing 8.20 Managing independent entity instances separately
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.20 分别管理独立的实体实例
- en: '[PRE37]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'When we create several bids, calling `EntityManager#persist()` or `BidRepository
    #save()` on each seems redundant. New instances are transient and have to be made
    persistent. The relationship between `Bid` and `Item` doesn’t influence their
    lifecycles. If `Bid` were to be a value type, the state of a `Bid` would automatically
    be the same as the owning `Item`. In this case, however, `Bid` has its own completely
    independent state.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '当我们创建多个出价时，对每个出价调用 `EntityManager#persist()` 或 `BidRepository #save()` 似乎有些冗余。新实例是瞬时的，必须使它们持久化。`Bid`
    和 `Item` 之间的关系不影响它们的生命周期。如果 `Bid` 是一个值类型，`Bid` 的状态将自动与拥有它的 `Item` 相同。然而，在这种情况下，`Bid`
    有它自己的完全独立的状态。'
- en: We said earlier that fine-grained control is sometimes necessary to express
    the dependencies between associated entity classes; this is such a case. The mechanism
    for this in JPA is the `cascade` option. For example, to save all bids when the
    item is saved, map the collection as demonstrated next.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到，有时需要细粒度控制来表达关联实体类之间的依赖关系；这是一个例子。JPA 中实现这一机制的选项是 `cascade`。例如，为了在保存项目时保存所有出价，可以将集合映射如下。
- en: Listing 8.21 Cascading persistent state from `Item` to all `bids`
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.21 从 `Item` 到所有 `bids` 的级联持久化状态
- en: '[PRE38]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Cascading options here intend to be transitive, so we use `CascadeType.PERSIST`
    for the `ItemRepository#save()` or `EntityManager#persist()` operation. We can
    now simplify the code that links items and bids and then saves them.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，级联选项旨在是传递性的，因此我们在 `ItemRepository#save()` 或 `EntityManager#persist()` 操作中使用
    `CascadeType.PERSIST`。现在我们可以简化连接项目和出价并保存它们的代码。
- en: Listing 8.22 All referenced `bids` are automatically made persistent
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.22 所有引用的 `bids` 都自动变为持久化
- en: '[PRE39]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Ⓐ We save the bids automatically, but later. At commit time, Spring Data JPA
    using Hibernate examines the managed/persistent `Item` instance and looks into
    the bids collection. It then calls `save()` internally on each of the referenced
    `Bid` instances, saving them as well. The value stored in the column `BID#ITEM_ID`
    is taken from each `Bid` by inspecting the `Bid#item` property. The foreign key
    column is `mappedBy` with `@ManyToOne` on that property.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 我们自动保存出价，但稍后。在提交时间，Spring Data JPA 使用 Hibernate 检查管理的/持久化的 `Item` 实例，并查看出价集合。然后，它对每个引用的
    `Bid` 实例内部调用 `save()`，也将它们保存。列 `BID#ITEM_ID` 中的值通过检查 `Bid#item` 属性从每个 `Bid` 中获取。外键列是
    `mappedBy`，在该属性上使用 `@ManyToOne`。
- en: 'The `@ManyToOne` annotation also has the `cascade` option. We won’t use this
    often. For example, we can’t really say, “when the bid is saved, also save the
    item.” The item has to exist beforehand; otherwise the bid won’t be valid in the
    database. Think about another possible `@ManyToOne` relationship: the `Item#seller`
    property. The `User` has to exist before they can sell an `Item`.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ManyToOne` 注解也有 `cascade` 选项。我们不会经常使用它。例如，我们真的不能说，“当出价被保存时，也保存项目。”项目必须先存在；否则，出价在数据库中将无效。考虑另一个可能的
    `@ManyToOne` 关系：`Item#seller` 属性。`User` 必须存在，他们才能出售 `Item`。'
- en: Transitive persistence is a simple concept, frequently useful with `@OneToMany`
    or `@ManyToMany` mappings. On the other hand, we have to apply transitive deletion
    carefully.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 传递性持久化是一个简单但经常有用的概念，尤其是在使用 `@OneToMany` 或 `@ManyToMany` 映射时。另一方面，我们必须谨慎地应用传递性删除。
- en: Cascading deletion
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 级联删除
- en: 'It seems reasonable that the deletion of an item implies the deletion of all
    the bids for the item, because they’re not relevant alone. This is what the *composition*
    (the filled-out diamond) in the UML diagram means. With the current cascading
    options, we’ll have to write the following code to delete an item:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎合理的推断是，项目的删除意味着所有相关出价的删除，因为它们单独并不相关。这正是 UML 图中 *组合*（填充的菱形）所表示的。使用当前的级联选项，我们将不得不编写以下代码来删除一个项目：
- en: '[PRE40]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Ⓐ First we remove the bids.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 首先，我们删除所有的出价。
- en: Ⓑ Then we remove the Item owner.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 然后我们删除项目所有者。
- en: JPA offers a cascading option to help with this. The persistence engine can
    remove an associated entity instance automatically.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: JPA 提供了一个级联选项来帮助解决这个问题。持久化引擎可以自动删除关联的实体实例。
- en: Listing 8.23 Cascading removal from `Item` to all `bids`
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.23 从 `Item` 到所有 `bids` 的级联删除
- en: '[PRE41]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Just as before with `PERSIST`, the `delete()` operations on this association
    will be cascaded. If we call `ItemRepository#delete()` or `EntityManager#remove()`
    on an `Item`, Hibernate loads the `bids` collection elements and internally calls
    `remove()` on each instance:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前的 `PERSIST` 一样，这个关联上的 `delete()` 操作将被级联。如果我们对 `Item` 调用 `ItemRepository#delete()`
    或 `EntityManager#remove()`，Hibernate 将加载 `bids` 集合元素并在每个实例上内部调用 `remove()`：
- en: '[PRE42]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: One line of code will be enough to also delete bids one by one.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 一行代码就足够逐个删除出价了。
- en: 'This deletion process is inefficient, however: Hibernate or Spring Data JPA
    must always load the collection and delete each `Bid` individually. A single SQL
    statement would have the same effect on the database: `delete from BID where ITEM_ID
    = ?`.'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个删除过程效率不高：Hibernate 或 Spring Data JPA 必须始终加载集合并逐个删除每个 `Bid`。一个 SQL 语句对数据库会产生相同的效果：`delete
    from BID where ITEM_ID = ?`。
- en: Nobody in the database has a foreign key reference on the `BID` table. Hibernate
    doesn’t know this, however, and it can’t search the whole database for any row
    that might have a linked `BID_ID` (that is, a `BID_ID` that is actually an `Item`
    foreign key).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库中没有人在 `BID` 表上有外键引用。然而，Hibernate 并不知道这一点，并且它无法在整个数据库中搜索任何可能具有链接 `BID_ID`（即实际的
    `Item` 外键）的行。
- en: If `Item#bids` was instead a collection of embeddable components, `someItem
    .getBids().clear()` would execute a single SQL `DELETE`. With a collection of
    value types, Hibernate assumes that nobody can possibly hold a reference to the
    bids, and removing only the reference from the collection makes it orphan removable
    data.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `Item#bids` 是可嵌入组件的集合，则 `someItem.getBids().clear()` 将执行单个 SQL `DELETE`。对于值类型集合，Hibernate
    假设没有人可能持有出价的引用，并且仅从集合中删除引用使其成为孤儿可删除数据。
- en: Enabling orphan removal
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 启用孤儿删除
- en: JPA offers a flag that enables the same behavior for `@OneToMany` (and only
    `@OneToMany`) entity associations.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: JPA 提供了一个标志，可以为 `@OneToMany`（仅限 `@OneToMany`）实体关联启用相同的行为。
- en: Listing 8.24 Enabling orphan removal on a `@OneToMany` collection
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.24 在 `@OneToMany` 集合上启用孤儿删除
- en: '[PRE43]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `orphanRemoval=true` argument tells Hibernate that we want to permanently
    remove a `Bid` when it’s removed from the collection.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '`orphanRemoval=true` 参数告诉 Hibernate，当 `Bid` 从集合中删除时，我们希望永久删除它。'
- en: We’ll change the `ItemRepository` interface as in the following listing.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照以下列表更改 `ItemRepository` 接口。
- en: Listing 8.25 The modified `ItemRepository` interface
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.25 修改后的 `ItemRepository` 接口
- en: '[PRE44]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Ⓐ The new `findItemWithBids` method will get the Item by `id`, including the
    bids collection. To fetch this collection, we’ll use the inner join fetch capability
    of JPQL.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 新的 `findItemWithBids` 方法将通过 `id` 获取 Item，包括出价集合。为了获取这个集合，我们将使用 JPQL 的内部连接获取功能。
- en: 'Here is an example of deleting a single `Bid`:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个删除单个 `Bid` 的示例：
- en: '[PRE45]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Hibernate or Spring Data JPA using Hibernate will monitor the collection, and
    on transaction commit will notice that we removed an element from the collection.
    Hibernate now considers the `Bid` to be orphaned. We have guaranteed that nobody
    else had a reference to it; the only reference was the one we just removed from
    the collection. Thus, Hibernate or Spring Data JPA using Hibernate will automatically
    execute an SQL `DELETE` to remove the `Bid` instance in the database.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate 或 Spring Data JPA 使用 Hibernate 将监视集合，并在事务提交时注意到我们从集合中删除了一个元素。现在 Hibernate
    认为该 `Bid` 是孤儿的。我们已保证没有人持有对该对象的引用；唯一的引用是我们刚刚从集合中删除的那个。因此，Hibernate 或 Spring Data
    JPA 使用 Hibernate 将自动执行一个 SQL `DELETE` 来删除数据库中的 `Bid` 实例。
- en: We still won’t get the `clear()` one-shot `DELETE`, as with a collection of
    components. Hibernate respects the regular entity-state transitions, and the bids
    are all loaded and removed individually.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然不会得到与组件集合相同的 `clear()` 一次性 `DELETE`。Hibernate 尊重常规实体状态转换，并且出价都是逐个加载和删除的。
- en: Orphan removal is a questionable process. It’s fine in this example, where there
    is no other table in the database with a foreign key reference on `BID`. There
    are no consequences to deleting a row from the `BID` table; the only in-memory
    references to bids are in `Item#bids`.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 孤儿删除是一个有争议的过程。在这个例子中，没有其他表在数据库中具有对 `BID` 的外键引用，所以这是可以的。从 `BID` 表中删除一行没有后果；对出价的所有内存引用都在
    `Item#bids` 中。
- en: As long as all of this is true, there is no problem with enabling orphan removal.
    It’s a convenient option when the presentation layer can remove an element from
    a collection to delete something. We only need to work with domain model instances,
    and we don’t need to call a service to perform this operation.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 只要所有这些条件都成立，启用孤儿删除就没有问题。当表示层可以从集合中删除一个元素以删除某些内容时，这是一个方便的选项。我们只需要处理领域模型实例，并且不需要调用服务来执行此操作。
- en: 'But consider what happens when we create a `User#bids` collection mapping—another
    `@OneToMany`—as shown in figure 8.16\. This is a good time to test your knowledge
    of Hibernate: what will the tables and schema look like after this change? (Answer:
    the `BID` table has a `BIDDER_ID` foreign key column, referencing `USERS`.)'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 但考虑当我们创建一个 `User#bids` 集合映射——另一个 `@OneToMany`——如图8.16所示时会发生什么。这是测试你对Hibernate知识的好时机：在此更改后，表和模式将是什么样子？（答案：`BID`
    表有一个 `BIDDER_ID` 外键列，引用 `USERS`。）
- en: '![](../../OEBPS/Images/CH08_F16_Tudose2.png)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH08_F16_Tudose2.png)'
- en: Figure 8.16 Bidirectional associations between `Item`, `Bid`, and `User`
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.16 `Item`、`Bid` 和 `User` 之间的双向关联
- en: The test shown in the following listing won’t pass.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表中显示的测试将不会通过。
- en: Listing 8.26 No clean up in-memory references after database removal
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.26 数据库删除后内存引用无清理
- en: '[PRE46]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Hibernate or Spring Data JPA thinks the removed `Bid` is orphaned and deletable;
    it will be deleted automatically in the database, but we still hold a reference
    to it in the other collection, `User#bids`. The database state is fine when this
    transaction commits; the deleted row of the `BID` table contained both foreign
    keys, `ITEM_ID` and `BIDDER_ID`. But we now have an inconsistency in memory, because
    saying, “Remove the entity instance when the reference is removed from the collection”
    naturally conflicts with shared references.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate或Spring Data JPA认为已删除的 `Bid` 是孤儿且可删除的；它将在数据库中自动删除，但我们仍然在另一个集合 `User#bids`
    中持有对该实体的引用。当此事务提交时，数据库状态良好；删除的 `BID` 表行包含两个外键，`ITEM_ID` 和 `BIDDER_ID`。但现在我们在内存中有一个不一致性，因为当我们说“从集合中移除引用时删除实体实例”时，这自然与共享引用相冲突。
- en: Instead of orphan removal, or even `CascadeType.REMOVE`, always consider a simpler
    mapping. Here, `Item#bids` would be fine as a collection of components, mapped
    with `@ElementCollection`. The `Bid` would be `@Embeddable` and have a `@ManyToOne`
    `bidder` property, referencing a `User`. (Embeddable components can own unidirectional
    associations to entities.)
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是孤儿删除，甚至 `CascadeType.REMOVE`，始终考虑一个更简单的映射。在这里，`Item#bids` 作为组件集合，使用 `@ElementCollection`
    映射，将很好。`Bid` 将是 `@Embeddable` 并具有一个 `@ManyToOne` `bidder` 属性，引用一个 `User`。（可嵌入组件可以拥有对实体的单向关联。）
- en: 'This would provide the lifecycle we’re looking for: a full dependency on the
    owning entity. We’ll have to avoid shared references; the UML diagram in figure
    8.16 makes the association from `Bid` to `User` unidirectional. Drop the `User#bids`
    collection—we don’t need this `@OneToMany`. If we need all the bids made by a
    user, we can write a query: `select b from Bid b where b.bidder = :userParameter`.
    (In the next chapter, we’ll complete this mapping with a `@ManyToOne` in an embeddable
    component.)'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这将提供我们寻找的生命周期：对拥有实体的完全依赖。我们将必须避免共享引用；图8.16中的UML图使 `Bid` 到 `User` 的关联变为单向。删除
    `User#bids` 集合——我们不需要这个 `@OneToMany`。如果我们需要获取用户做出的所有出价，我们可以编写一个查询：`select b from
    Bid b where b.bidder = :userParameter`。（在下一章中，我们将使用可嵌入组件中的 `@ManyToOne` 完成此映射。）
- en: Enabling ON DELETE CASCADE on the foreign key
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 启用外键上的ON DELETE CASCADE
- en: 'All the removal operations we’ve shown so far are inefficient. Bids have to
    be loaded into memory, and many SQL `DELETE`s are necessary. SQL databases support
    a more efficient foreign key feature: the `ON DELETE` option. In DDL, it looks
    like this: `foreign` `key` `(ITEM_ID)` `references` `ITEM` `on` `delete` `cascade`
    for the `BID` table.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们展示的所有删除操作都是低效的。必须将出价加载到内存中，并且需要许多SQL `DELETE` 操作。SQL数据库支持一个更高效的外键特性：`ON
    DELETE` 选项。在DDL中，它看起来像这样：`foreign` `key` `(ITEM_ID)` `references` `ITEM` `on`
    `delete` `cascade` 对于 `BID` 表。
- en: This option tells the database to maintain the referential integrity of composites
    transparently for all applications accessing the database. Whenever we delete
    a row in the `ITEM` table, the database will automatically delete any row in the
    `BID` table with the same `ITEM_ID` key value. We only need one `DELETE` statement
    to remove all dependent data recursively, and nothing has to be loaded into application
    (server) memory.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项告诉数据库为所有访问数据库的应用程序透明地维护复合的引用完整性。每当我们在 `ITEM` 表中删除一行时，数据库将自动删除 `BID` 表中具有相同
    `ITEM_ID` 键值的任何行。我们只需要一个 `DELETE` 语句来递归地删除所有相关数据，并且不需要将任何内容加载到应用程序（服务器）内存中。
- en: You should check whether your schema already has this option enabled on foreign
    keys. If you want this option added to the Hibernate-generated schema, use the
    Hibernate `@OnDelete` annotation.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该检查你的模式是否已经在外键上启用了此选项。如果你想要将此选项添加到Hibernate生成的模式中，请使用Hibernate `@OnDelete`
    注解。
- en: You should also check whether this option works with your DBMS and if Hibernate
    or Spring Data JPA using Hibernate generates a foreign key with the `ON DELETE
    CASCADE` option. This does not work with MySQL, so we chose to demonstrate this
    particular example on the H2 database. You will find it this way in the source
    code (Maven dependency in pom.xml and Spring Data JPA configuration).
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该检查这个选项是否与你的DBMS兼容，以及Hibernate或使用Hibernate的Spring Data JPA是否生成带有`ON DELETE
    CASCADE`选项的外键。这在MySQL中不起作用，所以我们选择在H2数据库上展示这个特定的例子。你可以在源代码中找到它（在pom.xml中的Maven依赖项和Spring
    Data JPA配置）。
- en: Listing 8.27 Generating foreign key `ON` `DELETE` `CASCADE` in the schema
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.27 在架构中生成外键`ON DELETE CASCADE`
- en: '[PRE47]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Ⓐ One of the Hibernate’s quirks is visible here: the `@OnDelete` annotation
    affects only the schema generation by Hibernate. Settings that affect schema generation
    are usually on the “other” `mappedBy` side, where the foreign key/join column
    is mapped. The `@OnDelete` annotation is usually next to the `@ManyToOne` in `Bid`.
    When the association is mapped bidirectionally, however, Hibernate will only recognize
    it on the `@OneToMany` side.'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ Hibernate的一个特性在这里可见：`@OnDelete`注解仅影响Hibernate的架构生成。影响架构生成的设置通常位于“另一边”的`mappedBy`，即外键/连接列映射的地方。在`Bid`中，`@OnDelete`注解通常位于`@ManyToOne`旁边。然而，当关联双向映射时，Hibernate只会识别`@OneToMany`这一侧。
- en: Enabling foreign key cascade deletion in the database doesn’t influence Hibernate’s
    runtime behavior. We can still run into the same problem as shown in listing 8.26\.
    Data in memory may no longer accurately reflect the state in the database. If
    all related rows in the `BID` table are automatically removed when a row in the
    `ITEM` table is deleted, the application code is responsible for cleaning up references
    and catching up with the database state. If we aren’t careful, we may even end
    up saving something that we or someone else previously deleted.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库中启用外键级联删除不会影响Hibernate的运行时行为。我们仍然可能遇到列表8.26中显示的相同问题。内存中的数据可能不再准确反映数据库的状态。如果当`ITEM`表中的一行被删除时，`BID`表中的所有相关行都会自动删除，那么应用程序代码负责清理引用并更新数据库状态。如果我们不小心，甚至可能保存我们或其他人之前删除的内容。
- en: The `Bid` instances don’t go through the regular lifecycle, and callbacks such
    as `@PreRemove` have no effect. Additionally, Hibernate doesn’t automatically
    clear the optional second-level global cache, which potentially contains stale
    data. Fundamentally, the kinds of problems encountered with database-level foreign
    key cascading are the same as when another application besides ours is accessing
    the same database, or any other database trigger makes changes. Hibernate can
    be a very effective utility in such a scenario, but there are other moving parts
    to consider.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bid`实例不会经过常规的生命周期，并且像`@PreRemove`这样的回调没有效果。此外，Hibernate不会自动清除可选的二级全局缓存，该缓存可能包含过时数据。从根本上说，在数据库级别遇到的外键级联问题与我们的应用程序之外的另一个应用程序访问同一数据库，或者任何其他数据库触发器进行更改时遇到的问题相同。在这种情况下，Hibernate可以是一个非常有效的工具，但还有其他需要考虑的动态部分。'
- en: 'If you work on a new schema, the easiest approach is to not enable database-level
    cascading and to map a composition relationship in your domain model as embedded/
    embeddable, not as an entity association. Hibernate or Spring Data JPA using Hibernate
    can then execute efficient SQL `DELETE` operations to remove the entire composite.
    We made this recommendation in the previous section: if you can avoid shared references,
    map the `Bid` as an `@ElementCollection` in `Item`, not as a standalone entity
    with `@ManyToOne` and `@OneToMany` associations. Alternatively, of course, you
    might not map any collections at all and use only the simplest mapping: a foreign
    key column with `@ManyToOne`, unidirectional between `@Entity` classes.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个新的架构上工作，最简单的方法是不要启用数据库级别的级联，并在你的领域模型中将组合关系映射为内嵌/可嵌入的，而不是作为实体关联。然后Hibernate或使用Hibernate的Spring
    Data JPA可以执行高效的SQL `DELETE`操作来删除整个组合。我们在上一节中提出了这个建议：如果你可以避免共享引用，将`Bid`映射为`Item`中的`@ElementCollection`，而不是作为具有`@ManyToOne`和`@OneToMany`关联的独立实体。当然，你也可以选择完全不映射任何集合，只使用最简单的映射：一个带有`@ManyToOne`的外键列，在`@Entity`类之间单向映射。
- en: Summary
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Using simple collection mappings, such as a `Set<String>`, you can work through
    a rich set of interfaces and implementations.
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用简单的集合映射，例如`Set<String>`，你可以处理丰富的一组接口和实现。
- en: You can use sorted collections as well as Hibernate’s options for letting the
    database return the collection elements in the desired order.
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用排序集合，以及Hibernate提供的选项，让数据库按所需顺序返回集合元素。
- en: You can use complex collections of user-defined embeddable types and sets, bags,
    and maps of components.
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用复杂集合，包括用户定义的可嵌入类型和集合、包以及组件的映射。
- en: You can use components as both keys and values in maps.
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在映射中使用组件作为键和值。
- en: You can use a collection in an embeddable component.
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在一个可嵌入的组件中使用一个集合。
- en: Mapping the first foreign key column to an entity many-to-one association makes
    it bidirectional as a one-to-many. You can implement cascading options.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将第一个外键列映射到实体的多对一关联使其作为一对多关系是双向的。你可以实现级联选项。
