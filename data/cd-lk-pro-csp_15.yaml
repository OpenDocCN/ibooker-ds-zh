- en: 10 Reflection and mocks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 反思和模拟
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: A refresher on using the repository/service pattern and views
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用存储库/服务模式和视图的复习
- en: Testing with mocks using the Moq library
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Moq库进行模拟测试
- en: Detecting coupling in multilayered testing architectures
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多层测试架构中检测耦合
- en: Using preprocessor directives
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用预处理器指令
- en: Using reflection to retrieve assembly information at run time
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用反射在运行时检索程序集信息
- en: 'In chapters 6 through 9, we implemented the repository layer of our `FlyingDutchmanAirlinesNextGen`
    project. In this chapter, we’ll refresh our knowledge of the repository/service
    pattern and implement (partially) two of the four following required service classes:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在第6章到第9章中，我们实现了`FlyingDutchmanAirlinesNextGen`项目的存储库层。在本章中，我们将回顾存储库/服务模式的知识，并实现以下四个必需服务类中的两个（部分）：
- en: '`CustomerService` (implemented in this chapter)'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CustomerService`（在本章实现）'
- en: '`BookingService` (implemented in this chapter and chapter 11)'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BookingService`（在本章和第11章实现）'
- en: '`AirportService` (implemented in chapter 12)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AirportService`（在第12章实现）'
- en: '`FlightService` (implemented in chapter 12)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FlightService`（在第12章实现）'
- en: Figure 10.1 shows where we are in the scheme of the book.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1显示了我们在本书方案中的位置。
- en: '![](../Images/10_01.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10_01.png)'
- en: Figure 10.1 This chapter is the start of the service layer implementation. We’ll
    implement `CustomerService` and `BookingService` in this chapter. In the following
    chapters, we’ll implement `AirportService` and `FlightService`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 本章是服务层实现的开始。我们将在本章实现`CustomerService`和`BookingService`。在接下来的章节中，我们将实现`AirportService`和`FlightService`。
- en: As you may have guessed, as with the repository classes, we want one service
    class per database entity. We’ll discuss why in section 10.1, followed by the
    `CustomerService` implementation in section 10.2 and the start of the `BookingService`
    implementation in section 10.3.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，与存储库类一样，我们希望每个数据库实体有一个服务类。我们将在10.1节中讨论原因，然后在10.2节中讨论`CustomerService`的实现，并在10.3节中开始`BookingService`的实现。
- en: Throughout the next couple of chapters, the speed of implementation increases
    once we get used to implementing a service class. Section by section, I take a
    more hands-off approach, leaving more and more implementation details for you
    to code. If you ever get stuck, you can always look back at the appropriate section
    for more details.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几章中，一旦我们习惯了实现服务类，实现速度就会加快。我会逐节采取更少干预的方法，将越来越多的实现细节留给你去编码。如果你遇到困难，可以随时回顾相应的章节以获取更多详细信息。
- en: 10.1 The repository/service pattern revisited
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1 再次探讨存储库/服务模式
- en: 'In section 5.2.4, we discussed the repository/service pattern. I showed you
    how, in a repository/service pattern, for every database entity (`Customer`, `Booking`,
    `Airport`, `Flight`) we have the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在5.2.4节中，我们讨论了存储库/服务模式。我向你展示了在存储库/服务模式中，对于每个数据库实体（`Customer`、`Booking`、`Airport`、`Flight`），我们都有以下内容：
- en: Controller
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器
- en: Service
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务
- en: Repository
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储库
- en: These controllers, services, and repositories sit atop a single database access
    layer, which we implemented in chapter 5\. The request life cycle in our repository/service
    pattern, shown in figure 10.2, sees an HTTP request enter a controller. The controller
    calls its respective entity’s service class. The entity’s service class calls
    whichever repository classes it needs to deal with, organizing the information
    it needs to return to the user. The service class returns to the controller, who
    in turn returns all data to the user.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些控制器、服务和存储库位于单个数据库访问层之上，我们在第5章中实现了它。我们的存储库/服务模式中的请求生命周期，如图10.2所示，是一个HTTP请求进入控制器。控制器调用其相应实体的服务类。实体的服务类调用它需要处理的任何存储库类，组织它需要返回给用户的信息。服务类返回到控制器，控制器随后将所有数据返回给用户。
- en: '![](../Images/10_02.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10_02.png)'
- en: Figure 10.2 The controller-service-repository life cycle. When a request enters,
    it goes to the controller. The controller calls a service, which calls one or
    more repositories. Data flows down from the controller and back up from the repository.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 控制器-服务-存储库生命周期。当请求进入时，它将进入控制器。控制器调用一个服务，该服务调用一个或多个存储库。数据从控制器流向存储库，并从存储库返回。
- en: 'In chapters 5 through 9, we implemented the repositories required for our architecture.
    Now it’s time to do the same for the services. Because a service is merely the
    middleman between the repository and controller, services are fairly light in
    complexity. Don’t be mistaken, however: the service layer is perhaps the most
    important layer of all. Without it, we would have no abstraction layer dealing
    with how we want to represent data to the customer. A service class calls a collection
    of repository methods and returns a view of the data to the controller. A service
    class serves the controller with data.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5章到第9章中，我们实现了我们架构所需的存储库。现在轮到为服务做同样的事情了。因为服务仅仅是存储库和控制层之间的中间人，所以服务在复杂性上相对较轻。然而，不要误解：服务层可能是所有层中最重要的一层。没有它，我们就不会有处理如何向客户表示数据的抽象层。服务类调用一系列存储库方法，并将数据的视图返回给控制器。服务类为控制器提供数据。
- en: 10.1.1 What is the use of a service class?
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.1 服务类的用途是什么？
- en: In the United States, to buy a car you have to navigate a myriad of eager salespeople,
    followed by hours of paperwork. Experiences at car dealerships are often an example
    of bad service. When looking at software architecture, we can also see bad service
    in service classes. If a service class returns things to the controller the user
    did not ask for, we have an example of bad service on our hands.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在美国，购买一辆车需要应对众多热心的销售人员，随后还要花费数小时处理文件工作。在汽车经销商那里的经历往往是糟糕服务的例子。当我们审视软件架构时，我们同样可以在服务类中看到糟糕的服务。如果一个服务类返回用户未请求的内容，那么我们手头就有了一个糟糕服务的例子。
- en: For example, let’s imagine we are developing an API for a car dealership. The
    dealership wants to display any car from their inventory to the user, withhold
    some of the more valuable information, such as the true value of the car (usually
    much less than the price they are asking). Whether withholding information for
    corporate gain is bad service depends on who you are. If you are the car dealership,
    this sounds very reasonable. If you are a buyer, you want as much information
    as possible. So how would you implement such an API?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们想象我们正在开发一个汽车经销商的API。经销商希望向用户展示他们库存中的任何汽车，同时保留一些更有价值的信息，例如汽车的真实价值（通常远低于他们要求的售价）。是否保留信息以获取公司利益是糟糕的服务取决于你是谁。如果你是汽车经销商，这听起来非常合理。如果你是买家，你希望尽可能多地获取信息。那么你将如何实现这样的API？
- en: 'An API to return car information consists of the following usual suspects:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 返回汽车信息的API包括以下常见元素：
- en: A controller accepting HTTP `GET` requests when given a specific car’s ID
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器接受特定汽车ID的HTTP `GET`请求
- en: A service layer that retrieves information from repositories and presents them
    to the controller
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个从存储库检索信息并将其呈现给控制器的服务层
- en: A repository that collects car instances from the database
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个从数据库收集汽车实例的存储库
- en: 'The service class calls methods from the repository and constructs what we
    call a view. We discussed views in section 3.3.2, but here is a quick refresher:
    a view is a “window” into a class. Views allow us to manipulate and spin a class’s
    appearance to suit our needs.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 服务类调用存储库的方法，构建我们称之为视图的内容。我们在3.3.2节中讨论了视图，但这里是一个快速回顾：视图是一个“窗口”，可以让我们操纵和调整类的外观以满足我们的需求。
- en: NOTE Sometimes people say ReturnView instead of view. They mean the same thing
    and you can use them interchangeably. This book tries to stick with view.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：有时人们会说ReturnView而不是view。它们的意思相同，你可以互换使用。这本书尽量坚持使用view。
- en: A view of a `Car` class may contain information such as the VIN, the make of
    the car, the year the car was built, and the model of the car, as shown in figure
    10.3\. But because it is just a “window” into the model, we can choose not to
    display the true value of the car or the total number of crashes it has seen in
    the last six months, in our view.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`Car`类的视图可能包含诸如VIN、汽车制造商、汽车制造年份和汽车型号等信息，如图10.3所示。但由于它只是一个“窗口”，我们可以选择不在视图中显示汽车的真实价值或过去六个月内汽车遭遇的总碰撞次数。'
- en: '![](../Images/10_03.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3](../Images/10_03.png)'
- en: Figure 10.3 A view is a collection of elements taken from one or multiple models,
    presented in a way that makes sense for the user. In this example, we took the
    `Year`, `Brand`, and `Model` properties from the `Car` class.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 视图是从一个或多个模型中提取的元素集合，以对用户有意义的方式呈现。在这个例子中，我们从`Car`类中提取了`Year`、`Brand`和`Model`属性。
- en: 'A service class may also trace down foreign key constraints, retrieving information
    where needed to compile a full image of the required data. We see foreign key
    constraints in action throughout this book. We’ll also take another, deeper dive
    into the world of unit testing. Yes, dear reader: this chapter sees us using test-driven
    development once again, but this time, we’ll use TDD combined with a new testing
    concept: mocks.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 服务类也可能追踪外键约束，在需要时检索信息以编译所需数据的完整图像。我们将在整本书中看到外键约束的实际应用。我们还将更深入地探索单元测试的世界。是的，亲爱的读者：本章我们将再次使用测试驱动开发，但这次，我们将使用TDD结合一个新的测试概念：模拟。
- en: Exercises
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Exercise 10.1
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 练习10.1
- en: In a repository/service pattern, what is the correct data flow for an incoming
    request?
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在仓库/服务模式中，传入请求的正确数据流是什么？
- en: a. Repository -> service -> controller
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: a. 仓库 -> 服务 -> 控制器
- en: b. Controller -> service -> repository
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: b. 控制器 -> 服务 -> 仓库
- en: Exercise 10.2
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 练习10.2
- en: True or false? A service class (in a repository/service pattern) typically directly
    interacts with a database.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 对或错？服务类（在仓库/服务模式中）通常直接与数据库交互。
- en: Exercise 10.3
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 练习10.3
- en: True or false? When using a view, we can return a unified presentation of multiple
    different data sources.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对或错？当使用视图时，我们可以返回多个不同数据源的统一表示。
- en: Exercise 10.4
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 练习10.4
- en: True or false? People often use view and ReturnView interchangeably to refer
    to the same concept.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对或错？人们经常将视图和ReturnView互换使用来指代相同的概念。
- en: 10.2 Implementing the CustomerService
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2 实现CustomerService
- en: Are you ready to implement your first service? In this section, we’ll implement
    the `CustomerService` class. This class allows us to funnel information to and
    from a controller and the `CustomerRepository`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你准备好实现你的第一个服务了吗？在本节中，我们将实现`CustomerService`类。这个类允许我们将信息从控制器和`CustomerRepository`中传递过来和传过去。
- en: '10.2.1 Setting up for success: Creating skeleton classes'
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.1 为成功做准备：创建骨架类
- en: What is the first thing we should do when starting work on a new class? Right,
    create an accompanying unit test class. I do not show you how to create a test
    class this time; just make sure you create one with a public access modifier and
    with a `TestInitialize` method (no need to add anything to the `TestInitialize`
    method for now). Also, to keep things somewhat organized, let’s mimic the folder
    structure we followed with the repository test classes and create a ServiceLayer
    folder in the `FlyingDutchmanAirlines_Tests` project, as shown in figure 10.4.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当开始一个新的类的工作时，我们应该首先做什么？对，创建一个相应的单元测试类。这次我不会向你展示如何创建测试类；只需确保你创建一个具有公共访问修饰符和`TestInitialize`方法的测试类（目前不需要向`TestInitialize`方法中添加任何内容）。此外，为了保持一定的组织性，让我们模仿我们之前使用的仓库测试类的文件夹结构，在`FlyingDutchmanAirlines_Tests`项目中创建一个ServiceLayer文件夹，如图10.4所示。
- en: '![](../Images/10_04.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/10_04.png)'
- en: Figure 10.4 The CustomerServiceTests file lives in the ServiceLayer folder inside
    the FlyingDutchmanAirlines_Tests project.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 CustomerServiceTests文件位于FlyingDutchmanAirlines_Tests项目中的ServiceLayer文件夹内。
- en: 'Before we can create a success case unit test, we need to figure out what methods
    we need in the `CustomerService` class. You may recall that in chapter 7 we implemented
    the following two methods in `CustomerRepository`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以创建一个成功案例单元测试之前，我们需要弄清楚在`CustomerService`类中需要哪些方法。你可能记得，在第7章中，我们在`CustomerRepository`中实现了以下两个方法：
- en: '`CreateCustomer`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreateCustomer`'
- en: '`GetCustomerByName`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetCustomerByName`'
- en: Should we mimic those method names in the `CustomerService` class? Well, yes,
    to an extent. If we maintain an isomorphic relationship between method names in
    the repository and the service, it makes our code more readable because we build
    up certain expectations. If a developer sees a method called `GetCombineHarvester`
    in both a service and repository class, the developer expects the service version
    of the `GetCombineHarvester` method to call the repository version of the same
    method. Let’s not let down the intuition of our fellow developers. Of course,
    a service method may call multiple repository methods, so pick the one that best
    reflects your intentions.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是否应该在`CustomerService`类中模仿那些方法名？嗯，是的，在一定程度上。如果我们保持仓库和服务中方法名的同构关系，这将使我们的代码更易于阅读，因为我们建立了一定的预期。如果一个开发者看到服务类和仓库类中都存在名为`GetCombineHarvester`的方法，开发者会期望`GetCombineHarvester`方法的服务版本调用相同方法的仓库版本。让我们不要让我们的开发者同伴的直觉失望。当然，服务方法可能会调用多个仓库方法，所以选择最能反映你意图的那个。
- en: '| ![](../Images/LightBulb.png)   | Naming service layer methods When deciding
    on a name for your service layer method, consider naming the method the same as
    the main repository layer method you call. This helps build intuition and makes
    your code more navigable. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| ![灯泡](../Images/LightBulb.png)   | 在为服务层方法命名时，考虑将方法命名为与您调用的主要仓库层方法相同的名称。这有助于建立直觉，并使您的代码更易于导航。|'
- en: 'That being said, no controller calls the `CreateCustomer` or `GetCustomerByName`
    methods directly. Instead, the only interaction we ever have with the `Customer`
    entity is through other services. How do we know a controller will not call a
    service directly? In figure 10.5, we see the following three required endpoints
    as laid out by the contract between Flying Dutchman Airlines and FlyTomorrow (discussed
    in sections 3.1 and 3.2):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，没有任何控制器直接调用`CreateCustomer`或`GetCustomerByName`方法。相反，我们与`Customer`实体的唯一交互是通过其他服务。我们如何知道控制器不会直接调用服务？在图10.5中，我们看到以下三个由飞荷兰人航空公司与FlyTomorrow之间的合同规定的必需端点（在第3.1节和第3.2节中讨论过）：
- en: '`GET /Flight`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /Flight`'
- en: '`GET /Flight/{FlightNumber}`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /Flight/{FlightNumber}`'
- en: '`POST /Booking/{FlightNumber}`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST /Booking/{FlightNumber}`'
- en: '![](../Images/10_05.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10_05.png)'
- en: Figure 10.5 The three endpoints required by FlyTomorrow as discussed in chapter
    3\. There are two `GET` endpoints and one `POST` endpoint.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 FlyTomorrow在第3章中讨论的三个必需端点。有两个`GET`端点和一个是`POST`端点。
- en: 'None of those endpoints interacts directly with the `Customer` entity. The
    word “customer” does not show up either in an endpoint path or as a path parameter.
    I am proposing something quite radical: if no controller ever calls a service,
    we do not need said service. In fact, we can go as far as saying that we do not
    need a controller for that entity, either. It would never get called anyway. In
    other words, we do not need a `CustomerService`, nor do we need a `CustomerController`.
    Well, that really opens up our day, doesn’t it? I always appreciate less work.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这些端点中没有任何一个直接与`Customer`实体交互。在端点路径或路径参数中也没有出现“customer”这个词。我提出一个相当激进的看法：如果没有任何控制器直接调用服务，我们就不需要这个服务。实际上，我们甚至可以说，我们也不需要为该实体提供控制器，因为它永远不会被调用。换句话说，我们不需要`CustomerService`，也不需要`CustomerController`。嗯，这真是一件让人开心的事情，不是吗？我总是欣赏工作量减少。
- en: 10.2.2 How to delete your own code
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.2 如何删除自己的代码
- en: 'At this point, I ask you to do something that may end up being the highlight
    of your day: deleting code. I’m quite serious about that. If deleting code makes
    you uneasy, this section is for you. I want you to view deleting code as a Zen-filled
    experience. Allowing yourself to delete your own code when you find an alternative
    approach (that works better) is a key skill for a developer and is harder than
    you think.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我要求你做一件可能成为你一天中最亮点的事情：删除代码。我是认真的。如果你对删除代码感到不安，这一节就是为你准备的。我希望你将删除代码视为一个充满禅意的体验。当你找到更好的替代方案时，允许自己删除自己的代码是开发人员的一项关键技能，而且比你想象的要难。
- en: 'In section 10.2.1, we created the following two classes:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在第10.2.1节中，我们创建了以下两个类：
- en: '`CustomerService`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CustomerService`'
- en: '`CustomerServiceTests`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CustomerServiceTests`'
- en: The `CustomerServiceTests` class contains an unimplemented `TestInitialize`
    method. We also determined that we don’t need the `CustomerService` and `CustomerServiceTests`
    classes because they would never be called by a controller. In the real world,
    I am unequivocally in favor of deleting code that needs to go. Think about empty
    classes, commented-out code, and incorrect implementations. If you are worried
    about breaking existing code (and you should be), then I hope you have a full
    suite of tests you can rely on to verify the correctness of your refactoring.
    You should also use a source control system so you can revert to a previous state
    if the deletion of code has unexpected side effects (you should *always* use a
    source control system).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`CustomerServiceTests`类包含一个未实现的`TestInitialize`方法。我们还确定我们不需要`CustomerService`和`CustomerServiceTests`类，因为它们永远不会被控制器调用。在现实世界中，我坚决支持删除需要删除的代码。考虑一下空类、注释掉的代码和错误的实现。如果你担心破坏现有的代码（你应该担心），那么我希望你有一个完整的测试套件可以依赖来验证重构的正确性。你还应该使用源代码控制系统，这样你就可以在代码删除产生意外的副作用时恢复到之前的状态（你应该*始终*使用源代码控制系统）。'
- en: '| ![](../Images/ThumbsUp.png)   |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| ![点赞](../Images/ThumbsUp.png)   |'
- en: Deleting code
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 删除代码
- en: Deleting code is scary. A commonly used phrase for hesitation to delete your
    own work is “kill your darlings.” Often, however, to deliver the best work possible,
    you have to swallow your pride and delete your own (usually beautiful and elegant)
    code. If you delete your code in favor of a better implementation, it is not defeat—quite
    the opposite, it is a win. Even if you did not write the new implementation yourself,
    you should consider this to be a positive change. The fresh approach is undoubtedly
    more readable and maintainable, saving yourself (and others) a lot of heartache
    down the road.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 删除代码令人害怕。对于犹豫删除自己的作品的常用说法是“杀死你的宝贝”。然而，为了交付尽可能好的工作，你必须吞下你的骄傲，删除你自己的（通常是美丽而优雅的）代码。如果你为了更好的实现而删除代码，那不是失败——恰恰相反，那是一种胜利。即使你没有自己编写新的实现，你也应该认为这是一个积极的改变。新的方法无疑是更易读和可维护的，这将在未来为你（和他人）节省很多痛苦。
- en: 'I want to draw your attention to a special case where you should be merciless
    in deleting code, both of your own design and of others: commented-out code. I’m
    going to say it, and I bet some of you disagree with me: commented-out code has
    no place in a production codebase. Period. You do *not* merge commented-out code
    into the main branch. Think about why the code is commented out in the first place.
    Is it something that is an alternative approach to a solution? Is it an old implementation?
    Is it a half-assed new implementation? Is it something that you might need in
    the future (unlikely)? In my humble opinion, those reasons are not good enough
    to warrant you spoiling my beautiful codebase with an ugly block of commented-out
    code. If you want commented-out code in the codebase, you can either make it work
    (and uncommented it), or you must not need it that badly.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我想提醒大家一个特殊情况，你应该无情地删除代码，无论是自己的设计还是别人的：被注释掉的代码。我要说的是，我敢打赌有些人会不同意我：被注释掉的代码在生产代码库中没有任何位置。就这样。你绝对不要将注释掉的代码合并到主分支中。想想代码为什么会被注释掉。它是解决方案的替代方法吗？它是旧实现吗？它是半吊子新实现吗？它是你未来可能需要的东西（不太可能）吗？在我看来，这些理由不足以证明你用一块丑陋的注释代码破坏了我的美丽代码库。如果你想在代码库中保留注释代码，你可以让它工作（并取消注释），或者你不必那么迫切地需要它。
- en: 'For example, the following code block contains a method with an implementation
    but has a comment with a different implementation:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码块包含一个有实现的方法，但有一个不同实现的注释：
- en: '[PRE0]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, the comment in the code has a valid point. The `IsToggleLight` method running
    uses a bitwise XOR operator to flip the _`light` bit. The implementation in the
    comment may be easier to read, indeed. It also comes with some unknowns, however,
    because it changes the return type of the `ToggleLight` method and the underlying
    type of _`light` (both from `bit` to `bool`), but we could deal with that. Why
    was this code never uncommented or implemented, though? Did it not pass code review?
    Does it not work? Is this a passive-aggressive “for future reference” comment
    by a disgruntled senior engineer or a new developer trying to impress somebody?
    It doesn’t matter.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，代码中的注释确实有一个合理的观点。`IsToggleLight` 方法运行时使用位异或运算符来翻转 `_`light` 位。注释中的实现确实更容易阅读。然而，它也带来了一些未知因素，因为它改变了
    `ToggleLight` 方法的返回类型和 `_`light` 的底层类型（两者都从 `bit` 变为 `bool`），但我们可以处理这一点。那么，为什么这段代码从未被取消注释或实现呢？它没有通过代码审查吗？它不起作用吗？这是一个由不满的高级工程师或试图给某人留下深刻印象的新开发者留下的被动-aggressive
    “供未来参考”的注释吗？这无关紧要。
- en: '|'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'So, grab your favorite destructive way to delete something (virtually; don’t
    go using a jackhammer on your laptop—the publisher and I are not liable for your
    regrettable life choices). I am partial to the good old command-line remove command
    shown in figure 10.6: `del /f [file]` in Windows and `rm -rf [file]` in macOS.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，拿起你最喜欢的破坏性删除方式（虚拟的；不要在你的笔记本电脑上使用冲击钻——出版商和我不对你的遗憾生活选择负责）。我偏爱图 10.6 中显示的古老命令行删除命令：Windows
    中的 `del /f [file]` 和 macOS 中的 `rm -rf [file]`。
- en: '![](../Images/10_06.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10_06.png)'
- en: Figure 10.6 To delete a file in the Windows command line, use the `del` `/f`
    `[FilePath]` syntax. Feeling a surge of power and yelping “by the power of the
    gods!” is optional.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6 在 Windows 命令行中删除文件，请使用 `del /f [FilePath]` 语法。感到一股力量涌动并尖叫“凭借神的力量！”是可选的。
- en: There, didn’t that feel powerful? I sure got a boost out of it, but that might
    tell you more about me than necessary. Let’s move on and do some actual work,
    shall we?
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 那里，难道没有感觉到很强大吗？我确实从中得到了很大的提升，但这可能比你需要的关于我的信息更多。让我们继续前进，做一些实际的工作，好吗？
- en: Exercises
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Exercise 10.5
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 10.5
- en: Why do we want to use the same name for a service class method name as the repository
    method it calls?
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们想要使用与调用它的仓库方法相同的名称作为服务类方法名？
- en: a. This establishes an isomorphic relationship between the two methods and helps
    create valid expectations for other developers.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: a. 这在两个方法之间建立了一种同构关系，并有助于为其他开发者创建有效的期望。
- en: b. We don’t want to do that. The code would not compile if the service and repository
    classes contained methods with the same name.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: b. 我们不想这么做。如果服务和仓库类中包含具有相同名称的方法，则代码将无法编译。
- en: c. We do want to do that, but only if there is a verb in the method name.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: c. 我们确实想这么做，但前提是方法名中必须有一个动词。
- en: Exercise 10.6
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 练习10.6
- en: You encounter a commented-out line of code that seems to indicate an alternative
    approach to the currently running code. What do you do?
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你遇到了一行被注释掉的代码，这似乎表明了一种替代当前运行代码的方法。你该怎么办？
- en: a. Leave it be. It is not your problem.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: a. 保持原样。这不是你的问题。
- en: b. Ask for clarification by adding questions to the original comment.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: b. 通过在原始评论中添加问题来请求澄清。
- en: c. Figure out why it is there, and, in most cases, delete the commented-out
    code.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: c. 找出为什么它在那里，并且在大多数情况下，删除被注释掉的代码。
- en: Exercise 10.7
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 练习10.7
- en: What does the `^` operator represent?
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`^`运算符代表什么？'
- en: a. A logical OR operation
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: a. 逻辑或操作
- en: b. A logical AND operation
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: b. 逻辑与操作
- en: c. A logical NAND operation
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: c. 逻辑与非操作
- en: d. A logical XOR operation
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: d. 逻辑异或操作
- en: Exercise 10.8
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 练习10.8
- en: What is the effect of using the `^=` operator on a Boolean value?
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`^=`运算符对布尔值有什么影响？
- en: a. The Boolean value flips (`true` becomes `false`, `false` becomes `true`).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: a. 布尔值翻转（`true`变为`false`，`false`变为`true`）。
- en: b. Nothing (`true` stays `true`, `false` stays `false`).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: b. 没有操作（`true`保持`true`，`false`保持`false`）。
- en: c. The Boolean value flips twice (`true` stays `true`, `false` stays `false`).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: c. 布尔值翻转两次（`true`保持`true`，`false`保持`false`）。
- en: 10.3 Implementing the BookingService
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3 实现BookingService
- en: After the refresher of the repository/service pattern in section 10.1 and the
    false start to implementing an actual service class in section 10.2, we are finally
    at the point where we start work on an actual service class—no joke this time.
    In this section, we’ll implement a service for the `Booking` entity.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在第10.1节中复习了仓库/服务模式，并在第10.2节中尝试实现实际的服务类后，我们终于到了开始实际工作在服务类上的阶段——这次不是开玩笑。在本节中，我们将实现一个针对`Booking`实体的服务。
- en: 'When we discussed the need for service classes in section 10.2, we talked about
    not needing a dedicated service layer if no controller class is ever going to
    call the respective service. This is some good advice, even if I say so myself,
    so let’s repeat that exercise for the `BookingService` class. Is there an API
    endpoint that needs to use the `Booking` entity directly? Well, let’s look at
    the following three required endpoints per the FlyTomorrow contract again:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在第10.2节中讨论服务类需求时，我们提到如果没有控制器类会调用相应的服务，则不需要专用服务层。即使我自己这么说，这也是一条很好的建议，所以让我们再次为`BookingService`类重复这个练习。是否有需要直接使用`Booking`实体的API端点？好吧，让我们再次查看FlyTomorrow合同中规定的以下三个必需端点：
- en: '`GET /Flight`'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /Flight`'
- en: '`GET /Flight/{FlightNumber}`'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /Flight/{FlightNumber}`'
- en: '`POST /Booking/{FlightNumber}`'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST /Booking/{FlightNumber}`'
- en: The `POST /Booking/{FlightNumber}` endpoint directly deals with the `Booking`
    entity, as is evident from the path. FlyTomorrow uses the `POST` endpoint to create
    a new booking in the database. And because we need to have a `BookingController`
    to accept the HTTP request, it stands to reason that we should call a `BookingService`
    from that controller. Remember that a service layer’s goal is to collect and organize
    data from repositories. So, to create a booking, a controller calls a method in
    the `BookingService` class, which calls the needed repositories to perform its
    promised duty, as shown in figure 10.7.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`POST /Booking/{FlightNumber}`端点直接处理`Booking`实体，正如路径所示。FlyTomorrow使用`POST`端点在数据库中创建新的预订。由于我们需要有一个`BookingController`来接受HTTP请求，因此从该控制器调用`BookingService`是合理的。记住，服务层的目的是从仓库中收集和组织数据。因此，为了创建预订，控制器会调用`BookingService`类中的方法，该方法调用所需的仓库以执行其承诺的职责，如图10.7所示。'
- en: '![](../Images/10_07.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10_07.png)'
- en: Figure 10.7 The life cycle of the `Booking` entity. A request is handled through
    the `BookingController` (not yet written), which calls the `BookingService`, which
    calls the `BookingRepository`. Then, the path is walked back to the caller.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7 `Booking`实体的生命周期。请求通过`BookingController`（尚未编写）处理，它调用`BookingService`，然后`BookingService`调用`BookingRepository`。然后，路径回溯到调用者。
- en: 'By thinking about what functionality the `BookingService` should provide, we
    can come up with the method needed to create a new booking: an asynchronous `public`
    method that calls the `BookingRepository.CreateBooking` and returns the appropriate
    information to a controller. Here, the appropriate information could be a `Task<(bool,
    Exception)>` representing that the `CreateBooking` method has executed and completed.
    If the booking was unsuccessful, we get a false Boolean along with the exception
    that the `CreateBooking` method threw: `(false, thrownException)`. If the booking
    was successful, we return a `true` Boolean and a null pointer (if you enabled
    nullable reference types, you may have to make `Exception` a nullable type by
    postfixing a question mark character: `Exception?`). If you don’t want to define
    a Boolean return, you could alternatively rely on `Task`’s internal `IsCompleted`
    `bool`.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 通过思考`BookingService`应该提供哪些功能，我们可以得出创建新预订所需的方法：一个异步的`public`方法，调用`BookingRepository.CreateBooking`并返回适当的信息给控制器。在这里，适当的信息可能是一个表示`CreateBooking`方法已执行并完成的`Task<(bool,
    Exception)>`。如果预订失败，我们得到一个假的布尔值以及`CreateBooking`方法抛出的异常：`(false, thrownException)`。如果预订成功，我们返回一个真的布尔值和一个空指针（如果你启用了可空引用类型，你可能需要通过后缀一个问号字符将`Exception`转换为可空类型：`Exception?`）。如果你不想定义布尔返回值，你可以改用`Task`的内部`IsCompleted`
    `bool`。
- en: 'We should also look at the database schema (figure 10.8). The `Booking` model
    has the following two foreign key constraints:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该查看数据库模式（图10.8）。`Booking`模型有以下两个外键约束：
- en: An outgoing foreign key constraint to `Customer.CustomerID`
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指向`Customer.CustomerID`的外键约束
- en: An outgoing foreign key constraint to `Flight.FlightNumber`
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指向`Flight.FlightNumber`的外键约束
- en: '![](../Images/10_08.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/10_08.png)'
- en: 'Figure 10.8 The Flying Dutchman Airlines database schema. The Booking model
    has two outgoing foreign key constraints: one to `Customer.CustomerID` and one
    to `Flight.FlightNumber`.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8 Flying Dutchman Airlines数据库模式。预订模型有两个外键约束：一个指向`Customer.CustomerID`，一个指向`Flight.FlightNumber`。
- en: 'As part of our input validation, we should check whether the passed-in values
    representing `CustomerID` and `FlightNumber` are valid. We validate the values
    passed in by calling the appropriate repository’s methods (in this case, `CustomerRepository.GetCustomerByID`
    and `FlightRepository.GetFlightByFlightNumber`). Validating the input arguments
    also begs the question: what do we do if the passed-in `CustomerID` or `FlightID`
    does not exist in the database? If the customer does not exist in the database,
    that means they have not booked a flight with Flying Dutchman Airlines before.
    We don’t want to lose any customers (and, therefore, revenue), so we call the
    `CustomerRepository.CreateCustomer` method (implemented in chapter 11). If a flight
    does not exist, the booking is unsuccessful because we do not have the authority
    to add a new flight whenever we want.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们输入验证的一部分，我们应该检查传入的表示`CustomerID`和`FlightNumber`的值是否有效。我们通过调用适当的存储库方法（在这种情况下，`CustomerRepository.GetCustomerByID`和`FlightRepository.GetFlightByFlightNumber`）来验证传入的值。验证输入参数也引发了一个问题：如果传入的`CustomerID`或`FlightID`在数据库中不存在，我们该怎么办？如果客户在数据库中不存在，这意味着他们之前没有通过Flying
    Dutchman Airlines预订过航班。我们不希望失去任何客户（因此，收入），所以我们调用`CustomerRepository.CreateCustomer`方法（在第11章中实现）。如果航班不存在，预订将失败，因为我们没有权限随时添加新航班。
- en: We will call our method `CreateBooking`, because that is what we do in the method,
    and require two integers for input parameters (`customerID` and `flightNumber`).
    To call the `BookingRepository.CreateBooking` method, we first need to instantiate
    an instance of type `BookingRepository`. If you remember, when we implemented
    `BookingRepository` in chapter 8, we required an instance of `FlyingDutchmanAirlinesContext`
    in the repository’s constructor. This was so we could “inject” the dependency
    and not worry about how it gets instantiated. Well, we have to worry about that
    now because we want to instantiate a `BookingRepository` and need to pass in the
    required `FlyingDutchmanAirlinesContext` dependency. Maybe we can kick the can
    a little further down the road instead. If we require the injection of an instance
    of `BookingRepository` into the constructor of `BookingService`, as shown in the
    next listing, our problem is solved . . . for now.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们的方法命名为`CreateBooking`，因为这就是我们在方法中做的事情，并且需要两个整数作为输入参数（`customerID`和`flightNumber`）。要调用`BookingRepository.CreateBooking`方法，我们首先需要实例化一个`BookingRepository`类型的实例。如果你还记得，当我们在第8章实现`BookingRepository`时，我们在仓库的构造函数中需要一个`FlyingDutchmanAirlinesContext`的实例。这样做是为了“注入”依赖关系，而不必担心它是如何实例化的。然而，我们现在必须担心这个问题，因为我们想要实例化一个`BookingRepository`并需要传递所需的`FlyingDutchmanAirlinesContext`依赖关系。也许我们可以将这个问题推迟一点。如果我们要求在`BookingService`的构造函数中注入`BookingRepository`的实例，如下一列表所示，我们的问题现在解决了……至少目前是这样。
- en: Listing 10.1 Injecting `BookingRepository` into `BookingService`
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.1 将`BookingRepository`注入到`BookingService`
- en: '[PRE1]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ The backing field for the injected instance
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 注入实例的支撑字段
- en: ❷ Injects an instance of BookingRepository
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 注入一个`BookingRepository`实例
- en: ❸ We can assign readonly fields only in a constructor
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 我们只能在构造函数中分配只读字段
- en: So, where do we get this instance of `BookingRepository` from at runtime? We
    may not want the controller layer to mess with instantiating it because that would
    couple the repository layer to the controller layer. This sounds to me like unwanted
    tight coupling because the repository layer is already coupled to the service
    layer, and the service layer is coupled to the controller layer, as shown in figure
    10.9.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在运行时我们从哪里获取这个`BookingRepository`的实例？我们可能不希望控制器层去实例化它，因为这会将仓库层耦合到控制器层。这听起来像是不希望看到的紧密耦合，因为仓库层已经耦合到服务层，服务层又耦合到控制器层，如图10.9所示。
- en: '![](../Images/10_09.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图片10.9](../Images/10_09.png)'
- en: Figure 10.9 If we have an instance of `BookingRepository` inside `BookingController`,
    we have a tight coupling between the two classes. If `BookingController` indirectly
    calls `BookingRepository` through `BookingService`, we have loose(r) coupling.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9 如果我们在`BookingController`内部有一个`BookingRepository`的实例，这两个类之间就存在紧密耦合。如果`BookingController`通过`BookingService`间接调用`BookingRepository`，我们就有了较松的耦合。
- en: 'How do we avoid having to create an instance of `BookingRepository` in the
    controller without losing the ability to create and use an instance of `BookingService`?
    The answer lies in plain sight: dependency injection. When we get to the controller
    layer, we inject an instance of `BookingService` into the `BookingController`.
    How this `BookingService` is instantiated is a mystery I leave for you to ponder
    (we’ll discuss how to set up dependency injection at service launch in chapter
    13). For now, it suffices to understand the basics of dependency injection and
    how we use it in conjunction with `BookingService`. The `BookingService` should
    also have an injected instance of type `CustomerRepository` so we can get customer
    details before booking them on a flight. I leave this for you to do. If you get
    stuck, follow the preceding paragraphs. Of course, you may want to rename the
    `_repository` variable to something along the lines of `_bookingRepository` before
    injecting the `CustomerRepository` type, but that is up to you. Think about what
    you would most like to see. What is most readable?'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何避免在控制器中创建`BookingRepository`的实例，同时又不失去创建和使用`BookingService`实例的能力？答案就在眼前：依赖注入。当我们到达控制器层时，我们将一个`BookingService`的实例注入到`BookingController`中。这个`BookingService`是如何实例化的，这是一个留给你思考的谜题（我们将在第13章讨论如何在服务启动时设置依赖注入）。现在，我们只需要理解依赖注入的基本原理以及我们如何与`BookingService`一起使用它。`BookingService`也应该有一个注入的`CustomerRepository`类型的实例，这样我们就可以在预订航班之前获取客户详情。这个任务留给你来完成。如果你遇到了困难，请参考前面的段落。当然，你可能在注入`CustomerRepository`类型之前将`_repository`变量重命名为类似`_bookingRepository`的名称，但这取决于你。考虑一下你最想看到什么。什么是最易读的？
- en: Before we continue with the actual implementation of the `BookingService.CreateBooking`
    method, we should create the backing unit test—we should at least attempt to adhere
    to test-driven development practices. If you have not done so already, create
    a skeleton test file (in a folder called ServiceLayer) called `BookingServiceTests`
    in the FlyingDutchmanAirlines_Tests project, as shown in figure 10.10.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续实际实现 `BookingService.CreateBooking` 方法之前，我们应该创建一个支持单元测试——我们应该至少尝试遵循测试驱动开发实践。如果你还没有这样做，请在名为
    `ServiceLayer` 的文件夹中创建一个名为 `BookingServiceTests` 的测试文件（在 `FlyingDutchmanAirlines_Tests`
    项目中），如图10.10所示。
- en: '![](../Images/10_10.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10_10.png)'
- en: Figure 10.10 The BookingServiceTests file lives in the ServiceLayer folder inside
    the FlyingDutchmanAirlines_Tests project.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10 `BookingServiceTests` 文件位于 `FlyingDutchmanAirlines_Tests` 项目中 `ServiceLayer`
    文件夹内。
- en: To start our unit test, create a unit test method called `CreateBooking_Success`
    that instantiates a `BookingService` and calls the (still imaginary) `CreateBooking`
    method as shown next.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始我们的单元测试，创建一个名为 `CreateBooking_Success` 的单元测试方法，它实例化一个 `BookingService` 并调用（仍然是虚构的）`CreateBooking`
    方法，如下所示。
- en: Listing 10.2 A skeleton `CreateBooking_Success` unit test
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.2 骨架 `CreateBooking_Success` 单元测试
- en: '[PRE2]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Sets up an in-memory database
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 设置内存数据库
- en: ❷ Creates a BookingRepository instance, injecting the database context
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建 `BookingRepository` 实例，注入数据库上下文
- en: ❸ Creates a BookingService instance, injecting the BookingRepository instance
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 创建一个 `BookingService` 实例，注入 `BookingRepository` 实例
- en: 'On the surface, it seems we just have to deal with the inevitable compilation
    error saying that the compiler cannot find the `CreateBooking` method in `BookingService`.
    We expected that error and can deal with it: add a skeleton method called `CreateBooking`
    in the `BookingService` class. We’ll have the `CreateBooking` method accept two
    parameters: an integer containing the customer name and an integer for the flight
    number, as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上看，我们似乎只需要处理那个不可避免的编译错误，即编译器找不到 `BookingService` 中的 `CreateBooking` 方法。我们预料到这个错误并且可以处理它：在
    `BookingService` 类中添加一个名为 `CreateBooking` 的骨架方法。我们将让 `CreateBooking` 方法接受两个参数：一个包含客户名称的整数和一个表示航班号的整数，如下所示：
- en: '[PRE3]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There is another problem in listing 10.2: a snippet of code that is logically
    sound but won’t *quite* do. I am talking about how we instantiate the `BookingService`
    in the assignment to the `service` variable as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.2中还有一个问题：一段逻辑上合理但不会完全做到的代码片段。我指的是我们在将 `BookingService` 分配给 `service` 变量时的实例化方式：
- en: '[PRE4]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the next section, we’ll dissect the problem with this assignment further.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将进一步剖析这个作业的问题。
- en: 10.3.1 Unit testing across architectural layers
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.1 在架构层之间进行单元测试
- en: 'In this section, I’ll introduce you to the concept of scoping your unit tests
    to only your immediate architectural layer. This section contains a somewhat unique
    element for a technical book: a Socratic dialogue.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将向您介绍将单元测试范围限制在您直接架构层的概念。本节包含了一本技术书中相对独特的元素：苏格拉底对话。
- en: 'Because the `BookingService` requires an injected instance `BookingRepository`
    (through its only available constructor), we simply created a new instance of
    `BookingRepository` in listing 10.2\. This is perfectly legitimate code in terms
    of syntax. But I want to convince you otherwise. Let’s perform an experiment in
    (somewhat untrue to form and inspired by Alcibiades II) the following Socratic
    dialogue:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `BookingService` 需要一个注入的实例 `BookingRepository`（通过其唯一可用的构造函数），所以我们简单地创建了 `BookingRepository`
    的新实例，如列表10.2所示。这在语法上是完全合法的代码。但我想要说服你相反。让我们在（某种程度上不符合形式且受阿尔基比阿德斯二世启发）以下苏格拉底对话中进行实验：
- en: '*PERSONS OF THE DIALOGUE: Socrates and Phaidra*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*对话人物：苏格拉底和菲德拉*'
- en: 'Setting: A cubicle somewhere deep in Mount Olympus'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 环境：奥林匹斯山深处的一个隔间
- en: '**SOCRATES**: Are you testing the `BookingService`, Phaidra?'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**SOCRATES**：你在测试 `BookingService`，菲德拉吗？'
- en: '**PHAIDRA**: Yes, Socrates, I am.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**PHAIDRA**：是的，苏格拉底，我是。'
- en: '**SOCRATES**: You seem troubled and cast your eyes to the ground. Are you thinking
    of something?'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**SOCRATES**：你似乎很烦恼，眼睛向下看。你在想什么吗？'
- en: '**PHAIDRA**: Of what am I supposed to be thinking?'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**PHAIDRA**：我应该想些什么？'
- en: '**SOCRATES**: Oh, of all kinds of things, I suppose. Perhaps how to correctly
    test a code base, or the airspeed velocity of an unladen swallow?'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**SOCRATES**：哦，各种各样的事情，我想。也许是如何正确测试代码库，或者一只未迁徙的麻雀的飞行速度？'
- en: '**PHAIDRA**: Certainly.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**PHAIDRA**：当然。'
- en: '**SOCRATES**: Do you not imagine, then, that it is of the utmost importance
    that you determine what you are testing before you test it?'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**苏格拉底**：那么，你不认为在测试之前确定你要测试的内容是最重要的吗？'
- en: '**PHAIDRA**: Certainly, Socrates. But you are speaking like a mad man; surely
    you do not offer that I do not know what I test?'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**菲德拉**：当然，苏格拉底。但你说话像疯子一样；你肯定不会认为我不知道我在测试什么吧？'
- en: '**SOCRATES**: Well, then, let’s discuss what it means to test something correctly.
    Does testing an ox cart mean you test the ox? Does testing the pluck of a lyre
    mean you test Apollo’s skill like Marsyas, the Muses, and the Nysean nymphs?'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**苏格拉底**：那么，让我们讨论正确测试某事物意味着什么。测试牛车是否意味着你测试牛？测试里拉琴弦的拨动是否意味着你像玛尔斯亚斯、缪斯和尼塞恩仙女一样测试阿波罗的技艺？'
- en: '**PHAIDRA**: Certainly not.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**菲德拉**：当然不是。'
- en: '**SOCRATES**: Nor does the accurate representation of the scribe’s hand reflect
    a test on the orator’s vocals?'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**苏格拉底**：难道抄写员的笔迹的准确表示不反映对演说者嗓音的测试吗？'
- en: '**PHAIDRA**: That is my opinion.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**菲德拉**：这是我的观点。'
- en: '**SOCRATES**: Then does one need to test, and have an accurate representation
    of, a repository when dealing with a service?'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**苏格拉底**：那么，在处理服务时，是否需要测试并有一个准确的存储库表示？'
- en: '**PHAIDRA**: Socrates, you are devious and cunning.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**菲德拉**：苏格拉底，你狡猾而机智。'
- en: '**SOCRATES**: So, we are agreed that if you test the `BookingService` class,
    do you need to also test the `BookingRepository` class?'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**苏格拉底**：所以，我们一致认为，如果你测试`BookingService`类，你是否也需要测试`BookingRepository`类？'
- en: '**PHAIDRA**: We are agreed.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**菲德拉**：我们意见一致。'
- en: 'Even in ancient Greece, how to properly test code was a hot topic! Let us ask
    ourselves a question: what do we want to test in the `BookingService` unit tests?
    Should we verify that the `BookingService` returns the correct output when given
    an appropriate input? Yes, that sounds about right. Should we also test whether
    `BookingRepository` does the same? Well, yes, to a point.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在古希腊，如何正确测试代码也是一个热门话题！让我们自问一个问题：在`BookingService`单元测试中，我们想测试什么？我们应该验证当给`BookingService`适当的输入时，它是否返回正确的输出吗？是的，听起来很对。我们也应该测试`BookingRepository`是否做同样的事情吗？嗯，是的，在某种程度上。
- en: If `BookingRepository` does not function correctly, it has unwanted consequences
    for `BookingService`. In testing `BookingService`, can we not assume that `BookingRepository`
    works correctly because we already have unit tests in place for that class? Well,
    yes, that makes some sense. If we could somehow skip the `BookingService` code
    and have it return valid information when we want it, we could control all the
    code execution in the repository layer during the test. Additionally, if we instantiate
    a `BookingRepository` and inject that into `BookingService`, the tests would operate
    on the actual `BookingRepository` instance and, therefore, on the in-memory database
    as well, as shown in figure 10.11.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`BookingRepository`不能正确工作，它会对`BookingService`产生不希望的结果。在测试`BookingService`时，我们不能假设`BookingRepository`工作正常，因为我们已经为该类设置了单元测试，对吗？嗯，是的，这有些道理。如果我们能以某种方式跳过`BookingService`代码，并在需要时返回有效信息，我们就可以在测试期间控制存储库层的所有代码执行。此外，如果我们实例化一个`BookingRepository`并将其注入到`BookingService`中，测试将操作实际的`BookingRepository`实例，因此也会在内存数据库上操作，如图10.11所示。
- en: '![](../Images/10_11.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10_11.png)'
- en: Figure 10.11 In a multilayered architecture, we test only the layer we are executing
    code in and mock or stub one layer down. As a result, we don’t interact with layers
    further down.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.11在多层架构中，我们只测试我们正在执行的代码所在的层，并模拟或存根下一层。因此，我们不会与更低的层交互。
- en: When testing a multilayered architecture (such as the repository/service pattern
    we are using), you typically don’t need to test the actual logic of a tier down
    from what you are working on. If you are testing the repository layer, you can
    stub or mock the database access layer (which is what we did with the `FlyingDutchmanAirlinesContext
    _Stub` class). If you are testing the service layer, you don’t need to verify
    the logic of the repository layer.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试多层架构（如我们使用的存储库/服务模式）时，你通常不需要测试低于你正在工作的那一层的实际逻辑。如果你正在测试存储库层，你可以模拟或存根数据库访问层（这就是我们使用`FlyingDutchmanAirlinesContext_Stub`类所做的那样）。如果你正在测试服务层，你不需要验证存储库层的逻辑。
- en: 10.3.2 The difference between a stub and a mock
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.2存根和模拟的区别
- en: 'Throughout the book, we used the `FlyingDutchmanAirlinesContext_Stub` to unit-test
    the repository layer of our `FlyingDutchmanAirlines` project. In this (and the
    following) section, I’ll introduce you to another approach to controlling code
    execution during tests: mocks. We’ll also look at the difference between a stub
    and a mock.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们使用了`FlyingDutchmanAirlinesContext_Stub`来对`FlyingDutchmanAirlines`项目的仓库层进行单元测试。在本节（以及接下来的章节）中，我将向您介绍另一种在测试期间控制代码执行的方法：模拟。我们还将探讨存根和模拟之间的区别。
- en: A stub is very helpful when we want to execute different code than what the
    original class does. For example, the `context.SaveChangesAsync` method saves
    the changes made to the internal `DbSets` of Entity Framework Core to the database.
    In section 8.4, we wanted to execute a different version of the method, so we
    made a stub (`FlyingDutchmanAirlinesContext_Stub`) and overrode the parent class’s
    `SaveChangesAsync` method.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要执行与原始类不同的代码时，存根非常有用。例如，`context.SaveChangesAsync`方法将Entity Framework Core内部`DbSets`所做的更改保存到数据库中。在第8.4节中，我们想要执行方法的不同版本，因此我们创建了一个存根（`FlyingDutchmanAirlinesContext_Stub`）并重写了父类的`SaveChangesAsync`方法。
- en: In a mock, we do not provide any new implementation for a method. When we use
    a mock, we tell the compiler to instantiate a type of `Mock<T>` that masquerades
    as `T`. Because of the Liskov substitution principle, we can use the mock as type
    `T`. Instead of an actual instance of class `T` being instantiated and injected
    into a constructor, we instantiate and inject the mock.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟中，我们不对方法提供任何新的实现。当我们使用模拟时，我们告诉编译器实例化一个`Mock<T>`类型的类型，它伪装成`T`。由于Liskov替换原则，我们可以将模拟用作类型`T`。而不是实例化并注入实际的`T`类实例，我们实例化并注入模拟。
- en: 'In our case, we want a `Mock<BookingRepository>`. When, during a test, the
    code in `BookingService` calls this mock’s `CreateBooking`, we want to do one
    of two following things:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们想要一个`Mock<BookingRepository>`。当在测试期间`BookingService`中的代码调用这个模拟的`CreateBooking`方法时，我们想要执行以下两个操作之一：
- en: Immediately return from the method (without actually creating the booking in
    the database) when we want to mimic a success condition.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们想要模拟成功条件时，立即从方法返回（实际上不在数据库中创建预订）。
- en: Throw an `Exception` when we want to mimic a failure condition.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们想要模拟失败条件时，抛出`Exception`。
- en: Because we need to do only these two simple things, and we do not have to perform
    any logic that checks for entities within the in-memory database (like we do in
    the stub), it is easier to use a mock. You’re not convinced? Well, hang on to
    your hats and read the next section.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们只需要做这两件简单的事情，而且我们不需要在内存数据库中执行任何检查实体的逻辑（就像我们在存根中做的那样），所以使用模拟会更简单。您还没有被说服？好吧，请系好您的帽子，阅读下一节。
- en: 10.3.3 Mocking a class with the Moq library
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.3 使用Moq库模拟类
- en: 'In section 10.3.2, we briefly discussed the difference between a mock and a
    stub. It’s now time for me to show you how we can use a mock in practice and what
    we need to do to make that happen. First, neither C# nor .NET 5 has dedicated
    mocking functionality, so we need to use a third-party (open source) library to
    mock our classes: Moq. Of course, you can use plenty of other mocking libraries
    or frameworks (Telerik JustMock, FakeItEasy, and NSubstitute are examples). I
    chose Moq because it is widely used and easy to work with.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在第10.3.2节中，我们简要讨论了模拟和存根之间的区别。现在是我向大家展示如何在实际中运用模拟以及我们需要做什么来实现这一点的时候了。首先，C#和.NET
    5都没有专门的模拟功能，因此我们需要使用第三方（开源）库来模拟我们的类：Moq。当然，您可以使用许多其他的模拟库或框架（Telerik JustMock、FakeItEasy和NSubstitute是一些例子）。我选择Moq是因为它被广泛使用且易于使用。
- en: 'To install Moq, you can either use the NuGet package manager within Visual
    Studio or use the command line in the FlyingDutchmanAirlines_Tests folder as we
    did in section 5.2.1 and as shown next:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装Moq，您可以使用Visual Studio中的NuGet包管理器，或者在FlyingDutchmanAirlines_Tests文件夹中使用命令行，就像我们在第5.2.1节中做的那样，如下所示：
- en: '[PRE5]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This command adds the Moq package to the FlyingDutchmanAirlines_Test project.
    To verify the Moq package was added, you can either check Visual Studio for a
    Moq reference or open up the FlyingDutchmanAirlines_Test.csproj file and look
    for a Moq package reference, as shown in figure 10.12`.`
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将Moq包添加到FlyingDutchmanAirlines_Test项目中。为了验证Moq包已被添加，您可以在Visual Studio中检查Moq引用，或者打开FlyingDutchmanAirlines_Test.csproj文件并查找Moq包引用，如图10.12所示。
- en: '![](../Images/10_12.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图10.12](../Images/10_12.png)'
- en: Figure 10.12 A reference to a package is added to a project’s .csproj file.
    Visual Studio scans this file and shows the added packages in the Solution Explorer
    panel. Edits made in the .csproj or Visual Studio automatically trickle down to
    both places.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.12 将包引用添加到项目的 .csproj 文件中。Visual Studio 扫描此文件，并在解决方案资源管理器面板中显示添加的包。对 .csproj
    或 Visual Studio 的编辑会自动传播到这两个地方。
- en: 'Before we can use Moq, we have to import its namespace into the `BookingServiceTests`
    class. To create a mock of type `BookingRepository` and return the appropriate
    output from the `CreateBooking` method (a completed `Task`) we need to do the
    following:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够使用 Moq 之前，我们必须将其命名空间导入到 `BookingServiceTests` 类中。为了创建一个 `BookingRepository`
    类型的模拟并从 `CreateBooking` 方法返回适当的输出（一个完成的 `Task`），我们需要执行以下操作：
- en: Instantiate a `Mock<BookingRepository>`.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例化一个 `Mock<BookingRepository>`。
- en: Set up the `Mock<BookingRepository>` to return a completed task when we call
    `CreateBooking`.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 `Mock<BookingRepository>` 以在调用 `CreateBooking` 时返回一个完成的任务。
- en: 'We know how to do the first item on the list—instantiate a `Mock<BookingRepository>`—because
    instantiating a mock is no different from instantiating any other class. Let’s
    create our instance of the mock in the `CreateBooking_Success` unit test as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道如何执行列表中的第一项——实例化一个 `Mock<BookingRepository>`——因为实例化模拟与实例化任何其他类没有区别。让我们在
    `CreateBooking_Success` 单元测试中创建模拟的实例，如下所示：
- en: '[PRE6]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can use the `mock.Setup([lambda expression to call method])).[return]`
    syntax to set up a mock where a method returns a specific value when called. Because
    we want to call (and mock) the `CreateBooking` method, the lambda expression we
    can use is `repository => repository.CreateBooking(0, 0)`. We follow this by specifying
    what we want to return: `Returns(Task.CompletedTask``)`, as shown next.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `mock.Setup([lambda expression to call method])).[return]` 语法设置模拟，当调用方法时返回特定值。因为我们想调用（并模拟）`CreateBooking`
    方法，所以我们可以使用的 lambda 表达式是 `repository => repository.CreateBooking(0, 0)`。然后我们指定我们想要返回的内容：`Returns(Task.CompletedTask)`，如下所示。
- en: Listing 10.3 Setting up a mock of `BookingRepository` and calling `CreateBooking`
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.3 设置 `BookingRepository` 的模拟并调用 `CreateBooking`
- en: '[PRE7]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ We instantiate a new mock instance of BookingRepository.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们实例化一个新的 `BookingRepository` 模拟实例。
- en: ❷ If the mock calls CreateBooking with two parameters with zero values, returns
    a Task.CompletedTask
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果模拟调用 `CreateBooking` 并传递两个值为零的参数，则返回 `Task.CompletedTask`
- en: Unfortunately, the code in listing 10.3 won’t run correctly. Moq throws a runtime
    exception, shown in figure 10.13, saying it cannot instantiate a mock from a class
    it cannot override.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，列表 10.3 中的代码无法正确运行。Moq 抛出一个运行时异常，如图 10.13 所示，表示它无法从无法覆盖的类中实例化模拟。
- en: '![](../Images/10_13.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10_13.png)'
- en: Figure 10.13 Moq throws a runtime exception because we tried to mock a class
    that is not overridable.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.13 Moq 抛出运行时异常，因为我们尝试模拟一个不可覆盖的类。
- en: The `BookingRepository.CreateBooking` is not a virtual method, so Moq cannot
    override the method to implement a new version of it. Moq also needs to be able
    to call a parameterless constructor, which the `BookingRepository` does not have.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`BookingRepository.CreateBooking` 不是一个虚方法，所以 Moq 无法覆盖该方法以实现其新版本。Moq 还需要能够调用无参数的构造函数，而
    `BookingRepository` 没有这样的构造函数。'
- en: To remedy these two issues, we first make the `BookingRepository.CreateBooking`
    method `virtual` as follows`:`
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这两个问题，我们首先将 `BookingRepository.CreateBooking` 方法设置为 `virtual`，如下所示：`
- en: '[PRE8]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Then, we create a parameterless constructor for `BookingRepository` like so`:`
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们为 `BookingRepository` 创建一个无参数的构造函数，如下所示：`
- en: '[PRE9]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'But it would be a shame if all our work making sure developers instantiate
    an instance of `BookingRepository` through the constructor with the injected `FlyingDutchmanAirlinesContext`
    goes out the window. I really would like for the new constructor to have an access
    modifier of `private`, but then the unit tests wouldn’t be able to access them
    (because the unit tests live in a different assembly than the repository layer).
    There are a couple of tricks that can help us here. The three most used follow:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们的所有工作都白费了，确保开发人员通过构造函数使用注入的 `FlyingDutchmanAirlinesContext` 实例化 `BookingRepository`，那就太遗憾了。我真的希望新的构造函数具有
    `private` 访问修饰符，但这样单元测试就无法访问它们（因为单元测试位于与存储库层不同的程序集）。这里有几个技巧可以帮助我们。以下是最常用的三个：
- en: 'Use the `[assembly: InternalsVisibleTo([assembly name])`] attribute.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '使用 `[assembly: InternalsVisibleTo([assembly name])`] 属性。'
- en: Use the `#warning` preprocessor directive to generate a compiler warning.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `#warning` 预处理器指令生成编译器警告。
- en: Verify that the executing assembly does not match the non–unit test assembly.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证正在执行的程序集与单元测试程序集不匹配。
- en: Let’s unpack them one by one.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一解开它们。
- en: The InternalsVisibleTo method attribute
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`InternalsVisibleTo` 方法属性'
- en: 'First, the `[assembly: InternalsVisibleTo([assembly name])]` attribute, which
    you can apply only to assemblies, allows a different assembly (the `FlyingDutchmanAirlines
    _Tests.ServiceLayer` assembly, in our case) to access and manipulate methods,
    properties, and fields of the containing assembly (`FlyingDutchmanAirlines`) flagged
    with the internal access modifier. When the CLR sees the `InternalsVisibleTo`
    attribute, it notes the given assembly and designates it as a “friend” assembly
    to the one it is trying to access the internals of. In practical terms, the CLR
    treats a friend assembly as the same assembly as the containing assembly when
    it comes to compiling down to Intermediate Language.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '首先，`[assembly: InternalsVisibleTo([assembly name])]` 属性，您只能将其应用于程序集，允许不同的程序集（在我们的例子中是
    `FlyingDutchmanAirlines _Tests.ServiceLayer` 程序集）访问和操作带有内部访问修饰符的包含程序集（`FlyingDutchmanAirlines`）中的方法、属性和字段。当
    CLR 看到内部可见性属性时，它会记录给定的程序集，并将其指定为尝试访问其内部程序集的“友元”程序集。在实践中，当 CLR 编译到中间语言时，它将友元程序集视为与包含程序集相同的程序集。'
- en: The problem with using friend assemblies and the `InternalsVisibleTo` attribute
    approach is that the `InternalsVisibleTo` attribute is incredibly finicky. There
    are oodles of pages on Stack Overflow with questions about how to get the attribute
    working correctly. Besides the usability issue, we also aren’t very keen on testing
    private methods. Ideally, we would test all private methods through the public
    methods that use them. Tests should not walk any paths that a normal user would
    not walk. Because a normal user does not interact with a class by calling its
    private methods, neither should a unit test. The `InternalsVisibleTo` method attribute
    is a good thing to know about, but not a practical thing to use. The real pro
    tip when it comes to `InternalsVisibleTo` is to save yourself the heartache of
    using it and just don’t.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 使用友元程序集和 `InternalsVisibleTo` 属性方法的问题在于，`InternalsVisibleTo` 属性非常挑剔。Stack Overflow
    上有大量关于如何正确使用该属性的提问。除了可用性问题之外，我们也不太愿意测试私有方法。理想情况下，我们应该通过使用它们的公共方法来测试所有私有方法。测试不应该走任何普通用户不会走的路径。因为普通用户不会通过调用其私有方法与类进行交互，单元测试也不应该这样做。`InternalsVisibleTo`
    方法属性是了解的好东西，但不是实际使用的好方法。关于 `InternalsVisibleTo` 的真正实用提示是，避免使用它，直接不使用即可。
- en: 'TIP For more information on method and member accessibility, see the “bible”
    of the CLR: Jeffrey Richter’s *CLR via C#* (4th edition; Microsoft Press, 2012).
    Be aware, however, that this book assumes a lot of the knowledge covered in this
    book.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：有关方法和成员访问权限的更多信息，请参阅 CLR 的“圣经”：Jeffrey Richter 的 *CLR via C#*（第 4 版；Microsoft
    Press，2012 年）。然而，请注意，这本书假设了本书中涵盖的大量知识。
- en: 'Preprocessor directives (#warning and #error)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '预处理器指令（#warning 和 #error）'
- en: 'Second, we can use preprocessor directives in our source code. Preprocessor
    directives are commands starting with the `#` character that are resolved before
    compilation. The compiler scans the codebase for preprocessor directives and executes
    them before compilation. To deal with compilation warnings and errors, we can
    use the `#warning` and `#error` preprocessor directives. `#warning` throws a compiler
    warning, and `#error` throws a compiler error when warnings and errors are encountered.
    To add a compiler warning through the `#warning` directive in our public parameterless
    constructor, add the directive along with a message to the constructor. It is
    good to note that we always insert preprocessor directives into the source code
    with no indentation (be they spaces or tabs), as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们可以在源代码中使用预处理器指令。预处理器指令是以 `#` 字符开头的命令，在编译之前解析。编译器扫描代码库中的预处理器指令，并在编译之前执行它们。为了处理编译警告和错误，我们可以使用
    `#warning` 和 `#error` 预处理器指令。`#warning` 抛出编译器警告，而 `#error` 在遇到警告和错误时抛出编译器错误。要通过
    `#warning` 指令在我们的公共无参数构造函数中添加编译器警告，请将指令及其消息添加到构造函数中。值得注意的是，我们总是将预处理器指令插入到源代码中，不进行缩进（无论是空格还是制表符），如下所示：
- en: '[PRE10]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Using the `#warning` preprocessor directive works decently well, but if we have
    a lot of `#warning` directives, our compilation process would cause a lot of warnings,
    diminishing the value of them collectively and making it easy to overlook other
    warnings. The other downside is that just because there is a warning doesn’t mean
    that a developer pays attention to it. See figure 10.14 for an example.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `#warning` 预处理器指令效果不错，但如果我们有大量的 `#warning` 指令，我们的编译过程将导致很多警告，这会降低它们的整体价值，并使得其他警告容易被忽视。另一个缺点是，仅仅因为有一个警告并不意味着开发者会注意到它。请参阅图
    10.14 中的示例。
- en: '![](../Images/10_14.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10_14.png)'
- en: Figure 10.14 The `#warning` preprocessor directive generates a compiler warning
    with the given string. Here we see the compiler warning as shown in Visual Studio
    2019.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.14 `#warning` 预处理器指令生成带有给定字符串的编译器警告。这里我们看到的是在 Visual Studio 2019 中显示的编译器警告。
- en: Matching executing and calling assembly names
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配执行和调用汇编名称
- en: 'Third, I propose the possibility of doing a bit of a programmatic hack: by
    using reflection, we can access the name of the executing or calling assemblies
    (for a discussion on what assemblies are, see section 2.3.1). When we call the
    parameterless constructor of `BookingRepository.CreateBooking` from a class inside
    the `FlyingDutchmanAirlines` assembly, the calling assembly is `FlyingDutchmanAirlines`.
    If we call the same constructor from a different assembly, let’s say, the `FlyingDutchmanAirlines_Tests`
    assembly, the CLR does not have the required info to provide us with the executing
    assembly name because it often can retrieve information only on the executing
    assembly.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，我提出了一种程序性黑客攻击的可能性：通过使用反射，我们可以访问执行或调用汇编的名称（有关汇编是什么的讨论，请参阅第 2.3.1 节）。当我们从 `FlyingDutchmanAirlines`
    汇编内部调用 `BookingRepository.CreateBooking` 的无参构造函数时，调用汇编是 `FlyingDutchmanAirlines`。如果我们从不同的汇编中调用相同的构造函数，比如说，`FlyingDutchmanAirlines_Tests`
    汇编，CLR 没有提供所需信息来提供执行汇编名称，因为它通常只能检索执行汇编的信息。
- en: We can take advantage of this by checking whether the calling assembly is equal
    to the currently *executing* assembly. If it is, somebody is being sneaky and
    instantiating `BookingRepository` in the wrong way. Of course, checking assembly
    names against each other is not foolproof. Somebody could create a new assembly
    and use the incorrect constructor, but the amount of effort to do that makes it
    unlikely. We access the names of the calling and executing assemblies by using
    the `Assembly` class, as shown in the next listing.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过检查调用汇编是否等于当前 *执行* 汇编来利用这一点。如果是这样，有人正在偷偷摸摸地以错误的方式实例化 `BookingRepository`。当然，将汇编名称相互比较并不是万无一失的。有人可以创建一个新的汇编并使用错误的构造函数，但这样做需要付出的努力使得这种情况不太可能。我们通过使用
    `Assembly` 类来访问调用和执行汇编的名称，如下一列表所示。
- en: Listing 10.4 Comparing executing and calling assembly names
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.4 比较执行和调用汇编名称
- en: '[PRE11]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Compares the executing assembly against the calling assembly names
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将执行汇编与调用汇编名称进行比较
- en: ❷ Throws an exception if the constructor is accessed incorrectly
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果构造函数被错误访问，则抛出异常
- en: With the code in listing 10.4, if a developer tries to instantiate an instance
    of `BookingRepository` from within the `FlyingDutchmanAirlines` assembly and does
    not use the appropriate constructor, the code throws an `Exception` at runtime
    because the names of the executing assembly and calling assembly match.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 10.4 的代码中，如果开发者在 `FlyingDutchmanAirlines` 汇编内部尝试实例化 `BookingRepository`
    的一个实例，并且没有使用适当的构造函数，那么代码在运行时会抛出一个 `Exception`，因为执行汇编和调用汇编的名称匹配。
- en: 'There is one caveat with using reflection to get the name of a calling assembly:
    the CLR uses the last executed stack frame to get the calling assembly name, but
    if some of the code was inlined by the compiler, there is a chance that this stack
    frame does not contain the correct information.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 使用反射获取调用汇编名称有一个注意事项：CLR 使用最后一个执行的堆栈帧来获取调用汇编名称，但如果一些代码被编译器内联了，那么这个堆栈帧可能不包含正确的信息。
- en: Compiler method inlining
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器方法内联
- en: During compilation, when a compiler encounters a call to a method in a different
    class, it is often beneficial for performance to replace the method call with
    the body of the called method. This decreases the amount of cross-file computation
    and, in general, improves performance. There is a point of diminishing returns,
    however. When the called method is very large and contains calls to other large
    methods, the compiler can get stuck in a rabbit hole. The compiler then copies
    the bodies of deeply nested methods into the original calling class, and before
    you know it, your class blows up in size and complexity. Modern compilers are
    very good at detecting this sort of thing, so in general, it is not something
    you need to worry about.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译过程中，当编译器遇到对另一个类中方法的调用时，通常将方法调用替换为被调用方法的主体对性能有益。这减少了跨文件计算量，并且通常可以提高性能。然而，也存在收益递减的点。当被调用方法非常大且包含对其他大型方法的调用时，编译器可能会陷入一个死胡同。然后编译器会将深层嵌套方法的主体复制到原始调用类中，在你意识到之前，你的类的大小和复杂性就会急剧增加。现代编译器非常擅长检测这类问题，所以通常这不是你需要担心的事情。
- en: 'Additionally, compilers generally do not attempt to inline recursive methods
    because it would result in the compiler being stuck in an infinite loop where
    it tries to copy the body of the same method into itself into perpetuity. For
    more information on compiler inlining (and compilers in general), see Alfred V.
    Aho, Monica S. Lam, Ravi Sethi, and Jeffrey D. Ullman’s *Compilers: Principles,
    Techniques & Tools* (2nd edition; Pearson Education, 2007).'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '此外，编译器通常不会尝试内联递归方法，因为这会导致编译器陷入一个无限循环，其中它试图将相同方法的主体永久地复制到自身中。有关编译器内联（以及编译器的一般信息），请参阅
    Alfred V. Aho、Monica S. Lam、Ravi Sethi 和 Jeffrey D. Ullman 的 *Compilers: Principles,
    Techniques & Tools*（第 2 版；Pearson Education，2007）。'
- en: 'Luckily, we can tell the compiler to not inline the code in a specific method
    by using the method implementation (`MethodImpl`) method attribute. The `MethodImpl`
    method attribute allows us to specify how the compiler should treat our method,
    and lo and behold, one option is to stop the compiler from inlining a given method.
    Let’s add the `MethodImpl` method attribute to the constructor and ask the compiler
    not to inline the method, as shown here:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以通过使用方法实现（`MethodImpl`）方法属性来告诉编译器不要在特定方法中内联代码。`MethodImpl` 方法属性允许我们指定编译器应该如何处理我们的方法，而且，令人惊讶的是，有一个选项是停止编译器内联给定方法。让我们将
    `MethodImpl` 方法属性添加到构造函数中，并要求编译器不要内联该方法，如下所示：
- en: '[PRE12]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Coming back to the `CreateBooking_Success` unit test, we now have a `Mock<BookingRepository>`
    instance that we can inject into the `BookingService`. Injecting an instance of
    mock into the `BookingService` allows us to test the `BookingService` without
    worrying about the implementation details of the `BookingRepository` class. To
    inject a `Mock<T>`, we need to use the mock’s underlying object, which is the
    actual mocked object: `Object`. If we do not use the `Object` property of a mock,
    we pass in the actual instance of type `Mock<T>`, which does not match the required
    dependency. To use a mock’s `Object` property, you call the `[mock].Object` property,
    as shown in the following listing.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 `CreateBooking_Success` 单元测试，我们现在有一个可以注入到 `BookingService` 的 `Mock<BookingRepository>`
    实例。将模拟实例注入到 `BookingService` 允许我们在不担心 `BookingRepository` 类的实现细节的情况下测试 `BookingService`。要注入
    `Mock<T>`，我们需要使用模拟的底层对象，即实际模拟的对象：`Object`。如果我们不使用模拟的 `Object` 属性，我们将传递 `Mock<T>`
    的实际实例，这不符合所需的依赖项。要使用模拟的 `Object` 属性，你调用 `[mock].Object` 属性，如下所示。
- en: Listing 10.5 Injection a mocked instance into `RepositoryService`
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.5 将模拟实例注入到 `RepositoryService`
- en: '[PRE13]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Creates a mock of BookingRepository
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建 BookingRepository 的模拟
- en: ❷ Sets up the correct return of the mock’s CreateBooking method
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 设置模拟的 CreateBooking 方法的正确返回值
- en: ❸ Injects the mock into the BookingService
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将模拟注入到 BookingService
- en: ❹ The CreateBooking method returns a named tuple.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ CreateBooking 方法返回一个命名元组。
- en: 'We also need a mock of the `CustomerRepository` that returns a new `Customer`
    object when we call `GetCustomerByName`. We know what to do now. Go ahead and
    add the `virtual` keyword to the `GetCustomerByName` method, and make sure that
    we can mock the `CustomerRepository` (add a constructor similar to what we did
    for the `BookingRepository`), shown next:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个当调用 `GetCustomerByName` 时返回新 `Customer` 对象的 `CustomerRepository` 模拟。我们现在知道该怎么做。将
    `virtual` 关键字添加到 `GetCustomerByName` 方法中，并确保我们可以模拟 `CustomerRepository`（添加一个类似于我们为
    `BookingRepository` 做的构造函数），如下所示：
- en: '[PRE14]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In terms of test-driven development, we are currently in the green stage and
    attempting to go to the red stage. Before we go on, we should do some quick cleanups.
    Because we are using a mock, we do not need to use the stub of `FlyingDutchmanAirlinesContext`
    or the `dbContextOptions` in this test class. We should remove the instantiation
    of the stub, the corresponding backing field, and `dbContextOptions` from the
    `TestInitialize` method now. I leave this for you to do.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试驱动开发方面，我们目前处于绿色阶段，并试图进入红色阶段。在我们继续之前，我们应该做一些快速的清理工作。因为我们使用了一个模拟，所以我们不需要在这个测试类中使用
    `FlyingDutchmanAirlinesContext` 的存根或 `dbContextOptions`。我们现在应该从 `TestInitialize`
    方法中移除存根的实例化、相应的后置字段和 `dbContextOptions`。我将这个任务留给你去做。
- en: If we run our tests now, we see that they pass. Unfortunately, they pass for
    the wrong reasons. In section 10.3, we added a skeleton body to `BookingService.CreateBooking`
    along with a hardcoded return value. This is what makes the `CreateBooking_Success`
    unit test pass. An important lesson to keep in mind with unit testing is to always
    make sure your tests pass for the right reasons. It is easy to “fake” a successful
    test result by providing hardcoded return values or by asserting on incorrect
    data. How do we make sure the `CreateBooking_Success` unit test passes for the
    correct reasons? We have to continue implementing the `CreateBooking` method,
    which we’ll do in section 10.3.4.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行我们的测试，我们会看到它们通过了。不幸的是，它们通过的原因是错误的。在 10.3 节中，我们为 `BookingService.CreateBooking`
    添加了一个骨架体以及一个硬编码的返回值。这就是使 `CreateBooking_Success` 单元测试通过的原因。在单元测试中要记住的一个重要教训是，一定要确保你的测试通过正确的原因。通过提供硬编码的返回值或对错误数据进行断言，很容易“伪造”一个成功的测试结果。我们如何确保
    `CreateBooking_Success` 单元测试通过正确的原因？我们必须继续实现 `CreateBooking` 方法，我们将在 10.3.4 节中这样做。
- en: 10.3.4 Calling a repository from a service
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.4 从服务中调用仓库
- en: We came out of section 10.3.3 with a skeleton implementation of `BookingService
    .CreateBooking` and a finished unit test for the success case through `BookingServiceTests.CreateBooking_Success`.
    In this section, we’ll look at further implementing the `CreateBooking` method
    so it calls the appropriate repository method and returns the correct information.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 10.3.3 节结束时得到了 `BookingService.CreateBooking` 的骨架实现以及通过 `BookingServiceTests.CreateBooking_Success`
    的成功情况完成的单元测试。在本节中，我们将进一步实现 `CreateBooking` 方法，使其调用适当的仓库方法并返回正确的信息。
- en: 'To finish the `CreateBooking` method, we need to implement the following two
    things:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成 `CreateBooking` 方法，我们需要实现以下两个事项：
- en: An asynchronous call to the `BookingRepository`. `GetCustomerByName` method
    inside a `try-catch` block
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对 `BookingRepository` 的异步调用。在 `try-catch` 块内调用 `GetCustomerByName` 方法
- en: The appropriate set of tuple values for returning out of the method
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从方法中返回适当的元组值集合
- en: 'Calling repository methods inside a `try-catch` block allows us to do error
    handling. When an exception is raised inside the called repository method, the
    `try-catch` block catches the exception, as shown here:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `try-catch` 块内调用仓库方法允许我们进行错误处理。当在调用的仓库方法内部抛出异常时，`try-catch` 块会捕获该异常，如下所示：
- en: '[PRE15]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Inside the `try` part of the `try-catch` code block, we want to use the class-level
    private properties containing references to the injected `CustomerRepository`
    and `BookingRepository` instances: `_customerRepository` and `_bookingRepository`
    (during the execution of our unit tests, this holds a reference to the mocked
    version of `BookingRepository`, as explained in section 10.3.3). We use the `_customerRepository`
    instance to call its `GetCustomerByName` method. The `GetCustomerByName` method
    retrieves the appropriate `Customer` instance or throws a `CustomerNotFoundException`,
    which lets us know the customer was not found. If it does not exist, we call the
    `CreateCustomer` method and have it created. After that, we call the `CreateBooking`
    method again, returning its return value. Calling into the same method in which
    you are located is also called *recursion*. Because the `GetCustomerByName` method
    throws an exception that we actually want to utilize, we wrap the call to `GetCustomerByName`
    inside its own `try-catch` block, as shown in the next code sample.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在`try-catch`代码块的`try`部分，我们希望使用包含对注入的`CustomerRepository`和`BookingRepository`实例引用的类级私有属性：`_customerRepository`和`_bookingRepository`（在执行我们的单元测试期间，这保留了对`BookingRepository`模拟版本的引用，如第10.3.3节所述）。我们使用`_customerRepository`实例来调用其`GetCustomerByName`方法。`GetCustomerByName`方法检索适当的`Customer`实例或抛出`CustomerNotFoundException`，这让我们知道客户未找到。如果不存在，我们调用`CreateCustomer`方法并创建它。之后，我们再次调用`CreateBooking`方法，返回其返回值。调用位于你所在的方法也是称为*递归*。因为`GetCustomerByName`方法抛出了我们实际上想要利用的异常，所以我们将其调用包裹在其自己的`try-catch`块中，如下一个代码示例所示。
- en: DEFINITION Recursion happens when a method calls itself. When this happens,
    the CLR pauses the currently executing method to enter the new call of the method.
    Recursion often comes with a heavy performance and complexity penalty. Here it
    is used as a teaching device, but in production environments, it is often not
    the best (most performant) way to solve a particular problem.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 定义：当方法调用自身时发生递归。当这种情况发生时，CLR会暂停当前正在执行的方法以进入方法的新调用。递归通常伴随着沉重的性能和复杂性惩罚。在这里，它被用作教学工具，但在生产环境中，这通常不是解决特定问题的最佳（性能最佳）方式。
- en: Listing 10.6 Recursive call into `CreateBooking`
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.6 对`CreateBooking`的递归调用
- en: '[PRE16]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ Checks if the customer exists in the database and gets its details if so
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 检查客户是否存在于数据库中，如果存在则获取其详细信息
- en: ❷ The customer does not exist in the database.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 客户在数据库中不存在。
- en: ❸ Adds the customer to the database
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将客户添加到数据库中
- en: ❹ Recursively calls this method now that the customer is in the database
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 现在递归调用此方法，因为客户已在数据库中
- en: We can now use the `_bookingRepository` variable to call the `CreateBooking`
    method in the `BookingRepository`. Because the `BookingRepository.CreateBooking`
    method should execute asynchronously, we also `await` the call.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用`_bookingRepository`变量来调用`BookingRepository`中的`CreateBooking`方法。因为`BookingRepository.CreateBooking`方法应该异步执行，所以我们也在调用中`await`。
- en: When the `Task` is completed, because the `try-catch` code block caught no exceptions,
    and the code returns the `BookingRepository.CreateBooking` method, we return a
    set of tuples representing a `true` Boolean state for the `success` variable and
    a `null` reference for the `exception` variable. If the `try-catch` block caught
    an `Exception` during the execution of the `BookingRepository.CreateBooking` method,
    we would return a set of named tuples with the `success` variable set to a `false`
    state along with a reference to the caught `Exception` instead. By terminating
    all code paths inside the `try-catch` statement, we do not need the placeholder
    return of `(true, null)` anymore, as shown next.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 当`Task`完成时，因为`try-catch`代码块捕获了没有异常，并且代码返回了`BookingRepository.CreateBooking`方法，我们返回一组表示`success`变量为`true`布尔状态和`null`引用的元组。如果在`BookingRepository.CreateBooking`方法的执行过程中`try-catch`块捕获了`Exception`，我们将返回一组带有`success`变量设置为`false`状态以及捕获到的`Exception`引用的命名元组。通过在`try-catch`语句内部终止所有代码路径，我们不再需要如以下所示占位符返回`(true,
    null)`。
- en: Listing 10.7 The `BookingService.CreateBooking` method
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.7 `BookingService.CreateBooking`方法
- en: '[PRE17]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We only have the following things left to do before we can officially wrap
    up the `BookingService` class:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们正式完成`BookingService`类之前，我们只剩下以下几件事情要做：
- en: Add input validation for the `customerName` and `flightNumber` input arguments.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为`customerName`和`flightNumber`输入参数添加输入验证。
- en: Verify that the requested `Flight` exists in the database. If it does not, we
    need to gracefully exit out of the method.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证请求的 `Flight` 是否存在于数据库中。如果不存在，我们需要优雅地退出方法。
- en: Add unit tests for input validation, `Customer` verification and creation, and
    `Flight` verification.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为输入验证、`Customer` 验证和创建以及 `Flight` 验证添加单元测试。
- en: We’ll do these three things in the next chapter and finish implementing `BookingService`.
    In this chapter, we started implementing `BookingService`, learned about using
    mocks (with the Moq package), and refreshed our knowledge of the repository/service
    pattern.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章中做这三件事，并完成 `BookingService` 的实现。在本章中，我们开始实现 `BookingService`，学习了如何使用模拟（使用
    Moq 包），并更新了我们对仓储/服务模式的知识。
- en: Exercises
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Exercise 10.9
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 10.9
- en: True or false? When unit testing a multitiered architecture, we can replace
    the tier immediately below our testing concern with a mock or a stub.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 对或错？在单元测试多层架构时，我们可以将测试关注点立即下方的层替换为模拟或存根。
- en: Exercise 10.10
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 10.10
- en: Imagine you are unit testing a class in the controller layer of a repository/service
    architecture. Which of these approaches is the correct approach?
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在单元测试一个位于仓储/服务架构控制器层的类。以下哪种方法是正确的方法？
- en: a. Mock the controller layer, stub the service, and use the repository layer.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: a. 模拟控制器层，存根服务，并使用仓储层。
- en: b. Stub the controller layer, do not use the service layer, and mock the repository
    layer.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: b. 存根控制器层，不使用服务层，并模拟仓储层。
- en: c. Use the controller layer, mock the service layer, and do not use the repository
    layer.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: c. 使用控制器层，模拟服务层，不使用仓储层。
- en: Exercise 10.11
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 10.11
- en: True or false? By using a service layer to control access to the various repositories
    in a repository/service pattern, the coupling between a controller and a repository
    is decreased because the controller calls the repository indirectly through the
    service.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 对或错？通过使用服务层来控制对仓储/服务模式中各种仓储的访问，控制器和仓储之间的耦合度降低，因为控制器通过服务间接调用仓储。
- en: Exercise 10.12
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 10.12
- en: True or false? Mocks are used to provide alternative implementations to existing
    methods. To use a mock, you provide a new method body and write alternative logic
    for the methods you override.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 对或错？模拟用于提供现有方法的替代实现。要使用模拟，你需要提供一个新方法主体，并为覆盖的方法编写替代逻辑。
- en: Exercise 10.13
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 10.13
- en: True or false? The `InternalsVisibleTo` method attribute can be used to block
    other assemblies from viewing the internals of the assembly the attribute is applied
    in.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 对或错？`InternalsVisibleTo` 方法属性可以用来阻止其他程序集查看应用了该属性的程序集的内部结构。
- en: Exercise 10.14
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 10.14
- en: What preprocessor directive can you use to generate a compiler warning?
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用哪个预处理器指令来生成编译器警告？
- en: a. `#error`
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: a. `#error`
- en: b. `^&generate`
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: b. `^&generate`
- en: c. `#warning`
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: c. `#warning`
- en: d. `^&compiler::warning`
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: d. `^&compiler::warning`
- en: Exercise 10.15
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 10.15
- en: True or false? You can ask the CLR for the executing and calling assemblies’
    names at runtime by using reflection and methods inside the assembly namespace.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 对或错？你可以通过使用反射和程序集命名空间内的方法在运行时请求执行和调用程序集的名称。
- en: Exercise 10.16
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 10.16
- en: When a compiler inlines a method, what happens to the code that calls the method?
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器内联一个方法时，调用该方法代码会发生什么？
- en: a. Nothing—inlining means we immediately execute the called method. The code
    does not change.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: a. 没有内容——内联意味着我们立即执行被调用方法。代码不会改变。
- en: b. The compiler replaces the method call with the called method’s body
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: b. 编译器将方法调用替换为被调用方法的主体。
- en: c. The compiler replaces the method call with the contents of the method’s containing
    class.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: c. 编译器将方法调用替换为包含该方法的类的内容。
- en: Exercise 10.17
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 10.17
- en: If we add the attribute `[MethodImpl(MethodImplOptions.NoInlining)]` to a property,
    what happens?
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将属性 `[MethodImpl(MethodImplOptions.NoInlining)]` 添加到属性中，会发生什么？
- en: a. We get a compilation error because you cannot use the `MethodImpl` attribute
    on a property.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: a. 我们会得到编译错误，因为你不能在属性上使用 `MethodImpl` 属性。
- en: b. The property calls are inlined.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: b. 属性调用会被内联。
- en: c. The property calls are inlined only if there is a significant performance
    gain to be made.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: c. 只有在可以获得显著性能提升的情况下，才会内联属性调用。
- en: Summary
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'The repository/service pattern divides an application into three layers: a
    controller, service, and repository. This helps us control the flow of data and
    separate concerns.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仓储/服务模式将应用程序分为三个层：控制器、服务和仓储。这有助于我们控制数据流和分离关注点。
- en: In a repository/service world, the controller holds an instance of the service,
    and the service holds an instance of the repository. This is to ensure coupling
    is as loose as possible between the individual classes. If the controller were
    to hold an instance of both the service and repository, we would have very tight
    coupling to the repository.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在存储库/服务世界中，控制器持有服务的一个实例，服务持有存储库的一个实例。这是为了确保各个类之间的耦合尽可能松散。如果控制器要持有服务和存储库的实例，我们将对存储库有非常紧密的耦合。
- en: A view is a “window” into one or more models that are returned to a user. We
    use views to collect and present information to the user.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图是用户返回的一个或多个模型的“窗口”。我们使用视图来收集并向用户展示信息。
- en: When testing a solution that follows the repository/service pattern (or any
    other multilayered architecture), you need to test the logic only at the level
    you want to test. For example, if you are testing a controller class, you may
    mock or stub the service layer, but the test does not need to execute the actual
    logic in the service layer. Consequently, the repository layer is not called at
    all in this scenario. This helps us test only atomic operations, as opposed to
    entire stacks. If we want to test across layers, we need an integration test.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当测试遵循存储库/服务模式（或任何其他多层架构）的解决方案时，你只需要在想要测试的级别进行测试。例如，如果你正在测试控制器类，你可能需要模拟或存根服务层，但测试不需要执行服务层中的实际逻辑。因此，在这种情况下根本不会调用存储库层。这有助于我们只测试原子操作，而不是整个堆栈。如果我们想要跨层测试，我们需要一个集成测试。
- en: A mock is a class that returns a specific return when a method or property is
    called. It is used instead of the original class. This helps us focus on the layer
    we want to test.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟是一个在调用方法或属性时返回特定返回值的类。它被用来代替原始类。这有助于我们专注于想要测试的层。
- en: The `InternalsVisibleTo` method attribute is used to designate “friend” assemblies
    that can access internal methods, fields, and properties. This is helpful in unit
    testing, where usually the tests live in a separate assembly than the code we
    want to test.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InternalsVisibleTo`方法属性用于指定可以访问内部方法、字段和属性的“朋友”程序集。这在单元测试中很有帮助，因为通常测试代码位于我们想要测试的代码的单独程序集中。'
- en: Preprocessor directives can generate compiler warnings (`#warning`) and compiler
    errors (`#error`). We can also use preprocessor directives to control our data
    flow when access modifiers and encapsulation are not enough. Putting in a compiler
    warning lets developers know that there is a potential pitfall at a specific location.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预处理器指令可以生成编译器警告（`#warning`）和编译器错误（`#error`）。我们还可以使用预处理器指令来控制我们的数据流，当访问修饰符和封装不足时。添加编译器警告可以让开发者知道在特定位置存在潜在的风险。
- en: Compiler inlining means that a compiler replaces a method call with the body
    of the called method. This is useful for performance because it reduces cross-file
    calls.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器内联意味着编译器用一个被调用方法的主体替换方法调用。这对于性能很有用，因为它减少了跨文件调用。
- en: By using the method implementation (`MethodImpl`) method attribute, we can control
    the compiler’s inlining preferences. We can force the compiler not to inline a
    method by adding `[MethodImpl(MethodImplOptions.NoInlining``)]` as a method attribute.
    This is useful to retain stack traces when rethrowing exceptions.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用方法实现（`MethodImpl`）方法属性，我们可以控制编译器的内联偏好。我们可以通过添加`[MethodImpl(MethodImplOptions.NoInlining)]`作为方法属性来强制编译器不内联一个方法。这在重新抛出异常时保留堆栈跟踪非常有用。
