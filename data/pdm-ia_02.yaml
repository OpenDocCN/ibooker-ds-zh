- en: '1 Podman: A next-generation container engine'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1 Podman：下一代容器引擎
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: What Podman is
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Podman 是什么
- en: The advantages of using Podman over Docker
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Podman 而不是 Docker 的优势
- en: Examples of using Podman
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Podman 的使用示例
- en: Starting this book is difficult because so many people come to it with different
    expectations and experiences. You likely have some experience with containers,
    Docker, or Kubernetes—or at least are interested in learning more about Podman
    because you’ve heard about it. If you’ve used or evaluated Docker, you’ll find
    that Podman works the same as Docker in most cases, but it solves some problems
    inherent in Docker; most significantly, Podman offers enhanced security and the
    ability to run commands with non-root privileges. This means you can manage containers
    with Podman without root access or privileges. Because of Podman’s design, it
    can run with much better security than Docker by default.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 开始这本书是困难的，因为许多人带着不同的期望和经验来到这里。您可能对容器、Docker 或 Kubernetes 有一些经验，或者至少是因为您听说过 Podman
    而对学习 Podman 感兴趣。如果您使用过或评估过 Docker，您会发现 Podman 在大多数情况下与 Docker 的工作方式相同，但它解决了 Docker
    中固有的某些问题；最显著的是，Podman 提供了增强的安全性和使用非 root 权限运行命令的能力。这意味着您可以使用 Podman 来管理容器，而无需
    root 访问或权限。由于 Podman 的设计，它默认情况下可以比 Docker 运行得更加安全。
- en: In addition to being open source (and therefore free), Podman’s commands, run
    from the command-line interface (CLI), are quite similar to Docker’s. This book
    shows how you can use Podman as a local container engine to launch containers
    on a single node, either locally or through a remote REST API. You’ll also learn
    how to find, run, and build containers using Podman with open source tools such
    as Buildah and Skopeo.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 除了是开源的（因此是免费的）之外，Podman 的命令，从命令行界面（CLI）运行，与 Docker 的命令非常相似。这本书展示了您如何使用 Podman
    作为本地容器引擎在单个节点上启动容器，无论是本地还是通过远程 REST API。您还将学习如何使用 Podman 以及 Buildah 和 Skopeo 等开源工具来查找、运行和构建容器。
- en: 1.1 About all these terms
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1 关于所有这些术语
- en: 'Before you go further, I think it is important to define the terminology that
    will be used throughout this book. In the container world, terms like *container
    orchestrator*, *container engine*, and *container runtime* are often used interchangeably,
    which commonly leads to confusion. The following list is a summary of what each
    of these terms refers to in the context of this text:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在您继续之前，我认为定义本书中将使用的术语非常重要。在容器世界中，诸如 *容器编排器*、*容器引擎* 和 *容器运行时* 这样的术语经常被互换使用，这通常会导致混淆。以下列表是每个术语在本文中的含义的总结：
- en: '*Container orchestrators*—Software projects and products that orchestrate containers
    onto multiple different machines or nodes. These orchestrators communicate with
    container engines to run containers. The primary container orchestrator is Kubernetes,
    which was originally designed to talk to the Docker daemon container engine, but
    using Docker is becoming obsolete because Kubernetes primarily uses CRI-O or containerd
    as its container engine. CRI-O and containerd are purpose built for running orchestrated
    Kubernetes containers (CRI-O is covered in appendix A). Docker Swarm and Apache
    Mesos are other examples of container orchestrators.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*容器编排器*——将容器编排到多个不同机器或节点上的软件项目和产品。这些编排器与容器引擎通信以运行容器。主要的容器编排器是 Kubernetes，它最初是为了与
    Docker 守护进程容器引擎通信而设计的，但使用 Docker 正在变得过时，因为 Kubernetes 主要使用 CRI-O 或 containerd
    作为其容器引擎。CRI-O 和 containerd 是专门为运行编排的 Kubernetes 容器而构建的（CRI-O 在附录 A 中介绍）。Docker
    Swarm 和 Apache Mesos 是其他容器编排器的例子。'
- en: '*Container engines*—Primarily used for configuring containerized applications
    to run on a single local node. They can be launched directly by users, administrators,
    and developers. They can also be launched out of systemd unit files at boot as
    well as launched by container orchestrators like Kubernetes. As previously mentioned,
    CRI-O and containerd are container engines used by Kubernetes to manage containers
    locally. They really are not intended to be used directly by users. Docker and
    Podman are the primary container engines used by users to develop, manage, and
    run containerized applications on a single machine. Podman is seldom used to launch
    containers for Kubernetes; therefore, Kubernetes is not generally covered in this
    book. Buildah is another container engine, although it is only used for building
    container images.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*容器引擎*——主要用于配置容器化应用程序在单个本地节点上运行。它们可以直接由用户、管理员和开发者启动。它们也可以在启动时从 systemd 单元文件中启动，以及由容器编排器如
    Kubernetes 启动。如前所述，CRI-O 和 containerd 是 Kubernetes 用于本地管理容器的容器引擎。它们实际上并不打算直接由用户使用。Docker
    和 Podman 是用户用于在单个机器上开发、管理和运行容器化应用程序的主要容器引擎。Podman 很少用于启动 Kubernetes 的容器；因此，本书通常不涉及
    Kubernetes。Buildah 是另一个容器引擎，尽管它仅用于构建容器镜像。'
- en: '*Open Container Initiative (OCI) container runtimes*—Configure different parts
    of the Linux kernel and then, finally, launch the containerized application. The
    two most commonly used container runtimes are `runc` and `crun`. Kata and gVisor
    are other examples of container runtimes. See appendix B to understand the differences
    between the OCI container runtimes.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开放容器倡议（OCI）容器运行时*——配置 Linux 内核的不同部分，然后最终启动容器化应用程序。最常用的两个容器运行时是 `runc` 和 `crun`。Kata
    和 gVisor 是其他容器运行时的例子。请参阅附录 B 了解 OCI 容器运行时的区别。'
- en: Figure 1.1 shows into which categories these open source container projects
    fit.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 展示了这些开源容器项目属于哪些类别。
- en: '![](../../OEBPS/Images/01-01.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/01-01.png)'
- en: Figure 1.1 Different open source projects dealing with containers within the
    categories of orchestrators, engines, and runtimes.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 不同开源项目在编排器、引擎和运行时类别中处理容器。
- en: '*Podman* is short for *Pod Manager*. A *pod*, a concept popularized by the
    Kubernetes project, is one or more containers sharing the same namespaces and
    `cgroups` (resource constraints). Pods are covered in greater depth in chapter
    4\. Podman runs individual containers as well as pods. The Podman logo in figure
    1.2 is a group of Selkies, the Irish concept of a mermaid. Groups of Selkies are
    called pods.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*Podman* 是 *Pod Manager* 的简称。*Pod*，一个由 Kubernetes 项目普及的概念，是指一个或多个共享相同命名空间和
    `cgroups`（资源限制）的容器。Pods 在第 4 章中有更深入的介绍。Podman 可以运行单个容器以及 pods。图 1.2 中的 Podman
    标志是一群塞尔基（Selkies），这是爱尔兰关于美人鱼的概念。塞尔基群被称为 pods。'
- en: '![](../../OEBPS/Images/01-02.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/01-02.png)'
- en: Figure 1.2 Podman’s logo
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 Podman 的标志
- en: The Podman project describes Podman as “a daemonless container engine for developing,
    managing, and running OCI Containers on your Linux System. Containers can either
    be run as root or in rootless mode” ([https://podman.io](https://podman.io)).
    Podman is often summarized with the simple line *alias Docker = Podman* because
    Podman does almost everything that Docker can do with the same command line as
    Docker. But as you will learn in this book, Podman can do so much more. Understanding
    Docker is not critical to understanding Podman, but it is helpful.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 项目将 Podman 描述为“一个无守护进程的容器引擎，用于在您的 Linux 系统上开发、管理和运行 OCI 容器。容器可以以 root
    用户身份运行或在无 root 模式下运行” ([https://podman.io](https://podman.io))。Podman 常常被简单地概括为
    *alias Docker = Podman*，因为 Podman 几乎可以执行 Docker 可以用相同命令行完成的几乎所有操作。但正如您将在本书中学到的，Podman
    可以做更多的事情。理解 Docker 对于理解 Podman 不是必需的，但却是很有帮助的。
- en: Note The Open Container Initiative (OCI) is a standards body with the primary
    goal of creating open industry standards regarding container formats and runtimes.
    For more information, see [https://opencontainers.org](https://opencontainers.org).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：开放容器倡议（Open Container Initiative，OCI）是一个标准机构，其主要目标是创建关于容器格式和运行时的开放行业标准。更多信息，请参阅
    [https://opencontainers.org](https://opencontainers.org)。
- en: The Podman upstream project resides at github.com in the Containers project,
    ([https://github.com/containers/podman](https://github.com/containers/podman))
    shown in figure 1.3, along with other container libraries and container management
    tools like Buildah and Skopeo. (See appendix A for a description of some of these
    tools.)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Podman上游项目位于github.com的容器项目中，如图1.3所示，([https://github.com/containers/podman](https://github.com/containers/podman))，与其他容器库和容器管理工具如Buildah和Skopeo一起。
    (有关这些工具的描述，请参阅附录A。)
- en: '![](../../OEBPS/Images/01-03.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/01-03.png)'
- en: Figure 1.3 Containers is the developer site for Podman and other related container
    tools (see [https://github.com/containers](https://github.com/containers)).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 容器是Podman和其他相关容器工具的开发者网站（见[https://github.com/containers](https://github.com/containers)）。
- en: Podman runs images with the newer OCI format, described in section 1.1.2, as
    well as the legacy Docker (v2 and v1) format images. Podman runs any image available
    at container registries, like docker.io and quay.io, as well as the hundreds of
    other container registries. Podman pulls these images to a Linux host and launches
    them in the same way as Docker and Kubernetes. Podman supports all OCI runtimes,
    including `runc`, `crun`, `kata`, and `gvisord` (appendix B), just like Docker.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Podman使用新的OCI格式运行镜像，如第1.1.2节所述，以及传统的Docker（v2和v1）格式镜像。Podman可以在容器注册库中运行任何可用的镜像，如docker.io和quay.io，以及数百个其他容器注册库。Podman将这些镜像拉取到Linux主机上，并以与Docker和Kubernetes相同的方式启动它们。Podman支持所有OCI运行时，包括`runc`、`crun`、`kata`和`gvisord`（附录B），就像Docker一样。
- en: This book is intended to aid Linux administrators in understanding the advantages
    of using Podman as their primary container engine. You will learn how to configure
    your systems as securely as possible but still allow your users to work with containers.
    One of Podman’s primary use cases is running containerized applications on single-node
    environments, such as edge devices. Podman and systemd allow you to manage the
    entire life cycle of the application on nodes without human intervention. Podman’s
    goal is running containers naturally on a Linux box, taking advantage of all the
    features of the Linux platform.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 本书旨在帮助Linux管理员了解使用Podman作为其主要容器引擎的优势。您将学习如何以尽可能安全的方式配置您的系统，同时仍然允许您的用户与容器一起工作。Podman的主要用例之一是在单节点环境中运行容器化应用程序，例如边缘设备。Podman和systemd允许您在不进行人工干预的情况下管理节点上应用程序的整个生命周期。Podman的目标是在Linux盒子上自然运行容器，利用Linux平台的所有功能。
- en: Note Podman is available for many different Linux distributions and on Mac and
    Windows platforms. Please refer to appendix C to see how to get Podman on your
    platform.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Podman适用于许多不同的Linux发行版，以及Mac和Windows平台。请参阅附录C了解如何在您的平台上获取Podman。
- en: Application developers are also an intended audience for this book. Podman is
    a great tool for developers looking to containerize their applications in a secure
    manner. Podman allows developers to create Linux containers on all Linux distributions.
    In addition, Podman is available on the Mac and Windows platforms, where it can
    communicate with the Podman service running within a VM or on a Linux box available
    on the network. *Podman in Action* shows you how to work with containers, build
    container images, and then convert their containerized applications into either
    single-node services to run on edge devices or into Kubernetes-based microservices.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序开发人员也是本书的目标读者。Podman是开发者寻求以安全方式容器化其应用程序的绝佳工具。Podman允许开发者在所有Linux发行版上创建Linux容器。此外，Podman还可在Mac和Windows平台上使用，它可以在VM内或网络上可用的Linux盒子上与运行的Podman服务进行通信。“Podman
    in Action”向您展示如何与容器一起工作，构建容器镜像，然后将它们的容器化应用程序转换为在边缘设备上运行的单一节点服务或基于Kubernetes的微服务。
- en: Podman and the container tools are open source projects with contributors from
    many different companies, universities, and organizations. Contributors come from
    all over the world. The projects are always looking to add new contributors to
    improve them; please refer to appendix D to see how you can join the effort. In
    this chapter, I first provide a brief overview of containers, and then I explain
    some key features that make Podman a great tool for working with containers.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Podman和容器工具是开源项目，来自许多不同的公司、大学和组织。贡献者来自世界各地。项目始终在寻找新的贡献者以改进它们；请参阅附录D了解您如何加入这一努力。在本章中，我首先简要概述容器，然后解释一些使Podman成为处理容器优秀工具的关键特性。
- en: 1.2 A brief overview of containers
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2 容器简要概述
- en: '*Containers* are groups of processes running on a Linux system that are isolated
    from each other. Containers make sure one group of processes does not interfere
    with other processes on the system. Rogue processes can’t dominate system resources,
    which might prevent other processes from performing their task. Hostile containers
    are also prevented from attacking other containers, stealing data, or causing
    denial of service attacks. A final goal of containers is allowing applications
    to be installed with their own versions of shared libraries that do not conflict
    with applications requiring different versions of the same libraries. Instead
    they allow applications to live in a virtualized environment, giving the impression
    that they own the entire system.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*容器*是运行在Linux系统上的进程组，彼此之间是隔离的。容器确保一个进程组不会干扰系统上的其他进程。恶意进程无法控制系统资源，这可能会阻止其他进程执行其任务。容器的最终目标之一是允许应用程序安装具有自己版本的共享库，这些库不会与需要不同版本相同库的应用程序冲突。相反，它们允许应用程序生活在虚拟化环境中，给人一种它们拥有整个系统的印象。'
- en: 'Containers are isolated via the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 容器通过以下方式隔离：
- en: '*Resource constraints (cgroups**)*—The cgroup man page ([https://man7.org/linux/man-pages/man7/cgroups.7.xhtml](https://man7.org/linux/man-pages/man7/cgroups.7.xhtml))
    defines cgroups as the following: “Control groups, usually referred to as cgroups,
    are a Linux kernel feature which allow processes to be organized into hierarchical
    groups whose usage of various types of resources can then be limited and monitored.”'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*资源约束（cgroups**）*—cgroup手册页([https://man7.org/linux/man-pages/man7/cgroups.7.xhtml](https://man7.org/linux/man-pages/man7/cgroups.7.xhtml))将cgroups定义为以下内容：“控制组，通常称为cgroups，是Linux内核的一个特性，它允许将进程组织成层次结构分组，然后可以限制和监控这些分组对各种类型资源的使用。”'
- en: 'Examples of resources controlled by cgroups include the following:'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: cgroups控制的资源示例包括以下内容：
- en: The amount of memory a group of processes can use
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组进程可以使用的内存量
- en: The amount of CPU processes can use
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程可以使用的CPU量
- en: The amount of network resources a process can use
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程可以使用的网络资源量
- en: The basic idea of cgroups is preventing one group of processes from dominating
    certain system resources in such a way that another group of processes can’t make
    progress on the system.
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: cgroups的基本思想是防止一个进程组以某种方式控制某些系统资源，以至于另一个进程组无法在系统上取得进展。
- en: '*Security constraints*—Containers are isolated from each other using many security
    tools available in the kernel. The goal is blocking privilege escalation and preventing
    a rogue group of processes from committing hostile acts against the system, including
    the following examples:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*安全约束*—容器使用内核中可用的许多安全工具彼此隔离。目标是阻止权限提升，防止恶意进程组对系统进行敌对行为，以下是一些示例：'
- en: Dropped Linux capabilities limit the power of root.
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 丢弃Linux能力限制了root的权限。
- en: SELinux controls access to the filesystem.
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: SELinux控制对文件系统的访问。
- en: There is read-only access to kernel filesystems.
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对内核文件系统只有只读访问。
- en: Seccomp limits the system calls available in the kernel.
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Seccomp限制了内核中可用的系统调用。
- en: A user namespace to map one group of UIDs in the host to another allows access
    to limited root environments.
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户命名空间将主机中的一组UID映射到另一组，允许访问有限的root环境。
- en: Table 1.1 gives further information and provides links with more detail about
    some of these security features.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 表1.1提供了更多信息和有关这些安全特性的更多详细信息的链接。
- en: Table 1.1 Advanced Linux security features
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 表1.1 高级Linux安全特性
- en: '| Component | Description | Reference |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 组件 | 描述 | 参考 |'
- en: '| Linux capabilities | Linux capabilities subdivide the power of root into
    distinct capabilities. | The capabilities man page is a good overview of the available
    capabilities ([https://bit.ly/3A3Ppeg](https://bit.ly/3A3Ppeg)). |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| Linux能力 | Linux能力将root权限细分为不同的能力。 | 能力手册页是一个关于可用能力的良好概述([https://bit.ly/3A3Ppeg](https://bit.ly/3A3Ppeg))。
    |'
- en: '| SELinux | Security-Enhanced Linux (SELinux) is a Linux kernel mechanism that
    labels every process and every filesystem object on the system. A SELinux policy
    defines the rules on how labeled processes interact with label objects. The Linux
    kernel enforces the rules. | I wrote the *SELinux Coloring Book*, which is a fun
    way to help you understand SELinux ([https://bit.ly/33plEbD](https://bit.ly/33plEbD)).
    If you really want to study the subject, check out the SELinux notebook ([https://bit.ly/3GxGhkm](https://bit.ly/3GxGhkm)).
    |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| SELinux | 安全增强型 Linux (SELinux) 是一种 Linux 内核机制，它为系统上的每个进程和每个文件系统对象打上标签。SELinux
    策略定义了标记进程如何与标签对象交互的规则。Linux 内核强制执行这些规则。| 我编写了 *SELinux 彩色图书*，这是一种有趣的方式来帮助您理解 SELinux
    ([https://bit.ly/33plEbD](https://bit.ly/33plEbD))。如果您真的想研究这个主题，请查看 SELinux 笔记本
    ([https://bit.ly/3GxGhkm](https://bit.ly/3GxGhkm))。|'
- en: '| Seccomp | seccomp is a Linux kernel mechanism that limits the number of syscalls
    to a group of processes on the system. You can remove potentially dangerous syscalls
    from being called by the processes. | The seccomp man page is a good source of
    additional information on seccomp ([https://bit.ly/3rnnim1](https://bit.ly/3rnnim1)).
    |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| Seccomp | seccomp 是 Linux 内核的一种机制，它限制了系统上进程组可以调用的系统调用数量。您可以移除可能危险的系统调用，防止进程调用它们。|
    Seccomp 的 man 页面是获取关于 seccomp 的额外信息的良好来源 ([https://bit.ly/3rnnim1](https://bit.ly/3rnnim1))。|'
- en: '| User namespace | The user namespace allows you to have Linux capabilities
    within the group of UIDs and GIDs assigned to the namespace, without having root
    capabilities on the host. | The user namespace is fully explained in chapter 3.
    |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 用户命名空间 | 用户命名空间允许您在命名空间分配的 UIDs 和 GIDs 组内拥有 Linux 能力，而无需在主机上具有 root 能力。|
    用户命名空间在第三章中得到了全面解释。|'
- en: '*Virtualization technologies (namespaces**)*—The Linux kernel employs a concept
    called *namespaces*, which creates virtualized environments, where one set of
    processes sees one set of resources, while another set of processes sees a different
    set of resources. These virtualized environments eliminate processes’ views into
    the rest of the system, giving them the feel of a virtual machine (VM) without
    the overhead. Examples of namespaces include the following:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*虚拟化技术（命名空间**）*—Linux 内核采用了一种称为 *命名空间* 的概念，它创建了虚拟化环境，其中一组进程看到一组资源，而另一组进程看到不同的资源集。这些虚拟化环境消除了进程对系统其他部分的视图，使它们感觉像虚拟机（VM）而没有开销。命名空间的例子包括以下内容：'
- en: '*Network namespace*—Eliminates the access to the host network but gives access
    to virtual network devices'
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*网络命名空间*—消除对主机网络的访问，但允许访问虚拟网络设备'
- en: '*Mount namespace*—Eliminates the view of all the filesystem, except the containers
    filesystem'
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*挂载命名空间*—消除对除容器文件系统之外的所有文件系统的视图'
- en: '*PID namespace*—Eliminates the view of other processes on the system; container
    processes only see the processes within the container'
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PID 命名空间*—消除对系统上其他进程的视图；容器进程只能看到容器内的进程'
- en: These container technologies have existed in the Linux kernel for many years.
    Security tools for isolating processes started in Unix back in the 1970s, and
    SELinux started in 2001\. Namespaces were introduced around 2004, and cgroups
    were introduced around 2006.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这些容器技术在 Linux 内核中已经存在了许多年。用于隔离进程的安全工具始于 Unix 时代的 1970 年代，而 SELinux 则始于 2001
    年。命名空间大约在 2004 年引入，cgroups 大约在 2006 年引入。
- en: Note Windows container images exist, but this book concentrates on Linux-based
    containers. Even when running Podman on Windows, you are still working with Linux
    containers. Podman on Mac is covered in appendix E. Podman on Windows is covered
    in appendix F.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 Windows 容器镜像确实存在，但本书专注于基于 Linux 的容器。即使运行 Windows 上的 Podman，您仍在处理 Linux 容器。Podman
    在 Mac 上的内容包含在附录 E 中。Podman 在 Windows 上的内容包含在附录 F 中。
- en: '1.2.1 Container images: A new way to ship software'
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.1 容器镜像：一种新的软件分发方式
- en: Containers really didn’t take off until the Docker project introduced the concept
    of the container image and container registry. Basically, they created a new way
    to ship software.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 容器技术直到 Docker 项目引入了容器镜像和容器注册的概念才真正兴起。基本上，它们创造了一种新的软件分发方式。
- en: Traditionally, installing multiple software applications on a Linux system has
    led to a problem of dependency management. Before containers, you packaged software
    using package managers like RPM and Debian packages. These packages are installed
    on a host and share the content on the host, including shared libraries. When
    developers test their code, everything might work fine when run on the host machine.
    The quality engineering team then might test the software on a different machine
    with different packages and see failures. Both teams would need to work together
    to generate the proper requirements. Finally, the software is shipped to customers,
    who have many different configurations and software installed, leading to further
    breakage of the application.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，在Linux系统上安装多个软件应用程序导致了依赖管理问题。在容器出现之前，开发者使用RPM和Debian包管理等包管理器打包软件。这些包安装在主机上，并在主机上共享内容，包括共享库。当开发者测试他们的代码时，在主机机器上运行可能一切正常。然后，质量工程团队可能在具有不同包的不同机器上测试软件，并看到失败。两个团队都需要共同努力来生成正确的要求。最后，软件被发送给客户，他们有许多不同的配置和安装的软件，导致应用程序进一步损坏。
- en: Container images solve the dependency management problem by bundling all the
    software needed to run your application together into a unit. You ship all the
    libraries, executables, and configuration files together. The software is isolated
    from the host via container technology. Usually the only part of the host system
    that your application interacts with is the host kernel.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像通过将运行应用程序所需的所有软件捆绑成一个单元来解决依赖管理问题。你将所有库、可执行文件和配置文件一起发送。软件通过容器技术从主机隔离。通常，应用程序与主机系统交互的唯一部分是主机内核。
- en: The developer, quality engineers, and customer all run the exact same containerized
    environment along with the application. This helps guarantee consistency and limits
    the number of bugs caused by misconfiguration.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者、质量工程师和客户都运行与应用程序相同的精确容器化环境。这有助于保证一致性，并限制由配置错误引起的错误数量。
- en: Containers are often compared to VMs in that they both can run multiple isolated
    applications on a single node. When using VMs, you need to manage the entire VM
    operating system as well as the isolated application. You need to manage the life
    cycle of the different kernel, init system, logging, security updates, backups,
    and so on. The system also has to deal with the overhead of the entire running
    operation system, not just the application. In the container world, all you run
    is the containerized application—there is no overhead and no additional OS management.
    Figure 1.4 shows three applications running in three different VMs.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 容器通常与虚拟机（VMs）相提并论，因为它们都可以在单个节点上运行多个隔离的应用程序。当使用虚拟机时，你需要管理整个虚拟机操作系统以及隔离的应用程序。你需要管理不同内核、init系统、日志、安全更新、备份等不同组件的生命周期。系统还必须处理整个运行操作系统的开销，而不仅仅是应用程序。在容器世界中，你运行的是容器化的应用程序——没有开销，也没有额外的操作系统管理。图1.4展示了在三个不同的虚拟机上运行三个应用程序。
- en: '![](../../OEBPS/Images/01-04.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/01-04.png)'
- en: Figure 1.4 Physical machine running three applications in three VMs
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 物理机在三个虚拟机上运行三个应用程序
- en: With VMs you end up needing to manage four operations systems, whereas with
    containers the three applications run with just their required user spaces. You
    end up managing just one operating system, as shown in figure 1.5.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用虚拟机，你最终需要管理四个操作系统，而使用容器，三个应用程序只需运行它们所需的用户空间。如图1.5所示，你最终只需管理一个操作系统。
- en: '![](../../OEBPS/Images/01-05.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/01-05.png)'
- en: Figure 1.5 Physical machine running three applications in three containerized
    applications
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5 物理机在三个容器化应用程序中运行三个应用程序
- en: 1.2.2 Container images lead to microservices
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.2 容器镜像导致微服务
- en: Packing applications inside of container images allows the installation of multiple
    applications with conflicting requirements on the same host. For example, one
    application might require a different version of the C library than another, which
    prevents them from being installed at the same time. Figure 1.6 shows a traditional
    application running within an operating system without use of containers.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序打包到容器镜像中允许在同一主机上安装具有冲突要求的多应用程序。例如，一个应用程序可能需要与另一个应用程序不同的C库版本，这阻止了它们同时安装。图1.6展示了在没有使用容器的情况下，在操作系统中运行的传统应用程序。
- en: '![](../../OEBPS/Images/01-06.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/01-06.png)'
- en: Figure 1.6 Traditional LAMP stack (Linux, Apache, MariaDB, and PHP/PERL application)
    running on a server
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.6 传统 LAMP 栈（Linux、Apache、MariaDB 和 PHP/PERL 应用程序）在服务器上运行
- en: Containers can have the correct C library within their container image, with
    each image potentially having different versions of the library specific to the
    container’s application. You can run applications from totally different distributions.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 容器可以在其镜像中包含正确的 C 库，每个镜像可能具有针对容器应用程序的不同版本的库。您可以从完全不同的发行版中运行应用程序。
- en: Containers make it easy to run multiple instances of the same application, as
    shown in figure 1.7\. Container images encourage the packaging of a single service
    or application into a single container. Containers allow you to easily wire multiple
    applications together via the network.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 容器使得运行同一应用程序的多个实例变得容易，如图 1.7 所示。容器镜像鼓励将单个服务或应用程序打包到单个容器中。容器允许您通过网络轻松地将多个应用程序连接在一起。
- en: '![](../../OEBPS/Images/01-07.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/01-07.png)'
- en: Figure 1.7 LAMP stack packaged individually into microservice containers. As
    containers communicate via the network, they can be easily moved to other VMs,
    making reuse much easier.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.7 将 LAMP 栈（Linux、Apache、MariaDB 和 PHP/PERL 应用程序）分别打包到微服务容器中。由于容器通过网络进行通信，它们可以轻松地移动到其他虚拟机中，使得重用变得更加容易。
- en: Instead of designing monolithic applications in which you have a web frontend,
    a load balancer, and a database, you can build three different container images
    and then wire them together to build microservices. Microservices allow you and
    other users to experiment with running multiple databases and web frontends, then
    orchestrate them together. Containerized microservices make the sharing and reuse
    of software possible.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以不设计单体应用程序，其中包含一个网络前端、负载均衡器和数据库，而是构建三个不同的容器镜像，然后将它们连接起来以构建微服务。微服务允许您和其他用户尝试运行多个数据库和网络前端，然后一起编排它们。容器化的微服务使得软件的共享和重用成为可能。
- en: 1.2.3 Container image format
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.3 容器镜像格式
- en: 'A container image consists of three components:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像由三个组件组成：
- en: A directory tree containing all the software required to run your application
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含运行您应用程序所需所有软件的目录树
- en: A JSON file that describes the contents of the rootfs
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述根文件系统内容的 JSON 文件
- en: Another JSON file called a manifest list that links multiple images together
    to support different architectures
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个名为清单列表的 JSON 文件，它将多个镜像链接在一起以支持不同的架构
- en: The directory tree is called a *rootfs* (root filesystem). The software is laid
    out like it was the root (/) of a Linux system.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 目录树被称为 *rootfs*（根文件系统）。软件布局就像它是 Linux 系统的根 (/) 一样。
- en: 'The executable to be run within the rootfs, the working directory, the environment
    variables to be used, the maintainer of the executable, and other labels to help
    identify the content of the image are defined in the first JSON file. You can
    see this JSON file using the `podman` `inspect` command:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在根文件系统中运行的可执行文件、工作目录、要使用的环境变量、可执行文件的维护者以及其他帮助识别镜像内容的标签定义在第一个 JSON 文件中。您可以使用
    `podman` 的 `inspect` 命令查看此 JSON 文件：
- en: '[PRE0]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Date the image was created
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 镜像创建的日期
- en: ❷ Architecture for this image
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 此镜像的架构
- en: ❸ Operating system for this image
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 此镜像的操作系统
- en: ❹ Environment variables that the developer of the image wants to be set within
    the container
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 图像开发者希望在容器内设置的环境变量
- en: ❺ Default command to be executed when the container starts
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 容器启动时默认要执行的命令
- en: ❻ Labels to help describe the contents of the image. These fields can be free-form
    and do not affect the way images are run but can be used to search for and describe
    the image.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 帮助描述镜像内容的标签。这些字段可以是自由形式的，不会影响镜像的运行方式，但可以用于搜索和描述镜像。
- en: 'The second JSON file, the manifest list, allows users on an arm64 machine to
    pull an image with the same name as they would if they were on an arm64 machine.
    Podman pulls the image based on the default architecture of the machine, using
    this manifest list. Skopeo is a tool that uses the same underlying libraries as
    Podman and is available at [github.com/containers/skopeo](http://github.com/containers/skopeo)
    (see appendix A). Skopeo provides lower-level output examining the structures
    of a container image. In the following example, use the `skopeo` command with
    the `--raw` option to examine the registry.access.redhat.com/ ubi8 image manifest
    specification:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个 JSON 文件，即清单列表，允许 arm64 机器上的用户拉取与他们在 arm64 机器上相同的名称的镜像。Podman 根据机器的默认架构使用此清单列表来拉取镜像。Skopeo
    是一个使用与 Podman 相同的底层库的工具，可在 [github.com/containers/skopeo](http://github.com/containers/skopeo)
    上找到（见附录 A）。Skopeo 提供了检查容器镜像结构的底层输出。在以下示例中，使用带有 `--raw` 选项的 `skopeo` 命令来检查 registry.access.redhat.com/
    ubi8 镜像清单规范：
- en: '[PRE1]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Digest of the exact image pulled when the architecture and OS match
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 当架构和操作系统匹配时，提取的确切镜像摘要
- en: ❷ mediaType describes the type of the image, OCI, Docker, and so on.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ mediaType 描述了镜像的类型，如 OCI、Docker 等。
- en: '❸ The architecture of this image digest: amd64'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 此镜像摘要的架构：amd64
- en: '❹ The OS of this image digest: Linux'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 此镜像摘要的操作系统：Linux
- en: '❺ This stanza points to a different image for a different architecture: arm64.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 此节指向不同架构的另一个镜像：arm64。
- en: Images use the Linux tar utility to pack the rootfs and the JSON files together.
    These images are then stored on web servers called container registries (e.g.,
    docker.io, quay.io, and Artifactory). Container engines like Podman can copy these
    images to a host and unpack them onto the filesystem. Then the engine merges the
    image’s JSON file, the engine’s built-in defaults, and the user’s input to create
    a new container OCI runtime specification JSON file. The JSON file describes how
    to run the containerized application.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图片使用 Linux tar 工具将 rootfs 和 JSON 文件打包在一起。这些镜像随后存储在称为容器注册库的 Web 服务器上（例如，docker.io,
    quay.io 和 Artifactory）。Podman 等容器引擎可以将这些镜像复制到主机上，并在文件系统上解包。然后，引擎将镜像的 JSON 文件、引擎的内置默认值和用户的输入合并，以创建一个新的容器
    OCI 运行时规范 JSON 文件。该 JSON 文件描述了如何运行容器化应用程序。
- en: In the last step, the container engine launches a small program called a container
    runtime (e.g., `runc`, `crun`, `kata`, or `givisord`). The container runtime reads
    the container’s JSON and instruments, kernel cgroups, security constraints, and
    namespaces before finally launching the primary process of the container.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一步，容器引擎启动一个名为容器运行时的程序（例如，`runc`、`crun`、`kata` 或 `givisord`）。容器运行时在最终启动容器的首要进程之前，读取容器的
    JSON 文件，并配置内核 cgroups、安全约束和命名空间。
- en: 1.2.4 Container standards
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.4 容器标准
- en: The OCI standards body defined the standard formats for storing and defining
    container images. They also defined the standard for container engines running
    containers. The OCI created the OCI Image Format, which standardizes the format
    of the container images and the images’ JSON file. They also created the OCI Runtime
    Specification, which standardized the container’s JSON file to be used by OCI
    runtimes. The OCI standards allow other container engines, like Podman,[¹](#pgfId-1031801)
    to follow the standards and be able to work with all the images stored at container
    registries and to run them in the exact same way as all other container engines,
    including Docker (see figure 1.7).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: OCI 标准机构定义了存储和定义容器镜像的标准格式。他们还定义了运行容器的容器引擎的标准。OCI 创建了 OCI 镜像格式，该格式标准化了容器镜像和镜像
    JSON 文件的格式。他们还创建了 OCI 运行时规范，该规范标准化了用于 OCI 运行时的容器 JSON 文件。OCI 标准允许其他容器引擎，如 Podman[¹](#pgfId-1031801)，遵循标准，能够与容器注册库中存储的所有镜像一起工作，并以与其他容器引擎（包括
    Docker）完全相同的方式运行它们（见图 1.7）。
- en: 1.3 Why use Podman when you have Docker?
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3 为什么在有 Docker 的情况下还要使用 Podman？
- en: I often get asked the question, “Why do you need Podman when you already have
    Docker?” Well one reason is that *open source is all about choice*. Operating
    systems have more than one editor, more than one shell, more than one filesystem,
    and more than one internet web browser. I believe that Podman’s design is fundamentally
    better than Docker’s and offers features that advance the security and use of
    containers.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常被问到这样的问题，“为什么你已经有了 Docker，还需要 Podman？”好吧，一个原因就是 *开源就是关于选择*。操作系统有不止一个编辑器，不止一个
    shell，不止一个文件系统，还有不止一个互联网网页浏览器。我相信 Podman 的设计在本质上优于 Docker，并提供了提高容器安全和使用的功能。
- en: 1.3.1 Why have only one way to run containers?
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.1 为什么只有一种运行容器的方式？
- en: One of Podman’s advantages was that it was created long after Docker existed.
    Podman developers looked at ways to improve on Docker’s design from a totally
    different perspective. Because Docker was written as open source, Podman shares
    some of the code and takes advantage of new standards, like the Open Container
    Initiative. Podman works with the open source community to concentrate on developing
    new features.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Podman的一个优点是它是在Docker存在之后创建的。Podman的开发者从完全不同的角度审视了改进Docker设计的方法。因为Docker是以开源的形式编写的，Podman共享了一些代码并利用了新的标准，如开放容器倡议。Podman与开源社区合作，专注于开发新功能。
- en: In the rest of this section, I cover some of these improvements. Table 1.2 describes
    and compares features available in Podman and Docker.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的其余部分，我将介绍一些这些改进。表1.2描述并比较了Podman和Docker中可用的功能。
- en: Table 1.2 Podman and Docker feature comparison
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 表1.2 Podman和Docker功能比较
- en: '| Feature | Podman | Docker | Description |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| 功能 | Podman | Docker | 描述 |'
- en: '| Supports all OCI and Docker images | ✔ | ✔ | Pulls and runs container images
    from container registries (i.e., quay.io and docker.io). See chapter 2. |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 支持所有OCI和Docker镜像 | ✔ | ✔ | 从容器注册库（即，quay.io和docker.io）拉取和运行容器镜像。请参阅第2章。|'
- en: '| Launches OCI container engines | ✔ | ✔ | Launches `runc`, `crun`, Kata, gVisor,
    and OCI container engines. See appendix B. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| 启动OCI容器引擎 | ✔ | ✔ | 启动`runc`、`crun`、Kata、gVisor和OCI容器引擎。请参阅附录B。|'
- en: '| Simple command-line interface | ✔ | ✔ | Podman and Docker share the same
    CLI. See chapter 2. |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| 简单的命令行界面 | ✔ | ✔ | Podman和Docker共享相同的CLI。请参阅第2章。|'
- en: '| Integration with systemd | ✔ | ✘ | Podman supports running systemd inside
    the container as well as many systemd features. See chapter 7. |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 与systemd集成 | ✔ | ✘ | Podman支持在容器内运行systemd以及许多systemd功能。请参阅第7章。|'
- en: '| Fork/exec model | ✔ | ✘ | The container is a child of the command. |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| Fork/exec模型 | ✔ | ✘ | 容器是命令的子进程。|'
- en: '| Fully supports user namespace | ✔ | ✘ | Only Podman supports running containers
    in separate user namespaces. See chapter 6. |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 完全支持用户命名空间 | ✔ | ✘ | 只有Podman支持在单独的用户命名空间中运行容器。请参阅第6章。|'
- en: '| Client-server model | ✔ | ✔ | Docker is a REST API daemon. Podman supports
    REST APIs via a systemd socket-activated service. See chapter 9. |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 客户端-服务器模型 | ✔ | ✔ | Docker是一个REST API守护进程。Podman通过systemd套接字激活服务支持REST API。请参阅第9章。|'
- en: '| Supports `docker-compose` | ✔ | ✔ | Compose scripts work against both REST
    APIs. Podman works in rootless mode. See chapter 9. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 支持`docker-compose` | ✔ | ✔ | Compose脚本针对REST API工作。Podman以rootless模式运行。请参阅第9章。|'
- en: '| Supports docker-py | ✔ | ✔ | Docker-py Python bindings work against both
    REST APIs. Podman works in rootless mode. Podman also supports podman-py for running
    advanced features. See chapter 9. |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 支持docker-py | ✔ | ✔ | Docker-py Python绑定针对REST API工作。Podman以rootless模式运行。Podman还支持podman-py以运行高级功能。请参阅第9章。|'
- en: '| Daemonless | ✔ | ✘ | The Podman command runs like a traditional command-line
    tool, while Docker requires multiple root-running daemons. |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 无守护进程模式 | ✔ | ✘ | Podman命令的运行方式类似于传统的命令行工具，而Docker需要多个在root模式下运行的守护进程。|'
- en: '| Supports Kubernetes-like pods | ✔ | ✘ | Podman supports running multiple
    containers within the same pod. See chapter 4. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 支持类似Kubernetes的Pod | ✔ | ✘ | Podman支持在同一个Pod中运行多个容器。请参阅第4章。|'
- en: '| Supports Kubernetes YAML | ✔ | ✘ | Podman can launch containers and pods
    based on Kubernetes YAML. It can also generate Kubernetes YAML from running containers.
    See chapter 8. |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 支持Kubernetes YAML | ✔ | ✘ | Podman可以根据Kubernetes YAML启动容器和Pod。它还可以从运行中的容器生成Kubernetes
    YAML。请参阅第8章。|'
- en: '| Supports Docker Swarm | ✘ | ✔ | Podman believes the future for orchestrated
    multinode containers is Kubernetes and does not plan on implementing Swarm. |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 支持Docker Swarm | ✘ | ✔ | Podman认为容器编排的多节点容器的未来是Kubernetes，并且不打算实现Swarm。|'
- en: '| Customizable registries | ✔ | ✘ | Podman allows you to configure registries
    for short-name expansion. Docker is hardcoded to docker.io when you specify a
    short name. See chapter 5. |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 可定制的注册库 | ✔ | ✘ | Podman允许您配置用于短名展开的注册库。当您指定短名时，Docker被硬编码为docker.io。请参阅第5章。|'
- en: '| Customizable defaults | ✔ | ✘ | Podman supports fully customizing all of
    its defaults, including security, namespaces, and volumes. See chapter 5. |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 可定制的默认设置 | ✔ | ✘ | Podman支持完全自定义其所有默认设置，包括安全、命名空间和卷。请参阅第5章。|'
- en: '| macOS support | ✔ | ✔ | Podman and Docker support running containers on a
    Mac via a VM running Linux. See appendix E. |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| macOS支持 | ✔ | ✔ | Podman和Docker支持通过运行Linux的VM在Mac上运行容器。请参阅附录E。|'
- en: '| Windows support | ✔ | ✔ | Podman and Docker support running containers on
    a Windows WSL 2 or a VM running Linux. See appendix F. |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| Windows支持 | ✔ | ✔ | Podman和Docker支持在Windows WSL 2或运行Linux的虚拟机上运行容器。请参阅附录F。|'
- en: '| Linux support | ✔ | ✔ | Podman and Docker are supported on all major Linux
    distributions. See appendix C. |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| Linux支持 | ✔ | ✔ | Podman和Docker支持所有主要的Linux发行版。请参阅附录C。|'
- en: '| Containers aren’t stopped on software upgrade. | ✔ | ✘ | Podman is not required
    to remain running when containers are running. Since the Docker daemon is monitoring
    containers, by default, when it stops, all containers stop. |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 软件升级时容器不会停止。 | ✔ | ✘ | Podman不需要在容器运行时保持运行。由于Docker守护进程正在监控容器，默认情况下，当它停止时，所有容器都会停止。|'
- en: 1.3.2 Rootless containers
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.2 Rootless容器
- en: Probably the most significant feature of Podman is its ability to run in rootless
    mode. In many situations, you do not want to give full root access to your users,
    but users and developers still need to run containers and build container images.
    Requiring root access prevents lots of security-conscious companies from widespread
    adoption of Docker. Podman, on the other hand, can run containers with no additional
    security features in Linux other than a standard login account.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Podman最显著的功能可能是其能够在rootless模式下运行。在许多情况下，你不想给你的用户完全的root访问权限，但用户和开发者仍然需要运行容器和构建容器镜像。需要root访问权限阻止了许多注重安全的公司广泛采用Docker。另一方面，Podman可以在Linux上运行容器，无需额外的安全功能，只需一个标准的登录账户。
- en: 'You can run the Docker client as a normal user by adding the user to the Docker
    user group (/etc/group), but I believe granting this access is one of the most
    dangerous things you can do on a Linux machine. Access to the docker.sock allows
    you to gain full root access on the host by running the following command. In
    the command, you are mounting the entire host operating system / on the /host
    directory within the container. The `--privileged` flag turns off all container
    security, and then you `chroot` to /host. After the `chroot`, you are in a root
    shell at / of the operating system, with full root privileges:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将用户添加到Docker用户组（/etc/group）来以普通用户身份运行Docker客户端，但我认为授予这种访问权限是在Linux机器上你能做的最危险的事情之一。对docker.sock的访问允许你通过运行以下命令在主机上获得完整的root访问权限。在命令中，你将整个主机操作系统/挂载到容器内的/host目录。`--privileged`标志关闭了所有容器安全特性，然后你`chroot`到/host。`chroot`之后，你就在操作系统的/目录下的root
    shell中，拥有完整的root权限：
- en: '[PRE2]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'At this point, you have full root privileges on the machine, and you can do
    whatever you want. When you are done hacking the machine, you can simply execute
    the `docker` `rm` command to remove the container and all records of what you
    did:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你在机器上拥有完整的root权限，你可以做任何你想做的事情。当你完成对机器的破解后，你可以简单地执行`docker rm`命令来删除容器和你所做的一切记录：
- en: '[PRE3]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When Docker is configured with default file logging, all records of your launching
    the container are erased. I believe this is far worse than setting up `sudo` without
    root, in that at least with `sudo`, you have the chance to see that `sudo` was
    run in your log files.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当Docker配置为默认文件日志记录时，你启动容器的所有记录都会被删除。我相信这比没有root设置`sudo`还要糟糕，因为至少在日志文件中，你有机会看到`sudo`被运行。
- en: With Podman the processes running on the system are always owned by the user
    and have no capabilities greater than a normal user. Even if you break out of
    the container, the process is still running as your UID, and all actions on the
    system are recorded in the audit logs. Users of Podman cannot simply remove the
    container and cover up their tracks. See chapter 6 for more information.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Podman时，系统上运行的进程始终属于用户，并且没有比普通用户更大的能力。即使你从容器中逃逸出来，进程仍然以你的UID运行，系统上的所有操作都会记录在审计日志中。Podman的用户不能简单地删除容器并掩盖他们的踪迹。更多信息请参阅第6章。
- en: Note Docker now has the ability to run rootless similarly to Podman, but almost
    no one runs it that way. Starting up multiple services in your home directory
    just to launch a single container has not caught on.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Docker现在可以像Podman一样以rootless模式运行，但几乎没有人那样使用。仅仅为了启动一个容器而在家目录中启动多个服务并没有流行起来。
- en: 1.3.3 Fork/exec model
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.3 Fork/exec模型
- en: Docker is built as a REST API server. Fundamentally Docker is a client-server
    architecture including multiple daemons. When a user executes the Docker client,
    they execute a command-line tool that connects to the Docker daemon. The Docker
    daemon then pulls images to its storage and then connects to the containerd daemon,
    which finally executes an OCI runtime that creates the container. The Docker daemon,
    then, is a communication platform that communicates reads and writes of `stdin`,
    `stdout`, and `stderr` from the initial process (PID1) created in the container.
    The daemon relays all of the output back to the Docker client. Users imagine the
    container’s processes are just children of the current session, but there is a
    lot of communication going on behind the scenes. Figure 1.8 shows the Docker client-server
    architecture.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Docker被构建为一个REST API服务器。本质上，Docker是一个包含多个守护进程的客户端-服务器架构。当用户执行Docker客户端时，他们执行一个连接到Docker守护进程的命令行工具。然后Docker守护进程将其存储中的镜像拉取到其存储中，然后连接到containerd守护进程，该守护进程最终执行一个OCI运行时来创建容器。然后，Docker守护进程是一个通信平台，它从容器中创建的初始进程（PID1）读取和写入`stdin`、`stdout`和`stderr`。守护进程将所有输出回传给Docker客户端。用户想象容器的进程只是当前会话的子进程，但幕后有很多通信在进行。图1.8展示了Docker客户端-服务器架构。
- en: '![](../../OEBPS/Images/01-08.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图1.8](../../OEBPS/Images/01-08.png)'
- en: Figure 1.8 Docker client-server architecture. The container is a direct descendant
    of containerd, not the Docker client. The kernel sees no relationship between
    the client program and the container.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.8 Docker客户端-服务器架构。容器是containerd的直接后裔，而不是Docker客户端。内核看不到客户端程序和容器之间的任何关系。
- en: The bottom line is the Docker client communicates with the Docker daemon, which
    then communicates with the containerd daemon, which finally launches an OCI runtime
    like `runc` to launch PID1 of the container. There is a lot of complexity involved
    in running containers in this way. Over the years, failures in any of the Daemons
    have led to all containers shutting down, and it is often difficult to diagnose
    what happened. The core Podman engineering team comes from an operating system
    background grounded in the Unix philosophy.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 核心是Docker客户端与Docker守护进程通信，然后Docker守护进程与containerd守护进程通信，最终启动一个如`runc`这样的OCI运行时来启动容器的PID1。以这种方式运行容器涉及很多复杂性。多年来，任何守护进程的故障都可能导致所有容器关闭，而且通常很难诊断发生了什么。Podman的核心工程团队来自一个基于Unix哲学的操作系统背景。
- en: Unix and C were designed with the fork/exec model of computing. Basically, when
    you execute a new program, a parent program like the Bash shell forks a new process
    and then executes the new program as a child of the old program. The Podman engineering
    team thought they could make containers simpler by building a tool that pulls
    container images from a container registry, configures container storage, and
    then launches an OCI runtime, which starts the container as a child of your container
    engine.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Unix和C都是基于计算中的fork/exec模型设计的。基本上，当你执行一个新程序时，像Bash shell这样的父程序会创建一个新的进程，然后作为旧程序的子程序执行新程序。Podman工程团队认为，通过构建一个从容器注册库拉取容器镜像、配置容器存储并最终启动OCI运行时的工具，可以使容器更简单。这个运行时作为你的容器引擎的子程序启动容器。
- en: In the Unix operating system, processes can share content via the filesystem
    and inter-process communication (IPC) mechanisms. These features of the operating
    system enable multiple container engines to share storage without requiring a
    daemon to be running to control access and share content. The engines do not need
    to communicate together aside from using locking mechanisms provided by the operating
    system’s filesystems. Future chapters examine the advantages and disadvantages
    of this mechanism. Figure 1.9 shows the Podman architecture and communication
    flow.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unix操作系统中，进程可以通过文件系统和进程间通信（IPC）机制共享内容。这些操作系统特性使得多个容器引擎可以共享存储，而无需运行守护进程来控制访问和共享内容。除了使用操作系统文件系统提供的锁定机制外，引擎之间不需要相互通信。未来的章节将探讨这种机制的优势和劣势。图1.9展示了Podman架构和通信流程。
- en: '![](../../OEBPS/Images/01-09.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图1.9](../../OEBPS/Images/01-09.png)'
- en: Figure 1.9 Podman fork/exec architecture. The user launches Podman, which executes
    the OCI runtime, which then launches the container. The container is a direct
    descendant of Podman.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.9 Podman fork/exec架构。用户启动Podman，它执行OCI运行时，然后启动容器。容器是Podman的直接后裔。
- en: 1.3.4 Podman is daemonless
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.4 Podman是无守护进程的
- en: Podman is fundamentally different from Docker because it is daemonless. Podman
    can run all of the same container images as Docker and launch containers with
    the same container runtimes. However, Podman does this without having multiple
    continuously root-running daemons.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 与 Docker 基本上不同，因为它是无守护进程的。Podman 可以运行与 Docker 相同的所有容器镜像，并使用相同的容器运行时启动容器。然而，Podman
    在没有多个持续以 root 权限运行的守护进程的情况下完成这些操作。
- en: Imagine you have a web service that you want to run at boot time. The web service
    is packaged in a container, so you need a container engine. In the Docker case,
    you need to set it up to be running on your machine with each of the daemons running
    and accepting connections. Next, launch the Docker client to start the web service.
    Now you have your containerized application running as well as all of the Docker
    daemons. In the Podman case, use the Podman command to launch your container,
    and Podman will go away. Your container will continue to run without the overhead
    of running the multiple daemons. Less overhead is incredibly popular on low-end
    machines like IOT devices and edge servers.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你有一个希望在启动时运行的 Web 服务。这个 Web 服务被封装在一个容器中，因此你需要一个容器引擎。在 Docker 的情况下，你需要将其设置在您的机器上运行，并且每个守护进程都在运行并接受连接。接下来，启动
    Docker 客户端以启动 Web 服务。现在，你的容器化应用程序以及所有的 Docker 守护进程都在运行。在 Podman 的情况下，使用 Podman
    命令来启动你的容器，Podman 将会消失。你的容器将继续运行，而无需运行多个守护进程的开销。在低端机器上，如 IOT 设备和边缘服务器，更少的开销非常受欢迎。
- en: 1.3.5 User-friendly command line
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.5 用户体验友好的命令行
- en: 'One of the great features of Docker is the simple command-line interface. There
    have been other container command lines like `RKT`, `lxc`, and `lxcd`, but they
    have their own command-line interfaces. The Podman team realized early on that
    it wouldn’t gain market share if Podman had its own command-line interface. Docker
    was the dominant tool, and almost everyone who had played with containers had
    done it with its CLI. In addition, if you were to search how to do something with
    a container online, invariably you would get an example using the Docker command
    line. Right from the start, Podman had to match the Docker command line. A motto
    for replacing Docker with Podman was quickly developed: `alias` `Docker` `=` `Podman`.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 的一个伟大特性是简单的命令行界面。曾经有过其他容器命令行，如 `RKT`、`lxc` 和 `lxcd`，但它们都有自己的命令行界面。Podman
    团队很早就意识到，如果 Podman 有自己的命令行界面，那么它将无法获得市场份额。Docker 是主导工具，几乎每个玩过容器的人都使用过它的 CLI。此外，如果你在网上搜索如何使用容器，不可避免地你会得到一个使用
    Docker 命令行的示例。从一开始，Podman 就必须与 Docker 命令行相匹配。一个用 Podman 替换 Docker 的座右铭很快就被开发出来了：`alias
    Docker = Podman`。
- en: With this command, you can continue to type in your Docker commands, but Podman
    runs your containers. If the Podman command line differs from Docker, it is considered
    a bug in Podman, and users demand Podman to be fixed to make the tools match.
    There are a few commands, such as Docker Swarm, that Podman doesn’t support, but
    for the most part, Podman is a complete replacement for the Docker CLI.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个命令，你可以继续输入你的 Docker 命令，但 Podman 会运行你的容器。如果 Podman 命令行与 Docker 不同，则被认为是 Podman
    的一个错误，并且用户要求 Podman 修复以使工具匹配。有一些命令，如 Docker Swarm，Podman 不支持，但就大部分而言，Podman 是
    Docker CLI 的完整替代品。
- en: Many distributions supply a package called `podman-docker`, which changes the
    alias from *docker* to *podman* and links the man page. The alias means when you
    type `docker` `ps`, the `podman` `ps` command runs. If you execute `man` `docker`
    `ps`, the Podman `ps` man pages show up. Figure 1.10 is a twitter message from
    a Podman user who aliased the `docker` command to `podman`, and was surprised
    to remember he had been using Podman for two months while thinking he was using
    Docker.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 许多发行版提供了一个名为 `podman-docker` 的软件包，它将别名从 `docker` 更改为 `podman` 并链接到 man 页面。别名意味着当你输入
    `docker ps` 时，会运行 `podman ps` 命令。如果你执行 `man docker ps`，Podman 的 `ps` man 页面就会出现。图
    1.10 是一位 Podman 用户发布的推文，他将 `docker` 命令别名为 `podman`，并惊讶地记得他已经使用 Podman 两个月了，而当时他以为自己在使用
    Docker。
- en: '![](../../OEBPS/Images/01-10.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/01-10.png)'
- en: Figure 1.10 Tweet about “alias docker=’podman’”
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.10 关于“alias docker=’podman’”的推文
- en: 'Back in 2018, Alan Moran tweeted, “I completely forgot that ~2 months ago I
    set up ‘alias docker=“podman”’ and it has been a dream. #nobigfatdaemons...”.
    Joe Thomson responded, “So, what reminded you?” and Alan Moran answered “docker
    help.” And Podman help showed up.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 2018 年，Alan Moran 推文说：“我完全忘记了大约两个月前我设置了‘alias docker=“podman”’，这真是个梦。#nobigfatdaemons...”。Joe
    Thomson 回应道：“那么，是什么提醒你的？”Alan Moran 回答说：“docker help。”然后出现了 Podman 的帮助信息。
- en: 1.3.6 Support for REST API
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.6 支持 REST API
- en: Podman can be run as a socket-activated REST API service. This allows remote
    clients to manage and launch Podman containers. Podman supports the Docker API
    as well as the Podman API for advanced Podman features. Through the use of the
    Docker API, Podman supports `docker-compose` and other users of the docker-py
    Python bindings. This means that even if you built your infrastructure around
    using the Docker socket for launching containers, you can simply replace Docker
    with the Podman service and continue to use your existing scripts and tools. Chapter
    9 covers the Podman service.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Podman可以作为socket激活的REST API服务运行。这允许远程客户端管理和启动Podman容器。Podman支持Docker API以及用于高级Podman功能的Podman
    API。通过使用Docker API，Podman支持`docker-compose`和其他使用docker-py Python绑定的用户。这意味着即使你围绕使用Docker套接字来启动容器构建了你的基础设施，你也可以简单地用Podman服务替换Docker，并继续使用你现有的脚本和工具。第9章涵盖了Podman服务。
- en: The Podman REST API also allows remote Podman clients on Mac, Windows, and Linux
    systems to interact with Podman containers on a Linux machine. Appendixes E and
    F cover Podman use on Mac and Windows machines.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Podman REST API还允许远程的Mac、Windows和Linux系统上的Podman客户端与Linux机器上的Podman容器交互。附录E和F涵盖了在Mac和Windows机器上使用Podman。
- en: 1.3.7 Integration with systemd
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.7 与systemd的集成
- en: 'Systemd is the fundamental init system in the operating systems. The init process
    on a Linux system is the first process that is started by the kernel on boot.
    Therefore, the init system is the ancestor of all processes and can monitor them
    all. Podman wants to fully integrate the running of containers with the init system.
    Users want to use systemd to start and stop containers at boot time. Containers
    should do the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Systemd是操作系统中的基本初始化系统。Linux系统上的初始化进程是内核在启动时启动的第一个进程。因此，初始化系统是所有进程的祖先，可以监控它们所有。Podman希望将容器的运行与初始化系统完全集成。用户希望使用systemd在启动时启动和停止容器。容器应该执行以下操作：
- en: Support systemd within a container
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器内支持systemd
- en: Support socket activation
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持套接字激活
- en: Support systemd notifications that a containerized application is fully activated
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持容器化应用程序完全激活的systemd通知
- en: Allow systemd to fully manage the cgroups and lifespan of a containerized application
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许systemd完全管理容器化应用程序的cgroups和生命周期
- en: Basically, containers work as services in systemd unit files. Many developers
    want to run systemd within a container to run multiple system-defined services
    within a container.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，容器在systemd单元文件中充当服务的作用。许多开发者希望在一个容器内运行systemd，以便在容器内运行多个系统定义的服务。
- en: However, the upstream Docker community disagrees with this and has denied all
    pull requests that attempt to integrate systemd into Docker. They believe Docker
    should manage the life cycle of the container, and they do not want to accommodate
    users who want to run systemd in a container.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，上游的Docker社区对此表示不同意，并拒绝了所有尝试将systemd集成到Docker中的拉取请求。他们认为Docker应该管理容器的生命周期，他们不希望满足那些希望在容器中运行systemd的用户的需求。
- en: The upstream Docker community believes the Docker daemon, as opposed to systemd,
    should be the controller of processes, it should manage the life cycle of containers,
    and it should start and stop them at boot time. The problem is there are many
    more features in systemd than in Docker, including startup ordering, socket activation,
    service ready notifications, and so on. Figure 1.11 is an actual badge of a Docker
    employee at the first DockerCon, illustrating their hostility towards systemd.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 上游的Docker社区认为，与systemd相比，Docker守护进程应该是进程的控制者，它应该管理容器的生命周期，并在启动时启动和停止它们。问题是systemd比Docker有更多功能，包括启动顺序、套接字激活、服务就绪通知等。图1.11是DockerCon
    EU上一位Docker员工的实际徽章，展示了他们对systemd的敌意。
- en: '![](../../OEBPS/Images/01-11.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/01-11.png)'
- en: Figure 1.11 Docker employee badge at DockerCon EU
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.11 DockerCon EU上Docker员工的徽章
- en: 'When Podman was designed, the developers wanted to make sure it fully integrated
    with systemd. When you run systemd inside a container, Podman sets up the container
    the way systemd expects and allows it to simply run as PID1 of the container with
    limited privileges. Podman allows you to run services within the container the
    same way they run on a system or in a VM: via systemd unit files. Podman supports
    socket activation, service notifications, and many other systemd unit file features.
    Podman makes it simple to generate systemd unit files with best practices for
    running containers within a systemd service. For more information, see chapter
    7 on systemd integration.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当设计Podman时，开发者想要确保它与systemd完全集成。当你在一个容器内运行systemd时，Podman会按照systemd期望的方式设置容器，并允许它以有限的权限简单地作为容器的PID1运行。Podman允许你以与系统或虚拟机中相同的方式在容器内运行服务：通过systemd单元文件。Podman支持套接字激活、服务通知以及许多其他systemd单元文件功能。Podman使得生成适用于在systemd服务中运行容器的最佳实践systemd单元文件变得简单。有关更多信息，请参阅第7章关于systemd集成的部分。
- en: The Containers project ([https://github.com/containers](https://github.com/containers))
    where Podman, container libraries, and other container management tools reside,
    wants to embrace all features of the operating system and fully integrate it.
    Chapter 7 explains Podman integration with systemd.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 容器项目([https://github.com/containers](https://github.com/containers))，其中包含Podman、容器库和其他容器管理工具，希望拥抱操作系统的所有功能并完全集成。第7章解释了Podman与systemd的集成。
- en: 1.3.8 Pods
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.8 Pods
- en: 'One advantage of Podman is described in its name. As mentioned earlier, *Podman*
    is actually short for *Pod Manager*. As the official Kubernetes documentation
    puts it, “A pod (as in a pod of seals, hence the logo, or pea pod) is a group
    of one or more containers, with shared storage/network resources, and a specification
    for how to run the containers.” Podman works with either a single container at
    a time, like Docker, or it can manage groups of containers together in a pod.
    One of the design goals of containers is to separate services into single containers:
    microservices. Then you combine containers together to build larger services.
    Pods allow you to group multiple services together to form a larger service managed
    as a single entity. One of the goals of Podman is allowing you to experiment with
    pods. Figure 1.12 shows two pods running on a system, each pod containing three
    containers.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Podman的一个优点可以从其名称中看出。如前所述，*Podman*实际上是*Pod Manager*的缩写。正如官方Kubernetes文档所述，“Pod（就像海豹群，因此有该标志，或豌豆荚）是一组一个或多个容器，具有共享的存储/网络资源，以及如何运行容器的规范。”Podman可以一次与单个容器一起工作，就像Docker一样，或者它可以一起管理Pod中的容器组。容器的设计目标之一是将服务分离到单个容器中：微服务。然后你将容器组合起来构建更大的服务。Pods允许你将多个服务组合在一起形成一个更大的服务，该服务作为一个单一实体进行管理。Podman的一个目标之一是允许你尝试使用Pods。图1.12显示了在系统上运行的两个Pod，每个Pod包含三个容器。
- en: '![](../../OEBPS/Images/01-12.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/01-12.png)'
- en: Figure 1.12 Two pods running on a host. Each pod runs two different containers
    along with the infra container.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.12 在主机上运行的两个Pod。每个Pod运行两个不同的容器以及基础设施容器。
- en: Podman has the `podman` `generate` `kube` command, which allows you to generate
    Kubernetes YAML files from running containers and pods, as you can see in chapter
    7\. Similarly, it has the `podman` `play` `kube` command, which allows you to
    play Kubernetes YAML files and generate pods and containers on your host. I suggest
    using Podman for running pods and containers on a single host and using Kubernetes
    to take your pods and containers and run them on multiple machines and all through
    your infrastructure. Other projects, like kind ([https://kind.sigs.k8s.io/docs/user/rootless](https://kind.sigs.k8s.io/docs/user/rootless)),
    are experimenting with running pods with Podman under the guidance of Kubernetes.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Podman有一个`podman` `generate` `kube`命令，允许你从运行中的容器和Pod生成Kubernetes YAML文件，正如第7章中所示。同样，它还有一个`podman`
    `play` `kube`命令，允许你播放Kubernetes YAML文件并在你的主机上生成Pod和容器。我建议在单个主机上使用Podman运行Pod和容器，并使用Kubernetes将你的Pod和容器运行在多台机器上，并且在整个基础设施中运行。其他项目，如kind
    ([https://kind.sigs.k8s.io/docs/user/rootless](https://kind.sigs.k8s.io/docs/user/rootless))，正在尝试在Kubernetes的指导下使用Podman运行Pod。
- en: 1.3.9 Customizable registries
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.9 可定制注册表
- en: 'Container engines like Podman support the concept of pulling images using short
    names, such as ubi8, without specifying the registry in which they reside: [registry.access.redhat.com](http://registry.access.redhat.com).
    Complete image names include the name of the container registry they were pulled
    from: [registry.access.redhat.com/library/ubi8:latest](http://registry.access.redhat.com/library/ubi8:latest).
    Table 1.3 shows the components of the image name broken out.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于Podman这样的容器引擎支持使用短名称拉取镜像的概念，例如ubi8，而不必指定它们所在的注册库：[registry.access.redhat.com](http://registry.access.redhat.com)。完整的镜像名称包括它们从中拉取的容器注册库的名称：[registry.access.redhat.com/library/ubi8:latest](http://registry.access.redhat.com/library/ubi8:latest)。表1.3显示了镜像名称的组成部分。
- en: Table 1.3 Short name to container image name table
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 表1.3 短名称到容器镜像名称表
- en: '| Name | Registry | Repo | Name | Tag |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| Name | Registry | Repo | Name | Tag |'
- en: '| Short name |  |  | ubi8 |  |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| 短名称 |  |  | ubi8 |  |'
- en: '| Complete name | registry.access.redhat.com | library | ubi8 | `latest` |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| 完整名称 | registry.access.redhat.com | library | ubi8 | `latest` |'
- en: 'Docker is hardcoded to always pull from [https://docker.io](https://docker.io)
    when using a short name. If you want to pull an image from a different container
    registry, you must fully specify the image. In the following example, I attempt
    to pull ubi8/httpd-24, and it fails because the container image is not on docker.io.
    The image is on [registry.access.redhat.com](http://registry.access.redhat.com):'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Docker在默认情况下，使用短名称时总是从[https://docker.io](https://docker.io)拉取。如果您想从不同的容器注册库拉取镜像，您必须完全指定镜像。在以下示例中，我尝试拉取ubi8/httpd-24，但失败了，因为容器镜像不在docker.io上。该镜像在[registry.access.redhat.com](http://registry.access.redhat.com)：
- en: '[PRE4]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'So if I want to use ubi8/httpd-24, I am forced to type the entire name, including
    the registry:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我想使用ubi8/httpd-24，我被迫输入整个名称，包括注册库：
- en: '[PRE5]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The Docker engine gives docker.io an advantage over other container registries
    as the preferred registry. Podman was designed to allow you to specify multiple
    registries, like what you can do with `dnf`, `yum`, and `apt` tools for installing
    packages. You can even remove docker.io from the list. If you attempt to pull
    ubi8/httpd-24 with Podman, Podman presents you with a list of registries to choose
    from:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Docker引擎给docker.io带来了优势，使其成为首选的注册库。Podman被设计成允许您指定多个注册库，就像使用`dnf`、`yum`和`apt`工具安装软件包时一样。您甚至可以删除docker.io。如果您尝试使用Podman拉取ubi8/httpd-24，Podman会向您提供一个注册库列表以供选择：
- en: '[PRE6]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Once you make your decision, Podman records the short-name alias and no longer
    prompts and uses the previously selected registry. Podman supports lots of other
    features, like blocking registries, only pulling signed images, setting up image
    mirrors, and specifying hardcoded short names, so specific short names map directly
    to the long names (see chapter 5).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您做出决定，Podman会记录短名称别名，并且不再提示并使用之前选择的注册库。Podman支持许多其他功能，如阻止注册库、仅拉取签名镜像、设置镜像镜像以及指定硬编码的短名称，以便特定的短名称直接映射到长名称（见第5章）。
- en: 1.3.10 Multiple transports
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.10 多种传输
- en: Podman supports many different container image sources and targets called *transports*
    (see table 1.4). Podman can pull images from container registries and from local
    containers storage but also supports images stored in OCI format, OCI TAR format,
    legacy Docker TAR format, directory format, and images directly from the Docker
    daemon. Podman commands can easily run images from each of the formats.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Podman支持许多不同的容器镜像源和目标，这些被称为*传输*（见表1.4）。Podman可以从容器注册库和本地容器存储中拉取镜像，同时也支持存储在OCI格式、OCI
    TAR格式、传统Docker TAR格式、目录格式以及直接从Docker守护进程中的镜像。Podman命令可以轻松运行来自每种格式的镜像。
- en: Table 1.4 Podman-supported transports
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 表1.4 Podman支持的传输
- en: '| Transport | Description |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 传输 | 描述 |'
- en: '| Container registry(`docker`) | References a container image stored in a remote
    container image registry website. Registries store and share container images
    (e.g., docker.io and quay.io). |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 容器注册库（`docker`） | 引用存储在远程容器镜像注册网站中的容器镜像。注册库存储和共享容器镜像（例如，docker.io和quay.io）。
    |'
- en: '| `oci` | References a container image compliant with OCI layout specifications.
    The manifest and layer tarballs are located in the local directory as individual
    files. |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `oci` | 引用符合OCI布局规范的容器镜像。manifest和层tar包位于本地目录中作为单独的文件。 |'
- en: '| `dir` | References a container image compliant with the Docker image layout,
    similar to the `oci` transport but storing the files using the legacy `docker`
    format. |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `dir` | 引用符合Docker镜像布局的容器镜像，类似于`oci`传输，但使用传统的`docker`格式存储文件。 |'
- en: '| `docker-archive` | References a container image in a Docker image layout
    that is packed into a TAR archive. |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `docker-archive` | 指向打包成 TAR 归档的 Docker 镜像布局中的容器镜像。|'
- en: '| `oci-archive` | References a container image compliant with OCI layout specifications
    that is packed into a TAR archive. |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `oci-archive` | 指向符合 OCI 布局规范的容器镜像，该镜像被打包成 TAR 归档。|'
- en: '| `docker-daemon` | References an image stored in the Docker daemon’s internal
    storage. |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `docker-daemon` | 指向存储在 Docker 守护进程内部存储中的镜像。|'
- en: '| `container-storage` | References a container image located in a local storage.
    Podman defaults to using container storage for local images. |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `container-storage` | 指向存储在本地存储中的容器镜像。Podman 默认使用容器存储来处理本地镜像。|'
- en: 1.3.11 Complete customizability
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.11 完全可定制性
- en: Container engines tend to have lots of built-in constants, like the namespaces
    they run with, whether or not SELinux is enabled, and which capabilities containers
    run with. With Docker, most of these values are hardcoded and cannot be changed
    by default. Podman, on the other hand, has a very customizable configuration.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 容器引擎通常有很多内置的常量，例如它们运行的命名空间、SELinux 是否启用以及容器运行时使用的权限。在 Docker 中，这些值大多数是硬编码的，默认情况下无法更改。而
    Podman 则具有非常可定制的配置。
- en: 'Podman has its built-in defaults but defines three locations for its configuration
    files to be stored:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 有其内置的默认值，但定义了三个位置来存储其配置文件：
- en: '*/usr/share/containers/containers.conf*—Where a distribution can define the
    changes the distribution likes to use'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*/usr/share/containers/containers.conf*—在这里，发行版可以定义它希望使用的更改'
- en: '*/etc/containers/containers.conf*—Where they can set up system overrides'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*/etc/containers/containers.conf*—在这里可以设置系统覆盖项'
- en: '*$HOME/.config/containers/containers.conf*—Can be specified only in rootless
    mode'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*$HOME/.config/containers/containers.conf*—只能在无根模式下指定'
- en: The configuration files allow you to configure Podman to run the way you want
    by default. You can even run with more security by default if you choose.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件允许您通过默认方式配置 Podman 以满足您的需求。您甚至可以选择以更高的安全性默认运行。
- en: 1.3.12 User-namespace support
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.12 用户命名空间支持
- en: Podman is fully integrated with the user namespace. Rootless mode relies on
    user namespaces, which allows for multiple UIDs to be assigned to a user. User
    namespaces provide isolation between users on a system, so you can have multiple
    rootless users running containers with multiple user IDs, all isolated from each
    other.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 完全集成了用户命名空间。无根模式依赖于用户命名空间，这允许为用户分配多个 UID。用户命名空间在系统上的用户之间提供隔离，因此您可以拥有多个无根用户，他们使用多个用户
    ID 运行容器，所有这些用户都是相互隔离的。
- en: A user namespace can be used to isolate containers from each other. Podman makes
    it simple to launch multiple containers, each with a unique user namespace. The
    kernel then isolates the processes from host users as well as each other based
    on UID separation.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 用户命名空间可以用来隔离容器。Podman 使启动具有唯一用户命名空间的多个容器变得简单。然后内核根据 UID 分隔将进程从主机用户以及彼此之间隔离。
- en: Docker only supports running containers in a single, separate, user namespace,
    meaning all containers run within the same user namespace. Root in one container
    is the same as root in another container. It does not support running each container
    in a different user namespace, which means containers attack each other from a
    user-namespace perspective. Even though Docker supports this mode, almost no one
    runs containers with Docker in a separate user namespace.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 只支持在单个、独立的用户命名空间中运行容器，这意味着所有容器都在同一个用户命名空间内运行。一个容器中的 root 与另一个容器中的 root
    相同。它不支持在不同的用户命名空间中运行每个容器，这意味着容器从用户命名空间的角度相互攻击。尽管 Docker 支持这种模式，但几乎没有人使用 Docker
    在单独的用户命名空间中运行容器。
- en: 1.4 When not to use Podman
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.4 何时不使用 Podman
- en: Like Docker, Podman is not a container orchestrator. Podman is a tool for running
    container workloads on a single host in either rootless or rootful mode. Higher-level
    tools are required if you want to orchestrate running containers on multiple machines.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Docker 类似，Podman 不是一个容器编排器。Podman 是一个用于在单个主机上以无根或根模式运行容器工作负载的工具。如果您想在多台机器上编排运行中的容器，则需要更高层次的工具。
- en: I believe the best tool for doing this now is Kubernetes. Kubernetes won the
    container orchestrator war when it comes to mind share. Docker has an orchestrator
    called Swarm, which had some popularity, but it now seems to be out of favor.
    Because the Podman team believes Kubernetes is the way to go for containers on
    multiple machines, Podman does not support Swarm functionality. Podman has been
    used for different orchestrators and is used for grid/HPC computing, and open
    source developers have even added it to Kubernetes frontends.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为目前做这件事最好的工具是 Kubernetes。在市场份额方面，Kubernetes 赢得了容器编排器的战争。Docker 有一个名为 Swarm
    的编排器，曾经相当受欢迎，但现在似乎已经不再流行。因为 Podman 团队认为 Kubernetes 是多机容器化的正确选择，所以 Podman 不支持 Swarm
    功能。Podman 已被用于不同的编排器，并用于网格/HPC 计算，开源开发者甚至将其添加到了 Kubernetes 前端。
- en: Summary
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Containers technology has been around for many years, but the introduction of
    container images and container registries allows developers a better way to ship
    software.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器技术已经存在很多年了，但容器镜像和容器注册表的引入为开发者提供了更好的软件分发方式。
- en: Podman is an excellent container engine, suitable for almost all of your single-node
    container projects. It is useful for developing, building, and running containerized
    applications.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Podman 是一个出色的容器引擎，适用于几乎所有的单节点容器项目。它对于开发、构建和运行容器化应用程序非常有用。
- en: Podman is as simple to use as Docker, with the exact same command-line interface.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Podman 的使用与 Docker 一样简单，具有完全相同的命令行界面。
- en: Podman supports a REST API, which allows remote tools and languages, including
    `docker-compose`, to work with Podman containers.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Podman 支持REST API，允许远程工具和语言，包括 `docker-compose`，与 Podman 容器一起工作。
- en: Unlike Docker, Podman includes such notable features as user-namespace support,
    multiple transports, customizable registries, integration with systems, the fork/exec
    model, and out-of-the-box rootless mode.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 Docker 不同，Podman 包含诸如用户命名空间支持、多种传输方式、可定制的注册表、系统集成、fork/exec 模型以及开箱即用的无根模式等显著特性。
- en: Podman is a more secure way to run containers.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Podman 是运行容器的一种更安全的方式。
- en: '* * *'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ¹ Other container engines include Buildah, CRI-O, containerd, and many others.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ¹ 其他容器引擎包括 Buildah、CRI-O、containerd 以及许多其他引擎。
