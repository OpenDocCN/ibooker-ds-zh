- en: Part 2\. Implementing Enterprise Java microservices
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二部分\. 实施企业Java微服务
- en: In [part 2](#part02), we delve deeper into microservice development by covering
    topics such as consuming other microservices, service registration and discovery,
    fault tolerance, and security.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第二部分](#part02)中，我们通过涵盖诸如消费其他微服务、服务注册和发现、容错和安全性等主题，更深入地探讨了微服务开发。
- en: These six chapters also cover the development of a microservice hybrid from
    the Cayambe monolith, using the microservices that you’ve developed throughout
    the book. Finally, you’ll add data streaming with Kafka as you learn about sharing
    data among microservices and with hybrids.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这六章也涵盖了从Cayambe单体应用中开发微服务混合体，使用你在整本书中开发的微服务。最后，当你学习到在微服务及其混合体之间共享数据时，你将添加Kafka的数据流。
- en: Chapter 6\. Consuming microservices
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第六章\. 消费微服务
- en: '*This chapter covers*'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: How to consume a microservice
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何消费微服务
- en: Your choices when consuming a microservice
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费微服务时的选择
- en: Consuming a microservice can mean many things to many people. Clients of a microservice
    could be scripts, web pages, other microservices, or pretty much anything that
    can make HTTP requests. If we covered them all, this chapter would be a whole
    book by itself!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 消费微服务对许多人来说意味着很多不同的事情。微服务的客户端可以是脚本、网页、其他微服务，或者几乎所有可以发起HTTP请求的东西。如果我们涵盖了所有这些，那么这一章将是一本完整的书！
- en: Developing a microservice is interesting, but it doesn’t get you far until you
    introduce many microservices interacting with each other. To enable two services
    to interact with each other, you need a method by which one service can call another.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 开发一个微服务很有趣，但直到你引入许多相互交互的微服务之前，它并不能让你走得很远。为了使两个服务能够相互交互，你需要一种方法，使得一个服务可以调用另一个服务。
- en: This chapter provides examples focused on one microservice consuming another
    with Java-based libraries, but the methods shown can be equally applied to any
    generic Java client consuming a microservice.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了使用基于Java的库来消费另一个微服务的示例，但所示方法同样适用于任何通用Java客户端消费微服务。
- en: With Enterprise Java, two services would interact with a direct service call,
    as shown in [figure 6.1](#ch06fig01).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业Java中，两个服务将直接通过服务调用进行交互，如图6.1所示。
- en: Figure 6.1\. Enterprise Java business service calls
  id: totrans-11
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.1\. 企业Java业务服务调用
- en: '![](Images/06fig01_alt.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/06fig01_alt.jpg)'
- en: 'The service call could be accomplished by the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 服务调用可以通过以下方式实现：
- en: '`@EJB` injection when using EJBs'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用EJB时的`@EJB`注入
- en: '`@Inject` with CDI'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Inject`与CDI'
- en: Retrieving an instance of a service via a `static` method or variable
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`static`方法或变量获取服务实例
- en: Spring dependency injection, either XML or annotation based
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring依赖注入，无论是基于XML还是基于注解
- en: All these options require that your two services reside in the same JVM and
    runtime, as shown in [figure 6.1](#ch06fig01).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些选项都需要你的两个服务位于同一个JVM和运行时环境中，如图6.1所示。
- en: In the figure one microservice is calling another microservice. In the diagram,
    they’re within the same microservices environment, but they don’t have to be.
    Revisiting [figure 1.4](kindle_split_010.xhtml#ch01fig04), [figure 6.2](#ch06fig02)
    highlights the focus of this chapter, solving the means by which two microservices
    in separate runtimes are able to communicate.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中，一个微服务正在调用另一个微服务。在图中，它们位于相同的微服务环境中，但不必如此。回顾[图1.4](kindle_split_010.xhtml#ch01fig04)，[图6.2](#ch06fig02)突出了本章的重点，即解决两个在不同运行时环境中的微服务如何进行通信的问题。
- en: Figure 6.2\. Consuming microservices
  id: totrans-20
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.2\. 消费微服务
- en: '![](Images/06fig02.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/06fig02.jpg)'
- en: In our particular case, you’ll be taking the new Cayambe administration microservice
    from [chapter 2](kindle_split_011.xhtml#ch02) and developing clients for it with
    different libraries. [Figure 6.3](#ch06fig03) illustrates where the microservice
    client fits; you use a short-term way of retrieving category data until such time
    as the final solution is in place.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的特定情况下，你将使用[第2章](kindle_split_011.xhtml#ch02)中的新Cayambe管理微服务，并使用不同的库为其开发客户端。[图6.3](#ch06fig03)说明了微服务客户端的位置；你使用一种临时方式检索分类数据，直到最终解决方案到位。
- en: Figure 6.3\. Cayambe administration microservice client
  id: totrans-23
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.3\. Cayambe管理微服务客户端
- en: '![](Images/06fig03_alt.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/06fig03_alt.jpg)'
- en: You’ll start with a look at consuming a microservice by using low-level libraries
    that deal directly with HTTP requests. Because they deal with HTTP requests, they
    can be used with microservices that don’t expose RESTful endpoints. Then you’ll
    learn about client libraries that are specifically designed to simplify the code
    required to call RESTful endpoints. They offer a higher level of abstraction over
    HTTP requests, which simplifies the client code significantly, as you’ll see in
    our examples. The code for this section can be found in the /chapter6 directory
    of the book’s example code. For each client library, a service will be implemented
    that calls the `CategoryResource` RESTful endpoint, which you created in [chapter
    2](kindle_split_011.xhtml#ch02), and then returns the received data as the response
    to the caller.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你将首先通过使用直接处理HTTP请求的低级库来了解如何消费微服务。因为它们处理HTTP请求，所以可以与不暴露RESTful端点的微服务一起使用。然后，你将学习专门设计来简化调用RESTful端点所需代码的客户端库。它们在HTTP请求上提供了更高层次的抽象，这显著简化了客户端代码，正如你将在我们的示例中看到的那样。本节代码可以在书籍示例代码的/chapter6目录中找到。对于每个客户端库，将实现一个服务，该服务调用你在[第2章](kindle_split_011.xhtml#ch02)中创建的`CategoryResource`
    RESTful端点，然后将接收到的数据作为对调用者的响应返回。
- en: '|  |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-27
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: You can set the port that the `CategoryResource` starts on to prevent port clashes
    with the other microservices. You set the `swarm.port.offset` property in the
    Maven plugin to `1`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将`CategoryResource`启动的端口设置为防止与其他微服务发生端口冲突。你将`swarm.port.offset`属性在Maven插件中设置为`1`。
- en: '|  |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Each of these services needs an object to represent the category JSON that you’ll
    receive from the administration service. To facilitate that, each client library
    Maven module will have its own `Category` object, which will be used when deserializing
    the response from the administration service.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些服务中的每一个都需要一个对象来表示从管理服务接收到的类别JSON。为了方便起见，每个客户端库Maven模块都将有自己的`Category`对象，该对象将在从管理服务反序列化响应时使用。
- en: Listing 6.1\. `Category` model class
  id: totrans-31
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.1\. `Category`模型类
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '***1*** Defines the key as the ID for Category, which is used for deserializing
    the collection of children received as JSON'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 将键定义为Category的ID，该ID用于反序列化作为JSON接收到的子集合'
- en: '***2*** Initializes the collection of children to ensure that you always have
    a valid collection, even if it’s empty'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 初始化子集合，以确保即使它是空的，你也能始终拥有一个有效的集合'
- en: The getter and setter methods are omitted for brevity, but the full source of
    `Category` is available in the book’s source code.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁，省略了获取器和设置器方法，但`Category`类的完整源代码可以在书籍的源代码中找到。
- en: 'In addition, each of these services needs access to `ExecutorService` to submit
    work for processing on a new thread. You want to use one provided by Java EE so
    the services all retrieve one the same way:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这些服务中的每一个都需要访问`ExecutorService`以在新的线程上提交工作。你希望使用Java EE提供的，以便所有服务都以相同的方式检索：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This does a simple JNDI lookup of the service by name and returns the instance
    you can use for submitting work.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过名称进行简单的JNDI查找以获取服务，并返回你可以用于提交工作的实例。
- en: '|  |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-40
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: The `ExecutorService` is defined for you by WildFly. You don’t need to do anything
    to make it available in order to retrieve it from JNDI.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExecutorService`是由WildFly定义的。你不需要做任何事情就可以通过JNDI检索它。'
- en: '|  |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Your services could just as easily have created a new `Thread` directly to perform
    any required work, but then your new thread would be outside the Java EE thread
    pool management. Is this a problem? Not always, but you could have problems if
    the thread pool size of the runtime is almost as large as the available JVM threads.
    In that case, you could exhaust all available JVM threads when creating threads
    outside the Java EE thread pool. As a general rule, it’s best not to create threads
    directly, but instead use the `ExecutorService`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你的服务也可以直接创建一个新的`Thread`来执行任何所需的工作，但这样你的新线程就会在Java EE线程池管理之外。这是问题吗？不一定，但如果运行时的线程池大小几乎与可用的JVM线程一样大，你可能会遇到问题。在这种情况下，当在Java
    EE线程池之外创建线程时，你可能会耗尽所有可用的JVM线程。一般来说，最好不直接创建线程，而是使用`ExecutorService`。
- en: 'Because you want to show how synchronous and asynchronous usage scenarios result
    in different client code for consuming a microservice, each resource that uses
    a client library will contain two endpoints:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你想展示同步和异步使用场景如何导致消费微服务的不同客户端代码，每个使用客户端库的资源将包含两个端点：
- en: '`/sync`—Synchronously processes a request from the caller'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/sync`—同步处理调用者的请求'
- en: '`/async`—Asynchronously processes a request from the caller'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/async`—异步处理调用者的请求'
- en: Traditionally, services were developed to communicate synchronously with any
    other resources required to complete a response. With increasing demands from
    the enterprise to deliver greater performance and scalability, we’ve moved toward
    greater asynchronous behavior in our services. In this chapter and the remainder
    of the book, you’ll learn about both synchronous and asynchronous usage patterns.
    Enhancing the benefits of microservices also requires some level of asynchronous
    behavior; otherwise, you minimize the benefits of their distributed nature. If
    you take that route, you may as well stick with a monolith!
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，服务被开发出来以同步方式与完成响应所需的任何其他资源进行通信。随着企业对提高性能和可扩展性的需求不断增加，我们在服务中转向了更大的异步行为。在本章和本书的剩余部分，你将了解同步和异步的使用模式。增强微服务的优势也需要一定程度的异步行为；否则，你将最小化它们分布式特性的优势。如果你选择那条路线，那么你不妨坚持使用单体架构！
- en: '|  |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Each of your microservices defines a field called `categoryUrl`, which is hardcoded
    to http://localhost:8081/admin/categorytree. This isn’t what you’d go into production
    doing, but it serves our purpose to simplify the examples. In a later chapter,
    you’ll see how service discovery can be used for connecting to other services.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你的每个微服务定义了一个名为`categoryUrl`的字段，该字段硬编码为http://localhost:8081/admin/categorytree。这不是你投入生产时会做的事情，但它有助于简化示例。在后面的章节中，你将看到如何使用服务发现来连接到其他服务。
- en: '|  |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 6.1\. Consuming a microservice with a Java client library
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1\. 使用Java客户端库消费微服务
- en: In this section, you’ll see examples of consuming a microservice that uses lower-level
    libraries to deal with HTTP requests directly. Though that results in more verbose
    and extra handling of data, it does provide the greatest flexibility as to how
    a call can be made. For instance, using these libraries may be a better choice
    if a microservice needs to communicate with many types of HTTP resources, because
    it doesn’t make sense to add another library just for RESTful endpoint interaction.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将看到如何消费使用较低级别库直接处理HTTP请求的微服务的示例。尽管这会导致更冗长和额外的数据处理，但它确实提供了最大的灵活性，关于如何进行调用。例如，如果微服务需要与许多类型的HTTP资源通信，那么使用这些库可能是一个更好的选择，因为为RESTful端点交互添加另一个库是没有意义的。
- en: 6.1.1\. java.net
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.1\. java.net
- en: The classes in the java.net package have been part of the JDK from the beginning.
    Though they’ve been enhanced and updated over the years, they focus on low-level
    HTTP interactions. They’re in no way designed for RESTful endpoint consumption,
    so some level of cumbersome code is required.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: java.net包中的类从一开始就是JDK的一部分。尽管这些年来它们得到了增强和更新，但它们专注于低级HTTP交互。它们绝不是为RESTful端点消费而设计的，因此需要一定程度的繁琐代码。
- en: Let’s take a look at our first method for the `DisplayResource`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`DisplayResource`的第一个方法。
- en: Listing 6.2\. `DisplayResource` with java.net
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.2\. 使用java.net的`DisplayResource`
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***1*** Create a URL pointing to your CategoryResource.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 创建一个指向你的CategoryResource的URL。'
- en: '***2*** Set HTTP GET as the request method for your connection.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 将HTTP GET设置为连接的请求方法。'
- en: '***3*** Set “application/json” as the media type that you’ll accept in a response.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 将“application/json”设置为响应中你将接受的媒体类型。'
- en: '***4*** Check for a non-OK response code.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** 检查非OK响应代码。'
- en: '***5*** Create a new ObjectMapper to perform the JSON deserialization.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** 创建一个新的ObjectMapper来执行JSON反序列化。'
- en: '***6*** Register the JavaTimeModule to handle conversion of JSON to LocalDateTime
    instances.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** 注册JavaTimeModule以处理JSON到LocalDateTime实例的转换。'
- en: '***7*** Pass the InputStream you received in the response to the ObjectMapper
    for deserialization, into an instance of Category.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7*** 将你在响应中收到的InputStream传递给ObjectMapper进行反序列化，到一个Category实例中。'
- en: '***8*** Close the connection to CategoryResource.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8*** 关闭与CategoryResource的连接。'
- en: Though you’re dealing with a simple RESTful endpoint, the client code to communicate
    with it certainly isn’t, and this is only synchronous!
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你处理的是一个简单的RESTful端点，但与之通信的客户端代码肯定不是，这只是一个同步操作！
- en: The next listing shows how the preceding code changes if you want to handle
    the client request to your microservice asynchronously.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了如果你想要异步处理对微服务的客户端请求，前面的代码将如何改变。
- en: Listing 6.3\. `DisplayResource` with java.net asynchronously
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.3\. 使用java.net异步的`DisplayResource`
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1*** Request processing will be handled asynchronously.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 请求处理将异步进行。'
- en: '***2*** Pass the lambda expression to an executor for processing.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 将 lambda 表达式传递给执行器进行处理。'
- en: '***3*** Resume the AsyncResponse with the deserialized Category instance.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 使用反序列化的 Category 实例恢复 AsyncResponse。'
- en: '***4*** Resume the AsyncResponse with an exception.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** 使用异常恢复 AsyncResponse。'
- en: The listing introduced concepts you haven’t seen before—namely, `@Suspended`
    and `AsyncResponse`. These two pieces are the core of how JAX-RS handles client
    requests asynchronously. `@Suspended` informs the JAX-RS runtime that the HTTP
    request from the client should be suspended until a response is ready. `AsyncResponse`
    indicates how the developer informs the runtime that a response is ready or has
    failed to complete.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中介绍了你之前未见过的新概念——即 `@Suspended` 和 `AsyncResponse`。这两个部分是 JAX-RS 处理客户端请求异步的核心。`@Suspended`
    通知 JAX-RS 运行时，客户端的 HTTP 请求应挂起，直到有响应准备就绪。`AsyncResponse` 指示开发者如何通知运行时响应已准备就绪或未能完成。
- en: What does that look like? Take a look at [figure 6.4](#ch06fig04).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来是什么样子？请查看 [图 6.4](#ch06fig04)。
- en: 'Here’s what is happening at each step within [figure 6.4](#ch06fig04):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 [图 6.4](#ch06fig04) 中每个步骤所发生的情况：
- en: An HTTP request arrives from a browser or another client.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从浏览器或其他客户端收到了 HTTP 请求。
- en: '`getCategoryTreeAsync()` triggers code to be executed in a separate thread.
    On completion of `getCategoryTreeAsync()`, the client request is suspended and
    the HTTP request thread that was handling it is made available to handle additional
    requests.'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`getCategoryTreeAsync()` 触发在单独的线程中执行代码。在 `getCategoryTreeAsync()` 完成后，客户端请求被挂起，处理该请求的
    HTTP 请求线程变得可用以处理其他请求。'
- en: An HTTP request is made to an external microservice.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向外部微服务发出 HTTP 请求。
- en: Figure 6.4\. JAX-RS `AsyncResponse` handling
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.4\. JAX-RS `AsyncResponse` 处理
- en: '![](Images/06fig04_alt.jpg)'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](Images/06fig04_alt.jpg)'
- en: An HTTP response is received from the external microservice.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从外部微服务接收到了 HTTP 响应。
- en: The response data is passed to `asyncResponse.resume()`.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 响应数据传递给 `asyncResponse.resume()`。
- en: The client request is reactivated in the HTTP request thread and a response
    is constructed.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端请求在 HTTP 请求线程中被重新激活，并构建响应。
- en: The response is returned to the browser, or to whatever client made the request.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 响应返回给浏览器，或返回给发起请求的任何客户端。
- en: '|  |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-88
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: Using `@Suspended` in a RESTful endpoint doesn’t prevent the client that’s calling
    the endpoint from blocking. It benefits only the server side of the request by
    allowing greater request throughput. Without the use of `@Suspended`, a JAX-RS
    resource can handle only as many requests as there are available threads, because
    each request blocks the thread until the method completes.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RESTful 端点中使用 `@Suspended` 并不能阻止调用端点的客户端阻塞。它仅通过允许更大的请求吞吐量来使请求的服务器端受益。不使用 `@Suspended`，JAX-RS
    资源只能处理与可用线程数量一样多的请求，因为每个请求都会阻塞线程，直到方法完成。
- en: '|  |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Now that you have your services built, you can start them.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经构建了服务，可以启动它们。
- en: 'Change into the /chapter6/admin directory of the book’s example code and run
    this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到书籍示例代码的 /chapter6/admin 目录并运行以下命令：
- en: '[PRE4]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`CategoryResource` will be started and available at http://localhost:8081/admin/categorytree
    in a browser.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`CategoryResource` 将启动并在浏览器中可用，地址为 http://localhost:8081/admin/categorytree。'
- en: 'Now you start your `DisplayResource`. Change into the /chapter6/java-net directory
    and run this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在开始你的 `DisplayResource`。切换到 /chapter6/java-net 目录并运行以下命令：
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It’s now possible to access the microservices by accessing them in a browser:
    http://localhost:8080/sync and http://localhost:8080/async. Either of the preceding
    URLs opened in the browser will show the tree of categories that are currently
    present within the administration microservice.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以通过在浏览器中访问它们来访问微服务：http://localhost:8080/sync 和 http://localhost:8080/async。在浏览器中打开上述任一
    URL 都会显示当前存在于管理微服务中的类别树。
- en: 6.1.2\. Apache HttpClient
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.2\. Apache HttpClient
- en: With Apache HttpClient, you get an abstraction over classes you used with java.net,
    minimizing the code required for interacting with the underlying HTTP connection.
    The code in `DisplayResource` isn’t vastly different from your previous code,
    but it does improve the code’s readability.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Apache HttpClient，你得到了对 java.net 中使用的类的抽象，最小化了与底层 HTTP 连接交互所需的代码。`DisplayResource`
    中的代码与之前的代码没有太大不同，但它提高了代码的可读性。
- en: For instance, let’s look at your first method for `DisplayResource`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看看你的第一个 `DisplayResource` 方法。
- en: Listing 6.4\. `DisplayResource` with HttpClient
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.4\. 使用 HttpClient 的 `DisplayResource`
- en: '[PRE6]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1*** Create an HTTP client inside the try-with-resources statement.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 在 try-with-resources 语句内创建一个 HTTP 客户端。'
- en: '***2*** Create an HttpGet instance with the CategoryResource URL endpoint.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 使用 CategoryResource URL 端点创建一个 HttpGet 实例。'
- en: '***3*** Specify that you’ll accept JSON responses.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 指定你将接受 JSON 响应。'
- en: '***4*** Execute HttpGet, passing a handler for the Response.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** 执行 HttpGet，传递一个用于响应的处理程序。'
- en: '***5*** Verify that the response code is OK.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** 验证响应代码是否为 OK。'
- en: '***6*** Extract HttpEntity from Response. Convert the entity to a Category
    instance using an ObjectMapper.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** 从响应中提取 HttpEntity。使用 ObjectMapper 将实体转换为 Category 实例。'
- en: Even with this short example, you can see how much simpler your client code
    is when making an HTTP request. Now let’s see how much simpler your code becomes
    when you use `@Suspended`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是这样一个简短的示例，你也能看到在发起 HTTP 请求时客户端代码有多简单。现在让我们看看使用 `@Suspended` 时代码会变得多么简单。
- en: Listing 6.5\. `DisplayResource` with HttpClient and `@Suspended`
  id: totrans-110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.5\. 使用 HttpClient 和 `@Suspended` 的 `DisplayResource`
- en: '[PRE7]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '***1*** Execute your calling code in a separate thread.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 在单独的线程中执行你的调用代码。'
- en: '***2*** Resume the AsyncResponse with the received category.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 使用接收到的类别恢复 AsyncResponse。'
- en: Once again, this approach is similar to our synchronous example, but you use
    `@Suspended` and `AsyncResponse` to indicate to JAX-RS that you want the HTTP
    request to be suspended while you make your call to an external microservice.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这种方法与我们的同步示例类似，但你使用 `@Suspended` 和 `AsyncResponse` 来告诉 JAX-RS 你希望在调用外部微服务时挂起
    HTTP 请求。
- en: If you already have your `CategoryResource` microservice running at http://localhost:8081,
    you can now start your new microservice by using Apache HttpClient.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经在 http://localhost:8081 上运行了你的 `CategoryResource` 微服务，你现在可以使用 Apache HttpClient
    启动你的新微服务。
- en: '|  |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: You need to stop any previously running microservices before you can run this
    one, because they use the same port.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行此微服务之前，你需要停止任何之前运行的微服务，因为它们使用相同的端口。
- en: '|  |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Change into the /chapter6/apache-httpclient directory and run this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到 /chapter6/apache-httpclient 目录并运行以下命令：
- en: '[PRE8]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It’s now possible to access the microservices by accessing them in a browser:
    http://localhost:8080/sync and http://localhost:8080/async. As with your previous
    microservice, you’ll see a tree of categories that are currently present within
    the administration microservice.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以通过浏览器访问微服务：http://localhost:8080/sync 和 http://localhost:8080/async。就像你之前使用的微服务一样，你将看到一个当前存在于管理微服务中的类别树。
- en: In this section, you looked at client libraries that focus on using URLs and
    HTTP request methods directly. They’re great for interacting with HTTP resources,
    but they’re verbose when dealing with RESTful endpoints. Can you find client libraries
    that simplify your client code even further?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你查看了一些专注于直接使用 URL 和 HTTP 请求方法的客户端库。它们在与 HTTP 资源交互时非常出色，但在处理 RESTful 端点时则较为冗长。你能找到进一步简化客户端代码的客户端库吗？
- en: 6.2\. Consuming a microservice with a JAX-RS client library
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2\. 使用 JAX-RS 客户端库消费微服务
- en: This section introduces client libraries that bring your abstraction level even
    higher than HTTP. Both libraries provide APIs that are designed specifically for
    use in communicating with JAX-RS endpoints.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了将抽象级别提升到 HTTP 以上的客户端库。这两个库都提供了专门为与 JAX-RS 端点通信而设计的 API。
- en: 6.2.1\. JAX-RS client
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.1\. JAX-RS 客户端
- en: JAX-RS has been defined over the years as part of the JSR 311 and JSR 339 specifications
    of Java EE. As part of these specifications, JAX-RS has a client API that provides
    a developer with a cleaner means of calling RESTful endpoints from a JAX-RS resource.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: JAX-RS 在多年的时间里被定义为 Java EE 的 JSR 311 和 JSR 339 规范的一部分。作为这些规范的一部分，JAX-RS 有一个客户端
    API，它为开发者提供了一种更干净的方式来从 JAX-RS 资源调用 RESTful 端点。
- en: 'So what are the benefits of using the JAX-RS client library? It allows you
    to forget about the low-level HTTP connection you need for connecting to a RESTful
    microservice, and focus on the required metadata such as the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，使用 JAX-RS 客户端库的好处是什么？它允许你忘记连接到 RESTful 微服务所需的低级 HTTP 连接，并专注于所需的元数据，如下所示：
- en: HTTP method
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP 方法
- en: Parameters to be passed
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要传递的参数
- en: MediaType format of parameters and return type
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数和返回类型的 MediaType 格式
- en: Required cookies
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必要的 Cookie
- en: Any other piece of metadata required to consume a RESTful microservice
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费 RESTful 微服务所需的任何其他元数据
- en: When using the JAX-RS client library, you need to register a provider to handle
    the deserialization of JSON into `LocalDateTime` instances when processing a response.
    For that, you need the following listing, which you’ll use in our subsequent examples.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 JAX-RS 客户端库时，你需要注册一个提供者来处理响应中 JSON 到 `LocalDateTime` 实例的反序列化。为此，你需要以下列表，你将在我们后续的示例中使用它。
- en: Listing 6.6\. `ClientJacksonProvider`
  id: totrans-135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.6\. `ClientJacksonProvider`
- en: '[PRE9]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '***1*** Provide ContextResolver for ObjectMapper instances.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 为 ObjectMapper 实例提供 ContextResolver。'
- en: '***2*** Create a new ObjectMapper instance.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 创建一个新的 ObjectMapper 实例。'
- en: '***3*** Register the JavaTimeModule for handling LocalDateTime conversion.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 注册 JavaTimeModule 以处理 LocalDateTime 转换。'
- en: '***4*** Return the instance of ObjectMapper that you created when it’s requested.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** 当请求时返回你创建的 ObjectMapper 实例。'
- en: Once again, you start with your synchronous example endpoint.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，你从你的同步示例端点开始。
- en: Listing 6.7\. `DisplayResource` with JAX-RS client
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.7\. 使用 JAX-RS 客户端的 `DisplayResource`
- en: '[PRE10]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '***1*** Create a JAX-RS client.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 创建一个 JAX-RS 客户端。'
- en: '***2*** Register the provider you defined in [listing 6.6](#ch06ex06).'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 注册你在 [列表 6.6](#ch06ex06) 中定义的提供者。'
- en: '***3*** Set the target of the client to be the CategoryResource URL.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 将客户端的目标设置为 CategoryResource URL。'
- en: '***4*** Specify that your response should return JSON.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** 指定响应应返回 JSON。'
- en: '***5*** Make an HTTP GET request and convert the response body to Category.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** 发送 HTTP GET 请求并将响应体转换为 Category。'
- en: When comparing the preceding listing to either of the pure Java client libraries,
    you have a significantly simplified and more coherent piece of code for calling
    an external microservice.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当将前面的列表与任何纯 Java 客户端库进行比较时，你将有一个显著简化且更连贯的代码片段，用于调用外部微服务。
- en: Is that important? In terms of the functionality required to execute a request
    and process the response, not at all. But that isn’t anywhere near as critical
    as how easily a developer can understand existing or develop new code. I’ll leave
    it up to you to judge, but I know I’d prefer to see the preceding example than
    anything else we’ve seen so far.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这重要吗？从执行请求和处理响应所需的功能角度来看，一点也不重要。但这一点与开发者理解现有代码或开发新代码的容易程度相比，远没有那么关键。我会把它留给你来判断，但我知道我宁愿看到之前的例子，也不愿看到我们迄今为止看到的任何其他东西。
- en: Can the JAX-RS client library likewise improve the readability of your code
    for asynchronous use? See the next listing.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: JAX-RS 客户端库同样可以改善你代码的异步可读性吗？参见下一列表。
- en: Listing 6.8\. `DisplayResource` with JAX-RS client and `@Suspended`
  id: totrans-152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.8\. 使用 JAX-RS 客户端和 `@Suspended`
- en: '[PRE11]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '***1*** Return a response you construct, including the exception message, instead
    of just passing the exception along.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 返回你构造的响应，包括异常消息，而不是仅仅传递异常。'
- en: As with all asynchronous usage, you specify `@Suspended` and `AsyncResponse`.
    You also use `ManagedExecutorService` to provide a new thread for processing your
    call, and you set the response with `asyncResponse.resume()`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有异步使用一样，你指定 `@Suspended` 和 `AsyncResponse`。你还使用 `ManagedExecutorService` 为处理你的调用提供一个新线程，并通过
    `asyncResponse.resume()` 设置响应。
- en: You also could’ve used the asynchronous functionality of the JAX-RS client library
    itself.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 JAX-RS 客户端库本身的异步功能。
- en: Listing 6.9\. `DisplayResource` with JAX-RS client and `InvocationCallback`
  id: totrans-157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.9\. 使用 JAX-RS 客户端和 `InvocationCallback` 的 `DisplayResource`
- en: '[PRE12]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***1*** Indicate you want the call to be asynchronous.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 指示你希望调用是异步的。'
- en: '***2*** Pass InvocationCallback with methods for completed and failed handling.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 传递带有完成和失败处理方法的 InvocationCallback。'
- en: This second asynchronous version alters which pieces of your code execute in
    a new thread, but it doesn’t alter the end result. In `getCategoryTreeAsync()`,
    you pass all your RESTful endpoint code into a new thread so that the HTTP request
    thread can be unblocked almost as quickly as it was processed. `getCategoryTreeAsyncAlt()`
    differs by executing only the HTTP request to your external microservice in a
    new thread. All the setup code required to make your HTTP request occurs in the
    same thread as the client request.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个异步版本改变了你的代码中哪些部分在新线程中执行，但它并没有改变最终结果。在 `getCategoryTreeAsync()` 中，你将所有 RESTful
    端点代码传递到一个新线程，以便 HTTP 请求线程可以几乎与处理一样快地被解除阻塞。`getCategoryTreeAsyncAlt()` 的不同之处在于它只在新的线程中执行对外部微服务的
    HTTP 请求。所有用于发送 HTTP 请求的设置代码都发生在客户端请求相同的线程中。
- en: As `getCategoryTreeAsyncAlt()` uses the HTTP request thread opened for the client
    the longest, it reduces the throughput of the RESTful endpoints by causing each
    client to block on a thread for longer than necessary. Though the impact may be
    minimal, given a large enough number of requests, the impact exists.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `getCategoryTreeAsyncAlt()` 使用了为客户端打开的最长时间 HTTP 请求线程，它通过使每个客户端在比必要更长的时间内阻塞线程来降低
    RESTful 端点的吞吐量。尽管影响可能很小，但如果请求数量足够大，这种影响是存在的。
- en: So why show an *inferior* method that negatively affects throughput? First,
    as a way to show that there can be many means to achieve a similar goal. Second,
    many microservices may not have a large enough number of concurrent client requests
    for such a performance impact to be noticeable and cause problems. In such a case,
    a developer may prefer callbacks over any alternative—because when an option doesn’t
    impact performance, that’s a reasonable choice to make.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么展示一个 *较差* 的方法，它会对吞吐量产生负面影响？首先，作为一种展示有多种方式可以实现类似目标的方式。其次，许多微服务可能没有足够多的并发客户端请求，以至于这种性能影响是明显的并导致问题。在这种情况下，开发者可能更愿意选择回调而不是任何其他替代方案——因为当某个选项不会影响性能时，这是一个合理的选择。
- en: In switching to using the JAX-RS client library, you’ve simplified your calling
    code and made it clearer to understand. That certainly makes it more pleasurable
    to develop with than the lower-level libraries, but it does come at a cost in
    terms of how flexibly it can be used.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在切换到使用 JAX-RS 客户端库时，您简化了调用代码，并使其更容易理解。这当然比使用底层库更令人愉快，但它确实在如何灵活使用方面付出了代价。
- en: What kind of flexibility is lost? For most use cases, the JAX-RS client library
    wouldn’t cause any impact, but calling a microservice that uses a binary protocol
    would be more difficult. Depending on the protocol, it may require developing
    custom handlers and providers or incorporating additional third-party libraries
    that provide such features.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 会失去什么样的灵活性？对于大多数用例来说，JAX-RS 客户端库不会造成任何影响，但调用使用二进制协议的微服务可能会更困难。根据协议的不同，可能需要开发自定义处理程序和提供者，或者集成提供此类功能的额外第三方库。
- en: 'Change into the /chapter6/jaxrs-client directory and run this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到 /chapter6/jaxrs-client 目录并运行以下命令：
- en: '[PRE13]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'It’s now possible to access the microservices by accessing them in a browser:
    http://localhost:8080/sync and http://localhost:8080/async. As with our previous
    examples, you’ll see a tree of categories that are currently present within the
    administration microservice.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以通过在浏览器中访问它们来访问微服务：http://localhost:8080/sync 和 http://localhost:8080/async。就像我们之前的示例一样，您将看到当前存在于管理微服务中的类别树。
- en: 6.2.2\. RESTEasy client
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.2\. RESTEasy 客户端
- en: RESTEasy is an implementation of the JAX-RS specification that’s made available
    within WildFly as well as separately. Though many parts of its client library
    are identical to those provided by the JAX-RS client API, RESTEasy provides a
    particularly interesting feature that’s worthwhile.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: RESTEasy 是 JAX-RS 规范的实现，它不仅可在 WildFly 中使用，还可以单独使用。尽管其客户端库的许多部分与 JAX-RS 客户端 API
    提供的相同，但 RESTEasy 提供了一个特别有趣的功能，值得注意。
- en: With the JAX-RS client library, you specify what RESTful endpoint you want to
    call by chaining methods together to build up a picture of the endpoints, URL
    path, parameters, return type, media types, and so forth. There’s nothing wrong
    with that, but it’s not overly natural for developers who are more familiar with
    creating RESTful endpoints with JAX-RS.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 JAX-RS 客户端库，您可以通过链式调用方法来指定想要调用的 RESTful 端点，从而构建端点、URL 路径、参数、返回类型、媒体类型等的画面。这样做并没有什么问题，但对于更熟悉使用
    JAX-RS 创建 RESTful 端点的开发者来说，这并不十分自然。
- en: With RESTEasy, you can re-create the RESTful endpoint that you want to communicate
    with as an interface and have a proxy of that interface generated for you. This
    process allows you to use an interface of the external microservice as if it were
    present within your own codebase.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 RESTEasy，您可以重新创建想要与之通信的 RESTful 端点作为接口，并为您生成该接口的代理。这个过程允许您将外部微服务的接口用作如果它存在于您的代码库中一样。
- en: For your external `CategoryResource` microservice, you’d create an interface
    like the following.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 对于您的外部 `CategoryResource` 微服务，您会创建如下所示的接口。
- en: Listing 6.10\. `CategoryService`
  id: totrans-174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.10\. `CategoryService`
- en: '[PRE14]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There’s nothing special about the code here. It looks like any other JAX-RS
    endpoint class, except that it’s an interface and there’s no method implementation.
    Another benefit is needing to define only the methods on the interface that your
    microservice requires. For instance, if an external microservice has five endpoints
    and your micro-service needs to use only one, your interface defining that external
    microservice requires only a single method. You don’t need to define the entire
    external microservice.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的代码没有什么特别之处。它看起来像任何其他的 JAX-RS 端点类，除了它是一个接口并且没有方法实现。另一个好处是只需要在接口上定义你的微服务需要的方法。例如，如果一个外部微服务有五个端点，而你的微服务只需要使用一个，那么定义该外部微服务的接口只需要一个方法。你不需要定义整个外部微服务。
- en: Is there an advantage to this? Definitely! It allows you to have a focused definition
    of an external microservice that you need to consume. If methods are updated on
    that microservice that you don’t consume, there’s no need to update your interface
    because you don’t use those endpoints.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这有什么优势吗？当然有！它允许你有一个专注于定义你需要消费的外部微服务的明确定义。如果该微服务上的方法被更新而你不需要，那么你不需要更新你的接口，因为你没有使用那些端点。
- en: '|  |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Taking this approach, it’d be possible to share the same interface between service
    and client. The service would provide an implementation of the interface for the
    actual endpoint code.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种方法，可以在服务和客户端之间共享相同的接口。服务将为实际的端点代码提供接口的实现。
- en: '|  |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-183
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: Such an approach, though possible, isn’t recommended practice for microservices
    because it becomes a separate library that both microservices depend on, introducing
    release timing and sequencing issues. This is a dangerous road to head down and
    will result in only continual pain for an enterprise. It’s therefore preferable
    to replicate the methods that you need to call.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种做法是可能的，但不推荐在微服务中使用，因为它变成了两个微服务都依赖的独立库，这会引入发布时间和顺序问题。这是一条危险的道路，最终只会给企业带来持续的痛苦。因此，最好是复制你需要调用的方法。
- en: '|  |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Now that you’ve defined an interface that maps onto your external microservice,
    how can it be used?
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经定义了一个映射到你的外部微服务的接口，它该如何使用呢？
- en: Listing 6.11\. `DisplayResource` with RESTEasy
  id: totrans-187
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.11\. 使用 RESTEasy 的 `DisplayResource`
- en: '[PRE15]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '***1*** Create the client with RESTEasy.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 使用 RESTEasy 创建客户端。'
- en: '***2*** Set the target URL base path for your request.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 设置请求的目标 URL 基路径。'
- en: '***3*** Generate a proxy implementation of your CategoryService.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 生成你的 CategoryService 的代理实现。'
- en: '***4*** Call CategoryResource via your proxy.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** 通过你的代理调用 CategoryResource。'
- en: With this approach, you shift setting all the request parameters such as URL
    path, media types, and return types into your `CategoryService` interface. Now
    your client code interacting with the proxy behaves just like a local method call.
    You’ve gained a further simplification in your code by separating common request
    parameter values into a single place. This is particularly important when a microservice
    may require calling the same external microservice in different RESTful endpoints,
    because you don’t want to repeat information that isn’t going to change wherever
    it might be called from.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种方法，你将设置所有请求参数（如 URL 路径、媒体类型和返回类型）的操作转移到你的 `CategoryService` 接口上。现在与代理交互的客户端代码表现得就像是一个本地方法调用。通过将常见的请求参数值集中到一个地方，你在代码中获得了进一步的简化。这在微服务可能需要在不同的
    RESTful 端点调用相同的对外部微服务时尤为重要，因为你不希望在不改变信息的地方重复信息。
- en: Let’s see some asynchronous examples with your proxy interface.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些使用你的代理接口的异步示例。
- en: Listing 6.12\. `DisplayResource` with RESTEasy and `@Suspended`
  id: totrans-195
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.12\. 使用 RESTEasy 和 `@Suspended` 的 `DisplayResource`
- en: '[PRE16]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The only changes you need between synchronous and asynchronous RESTful endpoints
    are the JAX-RS asynchronous requirements of `@Suspended` and `@AsyncResponse`,
    submitting the client code for processing in a separate thread, and setting either
    success or failure on `asyncResponse.resume()`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在同步和异步 RESTful 端点之间，你需要做的唯一改变是 JAX-RS 异步要求的 `@Suspended` 和 `@AsyncResponse`，将客户端代码提交到单独的线程进行处理，并在
    `asyncResponse.resume()` 上设置成功或失败。
- en: The one drawback with the proxy approach you’ve been using with the RESTEasy
    client library is that it doesn’t support invoking a callback when executing the
    call to your external microservice. As such, your `getCategoryTreeAsyncAlt()`
    with RESTEasy would be identical to when you used the JAX-RS client library.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你在使用 RESTEasy 客户端库时采用的代理方法的一个缺点是，它不支持在调用外部微服务时执行回调。因此，使用 RESTEasy 的 `getCategoryTreeAsyncAlt()`
    将与使用 JAX-RS 客户端库时相同。
- en: 'Change into the /chapter6/resteasy-client directory and run this:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到 /chapter6/resteasy-client 目录并运行以下命令：
- en: '[PRE17]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It’s now possible to access the microservices at http://localhost:8080/sync
    and http://localhost:8080/async. Each URL will return a tree of categories that
    are currently present within the administration microservice, as the result.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以通过 http://localhost:8080/sync 和 http://localhost:8080/async 访问微服务。每个 URL
    都会返回当前存在于管理微服务中的分类树，作为结果。
- en: Now we’ve covered a couple of client libraries that provide a higher level of
    abstraction for interacting with RESTful endpoints. The examples show the benefits
    to the client code in reducing complexity and improving readability.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了几种提供更高层次抽象以与 RESTful 端点交互的客户端库。示例展示了这些库在减少代码复杂性和提高可读性方面的好处。
- en: Summary
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Java-based client libraries, such as java.net and Apache HttpClient, provide
    low-level access to networking in Java but create more verbose code than necessary.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于 Java 的客户端库，如 java.net 和 Apache HttpClient，提供了对 Java 网络的低级别访问，但比必要的代码更冗长。
- en: JAX-RS-based client libraries provide an abstraction that makes consuming microservices
    easier.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于 JAX-RS 的客户端库提供了一个抽象，使得消费微服务变得更加容易。
- en: Chapter 8\. Strategies for fault tolerance and monitoring
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 8 章\. 容错和监控策略
- en: '*This chapter covers*'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: What is latency?
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是延迟？
- en: Why do microservices need to be fault tolerant?
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么微服务需要具备容错能力？
- en: How do circuit breakers work?
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电路断路器是如何工作的？
- en: What tools can mitigate against distributed failure?
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有哪些工具可以减轻分布式故障的影响？
- en: You’ll use the example from the previous chapters to expand the functionality
    of Stripe and Payment to include fault mitigation as you explore the concepts
    of fault tolerance and monitoring. Fault tolerance is especially important when
    your Payment microservice is communicating over a network to external systems.
    You need to expect failures and time-outs when communicating across networks.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用前几章中的示例来扩展 Stripe 和 Payment 的功能，包括在探索容错和监控概念时加入故障缓解。当你的 Payment 微服务通过网络与外部系统通信时，容错尤为重要。你需要预料到在网络通信中可能会出现故障和超时。
- en: 8.1\. Microservice failures in a distributed architecture
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1\. 分布式架构中的微服务故障
- en: '[Figure 8.1](#ch08fig01) revisits what your distributed architecture for microservices
    looks like.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8.1](#ch08fig01) 回顾了你的微服务分布式架构的外观。'
- en: Figure 8.1\. Microservices in a distributed architecture
  id: totrans-215
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.1\. 分布式架构中的微服务
- en: '![](Images/08fig01_alt.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig01_alt.jpg)'
- en: How is this distributed architecture relevant to failures? By virtue of your
    microservices containing smaller chunks of business logic, as opposed to a monolith
    that contains everything, you end up with a significantly larger number of services
    to maintain. You’re no longer dealing with a UI that might communicate with a
    single backend service that handles all its needs. More likely, that same UI is
    now integrating with dozens of microservices, or more, that need to be just as
    reliable as your previous monolith.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分布式架构与故障有何关联？由于你的微服务包含更小的业务逻辑块，而不是包含所有内容的单体，你最终会拥有显著更多的服务需要维护。你不再处理可能只与单个后端服务通信的
    UI，该服务处理所有需求。更有可能的是，相同的 UI 现在正在与数十个甚至更多的微服务集成，这些微服务需要与之前的单体一样可靠。
- en: But your microservices won’t fail in production, right? Nothing fails in production!
    We’ve all likely made statements similar to that at some point, usually before
    we’ve been bitten by a major failure in production! Once bitten, twice fault tolerant!
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 但你的微服务在生产环境中不会失败，对吧？在生产环境中，什么都不会失败！我们可能都曾在某个时刻说过类似的话，通常是在我们被生产环境中的重大故障咬了一口之后！一朝被蛇咬，十年怕井绳！
- en: Why is it that, without previous experiences of production failures, we tend
    toward grandiose statements about the reliability of our production systems? Some
    of it’s because we can be optimistic in nature, but mostly it’s a lack of experience.
    If you’ve never had to deal with fixing production issues for your application,
    especially in the middle of the night, it’s hard to appreciate the valid concerns
    around the reliability of systems.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么在没有生产故障的先前经验的情况下，我们倾向于对生产系统的可靠性做出宏伟的声明？部分原因可能是因为我们天生乐观，但主要还是缺乏经验。如果你从未不得不在深夜处理应用程序的生产问题，那么就很难理解关于系统可靠性的合理担忧。
- en: '|  |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Pager nightmares**'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**呼叫器噩梦**'
- en: I remember in the late ’90s—yes, I was in IT back then—that the most dreaded
    experience of the novice was to be handed the pager for *on-call* duty. There’s
    no worse feeling than getting a page around 2 a.m. about failed jobs that need
    to be fixed, and then trying to complete them before the staff arrives in the
    office at 8 a.m.! These were only nightly batch jobs, but the anxiety over being
    paged was terrible.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我记得在20世纪90年代末——是的，那时候我在IT行业——新手最可怕的经历就是被分配到*值班*。没有什么比凌晨2点左右接到故障作业需要修复的通知更糟糕的了，然后试图在早上8点员工到达办公室之前完成它们！这些只是夜间的批量作业，但接到电话的焦虑感是可怕的。
- en: I can only imagine what it’s like to receive a page (if pagers are still around
    today) for a production failure on a live application that needs to be resolved
    because it’s affecting the 24/7 running of the business!
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我只能想象收到一个生产故障的呼叫（如果呼叫器今天仍然存在）来处理一个需要解决的实时应用程序，因为它正在影响业务的24/7运行！
- en: '|  |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Here are some of the statements you might falsely believe regarding production
    systems, and distributed architectures in particular:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些关于生产系统，尤其是分布式架构，你可能会错误地相信的声明：
- en: '***The network of computing devices is reliable*.** Without taking into account
    the possibility of network failures, it’s possible for an application to stall
    while waiting for a response that won’t arrive. Worse, the application would be
    unable to retry any failed operations when the network is available again.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***计算设备网络是可靠的**。如果不考虑网络故障的可能性，应用程序在等待不会到达的响应时可能会停滞。更糟糕的是，当网络再次可用时，应用程序将无法重试任何失败的操作。'
- en: '***There’s no delay in making a request and having it acted upon (known as
    zero latency)*.** Ignoring network latency, and associated network packet loss,
    can result in wasted bandwidth and an increase in dropped network packets as the
    amount of traffic on the network grows without limitation.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***请求得到响应没有延迟（称为零延迟）**。忽略网络延迟以及相关的网络数据包丢失，可能会导致带宽浪费和网络数据包丢失增加，而网络流量在无限制增长的情况下。'
- en: '***There’s no limitation to the available bandwidth on the network*.** If clients
    are sending too much data, or too many requests, the available network bandwidth
    could shrink to the point that bottlenecks appear and application throughput is
    reduced. The impact of latency on network throughput can last for a few seconds
    or be constantly present.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***网络上的可用带宽没有限制**。如果客户端发送的数据太多，或者请求太多，可用的网络带宽可能会缩小到出现瓶颈并降低应用程序吞吐量的程度。延迟对网络吞吐量的影响可能持续几秒钟或持续存在。'
- en: '***The entire network is secure from possible attack, external or internal*.**
    It’s naive to ignore the possibility that a malicious user, such as a disgruntled
    employee, could attempt to cause damage to an application. Likewise, a once-internal
    application can be easily exposed to external threats by making it available publicly
    without proper security vetting. Even an innocuous change in firewall rules for
    a port could make it unintentionally accessible externally.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***整个网络对可能的攻击，无论是外部还是内部，都是安全的**。忽视恶意用户，如不满的员工，可能试图对应用程序造成损害的可能性是幼稚的。同样，一个曾经内部的应用程序，如果没有经过适当的安全审查就公开提供，很容易受到外部威胁。即使是对端口的防火墙规则的无害更改也可能无意中使其对外部可访问。'
- en: '***Location and arrangement of computing devices on a network never changes*.**
    When networks are altered, and devices moved to different locations, the available
    bandwidth and latency can be diminished.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***计算设备在网络上的位置和布局永远不会改变**。当网络发生变化，设备被移动到不同的位置时，可用的带宽和延迟可能会降低。'
- en: '***There’s a single administrator for everything*.** With multiple administrators
    for different networks within an enterprise, conflicting security policies could
    be implemented. In this case, a client who needs to communicate across differently
    secured networks needs to be aware of the requirements of both to successfully
    communicate.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***一切只有一个管理员**。在企业内部，如果不同网络有不同的管理员，可能会实施冲突的安全策略。在这种情况下，需要跨不同安全网络通信的客户端需要了解双方的要求才能成功通信。'
- en: '***Zero transport cost*.** Though the transport of physical data through a
    network may cost zero, it’s a nonzero cost to maintain a network after it’s built.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***零传输成本**。尽管通过网络传输物理数据可能没有成本，但在网络建成后维护网络是有成本的。'
- en: '***The entire network is homogeneous*.** In a homogeneous network, every device
    on the network uses similar configurations and protocols. A nonhomogeneous network
    can lead to the problems described in the first three points of this list.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***整个网络是同质的**。在同质网络中，网络上的每个设备都使用类似的配置和协议。异质网络可能导致本列表前三个点中描述的问题。'
- en: All these statements are known as the Fallacies of Distributed Computing ([www.rgoarchitects.com/Files/fallacies.pdf](http://www.rgoarchitects.com/Files/fallacies.pdf)).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些陈述都被称为分布式计算的谬误([www.rgoarchitects.com/Files/fallacies.pdf](http://www.rgoarchitects.com/Files/fallacies.pdf))。
- en: 8.2\. Network failures
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2. 网络故障
- en: Though there are many ways a network can fail, in this section you’ll focus
    on network latency and time-outs. Previously, I mentioned zero latency as being
    part of the Fallacies of Distributed Computing, which equates to no delay in making
    a request and having it acted upon.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管网络可能以许多方式失败，但在这个部分，你将专注于网络延迟和超时。之前，我提到零延迟是分布式计算的谬误之一，这等于在请求和执行请求时没有延迟。
- en: 'Why is *latency* important for your microservice? It affects almost anything
    your microservice might want to do:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么延迟对你的微服务很重要？它几乎影响你的微服务可能想要做的任何事情：
- en: Calling another microservice
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用另一个微服务
- en: Waiting for an asynchronous message
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待异步消息
- en: Reading from a database
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从数据库读取
- en: Writing to a database
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向数据库写入
- en: Without being mindful of the existence of latency in your network, you’d presume
    that all communication of messages and data is near instantaneous, assuming the
    network devices involved in the communication are sufficiently close.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不考虑网络中存在延迟的事实，你会假设所有消息和数据通信都是几乎瞬时的，假设参与通信的网络设备足够接近。
- en: Time-outs are another crucial source of network failure you need to be mindful
    of when developing microservices. Time-outs can be linked to high latency; requests
    aren’t responded to in a timely manner not only because of network delays, but
    also because of issues with the consuming microservice. If the microservice you’re
    calling has gone down, is experiencing high load, or failing for any other number
    of reasons, you’ll notice problems when you try to consume it, most often in the
    form of a time-out. There’s no way to predict when a time-out will occur, so your
    code needs to be aware that time-outs happen, and of how you want to handle the
    situation when you receive one.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 超时是你在开发微服务时需要留意的另一个关键网络故障来源。超时可能与高延迟相关；请求没有及时得到响应，不仅因为网络延迟，还因为消费微服务的问题。如果你调用的微服务已经宕机，正在经历高负载，或者因为其他任何原因失败，当你尝试消费它时，你将注意到问题，最常见的形式是超时。无法预测超时何时发生，因此你的代码需要意识到超时会发生，以及当你收到超时时你想要如何处理这种情况。
- en: Do you try again, either immediately or after a short delay? Do you presume
    a standard response and proceed anyway?
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 你是立即重试还是稍后延迟重试？你假设标准响应并继续进行吗？
- en: It’s these network failures that you want to especially mitigate against. Otherwise,
    you leave your microservices, and entire application, open to unexpected network
    failure with no means of recovering other than restarting services. Because you
    can’t afford to be restarting services every time a network problem occurs, you
    need to develop your code to prevent restarting from being your only option.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 你特别希望减轻这些网络故障。否则，你将你的微服务，以及整个应用程序，暴露在无法恢复的意外网络故障中，除了重新启动服务外没有其他恢复手段。因为你不能每次网络问题发生时都重启服务，你需要开发你的代码以防止重启成为你唯一的选项。
- en: 8.3\. Mitigating against failures
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3. 防御故障
- en: In looking at how to mitigate against failure, you could certainly implement
    the features you need yourself. But you might not be an expert in all the best
    ways to implement the features you need. Even if you were, accomplishing that
    implementation requires more than a short development lifecycle. You’d rather
    be developing more applications! Though you might be able to use many different
    libraries, in this case you’re going to be using Hystrix from Netflix Open Source
    Software.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑如何减轻失败时，你当然可以自己实现所需的功能。但你可能不是所有最佳实现方式的专家。即使你是，完成这种实现也需要超过短期的开发周期。你更愿意开发更多的应用程序！尽管你可能能够使用许多不同的库，但在这个案例中，你将使用Netflix开源软件中的Hystrix。
- en: 8.3.1\. What is Hystrix?
  id: totrans-248
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.1\. 什么是Hystrix？
- en: Hystrix is a latency and fault-tolerance library intended to isolate access
    points with remote systems, services, and libraries; halt cascading failure; and
    enable resilience in distributed systems. Wherever failure is inevitable, as with
    distributed systems, the Hystrix library improves the resiliency of microservices
    in these environments.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: Hystrix是一个旨在隔离远程系统、服务和库的访问点、阻止级联故障以及在分布式系统中提供弹性的延迟和容错库。无论在何处失败是不可避免的，例如在分布式系统中，Hystrix库提高了这些环境中微服务的弹性。
- en: A lot of things are going on with Hystrix, so how does this library do it? We
    can’t cover the entirety of Hystrix within this single chapter; that would require
    an entire book in its own right. But this section provides a high-level view of
    how Hystrix performs its segregation.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Hystrix有很多功能，那么这个库是如何做到的呢？我们无法在本章中涵盖Hystrix的所有内容；那需要一本完全属于自己的书。但本节提供了Hystrix如何执行隔离的高级视图。
- en: '[Figure 8.2](#ch08fig02) shows a view of a microservice handling the load of
    many user requests. This microservice needs to communicate with an external service.
    In this situation, it’s easy for the microservice you’ve developed to become blocked
    as it’s waiting for external service 2 to respond. Worse, you could overload the
    external service to the point it stops functioning completely.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '[图8.2](#ch08fig02) 展示了一个微服务处理多个用户请求负载的视图。这个微服务需要与外部服务进行通信。在这种情况下，你开发的微服务很容易因为等待外部服务2响应而被阻塞。更糟糕的是，你可能会使外部服务过载到完全停止工作的程度。'
- en: Figure 8.2\. Microservice processing user requests without Hystrix
  id: totrans-252
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.2\. 不使用Hystrix处理的微服务用户请求
- en: '![](Images/08fig02_alt.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig02_alt.jpg)'
- en: This is where Hystrix comes in, to be the middleman and mediate your external
    communication in order to mitigate against various failures. [Figure 8.3](#ch08fig03)
    adds Hystrix into the picture, by wrapping your external service calls inside
    `HystrixCommand` instances that use configuration to define its behavior, such
    as the number of available threads.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 正是在这里，Hystrix发挥作用，作为中间人并调解你的外部通信，以减轻各种故障。[图8.3](#ch08fig03) 通过将`HystrixCommand`实例包装在外部服务调用中，并将配置用于定义其行为（例如，可用的线程数）来将Hystrix添加到图中。
- en: In [figure 8.3](#ch08fig03), each external service has a different number of
    threads available to the respective `HystrixCommand`. This is an indication that
    some services might be easier to overload than others, and you need to restrict
    the number of concurrent requests that you send.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图8.3](#ch08fig03)中，每个外部服务都有不同数量的线程可供相应的`HystrixCommand`使用。这表明某些服务可能比其他服务更容易过载，你需要限制你发送的并发请求数量。
- en: Figure 8.3\. Microservice processing user requests with Hystrix
  id: totrans-256
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.3\. 使用Hystrix处理用户请求的微服务
- en: '![](Images/08fig03_alt.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig03_alt.jpg)'
- en: By wrapping external service 2 into a `HystrixCommand`, you’re limiting the
    number of requests that call it from your microservice concurrently. Though you’ve
    added mitigation for interacting with that particular external service, you’ve
    just increased the likelihood of requests failing in your microservice because
    you’re rejecting additional requests out to the external service! Such a situation
    may be fine, or it may not; the outcome depends on the speed with which the external
    request can process your requests.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将外部服务2包装到`HystrixCommand`中，你限制了从你的微服务并发调用它的请求数量。尽管你为与该特定外部服务的交互增加了缓解措施，但你只是增加了请求在微服务中失败的可能性，因为你拒绝了发送到外部服务的额外请求！这种情况可能很好，也可能不好；结果取决于外部请求处理你的请求的速度。
- en: This does raise an important point. Adding failure mitigation to a single micro-service
    within an entire ecosystem isn’t that beneficial. Making your microservice a better
    citizen within the distributed network is great, but if everyone else in the network
    doesn’t have the same mitigation for interacting with your microservice, you’ve
    simply moved where the bottleneck and failure point reside. For this reason, it’s
    critical that failure mitigation is an enterprise-wide concern, or at least within
    a grouping of microservices that all communicate with each other.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实提出了一个重要观点。在整个生态系统中的单个微服务中添加故障缓解并不那么有益。使您的微服务成为分布式网络中的更好公民是很好的，但如果网络中的其他人没有相同的缓解措施来与您的微服务交互，您只是将瓶颈和故障点移动了位置。因此，故障缓解成为企业级关注的问题，或者至少在所有相互通信的微服务组中是至关重要的。
- en: Another advantage to Hystrix that you can see in [figure 8.3](#ch08fig03) is
    the isolation it provides between external services. If calls to external service
    2 weren’t limited, there’s a good chance it could consume all available threads
    within the JVM, preventing your micro-service from handling requests that don’t
    need to interact with external service 2!
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[图8.3](#ch08fig03)中看到的Hystrix的另一个优点是它提供的外部服务之间的隔离。如果对外部服务2的调用没有限制，那么它很可能消耗掉JVM中所有可用的线程，从而阻止您的微服务处理不需要与外部服务2交互的请求！
- en: For the remainder of the chapter, our approach will be to outline the theory
    behind a mitigation strategy for failures, and then show how that strategy is
    implemented within Hystrix. You know you need to mitigate against network failures
    in your code, so what strategies do you have at your disposal?
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，我们的方法将是概述故障缓解策略背后的理论，然后展示该策略如何在Hystrix中实现。您知道您需要在代码中缓解网络故障，那么您有哪些策略可供选择？
- en: 8.3.2\. Circuit breakers
  id: totrans-262
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.2. 电路断路器
- en: If you’re in any way familiar with the way fuses work in your home’s electrical
    panel, you’ll understand the principles of a circuit breaker. [Figure 8.4](#ch08fig04)
    shows that electricity flows through a fuse unhindered unless it’s tripped open,
    causing the flow to be interrupted.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对家中电气面板中保险丝的工作方式有所了解，您就会理解电路断路器的原理。[图8.4](#ch08fig04)显示，除非保险丝被跳闸打开，否则电流会无阻碍地通过保险丝流动。
- en: Figure 8.4\. Electrical circuit-breaker states
  id: totrans-264
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.4. 电气电路断路器状态
- en: '![](Images/08fig04_alt.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/08fig04_alt.jpg)'
- en: The one difference between an electrical panel and software is that a software
    circuit breaker will automatically close itself without manual intervention, based
    on thresholds that have been defined to indicate the level at which it becomes
    unhealthy.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 电气面板和软件之间唯一的区别是，软件电路断路器将根据已定义的阈值自动关闭，这些阈值指示电路变得不健康时的水平。
- en: '[Figure 8.5](#ch08fig05) shows the initial part of a larger flow to mitigate
    against failures when calling external services. As you progress through this
    chapter, additional parts will be added to the flow, providing additional functionality
    to assist with mitigation. This first part focuses on providing a circuit breaker.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '[图8.5](#ch08fig05)显示了缓解调用外部服务时故障的更大流程的初始部分。随着您进入本章，流程中还将添加更多部分，提供额外的功能以帮助缓解。这一部分主要关注提供电路断路器。'
- en: Figure 8.5\. Failure mitigation flow with basic circuit
  id: totrans-268
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.5. 基本电路的故障缓解流程
- en: '![](Images/08fig05.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/08fig05.jpg)'
- en: When the circuit breaker is Closed, all requests continue through the flow.
    When the circuit breaker is Open, the requests exit the flow early. You can see
    in [figure 8.5](#ch08fig05) that your circuit breaker requires Circuit Health
    Data, which is used in determining whether the circuit should be open or closed.
    In addition to the states in [figure 8.5](#ch08fig05), a circuit breaker can be
    in a Half Open state. See [figure 8.6](#ch08fig06).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 当电路断路器处于闭合状态时，所有请求将继续通过流程。当电路断路器处于开路状态时，请求将提前退出流程。您可以在[图8.5](#ch08fig05)中看到，您的电路断路器需要电路健康数据，这些数据用于确定电路应该开启还是关闭。除了[图8.5](#ch08fig05)中的状态外，电路断路器还可以处于半开状态。参见[图8.6](#ch08fig06)。
- en: Figure 8.6\. Circuit-breaker states
  id: totrans-271
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.6. 电路断路器状态
- en: '![](Images/08fig06_alt.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/08fig06_alt.jpg)'
- en: 'Here are the transitions between states of a circuit breaker:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是电路断路器状态之间的转换：
- en: All requests pass through unhindered, as the circuit is Closed.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有请求都能无阻碍地通过，因为电路处于闭合状态。
- en: When a failure threshold is reached, the circuit becomes Open.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当达到故障阈值时，电路变为开路状态。
- en: While the circuit is Open, all requests are rejected, failing fast.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当电路处于开启状态时，所有请求都会被拒绝，快速失败。
- en: The circuit’s Open time-out expires. The circuit moves to Half Open to allow
    a single request to pass.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 电路的开启超时时间到期。电路移动到半开启状态，以允许单个请求通过。
- en: 'The request fails or succeeds:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求失败或成功：
- en: The single request fails, returning the circuit to Open.
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单个请求失败，将电路状态恢复为开启。
- en: The single request succeeds, returning the circuit to Closed.
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单个请求成功，将电路状态恢复为关闭。
- en: In the Half Open state, the circuit breaker is officially still Closed. But
    after a sleep time-out is reached, a single request will be allowed to pass through.
    The success or failure of this single request then determines whether the state
    shifts back to Closed (a single request was successful), or whether it remains
    Open until making another attempt when the next time-out interval is reached.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在半开启状态下，断路器仍然是官方关闭的。但一旦达到睡眠超时时间，将允许单个请求通过。这个单个请求的成功或失败将决定状态是否回到关闭（单个请求成功），或者是否保持开启状态，直到下一次超时间隔到达时再次尝试。
- en: A circuit breaker is only a way to allow or prevent requests from passing through.
    The key piece to it behaving the way you want is the Circuit Health Data. Without
    capturing any Circuit Health Data, the circuit breaker would always remain Closed,
    regardless of how many requests might fail or for what reasons.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 断路器只是允许或阻止请求通过的一种方式。使其按您期望的方式运行的关键部分是电路健康数据。如果没有捕获任何电路健康数据，无论有多少请求失败或是什么原因，断路器都将始终保持关闭状态。
- en: Hystrix provides sensible defaults for a circuit breaker to handle time-outs,
    network congestion, and latency with any request you make. Let’s take a look at
    a simple Hystrix circuit breaker.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: Hystrix为断路器提供了合理的默认设置，以处理任何请求的超时、网络拥塞和延迟。让我们看看一个简单的Hystrix断路器。
- en: Listing 8.1\. `StockCommand`
  id: totrans-284
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.1\. `StockCommand`
- en: '[PRE18]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '***1*** Specify String as the HystrixCommand Type.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 将`String`指定为`HystrixCommand`类型。'
- en: '***2*** Unique key for grouping data in the Hystrix dashboard'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** Hystrix仪表板中用于分组数据的唯一键'
- en: '***3*** Execution of call to external service'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 调用外部服务的执行'
- en: 'You can then call this command synchronously with code such as the following:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下代码同步调用此命令：
- en: '[PRE19]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If you prefer asynchronous execution, you use this:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更喜欢异步执行，您可以使用以下方法：
- en: '[PRE20]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In each of the examples, you’re expecting only a single result from executing
    the request, whether you’re calling it synchronously or asynchronously. For that
    reason, you choose to extend `HystrixCommand`, which caters to single-response
    executions.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个示例中，您都期望从执行请求中只得到一个结果，无论您是同步调用还是异步调用。因此，您选择扩展`HystrixCommand`，它适用于单响应执行。
- en: What happens if you expect multiple responses instead of one? Stock prices change
    extremely frequently, so wouldn’t it be nice to not continually execute another
    call every time you want it updated?
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您期望多个响应而不是一个，会发生什么？股票价格变化非常频繁，所以每次您想要更新时，不是不断地执行另一个调用不是很好吗？
- en: You need to modify your circuit breaker to support a command that returns an
    `Observable` that can emit multiple responses. You’ll subscribe to this `Observable`
    to handle each response as it’s received. Handling each response as it’s returned
    identifies the execution as being *reactive*.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要修改您的断路器以支持返回一个可以发出多个响应的`Observable`的命令。您将订阅此`Observable`以处理接收到的每个响应。将每个响应的处理识别为**反应式**执行。
- en: '|  |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Definition
  id: totrans-297
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义
- en: '*Reactive* is an adjective meaning *acting in response to a situation rather
    than creating or controlling it*. When you’re using an `Observable` and listening
    to results that are emitted from it, you’re *acting in response* to each emitted
    result. An advantage with this approach is that you don’t block while waiting
    for each result to be emitted.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reactive`是一个形容词，意为**对情况做出反应，而不是创造或控制它**。当您使用`Observable`并监听从中发出的结果时，您是在对每个发出的结果做出**反应**。这种方法的优点是，您在等待每个结果发出时不会阻塞。'
- en: '|  |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Let’s modify your command to provide an `Observable`.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改您的命令以提供一个`Observable`。
- en: Listing 8.2\. `StockObservableCommand`
  id: totrans-301
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.2\. `StockObservableCommand`
- en: '[PRE21]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '***1*** Specify String as the HystrixObservableCommand type.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 将`String`指定为`HystrixObservableCommand`类型。'
- en: '***2*** Unique key for grouping data in the Hystrix dashboard'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** Hystrix仪表板中用于分组数据的唯一键'
- en: '***3*** Return an Observable that executes a call to an external service.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 返回一个执行调用外部服务的`Observable`。'
- en: 'If you want the command to be executed as soon as an `Observable` is created,
    you request a hot `Observable`:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望命令在创建 `Observable` 时立即执行，你可以请求一个热 `Observable`：
- en: '[PRE22]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Normally, a hot `Observable` will emit responses whether or not there are subscribers,
    which makes it possible for responses to be lost completely if no one is subscribed.
    But Hystrix uses `ReplaySubject` to capture those responses for you, allowing
    them to be replayed to your own listener when you subscribe to the `Observable`.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，热 `Observable` 会发出响应，无论是否有订阅者，这使得在没有订阅者的情况下，响应可能会完全丢失。但 Hystrix 使用 `ReplaySubject`
    来为你捕获这些响应，允许它们在你订阅 `Observable` 时回放给你的监听器。
- en: 'You could also use a *cold* `Observable` instead:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用一个 *冷* `Observable`：
- en: '[PRE23]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: With a cold `Observable`, the execution isn’t triggered until a listener has
    subscribed to it. This guarantees that any subscriber will receive all notifications
    that the `Observable` has produced.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 对于冷 `Observable`，执行不会在订阅者订阅之前触发。这保证了任何订阅者都将接收到 `Observable` 所产生的所有通知。
- en: Which type of `Observable` to use depends on your situation. If a listener can
    afford to miss some initial data, especially if they’re not the first subscriber
    to an `Observable`, then hot is appropriate. If, however, you want a listener
    to receive all data, then cold is the better choice.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 应该使用哪种类型的 `Observable` 取决于你的情况。如果一个监听器可以承受错过一些初始数据，特别是如果他们不是 `Observable` 的第一个订阅者，那么热
    `Observable` 是合适的。然而，如果你希望监听器接收所有数据，那么冷 `Observable` 是更好的选择。
- en: '|  |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-314
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Though `HystrixCommand` supports returning an `Observable` from its nonreactive
    methods, `execute()` and `queue()`, they’ll always emit only a single value.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `HystrixCommand` 支持从其非响应式方法 `execute()` 和 `queue()` 返回一个 `Observable`，但它们总是只发出单个值。
- en: '|  |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 8.3.3\. Bulkheads
  id: totrans-317
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.3\. 隔舱
- en: Bulkheads in software offer a similar strategy to those in ships, by isolating
    different parts to prevent a failure in one from impacting others. For ships,
    a failure in a single watertight compartment doesn’t spread to others because
    they’re separated by bulkheads.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 软件中的隔舱提供了与船舶中类似的策略，通过隔离不同的部分来防止一个部分的故障影响其他部分。对于船舶来说，单个水密舱的故障不会蔓延到其他部分，因为它们由隔舱分开。
- en: How does a software bulkhead achieve the same result? By shedding the load that
    a microservice is experiencing or is about to experience. A *bulkhead* allows
    you to limit the number of concurrent calls to a component or service, to prevent
    the network from becoming saturated with requests, which would then increase latency
    across all requests in the system. [Figure 8.7](#ch08fig07) adds the bulkhead
    strategy as the next step in your flow.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 软件隔舱是如何达到相同的效果的？通过减轻微服务正在经历或即将经历的压力。*隔舱* 允许你限制对组件或服务的并发调用数量，以防止网络因请求而饱和，这会增加系统中所有请求的延迟。[图
    8.7](#ch08fig07) 将隔舱策略作为你流程中的下一步添加。
- en: Figure 8.7\. Failure mitigation flow with bulkhead
  id: totrans-320
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.7\. 带有隔舱的故障缓解流程
- en: '![](Images/08fig07_alt.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig07_alt.jpg)'
- en: You add a bulkhead after any circuit breaker. There’s no need to check the bulkhead
    if the circuit breaker is Open, because you’re in an error state. When you’re
    in a Closed state, the bulkhead prevents too many requests from being executed
    that could create a network bottleneck.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在任何断路器之后添加隔舱。如果断路器是开启的，不需要检查隔舱，因为你处于错误状态。当你处于关闭状态时，隔舱可以防止执行过多的请求，这可能会创建网络瓶颈。
- en: You may need to call a database service to perform a computation that’s extremely
    intensive and time-consuming, for instance. If you know that the external service
    can take 10 seconds to respond, you don’t want to be sending more than six requests
    a minute to that service. If you send more than six, your requests are queued
    for later processing, which causes your microservice to hold up client requests
    to itself from being released. It’s a vicious cycle that can be hard to break,
    potentially resulting in cascading failures through your microservices. The bulkhead
    in [figure 8.7](#ch08fig07) performs its checks and indicates whether you’re OK
    to continue processing the request or whether it needs to be rejected.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要调用数据库服务来执行非常密集和耗时的计算，例如。如果你知道外部服务可能需要 10 秒来响应，你不想向该服务发送超过每分钟六个请求。如果你发送超过六个，你的请求将被排队等待后续处理，这会导致你的微服务无法释放对客户端请求的控制。这是一个难以打破的恶性循环，可能会导致微服务中的级联故障。[图
    8.7](#ch08fig07) 中的隔舱执行其检查并指示你是否可以继续处理请求或是否需要拒绝。
- en: How would you implement a software bulkhead? Two of the most common approaches
    are counters and thread pools. *Counters* allow you to set a maximum number of
    parallel requests that can be active at any one time. *Thread pools* also limit
    the number of parallel requests that are simultaneously active, but by limiting
    the number of threads available in a pool for executing requests. For a thread-pool
    bulkhead, a specific pool is created to handle requests to a particular external
    service, allowing different external services to be isolated from each other,
    but also isolated from the thread being used to execute your microservice.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 你会如何实现软件舱壁？两种最常见的方法是计数器和线程池。*计数器*允许你设置在任何时候可以同时活跃的最大并行请求数量。*线程池*也限制了同时活跃的并行请求数量，但通过限制池中可用于执行请求的线程数量。对于线程池舱壁，会创建一个特定的池来处理对特定外部服务的请求，允许不同的外部服务相互隔离，同时也与执行你的微服务的线程隔离。
- en: Details of rejected requests are provided to Circuit Health Data so that counters
    can be updated for use the next time that the circuit breaker status needs to
    be calculated.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 被拒绝的请求的详细信息会提供给断路器健康数据，以便更新计数器，以便在下一次需要计算断路器状态时使用。
- en: As a software bulkhead, Hystrix provides execution strategies for thread pools
    (`THREAD`) and counters (`SEMAPHORE`). By default, `HystrixCommand` uses `THREAD`,
    and `HystrixObservableCommand` uses `SEMAPHORE`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 作为软件舱壁，Hystrix为线程池(`THREAD`)和计数器(`SEMAPHORE`)提供了执行策略。默认情况下，`HystrixCommand`使用`THREAD`，而`HystrixObservableCommand`使用`SEMAPHORE`。
- en: '`HystrixObservableCommand` doesn’t need to be bulkheaded by threads, because
    it’s already executing in a separate thread via the `Observable`. You can use
    `THREAD` with `HystrixObservableCommand`, but doing so doesn’t add safety. If
    you wanted to run `StockCommand` in `SEMAPHORE`, it would look like the following
    listing.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`HystrixObservableCommand`不需要通过线程进行舱壁处理，因为它已经通过`Observable`在单独的线程中执行。你可以使用`THREAD`与`HystrixObservableCommand`一起使用，但这样做并不增加安全性。如果你想在`SEMAPHORE`中运行`StockCommand`，它看起来会像以下列表。'
- en: Listing 8.3\. `StockCommand` using `SEMAPHORE`
  id: totrans-328
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.3\. 使用`SEMAPHORE`的`StockCommand`
- en: '[PRE24]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '***1*** Using Setter as a fluent interface to define additional configuration
    for Hystrix'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 使用Setter作为流畅接口来为Hystrix定义额外的配置'
- en: '***2*** Set the execution isolation strategy to SEMAPHORE.'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 将执行隔离策略设置为SEMAPHORE。'
- en: The listing illustrates how to set additional configuration for Hystrix to customize
    the way a particular command behaves. In practice, you wouldn’t use `SEMAPHORE`
    with `HystrixCommand` because it doesn’t provide any ability to set time-outs
    on how long an execution should take. Without time-outs, you can easily find yourself
    with a deadlocked system if the service you consume fails to provide a timely
    response.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 列表说明了如何为Hystrix设置额外的配置以自定义特定命令的行为。在实践中，你不会使用`SEMAPHORE`与`HystrixCommand`一起使用，因为它无法设置执行应该持续多长时间的超时。没有超时，如果消费的服务未能及时提供响应，你很容易发现自己陷入死锁系统。
- en: 8.3.4\. Fallbacks
  id: totrans-333
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.4\. 回退
- en: Currently, when your circuit breaker or bulkhead doesn’t proceed with the request,
    an error response is returned. Though that’s not great, it’s better than your
    micro-service being in a state of waiting until time-out.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，当你的断路器或舱壁不执行请求时，会返回一个错误响应。虽然这并不理想，但总比你的微服务处于等待超时状态要好。
- en: Wouldn’t it be nice if you could provide a simple response in place of the failure?
    In some cases, it certainly may not be possible to provide a common response for
    these situations, but often it’s possible and beneficial.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能提供一个简单的响应来代替失败，那岂不是很好？在某些情况下，可能确实无法为这些情况提供通用的响应，但通常这是可能的，并且是有益的。
- en: In [figure 8.8](#ch08fig08), you can see fallback handling after Circuit Breaker
    and Bulkhead on the failure paths. If the microservice your method wants to consume
    has a fallback handler registered, its response is returned to you. If not, the
    original error is returned.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图8.8](#ch08fig08)中，你可以看到在断路器和舱壁失败路径上的回退处理。如果你想要消费的微服务有一个已注册的回退处理器，它的响应会返回给你。如果没有，则返回原始错误。
- en: Figure 8.8\. Failure mitigation flow with fallback handling
  id: totrans-337
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.8\. 带有回退处理的故障缓解流程
- en: '![](Images/08fig08_alt.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/08fig08_alt.jpg)'
- en: Let’s see how to implement a fallback handler for `StockCommand`.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何为`StockCommand`实现回退处理器。
- en: Listing 8.4\. `StockCommand` with fallback
  id: totrans-340
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.4\. 带有回退的`StockCommand`
- en: '[PRE25]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '***1*** Override the default fallback that throws the failure exception.'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 覆盖默认的抛出失败异常的回退。'
- en: Implementing a fallback handler is a little different when you’re dealing with
    `HystrixObservableCommand`, but not much.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 当你处理`HystrixObservableCommand`时，实现回退处理程序会有所不同，但并不太多。
- en: Listing 8.5\. `StockObservableCommand` with fallback
  id: totrans-344
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.5\. 带有回退的`StockObservableCommand`
- en: '[PRE26]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '***1*** Returns an Observable<String> instead of String to match the command
    response type'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 返回Observable<String>而不是String以匹配命令响应类型'
- en: 8.3.5\. Request caching
  id: totrans-347
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.5\. 请求缓存
- en: Though not directly mitigating against a failure, *request caching* can prevent
    bulkhead and other failures from occurring by reducing the number of requests
    you make on another microservice.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它并不能直接减轻失败，但*请求缓存*可以通过减少你对其他微服务发出的请求数量来防止bulkhead和其他失败的发生。
- en: How does it do that? With a request cache, previous requests and their responses
    can be cached, allowing you to match future requests and return the response from
    the cache instead. [Figure 8.9](#ch08fig09) shows the request cache sitting in
    front of other mitigation strategies as it reduces the number of requests that
    need to pass through any subsequent stages of the flow.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 它是如何做到这一点的呢？通过请求缓存，之前的请求及其响应可以被缓存，这样你就可以匹配未来的请求，并从缓存中返回响应。[图8.9](#ch08fig09)显示了请求缓存位于其他缓解策略之前，因为它减少了需要通过流程后续阶段的请求数量。
- en: Figure 8.9\. Failure mitigation flow with request cache
  id: totrans-350
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.9\. 带有请求缓存的失败缓解流程
- en: '![](Images/08fig09_alt.jpg)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig09_alt.jpg)'
- en: The request cache provides the joint benefits of reducing the number of requests
    passing through your mitigation flow and increasing the speed with which a response
    is returned. Enabling the request cache isn’t appropriate for all situations but
    is beneficial when the data being returned doesn’t change at all or is unlikely
    to have changed during the time your microservice completes its task.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 请求缓存提供了减少通过你的缓解流程的请求数量和提高返回响应速度的双重好处。启用请求缓存并不适用于所有情况，但在返回的数据根本不会改变或在你微服务完成任务期间不太可能改变的情况下是有益的。
- en: This solution is particularly beneficial for reference data or for retrieving
    a user account, as some examples. It allows your microservice to call out to an
    external microservice as many times as needed without fear of increasing network
    traffic. This approach also simplifies the interfaces of your microservices’ internal
    methods and services, as you no longer need to pass around data in your calls
    to prevent an additional call. With a request cache, you have no risk of additional
    calls.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解决方案特别适用于参考数据或用于检索用户账户等情况，因为它允许你的微服务在无需担心增加网络流量的情况下，根据需要多次调用外部微服务。这种方法还简化了微服务内部方法和服务接口，因为你不再需要在调用中传递数据以防止额外的调用。有了请求缓存，你就没有额外的调用风险。
- en: 'To enable the request cache in Hystrix, you need to do two things. First, you
    need to activate `HystrixRequestContext` so you have a means of caching responses:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Hystrix中启用请求缓存，你需要做两件事。首先，你需要激活`HystrixRequestContext`，这样你就有缓存响应的手段：
- en: '[PRE27]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This call needs to occur before executing any Hystrix commands. For our situations,
    you make the first call inside your JAX-RS endpoint method, as you’ll see later.
    Second, you need to define the key to use for caching requests and their responses.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调用需要在执行任何Hystrix命令之前发生。对于我们的情况，你将在稍后看到的JAX-RS端点方法中进行第一次调用。其次，你需要定义用于缓存请求及其响应的键。
- en: Listing 8.6\. `StockCommand` with request cache
  id: totrans-357
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.6\. 带有请求缓存的`StockCommand`
- en: '[PRE28]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '***1*** Override key for request cache with the stock symbol you used in your
    request'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 使用你在请求中使用的股票代码覆盖请求缓存的键'
- en: 8.3.6\. Putting it all together
  id: totrans-360
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.6\. 将所有内容整合在一起
- en: In your flow so far, you have a request cache, circuit breaker, bulkhead, and
    fallback. [Figure 8.10](#ch08fig10) shows how they fit into an actual call.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在你目前的流程中，你已经有了请求缓存、断路器、bulkhead和回退。[图8.10](#ch08fig10)显示了它们在实际调用中的位置。
- en: Figure 8.10\. Entire failure mitigation flow
  id: totrans-362
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.10\. 整个失败缓解流程
- en: '![](Images/08fig10_alt.jpg)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig10_alt.jpg)'
- en: Here you add Execute to indicate that you’re making the call to an external
    service. Any failures or time-outs that Execute experiences feed back into the
    fallback handling, but also provide the failure data to Circuit Health Data. The
    information is then used by the circuit breaker to determine whether error thresholds
    have been reached, and the circuit should switch to Open.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你添加“执行”来表示你正在调用外部服务。执行过程中遇到的任何失败或超时都会反馈到回退处理中，同时也提供失败数据到电路健康数据。然后，断路器使用这些信息来确定是否达到了错误阈值，电路应该切换到开启状态。
- en: '[Figure 8.11](#ch08fig11) takes the flow a step further to show how Hystrix
    provides these features when integrated between your microservice, Service A,
    and one that you consume, Service B.'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '[图8.11](#ch08fig11)进一步展示了Hystrix如何在你的微服务、服务A和你要消费的服务B之间集成时提供这些功能。'
- en: Figure 8.11\. Microservice calls with failure mitigation
  id: totrans-366
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.11\. 具有故障缓解的微服务调用
- en: '![](Images/08fig11_alt.jpg)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/08fig11_alt.jpg)'
- en: As the request enters your Service A method, or endpoint, you create a request
    and pass it to Hystrix. The request passes through whichever checks have been
    enabled before being executed on Service B. A response from Service B passes back
    to your Service A method for any required processing before you construct a response
    for the client.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求进入你的服务A方法或端点时，你创建一个请求并将其传递给Hystrix。请求通过之前启用的任何检查，然后才在服务B上执行。服务B的响应返回到你的服务A方法，进行任何必要的处理，然后你为客户端构造响应。
- en: As you can see, at many points Hystrix can provide a different, or cached, response
    without needing to call Service B directly. Such a flow provides many benefits
    in directly reducing failures, but also in reducing the factors that lead to failure.
    An example is the reduction of microservice load by using a request cache.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在许多点上，Hystrix可以提供不同的或缓存的响应，而无需直接调用服务B。这样的流程在直接减少失败的同时，也减少了导致失败的因素。一个例子是使用请求缓存来减少微服务负载。
- en: Though you’ve been seeing how Hystrix implements these failure mitigation features,
    other libraries or frameworks that provide the same features should operate in
    a similar manner. But the way that other libraries or frameworks implement the
    required mitigation can differ greatly.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你已经看到了Hystrix如何实现这些故障缓解功能，但提供相同功能的其他库或框架应该以类似的方式运行。但其他库或框架实现所需缓解的方式可能差异很大。
- en: 8.3.7\. Hystrix Dashboard
  id: totrans-371
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.7\. Hystrix仪表板
- en: Awesome—you can now improve the reliability of your microservices in a distributed
    architecture. But how can you determine whether a particular microservice is continually
    causing failures? Or whether you need to tune settings to reduce errors and handle
    additional load?
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了——你现在可以改善分布式架构中微服务的可靠性。但你怎么确定特定的微服务是否持续导致失败？或者你是否需要调整设置以减少错误并处理额外的负载？
- en: Sounds like you need a way to monitor how your fault-tolerance library is performing.
    It just so happens that Hystrix provides SSEs (server-sent events), providing
    many details about a particular microservice. You can see and analyze everything—the
    number of hosts running the microservice, requests processed, failures, time-outs,
    and more.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来你需要一种方法来监控你的容错库的性能。恰好Hystrix提供了SSEs（服务器端事件），提供了关于特定微服务的许多详细信息。你可以看到并分析一切——运行微服务的宿主数量、处理的请求、失败、超时等等。
- en: 'Hystrix also provides a way to visualize all these events: the Hystrix Dashboard,
    shown in [figure 8.12](#ch08fig12). The Hystrix Dashboard provides a visual representation
    of the SSEs that it receives from each registered stream. You’ll get to see what
    a stream is shortly.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: Hystrix还提供了一种可视化所有这些事件的方法：Hystrix仪表板，如图8.12所示。Hystrix仪表板提供了它从每个注册流接收到的SSEs的视觉表示。你将很快看到流是什么。
- en: '[Figure 8.12](#ch08fig12) shows the information for the `StockCommand`. There
    are many data points in such a small UI, but some of the most crucial are as follows:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '[图8.12](#ch08fig12)显示了`StockCommand`的信息。在如此小的UI中有很多数据点，但其中一些最重要的如下：'
- en: Figure 8.12\. A single circuit from the Hystrix Dashboard
  id: totrans-376
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.12\. Hystrix仪表板的单个电路
- en: '![](Images/08fig12.jpg)'
  id: totrans-377
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/08fig12.jpg)'
- en: Error percentage in last 10 seconds—100%
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过去10秒内的错误百分比—100%
- en: Number of hosts running the microservice—1
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行微服务的宿主数量—1
- en: Successful requests in last 10 seconds—0
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过去10秒内的成功请求—0
- en: Short-circuited requests that were rejected in the last 10 seconds—40
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在过去10秒内被拒绝的短路请求—40
- en: Failures in last 10 seconds—0
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过去10秒内的失败—0
- en: Circuit is open or closed—Open
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电路是开启还是关闭——开启
- en: '|  |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-385
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Full details of each metric for a circuit can be found at [https://github.com/Netflix/Hystrix/wiki/Dashboard](https://github.com/Netflix/Hystrix/wiki/Dashboard).
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [https://github.com/Netflix/Hystrix/wiki/Dashboard](https://github.com/Netflix/Hystrix/wiki/Dashboard)
    找到每个电路的每个度量指标的详细信息。
- en: '|  |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Let’s see the dashboard in action. Change into the /hystrix-dashboard directory
    and build the project:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看仪表板的实际运行情况。切换到 /hystrix-dashboard 目录并构建项目：
- en: '[PRE29]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'then run the dashboard:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行仪表板：
- en: '[PRE30]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: After the dashboard is started, open a browser and navigate to http://localhost:8090/.
    For the dashboard to visualize metrics data, it needs to get that data from your
    circuit breaker! For a single circuit, you can add the SSE stream directly by
    adding http://localhost:8080/hystrix.stream into the main entry box, as shown
    in [figure 8.13](#ch08fig13). Click the Add Stream button and then click Monitor
    Streams. The main page will load, but until you start your microservice, no SSEs
    are being received in the stream, so the visualization won’t appear yet.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 启动仪表板后，打开浏览器并导航到 http://localhost:8090/。为了使仪表板能够可视化度量数据，它需要从您的断路器获取这些数据！对于单个电路，您可以通过将
    http://localhost:8080/hystrix.stream 直接添加到主输入框中，来直接添加 SSE 流，如图 8.13 所示。点击添加流按钮，然后点击监控流。主页面将加载，但直到您启动微服务，流中不会接收到任何
    SSE，因此可视化尚未出现。
- en: Figure 8.13\. Hystrix Dashboard homepage
  id: totrans-393
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.13\. Hystrix 仪表板主页
- en: '![](Images/08fig13_alt.jpg)'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig13_alt.jpg)'
- en: 'Change to the /chapter8/stock-client directory and start the microservice:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到 /chapter8/stock-client 目录并启动微服务：
- en: '[PRE31]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In another browser window, you can access http://localhost:8080/single/AAPL
    to request the current stock price details represented by the code AAPL. Any valid
    stock code could have been used in the URL path.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个浏览器窗口中，您可以访问 http://localhost:8080/single/AAPL 以请求由代码 AAPL 表示的当前股票价格详情。在
    URL 路径中可以使用任何有效的股票代码。
- en: If you refresh the page, or make multiple requests in another manner, you can
    switch back to the Hystrix Dashboard and see the data on your circuit.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您刷新页面或以其他方式多次请求，您可以通过切换回 Hystrix 仪表板来查看您电路上的数据。
- en: Your stock-client has built-in handling to showcase specific Hystrix functionality.
    For instance, every tenth request will throw an exception back to your consuming
    microservice, and every second request is put to sleep for 10 seconds to trigger
    a time-out. This allows you to see how failures are represented on the dashboard.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 stock-client 内置了处理特定 Hystrix 功能的机制。例如，每第十个请求将抛出异常返回给您的消费微服务，而每第二个请求将被暂停 10
    秒以触发超时。这允许您看到失败如何在仪表板上表示。
- en: To see how request caching works, you can access http://localhost:8080/single/AAPL/4\.
    Note in the console that only a single request was made to the external service,
    and each response to the browser has an identical request number.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看请求缓存的工作方式，您可以访问 http://localhost:8080/single/AAPL/4。注意在控制台中，只对外部服务发出了单个请求，并且浏览器收到的每个响应都有一个相同的请求编号。
- en: 'To fully see your circuit in action, you need to hit the service many times:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全看到电路的实际运行情况，您需要多次调用该服务：
- en: '[PRE32]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This hits your service 100 times in succession, allowing you to monitor the
    circuit in the dashboard as you see the requests come in. You’ll notice a point
    at which too many errors have occurred, causing the circuit breaker to open. Then
    you immediately see all remaining requests short-circuited by not calling the
    microservice and returning the fallback instead. If you wait a few seconds before
    accessing the service through a browser as before, you then see the circuit-breaker
    attempt the request, succeed, and revert to Closed again.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 这将连续对您的服务进行 100 次调用，允许您在看到请求进入时监控仪表板上的电路。您会注意到错误过多导致断路器打开的点。然后您会立即看到所有剩余的请求通过不调用微服务而是返回回退来短路。如果您在通过浏览器访问服务之前等待几秒钟，然后您会看到断路器尝试请求，成功，并再次切换到关闭状态。
- en: Play around with the settings in `StockCommand` to see how the circuit behavior
    changes. One example, which is present in the book’s example code, is to modify
    `StockCommand` to set the number of threads that should be available to consume
    the microservice.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `StockCommand` 中调整设置以查看电路行为如何变化。书中示例代码中的一个例子是将 `StockCommand` 修改为设置可用于消费微服务的线程数量。
- en: Listing 8.7\. `StockCommand` with thread configuration
  id: totrans-405
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.7\. 带有线程配置的 `StockCommand`
- en: '[PRE33]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '***1*** Specifies that a single thread must be used'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 指定必须使用单个线程'
- en: With the [listing 8.7](#ch08ex07) constructor for `StockCommand`, rerunning
    your tests shows requests being rejected by `ThreadPool`.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`StockCommand`的[列表8.7](#ch08ex07)构造函数重新运行你的测试，显示请求被`ThreadPool`拒绝。
- en: After taking a look at the Hystrix Dashboard, we should all appreciate how crucial
    such a tool is in our arsenal. Adding Hystrix to your external calls provides
    a level of fault tolerance to those executions, but it’s not foolproof. You need
    continual real-time monitoring of your microservices to track impending problems
    and observe failures that could be resolved with tuning of circuit-breaker settings.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看Hystrix仪表板后，我们应该都认识到这样的工具在我们的工具箱中是多么关键。将Hystrix添加到你的外部调用中为这些执行提供了容错级别，但它并不是万无一失的。你需要持续实时监控你的微服务，以跟踪即将出现的问题并观察可以通过调整断路器设置来解决的问题。
- en: If you don’t take advantage of what the Hystrix dashboard offers, particularly
    in terms of real-time monitoring, you won’t receive all the benefits of using
    a fault-tolerant library in your code.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有充分利用Hystrix仪表板提供的内容，尤其是在实时监控方面，你将无法获得使用容错库的所有好处。
- en: 8.4\. Adding Hystrix to your Payment microservice
  id: totrans-411
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4\. 将Hystrix添加到你的支付微服务
- en: You’ve seen how Hystrix can be implemented and its metrics viewed from a dashboard.
    Your Stripe microservice isn’t super reliable, so let’s use Hystrix in Payment
    to make sure you’re not overly impacted by its failures or time-outs!
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了如何实现Hystrix以及从仪表板查看其指标。你的Stripe微服务并不非常可靠，所以让我们在支付中使用Hystrix来确保你不会过度受到其失败或超时的负面影响！
- en: The previous sections have covered the various pieces Hystrix offers to help
    with fault mitigation. When adding Hystrix to Payment, you’ll take advantage of
    the full flow that Hystrix provides.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的章节已经介绍了Hystrix提供的各种功能，以帮助进行故障缓解。当将Hystrix添加到支付时，你将充分利用Hystrix提供的完整流程。
- en: 'For each of the next sections, you need your Stripe microservice running, so
    let’s start that now. First you need to make sure that a Minishift environment
    is running and that you’ve logged into it with the OpenShift client. Then change
    to the /chapter8/stripe directory and run this:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的每个部分中，你需要你的Stripe微服务正在运行，所以让我们现在开始。首先，你需要确保Minishift环境正在运行，并且你已经使用OpenShift客户端登录。然后切换到/chapter8/stripe目录并运行以下命令：
- en: '[PRE34]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 8.4.1\. Hystrix with the RESTEasy client
  id: totrans-416
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.4.1\. 使用RESTEasy客户端的Hystrix
- en: Let’s modify Payment from [chapter 7](kindle_split_017.xhtml#ch07) with a `HystrixCommand`
    for interacting with Stripe.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改[第7章](kindle_split_017.xhtml#ch07)中的Payment，使用`HystrixCommand`与Stripe交互。
- en: Listing 8.8\. `StripeCommand`
  id: totrans-418
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.8\. `StripeCommand`
- en: '[PRE35]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '***1*** Pass the Stripe URL and ChargeRequest into the command and set up properties.'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 将Stripe URL和ChargeRequest传递到命令中并设置属性。'
- en: '***2*** Overloaded constructor allowing Hystrix properties to be set up by
    caller'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 允许调用者设置Hystrix属性的重载构造函数'
- en: '***3*** Equivalent to PaymentServiceResource method in [chapter 7](kindle_split_017.xhtml#ch07),
    as call is no longer made in JAX-RS Resource'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 等同于[第7章](kindle_split_017.xhtml#ch07)中`PaymentServiceResource`的方法，因为不再在JAX-RS
    Resource中进行调用'
- en: '***4*** Fallback to empty ChargeResponse if there was a problem.'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** 如果有问题，回退到空的ChargeResponse。'
- en: Now that you have your `StripeCommand`, how different does `PaymentServiceResource`
    from [chapter 7](kindle_split_017.xhtml#ch07) look?
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了你的`StripeCommand`，`PaymentServiceResource`与[第7章](kindle_split_017.xhtml#ch07)相比有何不同？
- en: Listing 8.9\. `PaymentServiceResource`
  id: totrans-425
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.9\. `PaymentServiceResource`
- en: '[PRE36]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '***1*** Instantiate command and set Hystrix properties.'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 实例化命令并设置Hystrix属性。'
- en: '***2*** Block on command execute().'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 在命令执行()上阻塞。'
- en: '***3*** Instantiate command with default Hystrix properties.'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 使用默认的Hystrix属性实例化命令。'
- en: '***4*** Get Observable for command.'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** 获取命令的Observable。'
- en: '***5*** Subscribe to the Observable, passing success and failure methods.'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** 订阅Observable，传递成功和失败方法。'
- en: Your `PaymentServiceResource` has shown that when expecting only a single response,
    you’re able to easily switch between synchronous and asynchronous execution modes
    with the same `HystrixCommand` implementation.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 你的`PaymentServiceResource`已经表明，当期望只有一个响应时，你可以轻松地在同步和异步执行模式之间切换，使用相同的`HystrixCommand`实现。
- en: It didn’t take much of a refactor from your [chapter 7](kindle_split_017.xhtml#ch07)
    version to this one, mostly extracting out the code that consumes the external
    microservice into a new method and class, `StripeCommand`.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 从你的[第7章](kindle_split_017.xhtml#ch07)版本到这个版本，重构并不多，主要是将消耗外部微服务的代码提取到一个新的方法和类`StripeCommand`中。
- en: 'Now that you’ve refactored your resources, let’s run it! Change to the /chapter8/
    resteasy-client directory and run this:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经重构了资源，让我们运行它！切换到 /chapter8/resteasy-client 目录并运行以下命令：
- en: '[PRE37]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If the Hystrix Dashboard is still running, head back to the homepage so you
    can add a new stream. If it’s not still running, start it up again as you did
    earlier in the chapter.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Hystrix Dashboard 仍在运行，请返回主页以便您可以添加新的流。如果它尚未运行，请像本章早期那样重新启动它。
- en: Copy the URL for chapter8-resteasy-client from the OpenShift console, paste
    it into the text box on the Hystrix Dashboard homepage, and add hystrix.stream
    as a URL suffix. Click Add Stream and then Monitor Streams.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 从 OpenShift 控制台复制 chapter8-resteasy-client 的 URL，将其粘贴到 Hystrix Dashboard 主页上的文本框中，并添加
    hystrix.stream 作为 URL 后缀。点击添加流然后监控流。
- en: The Hystrix Dashboard won’t show anything immediately because you haven’t made
    any requests yet. To exercise the Payment service, you can execute either single
    requests or multiple requests, with the latter being easier to see results in
    the dashboard, especially if their execution can be automated.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您尚未发出任何请求，Hystrix Dashboard 不会立即显示任何内容。为了练习 Payment 服务，您可以执行单个请求或多个请求，后者在仪表板中更容易看到结果，尤其是如果它们的执行可以自动化。
- en: With the URL for chapter8-resteasy-client from earlier, you can access the synchronous
    (`/sync`) or asynchronous `(/async`) versions of the service. After starting a
    series of requests on either, or both, of those endpoints, the Hystrix Dashboard
    will show all the details of successful and failed requests that have been made.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 使用之前章节 8.4-resteasy-client 的 URL，您可以访问服务的同步版本 (`/sync`) 或异步版本 (`/async`)。在任一或两个端点启动一系列请求后，Hystrix
    Dashboard 将显示已成功和失败的请求的所有详细信息。
- en: 8.4.2\. Hystrix with the Ribbon client
  id: totrans-440
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.4.2\. 使用 Ribbon 客户端的 Hystrix
- en: Your RESTEasy client required a little bit of rework to add Hystrix support.
    Now you’ll take a look at what’s required for the Ribbon client.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 RESTEasy 客户端需要一点修改以添加 Hystrix 支持。现在您将查看 Ribbon 客户端所需的操作。
- en: First, you need to update your interface definition for the Stripe microservice
    so that it takes advantage of Hystrix annotations with Ribbon.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要更新 Stripe 微服务的接口定义，以便利用 Hystrix 注解与 Ribbon 结合。
- en: Listing 8.10\. `StripeService`
  id: totrans-443
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.10\. `StripeService`
- en: '[PRE38]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '***1*** Adds Hystrix functionality into your Ribbon HTTP request, with a fallback
    handler'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 将 Hystrix 功能添加到您的 Ribbon HTTP 请求中，并带有回退处理程序'
- en: That was easy—only a few extra lines!
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单——只需几行额外的代码！
- en: '|  |'
  id: totrans-447
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-448
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Hystrix annotations are available only for use in combination with Netflix Ribbon.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: Hystrix 注解仅可用于与 Netflix Ribbon 结合使用。
- en: '|  |'
  id: totrans-450
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Right now, the code won’t compile because you don’t have the class for the fallback
    handler. Let’s add that.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，代码无法编译，因为您没有回退处理程序的类。让我们添加它。
- en: Listing 8.11\. `StripeServiceFallbackHandler`
  id: totrans-452
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.11\. `StripeServiceFallbackHandler`
- en: '[PRE39]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '***1*** Implement getFallback() to return whatever you choose in the fallback
    case.'
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 实现 getFallback() 以在回退情况下返回您选择的任何内容。'
- en: '***2*** Create an empty ChargeResponse to use for fallback and convert to byte[].'
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 创建一个空的 ChargeResponse 用于回退，并将其转换为 byte[]。'
- en: '***3*** Write byte[] into ByteBuf that you created on the previous line.'
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 将 byte[] 写入您在上一个步骤中创建的 ByteBuf。'
- en: '***4*** Create an Observable that returns the ByteBuf content as a single result.'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** 创建一个 Observable，它返回作为单个结果的 ByteBuf 内容。'
- en: The last piece you need is to update `PaymentServiceResource` from [chapter
    7](kindle_split_017.xhtml#ch07). But not so! One advantage of using Hystrix with
    Ribbon when using annotations is that your `PaymentServiceResource` from [chapter
    7](kindle_split_017.xhtml#ch07) doesn’t need to change at all. A big advantage
    is that you can easily add Hystrix into an existing microservice that uses Ribbon
    without refactoring. Simply add an extra annotation and a fallback handler, if
    needed.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要更新 `PaymentServiceResource`，来自 [第 7 章](kindle_split_017.xhtml#ch07)。但不是这样！使用
    Hystrix 与 Ribbon 结合使用注解的一个优点是，您从 [第 7 章](kindle_split_017.xhtml#ch07) 的 `PaymentServiceResource`
    完全不需要更改。一个很大的优点是，您可以在使用 Ribbon 的现有微服务中轻松添加 Hystrix 而无需重构。只需添加一个额外的注解，如果需要，还可以添加一个回退处理程序。
- en: 'Time to run it! Change to the /chapter8/ribbon-client directory and run this:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候运行它了！切换到 /chapter8/ribbon-client 目录并运行以下命令：
- en: '[PRE40]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As with the RESTEasy client example, you can open a browser and access /sync
    or /async URLs of the service, using the base URL from the OpenShift console for
    the service. You can then update the Hystrix Dashboard to use this new stream,
    execute some requests, and see how the dashboard changes.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 就像RESTEasy客户端示例一样，您可以通过浏览器打开并访问服务的/sync或/async URL，使用OpenShift控制台中的服务基本URL。然后，您可以更新Hystrix仪表板以使用此新流，执行一些请求，并查看仪表板如何变化。
- en: 'As with other examples you’ve deployed to Minishift, after you’re finished,
    you need to undeploy them to free up the resources:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 就像您部署到Minishift的其他示例一样，完成后，您需要取消部署以释放资源：
- en: '[PRE41]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Summary
  id: totrans-464
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Latency and fault tolerance are important when considering deployments to a
    distributed architecture, as it can adversely affect the throughput and speed
    of your microservices.
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当考虑部署到分布式架构时，延迟和容错性很重要，因为它可能会对微服务的吞吐量和速度产生不利影响。
- en: Your code that consumes microservices can be wrapped with Hystrix to incorporate
    fault-tolerant features such as fallback, request caching, and bulkheads.
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您消费微服务的代码可以用Hystrix包装，以集成容错特性，如回退、请求缓存和隔离舱。
- en: Hystrix alone is not a panacea for supreme fault tolerance. Real-time monitoring,
    through a tool such as the Hystrix Dashboard, is crucial to successfully improving
    overall fault tolerance.
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hystrix本身并不是最高容错性的万能药。通过像Hystrix仪表板这样的工具进行实时监控对于成功提高整体容错性至关重要。
- en: Chapter 9\. Securing a microservice
  id: totrans-468
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第9章. 保护微服务
- en: '*This chapter covers*'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Understanding why you need secure microservices
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解为什么你需要安全的微服务
- en: Securing a microservice
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护微服务
- en: Consuming a secured microservice
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费一个受保护的微服务
- en: Interacting with secured microservices from a UI
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从UI与受保护的微服务交互
- en: In this chapter, you’ll expand on previous examples by adding various types
    of security to them. First you will learn about the different kinds of security
    that you might need to consider when designing and developing microservices.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将通过向它们添加各种类型的安全性来扩展先前的示例。首先，您将了解在设计和发展微服务时可能需要考虑的不同类型的安全性。
- en: 9.1\. The importance of securing your microservice
  id: totrans-475
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1\. 保护微服务的重要性
- en: Securing your microservice is a critical task that needs to be thought out from
    the beginning of development. Not doing so early results in greater development
    time for integrating security later. Why? Not designing for security results in
    code that might need major refactoring to do so at a later date.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 保护微服务是一项至关重要的任务，需要在开发初期就考虑。如果不这样做，后期集成安全性的开发时间会更长。为什么？不设计安全性会导致代码可能需要在以后进行重大重构才能实现。
- en: Though not taking security into account before development on a typical Enterprise
    Java application can easily add months to the development schedule, at least with
    microservices you usually have a lot less code to be refactored. Even so, isn’t
    it better to design for security up front and save time?
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在典型企业Java应用程序的开发之前不考虑安全性可能会轻易增加几个月的开发时间，但至少在微服务中，您通常需要重构的代码要少得多。即便如此，不是最好一开始就设计安全性并节省时间吗？
- en: 9.1.1\. Why is security important?
  id: totrans-478
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.1\. 为什么安全性很重要？
- en: As enterprise developers, we’re often called on to develop myriad applications,
    with the end user of the application varying between internal or external, and
    sometimes both. [Figure 9.1](#ch09fig01) shows a microservice used by a small
    group of internal users.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 作为企业开发者，我们经常被要求开发各种应用程序，应用程序的最终用户可能是内部或外部，有时两者都是。[图9.1](#ch09fig01) 展示了一组内部用户使用的微服务。
- en: Figure 9.1\. Internal users
  id: totrans-480
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.1\. 内部用户
- en: '![](Images/09fig01_alt.jpg)'
  id: totrans-481
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig01_alt.jpg)'
- en: With these requirements, it’d be fair to determine that you can ignore security,
    right? Wrong!
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 有这些要求，你就可以忽略安全性，对吧？错！
- en: Even when you’re developing a microservice for internal users only, can you
    guarantee that the security surrounding your microservice will hold? What happens
    if, or when, any security barriers preventing external network intrusions are
    breached?
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您只为内部用户开发微服务，您能保证围绕您的微服务的安全性会保持吗？如果或当任何防止外部网络入侵的安全屏障被破坏时会发生什么？
- en: '[Figure 9.2](#ch09fig02) shows how a malicious user, external to the network,
    would have uninhibited access to a microservice if network security is breached.'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9.2](#ch09fig02) 展示了如果网络安全被破坏，恶意用户（网络外部）将如何无限制地访问微服务。'
- en: Figure 9.2\. Malicious external user
  id: totrans-485
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.2\. 恶意外部用户
- en: '![](Images/09fig02.jpg)'
  id: totrans-486
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig02.jpg)'
- en: Security is a feature that should never be taken for granted, no matter what
    precautions might be implemented. A common misconception is that security is infallible,
    which is certainly not the case.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 安全是一个不应该被理所当然地认为存在的功能，无论可能实施哪些预防措施。一个常见的误解是安全是无可挑剔的，这当然不是事实。
- en: Looking again at [figure 9.2](#ch09fig02), if you don’t consider an internal
    network secure, you’re more inclined to add extra security within your own microservice
    to prevent unpermitted access to it. If every application or microservice that’s
    purely for internal purposes doesn’t include its own security precautions, you’ve
    made the security at the boundary of the external network a single point of failure.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 再次查看[图9.2](#ch09fig02)，如果你不认为内部网络是安全的，你更倾向于在自己的微服务中添加额外的安全措施，以防止未经授权的访问。如果纯粹用于内部目的的每个应用程序或微服务都不包括自己的安全预防措施，那么你已将外部网络边界的安全性变成了一个单点故障。
- en: 'That’s not even considering the case where you may have a malicious user *within*
    the internal network, as shown in [figure 9.3](#ch09fig03)! Though having an internal
    malicious user may not be common, this situation can’t be discounted. This situation
    can occur for many reasons: disgruntled employee or corporate espionage the most
    likely.'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 这还不包括你可能在内部网络中有一个恶意用户的情况，如[图9.3](#ch09fig03)所示！尽管内部恶意用户可能并不常见，但这种情况不能被忽视。这种情况可能由许多原因引起：不满的员工或企业间谍活动最有可能。
- en: Few types of applications are developed that don’t need security. Those applications
    are mostly limited to serving read-only data that’s available to the general public
    already.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎没有开发的应用程序不需要安全。这些应用程序大多仅限于提供对公众已经可用的只读数据的读取。
- en: Figure 9.3\. Malicious internal user
  id: totrans-491
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.3. 恶意内部用户
- en: '![](Images/09fig03_alt.jpg)'
  id: totrans-492
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/09fig03_alt.jpg)'
- en: That’s a fairly narrow definition of an application for which you can ignore
    security. How many of these are your enterprise’s building every day? Probably
    none! Applications of this type that an enterprise has developed, or will, in
    its entire lifetime, would be extremely small in number. Static data that’s also
    publicly available doesn’t interest an enterprise.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当狭窄的应用定义，你可以忽略安全。你的企业每天在建造多少这样的应用？可能没有！企业在其整个生命周期中开发或将要开发的应用程序类型，数量会非常少。静态数据也是公开可用的，这不会引起企业的兴趣。
- en: What does all that mean? It means that no application or microservice can ignore
    security, at all, ever.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些意味着什么？这意味着没有任何应用程序或微服务可以完全忽视安全，任何时候都不可以。
- en: 9.1.2\. What problems does security need to solve?
  id: totrans-495
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.2. 安全需要解决哪些问题？
- en: Now that you know you need security, what kind of problems do you need to solve?
    That in itself could be the sole topic for a book! Because you’re not looking
    to re-create *War and Peace* for microservices, you’ll focus on the areas that
    would be of most interest.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你知道你需要安全，你需要解决哪些问题？这本身可能就是一本书的主题！因为你不是要为微服务重新创作《战争与和平》，所以你会关注那些最有兴趣的领域。
- en: Authentication and authorization are the two aspects of security that are the
    most relevant to microservices for us. Before you delve too deeply, you need to
    outline what each of these terms means.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 认证和授权是我们认为与微服务最相关的两个安全方面。在你深入探讨之前，你需要概述每个这些术语的含义。
- en: '*Authentication* is illustrated in [figures 9.1](#ch09fig01), [9.2](#ch09fig02),
    and [9.3](#ch09fig03). It deals solely with whether a user has the right to access
    an application or microservice. It doesn’t matter where that application or microservice
    might be hosted, or even whether a user belongs to the enterprise or is external.
    Authentication is purely concerned with a user being able to access an application.'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '*认证*在[图9.1](#ch09fig01)、[9.2](#ch09fig02)和[9.3](#ch09fig03)中展示。它仅涉及用户是否有权访问应用程序或微服务。无论该应用程序或微服务可能托管在哪里，或者用户是否属于企业或外部，认证纯粹关注用户能否访问应用程序。'
- en: If a microservice doesn’t need to distinguish between users beyond whether or
    not they’re allowed, authentication is all that’s needed. But if users who’ve
    been authenticated require different levels of access to different parts of an
    application or microservice, you also need *authorization*.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 如果微服务不需要区分用户是否允许访问，那么认证就是所需的全部。但如果经过认证的用户需要访问应用程序或微服务的不同部分，那么你还需要*授权*。
- en: '[Figure 9.4](#ch09fig04) provides an example of user roles that could be used
    for authorization of a microservice.'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9.4](#ch09fig04) 提供了一个用于微服务授权的用户角色示例。'
- en: Figure 9.4\. Multiple user roles for authorization
  id: totrans-501
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.4. 多个用户角色用于授权
- en: '![](Images/09fig04_alt.jpg)'
  id: totrans-502
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig04_alt.jpg)'
- en: You see the roles of Admin, Manager, and User, all fairly typical roles that
    might be required. Whatever roles might be required for your microservice will
    vary, potentially from zero to many, depending on the requirements.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到Admin、Manager和User这些角色，这些都是可能需要的典型角色。对于你的微服务可能需要的角色可能会有所不同，可能从零到多个，这取决于需求。
- en: An enterprise may also have microservices, as shown in [figure 9.5](#ch09fig05).
    In this case, you have a microservice administered by an internal user, with the
    role of Admin. But the User of the microservice is external to the enterprise.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 企业也可能拥有微服务，如图9.5所示。在这种情况下，你有一个由内部用户管理的微服务，其角色为Admin。但微服务的用户对企业来说是外部的。
- en: Figure 9.5\. Internal and external user roles
  id: totrans-505
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.5. 内部和外部用户角色
- en: '![](Images/09fig05.jpg)'
  id: totrans-506
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig05.jpg)'
- en: From the perspective of an entire application that may comprise many microservices,
    you usually need a mixture of authentication and authorization to satisfy security
    requirements. For an individual microservice within an application, you may need
    to concern yourself with only authentication of a user’s request and nothing more.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 从整个可能包含许多微服务的应用程序的角度来看，你通常需要认证和授权的混合来满足安全需求。对于应用程序中的单个微服务，你可能只需要关注用户请求的认证，而无需更多。
- en: Whatever your microservice might require—whether it be authentication, authorization,
    or both—security needs to be considered during design to ensure that it isn’t
    a last-minute concern.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你的微服务可能需要什么——无论是认证、授权还是两者兼而有之——在设计阶段就需要考虑安全性，以确保它不会成为最后一刻的担忧。
- en: So how do you go about adding security into your microservices? You can certainly
    develop your own security solution, but that’s far from ideal in many situations.
    You’d have to spend time developing it, maintaining it, and so forth. Developing
    your own security solution not only results in a delayed start to developing what
    you want, your microservice, but also creates an additional maintenance burden
    for future developers.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 那么你是如何将安全性添加到你的微服务中的呢？你当然可以开发自己的安全解决方案，但在许多情况下这并不理想。你需要花费时间开发、维护等等。开发自己的安全解决方案不仅会导致你想要开发的微服务开发延迟，而且还会给未来的开发者增加额外的维护负担。
- en: What you want to do is take advantage of a solid project that’s developed and
    maintained by a large group of developers and that provides the security use cases
    you need to handle. Though you might have many possible options for such a project
    available, in this book we’ll choose Keycloak.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要做的是利用一个由大量开发者开发和维护的稳定项目，该项目提供了你需要的处理安全用例。尽管你可能有很多这样的项目选项，但在这本书中，我们将选择Keycloak。
- en: 9.2\. Working with Keycloak
  id: totrans-511
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2. 使用Keycloak
- en: Keycloak is an open source project providing identity and access management
    for modern applications and services. Adding authentication to applications and
    securing services can be achieved with a minimum of fuss.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: Keycloak是一个开源项目，为现代应用程序和服务提供身份和访问管理。向应用程序添加认证和确保服务安全可以以最小的麻烦实现。
- en: 9.2.1\. Understanding Keycloak’s features
  id: totrans-513
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.1. 理解Keycloak的功能
- en: 'Keycloak provides many features. Here are four most relevant for microservice
    development:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: Keycloak提供了许多功能。以下是四个与微服务开发最相关的功能：
- en: '***Single-sign on*—** Allows users to authenticate against Keycloak rather
    than each individual application or service. After users log in to Keycloak, they
    can access any application or service that’s authenticated through Keycloak.'
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***单点登录*——** 允许用户对Keycloak进行认证，而不是对每个单独的应用程序或服务进行认证。用户登录Keycloak后，可以访问任何通过Keycloak进行认证的应用程序或服务。'
- en: '***Social login*—** It’s super easy to enable social logins with Keycloak!
    Configure the social network within the admin console and go. No code or application
    changes are required.'
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***社交登录*——** 使用Keycloak启用社交登录非常简单！在管理控制台中配置社交网络即可。无需代码或应用程序更改。'
- en: '***User federation*—** If your users are registered within LDAP or Active Directory,
    they can easily be federated with Keycloak. It’s also possible to develop your
    own provider to access your users, if they’re in different types of stores, such
    as a relational database.'
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***用户联合*—** 如果您的用户在LDAP或Active Directory中注册，他们可以很容易地与Keycloak联合。如果用户存储在不同的类型中，例如关系数据库，您还可以开发自己的提供程序来访问您的用户。'
- en: '***Standard protocols*—** Out of the box, Keycloak provides support for OpenID
    Connect, OAuth 2.0, and Security Assertion Markup Language (SAML).'
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***标准协议*—** 默认情况下，Keycloak提供了对OpenID Connect、OAuth 2.0和安全断言标记语言(SAML)的支持。'
- en: Full details on Keycloak and all its features can be found on its website, [www.keycloak.org](http://www.keycloak.org).
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Keycloak及其所有功能的详细信息可以在其网站上找到，[www.keycloak.org](http://www.keycloak.org)。
- en: 9.2.2\. Setting up Keycloak
  id: totrans-520
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.2\. 设置Keycloak
- en: The first thing you need to do is download the Keycloak server for your microservices
    and applications to integrate with. For our purposes, you have two ways of doing
    that. You could download a full WildFly distribution customized for Keycloak or
    download a Keycloak server built with Thorntail. To keep with the microservices
    way of doing things, choose the Thorntail version. The version you need for our
    examples is downloadable from [http://mng.bz/s6r9](http://mng.bz/s6r9).
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要做的第一件事是为您的微服务和应用程序下载Keycloak服务器以进行集成。就我们的目的而言，您有两种方法可以做到这一点。您可以下载一个为Keycloak定制的完整WildFly发行版，或者下载一个使用Thorntail构建的Keycloak服务器。为了保持微服务的方式，请选择Thorntail版本。我们示例所需的版本可以从[http://mng.bz/s6r9](http://mng.bz/s6r9)下载。
- en: 'After downloading, start this version on a separate port so it doesn’t interfere
    with your own microservices:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 下载后，在单独的端口上启动此版本，以免干扰您自己的微服务：
- en: '[PRE42]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: When the server is started, in a browser navigate to http://localhost:9090/auth/.
    You’ll see a screen like the one in [figure 9.6](#ch09fig06).
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器启动后，在浏览器中导航到 http://localhost:9090/auth/。您将看到一个类似于[图9.6](#ch09fig06)的屏幕。
- en: Figure 9.6\. Setting up the Keycloak Admin user
  id: totrans-525
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.6\. 设置Keycloak管理员用户
- en: '![](Images/09fig06_alt.jpg)'
  id: totrans-526
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig06_alt.jpg)'
- en: Enter a username and password for an administrator account on the Keycloak server.
    Then click Create. Next, click the Administration Console link to see the login
    screen in [figure 9.7](#ch09fig07).
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 在Keycloak服务器上输入管理员账户的用户名和密码。然后点击创建。接下来，点击管理控制台链接以查看[图9.7](#ch09fig07)中的登录屏幕。
- en: Figure 9.7\. Logging into the Keycloak administration console
  id: totrans-528
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.7\. 登录Keycloak管理控制台
- en: '![](Images/09fig07_alt.jpg)'
  id: totrans-529
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig07_alt.jpg)'
- en: Enter the credentials you provided when setting up the administrator account,
    and then click the Log In button.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 输入您在设置管理员账户时提供的凭据，然后点击登录按钮。
- en: '[Figure 9.8](#ch09fig08) shows the main screen of the Keycloak administration
    console. From here, all parts of Keycloak can be modified and adjusted to suit
    your needs. By default, you’re given a Master realm.'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9.8](#ch09fig08)显示了Keycloak管理控制台的主屏幕。从这里，您可以修改和调整Keycloak的所有部分以满足您的需求。默认情况下，您会获得一个主域。'
- en: Figure 9.8\. Keycloak administration console
  id: totrans-532
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.8\. Keycloak管理控制台
- en: '![](Images/09fig08_alt.jpg)'
  id: totrans-533
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig08_alt.jpg)'
- en: Because the Master realm contains the admin user, it’s good practice to not
    use this realm for users who are authenticating with applications or microservices.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 由于主域包含管理员用户，因此对于使用应用程序或微服务进行身份验证的用户，不使用此域是一种良好的做法。
- en: '|  |'
  id: totrans-535
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Keycloak realms**'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '**Keycloak域**'
- en: A Keycloak *realm* manages a set of users, along with their credentials, roles,
    and groups. Realms are isolated from each other and are responsible for managing
    only the users they’re associated with.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: Keycloak *域*管理一组用户，包括他们的凭据、角色和组。域彼此隔离，只负责管理他们关联的用户。
- en: Realms provide a way to segregate groups of users for different purposes. You
    might have a realm for finance microservices and another realm for people management
    microservices. This separation ensures that users from each realm remain separate
    but are managed from a single Keycloak instance.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 域提供了一种将用户分组分离用于不同目的的方法。您可能有一个用于财务微服务的域，另一个用于人员管理微服务的域。这种分离确保了来自每个域的用户保持分离，但由单个Keycloak实例进行管理。
- en: '|  |'
  id: totrans-539
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Depending on your needs, Keycloak is flexible enough to handle any situation
    that your application or microservice requires. A common requirement for typical
    application development, but still relevant for microservices, is the need to
    authenticate a user and use their credentials when calling services.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的需求，Keycloak 足够灵活，可以处理应用程序或微服务所需的任何情况。对于典型的应用程序开发，尽管对于微服务仍然相关，但通常需要认证用户并在调用服务时使用其凭证。
- en: '[Figure 9.9](#ch09fig09) lays out the path a request would take to authenticate
    a user within a UI.'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9.9](#ch09fig09) 展示了在 UI 内部对用户进行认证的请求路径。'
- en: Figure 9.9\. User authentication via a UI
  id: totrans-542
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.9\. 通过 UI 进行用户认证
- en: '![](Images/09fig09_alt.jpg)'
  id: totrans-543
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig09_alt.jpg)'
- en: 'The authentication steps are as follows:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 认证步骤如下：
- en: The user requests to log into the application UI.
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户请求登录应用程序 UI。
- en: The UI redirects to Keycloak to perform the login. Keycloak returns tokens that
    can be used to issue authenticated requests.
  id: totrans-546
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: UI 重定向到 Keycloak 进行登录。Keycloak 返回可用于发出认证请求的令牌。
- en: The user chooses to load a view requiring authentication.
  id: totrans-547
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户选择加载需要认证的视图。
- en: A *bearer token* provided by Keycloak is added to the HTTP headers of the request.
  id: totrans-548
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Keycloak 提供的 *bearer 令牌* 被添加到请求的 HTTP 头部。
- en: The token is extracted from the request and passed to Keycloak for validation.
    If the token is valid, the secured microservice is able to process the request.
    If the token isn’t valid, an HTTP 401 status is returned to indicate that an unauthorized
    user made a request.
  id: totrans-549
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从请求中提取令牌并将其传递给 Keycloak 进行验证。如果令牌有效，受保护的微服务能够处理请求。如果令牌无效，则返回 HTTP 401 状态码，表示未经授权的用户发出了请求。
- en: '|  |'
  id: totrans-550
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Definition
  id: totrans-551
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义
- en: A *bearer token* is a security token with a special behavioral property. Any
    party in possession of the token can use it in any way that any other party in
    possession of the same token could. Using a bearer token doesn’t require the holder
    to prove possession of the cryptographic key.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: '*bearer 令牌* 是一种具有特殊行为属性的安全令牌。任何持有令牌的实体都可以像持有相同令牌的其他实体一样使用它。使用 bearer 令牌不需要持有人证明对加密密钥的占有。'
- en: '|  |'
  id: totrans-553
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: A slight variation on the preceding process involves one microservice authenticating
    itself to issue requests against a secured microservice. [Figure 9.10](#ch09fig10)
    illustrates this variation.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的过程中，有一个微服务对自身进行认证以向受保护的微服务发出请求的微小变化。[图 9.10](#ch09fig10) 说明了这种变化。
- en: Figure 9.10\. Microservice authentication
  id: totrans-555
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.10\. 微服务认证
- en: '![](Images/09fig10.jpg)'
  id: totrans-556
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig10.jpg)'
- en: 'This process differs in that whatever calls the secured microservice doesn’t
    contain or receive an authentication token from a user:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程的不同之处在于，调用受保护微服务的任何调用者都不包含或接收来自用户的认证令牌：
- en: The request is received by a microservice that isn’t secured.
  id: totrans-558
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求被一个未受保护的微服务接收。
- en: The unsecured microservice authenticates itself against Keycloak.
  id: totrans-559
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 未受保护的微服务对 Keycloak 进行自身认证。
- en: The bearer token is passed in the HTTP headers of the request to the secured
    microservice.
  id: totrans-560
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 认证令牌通过请求的 HTTP 头部传递给受保护的微服务。
- en: The token is extracted from the request and passed to Keycloak for validation.
    If the token is valid, the secured microservice can process the request. If the
    token isn’t valid, an HTTP 401 status is returned to indicate that an unauthorized
    user made a request.
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从请求中提取令牌并将其传递给 Keycloak 进行验证。如果令牌有效，受保护的微服务可以处理请求。如果令牌无效，则返回 HTTP 401 状态码，表示未经授权的用户发出了请求。
- en: The remainder of this chapter presents examples for both of these scenarios.
    Let’s see how you can use Keycloak to secure some microservices.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的剩余部分将提供这两个场景的示例。让我们看看如何使用 Keycloak 保护一些微服务。
- en: 9.3\. Securing the Stripe microservice
  id: totrans-563
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3\. 保护 Stripe 微服务
- en: In this section, you’ll look at how authentication works in the scenario in
    [figure 9.10](#ch09fig10). Stripe and Payment microservices from [chapter 8](kindle_split_018.xhtml#ch08)
    will be implemented with security like [figure 9.10](#ch09fig10). The Payment
    microservice will be based on the RESTEasy client version from that chapter. Let’s
    take a look at the previous scenario, this time with Stripe and Payment; see [figure
    9.11](#ch09fig11).
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将了解如何在[图 9.10](#ch09fig10)的场景中实现认证。来自[第 8 章](kindle_split_018.xhtml#ch08)的
    Stripe 和 Payment 微服务将采用与[图 9.10](#ch09fig10)类似的安保措施。Payment 微服务将基于该章节中的 RESTEasy
    客户端版本。让我们回顾一下之前的场景，这次是 Stripe 和 Payment；请参见[图 9.11](#ch09fig11)。
- en: Figure 9.11\. Microservice authentication with Stripe and Payment
  id: totrans-565
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.11\. 带有 Stripe 和 Payment 的微服务认证
- en: '![](Images/09fig11.jpg)'
  id: totrans-566
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig11.jpg)'
- en: 9.3.1\. Configuring Keycloak
  id: totrans-567
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.1\. 配置 Keycloak
- en: With your Keycloak server running, the next step is defining a realm for your
    microservices to associate with.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的 Keycloak 服务器运行后，下一步是为您的微服务定义一个区域。
- en: After you’ve logged in to the administration console, hover over the Master
    realm name in the top-left corner to reveal the Add realm button, shown in [figure
    9.12](#ch09fig12).
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 登录到管理控制台后，将鼠标悬停在左上角的 Master 区域名称上，以显示添加区域按钮，如图 9.12 所示。
- en: Figure 9.12\. Accessing the Add realm button in Keycloak
  id: totrans-570
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.12\. 在 Keycloak 中访问添加区域按钮
- en: '![](Images/09fig12.jpg)'
  id: totrans-571
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig12.jpg)'
- en: Click the Add Realm button to open the screen used to create a realm. [Figure
    9.13](#ch09fig13) shows this screen.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 点击添加区域按钮，打开用于创建区域的屏幕。[图 9.13](#ch09fig13) 显示此屏幕。
- en: Figure 9.13\. Creating a realm
  id: totrans-573
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.13\. 创建区域
- en: '![](Images/09fig13_alt.jpg)'
  id: totrans-574
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig13_alt.jpg)'
- en: Click the Select File option to locate cayambe-realm.json from the /chapter9/keycloak
    directory of the book’s code repository. Then click Open.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 点击选择文件选项，从书籍代码存储库的 /chapter9/keycloak 目录中定位 cayambe-realm.json。然后点击打开。
- en: '[Figure 9.14](#ch09fig14) shows the realm you’ll create in Keycloak. To perform
    the import, you need to click Create so that the content of cayambe-realm.json
    will be imported and a Cayambe realm will exist.'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9.14](#ch09fig14) 显示您将在 Keycloak 中创建的区域。要执行导入，您需要点击创建，以便 cayambe-realm.json
    的内容被导入，并存在一个 Cayambe 区域。'
- en: Figure 9.14\. Importing the Cayambe realm
  id: totrans-577
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.14\. 导入 Cayambe 区域
- en: '![](Images/09fig14_alt.jpg)'
  id: totrans-578
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig14_alt.jpg)'
- en: With the Cayambe realm, you’re taking advantage of the Keycloak service accounts
    feature. This feature allows a client to authenticate itself with Keycloak, without
    any interaction from a user. This feature is super useful for administrative tasks
    that aren’t triggered by a user directly, such as scheduled jobs that still require
    authentication.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Cayambe 区域，您正在利用 Keycloak 服务账户功能。此功能允许客户端通过 Keycloak 进行身份验证，而无需用户任何交互。此功能对于直接由用户触发的管理任务非常有用，例如需要身份验证的预定作业。
- en: Now that your realm is created, let’s look at parts of the JSON you imported
    so you can see what Keycloak has set up.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的区域已创建，让我们看看您导入的 JSON 的部分，以便您可以看到 Keycloak 设置了什么。
- en: Listing 9.1\. cayambe-realm.json
  id: totrans-581
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.1\. cayambe-realm.json
- en: '[PRE43]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '***1*** Specifies the realm name to be cayambe'
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 指定区域名称为 cayambe'
- en: '***2*** Ensures that your realm is enabled after being loaded'
  id: totrans-584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 确保在加载后您的区域已启用'
- en: '***3*** Unique username for your service account user.'
  id: totrans-585
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 服务账户用户的唯一用户名'
- en: '***4*** Defines the clientId that will be authenticating with the service account'
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** 定义将使用服务账户进行身份验证的 clientId'
- en: '***5*** The roles that should be assigned to the service account user.'
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** 应分配给服务账户用户的角色。'
- en: '***6*** Defines the stripe-service-access realm role'
  id: totrans-588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** 定义 stripe-service-access 区域角色'
- en: '***7*** Unique clientId for your Payment microservice.'
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7*** 为您的支付微服务分配的唯一 clientId。'
- en: '***8*** Secret to be used for authenticating the service account user.'
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8*** 用于身份验证服务账户用户的密钥'
- en: '***9*** Enables the service account feature of Keycloak for the client'
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9*** 为客户端启用 Keycloak 的服务账户功能'
- en: '***10*** Client ID of the Stripe microservice that will be secured.'
  id: totrans-592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***10*** 将被保护的 Stripe 微服务的客户端 ID。'
- en: '***11*** Identifies that the client only validates bearer tokens, but is unable
    to retrieve them'
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***11*** 标识客户端仅验证 bearer 令牌，但无法检索它们'
- en: All the names and IDs you’ve defined here are unique within the realm you’ve
    created but have no meaning by themselves. They’re just text.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 您在此处定义的所有名称和 ID 在您创建的区域中都是唯一的，但它们本身没有意义。它们只是文本。
- en: What’s important is that the client ID for a service in the realm matches the
    specification in the service configuration (which is covered in the next section).
    With that, your Keycloak server is ready to handle authentication for Stripe and
    Payment.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，区域中某个服务的客户端 ID 与服务配置中的规范相匹配（下一节将介绍）。有了这个，您的 Keycloak 服务器就准备好处理 Stripe 和支付的认证了。
- en: 9.3.2\. Securing the Stripe resource
  id: totrans-596
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.2\. 保护 Stripe 资源
- en: The first step is to secure the Stripe microservice to ensure that you’re accessing
    Stripe APIs, without appropriate authentication. Once you know that you’re properly
    connecting to the service, you’ll add the necessary authentication.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是保护 Stripe 微服务，以确保您在访问 Stripe API 时没有适当的身份验证。一旦您知道您已正确连接到服务，您将添加必要的身份验证。
- en: If you take the code from [chapter 8](kindle_split_018.xhtml#ch08), you don’t
    need to modify `StripeResource` to add security. Pretty cool, right? You can add
    security to an existing RESTful endpoint without modifying its code! How does
    that work?
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您从 [第 8 章](kindle_split_018.xhtml#ch08) 中的代码开始，您不需要修改 `StripeResource` 来添加安全性。非常酷，对吧？您可以在不修改其代码的情况下向现有的
    RESTful 端点添加安全性！这是怎么做到的？
- en: 'Right off the bat you need to let Maven know that you want to use Keycloak
    with your Thorntail microservice. For that, you need to add a dependency to your
    pom.xml:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 立即让 Maven 知道您想要使用 Keycloak 与您的 Thorntail 微服务一起使用。为此，您需要在您的 pom.xml 中添加一个依赖项：
- en: '[PRE44]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The only other task is to define where Keycloak is, how it’s configured, and
    what needs protecting. Thankfully, you can do all that from within one file with
    Thorntail! You add a project-defaults.yml file into the src/main/resources directory
    of your Stripe microservice with the content shown in the following listing.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的其他任务是定义 Keycloak 的位置、其配置以及需要保护的内容。幸运的是，您可以使用 Thorntail 在一个文件中完成所有这些操作！您将一个
    project-defaults.yml 文件添加到 Stripe 微服务的 src/main/resources 目录中，其内容如下所示。
- en: Listing 9.2\. project-defaults.yml
  id: totrans-602
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.2\. project-defaults.yml
- en: '[PRE45]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '***1*** Section defining Keycloak configuration for chapter9-stripe.war deployment'
  id: totrans-604
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 定义 chapter9-stripe.war 部署的 Keycloak 配置章节'
- en: '***2*** Which realm your deployment uses for authentication—in this case, cayambe'
  id: totrans-605
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 您的部署用于身份验证的领域——在本例中为 cayambe'
- en: '***3*** Identify your microservice as bearer-only.'
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 将您的微服务标识为仅带 bearer。'
- en: '***4*** URL of the Keycloak server where the service realm is located. You
    don’t use localhost for when the service is deployed to Minishift.'
  id: totrans-607
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** 服务域所在的服务器上的 Keycloak 服务器 URL。当服务部署到 Minishift 时，您不使用 localhost。'
- en: '***5*** Identify this resource as stripe-service, which corresponds to the
    Client ID in cayambe-realm.json.'
  id: totrans-608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** 将此资源标识为 stripe-service，它对应于 cayambe-realm.json 中的客户端 ID。'
- en: '***6*** Section defining deployment-specific configuration for chapter9-stripe.war.
    This is equivalent to what could be provided as part of web.xml.'
  id: totrans-609
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** 定义 chapter9-stripe.war 部署特定配置的章节。这相当于可以在 web.xml 中提供的内容。'
- en: '***7*** Request that /stripe/charge URL patterns from this microservice are
    protected.'
  id: totrans-610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7*** 保护来自此微服务的 /stripe/charge URL 模式。'
- en: '***8*** Only users with the role stripe-service-access can successfully execute
    a request on this microservice.'
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8*** 只有具有 stripe-service-access 角色的用户才能成功执行对这一微服务的请求。'
- en: 'Now your Stripe microservice is secured from unauthenticated access! Let’s
    give it a try. Change to the /chapter9/serviceauth/stripe directory and run this:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的 Stripe 微服务已经从未经身份验证的访问中得到了保护！让我们试一试。切换到 /chapter9/serviceauth/stripe 目录并运行以下命令：
- en: '[PRE46]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Try opening a browser to http://localhost:8080/stripe/charge, and it will indicate
    *Unauthorized*. Connecting without a bearer token on the HTTP request from the
    browser results in your request being rejected, because you’re not properly authenticated.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试打开浏览器到 http://localhost:8080/stripe/charge，它将指示 *未授权*。从浏览器发送不带 bearer 令牌的
    HTTP 请求会导致您的请求被拒绝，因为您没有进行适当的身份验证。
- en: To see a little more detail, you can use a browser plugin that shows the HTTP
    network call or use `curl` from a terminal.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看更多细节，您可以使用显示 HTTP 网络调用的浏览器插件，或者从终端使用 `curl`。
- en: Listing 9.3\. Output from `curl` of Stripe
  id: totrans-616
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.3\. `curl` 的 Stripe 输出
- en: '[PRE47]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '***1*** HTTP request headers'
  id: totrans-618
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** HTTP 请求头'
- en: '***2*** HTTP response headers'
  id: totrans-619
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** HTTP 响应头'
- en: '***3*** Body of HTTP response'
  id: totrans-620
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** HTTP 响应体'
- en: Now it’s easier to see that you’re receiving a 401 HTTP response code, indicating
    you made an unauthorized attempt to access the URL. Now that Stripe is properly
    secured, how can another microservice access it without receiving user credentials?
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 现在更容易看出您收到了一个 401 HTTP 响应代码，表示您尝试未经授权访问 URL。现在 Stripe 已经得到了适当的保护，另一个微服务如何在不接收用户凭证的情况下访问它？
- en: 'You could also have deployed Stripe to Minishift as follows:'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以按照以下方式将 Stripe 部署到 Minishift：
- en: '[PRE48]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 9.3.3\. Authenticating in the Payment resource
  id: totrans-624
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.3\. 在支付资源中进行身份验证
- en: The Payment microservice for this chapter is derived from the RESTEasy client
    in [chapter 8](kindle_split_018.xhtml#ch08). You need to make only a few minor
    modifications to have it authenticate itself against Keycloak.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的支付微服务是从 [第 8 章](kindle_split_018.xhtml#ch08) 中的 RESTEasy 客户端派生出来的。您只需进行一些小的修改，就可以使其对
    Keycloak 进行身份验证。
- en: 'To be able to authenticate Payment against Keycloak, you need to add a dependency
    to the Keycloak Authz Client:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够使用 Keycloak 对支付进行身份验证，您需要向 Keycloak Authz 客户端添加一个依赖项：
- en: '[PRE49]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This dependency provides all the utility classes you need to authenticate with
    Keycloak. Now you need to define what Keycloak you’re interacting with, and which
    Payment microservice is within the Cayambe realm. For that, you need to create
    a keycloak.json file within the src/main/resources/directory.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 这个依赖项提供了你需要用于通过Keycloak进行身份验证的所有实用类。现在你需要定义你正在与之交互的Keycloak，以及哪个Payment微服务位于Cayambe领域内。为此，你需要在src/main/resources目录下创建一个keycloak.json文件。
- en: Listing 9.4\. keycloak.json for Payment service
  id: totrans-629
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.4\. Payment服务的keycloak.json
- en: '[PRE50]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '***1*** The realm your deployment uses for authentication—in this case, cayambe.'
  id: totrans-631
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 你的部署用于身份验证的领域——在本例中，为cayambe。'
- en: '***2*** URL of the Keycloak server where the cayambe realm is located.'
  id: totrans-632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** cayambe领域所在的Keycloak服务器的URL。'
- en: '***3*** Identify this resource as payment-authz-service, which corresponds
    to the Client ID in cayambe-realm.json.'
  id: totrans-633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 将此资源标识为payment-authz-service，它对应于cayambe-realm.json中的Client ID。'
- en: '***4*** The credential that needs to be passed to Keycloak to authenticate
    this client.'
  id: totrans-634
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** 需要传递给Keycloak以验证此客户端的凭证。'
- en: That’s all the configuration you need. Next add the code to authenticate with
    Keycloak. Because you’re now using Hystrix, you need to add the authentication
    handling into `StripeCommand`.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你需要做的所有配置。接下来，添加用于通过Keycloak进行身份验证的代码。因为你现在使用Hystrix，你需要将身份验证处理添加到`StripeCommand`中。
- en: Listing 9.5\. `StripeCommand`—`getAuthzClient` method
  id: totrans-636
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.5\. `StripeCommand`—`getAuthzClient`方法
- en: '[PRE51]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '***1*** Add a helper method for retrieving the AuthzClient for Keycloak.'
  id: totrans-638
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 添加一个用于检索Keycloak AuthzClient的辅助方法。'
- en: '***2*** If you haven’t already created an AuthzClient, proceed.'
  id: totrans-639
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 如果你还没有创建AuthzClient，请继续。'
- en: '***3*** Create the AuthzClient, which uses the information from keycloak.json
    to authenticate itself.'
  id: totrans-640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 创建AuthzClient，它使用keycloak.json中的信息进行身份验证。'
- en: With `AuthzClient` at your disposal, you can now retrieve an access token that
    you can add to any request you make to Stripe. To do that, you must modify your
    `run()` method from `StripeCommand` by adding a request filter after you have
    a `Resteasy-Client` instance.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 在拥有`AuthzClient`之后，你现在可以检索一个访问令牌，你可以将其添加到你对Stripe发出的任何请求中。为此，你必须修改`StripeCommand`中的`run()`方法，在你获得`Resteasy-Client`实例后添加一个请求过滤器。
- en: Listing 9.6\. `StripeCommand`—`run` method
  id: totrans-642
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.6\. `StripeCommand`—`run`方法
- en: '[PRE52]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '***1*** Register an anonymous ClientRequestFilter for modifying the HTTP request.'
  id: totrans-644
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 注册一个匿名ClientRequestFilter以修改HTTP请求。'
- en: '***2*** Use the AuthzClient to retrieve an access token from Keycloak, adding
    a prefix of Bearer to the token and adding it to a List.'
  id: totrans-645
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 使用AuthzClient从Keycloak检索一个访问令牌，将Bearer前缀添加到令牌中，并将其添加到列表中。'
- en: '***3*** Add the List you created to the AUTHORIZATION HTTP header of the request.'
  id: totrans-646
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 将你创建的列表添加到请求的AUTHORIZATION HTTP头部。'
- en: That’s all you need to do to pass a bearer token on any request you make to
    Stripe. Pretty simple, right?
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需做这些就能在向Stripe发出的任何请求上传递一个bearer令牌。很简单，对吧？
- en: 9.3.4\. Testing your secured microservice
  id: totrans-648
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.4\. 测试你的受保护微服务
- en: Now that you have Stripe and Payment set up, it’s time to see all the services
    running and interacting with each other. If you don’t have the Keycloak server
    and Stripe already running, start them again, ensuring that you deploy Stripe
    into Minishift.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经设置了Stripe和Payment，是时候查看所有正在运行并相互交互的服务了。如果你还没有启动Keycloak服务器和Stripe，请再次启动它们，确保将Stripe部署到Minishift。
- en: 'Then, you need to start Payment by changing to the /chapter9/serviceauth/ payment-service
    directory and running the following:'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你需要通过切换到/chapter9/serviceauth/payment-service目录并运行以下命令来启动Payment：
- en: '[PRE53]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Open the OpenShift console to retrieve the URL of Payment. Then use the same
    tools you used in [chapters 7](kindle_split_017.xhtml#ch07) and [8](kindle_split_018.xhtml#ch08)
    to execute an HTTP POST against the /sync and /async endpoints. If you try to
    access the Stripe microservice directly, you’ll still receive the HTTP response
    code 401 indicating you’re unauthorized.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 打开OpenShift控制台以检索Payment的URL。然后使用你在第7章和第8章中使用的相同工具对/sync和/async端点执行HTTP POST操作。如果你直接尝试访问Stripe微服务，你仍然会收到HTTP响应代码401，表示你未授权。
- en: To see the HTTP headers for Stripe when you’re calling it from Payment, you
    need to intercept the request or have some other way to output it. In this instance,
    you’ll modify Stripe to output HTTP request and response headers directly.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看从支付功能调用Stripe时的HTTP头部信息，你需要拦截请求或找到其他方式来输出它。在这种情况下，你需要修改Stripe以直接输出HTTP请求和响应头部。
- en: 'Let’s uncomment the following from project-defaults.yml in /chapter9/serviceauth/stripe:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在/chapter9/serviceauth/stripe的project-defaults.yml中取消注释以下内容：
- en: '[PRE54]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Restart Stripe and then issue another HTTP POST request on Payment. Within
    the OpenShift console, locate the Stripe service entry and click the three dots
    to the right of the pod status. From there, select View Logs, and you should see
    output logged for Stripe, such as the following:'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 重启Stripe，然后在Payment上发出另一个HTTP POST请求。在OpenShift控制台中，找到Stripe服务条目，点击pod状态右侧的三个点。从那里，选择查看日志，您应该会看到Stripe的输出，如下所示：
- en: '[PRE55]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 9.4\. Capturing user authentication
  id: totrans-658
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4\. 捕获用户认证
- en: To see how you can use user credentials to call a secured microservice, let’s
    secure the new Admin interface for Cayambe.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解您如何使用用户凭据调用受保护的微服务，让我们为Cayambe的新管理界面进行保护。
- en: In this scenario, it’s been decided that a few users need the ability to delete
    categories from the system. That seems reasonable enough. But you don’t want everyone
    with access to be able to delete a category. That certainly wouldn’t be an ideal
    outcome!
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，已经决定需要一些用户能够从系统中删除类别。这看起来是合理的。但您不希望所有有权访问的人都能删除类别。这绝对不是理想的结果！
- en: 'To achieve this goal, you need a few code modifications:'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一目标，您需要进行一些代码修改：
- en: Secure the HTTP DELETE method on the JAX-RS resource.
  id: totrans-662
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保护JAX-RS资源上的HTTP DELETE方法。
- en: Integrate with Keycloak for logging a user into the UI.
  id: totrans-663
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过Keycloak集成以将用户登录到UI。
- en: Add a Delete button to the UI for categories in the tree but enable it only
    when a user has the Admin role.
  id: totrans-664
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在树中的类别UI上添加一个删除按钮，但仅在用户具有管理员角色时启用它。
- en: 9.4.1\. Configuring Keycloak
  id: totrans-665
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.4.1\. 配置Keycloak
- en: I didn’t show it when you set up the Cayambe realm earlier, but the realm is
    already set up with what you need for user authentication. Now let’s cover the
    details of the parts specifically about user authentication.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 在您之前设置Cayambe领域时，我没有展示它，但该领域已经根据您进行用户认证的需求进行了设置。现在让我们具体了解与用户认证相关的部分细节。
- en: Listing 9.7\. cayambe-realm.json
  id: totrans-667
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.7\. cayambe-realm.json
- en: '[PRE56]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '***1*** Specifies the realm name to be cayambe'
  id: totrans-669
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 指定要使用的领域名为cayambe。'
- en: '***2*** Creates a user named ken that has the realm roles of user and admin'
  id: totrans-670
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 创建了一个名为ken的用户，该用户具有领域角色用户和管理员。'
- en: '***3*** Creates a user named bob that has the realm role of user'
  id: totrans-671
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 创建了一个名为bob的用户，该用户具有领域角色用户。'
- en: '***4*** Defines the user and admin realm roles'
  id: totrans-672
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** 定义用户和管理员领域角色。'
- en: '***5*** Client ID for your UI'
  id: totrans-673
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** 您UI的客户端ID。'
- en: '***6*** publicClient indicates that the client has the ability to log in users
    to Keycloak'
  id: totrans-674
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** publicClient表示客户端具有将用户登录到Keycloak的能力。'
- en: '***7*** Base URL of the application.'
  id: totrans-675
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7*** 应用程序的基本URL。'
- en: '***8*** Client ID of the JAX-RS endpoints that the UI uses.'
  id: totrans-676
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8*** UI使用的JAX-RS端点的客户端ID。'
- en: Now you’re ready to move on to the changes your application needs.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经准备好对应用程序所需的更改进行操作。
- en: 9.4.2\. Securing category deletion
  id: totrans-678
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.4.2\. 保护类别删除
- en: 'Taking code from the admin directory of [chapter 6](kindle_split_016.xhtml#ch06),
    you need to make only a few small modifications to secure it as you did with Stripe.
    Once again, you need to add the Maven dependency for Keycloak in Thorntail:'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 从[第6章](kindle_split_016.xhtml#ch06)的admin目录中获取代码，您只需进行一些小的修改，就可以像对Stripe所做的那样进行保护。再次提醒，您需要在Thorntail中添加Keycloak的Maven依赖项：
- en: '[PRE57]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Next you configure the integration with Keycloak through project-defaults.yml.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您通过project-defaults.yml配置与Keycloak的集成。
- en: Listing 9.8\. project-defaults.yml
  id: totrans-682
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.8\. project-defaults.yml
- en: '[PRE58]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '***1*** The realm your deployment uses for authentication—in this case, cayambe.'
  id: totrans-684
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 您部署所使用的认证领域——在本例中，为cayambe。'
- en: '***2*** URL of the Keycloak server where the cayambe realm is located.'
  id: totrans-685
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** cayambe领域所在Keycloak服务器的URL。'
- en: '***3*** Identify this resource as cayambe-admin-service, which corresponds
    to the Client ID in cayambe-realm.json.'
  id: totrans-686
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 将此资源标识为cayambe-admin-service，它对应于cayambe-realm.json中的客户端ID。'
- en: '***4*** Section defining deployment-specific configuration for chapter9-admin.war.
    This is equivalent to what could be provided as part of web.xml.'
  id: totrans-687
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** 定义chapter9-admin.war的特定部署配置部分。这相当于可以作为web.xml的一部分提供的内容。'
- en: '***5*** Request that all URL patterns deeper than /admin/category from this
    microservice are protected, for the HTTP DELETE method. Only users with the role
    admin can execute a request with the URL and method defined.'
  id: totrans-688
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** 请求保护从该微服务中比/admin/category更深的所有URL模式，针对HTTP DELETE方法。只有具有管理员角色的用户才能执行具有定义的URL和方法的请求。'
- en: That’s as far as you need to go to secure the deletion of categories over REST,
    but you’ll take this a step further to provide details about who is doing the
    deleting.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过 REST 安全删除类别，你需要做到这一步，但你会更进一步，提供有关谁在进行删除的详细信息。
- en: By adding the Keycloak dependency from Thorntail, you can retrieve details of
    the user making a request in the microservice. That’s nice for being able to audit
    who is doing what, though for our purposes you’re going to print out the information
    to the console.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从 Thorntail 添加 Keycloak 依赖项，你可以在微服务中检索发出请求的用户的详细信息。这很好，因为能够审计谁在做什么，尽管对于我们的目的，你将打印信息到控制台。
- en: Listing 9.9\. `CategoryResource`
  id: totrans-691
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.9\. `CategoryResource`
- en: '[PRE59]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '***1*** Inject the JAX-RS SecurityContext as a method parameter. This gives
    you access to security information from the HTTP request.'
  id: totrans-693
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 将 JAX-RS SecurityContext 注入为方法参数。这让你可以访问来自 HTTP 请求的安全信息。'
- en: '***2*** Check if the User Principal is of type KeycloakPrincipal, which is
    what you expect.'
  id: totrans-694
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 检查用户主体是否为 KeycloakPrincipal 类型，这是你预期的类型。'
- en: '***3*** Retrieve the User Principal into a KeycloakPrincipal.'
  id: totrans-695
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 将用户主体检索到 KeycloakPrincipal。'
- en: '***4*** From the token on the HTTP request, get the username of the user who
    initiated the request.'
  id: totrans-696
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** 从 HTTP 请求的令牌中获取发起请求的用户的用户名。'
- en: '***5*** Print a simple audit message stating who is deleting which address.'
  id: totrans-697
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** 打印一个简单的审计消息，说明谁正在删除哪个地址。'
- en: 9.4.3\. Authenticating the user in a UI
  id: totrans-698
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.4.3\. 在 UI 中认证用户
- en: Now that your RESTful endpoint is secure for category deletion, you can make
    the functionality available from the application UI. To see the changes you’ve
    made to the UI, look in the /chapter9/admin_ui/ui directory of the code for the
    chapter.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 现在由于你的 RESTful 端点对类别删除是安全的，你可以从应用程序 UI 中提供该功能。要查看你对 UI 所做的更改，请查看代码中第 9 章的 /chapter9/admin_ui/ui
    目录。
- en: In this situation, you’ve chosen to include the JavaScript that Keycloak provides
    by adding an NPM dependency into package.json for `keycloak-js`. You could also
    download the appropriate JavaScript from the server directly, from http://localhost:9090/auth/js/keycloak.js.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你选择通过将 NPM 依赖项添加到 package.json 中的 `keycloak-js` 来包含 Keycloak 提供的 JavaScript。你也可以直接从服务器下载适当的
    JavaScript，从 http://localhost:9090/auth/js/keycloak.js。
- en: As with your Java-based services, you need a keycloak.json file to configure
    our connection to the Keycloak server.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 与你的基于 Java 的服务一样，你需要一个 keycloak.json 文件来配置我们与 Keycloak 服务器的连接。
- en: Listing 9.10\. keycloak.json for Admin UI
  id: totrans-702
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.10\. Admin UI 的 keycloak.json
- en: '[PRE60]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This code should now be quite familiar to you, because it covers the typical
    requirements for connecting to Keycloak. It defines `cayambe-admin-ui` as the
    resource you specified earlier as your Client ID, within the cayambe-realm.json
    file you imported into Keycloak.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码现在应该很熟悉了，因为它涵盖了连接到 Keycloak 的典型要求。它将 `cayambe-admin-ui` 定义为你之前作为客户端 ID 指定的资源，在导入到
    Keycloak 中的 cayambe-realm.json 文件中。
- en: With the keycloak.json file in place, you can initialize your connection to
    Keycloak.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 在 keycloak.json 文件就绪后，你可以初始化你的 Keycloak 连接。
- en: Listing 9.11\. keycloak-service.js
  id: totrans-706
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.11\. keycloak-service.js
- en: '[PRE61]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '***1*** Import the Keycloak object from the keycloak-js NPM module.'
  id: totrans-708
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 从 keycloak-js NPM 模块导入 Keycloak 对象。'
- en: '***2*** Create the Keycloak object and tell it where keycloak.json is for configuration.'
  id: totrans-709
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 创建 Keycloak 对象，并告诉它配置文件 keycloak.json 的位置。'
- en: '***3*** Initialize Keycloak with check-sso, which checks only whether a user
    is currently logged in.'
  id: totrans-710
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 使用 check-sso 初始化 Keycloak，它只检查用户是否当前已登录。'
- en: '***4*** If you successfully connected to Keycloak, you’re passed an authenticated
    parameter to let you know whether a user is authenticated.'
  id: totrans-711
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** 如果你成功连接到 Keycloak，你会收到一个认证参数，告诉你用户是否已认证。'
- en: 'As part of the `success()` handling from [listing 9.11](#ch09ex11), you want
    to set variables that you’ll need later. One of those is to retrieve the URL for
    logging into Keycloak, because you need to add the URL into the UI:'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 [列表 9.11](#ch09ex11) 中的 `success()` 处理的一部分，你想要设置你稍后需要的变量。其中之一是检索登录 Keycloak
    的 URL，因为你需要将 URL 添加到 UI 中：
- en: '[PRE62]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'You can then pass that value into your ReactJS component for the header of
    the page, so that you can provide a link to log in:'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以将此值传递到你的 ReactJS 组件的页面标题中，以便你可以提供登录链接：
- en: '[PRE63]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '`this.props.login` is set to the value of the Keycloak login URL, which you
    set on `this.auth.loginUrl`. You also want to add information into the header
    of the page about the current logged-in user, and provide a way for that user
    to log out as well. It’ll be an exercise for you to explore the JavaScript and
    see how that works.'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: '`this.props.login`被设置为Keycloak登录URL的值，您在`this.auth.loginUrl`中设置。您还希望将有关当前登录用户的信息添加到页面标题中，并提供一种让该用户注销的方式。探索JavaScript并了解它是如何工作的将成为您的练习。'
- en: The last piece is to provide a button in the UI to delete a category. `CategoryListContainer`,
    a ReactJS component, will set a Boolean value for the `adminRole` property to
    indicate whether the user has that role.
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个步骤是在UI中提供一个按钮来删除一个类别。`CategoryListContainer`是一个ReactJS组件，它将为`adminRole`属性设置一个布尔值，以指示用户是否具有该角色。
- en: 'Then you just need HTML code to enable and disable a button based on this property:'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您只需要HTML代码来根据此属性启用和禁用按钮：
- en: '[PRE64]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: That’s most of the UI work done, except for passing the token you have for an
    authenticated user into any request that needs it. Let’s do that now.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上完成了大部分UI工作，除了将您为认证用户拥有的令牌传递给任何需要它的请求。让我们现在就做这件事。
- en: You need to modify the ReactJS action you have for `delete` to set the token
    on a request, just as you did in the Payment microservice earlier. The process
    is similar in JavaScript.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要修改ReactJS的`delete`动作，以便在请求中设置令牌，就像您在Payment微服务中之前所做的那样。在JavaScript中，这个过程是相似的。
- en: Listing 9.12\. Delete admin category
  id: totrans-722
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.12. 删除管理员类别
- en: '[PRE65]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '***1*** Imports an NPM module to assist in HTTP calls'
  id: totrans-724
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 导入一个NPM模块以帮助进行HTTP调用'
- en: '***2*** Defines the root URL of the RESTful endpoint for the address microservice'
  id: totrans-725
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 定义地址微服务的RESTful端点的根URL'
- en: '***3*** Checks whether there’s an authenticated user'
  id: totrans-726
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 检查是否存在认证用户'
- en: '***4*** Retrieves an authenticated token from keycloak-service.js'
  id: totrans-727
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** 从keycloak-service.js检索一个认证令牌'
- en: '***5*** Defines the HTTP DELETE request you want to execute'
  id: totrans-728
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** 定义您要执行的HTTP DELETE请求'
- en: '***6*** Sets the token you received from keycloak.getToken() into an authorization
    header for the request'
  id: totrans-729
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** 将您从keycloak.getToken()接收到的令牌设置到请求的授权头中'
- en: Did you forget how a UI and Keycloak interact? Let’s take another look in [figure
    9.15](#ch09fig15).
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 您忘记UI和Keycloak是如何交互的吗？让我们再次查看图9.15。
- en: Figure 9.15\. User authentication via UI
  id: totrans-731
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.15. 通过UI进行用户认证
- en: '![](Images/09fig15_alt.jpg)'
  id: totrans-732
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/09fig15_alt.jpg)'
- en: Anytime the UI calls `delete` on your RESTful endpoint, a token, if present,
    will be set on the request. For now, no other request from the UI will pass a
    token, but if there was a need to secure additional endpoints or to log information
    about the user making a request, then it could be added in a similar manner.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: '每当UI在您的RESTful端点上调用`delete`时，如果存在，令牌将被设置在请求上。目前，UI的其他请求不会传递令牌，但如果需要保护额外的端点或记录有关发起请求的用户的信息，则可以以类似的方式添加。 '
- en: 9.4.4\. Testing that the new UI and service all work
  id: totrans-734
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.4.4. 测试新的UI和服务是否都正常工作
- en: 'It’s time to take the new UI for a spin. If Keycloak isn’t still running, start
    it with the command you used earlier in the chapter. Start the RESTful endpoints
    for your Admin service, change to /chapter9/admin_ui/admin, and run this:'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候尝试新的UI了。如果Keycloak还没有运行，请使用本章中之前使用的命令启动它。启动您的Admin服务的RESTful端点，切换到/chapter9/admin_ui/admin，然后运行以下命令：
- en: '[PRE66]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Finally, you can run the UI! You want to simulate a production build, so you
    need a separate command to build and then start the UI:'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以运行UI！您想要模拟一个生产构建，因此您需要一个单独的命令来构建并启动UI：
- en: '[PRE67]'
  id: totrans-738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Now you can navigate to http://localhost:8080 and you’ll see the main page of
    the application, shown in [figure 9.16](#ch09fig16).
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以导航到http://localhost:8080，您将看到应用程序的主页，如图9.16所示。
- en: Figure 9.16\. Cayambe Admin screen
  id: totrans-740
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.16. Cayambe Admin屏幕
- en: '![](Images/09fig16_alt.jpg)'
  id: totrans-741
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/09fig16_alt.jpg)'
- en: You can see your categories, as before, but now you also have a Login link in
    the top-right corner, and a disabled Delete button for each category.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到您的类别，就像之前一样，但现在您在右上角还有一个登录链接，以及每个类别的禁用删除按钮。
- en: Clicking Login, you’re redirected to Keycloak to authenticate yourself. Enter
    `bob` as the username and `password` for the password. You’re redirected back
    to your application and you’re now authenticated, as shown in [figure 9.17](#ch09fig17).
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 点击登录，您将被重定向到Keycloak进行身份验证。将用户名输入为`bob`，密码输入为`password`。您将被重定向回您的应用程序，并且现在您已经认证成功，如图9.17所示。
- en: Figure 9.17\. Cayambe Admin when logged in with the User role
  id: totrans-744
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.17. 使用用户角色登录的Cayambe Admin
- en: '![](Images/09fig17_alt.jpg)'
  id: totrans-745
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/09fig17_alt.jpg)'
- en: Although you’re authenticated, the Delete button is still disabled. Because
    Bob has only the User role, you’re not permitted to delete categories.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您已经认证，但删除按钮仍然处于禁用状态。因为 Bob 只有用户角色，您没有权限删除类别。
- en: To see how to delete a category, let’s log out from Bob by clicking the user
    details in the top-right corner, and then select Logout from the options.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何删除一个类别，让我们通过点击右上角的用户详情退出 Bob，然后从选项中选择登出。
- en: Now let’s log in as `ken` with the same password as before; see [figure 9.18](#ch09fig18).
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用之前相同的密码以 `ken` 身份登录；参见[图 9.18](#ch09fig18)。
- en: Figure 9.18\. Cayambe Admin when logged in with the Admin role
  id: totrans-749
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.18\. 使用管理员角色登录时的 Cayambe 管理员界面
- en: '![](Images/09fig18_alt.jpg)'
  id: totrans-750
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig18_alt.jpg)'
- en: The Delete button is now bright red, indicating it’s available for you to use.
    Clicking it deletes the category you choose, and you’ll see that category removed,
    as well as a message letting you know the category was successfully deleted.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 删除按钮现在呈鲜艳的红色，表示您可以使用它。点击它将删除您选择的类别，您将看到该类别被删除，以及一条消息通知您类别已成功删除。
- en: I didn’t cover a lot of ReactJS code in this chapter, such as the code to check
    the token validity and to refresh it when it’s expiring. Please take a look at
    all the Java-Script code available for the application in the source code for
    the book.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 我在本章中没有涵盖很多 ReactJS 代码，例如检查令牌有效性和在它即将过期时刷新它的代码。请查看书中源代码中为应用程序提供的所有 Java-Script
    代码。
- en: Summary
  id: totrans-753
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Securing your microservices is critical, regardless of whether they’re intended
    for internal users only. You can’t predict all the types of malicious users who
    may attempt to do harm through your microservices.
  id: totrans-754
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论微服务是为内部用户还是外部用户设计的，保护您的微服务都是至关重要的。您无法预测所有可能尝试通过您的微服务造成损害的恶意用户类型。
- en: Keycloak can accept bearer tokens, provide an authorization client, and provide
    easy configuration for securing your microservices.
  id: totrans-755
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Keycloak 可以接受载体令牌，提供授权客户端，并提供为保护您的微服务配置的简单方法。
- en: You can authenticate against Keycloak without a user, which is essential for
    microservice-to-microservice calls when the recipient is secured.
  id: totrans-756
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在没有用户的情况下对 Keycloak 进行身份验证，这对于当接收方受到保护时进行微服务到微服务的调用是必不可少的。
- en: You can integrate Keycloak into an application UI to provide authentication,
    and pass tokens to RESTful endpoints that are secured.
  id: totrans-757
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以将 Keycloak 集成到应用程序 UI 中以提供身份验证，并将令牌传递到受保护的 RESTful 端点。
- en: Chapter 10\. Architecting a microservice hybrid
  id: totrans-758
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 10 章\. 构建微服务混合架构
- en: '*This chapter covers*'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Running the Cayambe monolith
  id: totrans-760
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行 Cayambe 单体
- en: Integrating microservices into Cayambe with a hybrid approach
  id: totrans-761
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用混合方法将微服务集成到 Cayambe 中
- en: Modifying Cayambe to integrate your microservices
  id: totrans-762
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改 Cayambe 以集成您的微服务
- en: Running the integrated Cayambe in a hybrid cloud
  id: totrans-763
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在混合云中运行集成的 Cayambe
- en: This chapter starts by showing you the old Cayambe and how to get it running
    locally. Then, after covering some theory on using the hybrid approach to integrating
    your microservices, you’ll revisit the architecture you’re looking to achieve
    for the new Cayambe. Next, you’ll dive into implementing the hybrid approach,
    with the microservices you’ve developed throughout the book so far. Finally, you’ll
    take your revitalized Cayambe monolith, along with the required microservices,
    and get them all running in the cloud.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先向您展示旧版的 Cayambe 以及如何在本地运行它。然后，在介绍了一些关于使用混合方法集成微服务理论之后，您将重新审视您希望实现的新 Cayambe
    架构。接下来，您将深入实施混合方法，使用本书迄今为止开发的微服务。最后，您将带着焕然一新的 Cayambe 单体以及所需的微服务，在云端运行它们。
- en: 10.1\. The Cayambe monolith
  id: totrans-765
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1\. Cayambe 单体
- en: '[Figure 10.1](#ch10fig01) provides a reminder of the Cayambe homepage from
    a user’s perspective.'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10.1](#ch10fig01) 从用户的角度提供了一个 Cayambe 主页的提醒。'
- en: Figure 10.1\. Cayambe homepage
  id: totrans-767
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.1\. Cayambe 主页
- en: '![](Images/10fig01_alt.jpg)'
  id: totrans-768
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/10fig01_alt.jpg)'
- en: Cayambe ([https://sourceforge.net/projects/cayambe/](https://sourceforge.net/projects/cayambe/))
    is described as a “J2EE E-Commerce Solution using Java Servlets & JSP & EJB.”
    It was built on JDK 1.2 and uses Apache Struts v1\. The existing code, which was
    last updated 15 years ago and can be found at [http://cayambe.cvs.sourceforge.net/viewvc/cayambe/](http://cayambe.cvs.sourceforge.net/viewvc/cayambe/),
    was downloaded and imported to the code repository for this book under /cayambe.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: Cayambe ([https://sourceforge.net/projects/cayambe/](https://sourceforge.net/projects/cayambe/))
    被描述为“使用 Java Servlets & JSP & EJB 的 J2EE 电子商务解决方案”。它是基于 JDK 1.2 构建的，并使用 Apache
    Struts v1。现有的代码，最后更新于 15 年前，可以在 [http://cayambe.cvs.sourceforge.net/viewvc/cayambe/](http://cayambe.cvs.sourceforge.net/viewvc/cayambe/)
    找到，已被下载并导入到本书的代码仓库中的 /cayambe 目录下。
- en: I faced initial challenges in finding compatible versions of Apache Struts,
    as well as making the necessary changes for it to compile on JDK 8! I resolved
    some minor bugs as well, to ensure that the basic UI was as functional as possible
    (as much as possible, given that I wasn’t involved in Cayambe’s creation).
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 我在寻找兼容版本的 Apache Struts 以及使其在 JDK 8 上编译所需的更改方面遇到了初步挑战！我还解决了一些小错误，以确保基本 UI 尽可能地功能齐全（考虑到我没有参与
    Cayambe 的创建，尽可能做到这一点）。
- en: '|  |'
  id: totrans-771
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-772
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The changes required to compile and run the original Cayambe code are beyond
    the scope of this book. But you can see the changes by viewing the Git commit
    history of the code at [http://mng.bz/4MZ5](http://mng.bz/4MZ5).
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 需要进行的更改以编译和运行原始 Cayambe 代码超出了本书的范围。但您可以通过查看代码的 Git 提交历史来查看这些更改 [http://mng.bz/4MZ5](http://mng.bz/4MZ5)。
- en: '|  |'
  id: totrans-774
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[Figure 10.2](#ch10fig02) provides a detailed view of the layers of code that
    Cayambe currently has architected. You start with JavaServer Pages (JSP) for the
    UI; these pages interact with Struts forms and actions. In turn, they interact
    with a layer of delegates that communicate with the Enterprise JavaBeans (EJB)
    that are present in what is referred to as the *backend* because it doesn’t involve
    user-facing code. Finally, the EJBs execute calls on the Data Access Objects (DAOs)
    that provide persistence to the database.'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10.2](#ch10fig02) 提供了 Cayambe 当前架构的代码层的详细视图。您从用于 UI 的 JavaServer Pages (JSP)
    开始；这些页面与 Struts 表单和操作交互。反过来，它们与一层代表者交互，这些代表者与被称为 *后端* 的企业 JavaBeans (EJB) 通信，因为它们不涉及面向用户的代码。最后，EJB
    在提供数据库持久性的数据访问对象 (DAO) 上执行调用。'
- en: '[Figure 10.2](#ch10fig02) provides a great view into the many layers that are
    present within Cayambe, as well as which pieces of each layer interact with the
    others. For instance, you can see that Struts forms and actions for both the Admin
    WAR and Cart WAR use the same delegate classes for Category and Product. Though
    such a situation is typical of older code, you should use design tools such as
    DDD (Domain-Driven Design), which was discussed in [chapter 1](kindle_split_010.xhtml#ch01),
    to separate the domain model of administration from a user placing an order. You
    likely would want particular pieces of data for Category and Product present that
    are applicable to only administrators of the site, but not to a user trying to
    place an order.'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10.2](#ch10fig02) 提供了对 Cayambe 内部众多层的深入了解，以及每一层的哪些部分相互交互。例如，您可以看到 Struts
    表单和操作对于 Admin WAR 和 Cart WAR 都使用相同的代表类来处理类别和产品。尽管这种情况在旧代码中很典型，但您应该使用如 DDD（领域驱动设计）这样的设计工具，这在第
    1 章（kindle_split_010.xhtml#ch01）中已讨论过，以将管理域模型与用户下订单分离。您可能希望某些数据（如类别和产品）仅适用于网站管理员，而不适用于试图下订单的用户。'
- en: Figure 10.2\. Cayambe code structure
  id: totrans-777
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.2\. Cayambe 代码结构
- en: '![](Images/10fig02_alt.jpg)'
  id: totrans-778
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/10fig02_alt.jpg)'
- en: 10.2\. Running the Cayambe monolith
  id: totrans-779
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2\. 运行 Cayambe 单体
- en: 'Running Cayambe locally requires these prerequisites:'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地运行 Cayambe 需要以下先决条件：
- en: WildFly 11.0.0.Final which you can download from [http://mng.bz/uZdC](http://mng.bz/uZdC)
  id: totrans-781
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以从 [http://mng.bz/uZdC](http://mng.bz/uZdC) 下载 WildFly 11.0.0.Final
- en: MySQL Connector for Java which you can download from [https://dev.mysql.com/downloads/connector/j/](https://dev.mysql.com/downloads/connector/j/)
  id: totrans-782
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以从 [https://dev.mysql.com/downloads/connector/j/](https://dev.mysql.com/downloads/connector/j/)
    下载 MySQL Connector for Java
- en: A running MySQL Server, whether locally or in a Docker container
  id: totrans-783
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地或 Docker 容器中的运行中的 MySQL 服务器
- en: 10.2.1\. Database setup
  id: totrans-784
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.1\. 数据库设置
- en: With a running MySQL server, you can now set up the database and load data.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行中的 MySQL 服务器上，您现在可以设置数据库并加载数据。
- en: Listing 10.1\. Create database and load data
  id: totrans-786
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.1\. 创建数据库并加载数据
- en: '[PRE68]'
  id: totrans-787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '***1*** Connect to the MySQL server running on port 32768 on localhost as the
    root user. This may be different in your environment.'
  id: totrans-788
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 以 root 用户身份连接到运行在 localhost 上 32768 端口的 MySQL 服务器。这可能在您的环境中不同。'
- en: '***2*** Create a user named cayambe with a password of cayambe.'
  id: totrans-789
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 创建一个名为 cayambe 的用户，密码为 cayambe。'
- en: '***3*** Grant privileges to the cayambe user in MySQL Server.'
  id: totrans-790
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 授予 MySQL 服务器中 cayambe 用户权限。'
- en: '***4*** Create a database named cayambe.'
  id: totrans-791
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** 创建一个名为 cayambe 的数据库。'
- en: '***5*** Switch to using the database you just created.'
  id: totrans-792
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** 切换到使用您刚刚创建的数据库。'
- en: '***6*** Execute the SQL script in mysql.sql to create all the necessary tables
    for Cayambe.'
  id: totrans-793
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** 执行 mysql.sql 中的 SQL 脚本来创建 Cayambe 所需的所有表。'
- en: '***7*** Execute the SQL script in test_data.sql to load initial data into the
    tables.'
  id: totrans-794
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7*** 执行 test_data.sql 中的 SQL 脚本来将初始数据加载到表中。'
- en: With these steps, you now have a database ready for use with Cayambe. The next
    task is to configure WildFly to be able to access the database you just set up.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些步骤，您现在有一个可以用于 Cayambe 的数据库。下一个任务是配置 WildFly 以能够访问您刚刚设置的数据库。
- en: 10.2.2\. WildFly setup
  id: totrans-796
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.2\. WildFly 设置
- en: After you’ve extracted the WildFly 11.0.0.Final download into a directory of
    your choosing, you need to provide some setup so that WildFly knows where the
    MySQL driver can be found. To do that, you create /modules/system/layers/base/com/
    mysql/main inside the location where WildFly was extracted.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 在您将 WildFly 11.0.0.Final 下载文件提取到您选择的目录之后，您需要提供一些设置，以便 WildFly 知道 MySQL 驱动器的位置。为此，您需要在
    WildFly 提取的位置内创建 /modules/system/layers/base/com/mysql/main。
- en: Inside the directory you just created, copy the MySQL connector for Java JAR
    file that you downloaded earlier. In the same directory, create this file.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 在您刚刚创建的目录中，复制您之前下载的 MySQL 连接器 for Java JAR 文件。在同一个目录中，创建此文件。
- en: Listing 10.2\. MySQL driver module.xml for monolith
  id: totrans-799
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.2\. 单体模式的 MySQL 驱动器模块.xml
- en: '[PRE69]'
  id: totrans-800
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '***1*** Sets the module name to be com.mysql, matching the directory structure
    you created'
  id: totrans-801
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 将模块名称设置为 com.mysql，与您创建的目录结构相匹配'
- en: '***2*** Path to the MySQL connector for Java JAR. Your JAR may require a different
    version in the name.'
  id: totrans-802
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** MySQL 连接器 for Java JAR 的路径。您的 JAR 可能需要不同的版本号。'
- en: '***3*** Some dependencies that are required for JDBC drivers in WildFly'
  id: totrans-803
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** WildFly 中 JDBC 驱动器所需的某些依赖项'
- en: What you’ve done here is create a JBoss module definition that’s used by WildFly.
    JBoss Modules is an open source project at the core of WildFly’s management of
    classloaders, and the separation of classes between classloaders to prevent clashes.
    For this example, you don’t need to understand how JBoss Modules does what it
    does. All you need to know is how to create a new module, as you did here, for
    adding JDBC drivers into WildFly.
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 您在这里所做的是创建一个 JBoss 模块定义，该定义由 WildFly 使用。JBoss Modules 是 WildFly 管理类加载器核心的开源项目，它通过在类加载器之间分离类来防止冲突。对于此示例，您不需要了解
    JBoss Modules 如何工作。您需要了解的是如何创建一个新的模块，就像您在这里所做的那样，以将 JDBC 驱动器添加到 WildFly 中。
- en: Finally, you need to tell WildFly about the new database driver and define a
    new data source that Cayambe can use to talk to the database. All WildFly configuration
    is present in standalone.xml. You need to locate standalone.xml inside /standalone/configuration/
    of the WildFly installation and then open the file for editing. Locate the section
    for the datasource’s subsystem and replace the entire section with the following
    content.
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您需要告诉 WildFly 关于新的数据库驱动程序，并定义一个 Cayambe 可以用来与数据库通信的新数据源。所有 WildFly 配置都位于
    standalone.xml 中。您需要在 WildFly 安装目录的 /standalone/configuration/ 中找到 standalone.xml
    并打开文件进行编辑。找到数据源的子系统部分，并用以下内容替换整个部分。
- en: Listing 10.3\. standalone.xml snippet
  id: totrans-806
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.3\. standalone.xml 片段
- en: '[PRE70]'
  id: totrans-807
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '***1*** Existing ExampleDS datasource present in WildFly. It hasn’t been altered.'
  id: totrans-808
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** WildFly 中现有的 ExampleDS 数据源。它尚未被修改。'
- en: '***2*** Climb datasource for Cayambe made accessible under JNDI name java:/Climb'
  id: totrans-809
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** Cayambe 的数据源在 JNDI 名称 java:/Climb 下可访问'
- en: '***3*** MySQL connection URL to database. Needs to be modified for your environment.'
  id: totrans-810
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 数据库的 MySQL 连接 URL。需要根据您的环境进行修改。'
- en: '***4*** mysql is the name of the driver definition, which is added at the end
    of the listing.'
  id: totrans-811
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** mysql 是驱动器定义的名称，它添加在列表的末尾。'
- en: '***5*** Security credentials you created in MySQL for the database'
  id: totrans-812
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** 在 MySQL 中为数据库创建的安全凭证'
- en: '***6*** Existing h2 driver for ExampleDS'
  id: totrans-813
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** ExampleDS 的现有 h2 驱动器'
- en: '***7*** mysql driver definition, which points to the com.mysql module you created
    earlier'
  id: totrans-814
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7*** 指向您之前创建的 com.mysql 模块的 mysql 驱动器定义'
- en: That’s all you need to do to configure WildFly to work with Cayambe.
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是您需要做的所有配置 WildFly 以与 Cayambe 一起工作的步骤。
- en: 10.2.3\. Running Cayambe
  id: totrans-816
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.3\. 运行 Cayambe
- en: You’re almost ready to start Cayambe and see it running. But first you need
    to build the EAR deployment. [Figure 10.3](#ch10fig03) reminds you of what Cayambe
    looks like from a deployment perspective, which you first saw in [chapter 2](kindle_split_011.xhtml#ch02).
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 您几乎准备好启动 Cayambe 并看到它运行了。但首先您需要构建 EAR 部署。[图 10.3](#ch10fig03) 提醒您从部署角度来看 Cayambe
    的样子，这是您在 [第 2 章](kindle_split_011.xhtml#ch02) 中首次看到的。
- en: Figure 10.3\. Cayambe monolith deployment
  id: totrans-818
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.3\. Cayambe 单体部署
- en: '![](Images/10fig03.jpg)'
  id: totrans-819
  prefs: []
  type: TYPE_IMG
  zh: '![图片 10.3](Images/10fig03.jpg)'
- en: Cayambe uses EAR (Enterprise Application aRchive) as the means of packaging
    the deployment. EAR allows Cayambe to include multiple WARs in addition to common
    JAR libraries that can be shared.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: Cayambe 使用 EAR（企业应用程序存档）作为打包部署的手段。EAR 允许 Cayambe 包含多个 WAR 文件，以及可以共享的通用 JAR 库。
- en: '|  |'
  id: totrans-821
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-822
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Though EARs were the preferred method for packaging a Java EE deployment, WAR
    deployments are more common at present. That’s not to say that EARs aren’t still
    being used, either by choice or legacy code, but EAR usage is less prevalent than
    it was.
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 EAR 是打包 Java EE 部署的首选方法，但当前更常见的是 WAR 部署。这并不意味着 EAR 没有被使用，无论是出于选择还是遗留代码，但
    EAR 的使用不如以前普遍。
- en: '|  |'
  id: totrans-824
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'To build Cayambe, you need to change to the /cayambe directory of the book’s
    code and run the following:'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建 Cayambe，您需要切换到书籍代码的 /cayambe 目录并运行以下命令：
- en: '[PRE71]'
  id: totrans-826
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Maven will construct each of the JARs and WARs that the project code resides
    within, and then package it into an EAR for you to deploy. After that construction
    is complete, copy /cayambe-ear/target/cayambe.ear into /standalone/deployments
    of the WildFly installation.
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: Maven 将构建项目代码中包含的每个 JAR 和 WAR 文件，并将其打包成 EAR 文件供您部署。构建完成后，将 /cayambe-ear/target/cayambe.ear
    复制到 WildFly 安装目录的 /standalone/deployments 中。
- en: 'Now start WildFly, including your deployment, by running this command from
    the root of the WildFly installation:'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 现在从 WildFly 安装根目录运行以下命令以启动 WildFly，包括您的部署：
- en: '[PRE72]'
  id: totrans-829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Lots of messages are output to the console as WildFly starts, and then your
    deployment is started. WildFly is ready to accept traffic to Cayambe after the
    messages stop, and you should see a message that contains content like this:'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 当 WildFly 启动时，会在控制台输出大量消息，然后您的部署开始。消息停止后，WildFly 准备接受 Cayambe 的流量，您应该会看到一个包含如下内容的消息：
- en: '[PRE73]'
  id: totrans-831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: You can access the user site at http://localhost:8080, and the administration
    site at http://localhost:8080/admin.
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过 http://localhost:8080 访问用户站点，通过 http://localhost:8080/admin 访问管理站点。
- en: 10.3\. Cayambe hybrid—monolith with microservices
  id: totrans-833
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3\. Cayambe 混合——单体与微服务
- en: In [chapter 1](kindle_split_010.xhtml#ch01), you learned about the Hybrid pattern
    for monoliths, whereby an existing monolith can have existing functionality migrated
    to a microservice environment. This pattern allows those pieces of the monolith
    that require higher scalability or performance to be efficiently separated, while
    not requiring the entire monolith to be rebuilt to make improvements. Let’s revisit
    what a monolith using the Hybrid pattern might look like; see [figure 10.4](#ch10fig04).
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 1 章](kindle_split_010.xhtml#ch01) 中，您学习了用于单体的混合模式，其中现有单体可以将现有功能迁移到微服务环境中。这种模式允许那些需要更高可扩展性或性能的单体部分被有效地分离，而无需重建整个单体以进行改进。让我们回顾一下使用混合模式的单体可能看起来是什么样子；参见
    [图 10.4](#ch10fig04)。
- en: Figure 10.4\. Enterprise Java and microservices hybrid architecture
  id: totrans-835
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.4\. 企业 Java 和微服务混合架构
- en: '![](Images/10fig04_alt.jpg)'
  id: totrans-836
  prefs: []
  type: TYPE_IMG
  zh: '![图片 10.4](Images/10fig04_alt.jpg)'
- en: '|  |'
  id: totrans-837
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-838
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: In this particular instance, you won’t be using a gateway that fronts all your
    microservices.
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定实例中，您不会使用一个面向所有微服务的网关。
- en: '|  |'
  id: totrans-840
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: There are certainly benefits to being able to split a monolith into pieces,
    while also separating out where those pieces might be deployed. Although doing
    so adds overhead, at least in terms of network calls and performance, the advantages
    often outweigh any downsides. This is especially true when those advantages revolve
    around key aspects, such as continuous delivery and release cadence.
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 能够将单体应用拆分成多个部分，同时分离这些部分可能部署的位置，这确实有好处。虽然这样做会增加开销，至少在网络调用和性能方面，但优势通常大于任何缺点。当这些优势围绕关键方面，如持续交付和发布节奏时，这一点尤其正确。
- en: In [chapter 2](kindle_split_011.xhtml#ch02), you developed a new administration
    UI, as well as RESTful endpoints for interacting with the data. In [chapter 7](kindle_split_017.xhtml#ch07),
    you introduced a separate microservice for processing card payments, to make it
    easier to integrate with external systems. Finally, in [chapter 9](kindle_split_019.xhtml#ch09),
    you added security to your administration UI, which was originally created in
    [chapter 2](kindle_split_011.xhtml#ch02).
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 2 章](kindle_split_011.xhtml#ch02) 中，您开发了一个新的管理 UI，以及用于与数据交互的 RESTful 端点。在
    [第 7 章](kindle_split_017.xhtml#ch07) 中，您引入了一个单独的微服务来处理卡片支付，以便更容易地与外部系统集成。最后，在
    [第 9 章](kindle_split_019.xhtml#ch09) 中，您为您最初在第 2 章 [第 2 章](kindle_split_011.xhtml#ch02)
    中创建的管理 UI 添加了安全性。
- en: How does it all fit together? [Figure 10.5](#ch10fig05) represents the proposed
    architecture of the Cayambe hybrid monolith. You’ll combine large pieces of the
    original monolith with new microservices that you’ve developed throughout the
    book. This architecture has certainly come a long way from where it started, but
    you still have some work ahead.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 它们是如何结合在一起的？[图 10.5](#ch10fig05) 表示了 Cayambe 混合单体提出的架构。您将结合原始单体的大块内容以及您在本书中开发的新微服务。这种架构确实已经从起点走了很长的路，但您仍然有一些工作要做。
- en: Figure 10.5\. Proposed Cayambe hybrid monolith
  id: totrans-844
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.5\. 提出的 Cayambe 混合单体
- en: '![](Images/10fig05_alt.jpg)'
  id: totrans-845
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/10fig05_alt.jpg)'
- en: So what exactly did you do in [figure 10.5](#ch10fig05)? You wanted to integrate
    the Payment microservice for processing card payments during the checkout process,
    and you wanted the UI to retrieve category information from Admin instead of storing
    the data itself. In addition to the new microservices, you also replaced the UI
    for administration with a new one, so you can remove the old one from Cayambe.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，您在 [图 10.5](#ch10fig05) 中到底做了什么？您想要在结账过程中集成支付微服务以处理卡片支付，并且您希望 UI 从 Admin
    而不是存储数据本身检索类别信息。除了新的微服务之外，您还用一个新的 UI 替换了管理界面，因此您可以从 Cayambe 中删除旧的界面。
- en: Let’s look at the requirements for each integration. All the code for the Cayambe
    hybrid monolith and its microservices is present within the book’s code in /chapter10.
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看每个集成的需求。Cayambe 混合单体及其微服务的所有代码都包含在本书的代码中，位于 /chapter10。
- en: 10.3.1\. Integrating the Payment microservice
  id: totrans-848
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3.1\. 集成支付微服务
- en: As a result of integrating the Payment microservice (and, in particular, because
    you’re using an external payment provider—in this case, Stripe), you no longer
    need to store your customers’ credit card information. This is a huge benefit
    because the rules and restrictions around storing credit card information can
    be difficult to enforce, and offloading that responsibility to a company specializing
    in that area is easier.
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 由于集成了支付微服务（特别是您正在使用外部支付提供商——在这种情况下，Stripe），您不再需要存储客户的信用卡信息。这是一个巨大的好处，因为存储信用卡信息的规则和限制可能很难执行，将这项责任转交给在该领域专门化的公司更容易。
- en: 'Because you don’t need to store that information, let’s remove it from the
    `billing_info` table of Cayambe. You modify /sql/cayambe/mysql.sql so that the
    following columns are removed:'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您不需要存储这些信息，让我们将其从 Cayambe 的 `billing_info` 表中删除。您修改 /sql/cayambe/mysql.sql，以便删除以下列：
- en: '`name_on_card`'
  id: totrans-851
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name_on_card`'
- en: '`card_type`'
  id: totrans-852
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`card_type`'
- en: '`card_number`'
  id: totrans-853
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`card_number`'
- en: '`card_expiration_month`'
  id: totrans-854
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`card_expiration_month`'
- en: '`card_expiration_year`'
  id: totrans-855
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`card_expiration_year`'
- en: '`authorization_code`'
  id: totrans-856
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`authorization_code`'
- en: You replace all those columns with a single column for `card_charge_id`. In
    changing what you’re storing in the database, you also need to update classes
    that passed those values around.
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 您将这些列替换为一个用于 `card_charge_id` 的单列。在更改数据库中存储的内容时，您还需要更新传递这些值的类。
- en: Listing 10.4\. `OrderDAO`
  id: totrans-858
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.4\. `OrderDAO`
- en: '[PRE74]'
  id: totrans-859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '***1*** Remove existing card columns from the select statement and add card_charge_id.'
  id: totrans-860
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 从选择语句中删除现有的卡片列，并添加 card_charge_id。'
- en: '***2*** Remove calls to set the values for the removed columns, and replace
    them with getCardChargeId() for the new field.'
  id: totrans-861
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 删除对删除列设置值的调用，并用 getCardChargeId() 替换新字段。'
- en: '***3*** Remove retrieval of old card data columns and add one for card_charge_id.'
  id: totrans-862
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 删除旧卡片数据列的检索，并添加一个用于 card_charge_id 的列。'
- en: Here you modify `OrderDAO` that interacts directly with the database for storing
    and retrieving the data for an order. Because you’ve modified methods that were
    on `BillingInfoVO`, you now need to make changes there as well, as shown in [listing
    10.5](#ch10ex05).
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您修改`OrderDAO`，该DAO直接与数据库交互以存储和检索订单数据。因为您已经修改了`BillingInfoVO`上的方法，所以您现在也需要在那里进行更改，如[列表10.5](#ch10ex05)所示。
- en: Listing 10.5\. `BillingInfoVO`
  id: totrans-864
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.5\. `BillingInfoVO`
- en: '[PRE75]'
  id: totrans-865
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '***1*** Replace nameOnCard, cardType, cardExpirationMonth, cardExpirationYear,
    and authorizationCode with cardToken and cardChargeId. cardToken is used to pass
    a token from the UI, which you’ll see shortly.'
  id: totrans-866
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 将nameOnCard、cardType、cardExpirationMonth、cardExpirationYear和authorizationCode替换为cardToken和cardChargeId。cardToken用于从UI传递令牌，您很快就会看到。'
- en: '***2*** Remove getter and setter methods for the previously mentioned fields,
    and add them for cardToken and cardChargeId.'
  id: totrans-867
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 删除之前提到的字段的getter和setter方法，并为cardToken和cardChargeId添加它们。'
- en: Now that you’ve modified the data objects that you’re passing around, let’s
    add the code needed to call the Payment client proxy from inside the Cayambe monolith.
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经修改了传递的数据对象，让我们添加从Cayambe单体内部调用Payment客户端代理所需的代码。
- en: To be able to send and receive the JSON and have it converted to objects, you
    need `ChargeStatus`, `PaymentRequest`, and `PaymentResponse`. To make it easy,
    you’ve copied these files from the Payment microservice, so you have them. Next
    you need an interface that represents Payment.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够发送和接收JSON并将其转换为对象，您需要`ChargeStatus`、`PaymentRequest`和`PaymentResponse`。为了方便起见，您已经从Payment微服务中复制了这些文件，因此您已经有了它们。接下来，您需要一个表示支付的接口。
- en: Listing 10.6\. `PaymentService`
  id: totrans-870
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.6\. `PaymentService`
- en: '[PRE76]'
  id: totrans-871
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '***1*** You’re using the /sync endpoint on the Payment microservice.'
  id: totrans-872
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 您正在使用Payment微服务的/sync端点。'
- en: '***2*** RESTful endpoint will consume and produce JSON.'
  id: totrans-873
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** RESTful端点将消费和产生JSON。'
- en: '***3*** Method to be proxied that will call Payment.'
  id: totrans-874
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 要代理的方法将调用Payment。'
- en: That’s all you need in order to define the external Payment microservice. Now
    let’s see how you integrate it into the existing Struts code. To be able to process
    a card transaction before you save the order, you need to modify `SubmitOrderAction`
    from within /cayambe-hybrid/checkout.
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定义外部Payment微服务，您需要这些所有内容。现在让我们看看如何将其集成到现有的Struts代码中。在保存订单之前处理卡交易，您需要从/cayambe-hybrid/checkout内部修改`SubmitOrderAction`。
- en: Listing 10.7\. `SubmitOrderAction`
  id: totrans-876
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.7\. `SubmitOrderAction`
- en: '[PRE77]'
  id: totrans-877
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '***1*** Existing Struts Action class for handling order submission'
  id: totrans-878
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 用于处理订单提交的现有Struts操作类'
- en: '***2*** Create a ResteasyClient that calls Payment within OpenShift.'
  id: totrans-879
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 创建一个ResteasyClient，在OpenShift中调用Payment。'
- en: '***3*** Create a proxy instance of PaymentService.'
  id: totrans-880
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 创建PaymentService的代理实例。'
- en: '***4*** Call Payment, passing it a PaymentRequest with the amount of the order
    and the cardToken from Stripe.'
  id: totrans-881
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** 调用Payment，传递一个包含订单金额和Stripe的cardToken的PaymentRequest。'
- en: '***5*** Set the chargeId you got back from Payment onto the BillingInfoVO.'
  id: totrans-882
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** 将从Payment返回的chargeId设置到BillingInfoVO上。'
- en: The preceding code will be familiar from [chapters 6](kindle_split_016.xhtml#ch06),
    [7](kindle_split_017.xhtml#ch07), and [8](kindle_split_018.xhtml#ch08), because
    you used the RESTEasy client proxy generation in those examples as well.
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将熟悉于[第6章](kindle_split_016.xhtml#ch06)、[第7章](kindle_split_017.xhtml#ch07)和[第8章](kindle_split_018.xhtml#ch08)，因为您在那些示例中也使用了RESTEasy客户端代理生成。
- en: In creating a `PaymentRequest` instance, you called `oaf.getCardToken()`, which
    contains the card token you need for processing a Stripe request. But you need
    to update `OrderActionForm` to provide that information for you.
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建`PaymentRequest`实例时，您调用了`oaf.getCardToken()`，它包含您处理Stripe请求所需的卡令牌。但您需要更新`OrderActionForm`以提供该信息。
- en: '`OrderActionForm` is located in /cayambe-hybrid/web-common. You remove the
    following fields, and their associated getters and setters:'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrderActionForm`位于/cayambe-hybrid/web-common。您需要删除以下字段及其关联的getter和setter：'
- en: '`nameOnCard`'
  id: totrans-886
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nameOnCard`'
- en: '`cardNumber`'
  id: totrans-887
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cardNumber`'
- en: '`cardType`'
  id: totrans-888
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cardType`'
- en: '`cardExpirationMonth`'
  id: totrans-889
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cardExpirationMonth`'
- en: '`cardExpirationYear`'
  id: totrans-890
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cardExpirationYear`'
- en: Finally, you add a field for `cardToken` of type `String`, and the getter and
    setter for it as well.
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您添加了一个类型为`String`的`cardToken`字段，以及它的getter和setter。
- en: Let’s modify the checkout page to capture the credit card details, before calling
    Stripe to retrieve a `cardToken` representing the credit card. For that, you need
    to update CheckOutForm.jsp inside /cayambe-hybrid/checkout.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改结账页面以捕获信用卡详情，在调用Stripe检索代表信用卡的`cardToken`之前。为此，您需要更新位于/cayambe-hybrid/checkout中的CheckOutForm.jsp。
- en: Listing 10.8\. CheckOutForm.jsp
  id: totrans-893
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.8\. CheckOutForm.jsp
- en: '[PRE78]'
  id: totrans-894
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '***1*** Create a Stripe JavaScript instance, passing in a publisher key.'
  id: totrans-895
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 创建一个 Stripe JavaScript 实例，传入一个发布者密钥。'
- en: '***2*** Initialize the prebuilt UI components from Stripe.'
  id: totrans-896
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 初始化 Stripe 的预构建 UI 组件。'
- en: '***3*** Set the token ID you received from Stripe onto the cardToken element.'
  id: totrans-897
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 将您从 Stripe 收到的令牌 ID 设置到 cardToken 元素上。'
- en: '***4*** Retrieve the orderForm and submit it.'
  id: totrans-898
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** 获取 orderForm 并提交它。'
- en: '***5*** When the document is loaded, mount the Stripe card element onto the
    card-element div.'
  id: totrans-899
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** 当文档加载时，将 Stripe 卡元素挂载到 card-element div 上。'
- en: '***6*** Add an event listener on the UI component to handle Stripe errors.'
  id: totrans-900
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** 在 UI 组件上添加一个事件监听器来处理 Stripe 错误。'
- en: '***7*** Add an event listener for submit onto the orderForm.'
  id: totrans-901
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7*** 在 orderForm 上添加一个提交事件监听器。'
- en: '***8*** Submit event listener asks Stripe to create a token from the card element
    in the UI.'
  id: totrans-902
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8*** 提交事件监听器请求 Stripe 从 UI 中的卡元素创建令牌。'
- en: '***9*** If Stripe returned success, call the stripeTokenHandler function.'
  id: totrans-903
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9*** 如果 Stripe 返回成功，调用 stripeTokenHandler 函数。'
- en: '***10*** Div to hold the card element Stripe will create for you.'
  id: totrans-904
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***10*** 用于容纳 Stripe 为您创建的卡元素的 div。'
- en: '***11*** Add a hidden form field to pass the Stripe card token into OrderActionForm.'
  id: totrans-905
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***11*** 添加一个隐藏表单字段，将 Stripe 卡令牌传递到 OrderActionForm。'
- en: '|  |'
  id: totrans-906
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-907
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: The full details of how to integrate UI elements of Stripe into a website can
    be found at [https://stripe.com/docs/stripe-js](https://stripe.com/docs/stripe-js).
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 如何将 Stripe 的 UI 元素集成到网站中的完整细节可以在 [https://stripe.com/docs/stripe-js](https://stripe.com/docs/stripe-js)
    找到。
- en: '|  |'
  id: totrans-909
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In addition to adding the card capture into the table of the form, you remove
    all the existing fields that captured each piece of credit card information.
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将卡捕获添加到表单的表中之外，您还删除了所有捕获每条信用卡信息的现有字段。
- en: For the preceding CheckOutForm.jsp to work, you also need to modify struts-forms.tld
    in /cayambe-hybrid/checkout to add `styleId` to both the form and hidden tags.
    This allows you to set a name that will be added to the `id` attribute of the
    generated HTML element.
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使前面的 CheckOutForm.jsp 正常工作，您还需要修改 /cayambe-hybrid/checkout 中的 struts-forms.tld，为表单和隐藏标签都添加
    `styleId`。这允许您设置一个将被添加到生成的 HTML 元素的 `id` 属性中的名称。
- en: That’s all the changes you need for the Payment microservice integration. Now
    it’s time to integrate Admin!
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是您需要为 Payment 微服务集成所做的所有更改。现在，是时候集成 Admin 了！
- en: 10.3.2\. Integrating the Admin microservice
  id: totrans-913
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3.2\. 集成 Admin 微服务
- en: To integrate Admin, you want to do something similar to Payment—at least in
    that you want to provide the classes required to send and receive objects to Admin,
    as well as to generate a proxy from an interface that represents Admin.
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 要集成 Admin，您需要做类似于 Payment 的事情——至少在这一点上，您希望提供发送和接收对象到 Admin 所需的类，以及从表示 Admin
    的接口生成代理。
- en: In addition to being able to call Admin, you need to integrate the category
    retrieval into the Cayambe monolith wherever categories are currently used. In
    looking at how categories are defined within Cayambe, you notice that categories
    are a separate database table, and the category/parent relationship is present
    in a separate table.
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 除了能够调用 Admin 之外，您还需要将类别检索集成到 Cayambe 单体中，无论当前在哪里使用类别。在查看 Cayambe 中类别的定义时，您会发现类别是一个独立的数据库表，而类别/父级关系存在于另一个表中。
- en: You also see that categories are called from various layers within the Cayambe
    monolith, and that the Category EJB provides many ways to interact with the categories
    that are split across many Java classes. Such a situation doesn’t bode well for
    a smooth integration of Admin, at least not in the same way that Payment was integrated.
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: 您还会看到类别从 Cayambe 单体中的各个层被调用，并且 Category EJB 提供了许多与分布在许多 Java 类中的类别交互的方式。这种情况并不利于
    Admin 的顺利集成，至少不是像 Payment 那样集成。
- en: Because the integration would require large code changes across nearly the entire
    stack, you decide that such an enhancement, though beneficial, has too many risks
    associated with it. In wanting to be agile and nimble, you don’t want to be held
    up for weeks or months to integrate Admin because you’re dealing with problems.
    These problems could be anything from issues in integrating the actual code, to
    spending a large amount of time testing the new changes in Cayambe—in addition
    to regression testing to make sure the changes don’t have ripple effects into
    other parts of the code. It’s unfortunate, but sometimes tough decisions like
    this need to be made for the stability of production code.
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 由于集成将需要在几乎整个堆栈中进行大量代码更改，你决定尽管这种增强很有益，但与之相关的风险太多。在希望敏捷灵活的同时，你不想因为处理问题而被拖累数周或数月来集成Admin。这些问题可能包括实际代码集成的问题，以及在Cayambe中测试新更改的大量时间——除了回归测试以确保更改不会对代码的其他部分产生连锁反应。这是令人遗憾的，但有时为了生产代码的稳定性，需要做出这样的艰难决定。
- en: So did I just waste large parts of the book for you to write a new UI and service
    for Admin that you won’t use? Far from it! In [chapter 11](kindle_split_021.xhtml#ch11),
    you’ll minimize your risk concerns by using event streaming, allowing you to retain
    the existing code within the Cayambe monolith but still take advantage of the
    new Admin UI and microservice.
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 难道我浪费了这本书的大部分内容，让你编写一个你不会使用的新的Admin UI和服务？远非如此！在[第11章](kindle_split_021.xhtml#ch11)中，你将通过使用事件流来最小化你的风险担忧，允许你在Cayambe单体中保留现有代码，同时仍然利用新的Admin
    UI和微服务。
- en: 10.3.3\. New administration UI
  id: totrans-919
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3.3. 新的行政UI
- en: You’ve seen the new administration UI, along with its associated microservice,
    but there’s already an administration section inside the Cayambe monolith. You
    remove the content from /cayambe-hybrid/admin, because you no longer need the
    existing administration UI. Next you remove all the references to the Admin.war
    that were present in /cayambe-hybrid/cayambe-ear, as that WAR is no longer a dependency
    of the EAR and doesn’t need to be packaged inside it.
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了新的行政UI及其相关的微服务，但在Cayambe单体中已经存在一个行政部分。你从/cayambe-hybrid/admin中移除了内容，因为你不再需要现有的行政UI。接下来，你移除了/cayambe-hybrid/cayambe-ear中存在的所有对Admin.war的引用，因为这个WAR不再是EAR的依赖项，也不需要打包在其中。
- en: 10.3.4\. Cayambe hybrid summary
  id: totrans-921
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3.4. Cayambe混合总结
- en: '[Figure 10.6](#ch10fig06) provides the complete picture of where you are currently,
    as well as the remaining pieces that are yet to be developed. You’ll add the remaining
    pieces in [chapter 11](kindle_split_021.xhtml#ch11).'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: '[图10.6](#ch10fig06) 展示了你当前所处的完整情况，以及尚未开发的剩余部分。你将在[第11章](kindle_split_021.xhtml#ch11)中添加剩余部分。'
- en: Figure 10.6\. Cayambe hybrid monolith
  id: totrans-923
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.6. Cayambe混合单体
- en: '![](Images/10fig06_alt.jpg)'
  id: totrans-924
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/10fig06_alt.jpg)'
- en: 10.4\. Deploying everything to a hybrid cloud
  id: totrans-925
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4. 将一切部署到混合云
- en: Because you’ve converted the Cayambe monolith to a hybrid, deploying everything
    becomes more complex—but you’re also doing everything manually. In a real environment,
    you’d want the deployments to be automated to make the process even simpler.
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你已经将Cayambe单体转换为混合型，部署一切变得更加复杂——但你也在手动完成所有工作。在实际环境中，你希望部署自动化，以使过程更加简单。
- en: 'This section covers all the pieces of the Cayambe hybrid that need to be set
    up, configured, or deployed to run it. The first thing you need to do is have
    Minishift running. It should also start with a clean OpenShift environment, to
    remove any services that might be present. You’re going to need all the room you
    can get inside a local OpenShift! So let’s delete any existing Minishift VM (virtual
    machine) you have and start from scratch:'
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖了Cayambe混合需要设置、配置或部署以运行的所有部分。你需要做的第一件事是让Minishift运行。它也应该从一个干净的OpenShift环境开始，以移除可能存在的任何服务。你需要在本地OpenShift中获得尽可能多的空间！所以，让我们删除你现有的任何Minishift虚拟机（虚拟机），从头开始：
- en: '[PRE79]'
  id: totrans-928
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The main difference from previous executions of Minishift is that you’re specifying
    three virtual CPUs and 4 GB of memory. This is necessary to ensure that you have
    the capacity to install the services you need for this and the next chapter.
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 与Minishift之前执行的版本相比，主要区别在于你指定了三个虚拟CPU和4GB的内存。这是必要的，以确保你有足够的空间安装本章节和下一章节所需的服务。
- en: 10.4.1\. Database
  id: totrans-930
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.4.1. 数据库
- en: Let’s create a MySQL database to store your data! Run `minishift console` and
    log into the OpenShift console.
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个MySQL数据库来存储你的数据！运行`minishift console`并登录到OpenShift控制台。
- en: Open the default My Project. Click the Add to Project menu item near the top
    and select Browse Catalog. This provides all the types of prebuilt images that
    OpenShift can install for you, as shown in [figure 10.7](#ch10fig07).
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 打开默认的My Project。点击顶部附近的添加到项目菜单项并选择浏览目录。这提供了OpenShift可以为您安装的所有预构建镜像类型，如[图10.7](#ch10fig07)所示。
- en: Figure 10.7\. Choosing the Browse Catalog option in the OpenShift console
  id: totrans-933
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.7\. 在OpenShift控制台中选择浏览目录选项
- en: '![](Images/10fig07_alt.jpg)'
  id: totrans-934
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/10fig07_alt.jpg)'
- en: Click the Data Stores box in the bottom row to see the different data stores
    available. On the Data Stores page that opens, shown in [figure 10.8](#ch10fig08),
    click the Select button in the MySQL (Persistent) box.
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 点击底部行中的数据存储框，以查看可用的不同数据存储。在打开的数据存储页面中，如[图10.8](#ch10fig08)所示，点击MySQL（持久）框中的选择按钮。
- en: You’ll be presented with a page containing configuration for MySQL, most of
    which can be left with the defaults. The only options you need to set are MySQL
    Connection Username, MySQL Connection Password, and MySQL Root User Password.
    Enter values for those fields, make a note of that information, and then click
    Create.
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到一个包含MySQL配置的页面，其中大部分可以保留默认设置。您需要设置的唯一选项是MySQL连接用户名、MySQL连接密码和MySQL根用户密码。输入这些字段的值，记下这些信息，然后点击创建。
- en: '|  |'
  id: totrans-937
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Warning
  id: totrans-938
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: Don’t use *cayambe* as the MySQL Connection Username, because that would conflict
    with the user you need to create later.
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用*cayambe*作为MySQL连接用户名，因为这会与您稍后需要创建的用户冲突。
- en: '|  |'
  id: totrans-940
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Figure 10.8\. OpenShift console—data stores
  id: totrans-941
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.8\. OpenShift控制台—数据存储
- en: '![](Images/10fig08_alt.jpg)'
  id: totrans-942
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/10fig08_alt.jpg)'
- en: 'After a minute or two, a MySQL service will be available in OpenShift. To be
    able to set up the databases, tables, and data that you need for Cayambe, you
    need to access the service remotely. Open a terminal window, log in to the OpenShift
    CLI with `oc login`, and then run `oc get pods`. The command returns a list similar
    to this:'
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 一两分钟后，OpenShift中将有一个MySQL服务可用。为了能够远程访问服务并设置Cayambe所需的数据库、表和数据，请打开终端窗口，使用`oc
    login`登录到OpenShift CLI，然后运行`oc get pods`。该命令返回一个类似以下列表：
- en: '[PRE80]'
  id: totrans-944
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'You need to copy the name of the MySQL pod, mysql-1-xq98q in this case, to
    connect to it:'
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要复制MySQL pod的名称，在本例中为mysql-1-xq98q，以连接到它：
- en: '[PRE81]'
  id: totrans-946
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'From inside the pod, you can then run the following to open a command prompt
    into the MySQL instance:'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: 在pod内部，您然后可以运行以下命令以打开MySQL实例的命令提示符：
- en: '[PRE82]'
  id: totrans-948
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Within the MySQL pod, `$MYSQL_ROOT_PASSWORD` and `$HOSTNAME` are defined as
    environment variables, so you don’t need to remember them to connect to the MySQL
    instance. Now that you’re inside MySQL, let’s set up the data you need!
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: 在MySQL pod内部，`$MYSQL_ROOT_PASSWORD`和`$HOSTNAME`被定义为环境变量，因此您不需要记住它们来连接到MySQL实例。现在您已经进入MySQL，让我们设置您所需的数据！
- en: Admin microservice data
  id: totrans-950
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 管理微服务数据
- en: 'The following commands create a `cayambe-admin` user for the admin database,
    grant the user all privileges to the `cayambe_admin` database, create the database,
    and finally switch to using that database:'
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令为管理数据库创建一个`cayambe-admin`用户，授予用户对`cayambe_admin`数据库的所有权限，创建数据库，并最终切换到使用该数据库：
- en: '[PRE83]'
  id: totrans-952
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: In the context of the `cayambe_admin` database, you can now execute some SQL
    to create the tables and populate them with initial data.
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: 在`cayambe_admin`数据库的上下文中，您现在可以执行一些SQL来创建表并填充初始数据。
- en: Open /chapter10/sql/admin/mysql.sql and paste the contents into the terminal
    window where you’re logged into MySQL. You should see SQL statements flash by,
    and if all went well, no errors! Now that the tables are there, do the same with
    /chapter10/sql/admin/data.sql to load the data.
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: 打开/chapter10/sql/admin/mysql.sql，并将内容粘贴到您已登录MySQL的终端窗口中。您应该会看到SQL语句快速闪过，如果一切顺利，则没有错误！现在表已经存在，用/chapter10/sql/admin/data.sql进行相同的操作以加载数据。
- en: Payment microservice data
  id: totrans-955
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 支付微服务数据
- en: 'You now run a similar set of commands for a `cayambe-payment` user and `cayambe_payment`
    database:'
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在为`cayambe-payment`用户和`cayambe_payment`数据库运行一组类似的命令：
- en: '[PRE84]'
  id: totrans-957
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Now open /chapter10/sql/payment-service/mysql.sql and paste the contents into
    the terminal window where you’re logged into MySQL. That should create the two
    tables you need and set an initial value for the ID sequence generator that JPA
    needs.
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开/chapter10/sql/payment-service/mysql.sql，并将内容粘贴到您已登录MySQL的终端窗口中。这将创建所需的两个表，并为JPA需要的ID序列生成器设置一个初始值。
- en: Cayambe monolith data
  id: totrans-959
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Cayambe单体数据
- en: 'Finally, run a similar set of commands for the `cayambe` user and database:'
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为`cayambe`用户和数据库运行一组类似的命令：
- en: '[PRE85]'
  id: totrans-961
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Open /chapter10/sql/cayambe/mysql.sql and paste the contents into the terminal
    window, which will create all the tables for the Cayambe monolith. Then copy the
    contents of /chapter10/sql/cayambe/test_data.sql to load the initial test data.
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: 打开/chapter10/sql/cayambe/mysql.sql并将其内容粘贴到终端窗口中，这将创建Cayambe单体所需的所有表。然后复制/chapter10/sql/cayambe/test_data.sql的内容以加载初始测试数据。
- en: 10.4.2\. Security
  id: totrans-963
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.4.2\. 安全性
- en: 'You already have a Keycloak server that you set up as part of [chapter 9](kindle_split_019.xhtml#ch09),
    so you’re going to reuse that:'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经有一个Keycloak服务器，它是作为[第9章](kindle_split_019.xhtml#ch09)的一部分设置的，所以您将重用它：
- en: '[PRE86]'
  id: totrans-965
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Open http://localhost:9090/auth/ and log into the administration console. Select
    the Clients option from the left navigation menu. From the list of available clients,
    click cayambe-admin-ui to open its details. All you need to do is update the three
    URLs that specify where your new administration UI is running, by changing the
    port from 8080 to 8090.
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 http://localhost:9090/auth/ 并登录到管理控制台。从左侧导航菜单中选择“客户端”选项。从可用客户端列表中点击cayambe-admin-ui以打开其详细信息。您需要做的只是更新指定新管理UI运行的三个URL，将端口从8080更改为8090。
- en: 10.4.3\. Microservices
  id: totrans-967
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.4.3\. 微服务
- en: Now it’s time to start deploying the microservices to OpenShift.
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候开始将微服务部署到OpenShift了。
- en: Admin microservice
  id: totrans-969
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Admin微服务
- en: Because the Admin microservice was brought across from previous chapters, you
    don’t need to do anything to it other than deploy it!
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Admin微服务是从前面的章节中引入的，所以除了部署之外，您不需要对它做任何事情！
- en: '[PRE87]'
  id: totrans-971
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: After this microservice is deployed, you should see it within the OpenShift
    console.
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 在此微服务部署后，您应该在OpenShift控制台中看到它。
- en: Stripe microservice
  id: totrans-973
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Stripe微服务
- en: 'As with Admin, you don’t need to do anything in the Stripe code, so you just
    deploy it:'
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: 与Admin一样，你不需要在Stripe代码中做任何事情，所以你只需部署它：
- en: '[PRE88]'
  id: totrans-975
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Payment microservice
  id: totrans-976
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 支付微服务
- en: 'Next, you need to deploy Payment, which is done in the same way as the others:'
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要部署Payment，这与其他部署方式相同：
- en: '[PRE89]'
  id: totrans-978
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 10.4.4\. Cayambe hybrid
  id: totrans-979
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.4.4\. Cayambe混合
- en: Now you’re ready to set up a WildFly application for the Cayambe hybrid. You
    can reuse the WildFly 11 and MySQL connector JAR downloads from earlier in the
    chapter and unpack them into a new directory.
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经准备好为Cayambe混合设置WildFly应用程序了。您可以使用本章前面下载的WildFly 11和MySQL连接器JAR文件，并将它们解压缩到一个新目录中。
- en: After they’re all extracted, create a directory structure that matches /wildfly-11.0.0.Final/modules/system/layers/base/com/mysql/main.
    Into that directory, copy the JAR file for MySQL Connector, and create a module.xml
    file with the following content.
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 在它们全部提取后，创建一个与/wildfly-11.0.0.Final/modules/system/layers/base/com/mysql/main相匹配的目录结构。到那个目录中，复制MySQL连接器的JAR文件，并创建一个包含以下内容的module.xml文件。
- en: Listing 10.9\. MySQL driver module.xml for hybrid
  id: totrans-982
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.9\. 混合版MySQL驱动模块.xml
- en: '[PRE90]'
  id: totrans-983
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '***1*** The particular version referenced here needs to match the file you
    copied into the directory.'
  id: totrans-984
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 这里引用的特定版本需要与您复制到目录中的文件相匹配。'
- en: Next you need to provide WildFly with the information it needs to configure
    the datasource for Cayambe. Open /wildfly-11.0.0.Final/standalone/configuration/standalone.xml,
    and replace the current datasource’s subsystem config with the following.
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要向WildFly提供它需要配置Cayambe数据源的信息。打开/wildfly-11.0.0.Final/standalone/configuration/standalone.xml，并用以下内容替换当前数据源的子系统配置。
- en: Listing 10.10\. standalone.xml
  id: totrans-986
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.10\. standalone.xml
- en: '[PRE91]'
  id: totrans-987
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[Listing 10.10](#ch10ex10) is virtually identical to [listing 10.3](#ch10ex03),
    except for one difference: the port number for the MySQL instance for Cayambe
    is set to 53652\. You might be wondering what that port number is from, because
    it’s not a standard MySQL port. Well, you’re going to define that port by forwarding
    the `mysql` service port within OpenShift so you can access it:'
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表10.10](#ch10ex10) 与[列表10.3](#ch10ex03)几乎相同，除了一个区别：Cayambe的MySQL实例端口号设置为53652。您可能会想知道这个端口号的来源，因为它不是一个标准的MySQL端口。好吧，您将通过在OpenShift中转发`mysql`服务端口来定义该端口，以便您可以访问它：'
- en: '[PRE92]'
  id: totrans-989
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '|  |'
  id: totrans-990
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-991
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If an existing forwarded port is shut down, or your machine is rebooted, you’ll
    have to rerun this command before WildFly will be able to find the database.
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现有的转发端口关闭，或者您的机器重新启动，您必须在WildFly能够找到数据库之前重新运行此命令。
- en: '|  |'
  id: totrans-993
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 10.4.5\. Cayambe EAR
  id: totrans-994
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.4.5\. Cayambe EAR
- en: Now that WildFly is set up, let’s deploy the modified Cayambe hybrid EAR to
    it. First you need to build it!
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 现在WildFly已经设置好了，让我们部署修改后的Cayambe混合EAR。首先您需要构建它！
- en: '[PRE93]'
  id: totrans-996
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'After it’s built, copy /cayambe-hybrid/cayambe-ear/target/cayambe.ear into
    /wildfly-11.0.0.Final/standalone/deployments. Now you start WildFly:'
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 构建完成后，将 /cayambe-hybrid/cayambe-ear/target/cayambe.ear 复制到 /wildfly-11.0.0.Final/standalone/deployments。现在您开始启动
    WildFly：
- en: '[PRE94]'
  id: totrans-998
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: With WildFly started, it’s now possible to try out the Cayambe UI by opening
    http://localhost:8080.
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 启动 WildFly 后，现在可以通过打开 http://localhost:8080 来尝试 Cayambe UI。
- en: 10.4.6\. Admin UI
  id: totrans-1000
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.4.6. 管理界面
- en: The last piece to get running is the new administration UI, because you already
    have the Admin microservice running from earlier.
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要启动的是新的管理界面，因为您已经从之前启动了 Admin 微服务。
- en: For the most part, the code is the same as that you used in [chapter 9](kindle_split_019.xhtml#ch09),
    with two small modifications. You adjusted the port that the UI runs on to be
    8090, so it didn’t clash with the main UI, and you also modified `ROOT_URL` in
    /chapter10/admin-ui/app/actions/category-actioxns.js to be the URL shown in the
    OpenShift console for cayambe-admin-service.
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大部分代码，它与您在[第 9 章](kindle_split_019.xhtml#ch09)中使用的代码相同，但有两次小的修改。您调整了 UI 运行的端口为
    8090，这样就不会与主 UI 冲突，并且您还修改了 /chapter10/admin-ui/app/actions/category-actioxns.js
    中的 `ROOT_URL`，使其成为 OpenShift 控制台中 cayambe-admin-service 显示的 URL。
- en: '|  |'
  id: totrans-1003
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-1004
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Be sure to remove the trailing slash from the URL.
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保从 URL 中删除尾随斜杠。
- en: '|  |'
  id: totrans-1006
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'It’s time to start the administration UI:'
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候开始启动管理界面了：
- en: '[PRE95]'
  id: totrans-1008
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Summary
  id: totrans-1009
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: You set up and ran the Cayambe monolith to show the code as it was before you
    made any modifications.
  id: totrans-1010
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您设置了并运行了 Cayambe 单体，以展示在您进行任何修改之前的代码。
- en: You integrated the microservices that you’d developed throughout the book into
    Cayambe, making the necessary modifications to Cayambe to make the integration
    possible.
  id: totrans-1011
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您将本书中开发的所有微服务集成到 Cayambe 中，并对 Cayambe 进行了必要的修改以实现集成。
- en: You learned that although you might want to integrate a microservice (in this
    case, Admin), sometimes doing so can add too much risk, so other options need
    to be considered.
  id: totrans-1012
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您了解到，尽管您可能想集成一个微服务（在这种情况下，是 Admin），但有时这样做可能会增加太多风险，因此需要考虑其他选项。
- en: You deployed the handful of microservices and the Cayambe hybrid and had them
    all functioning together.
  id: totrans-1013
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您部署了少量微服务以及 Cayambe 混合体，并使它们共同运行。
- en: Chapter 11\. Data streaming with Apache Kafka
  id: totrans-1014
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 11 章. 使用 Apache Kafka 进行数据流
- en: '*This chapter covers*'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Understanding data streaming with Apache Kafka
  id: totrans-1016
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Apache Kafka 的数据流
- en: Using data streaming to simplify an architecture
  id: totrans-1017
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数据流简化架构
- en: Incorporating data streaming into the Cayambe hybrid
  id: totrans-1018
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据流集成到 Cayambe 混合体中
- en: In [chapter 10](kindle_split_020.xhtml#ch10), you put together the Cayambe hybrid,
    combining the slimmed-down monolith with your new microservices. This chapter
    simplifies the access of administration data in the Cayambe hybrid by switching
    it to use data streaming.
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 10 章](kindle_split_020.xhtml#ch10)中，您组装了 Cayambe 混合体，将精简后的单体与您的新微服务相结合。本章通过将其切换到使用数据流来简化
    Cayambe 混合体中管理数据的访问。
- en: First you’ll learn about data streaming and how it can benefit developers and
    architects alike. Taking those lessons, you’ll develop a data-streaming solution
    for the Cayambe hybrid from the previous chapter, completing the journey from
    monolith to hybrid.
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您将了解数据流及其如何使开发人员和架构师都受益。带着这些课程，您将开发一个用于上一章 Cayambe 混合体的数据流解决方案，完成从单体到混合体的旅程。
- en: 11.1\. What can Apache Kafka do for you?
  id: totrans-1021
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1. Apache Kafka 能为您做什么？
- en: Before delving into Apache Kafka, the solution you’re going to use for recording
    and processing data streams, you need some background on data streaming. Otherwise,
    what Apache Kafka does and how it works will be completely foreign to you as an
    Enterprise Java developer.
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究 Apache Kafka、您将要用于记录和处理数据流的解决方案之前，您需要对数据流有一些背景知识。否则，作为企业 Java 开发人员，Apache
    Kafka 做什么以及它是如何工作的将完全陌生。
- en: 11.1.1\. Data streaming
  id: totrans-1023
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.1.1. 数据流
- en: '*Data streaming* doesn’t just refer to the way Netflix gets its movies to play
    on all your devices. It also refers to a continuously generated stream of data
    from potentially thousands of sources; each piece of data, or record, is small
    in size and is stored in the sequence that it was received. That may seem like
    a lot of buzzwords, but data streaming is still relatively new, and new ways to
    use it are always being conceived.'
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: '*数据流*不仅仅是指 Netflix 如何将电影播放到您的所有设备上。它还指来自可能成千上万个来源的持续生成数据流；每条数据或记录都很小，并且按接收顺序存储。这可能听起来有很多术语，但数据流仍然相对较新，并且总是有新的使用方式在构思中。'
- en: What kinds of data apply to data streaming? In a nutshell, pretty much any type
    of data could be useful in the context of data streaming. Common examples include
    measurements from vehicle sensors, real-time share prices from the stock market,
    and trending topics from social networks and sites.
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 哪些类型的数据适用于数据流？简而言之，几乎任何类型的数据在数据流的背景下都可能是有用的。常见的例子包括来自车辆传感器的测量数据、股市的实时股价，以及来自社交网络和网站的流行话题。
- en: 'A common use case for data streaming occurs when you have a lot of data, or
    records, and you want to analyze it for patterns or trends. It may well be that
    large amounts of the data can be completely ignored, and only key pieces of data
    are pertinent. It’s also possible for the same set of data records to have different
    purposes, dependent on which system might be consuming it! For instance, an e-commerce
    site that captures a stream of page-visit events can use the same data not only
    to record the number of pages a user visits before purchasing, but also to analyze
    the number of views each page is getting across all users. This is the beauty
    of data streaming: you can solve different problems with the same set of data.'
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: 数据流的一个常见用例是当你拥有大量数据或记录，并且你想分析它们以寻找模式或趋势时。可能大量数据可以完全忽略，只有关键数据片段是相关的。同一组数据记录也可能有不同的用途，这取决于可能消费它的系统！例如，一个捕捉页面访问事件流的电子商务网站可以使用相同的数据不仅记录用户在购买前访问的页面数量，还可以分析每个页面在所有用户中的查看次数。这就是数据流的美丽之处：你可以用同一组数据解决不同的问题。
- en: '[Figure 11.1](#ch11fig01) illustrates how data is received as a stream.'
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11.1](#ch11fig01) 展示了数据作为流接收的方式。'
- en: Figure 11.1\. Data-streaming pipes
  id: totrans-1028
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.1\. 数据流管道
- en: '![](Images/11fig01_alt.jpg)'
  id: totrans-1029
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/11fig01_alt.jpg)'
- en: The data for a particular type is received from potentially many sources, and
    is added to the end of the stream, or pipe, in the order it was received by the
    system that’s responsible for recording the data stream. There’s no concept of
    inserting a particular record at a given point in the stream. Everything is added
    to the end as it’s received.
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 特定类型的数据可能来自许多来源，并且按照系统记录数据流的接收顺序添加到流的末尾或管道中。在流中插入特定记录的概念是不存在的。所有东西都是按照接收的顺序添加到末尾的。
- en: Though you have several options for recording and processing data streams, for
    this chapter you’ll focus on Apache Kafka, so let’s take a look at it now.
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你有多种记录和处理数据流的方法，但本章将专注于Apache Kafka，让我们现在看看它。
- en: '|  |'
  id: totrans-1032
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Definition
  id: totrans-1033
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义
- en: 'To clarify the terminology used throughout this chapter, the terms *data streaming*,
    *data streams*, and *streaming* all refer to the same thing: the process of streaming
    data from a source for capture.'
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 为了明确本章中使用的术语，术语“数据流”、“数据流”和“流式传输”都指的是同一件事：从源捕获数据的过程。
- en: '|  |'
  id: totrans-1035
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 11.1.2\. Apache Kafka
  id: totrans-1036
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.1.2\. Apache Kafka
- en: Apache Kafka ([https://kafka.apache.org/](https://kafka.apache.org/)) was originally
    developed by LinkedIn in 2010 to be the core for its central data pipeline. Currently,
    the pipeline processes upward of 2 trillion messages a day! In early 2011, Apache
    Kafka was proposed as an open source project at Apache, and it moved out of the
    incubation phase in late 2012\. In the space of a few years, many enterprises
    are using Apache Kafka, including Apple, eBay, Netflix, Spotify, and Uber.
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Kafka ([https://kafka.apache.org/](https://kafka.apache.org/))最初由LinkedIn于2010年开发，作为其中心数据管道的核心。目前，该管道每天处理超过2000亿条消息！在2011年初，Apache
    Kafka被提议作为Apache的一个开源项目，并在2012年底结束了孵化阶段。在短短几年内，许多企业开始使用Apache Kafka，包括Apple、eBay、Netflix、Spotify和Uber。
- en: What is Apache Kafka? It’s is a distributed streaming platform. What do I mean
    by *distributed* here? Apache Kafka can partition data from a single data stream
    across multiple servers within a cluster. In addition, each partition is replicated
    across servers for fault tolerance of that data.
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是Apache Kafka？它是一个分布式流平台。我这里所说的“分布式”是什么意思？Apache Kafka可以将单个数据流的数据分区到集群内的多个服务器上。此外，每个分区都在服务器之间复制，以实现该数据的容错性。
- en: There are many ways to configure Apache Kafka, in terms of how it’s distributed
    and its level of fault tolerance, but those topics are beyond the scope of this
    chapter. For full details, take a look at the Apache Kafka documentation at [https://kafka.apache.org/documentation/](https://kafka.apache.org/documentation/).
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Kafka有许多配置方式，包括其分布方式和容错级别，但这些内容超出了本章的范围。对于完整详情，请参阅Apache Kafka文档[https://kafka.apache.org/documentation/](https://kafka.apache.org/documentation/)。
- en: 'As a streaming platform, the key capabilities that Apache Kafka provides are
    as follows:'
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: 作为流媒体平台，Apache Kafka提供的关键功能如下：
- en: Publish and subscribe to streams of records.
  id: totrans-1041
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布和订阅记录流。
- en: Store streams of records in a fault-tolerant, durable manner.
  id: totrans-1042
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以容错和持久的方式存储记录流。
- en: Process streams of records as they happen.
  id: totrans-1043
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在发生时处理记录流。
- en: 'At its core, Apache Kafka is a distributed commit log: it doesn’t notify sources
    that a piece of data has been recorded in the stream until it’s committed to the
    log. Being distributed, as I mentioned before, refers to each commit in the log,
    or stream, being spread across partitions and replicated.'
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，Apache Kafka是一个分布式提交日志：它不会在数据被记录到流中时通知源，直到数据被提交到日志中。正如我之前提到的，分布式指的是日志或流中的每个提交被分散到分区并复制。
- en: 'Another way of describing Apache Kafka is as a database with no clothes: the
    data is at the forefront and not hidden. Databases, at their core, use a commit
    log, as Apache Kafka does, to track changes and as a means of recovering from
    server failures to reconstitute the database. With Apache Kafka, the clothes of
    the database (tables, indexes, and so forth) have been stripped away, leaving
    just the commit log. This makes Apache Kafka infinitely more consumable and accessible
    than regular databases.'
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种描述Apache Kafka的方式是将其视为没有衣服的数据库：数据处于前沿，没有隐藏。数据库在其核心使用提交日志，就像Apache Kafka一样，用于跟踪更改和作为从服务器故障中恢复以重建数据库的手段。在Apache
    Kafka中，数据库的衣服（表、索引等）已经被剥离，只剩下提交日志。这使得Apache Kafka比常规数据库更易于消费和访问。
- en: Apache Kafka also uses semantics that are familiar to Enterprise Java developers
    that have integrated with messaging systems. There are *producers*, which generate
    records or events that are added to the stream, equivalent to the multiple sources
    present in [figure 11.1](#ch11fig01) previously. Each stream of records is referred
    to as a *topic*, and anything that reads records from the stream is a *consumer*.
    [Figure 11.2](#ch11fig02) shows how producers and consumers integrate with Apache
    Kafka.
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Kafka还使用了企业Java开发者熟悉的语义，这些开发者已经集成了消息系统。有*生产者*，它们生成记录或事件，这些事件被添加到流中，相当于之前[图11.1](#ch11fig01)中存在的多个源。每个记录流被称为*主题*，任何从流中读取记录的东西都是一个*消费者*。[图11.2](#ch11fig02)展示了生产者和消费者如何与Apache
    Kafka集成。
- en: Figure 11.2\. Apache Kafka integrations (reproduced from [https://kafka.apache.org/intro.html](https://kafka.apache.org/intro.html))
  id: totrans-1047
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.2\. Apache Kafka集成（来自[https://kafka.apache.org/intro.html](https://kafka.apache.org/intro.html)）
- en: '![](Images/11fig02.jpg)'
  id: totrans-1048
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/11fig02.jpg)'
- en: In addition, *connectors* enable databases, or other systems, to be sources
    of records being sent to Apache Kafka. Finally, *stream processors* have the ability
    to stream records from one or more topics, perform some type of transformation
    on the data, and then output it to one or more different topics.
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，*连接器*使数据库或其他系统能够成为发送到Apache Kafka的记录的来源。最后，*流处理器*能够从一个或多个主题中流式传输记录，对数据进行某种类型的转换，然后将输出到一个或多个不同的主题。
- en: What is a record?
  id: totrans-1050
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 记录是什么？
- en: Now that you understand some of the pieces that make up Apache Kafka, let’s
    define what a *record* means. Each record within a stream consists of a key, a
    value, and a timestamp. The key and value are straightforward in terms of their
    purpose, but why is a timestamp needed? The timestamp is crucial to Apache Kafka
    knowing when a record was received (which will become even more critical when
    we cover partitions).
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了一些构成Apache Kafka的组件，让我们定义一下*记录*的含义。流中的每个记录由一个键、一个值和一个时间戳组成。键和值在目的上很简单，但为什么需要一个时间戳呢？时间戳对于Apache
    Kafka知道记录何时被接收（当涉及到分区时将变得更加关键）是至关重要的。
- en: 'You also need to be aware of additional concepts about records before continuing.
    Each record is *immutable* within the data stream: you can’t edit, modify, or
    remove a record from the data stream after it’s been added. All you can do is
    provide update records for the same key that sets a different value.'
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，你还需要了解关于记录的额外概念。每个记录在数据流中都是*不可变的*：一旦记录被添加到数据流中，你无法编辑、修改或从数据流中删除记录。你所能做的就是为同一个键提供更新记录，设置不同的值。
- en: '[Figure 11.3](#ch11fig03) expands on the stream from [figure 11.1](#ch11fig01),
    showing possible records for a real-time stream of share prices. In [figure 11.3](#ch11fig03),
    you can see that there’s no single record for the key RHT. There are currently
    three, all with different values. This is the immutability of the data stream.
    If the stream weren’t immutable, there likely would be a single record with key
    RHT that’s continually updated with a new value.'
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: '[图11.3](#ch11fig03)扩展了[图11.1](#ch11fig01)中的流，展示了实时股价流的可能记录。在[图11.3](#ch11fig03)中，你可以看到没有针对键RHT的单个记录。目前有三个，它们的值都不同。这就是数据流的不可变性。如果流不是不可变的，那么很可能会有一个键为RHT的记录，它将不断更新为新值。'
- en: Figure 11.3\. Immutable data stream
  id: totrans-1054
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.3。不可变数据流
- en: '![](Images/11fig03_alt.jpg)'
  id: totrans-1055
  prefs: []
  type: TYPE_IMG
  zh: '![图11.3的替代文本](Images/11fig03_alt.jpg)'
- en: A big advantage with immutable data streams is that you have a history of change
    for the same key. Certainly in some situations, you might be concerned with only
    the current value of something. But far more often, knowing the history and being
    able to determine change over time is critical.
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变数据流的一个大优点是，对于同一个键，你可以有一个变化的历史记录。当然，在某些情况下，你可能只关心某个事物的当前值。但更常见的是，了解历史并能够确定随时间的变化是至关重要的。
- en: 'Records are also *persisted*: the log is retained on the filesystem, allowing
    the records to be processed at any point in the future. Having said that, limits
    exist on how long a record is retained. Each record is persisted only so long
    as is allowed by the retention policy on that particular topic. A topic could
    be defined to retain records indefinitely, presuming disk space isn’t an issue,
    or it could be purged after a few days, whether or not it has been consumed by
    anything.'
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: 记录也被*持久化*：日志保留在文件系统中，允许在未来任何时间点处理记录。话虽如此，记录保留的时间长度是有限制的。每个记录只保留到特定主题的保留策略允许的时间。一个主题可以被定义为无限期保留记录，前提是磁盘空间不是问题，或者几天后无论是否被消费都会被清除。
- en: How do topics work?
  id: totrans-1058
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 主题是如何工作的？
- en: '*Topics* in Kafka relate to a category, or type, of record that can be published
    and consumed. For instance, you’d use one topic for real-time share prices and
    a separate topic for measurements from vehicle sensors.'
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: Kafka中的*主题*与一个类别或类型相关，这种记录可以被发布和消费。例如，你会使用一个主题来实时股价，并为车辆传感器的测量使用另一个单独的主题。
- en: Each topic is divided into one or more partitions, across one or more servers
    within the Kafka cluster. A *partition* is a single logical data stream, or topic,
    such as those you saw in [figures 11.1](#ch11fig01) and [11.3](#ch11fig03), that’s
    split into multiple physical data streams.
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: 每个主题被划分为一个或多个分区，这些分区位于Kafka集群中的一个或多个服务器上。一个*分区*是一个单一的逻辑数据流，或主题，例如你在[图11.1](#ch11fig01)和[11.3](#ch11fig03)中看到的，它被分割成多个物理数据流。
- en: '[Figure 11.4](#ch11fig04) shows a partition. Partitioning of a topic increases
    the parallelism that can be achieved when writing or reading from a specific topic.
    The figure illustrates a single topic that’s split into three partitions. Each
    partition represents an ordered and immutable sequence of records that’s continually
    appended to, creating a structured log of change events within a data stream.
    Each record in a given partition is assigned a sequential ID number known as the
    *offset*. The offset uniquely identifies a record within a specific partition.'
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: '[图11.4](#ch11fig04)显示了一个分区。主题的分区增加了在特定主题写入或读取时可以实现的并行性。该图展示了一个被分割成三个分区的单一主题。每个分区代表一个有序且不可变的记录序列，这些记录不断追加，从而在数据流内创建一个结构化的变更事件日志。给定分区中的每个记录都被分配一个称为*偏移量*的顺序ID号。偏移量唯一地标识了特定分区内的记录。'
- en: Figure 11.4\. Topic partitions (reproduced from [https://kafka.apache.org/intro.html](https://kafka.apache.org/intro.html))
  id: totrans-1062
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.4。主题分区（摘自[https://kafka.apache.org/intro.html](https://kafka.apache.org/intro.html))
- en: '![](Images/11fig04_alt.jpg)'
  id: totrans-1063
  prefs: []
  type: TYPE_IMG
  zh: '![图11.4的替代文本](Images/11fig04_alt.jpg)'
- en: A critical point with Kafka records that developers need to be especially mindful
    of is the definition of the key to be associated with a record. If the key isn’t
    truly unique within the context of the business, there’s the danger of overlap
    between key and timestamp combinations—especially as Kafka guarantees that all
    records with the same key are placed on the same partition, ensuring that all
    records for a key are stored in sequence on a single partition.
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者需要特别注意 Kafka 记录的一个关键点是与之关联的键的定义。如果键在业务上下文中不是真正唯一的，那么键和时间戳组合之间可能会发生重叠——特别是由于
    Kafka 保证所有具有相同键的记录都放置在同一个分区上，确保所有键的记录都按顺序存储在单个分区上。
- en: '[Figure 11.5](#ch11fig05) shows how producers and consumers interact with a
    topic partition.'
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11.5](#ch11fig05) 展示了生产者和消费者如何与主题分区交互。'
- en: Figure 11.5\. Topic producers and consumers (reproduced from [https://kafka.apache.org/intro.html](https://kafka.apache.org/intro.html))
  id: totrans-1066
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.5. 主题生产者和消费者（摘自 [https://kafka.apache.org/intro.html](https://kafka.apache.org/intro.html))
- en: '![](Images/11fig05.jpg)'
  id: totrans-1067
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/11fig05.jpg)'
- en: As mentioned previously, producers always write new records to the very end
    of a partition. Consumers typically process records sequentially, but are able
    to specify at which offset they begin processing. For instance, in [figure 11.5](#ch11fig05),
    Consumer B may have begun reading from offset 0 and is now processing offset 11\.
    Consumer A is at offset 9 but may have begun reading records from that offset
    only and not from 0.
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，生产者总是将新记录写入分区的末尾。消费者通常按顺序处理记录，但能够指定从哪个偏移量开始处理。例如，在[图 11.5](#ch11fig05)中，消费者
    B 可能从偏移量 0 开始读取，现在正在处理偏移量 11。消费者 A 在偏移量 9，但可能只从该偏移量开始读取记录，而不是从 0 开始。
- en: '[Figure 11.5](#ch11fig05) introduces some concepts regarding consumers that
    are worth elaborating on, so you’re familiar with what they can do:'
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11.5](#ch11fig05) 介绍了一些关于消费者的概念，值得详细阐述，以便你熟悉它们能做什么：'
- en: Consumers can start reading a topic from any offset, including from the very
    beginning, offset 0.
  id: totrans-1070
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费者可以从任何偏移量开始读取一个主题，包括从非常开始，偏移量 0。
- en: Consumers can be load balanced by specifying a consumer group when reading records.
  id: totrans-1071
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在读取记录时指定消费者组，可以对消费者进行负载均衡。
- en: A *consumer group* is a logical grouping of multiple consumers, ensuring that
    each record is read by only a single consumer within the same consumer group.
  id: totrans-1072
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*消费者组*是多个消费者的逻辑分组，确保同一消费者组内的每个记录只被单个消费者读取。'
- en: 11.2\. Simplifying your monolith architecture with streaming
  id: totrans-1073
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2. 使用流式传输简化单体架构
- en: '[Figure 11.6](#ch11fig06) is a brief reminder of what has been developed and
    integrated so far with the Cayambe hybrid. The grayed-out piece is to be completed
    in this chapter and links the Admin and Cayambe databases, via an Apache Kafka
    topic, to remove the need for the Cayambe database to manage categories directly.
    This makes it possible to simply feed the data from one database to another.'
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11.6](#ch11fig06) 简要回顾了迄今为止与 Cayambe 混合架构一起开发和集成的内容。灰色部分将在本章中完成，并通过 Apache
    Kafka 主题将 Admin 和 Cayambe 数据库链接起来，以消除 Cayambe 数据库直接管理类别的需求。这使得能够简单地从数据库 A 将数据传输到数据库
    B。'
- en: 'Without data streaming in [figure 11.6](#ch11fig06), you have a few alternatives:'
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 11.6](#ch11fig06)中没有数据流的情况下，你有几种替代方案：
- en: Modify the Cayambe JAR to retrieve records from the Admin database. Quite apart
    from it being bad data design to have different services interacting with the
    same database, you found in [chapter 10](kindle_split_020.xhtml#ch10) that such
    a change in this case would require a lot of code changes to accomplish.
  id: totrans-1076
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改 Cayambe JAR 以从 Admin 数据库检索记录。除了不同服务与同一数据库交互是一种不良的数据设计之外，你还在[第 10 章](kindle_split_020.xhtml#ch10)中发现，在这种情况下，这样的更改需要大量的代码更改才能完成。
- en: Develop a scheduled job to extract all the records from the Admin database,
    and then clear out and insert those records into the Cayambe database. This is
    simpler to implement but does result in periods where the data is out of sync,
    and also where the data in Cayambe would be unavailable when the job to run it
    is executing. Depending on how frequently the data changes, this may be an acceptable
    solution, though having any scheduled downtime is far from ideal.
  id: totrans-1077
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发一个计划任务以从 Admin 数据库提取所有记录，然后清除并将这些记录插入到 Cayambe 数据库中。这种方法实现起来更简单，但会导致数据不同步的时期，以及当运行该任务的作业正在执行时，Cayambe
    中的数据将不可用。根据数据变化的频率，这可能是一个可接受的解决方案，尽管任何计划中的停机时间都远远不是理想的。
- en: Modify the Admin microservice to also update the records within the Cayambe
    database. Though this would be easier to implement than the first option, this
    solution is prone to problems around transactions and knowing whether both updates
    were successful. It would require the Admin microservice to be a lot smarter about
    succeeding or failing, and how to handle failures appropriately in one of the
    database calls to roll back the other.
  id: totrans-1078
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改 Admin 微服务以更新 Cayambe 数据库中的记录。虽然这比第一个选项更容易实现，但这种解决方案容易受到事务问题和知道两个更新是否都成功的影响。它需要
    Admin 微服务对成功或失败以及如何适当地处理数据库调用中的失败有更多的智能，以便回滚另一个。
- en: To properly support the model in [figure 11.6](#ch11fig06), you want to be able
    to convert the database change events into records in Kafka for you to process.
    Such a solution has the least impact on the Admin microservice while still enabling
    you to consume its data. What you need is a connector for Kafka that can do this
    for you.
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确支持 [图 11.6](#ch11fig06) 中的模型，你希望能够将数据库更改事件转换为 Kafka 中的记录以便你处理。这种解决方案对 Admin
    微服务的影响最小，同时仍然允许你消费其数据。你需要的是一个可以为你做这件事的 Kafka 连接器。
- en: Figure 11.6\. Current Cayambe hybrid monolith
  id: totrans-1080
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.6\. 当前 Cayambe 混合单体
- en: '![](Images/11fig06_alt.jpg)'
  id: totrans-1081
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/11fig06_alt.jpg)'
- en: Are any tools available that would make that possible? Why, yes, there are!
    Debezium is an open source project for streaming changes out of databases into
    Kafka.
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: 有任何工具可以实现这一点吗？是的，当然有！Debezium 是一个开源项目，用于将数据库中的更改流出到 Kafka。
- en: '|  |'
  id: totrans-1083
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-1084
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Debezium is a distributed platform for change data capture. You can start Debezium,
    point it at your databases, and react to each insert, update, or delete that’s
    made on those databases in completely separate applications. Debezium allows you
    to consume database row-level changes, without any impact or changes to applications
    that currently perform those database updates directly. A huge benefit with Debezium
    is that any applications or services consuming the database changes can be taken
    down for maintenance without losing a single change. Debezium is still recording
    the changes into Kafka, ready for consumption when the services are available
    again. Full details on Debezium can be found at [http://debezium.io/](http://debezium.io/).
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: Debezium 是一个用于变更数据捕获的分布式平台。你可以启动 Debezium，将其指向你的数据库，并在完全独立的应用程序中对这些数据库上的每个插入、更新或删除做出反应。Debezium
    允许你消费数据库行级更改，而不会对当前直接执行这些数据库更新的应用程序产生任何影响或更改。Debezium 的一个巨大好处是，任何消费数据库更改的应用程序或服务都可以进行维护而不会丢失任何更改。Debezium
    仍然将更改记录到 Kafka 中，以便在服务再次可用时进行消费。关于 Debezium 的详细信息可以在 [http://debezium.io/](http://debezium.io/)
    找到。
- en: '|  |'
  id: totrans-1086
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: To gain a better understanding of Apache Kafka, data streaming, and how they
    can be integrated into your microservices, you aren’t going to implement Debezium
    for the Cayambe hybrid in this chapter. I’ll leave that as an additional exercise
    for you.
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解 Apache Kafka、数据流以及它们如何集成到你的微服务中，你在这个章节中不会为 Cayambe 混合型实现 Debezium。我将把它留给你作为额外的练习。
- en: For the Cayambe hybrid, you’re going to directly produce events into Apache
    Kafka, and then consume them on the other side. [Figure 11.7](#ch11fig07) shows
    the changes you’re going to make to the architecture, in support of showing more
    details of the way Apache Kafka works.
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Cayambe 混合型，你将直接将事件生产到 Apache Kafka，然后在另一侧消费它们。[图 11.7](#ch11fig07) 展示了你要对架构进行的更改，以支持展示
    Apache Kafka 的工作方式更多细节。
- en: Figure 11.7\. Cayambe hybrid monolith
  id: totrans-1089
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.7\. Cayambe 混合单体
- en: '![](Images/11fig07_alt.jpg)'
  id: totrans-1090
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/11fig07_alt.jpg)'
- en: You’re adding code to the Admin microservice to produce events that will be
    sent to an Apache Kafka topic. Then you have a Kafka microservice to consume those
    events and update the Cayambe database with the changes.
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在向 Admin 微服务添加代码以产生将被发送到 Apache Kafka 主题的事件。然后你有一个 Kafka 微服务来消费这些事件并更新 Cayambe
    数据库中的更改。
- en: You’re still going to use data streaming to move the data you need from one
    place to another, though not using something like Debezium will be a bit less
    efficient in terms of real production use, but beneficial to understand what’s
    going on.
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: 你仍然会使用数据流来将所需数据从一个地方移动到另一个地方，尽管不使用类似 Debezium 的方法在真实生产使用中可能效率略低，但有助于理解正在发生的事情。
- en: 11.3\. Deploying and using Kafka for data streaming
  id: totrans-1093
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3\. 部署和使用 Kafka 进行数据流
- en: 'Before looking at implementing the microservices to integrate with Kafka, let’s
    get Kafka up and running on OpenShift! If you don’t have Minishift running already,
    let’s start it now just as you did in [chapter 10](kindle_split_020.xhtml#ch10):'
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看如何实现与Kafka集成的微服务之前，让我们在OpenShift上启动并运行Kafka！如果你还没有运行Minishift，让我们现在启动它，就像你在[第10章](kindle_split_020.xhtml#ch10)中做的那样：
- en: '[PRE96]'
  id: totrans-1095
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 11.3.1\. Kafka on OpenShift
  id: totrans-1096
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.1\. OpenShift上的Kafka
- en: After Minishift is up and running, start the OpenShift console and log in. In
    your existing project, click Add to Project and then click Import YAML/JSON.
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: Minishift启动并运行后，启动OpenShift控制台并登录。在你的现有项目中，点击添加到项目，然后点击导入YAML/JSON。
- en: Paste into the text box the contents of /chapter11/resources/Kafka_OpenShift.yml,
    some snippets of which are in this listing.
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: 将/chapter11/resources/Kafka_OpenShift.yml的内容粘贴到文本框中，其中一些片段如本列表所示。
- en: Listing 11.1\. Kafka OpenShift template
  id: totrans-1099
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.1\. Kafka OpenShift模板
- en: '[PRE97]'
  id: totrans-1100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '***1*** strimzi is the name of the application that will appear within OpenShift.'
  id: totrans-1101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** strimzi是将在OpenShift中出现的应用程序的名称。'
- en: '***2*** Defines the kafka service'
  id: totrans-1102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 定义了kafka服务'
- en: '***3*** kafka service will be available on port 9092.'
  id: totrans-1103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** kafka服务将在端口9092上可用。'
- en: '***4*** Defines the zookeeper service'
  id: totrans-1104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** 定义了zookeeper服务'
- en: '***5*** zookeeper service is available on port 2181.'
  id: totrans-1105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** ZooKeeper服务在端口2181上可用。'
- en: Hold on there, what’s ZooKeeper doing there? It wasn’t mentioned before! That’s
    right, it wasn’t mentioned before. ZooKeeper is an implementation detail because
    it’s used internally by Kafka as a distributed key/value store. It’s not something
    you need to interact with. You’re seeing it here because you’re acting as operations
    staff to set up Kafka for yourself.
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: 稍等一下，ZooKeeper在那里做什么？之前可没提到！没错，之前确实没有提到。ZooKeeper是一个实现细节，因为它被Kafka内部用作分布式键/值存储。这不是你需要与之交互的东西。你在这里看到它是因为你正在扮演运维人员角色，为自己设置Kafka。
- en: /chapter11/resources/Kafka_OpenShift.yml was originally copied from [http://mng.bz/RqUn](http://mng.bz/RqUn),
    but was modified to have only a single Kafka broker instead of three. As a result,
    it doesn’t support topic replication, but your OpenShift instance needs fewer
    resources to run Kafka!
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: /chapter11/resources/Kafka_OpenShift.yml最初是从[http://mng.bz/RqUn](http://mng.bz/RqUn)复制的，但被修改为只有一个Kafka代理而不是三个。因此，它不支持主题复制，但你的OpenShift实例运行Kafka所需的资源更少！
- en: After you’ve pasted the contents of the modified file into the pop up, click
    Create and then Continue to see a form where you can specify different default
    values. For now, leave those as they are and click Create at the bottom of the
    page. OpenShift will now provision a Kafka cluster with a single broker, which
    you can see from the main console page under the strimzi application.
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: 在将修改后的文件内容粘贴到弹出窗口后，点击创建，然后继续，你将看到一个表单，你可以指定不同的默认值。现在，保持它们不变，并在页面底部点击创建。OpenShift现在将配置一个包含单个代理的Kafka集群，你可以在主控制台页面下的strimzi应用程序中看到它。
- en: '|  |'
  id: totrans-1109
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-1110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: It can take a little time to complete the downloading of the necessary Docker
    images and then start the containers. Don’t be concerned if the Kafka cluster
    fails initially if ZooKeeper isn’t running yet. Given time, it’ll restart, and
    everything will be running as expected.
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: 完成必要的Docker镜像下载并启动容器可能需要一些时间。如果ZooKeeper尚未运行，Kafka集群最初失败，请不要担心。给定时间，它将重新启动，一切都将按预期运行。
- en: '|  |'
  id: totrans-1112
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'After all the pods are started, open a terminal window and log into the OpenShift
    client, if you’re not already. You need to retrieve all the OpenShift services
    to find the URL for ZooKeeper:'
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有Pod启动后，打开一个终端窗口并登录到OpenShift客户端（如果你还没有登录的话）。你需要检索所有OpenShift服务以找到ZooKeeper的URL：
- en: '[PRE98]'
  id: totrans-1114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: From the list, you can see the ZooKeeper URL is 172.30.93.118\. Head back to
    the OpenShift console and select Applications and then Pods from the menu options.
    This provides a list of the running pods in OpenShift. With a single broker, there
    should be only a single kafka-* pod. Click that Pod and then select the Terminal
    tab, and you should see something similar to [figure 11.8](#ch11fig08).
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: 从列表中，你可以看到ZooKeeper的URL是172.30.93.118。返回OpenShift控制台，从菜单选项中选择应用程序和Pod。这提供了一个OpenShift中运行中的Pod列表。对于单个代理，应该只有一个kafka-*
    Pod。点击该Pod，然后选择终端标签页，你应该会看到类似于[图11.8](#ch11fig08)的内容。
- en: Figure 11.8\. OpenShift pod terminal
  id: totrans-1116
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.8\. OpenShift pod终端
- en: '![](Images/11fig08_alt.jpg)'
  id: totrans-1117
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/11fig08_alt.jpg)'
- en: 'To use Kafka, you need to create a topic for your records. Let’s do that within
    the Terminal tab:'
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Kafka，你需要为你的记录创建一个主题。让我们在终端标签页中做这件事：
- en: '[PRE99]'
  id: totrans-1119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: You use a Kafka script to create a topic named `category_topic` that has only
    a single partition and a single replication. You specify only single replication
    and partition because you have a single broker in the cluster. For instance, if
    you had three brokers in the cluster, you could use three partitions and a replication
    factor of 2.
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用Kafka脚本来创建一个名为`category_topic`的主题，该主题只有一个分区和一个副本。你只指定单个副本和分区，因为你在集群中只有一个代理。例如，如果你在集群中有三个代理，你可以使用三个分区和2的副本因子。
- en: 11.3.2\. Admin microservice
  id: totrans-1121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.2\. Admin微服务
- en: Now that Kafka is running and your topic is created, it’s time to modify the
    Admin microservice to produce events onto the topic!
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Kafka已经运行并且你的主题已经创建，是时候修改Admin微服务以将事件发送到该主题了！
- en: To assist in integrating your Enterprise Java code with Kafka, you’ll use a
    library that converts the *pull* approach of Kafka into a *push* approach. This
    library is still in its infancy but is easy to use because it removes a lot of
    the boilerplate code that’s required when using the Kafka APIs directly. It’s
    written as a CDI extension and is available as Maven artifacts for you to consume.
    The code is available at [https://github.com/aerogear/kafka-cdi](https://github.com/aerogear/kafka-cdi).
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助将你的企业Java代码与Kafka集成，你将使用一个库，该库将Kafka的*拉取*方法转换为*推送*方法。这个库仍然处于初级阶段，但很容易使用，因为它去除了直接使用Kafka
    API时所需的大量样板代码。它被编写为一个CDI扩展，并以Maven工件的形式提供给你使用。代码可在[https://github.com/aerogear/kafka-cdi](https://github.com/aerogear/kafka-cdi)找到。
- en: What’s the advantage of converting Kafka’s *pull* approach into a *push* one?
    It’s beneficial for those of us more familiar with Enterprise Java development,
    where with the CDI programming model we’re able to listen for events and perform
    an action when we receive one. This is what the Kafka library we’re using brings
    for us, the ability to listen for events every time a new record is written to
    a topic, just as if it were a CDI event listener.
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: 将Kafka的*拉取*方法转换为*推送*方法有什么优势？这对于我们这些更熟悉企业Java开发的人来说是有益的，因为在CDI编程模型中，我们能够监听事件并在接收到事件时执行操作。这正是我们使用的Kafka库为我们带来的，即每次向主题写入新记录时都能监听事件，就像它是CDI事件监听器一样。
- en: 'The first thing you need to do is update the pom.xml of the Admin microservice
    to use the new dependency:'
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做的第一件事是更新Admin微服务的pom.xml以使用新的依赖项：
- en: '[PRE100]'
  id: totrans-1126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Next you modify `CategoryResource` to connect with the Kafka topic, and produce
    records to be appended onto it.
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你修改 `CategoryResource` 以连接到Kafka主题，并生成要附加到其上的记录。
- en: Listing 11.2\. `CategoryResource`
  id: totrans-1128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.2\. `CategoryResource`
- en: '[PRE101]'
  id: totrans-1129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '***1*** Identifies the Kafka server you’re connecting to. You can use environment
    variables for the host and port because you’re deploying the microservice into
    the same OpenShift namespace as Kafka.'
  id: totrans-1130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 识别你连接到的Kafka服务器。你可以使用环境变量来指定主机和端口，因为你在与Kafka相同的OpenShift命名空间中部署微服务。'
- en: '***2*** Inject a CDI producer that accepts an Integer as key and Category as
    value.'
  id: totrans-1131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 注入一个接受整数作为键和类别作为值的CDI生产者。'
- en: '***3*** create() was modified to call send() after the new Category was created.
    It indicates the topic you’re sending the record to, along with the key and value.'
  id: totrans-1132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** `create()` 方法被修改为在创建新的类别之后调用 `send()` 方法。这表示你将记录发送到的主题，以及键和值。'
- en: '***4*** remove() was modified in a similar manner. The main difference with
    create() is that you’re passing a null value because there’s no longer a valid
    value.'
  id: totrans-1133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** `remove()` 方法以类似的方式进行修改。与 `create()` 方法的主要区别在于你传递了一个null值，因为没有有效的值了。'
- en: 'With the changes made to the Admin microservice, you can now deploy it! Before
    deploying the microservice, you need to have Keycloak running, because your micro-service
    uses it to secure the delete endpoint. To do that, you need to run this:'
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: 在Admin微服务所做的更改之后，你现在可以部署它了！在部署微服务之前，你需要确保Keycloak正在运行，因为你的微服务使用它来保护删除端点。为此，你需要运行以下命令：
- en: '[PRE102]'
  id: totrans-1135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'If the database files haven’t been removed from the directory, Keycloak should
    start up and remember all the settings you’ve installed previously. With Keycloak
    running again, you can now deploy Admin:'
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据库文件尚未从目录中删除，Keycloak应该启动并记住你之前安装的所有设置。随着Keycloak再次运行，你现在可以部署Admin：
- en: '[PRE103]'
  id: totrans-1137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: After the microservice is up and running, you can use the new Administration
    UI, or via HTTP requests directly with Postman, to update and delete categories.
    How do you know the Admin microservice is correctly putting records onto the Kafka
    topic? You don’t have anything consuming those records!
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务启动并运行后，你可以使用新的管理界面，或者通过 Postman 直接使用 HTTP 请求来更新和删除类别。你怎么知道 Admin 微服务是否正确地将记录放入
    Kafka 主题？因为你没有任何消费者消费这些记录！
- en: 'Thankfully, Kafka provides a consumer you can use in a console to see the contents
    of a topic. In the OpenShift console, you go back to the kafka-* pod, as you had
    before, and select the Terminal tab. On the command line, run the following:'
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Kafka 提供了一个可以在控制台中使用的消费者，用于查看主题的内容。在 OpenShift 控制台中，你回到 kafka-* 容器，就像之前一样，并选择终端标签页。在命令行中，运行以下命令：
- en: '[PRE104]'
  id: totrans-1140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Alternatively, you could connect to the kafka-* pod and run the command remotely:'
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以连接到 kafka-* 容器，并远程运行命令：
- en: '[PRE105]'
  id: totrans-1142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: You used the IP address and port of the Kafka service from the list of OpenShift
    services you retrieved earlier to specify where Kafka is located. Next you tell
    the script you want to consume all records from the beginning, which is the same
    as saying from offset 0\. Finally, you give it the name of the topic. If all has
    worked OK, you should see a record appear for each change you made through the
    Admin microservice.
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用了之前从 OpenShift 服务列表中检索到的 Kafka 服务 IP 地址和端口来指定 Kafka 的位置。接下来，你告诉脚本你想要从开始消费所有记录，这与从偏移量
    0 开始相同。最后，你给出主题的名称。如果一切正常，你应该会看到通过 Admin 微服务所做的每个更改都对应一个记录。
- en: We’ve covered the producing side of the Kafka topic. Now let’s look at the consuming
    side.
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了 Kafka 主题的生产方面。现在让我们看看消费方面。
- en: 11.3.3\. Kafka consumer
  id: totrans-1145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.3\. Kafka 消费者
- en: All the code for the Kafka consumer is in the /chapter11/kafka-consumer/ directory
    of the book’s code. As with the producer, you add the `kafka-cdi-extension` dependency
    to the pom.xml. The remainder of the pom.xml contains the usual Thorntail plugin
    and dependencies, and the fabric8 Maven plugin for deploying to OpenShift. You
    also specify a MySQL JDBC driver dependency so you can update the records within
    the Cayambe database.
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: 书中代码的 /chapter11/kafka-consumer/ 目录中包含了 Kafka 消费者的所有代码。与生产者类似，你需要在 pom.xml 中添加
    `kafka-cdi-extension` 依赖项。pom.xml 的其余部分包含常规的 Thorntail 插件和依赖项，以及用于部署到 OpenShift
    的 fabric8 Maven 插件。你还指定了一个 MySQL JDBC 驱动依赖项，以便你可以更新 Cayambe 数据库中的记录。
- en: For connecting to the Cayambe database, you need to define a `DataSource`.
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接到 Cayambe 数据库，你需要定义一个 `DataSource`。
- en: Listing 11.3\. project-defaults.yml
  id: totrans-1148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.3\. project-defaults.yml
- en: '[PRE106]'
  id: totrans-1149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '***1*** Name of the DataSource in JNDI.'
  id: totrans-1150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** JNDI 中 DataSource 的名称。'
- en: '***2*** Uses the module created from the MySQL JDBC driver dependency'
  id: totrans-1151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 使用从 MySQL JDBC 驱动依赖项创建的模块'
- en: '***3*** URL to the MySQL database instance on OpenShift'
  id: totrans-1152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** OpenShift 上 MySQL 数据库实例的 URL'
- en: '***4*** Credentials for the Cayambe database'
  id: totrans-1153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** Cayambe 数据库的凭据'
- en: Finally, you create a class to process the records from the Kafka topic, as
    you receive them.
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你创建一个类来处理从 Kafka 主题接收到的记录。
- en: Listing 11.4\. `CategoryEventListener`
  id: totrans-1155
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.4\. `CategoryEventListener`
- en: '[PRE107]'
  id: totrans-1156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '***1*** As you did on the producer, you define the Kafka host and port for
    the configuration.'
  id: totrans-1157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 如你在生产者中做的那样，你为配置定义 Kafka 主机和端口。'
- en: '***2*** The JNDI name for the CayambeDS that you created with project-defaults.yml.
    It’s used by getDatasource(), so you can update the Cayambe database with changed
    Categories.'
  id: totrans-1158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 使用 project-defaults.yml 创建的 CayambeDS 的 JNDI 名称。它由 getDatasource()
    使用，因此你可以使用更改后的类别更新 Cayambe 数据库。'
- en: '***3*** @Consumer identifies the method as accepting Kafka topic records, and
    provides the necessary configuration to wire it up to the Kafka API. It defines
    the name of the topic you want records from, the type of the key, a unique consumer
    group identifier, and that you want the offset to start at the beginning of the
    topic.'
  id: totrans-1159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** @Consumer 将方法标识为接受 Kafka 主题记录，并提供将它们连接到 Kafka API 所需的配置。它定义了你想要记录的主题的名称、键的类型、一个唯一的消费者组标识符，以及你想要从主题的开始偏移量处开始。'
- en: '***4*** Method to receive the Kafka record, with parameters for the key and
    value types to be passed'
  id: totrans-1160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** 接收 Kafka 记录的方法，带有传递给键和值类型的参数'
- en: '***5*** Execute the SQL to remove the category.'
  id: totrans-1161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** 执行删除类别的 SQL 语句。'
- en: '***6*** Execute the SQL to remove the category from the category hierarchy,
    either as a child or parent.'
  id: totrans-1162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** 执行从类别层次结构中删除类别的 SQL 语句，无论是作为子节点还是父节点。'
- en: '***7*** Execute SQL to determine if a row for a category ID already exists.
    Determines whether you''re updating or inserving a record.'
  id: totrans-1163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7*** 执行 SQL 以确定是否存在类别 ID 的行。确定你是否正在更新或插入记录。'
- en: '***8*** Execute SQL to update the fields on a category in the database.'
  id: totrans-1164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8*** 执行 SQL 更新数据库中类别字段的操作。'
- en: '***9*** Execute SQL to insert the new category into the database, and insert
    it into the category hierarchy.'
  id: totrans-1165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9*** 执行 SQL 将新类别插入数据库，并将其插入到类别层次结构中。'
- en: '***10*** Method to handle SQL update execution.'
  id: totrans-1166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***10*** 处理 SQL 更新执行的方法。'
- en: '***11*** Method to check if a Category row exists in the database.'
  id: totrans-1167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***11*** 检查数据库中是否存在 Category 行的方法。'
- en: '***12*** Method for retrieving the DataSource from JNDI.'
  id: totrans-1168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***12*** 从 JNDI 获取 DataSource 的方法。'
- en: '`CategoryEventListener` registers a method to listen to the Kafka events, by
    defining the key type, value type, which topic you’re processing, a consumer group,
    and that you want to process all records in the stream from the beginning. When
    you receive a Kafka record, you then determine whether you need to remove a category,
    the value is `null`, or whether we’re processing a new or updated record.'
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: '`CategoryEventListener` 通过定义键类型、值类型、你正在处理的主题、消费者组以及你想要从流中从头开始处理所有记录，注册一个方法来监听
    Kafka 事件。当你收到 Kafka 记录时，然后确定你是否需要删除一个类别，值是 `null`，或者我们正在处理一个新或更新的记录。'
- en: To distinguish between update and new categories, you execute an SQL statement
    on the existing categories in Cayambe to see whether this record exists. If it
    does, it’s an update record; if it doesn’t, it’s a new one.
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了区分更新和新的类别，你需要在 Cayambe 中对现有类别执行 SQL 语句，以查看此记录是否存在。如果存在，则是一个更新记录；如果不存在，则是一个新记录。
- en: If you didn’t want the overhead of running an SQL statement to determine whether
    you’re dealing with an update or a new category, you could change the value type
    for the records in Kafka to be an enclosing object. The `Category` instance, the
    current value, can be a field on a new type, with a flag to indicate the type
    of change event that’s being dealt with.
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想运行 SQL 语句来确定你是否正在处理更新或新类别，你可以将 Kafka 中记录的值类型更改为封装对象。`Category` 实例、当前值可以是一个新类型上的字段，带有指示正在处理哪种更改事件的标志。
- en: 'Now that you’ve finished developing the Kafka consumer, you’re ready to see
    it all working in unison! But before you deploy the Kafka consumer you just created,
    to see the visual changes as they happen, it’s worth starting up the Cayambe hybrid
    from [chapter 10](kindle_split_020.xhtml#ch10) with the following:'
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经完成了 Kafka 消费者的开发，你准备好看到它协同工作！但在你部署刚刚创建的 Kafka 消费者之前，为了看到它们发生的视觉变化，值得从 [第
    10 章](kindle_split_020.xhtml#ch10) 启动 Cayambe 混合模式，如下所示：
- en: '[PRE108]'
  id: totrans-1173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'With Cayambe started, open a browser and navigate around the category tree.
    You should notice that any changes you made through the Admin microservice aren’t
    visible, which makes sense because you haven’t activated the process to update
    the Cayambe database with any changes. So let’s start your Kafka consumer now:'
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: Cayambe 启动后，打开浏览器并浏览类别树。你应该注意到你通过 Admin 微服务所做的任何更改都是不可见的，这是有道理的，因为你还没有激活更新 Cayambe
    数据库的任何更改的过程。所以现在让我们启动你的 Kafka 消费者：
- en: '[PRE109]'
  id: totrans-1175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: When the pod becomes operational, it should process all the records that are
    present on the Kafka topic, because you specified for it to begin at the earliest
    offset on the topic. You can open the logs of the service and see the console
    statements that were printed for each record processed.
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: 当 pod 变得可用时，它应该处理 Kafka 主题上所有现有的记录，因为你指定它从主题的最早偏移量开始。你可以打开服务的日志，查看为每个处理的记录打印的控制台语句。
- en: With the records processed by the Kafka consumer, go back to the Cayambe UI
    and refresh the page. When navigating through the category tree and finding categories
    that were changed through the Admin microservice, you’ll notice that they’re now
    updated or removed based on what you did earlier.
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Kafka 消费者处理过的记录，返回 Cayambe UI 并刷新页面。在浏览类别树并找到通过 Admin 微服务更改的类别时，你会注意到它们现在根据你之前所做的操作已更新或删除。
- en: You’ve successfully decoupled the data between the two systems so that one owns
    the data, the Admin microservice, and the other consumes a copy of it in a read-only
    manner. As an added benefit, as long as the Kafka producers and consumers are
    functioning, the data never becomes stale.
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经成功地将两个系统之间的数据解耦，一个拥有数据（Admin 微服务），另一个以只读方式消费其副本。作为额外的好处，只要 Kafka 生产者和消费者正在运行，数据永远不会过时。
- en: 11.4\. Additional exercises
  id: totrans-1179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4. 额外练习
- en: As discussed earlier in the chapter, for an additional exercise, try converting
    the Cayambe hybrid to use Debezium to process database entries directly, instead
    of by you producing records within the Admin microservice.
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所述，作为额外练习，尝试将 Cayambe 混合型转换为使用 Debezium 直接处理数据库条目，而不是在 Admin 微服务中由您生成记录。
- en: This will also provide another benefit over the current solution, as the category
    hierarchy can be completely reconstructed from the Kafka topic records whenever
    needed. The hierarchy will contain records for all the initial inserts you did
    to load the database initially, as well as any insertions, updates, and removals
    that have occurred since then.
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: 这也将为当前解决方案提供另一个优势，因为每当需要时，类别层次结构都可以完全从 Kafka 主题记录中重建。该层次结构将包含所有您最初为加载数据库而进行的初始插入记录，以及自那时以来发生的任何插入、更新和删除操作。
- en: Summary
  id: totrans-1182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Data streaming simplifies an architecture by enabling separate components or
    microservices to remain decoupled, while still using the same data.
  id: totrans-1183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据流通过使单独的组件或微服务保持解耦，同时仍然使用相同的数据，从而简化了架构。
- en: You can use data streaming with Apache Kafka to share data among microservices
    and applications without the need for REST calls to retrieve it.
  id: totrans-1184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 Apache Kafka 的数据流技术在微服务和应用程序之间共享数据，而无需通过 REST 调用来检索它。
- en: '|  |'
  id: totrans-1185
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-1186
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Additional details on developing microservices with Spring Boot can be found
    in the appendix.
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用 Spring Boot 开发微服务的更多详细信息，请参阅附录。
- en: '|  |'
  id: totrans-1188
  prefs: []
  type: TYPE_TB
  zh: '|  |'
