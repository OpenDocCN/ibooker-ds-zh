- en: 2 Java modules
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 Java 模块
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Java’s platform modules
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 的平台模块
- en: Changes to access control semantics
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问控制语义的变化
- en: Writing modular applications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写模块化应用程序
- en: Multi-release JARs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多版本 JAR
- en: As mentioned in chapter 1, versions of Java, up to and including Java 9, were
    delivered according to a feature-driven release plan, often with a major new capability
    that defined or was strongly associated with the release.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如第 1 章所述，Java 的版本，直到包括 Java 9，都是根据以功能驱动的发布计划交付的，通常包含一个定义或与发布强相关的主要新功能。
- en: For Java 9, this feature was Java Platform Modules (also known as JPMS, Jigsaw,
    or just “modules”). This is a major enhancement and change to the Java platform
    that had been discussed for many years—it was originally conceived of as potentially
    shipping as a part of Java 7, back in 2009/2010.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Java 9，这个特性是 Java 平台模块（也称为 JPMS、Jigsaw 或简称为“模块”）。这是对 Java 平台的重大增强和改变，它已经讨论了很多年——它最初是在
    2009/2010 年作为 Java 7 的一部分可能发布的。
- en: In this chapter, we will explain the reasons modules are needed, as well as
    the new syntax used to articulate modularity concepts and how to use them in your
    applications. This will enable you to use JDK and third-party modules in your
    build as well as packaging apps or libraries as modules.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将解释为什么需要模块，以及用于阐述模块概念的新语法以及如何在您的应用程序中使用它们。这将使您能够在构建时使用 JDK 和第三方模块，以及将应用程序或库作为模块打包。
- en: Note Modules represent a new way of packaging and deploying your code, and adopting
    them will make your applications better. However, if you just want to start using
    modern Java features (11 or 17), there is no need for you to adopt modules immediately
    unless you want to.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 注意模块代表了一种新的代码打包和部署方式，采用它们会使您的应用程序变得更好。然而，如果您只想开始使用现代 Java 功能（11 或 17），您无需立即采用模块，除非您想这么做。
- en: The arrival of modules has profound implications for the architecture of applications,
    and modules have many benefits to modern projects that are concerned about such
    aspects as process footprint, startup cost, and warmup time. Modules can also
    help to solve the so-called JAR Hell problem that can plague Java applications
    with complex dependencies. Let’s get to know them.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 模块的出现对应用程序的架构有深远的影响，并且模块对关注诸如进程占用、启动成本和预热时间等方面的现代项目有许多好处。模块还可以帮助解决可能困扰具有复杂依赖的
    Java 应用程序的所谓 JAR 地狱问题。让我们来了解它们。
- en: 2.1 Setting the scene
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 设置场景
- en: 'A *module* is a fundamentally new concept in the Java language (as of Java
    9). It is a unit of application deployment and dependency that has semantic meaning
    to the runtime. This is different from existing concepts in Java for the following
    reasons:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*模块*是 Java 语言中的一个基本新概念（截至 Java 9）。它是一个应用程序部署和依赖的单位，对运行时有语义意义。这与 Java 中现有的概念不同，以下是一些原因：'
- en: JAR files are invisible to the runtime—they’re basically just zipped directories
    containing class files.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JAR 文件对运行时来说是不可见的——它们基本上只是包含类文件的压缩目录。
- en: Packages are really just namespaces to group classes together for access control.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包实际上只是用于将类分组在一起以进行访问控制的命名空间。
- en: Dependencies are defined at the class level only.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖仅在类级别定义。
- en: Access control and reflection combine in a way that produces a fundamentally
    open system without clear deployment unit boundaries and with minimal enforcement.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问控制和反射以一种方式结合，产生了一个基本开放的系统，没有清晰的部署单元边界，并且执行力度最小。
- en: Modules, on the other hand
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面
- en: Define dependency information between modules, so all sorts of resolution and
    linkage problems can be detected at compile or application start time
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义模块之间的依赖信息，以便在编译或应用程序启动时检测到各种解析和链接问题
- en: Provide proper encapsulation, so internal packages and classes can be made safe
    from pesky users who might want to fiddle with them
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供适当的封装，因此内部包和类可以免受可能想要篡改它们的烦人用户的干扰
- en: Are a proper unit of deployment with metadata that can be understood and consumed
    by a modern Java runtime and are represented in the Java type system (e.g., reflectively)
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是一个具有元数据的适当部署单元，这些元数据可以被现代 Java 运行时理解和消费，并在 Java 类型系统中表示（例如，通过反射）。
- en: Note Before modules, within the core language and runtime environment, there
    was no aggregated dependency metadata. Instead, it was defined only in build systems
    like Maven or in third-party modules systems (such as OSGI or JBoss modules) that
    the JVM neither knows nor cares about.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在模块之前，在核心语言和运行时环境中，没有聚合的依赖元数据。相反，它仅在Maven等构建系统或JVM既不知道也不关心的第三方模块系统（如OSGI或JBoss模块）中定义。
- en: Java platform modules represent an implementation of a missing concept within
    the Java world as it existed at version 8.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Java平台模块代表了在版本8存在的Java世界中一个缺失概念的实现。
- en: Note Java modules are often packaged as special JAR files, but they are not
    tied to that format (we will see other possible formats later).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Java模块通常打包为特殊的JAR文件，但它们并不局限于该格式（我们将在后面看到其他可能的格式）。
- en: The aim of the modules system is to make the deployment units (modules) as independent
    of each other as possible. The idea is that modules are able to be separately
    loaded and linked, although in practice, real applications may well end up depending
    on a group of modules that provide related capabilities (such as security).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 模块系统的目标是使部署单元（模块）尽可能相互独立。想法是模块能够分别加载和链接，尽管在实践中，实际应用程序可能最终依赖于提供相关功能（如安全）的一组模块。
- en: 2.1.1 Project Jigsaw
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.1 项目Jigsaw
- en: 'The project within OpenJDK to deliver the modules feature was known as *Project
    Jigsaw*. It aimed to deliver a full-featured modularity solution which included
    the following goals:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenJDK中交付模块功能的项目的名称是*项目Jigsaw*。它旨在提供一个功能齐全的模块化解决方案，包括以下目标：
- en: Modularizing the JDK platform source
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块化JDK平台源
- en: Reducing the process footprint
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少进程占用
- en: Improving the application startup time
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高应用程序启动时间
- en: Having modules available to both the JDK and to application code
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使模块对JDK和应用代码都可用
- en: Allowing true strict encapsulation for the first time in Java
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首次在Java中实现真正的严格封装
- en: Adding new, previously impossible access control modes to the Java language
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向Java语言添加新的、以前不可能的访问控制模式
- en: 'These goals were, in turn, driven by the following other objectives that are
    more closely focused on the JDK and Java runtime:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这些目标反过来又是由以下其他目标驱动的，这些目标更专注于JDK和Java运行时：
- en: Bringing the end of a single, monolithic runtime JAR (`rt.jar`)
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带来单一单体运行时JAR（`rt.jar`）的终结
- en: Properly encapsulating and protecting JDK internals
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确封装和保护JDK内部组件
- en: Allowing major internal changes to be made (including changes that will break
    unauthorized non-JDK usage)
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许进行重大内部更改（包括将破坏未经授权的非JDK使用的更改）
- en: Introducing modules as “super packages”
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将模块作为“超级包”引入
- en: These secondary goals may require a bit more explanation because they are more
    closely connected to internal and implementation aspects of the platform.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这些次要目标可能需要更多的解释，因为它们与平台内部和实现方面更为紧密相关。
- en: Modular, not monolithic Java runtime
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化而非单体化的Java运行时
- en: The legacy JAR format is essentially just a zip file that contains classes.
    It dates back to the earliest days of the platform and is in no way optimized
    for Java classes and applications. Abandoning the JAR format for the platform
    classes can help in several areas—for example, enabling much better startup performance.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的JAR格式本质上只是一个包含类的zip文件。它可以追溯到平台最早的日子，并且根本不是为Java类和应用程序优化的。放弃平台类对JAR格式的使用可以在多个领域提供帮助——例如，实现更好的启动性能。
- en: Modules provide two new formats—*JMOD* and *JIMAGE*—which are used at different
    times (compile/link time and runtime, respectively) in the program lifecycle.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 模块提供了两种新的格式——*JMOD*和*JIMAGE*，它们在程序生命周期的不同时间（编译/链接时间和运行时）使用。
- en: The JMOD format is somewhat similar to the existing JAR format, but it has been
    modified to allow the inclusion of native code as part of a single file (rather
    than having to ship a separate shared object file as is done in Java 8). For most
    developer needs, including publishing modules to Maven, it’s better to package
    your own modules as modular JARs rather than as JMODs.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: JMOD格式与现有的JAR格式有些相似，但它已被修改以允许将本地代码作为单个文件的一部分包含进来（而不是像Java 8那样必须单独发送一个共享对象文件）。对于大多数开发者的需求，包括将模块发布到Maven，将您自己的模块打包为模块化JAR而不是JMOD会更好。
- en: The JIMAGE format is used to represent a Java runtime image. Until Java 8, only
    two possible runtime images existed (JDK and JRE), but this was largely an accident
    of history. Oracle introduced the *Server JRE* with Java 8 (as well as *Compact
    Profiles*) as a stepping-stone toward full modularity. These images basically
    removed some capabilities (e.g., GUI frameworks) to provide a smaller footprint
    specifically geared toward the needs of server-side applications.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: JIMAGE格式用于表示Java运行时图像。在Java 8之前，只有两种可能的运行时图像存在（JDK和JRE），但这在很大程度上是历史的一个偶然。Oracle在Java
    8中引入了*服务器JRE*（以及*紧凑配置文件*）作为迈向完全模块化的垫脚石。这些图像基本上删除了一些功能（例如，GUI框架），以提供更小的足迹，专门针对服务器端应用程序的需求。
- en: A modular application has enough metadata that the exact set of dependencies
    can be known before program start. This leads to the possibility that only what
    is needed has to be loaded, which is much more efficient. It is possible to go
    even further and define a *custom runtime image* that can be shipped along with
    an application and that does not contain a full, general-purpose installation
    of Java but only what the application requires. We will encounter this last possibility
    at the end of this chapter when we meet the `jlink` tool.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化应用程序具有足够的元数据，可以在程序启动前知道确切的依赖集。这导致了一种可能性，即只需要加载所需的内容，这要高效得多。甚至可以更进一步，定义一个*自定义运行时图像*，它可以与应用程序一起分发，并且不包含完整的通用Java安装，而只包含应用程序所需的内容。我们将在本章末尾遇到`jlink`工具时遇到这种最后一种可能性。
- en: 'For now, let’s meet the `jimage` tool that’s available to show details about
    a Java runtime image. For example, for a Java 15 full runtime (i.e., what used
    to be contained in a JDK), see the following code sample:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，让我们来认识一下`jimage`工具，它可以用来显示Java运行时图像的详细信息。例如，对于一个Java 15完整运行时（即过去包含在JDK中的内容），请看以下代码示例：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: or
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Moving away from `rt.jar` allows for better startup performance and to optimize
    for only what is needed by an application. The new formats are designed to be
    opaque to the developer and are implementation-dependent. It is no longer possible
    to just unzip `rt.jar` and get back the JDK’s class library. This is just one
    step, however, in making the platform’s internals less accessible to Java programmers,
    which was one of the goals of the modules system.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 离开`rt.jar`可以提升启动性能，并针对应用程序所需的内容进行优化。新格式旨在对开发者透明，并且依赖于实现。现在已不再可能简单地解压`rt.jar`并恢复JDK的类库。然而，这只是使平台内部对Java程序员更不透明的一步，这也是模块系统的一个目标。
- en: Encapsulate the internals
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 封装内部结构
- en: The contract between the Java platform and its users was always intended to
    be an API contract—that backward compatibility would be maintained at the interface
    level, *not* in the details of the implementation.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Java平台与其用户之间的合同原本旨在是一个API合同——向后兼容性将在接口级别得到保持，*而不是*在实现的细节中。
- en: However, Java developers have not held up their end of the bargain and, instead,
    over time, have tended to use parts of the platform implementation that were never
    intended for public consumption.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Java开发者并没有履行他们的承诺，相反，随着时间的推移，他们倾向于使用平台实现中从未打算公开消费的部分。
- en: This is problematic, because the OpenJDK platform developers want the freedom
    to modify the implementation of the JVM and platform classes to future-proof and
    modernize them—to provide new features and better performance without worrying
    about breaking user applications.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有问题的，因为OpenJDK平台开发者希望有修改JVM和平台类实现的自由，以使其面向未来和现代化——提供新功能和更好的性能，而无需担心破坏用户应用程序。
- en: One major impediment to making breaking changes to the platform internals is
    Java’s approach to access control as it exists in Java 8\. Java only defines `public`,
    `private`, `protected`, and `package-private` as access control levels, and these
    modifiers are applied only at the class level and finer.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对平台内部进行重大更改的主要障碍是Java 8中存在的访问控制方法。Java只定义了`public`、`private`、`protected`和`package-private`作为访问控制级别，并且这些修饰符仅应用于类级别及其更细的级别。
- en: We can work around these restrictions in numerous ways (such as reflection or
    creating additional classes in relevant packages), and there is no foolproof (or
    expert-proof) way to fully protect the internals.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过多种方式（如反射或在相关包中创建额外的类）来绕过这些限制，而且没有万无一失（或专家级）的方法来完全保护内部结构。
- en: The use of the workarounds to access the internals was historically often for
    valid reasons. As the platform has matured, however, an official way of accessing
    almost all of the desired functionality has been added. The unprotected internals,
    therefore, represent a liability for the platform going forward without a corresponding
    benefit—and modularity was one way to remove that legacy problem.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用替代方案访问内部的功能在历史上往往是出于正当理由。然而，随着平台的成熟，已经添加了一种官方方式来访问几乎所有期望的功能。因此，未受保护的内部功能代表了平台未来的一个风险——而没有相应的利益——模块化是解决这个遗留问题的方法之一。
- en: To sum up, Project Jigsaw was a way to solve several problems at once—primarily
    to reduce runtime size, improve startup time, and tidy up dependencies between
    internal packages. These were problems that were hard (or impossible) to tackle
    incrementally. Opportunities for these types of “nonlocal” improvement do not
    come along very often, especially in mature software platforms, so the Jigsaw
    team wanted to take advantage of their circumstances.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，Project Jigsaw是一种同时解决几个问题的方法——主要是减少运行时大小、提高启动时间和整理内部包之间的依赖关系。这些问题是难以逐步解决的（或不可能解决）。这类“非局部”改进的机会并不常见，尤其是在成熟的软件平台上，因此Jigsaw团队希望利用他们的情况。
- en: The JVM is modular now
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: JVM现在是模块化的了
- en: 'To see this, consider the next very simple program:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到这一点，考虑下一个非常简单的程序：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Compiling and running this code produces a runtime exception, shown next:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 编译和运行此代码会产生一个运行时异常，如下所示：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: However, we can clearly see that the format of the stack trace has changed somewhat
    from the form that was used in Java 8\. In particular, the stack frames are now
    qualified by a module name (`java.base`) as well as a package name, class name,
    and line number. This clearly shows that the modular nature of the platform is
    pervasive and is present for even the simplest program.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以清楚地看到，堆栈跟踪的格式与Java 8中使用的格式有所不同。特别是，现在堆栈帧由模块名称（`java.base`）、包名、类名和行号限定。这清楚地表明，平台的模块化性质是普遍存在的，甚至在最简单的程序中也存在。
- en: 2.1.2 The module graph
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.2 模块图
- en: Key to all of modularity is the *module graph*, which is a representation of
    how modules depend on each other. Modules make their dependencies explicit via
    some new syntax, and those dependencies are hard guarantees that the compiler
    and runtime can rely upon. One very important concept is that the module graph
    must be a *directed acyclic graph* (DAG), so in mathematical terms, there cannot
    be any cyclic dependencies.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 所有模块化的关键在于**模块图**，它表示模块之间是如何相互依赖的。模块通过一些新的语法来明确它们的依赖关系，而这些依赖关系是编译器和运行时可以依赖的硬性保证。一个非常重要的概念是模块图必须是一个**有向无环图**（DAG），在数学术语中，不能有任何循环依赖。
- en: Note It is important to realize that in modern Java environments, all applications
    run on top of the modular JRE; a “modular mode” and a “legacy classpath mode”
    don’t exist.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：重要的是要认识到，在现代Java环境中，所有应用程序都是在模块化的JRE之上运行的；不存在“模块模式”和“遗留类路径模式”。
- en: Although not every developer needs to become an expert in the modules system,
    it makes sense that a well-grounded Java developer would benefit from a working
    knowledge of a new subsystem that has changed the way that all programs are executed
    on the JVM. Let’s take a look at a first view of the modules system, shown in
    figure 2.1, as most developers encounter it.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不是每个开发者都需要成为模块系统的专家，但一个扎实的Java开发者对一个新的子系统有实际了解是有意义的，这个子系统改变了所有程序在JVM上执行的方式。让我们看看模块系统的第一个视图，如图2.1所示，这是大多数开发者遇到的情况。
- en: '![](../Images/CH02_F01_Evans2.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH02_F01_Evans2.png)'
- en: Figure 2.1 JDK system modules (simplified view)
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 JDK系统模块（简化视图）
- en: In figure 2.1, we can see a simplified view of some of the main modules in the
    JDK. Note that the module `java.base` is always a dependency of every module.
    When drawing pictures of module graphs, the implicit dependency on `java.base`
    is often eliminated just to reduce visual clutter.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在图2.1中，我们可以看到JDK中一些主要模块的简化视图。请注意，模块`java.base`始终是每个模块的依赖项。在绘制模块图时，对`java.base`的隐式依赖通常被消除，以减少视觉上的杂乱。
- en: The clean and relatively simple set of module boundaries that we can see in
    figure 2.1 needs to be contrasted with the state of the JDK in Java 8\. Unfortunately,
    before modules, Java’s top-level unit of code was the package—and Java 8 had almost
    1,000 of them in the standard runtime. This would be essentially impossible to
    draw, and the dependencies within the graph would be so complex that a human would
    not be able to make sense of it.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在图2.1中看到的干净且相对简单的模块边界需要与Java 8中JDK的状态进行对比。不幸的是，在模块出现之前，Java的最高级代码单元是包——Java
    8在标准运行时中就有近1000个包。这基本上是无法绘制的，图中的依赖关系会如此复杂，以至于人类无法理解。
- en: 'Taking the premodular JDK and reshaping it into the well-defined form that
    we see today was not easy to achieve, and the path to delivering JDK modularity
    was long. Java 9 was released in September 2017, but development of the feature
    had begun several years before that with the Java 8 release train. In particular,
    there were several subgoals that were necessary first steps for the delivery of
    modules, including the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 将预模块化的JDK重塑成我们今天看到的良好定义的形式并不容易实现，交付JDK模块化的道路也很长。Java 9于2017年9月发布，但该功能的发展始于几年前的Java
    8发布列车。特别是，有几个子目标是模块交付的必要第一步，包括以下内容：
- en: Modularizing the layout of source code in the JDK (JEP 201)
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块化JDK中源代码布局（JEP 201）
- en: Modularizing the structure of runtime images (JEP 220)
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块化运行时图像结构（JEP 220）
- en: Disentangling complex implementation dependencies between JDK packages
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解耦JDK包之间的复杂实现依赖
- en: Even though the finished modules feature did not ship until Java 9, much of
    the cleanup was undertaken as part of Java 8 and even allowed a feature known
    as *compact profiles* (which we will meet at the end of this chapter) to ship
    as part of that release.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管模块功能直到Java 9才发布，但大部分清理工作是在Java 8期间进行的，甚至允许一个名为*紧凑配置文件*（我们将在本章末尾遇到）的功能作为该版本的一部分发布。
- en: 2.1.3 Protecting the internals
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.3 保护内部结构
- en: One of the major problems that modules needed to solve was overcoupling of user
    Java frameworks to internal implementation details. For example, this piece of
    Java 8 code extends an internal class to get access to a low-level *URL canonicalizer*.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 模块需要解决的主要问题之一是用户Java框架与内部实现细节的过度耦合。例如，这段Java 8代码通过扩展一个内部类来获取访问低级*URL规范器*的权限。
- en: 'The following code is for demonstration purposes only, so we can have a concrete
    example to discuss modules and access control—your code should never access internal
    classes directly:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码仅用于演示目的，以便我们可以有一个具体的例子来讨论模块和访问控制——你的代码永远不应该直接访问内部类：
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A URL canonicalizer is a piece of code that takes a URL in one of the various
    forms permitted by the URL standard and converts it to a standard (canonical)
    form. The intent is that canonical URLs can act as a single source of truth for
    the location of content that can be accessed via multiple different possible URLs.
    If we try to compile it using Java 8, `javac` warns us that we’re accessing an
    internal API, as shown next:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: URL规范器是一段代码，它将URL标准允许的多种形式之一转换为标准（规范）形式。目的是规范URL可以作为多个不同可能的URL访问的内容位置的单一来源。如果我们尝试使用Java
    8编译它，`javac`会警告我们正在访问内部API，如下所示：
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: However, by default, the compiler still allows access, and the result is a user
    class that is tightly coupled to the internal implementation of the JDK. This
    connection is fragile and will break if the called code moves or is replaced.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，默认情况下，编译器仍然允许访问，结果是用户类与JDK的内部实现紧密耦合。这种联系是脆弱的，如果被调用的代码移动或被替换，它就会断裂。
- en: If enough developers abuse this openness, then this leads to a situation in
    which it is difficult or impossible to make changes to the internals, because
    to do so would break deployed libraries and applications.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果足够的开发者滥用这种开放性，那么这会导致一种难以或不可能对内部进行更改的情况，因为这样做会破坏已部署的库和应用。
- en: Note The `URLCanonicalizer` class needs to be called from several different
    packages, not just its own, so it has to be a public class—it can’t be package-private—meaning
    it’s accessible to anyone.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：`URLCanonicalizer`类需要从多个不同的包中调用，而不仅仅是它自己的包，因此它必须是一个公开的类——不能是包私有——这意味着它对任何人都是可访问的。
- en: The solution to this very general problem was to make a one-time change to Java’s
    model of access control. This change applies both to user code calling the JDK
    and to applications calling third-party libraries.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个非常普遍的问题的方法是对 Java 访问控制模型进行一次性的更改。这个更改既适用于调用 JDK 的用户代码，也适用于调用第三方库的应用程序。
- en: 2.1.4 New access control semantics
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.4 新的访问控制语义
- en: 'Modules add a new concept to Java’s access control model: the idea of *exporting*
    a package. In Java 8 and earlier, code in any package can call public methods
    on any public class in any package. This is sometimes called “shotgun privacy,”
    after a famous quote about another programming language:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 模块为 Java 的访问控制模型添加了一个新概念：*导出* 包的想法。在 Java 8 及更早版本中，任何包中的代码都可以调用任何包中任何公共类的公共方法。这有时被称为“猎枪隐私”，这是关于另一种编程语言的一个著名引言：
- en: Perl doesn’t have an infatuation with enforced privacy. It would prefer that
    you stayed out of its living room because you weren’t invited, not because it
    has a shotgun.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Perl 并没有对强制隐私的迷恋。它更希望你不进入它的客厅，因为你没有被邀请，而不是因为它有猎枪。
- en: —Larry Wall
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ——拉里·沃德
- en: For Java, however, shotgun privacy represented a major problem. More and more
    libraries were using internal APIs to provide capabilities that were difficult
    or impossible to provide in another way, and this threatened to harm the long-term
    health of the platform.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于 Java 来说，猎枪隐私代表了一个重大问题。越来越多的库正在使用内部 API 来提供难以或无法以其他方式提供的功能，这可能会损害平台的长期健康。
- en: As of Java 8, there was no way to enforce access control across an entire package.
    This meant that the JDK team was unable to define a public API and know with certainty
    that clients of that API could not subvert it or directly link to the internal
    implementation.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 Java 8，无法在整个包中强制执行访问控制。这意味着 JDK 团队无法定义一个公共 API，并确信该 API 的客户端无法绕过它或直接链接到内部实现。
- en: The convention that anything in a package that starts `java` or `javax` is a
    public API and everything else is internal only is just that—a convention. No
    VM or class loading mechanism enforces that, as we’ve already seen.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 任何以 `java` 或 `javax` 开头的包中的内容都是公共 API，而其他所有内容仅限于内部，这种约定只是约定而已。没有虚拟机或类加载机制强制执行这一点，正如我们之前所看到的。
- en: 'With modules, however, this changes. The `exports` keyword has been introduced
    to indicate which packages are considered the public API of a module. In the modular
    JDK, the package `sun.net` is not exported, so the previous Java 8 URL canonicalizer
    code will not compile. Here’s what happens when we try with Java 11:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着模块的出现，这发生了变化。引入了 `exports` 关键字来指示哪些包被认为是模块的公共 API。在模块化 JDK 中，`sun.net`
    包没有被导出，因此之前的 Java 8 URL 规范化代码将无法编译。以下是尝试使用 Java 11 时发生的情况：
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that the form of the error message explicitly says that the `sun.net` package
    is now not visible—the compiler cannot even see the symbol. This is a fundamental
    change in the way Java access control works. Only methods on exported packages
    are accessible. It is no longer the case that a public method on a public class
    is automatically visible to all code everywhere.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，错误信息的格式明确指出 `sun.net` 包现在不可见——编译器甚至看不到该符号。这是 Java 访问控制工作方式的一个根本性变化。只有导出包上的方法才是可访问的。公共类上的公共方法不再是自动对所有代码都可见的。
- en: However, this change may not be visible to many developers. If you’re a Java
    developer who plays by the rules, you will never have called an API in an internal
    package directly. However, you might use a library or a framework that does, so
    it’s good to understand what has actually changed and avoid the FUD.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个变化可能对许多开发者来说并不明显。如果你是一个遵守规则的 Java 开发者，你永远不会直接调用内部包中的 API。然而，你可能会使用一个库或框架，它会这样做，因此了解实际上发生了什么并避免恐惧、不确定和怀疑是好的。
- en: Note Proper encapsulation is not free, and premodular Java is actually a very
    open system. It is perhaps only natural that when confronted with the more structured
    system that modules provide, many Java developers find some of the extra protections
    constraining or frustrating. Let’s meet the syntax that encodes these new semantics
    of Java modules.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 正确的封装不是免费的，而且预模块化的 Java 实际上是一个非常开放的系统。面对模块提供的更结构化的系统，许多 Java 开发者可能会觉得一些额外的保护限制或令人沮丧。让我们来认识一下编码
    Java 模块新语义的语法。
- en: 2.2 Basic modules syntax
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 基本模块语法
- en: 'A Java platform module is defined as a conceptual unit, which is a collection
    of packages and classes that are declared and loaded as a single entity. Each
    module must declare a new file, called a *module descriptor*, represented as a
    module-info.java file, which contains the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Java平台模块被定义为概念单元，它是一组声明和加载为单一实体的包和类。每个模块必须声明一个新的文件，称为*模块描述符*，表示为module-info.java文件，其中包含以下内容：
- en: Module name
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块名称
- en: Module dependencies
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块依赖
- en: Public API (packages exported)
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共API（导出的包）
- en: Reflective access permissions
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反射访问权限
- en: Services provided
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供的服务
- en: Services consumed
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消耗的服务
- en: 'This file must be placed in a suitable place within the source hierarchy. For
    example, within a Maven-style layout, the full module name `wgjd.discovery` appears
    directly after src/main/java and contains module-info.java and the package root,
    as shown here:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件必须放置在源层次结构中的合适位置。例如，在Maven风格的布局中，完整的模块名称`wgjd.discovery`直接位于src/main/java之后，包含module-info.java和包根，如下所示：
- en: '[PRE7]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is, of course, slightly different from nonmodular Java projects, which
    often nominate src/main/java as the root of the package directories. However,
    the familiar hierarchical structure of packages under the module root is still
    visible.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这当然与非线性模块的Java项目略有不同，后者通常将src/main/java指定为包目录的根。然而，在模块根下的包的熟悉层次结构仍然可见。
- en: Note When a modular project is built, the module descriptor will be compiled
    into a class file, module-info.class, but that file (despite its name) is actually
    quite different from the usual sort of class file that we see in the Java platform.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：当模块化项目构建时，模块描述符将被编译成一个类文件，module-info.class，但这个文件（尽管它的名字如此）实际上与我们在Java平台中看到的普通类文件有很大不同。
- en: In this chapter we will address the basic directives of the descriptor but will
    not be delving deeply into all of the capabilities that modules provide. In particular,
    we will not discuss the services aspects of modules.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论描述符的基本指令，但不会深入探讨模块提供的所有功能。特别是，我们不会讨论模块的服务方面。
- en: 'A simple example of a module descriptor looks like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一个模块描述符的简单例子如下所示：
- en: '[PRE8]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This contains three new keywords—`module`, `exports`, and `requires`—in a syntax
    that should be suggestive to most Java programmers. The keyword `module` simply
    declares the opening scope of the declaration.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这包含三个新关键字——`module`、`exports`和`requires`——其语法对大多数Java程序员来说应该是启发性的。关键字`module`简单地声明声明的开始范围。
- en: 'Note The name module-info.java is reminiscent of package-info.java, and they
    are somewhat related. Because packages are not really visible to the runtime,
    a workaround (hack?) was needed to provide a hook for annotation metadata that
    was intended to apply to the whole package. This hack was `package-info.java`.
    In the modular world, much more metadata can be associated with a module, and
    so a similar name was chosen. The new syntax actually consists of *restricted
    keywords*, which are described in the Java Language Specification like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：模块-info.java的名称让人联想到package-info.java，并且它们有些相关。因为包对运行时来说实际上并不可见，所以需要一个解决方案（黑客技巧？）来提供应用于整个包的注解元数据的钩子。这个解决方案是`package-info.java`。在模块化的世界中，可以与模块关联更多的元数据，因此选择了类似的名字。新的语法实际上由*限制性关键字*组成，这在Java语言规范中是这样描述的：
- en: 'A further ten character sequences are restricted keywords: `open`, `module`,
    `requires`, `transitive`, `exports`, `opens`, `to`, `uses`, `provides`, and `with`.
    These character sequences are tokenized as keywords solely where they appear as
    terminals in the `ModuleDeclaration` and `ModuleDirective` productions.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 另有十个字符序列被限制为关键字：`open`、`module`、`requires`、`transitive`、`exports`、`opens`、`to`、`uses`、`provides`和`with`。这些字符序列仅在它们出现在`ModuleDeclaration`和`ModuleDirective`产生式中的终端位置时被标记为关键字。
- en: In simpler language, this means these new keywords will appear only in the descriptor
    for the module metadata and are not treated as keywords in general Java source.
    However, it is good practice to avoid these words as Java identifiers, even if
    it is technically legal to use them. This is the same situation as we saw with
    `var` in chapter 1, and we will use looser language and refer to them as “keywords”
    throughout the rest of the book.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 用更简单的语言来说，这意味着这些新关键字只会出现在模块元数据的描述符中，而不是在一般的Java源代码中被视为关键字。然而，避免将这些词用作Java标识符是一个好的实践，尽管在技术上使用它们是合法的。这与我们在第1章中看到的`var`的情况相同，并且我们将在本书的其余部分使用更宽松的语言，并将它们称为“关键字”。
- en: 2.2.1 Exporting and requiring
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.1 导出和需求
- en: The `exports` keyword expects an argument, which is a package name. In our example
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`exports` 关键字期望一个参数，即包名称。在我们的例子中'
- en: '[PRE9]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: means that our example discovery module exports the package `wgjd.discovery`,
    but because the descriptor does not mention any other packages, `wgjd.discovery
    .internal` is not exported and is not normally available to code outside the discovery
    module.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 意味着我们的示例发现模块导出了 `wgjd.discovery` 包，但由于描述符没有提及任何其他包，`wgjd.discovery.internal`
    没有被导出，并且通常不可用于发现模块外的代码。
- en: Multiple `exports` lines are possible in a module descriptor and, in fact, are
    quite usual. Fine-grained control is also possible with the `exports ... to ...`
    syntax that indicates only certain external modules may access a specified package
    from this module.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 模块描述符中可以有多个 `exports` 行，实际上这是相当常见的。使用 `exports ... to ...` 语法也可以实现细粒度的控制，该语法仅指示某些外部模块可以访问此模块中指定的包。
- en: Note A single module `exports` one or more packages that constitute the public
    API of the module and that are the only packages that code in other modules may
    access unless an override (e.g., command-line switch) is used.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意一个模块 `exports` 一个或多个构成模块公共 API 的包，并且是其他模块中的代码可以访问的唯一包，除非使用覆盖（例如，命令行开关）。
- en: 'The `requires` keyword declares a dependency of the current module and always
    requires an argument, which is a *module* name, rather than a package name. The
    `java.base` module contains the most fundamental packages and classes of the Java
    runtime. We can use the `jmod` command to take a look, as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`requires` 关键字声明了当前模块的依赖关系，并且总是需要一个参数，即一个 *模块* 名称，而不是包名称。`java.base` 模块包含了
    Java 运行时最基础的包和类。我们可以使用 `jmod` 命令来查看，如下所示：'
- en: '[PRE10]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: These packages are used by every Java program, and so `java.base` is always
    an implicit dependency of every module, so does not need to be explicitly declared
    in `module-info.java`. This is in much the same way that `java.lang` is an implicit
    `import` into every Java class.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这些包被每个 Java 程序使用，因此 `java.base` 总是每个模块的隐式依赖，所以不需要在 `module-info.java` 中显式声明。这与
    `java.lang` 是每个 Java 类的隐式 `import` 的方式非常相似。
- en: 'Some of the basic rules and conventions for module names follow:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 模块名称的一些基本规则和约定如下：
- en: Modules live in a global namespace.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块存在于一个全局命名空间中。
- en: Module names must be unique.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块名称必须是唯一的。
- en: Use the standard `com.company.project` convention if appropriate.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果适用，请使用标准的 `com.company.project` 约定。
- en: One important basic modules concept is *transitivity*. Let’s take a closer look
    at this concept, because it occurs not only in the context of modules but also
    in Java’s more familiar library (i.e., JAR file) dependencies (which we will meet
    in chapter 11).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的基本模块概念是 *传递性*。让我们更仔细地看看这个概念，因为它不仅出现在模块的上下文中，也出现在 Java 更熟悉的库（即 JAR 文件）依赖中（我们将在第
    11 章中遇到）。
- en: 2.2.2 Transitivity
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.2 传递性
- en: '*Transitivity* is a very general computing term, not specific to Java at all,
    which describes the situation that occurs when a code unit requires other units
    to function correctly, and those units can themselves require other units. Our
    original code may never even mention these “one step removed” code units, but
    they still need to be present or our application will not work.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*传递性* 是一个非常通用的计算机术语，并不特指 Java，它描述了当代码单元需要其他单元以正确运行时的情况，而这些单元本身也可以需要其他单元。我们的原始代码可能甚至从未提及这些“一步之遥”的代码单元，但它们仍然需要存在，否则我们的应用程序将无法工作。'
- en: 'To understand why this is the case—and why it is important—consider two modules
    `A` and `B` where `A` requires `B`. There are two different possible cases:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解为什么是这样——以及为什么这很重要——考虑两个模块 `A` 和 `B`，其中 `A` 依赖于 `B`。有两种不同的情况可能发生：
- en: '`A` does not export any methods that mention types from `B` directly.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`A` 不导出任何直接提及 `B` 中类型的方法。'
- en: '`A` includes types from `B` as part of its API.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`A` 将 `B` 中的类型作为其 API 的一部分包含。'
- en: In the case where `A` exports methods that return types that are defined in
    `B`, this would have the effect that `A` is not usable unless clients of `A` (those
    modules that require `A`) also require `B`. This is quite an unnecessary overhead
    on clients of `A`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `A` 导出返回类型定义在 `B` 中的方法的情况下，这将导致 `A` 无法使用，除非 `A` 的客户端（那些需要 `A` 的模块）也要求 `B`。这对
    `A` 的客户端来说是一个相当不必要的开销。
- en: 'The modules system provides some simple syntax to solve this: `requires transitive`.
    If a module `A` requires another module transitively, then any code that depends
    on `A` will also, implicitly, pick up the transitive dependencies as well.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 模块系统提供了一些简单的语法来解决这个问题：`requires transitive`。如果一个模块`A`需要另一个模块的传递性，那么任何依赖于`A`的代码也将隐式地获取传递性依赖。
- en: Although usage of `requires` `transitive` is unavoidable in some use cases,
    in general, when writing modules, minimizing use of transitivity is considered
    a best practice. We will have more to say about transitive dependencies when we
    discuss build tools in chapter 11\.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在某些用例中不可避免地要使用`requires` `transitive`，但在一般情况下，编写模块时，最小化使用传递性被认为是一种最佳实践。当我们讨论第11章中的构建工具时，我们将有更多关于传递性依赖的内容要讲。
- en: 2.3 Loading modules
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 加载模块
- en: 'If the first time you’ve encountered Java class loading is when we briefly
    mentioned it in chapter 1 and you have no other experience of it, don’t worry.
    The most important thing to know right now is that the following four types of
    modules exist, some of which have slightly different behaviors when loaded:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你第一次遇到Java类加载是在第1章中我们简要提到它，并且你没有其他相关经验，不要担心。现在最重要的知道的事情是以下四种类型的模块存在，其中一些在加载时具有略微不同的行为：
- en: Platform modules
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平台模块
- en: Application modules
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用模块
- en: Automatic modules
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动模块
- en: Unnamed module
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未命名的模块
- en: On the other hand, if you’re already familiar with class loading, you should
    know that the arrival of modules has changed some of the details of the way that
    class loading operates.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你已经熟悉类加载，你应该知道模块的出现已经改变了类加载操作的一些细节。
- en: A modern JVM has module-aware class loaders, and the way that the JRE classes
    are loaded is quite different than in Java 8\. One key concept is the *module
    path*, which is a sequence of paths to modules (or directories that contain modules).
    This is similar to, but separate from, the traditional Java classpath.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现代JVM具有模块感知的类加载器，JRE类加载的方式与Java 8相比有很大不同。一个关键概念是*模块路径*，它是一系列指向模块（或包含模块的目录）的路径。这与传统的Java类路径类似，但却是分开的。
- en: Note We will meet class loading properly in chapter 4 and introduce the modern
    way of doing things to both new and experienced readers.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们将在第4章中详细介绍类加载，并向新读者和有经验的读者介绍现代的做法。
- en: 'The fundamental principles of the modular approach to class loading follow:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 类加载模块化方法的根本原则如下：
- en: Modules are resolved from the module path, not the old-school classpath.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块是从模块路径解析的，而不是从旧的类路径解析的。
- en: At startup, the JVM resolves a graph of modules, which must be acyclic.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在启动时，JVM解析一个模块图，该图必须是无环的。
- en: One module is the root of the graph and is where execution starts from. It contains
    the class with the main method that will be the entry point.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个模块是图的根，也是执行开始的地方。它包含具有主方法的类，该主方法将是入口点。
- en: Dependencies that have already been modularized are known as *application modules*
    and are placed on the module path. Unmodularized dependencies are placed on the
    familiar classpath, and are coopted into the modules system via a migration mechanism.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 已经模块化的依赖项被称为*应用模块*，并放置在模块路径上。未模块化的依赖项放置在熟悉的类路径上，并通过迁移机制被纳入模块系统。
- en: Module resolution uses depth-first traversal, and because the graph must be
    acyclic, the resolution algorithm will terminate (and in linear time). Let’s delve
    a little more deeply into each of the four types of modules.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 模块解析使用深度优先遍历，由于图必须是无环的，解析算法将终止（并且在线性时间内）。让我们更深入地探讨四种模块类型中的每一个。
- en: 2.3.1 Platform modules
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.1 平台模块
- en: 'These are modules from the modular JDK itself. They would have been part of
    the monolithic runtime (`rt.jar`) in Java 8 (or possibly ancillary JARs, such
    as `tools.jar`). We can get a list of the available platform modules from the
    `--list-modules` flag, as shown here:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是来自模块化JDK本身的模块。在Java 8中，它们将是单体运行时（`rt.jar`）的一部分（或者可能是辅助JAR文件，如`tools.jar`）。我们可以通过`--list-modules`标志获取可用的平台模块列表，如下所示：
- en: '[PRE11]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This code will provide an unabridged list, rather than the partial set that
    we saw in figure 2.1.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将提供一个未经删减的列表，而不是我们在图2.1中看到的部分集合。
- en: Note The exact list of modules and their names will depend on the version of
    Java in use. For example, on Oracle’s GraalVM implementation, some additional
    modules like `com.oracle.graal.graal_enterprise`, `org.graalvm.js .scriptengine`
    and `org.graalvm.sdk` may be present.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：模块及其名称的确切列表将取决于所使用的Java版本。例如，在Oracle的GraalVM实现中，可能存在一些额外的模块，如`com.oracle.graal.graal_enterprise`、`org.graalvm.js.scriptengine`和`org.graalvm.sdk`。
- en: The platform modules make heavy use of the *qualified exporting* mechanism wherein
    some packages are exported only to a specified list of modules and are not made
    generally available.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 平台模块大量使用了**合格导出**机制，其中一些包仅导出到指定的模块列表中，并不对一般用户公开。
- en: The most important module in the distribution is `java.base`, which is always
    an implicit dependency of every other module. It contains `java.lang`, `java.util`,
    `java.io`, and various other basic packages. The module basically corresponds
    to the smallest possible Java runtime that an application could require and still
    run.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在分发中最重要的模块是`java.base`，它是每个其他模块的隐式依赖。它包含`java.lang`、`java.util`、`java.io`以及各种其他基本包。该模块基本上对应于应用程序可能需要的最小Java运行时，同时仍然可以运行。
- en: At the other end of the spectrum are the *aggregator modules*, which don’t contain
    any code but which serve as a shortcut mechanism to allow applications to bring
    in a very broad set of dependencies transitively. For example, the `java.se` module
    brings in the entire Java SE platform.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一端的是**聚合模块**，它们不包含任何代码，但作为允许应用程序通过传递方式引入非常广泛的依赖项的快捷机制。例如，`java.se`模块引入了整个Java
    SE平台。
- en: 2.3.2 Application modules
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.2 应用程序模块
- en: These types of modules are the modularized dependencies of an application, or
    the application itself. This type of module is also sometimes known as a *library
    module*.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这类模块是应用程序的模块化依赖，或者是应用程序本身。这种模块有时也被称为**库模块**。
- en: Note No technical distinction exists between platform and application modules—the
    difference is purely philosophical—and which class loader is used to load them,
    as we will discuss in chapter 4.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：平台模块和应用程序模块之间没有技术上的区别——区别纯粹是哲学上的——以及用于加载它们的类加载器，正如我们将在第4章中讨论的那样。
- en: The third-party libraries that an application depends on will be application
    modules. For example, the Jackson libraries for manipulating JSON have been modularized
    as of version 2.10 and count as application (aka library) modules.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序所依赖的第三方库将是应用程序模块。例如，用于操作JSON的Jackson库自2.10版本以来已经模块化，并被视为应用程序（也称为库）模块。
- en: Application modules will typically depend upon both platform modules and other
    application modules. It is a good idea to try to constrain the dependencies of
    these modules as much as possible and to avoid requiring, for example, `java.se`
    as a dependency.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序模块通常依赖于平台模块和其他应用程序模块。尽可能约束这些模块的依赖性是一个好主意，并尽量避免将其作为依赖项，例如`java.se`。
- en: 2.3.3 Automatic modules
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.3 自动模块
- en: One deliberate design feature of the modules system is that you can’t reference
    the classpath from a module. This restriction seems to be potentially problematic—what
    happens if a module needs to depend on some code that has not yet been modularized?
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 模块系统的第三个设计特性是您不能从模块中引用类路径。这种限制似乎可能存在潜在问题——如果模块需要依赖于尚未模块化的某些代码，会发生什么？
- en: The solution is to move the nonmodular JAR file onto the module path (and remove
    it from the classpath). When this is done, the JAR becomes an *automatic module*.
    The modules system will automatically generate a name for your module, which is
    derived from the JAR’s name.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是将非模块化的JAR文件移动到模块路径上（并从类路径中移除）。完成此操作后，JAR成为了一个**自动模块**。模块系统将自动为您的模块生成一个名称，该名称是从JAR的名称派生出来的。
- en: An automatic module exports every package that it contains, and automatically
    depends upon all other modules in the module path. Automatic modules do not have
    proper module dependency information, because they neither explicitly declare
    their dependencies nor advertise their API. This means that they are not first-class
    citizens in the modules system and do not provide the same level of guarantees
    as genuine Java modules.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 自动模块导出它包含的每个包，并自动依赖于模块路径中的所有其他模块。自动模块没有适当的模块依赖信息，因为它们既没有明确声明它们的依赖关系，也没有宣传它们的API。这意味着它们不是模块系统中的第一类公民，并且不提供与真正的Java模块相同的保证。
- en: It is possible to explicitly declare a name, by adding an entry for `Automatic-Module-Name`
    into the MANIFEST.MF file in the JAR. This is often done as an intermediate step
    when migrating to Java modules, because it allows developers to reserve a module
    name and start to gain some of the benefits of interoperating with modular code.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 可以显式声明一个名称，通过在JAR文件中的MANIFEST.MF文件中添加`Automatic-Module-Name`条目来实现。这通常是在迁移到Java模块时作为一个中间步骤完成的，因为它允许开发者为模块名称保留空间，并开始获得与模块化代码交互的一些好处。
- en: For example, the Apache Commons Lang library is not yet fully modularized, but
    it provides `org.apache.commons.lang3` as an automatic module name. Other modules
    can then declare that they depend upon this automatic module, even if the maintainers
    of it have not finished transitioning it to full modularity.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Apache Commons Lang库尚未完全模块化，但它提供了`org.apache.commons.lang3`作为自动模块名称。其他模块可以声明它们依赖于这个自动模块，即使维护者还没有完成将其过渡到完全模块化的工作。
- en: 2.3.4 Unnamed module
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.4 未命名的模块
- en: All classes and JARs on the classpath are added to a single module, which is
    the unnamed module, or `UNNAMED`. This is done for backward compatibility but
    at the cost that the modules system is not as effective as it might be all the
    time that some code remains in the unnamed module.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 类路径上的所有类和JAR文件都被添加到单个模块中，即未命名的模块或`UNNAMED`。这是为了向后兼容，但代价是模块系统可能不如它可能的那样有效，因为在未命名的模块中仍然有一些代码时。
- en: For the case of completely nonmodular apps (e.g., Java 8 apps that are running
    on top of a Java 11 runtime), the contents of the classpath are dumped into the
    unnamed module, and the root module is taken to be `java.se`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于完全非模块化应用程序的情况（例如，运行在Java 11运行时之上的Java 8应用程序），类路径的内容将被倒入未命名的模块中，而根模块被认为是`java.se`。
- en: Modular code cannot depend on the unnamed module, and so in practice, modules
    cannot depend upon anything in the classpath. Automatic modules are often used
    to help resolve this situation. Formally, the unnamed module depends upon all
    modules in JDK and on the module path because it is replicating the premodular
    behavior.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化代码不能依赖于未命名的模块，因此实际上，模块不能依赖于类路径中的任何内容。自动模块通常用于帮助解决这种情况。形式上，未命名的模块依赖于JDK中的所有模块和模块路径，因为它正在复制预模块化行为。
- en: 2.4 Building a first modular app
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4 构建第一个模块化应用程序
- en: Let’s build a first example of a modular application. To do this, we need to
    build a module graph (which is, of course, a DAG). The graph must have a *root
    module*, which in our case is the module containing the entry point class of the
    app. The module graph of the application is the transitive closure of all modular
    dependencies of the root module.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个模块化应用程序的第一个示例。为此，我们需要构建一个模块图（这当然是一个有向无环图DAG）。图中必须有一个*根模块*，在我们的例子中，是包含应用程序入口点类的模块。应用程序的模块图是根模块所有模块依赖的传递闭包。
- en: 'For our example, we’re going to adapt the HTTP site-checking tool we created
    at the end of chapter 1 to become a modular app. The files will be laid out like
    this:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，我们将把我们在第1章末尾创建的HTTP站点检查工具改编成一个模块化应用程序。文件将按照以下方式布局：
- en: '[PRE12]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We’re breaking out certain concerns (e.g., the `TrustEveryone` provider) into
    their own classes rather than representing them as static inner classes, as we
    had to when all the code needed to live in a single file. We’ve also set up separate
    packages and will not be exporting all of them. The module file is very similar
    to the one we met earlier, shown here:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将某些关注点（例如，`TrustEveryone`提供者）拆分到它们自己的类中，而不是像所有代码都需要生活在单个文件中时那样，将它们表示为静态内部类。我们还设置了单独的包，并且不会导出所有这些包。模块文件与我们在前面遇到的非常相似，如下所示：
- en: '[PRE13]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Note the dependency on the module `java.net.http`. To investigate what happens
    when a dependency is missed, let’s comment out the dependency on the HTTP module
    and try to compile the project using `javac` as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 注意对模块`java.net.http`的依赖。为了调查当错过依赖项时会发生什么，让我们取消注释对HTTP模块的依赖，并尝试使用以下方式使用`javac`编译项目：
- en: '[PRE14]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This failure shows that simple problems with modules can be very easy to solve.
    The modules system has detected the missing module and is trying to help by suggesting
    a solution: add the missing module as a dependency. If we make that change, then,
    as expected, the module builds without complaint. However, more complex problems
    may require changes to the compilation step or manual intervention via a switch
    to control the modules system.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这个失败表明，模块的简单问题可能非常容易解决。模块系统已检测到缺失的模块，并试图通过建议解决方案来帮助：将缺失的模块作为依赖项添加。如果我们做出这个改变，那么，正如预期的那样，模块构建时不会有任何抱怨。然而，更复杂的问题可能需要更改编译步骤或通过开关手动干预来控制模块系统。
- en: 2.4.1 Command-line switches for modules
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.1 模块的命令行开关
- en: 'When compiling a module, a number of command-line switches can be used to control
    the modular aspects of the compile (and, later, execution). The most commonly
    encountered of these switches follow:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译模块时，可以使用一些命令行开关来控制编译（以及稍后执行）的模块化方面。这些开关中最常见的是：
- en: '`list-modules`—Prints a list of all modules'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list-modules`——打印所有模块的列表'
- en: '`module-path`—Specifies one or more directories that contain your modules'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`module-path`——指定包含您的模块的一个或多个目录'
- en: '`add-reads`—Adds an additional `requires` to the resolution'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add-reads`——向解析添加额外的`requires`'
- en: '`add-exports`—Adds an additional `exports` to the compilation'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add-exports`——向编译添加额外的`exports`'
- en: '`add-opens`—Enables reflective access to all types at runtime'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add-opens`——启用运行时对所有类型的反射访问'
- en: '`add-modules`—Adds the list of modules to the default set'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add-modules`——将模块列表添加到默认集合中'
- en: '`illegal-access=permit|warn|deny`—Changes the reflective access rule'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`illegal-access=permit|warn|deny`——更改反射访问规则'
- en: We have already met the majority of these concepts already—with the exception
    of the qualifiers related to reflection, which we will discuss in detail in section
    2.4.3
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经遇到了这些概念中的大多数——除了与反射相关的限定符，我们将在第2.4.3节中详细讨论。
- en: Let’s see one of these switches in action. This will demonstrate a common issue
    with module packaging and serves as an example of a real-world issue that many
    developers may encounter when starting to use modules with their own code.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些开关的实际应用。这将演示模块打包中常见的一个问题，并作为一个真实世界问题的例子，许多开发者在使用模块和自己的代码时可能会遇到。
- en: When starting to work with modules, we sometimes find that we need to break
    encapsulation. For example, an application that has been ported from Java 8 may
    be expecting to access an internal package that is no longer exported.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当开始使用模块时，我们有时会发现我们需要打破封装。例如，一个从Java 8迁移的应用程序可能期望访问一个不再导出的内部包。
- en: 'For example, let’s consider a project with a simple structure that uses the
    *Attach API* to dynamically connect to other JVMs running on a host and report
    some basic information about them. It’s laid out on disc like this, just as we
    saw in an earlier example:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们考虑一个使用*Attach API*动态连接到主机上运行的其他JVM并报告一些基本信息的简单结构的项目。它在磁盘上的布局如下，就像我们在前面的例子中看到的那样：
- en: '[PRE15]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Compiling the project gives the following series of errors:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 编译项目时出现以下一系列错误：
- en: '[PRE16]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'These problems are being caused by some code in the project that makes use
    of internal APIs, as shown next:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题是由项目中某些使用内部API的代码引起的，如下所示：
- en: '[PRE17]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Although classes like `VirtualMachineDescriptor` are part of the exported interface
    of the `jdk.attach` module (because the class is in the exported package `com.sun
    .tools.attach`), other classes that we depend on (such as `MonitoredVmUtil` in
    `sun .jvmstat.monitor`) are not accessible. Fortunately, the tools provide a way
    to soften the module boundaries and provide access to a nonexported package.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管像`VirtualMachineDescriptor`这样的类是`jdk.attach`模块的导出接口的一部分（因为该类位于导出包`com.sun.tools.attach`中），但我们所依赖的其他类（如`sun.jvmstat.monitor`中的`MonitoredVmUtil`）则不可访问。幸运的是，工具提供了一种方法来软化模块边界，并提供对非导出包的访问。
- en: 'To achieve this, we need to add a switch—`--add-exports`—to force access to
    the internals of the `jdk.internal.jvmstat` module, which means we are definitely
    breaking encapsulation by doing this. The resulting compilation command line looks
    like this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们需要添加一个开关——`--add-exports`——来强制访问`jdk.internal.jvmstat`模块的内部，这意味着我们通过这样做肯定是在打破封装。生成的编译命令行看起来像这样：
- en: '[PRE18]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The syntax of `--add-exports` is that we must provide the module and package
    name that we require access to and which module is being granted the access.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`--add-exports`的语法是我们必须提供我们需要的模块和包名，以及哪个模块正在被授予访问权限。'
- en: 2.4.2 Executing a modular app
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.2 执行模块化应用程序
- en: 'Until the arrival of modules, only the following two methods existed to start
    a Java application:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块出现之前，只有以下两种方法可以启动 Java 应用程序：
- en: '[PRE19]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'These should both be familiar to Java programmers as launching a class and
    the main class from within a JAR file. In modern Java, two more methods of launching
    programs have been added. We met a new way of launching single-source-file programs
    in section 1.5.4, and now we’re going to meet the fourth mode: launching the main
    class of a module. The syntax follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对于 Java 程序员来说应该是熟悉的，因为它们涉及到从 JAR 文件中启动类和主类。在现代 Java 中，又增加了两种启动程序的方法。我们在 1.5.4
    节中遇到了启动单源文件程序的新方法，现在我们将遇到第四种模式：启动模块的主类。语法如下：
- en: '[PRE20]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'However, just as for compilation, we may need additional command-line switches.
    For example, from our earlier example of introspection:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，就像编译一样，我们可能需要额外的命令行开关。例如，从我们之前的内省示例：
- en: '[PRE21]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To prevent this error, we must also provide the encapsulation-breaking switch
    to the actual program execution as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这种错误，我们还必须向实际程序执行提供封装破坏开关，如下所示：
- en: '[PRE22]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If the runtime system can’t find the root module we asked for, then we expect
    to see an exception like this:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行时系统找不到我们请求的根模块，那么我们预计会看到如下异常：
- en: '[PRE23]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Even this simple error message is showing us that we have new aspects to the
    JDK, including
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这个简单的错误信息也显示我们对于 JDK 有新的认识，包括
- en: Packages, including `java.lang.module`
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包，包括 `java.lang.module`
- en: Exceptions, including `FindException`
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常，包括 `FindException`
- en: This shows once again that the modules system really has become an integral
    part of the execution of every Java program, even if it is not always immediately
    obvious.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这再次表明，模块系统确实已经成为每个 Java 程序执行的一个基本组成部分，即使它并不总是立即明显。
- en: In the next section, we’ll briefly introduce the interaction of modules with
    reflection. We assume that you’re already familiar with reflection, but if you’re
    not, feel free to skip this section for now and come back to it after you’ve read
    chapter 4, which contains an introduction to class loading and reflection.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将简要介绍模块与反射的交互。我们假设你已经熟悉反射，但如果你不熟悉，现在可以自由跳过这一节，在阅读完包含类加载和反射介绍的第四章后回来。
- en: 2.4.3 Modules and reflection
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.3 模块和反射
- en: In Java 8, developers can use reflection to access almost anything in the runtime.
    There’s even a way to bypass the access control checks in Java and, for example,
    call private methods on other classes via the so-called `setAccessible()` hack.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 8 中，开发者可以使用反射访问运行时几乎任何内容。甚至有一种方法可以绕过 Java 的访问控制检查，例如，通过所谓的 `setAccessible()`
    欺骗调用其他类的私有方法。
- en: As we’ve already seen, modules change the rules for access control. This also
    applies to reflection—the intent is that by default, only exported packages should
    be accessed reflectively.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经看到的，模块改变了访问控制的规则。这也适用于反射——默认情况下，只有导出的包应该被反射访问。
- en: However, the creators of the modules system realized that sometimes developers
    want to give reflective access (but not direct access) to certain packages. This
    requires an explicit permission and can be achieved by using the `opens` keyword
    to provide reflective-only access to an otherwise internal package. Developers
    can also specify fine-grained access by using the syntax `opens ... to ...` to
    allow a named set of packages to be opened reflectively to specific modules, but
    not more generally.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，模块系统的创建者意识到，有时开发者希望给予某些包的反射访问权限（但不是直接访问）。这需要显式的权限，并且可以通过使用 `opens` 关键字来提供对其他内部包的仅反射访问。开发者还可以通过使用
    `opens ... to ...` 语法来指定细粒度访问，允许一组命名的包可以反射地打开到特定的模块，但不能更广泛地打开。
- en: The previous discussion seems to imply that these types of reflective tricks
    are now ruled out. The truth is a little more complicated and is best explained
    via a discussion of the command-line switch `--illegal-access`. This switch comes
    with three settings—`permit|warn|deny`—and is used to control the strictness of
    checks on reflection.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的讨论似乎暗示这些类型的反射技巧现在已被禁止。事实要复杂一些，最好通过讨论命令行开关 `--illegal-access` 来解释。此开关有三个设置——`permit|warn|deny`——用于控制对反射的检查的严格性。
- en: The intent of the modules system has always been that over time, the entire
    Java ecosystem should move toward proper encapsulation, including reflection,
    and that at some point, the switch will default to `deny` (and will ultimately
    be removed). This change obviously could not happen overnight—if the reflection
    switch was suddenly set to `deny`, huge swathes of the Java ecosystem would break
    and *no one would upgrade*.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 模块系统的意图始终是随着时间的推移，整个 Java 生态系统应该朝着适当的封装方向发展，包括反射，并且在某一点上，默认的切换将变为`deny`（并且最终将被移除）。这种变化显然不可能一夜之间发生——如果反射切换突然设置为`deny`，Java
    生态系统的大部分内容都会崩溃，并且*没有人会升级*。
- en: However, with the release of Java 17, it is now four years since Java 9 was
    released and this warning first started to appear. This is, surely, time enough
    and fair warning. Accordingly, the decision was made in Java 16 to change the
    default option of `--illegal -access` to `deny` and to remove the option’s effect
    completely in Java 17.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着 Java 17 的发布，Java 9 已经发布了四年，这个警告第一次开始出现。这无疑已经足够多了，并且是一个合理的警告。因此，Java 16
    中做出了决定，将`--illegal-access`的默认选项更改为`deny`，并在 Java 17 中完全移除该选项的效果。
- en: Note This change to reflective encapsulation semantics is one reason an application
    migrating directly from 8 to 17 may see more headaches than one that performs
    two upgrade hops (8 to 11 and then 11 to 17).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：这种对反射封装语义的改变是为什么直接从 8 版本迁移到 17 版本的应用程序可能会遇到比执行两次升级跳转（8 到 11，然后 11 到 17）更多的麻烦。
- en: It is still possible to use the `--add-opens` command-line option, or the `Add-Opens`
    JAR manifest attribute, to open specific packages. This usage may be required
    for specific libraries or frameworks that have always used reflection and have
    not yet fully modularized. However, the brute force option to globally reenable
    access has been removed in Java 17.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然可以使用`--add-opens`命令行选项或`Add-Opens` JAR 清单属性来打开特定的包。这种用法可能对于一些始终使用反射且尚未完全模块化的特定库或框架是必需的。然而，在
    Java 17 中已经移除了全局重新启用访问的暴力选项。
- en: One additional useful concept to help this transition is *open modules*. This
    simple declaration is used to allow for completely open reflective access—it opens
    all the module’s packages for reflection but not compile-time access. This provides
    simple compatibility with existing code and frameworks but is a looser form of
    encapsulation. For this reason, open modules are best avoided or used only as
    a transitional form when migrating to a modular build. In chapter 17, we will
    discuss the specific case of `Unsafe`, which is a great example to indicate some
    of the problems with reflection in a modular world.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 一个额外的有用概念可以帮助这个过渡，那就是*开放模块*。这个简单的声明用于允许完全开放的反射访问——它为反射打开了所有模块的包，但不允许编译时访问。这为现有的代码和框架提供了简单的兼容性，但是一种更宽松的封装形式。因此，最好避免使用开放模块，或者仅在迁移到模块化构建时作为过渡形式使用。在第
    17 章中，我们将讨论`Unsafe`的具体案例，这是一个很好的例子，可以表明模块化世界中反射的一些问题。
- en: 2.5 Architecting for modules
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.5 为模块构建架构
- en: Modules represent a fundamentally new way of packaging and deploying code. Teams
    do need to adopt some new practices to get the most out of the new functionality
    and the architectural benefits. However, the good news is there’s no need to start
    doing that straightaway just to start using modern Java. The traditional, old-school
    methods using the classpath and JAR files will continue to work until such time
    as teams are ready to adopt modules wholeheartedly.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 模块代表了打包和部署代码的一种全新的方式。团队确实需要采用一些新的实践来充分利用新的功能和架构优势。然而，好消息是，你不需要立即开始这样做，只是为了开始使用现代
    Java。使用类路径和 JAR 文件的传统、老式方法将继续工作，直到团队准备好全心全意地采用模块。
- en: In fact, Mark Reinhold (chief architect for Java at Oracle) had this to say
    about the “need” for applications to adopt modularity.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Oracle 的 Java 首席架构师马克·雷诺尔德（Mark Reinhold）关于应用程序采用模块化的“必要性”是这样说的。
- en: There is no need to switch to modules.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 没有必要切换到模块。
- en: There has never been a need to switch to modules.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 从来没有必要切换到模块。
- en: Java 9 and later releases support traditional JAR files on the traditional class
    path, via the concept of the unnamed module, and will likely do so until the heat
    death of the universe.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9及以后的版本支持在传统类路径上使用传统的 JAR 文件，通过未命名模块的概念，并且可能会这样做直到宇宙的热寂。
- en: Whether to start using modules is entirely up to you.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 是否开始使用模块完全取决于你。
- en: If you maintain a large legacy project that isn’t changing very much, then it’s
    probably not worth the effort.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您维护一个大型遗留项目，而且这个项目变化不大，那么可能不值得付出努力。
- en: —Mark Reinhold, [https://stackoverflow.com/a/62959016](https://stackoverflow.com/a/62959016)
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: —马克·雷诺尔德，[https://stackoverflow.com/a/62959016](https://stackoverflow.com/a/62959016)
- en: 'In an ideal world, modules would be the default for all greenfield apps, but
    this is proving to be complex in practice, so as an alternative, when migrating,
    follow a process like this:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个理想的世界里，模块应该是所有绿色字段应用程序的默认选项，但在实践中这正在证明是复杂的，因此作为一个替代方案，在迁移时遵循以下过程：
- en: Upgrade to Java 11 (classpath only).
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 升级到Java 11（仅classpath）。
- en: Set an automatic module name.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个自动模块名称。
- en: Introduce a *monolithic module* consisting of all code.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 引入一个包含所有代码的*单体模块*。
- en: Break out into individual modules as needed.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据需要将其拆分为单独的模块。
- en: Typically, at step 3, way too much implementation code is exposed. This means
    that quite often, part of the work of step 4 is to create additional packages
    to house internal and implementation code and to refactor code into them.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在步骤3中，会暴露出过多的实现代码。这意味着，在步骤4的工作中，通常需要创建额外的包来存放内部和实现代码，并将代码重构到这些包中。
- en: 'If you are still using Java 8 and you aren’t ready yet to migrate to a modular
    build, you can still do the following things to prepare your code for the migration:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仍在使用Java 8，并且尚未准备好迁移到模块化构建，您仍然可以执行以下操作来为迁移准备您的代码：
- en: Introduce an automatic module name in MANIFEST.MF.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在MANIFEST.MF中引入自动模块名称。
- en: Remove split packages from your deployment artifacts.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从您的部署工件中移除分割包。
- en: Use `jdeps` and Compact Profiles to reduce your footprint of unnecessary dependencies.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`jdeps`和Compact Profiles来减少您不必要的依赖项的足迹。
- en: To take the first of these, the use of an explicit automatic module name (as
    we discussed earlier in the chapter) will ease the transition. The automatic module
    name will be ignored by all versions of Java that do not support modules but will
    still allow you to reserve a stable name for your library and to move some code
    out of the unnamed module. It also has the advantage that consumers of your library
    are prepared for the transition to modules, because you have already advertised
    the name the module will be using. Let’s take a closer look at the other two concrete
    recommendations.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 首先考虑这些中的一个，使用显式的自动模块名称（如我们在本章前面讨论的）将简化过渡。自动模块名称将不被不支持模块的所有Java版本忽略，但仍然允许您为您的库保留一个稳定的名称，并将一些代码移出未命名的模块。它还有这样的优势，即您的库的消费者已经为模块的过渡做好了准备，因为您已经宣传了模块将使用的名称。让我们更详细地看看其他两个具体建议。
- en: 2.5.1 Split packages
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.1 分割包
- en: One common problem that developers encounter when they start to use modules
    is *split packages*—when two or more separate JARs contain classes belonging to
    the same package. In a nonmodular application, there is no problem with split
    packages because neither JAR files nor packages have any particular significance
    to the runtime. However, in the modular world, a package must belong to only one
    module and cannot be split.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者在开始使用模块时遇到的一个常见问题是*分割包*——当两个或更多单独的JAR文件包含属于同一包的类。在非模块应用程序中，分割包没有问题，因为JAR文件和包对运行时没有任何特定的意义。然而，在模块世界中，一个包必须只属于一个模块，不能分割。
- en: If an existing application is upgraded to use modules and has dependencies that
    contain split packages, this will have to be remediated—there just is no way around
    it. For code that the team controls, this is additional work but not too difficult.
    One technique is to have a specific artifact (often using a `-all` suffix) that
    is generated by the build system alongside the nonmodular versions, with a single
    JAR containing all parts of the split package.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个现有应用程序升级为使用模块并且有包含分割包的依赖项，这将必须得到修复——别无他法。对于团队控制的代码，这将是额外的工作，但并不太难。一种技术是有一个特定的工件（通常使用`-all`后缀），它由构建系统与非模块版本一起生成，包含分割包的所有部分。
- en: For external dependencies, remediation can be more complicated. It may be necessary
    to repackage third-party open source code into a JAR that can be consumed as an
    automatic module.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 对于外部依赖项，修复可能更复杂。可能需要将第三方开源代码重新打包成一个可以消费为自动模块的JAR文件。
- en: 2.5.2 Java 8 Compact Profiles
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.2 Java 8 Compact Profiles
- en: Compact Profiles are a Java 8 feature. They are runtime environments that are
    reduced in size that must implement both the JVM and Java language specifications.
    They were introduced in Java 8 as a useful stepping-stone to the modularity story
    that would arrive in Java 9.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Compact配置文件是Java 8的一个特性。它们是经过缩减的运行时环境，必须实现JVM和Java语言规范。它们是在Java 8中引入的，作为通向Java
    9中即将到来的模块化故事的有用垫脚石。
- en: A Compact Profile must include all classes and packages that are explicitly
    mentioned in the Java language specification. Profiles are lists of packages,
    and they are usually identical to the package of the same name in the full Java
    SE platform. Very few exceptions exist, but they are explicitly called out.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Compact配置文件必须包含Java语言规范中明确提到的所有类和包。配置文件是包的列表，它们通常与完整Java SE平台中同名的包相同。存在非常少的例外，但它们被明确指出。
- en: One of the main use cases of profiles is as the basis for a server application
    or other environment, where deploying unnecessary capabilities is undesirable.
    For example, historically, a large number of security vulnerabilities were connected
    to Java’s GUI features, especially in Swing and AWT. By choosing not to deploy
    the packages that implement those features in applications where they are not
    needed, we can gain a modest amount of additional security, especially for, for
    example, server applications.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件的主要用例之一是作为服务器应用程序或其他环境的基础，在这些环境中，部署不必要的功能是不受欢迎的。例如，历史上，大量安全漏洞与Java的GUI功能有关，尤其是在Swing和AWT中。通过选择不在不需要这些功能的程序中部署实现这些功能的包，我们可以获得一定程度的额外安全性，尤其是在服务器应用程序中。
- en: Note At one time, Oracle shipped a cut-down JRE (the “Server JRE”) that played
    a very similar role to Compact 1.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Oracle曾经发布了一个缩减版的JRE（“服务器JRE”），它在某些方面与Compact 1非常相似。
- en: Compact 1 is the smallest set of packages on which it is feasible to deploy
    an application. It contains 50 packages, from the very familiar
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: Compact 1是可以部署应用程序的最小包集。它包含50个包，从非常熟悉的
- en: java.io
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: java.io
- en: java.lang
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: java.lang
- en: java.math
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: java.math
- en: java.net
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: java.net
- en: java.text
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: java.text
- en: java.util
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: java.util
- en: 'to some perhaps more unexpected packages that nonetheless provide essential
    classes to modern applications:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 到一些可能不那么意外的包，尽管如此，它们还是为现代应用程序提供了必要的类：
- en: java.util.concurrent.atomic
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: java.util.concurrent.atomic
- en: java.util.function
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: java.util.function
- en: javax.crypto.interfaces
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: javax.crypto.interfaces
- en: javax.net.ssl
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: javax.net.ssl
- en: javax.security.auth.x500
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: javax.security.auth.x500
- en: Compact 2 is significantly larger, containing packages such as those needed
    for XML, SQL, RMI, and security. Compact 3 is larger still and basically consists
    of the entire JRE, minus the windowing and GUI components—similar to the `java.se`
    module.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: Compact 2的体积显著更大，包含XML、SQL、RMI和安全所需的包。Compact 3更大，基本上是整个JRE，除了窗口和GUI组件——类似于`java.se`模块。
- en: Note All profiles ship the transitive closure of types referred to by `Object`
    and all types mentioned within the language specification.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：所有配置文件都包含由`Object`引用的所有类型以及语言规范中提到的所有类型的传递闭包。
- en: The Compact 1 profile is the closest to a minimal runtime, so in some ways it
    resembles a prototypical form of the `java.base` module. Ideally, if your application
    or library can be made to run with only Compact 1 as a dependency, then it should.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: Compact 1配置文件与最小运行时最为接近，因此在某些方面它类似于`java.base`模块的原型形式。理想情况下，如果你的应用程序或库可以仅通过Compact
    1作为依赖项运行，那么应该这样做。
- en: 'To help determine whether your app can run with Compact 1 or another profile,
    the JDK provides `jdeps`. This is a static analysis tool that ships with Java
    8 and 11 for examining the dependencies of packages or classes. The tool can be
    used in a number of different ways, from identifying which profile an application
    needs to run under, to identifying developer code that makes calls into the undocumented,
    internal JDK APIs (such as the `sun.misc` classes), through to helping trace transitive
    dependencies. It can be very helpful for migrations from Java 8 to 11 and works
    with both JARs and modules. In its simplest form, `jdeps` takes a class or package
    and provides a brief list of packages that are the dependencies. For example,
    for the discovery example:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助确定您的应用程序是否可以与 Compact 1 或其他配置文件一起运行，JDK 提供了 `jdeps`。这是一个静态分析工具，随 Java 8
    和 11 一起提供，用于检查包或类的依赖关系。该工具可以以多种方式使用，从确定应用程序需要在哪个配置文件下运行，到识别调用未记录的、内部的 JDK API（例如
    `sun.misc` 类）的开发者代码，再到帮助跟踪传递依赖。对于从 Java 8 迁移到 11 非常有帮助，并且与 JAR 和模块都兼容。在其最简单的形式中，`jdeps`
    接收一个类或包，并提供一个简短的依赖包列表。例如，对于发现示例：
- en: '[PRE24]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `-P` switch shows which profile is needed for a class (or package) to run,
    although, of course, this works only for a Java 8 runtime.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`-P` 开关显示一个类（或包）运行所需的配置文件，尽管当然，这仅适用于 Java 8 运行时。'
- en: Let’s move on to take a quick look at another migration technique that a well-grounded
    Java developer should be aware of—the use of *multi-release JARs*.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下另一个迁移技术，一个经验丰富的 Java 开发者应该了解的——使用 *多版本 JAR*。
- en: 2.5.3 Multi-release JARs
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.3 多版本 JAR
- en: This new capability allows the construction of a JAR file that can house libraries
    and components that can work on both Java 8 and modern, modular JVMs. For example,
    you can depend on library classes that are available only in later versions but
    can still run on an earlier version by using a fallback and stubbing approach.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这种新功能允许构建一个可以容纳在 Java 8 和现代、模块化 JVM 上运行的库和组件的 JAR 文件。例如，您可以使用仅在后续版本中可用的库类，但通过回退和存根方法仍然可以在早期版本上运行。
- en: 'To make a multi-release JAR, the following entry must be included in the JAR’s
    manifest file:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建多版本 JAR，必须在 JAR 的清单文件中包含以下条目：
- en: '[PRE25]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This entry is meaningful to JVMs only from version 9 upward, so if the JAR is
    used on a Java 8 (or earlier) VM, the multi-release nature will be ignored.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 此条目仅对从版本 9 开始的 JVM 有意义，因此如果 JAR 在 Java 8（或更早）VM 上使用，则多版本特性将被忽略。
- en: 'The classes that target post–Java 8 versions are referred to as *variant code*
    and are stored in a special directory in `META-INF` within the JAR, as shown next:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 针对Java 8之后版本的类被称为 *变体代码*，并存储在 JAR 内部 `META-INF` 的一个特殊目录中，如下所示：
- en: '[PRE26]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The mechanism works by overriding on a per-class basis. Versions 9 and upward
    of Java will look for a class that has the exact same name in the `versions` directories
    as in the main content root. If one is found, the overridden version is used in
    place of the class in the content root.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 该机制通过每个类的基础上进行覆盖来实现。Java 9 及以后的版本将寻找在 `versions` 目录中与主内容根目录中完全相同的类名。如果找到，则使用覆盖版本代替内容根目录中的类。
- en: Note Java class files are stamped with the version number of the Java compiler
    that created them—the *class file version number*—and code created on a later
    Java release will not run on an older JVM.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 Java 类文件带有创建它们的 Java 编译器的版本号——即 *类文件版本号*——而后来 Java 版本创建的代码在较旧的 JVM 上无法运行。
- en: The `META-INF/versions` location is ignored by Java 8 and earlier, so this provides
    a clever trick to sidestep the fact that some of the code contained in a multi-release
    JAR has too high a class file version to run on Java 8.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`META-INF/versions` 位置被 Java 8 及更早版本忽略，因此这提供了一个巧妙的技巧来规避多版本 JAR 中包含的一些代码的类文件版本过高，无法在
    Java 8 上运行的事实。'
- en: However, this does mean that the API of the class in the content root and any
    overridden variants must be the same, because they will be linked in exactly the
    same way for both cases.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这也意味着内容根目录中的类及其覆盖变体的 API 必须相同，因为它们将以完全相同的方式在两种情况下链接。
- en: 'Example: Building a multi-release JAR'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：构建多版本 JAR
- en: 'Let’s look at providing an example capability: getting the process ID of the
    running JVM. Unfortunately, this is somewhat cumbersome on versions of Java before
    9 and requires some low-level hackery in the `java.lang.management` package.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看提供一个示例功能：获取正在运行的 JVM 的进程 ID。不幸的是，在 Java 9 之前的版本中，这有些繁琐，并且需要在 `java.lang.management`
    包中进行一些低级黑客操作。
- en: Java 11 does provide an API for getting a PID from the Process API, so we want
    to set up a simple multi-release JAR that will use the simpler API when it is
    available and fall back to the JMX-based approach only if necessary.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: Java 11 为 Process API 提供了一个获取 PID 的 API，因此我们想要设置一个简单的多版本 JAR，当可用时使用更简单的 API，并在必要时回退到基于
    JMX 的方法。
- en: 'The main class looks like this:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 主类看起来像这样：
- en: '[PRE27]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Note that the capability that has a version-dependent implementation has been
    isolated into a separate class, `GetPID`. The Java 8 version of the code is somewhat
    verbose, as shown here:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，具有版本相关实现的特性已被隔离到单独的类 `GetPID` 中。Java 8 版本的代码有些冗长，如下所示：
- en: '[PRE28]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ❶ We include this line so we can see that this is the Java 8 version.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们包含这一行是为了可以看到这是 Java 8 版本。
- en: 'This requires us to parse a string from a JMX method—and even then our solution
    is not guaranteed to be portable across JVM implementations. By contrast, Java
    9 and later provide a much simpler standard method in the API, as shown in the
    following code snippet:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要我们从 JMX 方法中解析字符串——即使如此，我们的解决方案也不能保证在 JVM 实现之间具有可移植性。相比之下，Java 9 及以后的版本在 API
    中提供了一个更简单的标准方法，如下面的代码片段所示：
- en: '[PRE29]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Because the `ProcessHandle` class is in the package `java.lang`, we don’t even
    need an `import` statement.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `ProcessHandle` 类位于 `java.lang` 包中，我们甚至不需要 `import` 语句。
- en: 'We now need to arrange the multi-release JAR so that the Java 11 code is included
    in the JAR and is used in preference to the fallback version, if the JVM has a
    high enough version. One suitable code layout looks like this:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要安排多版本 JAR，以便在 JVM 版本足够高时，Java 11 代码包含在 JAR 中，并优先使用回退版本。一个合适的代码布局如下所示：
- en: '[PRE30]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The main part of the codebase needs to be compiled with Java 8, and then the
    post– Java 8 code is compiled afterward with a different Java version, before
    being packaged into a multi-release JAR “by hand” (i.e., using the command-line
    `jar` tool directly).
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 代码库的主要部分需要使用 Java 8 编译，然后使用不同的 Java 版本编译 Java 8 之后的代码，最后将其手动打包到多版本 JAR 中（即，直接使用命令行
    `jar` 工具）。
- en: Note This code layout uses the convention that the Maven and Gradle build tools
    follow, which we’ll meet properly in chapter 11.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：此代码布局遵循 Maven 和 Gradle 构建工具的约定，我们将在第 11 章中详细介绍。
- en: 'Let’s compile the code from the command line using JDK version `javac` but
    targeting our output to Java 8 via the `--release` flag:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 JDK 版本的 `javac` 命令行编译代码，但通过 `--release` 标志将输出目标设置为 Java 8：
- en: '[PRE31]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, we build the Java 11 targeted code with a separate output directory for
    the variant code `out-11`:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用单独的输出目录 `out-11` 为针对 Java 11 的代码构建：
- en: '[PRE32]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We also need a MANIFEST.MF file, but we can use the (Java 11) `jar` tool to
    automatically construct what we need as follows:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个 MANIFEST.MF 文件，但我们可以使用（Java 11）`jar` 工具自动构建我们需要的文件，如下所示：
- en: '[PRE33]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This creates a multi-release JAR, which is also runnable (with `Main` being
    the entry point class). Running the JAR gives the next output on Java 11:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个多版本 JAR，它也是可运行的（其中 `Main` 是入口点类）。在 Java 11 上运行 JAR 会得到以下输出：
- en: '[PRE34]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'and on Java 8:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 8 上：
- en: '[PRE35]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note the extra banner we added to the Java 8 version so you can distinguish
    between the two cases and be sure that the two different classes are actually
    being run. For real-world use cases for multi-release JARs, we would want the
    code to either perform the same in both cases (if we’re shimming a capability
    back to Java 8) or to fail in a graceful or predictable way if run on a JVM that
    doesn’t support a capability.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们添加到 Java 8 版本中的额外横幅，这样您可以区分两种情况，并确保两个不同的类实际上正在运行。对于多版本 JAR 的实际用例，我们希望代码在这两种情况下都能执行相同的功能（如果我们正在将功能回退到
    Java 8），或者在运行不支持该功能的 JVM 上以优雅或可预测的方式失败。
- en: One important architectural pattern that we recommend following is isolating
    JDK version-specific code into a package or group of packages, depending on how
    extensive the capability is.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们推荐遵循的一个重要架构模式是将特定 JDK 版本的代码隔离到包或一组包中，具体取决于功能范围的大小。
- en: 'Some basic guidelines and principles for the project follow:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是项目的某些基本指南和原则：
- en: The main codebase must be able to be built with Java 8.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主代码库必须能够使用 Java 8 构建。
- en: Java 11 portion must be built with Java 11.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 11 部分必须使用 Java 11 构建。
- en: Java 11 portion must be in a separate code root, isolated from the main build.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 11 部分必须在单独的代码根目录中，与主构建隔离。
- en: The end result should be a single JAR.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终结果应该是一个单一的 JAR 文件。
- en: Keep the build configuration as simple as possible.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能保持构建配置简单。
- en: Consider making the multi-release JAR modular as well.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑将多版本 JAR 文件也模块化。
- en: The last point is especially important, and this continues to be true for more
    complex projects that will inevitably end up requiring a proper build tool, rather
    than just `javac` and `jar`.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点尤为重要，并且对于不可避免地需要适当构建工具（而不仅仅是 `javac` 和 `jar`）的更复杂项目来说，这一点依然成立。
- en: 2.6 Beyond modules
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.6 超越模块
- en: 'To conclude the chapter, let’s take a quick look at what lies beyond modules.
    Recall that the entire point of modules was to introduce a missing abstraction
    into the Java language: the idea of deployment units with dependency guarantees
    that can be relied upon by the source code compiler and runtime.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束本章，让我们快速看一下模块之外的内容。回想一下，模块的整个目的就是向 Java 语言中引入一个缺失的抽象：具有依赖保证的部署单元，这些保证可以被源代码编译器和运行时依赖。
- en: This idea of modular dependency information that can be trusted has a number
    of applications to the modern world of deployable software. In Java, modules have
    seen slow but steady adoption as the tooling and ecosystem comes to fully support
    them and the benefits that they enable have become better understood.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这种可信赖的模块化依赖信息在现代可部署软件世界中有着许多应用。在 Java 中，随着工具和生态系统的全面支持，模块的采用速度缓慢但稳定，它们所提供的优势也变得更为人所知。
- en: 'Let’s conclude this chapter by meeting a new capability that was added to the
    platform along with modules—*JLink*. This is the ability to package a reduced
    Java runtime along with an application. This provides the following benefits to
    applications that make use of it:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过介绍平台新增的一项新功能来结束本章内容——与模块一起新增的*JLink*。这是将缩减版的 Java 运行时与应用程序打包在一起的能力。这为使用它的应用程序提供了以下好处：
- en: Package the application and JVM into a single, self-contained directory.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将应用程序和 JVM 打包成一个单一的自包含目录。
- en: Reduce the footprint and overall download size of the application and JRE bundle.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少应用程序和 JRE 打包的整体下载大小。
- en: Reduce support overhead, because there is no need to debug interactions between
    a Java application and a host-installed JVM.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少支持开销，因为不需要调试 Java 应用程序与主机安装的 JVM 之间的交互。
- en: The self-contained directories that `jlink` produces can easily be packaged
    as deployable artifacts (such as a Linux `.rpm` or `.deb`, a Mac `.dmg`, or a
    Windows `.msi`), providing a simple installation experience for modern Java applications.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`jlink` 生成的自包含目录可以轻松地打包成可部署的工件（如 Linux 的 `.rpm` 或 `.deb`，Mac 的 `.dmg` 或 Windows
    的 `.msi`），为现代 Java 应用程序提供简单的安装体验。'
- en: 'In some ways, the Compact Profiles technology in Java 8 provides an early version
    of JLink, but the version that arrived with modules is far more useful and comprehensive.
    As an example, we’re going to reuse the discovery example from earlier in the
    chapter. This has a simple module-info.java:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些方面，Java 8 中的 Compact Profiles 技术提供了 JLink 的早期版本，但与模块一起到来的版本更有用且更全面。例如，我们将重用本章早期部分的发现示例。它有一个简单的
    `module-info.java`：
- en: '[PRE36]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This can be built into a JLink bundle via a command like this:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以下命令将其构建成一个 JLink 打包文件：
- en: '[PRE37]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In our simple example, we have produced a JLink bundle that can be delivered
    as a TAR ball or packaged into a Linux package (such as .deb or .rpm). We can
    actually take this one step further and use *static compilation* to convert such
    a bundle into a native executable, but a full discussion of this is outside the
    scope of this book.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的简单示例中，我们生成了一个可以以 TAR 包或打包成 Linux 软件包（如 .deb 或 .rpm）交付的 JLink 打包文件。实际上，我们可以更进一步，使用
    *静态编译* 将这样的打包文件转换为本地可执行文件，但对此的全面讨论超出了本书的范围。
- en: 'We should sound a word of caution: JLink is a great piece of technology, but
    it has some important limitations that you should be aware of:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该提出一个警告：JLink 是一项伟大的技术，但它有一些重要的限制，您应该了解：
- en: It will work only with an application with fully modularized dependencies.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它仅与完全模块化的应用程序一起工作。
- en: It does not work with nonmodular code.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它与非模块化代码不兼容。
- en: Even automatic modules are not sufficient.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使是自动模块也不够。
- en: This is because, to be absolutely sure that all of the necessary parts of the
    JRE are included in the bundle, JLink relies upon the strongly declarative information
    in the module graph and therefore requires a `module-info.class` for each dependency.
    Without this information, building a reduced JRE is very likely to be unsafe.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为，为了确保 JRE 的所有必要部分都包含在打包文件中，JLink 依赖于模块图中强声明性的信息，因此需要为每个依赖项提供一个 `module-info.class`
    文件。没有这些信息，构建缩减版的 JRE 很可能是不安全的。
- en: Unfortunately, in the real world, many libraries that applications depend upon
    are still not fully modularized. This sharply reduces the usefulness of JLink.
    To solve this problem, toolmakers have developed plugins to repackage and synthesize
    “true” modules from unmodularized libraries. We’ll discuss these in chapter 11\.
    However, to use these tools requires the use of a build system. This means we
    will defer real-world examples of JLink until later on, when we meet the build
    tools in chapter 11.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在现实世界中，许多应用程序所依赖的库仍然没有完全模块化。这大大降低了JLink的有用性。为了解决这个问题，工具制造商开发了插件，从非模块化库中重新打包和合成“真正的”模块。我们将在第11章中讨论这些内容。然而，要使用这些工具需要使用构建系统。这意味着我们将推迟到第11章介绍构建工具时再提供JLink的实际示例。
- en: Summary
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Modules are a new concept in Java. They group packages and provide metadata
    about the whole unit, its dependencies, and its public interfaces. These constraints
    are then enforced by the compiler and runtime.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块是Java中的新概念。它们将包分组并提供关于整个单元、其依赖项及其公共接口的元数据。然后，编译器和运行时会强制执行这些约束。
- en: Modules are *not* a deployment construct (e.g., a different file format). Modularized
    libraries and applications can still be distributed via JAR files and downloaded
    by standard build tools.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块**不是**一种部署结构（例如，不同的文件格式）。模块化的库和应用程序仍然可以通过JAR文件分发并由标准构建工具下载。
- en: Moving to modules requires changes in how we develop our Java applications.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转向模块需要改变我们开发Java应用程序的方式。
- en: New syntax in the module-info.java file controls how classes and methods are
    exposed within the module system.
  id: totrans-353
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`module-info.java` 文件中的新语法控制着类和方法在模块系统中的暴露方式。'
- en: Class loading is aware of the restrictions a module defines and handles loading
    nonmodular code.
  id: totrans-354
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类加载器了解模块定义的限制并处理非模块化代码的加载。
- en: Building with modules requires new command-line flags and a change to the standard
    layout for a Java project.
  id: totrans-355
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模块构建需要新的命令行标志以及更改Java项目的标准布局。
- en: Modules provide a number of benefits in return for this work.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块提供了许多好处作为对这种工作的回报。
- en: Because of the more granular controls, modules are a fundamentally better way
    to architect applications for modern deployment and future maintainability.
  id: totrans-357
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于更细粒度的控制，模块是构建现代部署和未来可维护性应用程序的基本更好的方法。
- en: Modules are key to reducing footprint, especially in containers.
  id: totrans-358
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块对于减少占用空间至关重要，尤其是在容器中。
- en: Modules pave the way for other new capabilities (such as static compilation).
  id: totrans-359
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块为其他新功能（如静态编译）铺平了道路。
- en: Migrating to modules can be challenging, especially for legacy monolithic applications.
    Even three years after the first modular runtime was released, adoption remains
    patchy and incomplete.
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迁移到模块可能具有挑战性，尤其是对于遗留的单体应用程序。即使第一个模块化运行时发布已经三年了，采用率仍然参差不齐且不完整。
- en: Tools such as multi-release JARs and Compact Profiles can help prepare existing
    Java 8 projects to integrate with the modular ecosystem, even if they can’t move
    now.
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多版本JAR和紧凑配置文件等工具可以帮助准备现有的Java 8项目以集成到模块化生态系统中，即使它们现在无法迁移。
