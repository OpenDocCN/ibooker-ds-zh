- en: 9 Proximity-based algorithms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 基于邻近度的算法
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Using advanced algorithms to fight fraud based on anomaly detection
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于异常检测的高级算法对抗欺诈
- en: Using graphs for storing and analyzing the k-NN of transactions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用图存储和分析交易的k-NN
- en: Identifying transactions that are anomalous
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别异常交易
- en: Chapter 8 introduced fraud detection techniques by showing two approaches based
    on identifying relationships that are explicit in the data. In the first case,
    each transaction connected the cardholder to the merchant where the card was used.
    In the second case, bank or credit card accounts were connected by the owner’s
    personal or access details (phone number, address, IP, and so on). But in most
    cases, such relationships are not explicit, and in these circumstances, we need
    to do more work to infer or discover connections or relationships between data
    items to detect and combat fraud.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 第8章通过展示基于识别数据中显式关系的两种方法介绍了欺诈检测技术。在第一种情况下，每笔交易将持卡人与使用卡的商家连接起来。在第二种情况下，银行或信用卡账户通过所有者的个人或访问详情（电话号码、地址、IP等）连接起来。但在大多数情况下，这种关系并不明显，在这些情况下，我们需要做更多的工作来推断或发现数据项之间的连接或关系，以检测和对抗欺诈。
- en: This chapter explores advanced algorithms for fighting fraud, borrowed from
    anomaly detection theory, that are capable of recognizing anomalous items in large
    transactional datasets in which the data points appear to be independent. As I
    touched on in chapter 8, anomaly detection is the branch of data mining concerned
    with discovering rare occurrences, or outliers, in datasets. When you’re analyzing
    large and complex datasets, determining what stands out in the data is often at
    least as important and interesting as learning about its general structure.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了用于对抗欺诈的高级算法，这些算法借鉴了异常检测理论，能够在看似独立的大型交易数据集中识别异常项。正如我在第8章中提到的，异常检测是数据挖掘的一个分支，涉及在数据集中发现罕见事件或异常值。当你分析大型且复杂的数据集时，确定数据中的突出点至少与了解其一般结构一样重要和有趣。
- en: Many techniques and algorithms have been developed to tackle the abnormality
    detection problem [Akoglu et al. 2014], focusing mainly on spotting anomalies
    in unstructured collections of multidimensional data points—that is, datasets
    in which each data point can be represented by a vector. These techniques treat
    data objects as independent points lying in multidimensional space, but the reality
    is that in a lot of scenarios, they may exhibit interdependencies that should
    be accounted for during the anomaly detection process. In a wide range of disciplines—such
    as physics, biology, the social sciences, and information systems—data instances
    are in fact inherently related. As we’ve seen, graphs provide a powerful tool
    for effectively capturing long-range correlations among interdependent data objects.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决异常检测问题，已经开发了许多技术和算法 [Akoglu et al. 2014]，主要关注在非结构化的多维数据点集合中检测异常——即每个数据点都可以用一个向量表示的数据集。这些技术将数据对象视为位于多维空间中的独立点，但现实情况是，在许多场景中，它们可能表现出应考虑在异常检测过程中的相互依赖性。在广泛的学科领域——如物理学、生物学、社会科学和信息系统——数据实例实际上本质上相关。正如我们所见，图提供了一种强大的工具，可以有效地捕捉相互依赖数据对象之间的长期相关性。
- en: This chapter continues our investigation of the use of graphs in the anomaly
    detection space to fight fraud. First, we will use graph construction techniques
    to create a graph; then, we will analyze the graph to reveal anomalous transactions.
    The algorithms used here are not new, but the examples clearly show how graphs
    can help us visualize and navigate data better, simplifying the analysis process.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章继续我们关于在异常检测领域使用图来对抗欺诈的研究。首先，我们将使用图构建技术来创建一个图；然后，我们将分析这个图以揭示异常交易。这里使用的算法并不新颖，但示例清晰地展示了图如何帮助我们更好地可视化和导航数据，简化分析过程。
- en: '9.1 Proximity-based algorithms: An introduction'
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1 基于邻近度的算法：简介
- en: Suppose that you would like to identify suspicious credit card transactions
    to avoid customers being charged for payments they didn’t authorize. In analyzing
    the operational data, you need to identify transactions that diverge from normal
    user behavior and mark them as potentially fraudulent.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要识别可疑的信用卡交易以避免客户被收取未经授权的付款。在分析运营数据时，你需要识别偏离正常用户行为的交易并将它们标记为可能欺诈。
- en: 'At this stage, the scenario should be clear: you have been tasked with spotting
    fraudulent, or at least anomalous, transactions in a list of credit card operations.
    The goal is to go through the data and compile a list of transactions for further
    inspection. Conversely, when a new transaction has been requested, the system
    should evaluate whether to accept or reject it. It is worth noting that in this
    case, the data available is different from the scenarios we looked at in chapter
    8\. Here, we have a huge set of features for each transaction, whereas, before,
    we had only a few. This scenario is more realistic because, generally, credit
    card companies collect a lot of information about each transaction to enable them
    to classify a transaction as fraudulent as accurately as possible.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，场景应该是清晰的：你被分配的任务是在信用卡操作列表中识别欺诈或至少异常的交易。目标是浏览数据并编制一份需要进一步检查的交易清单。相反，当请求新的交易时，系统应该评估是否接受或拒绝它。值得注意的是，在这种情况下，可用的数据与我们在第8章中考虑的场景不同。在这里，我们有一个巨大的特征集，每个交易都有很多特征，而之前我们只有几个。这种场景更现实，因为通常信用卡公司会收集每个交易的大量信息，以便尽可能准确地将其分类为欺诈。
- en: Even the purpose here is different. Previously, we were trying to pinpoint the
    location where users’ credit card details were stolen or where purchases were
    made to test the stolen credentials. In this case, our goal is to identify anomalous
    transactions. When the system marks a transaction as suspicious, the card is blocked
    until further investigations and analyses are performed.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 即使目的在这里也有所不同。之前，我们试图确定用户信用卡详细信息被盗或购买发生的地点，以测试被盗凭证。在这种情况下，我们的目标是识别异常交易。当系统将交易标记为可疑时，卡片将被锁定，直到进行进一步的调查和分析。
- en: Clearly, this scenario requires a different approach. The data available is
    in the form of a sequence of transactions, described via a set of properties such
    as card ID, time, amount, location, merchant ID, and other information collected
    by the credit card system. Little or no information about the individual users
    and merchants is available. Furthermore, the volume of data is large compared
    with the earlier examples.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这种场景需要不同的方法。可用的数据是以一系列交易的形式存在的，通过一系列属性来描述，如卡ID、时间、金额、位置、商户ID以及信用卡系统收集的其他信息。关于个人用户和商户的信息很少或没有。此外，与早期示例相比，数据量很大。
- en: 'Because of the size of the data and the absence of explicit relationships,
    the techniques we explored in chapter 8 cannot be applied here. Instead, this
    chapter introduces a new technique for fraud detection that uses well-defined
    methods from the field of anomaly detection: *proximity-based approaches*. We
    will also use a graph representation to model and navigate the data and to improve
    the speed and performance of analysis. You’ll find the approach used for modeling
    the graph from data to be familiar because it uses some of the graph construction
    techniques discussed earlier in this book. This chapter shows how flexible such
    approaches are and how they can be adapted to multiple contexts and use cases.
    I’ll introduce the options quickly and then apply the most appropriate one to
    our scenario.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据量很大且缺乏明确的关系，我们在第8章中探讨的技术不能在这里应用。相反，本章介绍了一种新的欺诈检测技术，它使用来自异常检测领域的定义良好的方法：*基于邻近度的方法*。我们还将使用图表示来建模和导航数据，以提高分析和性能。你会发现用于从数据建模图的方法是熟悉的，因为它使用了本书前面讨论的一些图构建技术。本章展示了这种方法的灵活性以及它们如何适应多个上下文和用例。我将快速介绍这些选项，然后将其中最合适的一个应用到我们的场景中。
- en: Proximity-based techniques define a data point as an outlier when it is uncommonly
    far from the other data points. A more sophisticated way of saying this is that
    its locality (or proximity) is sparsely populated. Different algorithms use different
    mechanisms for defining the proximity of a data point. These methods are subtly
    different, but the concepts behind them are similar enough to merit unifying them
    into a few groups. The most common ways to define proximity for outlier analysis
    are [Aggarwal, 2016]
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 基于邻近度的技术将数据点定义为异常值，当它与其他数据点距离异常遥远时。更复杂地说，它的局部性（或邻近度）是稀疏的。不同的算法使用不同的机制来定义数据点的邻近度。这些方法在细节上有所不同，但它们背后的概念足够相似，值得将它们统一为几个组。用于定义异常分析中邻近度的最常见方法是由Aggarwal在2016年提出的。
- en: '*Cluster-based*—The data points are split into clusters, using whatever technique
    is most appropriate, considering how the elements are represented and how accurate
    the algorithm should be. The outlier score is computed by using the nonmembership
    of a data point in any of the clusters, its distance from other clusters, the
    size of the closest cluster, or a combination of these factors. Points belong
    to clusters or should be considered to be outliers.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基于聚类的*—使用最合适的技巧将数据点划分为聚类，考虑到元素如何表示以及算法应该有多精确。通过使用数据点在任意聚类中的非成员资格、与其他聚类的距离、最近聚类的尺寸或这些因素的组合来计算异常值得分。点属于聚类或应被视为异常值。'
- en: '*Density-based*—A local region is defined for each data point (perhaps based
    on grid position), and the number of other points in that region is used to define
    a local density value. This value can be converted to an outlier score, with elements
    with higher scores considered to be outliers. The basic assumption of density-based
    outlier detection methods is that the local density around a nonoutlier object
    is similar to the local density around its neighbors, whereas the local density
    around an outlier object is significantly different from the local density around
    its neighbors. Whereas cluster-based methods partition the data points, density-based
    methods partition the data space.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基于密度的*—为每个数据点定义一个局部区域（可能基于网格位置），并使用该区域中其他点的数量来定义一个局部密度值。此值可以转换为异常值得分，得分较高的元素被认为是异常值。基于密度的异常值检测方法的基本假设是，非异常对象周围的局部密度与其邻居周围的局部密度相似，而异常对象周围的局部密度与其邻居周围的局部密度显著不同。与基于聚类的方
    法划分数据点不同，基于密度的方法划分数据空间。'
- en: '*Distance-based*—For each data point, the k-nearest neighbor (k-NN) network
    (yes, the same one we used earlier for recommendations) is computed. The outlier
    score is computed by using the distance of a data point to its k-nearest neighbors;
    the data points with the largest k-NN distances are marked as outliers. Distance-based
    algorithms typically perform better than the other methods presented here because
    they have higher granularity. In both clustering- and density-based methods, the
    data is aggregated before outlier analysis by partitioning the points or the data
    space, and the individual data points are compared with those distributions for
    analysis. In distance-based methods, the outlier score is based on the k-NN distance
    to the original data points. This greater granularity often comes at a significant
    computational cost, but that cost can be mitigated by using graphs and some other
    techniques.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基于距离的*—对于每个数据点，计算k-近邻（k-NN）网络（是的，就是之前用于推荐的同一个网络）。通过使用数据点到其k-近邻的距离来计算异常值得分；具有最大k-NN距离的数据点被标记为异常值。基于距离的算法通常比这里介绍的其他方法表现更好，因为它们具有更高的粒度。在基于聚类和密度的方法中，在异常值分析之前，通过划分点或数据空间来聚合数据，并将单个数据点与这些分布进行比较以进行分析。在基于距离的方法中，异常值得分基于原始数据点到k-NN的距离。这种更高的粒度通常伴随着显著的计算成本，但可以通过使用图和一些其他技术来减轻这种成本。'
- en: All these techniques are based on some notion of proximity (or similarity, or
    distance) and are closely related. The major difference is in the level of detail
    in which this distance is defined.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些技术都是基于某种邻近度（或相似度，或距离）的概念，并且密切相关。主要区别在于定义此距离的详细程度。
- en: We will focus on distance-based mechanisms because they are accurate compared
    with the others. Moreover, they fit well not only in the graph space, but also
    with the techniques I’ve presented so far. Although this chapter focuses on multidimensional
    numerical data such as credit card transactions, such methods have been generalized
    to many other domains, such as categorical data, text data, time series data,
    and sequence data.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重点关注基于距离的机制，因为与其它方法相比，它们更准确。此外，它们不仅适用于图空间，还适用于我迄今为止介绍的技术。尽管本章重点讨论多维数值数据，如信用卡交易，但这些方法已被推广到许多其他领域，例如分类数据、文本数据、时间序列数据和序列数据。
- en: Another takeaway in this chapter is the use of k-NN networks for a task different
    from recommendations, which shows the power of this technique for classification
    purposes. Earlier in this book, we explored the different uses and intrinsic flexibility
    of k-NN networks for solving disparate problems. This chapter completes the overview.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的另一个要点是使用k-NN网络进行不同于推荐的任务，这展示了该技术在分类目的上的强大能力。在本书的早期，我们探讨了k-NN网络在解决不同问题时的不同用途和内在灵活性。本章完成了概述。
- en: 9.2 Distance-based approach
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2 基于距离的方法
- en: 'To illustrate the use of distance-based outlier detection methods, we will
    use a dataset of anonymized credit card transactions available on Kaggle.[¹](#pgfId-1005615)
    The dataset contains credit card transactions made by European cardholders over
    two days in September 2013\. There are a total of 284,807 transactions, of which
    492 were fraudulent. The dataset is highly unbalanced: the positive class (frauds)
    accounts for 0.172% of all transactions. The dataset contains only numerical input
    variables, which are the result of a statistical transformation to make them uncorrelated,
    to better suit our scenario. Due to confidentiality issues, Kaggle cannot provide
    the original features and more background information about the data. The only
    features that have not been transformed are Time and Amount. The Time feature
    contains the seconds elapsed between each transaction and the first transaction
    in the dataset. The Amount feature is the transaction amount. The Class feature
    is the response variable; it takes the value 1 in case of fraud and 0 otherwise.
    The schema in figure 9.1 shows a high-level workflow with the subtasks necessary
    to identify outliers in such a list of transactions by using distance-based methods.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明基于距离的异常值检测方法的使用，我们将使用Kaggle上可用的匿名信用卡交易数据集。[¹](#pgfId-1005615) 该数据集包含2013年9月两日内欧洲持卡人进行的信用卡交易。总共有284,807笔交易，其中492笔是欺诈交易。该数据集高度不平衡：正类（欺诈）占所有交易的0.172%。数据集仅包含数值输入变量，这些变量是经过统计转换以使其不相关，以更好地适应我们的场景。由于保密问题，Kaggle无法提供原始特征和更多关于数据的背景信息。唯一未转换的特征是时间和金额。时间特征包含每个交易与数据集中第一个交易之间的秒数。金额特征是交易金额。类别特征是响应变量；在欺诈的情况下取值为1，否则为0。图9.1中的模式显示了使用基于距离的方法在这样一份交易列表中识别异常值所需的高级工作流程。
- en: '![CH09_F01_Negro](../Images/CH09_F01_Negro.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![CH09_F01_Negro](../Images/CH09_F01_Negro.png)'
- en: Figure 9.1 Graph-powered distance-based approach
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 由图驱动的基于距离的方法
- en: The first part, composed of two subtasks (extracting the data and storing it
    as nodes in a graph), is a classic graph construction technique. We’ve used it
    quite a bit in the book, so by now, you should be familiar with it. This first
    step creates a graph like the one in figure 9.2.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分由两个子任务（提取数据和将其存储为图中的节点）组成，这是一种经典的图构建技术。我们在书中已经多次使用它，所以到现在你应该已经很熟悉了。这一步创建了一个如图9.2所示的图。
- en: '![CH09_F02_Negro](../Images/CH09_F02_Negro.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![CH09_F02_Negro](../Images/CH09_F02_Negro.png)'
- en: Figure 9.2 Transactions stored in the graph
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 图中存储的交易
- en: Let’s take a closer look at what’s involved here.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看这里涉及的内容。
- en: 9.2.1 Storing transactions as a graph
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.1 将交易存储为图
- en: We begin by ingesting our data from its original format, CSV, as nodes in the
    graph. You’ll find the Python scripts and the required dependencies for importing
    the data in the code repository, at ch09/import/creditcard. This step begins the
    process of storing the transactions as nodes in a graph, highlighted in figure
    9.3.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从原始格式CSV中摄取我们的数据，作为图中的节点。你可以在代码仓库的ch09/import/creditcard目录下找到导入数据的Python脚本和所需依赖。这一步开始了将交易存储为图中的节点的过程，如图9.3所示。
- en: '![CH09_F03_Negro](../Images/CH09_F03_Negro.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![CH09_F03_Negro](../Images/CH09_F03_Negro.png)'
- en: Figure 9.3 Where we are in our mental model
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 我们在心理模型中的位置
- en: The next listing, from the code repository, shows how to ingest the dataset
    from Kaggle and convert the transaction data to vectors.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表，来自代码仓库，展示了如何从Kaggle摄取数据集并将交易数据转换为向量。
- en: Listing 9.1 Code for importing transactions
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.1 导入交易的代码
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Reads from the transactions .csv file, using pandas
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用pandas从交易.csv文件中读取
- en: ❷ Starts the 50 writing threads. In this case, because each transaction node
    is independent, there will not be any concurrency issues.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 启动50个写入线程。在这种情况下，因为每个交易节点是独立的，所以不会出现任何并发问题。
- en: ❸ Iterates through the file, creating the parameter map
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 遍历文件，创建参数映射
- en: ❹ Creates the transaction vectors by removing useless columns and converting
    discrete/nonnumerical data to numbers (not necessary for this specific dataset,
    because the data is already normalized). See the code repository for the full
    implementation.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 通过删除无用列并将离散/非数值数据转换为数字（对于这个特定数据集不是必需的，因为数据已经标准化）来创建交易向量。请参阅代码存储库以获取完整实现。
- en: ❺ Adds the transaction object to the queue of elements to store
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将交易对象添加到存储元素的队列中
- en: ❻ This join waits for all the elements to be processed.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 这个连接等待所有元素被处理。
- en: ❼ Processes the queue elements by storing each transaction as a node in the
    database
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 通过将每个交易作为数据库中的一个节点存储来处理队列元素
- en: The code in this listing should be easy to understand; it is similar to what
    we have done in other examples. The only relevant difference is that the vector
    for each node doesn’t have to be computed later because it is already available
    in the data provided. The code extracts some data (like, time, is fraud, and so
    on) and makes it dedicated properties of the transaction nodes. The rest of the
    input data is put in the same nodes as a vector property, comprising the vector
    of floats so that we won’t need to compute it ourselves.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的代码应该很容易理解；它与我们在其他示例中所做的是相似的。唯一相关的区别是，每个节点的向量不需要后来计算，因为它已经在提供的数据中可用。代码提取一些数据（如时间、是否欺诈等）并将其作为交易节点的专用属性。其余的输入数据被放在相同的节点中，作为向量属性，包含浮点向量，这样我们就不需要自己计算它了。
- en: 'WARNING It is important to point out the use of multiple threads to write to
    Neo4j. This approach is a common one, but be careful: it can be used safely only
    when the queries don’t cause any conflicts (in other words, when the queries act
    on different, nonoverlapping portions of the graph). This “isolation” will prevent
    any issue with serialization or, worse, deadlocks. The first type of problem can
    be solved with a delayed retry, but the second problem is not so simple to overcome,
    requiring the update operations to be written so that even though they run in
    parallel, they lock the nodes in the same order.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：重要的是指出，使用多个线程写入Neo4j的使用。这种方法是常见的，但请注意：只有在查询不会引起任何冲突的情况下（换句话说，当查询作用于不同的、不重叠的图部分时），才能安全地使用。这种“隔离”将防止任何与序列化相关的问题，或者更糟糕的是，死锁。第一种问题可以通过延迟重试来解决，但第二种问题并不那么简单，需要更新操作以写入的方式，即使它们并行运行，也会按相同的顺序锁定节点。
- en: At the end of the ingestion, which should take a few seconds, your database
    will have 284,807 nodes and no relationships.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据摄取结束时，这应该只需要几秒钟，你的数据库将包含284,807个节点和没有关系。
- en: Exercise
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: 'After ingesting the data, run some queries on Neo4j (through the Neo4j browser)
    to see whether the ingestion succeeded. Here are some suggestions:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在摄取数据后，在Neo4j（通过Neo4j浏览器）上运行一些查询，以查看摄取是否成功。这里有一些建议：
- en: Count how many transactions (with the label Transaction) have been inserted.
    Does this number match what you expected?
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算被标记为“Transaction”的交易数量。这个数字符合你的预期吗？
- en: Count the number of transactions labeled as fraudulent. Does this number match
    your expectations?
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算被标记为欺诈的交易数量。这个数字符合你的预期吗？
- en: Get 10 vectors from the nodes. Can you find the dimension of each vector?
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从节点获取10个向量。你能找到每个向量的维度吗？
- en: Get the top 10 transactions in terms of amount.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取按金额排序的前10笔交易。
- en: 9.2.2 Creating the k-nearest neighbors graph
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.2 创建k最近邻图
- en: The second step (figure 9.4) is creating a k-NN graph by connecting the nodes
    using relationships that represent the distances between them.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步（图9.4）是通过使用表示它们之间距离的关系连接节点来创建k-NN图。
- en: '![CH09_F04_Negro](../Images/CH09_F04_Negro.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![CH09_F04_Negro](../Images/CH09_F04_Negro.png)'
- en: Figure 9.4 Where we are in our mental model
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 我们在心理模型中的位置
- en: In the recommender systems we built earlier in the book, we used the concept
    of similarities, because we were looking for similar items or users. Here, we
    are considering distances, because we are looking for outliers that are far from
    the legitimate transactions. This change isn’t a big one because the distance
    is related to the similarity by the following simple formula:[²](#pgfId-1005630)
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中之前构建的推荐系统中，我们使用了相似度的概念，因为我们正在寻找相似的项目或用户。在这里，我们正在考虑距离，因为我们正在寻找远离合法交易的异常值。这种变化并不大，因为距离通过以下简单的公式与相似度相关联：[²](#pgfId-1005630)
- en: '*distance* = 1 – *similarity*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*距离* = 1 – *相似度*'
- en: 'The formula states that when two data points are identical, their similarity
    is the highest possible: 1\. As a result, their distance is 0\. On the other hand,
    if they are fully distinct (perpendicular, if you prefer), the similarity is 0\.
    In that case, the distance will be the highest possible: 1.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 公式表明，当两个数据点完全相同的时候，它们的相似度是最高可能的：1。因此，它们的距离是0。另一方面，如果它们完全不同（如果你喜欢，可以认为是垂直的），相似度是0。在这种情况下，距离将是最高可能的：1。
- en: 'When the k-NN graph has been computed and stored, it is possible to find the
    outlier—in our case, the fraudulent transactions. Distance-based proximity methods
    usually produce output in the form of scores that represent the predicted probability
    that a data point (in this case, a transaction) is an outlier. By assigning a
    threshold, we can make a binary decision: whenever the score is higher than the
    fixed threshold, the transaction is considered to be an outlier.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当k-NN图已经计算并存储后，就可以找到异常值——在我们的案例中，是欺诈交易。基于距离的邻近方法通常以分数的形式产生输出，这些分数代表预测一个数据点（在这种情况下，是一个事务）是异常值的概率。通过设置一个阈值，我们可以做出二元决策：每当分数高于固定的阈值时，该交易就被认为是异常值。
- en: So far, so good, but as in the scenarios we’ve explored earlier in the book,
    the devil is in the details. Computing the k-NN graph is computationally expensive,
    requiring O(N²) time. Luckily, some techniques can make it faster; we will see
    a few of them when the time is right.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利，但正如我们在本书前面探索的场景中一样，魔鬼在于细节。计算k-NN图是计算密集型的，需要O(N²)的时间。幸运的是，一些技术可以使它更快；在适当的时候，我们将看到其中的一些。
- en: Now that we have all the transactions in the database as a set of nodes, we
    have to create the k-NN graph. To do so, we must compute the distance of each
    node from all the other nodes, using the vector property we created. These distances
    are ordered, and only the top k are stored as relationships in the graph. Each
    relationship also contains the distance value as its weight property. The result
    of this process is shown in figure 9.5.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将数据库中的所有事务作为一个节点集，我们必须创建k-NN图。为此，我们必须使用我们创建的向量属性计算每个节点与其他所有节点的距离。这些距离是有序的，并且只有前k个距离被存储为图中的关系。每个关系还包含距离值作为其权重属性。这个过程的结果如图9.5所示。
- en: '![CH09_F05_Negro](../Images/CH09_F05_Negro.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![CH09_F05_Negro](../Images/CH09_F05_Negro.png)'
- en: Figure 9.5 k-NN graph obtained using the vector information
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5使用向量信息获得的k-NN图
- en: As stated previously, and as we have seen in the recommendation scenarios, computing
    the k-NN graph is a tedious task because it requires computing the distances or
    similarities between every pair of transactions. That’s why distance-based methods
    are less frequently used when there are a lot of data items (transactions, calls,
    and so on). Creating a k-NN graph and persisting it as a real graph (an extension
    of the previous graph) has a lot of advantages in terms of accessing and analyzing
    your data, but it won’t help during the computation of the similarities. I want
    to stress this point because, as I said at the beginning of the book, this book
    doesn’t aims to solve only toy examples. Data scientists and data engineers have
    to solve real problems in which time, disk/memory space, and quality of results
    have to be taken into account.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，正如我们在推荐场景中看到的那样，计算k-NN图是一项繁琐的任务，因为它需要计算每对事务之间的距离或相似度。这就是为什么当有大量数据项（事务、呼叫等）时，基于距离的方法使用得较少。创建k-NN图并将其持久化为真实图（前一个图的扩展）在访问和分析数据方面有很多优点，但在计算相似度时并不会有所帮助。我想强调这一点，因为正如我在本书开头所说，本书的目标不仅仅是解决玩具示例。数据科学家和数据工程师必须解决需要考虑时间、磁盘/内存空间和结果质量的真实问题。
- en: In chapter 6, we explored a few techniques—locality-sensitive hashing (LSH)
    and Spotify’s Annoy[³](#pgfId-1005677)—to compute an approximate nearest neighbor
    (ANN) graph, with good results. Now we’re going to explore another interesting
    ANN approach that performs better than those two techniques. For the sake of clarity,
    the other approaches worked well in the scenario we used them for because of the
    size of the data and the quality of the results required by that specific scenario.
    In the fraud detection use case, we need to process a lot of dense vectors, and
    the quality of the approximation will affect the quality of the fraud detection
    results. I recommend taking a different, more sophisticated approach to ANN in
    this case.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在第6章中，我们探索了几种技术——局部敏感哈希（LSH）和Spotify的Annoy[³](#pgfId-1005677)——来计算一个近似最近邻（ANN）图，并取得了良好的结果。现在我们将探索另一种比这两种技术表现更好的有趣ANN方法。为了清晰起见，由于数据的大小和特定场景对结果质量的要求，其他方法在我们使用它们的场景中表现良好。在欺诈检测用例中，我们需要处理大量的密集向量，近似的质量将影响欺诈检测结果的质量。我建议在这种情况下采用不同的、更复杂的方法来处理ANN。
- en: Compared with the exact k-NN search, which searches the other elements for the
    k closest elements, the ANN search relaxes the conditions by allowing a small
    number of errors. It searches in a reduced set that is supposed to contain the
    elements closest to the specific vector used as the input for search.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 与精确的k-NN搜索相比，后者搜索其他元素以找到k个最近的元素，ANN搜索通过允许少量错误来放宽条件。它在包含用于搜索的特定向量的元素最接近的子集中进行搜索。
- en: 'ANN search has been a hot topic over the past few decades and provides fundamental
    support for many applications, from generic data mining to recommendations and
    from database indexes to information retrieval. For sparse discrete data (such
    as documents), the nearest neighbor search can be carried out efficiently on advanced
    index structures such as inverted indexes [Manning et al., 2008].[⁴](#pgfId-1005692)
    For dense continuous vectors, like those in our fraud use case, various solutions
    have been proposed, including tree structure-based approaches, hashing-based approaches
    (such as the LSH approach described in chapter 6), quantization-based approaches,
    graph-based approaches, and more. Graph-based methods have been proposed to reduce
    indexing complexity by approximating the traditional graphs. Recently, these methods
    have demonstrated revolutionary performance on million-scale datasets [Fu et al.,
    2019]. These approaches are interesting not only because they are graph-based,
    and hence relevant to this book, but also because in terms of performance, they
    represent the state of the art.[⁵](#pgfId-1005714) Without going into too much
    detail, I can describe the basic idea behind these approaches in two big steps:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ANN搜索在过去几十年中一直是一个热门话题，并为许多应用提供了基本支持，从通用数据挖掘到推荐，从数据库索引到信息检索。对于稀疏离散数据（如文档），最近邻搜索可以在高级索引结构（如倒排索引[Manning
    et al., 2008] [⁴](#pgfId-1005692)）上有效地进行。对于密集连续向量，如我们欺诈用例中的向量，已经提出了各种解决方案，包括基于树结构的方法、基于哈希的方法（如第6章中描述的LSH方法）、基于量化的方法、基于图的方法等。为了减少索引复杂性，已经提出了基于近似传统图的方法。最近，这些方法在百万规模数据集上展示了革命性的性能[Fu
    et al., 2019]。这些方法不仅因为它们基于图，因此与本书相关，而且因为从性能的角度来看，它们代表了当前的最佳水平。[⁵](#pgfId-1005714)
    不深入细节，我可以描述这些方法背后的基本思想分为两大步：
- en: Create a graph-based index structure. During this phase, a proximity graph (or
    neighbor graph) is created. In this graph, the nodes are the vectors in a multidimensional
    space, and the edges between the nodes are created by using some logic based on
    the specific distance function defined and the criteria for navigation. Two nodes
    are connected if it is probable that they are neighbors according to the distance
    function used.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建基于图的索引结构。在这个阶段，创建一个邻近图（或邻居图）。在这个图中，节点是多维空间中的向量，节点之间的边是通过使用基于特定距离函数的逻辑和导航标准创建的。如果根据使用的距离函数，两个节点可能是邻居，则它们之间连接。
- en: Search for neighbors. Given a specific vector or search query, the proximity
    graph is navigated in different ways, according to the algorithm, to find the
    candidates to be the closest neighbors of the input vector.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索邻居。给定一个特定的向量或搜索查询，根据算法的不同，通过不同的方式在邻近图中导航，以找到输入向量的最近邻居候选。
- en: I’ve chosen the Hierarchical Navigable Small World (HNSW) implementation [Malkov
    and Yashunin, 2016] as the ANN approach for this scenario. According to the benchmark
    available on Erik Bernhardsson’s website and in Aumüller et al. [2018], it is
    one of the best, and the Python wrapper[⁶](#pgfId-1005729) is amazingly simply
    to use. The following listing shows how to compute and store the k-NN graph.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择了分层可导航小世界（HNSW）实现[Malkov and Yashunin, 2016]作为此场景的 ANN 方法。根据 Erik Bernhardsson
    网站和 Aumüller 等人[2018]提供的基准，它是其中最好的之一，Python 包装器[⁶](#pgfId-1005729)的使用非常简单。以下列表展示了如何计算和存储
    k-NN 图。
- en: Listing 9.2 Computing and storing distances
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.2 计算和存储距离
- en: '[PRE1]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Function for computing and storing the distance according to the set of parameters
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 用于根据参数集计算和存储距离的函数
- en: ❷ Function that creates the vector used during the distance computation
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建在距离计算期间使用的向量的函数
- en: ❸ Switches between exact and approximate k-NN
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在精确和近似 k-NN 之间切换
- en: ❹ Function that stores the k-NN graph
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 存储 k-NN 图的函数
- en: 'This code has been implemented in such a way that it allows the creation of
    both ANN and k-NN graphs. The credit card dataset is small enough to be manageable
    in the k-NN approach, so to test the different solutions, I ran the code in listing
    9.2, using different distance functions and both approaches: approximate and exact.
    Table 9.1 contains brief descriptions of the functions.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码已实现，允许创建 ANN 和 k-NN 图。信用卡数据集足够小，可以在 k-NN 方法中管理，因此为了测试不同的解决方案，我使用了列表 9.2 中的代码，使用了不同的距离函数和两种方法：近似和精确。表
    9.1 包含了函数的简要描述。
- en: Table 9.1 Different distance functions used during the tests
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9.1 测试期间使用的不同距离函数
- en: '| Name | Formula |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 公式 |'
- en: '| Squared L2 | L2 (also called Euclidean) distance is the straight-line distance
    between two points in Euclidean space. Squared L2 (the squared version of L2)
    is of central importance in estimating parameters of statistical models, where
    it is used in the method of least squares, a standard approach to regression analysis.
    |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 平方 L2 | L2（也称为欧几里得）距离是欧几里得空间中两点之间的直线距离。平方 L2（L2 的平方形式）在估计统计模型的参数中具有核心重要性，在其中它被用于最小二乘法，这是一种标准的回归分析方法。|'
- en: '| Mahalanobis[⁷](#pgfId-1010207) | Mahalanobis distance is the distance between
    a point and a distribution, not between two distinct points. It is effectively
    a multivariate equivalent of the Euclidean distance. It has excellent applications
    in multivariate anomaly detection, classification on highly imbalanced datasets,
    one-class classification, and more uncommon use cases. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 马氏距离[⁷](#pgfId-1010207) | 马氏距离是一个点到分布的距离，而不是两个不同点之间的距离。它实际上是欧几里得距离的多变量等效。它在多元异常检测、高度不平衡数据集的分类、单类分类以及更多不常见用例中具有出色的应用。|'
- en: Listings 9.3 and 9.4 show in detail how the approximate and exact nearest neighbors
    computations were implemented. The switch is obtained by setting the exact parameter
    in the compute_and_store_distances function in listing 9.2.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.3 和 9.4 详细展示了近似和精确最近邻计算的实施方式。切换是通过在列表 9.2 中的 compute_and_store_distances
    函数中设置精确参数来实现的。
- en: Listing 9.3 Function that computes the approximate nearest neighbors
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.3 计算近似最近邻的函数
- en: '[PRE2]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Declares the index
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 声明索引
- en: ❷ Initiates the index. The maximum number of elements should be known beforehand
    so that the index is computed on the data we have to load.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 初始化索引。应事先知道元素的最大数量，以便在要加载的数据上计算索引。
- en: ❸ Sets the query time accuracy/speed trade-off, defining the ef parameter that
    should always be > k and < num_elements. ef refers to the size of the dynamic
    list for the nearest neighbors (used during the search). Higher ef leads to more
    accurate but slower searches.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 设置查询时间精度/速度权衡，定义 ef 参数，该参数应始终大于 k 且小于 num_elements。ef 指的是最近邻动态列表的大小（在搜索期间使用）。更高的
    ef 导致搜索更精确但更慢。
- en: ❹ Query dataset, k number of closest elements (returns 2 numpy arrays)
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 查询数据集，k 个最近元素（返回 2 个 numpy 数组）
- en: Listing 9.4 Function that computes the exact nearest neighbors
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.4 计算精确最近邻的函数
- en: '[PRE3]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: After executing the code in listing 9.2 (the full code is available in the code
    repository) by using the parameters in table 9.2, you’ll get your approximate
    nearest neighbor graph.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行列表 9.2 中的代码（完整代码可在代码仓库中找到）并使用表 9.2 中的参数后，你将得到你的近似最近邻图。
- en: Table 9.2 Parameter values used for creating the approximate nearest neighbor
    graph
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9.2 创建近似最近邻图所使用的参数值
- en: '| Parameter | Value |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 值 |'
- en: '| exact | False |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| 精确 | False |'
- en: '| k | 25 |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| k | 25 |'
- en: '| distance_function | L2 |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 距离函数 | L2 |'
- en: '| relationship_name | DISTANT_FROM |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 关系名称 | DISTANT_FROM |'
- en: You can run a simple query from the Neo4j browser to inspect the new graph database.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从Neo4j浏览器运行一个简单的查询来检查新的图数据库。
- en: Listing 9.5 Visualizing a portion of the KNN (approximate) graph
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.5 可视化KNN（近似）图的一部分
- en: '[PRE4]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The result of the query will look like figure 9.6, a screenshot from the Neo4j
    browser.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 查询的结果将类似于图9.6，这是从Neo4j浏览器中截取的屏幕截图。
- en: '![CH09_F06_Negro](../Images/CH09_F06_Negro.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![CH09_F06_Negro](../Images/CH09_F06_Negro.png)'
- en: Figure 9.6 The result of listing 9.5
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 列表9.5的结果
- en: Before moving on, it is worth analyzing the differences between the approximate
    and exact nearest neighbor graphs. By running the Python script[⁸](#pgfId-1005753)
    in listing 9.2 with the parameters in table 9.3, you’ll get an exact nearest neighbor
    graph.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，分析近似最近邻图和精确最近邻图之间的差异是值得的。通过在列表9.2中运行Python脚本[⁸](#pgfId-1005753)，并使用表9.3中的参数，你可以得到一个精确最近邻图。
- en: Table 9.3 Parameter values used for creating the exact nearest neighbor graph
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 表9.3 创建精确最近邻图所使用的参数值
- en: '| Parameter | Value |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 值 |'
- en: '| exact | True |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 精确 | True |'
- en: '| k | 25 |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| k | 25 |'
- en: '| distance_function | L2 |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| 距离函数 | L2 |'
- en: '| relationship_name | DISTANT_FROM_EXACT |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 关系名称 | DISTANT_FROM_EXACT |'
- en: The result of executing the script is a graph that contains both approximate
    and exact nearest neighbor graphs. (The approximate graph was computed with the
    previous run.) Now comparing the graphs is no more complex than running a simple
    query against it. The following listing shows the query to compare the graphs.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 执行脚本的结果是一个包含近似和精确最近邻图的图。（近似图是使用之前的运行计算的。）现在比较这些图不再比对其运行简单查询更复杂。以下列表显示了比较图的查询。
- en: Listing 9.6 Comparing the nearest neighbor graphs
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.6 比较最近邻图
- en: '[PRE5]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you don’t want to wait to create the second graph and do the experiment yourself,
    I can reveal that this query will return a count higher than 230,000 (of a total
    284,807 transactions), which means that accuracy is higher than 80%. This result
    is the percentage of times the list of neighbors produced by the approximate nearest
    neighbor computation for a node matches the exact one. If you check the remaining
    20% or so, you’ll see that the differences are minimal. What is not minimal is
    the time required to compute the exact nearest neighbor graph, which requires
    N ×N distance computations. The ANN approach (specifically, the graph-based implementation
    of ANN provided by HNSW) not only performs well in terms of accuracy, but also
    dramatically reduces the time required for computing the nearest neighbor graph.
    Therefore, the approach proposed here is usable in a production environment with
    real datasets.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想等待创建第二个图并亲自进行实验，我可以透露这个查询将返回超过230,000（总共有284,807笔交易）的计数，这意味着准确率高于80%。这个结果是近似最近邻计算产生的邻居列表与精确列表匹配的百分比。如果你检查剩余的20%左右，你会发现差异很小。不是最小的是计算精确最近邻图所需的时间，这需要N
    × N的距离计算。ANN方法（特别是HNSW提供的基于图的ANN实现）不仅在准确性方面表现良好，而且显著减少了计算最近邻图所需的时间。因此，这里提出的方法可以在具有真实数据集的生产环境中使用。
- en: 9.2.3 Identifying fraudulent transactions
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.3 识别欺诈交易
- en: 'The last step (figure 9.7) is identifying the fraudulent transactions. With
    the distance-based methods—specifically, the nearest neighbor approach that we
    are discussing in detail here—an observation (a transaction, in our scenario)
    is considered to be an outlier, or a possible fraud, if its neighbors are far
    away. Hence, a measure of outlierness—the outlier score—can be computed by using
    the distance of a node from its nearest neighbor(s): the higher the score, the
    higher the probability of an outlier.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步（图9.7）是识别欺诈交易。基于距离的方法——特别是我们在此处详细讨论的最近邻方法——如果一个观察值（在我们的场景中是一个交易）的邻居很远，那么它被认为是一个异常值，或者可能的欺诈。因此，可以通过使用节点与其最近邻的距离来计算异常度量的异常分数：分数越高，异常的可能性就越高。
- en: '![CH09_F07_Negro](../Images/CH09_F07_Negro.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![CH09_F07_Negro](../Images/CH09_F07_Negro.png)'
- en: Figure 9.7 Where we are in our mental model
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 我们在心理模型中的位置
- en: 'Different ways exist to measure the score for each observation based on its
    k-NN. There are two simple variations of this scoring mechanism:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 存在多种方式来衡量每个观察值的分数，这些分数基于其k-NN。这种评分机制的两种简单变体如下：
- en: '*Exact k-nearest neighbor score*—The outlier score of any data observation
    is equal to its distance from its kth nearest neighbor. So if k = 5 and the k-NNs
    of a transaction with ID 32 are [45: 0.3, 34: 0.45, 67:0.6, 50: 0.75, 21: 0.8],
    the 2-nearest neighbor score is 0.45 (the distance to the second node in the list),
    the 3-nearest neighbor score will be 0.6, and so on.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*精确 k 近邻分数*——任何数据观察值的异常值分数等于其与第 k 个最近邻的距离。因此，如果 k = 5，且 ID 为 32 的交易的 k-NN 为
    [45: 0.3, 34: 0.45, 67:0.6, 50: 0.75, 21: 0.8]，则第二个最近邻的分数是 0.45（列表中第二个节点的距离），第三个最近邻的分数将是
    0.6，依此类推。'
- en: '*Average k-nearest neighbor score*—The outlier score of any observation is
    equal to the average distance to its k-nearest neighbors. So in the previous example,
    the score of the transaction with ID 32 would be 0.58 ((0.3 + 0.45 + 0.6 + 0.75
    + 0.8) / 5).'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*平均 k 近邻分数*——任何观察值的异常值分数等于其到其 k 个最近邻的平均距离。因此，在前面的例子中，ID 为 32 的交易的分数将是 0.58（(0.3
    + 0.45 + 0.6 + 0.75 + 0.8) / 5）。'
- en: In general—and trust me, this fact surprised me as well—if we know the correct
    value of k to use, looking at the exact k-NN score tends to give better results
    than the average k-NN score. In unsupervised problems like outlier detection,
    however, it is impossible to know the correct value of k to use for any particular
    algorithm, and an analyst might use a range of values of k. Moreover, when the
    dataset contains multiple clusters with different densities, defining a single
    ideal value for k is a complex (if not impossible) task.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言——相信我，这个事实也让我感到惊讶——如果我们知道正确的 k 值，查看精确的 k-NN 分数往往比平均 k-NN 分数给出更好的结果。然而，在无监督问题如异常值检测中，我们无法知道任何特定算法应使用的正确
    k 值，分析师可能会使用一系列的 k 值。此外，当数据集中包含具有不同密度的多个簇时，定义一个单一的理想 k 值是一个复杂（如果不是不可能）的任务。
- en: At this stage, because the k-NN graph is stored in our graph database, computing
    the scores and evaluating the performance of the method proposed here are a matter
    of running a few queries. The focus should be on identifying the transactions
    that are potentially fraudulent and passing them to an analyst for further verification.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，因为 k-NN 图已存储在我们的图数据库中，计算分数和评估此处提出的方法的性能只需运行几个查询。重点应放在识别可能欺诈的交易并将它们传递给分析师进行进一步验证。
- en: Before starting the deeper analysis, let’s evaluate the overall results obtained
    by considering how the average distance of a node from its k-nearest neighbors
    is distributed across the entire dataset. Again, the graph representation—specifically,
    Neo4j with the APOC[⁹](#pgfId-1005770) plugin—can help a lot. Using the following
    queries, it is possible to export a .csv file with the transactions in one column
    and the average distance of each transaction from its k-nearest neighbors in the
    other. The queries show how to do this for the transactions that are identified
    as being likely and not likely to be fraudulent, respectively.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始更深入的分析之前，让我们评估整个数据集中节点与其 k 个最近邻的平均距离的分布情况。再次强调，图形表示——特别是，使用 APOC[⁹](#pgfId-1005770)
    插件的 Neo4j——可以极大地帮助。使用以下查询，可以导出一个包含交易和每个交易与其 k 个最近邻的平均距离的 .csv 文件。查询展示了如何为被识别为可能和不太可能欺诈的交易分别执行此操作。
- en: Listing 9.7 Creating a .csv with the average distance for fraudulent transactions
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.7 创建欺诈交易的平均距离 .csv 文件
- en: '[PRE6]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Listing 9.8 Creating a .csv with the average distance for nonfraudulent transactions
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.8 创建非欺诈交易的平均距离 .csv 文件
- en: '[PRE7]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The results have been analyzed with Microsoft Excel (the file is in the code
    repository at ch09/analysis/analysis.xlsx), and are shown in figure 9.8\. The
    bar chart compares the distributions of the average distances across the two datasets
    (fraudulent versus nonfraudulent transactions). In general, we expect the average
    distances to be higher in the case of fraudulent transactions compared with nonfraudulent
    ones. In the figure, we should have higher values for fraudulent transactions
    on the right side (greater distances) and lower ones on the left (smaller distances).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 结果已使用 Microsoft Excel（文件位于代码仓库的 ch09/analysis/analysis.xlsx 目录下）进行分析，并在图 9.8
    中展示。条形图比较了两个数据集（欺诈交易与非欺诈交易）的平均距离分布。一般来说，我们预计欺诈交易的平均距离将高于非欺诈交易。在图中，欺诈交易应位于右侧（距离更大）且左侧（距离更小）的值更高。
- en: '![CH09_F08_Negro](../Images/CH09_F08_Negro.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![CH09_F08_Negro](../Images/CH09_F08_Negro.png)'
- en: Figure 9.8 Chart comparing average distance distributions for fraudulent and
    nonfraudulent transactions
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8 比较欺诈和非欺诈交易的平均距离分布图
- en: 'Reality meets our expectations in this case: the dotted bars, indicating nonfraudulent
    transactions, are higher on the left side, and the diagonally striped bars indicating
    fraudulent transactions are higher on the right side. Up to an average distance
    of about 20, the nonfraudulent bar is higher than the fraudulent one, and starting
    with the next value (54.6), the trend is inverted. The dotted bar’s peak is at
    around 7, where we have 33% of the values (that is, one-third of the ~284,000
    legitimate transactions have an average k-NN distance between 2.72 and 7.39).
    Approximately 78% of these transactions have an average score of between 2.72
    and 20.09\. The diagonally striped bar’s peak is at 403, and we can see that 72%
    of the fraudulent transactions have an average k-NN distance of between 54 and
    403\. This result means that the nonfraudulent transactions have average distances
    from their nearest neighbors that are statistically lower than the average distances
    of the fraudulent transactions from their nearest neighbors.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，现实符合我们的预期：表示非欺诈交易的虚线柱状图在左侧更高，表示欺诈交易的斜线条纹柱状图在右侧更高。直到平均距离约为20时，非欺诈柱状图高于欺诈柱状图，从下一个值（54.6）开始，趋势逆转。虚线柱状图的峰值在约7处，我们有33%的值（即大约284,000笔合法交易中有三分之一的交易的平均k-NN距离在2.72到7.39之间）。大约78%的这些交易的平均分数在2.72到20.09之间。斜线条纹柱状图的峰值在403处，我们可以看到72%的欺诈交易的平均k-NN距离在54到403之间。这个结果意味着非欺诈交易与最近邻的平均距离在统计上低于欺诈交易与最近邻的平均距离。
- en: Now that we are sure that the distance metric we are using is performing well
    and that the behavior of the data is in line with our expectations, let’s move
    on to deeper analysis. The first query proposed for this purpose orders transactions
    by the minimum distance from the k-nearest neighbors, which means k = 1 in the
    k-NN score mechanism.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们确信我们使用的距离度量标准表现良好，并且数据的行为符合我们的预期，让我们继续进行更深入的分析。为此目的提出的第一个查询是按k最近邻的最小距离对交易进行排序，这意味着在k-NN分数机制中k=1。
- en: Listing 9.9 Computing potentially fraudulent transactions ordered by minimum
    distance
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.9 按最小距离计算潜在的欺诈交易
- en: '[PRE8]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This query returns a count of 118,[^(10)](#pgfId-1005787) which means that of
    the first 1,000 transactions returned ordered by descending score, 11.8% were
    fraudulent. That value may seem to be low but isn’t. Recall that there are 492
    fraudulent transactions in the dataset of a total 284,807, which means that only
    0.17% of the transactions are fraudulent. This result reinforces our intuition
    that the greater the distance a transaction is from its closest neighbor, the
    higher the chance that the transaction is fraudulent. This distance is the defined
    score from listing 9.9 onward as well as in the related descriptions. It will
    be computed in different ways, but in all cases, the higher the score, the higher
    the chance that the transaction is fraudulent. Following is a more generic query
    in which you can change the value of k, considering whatever element you like
    in the list of the nearest neighbors.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询返回118个计数，[^(10)](#pgfId-1005787)，这意味着在按降序分数排序的前1000笔交易中，有11.8%是欺诈的。这个值可能看起来很低，但实际上并不是。回想一下，在总共284,807笔交易的数据集中有492笔欺诈交易，这意味着只有0.17%的交易是欺诈的。这个结果加强了我们这样的直觉：交易与其最近邻的距离越远，交易是欺诈的可能性就越高。这个距离是从列表9.9开始定义的分数，以及相关的描述中的分数。它将以不同的方式计算，但在所有情况下，分数越高，交易是欺诈的可能性就越高。以下是一个更通用的查询，你可以更改k的值，考虑你喜欢的最近邻列表中的任何元素。
- en: Listing 9.10 Computing potentially fraudulent transactions ordered by 4-NN distance
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.10 按四邻域距离计算潜在的欺诈交易
- en: '[PRE9]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ 3 can be any value less than k. (The vector resulting from the collect starts
    from 0, so k=1 is the element at 0, k=2 the element at 1 and so on.)
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 3可以是小于k的任何值。（collect生成的向量从0开始，所以k=1是0处的元素，k=2是1处的元素，依此类推。）
- en: In this query, we are fixing the vector position to 3 (which means the fourth
    element in our KNN, because the collect creates a 0-based vector). Hence, in this
    query, we are assigning the score based on the distance of each transaction to
    the fourth element in the KNN of the transaction itself. As a reminder, we set
    k (the number of nearest neighbors to consider) to 25 (see tables 9.2 and 9.3);
    the value can be any value lower than 25.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个查询中，我们将向量位置固定为 3（这意味着我们的 KNN 中的第四个元素，因为 collect 创建了一个基于 0 的向量）。因此，在这个查询中，我们根据每笔交易到其自身
    KNN 中第四个元素的距离来分配分数。提醒一下，我们将 k（要考虑的最近邻数量）设置为 25（见表格 9.2 和 9.3）；这个值可以是小于 25 的任何值。
- en: In this case, the query returns a count of 111, which means that 11.1% of the
    resulting list of transactions were fraudulent. This result is slightly lower
    than before but still much higher than 0.17%—the percentage of fraudulent transaction
    over the full dataset.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，查询返回 111，这意味着结果列表中有 11.1% 的交易是欺诈的。这个结果略低于之前，但仍然远高于 0.17%——这是整个数据集中欺诈交易的比例。
- en: The results generated by these queries are good. For proof, run the following
    query, which generates a random score.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这些查询生成的结果很好。为了证明，运行以下查询，它生成一个随机分数。
- en: Listing 9.11 Generating a random list of 1,000 transactions
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.11 生成 1,000 笔交易的随机列表
- en: '[PRE10]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The query assigns a random score to each transaction, regardless of the distance
    from any element of the KNN. Because the list of transactions is generated randomly,
    the results of this query can vary, but you should find that the query usually
    returns 2 or 3, which is equivalent to 0.2% to 0.3%. That result is aligned with
    the distribution of the fraud transactions across the overall dataset, which is
    0.17%.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 查询为每笔交易分配一个随机分数，无论其与 KNN 中任何元素的距离如何。由于交易列表是随机生成的，这个查询的结果可能会有所不同，但你应该发现查询通常返回
    2 或 3，这相当于 0.2% 到 0.3%。这个结果与整体数据集中欺诈交易分布相一致，即 0.17%。
- en: This experiment sets our baseline. Let’s try a few more experiments. Using the
    following query, we assign the score by using the average distance from all the
    k-nearest neighbors instead of picking the distance from one of the neighbors,
    as we have done before.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实验设定了我们的基线。让我们尝试更多的实验。使用以下查询，我们通过使用所有 k 个最近邻的平均距离来分配分数，而不是像之前那样选择一个邻居的距离。
- en: Listing 9.12 Computing the score of the transactions by using the average distance
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.12 使用平均距离计算交易的分数
- en: '[PRE11]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The result is 86—worse than the result from listing 9.9, where the score used
    for the ordering was based on the minimum distance from the k-nearest neighbor,
    which was 118 in our test. This result is to be expected, because as I stated
    earlier, looking at exact k-NN scores usually gives better results than the approximate
    k-NN for most datasets. Still, this technique performs much better than selecting
    transactions randomly.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是 86——比列表 9.9 的结果更差，在列表 9.9 中，用于排序的分数是基于到 k 个最近邻的最小距离，在我们的测试中是 118。这个结果是预期的，因为我之前提到，对于大多数数据集来说，查看精确
    k-NN 分数通常比近似 k-NN 给出更好的结果。尽管如此，这种技术比随机选择交易表现得要好得多。
- en: Graphs can help with deep analysis, and we can take this opportunity to discover
    more insights about the options available. An interesting possibility is to test
    listing 9.9 and listing 9.12 by using the exact k-NN graph. The following listings
    show how.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图可以帮助进行深入分析，我们可以利用这个机会来发现更多关于可用选项的见解。一个有趣的可能是通过使用精确 k-NN 图来测试列表 9.9 和列表 9.12。以下列表展示了如何进行。
- en: Listing 9.13 Computing the score by using the exact k-NN graph and minimum distance
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.13 使用精确 k-NN 图和最小距离计算分数
- en: '[PRE12]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Listing 9.14 Computing the score by using the exact k-NN graph and average distance
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.14 使用精确 k-NN 图和平均距离计算分数
- en: '[PRE13]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: These queries return 81 and 72, respectively, so the exact method returns worse
    results than the approximate one, perhaps because the graph-based approximation
    provided by HNSW removes some noise in the data.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这些查询分别返回 81 和 72，因此精确方法的结果比近似方法更差，这可能是因为 HNSW 提供的基于图的大致近似去除了数据中的部分噪声。
- en: Exercises
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: Try playing with the parameter values (k, exact, distance_function and relationship_name)
    and executing different queries to see whether you can get better results than
    the ones shown here. I did this experiment myself and found some interesting results.
    The following query, for example, considers scores from the 24th-nearest neighbors
    (k = 23), using the exact method and the Mahalanobis distance metric.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试调整参数值（k、精确值、距离函数和关系名称）并执行不同的查询，看看你是否能获得比这里展示的更好的结果。我自己也进行了这个实验，并发现了一些有趣的结果。例如，以下查询考虑了第24个最近邻的得分（k
    = 23），使用精确方法和Mahalanobis距离度量。
- en: Listing 9.15 Computing the score by using the exact 24-NN distance with Mahalanobis
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.15 使用Mahalanobis精确24-NN距离计算得分
- en: '[PRE14]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The query returns 147, which means that 14.7% of the top results are potentially
    fraudulent transactions. This example shows once again that the k-nearest neighbor
    approach performs better than average distance score in the dataset we are considering,
    at least with the current value of k (25) and the current distance metric (Mahalanobis).
    I ran another interesting test with the parameters in table 9.4 to see what the
    effect of increasing k would be.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 查询返回147，这意味着前14.7%的结果可能是欺诈交易。这个例子再次表明，在考虑的数据库中，k-最近邻方法比平均距离得分表现更好，至少在当前的k值（25）和当前的距离度量（Mahalanobis）下是这样。我使用表9.4中的参数进行了另一个有趣的测试，以查看增加k值会有什么影响。
- en: Table 9.4 Parameter values used for computing exact 400-NN with Mahalanobis
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 表9.4 用于计算精确400-NN的Mahalanobis参数值
- en: '| Parameter | Value |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 值 |'
- en: '| exact | True |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 精确值 | True |'
- en: '| k | 400 |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| k | 400 |'
- en: '| distance_function | MAHALANOBIS |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 距离函数 | MAHALANOBIS |'
- en: '| relationship_name | DISTANT_FROM_EXACT_400_MAHALANOBIS |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 关系名称 | DISTANT_FROM_EXACT_400_MAHALANOBIS |'
- en: Running the Python script will take a bit longer, due to the extra time required
    to store the k-NN in the graph, but now we can consider the 400 nearest neighbors
    for each transaction instead of 25\. The following query uses the average score
    over the 400-item list of neighbors for each transaction to generate the list.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 运行Python脚本会花费更长的时间，因为需要额外的时间来在图中存储k-NN，但现在我们可以考虑每个交易的400个最近邻，而不是25个。以下查询使用每个交易的400个邻居列表的平均得分来生成列表。
- en: Listing 9.16 Computing the score by using average distance with Mahalanobis
    (k = 400)
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.16 使用Mahalanobis（k = 400）计算平均距离得分
- en: '[PRE15]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The result is 183, which means that 18.3% of the top results are classified
    as fraudulent—definitely the best result so far! I also tested with L2 and the
    approximate nearest neighbor approach, and the result was 2. This example shows
    how much parameters can influence the results of your analysis.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是183，这意味着前18.3%的结果被分类为欺诈——这无疑是迄今为止最好的结果！我还测试了L2和近似最近邻方法，结果是2。这个例子展示了参数如何影响你分析的结果。
- en: You’re probably thinking that these results aren’t so great; you’d like to see
    much higher precision, around 80, which makes perfect sense. I had the same mindset
    at first. But it’s important to consider how unbalanced the dataset is. We have
    more than 280,000 transactions, and only 492 are fraudulent. In these conditions,
    our queries can’t perform much better. We can make the dataset more balanced,
    however, so that the number of fraudulent transactions is the same as the number
    of licit transactions. This approach enables us to better evaluate the quality
    of the scoring mechanism used so far. The following queries create a balanced
    dataset by taking only 492 (the number of fraudulent transactions) licit transactions
    randomly, among all the available, and adding to this dataset all the fraudulent
    transactions. The dataset is created by marking with a common label all the transactions
    in the dataset.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为这些结果并不那么好；你希望看到更高的精确度，大约80%，这是完全合理的。最初我也有同样的想法。但是，重要的是要考虑数据集的不平衡性。我们有超过280,000笔交易，其中只有492笔是欺诈的。在这些条件下，我们的查询表现不会更好。然而，我们可以使数据集更加平衡，使得欺诈交易的数量与合法交易的数量相同。这种方法使我们能够更好地评估迄今为止使用的评分机制的质量。以下查询通过随机选择所有可用的合法交易中的492笔（欺诈交易的数量）并添加到数据集中，创建了一个平衡的数据集。数据集是通过标记数据集中的所有交易来创建的。
- en: Listing 9.17 Generating a random set of transactions the same size as the fraudulent
    set
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.17 生成与欺诈集大小相同的随机交易集
- en: '[PRE16]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Listing 9.18 Assigning the fraudulent transactions to the same test set
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.18 将欺诈交易分配到相同的测试集
- en: '[PRE17]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The previous queries can be run repeatedly to create multiple testing datasets
    (change Test1 to Test2, Test3, and so on). The result in each case is a homogeneous
    dataset of size 984, with the number of fraudulent and legitimate transactions
    balanced. Now, with a similar query, let’s see how using the average distance
    allows us to catch the fraudulent transactions.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的查询可以重复运行以创建多个测试数据集（将 Test1 改为 Test2、Test3 等）。每种情况的结果都是一个大小为 984 的同质数据集，欺诈交易和合法交易的数目平衡。现在，使用类似的查询，让我们看看使用平均距离如何帮助我们捕捉到欺诈交易。
- en: Listing 9.19 Assigning a score to the small dataset
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.19 为小数据集分配分数
- en: '[PRE18]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The result is 100. The first 100 transactions ordered by descending score are
    fraudulent.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是 100。按分数降序排列的前 100 笔交易是欺诈交易。
- en: All this evidence—the chart from figure 9.8, the tests over the top 1,000 transactions
    ordered by average and other metrics, and this last test on a reduced but balanced
    dataset—shows how the distance-based approach is capable of identifying fraudulent
    transactions. Bear in mind also that the so-called legitimate transactions are
    transactions *not proved to be fraudulent*, so the quality of the results could
    be even higher than presented here.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些证据——图 9.8 的图表、按平均和其他指标排序的前 1,000 笔交易的测试，以及这个在减少但平衡的数据集上的最后测试——展示了基于距离的方法如何能够识别欺诈交易。请记住，所谓的合法交易是指尚未证明为欺诈的交易，因此结果的质量可能比这里展示的还要高。
- en: Exercise
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: I invite you to play with the parameters to find the best configuration for
    your dataset. Specifically, the distance function and the size of the k parameter
    affect the final results. In this sense, the graph approach will make all your
    analysis efforts pleasant and simple. You can store and compare solutions, as
    we have done throughout this section. Playing with multiple k-NNs in the same
    graph is exciting—or at least it was for me!
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我邀请您调整参数以找到适合您数据集的最佳配置。具体来说，距离函数和 k 参数的大小会影响最终结果。从这个意义上说，图方法将使您的分析工作变得愉快且简单。您可以存储和比较解决方案，就像我们在本节中做的那样。在同一个图中玩多个
    k-NN 是令人兴奋的——至少对我来说是这样的！
- en: This score-based approach can be easily converted to produce a binary output.
    In this case, instead of having a score that indicates how likely it is that a
    transaction is fraudulent, we can have a binary output that says “fraudulent”
    or “not fraudulent.” Converting a score-based mechanism to a binary one is a trivial
    task. The two main approaches that have been proposed for this purpose are
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这种基于分数的方法可以轻松地转换为产生二进制输出。在这种情况下，我们不再有一个表示交易欺诈可能性的分数，而是一个二进制输出，表示“欺诈”或“非欺诈”。将基于分数的机制转换为二进制机制是一个简单的任务。为此目的，已经提出了两种主要方法
- en: '*Score threshold-based distance outliers* [Knorr and Ng, 1998]—An observation
    (in our case, a transaction) is an outlier if at least a portion f of the objects
    in the full dataset lie at greater than distance β from it. If the dataset has
    100 transactions and f = 0.1 (10%) and β = 0.5, a transaction is an outlier if
    at least 10 other transactions have a distance higher than 0.5 from it. Note that
    the parameter f is virtually equivalent to using a parameter like k in the k-NN
    score. Instead of using a fraction f, we can use the exact kth-nearest neighbor
    distance by setting k = ⌈ N × (1 − f) ⌉. In this case, we can reformulate the
    condition as follows: an observation in a dataset is an outlier if its exact kth-nearest
    neighbor distance is at least β. See listing 9.20.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基于分数阈值的距离异常值* [Knorr 和 Ng，1998]——一个观察（在我们的情况下，是一笔交易）是异常值，如果至少有 f 部分对象在完整数据集中位于距离
    β 以上的位置。如果数据集有 100 笔交易，f = 0.1（10%）且 β = 0.5，那么一笔交易是异常值，如果至少有 10 笔其他交易的距离高于 0.5。请注意，参数
    f 在实际中相当于使用 k-NN 分数中的 k 参数。我们可以通过设置 k = ⌈ N × (1 − f) ⌉ 来使用确切的第 k 个最近邻距离，而不是使用分数
    f。在这种情况下，我们可以将条件重新表述如下：数据集中的观察值是异常值，如果其确切的第 k 个最近邻距离至少是 β。参见列表 9.20。'
- en: '*Rank threshold-based distance outliers* [Ramaswamy et al., 2000]—This second
    definition is based on top-r thresholding rather than the thresholding of the
    absolute values of the scores. This is exactly what we did in the preceding queries
    where we set our threshold to 1,000\. The observations (again, transactions in
    our case) are ranked in decreasing order of the exact k-NN distance or the average
    k-NN distance. The top-r such data points are reported as outliers. Hence, the
    threshold is on the distance rank rather than the distance value. See listing
    9.21.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基于排名阈值的距离异常值* [Ramaswamy等人，2000]——这个第二个定义是基于top-r阈值而不是分数绝对值的阈值。这正是我们在先前的查询中所做的，我们将阈值设置为1,000。观察值（在我们的案例中是交易）按精确k-NN距离或平均k-NN距离的降序排列。这些top-r数据点被报告为异常值。因此，阈值是在距离排名而不是距离值上。参见列表9.21。'
- en: 'It is worth mentioning that both of these variants are related to the distance-based
    approach. All that changes is the way in which the score or rank is computed for
    the outliers: the underlying neighborhood graph is still there as the base graph
    on which the computations are performed. The queries used earlier can easily be
    adapted to return rank threshold-based outliers, as follows.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，这两种变体都与基于距离的方法相关。唯一改变的是计算异常值的分数或排名的方式：基础邻域图仍然是计算的基础图。之前使用的查询可以很容易地调整，以返回基于排名阈值的异常值，如下所示。
- en: Listing 9.20 Rank threshold-based query
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.20 基于排名阈值的查询
- en: '[PRE19]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The threshold (the r value) is set to 100 in this query, but it can be anything
    you like. Regarding the score threshold-based outliers, the previous queries can
    be adapted as follows.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个查询中，阈值（r值）被设置为100，但它可以是任何您喜欢的值。关于基于分数阈值的异常值，之前的查询可以按以下方式调整。
- en: Listing 9.21 Score threshold-based query
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.21 基于分数阈值的查询
- en: '[PRE20]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As is evident from the previous discussions, the k-NN (exact or approximate)
    graph allows you to use multiple approaches on top of the same database with minimal
    effort and disk space.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，k-NN（精确或近似）图允许您在几乎不费力和最小磁盘空间的情况下，在同一个数据库上使用多种方法。
- en: 9.2.4 Advantages of the graph approach
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.4 图方法的优势
- en: 'This section presented one of the most powerful proximity-based techniques
    for fraud detection. We have seen how a single graph model is capable of providing
    an effective support to multiple algorithms/approaches. In particular, graphs
    allow us to do the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了用于欺诈检测的最强大的基于邻近度的技术之一。我们看到了单个图模型如何能够为多个算法/方法提供有效的支持。特别是，图使我们能够做到以下几点：
- en: Properly index the k-NN graph by providing direct access to each of the k-nearest
    neighbors
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过提供对每个k近邻的直接访问来正确索引k-NN图
- en: Store multiple k-NN graphs, exact and approximate, by using different distance
    functions and relationship types, making comparison and analysis simple
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用不同的距离函数和关系类型存储多个k-NN图，精确和近似，使比较和分析变得简单
- en: Explore and evaluate multiple score mechanisms (thanks to the flexibility provided
    by the query and accessing mechanism), making it possible to identify the best
    one and use it for further analysis
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索和评估多种分数机制（多亏了查询和访问机制提供的灵活性），以便能够识别最佳方案并将其用于进一步分析
- en: Use labels to mark different sets of nodes and use them to compute the accuracy
    of the models created
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标签标记不同的节点集，并使用它们来计算创建的模型的准确性
- en: Proximity-based techniques are well-established techniques for outlier detection,
    and the examples in this chapter showed how to combine these classical techniques
    with graphs, making them even more powerful and easy to use.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 基于邻近度的技术是异常检测中确立的技术，本章中的例子展示了如何将这些经典技术与图结合，使它们更加强大且易于使用。
- en: Summary
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter introduced an advanced technique for fraud detection and analysis.
    A combination of graph construction techniques and anomaly detection highlights
    the value of graph models to support data investigation and deep analysis. Different
    approaches have been presented in which the role of the graph is key to delivering
    not only high-quality analysis results, but also an infrastructure that is ready
    to scale to real production-ready solutions. You learned
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了一种用于欺诈检测和分析的高级技术。图构建技术和异常检测的结合突出了图模型在支持数据调查和深度分析中的价值。介绍了不同的方法，其中图的作用对于提供高质量的分析结果以及一个能够扩展到实际生产就绪解决方案的基础设施至关重要。您学习了
- en: How to construct a k-NN graph from transactions and how to use such techniques
    in a new domain for different tasks.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何从事务中构建k-NN图，以及如何将这些技术应用于新领域中的不同任务。
- en: How to use a graph model in a distance-based approach to outlier detection
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在基于距离的异常值检测方法中使用图模型
- en: How to use several distance metrics and multiple approaches at the same time,
    combining the results in a single graph using different relationships
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何同时使用多个距离度量以及多种方法，并通过不同的关系将结果合并到单个图中
- en: How to recognize anomalous nodes in a graph by using different queries
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过不同的查询识别图中的异常节点
- en: The examples and code in this chapter illustrate an end-to-end approach, from
    data import to the final results of the analysis, using algorithms from outlier
    analysis theory.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的示例和代码展示了从数据导入到分析最终结果的端到端方法，使用来自异常值分析理论的算法。
- en: References
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[Aggarwal, 2016] Aggarwal, Charu C. *Outlier Analysis*. New York: Springer,
    2016.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '[Aggarwal, 2016] Aggarwal, Charu C. *Outlier Analysis*. New York: Springer,
    2016.'
- en: '[Akoglu et al., 2014] Akoglu, Leman, Hanghang Tong, and Danai Koutra. “Graph-Based
    Anomaly Detection and Description: A Survey.” arXiv preprint arXiv:1404.4679 (2014).'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '[Akoglu et al., 2014] Akoglu, Leman, Hanghang Tong, and Danai Koutra. “Graph-Based
    Anomaly Detection and Description: A Survey.” arXiv preprint arXiv:1404.4679 (2014).'
- en: '[Aumüller et al., 2018] Aumüller, Martin, Erik Bernhardsson, and Alexander
    Faithfull. “ANN-Benchmarks: A Benchmarking Tool for Approximate Nearest Neighbor
    Algorithms.” arXiv preprint arXiv:1807.05614 (2018).'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '[Aumüller et al., 2018] Aumüller, Martin, Erik Bernhardsson, and Alexander
    Faithfull. “ANN-Benchmarks: A Benchmarking Tool for Approximate Nearest Neighbor
    Algorithms.” arXiv preprint arXiv:1807.05614 (2018).'
- en: '[Fu et al., 2019] Fu, Cong, Chao Xiang, Changxu Wang, and Deng Cai. “Fast Approximate
    Nearest Neighbor Search with the Navigating Spreading-out Graph.” *Proceedings
    of the VLDB Endowment* (2019): 461-474.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '[Fu et al., 2019] Fu, Cong, Chao Xiang, Changxu Wang, and Deng Cai. “Fast Approximate
    Nearest Neighbor Search with the Navigating Spreading-out Graph.” *Proceedings
    of the VLDB Endowment* (2019): 461-474.'
- en: '[Knorr and Ng, 1998] Knorr, Edwin M., and Raymond T. Ng. “Algorithms for Mining
    Distance-Based Outliers in Large Datasets.” *Proceedings of the 24th International
    Conference on Very Large Data Bases* (1998): 392-403.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '[Knorr and Ng, 1998] Knorr, Edwin M., and Raymond T. Ng. “Algorithms for Mining
    Distance-Based Outliers in Large Datasets.” *Proceedings of the 24th International
    Conference on Very Large Data Bases* (1998): 392-403.'
- en: '[Malkov and Yashunin, 2016] Malkov, Yu. A., and D. A. Yashunin. “Efficient
    and Robust Approximate Nearest Neighbor Search Using Hierarchical Navigable Small
    World Graphs.” arXiv preprint arXiv:1603.09320 (2016).'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '[Malkov and Yashunin, 2016] Malkov, Yu. A., and D. A. Yashunin. “Efficient
    and Robust Approximate Nearest Neighbor Search Using Hierarchical Navigable Small
    World Graphs.” arXiv preprint arXiv:1603.09320 (2016).'
- en: '[Manning et al., 2008] Manning, C. D., P. Raghavan, H. Schutze, et al. *Introduction
    to Information Retrieval*. Cambridge, UK: Cambridge University Press, 2008.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '[Manning et al., 2008] Manning, C. D., P. Raghavan, H. Schutze, et al. *Introduction
    to Information Retrieval*. Cambridge, UK: Cambridge University Press, 2008.'
- en: '[Ramaswamy et al., 2000] Ramaswamy, Sridhar, Rajeev Rastogi, and Kyuseok Shim.
    “Efficient Algorithms for Mining Outliers from Large Data Sets.” *ACM SIGMOD Record*
    29:2 (2000), 427-438.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[Ramaswamy et al., 2000] Ramaswamy, Sridhar, Rajeev Rastogi, and Kyuseok Shim.
    “Efficient Algorithms for Mining Outliers from Large Data Sets.” *ACM SIGMOD Record*
    29:2 (2000), 427-438.'
- en: '* * *'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^(1.)[https://www.kaggle.com/mlg-ulb/creditcardfraud](https://www.kaggle.com/mlg-ulb/creditcardfraud).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ^ (1.)[https://www.kaggle.com/mlg-ulb/creditcardfraud](https://www.kaggle.com/mlg-ulb/creditcardfraud).
- en: ^(2.)The formula can be used as though the similarity value is in the [0, 1]
    range. Otherwise, the similarity value has to be normalized by using, for example,
    *similarity*/*max*(*similarity values*).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ^ (2.)可以将公式用作相似度值在[0, 1]范围内的情况。否则，必须通过例如使用*相似度*/*max*(*相似度值*)来归一化相似度值。
- en: ^(3.)[https://github.com/spotify/annoy](https://github.com/spotify/annoy).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ^ (3.)[https://github.com/spotify/annoy](https://github.com/spotify/annoy).
- en: ^(4.)The inverted index data structure is the core component of all the typical
    search engine indexing algorithms. An *inverted index* consists of a list of all
    the unique words that appear in any document and, for each word, a list of the
    documents in which it appears. This data structure is also the most common one
    used in information retrieval processes.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ^ (4.)倒排索引数据结构是所有典型搜索引擎索引算法的核心组件。一个*倒排索引*包括所有出现在任何文档中的唯一单词列表，以及对于每个单词，一个列出它出现的文档列表。这种数据结构也是信息检索过程中最常用的一个。
- en: ^(5.)[http://mng.bz/veDM](https://shortener.manning.com/veDM).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ^ (5.)[http://mng.bz/veDM](https://shortener.manning.com/veDM).
- en: ^(6.)[https://github.com/nmslib/hnswlib](https://github.com/nmslib/hnswlib).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ^ (6.)[https://github.com/nmslib/hnswlib](https://github.com/nmslib/hnswlib).
- en: ^(7.)An interesting article about the importance and functionality of Mahalanobis
    distance is available at [http://mng.bz/4MEV](https://shortener.manning.com/4MEV).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: (7.)一篇关于马氏距离重要性和功能性的有趣文章可在[http://mng.bz/4MEV](https://shortener.manning.com/4MEV)找到。
- en: ^(8.)Depending on the hardware on which you’ll run the script, it could take
    a long time to complete.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: (8.)根据你运行脚本的硬件，完成可能需要很长时间。
- en: ^(9.)[http://mng.bz/Q26j](https://shortener.manning.com/Q26j). Appendix B shows
    how to install and configure it.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: (9.)[http://mng.bz/Q26j](https://shortener.manning.com/Q26j)。附录B展示了如何安装和配置它。
- en: ^(10.)The results can change a bit depending on the approximation used in the
    ANN.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: (10.)结果可能会根据在人工神经网络中使用的方法略有不同。
