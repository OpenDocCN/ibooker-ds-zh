- en: '0 Getting started: Introduction and installation guide'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 0 入门：简介和安装指南
- en: This book will teach you how to write Python programs that run on the command
    line. If you have never used the command line before, don’t worry! You can use
    programs like PyCharm (see figure 0.1) or Microsoft’s VS Code to help you write
    and run these programs. If you are completely new to programming or to the Python
    language, I will try to cover everything I think you’ll need to know, although
    you might find it useful to read another book first if you’ve never heard of things
    like variables and functions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书将教你如何编写在命令行上运行的 Python 程序。如果你以前从未使用过命令行，不要担心！你可以使用像 PyCharm（见图 0.1）或微软的 VS
    Code 这样的程序来帮助你编写和运行这些程序。如果你对编程或 Python 语言完全陌生，我会尽量涵盖我认为你需要知道的一切，尽管如果你从未听说过诸如变量和函数之类的东西，你可能觉得先读另一本书会有所帮助。
- en: In this introduction, we’ll discuss
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简介中，我们将讨论
- en: Why you should learn to write command-line programs
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么你应该学习编写命令行程序
- en: Tools and environments for writing code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写代码的工具和环境
- en: How and why we test software
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何以及为什么测试软件
- en: Writing command-line programs
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写命令行程序
- en: Why do I want you to write command-line programs? For one, I think they strip
    a program down to its most bare essentials. We’re not going to try to write complicated
    programs like an interactive 3D game that requires lots of other software to work.
    The programs in this book will all work with the barest of inputs and create only
    text output. We’re going to focus on learning the core Python language and how
    to write *and test* programs.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我想让你编写命令行程序？一方面，我认为它们将程序简化到最基本的形式。我们不会尝试编写像需要大量其他软件才能运行的交互式 3D 游戏这样的复杂程序。这本书中的程序都将使用最基本的数据输入，并仅创建文本输出。我们将专注于学习核心
    Python 语言以及如何编写和*测试*程序。
- en: Another reason for focusing on command-line programs is that I want to show
    you how to write programs that can run on any computer that has Python installed.
    I’m writing this book on my Mac laptop, but I can run all the programs on any
    of the Linux machines I use in my work or on a friend’s Windows machine. Any computer
    with the same version of Python can run any of these programs, and that is pretty
    cool.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 专注于命令行程序的另一个原因是我想向你展示如何编写可以在任何安装了 Python 的计算机上运行的程序。我在这本书记录的是我的 Mac 笔记本电脑，但我可以在我的工作中使用的任何
    Linux 机器或一个朋友的 Windows 机器上运行所有这些程序。任何具有相同 Python 版本的计算机都可以运行这些程序，这真的很酷。
- en: '![](../Images/intro_1.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/intro_1.png)'
- en: Figure 0.1 This is the PyCharm tool being used to edit and run the hello.py
    program from chapter 1\. “Hello, World!”
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图 0.1 这是使用 PyCharm 工具编辑和运行第 1 章的 hello.py 程序。“你好，世界！”
- en: The biggest reason I want to show you how to write command-line programs, though,
    is because I want to show you how to *test* programs to make sure they work. While
    I don’t think anyone will die if I make a mistake in one of my programs, I still
    really, really want to be sure that my code is as perfect as possible.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我最想向你展示如何编写命令行程序的最大原因，是因为我想向你展示如何*测试*程序以确保它们能正常工作。虽然我不认为如果我在我的程序中犯了一个错误，有人会死去，但我仍然非常、非常希望我的代码尽可能完美。
- en: What does it mean to test a program? Well, if my program is supposed to add
    two numbers together, I’ll need to run it with many pairs of numbers and check
    that it prints the correct sum. I might also give it a number and a word, to make
    sure that it doesn’t try to add “3” plus “seahorse” but instead complains that
    I didn’t give it two numbers. Testing gives me some measure of confidence in my
    code, and I hope you will come to see how testing can help you understand programming
    more deeply.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 测试一个程序意味着什么？嗯，如果我的程序是用来将两个数字相加的，我需要运行它并使用许多数字对来检查它是否打印出正确的总和。我也可以给它一个数字和一个单词，以确保它不会尝试将“3”加上“海马”，而是抱怨我没有给它两个数字。测试给了我一些对我的代码的信心，我希望你能够看到测试如何帮助你更深入地理解编程。
- en: The exercises in this book are meant to be silly enough to pique your interest,
    but they each contain lessons that can be applied to all sorts of real-world problems.
    Almost every program I’ve ever written needs to accept some input data, whether
    from the user or from a file, and produce some output--sometimes text on the screen
    or maybe a new file. These are the kinds of skills you’ll learn by writing these
    programs.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书中的练习旨在足够有趣以激发你的兴趣，但每个练习都包含可以应用于各种现实世界问题的教训。我写的几乎每个程序都需要接受一些输入数据，无论是来自用户还是来自文件，并产生一些输出——有时是屏幕上的文本，也可能是新文件。通过编写这些程序，你将学会这些技能。
- en: In each chapter, I’ll describe some program that I want you to write and the
    tests you’ll use to check if your program is working correctly. Then I’ll show
    you a solution and discuss how it works. As the problems get harder, I’ll start
    suggesting ways you might write your own tests to explore and verify your code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一章中，我将描述一些我想让你编写的程序以及你将使用的测试来检查你的程序是否正确工作。然后我会向你展示一个解决方案并讨论它是如何工作的。随着问题的难度增加，我会开始建议你可能编写自己的测试来探索和验证你的代码。
- en: When you’re done with this book, you should be able to
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成这本书后，你应该能够
- en: Write and run command-line Python programs
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写和运行命令行Python程序
- en: Handle arguments to your programs
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理程序的参数
- en: Write and run tests for your programs and functions
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为你的程序和函数编写和运行测试
- en: Use Python data structures like strings, lists, and dictionaries
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python数据结构，如字符串、列表和字典
- en: Have your programs read and write text files
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让你的程序读取和写入文本文件
- en: Use regular expressions to find patterns in text
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用正则表达式在文本中查找模式
- en: Use and control randomness to make your programs behave unpredictably
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用和控制随机性，使你的程序行为不可预测
- en: “Codes are a puzzle. A game, just like any other game.”
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: “代码是一个谜题。一种游戏，就像其他任何游戏一样。”
- en: --Alan Turing
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: --艾伦·图灵
- en: Alan Turing is perhaps most famous for cracking the Enigma code that the Nazis
    used to encrypt messages during World War II. The fact that the Allies could read
    enemy messages is credited with shortening the war by years and saving millions
    of lives. *The Imitation Game* is a fun movie that shows how Turing published
    puzzles in newspapers to find people who could help him break what was supposed
    to be an unbreakable code.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 艾伦·图灵最著名的可能是破解纳粹在二战期间用来加密消息的恩尼格玛密码。盟军能够阅读敌方消息的事实被归功于缩短了战争数年并挽救了数百万人的生命。《模仿游戏》是一部有趣的电影，展示了图灵如何在报纸上发布谜题来寻找能帮助他破解被认为是不可破解的密码的人。
- en: I think we can learn tons from writing fun programs that generate random insults
    or produce verses to “The Twelve Days of Christmas” or play Tic-Tac-Toe. Some
    of the programs in this book even dabble a bit in cryptography, like in chapter
    4 where we encode all the numbers in a piece of text or in chapter 18 where we
    create signatures for words by summing the numeric representations of their letters.
    I hope you’ll find the programs both amusing and challenging.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为我们可以从编写有趣的程序中学到很多东西，这些程序可以生成随机的侮辱或创作“圣诞十二天”的诗歌，或者玩井字棋。这本书中的一些程序甚至稍微涉猎了一点密码学，比如在第4章中，我们编码文本中的所有数字，或者在第18章中，我们通过求和字母的数字表示来为单词创建签名。我希望你会发现这些程序既有趣又具有挑战性。
- en: The programming techniques in each exercise are not specific to Python. Most
    every language has variables, loops, functions, strings, lists, and dictionaries,
    as well as ways to parameterize and test programs. After you write your solutions
    in Python, I encourage you to write solutions in another language you know and
    compare what parts of the different languages make it easier or harder to write
    your programs. If your programs support the same command-line options, you can
    even use the included tests to verify those programs.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 每个练习中的编程技术并不特定于Python。几乎每种语言都有变量、循环、函数、字符串、列表和字典，以及参数化和测试程序的方法。在你用Python编写解决方案后，我鼓励你用你了解的其他语言编写解决方案，并比较不同语言中哪些部分使编写程序更容易或更难。如果你的程序支持相同的命令行选项，你甚至可以使用包含的测试来验证这些程序。
- en: Using test-driven development
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用测试驱动开发
- en: '*Test-driven development* is described by Kent Beck in his 2002 book by that
    title as a method for creating more reliable programs. The basic idea is that
    we write tests even before we write code. The tests define what it means to say
    that our program works “correctly.” *First* we write and run our tests to verify
    that our code fails. Then we write the code to make each test pass. We always
    run *all of the tests* so that, as we fix new tests, we ensure we don’t break
    tests that were passing before. When all the tests pass, we have at least some
    assurance that the code we’ve written conforms to some manner of specification.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*测试驱动开发*由Kent Beck在他的2002年同名书中描述为创建更可靠程序的方法。基本思想是我们甚至在编写代码之前就编写测试。测试定义了我们的程序“正确工作”的含义。*首先*我们编写和运行测试以验证我们的代码失败。然后我们编写代码使每个测试通过。我们总是运行*所有测试*，这样，当我们修复新的测试时，我们确保我们没有破坏之前通过测试。当所有测试都通过时，我们至少可以保证我们编写的代码符合某种规范。'
- en: Each program you are asked to write in this book comes with tests that will
    tell you when the code is working acceptably. The first test in every exercise
    checks whether the expected program exists. The second test checks that the program
    will print a help message if we ask for help. After that, your program will be
    run with various inputs and options.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 本书要求你编写的每个程序都附带测试，这些测试会告诉你代码何时可以接受地工作。每个练习的第一个测试检查预期的程序是否存在。第二个测试检查程序在请求帮助时是否会打印帮助信息。之后，你的程序将使用各种输入和选项运行。
- en: Since I’ve written around 250 tests for the programs in this book, and you have
    not yet written one of the programs, you’re going to encounter many failed tests.
    That’s OK! In fact, it’s a really good thing, because when you pass all the tests,
    you’ll know that your programs are correct. You’ll learn to read the failed tests
    carefully to figure out what needs fixing. Then you’ll correct the program and
    run the tests again. You may get another failed test, in which case you’ll repeat
    the process until finally all the tests pass. Then you’ll be done.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我为本书的程序编写了大约250个测试，而你还没有编写过任何一个程序，你将遇到许多失败的测试。这是正常的！实际上，这是一个非常好的事情，因为当你通过所有测试时，你就知道你的程序是正确的。你将学会仔细阅读失败的测试，以找出需要修复的地方。然后你将修正程序并再次运行测试。你可能还会得到另一个失败的测试，在这种情况下，你需要重复这个过程，直到最终所有测试都通过。然后你就可以完成了。
- en: '![](../Images/intro_unnumb-1.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/intro_unnumb-1.png)'
- en: It doesn’t matter if you solve the problems the same way as in the solution
    I provide. All that matters is that you figure out a way to pass the tests.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你以何种方式解决我提供的解决方案中的问题，都没有关系。重要的是你要找到一种方法来通过测试。
- en: Setting up your environment
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置你的环境
- en: If you want to write these programs on your computer, you will need Python version
    3.6 or later. It’s quite possible that it’s already installed on your computer.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在你的计算机上编写这些程序，你需要Python 3.6或更高版本。它很可能已经安装在你的计算机上。
- en: You’ll also need some way to execute the `python3` command--something we often
    call a *command line*. If you use a Windows computer, you may want to install
    Windows Subsystem for Linux (WSL). On a Mac, the default Terminal app is sufficient.
    You can also use a tool like VS Code (in figure 0.2) or PyCharm, which have terminals
    built into them.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要一种方式来执行`python3`命令——我们通常称之为*命令行*。如果你使用的是Windows计算机，你可能想安装Windows Subsystem
    for Linux（WSL）。在Mac上，默认的终端应用就足够了。你也可以使用像VS Code（如图0.2所示）或PyCharm这样的工具，这些工具内置了终端。
- en: '![](../Images/intro_2.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/intro_2.png)'
- en: Figure 0.2 An IDE like VS Code combines a text editor for writing your code
    along with a terminal (lower-right window) for running your programs, and many
    other tools.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图0.2 一个像VS Code这样的IDE将代码编辑器（用于编写代码）与终端（右下角窗口）结合起来，用于运行程序，以及许多其他工具。
- en: I wrote and tested the programs for this book with Python version 3.8, but they
    should work with version 3.6 or newer. Python 2 reached its end of life at the
    end of 2019 and should no longer be used. To see what version of Python you have
    installed, open a terminal window and type `python3` `--version`. If it says something
    like “command "python3" not found,” then you need to install Python. You can download
    the latest version from the Python site ([www.python.org/downloads](http://www.python.org/downloads)).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用Python 3.8编写并测试了本书的程序，但它们应该与3.6或更新的版本兼容。Python 2在2019年底达到了其生命的尽头，不应再使用。要查看你安装的Python版本，打开终端窗口并输入`python3
    --version`。如果显示“找不到命令"python3"”，那么你需要安装Python。你可以从Python网站下载最新版本（[www.python.org/downloads](http://www.python.org/downloads)）。
- en: If you are using a computer that doesn’t have Python, and you don’t have any
    way to install Python, you can do everything in this book using the Repl.it website
    ([http://repl.it](http://repl.it)).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是没有Python的计算机，并且没有安装Python的方法，你可以通过Repl.it网站（[http://repl.it](http://repl.it)）来完成本书中的所有内容。
- en: Code examples
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码示例
- en: 'Throughout the book, I will show commands and code using a `fixed-width` `font`.
    When the text is preceded with a dollar sign (`$`), that means it’s something
    you can type on the command line. For instance, there is a program called `cat`
    (short for “concatenate”) that will print the contents of a file to the screen.
    Here is how I can run it to print the contents of the spiders.txt file that lives
    in the inputs directory:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我将使用`固定宽度`的`字体`来展示命令和代码。当文本前带有美元符号（`$`）时，这意味着你可以在命令行中输入的内容。例如，有一个名为`cat`（代表“连接”）的程序，它可以将文件的內容打印到屏幕上。以下是如何运行它来打印位于inputs目录中的spiders.txt文件的內容：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you want to run that command, *do not copy* the leading `$`, only the text
    that follows. Otherwise you’ll probably get an error like “$: command not found.”'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你想要运行那个命令，*不要复制*前面的 `$`，只复制后面的文本。否则你可能会得到一个错误，比如“$: command not found。”'
- en: Python has a really excellent tool called IDLE that allows you to interact directly
    with the language to try out ideas. You can start it with the command `idle3`.
    That should open a new window with a prompt that looks like `>>>` (see figure
    0.3).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有一个叫做 IDLE 的非常出色的工具，它允许你直接与语言交互来尝试新想法。你可以通过命令 `idle3` 启动它。这应该会打开一个新窗口，其中的提示符看起来像
    `>>>`（见图 0.3）。
- en: '![](../Images/intro_3.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/intro_3.png)'
- en: Figure 0.3 The IDLE application allows you to interact directly with the Python
    language. Each statement you type is evaluated when you press Enter, and the results
    are shown in the window.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 0.3 IDLE 应用程序允许你直接与 Python 语言交互。你按 Enter 键输入的每个语句都会被评估，结果会在窗口中显示。
- en: 'You can type Python statements there, and they will be immediately evaluated
    and printed. For example, type `3` `+` `5` and press Enter, and you should see
    `8`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在那里键入 Python 语句，它们将被立即评估并打印出来。例如，键入 `3` `+` `5` 并按 Enter 键，你应该会看到 `8`：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This interface is called a *REPL* because it’s a Read-Evaluate-Print-Loop. (I
    pronounce this like “repple” in a way that sort of rhymes with “pebble.”) You
    can get a similar tool by typing `python3` on the command line (see figure 0.4).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个界面被称为 *REPL*，因为它是一个读取-评估-打印-循环。（我把它读作“repple”，它有点像“pebble”押韵。）你可以在命令行中键入 `python3`
    来获取一个类似的工具（见图 0.4）。
- en: '![](../Images/intro_4.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/intro_4.png)'
- en: Figure 0.4 Typing the command `python3` in the terminal will give you a REPL
    similar to the IDLE interface.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 0.4 在终端中键入命令 `python3` 将会给你一个类似于 IDLE 界面的 REPL。
- en: The IPython program is yet another “interactive Python” REPL that has many enhancements
    over IDLE and `python3`. Figure 0.5 shows what it looks like on my system.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: IPython 程序是另一个“交互式 Python”REPL，它在 IDLE 和 `python3` 上有很多增强功能。图 0.5 展示了在我的系统上的样子。
- en: I also recommend you look into using Jupyter Notebooks, as they allow you to
    interactively run code with the added bonus that you can save a Notebook as a
    file and share all your code with other people.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我还推荐你了解一下 Jupyter Notebooks，因为它们允许你交互式地运行代码，并且还有一个额外的优点，那就是你可以将笔记本保存为文件，并与其他人共享所有代码。
- en: '![](../Images/intro_5.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/intro_5.png)'
- en: Figure 0.5 The IPython application is another REPL interface you can use to
    try out your ideas with Python.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 0.5 IPython 应用程序是另一个你可以用来尝试 Python 想法的 REPL 界面。
- en: 'Whichever REPL interface you use, you can type Python statements like `x` `=`
    `10` and press Enter to assign the value `10` to the variable `x`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用哪个 REPL 界面，你都可以键入 Python 语句，例如 `x` `=` `10` 并按 Enter 键，将值 `10` 赋给变量 `x`：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As with the command-line prompt, `$`, do not copy the leading `>>>` or Python
    will complain:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 与命令行提示符 `$` 一样，不要复制前面的 `>>>`，否则 Python 会报错：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The IPython REPL has a magical `%paste` mode that removes the leading `>>>`
    prompts so that you can copy and paste all the code examples:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: IPython REPL 有一个魔法 `%paste` 模式，它可以移除前面的 `>>>` 提示符，这样你就可以复制并粘贴所有代码示例：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Whichever way you choose to interact with Python, I suggest you *manually type
    all the code yourself* in this book, as this builds muscle memory and forces you
    to interact with the syntax of the language.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择哪种方式与 Python 交互，我建议你在本书中*手动键入所有代码*，因为这可以建立肌肉记忆并迫使你与语言的语法进行交互。
- en: Getting the code
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取代码
- en: 'All the tests and solutions are available at [https://github.com/kyclark/tiny_python_
    projects](https://github.com/kyclark/tiny_python_projects). You can use the program
    Git (which you may need to install) to copy that code to your computer with the
    following command:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 所有测试和解决方案都可以在 [https://github.com/kyclark/tiny_python_projects](https://github.com/kyclark/tiny_python_projects)
    找到。你可以使用 Git 程序（你可能需要安装）通过以下命令将代码复制到你的电脑上：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now you should have a new directory called tiny_python_projects on your computer.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该在你的电脑上有一个名为 tiny_python_projects 的新目录。
- en: You may prefer to make a copy of the code into your own repository, so that
    you can track your changes and share your solutions with others. This is called
    “forking” because you’re breaking off from my code and adding your own programs
    to the repository. If you plan to use Repl.it to write the exercises, I recommend
    you do fork my repo into your own account so that you can configure Repl.it to
    interact with your own GitHub repositories.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能更喜欢将代码复制到自己的仓库中，这样您就可以跟踪您的更改并与他人分享您的解决方案。这被称为“Fork”，因为您正在从我的代码中分离出来，并将您自己的程序添加到仓库中。如果您计划使用Repl.it编写练习，我建议您将我的repo
    Fork到您自己的账户中，这样您就可以配置Repl.it与您自己的GitHub仓库进行交互。
- en: 'To fork, do the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行Fork操作，请执行以下步骤：
- en: Create an account on GitHub.com.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在GitHub.com上创建一个账户。
- en: Go to [https://github.com/kyclark/tiny_python_projects](https://github.com/kyclark/tiny_python_projects).
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往[https://github.com/kyclark/tiny_python_projects](https://github.com/kyclark/tiny_python_projects)。
- en: Click the Fork button (see figure 0.6) to make a copy of the repository into
    your account.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“Fork”按钮（见图0.6）将仓库复制到您的账户中。
- en: '![](../Images/intro_6.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/intro_6.png)'
- en: Figure 0.6 The Fork button on my GitHub repository will make a copy of the code
    into your account.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图0.6 在我的GitHub仓库中的“Fork”按钮会将代码复制到您的账户中。
- en: 'Now you have a copy of my all code in your own repository. You can use Git
    to copy that code to your computer. Be sure to replace “YOUR_GITHUB_ID” with your
    actual GitHub ID:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您在自己的仓库中有了我的所有代码的副本。您可以使用Git将此代码复制到您的计算机上。请确保将“YOUR_GITHUB_ID”替换为您的实际GitHub
    ID：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'I may update the repo after you make your copy. If you would like to be able
    to get those updates, you will need to configure Git to set my repository as an
    “upstream” source. To do so, after you have cloned your repository to your computer,
    go into your tiny_python_projects directory:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我可能会在您复制后更新仓库。如果您想获取这些更新，您需要配置Git将我的仓库设置为“上游”源。为此，在您将您的仓库克隆到您的计算机后，进入您的tiny_python_projects目录：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then execute this command:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然后执行以下命令：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Whenever you would like to update your repository from mine, you can execute
    this command:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您想从我的仓库更新您的仓库时，您可以执行此命令：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Installing modules
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装模块
- en: 'I recommend using a few tools that may not be installed on your system. You
    can use the `pip` module to install them like so:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议使用一些可能未安装在本系统上的工具。您可以使用`pip`模块像这样安装它们：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'I’ve also included a requirements.txt file in the top level of the repository.
    You can use it to install all the modules and tools with this command:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我还在仓库的顶级目录中包含了一个requirements.txt文件。您可以使用此命令安装所有模块和工具：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If, for example, you wish to write the exercises on Repl.it, you will need to
    run this command to set up your environment, as the modules are not already installed.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您想在Repl.it上编写练习，您需要运行此命令来设置您的环境，因为这些模块尚未安装。
- en: Code formatters
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码格式化工具
- en: Most IDEs and text editors will have tools to help you format your code so that
    it’s easier to read and find problems. In addition, the Python community has created
    a standard for writing code so that other Python programmers can readily understand
    it. The PEP 8 (Python Enhancement Proposal) document at [www.python.org/dev/peps/
    pep-0008/](http://www.python.org/dev/peps/pep-0008/) describes best practices
    for formatting code, and most editors will automatically apply formatting for
    you. For instance, the Repl.it interface has an autoformat button (see figure
    0.7), VS Code has a Format Document command, and PyCharm has a Reformat Code command.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数IDE和文本编辑器都会有工具帮助您格式化代码，使其更容易阅读和查找问题。此外，Python社区已经为编写代码制定了一个标准，以便其他Python程序员可以轻松理解。位于[www.python.org/dev/peps/pep-0008/](http://www.python.org/dev/peps/pep-0008/)的PEP
    8（Python增强提案）文档描述了格式化代码的最佳实践，并且大多数编辑器会自动为您应用格式。例如，Repl.it界面有一个自动格式化按钮（见图0.7），VS
    Code有一个“格式化文档”命令，PyCharm有一个“重新格式化代码”命令。
- en: '![](../Images/intro_7.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/intro_7.png)'
- en: Figure 0.7 The Repl.it tool has an autoformat button to reformat your code according
    to community standards. The interface also includes a command line for running
    and testing your program.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图0.7 Repl.it工具有一个自动格式化按钮，可以根据社区标准重新格式化您的代码。界面还包括一个用于运行和测试程序的命令行。
- en: There are also command-line tools that integrate with your editor. I used YAPF
    (Yet Another Python Formatter, [https://github.com/google/yapf](https://github.com/google/yapf))
    to format every program in the book, but another popular formatter is Black ([https://github.com/psf/
    black](https://github.com/psf/black)). Whatever you use, I encourage you to use
    it *often*. For instance, I can tell YAPF to format the hello.py program that
    we will write in chapter 1 by running the following command. Note that the `-i`
    tells YAPF to format the code “in place,” so that the original file will be overwritten
    with the newly formatted code.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些命令行工具可以与您的编辑器集成。我使用了 YAPF（Yet Another Python Formatter，[https://github.com/google/yapf](https://github.com/google/yapf)）来格式化本书中的每个程序，但另一个流行的格式化工具是
    Black ([https://github.com/psf/black](https://github.com/psf/black))。无论您使用什么，我都鼓励您经常使用它。例如，我可以通过运行以下命令来告诉
    YAPF 格式化我们在第 1 章将要编写的 hello.py 程序。请注意，`-i` 告诉 YAPF 在“原地”格式化代码，因此原始文件将被新格式化的代码覆盖。
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Code linters
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码检查器
- en: A *code linter* is a tool that will report problems in your code, such as declaring
    a variable but never using it. Two that I like are Pylint ([www.pylint.org/](http://www.pylint.org/))
    and Flake8 ([http://flake8.pycqa.org/en/latest/](http://flake8.pycqa.org/en/latest/)),
    and both can find errors in your code that the Python interpreter itself will
    not complain about.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码检查器* 是一种工具，它会报告您代码中的问题，例如声明了一个变量但从未使用它。我喜欢的两个是 Pylint ([www.pylint.org/](http://www.pylint.org/))
    和 Flake8 ([http://flake8.pycqa.org/en/latest/](http://flake8.pycqa.org/en/latest/))，它们都可以找到
    Python 解释器本身不会抱怨的错误。'
- en: In the final chapter, I will show you how to incorporate *type hints* into your
    code that the Mypy tool ([http://mypy-lang.org/](http://mypy-lang.org/)) can use
    to find problems, such as using text when you should be using a number.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一章中，我将向您展示如何将 *类型提示* 集成到您的代码中，Mypy 工具 ([http://mypy-lang.org/](http://mypy-lang.org/))
    可以使用这些类型提示来查找问题，例如在应该使用数字时使用了文本。
- en: How to start writing new programs
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何开始编写新程序
- en: 'I think it’s much easier to start writing code with a standard template, so
    I wrote a program called new.py that will help you create new Python programs
    with boilerplate code that will be expected of every program. It’s located in
    the bin directory, so if you are in the top directory of the repository, you can
    run it like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为使用标准模板开始编写代码要容易得多，所以我编写了一个名为 new.py 的程序，它将帮助您使用每个程序都期望的样板代码创建新的 Python 程序。它位于
    bin 目录中，因此如果您在存储库的顶级目录中，您可以像这样运行它：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here you can see that new.py is asking you to provide the name of the “program”
    to create. For each chapter, the program you write needs to live in the directory
    that has the test.py file for that program.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到 new.py 正在要求您提供要创建的“程序”名称。对于每一章，您编写的程序需要位于包含该程序 test.py 文件的目录中。
- en: 'For example, you can use new.py to start off chapter 2’s crowsnest.py program
    in the 02_crowsnest directory like so:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以使用 new.py 在 02_crowsnest 目录中启动第 2 章的 crowsnest.py 程序，如下所示：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you open that file now, you’ll see that it has written a lot of code for
    you that I’ll explain later. For now, just realize that the resulting crowsnest.py
    program is one that can be run like so:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在打开该文件，您会看到它为您编写了大量的代码，我稍后会解释。现在，只需意识到生成的 crowsnest.py 程序可以像这样运行：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Later you’ll learn how to modify the program to do what the tests expect.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您将学习如何修改程序以实现测试所期望的功能。
- en: 'An alternative to running new.py is to copy the file template.py from the template
    directory to the directory and program name you need to write. You could create
    the crowsnest.py program file like so:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 new.py 的另一种方法是复制 template 目录中的 template.py 文件到您需要编写程序和目录名。您可以创建 crowsnest.py
    程序文件如下所示：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You do not have to use either new.py or copy the template.py file to start your
    programs. These are provided to save you time and provide your programs with an
    initial structure, but you are welcome to write your programs however you please.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您不必使用 new.py 或复制 template.py 文件来启动您的程序。这些文件提供给您节省时间并提供程序初始结构，但您当然可以按照您喜欢的任何方式编写程序。
- en: Why not Notebooks?
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么不使用 Notebooks？
- en: 'Many people are familiar with Jupyter Notebooks, as they provide a way to integrate
    Python code and text and images into a document that other people can execute
    like a program. I really love Notebooks, especially for interactively exploring
    data, but I find them difficult to use in teaching for the following reasons:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人熟悉 Jupyter Notebooks，因为它们提供了一种将 Python 代码、文本和图像集成到文档中的方法，其他人可以像执行程序一样执行这些文档。我真的很喜欢
    Notebooks，尤其是在交互式探索数据时，但我发现它们在教学上使用起来有些困难，以下是一些原因：
- en: A Notebook is stored in JavaScript Object Notation (JSON), not as line-oriented
    text. This makes it really difficult to compare Notebooks to each other to find
    out how they differ.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 笔记本存储在 JavaScript 对象表示法（JSON）中，而不是按行排列的文本。这使得比较笔记本之间的差异变得非常困难。
- en: Code and text and images can live mixed together in separate cells. These cells
    can be interactively run in any order, which can lead to very subtle problems
    in the logic of a program. The programs we write in this book will always be run
    from top to bottom in entirety every time, which I think makes them easier to
    understand.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码、文本和图像可以混合存储在单独的单元中。这些单元可以以任何顺序交互式运行，这可能导致程序逻辑中非常微妙的问题。我们在这本书中编写的程序将始终在每次运行时从头到尾完整运行，我认为这使它们更容易理解。
- en: There is no way for Notebooks to accept different values when they are run.
    That is, if you test a program with one input file and then want to change to
    a different file, you have to change *the program itself*. You will learn how
    to pass in a file as an *argument* to the program, so that you can change the
    value without changing the *code*.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 笔记本在运行时无法接受不同的值。也就是说，如果您用一个输入文件测试程序，然后想切换到另一个文件，您必须更改*程序本身*。您将学习如何将文件作为*参数*传递给程序，这样您就可以在不更改*代码*的情况下更改值。
- en: It’s difficult to automatically run tests on a Notebook or on the functions
    they contain. We will use the `pytest` module to run our programs over and over
    with different input values and verify that the programs create the correct output.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动在笔记本或其包含的函数上运行测试是困难的。我们将使用 `pytest` 模块反复运行我们的程序，并使用不同的输入值来验证程序是否生成正确的输出。
- en: The scope of topics we’ll cover
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们将涵盖的主题范围
- en: The purpose of this book is to show you how amazingly useful all the built-in
    features of the Python language are. The exercises will push you to practice manipulating
    strings, lists, dictionaries, and files. We’ll spend several chapters focusing
    on regular expressions, and every exercise except for the last requires you to
    accept and validate command-line arguments of varying types and numbers.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的目的是向您展示 Python 语言的所有内置功能是多么的惊人有用。练习将推动您练习操作字符串、列表、字典和文件。我们将用几章内容专注于正则表达式，除了最后一章的练习外，每个练习都需要您接受和验证不同类型和数量的命令行参数。
- en: Every author is biased toward some subjects, and I’m no different. I’ve chosen
    these topics because they reflect ideas that are fundamental to the work I’ve
    done over the last 20 years. For instance, I have spent many more hours than I
    would care to admit parsing really messy data from countless Excel spreadsheets
    and XML files. The world of genomics that has consumed most of my career is based
    primarily on efficiently parsing text files, and much of my web development work
    is predicated on understanding how text is encoded and transferred to and from
    the web browser. For that reason, you’ll find many exercises that entail processing
    text and files, and that will challenge you to think about how to transform inputs
    into outputs. If you work through every exercise, I believe you’ll be a much improved
    programmer who understands the basic ideas that are common across many languages.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 每位作者都会对某些主题有所偏见，我也不例外。我选择这些主题是因为它们反映了我过去 20 年工作中的一些基本理念。例如，我花了比我想承认的更多的时间来解析来自无数电子表格和
    XML 文件的真正混乱的数据。占据了我大部分职业生涯的基因组学世界主要基于高效地解析文本文件，而我大部分的网页开发工作都是基于理解文本是如何编码以及如何从网页浏览器中传输的。因此，您会发现许多涉及处理文本和文件的练习，这些练习将挑战您思考如何将输入转换为输出。如果您完成每一个练习，我相信您将成为一个改进了很多的程序员，能够理解许多语言中普遍存在的基本思想。
- en: Why not object-oriented programming?
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么不使用面向对象编程？
- en: One topic that you’ll notice is missing from this book is writing object-oriented
    code in Python. If you are not familiar with *object-oriented programming* (OOP),
    you can skip this section.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到这本书中缺少的一个主题是使用 Python 编写面向对象的代码。如果您不熟悉*面向对象编程*（OOP），您可以跳过这一部分。
- en: I think OOP is a somewhat advanced topic that is beyond the scope of this book.
    I prefer to focus on how to write small functions and their accompanying tests.
    I think this leads to more transparent code, because the functions should be short,
    should only use the values explicitly passed as arguments, and should have enough
    tests that you can completely understand how they will behave under both favorable
    and unfavorable circumstances.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为面向对象编程是一个相对高级的话题，超出了这本书的范围。我更倾向于关注如何编写小的函数及其伴随的测试。我认为这会导致更透明的代码，因为函数应该是短的，只应使用显式传递的参数值，并且应该有足够的测试，这样你就可以完全理解它们在有利和不利的条件下会如何表现。
- en: The Python language is itself inherently object-oriented. Almost everything
    from strings to the lists and dictionaries that we’ll use are actually *objects*,
    so you’ll get plenty of practice using objects. But I don’t think it’s necessary
    to create objects to solve any of the problems I present. In fact, even though
    I spent many years writing object-oriented code, I haven’t written in this style
    for the last few years. I tend to draw my inspiration from the world of purely
    functional programming, and I hope I can convince you by the end of this book
    that you can do anything you want by combining functions.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Python 语言本身是固有的面向对象。从字符串到我们将会使用的列表和字典等几乎所有事物实际上都是 *对象*，所以你将有很多使用对象的机会。但我不认为解决我提出的任何问题都需要创建对象。实际上，尽管我多年来一直在编写面向对象的代码，但我在过去几年里并没有以这种风格编写。我倾向于从纯函数式编程的世界中汲取灵感，并希望我在这本书的结尾能说服你，通过组合函数，你可以做任何你想做的事情。
- en: Although I personally avoid OOP, I would recommend you learn about it. There
    have been several seismic paradigm shifts in the world of programming from procedural
    to object-oriented and now functional. You can find dozens of books on OOP in
    general and on programming objects in Python specifically. This is a deep and
    fascinating topic, and I encourage you to try writing object-oriented solutions
    and compare them to my solutions.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我本人避免使用面向对象编程（OOP），但我仍然建议你了解它。编程世界中已经发生了几次重大的范式转变，从过程式到面向对象，再到现在的函数式。你可以找到关于面向对象编程的几十本书，特别是关于在
    Python 中编程对象的书籍。这是一个深奥且引人入胜的话题，我鼓励你尝试编写面向对象的解决方案，并将它们与我提供的解决方案进行比较。
- en: A note about the lingo
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于术语的说明
- en: Often in programming books you will see *foobar* used in examples. The word
    has no real meaning, but its origin probably comes from the military acronym “FUBAR”
    (Fouled Up Beyond All Recognition). If I use “foobar” in an example, it’s because
    I don’t want to talk about any specific thing in the universe, just the idea of
    a string of characters. If I need a list of items, usually the first item will
    be “foo” and the next will be “bar.” After that, convention uses “baz” and “quux,”
    again because they mean nothing at all. Don’t get hung up on “foobar.” It’s just
    a placeholder for something that could be more interesting later.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程书籍中，你经常会看到在示例中使用 *foobar*。这个词本身没有实际意义，但它的起源可能来自军事缩写词“FUBAR”（Fouled Up Beyond
    All Recognition）。如果我在示例中使用“foobar”，那是因为我不想谈论宇宙中的任何特定事物，只是想表达一串字符的概念。如果我需要一个项目列表，通常第一个项目会是“foo”，接下来是“bar”。之后，按照惯例使用“baz”和“quux”，因为它们根本没有任何意义。不要纠结于“foobar”。它只是一个占位符，可能在未来会变得更有趣。
- en: '| Programmers also tend to call errors in code *bugs*. This comes from the
    days of computing before the invention of transistors. Early machines used vacuum
    tubes, and the heat from the machines would attract actual bugs like moths that
    could cause short circuits. The operators (the people running the machines) would
    have to hunt through the machinery to find and remove the bugs; hence, the term
    “to debug.” | ![](../Images/intro_unnumb-2.png)  |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 程序员还倾向于将代码中的错误称为 *bugs*。这来自计算机发明晶体管之前的计算时代。早期的机器使用真空管，机器产生的热量会吸引实际的虫子，如蛾子，这可能导致短路。操作员（运行机器的人）必须检查机器以找到并移除虫子；因此，产生了“to
    debug”这个术语。 | ![图片](../Images/intro_unnumb-2.png) |'
