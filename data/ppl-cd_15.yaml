- en: 12 Lambda-based serverless functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12 基于 Lambda 的无服务器函数
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Implementing a CI/CD pipeline for a serverless-based application from scratch
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从零开始实现基于无服务器的应用程序的 CI/CD 管道
- en: Setting up continuous deployment and delivery with AWS Lambda
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 AWS Lambda 设置持续部署和交付
- en: Separating multiple Lambda deployment environments
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分离多个 Lambda 部署环境
- en: Implementing API Gateway multistage deployments with Lambda alias and stage
    variables
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Lambda 别名和阶段变量实现 API 网关的多阶段部署
- en: Delivering email notifications with attachments upon completion of CI/CD pipelines
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 CI/CD 管道完成后发送带有附件的电子邮件通知
- en: In the previous chapters, you learned how to write a CI/CD pipeline for a containerized
    application running in both Docker Swarm and Kubernetes. In this chapter, you
    will learn how to deploy the same application written in a different architecture.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你学习了如何为在 Docker Swarm 和 Kubernetes 上运行的可容器化应用程序编写 CI/CD 管道。在本章中，你将学习如何部署使用不同架构编写的相同应用程序。
- en: '*Serverless* is the fastest-growing architectural movement right now. It allows
    developers to develop scalable applications faster by delegating the full responsibility
    of managing the underlying infrastructure to the cloud provider. That said, going
    serverless carries several key challenges, one of which is CI/CD.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*无服务器* 是目前增长最快的架构运动。它允许开发者通过将底层基础设施的全部管理责任委托给云服务提供商，更快地开发可扩展的应用程序。然而，采用无服务器架构也带来了一些关键挑战，其中之一就是持续集成/持续部署（CI/CD）。'
- en: 12.1 Deploying a Lambda-based application
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.1 基于 Lambda 的应用程序部署
- en: Multiple serverless providers are out there, but to keep it simple, we’ll use
    AWS—and specifically, AWS Lambda ([https://aws.amazon.com/lambda/](https://aws.amazon.com/lambda/)),
    which is the best known and most mature solution in the serverless space today.
    AWS Lambda, launched at AWS re:Invent 2014, was the first implementation of serverless
    computing. Users can upload their code to Lambda, which then performs operational
    and scaling activities on behalf of the users.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 目前有多个无服务器提供商，但为了简化，我们将使用 AWS——具体来说，是 AWS Lambda ([https://aws.amazon.com/lambda/](https://aws.amazon.com/lambda/))，这是目前在无服务器领域最知名且最成熟的服务。AWS
    Lambda 于 2014 年 AWS re:Invent 上推出，是第一个无服务器计算的实施。用户可以将他们的代码上传到 Lambda，Lambda 然后代表用户执行操作和扩展活动。
- en: The service follows an event-driven architecture. This means the code deployed
    in Lambda can be triggered in response to events like HTTP requests coming from
    services like Amazon API Gateway ([https://aws.amazon.com/api-gateway/](https://aws.amazon.com/api-gateway/)).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 该服务遵循事件驱动架构。这意味着部署在 Lambda 中的代码可以响应来自像 Amazon API Gateway ([https://aws.amazon.com/api-gateway/](https://aws.amazon.com/api-gateway/))
    这样的服务发出的 HTTP 请求等事件。
- en: Before going into further detail about how to create a CI/CD pipeline for a
    serverless application, we will look at the corresponding architecture. Figure
    12.1 shows how serverless services like Amazon API Gateway, Amazon DynamoDB, Amazon
    S3, and AWS Lambda fit into the application architecture.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在进一步详细介绍如何为无服务器应用程序创建 CI/CD 管道之前，我们将查看相应的架构。图 12.1 展示了像 Amazon API Gateway、Amazon
    DynamoDB、Amazon S3 和 AWS Lambda 这样的无服务器服务如何融入应用程序架构。
- en: '![](Images/CH12_F01_Labouardy.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH12_F01_Labouardy.png)'
- en: Figure 12.1 Watchlist application based on serverless architecture. Each Lambda
    function is responsible for a single API endpoint. The endpoints are managed through
    API Gateway and consumed by the Marketplace service hosted on an S3 bucket.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1 基于无服务器架构的 Watchlist 应用程序。每个 Lambda 函数负责单个 API 端点。端点通过 API Gateway 管理，并由托管在
    S3 存储桶上的 Marketplace 服务消费。
- en: AWS Lambda empowers microservice development. That being said, each endpoint
    triggers a different Lambda function. These functions are independent of one another
    and can be written in different languages. Hence, this leads to scaling at the
    function level, easier unit testing, and loose coupling. All requests from clients
    first go through API Gateway. It then routes the incoming request to the right
    Lambda function accordingly. The functions are stateless, so that’s where DynamoDB
    comes into the scene, to manage data persistence across Lambda functions. The
    Amazon S3 bucket is used to serve the marketplace static web application. Finally,
    an Amazon CloudFront distribution (optional) is used to deliver static assets
    such as Cascading Style Sheets (CSS) or JavaScript files from edge cache locations
    around the globe.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: AWS Lambda 推动了微服务开发。也就是说，每个端点都会触发不同的 Lambda 函数。这些函数彼此独立，可以用不同的语言编写。因此，这导致了函数级别的扩展、更简单的单元测试和松散耦合。所有来自客户端的请求首先通过
    API Gateway。然后根据需要将传入的请求路由到正确的 Lambda 函数。这些函数是无状态的，因此 DynamoDB 就在这里发挥作用，以管理 Lambda
    函数之间的数据持久性。Amazon S3 存储桶用于提供市场静态 Web 应用程序。最后，使用 Amazon CloudFront 分发（可选）从全球边缘缓存位置交付静态资产，如层叠样式表（CSS）或
    JavaScript 文件。
- en: To deploy a Lambda function, we need to create an AWS Lambda resource and an
    IAM execution role with a list of AWS resources that the Lambda function has access
    to during runtime. For instance, the Lambda function `MoviesStoreListMovies` issues
    a `Scan` operation on a DynamoDB table to fetch a list of movies. Therefore, the
    Lambda execution role should grant access to the DynamoDB table.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署 Lambda 函数，我们需要创建一个 AWS Lambda 资源和一个 IAM 执行角色，该角色列出了 Lambda 函数在运行时可以访问的 AWS
    资源。例如，Lambda 函数 `MoviesStoreListMovies` 在 DynamoDB 表上执行 `Scan` 操作以获取电影列表。因此，Lambda
    执行角色应授予对 DynamoDB 表的访问权限。
- en: To avoid duplication of code and provide a lightweight abstraction for creating
    Lambda functions, we will use Terraform modules. A *module* is a container for
    multiple resources that are used together.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免代码重复并提供创建 Lambda 函数的轻量级抽象，我们将使用 Terraform 模块。*模块*是用于一起使用的一组多个资源的容器。
- en: Note You can use Terraform Registry ([https://registry.terraform.io/](https://registry.terraform.io/))
    to download well-tested modules built by the community or publish your own modules
    remotely.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您可以使用 Terraform 注册表 ([https://registry.terraform.io/](https://registry.terraform.io/))
    下载社区构建的经过良好测试的模块或远程发布您自己的模块。
- en: The module responsible for creating an AWS Lambda resource is located under
    the modules folder (chapter12/terraform/modules). Create a new lambda.tf file
    with a module block for each Lambda function, as shown in the following listing.
    The module resource references the custom module through the `source` argument
    and overrides default variables such as the Lambda runtime environment and environment
    variables.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 负责创建 AWS Lambda 资源的模块位于模块文件夹（chapter12/terraform/modules）下。为每个 Lambda 函数创建一个新的
    lambda.tf 文件，其中包含模块块，如下所示。模块资源通过 `source` 参数引用自定义模块，并覆盖默认变量，例如 Lambda 运行时环境和环境变量。
- en: Listing 12.1 Creating Lambda functions with the Terraform module
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.1 使用 Terraform 模块创建 Lambda 函数
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This code will provision a `MoviesLoader` Lambda function based on the Python
    3.7 runtime environment, a `MoviesParser` function based on the Go runtime, and
    a `MoviesStoreListMovies` function based on the Node.js environment.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将基于 Python 3.7 运行时环境部署一个 `MoviesLoader` Lambda 函数，一个基于 Go 运行时的 `MoviesParser`
    函数，以及一个基于 Node.js 环境的 `MoviesStoreListMovies` 函数。
- en: Next, we will deploy a RESTful API with Amazon API Gateway and define HTTP endpoints
    to trigger the Lambda functions upon incoming HTTP/HTTPS requests. The Terraform
    code in listing 12.2 exposes a GET method on the /movies resource. When a GET
    method is invoked on the /movies endpoint, the `MoviesStoreListMovies` Lambda
    function will be triggered to return a list of IMDb movies stored on the DynamoDB
    table. Add the code shown in the following listing to apigateway.tf.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 Amazon API Gateway 部署一个 RESTful API，并定义 HTTP 端点，以便在传入的 HTTP/HTTPS
    请求上触发 Lambda 函数。列表 12.2 中的 Terraform 代码在 /movies 资源上公开了一个 GET 方法。当在 /movies 端点上调用
    GET 方法时，`MoviesStoreListMovies` Lambda 函数将被触发，以返回存储在 DynamoDB 表上的 IMDb 电影列表。将以下列表中的代码添加到
    apigateway.tf 中。
- en: Listing 12.2 GET /movies endpoint definition
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.2 GET /movies 端点定义
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note In addition to providing a unified entry point for Lambda functions, API
    Gateway comes with powerful features such as caching, cross-origin resource sharing
    (CORS) configuration, security, and authentication.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：除了为 Lambda 函数提供统一的入口点外，API 网关还提供了强大的功能，如缓存、跨源资源共享（CORS）配置、安全和身份验证。
- en: Define the rest of the API endpoints, or download the complete apigateway.tf
    file from chapter12/terraform/apigateway.tf.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 定义剩余的 API 端点，或者从第 12 章/terraform/apigateway.tf 下载完整的 apigateway.tf 文件。
- en: The Movies Marketplace content—including HTML, CSS, JavaScript, images, and
    other files—will be hosted in an Amazon S3 bucket. The end users will then access
    the application by using the public website URL exposed by Amazon S3\. Hence,
    we don’t need to run any web server such as NGINX or Apache to make the web application
    available. The Terraform code in the following listing (s3.tf) creates an S3 bucket
    and enables website hosting.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 电影市场的所有内容——包括 HTML、CSS、JavaScript、图片和其他文件——将托管在 Amazon S3 存储桶中。最终用户将通过使用 Amazon
    S3 提供的公共网站 URL 访问应用程序。因此，我们不需要运行任何像 NGINX 或 Apache 这样的 Web 服务器来使 Web 应用程序可用。以下列表（s3.tf）中的
    Terraform 代码创建了一个 S3 存储桶并启用了网站托管。
- en: Listing 12.3 S3 website hosting configuration
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.3 S3 网站托管配置
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The bucket access-control list (ACL) must be set to `public-read`. The `website`
    block is where we define the index document for the application. Also, we grant
    access to the static content by attaching a bucket policy. The bucket policy grants
    `s3:GetObject` to all principals for any object in the bucket.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 存储桶的访问控制列表（ACL）必须设置为 `public-read`。`website` 块是我们定义应用程序索引文档的地方。此外，我们通过附加存储桶策略来授予对静态内容的访问权限。存储桶策略授予所有主体对存储桶中任何对象的
    `s3:GetObject` 权限。
- en: Note Unless you want to access the marketplace via the S3 bucket URL, you can
    use CloudFront on top of S3 to serve the application content by using a custom
    domain name over SSL.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：除非您想通过 S3 存储桶 URL 访问市场，否则您可以使用 CloudFront 在 S3 上通过使用自定义域名和 SSL 提供应用程序内容。
- en: Install the local modules with the `terraform init` command and run `terraform
    apply` to provision the AWS resources. Creating the whole infrastructure should
    take a few seconds. After the creation steps are complete, the API and marketplace
    URLs will be displayed in the `Outputs` section, as you can see in figure 12.2.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `terraform init` 命令安装本地模块，并运行 `terraform apply` 以配置 AWS 资源。创建整个基础设施可能需要几秒钟。创建步骤完成后，API
    和市场 URL 将在 `输出` 部分显示，如图 12.2 所示。
- en: '![](Images/CH12_F02_Labouardy.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH12_F02_Labouardy.png)'
- en: Figure 12.2 API Gateway and S3 website URLs
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.2 API 网关和 S3 网站URL
- en: The `api` variable holds the RESTful API URL powered by API Gateway, and the
    `marketplace` variable is the S3 website URL for the marketplace application.
    If you head to AWS Lambda console ([http://mng.bz/10Qg](http://mng.bz/10Qg)),
    the Lambda functions in figure 12.3 should be deployed.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`api` 变量包含由 API 网关提供的 RESTful API URL，而 `marketplace` 变量是市场应用程序的 S3 网站URL。如果您访问
    AWS Lambda 控制台（[http://mng.bz/10Qg](http://mng.bz/10Qg)），图 12.3 中的 Lambda 函数应该已经部署。'
- en: '![](Images/CH12_F03_Labouardy.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH12_F03_Labouardy.png)'
- en: Figure 12.3 Watchlist application’s Lambda functions
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.3 Watchlist 应用程序的 Lambda 函数
- en: Point your favorite browser to the API Gateway URL, and navigate to the /movies
    endpoint. The HTTP request should trigger the `MoviesStoreListMovies` Lambda function
    responsible for listing movies. The error message in figure 12.4 will be displayed.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 将您喜欢的浏览器指向 API 网关 URL，并导航到 /movies 端点。HTTP 请求应触发负责列出电影的 `MoviesStoreListMovies`
    Lambda 函数。图 12.4 中的错误消息将被显示。
- en: '![](Images/CH12_F04_Labouardy.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH12_F04_Labouardy.png)'
- en: Figure 12.4 `MoviesStoreListMovies` HTTP response
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.4 `MoviesStoreListMovies` HTTP 响应
- en: Right now, no code is deployed to Lambda functions, so there would be nothing
    to see. To list movies, we need to deploy the function’s code to the Lambda resource.
    In the upcoming section, we will create a CI/CD pipeline in Jenkins to automate
    the deployment of Lambda functions. Figure 12.5 illustrates the target CI/CD workflow.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Lambda 函数中没有部署任何代码，所以看不到任何内容。要列出电影，我们需要将函数的代码部署到 Lambda 资源。在下一节中，我们将在 Jenkins
    中创建 CI/CD 管道来自动化 Lambda 函数的部署。图 12.5 展示了目标 CI/CD 工作流程。
- en: '![](Images/CH12_F05_Labouardy.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH12_F05_Labouardy.png)'
- en: Figure 12.5 CI/CD workflow for a serverless application
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](Images/CH12_F05_Labouardy.png)'
- en: A pipeline will be triggered whenever you make a change to your application’s
    source code. The Jenkins master will schedule the build on one of the available
    Jenkins workers. The worker will execute the stages described in the Jenkinsfile
    located in the root directory of the application Git repository. The stages `Checkout`
    and `Tests` are given in chapter 8\. The `Build` stage will compile the source
    code, install needed dependencies, and generate a deployment package (zip archive).
    Next, the `Push` stage will store the zip file in a remote S3 bucket and finally,
    the `Deploy` stage will be executed to update the Lambda function’s code with
    the newest changes.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您对应用程序的源代码进行更改时，都会触发一个流水线。Jenkins 主节点将在可用的 Jenkins 工作节点之一上安排构建。工作节点将执行位于应用程序
    Git 仓库根目录中的 Jenkinsfile 中描述的阶段。第 8 章中提供了 `Checkout` 和 `Tests` 阶段。`Build` 阶段将编译源代码，安装所需的依赖项，并生成部署包（zip
    归档）。接下来，`Push` 阶段将 zip 文件存储在远程 S3 桶中，最后执行 `Deploy` 阶段以更新 Lambda 函数的代码，并应用最新的更改。
- en: 12.2 Creating deployment packages
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.2 创建部署包
- en: 'Before integrating the serverless application in Jenkins, we need to store
    the Lambda functions’ source code in a centralized remote repository for versioning.
    When it comes to serverless applications, two strategies are most used to organize
    functions into repositories:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在将无服务器应用程序集成到 Jenkins 之前，我们需要将 Lambda 函数的源代码存储在集中式远程仓库中以便进行版本控制。对于无服务器应用程序，最常用的两种策略是将函数组织到仓库中：
- en: '*Mono-repo*—Everything is put into the same repository; cohesive functions
    that work together to serve a business feature are grouped together under the
    same repository.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*单仓库*—所有内容都放入同一个仓库；协同工作以提供业务功能的函数被组合在同一个仓库下。'
- en: '*One repository per service*—Each Lambda function gets its own Git repository,
    with its own CI/CD pipeline.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*每个服务一个仓库*—每个 Lambda 函数都有自己的 Git 仓库，并拥有自己的 CI/CD 流水线。'
- en: This section doesn’t go into the details around which is better, but instead
    shows how to build a CI/CD pipeline with the two approaches.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 本节不深入探讨哪种方法更好，而是展示如何使用两种方法构建 CI/CD 流水线。
- en: 12.2.1 Mono-repo strategy
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.1 单仓库策略
- en: The MoviesLoader service, which consists of a single Lambda function written
    in Python, is responsible for loading a list of movies into a message queue. Create
    a GitHub repository, shown in figure 12.6, for the movies-loader Lambda function,
    and then push the source code available in the book’s repository (chapter12/functions)
    to the develop branch.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由单个用 Python 编写的 Lambda 函数组成的 MoviesLoader 服务，负责将电影列表加载到消息队列中。为 movies-loader
    Lambda 函数创建一个 GitHub 仓库，如图 12.6 所示，然后将书中仓库（chapter12/functions）中可用的源代码推送到 develop
    分支。
- en: '![](Images/CH12_F06_Labouardy.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH12_F06_Labouardy.png)'
- en: Figure 12.6 MoviesLoader Lambda function GitHub repository
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.6 MoviesLoader Lambda 函数 GitHub 仓库
- en: The Jenkinsfile (chapter12/functions/movies-loader/Jenkinsfile) is stored in
    the root repository. It’s similar to the one provided in chapter 8’s listing 8.3\.
    Upon a push event, it will check out the function source code and run unit tests
    inside a Docker container. Having proper unit tests in place safeguards against
    subsequent Lambda code updates. This definition file, shown in the following listing,
    must be committed to the Lambda function’s code repository.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkinsfile（位于 chapter12/functions/movies-loader/Jenkinsfile）存储在根仓库中。它与第 8 章的列表
    8.3 提供的类似。在推送事件发生时，它将检出函数源代码，并在 Docker 容器内运行单元测试。适当的单元测试可以保护 Lambda 代码的后续更新。以下列表中显示的定义文件必须提交到
    Lambda 函数的代码仓库。
- en: Listing 12.4 Running function unit tests inside a Docker container
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.4 在 Docker 容器内运行函数单元测试
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Sends a Slack notification when the build starts, by using the custom notifySlack
    method
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 通过使用自定义的 notifySlack 方法在构建开始时发送 Slack 通知
- en: ❷ When an error occurs, it’s cached here, and the currentBuild.result variable
    is set to FAILED so the right Slack notification will be sent afterward.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 当发生错误时，它将被缓存在此处，并将 currentBuild.result 变量设置为 FAILED，以便之后发送正确的 Slack 通知。
- en: ❸ When the pipeline is completed (success or failure), a Slack notification
    is sent to raise awareness about the pipeline status.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 当流水线完成（成功或失败）时，将发送 Slack 通知，以引起对流水线状态的注意。
- en: In listing 12.5, we create a deployment package, which is a zip file that includes
    both the Python code and any dependencies that the code needs to run. The `Build`
    stage generates a zip file and uses the Git commit ID as a name. Finally, we push
    the zip file to an S3 bucket for versioning and delete the file to save space.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表12.5中，我们创建了一个部署包，这是一个包含 Python 代码及其运行所需的任何依赖项的 zip 文件。`构建`阶段生成一个 zip 文件，并使用
    Git 提交 ID 作为名称。最后，我们将 zip 文件推送到 S3 桶中以进行版本控制，并删除文件以节省空间。
- en: Listing 12.5 Generating a deployment package
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.5 生成部署包
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ The name of the S3 bucket where the deployment packages (zip files) are stored
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 存储部署包（zip 文件）的 S3 桶的名称
- en: ❷ Clones the Git repository. The instruction was omitted for brevity; see chapter12/functions/movies-loader/Jenkinsfile
    for the command.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 克隆 Git 仓库。为了简洁，省略了说明；请参阅第12章/函数/movies-loader/Jenkinsfile 中的命令。
- en: ❸ Runs unit tests within a Docker container. See chapter12/functions/movies-loader/Jenkinsfile
    for instructions.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在 Docker 容器内运行单元测试。有关说明，请参阅第12章/函数/movies-loader/Jenkinsfile。
- en: ❹ Creates an archive (zip file) with the function entrypoint (index.py) and
    the movies JSON array. The commitId function is used to create a unique ID for
    the archive based on the current Git commit ID.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 创建一个包含函数入口点（index.py）和电影 JSON 数组的存档（zip 文件）。使用 commitId 函数根据当前的 Git 提交 ID
    创建存档的唯一 ID。
- en: ❺ Stores the archive to an S3 bucket
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将存档存储到 S3 桶中
- en: ❻ Deletes the archive at the end of the pipeline to save hard disk space
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 在管道结束时删除存档以节省硬盘空间
- en: Note We use the Git commit ID as a name for the deployment package to give a
    meaningful and significant name for each release and be able to roll back to a
    specific commit if things go wrong.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们使用 Git 提交 ID 作为部署包的名称，为每个发布提供一个有意义的名称，并在出现问题时能够回滚到特定的提交。
- en: On Jenkins, create a new multibranch pipeline job for the `MoviesLoader` lambda
    function (refer to chapter 7 for a step-by-step guide). Jenkins will discover
    the develop branch, and a new build will start; see figure 12.7.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Jenkins 上，为 `MoviesLoader` Lambda 函数创建一个新的多分支管道作业（请参阅第7章以获取逐步指南）。Jenkins 将发现
    develop 分支，并开始一个新的构建；请参阅图12.7。
- en: '![](Images/CH12_F07_Labouardy.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH12_F07_Labouardy.png)'
- en: Figure 12.7 MoviesLoader Lambda function pipeline
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7 MoviesLoader Lambda 函数管道
- en: You can drill down to see the steps on the UI that match our steps in the Jenkinsfile.
    While Jenkins is executing each stage, you can see the activity. You can see the
    tests running as part of the `Unit` `Tests` stage (figure 12.8). If tests are
    successful, a zip file will be generated and stored in an S3 bucket.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以深入查看 UI 上的步骤，这些步骤与 Jenkinsfile 中的步骤相匹配。当 Jenkins 执行每个阶段时，您可以看到活动。您可以看到作为
    `单元` `测试` 阶段一部分运行的测试（图12.8）。如果测试成功，将生成一个 zip 文件并将其存储在 S3 桶中。
- en: '![](Images/CH12_F08_Labouardy.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH12_F08_Labouardy.png)'
- en: Figure 12.8 Pipeline execution logs
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8 管道执行日志
- en: Open the S3 console and click the bucket used by the pipeline for package storage.
    A new deployment package should be available with a key name identical to the
    Git commit ID, as shown in figure 12.9.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 S3 控制台并单击用于包存储的管道使用的桶。应有一个新的部署包可用，其键名与 Git 提交 ID 相同，如图12.9所示。
- en: '![](Images/CH12_F09_Labouardy.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH12_F09_Labouardy.png)'
- en: Figure 12.9 S3 bucket for deployment packages storage
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.9 部署包存储的 S3 桶
- en: Similarly for the movies-parser function, push the function source code to a
    dedicated GitHub repository, shown in figure 12.10.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 movies-parser 函数，同样将函数源代码推送到一个专门的 GitHub 仓库，如图12.10所示。
- en: '![](Images/CH12_F10_Labouardy.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH12_F10_Labouardy.png)'
- en: Figure 12.10 MoviesParser Lambda function GitHub repository
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.10 MoviesParser Lambda 函数 GitHub 仓库
- en: Create a Jenkinsfile (chapter12/functions/movies-parser/Jenkinsfile) with similar
    stages to chapter 8’s listing 8.8 in the top-level directory of the Git repository;
    see the following listing.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Git 仓库的顶级目录中创建一个 Jenkinsfile（chapter12/functions/movies-parser/Jenkinsfile），其阶段与第8章的列表8.8类似；请参阅以下列表。
- en: Listing 12.6 Running function pre-integration tests in parallel
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.6 并行运行函数预集成测试
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The function is written in Go, so we need to build a binary with the Docker
    multistage build feature, as explained in listing 9.2\. Then, we copy the built
    binary from the Docker container and generate a zip package. Finally, we push
    the deployment package to the S3 bucket, as shown in the following listing.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于该函数是用 Go 编写的，因此我们需要使用 Docker 多阶段构建功能构建一个二进制文件，如第9.2节所述。然后，从 Docker 容器中复制构建的二进制文件并生成一个
    zip 包。最后，将部署包推送到 S3 桶中，如下所示。
- en: Listing 12.7 Building a Go-based Lambda deployment package
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.7 构建 Go 基础 Lambda 部署包
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Refer to listing 12.6 for the instructions.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 请参考列表 12.6 中的说明。
- en: Push the changes to the movies-parser Git repository, and create a new multibranch
    pipeline job for movies-parser. The pipeline stages should be executed. Upon completion,
    the pipeline should look like figure 12.11 in the Blue Ocean view.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 将更改推送到 movies-parser Git 仓库，并为 movies-parser 创建一个新的多分支管道作业。管道阶段应该被执行。完成后，管道在
    Blue Ocean 视图中应类似于图 12.11。
- en: '![](Images/CH12_F11_Labouardy.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH12_F11_Labouardy.png)'
- en: Figure 12.11 MoviesParser Lambda function workflow
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.11 MoviesParser Lambda 函数工作流程
- en: Figure 12.12 shows the console output of the `Push` stage. The function deployment
    package will be stored under the MoviesParser subfolder.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.12 显示了 `Push` 阶段的控制台输出。函数部署包将被存储在 MoviesParser 子文件夹下。
- en: '![](Images/CH12_F12_Labouardy.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH12_F12_Labouardy.png)'
- en: Figure 12.12 Publishing deployment package to S3
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.12 将部署包发布到 S3
- en: The obvious counterpart to the multi-repo pattern is the mono-repo approach.
    In this pattern, a single repository holds a collection of Lambda functions grouped
    by business capabilities.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 多仓库模式的明显对应模式是单仓库方法。在这种模式中，单个仓库包含按业务能力分组的 Lambda 函数集合。
- en: 12.2.2 Multi-repo strategy
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.2 多仓库策略
- en: The Movies Store API is split into multiple Lambda functions (`MoviesStoreListMovies`,
    `MoviesStoreSearchMovie`, `MoviesStoreViewFavorites`, `MoviesStoreAddToFavorites`).
    The easiest way to share code among these functions is by having them all together
    in a single repository. Create a new GitHub repository (chapter12/functions/movies-store),
    shown in figure 12.13.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Movies Store API 被拆分为多个 Lambda 函数（`MoviesStoreListMovies`、`MoviesStoreSearchMovie`、`MoviesStoreViewFavorites`、`MoviesStoreAddToFavorites`）。在这些函数之间共享代码的最简单方法是让它们都在单个仓库中。创建一个新的
    GitHub 仓库（chapter12/functions/movies-store），如图 12.13 所示。
- en: The src/ folder at the root is made up of a collection of services. Each service
    deals with a relatively small and self-contained function. For instance, the movies/findAll
    folder is responsible for serving a list of movies from the DynamoDB table. The
    package.json file is located at the root of the repo. However, it is fairly common
    to have a separate package.json inside each service directory.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 根目录下的 src/ 文件夹由一系列服务组成。每个服务处理相对较小且自包含的函数。例如，movies/findAll 文件夹负责从 DynamoDB 表中提供电影列表。package.json
    文件位于仓库的根目录。然而，在服务目录中有一个单独的 package.json 是相当常见的。
- en: '![](Images/CH12_F13_Labouardy.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH12_F13_Labouardy.png)'
- en: Figure 12.13 Multiple Lambda functions stored in single repository
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.13 单个仓库中存储的多个 Lambda 函数
- en: On the movies-store repository, create a Jenkinsfile (chapter12/functions/movies-store/Jenkinsfile)
    by using your favorite text editor or IDE with the content in the following listing.
    Refer to listing 8.14 for more details about the implemented stages.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在 movies-store 仓库中，使用您喜欢的文本编辑器或 IDE 创建一个 Jenkinsfile（chapter12/functions/movies-store/Jenkinsfile），内容如下一列表所示。有关实现阶段的更多详细信息，请参考列表
    8.14。
- en: Listing 12.8 Running quality tests and generating code coverage reports
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.8 运行质量测试和生成代码覆盖率报告
- en: '[PRE7]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Next, we run a Docker container from a Node.js base image to install external
    dependencies by running the `npm` `install` command. Then, we copy the node_modules
    folder from the running container to the current workspace and create a zip file,
    as shown in the next listing. The deployment package size will impact the functions’
    cold start. To keep the deployment package size smaller, we install only the runtime
    dependencies by passing `--prod=only` to the `npm` `install` command.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们从 Node.js 基础镜像运行 Docker 容器，通过执行 `npm install` 命令来安装外部依赖。然后，我们将运行容器中的 node_modules
    文件夹复制到当前工作区，并创建一个 zip 文件，如下一列表所示。部署包的大小将影响函数的冷启动。为了保持部署包的大小较小，我们通过将 `--prod=only`
    传递给 `npm install` 命令，只安装运行时依赖。
- en: Listing 12.9 Building a Node.js-based Lambda deployment package
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.9 构建 Node.js 基础 Lambda 部署包
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note One drawback of dynamic provisioning is a phenomenon called *cold start*.
    Essentially, functions that haven’t been used for a while take longer to start
    up and to handle the first request.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：动态预配的一个缺点是称为 *冷启动* 的现象。本质上，一段时间内未使用的函数启动和响应第一个请求需要更长的时间。
- en: Then, in the following listing, we push the generated zip file to an S3 bucket,
    use a loop to go through each function name, and save the zip in an S3 bucket
    under the function folder. You can use the Serverless framework ([www.serverless.com](http://www.serverless.com))
    to create a zip file per function and exclude unused dependencies and files.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在以下列表中，我们将生成的 zip 文件推送到 S3 桶，使用循环遍历每个函数名称，并将 zip 文件保存在 S3 桶下的函数文件夹中。您可以使用
    Serverless 框架（[www.serverless.com](http://www.serverless.com)）为每个函数创建一个 zip 文件，并排除未使用的依赖项和文件。
- en: Listing 12.10 Publishing Node.js deployment packages to S3
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.10 将 Node.js 部署包发布到 S3
- en: '[PRE9]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Head back to the Jenkins dashboard, create a new multibranch pipeline job for
    the movies-store project, and commit the changes to the develop branch. In a few
    seconds, a new build should be triggered on the movies-store job for the develop
    branch. On the resultant page, you will see the Stage view for the develop branch
    pipeline, shown in figure 12.14.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 Jenkins 仪表板，为 movies-store 项目创建一个新的多分支管道作业，并将更改提交到 develop 分支。几秒钟后，应该会在 develop
    分支的 movies-store 作业上触发一个新的构建。在结果页面上，您将看到 develop 分支管道的阶段视图，如图 12.14 所示。
- en: '![](Images/CH12_F14_Labouardy.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH12_F14_Labouardy.png)'
- en: Figure 12.14 MoviesStore Lambda functions CI workflow
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.14 MoviesStore Lambda 函数 CI 工作流程
- en: For common situations, the build and push stages can take a good amount of the
    CI/CD execution time. Therefore, we can use the `parallel` key, as shown in the
    following listing, to run the push stage in parallel, to keep the pipeline turnaround
    time short.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对于常见情况，构建和推送阶段可能会占用 CI/CD 执行时间的大部分。因此，我们可以使用以下列表中的 `parallel` 键，以并行运行推送阶段，以保持管道周转时间短。
- en: Listing 12.11 Parallel directive with a map structure
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.11 带有映射结构的并行指令
- en: '[PRE10]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Sets the archive’s name to the Git commit ID
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将存档的名称设置为 Git 提交 ID
- en: ❷ Parallel directive is expecting a map structure, so we’re building one. We
    iterate over the functions list and create the corresponding command to store
    the archive file to the appropriate S3 folder.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 并行指令期望一个映射结构，因此我们正在构建一个。我们遍历函数列表，并创建相应的命令将存档文件存储到适当的 S3 文件夹中。
- en: ❸ Runs the stages in parallel
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 并行运行阶段
- en: The `parallel` directive takes a map of the string and closure. The string is
    the display name of the parallel execution (name of the function), and the closure
    is the actual `aws` `s3` `cp` instruction to copy the deployment package to the
    corresponding function folder in S3\. As a result, storing the deployment packages
    for each function will be run in parallel, as shown in figure 12.15.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`parallel` 指令接受一个字符串和闭包的映射。字符串是并行执行的显示名称（函数名称），闭包是实际的 `aws` `s3` `cp` 指令，用于将部署包复制到
    S3 中相应的函数文件夹。因此，每个函数的部署包存储将并行运行，如图 12.15 所示。'
- en: '![](Images/CH12_F15_Labouardy.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH12_F15_Labouardy.png)'
- en: Figure 12.15 MoviesStore CI workflow
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.15 MoviesStore CI 工作流程
- en: Once the pipeline execution is completed, in the S3 bucket, a deployment package
    should be stored for each Lambda function, as shown in figure 12.16.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦管道执行完成，在 S3 桶中，应该为每个 Lambda 函数存储一个部署包，如图 12.16 所示。
- en: '![](Images/CH12_F16_Labouardy.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH12_F16_Labouardy.png)'
- en: Figure 12.16 Lambda functions deployment packages
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.16 Lambda 函数部署包
- en: By now, the deployment packages are stored in an S3 bucket, so we can go ahead
    and update the Lambda function source code with the built zip files.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，部署包已存储在 S3 桶中，因此我们可以继续更新 Lambda 函数的源代码，使用构建的 zip 文件。
- en: 12.3 Updating Lambda function code
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.3 更新 Lambda 函数代码
- en: For `MoviesLoader` and `MoviesParser` Lambda functions, add the following `Deploy`
    stage to their Jenkinsfiles (chapter12/functions/movies-loader/Jenkinsfile and
    chapter12/functions/movies-parser/Jenkinsfile). The stage uses the AWS Lambda
    CLI to issue an `update-function-code` command to update the function code with
    the zip file stored previously in the S3 bucket; see the following listing.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `MoviesLoader` 和 `MoviesParser` Lambda 函数，将以下 `Deploy` 阶段添加到它们的 Jenkinsfile
    中（第 12 章/函数/movies-loader/Jenkinsfile 和第 12 章/函数/movies-parser/Jenkinsfile）。该阶段使用
    AWS Lambda CLI 发出 `update-function-code` 命令来更新函数代码，该代码存储在之前 S3 桶中，如下列表所示。
- en: Listing 12.12 Updating the Lambda function’s code with AWS CLI
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.12 使用 AWS CLI 更新 Lambda 函数的代码
- en: '[PRE11]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The command takes as an argument the name of the S3 bucket where the zip file
    is stored as well as the Amazon S3 key of the deployment package.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将作为参数接受存储 zip 文件的 S3 桶的名称以及部署包的 Amazon S3 密钥。
- en: Once you push the changes to the Git remote repository, Jenkins will update
    the Lambda function’s code with the `update-function-code` command. The output
    in figure 12.17 confirms that.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将更改推送到Git远程仓库，Jenkins将使用`update-function-code`命令更新Lambda函数的代码。图12.17中的输出确认了这一点。
- en: '![](Images/CH12_F17_Labouardy.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH12_F17_Labouardy.png)'
- en: Figure 12.17 `UpdateFunction-Code` operation logs
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.17 `UpdateFunction-Code`操作日志
- en: The CI/CD pipelines for the `MoviesLoader` and `MoviesParser` functions should
    contain the stages shown in figure 12.18.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`MoviesLoader`和`MoviesParser`函数的CI/CD流水线应包含图12.18中显示的阶段。'
- en: '![](Images/CH12_F18_Labouardy.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH12_F18_Labouardy.png)'
- en: Figure 12.18 Python- and Go-based Lambda function CI/CD pipelines
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.18 基于 Python 和 Go 的 Lambda 函数 CI/CD 流水线
- en: Note The Serverless framework ([https://serverless.com/](https://serverless.com/))
    or AWS Serverless Application Model (SAM) can also be used to write and deploy
    Lambda functions within Jenkins pipelines.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Serverless框架([https://serverless.com/](https://serverless.com/))或AWS Serverless应用程序模型(SAM)也可以用于在Jenkins流水线中编写和部署Lambda函数。
- en: Similarly, add the same stage to the `MoviesStore` Lambda functions—except this
    time, we will wrap the `update-function-code` command with a `for` loop to update
    each function versioning within the same GitHub repository; see the following
    listing.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，将相同的阶段添加到`MoviesStore` Lambda函数中——这次，我们将使用`for`循环将`update-function-code`命令包装在同一个GitHub仓库内的每个函数版本中；请参阅以下列表。
- en: Listing 12.13 Updating multiple Lambda functions
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.13 更新多个Lambda函数
- en: '[PRE12]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When the new stage is committed, the pipeline will be triggered upon a push
    event, and the CI/CD stages in figure 12.19 will be executed.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当新阶段被提交时，在推送事件触发后，流水线将被触发，图12.19中的CI/CD阶段将被执行。
- en: '![](Images/CH12_F19_Labouardy.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH12_F19_Labouardy.png)'
- en: Figure 12.19 MoviesStore CI/CD pipeline
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.19 MoviesStore CI/CD流水线
- en: 'Before we automate the deployment of the marketplace, we need to load some
    data into the DynamoDB table. Trigger the `MoviesLoader` function from AWS Management
    Console, or by issuing the following command from your terminal session:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们自动化部署市场之前，我们需要将一些数据加载到DynamoDB表中。从AWS管理控制台触发`MoviesLoader`函数，或者从您的终端会话中执行以下命令：
- en: '[PRE13]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note Make sure to assign the `AWSLambda_FullAccess` policy to the IAM user configured
    with your AWS CLI.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：确保将`AWSLambda_FullAccess`策略分配给配置了您的AWS CLI的IAM用户。
- en: The preceding command will invoke the `MoviesLoader` function and save the function’s
    output in the response.json file. The function will load movies to SQS and trigger
    the `MoviesParser` Lambda function, which will crawl the movie’s IMDb page and
    store its information in the Movies DynamoDB table, shown in figure 12.20.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将调用`MoviesLoader`函数并将函数的输出保存到response.json文件中。该函数将电影加载到SQS并触发`MoviesParser`
    Lambda函数，该函数将爬取电影的IMDb页面并将信息存储在图12.20所示的Movies DynamoDB表中。
- en: Figure 12.20.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.20。
- en: '![](Images/CH12_F20_Labouardy.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH12_F20_Labouardy.png)'
- en: Figure 12.20  Movies DynamoDB table
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.20 Movies DynamoDB表
- en: Each message in SQS will invoke the `MoviesParser` function; once the queue
    is empty, the DynamoDB table should contain the top 100 IMDb movies.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: SQS中的每条消息都会调用`MoviesParser`函数；一旦队列变空，DynamoDB表应包含前100部IMDb电影。
- en: 12.4 Hosting a static website on S3
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.4 在S3上托管静态网站
- en: The Movie Marketplace is a single-page application (SPA), written in TypeScript,
    using the Angular framework. The application serves static content (HTML, JavaScript,
    and CSS files), which can be a good fit for S3 website-hosting features.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 电影市场是一个单页应用程序(SPA)，使用TypeScript编写，采用Angular框架。该应用程序提供静态内容（HTML、JavaScript和CSS文件），这对于S3网站托管功能来说可能是一个不错的选择。
- en: Let’s automate the deployment of the marketplace to an S3 bucket, as shown in
    the next listing. First, create a GitHub project to version the marketplace source
    code. Then, write a Jenkinsfile to run quality, unit tests, and static code analysis
    with SonarQube. Refer to chapter 8 for more details.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们自动化将市场部署到S3存储桶，如下所示。首先，创建一个GitHub项目以版本控制市场源代码。然后，编写一个Jenkinsfile以运行质量、单元测试和静态代码分析，使用SonarQube。有关更多详细信息，请参阅第8章。
- en: Listing 12.14 Integrating an Angular application with the Jenkinsfile
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.14 将 Angular 应用程序与 Jenkinsfile 集成
- en: '[PRE14]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ Builds a Docker image based on Dockerfile.test to run automated tests
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 基于Dockerfile.test构建Docker镜像以运行自动化测试
- en: ❷ Runs the code linting process
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 运行代码检查过程
- en: ❸ Runs unit tests and generates a coverage report
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 运行单元测试并生成覆盖率报告
- en: ❹ Consumes the coverage report with the Jenkins Publish HTML plugin
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用 Jenkins Publish HTML 插件消费覆盖率报告
- en: ❺ Runs code-quality inspection with SonarQube
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 使用 SonarQube 运行代码质量检查
- en: ❻ Interrupts SonarQube inspection if it takes more than 5 minutes
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 如果 SonarQube 检查超过 5 分钟，则中断检查
- en: Add a `Build` stage to create a Docker container to install the npm dependencies
    and copy the dependencies folder as well as the generated static web application
    files to the current workspace, as shown in the following listing. Note the use
    of the `--build-arg` argument to inject the API Gateway URL at the build time.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个 `Build` 阶段来创建一个 Docker 容器，安装 npm 依赖项，并将依赖项文件夹以及生成的静态Web应用程序文件复制到当前工作区，如下所示。注意使用
    `--build-arg` 参数在构建时注入 API 网关 URL。
- en: Listing 12.15 Building the Angular application
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.15 构建 Angular 应用程序
- en: '[PRE15]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Then, in the following listing, use the AWS CLI to push the generated static
    web application to the S3 bucket where website hosting is enabled.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在以下列表中，使用 AWS CLI 将生成的静态Web应用程序推送到启用了网站托管功能的S3存储桶。
- en: Listing 12.16 Storing the Angular static application to S3
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.16 将 Angular 静态应用程序存储到 S3
- en: '[PRE16]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ Recursively copies local files to S3
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 递归地将本地文件复制到 S3
- en: Push the changes to the develop branch. A new pipeline should be triggered,
    and the stages in figure 12.21 will be executed successfully.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 将更改推送到 develop 分支。应该触发一个新的管道，并且图 12.21 中的阶段将成功执行。
- en: '![](Images/CH12_F21_Labouardy.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![Labouardy](Images/CH12_F21_Labouardy.png)'
- en: Figure 12.21 Marketplace CI/CD workflow
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.21 市场CI/CD工作流程
- en: You can verify that the files have been successfully stored from the Amazon
    S3 bucket dashboard, or by running the `aws` `s3` `ls` command in your terminal
    session. Figure 12.22 shows the content of the marketplace S3 bucket.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过 Amazon S3 存储桶仪表板验证文件是否已成功存储，或者通过在终端会话中运行 `aws s3 ls` 命令。图 12.22 显示了市场
    S3 存储桶的内容。
- en: '![](Images/CH12_F22_Labouardy.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![Labouardy](Images/CH12_F22_Labouardy.png)'
- en: Figure 12.22 Marketplace S3 bucket content
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.22 市场S3存储桶内容
- en: If you head to the S3 website URL (http://BUCKET.s3-website-REGION.amazonaws
    .com/), it should display the marketplace UI, shown in figure 12.23.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你访问 S3 网站URL（http://BUCKET.s3-website-REGION.amazonaws.com/），它应该显示市场UI，如图
    12.23 所示。
- en: That’s great! However, when you’re building your serverless application, you
    must separate your deployment environments to test new changes without impacting
    your production. Therefore, having multiple environments makes sense while building
    serverless applications.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 那太好了！然而，当你构建无服务器应用程序时，你必须将部署环境分开，以测试新更改而不影响生产。因此，在构建无服务器应用程序时拥有多个环境是有意义的。
- en: '![](Images/CH12_F23_Labouardy.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![Labouardy](Images/CH12_F23_Labouardy.png)'
- en: Figure 12.23 Marketplace dashboard running in the sandbox environment
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.23 在沙盒环境中运行的 Marketplace 仪表板
- en: 12.5 Maintaining multiple Lambda environments
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.5 维护多个 Lambda 环境
- en: AWS Lambda allows you to publish a version, which represents the state of the
    function’s code and configuration in time. By default, each Lambda function has
    the `$LATEST` version pointing to the latest changes deployed to the function.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: AWS Lambda 允许你发布一个版本，它代表了函数代码和配置在时间上的状态。默认情况下，每个 Lambda 函数都有一个 `$LATEST` 版本，指向部署到函数的最新更改。
- en: To publish a new version from the `$LATEST` version, update the Jenkinsfile
    (chapter12/functions/movies-loader/Jenkinsfile) to add a new stage to publish
    a new Lambda function’s version, as shown in the following listing.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `$LATEST` 版本发布新版本时，需要更新 Jenkinsfile（chapter12/functions/movies-loader/Jenkinsfile），添加一个新阶段以发布新的
    Lambda 函数版本，如下所示。
- en: Listing 12.17 Publishing a new Lambda version
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.17 发布新的 Lambda 版本
- en: '[PRE17]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When you publish a new version of your Lambda function, you should give it a
    meaningful version name that allows you to track different changes made to your
    function through its development cycle. In listing 12.17, we’re using the Git
    commit ID as a version scheme. However, you can use an advanced version mechanism
    like semantic versioning ([https://semver.org/](https://semver.org/)).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当你发布 Lambda 函数的新版本时，你应该给它一个有意义的版本名称，这样你就可以通过其开发周期跟踪对函数所做的不同更改。在列表 12.17 中，我们使用
    Git 提交ID作为版本方案。然而，你可以使用更高级的版本机制，如语义版本化([https://semver.org/](https://semver.org/))。
- en: When the pipeline is executed, at the `Deploy` stage the preceding commands
    will be executed. Figure 12.24 shows their execution logs.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当管道执行时，在 `Deploy` 阶段将执行前面的命令。图 12.24 展示了它们的执行日志。
- en: '![](Images/CH12_F24_Labouardy.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![Labouardy](Images/CH12_F24_Labouardy.png)'
- en: Figure 12.24 Update and Publish commands executed within the deploy stage
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.24 在部署阶段执行的更新和发布命令
- en: 'Note Versions are immutable: once they’re created, you cannot update their
    code or settings (memory, execution time, VPC config, and so forth).'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 注意版本是不可变的：一旦创建，就无法更新它们的代码或设置（内存、执行时间、VPC 配置等）。
- en: On the MoviesLoader Lambda dashboard, a new version will be published based
    on the develop branch source code, as shown in figure 12.25.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MoviesLoader Lambda 仪表板上，将基于 develop 分支的源代码发布新版本，如图 12.25 所示。
- en: '![](Images/CH12_F25_Labouardy.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH12_F25_Labouardy.png)'
- en: Figure 12.25 MoviesLoader Lambda new published version
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.25 MoviesLoader Lambda 新发布的版本
- en: The publication of Lambda versions for the MoviesStore API will be done in parallel
    to reduce the execution time of the pipeline; see figure 12.26.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 将 MoviesStore API 的 Lambda 版本发布并行进行，以减少管道的执行时间；见图 12.26。
- en: As a result, you can work with different variations of your Lambda function
    in your development workflow.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可以在开发工作流程中与 Lambda 函数的不同变体一起工作。
- en: '![](Images/CH12_F26_Labouardy.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH12_F26_Labouardy.png)'
- en: Figure 12.26 Running the publish command in parallel
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.26 并行运行发布命令
- en: For now, API Gateway triggers the `MoviesStore` Lambda functions based on the
    `$LATEST` version, so every time a new version is published, we need to update
    API Gateway to point to the newest version (figure 12.27)—a tedious and not handy
    task.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，API Gateway 根据 `$LATEST` 版本触发 `MoviesStore` Lambda 函数，因此每次发布新版本时，都需要更新 API
    Gateway 以指向最新版本（图 12.27）——这是一个繁琐且不方便的任务。
- en: '![](Images/CH12_F27_Labouardy.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH12_F27_Labouardy.png)'
- en: Figure 12.27 GET /favorites integration request
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.27 GET /favorites 集成请求
- en: Fortunately, there’s the concept of a *Lambda alias*. The alias, a pointer to
    a specific version, allows you to promote a function from one environment to another
    (such as staging to production). Aliases are mutable, unlike immutable versions.
    Now, instead of directly assigning a Lambda function version in an API Gateway
    integration request, you can assign Lambda alias, where the alias is a variable.
    The variable will be resolved from a value during runtime.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有 *Lambda 别名* 的概念。别名是一个指向特定版本的指针，允许您将函数从一个环境提升到另一个环境（例如从预发布到生产）。与不可变的版本不同，别名是可变的。现在，您不再需要在
    API Gateway 集成请求中直接分配 Lambda 函数版本，而是可以分配 Lambda 别名，其中别名是一个变量。该变量将在运行时解析其值。
- en: 'That being said, create an alias for the sandbox, staging, and production environments
    that points to the latest version published by using the AWS command line:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，使用 AWS 命令行创建指向最新发布的版本的沙盒、预发布和生产环境的别名：
- en: '[PRE18]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Once created, the new aliases should be added to the list of Aliases under the
    Qualifiers drop-down list (figure 12.28).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建，新的别名应添加到“Qualifiers”下拉列表下的“别名”列表中（图 12.28）。
- en: '![](Images/CH12_F28_Labouardy.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH12_F28_Labouardy.png)'
- en: Figure 12.28 Using multiple aliases to reference different environments
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.28 使用多个别名引用不同的环境
- en: We can update the Jenkinsfile to update the alias directly. Update the `Deploy`
    stage with the code in the next listing. It updates the Lambda function code,
    publishes a new version, and then points the alias corresponding to the current
    Git branch (master branch = production alias, preprod branch = staging alias,
    develop branch = sandbox alias) to the newly deployed version.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以更新 Jenkinsfile 以直接更新别名。更新 `Deploy` 阶段，使用下一列表中的代码。它更新 Lambda 函数代码，发布新版本，并将对应于当前
    Git 分支的别名（master 分支 = 生产别名，preprod 分支 = 预发布别名，develop 分支 = 沙盒别名）指向新部署的版本。
- en: Listing 12.18 Updating the Lambda alias to point to the newest version
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.18 更新 Lambda 别名为指向最新版本
- en: '[PRE19]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `publish-version` operation returns JSON output with the deployed version
    number as an attribute. The `jq` command is used to parse the `Version` attribute
    and store its value in a `version` variable. Then, based on the current Git branch,
    the corresponding alias will point to the published version number.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`publish-version` 操作返回包含已部署版本号作为属性的 JSON 输出。使用 `jq` 命令解析 `Version` 属性并将其值存储在
    `version` 变量中。然后，根据当前的 Git 分支，相应的别名将指向发布的版本号。'
- en: Push the changes to the develop branch. The function code will be updated, a
    new version will be created, and the sandbox alias will point to the newest published
    version, as you can see in figure 12.29.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 将更改推送到 develop 分支。函数代码将被更新，将创建一个新版本，并且沙盒别名将指向最新发布的版本，如图 12.29 所示。
- en: '![](Images/CH12_F29_Labouardy.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH12_F29_Labouardy.png)'
- en: Figure 12.29 Updating the Lambda alias to the deployed version
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.29 更新 Lambda 别名为已部署版本
- en: On the `MoviesStoreListMovies` Lambda, for instance, the sandbox alias should
    point to the version with the develop branch source code, as shown in figure 12.30.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在`MoviesStoreListMovies` Lambda中，沙箱别名应指向包含develop分支源代码的版本，如图12.30所示。
- en: '![](Images/CH12_F30_Labouardy.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH12_F30_Labouardy.png)'
- en: Figure 12.30 Sandbox alias pointing to the new Lambda version
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.30 沙箱别名指向新的Lambda版本
- en: Now that you have seen how to create aliases and switch their values within
    a Jenkins pipeline, let’s configure the API Gateway to use these aliases with
    stage variables.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了如何在Jenkins管道中创建别名并切换其值，让我们配置API Gateway以使用这些别名和阶段变量。
- en: '*Stage variables* are environment variables that can be used to change the
    behavior at runtime of the API Gateway methods for each deployment stage.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '*阶段变量*是环境变量，可以在API Gateway的每个部署阶段的运行时更改方法的行为。'
- en: On the API Gateway Console, navigate to the Movies API, click the GET method
    for the instance, and update the target Lambda function to use a stage variable
    instead of a hardcoded Lambda function version, as shown in figure 12.31.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在API Gateway控制台中，导航到Movies API，单击实例的GET方法，并将目标Lambda函数更新为使用阶段变量而不是硬编码的Lambda函数版本，如图12.31所示。
- en: '![](Images/CH12_F31_Labouardy.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH12_F31_Labouardy.png)'
- en: Figure 12.31 Using a stage variable while configuring the API integration request
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.31 配置API集成请求时使用阶段变量
- en: In the Lambda Function field, the `${stageVariables.environment}` tells API
    Gateway to read the value for this field from a stage variable at runtime.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在Lambda函数字段中，`${stageVariables.environment}`告诉API Gateway在运行时从阶段变量中读取此字段的值。
- en: When you save the configuration, a new prompt will ask you to grant the permissions
    to API Gateway to call your Lambda function aliases. At this point, we need to
    deploy our API to make it publicly available.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当你保存配置时，会出现一个新的提示，要求你授权API Gateway调用你的Lambda函数别名。此时，我们需要部署我们的API以使其公开可用。
- en: From the Actions drop-down, select Deploy API. Choose the New Deployment Stage
    option, enter `sandbox` as a stage name, and deploy it. Or use the Terraform code
    in listing 12.19\. The sandbox stage will set the environment stage variable to
    `sandbox`. As a result, if a user invokes an HTTP request on any endpoint of the
    sandbox deployment, the corresponding Lambda function with the sandbox alias will
    be triggered.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 从操作下拉菜单中选择部署API。选择“新建部署阶段”选项，输入`sandbox`作为阶段名称，并部署它。或者使用列表12.19中的Terraform代码。沙箱阶段将设置环境阶段变量为`sandbox`。因此，如果用户在沙箱部署的任何端点上发起HTTP请求，将触发具有沙箱别名的相应Lambda函数。
- en: Listing 12.19 API Deployment with an alias stage variable
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.19 使用别名阶段变量进行API部署
- en: '[PRE20]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Create additional deployment stages for staging and production environments.
    On completion of the `terraform apply` command, the three deployment stage URLs
    will be displayed, as shown in figure 12.32.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为预发布和生产环境创建额外的部署阶段。在完成`terraform apply`命令后，将显示三个部署阶段URL，如图12.32所示。
- en: '![](Images/CH12_F32_Labouardy.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH12_F32_Labouardy.png)'
- en: Figure 12.32 API Gateway deployment URLs
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.32 API Gateway部署URL
- en: If you open the API at https://id.execute-api.region.amazonaws.com/sandbox/movies,
    you will get the response from Lambda `MoviesStoreListMovies` with the alias `sandbox`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开API在https://id.execute-api.region.amazonaws.com/sandbox/movies，你将获得Lambda
    `MoviesStoreListMovies`的别名`sandbox`的响应。
- en: To deploy the serverless application to the staging environment, create a pull
    request to merge the develop branch to the preprod branch. Jenkins will post the
    build status of the develop job on the PR (figure 12.33). Then, merge develop
    to preprod.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要将无服务器应用程序部署到预发布环境，创建一个合并develop分支到preprod分支的pull request。Jenkins将在PR上发布develop作业的构建状态（图12.33）。然后，将develop合并到preprod。
- en: '![](Images/CH12_F33_Labouardy.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH12_F33_Labouardy.png)'
- en: Figure 12.33 Jenkins post build status on GitHub PR
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.33 Jenkins在GitHub PR上的构建状态
- en: Once the PR is merged, a new build will be triggered on the preprod branch.
    At the end of the CI/CD pipeline, the staging alias will point to the newly deployed
    version, as you can see in figure 12.34.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦PR合并，preprod分支将触发新的构建。在CI/CD管道的末尾，预发布别名将指向新部署的版本，如图12.34所示。
- en: '![](Images/CH12_F34_Labouardy.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH12_F34_Labouardy.png)'
- en: Figure 12.34 Deploying Lambda functions to staging
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.34将Lambda函数部署到预发布环境
- en: Now, to deploy the marketplace on multiple environments, we will inject the
    environment name based on the current branch name; see the following listing.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了在多个环境中部署市场，我们将根据当前分支名称注入环境名称；请参阅以下列表。
- en: Listing 12.20 Injecting the environment name during the build
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.20 在构建过程中注入环境名称
- en: '[PRE21]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Then, in listing 12.21, we update the `aws s3 cp` instruction to push the static
    files to a folder named as the environment name under the S3 bucket. You can also
    create an S3 bucket per environment, but for simplicity, we use a single S3 to
    store different environments of the marketplace.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在列表 12.21 中，我们将 `aws s3 cp` 指令更新为将静态文件推送到 S3 桶下以环境名称命名的文件夹。您也可以为每个环境创建一个
    S3 桶，但为了简单起见，我们使用单个 S3 来存储市场place 的不同环境。
- en: Listing 12.21 Pushing static files to an S3 bucket
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.21 将静态文件推送到 S3 桶
- en: '[PRE22]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Push these changes to a feature branch. Then raise a pull request to merge to
    the develop branch. When the merge occurs, the new pipeline in figure 12.35 will
    be executed.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些更改推送到功能分支。然后发起一个拉取请求以合并到 develop 分支。当合并发生时，图 12.35 中的新管道将被执行。
- en: '![](Images/CH12_F35_Labouardy.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH12_F35_Labouardy.png)'
- en: Figure 12.35  Marketplace new CI/CD pipeline
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.35 市场place 新 CI/CD 管道
- en: Merge the changes to preprod to deploy the application to staging. Then, merge
    from preprod to master branch for production deployment. As a result, the S3 bucket
    should contain three folders. Each folder holds a different runtime environment
    of the marketplace, as you can see in figure 12.36.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 将更改合并到 preprod 以将应用程序部署到阶段。然后，从 preprod 合并到 master 分支以进行生产部署。结果，S3 桶应包含三个文件夹。每个文件夹包含市场place
    的不同运行环境，如图 12.36 所示。
- en: '![](Images/CH12_F36_Labouardy.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH12_F36_Labouardy.png)'
- en: Figure 12.36 S3 bucket with multiple environments
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.36 具有多个环境的 S3 桶
- en: If you point to the S3 bucket website URL and add the /staging endpoint, it
    should serve the staging environment of the marketplace, as shown in figure 12.37.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您指向 S3 桶的网站 URL 并添加 /staging 端点，它应提供市场place 的阶段环境，如图 12.37 所示。
- en: '![](Images/CH12_F37_Labouardy.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH12_F37_Labouardy.png)'
- en: Figure 12.37 Marketplace staging environment
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.37 市场place 阶段环境
- en: Now, to deploy the Lambda functions to production, merge the preprod branch
    to the master branch by raising a pull request, as shown in figure 12.38.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要将 Lambda 函数部署到生产环境，通过发起拉取请求将 preprod 分支合并到 master 分支，如图 12.38 所示。
- en: '![](Images/CH12_F38_Labouardy.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH12_F38_Labouardy.png)'
- en: Figure 12.38 Merging the movies-store Lambda functions’ preprod branch to master
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.38 将 movies-store Lambda 函数的 preprod 分支合并到 master
- en: When the merge occurs, the pipeline will be triggered on the master branch;
    see figure 12.39.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 当合并发生时，管道将在 master 分支上触发；见图 12.39。
- en: '![](Images/CH12_F39_Labouardy.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH12_F39_Labouardy.png)'
- en: Figure 12.39 Deploying Lambda functions to production
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.39 部署 Lambda 函数到生产
- en: The movies-store functions will be updated, a new version will be created, and
    the production alias will point to the newly deployed version.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: movies-store 函数将进行更新，将创建一个新版本，并且生产别名将指向新部署的版本。
- en: You can take this further and ask for developer authorization before actual
    deployment to production by using the Jenkins Input Step plugin; see the following
    listing. When the `Deploy` stage is reached, an input dialog will pop up for deployment
    confirmation.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 Jenkins Input Step 插件在实际上线部署之前请求开发者授权；参见以下列表。当达到 `Deploy` 阶段时，将弹出输入对话框以进行部署确认。
- en: Listing 12.22 Asking for user approval before production deployment
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.22 在生产部署之前请求用户批准
- en: '[PRE23]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The interactive input will ask whether we approve the deployment. If we click
    Yes, the pipeline will be resumed, and the production alias will point to the
    newly deployed version, as shown in figure 12.40.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 交互式输入将询问我们是否批准部署。如果我们点击是，管道将继续，并且生产别名将指向新部署的版本，如图 12.40 所示。
- en: '![](Images/CH12_F40_Labouardy.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH12_F40_Labouardy.png)'
- en: Figure 12.40 Production deployment confirmation within the Jenkins pipeline
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.40 Jenkins 管道中的生产部署确认
- en: So now if we make any change to our serverless application, CI/CD pipelines
    will be triggered, and the newly published Lambda function code will be promoted
    to production. A Slack notification will also be sent with the deployment job
    status, as shown in figure 12.41.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在如果我们对我们的无服务器应用程序进行任何更改，CI/CD 管道将被触发，新发布的 Lambda 函数代码将被升级到生产环境。部署作业状态也会发送
    Slack 通知，如图 12.41 所示。
- en: '![](Images/CH12_F41_Labouardy.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH12_F41_Labouardy.png)'
- en: Figure 12.41 Production deployment Slack notification
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.41 生产部署 Slack 通知
- en: Sending notifications on pipeline triggering and progress helps to communicate
    the work among team members. So far, we have used it to send start, completed,
    and failure notifications. but Slack can also be used to take actions or execute
    commands from the chat window to confirm the production deployment, for instance,
    or trigger the build of a Jenkins job.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在管道触发和进度上发送通知有助于在团队成员之间沟通工作。到目前为止，我们已经用它来发送启动、完成和失败通知。但 Slack 也可以用于从聊天窗口执行操作或命令，例如确认生产部署或触发
    Jenkins 作业的构建。
- en: Another way of raising awareness of job build status and reporting testing results
    is through email notifications.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种提高作业构建状态意识并报告测试结果的方法是通过电子邮件通知。
- en: 12.6 Configuring email notification in Jenkins
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.6 在 Jenkins 中配置电子邮件通知
- en: Email notification within Jenkins can be done with the help of an Email Extension
    plugin ([https://plugins.jenkins.io/email-ext/](https://plugins.jenkins.io/email-ext/)).
    This plugin comes with a list of essentials plugins installed on Jenkins.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Jenkins 中，可以通过 Email Extension 插件（[https://plugins.jenkins.io/email-ext/](https://plugins.jenkins.io/email-ext/))
    来实现电子邮件通知。此插件包含了一系列在 Jenkins 上安装的必备插件。
- en: To enable email notification, you need to configure an SMTP server. Go to Manage
    Jenkins, then Configure System. Scroll down to the Extended E-mail Notification
    section. Enter your SMTP credentials, if you’re using Gmail, and then type `smtp.gmail.com`
    for the SMTP server and enter your Gmail username and password. Select the use
    of SSL and enter the port number as 465.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用电子邮件通知，您需要配置一个 SMTP 服务器。转到“管理 Jenkins”，然后配置系统。滚动到“扩展电子邮件通知”部分。如果您使用的是 Gmail，请输入您的
    SMTP 凭据，然后输入 `smtp.gmail.com` 作为 SMTP 服务器，并输入您的 Gmail 用户名和密码。选择使用 SSL，并输入端口号为
    465。
- en: To be able to send an email, you need to configure a list of recipient addresses.
    Next, click the Apply and Save buttons, as shown in figure 12.42.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 要发送电子邮件，您需要配置一个收件人地址列表。然后，点击如图 12.42 所示的“应用”和“保存”按钮。
- en: '![](Images/CH12_F42_Labouardy.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH12_F42_Labouardy.png)'
- en: Figure 12.42 Extended email notification configuration
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.42 扩展电子邮件通知配置
- en: You can test configurations by entering the recipient email address and clicking
    Test Configuration. If all is good, you will see the message `Email` `sent` `successfully`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过输入收件人电子邮件地址并点击“测试配置”来测试配置。如果一切正常，您将看到消息“电子邮件已成功发送”。
- en: Now that the plugin is configured, type the following listing in your Jenkinsfile
    to define a function responsible for sending an email with customizable attributes
    based on the job build status.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在插件已配置，请在您的 Jenkinsfile 中输入以下列表，以定义一个根据作业构建状态发送具有可定制属性的电子邮件的功能。
- en: Listing 12.23 Sending email to report job build status
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.23 发送电子邮件以报告作业构建状态
- en: '[PRE24]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Finally, you can invoke the function upon the completion of the CI/CD pipeline
    by calling the `sendEmail()` method on the `finally` block. In the following listing,
    an email notification is sent only if a build is running on the master branch
    to avoid spamming developers.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以通过在 `finally` 块上调用 `sendEmail()` 方法来在 CI/CD 管道完成后调用该功能。在下面的列表中，只有当主分支上正在运行构建时才会发送电子邮件通知，以避免垃圾邮件。
- en: Listing 12.24 Sending email when a production deployment is happening
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.24 在生产部署发生时发送电子邮件
- en: '[PRE25]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Push the new Jenkinsfile to GitHub. When a build is occurring on the master
    branch, an email will be sent. Once the pipeline is finished, you should be able
    to see an email like the one in figure 12.43.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 将新的 Jenkinsfile 推送到 GitHub。当主分支上正在执行构建时，将会发送电子邮件。一旦管道完成，您应该能够看到类似于图 12.43 中的电子邮件。
- en: '![](Images/CH12_F43_Labouardy.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH12_F43_Labouardy.png)'
- en: Figure 12.43 Email notification reporting job build status
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.43 报告作业构建状态的电子邮件通知
- en: The email’s subject contains the name of the Jenkins job as well as its build
    status. The email’s body has a link to the job output.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 电子邮件的主题包含 Jenkins 作业的名称及其构建状态。电子邮件正文包含作业输出的链接。
- en: The declarative approach of writing Jenkinsfiles provides a `post` section,
    which can be used to place post-execution scripts. You can invoke the `sendEmail()`
    method by placing it in the `post` build section, as shown in the following listing.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 编写 Jenkinsfiles 的声明式方法提供了一个 `post` 部分，可以用来放置后执行脚本。您可以通过将其放置在 `post` 构建部分来调用
    `sendEmail()` 方法，如下面的列表所示。
- en: Listing 12.25 Post steps in Jenkins declarative pipeline
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.25 Jenkins 声明式管道中的后置步骤
- en: '[PRE26]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You can also attach the job build logs by enabling the `attachLog` attribute
    with the following listing.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过启用以下列表中的 `attachLog` 属性来附加作业构建日志。
- en: Listing 12.26 Attaching log files in a notification mail
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.26 在通知邮件中附加日志文件
- en: '[PRE27]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As a result, email sent by Jenkins will now contain the job status as well the
    full console output as an attachment, as shown in figure 12.44.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Jenkins发送的电子邮件现在将包含作业状态以及完整的控制台输出作为附件，如图12.44所示。
- en: '![](Images/CH12_F44_Labouardy.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH12_F44_Labouardy.png)'
- en: Figure 12.44 Sending job logs as an email notification attachment
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.44 将作业日志作为电子邮件通知附件发送
- en: Summary
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Terraform modules allow you to better organize your infrastructure configuration
    code and make the resources reusable.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Terraform模块允许您更好地组织您的基础设施配置代码，并使资源可重用。
- en: When building a serverless application as a collection of Lambda functions,
    you need to decide whether you’re going to push each function individually to
    its own Git repository, or bundle them all together as a single repo.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当将无服务器应用程序作为一组Lambda函数构建时，您需要决定是单独将每个函数推送到其自己的Git仓库，还是将它们全部捆绑在一起作为一个单一仓库。
- en: AWS Lambda supports aliases, which are named pointers to a particular version.
    This makes it easy to use a single Lambda function for sandbox, staging, and production
    environments.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS Lambda支持别名，它们是对特定版本的命名指针。这使得使用单个Lambda函数用于沙箱、预发布和生产环境变得容易。
- en: The API Gateway stage variable feature enables you to dynamically access different
    Lambda function environments.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API网关阶段变量功能使您能够动态访问不同的Lambda函数环境。
- en: The Email Extension plugin allows you to configure every aspect of email notifications.
    You can customize when an email is sent, who should receive it, and what the email
    says.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子邮件扩展插件允许您配置电子邮件通知的各个方面。您可以自定义何时发送电子邮件，谁应该接收它，以及电子邮件的内容。
