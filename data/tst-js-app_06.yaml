- en: 4 Testing backend applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 测试后端应用程序
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Structuring the test environment for your backend
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为你的后端构建测试环境
- en: Testing your server’s routes and middleware
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试你的服务器路由和中间件
- en: Dealing with databases in your tests
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在测试中处理数据库
- en: Managing dependencies on external services
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理对外部服务的依赖
- en: For many years, JavaScript was known as a client-side language only. It used
    to run only *within* browsers. Once Node.js appeared, circa 2009, people started
    writing both the frontend **and** backend of their applications using JavaScript.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 许多年来，JavaScript一直被当作一种仅用于客户端的语言。它曾经只*在浏览器内*运行。一旦Node.js出现，大约在2009年左右，人们开始使用JavaScript编写应用程序的前端**和**后端。
- en: Node.js enabled an entirely new kind of JavaScript application and heavily contributed
    to shaping the JavaScript testing ecosystem. Because JavaScript developers were
    now able to implement different types of applications, they also had to come up
    with new ways of testing them and new tools for doing so.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js使一种全新的JavaScript应用程序成为可能，并为塑造JavaScript测试生态系统做出了巨大贡献。由于JavaScript开发者现在能够实现不同类型的应用程序，他们还必须想出新的测试方法和新的测试工具。
- en: 'In this chapter, I will focus on how to test the most notable kind of application
    that Node has enabled: backends written in JavaScript.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将重点介绍如何测试Node.js所支持的最显著类型的应用程序：用JavaScript编写的后端。
- en: What you have already learned about organizing tests, assertions, and test doubles
    will still be crucial in this chapter. In it, you will learn the nuances associated
    with applying these techniques in the context of a server.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学到的关于组织测试、断言和测试替身的内容在本章中仍然至关重要。在本章中，你将学习与在服务器上下文中应用这些技术相关的细微差别。
- en: Testing a backend is significantly different from testing other kinds of programs
    like standalone modules or frontend applications. It involves dealing with the
    filesystem, databases, HTTP requests, and third-party services.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 测试后端与测试其他类型的程序（如独立模块或前端应用程序）显著不同。它涉及处理文件系统、数据库、HTTP请求和第三方服务。
- en: Because these components are vital for your backend application to work, they
    must be taken into account when writing tests. Otherwise, you may not find critical
    defects.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这些组件对于你的后端应用程序的正常运行至关重要，所以在编写测试时必须考虑它们。否则，你可能找不到关键缺陷。
- en: Errors could slip into production if, for example, you didn’t check whether
    the application added the correct rows to a table in your database, or if your
    server returned the wrong HTTP status code for a route. If you’re dealing with
    third-party APIs, how can you ensure that your application will be able to cope
    with that service being unavailable?
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果，例如，你没有检查应用程序是否正确地将行添加到数据库中的表，或者如果你的服务器为路由返回了错误的HTTP状态码，错误可能会滑入生产环境。如果你正在处理第三方API，你如何确保你的应用程序能够应对该服务不可用的情况？
- en: Besides defects, tests can also uncover security issues. By checking whether
    endpoints require the necessary authentication headers, you could ensure that
    unauthorized clients wouldn’t be able to access sensitive information or modify
    data belonging to other users.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 除了缺陷外，测试还可以揭示安全漏洞。通过检查端点是否需要必要的身份验证头，你可以确保未经授权的客户端无法访问敏感信息或修改属于其他用户的资料。
- en: Additionally, testing a web server is an effective way of ensuring it follows
    the “contract” upon which its consumers rely. When multiple services have to communicate,
    it’s crucial to guarantee that each deployment will preserve the interface that
    each of these services expects.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，测试Web服务器是确保其遵循消费者所依赖的“合同”的有效方式。当多个服务需要通信时，保证每个部署都将保留这些服务期望的接口至关重要。
- en: I will cover these topics by writing a server and testing it as I add new features.
    The application I will use as an example will be reasonably elaborate so that
    it can simulate situations you’d find in your day-to-day job as accurately as
    possible.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我将通过编写服务器并在添加新功能时对其进行测试来涵盖这些主题。我将用作示例的应用程序将相当复杂，以便尽可能准确地模拟你在日常工作中遇到的情况。
- en: This application will be the backend for Louis’s bakery’s online store. It will
    take HTTP requests, handle authentication, interact with a database, and integrate
    with a third-party API.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序将是Louis面包店在线商店的后端。它将处理HTTP请求，处理身份验证，与数据库交互，并集成第三方API。
- en: In section 4.1, I’ll talk through the application’s requirements and how to
    set it up for testing. In this section, you will write multiple different kinds
    of tests for your backend application and learn how to structure your testing
    environment based on chapter 2’s testing pyramid.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在4.1节中，我将讨论应用程序的需求以及如何为测试设置它。在本节中，你将为你的后端应用程序编写多种不同类型的测试，并学习如何根据第2章的测试金字塔来构建你的测试环境。
- en: Section 4.2 contains in-depth examples of how to test HTTP endpoints. It introduces
    new tools and techniques for validating your routes and elaborates on the aspects
    to which you should pay more attention, including authentication and middleware
    in general.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 4.2节包含如何测试HTTP端点的深入示例。它介绍了验证你的路由的新工具和技术，并详细说明了你应该更加关注的方面，包括认证和中间件。
- en: Given that the immense majority of backend applications rely on external dependencies,
    I will teach you how to deal with them in section 4.3\. Throughout the examples
    in this section, which involve databases and third-party APIs, you will learn
    how to think about dependencies in the context of tests so that you can obtain
    reliable quality guarantees without making your tests too fragile or convoluted.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于绝大多数后端应用程序依赖于外部依赖项，我将在4.3节中教你如何处理它们。在本节的示例中，涉及数据库和第三方API，你将学习如何在测试的上下文中考虑依赖项，以便在不使测试过于脆弱或复杂的情况下获得可靠的质量保证。
- en: 4.1 Structuring a testing environment
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 构建测试环境结构
- en: For a product or process to be testable, it must be devised with testing in
    mind. In Louis’s bakery, when making a cake, the staff makes the intermediary
    parts separately, carefully inspecting them, and only then putting them together.
    From a recipe’s beginning to its very end, the staff knows what to verify in each
    step. Because they have a strong quality-control process, they are not limited
    to trying only the final product. Rushing to get everything done faster could
    make it harder to determine whether a batch of cakes is at the usual standard
    of excellence, and, if it’s not, it could make it harder to figure out what went
    wrong.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要使产品或流程可测试，它必须以测试为导向进行设计。在路易斯的面包店，当制作蛋糕时，员工会分别制作中间部分，仔细检查它们，然后才将它们组合在一起。从食谱的开始到结束，员工都知道每个步骤要验证什么。因为他们有一个强大的质量控制流程，所以他们不仅限于尝试最终产品。急于完成所有事情可能会使确定一批蛋糕是否符合通常的高标准变得更加困难，如果不符合，可能会使找出问题所在变得更加困难。
- en: In the same way, **software that’s intended to be testable must be designed
    with testing in mind**, especially when dealing with backend applications. These
    kinds of applications tend to involve many moving parts, and, if these parts are
    not exposed nor separated into smaller pieces, they can make tests hard, or maybe
    even impossible, to write.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，**旨在可测试的软件必须以测试为导向进行设计**，尤其是在处理后端应用程序时。这类应用程序往往涉及许多动态部分，如果这些部分没有暴露或分离成更小的部分，它们可能会使测试变得困难，甚至可能根本无法编写测试。
- en: Consider, for example, the previous `addToInventory` route you have created.
    If your application uses a private in-memory `Map` to store data, doesn’t expose
    any functions in the `cartController`, and logs information directly to the console,
    there isn’t much room for testing. The best you can do is send an HTTP request
    and check its response, as shown in figure 4.1.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑你之前创建的`addToInventory`路由。如果你的应用程序使用私有内存`Map`来存储数据，不在`cartController`中公开任何函数，并且直接将信息记录到控制台，那么测试的空间就不大了。你所能做的最好的事情就是发送一个HTTP请求并检查其响应，如图4.1所示。
- en: '![](../Images/CH04_F01_DaCosta.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1](../Images/CH04_F01_DaCosta.png)'
- en: Figure 4.1 What tests can access if an application isn’t designed with testing
    in mind
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 如果应用程序没有考虑到测试，测试可以访问的内容
- en: Even though that would be a valid end-to-end test, in a scenario like that,
    it can be difficult to obtain granular feedback. If your tests also can’t access
    the application’s data storage, you can’t ensure that it has transitioned from
    one valid state to another. In a more extreme scenario, if your routes depend
    on authentication, your tests *must* be able to send authenticated requests. Otherwise,
    even end-to-end tests would become impossible to write.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管那将是一个有效的端到端测试，但在那种情况下，可能很难获得细粒度的反馈。如果你的测试也无法访问应用程序的数据存储，你无法确保它已经从一个有效状态转换到另一个状态。在更极端的情况下，如果你的路由依赖于认证，你的测试**必须**能够发送认证请求。否则，即使是端到端测试也可能无法编写。
- en: '**Testable software is broken down in smaller accessible pieces, which you
    can test separately**.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**可测试的软件被分解成更小的可访问部分，您可以单独测试它们**。'
- en: The more accessible your application’s code is, the easier it is to simulate
    error scenarios and more complicated edge cases. The more granular its parts are,
    the more precise your test’s feedback becomes.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序代码越容易访问，模拟错误场景和更复杂的边缘情况就越容易。其部分越细粒度，测试的反馈就越精确。
- en: In this section, I will teach you how to develop a structured approach to dividing
    your application and testing it. You will gradually break it down into smaller
    pieces and validate each one of them.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将向您展示如何开发一种结构化的方法来划分您的应用程序并对其进行测试。您将逐步将其分解成更小的部分，并验证每一个部分。
- en: I have divided this section into unit, integration, and end-to-end tests because
    as we have previously seen, that’s the most effective way to organize your tests
    comprehensibly and maintain a high quality threshold.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我将此部分分为单元测试、集成测试和端到端测试，因为我们之前看到的那样，这是组织测试和理解测试的最有效方式，并保持高质量标准。
- en: NOTE To focus on tests and avoid having to rewrite the API, I’m going to use
    a server that’s similar to the one you wrote in chapter 2\. You can find the code
    for every example in this chapter and the previous ones at [https://github.com/lucasfcosta/testing-javascript-applications](https://github.com/lucasfcosta/testing-javascript-applications).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：为了专注于测试并避免重写 API，我将使用与您在第二章中编写的类似的服务器。您可以在[https://github.com/lucasfcosta/testing-javascript-applications](https://github.com/lucasfcosta/testing-javascript-applications)找到本章和前几章中每个示例的代码。
- en: 4.1.1 End-to-end testing
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.1 端到端测试
- en: Let’s have a look at the `server.js` file and think about how to accomplish
    this task.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `server.js` 文件，并思考如何完成这个任务。
- en: 'This file has three routes: one that returns a cart’s items and two that add
    and remove items from it. When updating a cart’s contents, the application also
    updates the inventory accordingly.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件有三个路由：一个返回购物车项目，两个添加和从其中删除项目。当更新购物车的内容时，应用程序也会相应地更新库存。
- en: Listing 4.1 server.js
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.1 server.js
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Returns a cart’s items
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 返回购物车的项目
- en: ❷ Adds an item to a cart
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 向购物车添加一个项目
- en: ❸ Deletes an item from a cart
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 从购物车中删除一个项目
- en: ❹ Exports a server instance bound to the port 3000
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 导出绑定到端口 3000 的服务器实例
- en: Because this application does not expose anything but its routes, you can interact
    with it only by sending HTTP requests. You also don’t have access to its state,
    so you can’t check anything but the responses to your HTTP requests. In other
    words, you can write only end-to-end tests, and, even then, you can’t ensure that
    the application has gone into a consistent state.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个应用程序除了其路由外没有公开任何内容，所以您只能通过发送 HTTP 请求与之交互。您也没有访问其状态，因此您只能检查对您的 HTTP 请求的响应。换句话说，您只能编写端到端测试，即使如此，您也无法确保应用程序已进入一致的状态。
- en: This API is an impenetrable black box of code. You can’t set up elaborate scenarios,
    and there’s not much insight on what’s going on inside of it, as shown in figure
    4.2.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此 API 是一个无法穿透的黑盒代码。您无法设置复杂的场景，并且如图 4.2 所示，您对其内部发生的事情没有太多了解。
- en: '![](../Images/CH04_F02_DaCosta.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F02_DaCosta.png)'
- en: Figure 4.2 What’s available for a test when an application doesn’t expose any
    of its pieces
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 当应用程序未公开其任何部分时，测试可用性如何
- en: Let’s consider these limitations and try to write an end-to-end test for the
    route that adds items to a cart.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑这些限制，并尝试为添加项目到购物车的路由编写端到端测试。
- en: Listing 4.2 server.test.js
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.2 server.test.js
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Causes the server.js file to be executed, binding a server instance to the
    port 3000
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导致 server.js 文件执行，绑定一个服务器实例到端口 3000
- en: ❷ Tries to add one cheesecake to a user’s cart by sending a request to the server
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 通过向服务器发送请求尝试向用户的购物车添加一个芝士蛋糕
- en: ❸ Checks whether the response’s status is 200
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 检查响应的状态是否为 200
- en: This test will fail because the item we’re trying to add, a cheesecake, is not
    available. But how will we make this item available if the application doesn’t
    expose its inventory?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试将失败，因为我们试图添加的项目，一个芝士蛋糕，是不可用的。但如果应用程序没有公开其库存，我们将如何使这个项目可用？
- en: '**Tests need to be able to set up a scenario—provide an initial state—exercise
    your application, and check whether the output and the final state are correct**.
    To fix this, expose your `inventory`, and update your test, as shown next.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试需要能够设置一个场景——提供一个初始状态——执行您的应用程序，并检查输出和最终状态是否正确**。为了解决这个问题，公开您的 `inventory`，并更新您的测试，如下所示。'
- en: Listing 4.3 server.js
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.3 server.js
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Exports a server instance bound to the port 3000 through a property called
    app
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 通过一个名为 app 的属性导出一个绑定到 3000 端口的服务器实例
- en: ❷ Exports the server’s inventory through a property with the same name
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 通过具有相同名称的属性导出服务器的库存
- en: Listing 4.4 server.test.js
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.4 server.test.js
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Imports both the server instance and the inventory
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入服务器实例和库存
- en: ❷ Clears the inventory after each test
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在每个测试后清除库存
- en: '❸ Arrange: sets to 1 the number of cheesecakes in the inventory'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 安排：将库存中芝士蛋糕的数量设置为 1
- en: '❹ Act: sends a request that tries to add one cheesecake to a user’s cart'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 行动：发送一个尝试向用户的购物车添加一块芝士蛋糕的请求
- en: '❺ Assert: checks whether the response’s status is 200'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 断言：检查响应的状态是否为 200
- en: '❻ Assert: checks whether the response body matches the cart’s contents'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 断言：检查响应体是否与购物车的商品内容匹配
- en: '❼ Assert: verifies that the number of cheesecakes in the inventory is 0'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 断言：验证库存中芝士蛋糕的数量为 0
- en: Now your test passes. You have access to the piece of state you need to set
    up a scenario, the route with which you need to interact, and the response you
    need to check, as illustrated in figure 4.3\. Notice that you were able to add
    an extra verification to check if the inventory’s state is consistent only because
    you exposed it.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在测试通过了。你有了设置场景所需的州的一部分，你需要与之交互的路由，以及你需要检查的响应，如图 4.3 所示。注意，你能够添加额外的验证来检查库存的状态是否一致，仅仅是因为你暴露了它。
- en: '![](../Images/CH04_F03_DaCosta.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F03_DaCosta.png)'
- en: Figure 4.3 What’s been exposed to the test for `addItemToCart`
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 `addItemToCart` 测试暴露的内容
- en: Go ahead and add tests to check if the piece of state containing the carts also
    behaves appropriately. If you’re feeling confident, add similar end-to-end tests
    for all the other routes.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 继续添加测试来检查包含购物车的状态部分是否表现适当。如果你很有信心，可以为所有其他路由添加类似的端到端测试。
- en: When writing end-to-end tests, provide access to the state, as well as to the
    interface your customers or frontend clients use to interact with your backend.
    Access to the route will allow the test to exercise the application, and access
    to the state will allow the test to set up a scenario—create an initial state—and
    check whether the new state is valid.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写端到端测试时，提供对状态以及客户或前端客户端用来与后端交互的界面的访问。对路由的访问将允许测试锻炼应用程序，而对状态的访问将允许测试设置一个场景——创建初始状态——并检查新状态是否有效。
- en: NOTE We will cover replacing your in-memory database with an external one later
    in this chapter. For now, focus on understanding why and how to separate the different
    parts of your application.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们将在本章后面介绍如何用外部数据库替换内存中的数据库。现在，专注于理解为什么要以及如何分离应用程序的不同部分。
- en: 4.1.2 Integration testing
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.2 集成测试
- en: Even though end-to-end tests provide the strongest reliability guarantees, if
    you have *only* end-to-end tests, maintaining your application will possibly become
    more expensive. End-to-end tests take a long time to run and generate more coarse
    feedback. Because the route needs to be complete before you can extract any value
    from your end-to-end test, it also takes a lot longer to give you feedback.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管端到端测试提供了最强的可靠性保证，但如果你只有端到端测试，维护你的应用程序可能会变得更加昂贵。端到端测试运行时间较长，并且生成的反馈较粗。因为在你从端到端测试中提取任何价值之前，路由需要是完整的，所以它也花费了更长的时间来给你反馈。
- en: A smart strategy to get earlier and more granular feedback is to move the code
    within your routes to separate modules so that you can expose their functions
    and write tests individually.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 获取更早和更细粒度反馈的智能策略是将你的路由中的代码移动到单独的模块中，这样你就可以单独暴露它们的函数并编写测试。
- en: You could start by separating the interactions with the inventory and the carts
    into separate functions in different modules. First, create a file called `inventoryController.js`,
    and add a function that removes an item from the inventory.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从将库存和购物车的交互分离到不同模块中的单独函数开始。首先，创建一个名为 `inventoryController.js` 的文件，并添加一个从库存中删除项目的函数。
- en: Listing 4.5 inventoryController.js
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.5 inventoryController.js
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Encapsulates in this file the reference to the Map with the inventory’s contents
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在此文件中封装对包含库存内容的 Map 的引用
- en: ❷ Removes an item from the inventory
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从库存中删除一个项目
- en: ❸ Exports both the inventory and the removeFromInventory function
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 导出库存和 `removeFromInventory` 函数
- en: Within your `cartController`, you can create a function that uses `inventoryController`
    to add an item to a cart if it’s available.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 `cartController` 中，你可以创建一个函数，该函数使用 `inventoryController` 来添加一个可用的项目到购物车中。
- en: Listing 4.6 cartController.js
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.6 cartController.js
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Imports the removeFromInventory function from the inventoryController
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从 inventoryController 导入 removeFromInventory 函数
- en: ❷ Encapsulates in this file the reference to the Map with carts and their contents
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在此文件中封装对包含购物车及其内容的 Map 的引用
- en: ❸ Adds an item to a user’s cart
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 向用户的购物车添加一个项目
- en: ❹ Exports both the Map with carts and the addItemToCart function
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 导出包含购物车的 Map 和 addItemToCart 函数
- en: With these functions, you can then update server.js and make the route that
    adds items to a cart more succinct.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些函数，然后你可以更新 server.js 并使添加到购物车的路由更加简洁。
- en: Listing 4.7 server.js
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.7 server.js
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Imports the Map with carts and the addItemToCart function from the cartController
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从 cartController 导入包含购物车的 Map 和 addItemToCart 函数
- en: ❷ Uses the imported addItemToCart function within the route responsible for
    adding items to a cart
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在负责添加购物车项目的路由中使用导入的 addItemToCart 函数
- en: Once you update the `server.test.js` file to import `carts` and `inventory`
    from the right modules, all your tests should pass.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你将 `server.test.js` 文件更新为从正确的模块导入 `carts` 和 `inventory`，所有测试应该都能通过。
- en: Listing 4.8 server.test.js
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.8 server.test.js
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Imports the server’s instance, causing it to be bound to the port 3000
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入服务器的实例，使其绑定到端口 3000
- en: ❷ Imports the Map with carts and the addItemToCart function from the cartController
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从 cartController 导入包含购物车的 Map 和 addItemToCart 函数
- en: ❸ Imports the inventory from the inventoryController
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 从 inventoryController 导入库存
- en: By making your software more modular, you make it more readable and more testable.
    With more separate modules, you can write more granular tests. You can, for example,
    start writing integration tests that will coexist with your end-to-end tests.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使你的软件更加模块化，你可以使其更易于阅读和测试。随着更多独立的模块，你可以编写更细粒度的测试。例如，你可以开始编写与端到端测试共存的集成测试。
- en: Create a file called `cartController.test.js`, and write a test that covers
    only the `addItemToCart` function, as shown here and illustrated by figure 4.4.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `cartController.test.js` 的文件，并编写一个只覆盖 `addItemToCart` 函数的测试，如下所示，如图 4.4
    所示。
- en: Listing 4.9 cartController.test.js
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.9 cartController.test.js
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Clears the inventory after each test
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在每个测试后清除库存
- en: ❷ Clears the carts after each test
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在每个测试后清除购物车
- en: '❸ Arrange: sets the test user’s cart to an empty array'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 安排：将测试用户的购物车设置为空数组
- en: '❹ Arrange: sets to 0 the number of cheesecakes in the inventory'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 安排：将库存中芝士蛋糕的数量设置为 0
- en: '❺ Act: sends a request trying to add one cheesecake to the test user’s cart'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 行动：发送一个请求尝试向测试用户的购物车添加一块芝士蛋糕
- en: '❻ Assert: expects the request’s error to match the error created within the
    test'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 断言：期望请求的错误与测试中创建的错误匹配
- en: '❼ Assert: expects the test user’s cart to continue empty'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 断言：期望测试用户的购物车保持为空
- en: '❽ Assert: ensures that the test executed two assertions'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 断言：确保测试执行了两个断言
- en: '![](../Images/CH04_F04_DaCosta.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F04_DaCosta.png)'
- en: Figure 4.4 Which parts of your application each end-to-end and integration test
    has access to
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 每个端到端和集成测试可以访问的应用程序的部分
- en: A test like this does not depend on the route to which to send requests. It
    doesn’t rely on authentication, headers, URL parameters, or a specific kind of
    body. It examines your business logic directly. Even though, when considering
    the whole application, this test provides less reliable quality guarantees, it
    is cheaper to write and provides more granular feedback about a smaller part of
    your backend.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的测试不依赖于要发送请求的路由。它不依赖于身份验证、头信息、URL 参数或特定的请求体。它直接检查你的业务逻辑。尽管在考虑整个应用程序时，这个测试提供的质量保证不那么可靠，但它编写起来更便宜，并且提供了关于后端更小部分的更细粒度的反馈。
- en: As an exercise, try adding tests for the `removeFromInventory` function in `inventoryController`,
    too.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项练习，尝试也为 `inventoryController` 中的 `removeFromInventory` 函数添加测试。
- en: NOTE You can continue to move the application’s business logic into the `cartsController`
    and `inventoryController` modules until your `server.js` doesn’t have to manipulate
    the global `inventory` and `carts` maps anymore.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你可以继续将应用程序的业务逻辑移动到 `cartsController` 和 `inventoryController` 模块，直到你的 `server.js`
    不再需要操作全局的 `inventory` 和 `carts` 映射。
- en: If you do this refactor, you will notice that your application doesn’t need
    to import `inventory` or `carts` anywhere. But, because your tests depend on it,
    you *must*.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你这样做重构，你会注意到你的应用程序不需要在任何地方导入 `inventory` 或 `carts`。但是，因为你的测试依赖于它，你*必须*。
- en: It’s not a problem to expose parts of your code just for the sake of testing,
    even if your application code doesn’t need those parts to be exposed.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 仅为了测试而暴露代码的一部分，即使你的应用程序代码不需要这些部分被暴露，也不是问题。
- en: The tests you’ve added don’t really look much like integration tests yet. That’s
    because, for now, you’re storing all of your application’s data in memory. I’ve
    chosen to classify these tests as integration tests because they deal with the
    application’s global state. When we replace the in-memory data with a real database,
    you will notice how much better this definition fits.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你添加的测试实际上看起来并不像集成测试。那是因为，目前，你将所有应用程序的数据存储在内存中。我选择将这些测试归类为集成测试，因为它们处理应用程序的全局状态。当我们用真实数据库替换内存中的数据时，你会注意到这个定义是多么地合适。
- en: To have a better target for an integration test, try adding logging to your
    application. Write a `logger.js` file, and use the `fs` module to write logs to
    `/tmp/logs.out`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地针对集成测试，尝试将日志添加到你的应用程序中。编写一个`logger.js`文件，并使用`fs`模块将日志写入`/tmp/logs.out`。
- en: NOTE If you’re using Windows, you may have to change the path to which the logger
    will append messages.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果你使用的是Windows，你可能需要更改记录器将消息追加到的路径。
- en: Listing 4.10 logger.js
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.10 logger.js
- en: '[PRE9]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Synchronously appends a message to the /tmp/logs.out file
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 同步地将消息追加到/tmp/logs.out文件
- en: ❷ Exports the logger
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 导出记录器
- en: With this logger module, you can make `addToItemToCart` write to the `logs.out`
    file whenever a customer adds an item to the cart, as follows.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个记录器模块，你可以让`addToItemToCart`在客户将商品添加到购物车时写入`logs.out`文件，如下所示。
- en: Listing 4.11 cartController.js
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.11 cartController.js
- en: '[PRE10]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Appends a message to the /tmp/logs.out file whenever a user adds an item to
    the cart
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 当用户将商品添加到购物车时，将消息追加到/tmp/logs.out文件
- en: To test it, add an integration test to `cartController.test.js` that invokes
    the `addItemToCart` function and checks the log file’s contents, as shown next
    and illustrated in figure 4.5.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试它，向`cartController.test.js`添加一个集成测试，调用`addItemToCart`函数并检查日志文件的内容，如下所示，并在图4.5中展示。
- en: Listing 4.12 cartController.js
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.12 cartController.js
- en: '[PRE11]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Synchronously clears the log file before each test
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在每个测试之前同步清除日志文件
- en: '❷ Arrange: sets the test user’s cart to an empty array'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 安排：将测试用户的购物车设置为空数组
- en: '❸ Arrange: sets to 1 the number of cheesecakes in the inventory'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 安排：将库存中芝士蛋糕的数量设置为1
- en: '❹ Act: sends a request trying to add one cheesecake to the test user’s cart'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 行动：发送一个请求尝试向测试用户的购物车添加一块芝士蛋糕
- en: ❺ Synchronously reads the log file
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 同步地读取日志文件
- en: '❻ Assert: expects the logs to contain a message that informs that cheesecake
    was added to the test user’s cart'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 断言：期望日志包含一条消息，告知测试用户的购物车中添加了芝士蛋糕
- en: '![](../Images/CH04_F05_DaCosta.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图4.5](../Images/CH04_F05_DaCosta.png)'
- en: Figure 4.5 Integration tests will have access to all the dependencies with which
    your application interacts.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 集成测试将能够访问与你的应用程序交互的所有依赖项。
- en: When it comes to testing backends, integration tests will cover interactions
    between multiple functions and external components upon which your application
    may depend. These include, for example, external APIs, databases, global pieces
    of state, or the filesystem. Different from unit tests, integration tests will
    *not always* use test doubles to isolate your code from external dependencies.
    They might, for example, fake the responses from a third-party API but won’t use
    a test double for a database.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到测试后端时，集成测试将覆盖多个函数和外部组件之间的交互，这些组件可能是你的应用程序所依赖的。例如，外部API、数据库、全局状态或文件系统。与单元测试不同，集成测试**不一定**总是使用测试替身来隔离你的代码与外部依赖。例如，它们可能会伪造第三方API的响应，但不会为数据库使用测试替身。
- en: NOTE Throughout the rest of this chapter, we’ll talk about when to use test
    doubles and explain why it is a good idea to fake the responses from a third-party
    API but to run tests against a real database.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在本章的其余部分，我们将讨论何时使用测试替身，并解释为什么伪造第三方API的响应但针对真实数据库进行测试是一个好主意。
- en: 4.1.3 Unit testing
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.3 单元测试
- en: End-to-end and integration tests create the most reliable quality guarantees,
    but, without unit tests, writing backend applications can become unmanageable.
    With unit tests, you can target small pieces of software at a time, reducing the
    time it takes to get feedback after you write code.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端和集成测试提供了最可靠的质量保证，但没有单元测试，编写后端应用程序可能会变得难以管理。有了单元测试，你可以一次针对一小块软件，减少编写代码后获得反馈所需的时间。
- en: In the context of a backend application, unit tests are ideal for functions
    that don’t depend on other external dependencies, like a database or the filesystem.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在后端应用程序的上下文中，单元测试非常适合那些不依赖于其他外部依赖项的函数，例如数据库或文件系统。
- en: As the target for our unit tests, I will use a timely example. At the time I’m
    writing this chapter, I’ve started quarantining due to COVID-19\. Because many
    people have begun stockpiling food, it’s been hard to find bread, cakes, and brownies
    to help ease the tension of being locked inside. As many responsible businesses
    have done, let’s assume that Louis wants to ensure that his customers can buy
    only three units of any item at a time. This limitation ensures that everyone
    will have a sweet piece of dessert during these bitter times we’re going through.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们单元测试的目标，我将使用一个及时示例。在我撰写这一章的时候，由于COVID-19，我开始隔离。由于许多人开始囤积食物，很难找到面包、蛋糕和布朗尼来帮助缓解被锁在里面的紧张情绪。正如许多负责任的企业所做的那样，让我们假设路易斯想要确保他的客户一次只能购买任何商品的三件。这种限制确保了在我们在这些艰难时期，每个人都能享受到一块甜美的甜点。
- en: This function, which will go into the `cartController` module, looks like this.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数，它将被添加到`cartController`模块中，看起来是这样的。
- en: Listing 4.13 cartController.js
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.13 cartController.js
- en: '[PRE12]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Creates an object whose keys are the names of items in the cart and whose
    values are each item’s respective quantities
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个对象，其键是购物车中项目的名称，其值是每个项目的相应数量
- en: ❷ Creates an array whose items are the quantities of each item in the cart
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个数组，其元素是购物车中每个项目的数量
- en: ❸ Returns a Boolean indicating whether the quantity of each item is smaller
    than 3
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 返回一个布尔值，指示每个项目的数量是否小于3
- en: Even though the `compliesToItemLimit` function is not used outside of `cartController`,
    make sure to export it, as shown here, so that you can use it in your tests.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`compliesToItemLimit`函数在`cartController`之外没有使用，但请确保像这里所示那样导出它，以便你可以在测试中使用它。
- en: Listing 4.14 cartController.js
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.14 cartController.js
- en: '[PRE13]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, finally, add a new `describe` block to your `cartController.test.js` file,
    and write tests for the `compliesToItemLimit` function.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，最后，向你的`cartController.test.js`文件中添加一个新的`describe`块，并为`compliesToItemLimit`函数编写测试。
- en: Listing 4.15 cartController.test.js
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.15 cartController.test.js
- en: '[PRE14]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '❶ Arrange: creates a cart containing no more than two items of a kind'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 安排：创建一个包含不超过两种同类商品的购物车
- en: '❷ Act and assert: exercises the compliesToItemLimit function, and expects it
    to return true'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 执行并断言：测试`compliesToItemLimit`函数，并期望它返回true
- en: '❸ Arrange: creates a cart containing four cheesecakes'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 安排：创建一个包含四块芝士蛋糕的购物车
- en: '❹ Act and assert: exercises the compliesToItemLimit function, and expects it
    to return false'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 执行并断言：测试`compliesToItemLimit`函数，并期望它返回false
- en: This test isolates the `compliesToItemLimit` function, as you can see in figure
    4.6, and can tell you whether it works without you having to set up complex scenarios
    or rely on other pieces of code. It’s ideal for quickly iterating because it enables
    you to test the function as soon as you’ve written it.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如图 4.6 所示，这个测试隔离了`compliesToItemLimit`函数，并可以告诉你它是否工作，而无需设置复杂的场景或依赖其他代码。它非常适合快速迭代，因为它允许你在编写函数后立即对其进行测试。
- en: It saves you the effort of using it within `addItemToCart` and setting up a
    more complex scenario for an integration test, either in a database or in the
    application’s global state. It also doesn’t require you to deal with any HTTP
    requests or responses, as you’d have to do in an end-to-end test, which could
    become even more bloated if you had to deal with an aspect such as authentication.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 它节省了你使用`addItemToCart`和设置更复杂的集成测试场景（无论是在数据库中还是在应用程序的全局状态中）的努力。它也不需要你处理任何HTTP请求或响应，正如你在一个端到端测试中必须做的那样，如果你必须处理诸如身份验证之类的方面，这可能会变得更加庞大。
- en: '![](../Images/CH04_F06_DaCosta.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F06_DaCosta.png)'
- en: Figure 4.6 Integration tests will have access to all the dependencies with which
    your application interacts.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 集成测试将能够访问与你的应用程序交互的所有依赖项。
- en: '**Unit tests give you immediate and precise feedback when you need it: as soon
    as possible.**'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**单元测试在你需要时立即提供精确的反馈：尽可能快。**'
- en: As an exercise, try integrating this function into `addItemToCart` and writing
    integration and end-to-end tests to validate this behavior. Consider how much
    work that was and how much longer it took you to get feedback when compared to
    the unit test you had previously written.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项练习，尝试将此函数集成到 `addItemToCart` 中，并编写集成和端到端测试以验证此行为。考虑一下这需要多少工作量，以及与之前编写的单元测试相比，你获得反馈所需的时间更长。
- en: 4.2 Testing HTTP endpoints
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 测试HTTP端点
- en: Testing HTTP endpoints is reasonably different from testing other parts of your
    code because you are not directly interacting with the unit under test. Instead,
    you interact with your application only through HTTP requests. In this section,
    I will walk you through a simple yet robust approach for testing your APIs.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 测试HTTP端点与其他代码部分的测试合理不同，因为你不是直接与被测试的单元进行交互。相反，你只能通过HTTP请求与你的应用程序进行交互。在本节中，我将向您介绍一种简单但稳健的方法来测试您的API。
- en: Before we start writing tests for our endpoints, we must choose a proper tool.
    So far we’ve been testing our application by using `isomorphic-fetch`. Because
    the `isomorphic-fetch` package is made for making requests, but not specifically
    for testing APIs, there’s a bit of overhead in using it. You must manually create
    wrappers on top of `fetch` to make it less cumbersome to use, and your assertions
    will be tightly coupled to the implementation of the `fetch` function. These assertions
    will require more effort to update, and, when they fail, their feedback won’t
    be as clear as it should.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写端点测试之前，我们必须选择一个合适的工具。到目前为止，我们一直通过使用 `isomorphic-fetch` 来测试我们的应用程序。因为
    `isomorphic-fetch` 包是为了发送请求而设计的，但并非专门用于测试API，所以使用它会有一些开销。你必须手动在 `fetch` 上创建包装器，使其使用起来不那么繁琐，并且你的断言将与
    `fetch` 函数的实现紧密耦合。这些断言需要更多的努力来更新，并且当它们失败时，它们的反馈不会像应该的那样清晰。
- en: My tool of choice for testing HTTP endpoints is `supertest`, whose documentation
    you can find at [https://github.com/visionmedia/supertest](https://github.com/visionmedia/supertest).
    The `supertest` package is a testing tool that combines the ability to send HTTP
    requests with the ability to assert on these request’s responses. Because `supertest`
    is built on top of `superagent`—a library for performing HTTP requests—you can
    choose to use `superagent`’s extensive API whenever `supertest` itself can’t do
    what you want. This structure makes `supertest` flexible and reliable.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择用于测试HTTP端点的工具是 `supertest`，其文档可以在[https://github.com/visionmedia/supertest](https://github.com/visionmedia/supertest)找到。`supertest`
    包是一个测试工具，它结合了发送HTTP请求和断言这些请求响应的能力。因为 `supertest` 是建立在 `superagent`（一个执行HTTP请求的库）之上的，所以当
    `supertest` 本身无法完成你想要的功能时，你可以选择使用 `superagent` 的广泛API。这种结构使 `supertest` 更加灵活和可靠。
- en: In this section, you will refactor the end-to-end tests for your endpoints so
    that they use `supertest` instead of `fetch`, so start by installing `supertest`
    as a `dev-dependency`. To do that, you can execute `npm install --save-dev supertest`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将重构端到端测试，以便它们使用 `supertest` 而不是 `fetch`，因此首先将 `supertest` 作为 `dev-dependency`
    安装。为此，你可以执行 `npm install --save-dev supertest`。
- en: The `request` function (the default function exported by `supertest`) can take
    an API’s address and return an object that allows you to specify which route you
    want to call with which HTTP verb. Once you have determined which request to perform,
    you can then chain assertions to ensure that the response will match your expectations.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`request` 函数（由 `supertest` 默认导出的函数）可以接受一个API的地址，并返回一个对象，允许你指定你想要使用哪个HTTP动词调用哪个路由。一旦你确定了要执行哪个请求，你就可以链式添加断言以确保响应将符合你的预期。'
- en: As an example, refactor the test that adds available items to a cart. Instead
    of using `fetch` to check its HTTP status and response, use `supertest`’s `request`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，重构添加可用项目到购物车的测试。不要使用 `fetch` 来检查其HTTP状态和响应，而是使用 `supertest` 的 `request`。
- en: Listing 4.16 server.test.js
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.16 server.test.js
- en: '[PRE15]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '❶ Arrange: sets to 1 the number of cheesecakes in the inventory'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 安排：将库存中芝士蛋糕的数量设置为1
- en: '❷ Act and assert: sends a POST request to /carts/test_user/items/cheesecake,
    and expects the response’s status to be 200'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 执行和断言：向 /carts/test_user/items/cheesecake 发送POST请求，并期望响应的状态为200
- en: '❸ Assert: expects the response’s body to be an array containing one cheesecake'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 断言：期望响应体是一个包含一个芝士蛋糕的数组
- en: '❹ Assert: expects the inventory to have no more cheesecakes'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 断言：期望库存中不再有芝士蛋糕
- en: '❺ Assert: expects the test user’s cart to contain only one cheesecake'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 断言：期望测试用户的购物车中只包含一个芝士蛋糕
- en: Because `request` returns a `Promise`, we can use `await` to wait for it to
    resolve and assign the resolved value to `response`. This `response` will contain
    a `body` and many other relevant pieces of information that you can use in your
    assertions.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`request`返回一个`Promise`，我们可以使用`await`等待它解析并将解析后的值分配给`response`。这个`response`将包含`body`和其他许多相关信息，你可以在你的断言中使用这些信息。
- en: Even though you have access to all of the response’s data, you can also avoid
    having to write separate assertions to check it. You can, instead, keep using
    `supertest` to ensure that the headers, for example, also match your expectations.
    In the next excerpt, you can see how to check if the response’s `Content-Type`
    header is correctly set.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可以访问响应的所有数据，但你也可以避免编写单独的断言来检查它。相反，你可以继续使用`supertest`来确保，例如，头也符合你的期望。在下一个摘录中，你可以看到如何检查响应的`Content-Type`头是否正确设置。
- en: Listing 4.17 server.test.js
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.17 server.test.js
- en: '[PRE16]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '❶ Act and assert: sends a POST request to /carts/test_user/items/cheesecake,
    and expects the response’s status to be 200 and the Content-Type header to match
    json'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 行动和断言：向/carts/test_user/items/cheesecake发送POST请求，并期望响应的状态码为200，并且Content-Type头匹配json
- en: When using `supertest`, you can avoid having to hardcode your API’s address
    in your tests. Instead, you can export an instance of Koa and pass it to `request`.
    Giving it an instance of Koa instead of an address will make your tests pass,
    even when you change the port to which the server is bound.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`supertest`时，你可以避免在测试中硬编码你的API地址。相反，你可以导出一个Koa实例并将其传递给`request`。用Koa实例而不是地址来传递将使你的测试通过，即使你更改了服务器绑定的端口。
- en: Listing 4.18 server.test.js
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.18 server.test.js
- en: '[PRE17]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ Sends requests to where the server’s instance is so that you don’t have to
    hardcode its address
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将请求发送到服务器实例所在的位置，这样你就不必硬编码其地址
- en: So far we haven’t yet sent a request with a body. Let’s adapt the route that
    adds items to a cart so that it takes a body with multiple items. For the server
    to understand JSON bodies, we will need to use the `koa-body-parser` package.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有发送带有请求体的请求。让我们调整添加项目到购物车的路由，使其能够接受包含多个项目的请求体。为了服务器能够理解JSON请求体，我们需要使用`koa-body-parser`包。
- en: To use `koa-body-parser`, install it as a dependency, and attach a middleware
    that will parse the request’s body and update the context with the parsed content,
    as shown in figure 4.7.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`koa-body-parser`，将其作为依赖项安装，并附加一个中间件，该中间件将解析请求体并更新上下文中的解析内容，如图4.7所示。
- en: Listing 4.19 server.js
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.19 server.js
- en: '[PRE18]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Sets up the body-parser, causing it to attach the parsed body to the context’s
    request.body property
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 设置body-parser，使其将解析后的请求体附加到上下文的request.body属性
- en: '![](../Images/CH04_F07_DaCosta.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F07_DaCosta.png)'
- en: Figure 4.7 How the `body-parser` middleware works for JSON bodies
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 `body-parser`中间件如何处理JSON请求体
- en: Middleware By definition, middleware is any layer of software that stands between
    two others.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件按照定义，中间件是介于两个其他软件层之间的任何软件层。
- en: In the case of Koa, middleware stands between the initial request received and
    the final matched route.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在Koa的情况下，中间件位于接收到的初始请求和最终匹配的路由之间。
- en: If you think of your server as your house’s plumbing system, middleware is the
    pipes that take the water to your home, whereas the routes are the places from
    which water comes out—like your kitchen faucet or garden hose.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你把你的服务器想象成你房子的管道系统，那么中间件就是将水流送到你家的管道，而路由则是水流出来的地方——比如厨房的水龙头或花园的水管。
- en: Once the `body-parser` is in place, update the route so that it uses the body’s
    content. It should use the `item` property to determine what to add and the `quantity`
    property to determine how many.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`body-parser`设置好了，更新路由使其使用请求体的内容。它应该使用`item`属性来确定要添加什么，以及使用`quantity`属性来确定数量。
- en: Listing 4.20 server.js
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.20 server.js
- en: '[PRE19]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Extracts the item and quantity properties from the request’s body
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从请求体中提取项目属性和数量属性
- en: ❷ Tries to add the requested quantity of an item to the user’s cart
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 尝试将请求的项目数量添加到用户的购物车中
- en: Finally, let’s use the `send` method in our tests to send a JSON body to this
    route.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们在我们的测试中使用`send`方法向这个路由发送JSON请求体。
- en: Listing 4.21 server.test.js
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.21 server.test.js
- en: '[PRE20]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '❶ Arrange: sets to 3 the number of cheesecakes in the inventory'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 安排：将库存中的芝士蛋糕数量设置为3
- en: '❷ Act: sends a POST request to /cart/test_user/items'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 行动：向/cart/test_user/items发送POST请求
- en: ❸ Sets the request’s body to an object including the name of the item to add
    and how many
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将请求体设置为包含要添加的项目名称和数量的对象
- en: '❹ Assert: expects the response’s status to be 200'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 断言：期望响应的状态为 200
- en: '❺ Assert: expects the response’s Content-Type header to match json'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 断言：期望响应的 Content-Type 标头匹配 json
- en: '❻ Assert: expects the response’s body to be an array containing three cheesecakes'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 断言：期望响应的正文是一个包含三个芝士蛋糕的数组
- en: '❼ Assert: expects the inventory to not have any cheesecakes'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 断言：期望库存中没有芝士蛋糕
- en: '❽ Assert: expects the user’s cart to be an array containing three cheesecakes'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 断言：期望用户的购物车是一个包含三个芝士蛋糕的数组
- en: NOTE `supertest` supports everything that `superagent` does, including sending
    multiple different kinds of payloads. For example, you can send files if you want
    to test a route that accepts file uploads.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：`supertest` 支持所有 `superagent` 的功能，包括发送多种不同类型的有效载荷。例如，如果你想测试接受文件上传的路由，你可以发送文件。
- en: '[PRE21]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '❶ Act: attaches the test/photo.png file to the avatar field when sending a
    POST request to /users/test_user/profile_picture'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 操作：在向 /users/test_user/profile_picture 发送 POST 请求时，将测试/照片.png 文件附加到头像字段
- en: '❷ Assert: expects the response’s body to contain a message informing that the
    picture was updated successfully'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 断言：期望响应的正文包含一条消息，告知图片已成功更新
- en: The `superagent` package is part of what makes `supertest` so popular.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`superagent` 包是 `supertest` 受欢迎的部分原因。'
- en: NOTE To see everything that `superagent—`the package behind `supertest—`can
    do, check out its documentation at [https://visionmedia.github.io/superagent/](https://visionmedia.github.io/superagent/).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：要查看 `superagent`（`supertest` 背后的包）能做什么，请查看其文档：[https://visionmedia.github.io/superagent/](https://visionmedia.github.io/superagent/)。
- en: As an exercise, try updating the other tests in `server.test.js` to use `superagent`,
    too. If you’re feeling adventurous, experiment accepting different types of bodies
    other than JSON, such as file uploads.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项练习，尝试更新 `server.test.js` 中的其他测试，使其也使用 `superagent`。如果你感到好奇，可以尝试接受除 JSON
    之外的其他类型的正文，例如文件上传。
- en: 4.2.1 Testing middleware
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.1 测试中间件
- en: As with any other piece of code, you can test your middleware in isolation or
    alongside the pieces of software that depend on it—in the case of middleware,
    your routes. In this subsection, you will create your own middleware and learn
    how to test it. We will then compare the advantages, costs, and benefits of these
    two approaches so that you can choose which strategy is the most adequate for
    your project.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何其他代码片段一样，你可以单独测试你的中间件，或者与依赖它的软件组件（在这种情况下是路由）一起测试。在本小节中，你将创建自己的中间件并学习如何测试它。然后我们将比较这两种方法的优缺点，以便你可以选择最适合你项目的策略。
- en: The middleware you will create, which is shown in figure 4.8, will be responsible
    for checking users’ credentials when they try to access routes that add or remove
    items from carts.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你将创建的中间件，如图 4.8 所示，将负责在用户尝试访问添加或从购物车中删除项目的路由时检查用户的凭据。
- en: '![](../Images/CH04_F08_DaCosta.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F08_DaCosta.png)'
- en: Figure 4.8 The role of authentication middleware
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8 认证中间件的作用
- en: Create a new file called `authenticationController.js`. In it, you will put
    all the code necessary for implementing this middleware.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `authenticationController.js` 的新文件。在其中，你将放置实现此中间件所需的所有代码。
- en: Let’s start by creating a map that will store customers’ accounts. This map
    will be indexed by customer username, and each entry will contain their email
    and a hashed password.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个存储客户账户的映射开始。这个映射将按客户用户名索引，每个条目将包含他们的电子邮件和散列密码。
- en: NOTE Cryptographic hash functions allow you to map an input to a fixed size
    output, which can’t be mapped back to the original input.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：加密散列函数允许你将输入映射到固定大小的输出，该输出不能映射回原始输入。
- en: By hashing users’ passwords, you can avoid developers having access to them,
    and, even if your database is compromised, the attackers won’t be able to access
    your customers’ accounts.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 通过散列用户的密码，你可以避免开发者访问它们，即使你的数据库被入侵，攻击者也无法访问你的客户账户。
- en: Because we want to focus on tests, the examples in this book are simple and
    naive. I’d recommend you do more research on the subject when implementing your
    own production-ready applications.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们要专注于测试，所以这本书中的例子都很简单且直观。我建议你在实现自己的生产级应用时，对该主题进行更多研究。
- en: To hash passwords, we’ll use Node.js’s `crypto` module. With `crypto`, we can
    create a `Hash` object, update it with the user’s password, and generate a `digest—`that
    is, run the hash object’s content through the cryptographic hashing function,
    producing an irreversible output.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 为了哈希密码，我们将使用Node.js的`crypto`模块。使用`crypto`，我们可以创建一个`Hash`对象，用用户的密码更新它，并生成一个`digest`——即运行哈希对象的内容通过加密哈希函数，产生一个不可逆的输出。
- en: Listing 4.22 server.js
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.22 server.js
- en: '[PRE22]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ Creates an object that uses sha256 to generate hash digests
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个使用sha256生成哈希摘要的对象
- en: ❷ Updates the hash with a password
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用密码更新哈希
- en: ❸ Calculates the password’s hash, and returns a hexadecimal-encoded string
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 计算密码的哈希，并返回一个十六进制编码的字符串
- en: Now create a route for users to register. This route will save users to the
    `users` map in `authenticationController`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在为用户创建一个注册路由。这个路由将用户保存到`authenticationController`中的`users` Map。
- en: Listing 4.23 server.js
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.23 server.js
- en: '[PRE23]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ Creates a user if it doesn’t already exist
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果用户不存在，则创建一个用户
- en: ❷ When saving the user, hashes the password, and stores it in the passwordHash
    property
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 保存用户时，哈希密码，并将其存储在passwordHash属性中
- en: Just like we’ve done with the other routes, we can write end-to-end tests for
    this one, too.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们对其他路由所做的那样，我们也可以为这个路由编写端到端测试。
- en: Start with a test that creates a new account and checks the server’s response
    and the user saved in the `users` Map.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 从创建一个新账户并检查服务器响应以及`users` Map中保存的用户开始测试。
- en: Listing 4.24 server.test.js
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.24 server.test.js
- en: '[PRE24]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ Clears all users before each test
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在每个测试之前清除所有用户
- en: '❷ Act and assert: sends a request to the route that creates a user and expects
    its response’s status to be 200 and its Content-Type header to match json'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 行为和断言：向创建用户的路由发送请求，并期望其响应的状态为200，并且其Content-Type头与json匹配
- en: '❸ Assert: validates the message in the response’s body'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 断言：验证响应体的消息
- en: '❹ Assert: checks whether the stored user has the expected email and whether
    its passwordHash property corresponds to a hash of the password sent in the request'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 断言：检查存储的用户是否具有预期的电子邮件，以及其passwordHash属性是否对应于请求中发送的密码的哈希
- en: As an exercise, create a test to validate what happens when someone tries to
    create a duplicate user. This test should add a user to the `Map` of users, send
    a request to add a user with the same username, and check the server’s response.
    It should expect the response’s status to be `409` and its `message` property
    to say that a user with the passed username already exists. If you need help,
    this test is in this book’s GitHub repository at [https://github.com/lucasfcosta/testing-javascript-applications](https://github.com/lucasfcosta/testing-javascript-applications).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项练习，创建一个测试来验证当有人尝试创建一个重复用户时会发生什么。这个测试应该向用户的`Map`中添加一个用户，发送一个带有相同用户名的添加用户请求，并检查服务器的响应。它应该期望响应的状态为`409`，并且其`message`属性表示已存在具有传递的用户名。如果您需要帮助，这个测试在这个书的GitHub仓库中，网址为[https://github.com/lucasfcosta/testing-javascript-applications](https://github.com/lucasfcosta/testing-javascript-applications)。
- en: Notice how these end-to-end tests use the `hashPassword` function, which you
    will use in your middleware, too. Because the end-to-end tests simply trust it
    will work, you must create a transitive guarantee so that you test it only once,
    as shown next. This transitive guarantee helps you avoid having to retest `hashPassword`
    in every test that uses it.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这些端到端测试是如何使用`hashPassword`函数的，您也会在您的中间件中使用它。因为端到端测试只是简单地信任它将工作，所以您必须创建一个传递性保证，这样您就只需测试一次，如下所示。这个传递性保证帮助您避免在每次使用`hashPassword`时都需要重新测试。
- en: Listing 4.25 authenticationController.test.js
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.25 authenticationController.test.js
- en: '[PRE25]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ❶ Creates an object that uses sha256 to generate hash digests
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个使用sha256生成哈希摘要的对象
- en: ❷ Updates the hash with a password
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用密码更新哈希
- en: ❸ Generates the password’s hash digest, and returns a hexadecimal-encoded string
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 生成密码的哈希摘要，并返回一个十六进制编码的字符串
- en: ❹ Exercises the hashPassword function, passing it the same password previously
    used to generate a hash digest within the test
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 练习hashPassword函数，传递之前在测试中用于生成哈希摘要的相同密码
- en: ❺ Expects the hash digest returned by the hashPassword function to be the same
    as the one generated within the test
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 期望hashPassword函数返回的哈希摘要与测试中生成的哈希摘要相同
- en: Even though this test is similar to the `hashPassword` function’s implementation,
    it guarantees that you will be alerted if it ever changes. Whoever alters `hashPassword`
    will also have to update its tests, so the test delivers value by ensuring that
    this person is aware of the consequences of their change. In other words, it becomes
    more unlikely for someone to break `hashPassword` and not be aware of it.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个测试与`hashPassword`函数的实现类似，但它保证了如果它发生变化，你会收到警告。任何修改`hashPassword`的人也将不得不更新其测试，因此测试通过确保这个人知道他们改变的结果来提供价值。换句话说，有人破坏`hashPassword`而不意识到它的可能性变得更小。
- en: The test for `hashPassword` (figure 4.9) is part of how we test middleware.
    It is a guarantee that one of the parts of our middleware is already working—a
    granular piece of feedback upon which we can build. This unit test covers a tiny
    part of what our middleware will use.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`hashPassword`的测试（图4.9）是我们测试中间件的一部分。它保证我们的中间件的一部分已经工作——这是一个细粒度的反馈，我们可以在此基础上构建。这个单元测试覆盖了我们中间件将使用的一小部分。'
- en: '![](../Images/CH04_F09_DaCosta.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F09_DaCosta.png)'
- en: Figure 4.9 The part of the middleware with which this unit test interacts
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9 与此单元测试交互的中间件部分
- en: Proceed by adding a function that takes a username and password and validates
    whether those credentials are valid. You will use this function later to authenticate
    users within your middleware.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 继续添加一个函数，该函数接收用户名和密码，并验证这些凭证是否有效。你将使用这个函数在中间件中验证用户。
- en: Listing 4.26 authenticationController.js
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.26 authenticationController.js
- en: '[PRE26]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ Takes a username and password, and returns true if the user exists and the
    password’s hash matches the user’s passwordHash property; otherwise, it returns
    false.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 接收用户名和密码，如果用户存在且密码的哈希值与用户的passwordHash属性匹配，则返回true；否则返回false。
- en: Again, you can add tests for this function. Because it interacts with the application’s
    data—currently in a global state, but soon in a database—we can consider these
    tests to be integration tests. You have moved up in the pyramid, and you’re now
    testing another layer of your future middleware. An example of such a test is
    written below, and shown in figure 4.10.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，你可以为这个函数添加测试。因为它与应用程序的数据交互——目前是在全局状态中，但很快将在数据库中——我们可以将这些测试视为集成测试。你已经上升到了金字塔的更高层次，现在正在测试你未来中间件的另一层。下面是一个这样的测试示例，如图4.10所示。
- en: Listing 4.27 authenticationController.test.js
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.27 authenticationController.test.js
- en: '[PRE27]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ❶ Clears all users before each test
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在每个测试之前清除所有用户
- en: '❷ Arrange: saves a user directly to the Map of users'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 安排：直接将用户保存到用户的Map中
- en: ❸ Uses the hashPassword function to generate a hash digest for the user’s passwordHash
    property
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用hashPassword函数为用户的passwordHash属性生成哈希摘要
- en: '❹ Act: exercises the credentialsAreValid function, passing it the user’s username
    and their plain-text password'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 行动：调用credentialsAreValid函数，并传递用户的用户名和明文密码
- en: '❺ Assert: expects the credentialsAreValid function to have considered the credentials
    to be valid'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 断言：期望credentialsAreValid函数已将凭证视为有效
- en: '![](../Images/CH04_F10_DaCosta.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F10_DaCosta.png)'
- en: Figure 4.10 The part of the middleware with which this integration test interacts
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.10 与此集成测试交互的中间件部分
- en: Now that we can create user accounts and validate credentials, we must create
    a middleware so that each router knows who is sending the requests. This middleware
    will read the contents of the `authorization` header, find the corresponding user,
    and attach it to the `context`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够创建用户账户并验证凭证，我们必须创建一个中间件，以便每个路由器都知道谁在发送请求。这个中间件将读取`authorization`头部的内容，找到相应的用户，并将其附加到`context`。
- en: Functions that you intend to use as middleware will take the `context` and a
    `next` callback as arguments. When the middleware calls `next`, it invokes the
    subsequent middleware.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 你打算用作中间件的函数将接受`context`和一个`next`回调作为参数。当中间件调用`next`时，它将调用后续的中间件。
- en: NOTE In this example, I will use *basic access authentication* to authenticate
    our users. In a nutshell, this authentication method consists of sending a Base64-encoded
    string containing `Basic username:password` as the value for the `authorization`
    header. You can find the full specification at [https://tools .ietf.org/html/rfc7617](https://tools.ietf.org/html/rfc7617).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在这个例子中，我将使用*基本访问认证*来验证我们的用户。简而言之，这种认证方法包括发送一个包含`Basic username:password`的Base64编码字符串，并将其作为`authorization`头部的值。您可以在[https://tools.ietf.org/html/rfc7617](https://tools.ietf.org/html/rfc7617)找到完整的规范。
- en: Your middleware function should look like this.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 你的中间件函数应该看起来像这样。
- en: Listing 4.28 authenticationController.js
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.28 authenticationController.js
- en: '[PRE28]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ❶ Extracts the value from the authorization header
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从授权头中提取值
- en: ❷ Uses Base64 to decode the string after basic in the authorization header
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用Base64解码授权头中basic后的字符串
- en: ❸ Splits at “:” the decoded content of the authorization header to obtain username
    and password
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在“:”处拆分授权头的解码内容以获取用户名和密码
- en: ❹ Throws an error if the credentials are not valid
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 如果凭据无效，则抛出错误
- en: ❺ Responds with a 401 status if there were any errors parsing or validating
    the authorization header
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 如果解析或验证授权头时出现任何错误，则返回401状态
- en: ❻ Invokes the next middleware
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 调用下一个中间件
- en: Finally, we can test the middleware itself both in isolation and within a route.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以在隔离和路由中测试中间件本身。
- en: If you were to test the middleware function, you could import it into your test
    file and pass it arguments that you could inspect, as shown next.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您要测试中间件函数，您可以将它导入到测试文件中，并传递您可以检查的参数，如下所示。
- en: Listing 4.29 authenticationController.test.js
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.29 authenticationController.test.js
- en: '[PRE29]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '❶ Arrange: creates invalid credentials, and Base64-encodes them'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 安排：创建无效凭据，并对其进行Base64编码
- en: '❷ Act: directly invokes the authenticationMiddleware function, passing a context
    object that includes the invalid credentials and a dummy stub as the next middleware
    function'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 行动：直接调用身份验证中间件函数，传递一个包含无效凭据和占位符作为下一个中间件函数的上下文对象
- en: '❸ Assert: expects the dummy stub representing the next middleware to not have
    been called'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 断言：期望代表下一个中间件的占位符没有被调用
- en: '❹ Assert: expects the response to have a 401 status and contain a message telling
    the user to provide valid credentials'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 断言：期望响应具有401状态并包含一条消息，告知用户提供有效的凭据
- en: As an exercise, try adding tests that invoke the middleware function with valid
    credentials and check whether the `next` callback was invoked.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，尝试添加测试，使用有效凭据调用中间件函数，并检查`next`回调是否被调用。
- en: The previous test is excellent to ensure the function itself works, but it’s
    still, at most, an integration test. It doesn’t validate whether the middleware
    enforces that clients send valid credentials to access a route.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个测试非常出色，可以确保函数本身工作正常，但它最多只是一个集成测试。它没有验证中间件是否强制客户端发送有效的凭据以访问路由。
- en: Right now, even though the middleware function works, it’s not used by the server.
    Therefore, every customer can access any routes without providing credentials.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，尽管中间件函数工作正常，但服务器并未使用它。因此，每位客户都可以无需提供凭据就访问任何路由。
- en: Let’s use the `authenticationMiddleware` function to ensure that all routes
    starting with `/carts` will require authentication.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`authenticationMiddleware`函数来确保所有以`/carts`开头的路由都需要身份验证。
- en: Listing 4.30 server.js
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.30 server.js
- en: '[PRE30]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ❶ If the requested url path starts with /carts, uses the authenticationMiddleware;
    otherwise, proceeds to the next middleware
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果请求的URL路径以/carts开头，则使用身份验证中间件；否则，继续到下一个中间件
- en: If you rerun your tests, you will see that the ones for routes starting with
    `/carts` have started failing, as they should. These tests fail because they don’t
    provide valid credentials.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您重新运行测试，您将看到以`/carts`开头的路由测试已经开始失败，正如预期的那样。这些测试失败是因为它们没有提供有效的凭据。
- en: To make the old tests pass, you need to create a user and provide valid credentials
    when sending requests with `supertest`.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使旧测试通过，您需要在发送带有`supertest`的请求时创建用户并提供有效的凭据。
- en: First, create a function called `createUser`, which will insert a user in the
    `users` map. To make it easier to write tests later, also save the contents you
    will use in the `Authentication` header within your tests for the server.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个名为`createUser`的函数，该函数将在`users`映射中插入用户。为了便于以后编写测试，还请在您的服务器测试中保存您将用于`Authentication`头的内容。
- en: Listing 4.31 server.test.js
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.31 server.test.js
- en: '[PRE31]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ❶ Creates Base64-encoded credentials
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建Base64编码的凭据
- en: ❷ Creates a user whose username and password match the Base64-encoded credentials
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个用户，其用户名和密码与Base64编码的凭据匹配
- en: Finally, add a `beforeEach` hook to each block of tests whose unit under test
    is a route that requires authentication.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为每个测试块添加一个`beforeEach`钩子，其测试单元是一个需要身份验证的路由。
- en: You can then send the valid `authHeader` by using `supertest`’s `set` method,
    which allows you to set headers.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`supertest`的`set`方法发送有效的`authHeader`，这允许您设置头部信息。
- en: Listing 4.32 server.test.js
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.32 server.test.js
- en: '[PRE32]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: ❶ Before each test, creates a user whose username and password match the ones
    stored in this file’s scope. This hook can be considered part of the “arrange”
    stage of your test.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在每次测试之前，创建一个用户，其用户名和密码与存储在本文件范围内的那些匹配。这个钩子可以被认为是测试的“安排”阶段的一部分。
- en: '❷ Arrange: sets to 3 the number of cheesecakes in the inventory'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 安排：将库存中的芝士蛋糕数量设置为3
- en: '❸ Act and assert: uses the credentials in the test’s scope to send a request
    that adds an item to the user’s cart and expects the request to succeed'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 执行和断言：使用测试范围内的凭证发送一个请求，将项目添加到用户的购物车中，并期望请求成功
- en: '❹ Assert: expects the response’s body to be an array containing three cheesecakes'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 断言：期望响应体是一个包含三个芝士蛋糕的数组
- en: '❺ Assert: expects the inventory to not have any cheesecakes'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 断言：期望库存中没有芝士蛋糕
- en: '❻ Assert: expects the test user’s cart to be an array containing three cheesecakes'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 断言：期望测试用户的购物车是一个包含三个芝士蛋糕的数组
- en: As an exercise, try fixing all the other tests that are still failing. You can
    find complete solutions at [https://github.com/lucasfcosta/testing-javascript-applications](https://github.com/lucasfcosta/testing-javascript-applications).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，尝试修复所有其他仍然失败的测试。你可以在[https://github.com/lucasfcosta/testing-javascript-applications](https://github.com/lucasfcosta/testing-javascript-applications)找到完整的解决方案。
- en: Notice how we’ve built up multiple layers of reliability by adding tests to
    the different pieces of software upon which this middleware depends, as shown
    in figure 4.11\. We started by writing small unit tests for `hashPassword`. Then
    we wrote integration tests to check the function that validates credentials. And,
    finally, we were able to test the middleware itself, both by invoking it in isolation
    and by sending requests to other routes.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何通过向这个中间件所依赖的不同软件组件添加测试来建立多个可靠性层，如图4.11所示。我们首先为`hashPassword`编写了小的单元测试。然后我们编写了集成测试来检查验证凭证的功能。最后，我们能够通过单独调用它和向其他路由发送请求来测试中间件本身。
- en: '![](../Images/CH04_F11_DaCosta.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F11_DaCosta.png)'
- en: Figure 4.11 The part of the middleware with which this integration test interacts
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11 与此集成测试交互的中间件部分
- en: During the process of building this middleware, you’ve seen, in practice, how
    you can obtain different types of guarantees in distinct parts of the software
    development process.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建这个中间件的过程中，你实际上看到了如何在软件开发的不同部分获得不同类型的保证。
- en: Because this middleware intercepts requests to many routes, sending requests
    to those routes and checking whether they require authentication is the most reliable
    way to test it. But just because these end-to-end tests provide the strongest
    quality guarantees, it doesn’t mean that they’re the only ones you should write.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个中间件拦截了许多路由的请求，向这些路由发送请求并检查它们是否需要身份验证是测试它的最可靠方式。但仅仅因为端到端测试提供了最强的质量保证，并不意味着它们是你应该编写的唯一测试。
- en: As you’ve seen during this section, unit tests and integration tests were also
    useful for us to get quick feedback on the pieces that form the `authenticationMiddleware`.
    And, as we refactor, they will continue to deliver value, by emitting fast and
    more precise feedback. However, if the time and resources you have available are
    too constrained, you will probably reap more benefits by writing an end-to-end
    test than any other kind of test.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在本节中看到的，单元测试和集成测试对我们来说也非常有用，可以帮助我们快速获取关于构成`authenticationMiddleware`的各个部分的反馈。而且，随着我们进行重构，它们将继续通过提供快速且更精确的反馈来创造价值。然而，如果你可用的时间和资源过于受限，你可能通过编写端到端测试比编写其他任何类型的测试获得更多的好处。
- en: 4.3 Dealing with external dependencies
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 处理外部依赖
- en: It’s almost impossible to find a backend application that does not depend on
    another completely separate piece of software. Therefore, you need to ensure that
    your application interacts with those dependencies appropriately.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎找不到一个不依赖于另一件完全独立的软件的后端应用程序。因此，你需要确保你的应用程序与这些依赖项适当地交互。
- en: 'In this section, you will learn how to deal with external dependencies when
    testing your software. As examples, we’ll use two of the most common dependencies
    for backend applications: databases and third-party APIs.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何在测试软件时处理外部依赖。作为示例，我们将使用后端应用程序中最常见的两个依赖项：数据库和第三方API。
- en: While developing these examples, I will focus on explaining the rationale behind
    every decision so that you can apply these techniques to other similar situations.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发这些示例的过程中，我将专注于解释每个决策背后的理由，以便你可以将这些技术应用到其他类似的情况中。
- en: NOTE All the tests we will write in this section will use the same database.
    If tests that use the same database run simultaneously, they can interfere with
    one another.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本节中我们将编写的所有测试都将使用相同的数据库。如果使用相同数据库的测试同时运行，它们可能会相互干扰。
- en: Because, as we’ve seen in chapter 3, Jest runs different files in parallel,
    your tests will be flaky unless you run them sequentially.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 因为，正如我们在第3章中看到的，Jest并行运行不同的文件，除非你顺序运行它们，否则你的测试将是不稳定的。
- en: 'To run tests sequentially, you can either update your `test` script in `package.json`
    to include the `--runInBand` option or you can pass it directly to `npm test`,
    like this: `npm test` `--` `--runInBand`.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 要顺序运行测试，你可以更新`package.json`中的`test`脚本以包含`--runInBand`选项，或者你可以直接将其传递给`npm test`，如下所示：`npm
    test -- --runInBand`。
- en: Later in this chapter, you will learn how to parallelize tests that involve
    using a database.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，你将学习如何并行化涉及使用数据库的测试。
- en: 4.3.1 Integrations with databases
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.1 与数据库的集成
- en: Up to now, you have been using pieces of global state to store your application’s
    data. The problem with storing data in memory is that this data will be lost every
    time your application restarts.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你一直使用全局状态的一部分来存储你的应用程序数据。将数据存储在内存中的问题是，每次应用程序重启时，这些数据都会丢失。
- en: In the real world, most people use databases to store an application’s state.
    Even though it is possible to mock interactions with a database, it is reasonably
    tricky and requires a lot of effort, as we’ve previously discussed in chapter
    3\. Mocking a database also makes tests separate from a production environment
    and, therefore, makes it more likely for bugs to slip in.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，大多数人使用数据库来存储应用程序的状态。尽管可以模拟与数据库的交互，但这相当棘手且需要大量努力，正如我们在第3章中讨论的那样。模拟数据库也会使测试与生产环境分离，因此更容易出现错误。
- en: Tests that interact with databases may also add maintenance overhead. For example,
    you must be especially careful when setting up and cleaning up testing scenarios.
    Otherwise, a small change in the database schema can generate a lot of work when
    it comes to updating tests.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 与数据库交互的测试也可能增加维护开销。例如，在设置和清理测试场景时，你必须特别小心。否则，数据库模式的小幅变化在更新测试时可能会产生大量工作。
- en: Before we get to any particular techniques or best practices, let’s refactor
    the application so that it uses a database instead of storing state in memory.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论任何特定的技术或最佳实践之前，让我们重构应用程序，使其使用数据库而不是在内存中存储状态。
- en: Setting up your first tests with a database
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数据库设置你的第一个测试
- en: As you did in chapter 2, set up `knex`, the module that you will use to interact
    with the database. Install `knex` and the database management system you want
    to use. In these examples, I will use `sqlite3`.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在第2章中所做的那样，设置`knex`模块，你将使用它来与数据库交互。安装`knex`和你想要使用的数据库管理系统。在这些示例中，我将使用`sqlite3`。
- en: '[PRE33]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: First, create a `knexfile` specifying which database management system you will
    use and how to connect to it, as follows.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个`knexfile`文件，指定你将使用哪种数据库管理系统以及如何连接到它，如下所示。
- en: Listing 4.33 knexfile.js
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.33 knexfile.js
- en: '[PRE34]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: ❶ Uses sqlite3 as the database client
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用sqlite3作为数据库客户端
- en: ❷ Specifies the file in which the database will store its data
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 指定数据库存储数据的文件
- en: ❸ Uses NULL instead of DEFAULT for undefined keys
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用NULL而不是DEFAULT来处理未定义的键
- en: NOTE These examples use `sqlite3` because it’s the easiest database management
    system to set up. By using `sqlite3`, we can focus on tests instead of focusing
    on setting up a database.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：这些示例使用`sqlite3`，因为它是最容易设置的数据库管理系统。通过使用`sqlite3`，我们可以专注于测试，而不是专注于设置数据库。
- en: If you prefer to use Postgres or MySQL, for example, feel free to use them.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢使用Postgres或MySQL，例如，请随意使用它们。
- en: You will find instructions on how to set up many different database management
    systems at [http://knexjs.org](http://knexjs.org).
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[http://knexjs.org](http://knexjs.org)找到如何设置许多不同数据库管理系统的说明。
- en: Now that you have configured Knex, create a file that encapsulates the database
    connections. Remember also to add a method that closes the connection to the database.
    This method will be necessary to make sure we free up resources after tests.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经配置了Knex，创建一个封装数据库连接的文件。记住还要添加一个关闭数据库连接的方法。这个方法将确保我们在测试后释放资源。
- en: Listing 4.34 dbConnection.js
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.34 dbConnection.js
- en: '[PRE35]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: ❶ Imports the configurations necessary to connect to the development database
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入连接到开发数据库所需的配置
- en: ❷ Sets up a connection pool for the development database
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 为开发数据库设置连接池
- en: ❸ Tears down the connection pool
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 断开连接池
- en: Before you can start using the database, you need to create tables for the carts,
    users, and the inventory. To do that, create a `migration` by running `./node_modules/.bin/knex`
    `migrate:make` `--env` `development` `initial_schema`. In the migration file you
    will now find inside the `migrations` folder, create the necessary tables.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在您可以使用数据库之前，您需要为购物车、用户和库存创建表。为此，通过运行`./node_modules/.bin/knex` `migrate:make`
    `--env` `development` `initial_schema`来创建一个`migration`。现在您将在`migrations`文件夹中找到迁移文件，创建必要的表。
- en: NOTE In this migration, you will use Knex’s schema builder API to manipulate
    tables. You can find its documentation at [https://knexjs.org/#Schema](https://knexjs.org/#Schema).
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在这个迁移过程中，您将使用Knex的schema builder API来操作表。您可以在[https://knexjs.org/#Schema](https://knexjs.org/#Schema)找到其文档。
- en: Listing 4.35 20200325082401_initial_schema.js
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.35 20200325082401_initial_schema.js
- en: '[PRE36]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: ❶ The exported up function migrates the database to the next state.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导出的`up`函数将数据库迁移到下一个状态。
- en: ❷ Creates a table for the application’s users. Each user must have an ID, a
    unique username, an email, and a password.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 为应用程序的用户创建一个表。每个用户必须有一个ID、一个唯一的用户名、一个电子邮件和一个密码。
- en: ❸ Creates the carts_items table to keep track of the items in each user’s cart.
    Each row will include the item’s name, its quantity, and the ID of the user to
    whom it belongs.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 创建`carts_items`表以跟踪每个用户的购物车中的物品。每一行将包括物品的名称、数量以及属于该用户的ID。
- en: ❹ Creates an inventory table that keeps track of the items in stock
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 创建一个库存表，用于跟踪库存中的物品。
- en: ❺ The exported down function migrates the database to the previous state, deleting
    the carts, carts_items, and users tables.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 导出的`down`函数将数据库迁移到上一个状态，删除购物车、carts_items和用户表。
- en: To execute this migration, run `./node_modules/.bin/knex migrate:latest` in
    your terminal. This command will perform all the necessary migrations to take
    your database to an up-to-date state. It will create a file to store your data
    if it doesn’t exist and update it with the latest schema.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此迁移，请在终端中运行`./node_modules/.bin/knex migrate:latest`。此命令将执行所有必要的迁移，以将您的数据库带到最新状态。如果不存在，它将创建一个文件来存储您的数据，并使用最新的模式更新它。
- en: Now you can finally update other modules so that they use your database instead
    of a global piece of state.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您最终可以更新其他模块，使它们使用您的数据库而不是全局状态的一部分。
- en: Start by updating `authenticationController.js`. To validate credentials, instead
    of fetching a user from the global `users` map as it used to do, it will fetch
    a user from the database.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，更新`authenticationController.js`文件。为了验证凭证，它将不再像以前那样从全局`users`映射中获取用户，而是从数据库中获取用户。
- en: We also won’t need the `users` map, so don’t forget to remove it.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也不再需要`users`映射，所以别忘了将其删除。
- en: Listing 4.36 authenticationController.js
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.36 authenticationController.js
- en: '[PRE37]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: ❶ Fetches a user from the database whose username matches the one passed to
    the function
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从数据库中获取与函数传入的用户名匹配的用户
- en: ❷ Hashes the passed password and compares it to the user’s passwordHash stored
    in the database
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 对传入的密码进行哈希处理，并将其与数据库中存储的用户`passwordHash`进行比较
- en: After this change, the test for the `credentialsAreValid` function should fail
    because it depends on the global state imported from `authenticationController`.
    Update that test so that it can set up a scenario by adding a user to the database
    instead of updating a global piece state.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在此更改之后，对`credentialsAreValid`函数的测试应该会失败，因为它依赖于从`authenticationController`导入的全局状态。更新该测试，以便通过向数据库添加用户来设置场景，而不是更新全局状态的一部分。
- en: TIP You don’t necessarily need to run *all* of your tests whenever you run `jest`.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：您不必在每次运行`jest`时都运行所有测试。
- en: You can pass a filename as the first argument to `jest` to specify which file
    it should execute and the `-t` option to specify which test.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将文件名作为`jest`的第一个参数传递，以指定要执行哪个文件，使用`-t`选项指定要执行的测试。
- en: If, for example, you want to run only the tests grouped within the `credentialsAreValid`
    block in the `authenticationController.test.js` file, you can execute `jest` `authenticationController.test.js`
    `-t="creden-tialsAreValid"`.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您只想运行`authenticationController.test.js`文件中`credentialsAreValid`块内的测试，可以执行`jest`
    `authenticationController.test.js` `-t="credentialsAreValid"`。
- en: In case you are using `jest` from within an `npm` script, as we have previously
    done, you can append a `--` before passing those options to the script. You could
    run, for example, `npm test -- authenticationController.test.js -t="credentialsAreValid"`.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你像我们之前做的那样，在 `npm` 脚本中使用 `jest`，你可以在传递这些选项给脚本之前添加一个 `--`。例如，你可以运行 `npm test
    -- authenticationController.test.js -t="credentialsAreValid"`。
- en: Listing 4.37 authenticationController.test.js
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.37 authenticationController.test.js
- en: '[PRE38]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: ❶ Instead of clearing the users map, clears the users table in the database
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 不是清除用户映射，而是清除数据库中的用户表
- en: '❷ Arrange: inserts a test user into the database using the hashPassword function
    to generate the value for the passwordHash column'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 安排：使用 hashPassword 函数生成 passwordHash 列表的值，将测试用户插入数据库
- en: '❸ Act: exercises the credentialsAreValidfunction, passing the test user’s username
    and plain-text password'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 行动：通过传递测试用户的用户名和明文密码来练习 credentialsAreValid 函数
- en: '❹ Assert: expects the credentialsAreValid to have considered the credentials
    to be valid'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 断言：期望 credentialsAreValid 已将凭据视为有效
- en: The tests for the `credentialsAreValid` function should now be passing, but
    the tests for `authenticationMiddleware` in that same file should still fail.
    They fail because we have made the `credentialsAreValid` asynchronous, but we
    do not wait for its result in the `authenticationMiddleware` function.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '`credentialsAreValid` 函数的测试现在应该通过，但同一文件中 `authenticationMiddleware` 的测试仍然会失败。它们失败是因为我们将
    `credentialsAreValid` 设计为异步的，但在 `authenticationMiddleware` 函数中我们没有等待其结果。'
- en: Update the `authenticationMiddleware` function as shown in the next code so
    that it waits for `credentialsAreValid` to complete before proceeding.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下代码更新 `authenticationMiddleware` 函数，以便在继续之前等待 `credentialsAreValid` 完成。
- en: Listing 4.38 authenticationController.test.js
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.38 authenticationController.test.js
- en: '[PRE39]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: ❶ Waits for credentialsAreValid to resolve
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 等待 credentialsAreValid 解析
- en: As an exercise, try updating the rest of your application and, consequently,
    your tests. After refactoring, both the application and the tests should no longer
    rely on any pieces of in-memory state. If you want to skip directly to the next
    section, you can find the refactored application in the GitHub repo for this book
    at [http://mng.bz/w9VW](http://mng.bz/w9VW).
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，尝试更新你的应用程序的其余部分以及相应的测试。重构后，应用程序和测试都不应依赖于任何内存状态。如果你想直接跳到下一节，你可以在本书的 GitHub
    仓库中找到重构后的应用程序，网址为 [http://mng.bz/w9VW](http://mng.bz/w9VW)。
- en: 'Even though the tests for your updated `authenticationController.js` file pass,
    you still have two more problems to solve. If you proceeded to update the rest
    of your tests, you might have noticed the following:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你的更新后的 `authenticationController.js` 文件测试通过，你仍然有两个问题需要解决。如果你继续更新其余的测试，你可能已经注意到了以下情况：
- en: The database used for tests and the database used for running the application
    are the same. Not making a distinction between databases can cause tests to delete
    or overwrite critical data.
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于测试的数据库和用于运行应用程序的数据库是相同的。不区分数据库可能会导致测试删除或覆盖关键数据。
- en: You must remember to migrate and clear your databases before running any tests.
    If you forget to do this, your tests will probably fail due to starting from an
    inconsistent state.
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你必须记住在运行任何测试之前迁移和清除你的数据库。如果你忘记这样做，你的测试可能会因为从不一致的状态开始而失败。
- en: Let’s see how we can solve each of these problems and improve our tests.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何解决这些问题并改进我们的测试。
- en: Using separate database instances
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单独的数据库实例
- en: If your tests use the same database instance that your application does when
    it runs, they can overwrite or delete data. Tests may also fail because the database’s
    initial state may be different from what it should have been.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的测试使用与应用程序运行时相同的数据库实例，它们可能会覆盖或删除数据。测试也可能失败，因为数据库的初始状态可能与应有的状态不同。
- en: By using separate database instances for your tests, you can secure the application’s
    data in your development environment and, because these are still real databases,
    make tests as similar to reality as possible.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为你的测试使用单独的数据库实例，你可以在开发环境中保护应用程序的数据，并且因为这些仍然是真实数据库，可以使测试尽可能接近现实。
- en: NOTE You can find the complete code for this subsection inside `chapter4>3 _dealing_with_external_dependencies>2_separate_database_instances`
    at this book’s GitHub repository, [https://github.com/lucasfcosta/testing-javascript-applications](https://github.com/lucasfcosta/testing-javascript-applications).
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你可以在本书的 GitHub 仓库 `chapter4>3 _dealing_with_external_dependencies>2_separate_database_instances`
    中找到本小节完整的代码，[https://github.com/lucasfcosta/testing-javascript-applications](https://github.com/lucasfcosta/testing-javascript-applications)。
- en: Currently, your `knexfile` exports only a single configuration, called `development`.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，你的 `knexfile` 只导出了一个配置，称为 `development`。
- en: Listing 4.39 knexfile.js
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.39 knexfile.js
- en: '[PRE40]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This is the configuration that is used in your `dbConnection.js` file. As you
    can see in the second line of `dbConnection.js`, we use the `development` property
    of the object exported by `knexfile.js`.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你在 `dbConnection.js` 文件中使用的配置。正如你在 `dbConnection.js` 的第二行中看到的，我们使用了 `knexfile.js`
    导出的对象的 `development` 属性。
- en: Listing 4.40 dbConnection.js
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.40 dbConnection.js
- en: '[PRE41]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Because every file in your project uses `dbConnection.js` to interact with the
    database, it controls to which database your backend connects. If you change the
    database to which `dbConnection` connects, you will change the database instance
    for your entire application.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你的项目中的每个文件都使用 `dbConnection.js` 与数据库交互，它控制着你的后端连接到哪个数据库。如果你更改 `dbConnection`
    连接到的数据库，你将更改整个应用程序的数据库实例。
- en: First, create a new configuration within `knexfile` so that you can connect
    to a different database. I’d recommend calling it `"test"`.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在 `knexfile` 中创建一个新的配置，这样你就可以连接到不同的数据库。我建议将其命名为 `"test"`。
- en: Listing 4.41 knexfile.js
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.41 knexfile.js
- en: '[PRE42]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '❶ Exports an object with two properties: test and development'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导出一个具有两个属性的对象：test 和 development
- en: ❷ Defines the configurations for the test database
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 定义测试数据库的配置
- en: ❸ Defines the configurations for the development database
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 定义开发数据库的配置
- en: Now, to connect to the test database, which uses the `test.sqlite` file instead
    of `dev.sqlite`, and update the `dbConnection.js` file. Instead of using the `development`
    configuration within `knexfile.js`, use `test`.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了连接到使用 `test.sqlite` 文件而不是 `dev.sqlite` 的测试数据库，并更新 `dbConnection.js` 文件。不要在
    `knexfile.js` 中使用 `development` 配置，而使用 `test`。
- en: Listing 4.42 dbConnection.js
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.42 dbConnection.js
- en: '[PRE43]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: ❶ Extracts the test property exported by the knexfile
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从 knexfile 导出测试属性
- en: ❷ Uses the configuration for the test database to create a connection pool
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用测试数据库的配置来创建一个连接池
- en: If you try rerunning your tests, you will see that they will fail because the
    `test` database hasn’t been created.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试重新运行你的测试，你会看到它们会失败，因为 `test` 数据库还没有被创建。
- en: 'To create the `test` database—and therefore the `test.sqlite` file—run `./node_
    odules/.bin/knex migrate:latest`, passing the value `test` to the `env` option.
    This determines which environment to use when running migrations. The command
    you should run looks like this: `./node_modules/.bin/knex migrate:latest` `--env
    test`.'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建 `test` 数据库——因此是 `test.sqlite` 文件——运行 `./node_modules/.bin/knex migrate:latest`，将
    `test` 传递给 `env` 选项。这决定了运行迁移时使用哪个环境。你应该运行的命令看起来像这样：`./node_modules/.bin/knex migrate:latest
    --env test`。
- en: Once the `test` database has been created and updated, all tests should pass.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 `test` 数据库被创建和更新，所有测试都应该通过。
- en: Now that you have two different databases to which you can connect, you must
    use one for your tests and another for running the application.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有两个不同的数据库可以连接，你必须为你的测试使用一个，为运行应用程序使用另一个。
- en: To determine in which environment the application is running, we can pass it
    an environment variable and read it from within a `.js` file. To read environment
    variables, you can read the `env` property in the global `process` object.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定应用程序正在哪个环境中运行，我们可以传递一个环境变量并在 `.js` 文件中读取它。要读取环境变量，你可以读取全局 `process` 对象中的
    `env` 属性。
- en: Let’s quickly check how environment variables work. First, create a file that
    logs `process.env.EXAMPLE` to the console.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速检查环境变量是如何工作的。首先，创建一个文件，将 `process.env.EXAMPLE` 记录到控制台。
- en: Listing 4.43 example.js
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.43 example.js
- en: '[PRE44]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Now, run that file with `EXAMPLE="any` `value"` `node` `example.js`. You should
    see `any value` logged to your console.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用 `EXAMPLE="any value"` 运行该文件 `node example.js`。你应该会在你的控制台看到 `any value`
    被记录。
- en: Update your `dbConnection.js` file so that it connects to a database that we
    can specify through the `NODE_ENV` environment variable.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 更新你的 `dbConnection.js` 文件，使其能够连接到一个可以通过 `NODE_ENV` 环境变量指定的数据库。
- en: Listing 4.44 dbConnection.js
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.44 dbConnection.js
- en: '[PRE45]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: ❶ Obtains the value of the NODE_ENV environment variable
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 获取 NODE_ENV 环境变量的值
- en: ❷ Uses the value of NODE_ENV assigned to environmentName to determine which
    database configuration to pick
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用分配给 environmentName 的 NODE_ENV 环境变量的值来确定选择哪个数据库配置
- en: Now, when running your application with `NODE_ENV=development` `node` `server.js`,
    for example, it will connect to the `development` database.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你使用 `NODE_ENV=development` `node` `server.js` 运行你的应用程序时，例如，它将连接到 `development`
    数据库。
- en: To connect to the `test` database when running tests with Jest, you don’t need
    to make any changes. Jest automatically sets `NODE_ENV` to `test` and, therefore,
    will make your application connect to the `test` database when running tests.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Jest 运行测试并连接到 `test` 数据库时，你不需要做任何更改。Jest 自动将 `NODE_ENV` 设置为 `test`，因此当运行测试时，它将使你的应用程序连接到
    `test` 数据库。
- en: Maintaining a pristine state
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 维护原始状态
- en: Whenever running your tests against a database instance, you must make sure
    that it exists and that it’s up-to-date. Otherwise, your tests might not run.
    As you’ve seen when you started using a different database instance for your tests,
    they didn’t run until you executed the migration command `./node_modules/.bin/knex`
    `migrate :latest` `--env` `test`.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 每次运行测试针对数据库实例时，你必须确保它存在并且是最新的。否则，你的测试可能无法运行。正如你开始使用不同的数据库实例进行测试时所看到的，直到你执行迁移命令
    `./node_modules/.bin/knex` `migrate :latest` `--env` `test`，测试才运行。
- en: Every new developer who tries to run tests for your application will run into
    the same problem until they run the `migrate` command themselves. Every time the
    schema changes, they must remember to run the `migrate` command again. Otherwise,
    tests can fail mysteriously, and it might take others a long time to figure out
    what they must do to fix this problem.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 每个尝试运行你的应用程序测试的新开发者都会遇到相同的问题，直到他们自己运行 `migrate` 命令。每当架构发生变化时，他们都必须记得再次运行 `migrate`
    命令。否则，测试可能会神秘地失败，其他人可能需要很长时间才能弄清楚他们必须做什么来解决这个问题。
- en: To make everyone’s lives easier, you can automate the process of migrating databases.
    By ensuring that databases are up-to-date before running tests, you can use the
    global setup hook we saw in chapter 3.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让每个人的生活更轻松，你可以自动化迁移数据库的过程。通过确保在运行测试之前数据库是最新的，你可以使用我们在第 3 章中看到的全局设置钩子。
- en: NOTE You can find the complete code for this subsection inside `chapter4/3 _dealing_with_external_dependencies/3_maintaining_a_pristine_state`
    at this book’s GitHub repository, [https://github.com/lucasfcosta/testing-javascript-applications](https://github.com/lucasfcosta/testing-javascript-applications).
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你可以在本书的 GitHub 仓库 `chapter4/3 _dealing_with_external_dependencies/3_maintaining_a_pristine_state`
    中找到本小节的完整代码，[https://github.com/lucasfcosta/testing-javascript-applications](https://github.com/lucasfcosta/testing-javascript-applications)。
- en: Create a `jest.config.js` file, and specify that Jest should execute a file
    called `migrate Databases.js` before running tests, as shown next.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 `jest.config.js` 文件，并指定 Jest 在运行测试之前应该执行一个名为 `migrate Databases.js` 的文件，如下所示。
- en: Listing 4.45 jest.config.js
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.45 jest.config.js
- en: '[PRE46]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: ❶ Runs the asynchronous function exported by the migrateDatabases.js script
    once before all tests
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在所有测试之前运行 migrateDatabases.js 脚本导出的异步函数一次
- en: Within `migrateDatabases.js` you can use `knex` to run migrations.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `migrateDatabases.js` 中，你可以使用 `knex` 来运行迁移。
- en: Listing 4.46 migrateDatabases.js
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.46 migrateDatabases.js
- en: '[PRE47]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: ❶ Assigns to environmentName the value of the NODE_ENV environment variable;
    if it’s empty, assigns test
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将 NODE_ENV 环境变量的值分配给 environmentName；如果它为空，则分配 test
- en: ❷ Uses the value in environmentName to determine which database configuration
    to pick
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用 environmentName 中的值来确定选择哪个数据库配置
- en: ❸ Migrates the database to the latest state
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将数据库迁移到最新状态
- en: ❹ Closes the connection to the database so that tests won’t hang
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 关闭数据库连接，以便测试不会挂起
- en: This global hook ensures that a database with the latest schema will be available
    before any tests run.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 这个全局钩子确保在运行任何测试之前，将有一个具有最新架构的数据库可用。
- en: 'Now that you have automated creating and migrating your database, you should
    automate two other tasks: truncating—emptying—the content of every table and disconnecting
    from the database. Truncating tables ensures that tests will start from a pristine
    state and disconnecting from the database ensures that Jest won’t hang when tests
    finish.'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经自动化了创建和迁移数据库的过程，你应该自动化另外两个任务：截断（清空）每个表的内容和从数据库断开连接。截断表确保测试从原始状态开始，从数据库断开连接确保
    Jest 在测试完成后不会挂起。
- en: To configure which pieces of code Jest should execute before running each test
    file, add the `setupFilesAfterEnv` option to your `jest.config.js`. The files
    specified in `setupFilesAfterEnv` will run after Jest has been initialized and,
    therefore, have access to the global variables that Jest creates.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置 Jest 在运行每个测试文件之前应该执行哪些代码片段，请将 `setupFilesAfterEnv` 选项添加到你的 `jest.config.js`
    文件中。`setupFilesAfterEnv` 中指定的文件将在 Jest 初始化后运行，因此可以访问 Jest 创建的全局变量。
- en: Start by telling Jest to execute `truncateTables.js` before running each test
    file, as shown next.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，告诉 Jest 在运行每个测试文件之前执行 `truncateTables.js`，如下所示。
- en: Listing 4.47 jest.config.js
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.47 jest.config.js
- en: '[PRE48]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: ❶ Before each test file, runs truncateTables.js
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在每个测试文件之前运行 truncateTables.js
- en: NOTE The `<rootDir>` token indicates that Jest should resolve the file relative
    to the project’s root directory. Without specifying `<rootDir>`, Jest will resolve
    the setup file relative to each test file.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 备注：`<rootDir>` 符号表示 Jest 应该根据项目的根目录解析文件。如果不指定 `<rootDir>`，Jest 将根据每个测试文件解析设置文件。
- en: Your `truncateTables.js` file should then use the global `beforeEach` function
    to determine that tables should be truncated before each test.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你的 `truncateTables.js` 文件应该使用全局的 `beforeEach` 函数来确定在每个测试之前应该截断表格。
- en: Listing 4.48 truncateTables.js
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.48 truncateTables.js
- en: '[PRE49]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: ❶ Defines a list of tables to truncate
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义要截断的表格列表
- en: ❷ Before each test, truncates every table in the list
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在每个测试之前截断列表中的每个表格
- en: 'This global hook allows you to remove the repetitive `beforeEach` hooks to
    clean tables that you have in each test file, as follows:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 这个全局钩子允许你移除每个测试文件中重复的 `beforeEach` 钩子，以清理你拥有的表格，如下所示：
- en: '[PRE50]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Erasing data from a single place also ensures that you will not have tests failing
    because you forgot to clean one table or another. Every test is guaranteed to
    run from an empty state. When each test starts from a clean slate, they also don’t
    interfere with each other. And because you know exactly what data was available
    when each test started, you can easily track its actions when debugging.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 从单个位置擦除数据也确保你不会因为忘记清理某个表格或另一个表格而导致测试失败。每个测试都保证从空状态开始运行。当每个测试从干净的状态开始时，它们也不会相互干扰。并且因为你确切知道每个测试开始时可用的是什么数据，所以在调试时可以轻松跟踪其操作。
- en: If there is any data that needs to be kept, such as an account to which to send
    authenticated requests, you can add another script to `setupFilesAfterEnv` to
    do that, as shown here.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要保留某些数据，例如发送认证请求的账户，你可以向 `setupFilesAfterEnv` 添加另一个脚本来完成此操作，如下所示。
- en: Listing 4.49 jest.config.js
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.49 jest.config.js
- en: '[PRE51]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: ❶ Defines a list of scripts to run before each test file
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义在运行每个测试文件之前要运行的脚本列表
- en: ❷ Before each test file, runs `seedUser.js
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在每个测试文件之前运行 `seedUser.js`
- en: Again, a global setup file helped you eliminate many repetitive `beforeEach`
    hooks.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，一个全局设置文件帮助你消除了许多重复的 `beforeEach` 钩子。
- en: Go ahead and create the `seedUser.js` file that Jest should run.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 继续创建 `seedUser.js` 文件，Jest 应该运行此文件。
- en: Listing 4.50 seedUser.js
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.50 seedUser.js
- en: '[PRE52]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: ❶ Generates Base64-encoded credentials to use in the authorization header
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 生成用于授权头的 Base64 编码的凭据
- en: ❷ Attaches the user’s information to the global namespace, including the generated
    authorization header
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将用户信息附加到全局命名空间，包括生成的授权头
- en: ❸ Seeds the database with the test user before each test
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在每个测试之前用测试用户填充数据库
- en: Once you have made Jest create a user before each test, update all of your tests
    so that they access `global._tests.user` instead of having to create and fetch
    users themselves.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你让 Jest 在每个测试之前创建一个用户，更新所有测试，以便它们访问 `global._tests.user` 而不是必须自己创建和检索用户。
- en: Important For the sake of keeping this example short, I have used the `global`
    state to store data. You must be extremely careful when setting global data. A
    better alternative would be to create a separate module that can create a user
    and export it. Then, in your tests, instead of accessing `global`, you could import
    the `user` from that file. You can find an example of how to do that in this book’s
    GitHub repository.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 重要：为了使这个示例简短，我使用了 `global` 状态来存储数据。在设置全局数据时，你必须非常小心。更好的替代方案是创建一个可以创建用户并导出的单独模块。然后，在你的测试中，你可以在不访问
    `global` 的情况下从该文件导入 `user`。你可以在本书的 GitHub 仓库中找到一个如何做到这一点的示例。
- en: This baseline state you have just created for your tests is formally called
    a *fixture*. A fixture can be an initial database state, as you’ve done, or it
    can involve creating files or setting up a third-party dependency. In fact, if
    we take the term *fixture* to the letter, even your `before` and `beforeEach`
    hooks that prepare the tests to run can be considered fixtures.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 你为测试刚刚创建的基准状态正式称为*固定基准场景*。固定基准场景可以是初始数据库状态，就像你做的，也可以涉及创建文件或设置第三方依赖项。事实上，如果我们字面地理解*固定基准场景*这个术语，甚至你的`before`和`beforeEach`钩子，这些准备测试运行的钩子也可以被认为是固定基准场景。
- en: Fixture A fixture is a baseline scenario set up for tests. Fixtures guarantee
    that tests can run and produce repeatable results.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 固定基准场景：固定基准场景是为测试设置的基准场景。固定基准场景确保测试可以运行并产生可重复的结果。
- en: 'At the moment, there is still one repetitive hook that we can get rid of: the
    one that ensures that every test disconnects from the database. Thanks to this
    hook being present in all files, Jest doesn’t hang once the tests finish.'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们仍然可以消除一个重复的钩子：确保每个测试从数据库断开连接的那个钩子。多亏了这个钩子在所有文件中都存在，一旦测试完成，Jest就不会挂起。
- en: '[PRE53]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: ❶ After all tests, closes the connection to the database so that tests won’t
    hang
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在所有测试完成后，关闭数据库连接，以确保测试不会挂起
- en: Even though the `setupFilesAfterEnv` scripts run before test files, you can
    use them to set up `afterEach` or `afterAll` hooks, too.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 即使`setupFilesAfterEnv`脚本在测试文件之前运行，你也可以使用它们来设置`afterEach`或`afterAll`钩子。
- en: Create a `disconnectFromDb.js` file, and add an `afterAll` hook that calls `db.destroy`,
    as shown next.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`disconnectFromDb.js`文件，并添加一个调用`db.destroy`的`afterAll`钩子，如下所示。
- en: Listing 4.51 disconnectFromDb.js
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.51 disconnectFromDb.js
- en: '[PRE54]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Now that you’re done with all of your `setupFilesAfterEnv` hooks, make sure
    that your `jest.config.js` is up-to-date using the following code.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经完成了所有的`setupFilesAfterEnv`钩子，请确保使用以下代码更新你的`jest.config.js`。
- en: Listing 4.52 jest.config.js
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.52 jest.config.js
- en: '[PRE55]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: When dealing with backend applications, keeping the state clean can be tricky.
    As we’ve seen, introducing a third-party dependency like a database can add extra
    complexity to your tests. You have to worry about not only your code but also
    the state and setup process involved with each dependency.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理后端应用程序时，保持状态清洁可能很棘手。正如我们所见，引入第三方依赖项（如数据库）可以为你的测试添加额外的复杂性。你必须担心你的代码，以及每个依赖项涉及的状态和设置过程。
- en: Whenever possible, try to centralize the pieces of code you use to manage those
    dependencies, be it in a global setup file, in a global hook, or even in other
    utility scripts, as we’ve seen in this section. Modular tests, just like modular
    code, make changes quicker and easier because they require you to update fewer
    places at a time.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，尽量将用于管理这些依赖项的代码片段集中起来，无论是全局设置文件、全局钩子，还是其他实用脚本，就像我们在本节中看到的那样。模块化测试，就像模块化代码一样，使更改更快、更容易，因为它们要求你同时更新的地方更少。
- en: 4.3.2 Integrations with other APIs
  id: totrans-498
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.2 与其他API的集成
- en: Besides selling London’s sweetest desserts, Louis’s bakery also sells baking
    ingredients. Louis noticed that recently there’s been a surge in the number of
    people baking bread loaves of their own, so he decided to jump on the trend and
    make some profit to reinvest in his business.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 除了销售伦敦最甜美的甜点外，路易斯的面包店还出售烘焙原料。路易斯注意到最近越来越多的人开始自己烘焙面包，所以他决定抓住这个趋势，从中获利，并将利润再投资到他的生意中。
- en: To make customers more likely to buy baking ingredients, he thought it would
    be a good idea to include suggestions of recipes in each ingredient’s page. Unfortunately,
    his development team—you—doesn’t have the time or the resources to put together
    a list of recipes for each of the dozens of items the bakery sells.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让客户更有可能购买烘焙原料，他认为在每个原料页面上包含食谱建议是个好主意。不幸的是，你的开发团队——你——没有时间或资源为面包店销售的数十种物品中的每一种都整理一份食谱列表。
- en: Instead of creating this list of recipes yourself, you can use a third-party
    recipe API to extend your application.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以不自己创建这份食谱列表，而是使用第三方食谱API来扩展你的应用程序。
- en: First, create a route that allows clients to obtain the details of an inventory
    item, as shown here.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个路由，允许客户端获取库存项的详细信息，如下所示。
- en: Listing 4.53 server.js
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.53 server.js
- en: '[PRE56]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: ❶ Responds to GET requests sent to /inventory/:itemName with the item’s information
    found in the inventory table
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 响应发送到/inventory/:itemName的GET请求，返回库存表中找到的物品信息
- en: To test this route, we can seed the inventory with an item, send a request to
    it, and check the application’s response.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试这个路由，我们可以向库存中添加一个物品，向它发送请求，并检查应用程序的响应。
- en: Listing 4.54 server.test.js
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.54 server.test.js
- en: '[PRE57]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: ❶ Inserts three eggs and an apple pie in the inventory
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在库存中添加三个鸡蛋和一个苹果派
- en: ❷ Sends a GET request to /inventory/eggs, and expects the response’s body to
    include the item’s ID, name, and the quantity available
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 向/inventory/eggs发送GET请求，并期望响应体包含项目的ID、名称和可用数量
- en: Now let’s make the application fetch recipes from a third-party API over HTTP.
    In these examples, I will use the Recipe Puppy API, whose documentation you can
    find at [http://www.recipepuppy.com/about/api](http://www.recipepuppy.com/about/api).
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们让应用程序通过HTTP从第三方API获取食谱。在这些示例中，我将使用Recipe Puppy API，其文档可以在[http://www.recipepuppy.com/about/api](http://www.recipepuppy.com/about/api)找到。
- en: Try sending a `GET` request to `http://www.recipepuppy.com/api?i=eggs` to obtain
    a list of results involving eggs, for example. Pay attention to the response’s
    format so that you can use it within your new route.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试发送一个`GET`请求到`http://www.recipepuppy.com/api?i=eggs`以获取涉及鸡蛋的结果列表，例如。注意响应的格式，以便你可以在新的路由中使用它。
- en: Install the `isomorphic-fetch` package, and proceed to make your route perform
    an HTTP call to the Recipe Puppy API. You will then attach part of this request’s
    response to the returned object, as shown here.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 安装`isomorphic-fetch`包，然后让你的路由执行对Recipe Puppy API的HTTP调用。然后，将此请求响应的一部分附加到返回的对象中，如下所示。
- en: Listing 4.55 server.js
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.55 server.js
- en: '[PRE58]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: ❶ Sends a request to the Recipe Puppy API
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 向Recipe Puppy API发送请求
- en: ❷ Finds the item in the database
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在数据库中找到该项目
- en: ❸ Responds with the item’s details, the recipes fetched from the Recipe Puppy
    API, and a message informing about the data’s origin
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 响应包含项目的详细信息、从Recipe Puppy API获取的食谱以及关于数据来源的消息
- en: To make your test pass after this change, let’s make it perform an identical
    request to the Recipe Puppy API and use its response to verify what your application
    returned.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在这次更改后使测试通过，让我们让它执行对Recipe Puppy API的相同请求，并使用其响应来验证你的应用程序返回的内容。
- en: Listing 4.56 server.test.js
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.56 server.test.js
- en: '[PRE59]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: ❶ Sends a request to the Recipe Puppy API to obtain recipes with egg
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 向Recipe Puppy API发送请求以获取包含鸡蛋的食谱
- en: ❷ Sends a GET request to your own server’s /inventory/eggs route, and expects
    it to succeed
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 向你自己的服务器的/inventory/eggs路由发送GET请求，并期望它成功
- en: ❸ Expects your own server’s response to include the item’s information, a message
    about the data’s origin, and the same recipes that you previously fetched from
    the Recipe Puppy API in your tests
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 期望你自己的服务器的响应包含项目信息、关于数据来源的消息以及你在测试中之前从Recipe Puppy API获取的相同食谱
- en: The previous test will pass, but this approach contains several flaws.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的测试将通过，但这种方法存在几个缺陷。
- en: Many APIs will charge you for requests and limit the number of requests to which
    they will respond over a time window. If you are using an API to send SMS messages
    to your users, for example, it is likely to charge you for the messages it sends.
    Because even free APIs have costs associated with maintaining them, they are likely
    to limit the number of requests you can send if you are not a paying customer.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 许多API会根据请求次数向你收费，并在一定时间窗口内限制它们将响应的请求数量。例如，如果你使用API向用户发送短信，它可能会对你发送的消息收费。因为即使是免费的API也有维护成本，如果你不是付费客户，它们可能会限制你可以发送的请求数量。
- en: If both your tests and your application have to send real requests to a third-party
    API, your costs can easily skyrocket. Tests should run frequently, and, if you
    have to pay each time you run a test, they will become costly, and developers
    will be incentivized to run them less often.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你和你的应用程序都必须向第三方API发送真实请求，你的成本可能会轻易飙升。测试应该频繁运行，如果你每次运行测试都要付费，它们将变得昂贵，开发者将受到激励减少运行它们的频率。
- en: If you need to be authenticated to send requests to an API, it can also be tricky
    to manage its access tokens. You will need every developer to have those tokens
    saved in their machines. Managing credentials in this way can be troublesome and
    add overhead to the testing process because people will have to ask others about
    credentials or manually generate credentials themselves.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要通过身份验证才能向API发送请求，管理其访问令牌也可能很棘手。你需要确保每个开发者都将这些令牌保存在他们的机器上。以这种方式管理凭证可能会很麻烦，并给测试过程增加开销，因为人们将不得不询问他人凭证信息或手动生成凭证。
- en: The extra effort required to run tests can add to the cost of maintaining your
    application because people will have to spend more time setting up an environment
    or, if you’re dealing with paid APIs, paying to obtain tokens—and that’s not even
    considering the security risks of passing credentials around.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试所需的额外努力可能会增加维护应用程序的成本，因为人们需要花费更多的时间来设置环境，如果你正在处理付费API，还需要支付获取令牌的费用——这还不包括在传递凭证时的安全风险。
- en: If your application has to make requests to third-party APIs, its tests will
    run only when there’s an internet connection available. Networking problems can
    make tests fail even though the code is correct.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序需要向第三方API发起请求，它的测试只有在有可用互联网连接的情况下才会运行。网络问题可能会导致测试失败，即使代码是正确的。
- en: Finally, by testing against real APIs, it can be hard to simulate error scenarios.
    How will you check, for example, whether your application behaves appropriately
    when the third-party API is unavailable?
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过测试真实API，模拟错误场景可能会很困难。例如，你将如何检查当第三方API不可用时，你的应用程序是否表现适当？
- en: An excellent solution to these problems is to avoid making requests altogether
    but still checking whether your application has tried to make them.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 避免发出请求 altogether 但仍然检查你的应用程序是否尝试过发出请求，这是解决这些问题的绝佳方案。
- en: Given what we’ve already covered, probably the first solution that comes to
    your mind is to mock the `fetch` package yourself. Instead of using the “real”
    fetch function, you’d use a stub and then check whether it was called with the
    correct arguments. That stub would also resolve with the adequate response for
    your tests to proceed.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们之前已经讨论的内容，可能第一个出现在你脑海中的解决方案是自行模拟`fetch`包。你将不会使用“真实”的fetch函数，而是使用存根，然后检查它是否以正确的参数被调用。这个存根也会解析为适当的响应，以便测试可以继续进行。
- en: Try that, and see how it goes. First, as shown here, add a call to `jest.mock`
    to the top of your test file, and make it create a mock for `isomorphic-fetch`.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试这样做，看看效果如何。首先，如这里所示，在测试文件顶部添加对`jest.mock`的调用，并使其创建一个`isomorphic-fetch`的模拟。
- en: Listing 4.57 server.test.js
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.57 server.test.js
- en: '[PRE60]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: ❶ Causes imports to isomorphic-fetch to resolve to a Jest mock
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使导入isomorphic-fetch解析为Jest模拟
- en: After this call to `jest.mock`, the `isomorphic-fetch` import in your tests
    will resolve to the mock.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`jest.mock`之后，你的测试中的`isomorphic-fetch`导入将解析为模拟。
- en: 'Now you need to mock the `fetch` function in your tests and make it resolve
    with a hardcoded response. To be able to simulate a fake response, you need to
    look closely at the following ways the application expects `isomorphic-fetch`
    to behave:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你需要在测试中模拟`fetch`函数，并使其解析为一个硬编码的响应。为了能够模拟一个假响应，你需要仔细查看以下应用期望`isomorphic-fetch`如何表现的方式：
- en: The `fetch` function returns a promise, which resolves with an object.
  id: totrans-540
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`fetch`函数返回一个promise，该promise解析为一个对象。'
- en: Once the `fetch` function’s promise has resolved, you call its `json` method.
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦`fetch`函数的promise解析完成，你将调用它的`json`方法。
- en: The `json` method returns a promise, which will resolve to an object containing
    the response’s body.
  id: totrans-542
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`json`方法返回一个promise，该promise将解析为包含响应体的对象。'
- en: Go ahead and make the mock shown next for `isomorphic-fetch` to simulate the
    behavior I just described.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 现在继续为`isomorphic-fetch`创建一个模拟，以模拟我刚才描述的行为。
- en: Listing 4.58 server.test.js
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.58 server.test.js
- en: '[PRE61]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: ❶ Defines a static object that mimics a response from the Recipe Puppy API
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义一个静态对象，模拟Recipe Puppy API的响应
- en: ❷ Causes the fetch function from isomorphic-fetch to always resolve to the static
    object defined in the test
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使isomorphic-fetch的fetch函数始终解析为测试中定义的静态对象
- en: ❸ Sends a GET request to your own server’s /inventory/eggs route, and expects
    it to succeed
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 向你的服务器/inventory/eggs路由发送GET请求，并期望它成功
- en: ❹ Checks your server’s response. This assertion expects the response to include
    the item’s information found in the database and uses the static data specified
    earlier in the test to validate the other fields.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 检查服务器的响应。这个断言期望响应中包含数据库中找到的项目信息，并使用测试中之前指定的静态数据来验证其他字段。
- en: This mock will cause the application under test to get the `fakeApiResponse`
    you have defined instead of making an actual HTTP request.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模拟将导致正在测试的应用程序获取你定义的`fakeApiResponse`，而不是进行实际的HTTP请求。
- en: The test you’ve written still doesn’t check the request’s target URL, which
    means that this test would pass even if the application is sending requests to
    the wrong place.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 你编写的测试仍然没有检查请求的目标URL，这意味着即使应用程序正在向错误的地方发送请求，这个测试也会通过。
- en: To ensure your API is sending the requests to the correct URLs, you can check
    whether `fetch` was called with the expected arguments, as shown here.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保你的API正在将请求发送到正确的URL，你可以检查`fetch`是否以预期的参数被调用，如下所示。
- en: Listing 4.59 server.test.js
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.59 server.test.js
- en: '[PRE62]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: ❶ Causes the fetch function from isomorphic-fetch to always resolve to the static
    object defined earlier in the test
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使isomorphic-fetch的fetch函数始终解析到测试中之前定义的静态对象
- en: ❷ Sends a GET request to your own server’s /inventory/eggs route, and expects
    it to succeed
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 向你自己的服务器的/inventory/eggs路由发送GET请求，并期望它成功
- en: ❸ Expects the fetch function from isomorphic-fetch to have been called once
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 期望isomorphic-fetch的fetch函数被调用了一次
- en: ❹ Checks whether the first call to fetch used the expected URL
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 检查第一次调用fetch是否使用了预期的URL
- en: Alternatively, to avoid asserting on the arguments passed to `fetch`, you can
    restrict the values to which it responds. If, for example, you make the `fetch`
    return a successful response only when the correct URL is passed, you can avoid
    asserting on the URL itself.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，为了避免对传递给`fetch`的参数进行断言，你可以限制它响应的值。例如，如果你让`fetch`仅在传递正确的URL时返回成功的响应，你就可以避免对URL本身进行断言。
- en: TIP You can avoid accessing the test double’s internal properties in your tests
    by using specific assertions for them.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：你可以通过使用针对它们的特定断言来避免在测试中访问测试替身的内部属性。
- en: To check if a test double has been called once, for example, you could use `expect(testDouble).toHaveBeenCalled()`.
    If you’d like to assert on a call’s argument, you can use `expect(testDouble).toHaveBeenCalledWith(arg1,
    arg2, ...)`.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要检查一个测试替身是否被调用了一次，你可以使用`expect(testDouble).toHaveBeenCalled()`。如果你想断言一个调用的参数，你可以使用`expect(testDouble).toHaveBeenCalledWith(arg1,
    arg2, ...)`.
- en: For defining different responses depending on the arguments given to a mock,
    you can use the `jest-when` package, as shown in the next listing. This package
    makes it easier to determine what a mock should do according to the input it’s
    given.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 为了根据传递给模拟的参数定义不同的响应，你可以使用`jest-when`包，如下一个列表所示。这个包使得根据输入确定模拟应该做什么变得更加容易。
- en: Listing 4.60 server.test.js
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.60 server.test.js
- en: '[PRE63]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: ❶ Causes the fetch function from isomorphic-fetch to be rejected
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使isomorphic-fetch的fetch函数被拒绝
- en: ❷ Causes the fetch function from isomorphic-fetch to resolve to the static object
    defined earlier in the test only when called with the correct URL
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 当使用正确的URL调用时，仅使isomorphic-fetch的fetch函数解析到测试中之前定义的静态对象
- en: The problem with manually setting up mocks is that, as you’ve seen, you must
    strictly replicate what your application expects the HTTP request library to do.
    Using mocks to replicate complex behavior makes tests too tightly coupled to your
    application and, therefore, increases maintenance costs, because you will have
    to update them more often, even when the application still works.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 手动设置模拟的问题在于，正如你所看到的，你必须严格复制你的应用程序期望HTTP请求库执行的操作。使用模拟来复制复杂的行为会使测试与你的应用程序紧密耦合，因此增加了维护成本，因为你将不得不更频繁地更新它们，即使应用程序仍然可以正常工作。
- en: Mocking can be a fantastic solution when you’re interacting with applications
    over other protocols, like `MQTT` or `CoAP`, but, for HTTP, you can use a module
    called `nock`.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 当你与其他协议（如`MQTT`或`CoAP`）交互时，模拟可以是一个绝佳的解决方案，但对于HTTP，你可以使用名为`nock`的模块。
- en: Instead of requiring you to determine the sender library’s behavior, as the
    previous mocks did, **`nock` requires you to determine the server’s response**.
    By using `nock`, your tests won’t rely on the behavior of the library you’re using
    to make requests. Because you will mock the server’s response, your tests will
    be more loosely coupled and, therefore, cheaper.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的模拟不同，**`nock`要求你确定服务器的响应**，而不是要求你确定发送库的行为。通过使用`nock`，你的测试不会依赖于你用来发送请求的库的行为。因为你将模拟服务器的响应，所以你的测试将更加松散耦合，因此成本更低。
- en: Install `nock` as a dev dependency so that you can use it in your tests. The
    `nock` package will let you specify the status and the response for a particular
    HTTP verb, domain, path, and query string.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 将`nock`作为开发依赖项安装，这样你就可以在测试中使用它。`nock`包将允许你指定特定HTTP动词、域名、路径和查询字符串的状态和响应。
- en: Listing 4.61 server.test.js
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.61 server.test.js
- en: '[PRE64]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: ❶ Ensures that no mocks will persist from one test to another
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 确保没有模拟会从一个测试持续到另一个测试
- en: ❷ Causes requests sent to the Recipe Puppy API’s /api endpoint to resolve with
    the static object defined earlier in the test. This interceptor will be triggered
    only when the query string’s i property’s value is eggs.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 当向Recipe Puppy API的/api端点发送请求时，如果查询字符串的i属性值为eggs，则此拦截器将被触发，并且请求将解析为测试中之前定义的静态对象。
- en: ❸ Sends a GET request to your own server’s /inventory/eggs route, and expects
    it to succeed
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 向您自己的服务器的/inventory/eggs路由发送GET请求，并期望其成功。
- en: ❹ Checks your server’s response. This assertion expects the response to include
    the item’s information found in the database and uses the static data with which
    the nock interceptor responds.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 检查服务器的响应。此断言期望响应包含数据库中找到的项目信息，并使用nock拦截器响应的静态数据。
- en: With `nock` you won’t need to manually write assertions to check whether the
    `fetch` function sent requests to other inappropriate endpoints. Any requests
    sent to URLs other than the ones you mocked with `nock` will cause the test to
    fail.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`nock`，您不需要手动编写断言来检查`fetch`函数是否向其他不适当的端点发送了请求。发送到除您使用`nock`模拟的URL之外的其他URL的请求将导致测试失败。
- en: NOTE Every time an HTTP request hits an endpoint, `nock` will destroy the interceptor
    that handled the request. Because that interceptor will no longer be active, the
    next request will hit either the next matching interceptor or no interceptors
    at all.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：每次HTTP请求击中端点时，`nock`将销毁处理该请求的拦截器。因为该拦截器将不再活跃，下一个请求将击中下一个匹配的拦截器或根本没有任何拦截器。
- en: To avoid removing an interceptor once its been used, you must call `nock`’s
    `.persist` method when setting it up.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在使用后删除拦截器，您必须在设置拦截器时调用`nock`的`.persist`方法。
- en: Finally, instead of writing an assertion for each mocked endpoint to ensure
    that it received a request, you can use `nock.isDone` to check all endpoints at
    once. If `nock.isDone` returns `false`, it means that one or more mocked routes
    weren’t hit.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以使用`nock.isDone`来检查所有端点，而不是为每个模拟端点编写断言以确保它收到了请求。如果`nock.isDone`返回`false`，则意味着一个或多个模拟路由没有被击中。
- en: Add an `afterEach` hook that uses `nock.isDone` to your test file, as shown
    next, to guarantee that all the routes you mock will have been hit after each
    test.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的测试文件中添加一个`afterEach`钩子，使用`nock.isDone`，如下所示，以确保在每次测试之后所有模拟的路由都被击中。
- en: Listing 4.62 server.test.js
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.62 server.test.js
- en: '[PRE65]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: ❶ Before each test, if not all interceptors have been reached, removes all interceptors
    and throws an error. Clearing unused interceptors will prevent further tests from
    failing due to old interceptors being triggered.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在每个测试之前，如果并非所有拦截器都已到达，则删除所有拦截器并抛出错误。清除未使用的拦截器将防止进一步的测试因旧拦截器被触发而失败。
- en: There’s much more you can do with `nock`. You can, for example, mock endpoints
    using regular expressions and use functions to match a request’s body and even
    its headers. You can find its complete documentation at [https://github.com/nock/nock](https://github.com/nock/nock).
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`nock`做更多的事情。例如，您可以使用正则表达式模拟端点，并使用函数来匹配请求的主体，甚至其头部。您可以在[https://github.com/nock/nock](https://github.com/nock/nock)找到其完整的文档。
- en: NOTE `nock` works nicely with almost any HTTP request library because it overrides
    Node.js’s `http.request` and `http.ClientRequest` functions, which are the functions
    those libraries use behind the scenes.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：`nock`与几乎任何HTTP请求库都配合得很好，因为它覆盖了Node.js的`http.request`和`http.ClientRequest`函数，这些库在幕后使用这些函数。
- en: In the previous code snippet in which we use `nock`, if you replace `isomorphic-fetch`
    with a package like `request`, for example, your tests will continue to work.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前使用`nock`的代码片段中，如果您将`isomorphic-fetch`替换为`request`之类的包，例如，您的测试将继续工作。
- en: By removing the complexity of dealing with requests over the network, you can
    guarantee that your tests will work offline, won’t require authentication tokens,
    and won’t consume your precious resources or reach third-parties rate limits.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 通过移除处理网络请求的复杂性，您可以保证测试将在离线状态下工作，不需要身份验证令牌，并且不会消耗您宝贵的资源或达到第三方速率限制。
- en: In these examples, we’ve used a simple API to demonstrate how to mock requests.
    Now, try using a more complex API like Mailgun or Twilio, and use the techniques
    you’ve learned in this section when writing your tests.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些示例中，我们使用了一个简单的API来演示如何模拟请求。现在，尝试使用更复杂的API，如Mailgun或Twilio，并在编写测试时使用本节中学到的技术。
- en: Summary
  id: totrans-590
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: For an application to be testable, you must design it with testing in mind.
    It needs to be made of small separate pieces, which can be exposed and tested
    separately.
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了使应用程序可测试，你必须设计时考虑到测试。它需要由小的独立部分组成，这些部分可以单独暴露和测试。
- en: Tests must have access to the functions they need to execute and the output
    they need to check. It’s not a problem to expose a particular piece of code just
    so that you can test it. If that output is a global piece of state, you must expose
    it to your tests. If it’s a database, the test must have access to it.
  id: totrans-592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试必须能够访问它们需要执行的功能和它们需要检查的输出。仅为了测试而暴露特定的代码块并不是问题。如果该输出是一个全局状态，你必须将其暴露给测试。如果它是一个数据库，测试必须能够访问它。
- en: The same principles we’ve seen when talking about the testing pyramid also apply
    to backend applications. You should subdivide your tests into end-to-end tests,
    which send requests to your routes; integration tests, which directly invoke functions
    that interact with various parts of your software; and unit tests, which involve
    functions in isolation.
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在讨论测试金字塔时看到的相同原则也适用于后端应用程序。你应该将你的测试细分为端到端测试，这些测试向你的路由发送请求；集成测试，这些测试直接调用与软件的各个部分交互的功能；以及单元测试，这些测试涉及独立的功能。
- en: To ease testing HTTP endpoints and avoid bloat, you can use `supertest`, which
    bundles together a flexible API for performing requests and asserting on their
    content. With `supertest`, you can avoid performing complicated and repetitive
    assertions, and you won’t have to write your own wrappers on top of HTTP request
    libraries.
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了简化测试HTTP端点并避免冗余，你可以使用`supertest`，它捆绑了一个灵活的API，用于执行请求并对其内容进行断言。使用`supertest`，你可以避免执行复杂和重复的断言，并且你不需要在HTTP请求库之上编写自己的包装器。
- en: When dealing with databases, your testing pipeline must ensure that they will
    be available. By using global setup and teardown scripts, you can guarantee that
    their schema will be up-to-date and that the necessary seed data will be present.
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当处理数据库时，你的测试管道必须确保它们将可用。通过使用全局设置和清理脚本，你可以保证它们的模式将是最新的，并且必要的种子数据将存在。
