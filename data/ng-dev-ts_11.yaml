- en: Chapter 12\. Interacting with servers using HTTP
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第12章\. 使用HTTP与服务器交互
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Working with the HttpClient service
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HttpClient服务工作
- en: Creating a simple web server using the Node and Express frameworks
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Node和Express框架创建简单的网络服务器
- en: Developing an Angular client that communicates with the Node server
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发与Node服务器通信的Angular客户端
- en: Intercepting HTTP requests and responses
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拦截HTTP请求和响应
- en: Angular applications can communicate with any web server supporting HTTP, regardless
    of what server-side platform is used. In this chapter, we’ll show you how to use
    the `HttpClient` service offered by Angular. You’ll see how to make HTTP GET and
    POST methods with `HttpClient`. And you’ll learn how to intercept HTTP requests
    to implement cross-cutting concerns, such as global error handling.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Angular应用程序可以与任何支持HTTP的网络服务器通信，无论使用什么服务器端平台。在本章中，我们将向你展示如何使用Angular提供的`HttpClient`服务。你将了解如何使用`HttpClient`进行HTTP
    GET和POST方法。你还将学习如何拦截HTTP请求以实现跨切面关注点，例如全局错误处理。
- en: This chapter starts with a brief overview of Angular’s `HttpClient` service,
    and then you’ll create a web server using the Node.js and Express.js frameworks.
    The server will serve the data required for most code samples in this chapter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先简要概述Angular的`HttpClient`服务，然后你将使用Node.js和Express.js框架创建一个网络服务器。该服务器将提供本章大多数代码示例所需的数据。
- en: Finally, you’ll see how to implement HTTP interceptors and report progress while
    transferring large assets.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将了解如何实现HTTP拦截器并在传输大型资产时报告进度。
- en: 12.1\. Overview of the HttpClient service
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1\. HttpClient服务概述
- en: 'Browser-based web apps run HTTP requests asynchronously, so the UI remains
    responsive, and the user can continue working with the application while HTTP
    requests are being processed by the server. Asynchronous HTTP requests can be
    implemented using callbacks, promises, or observables. Although promises allow
    you to move away from callback hell (see [section A.12.2](kindle_split_025.xhtml#app01lev2sec14)
    in [appendix A](kindle_split_025.xhtml#app01)), they have the following shortcomings:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 基于浏览器的网络应用异步运行HTTP请求，因此用户界面保持响应，用户可以在服务器处理HTTP请求的同时继续使用应用程序。异步HTTP请求可以使用回调、承诺或观察者来实现。尽管承诺可以帮助你摆脱回调地狱（参见[附录A的A.12.2节](kindle_split_025.xhtml#app01lev2sec14)），但它有以下缺点：
- en: There’s no way to cancel a pending request made with a promise.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用承诺发出的挂起请求无法取消。
- en: When a promise resolves or rejects, the client receives either data or an error
    message, but in both cases it’ll be a single piece of data. A JavaScript promise
    doesn’t offer a way to handle a continuous stream of data chunks delivered over
    time.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当承诺解决或拒绝时，客户端将收到数据或错误消息，但在两种情况下都将是单一的数据块。JavaScript承诺不提供处理随时间分块连续交付的数据流的方法。
- en: Observables don’t have these shortcomings. In [section 6.4](kindle_split_015.xhtml#ch06lev1sec4)
    in [chapter 6](kindle_split_015.xhtml#ch06), we demonstrated how you can cancel
    HTTP requests made with observables, and in [chapter 13](kindle_split_022.xhtml#ch13),
    you’ll see how a server can push a stream of data to the client using WebSockets.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者没有这些缺点。在第6章的[6.4节](kindle_split_015.xhtml#ch06lev1sec4)中，我们演示了如何取消使用观察者发出的HTTP请求，在第13章中，你将了解服务器如何使用WebSockets向客户端推送数据流。
- en: Angular supports HTTP communications via the `HttpClient` service from the `@angular/common/http`
    package. If your app requires HTTP communications, you need to add `HttpClientModule`
    to the `imports` section of the `@NgModule()` decorator.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Angular通过`HttpClient`服务支持HTTP通信，该服务来自`@angular/common/http`包。如果你的应用程序需要HTTP通信，你需要将`HttpClientModule`添加到`@NgModule()`装饰器的`imports`部分。
- en: If you peek inside the type definition file @angular/common/http/src/client.d.ts,
    you’ll see that `get()`, `post()`, `put()`, `delete()`, and many other methods
    return an `Observable`, and an app needs to subscribe to get the data. To use
    the `HttpClient` service, you need to inject it into a service or component.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看类型定义文件@angular/common/http/src/client.d.ts，你会看到`get()`、`post()`、`put()`、`delete()`以及许多其他方法返回一个`Observable`，应用程序需要订阅以获取数据。要使用`HttpClient`服务，你需要将其注入到服务或组件中。
- en: '|  |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-17
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: As explained in [chapter 5](kindle_split_014.xhtml#ch05), every injectable service
    requires a provider declaration. The providers for `HttpClient` are declared in
    `HttpClientModule`, so you don’t need to declare them in your app.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [第 5 章](kindle_split_014.xhtml#ch05) 所述，每个可注入的服务都需要一个提供者声明。`HttpClient` 的提供者声明在
    `HttpClientModule` 中，因此你不需要在你的应用程序中声明它们。
- en: '|  |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The following listing illustrates one way of invoking the `get()` method of
    the `HttpClient` service, passing a URL as a `string`. You retrieve products of
    type `Product` here.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了调用 `HttpClient` 服务的 `get()` 方式的一种方法，传递一个 URL 作为 `string`。在这里，你检索的是类型为
    `Product` 的产品。
- en: Listing 12.1\. Making an HTTP GET request
  id: totrans-21
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.1\. 发送 HTTP GET 请求
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '***1* Defines the type Product**'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 定义 Product 类型**'
- en: '***2* Injects the HttpClient service**'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 注入 HttpClient 服务**'
- en: '***3* Declares a get() request**'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 声明 get() 请求**'
- en: '***4* Subscribes to the result of get()**'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 订阅 get() 的结果**'
- en: '***5* Logs an error, if any**'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 如果有错误，则记录错误**'
- en: In the `get()` method, you haven’t specified the full URL (such as http://localhost:8000/product)
    assuming that the Angular app makes a request to the same server where it was
    deployed, so the base portion of the URL can be omitted. Note that in `get<Product>()`,
    you use TypeScript generics (see [section B.9](kindle_split_026.xhtml#app02lev1sec9)
    in [appendix B](kindle_split_026.xhtml#app02)) to specify the type of data expected
    in the body of the HTTP response. The type annotation doesn’t enforce or validate
    the shape of the data returned by the server; it just makes the other code aware
    of the expected server response. By default, the response type is `any`, and the
    TypeScript compiler won’t be able to type-check the properties you access on the
    returned object.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `get()` 方法中，你没有指定完整的 URL（例如 http://localhost:8000/product），假设 Angular 应用请求的是它部署在同一服务器上的服务器，因此可以省略
    URL 的基本部分。请注意，在 `get<Product>()` 中，你使用了 TypeScript 泛型（参见 [附录 B 中的 B.9 节](kindle_split_026.xhtml#app02lev1sec9)），以指定
    HTTP 响应体中预期的数据类型。类型注解不会强制或验证服务器返回的数据形状；它只是让其他代码知道预期的服务器响应。默认情况下，响应类型是 `any`，TypeScript
    编译器将无法对返回对象上访问的属性进行类型检查。
- en: Your `subscribe()` method receives and prints the data on the browser’s console.
    By default, `HttpClient` expects the data in JSON format, and the data is automatically
    converted into JavaScript objects. If you expect non-JSON data, use the `responseType`
    option. For example, you can read arbitrary text from a file as shown in the following
    listing.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 `subscribe()` 方法接收并打印浏览器控制台中的数据。默认情况下，`HttpClient` 预期数据为 JSON 格式，数据会自动转换为
    JavaScript 对象。如果你期望非 JSON 数据，请使用 `responseType` 选项。例如，你可以像以下列表所示从文件中读取任意文本。
- en: Listing 12.2\. Specifying string as a returned data type
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.2\. 指定返回数据类型为字符串
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '***1* Specifies string as a response body type**'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 指定响应体类型为字符串**'
- en: '***2* Assigns the received data to a variable**'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将接收到的数据分配给一个变量**'
- en: '***3* Logs errors, if any**'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 如果有错误，则记录错误**'
- en: '|  |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: The `post()`, `put()`, and `delete()` methods are used in a fashion similar
    to [listing 12.2](#ch12ex02) by invoking one of these methods and subscribing
    to the results.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`post()`, `put()`, 和 `delete()` 方法的使用方式类似于 [列表 12.2](#ch12ex02)，通过调用这些方法之一并订阅结果来实现。'
- en: '|  |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Now let’s create an app that reads some data from a JSON file.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个应用程序，从 JSON 文件中读取一些数据。
- en: 12.2\. Reading a JSON file with HttpClient
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2\. 使用 HttpClient 读取 JSON 文件
- en: To illustrate `HttpClient.get()`, your app will read a file containing JSON-formatted
    product data. Create a new folder that contains the products.json file shown in
    the following listing.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明 `HttpClient.get()`，你的应用程序将读取包含 JSON 格式产品数据的文件。创建一个包含以下列表中所示 products.json
    文件的新文件夹。
- en: Listing 12.3\. The file data/products.json
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.3\. 文件数据/products.json
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The folder data and the products.json file become assets of your app that need
    to be included in the project bundles, so you’ll add this folder to the app’s
    `assets` property in the .angular-cli.json file (or angular.json, starting from
    Angular 6), as shown in the next listing.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 文件夹 data 和 products.json 文件成为你的应用程序的资产，需要包含在项目包中，因此你需要在 .angular-cli.json 文件（或从
    Angular 6 开始的 angular.json）中的应用程序的 `assets` 属性中添加此文件夹，如下一个列表所示。
- en: Listing 12.4\. A fragment from .angular-cli.json
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.4\. .angular-cli.json 的片段
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1* The name of the default assets folder generated by Angular CLI**'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 由 Angular CLI 生成的默认资产文件夹的名称**'
- en: '***2* The name of the folder with assets you add to the project**'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 添加到项目中资产文件夹的名称**'
- en: Let’s create an app that will show the product data, as shown in [figure 12.1](#ch12fig01).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个应用，它将显示如图[图12.1](#ch12fig01)所示的产品数据。
- en: Figure 12.1\. Rendering the content of products.json
  id: totrans-50
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.1\. 渲染products.json的内容
- en: '![](Images/12fig01.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/12fig01.jpg)'
- en: Your app component will use `HttpClient.get()` to issue an HTTP GET request,
    and you’ll declare a `Product` interface defining the structure of the expected
    product data. The observable returned by `get()` will be unwrapped in the template
    by the `async` pipe. The app.component.ts file is located in the readfile folder
    and has the content shown in the following listing.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用组件将使用`HttpClient.get()`来发出HTTP GET请求，并且您将声明一个`Product`接口来定义预期产品数据的结构。`get()`返回的可观察对象将通过`async`管道在模板中展开。`app.component.ts`文件位于readfile文件夹中，其内容如下所示。
- en: Listing 12.5\. app.component.ts
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表12.5\. app.component.ts
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***1* Declares a product type**'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 声明产品类型**'
- en: '***2* Iterates through the observable products and autosubscribes to them with
    the async pipe**'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用async管道遍历可观察的产品并自动订阅它们**'
- en: '***3* Renders the product title and the price formatted as currency**'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 渲染产品标题和以货币格式表示的价格**'
- en: '***4* Declares a typed observable for products**'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 声明一个针对产品的类型化的可观察对象**'
- en: '***5* Injects the HttpClient service**'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 注入HttpClient服务**'
- en: '***6* Makes an HTTP GET request specifying the type of the expected data**'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 指定预期数据的类型进行HTTP GET请求**'
- en: '|  |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: In this app, you don’t use the lifecycle hook `ngOnInit()` for fetching data.
    That’s not a crime, because this code doesn’t use any component properties that
    may not have been initialized during component construction. This data fetch will
    be executed asynchronously after the constructor when the `async` pipe subscribes
    to the `products$` observable.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在此应用中，您不使用生命周期钩子`ngOnInit()`来获取数据。这不是犯罪，因为此代码不使用任何可能在组件构造期间未初始化的组件属性。此数据获取将在构造函数之后异步执行，当`async`管道订阅`products$`可观察对象时。
- en: '|  |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'To see this app in action, run `npm install` in the client directory, and then
    run the following command:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此应用的运行情况，请在客户端目录中运行`npm install`，然后运行以下命令：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It wasn’t too difficult, was it? Open Chrome Dev tools, and you’ll see the HTTP
    request and response and their headers, as shown in [figure 12.2](#ch12fig02).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不太难，对吧？打开Chrome开发者工具，您将看到HTTP请求和响应及其头部，如图[图12.2](#ch12fig02)所示。
- en: Figure 12.2\. Monitoring HTTP request and response
  id: totrans-68
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.2\. 监控HTTP请求和响应
- en: '![](Images/12fig02_alt.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/12fig02_alt.jpg)'
- en: This app illustrates how to make an HTTP GET request that has no parameters
    and uses default HTTP request headers. If you want to add additional headers and
    query parameters, use an overloaded version of the `get()` method that offers
    an extra parameter where you can specify additional options. The following listing
    shows how to request data from the same products.json file, passing additional
    headers and query parameters, using the classes `HttpHeaders` and `HttpParams`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用演示了如何发出没有参数且使用默认HTTP请求头的HTTP GET请求。如果您想添加额外的头和查询参数，请使用提供额外参数的重载版`get()`方法，您可以在其中指定额外的选项。以下列表显示了如何使用`HttpHeaders`和`HttpParams`类请求来自同一products.json文件的数据，并传递额外的头和查询参数。
- en: Listing 12.6\. Adding HTTP headers and query parameters to the GET request
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表12.6\. 向GET请求添加HTTP头部和查询参数
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1* Creates the HttpHeaders object with two additional headers**'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建带有两个额外头部的HttpHeaders对象**'
- en: '***2* Creates the object with one query parameter (it can be any object literal)**'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 创建一个包含一个查询参数的对象（它可以是任何对象字面量）**'
- en: '***3* Passes the headers and query parameters as a second argument of get()**'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将头部和查询参数作为get()的第二个参数传递**'
- en: Since you simply read a file, passing query parameters doesn’t make much sense,
    but if you needed to make a similar request to a server’s endpoint that knows
    how to search products by title, the code would look the same. Using the chainable
    `set()` method, you can add as many headers or query parameters as needed.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您只是读取文件，传递查询参数没有太多意义，但如果您需要向知道如何通过标题搜索产品的服务器端点发出类似请求，代码将相同。使用链式`set()`方法，您可以添加所需数量的头部或查询参数。
- en: Running [listing 12.7](#ch12ex07) renders the same data from products.json,
    but the URL of the request and HTTP headers will look different. [Figure 12.3](#ch12fig03)
    uses arrows to highlight the differences compared to [figure 12.2](#ch12fig02).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 运行[列表12.7](#ch12ex07)将渲染来自products.json的相同数据，但请求的URL和HTTP头部将有所不同。[图12.3](#ch12fig03)使用箭头突出显示与[图12.2](#ch12fig02)相比的差异。
- en: Figure 12.3\. Monitoring the modified HTTP request
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.3\. 监控修改后的HTTP请求
- en: '![](Images/12fig03_alt.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/12fig03_alt.jpg)'
- en: You may be wondering how to send data (for example, using HTTP POST) to the
    server. To write such an app, you need a server that can accept your data. In
    [section 12.4.2](#ch12lev2sec4), you’ll create an app that uses `HttpClient.post()`,
    but first let’s create a web server using the Node.js and Express.js frameworks.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道如何向服务器发送数据（例如，使用HTTP POST）。要编写这样的应用程序，您需要一个可以接受您数据的服务器。在[第12.4.2节](#ch12lev2sec4)中，您将创建一个使用`HttpClient.post()`的应用程序，但首先让我们使用Node.js和Express.js框架创建一个Web服务器。
- en: 12.3\. Creating a web server with Node, Express, and TypeScript
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3\. 使用Node、Express和TypeScript创建Web服务器
- en: 'Angular can communicate with web servers running on any platform, but we decided
    to create and use a Node.js server in this book for the following reasons:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Angular可以与任何平台上的Web服务器进行通信，但我们在本书中决定创建并使用Node.js服务器，以下是一些原因：
- en: There’s no need to learn a new programming language to understand the code.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有必要学习一门新的编程语言来理解代码。
- en: Node allows you to create standalone applications (such as servers).
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node允许您创建独立的应用程序（例如服务器）。
- en: Using Node lets you continue writing code in TypeScript, so we don’t have to
    explain how to create a web server in Java, .NET, or any other language.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Node可以让您继续用TypeScript编写代码，因此我们不必解释如何在Java、.NET或其他任何语言中创建Web服务器。
- en: You’ll start with writing a basic web server using Node and Express frameworks.
    Then, you’ll write another web server that can serve JSON data using the HTTP
    protocol. After this server’s ready, you’ll create an Angular client that can
    consume its data.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 您将开始使用Node和Express框架编写一个基本的Web服务器。然后，您将编写另一个可以使用HTTP协议提供JSON数据的Web服务器。在这个服务器准备就绪后，您将创建一个可以消费其数据的Angular客户端。
- en: '|  |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-88
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Source code for this chapter can be found at [https://github.com/Farata/angulartypescript](https://github.com/Farata/angulartypescript)
    and [www.manning.com/books/angular-development-with-typescript-second-edition](http://www.manning.com/books/angular-development-with-typescript-second-edition).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可以在[https://github.com/Farata/angulartypescript](https://github.com/Farata/angulartypescript)和[www.manning.com/books/angular-development-with-typescript-second-edition](http://www.manning.com/books/angular-development-with-typescript-second-edition)找到。
- en: '|  |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 12.3.1\. Creating a simple web server
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.3.1\. 创建一个简单的Web服务器
- en: In this section, you’ll create a web server using Node and Express ([http://expressjs.com](http://expressjs.com))
    frameworks and TypeScript. The code that comes with this chapter has a directory
    called server, containing a separate project with its own package .json file,
    which doesn’t include any Angular dependencies. The sections for `dependencies`
    and `devDependencies` of this file look like the following listing.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将使用Node和Express([http://expressjs.com](http://expressjs.com))框架和TypeScript创建一个Web服务器。本章附带代码中有一个名为server的目录，其中包含一个具有自己的package.json文件的项目，该文件不包含任何Angular依赖项。此文件的`dependencies`和`devDependencies`部分如下所示。
- en: Listing 12.7\. The server’s dependencies in package.json
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表12.7\. 服务器在package.json中的依赖项
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '***1* Express.js framework**'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* Express.js框架**'
- en: '***2* Request body parser for Express.js**'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* Express.js的请求体解析器**'
- en: '***3* Type definition files for Express.js**'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* Express.js的类型定义文件**'
- en: '***4* Type definition files for Node.js**'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* Node.js的类型定义文件**'
- en: '***5* Local version of the TypeScript compiler**'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* TypeScript编译器的本地版本**'
- en: You can read about type definition files in [section B.12](kindle_split_026.xhtml#app02lev1sec12)
    in [appendix B](kindle_split_026.xhtml#app02). You’ll use the body-parser package
    for extracting the data from a request object in [section 12.4](#ch12lev1sec4).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[附录B](kindle_split_026.xhtml#app02)中的[B.12](kindle_split_026.xhtml#app02lev1sec12)部分了解类型定义文件。您将在[第12.4节](#ch12lev1sec4)中使用body-parser包从请求对象中提取数据。
- en: '|  |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'You install the local version of the TypeScript compiler just in case you need
    to keep a different version of the `tsc` compiler installed globally. Also, you
    shouldn’t expect that a continuous integration server has a global `tsc` executable.
    To use the local `tsc` version, you can add a custom npm script command in the
    `scripts` section of package.json (`"tsc": "tsc"`) and start the compiler by running
    the `npm run tsc` command.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '您安装TypeScript编译器的本地版本，以防您需要保留全局安装的不同版本的`tsc`编译器。此外，您不应期望持续集成服务器有一个全局的`tsc`可执行文件。要使用本地的`tsc`版本，您可以在package.json的`scripts`部分添加一个自定义npm脚本命令（`"tsc":
    "tsc"`）并通过运行`npm run tsc`命令来启动编译器。'
- en: '|  |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Because you’ll write the server code in TypeScript, it needs to be transpiled,
    so the following listing adds the tsconfig.json file with the compiler’s options
    for `tsc`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你会用 TypeScript 编写服务器代码，所以它需要被转译，所以以下列表添加了 tsconfig.json 文件，其中包含了 `tsc` 编译器的选项。
- en: Listing 12.8\. tsconfig.json for the server
  id: totrans-106
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.8\. 服务器 tsconfig.json
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '***1* Transpiles modules according to the CommonJS spec**'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 根据CommonJS规范转译模块**'
- en: '***2* Saves .js files into the build directory**'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将 .js 文件保存到构建目录中**'
- en: '***3* Transpiles into .js files using ES6 syntax**'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用 ES6 语法转译为 .js 文件**'
- en: '***4* Doesn’t transpile the code located in the node_modules directory**'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 不转译位于 node_modules 目录中的代码**'
- en: By specifying the CommonJS syntax for modules, you ensure that `tsc` transpiles
    statements like `import * as express from "express";` into `const express = require
    ("express");`, as required by Node.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 通过指定模块的 CommonJS 语法，你确保 `tsc` 将 `import * as express from "express";` 这样的语句转译为
    Node 所需的 `const express = require ("express");`。
- en: The following listing shows the code of a simple web server from the file my-express-server.ts.
    This server implements the server-side routing for HTTP `GET` requests by mapping
    three paths—/, /products, and /reviews—to the corresponding callback functions.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了文件 my-express-server.ts 中的简单 Web 服务器代码。此服务器通过将三个路径—/、/products 和 /reviews—映射到相应的回调函数，实现了对
    HTTP `GET` 请求的服务器端路由。
- en: Listing 12.9\. my-express-server.ts
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.9\. my-express-server.ts
- en: '[PRE9]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '***1* Instantiates Express.js**'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 实例化了 Express.js**'
- en: '***2* Matches GET requests to the root route**'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 匹配根路由的 GET 请求**'
- en: '***3* Matches GET requests to the /products route**'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 匹配 /products 路由的 GET 请求**'
- en: '***4* Matches GET requests to the /reviews route**'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 匹配 /reviews 路由的 GET 请求**'
- en: '***5* Starts listening on localhost:8000 and executes the code from the fat-arrow
    function**'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 在 localhost:8000 上开始监听并执行肥箭头函数中的代码**'
- en: 'Run `npm install`; transpile all code samples, including my-express-server.ts,
    by running `tsc`; and start this server by running the following command:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `npm install`；通过运行 `tsc` 转译所有代码示例，包括 my-express-server.ts；然后通过运行以下命令启动此服务器：
- en: '[PRE10]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '|  |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you don’t have the TypeScript compiler installed globally, you can either
    run its local version, ./node_modules/typescript/bin/tsc, or add the line `"tsc:
    "tsc"` to the `scripts` section of package.json, and run it like this: `npm run
    tsc`.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你没有全局安装 TypeScript 编译器，你可以运行其本地版本，./node_modules/typescript/bin/tsc，或者将 `"tsc:
    "tsc"` 行添加到 package.json 的 `scripts` 部分，并像这样运行它：`npm run tsc`。'
- en: '|  |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: You’ll see the message “Listening on localhost:8000” on the console, and now
    you can request either products or reviews, depending on which URL you enter in
    the browser, as shown in [figure 12.4](#ch12fig04).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在控制台看到“Listening on localhost:8000”的消息，现在你可以根据在浏览器中输入的 URL 请求产品或评论，如图 12.4
    所示。
- en: Figure 12.4\. Server-side routing with Express
  id: totrans-128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 12.4\. 使用 Express 的服务器端路由
- en: '![](Images/12fig04.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/12fig04.jpg)'
- en: '|  |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'To debug Node applications, refer to the documentation of your IDE. If you
    want to debug the TypeScript code, don’t forget to set the option `"sourceMap":
    true` in the tsconfig.json file of your Node project.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '要调试 Node 应用程序，请参考你 IDE 的文档。如果你想调试 TypeScript 代码，别忘了在 Node 项目的 tsconfig.json
    文件中设置 `"sourceMap": true` 选项。'
- en: '|  |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: This server responds with simple text messages, but how do you create a server
    that can respond with data in JSON format?
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个服务器响应简单的文本消息，但你是如何创建一个可以响应 JSON 格式数据的服务器的呢？
- en: 12.3.2\. Serving JSON
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.3.2\. 提供JSON服务
- en: 'To send JavaScript objects (such as products) to the browser in JSON format,
    you’ll use the Express function `json()` on the response object. Your REST server
    is located in the rest-server.ts file, and it can serve either all products or
    a specific one (by ID). In this server, you’ll create three endpoints: / for the
    root path, /api/products for all products, and /api/products/:id for the paths
    that include product IDs. The `products` array will contain three hardcoded objects
    of type `Product`, which will be turned into JSON format by invoking `res.json()`,
    offered by the Express framework.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要以 JSON 格式将 JavaScript 对象（如产品）发送到浏览器，你将在响应对象上使用 Express 函数 `json()`。你的 REST
    服务器位于 rest-server.ts 文件中，它可以提供所有产品或特定产品（通过 ID）。在这个服务器中，你将创建三个端点：/ 作为根路径，/api/products
    作为所有产品的路径，以及 /api/products/:id 作为包含产品 ID 的路径。`products` 数组将包含三个硬编码的 `Product`
    类型的对象，这些对象将通过调用 Express 框架提供的 `res.json()` 转换为 JSON 格式。
- en: Listing 12.10\. rest-server.ts
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.10\. rest-server.ts
- en: '[PRE11]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '***1* Defines the Product type**'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 定义了 Product 类型**'
- en: '***2* Creates an array of three JavaScript objects with products data**'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 创建包含产品数据的三个JavaScript对象的数组**'
- en: '***3* Returns all products**'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 返回所有产品**'
- en: '***4* Returns the text prompt as a response to the base URL GET request**'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将文本提示作为对基础URL GET请求的响应**'
- en: '***5* When the GET request contains /api/products in the URL, invokes getProducts()**'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 当GET请求包含URL中的/api/products时，调用getProducts()**'
- en: '***6* Converts products to JSON and returns them to the browser**'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 将产品转换为JSON并返回给浏览器**'
- en: '***7* Returns the product by ID. Here, you use the array’s find() method.**'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 通过ID返回产品。这里，你使用数组的find()方法。**'
- en: '***8* The GET request came with a parameter. Its values are stored in the params
    property of the request object.**'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* GET请求附带了一个参数。其值存储在请求对象的params属性中。**'
- en: '***9* Converts the product ID from a string to an integer, invokes getProductById(),
    and sends the JSON back**'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9* 将产品ID从字符串转换为整数，调用getProductById()，并发送JSON回**'
- en: 'Stop the my-express-server from the previous section if it’s running (Ctrl-C),
    and start the rest-server with the following command:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果之前运行的my-express-server还在运行，请使用Ctrl-C停止它，然后使用以下命令启动rest-server：
- en: '[PRE12]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Enter `http://localhost:8000/api/products` in the browser, and you should see
    the data in JSON format, as shown in [figure 12.5](#ch12fig05).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中输入`http://localhost:8000/api/products`，你应该会看到如图12.5所示的JSON格式的数据。
- en: Figure 12.5\. The server’s response to http://localhost:8000/api/products
  id: totrans-151
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.5\. 服务器对http://localhost:8000/api/products的响应
- en: '![](Images/12fig05_alt.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/12fig05_alt.jpg)'
- en: '[Figure 12.6](#ch12fig06) shows the browser window after you enter the URL
    http://localhost:8000/api/products/1\. This time, the server returns only data
    about the product that has an `id` with the value of `1`.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[图12.6](#ch12fig06)显示了输入URL http://localhost:8000/api/products/1后的浏览器窗口。这次，服务器只返回具有值为`1`的`id`的产品数据。'
- en: Figure 12.6\. The server’s response to http://localhost:8000/api/products/1
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.6\. 服务器对http://localhost:8000/api/products/1的响应
- en: '![](Images/12fig06_alt.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/12fig06_alt.jpg)'
- en: Your REST server is ready. Now let’s see how to initiate HTTP GET requests and
    handle responses in Angular applications.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你的REST服务器已准备就绪。现在让我们看看如何在Angular应用程序中发起HTTP GET请求并处理响应。
- en: 12.4\. Bringing Angular and Node together
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.4\. 将Angular和Node结合在一起
- en: In the preceding section, you created the rest-server.ts file, which responds
    to HTTP GET requests with product details regardless of whether the client was
    written using a framework or the user simply entered the URL in a browser. In
    this section, you’ll write an Angular client that will issue HTTP GET requests
    and treat the product data as an `Observable` data stream returned by your server.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你创建了rest-server.ts文件，该文件无论客户端是使用框架编写还是用户在浏览器中直接输入URL，都会响应HTTP GET请求并返回产品详情。在本节中，你将编写一个Angular客户端，该客户端将发出HTTP
    GET请求并将产品数据视为由你的服务器返回的`Observable`数据流。
- en: '|  |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-160
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'Just a reminder: the Angular app and the Node server are two separate projects.
    The server code is located in the directory called server, and the Angular app
    is located in a separate project in the client directory.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 只是一个提醒：Angular应用程序和Node服务器是两个独立的项目。服务器代码位于名为server的目录中，Angular应用程序位于client目录中的另一个项目中。
- en: '|  |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 12.4.1\. Static assets on the server
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.4.1\. 服务器上的静态资源
- en: A typical web app deployed on the server includes static assets (for example,
    HTML, images, CSS, and JavaScript code) that have to be loaded by the browser
    when the user enters the URL of the app. From the server’s perspective, the Angular
    portion of a web app is considered *static assets*. The Express framework allows
    you to specify the directory where the static assets are located.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 部署在服务器上的典型Web应用程序包括静态资源（例如，HTML、图像、CSS和JavaScript代码），当用户输入应用程序的URL时，浏览器需要加载这些资源。从服务器的角度来看，Web应用程序的Angular部分被视为*静态资源*。Express框架允许你指定静态资源所在的目录。
- en: 'Let’s create a new server: rest-server-angular.ts. In the rest-server.ts file
    from the previous section, you didn’t specify the directory with static assets,
    because no client app was deployed on the server. In the new server, you add the
    lines shown in the following listing.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的服务器：rest-server-angular.ts。在上一个节段的rest-server.ts文件中，你没有指定静态资源的目录，因为没有在服务器上部署客户端应用程序。在新服务器中，你添加以下列表中的行。
- en: Listing 12.11\. Specifying the directory with static resources
  id: totrans-166
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表12.11\. 指定静态资源所在的目录
- en: '[PRE13]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '***1* Adds the Node path module for working with the directory and paths**'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 添加Node路径模块以处理目录和路径**'
- en: '***2* Assigns the public subdirectory as the location of the static resources**'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将公共子目录指定为静态资源的位置**'
- en: Unlike in rest-server.ts, you just map the base URL (/) to the public directory,
    and Node will send index.html from there by default. The browser loads index.html,
    which in turn loads the rest of the bundles defined in the `<script>` tags.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 与 rest-server.ts 不同，您只需将基本 URL (/) 映射到公共目录，Node 将默认从那里发送 index.html。浏览器加载 index.html，然后加载在
    `<script>` 标签中定义的其余捆绑包。
- en: '|  |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-172
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The original index.html file generated by Angular CLI doesn’t contain `<script>`
    tags, but when you run the `ng build` or `ng serve` commands, they create a new
    version of index.html that includes the `<script>` tags with all the bundles and
    other assets.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 由 Angular CLI 生成的原始 index.html 文件不包含 `<script>` 标签，但当你运行 `ng build` 或 `ng serve`
    命令时，它们将创建一个包含所有捆绑包和其他资产的新的 index.html 版本。
- en: '|  |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'When the browser requests static assets, Node will look for them in the public
    subdirectory of the current one (`__dirname`)—the build directory from which you
    started this server. Here, you use Node’s `path.join()` API to ensure that the
    absolute file path is created in a cross-platform way. In the next section, we’ll
    introduce the Angular client and deploy its bundles in the public directory. The
    REST endpoints in rest-server-angular.ts remain the same as in rest-server.ts:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当浏览器请求静态资源时，Node 将在当前目录的 public 子目录中查找它们——这是您启动此服务器时的构建目录。在这里，您使用 Node 的 `path.join()`
    API 确保以跨平台的方式创建绝对文件路径。在下一节中，我们将介绍 Angular 客户端并将其捆绑包部署在公共目录中。rest-server-angular.ts
    中的 REST 端点与 rest-server.ts 中的相同：
- en: / serves index.html, which contains the code to load the Angular app.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: / 服务器提供 index.html，其中包含加载 Angular 应用的代码。
- en: /api/products serves all products.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: /api/products 提供所有产品。
- en: /api/products/:id serves one product by its ID.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: /api/products/:id 通过其 ID 提供一个产品。
- en: The complete code of the rest-server-angular.ts file is shown in the next listing.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: rest-server-angular.ts 文件的完整代码将在下一列表中展示。
- en: Listing 12.12\. rest-server-angular.ts
  id: totrans-180
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.12\. rest-server-angular.ts
- en: '[PRE14]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '***1* Adds the path module that provides utilities for working with file and
    directory paths**'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 添加了提供用于处理文件和目录路径实用工具的路径模块**'
- en: '***2* For the root path, specifies the directory from which to serve static
    assets**'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 对于根路径，指定提供静态资源的目录**'
- en: '***3* Configures the endpoint for HTTP GET requests**'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 配置 HTTP GET 请求的端点**'
- en: '***4* Configures another endpoint for HTTP GET requests**'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 为 HTTP GET 请求配置另一个端点**'
- en: '***5* Starts the server**'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 启动服务器**'
- en: 'The new server is ready to serve JSON data to the Angular client, so let’s
    start it:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 新服务器已准备好为 Angular 客户端提供 JSON 数据，让我们启动它：
- en: '[PRE15]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Trying to make a request to this server using the base URL http://localhost:8000
    will return a 404 error, because the directory with static assets doesn’t contain
    the index.html file: you haven’t deployed your Angular app there yet. Your next
    task is to create and deploy the Angular app that will consume JSON-formatted
    data.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用基本 URL http://localhost:8000 向此服务器发出请求将返回 404 错误，因为包含静态资产的目录中没有 index.html
    文件：您尚未将 Angular 应用部署到那里。您的下一个任务是创建并部署将消费 JSON 格式数据的 Angular 应用。
- en: 12.4.2\. Consuming JSON in Angular apps
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.4.2\. 在 Angular 应用中消费 JSON
- en: Your Angular app will be located in a directory called client. In previous chapters,
    you were starting all Angular apps building bundles in memory with `ng serve`,
    but this time you’ll also use the `ng build` command to generate bundles in files.
    Then you’ll use npm scripts to automate the deployment of these bundles in the
    Node server created in [section 12.4.1](#ch12lev2sec3).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 Angular 应用将位于名为 client 的目录中。在之前的章节中，您使用 `ng serve` 在内存中构建捆绑包来启动所有 Angular
    应用，但这次您还将使用 `ng build` 命令生成文件中的捆绑包。然后您将使用 npm 脚本来自动化在 [12.4.1 节](#ch12lev2sec3)
    中创建的 Node 服务器中的这些捆绑包的部署。
- en: In dev mode, you’ll keep serving Angular apps using the dev server from Angular
    CLI that runs on port 4200\. But the data will be coming from another web server,
    powered by Node and Express, that will run on port 8000\. [Figure 12.7](#ch12fig07)
    illustrates this two-server setup.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发模式下，您将继续使用运行在端口 4200 的 Angular CLI 开发服务器来提供 Angular 应用。但数据将来自另一个由 Node 和
    Express 驱动的网络服务器，该服务器将在端口 8000 上运行。[图 12.7](#ch12fig07) 展示了这种双服务器配置。
- en: Figure 12.7\. Two servers in dev mode
  id: totrans-193
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 12.7\. 开发模式下的两个服务器
- en: '![](Images/12fig07.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/12fig07.jpg)'
- en: '|  |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-196
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: '*Spoiler alert*: We’ll run into an issue when the client app served from one
    server tries to directly access another one. We’ll cross that bridge when we get
    to it.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*剧透警告*：当客户端应用从一台服务器提供并尝试直接访问另一台服务器时，我们会遇到一个问题。当我们到达那里时，我们会解决这个难题。'
- en: '|  |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: When the Angular `HttpClient` object makes a request to a URL, the response
    comes back as `Observable`, and the client’s code can handle it either by using
    the `subscribe()` method or with the `async` pipe introduced in [section 6.5](kindle_split_015.xhtml#ch06lev1sec5)
    in [chapter 6](kindle_split_015.xhtml#ch06). Using the `async` pipe is preferable,
    but we’ll show you both methods so you can appreciate the advantages of `async`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Angular 的 `HttpClient` 对象向一个 URL 发起请求时，响应会以 `Observable` 的形式返回，客户端的代码可以通过使用
    `subscribe()` 方法或使用在 [第 6.5 节](kindle_split_015.xhtml#ch06lev1sec5) 中引入的 `async`
    管道来处理它。使用 `async` 管道是首选的，但我们将展示两种方法，以便你可以欣赏 `async` 的优势。
- en: Let’s start with an app that retrieves all products from the rest-server-angular
    server and renders them using an HTML unordered list (`<ul>`). You can find this
    app in the app.component.ts file located in the client/src/app/restclient directory.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从这样一个应用开始，它从 rest-server-angular 服务器检索所有产品，并使用 HTML 无序列表 (`<ul>`) 来渲染它们。你可以在这个应用中找到
    app.component.ts 文件，它位于 client/src/app/restclient 目录中。
- en: Listing 12.13\. restclient/app.component.ts
  id: totrans-201
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.13\. restclient/app.component.ts
- en: '[PRE16]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '***1* Declares the type for products**'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 声明产品的类型**'
- en: '***2* Uses the currency pipe for rendering the price**'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用货币管道来渲染价格**'
- en: '***3* Declares an observable for data returned by HttpClient**'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 声明由 HttpClient 返回的数据的观察者**'
- en: '***4* Declares the subscription property—you’ll need to unsubscribe from observable**'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 声明订阅属性——你需要从观察者中取消订阅**'
- en: '***5* The HTTP requests errors (if any) are displayed here.**'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 在这里显示 HTTP 请求的错误（如果有）**。'
- en: '***6* Injects HttpClient**'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 注入 HttpClient**'
- en: '***7* Declares the intention to issue HTTP GET for products**'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 声明发起 HTTP GET 请求产品的意图**'
- en: '***8* Makes an HTTP GET request for products**'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 对产品发起 HTTP GET 请求**'
- en: '***9* Adds the received products to the array**'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9* 将接收到的产品添加到数组中**'
- en: '***10* Sets the value of an error message to a variable for rendering on the
    UI**'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***10* 将错误消息的值设置为一个变量，以便在 UI 上渲染**'
- en: '|  |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-214
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You didn’t use `ngOnDestroy()` to explicitly unsubscribe from the observable
    because once `HttpClient` gets the response (or an error), the underlying `Observable`
    completes, so the observer is unsubscribed automatically.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你没有使用 `ngOnDestroy()` 显式地取消订阅观察者，因为一旦 `HttpClient` 获取到响应（或错误），底层的 `Observable`
    就会完成，因此观察者会自动取消订阅。
- en: '|  |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'You already started the server in the previous section. Now, start the client
    by running the following command:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在上一节中启动了服务器。现在，通过运行以下命令来启动客户端：
- en: '[PRE17]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'No products are rendered by the browser, and the console shows a 404 error,
    but if you used the full URL in the `AppComponent` (for example, http://localhost:8000/api/products),
    the browser’s console would show the following error:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器没有渲染任何产品，控制台显示了一个 404 错误，但如果你在 `AppComponent` 中使用了完整的 URL（例如，http://localhost:8000/api/products），浏览器控制台将显示以下错误：
- en: '[PRE18]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: That’s because you violated the same-origin policy (see [http://mng.bz/2tSb](http://mng.bz/2tSb)).
    This restriction is set for clients that run in a browser as a security mechanism.
    Say you visited and logged in to bank.com, and then opened another tab and opened
    badguys.com. The same-origin policy ensures that scripts from badguys.com can’t
    access your account at bank.com.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为你违反了同源策略（见 [http://mng.bz/2tSb](http://mng.bz/2tSb)）。这种限制是为在浏览器中运行的客户端设置的作为一种安全机制。假设你访问并登录了
    bank.com，然后在另一个标签页中打开了 badguys.com。同源策略确保来自 badguys.com 的脚本无法访问你在 bank.com 的账户。
- en: Your Angular app was loaded from http://localhost:4200 but tries to access the
    URL http://localhost:8000\. Browsers aren’t allowed to do this unless the server
    that runs on port 8000 is configured to allow access to the clients with the origin
    http://localhost:4200. When your client app is deployed in the Node server, you
    won’t have this error, because the client app will be loaded from the server that
    runs on port 8000, and this client will be making data requests to the same server.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 Angular 应用是从 http://localhost:4200 加载的，但试图访问 URL http://localhost:8000。除非运行在端口
    8000 的服务器被配置为允许来自 http://localhost:4200 的客户端访问，否则浏览器不允许这样做。当你的客户端应用在 Node 服务器上部署时，你不会遇到这个错误，因为客户端应用将加载在端口
    8000 上运行的服务器，并且这个客户端将向同一服务器发送数据请求。
- en: In the hands-on section in [chapter 13](kindle_split_022.xhtml#ch13), you’ll
    use the Node.js CORS package (see [https://github.com/expressjs/cors](https://github.com/expressjs/cors))
    to allow requests from clients with other origins, but this may not be an option
    if you need to make requests to third-party servers. In dev mode, there’s a simpler
    solution to the same-origin restriction. You’ll use the server that runs on port
    4200 as a proxy for client requests to the server that runs on port 8000\. The
    same-origin policy doesn’t apply to server-to-server communications. In the next
    section, you’ll see how to configure such a proxy on the client.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 13 章的动手实践部分 [chapter 13](kindle_split_022.xhtml#ch13)，您将使用 Node.js CORS 包（见
    [https://github.com/expressjs/cors](https://github.com/expressjs/cors)）来允许来自其他源客户端的请求，但如果您需要向第三方服务器发送请求，这可能不是一个选项。在开发模式下，有一个更简单的解决方案来解决同源限制。您将使用运行在端口
    4200 的服务器作为客户端请求运行在端口 8000 的服务器的代理。同源策略不适用于服务器到服务器的通信。在下一节中，您将了解如何在客户端配置此类代理。
- en: 12.4.3\. Configuring the client proxy
  id: totrans-224
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.4.3\. 配置客户端代理
- en: In dev mode, you’d like to continue using the server that comes with Angular
    CLI with its hot reload features and fast rebuilding of application bundles in
    memory. On the other hand, you want to be able to make requests to other servers.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发模式下，您希望继续使用 Angular CLI 附带的具有热重载功能和快速重建内存中的应用程序包的服务器。另一方面，您希望能够向其他服务器发送请求。
- en: Under the hood, the Angular CLI dev server uses the Webpack dev server, which
    can serve as a proxy mediating browser communications with other servers. You
    just need to create a proxy-conf.json file in the root directory of the Angular
    project, where you’d configure a URL fragment(s) that the dev server should redirect
    to another server. In your case, you want to redirect any request that has the
    URL fragment /api to the server that runs on port 8000, as shown in the following
    listing.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，Angular CLI 开发服务器使用 Webpack 开发服务器，它可以作为代理，在浏览器与其他服务器之间进行通信。您只需在 Angular
    项目的根目录中创建一个 proxy-conf.json 文件，在那里您将配置开发服务器应重定向到另一个服务器的 URL 片段。在您的例子中，您希望将任何包含
    URL 片段 /api 的请求重定向到运行在端口 8000 的服务器，如下面的列表所示。
- en: Listing 12.14\. proxy-conf.json
  id: totrans-227
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.14\. proxy-conf.json
- en: '[PRE19]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '***1* Hijacks all requests that have /api in the URL**'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 修改包含 /api 的 URL 的所有请求**'
- en: '***2* Redirects these requests to this URL**'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将这些请求重定向到该 URL**'
- en: '***3* The target connection doesn’t need SSL certificates.**'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 目标连接不需要 SSL 证书。**'
- en: '|  |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-233
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Using a proxy file allows you to easily switch between local and remote servers.
    Just change the value of the `target` property to have your local app retrieve
    data from a remote server. You can read more about Angular CLI proxying support
    at [http://mng.bz/fLgf](http://mng.bz/fLgf).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 使用代理文件允许您轻松地在本地和远程服务器之间切换。只需更改 `target` 属性的值，让您的本地应用程序从远程服务器检索数据。您可以在 [http://mng.bz/fLgf](http://mng.bz/fLgf)
    上了解更多关于 Angular CLI 代理支持的信息。
- en: '|  |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'You need to make a small change in the app from the preceding section. You
    should replace the full URL of the backend server (http://localhost:8000/api/products)
    with the path of the endpoint (/api/products). The code that makes a request for
    products will look as if you try to access the /api/products endpoint on the Angular
    CLI dev server where the app was downloaded from:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在上一节的应用程序中进行一些小的修改。您应该将后端服务器的完整 URL（http://localhost:8000/api/products）替换为端点的路径（/api/products）。请求产品的代码将看起来像您尝试访问从
    Angular CLI 开发服务器下载的应用程序上的 /api/products 端点：
- en: '[PRE20]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: But the dev server will recognize the /api fragment in the URL and will redirect
    this request to another server that runs on port 8000, as shown in [figure 12.8](#ch12fig08)
    (compare it to [figure 12.7](#ch12fig07)).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 但开发服务器将识别 URL 中的 /api 片段，并将此请求重定向到运行在端口 8000 的另一个服务器，如图 12.8 所示（与图 12.7 进行比较）。
- en: Figure 12.8\. Two servers with a proxy
  id: totrans-239
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 12.8\. 使用代理的两个服务器
- en: '![](Images/12fig08.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/12fig08.jpg)'
- en: 'To see the modified app in action, you need to use the `--proxy-config` option,
    providing the name of the file where you configured the proxy parameters:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看修改后的应用程序的实际效果，您需要使用 `--proxy-config` 选项，提供配置代理参数的文件名：
- en: '[PRE21]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '|  |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-244
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If you forget to provide the name of the proxy file when configuring proxy parameters,
    you’ll get a 404 error, because the /api/products request won’t be redirected,
    and there’s no such endpoint in the server that runs on port 4200.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在配置代理参数时忘记提供代理文件的名称，您将收到 404 错误，因为 /api/products 请求不会被重定向，并且端口 4200 运行的服务器中没有这样的端点。
- en: '|  |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Open your browser to http://localhost:4200, and you’ll see the Angular app shown
    in [figure 12.9](#ch12fig09).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您的浏览器到 http://localhost:4200，您将看到 [图 12.9](#ch12fig09) 中显示的 Angular 应用程序。
- en: Figure 12.9\. Retrieving all products from the Node server via proxy
  id: totrans-248
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 12.9\. 通过代理从 Node 服务器检索所有产品
- en: '![](Images/12fig09.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/12fig09.jpg)'
- en: Note that data arrives from the server that runs on port 4200, which got it
    from the server that runs on port 8000\. [Figure 12.8](#ch12fig08) illustrates
    this data flow.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 注意数据来自运行在端口 4200 的服务器，该服务器从运行在端口 8000 的服务器获取数据。[图 12.8](#ch12fig08) 说明了此数据流。
- en: 'In dev mode, using Angular CLI proxying allows you to kill two birds with one
    stone: have the hot reload of your app on any code change and access data from
    another server without the need to deploy the app there.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发模式下，使用 Angular CLI 代理可以一石二鸟：在代码更改时热重载您的应用程序，并且无需部署到另一个服务器即可访问数据。
- en: Now let’s see how to replace the explicit subscription for products with the
    `async` pipe.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何用 `async` 管道替换产品的显式订阅。
- en: 12.4.4\. Subscribing to observables with the async pipe
  id: totrans-253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.4.4\. 使用异步管道订阅可观察对象
- en: 'We introduced `AsyncPipe` (or `async`, when used in templates) in [section
    6.5](kindle_split_015.xhtml#ch06lev1sec5) of [chapter 6](kindle_split_015.xhtml#ch06).
    `async` can receive an `Observable` as input, autosubscribe to it, and discard
    the subscription when the component gets destroyed. To see this in action, make
    the following changes in [listing 12.13](#ch12ex13):'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [第 6 章](kindle_split_015.xhtml#ch06) 的 [6.5 节](kindle_split_015.xhtml#ch06lev1sec5)
    中介绍了 `AsyncPipe`（或在模板中使用时称为 `async`）。`async` 可以接收一个 `Observable` 作为输入，自动订阅它，并在组件被销毁时取消订阅。要查看此功能的工作原理，请在
    [列表 12.13](#ch12ex13) 中进行以下更改：
- en: Change the type of the `products` variable from `Array` to `Observable`.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `products` 变量的类型从 `Array` 更改为 `Observable`。
- en: Remove the declaration of the variable `theDataSource$`.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除变量 `theDataSource$` 的声明。
- en: Remove the invocation of `subscribe()` in the code. You’ll assign the `Observable`
    returned by the `get()` method to `products`.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在代码中删除对 `subscribe()` 的调用。您将 `get()` 方法返回的 `Observable` 分配给 `products`。
- en: Add the `async` pipe to the `*ngFor` loop in the template.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `async` 管道添加到模板中的 `*ngFor` 循环。
- en: The following listing implements these changes (see the file restclient/app.component.asyncpipe.ts).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表实现了这些更改（请参阅文件 restclient/app.component.asyncpipe.ts）。
- en: Listing 12.15\. app.component.asyncpipe.ts
  id: totrans-260
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.15\. app.component.asyncpipe.ts
- en: '[PRE22]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '***1* The async pipe subscribes and unwraps products from observable products$.**'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 异步管道订阅并展开 observable products$ 中的产品**'
- en: '***2* Initializes the observable with HttpClient.get()**'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用 HttpClient.get() 初始化观察者**'
- en: '***3* Intercepts an error before it reaches the async pipe**'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在错误到达异步管道之前拦截错误**'
- en: '***4* Handles the error, if any**'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 处理可能出现的错误**'
- en: '***5* Returns an empty observable so the subscriber won’t get destroyed**'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 返回一个空的观察者，这样订阅者就不会被销毁**'
- en: Running this application will produce the same output shown in [figure 12.9](#ch12fig09).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此应用程序将产生与 [图 12.9](#ch12fig09) 中显示相同的输出。
- en: So far, you’ve been injecting `HttpClient` instances directly into components,
    but more often you inject `HttpClient` into a service. Let’s see how to do this.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经直接将 `HttpClient` 实例注入到组件中，但更常见的是将 `HttpClient` 注入到服务中。让我们看看如何做到这一点。
- en: 12.4.5\. Injecting HttpClient into a service
  id: totrans-269
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.4.5\. 将 HttpClient 注入到服务中
- en: Angular offers an easy way for separating the business logic implementation
    from rendering the UI. Business logic should be implemented in services, and the
    UI in components, and you usually implement all HTTP communications in one or
    more services that are injected into components. For example, your ngAuction app
    that comes with [chapter 11](kindle_split_020.xhtml#ch11) has the `ProductService`
    class with the injected `HttpClient` service. You inject a service into another
    service.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 提供了一种简单的方法来分离业务逻辑实现和渲染 UI。业务逻辑应在服务中实现，UI 在组件中实现，并且您通常在一个或多个注入到组件中的服务中实现所有
    HTTP 通信。例如，与 [第 11 章](kindle_split_020.xhtml#ch11) 一起提供的 ngAuction 应用程序具有注入 `HttpClient`
    服务的 `ProductService` 类。您将一个服务注入到另一个服务中。
- en: '`ProductService` reads the products.json file using `HttpClient`, but it could
    get the product data from a remote server the same way you did in the previous
    section. `ProductService` is injected into components of ngAuction. Check the
    source code of `ProductService` and `CategoriesComponent` in ngAuction that comes
    with [chapter 11](kindle_split_020.xhtml#ch11), and you’ll recognize the pattern
    shown in [figure 12.10](#ch12fig10).'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductService` 使用 `HttpClient` 读取 products.json 文件，但它也可以像上一节中那样从远程服务器获取产品数据。`ProductService`
    注入到 ngAuction 的组件中。检查 ngAuction 中 [第 11 章](kindle_split_020.xhtml#ch11) 伴随的 `ProductService`
    和 `CategoriesComponent` 的源代码，你将识别出 [图 12.10](#ch12fig10) 中显示的模式。'
- en: Figure 12.10\. Injecting into a service and a component
  id: totrans-272
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 12.10\. 将依赖注入到服务和组件中
- en: '![](Images/12fig10_alt.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/12fig10_alt.jpg)'
- en: The following listing from ngAuction’s `ProductService` is an example of encapsulating
    business logic and HTTP communications inside a service.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 ngAuction 的 `ProductService` 的下一个列表是封装业务逻辑和 HTTP 通信到服务中的一个示例。
- en: Listing 12.16\. A fragment from ngAuction’s `ProductService`
  id: totrans-275
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.16\. ngAuction 的 `ProductService` 的一个片段
- en: '[PRE23]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '***1* Injects HttpClient into ProductService**'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将 HttpClient 注入到 ProductService**'
- en: '***2* Invokes HttpClient.get()**'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 调用 HttpClient.get()**'
- en: '|  |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-280
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: In the preceding [listing 12.19](#ch12ex19), you use RxJS pipeable operators
    inside the `pipe()` method (see [section D.4.1](kindle_split_028.xhtml#app04lev2sec1)
    in [appendix D](kindle_split_028.xhtml#app04)).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 [列表 12.19](#ch12ex19) 中，你使用 RxJS 可管道操作符在 `pipe()` 方法中（参见 [附录 D](kindle_split_028.xhtml#app04)
    中的 [部分 D.4.1](kindle_split_028.xhtml#app04lev2sec1)）。
- en: '|  |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The next listing from `CategoriesComponent` is an example of using the preceding
    service in the component.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 `CategoriesComponent` 的下一个列表是使用该组件中先前服务的一个示例。
- en: Listing 12.17\. A fragment from the ngAuction’s `CategoriesComponent`
  id: totrans-284
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.17\. ngAuction 的 `CategoriesComponent` 的一个片段
- en: '[PRE24]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '***1* Injects ProductService**'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将 ProductService 注入**'
- en: '***2* Uses ProductService**'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用 ProductService**'
- en: The provider for `ProductService` is declared on the app level in the `@NgModule()`
    decorator of the root module of ngAuction. In the hands-on section in [chapter
    13](kindle_split_022.xhtml#ch13), you’ll split ngAuction into two projects, client
    and server, and the web server will be written using Node and Express frameworks.
    How can an Angular app (bundles and assets) be deployed in a web server?
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductService` 的提供者在 ngAuction 的根模块的 `@NgModule()` 装饰器中在应用级别声明。在第 13 章的实践部分
    [chapter 13](kindle_split_022.xhtml#ch13)，你将 ngAuction 分割成两个项目，客户端和服务器，并且将使用 Node
    和 Express 框架编写网络服务器。一个 Angular 应用（捆绑和资产）如何部署在 web 服务器上？'
- en: 12.4.6\. Deploying Angular apps on the server with npm scripts
  id: totrans-289
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.4.6\. 使用 npm 脚本在服务器上部署 Angular 应用
- en: The process of deploying the code of a web client in a server should be automated.
    At the very minimum, deploying an Angular app includes running several commands
    for building bundles and replacing previously deployed code (index.html, JavaScript
    bundles, and other assets) with new code. The deployment may also include running
    test scripts and other steps.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器上部署客户端代码的过程应该是自动化的。至少，部署一个 Angular 应用包括运行几个命令来构建捆绑包，并用新代码替换先前部署的代码（index.html、JavaScript
    捆绑包和其他资产）。部署可能还包括运行测试脚本和其他步骤。
- en: JavaScript developers use various tools for automating running deployment tasks
    such as Grunt, gulp, npm scripts, and others. In this section we’ll show you how
    to use npm scripts for deployment. We like using npm scripts, because they’re
    simple to use and offer an easy way to automate running command sequences in a
    predefined order. Besides, you already have npm installed, so there’s no need
    to install additional software for automating your deployment workflow.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 开发者使用各种工具来自动化运行部署任务，如 Grunt、gulp、npm 脚本等。在本节中，我们将向您展示如何使用 npm 脚本进行部署。我们喜欢使用
    npm 脚本，因为它们易于使用，并且提供了一种简单的方法来自动化以预定义顺序运行命令序列。此外，您已经安装了 npm，因此无需安装其他软件来自动化您的部署工作流程。
- en: To illustrate the deployment process, you’ll use the rest-server-angular server
    from [section 12.3.1](#ch12lev2sec1), where you’ll deploy the Angular app from
    section 12.3.4\. After deployment, you won’t need to configure the proxy anymore,
    because both the server and the client code will be deployed at the same server
    running http://localhost:8000\. After entering this URL in the browser, the user
    will see the product data, as shown earlier in [figure 12.9](#ch12fig09).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明部署过程，你将使用来自[第12.3.1节](#ch12lev2sec1)的rest-server-angular服务器，你将在其中部署来自[第12.3.4节](#ch12lev2sec4)的Angular应用。部署后，你不再需要配置代理，因为服务器和客户端代码都将部署在同一台运行http://localhost:8000的服务器上。在浏览器中输入此URL后，用户将看到之前在[图12.9](#ch12fig09)中展示的产品数据。
- en: 'npm allows you to add the `scripts` property in package.json, where you can
    define aliases for terminal commands. For example, instead of typing the long
    command `ng serve --app restclient --proxy-config proxy-conf.json`, you can define
    a start command in the scripts section of package.json as follows:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: npm允许你在package.json中添加`scripts`属性，其中你可以为终端命令定义别名。例如，你不必输入长命令`ng serve --app
    restclient --proxy-config proxy-conf.json`，你可以在package.json的脚本部分定义一个start命令，如下所示：
- en: '[PRE25]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, instead of typing that long command, you’ll just enter `npm start` in the
    console. npm supports more than a dozen script commands right out of the box (see
    the npm-scripts documentation for details, [https://docs.npmjs.com/misc/scripts](https://docs.npmjs.com/misc/scripts)).
    You can also add new custom commands specific to your development and deployment
    workflow.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你只需在控制台中输入`npm start`即可。npm支持十几个开箱即用的脚本命令（有关详细信息，请参阅npm-scripts文档，[https://docs.npmjs.com/misc/scripts](https://docs.npmjs.com/misc/scripts)）。你还可以添加针对你的开发和部署工作流程的新自定义命令。
- en: Some of these scripts need to be run manually (such as `npm start`), and some
    are invoked automatically if they have the `post` and `pre` prefixes (for example,
    `post-install`). If any command in the `scripts` section starts with the `post`
    prefix, it’ll run automatically after the corresponding command specified after
    this prefix.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些脚本需要手动运行（例如`npm start`），而一些脚本如果具有`post`和`pre`前缀则会自动调用（例如，`post-install`）。如果`scripts`部分中的任何命令以`post`前缀开头，它将在该前缀之后指定的相应命令运行后自动执行。
- en: 'For example, if you define the command `"postinstall": "myCustomInstall.js"`,
    each time you run `npm install`, the script myCustomInstall.js will automatically
    run right after. Similarly, if a command has a `pre` prefix, such a command will
    run before the command named after this prefix.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，如果你定义了命令`"postinstall": "myCustomInstall.js"`，每次你运行`npm install`时，脚本myCustomInstall.js将自动运行。同样，如果一个命令具有`pre`前缀，那么这样的命令将在该前缀之后命名的命令之前运行。'
- en: 'If you define custom commands that aren’t known by npm scripts, you’ll need
    to use an additional option: `run`. Say you defined a custom command `startDev`
    like this:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你定义了npm脚本所不知道的自定义命令，你需要使用一个额外的选项：`run`。比如说，你定义了一个自定义命令`startDev`，如下所示：
- en: '[PRE26]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To run that command, you need to enter the following in your terminal window:
    `npm run startDev`. To automate running some of your custom commands, use the
    same prefixes: `post` and `pre`.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行该命令，你需要在终端窗口中输入以下内容：`npm run startDev`。为了自动化运行一些自定义命令，使用相同的`post`和`pre`前缀。
- en: 'Let’s see how to create a sequence of runnable commands for deploying an Angular
    app on the Node server. Open package.json from the client directory, and you’ll
    find four custom commands there: `build`, `postbuild`, `predeploy`, and `deploy`.
    The following listing shows what will happen if you run a single command: `npm
    run build`.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建一个可运行的命令序列，用于在Node服务器上部署Angular应用。打开client目录下的package.json文件，你将找到四个自定义命令：`build`、`postbuild`、`predeploy`和`deploy`。以下列表显示了运行单个命令`npm
    run build`时会发生什么：
- en: Listing 12.18\. A fragment from client/package.json
  id: totrans-302
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表12.18。client/package.json的一个片段
- en: '[PRE27]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '***1* The command ng build will create a production build of the restclient
    app in the default directory dist.**'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* ng build命令将在默认目录dist中创建restclient应用的生成版本。**'
- en: '***2* Since there’s a postbuild command, it starts automatically and will try
    to run the deploy command.**'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 由于存在postbuild命令，它将自动启动并尝试运行部署命令。**'
- en: '***3* Since there’s also a predeploy command there, it’ll run after the postbuild
    and before deploy.**'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 由于还有一个predeploy命令，它将在postbuild之后和deploy之前运行。**'
- en: '***4* Finally, the deploy command is executed.**'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 最后，执行部署命令。**'
- en: We’ll explain what the commands `predeploy` and `deploy` do in a minute, but
    our main message here is that starting a single command resulted in running four
    commands in the specified order. Creating a sequence of deployment commands is
    easy.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在一分钟内解释`predeploy`和`deploy`命令的作用，但我们的主要信息是，启动一个单独的命令导致了在指定顺序中运行四个命令。创建一系列部署命令很容易。
- en: '|  |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-310
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you build the bundles with AOT compilation and use only standard Angular
    decorators (no custom ones), you can further optimize the size of the JavaScript
    in your app by commenting out the line `import 'core-js/es7/ reflect';` in the
    polyfills.ts file. This will reduce the size of the generated polyfill bundle.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用AOT编译构建包，并且只使用标准的Angular装饰器（没有自定义的），你可以在polyfills.ts文件中注释掉`import 'core-js/es7/reflect';`这一行来进一步优化你应用中JavaScript的大小。这将减小生成的polyfill包的大小。
- en: '|  |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Typically, the deployment process removes the directory with previously deployed
    files, creates a new empty directory, and copies the new files into this directory.
    In your deployment scripts, you use three npm packages that know how to do these
    operations, regardless of the platform you use (Windows, Unix, or macOS):'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，部署过程会删除之前部署的文件所在的目录，创建一个新的空目录，并将新文件复制到这个目录中。在你的部署脚本中，你使用三个npm包来执行这些操作，无论你使用的是Windows、Unix还是macOS平台：
- en: '**`rimraf`—** Removes the specified directory and its subdirectories'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`rimraf`——** 删除指定的目录及其子目录'
- en: '**`mkdirp`—** Creates a new directory'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`mkdirp`——** 创建一个新的目录'
- en: '**`copyfiles`—** Copies files from source to destination'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`copyfiles`——** 从源复制文件到目标'
- en: Check the devDependencies section in package.json, and you’ll see `rimraf`,
    `mkdirp`, and `copyfiles` there.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在package.json的devDependencies部分中检查，你会看到`rimraf`、`mkdirp`和`copyfiles`。
- en: '|  |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-319
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: Currently, Angular CLI uses Webpack to build bundles. Angular CLI 7 will come
    with new build tools. In particular, it’ll include Closure Compiler, which produces
    smaller bundles.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Angular CLI使用Webpack来构建包。Angular CLI 7将包含新的构建工具。特别是，它将包括Closure Compiler，它产生更小的包。
- en: '|  |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'The code that comes with this chapter is located in two sibling directories:
    client and server. Your `predeploy` command removes the content of the server/build/public
    directory (this is where you’ll deploy the Angular app) and then creates a new
    empty public directory. The `&&` sign allows you to define commands that run more
    than one script.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 本章附带代码位于两个兄弟目录中：client和server。你的`predeploy`命令会删除服务器/build/public目录的内容（这是你将部署Angular应用的地方），然后创建一个新的空公共目录。`&&`符号允许你定义运行多个脚本的命令。
- en: The `deploy` command copies the content of the client/dist directory (the app’s
    bundles and assets) into server/build/public.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`deploy`命令将客户端/dist目录的内容（应用的包和资源）复制到服务器/build/public。'
- en: In the real world, you may need to deploy an Angular app on a remote server,
    so using the package copyfiles won’t work. Consider using an SCP utility (see
    [https://en.wikipedia.org/wiki/Secure_copy](https://en.wikipedia.org/wiki/Secure_copy))
    that performs secure file transfer from a local computer to a remote one.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中，你可能需要在远程服务器上部署一个Angular应用，所以使用package copyfiles将不会工作。考虑使用SCP实用程序（见[https://en.wikipedia.org/wiki/Secure_copy](https://en.wikipedia.org/wiki/Secure_copy)），它可以从本地计算机安全地传输文件到远程计算机。
- en: 'If you can manually run a utility from the terminal window, you can run it
    using npm scripts as well. In [chapter 14](kindle_split_023.xhtml#ch14), you’ll
    learn how to write test scripts. Including a test runner into your build process
    could be as simple as adding `&& ng test` to your `predeploy` command. If you
    find some useful gulp plugins, create the npm script for it, for example, `"myGulpCommand"
    : "gulp SomeUsefulTask"`.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你可以从终端窗口手动运行一个实用程序，你也可以使用npm脚本来运行它。在[第14章](kindle_split_023.xhtml#ch14)中，你将学习如何编写测试脚本。将测试运行器包含到构建过程中可能只需将`&&
    ng test`添加到你的`predeploy`命令中。如果你发现了一些有用的gulp插件，为它创建一个npm脚本，例如，`"myGulpCommand"
    : "gulp SomeUsefulTask"`。'
- en: 'To see that your deployment scripts work, perform the following steps:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证你的部署脚本是否工作，请执行以下步骤：
- en: '**1**.  Start the server by running the following command in the server directory:'
  id: totrans-327
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 在服务器目录中运行以下命令以启动服务器：'
- en: ''
  id: totrans-328
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`node build/rest-server-angular`'
  id: totrans-329
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`node build/rest-server-angular`'
- en: '**2**.  In the client directory, run the build and deployment scripts:'
  id: totrans-330
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 在客户端目录中，运行构建和部署脚本：'
- en: ''
  id: totrans-331
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`npm run build`'
  id: totrans-332
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`npm run build`'
- en: ''
  id: totrans-333
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Check the server/build/public directory—the client’s bundles should be there.
  id: totrans-334
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 检查服务器/构建/公共目录——客户端的包应该在那里。
- en: '**3**.  Open your browser to http://localhost:8000, and your Angular app will
    be loaded from your Node server showing three products, as shown in [figure 12.9](#ch12fig09).'
  id: totrans-335
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. 打开浏览器访问 http://localhost:8000，你的 Angular 应用将从 Node 服务器加载，显示三个产品，如图 12.9
    所示 [figure 12.9](#ch12fig09)。'
- en: We’ve described the entire process of creating and running a web server, as
    well as creating and running Angular apps in dev mode and deploying in the server.
    Your Angular app was using the `HttpClient` service to issue HTTP GET requests
    to retrieve data from the server. Now let’s see how to issue HTTP POST requests
    to post data to the server.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经描述了创建和运行网络服务器、创建和运行 Angular 应用程序（以开发模式运行）以及部署到服务器的整个过程。你的 Angular 应用程序使用
    `HttpClient` 服务发出 HTTP GET 请求从服务器检索数据。现在让我们看看如何发出 HTTP POST 请求将数据发送到服务器。
- en: 12.5\. Posting data to the server
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.5\. 向服务器发送数据
- en: HTTP POST requests are used for sending new data to the server. With `HttpClient`,
    making POST requests is similar to making GET requests. Invoking the `HttpClient.post()`
    method declares your intention to post data to the specified URL, but the request
    is made when you invoke `subscribe()`.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP POST 请求用于向服务器发送新数据。使用 `HttpClient`，发送 POST 请求与发送 GET 请求类似。调用 `HttpClient.post()`
    方法表明你打算向指定的 URL 发送数据，但请求是在调用 `subscribe()` 时发出的。
- en: '|  |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-340
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: For updating existing data on the server, use `HttpClient.put()`; and for deleting
    data, use `HttpClient.delete()`.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更新服务器上的现有数据，使用 `HttpClient.put()`；对于删除数据，使用 `HttpClient.delete()`。
- en: '|  |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 12.5.1\. Creating a server for handling post requests
  id: totrans-343
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.5.1\. 创建处理 POST 请求的服务器
- en: You need a web server with an endpoint that knows how to handle POST requests
    issued by the client. The code that comes with this chapter includes a server
    with an /api/product endpoint for adding new products, located in the rest-server-angular-post.ts
    file. Because your goal isn’t to have a fully functional server for adding and
    saving products, the /api/product endpoint will simply log the posted data on
    the console and send a confirmation message to the client.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一个能够处理客户端发出的 POST 请求的网络服务器和端点。本章附带的服务器代码包括一个位于 rest-server-angular-post.ts
    文件中的 /api/product 端点，用于添加新产品。因为你的目标不是拥有一个能够添加和保存产品的完整功能服务器，所以 /api/product 端点将简单地记录控制台上的已发布数据并向客户端发送确认消息。
- en: The posted data will arrive in the request body, and you need to be able to
    parse it to extract the data. The npm package body-parser knows how to do this
    in Express servers. If you open package.json in the server directory, you’ll find
    body-parser in the dependencies section. The entire code of your server is shown
    in the following listing.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 发送到请求体的数据将到达，你需要能够解析它以提取数据。npm 包 body-parser 知道如何在 Express 服务器中这样做。如果你在服务器目录中打开
    package.json，你将在依赖项部分找到 body-parser。你的服务器代码的整个代码如下所示。
- en: Listing 12.19\. rest-server-angular-post.ts
  id: totrans-346
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.19\. rest-server-angular-post.ts
- en: '[PRE28]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '***1* Adds the body-parser package**'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 添加 body-parser 包**'
- en: '***2* Creates the parser to turn the payload of req.body into JSON**'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 创建解析器将 req.body 的负载转换为 JSON**'
- en: '***3* Creates an endpoint for handling POST requests**'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 创建处理 POST 请求的端点**'
- en: '***4* Logs the payload of the POST request**'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 记录 POST 请求的负载**'
- en: '***5* Sends the confirmation message to the client**'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 向客户端发送确认消息**'
- en: 'Your server expects the payload in a JSON format, and it’ll send the response
    back as a JSON object with one property: `message`. Start this server by running
    the following command in the server directory (don’t forget to run `tsc` to compile
    it):'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 你的服务器期望以 JSON 格式接收负载，并且它将以包含一个属性 `message` 的 JSON 对象的形式发送响应。通过在服务器目录中运行以下命令来启动此服务器（不要忘记运行
    `tsc` 来编译它）：
- en: '[PRE29]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '|  |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Testing a RESTful API**'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试 RESTful API**'
- en: When you create web servers with REST endpoints, you should test them to ensure
    that the endpoints work properly even before you start writing any client code.
    Your IDE may offer such a tool. For example, the WebStorm IDE has a menu item,
    Test RESTful Web Service, under Tools. After entering all the data to test your
    server, this tool looks like the following figure.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 REST 端点创建网络服务器时，你应该测试它们以确保在开始编写任何客户端代码之前端点能够正常工作。你的 IDE 可能提供这样的工具。例如，WebStorm
    IDE 在“工具”菜单下有一个“测试 RESTful Web 服务”的菜单项。在输入所有测试服务器的数据后，这个工具看起来如下所示。
- en: '![](Images/f0302-01_alt.jpg)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f0302-01_alt.jpg)'
- en: Using WebStorm’s Test RESTful client
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 WebStorm 的 Test RESTful 客户端
- en: '![](Images/f0302-02_alt.jpg)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f0302-02_alt.jpg)'
- en: The server response
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器响应
- en: Press the green play button, and you’ll see the response of your /api/product
    endpoint under the Response tab, as shown in the next figure.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 按下绿色播放按钮，你将在响应选项卡下看到你的/api/product端点的响应，如图所示的下图。
- en: '![](Images/f0302-03_alt.jpg)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f0302-03_alt.jpg)'
- en: The server response
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器响应
- en: If your IDE doesn’t offer such a testing tool, use the Chrome extension called
    Advanced REST Client ([https://install.advancedrestclient.com/#/install](https://install.advancedrestclient.com/#/install))
    or a tool called Postman ([www.getpostman.com](http://www.getpostman.com)).
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的IDE没有提供这样的测试工具，请使用名为Advanced REST Client的Chrome扩展程序（[https://install.advancedrestclient.com/#/install](https://install.advancedrestclient.com/#/install)）或名为Postman的工具（[www.getpostman.com](http://www.getpostman.com)）。
- en: '|  |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Now that you’ve created, started, and tested the web server, let’s write the
    Angular client that will post new products to this server.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建、启动并测试了Web服务器，让我们编写将新产品发布到该服务器的Angular客户端。
- en: 12.5.2\. Creating a client for making post requests
  id: totrans-368
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.5.2\. 创建用于发送POST请求的客户端
- en: Your Angular app will render a simple form where the user can enter the product
    title and price, as shown in [figure 12.11](#ch12fig11).
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 你的Angular应用将渲染一个简单的表单，用户可以在其中输入产品标题和价格，如图 12.11 所示。
- en: Figure 12.11\. UI for adding new products
  id: totrans-370
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 12.11\. 添加新产品的UI
- en: '![](Images/12fig11.jpg)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/12fig11.jpg)'
- en: After filling out the form and clicking the Add Product button, the server will
    respond with the confirmation message shown under the button.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在填写完表单并点击添加产品按钮后，服务器将响应按钮下显示的确认消息。
- en: In this app, you’ll use the template-driven Forms API, and your form will require
    the user to enter the new product’s title and price. On the button click, you’ll
    invoke the method `HttpClient.post()`, followed by `subscribe()`.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用中，你将使用模板驱动的表单API，你的表单将要求用户输入新产品标题和价格。在按钮点击时，你将调用`HttpClient.post()`方法，然后是`subscribe()`。
- en: The code of this Angular app is located in the client directory under the restclientpost
    subdirectory. It’s shown in the following listing.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Angular应用的代码位于restclientpost子目录下的client目录中。如下所示。
- en: Listing 12.20\. app.component.ts
  id: totrans-375
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.20\. app.component.ts
- en: '[PRE30]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '***1* Declares the intention to make a POST request**'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 声明发起POST请求的意图**'
- en: '***2* Provides the POST payload**'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 提供POST有效负载**'
- en: '***3* Makes the HTTP POST request**'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 发起HTTP POST请求**'
- en: '***4* Gets the server’s response**'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 获取服务器的响应**'
- en: '***5* Handles errors**'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 处理错误**'
- en: When the user clicks Add Product, the app makes a POST request and subscribes
    to the server response. `formValue` contains a JavaScript object with the data
    entered in the form, and `HttpClient` automatically turns it into a JSON object.
    If the data was posted successfully, the server returns a JSON object with the
    `message` property, which is rendered using data binding.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击添加产品时，应用会发起POST请求并订阅服务器响应。`formValue`包含一个JavaScript对象，其中包含在表单中输入的数据，`HttpClient`会自动将其转换为JSON对象。如果数据已成功发布，服务器将返回一个包含`message`属性的JSON对象，该属性通过数据绑定进行渲染。
- en: If the server responds with an error, you display it in the UI. Note that you
    use `err.message` and `err.error.message` to extract the error description. The
    second property may contain additional error details. Modify the code of the server
    to return a string instead of JSON, and the UI will show a detailed error message.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器响应错误，你将在UI中显示它。注意，你使用`err.message`和`err.error.message`来提取错误描述。第二个属性可能包含额外的错误详情。修改服务器的代码，使其返回字符串而不是JSON，UI将显示详细的错误信息。
- en: 'To see this app in action, run the following command in the project client:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此应用的实际运行情况，请在项目client中运行以下命令：
- en: '[PRE31]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You now know how to send HTTP requests and handle responses, and there could
    be lots of them in your app. Is there a way to intercept all of them to provide
    some additional processing, like showing/hiding the progress bar, or logging requests?
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在知道如何发送HTTP请求和处理响应，你的应用中可能会有很多这样的请求。有没有一种方法可以拦截所有这些请求以提供一些额外的处理，比如显示/隐藏进度条，或者记录请求？
- en: 12.6\. HTTP interceptors
  id: totrans-387
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.6\. HTTP拦截器
- en: Angular allows you to create HTTP interceptors for pre- and post-processing
    of all HTTP requests and responses of your app. They can be useful for implementing
    such cross-cutting concerns as logging, global error handling, authentication,
    and others. We’d like to stress that the interceptors work *before* the request
    goes out or before a response is rendered on the UI. This gives you a chance to
    implement the fallback scenarios for certain errors or prevent attempts of unauthorized
    access.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: Angular允许你为应用程序中所有HTTP请求和响应的预处理和后处理创建HTTP拦截器。它们对于实现诸如日志记录、全局错误处理、身份验证等跨切面关注点非常有用。我们想强调的是，拦截器在请求发出之前或在UI上渲染响应之前工作。这给你提供了一个机会来实现某些错误的重试场景或防止未授权访问的尝试。
- en: 'To create an interceptor, you need to write a service that implements the `HttpInterceptor`
    interface, which requires you to implement one method: `intercept()`. Angular
    will provide two arguments to this callback: `HttpRequest` and `HttpHandler`.
    The first one contains the request object being intercepted, which you can clone
    and modify. The second argument is used to forward the modified request to the
    backend or another interceptor in the chain (if any) by invoking the `handle()`
    method.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个拦截器，你需要编写一个实现`HttpInterceptor`接口的服务，这要求你实现一个方法：`intercept()`。Angular将为这个回调提供两个参数：`HttpRequest`和`HttpHandler`。第一个参数包含被拦截的请求对象，你可以克隆并修改它。第二个参数用于通过调用`handle()`方法将修改后的请求转发到后端或链中的另一个拦截器（如果有的话）。
- en: '|  |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-391
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The `HttpRequest` and `HttpResponse` objects are immutable, and the word *modify*
    means creating and passing through the new instances of these objects.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpRequest`和`HttpResponse`对象是不可变的，而“修改”一词意味着创建并传递这些对象的新实例。'
- en: '|  |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The interceptor service shown in the following listing doesn’t modify the outgoing
    `HttpRequest` but simply prints its content on the console and passes it through
    as is.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表中显示的拦截器服务不会修改输出的`HttpRequest`，而只是简单地将其内容打印到控制台并原样传递。
- en: Listing 12.21\. A simple interceptor
  id: totrans-395
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.21\. 一个简单的拦截器
- en: '[PRE32]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In [listing 12.21](#ch12ex21), you forward the `HttpRequest`, but you could
    modify its headers or parameters and return the modified request. The `next.handle()`
    method returns an observable when the request is complete, and if you want to
    modify the HTTP response as well, apply additional RxJS operators on the stream
    returned by `next.handle()`.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 12.21](#ch12ex21)中，你转发`HttpRequest`，但你可以修改其头部或参数，并返回修改后的请求。`next.handle()`方法在请求完成时返回一个可观察对象，如果你想同时修改HTTP响应，可以在`next.handle()`返回的流上应用额外的RxJS操作符。
- en: The `intercept()` method receives the `HttpRequest` object and returns, not
    the `HttpResponse` object, but the observable of `HttpEvent`, because Angular
    implements `HttpResponse` as a stream of `HttpEvent` values.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '`intercept()`方法接收`HttpRequest`对象并返回，不是`HttpResponse`对象，而是`HttpEvent`的可观察对象，因为Angular将`HttpResponse`实现为一个`HttpEvent`值的流。'
- en: Both `HttpRequest` and `HttpResponse` are immutable, and if you want to modify
    their properties, you need to clone them first, as in the following listing.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpRequest`和`HttpResponse`都是不可变的，如果你想修改它们的属性，你需要先克隆它们，如下面的列表所示。'
- en: Listing 12.22\. Modifying `HTTPRequest`
  id: totrans-400
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.22\. 修改 `HTTPRequest`
- en: '[PRE33]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Because an interceptor is an injectable service, don’t forget to declare its
    provider for the `HTTP_INTERCEPTORS` token in the `@NgModule()` decorator:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 因为拦截器是一个可注入的服务，不要忘记在`@NgModule()`装饰器中声明其提供者以`HTTP_INTERCEPTORS`令牌：
- en: '[PRE34]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `multi: true` option tells you that `HTTP_INTERCEPTORS` is a multiprovider
    token—an array of services can represent the same token. You can register more
    than one interceptor, and Angular will inject all of them:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '`multi: true`选项告诉你`HTTP_INTERCEPTORS`是一个多提供者令牌——一组服务可以代表相同的令牌。你可以注册多个拦截器，Angular将注入所有这些拦截器：'
- en: '[PRE35]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '|  |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-407
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If you have more than one interceptor, they’ll be invoked in the order they’re
    defined.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你定义了多个拦截器，它们将按照定义的顺序被调用。
- en: '|  |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: To illustrate how interceptors work, let’s create an app with an `HttpInterceptor`
    that will intercept and log all errors returned by the server. For the client,
    you’ll reuse the app from [section 12.5.2](#ch12lev2sec10) shown in [figure 12.11](#ch12fig11),
    adding the logging service and the interceptor to log errors on the console.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明拦截器的工作原理，让我们创建一个带有`HttpInterceptor`的应用程序，该拦截器将拦截并记录服务器返回的所有错误。对于客户端，你将重用[第
    12.5.2 节](#ch12lev2sec10)中显示的应用程序，该应用程序如[图 12.11](#ch12fig11)所示，添加日志服务和拦截器以在控制台记录错误。
- en: You’ll slightly modify the server from the previous section to randomly generate
    errors. You can find the complete code of the server in the rest-server-angular-post-errors.ts
    file. Now, instead of just responding with success messages, it’ll randomly return
    an error, as shown in the following listing.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 你将稍微修改前一个章节中的服务器以随机生成错误。你可以在 rest-server-angular-post-errors.ts 文件中找到服务器的完整代码。现在，它将不再只是响应成功消息，而是随机返回一个错误，如下所示。
- en: Listing 12.23\. Emulating server errors
  id: totrans-412
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.23\. 模拟服务器错误
- en: '[PRE36]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '***1* Returns an HTTP response with the status 500**'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 返回状态为 500 的 HTTP 响应**'
- en: '***2* Returns a successful HTTP response**'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 返回成功的 HTTP 响应**'
- en: 'Start this server as follows:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下方式启动此服务器：
- en: '[PRE37]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Your Angular app is located in the interceptor directory and includes a logging
    service implemented as two classes: `LoggingService` and `ConsoleLoggingService`.
    `LoggingService` is an abstract class that declares one method, `log()`.'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 Angular 应用位于拦截器目录中，并包含一个作为两个类实现的日志服务：`LoggingService` 和 `ConsoleLoggingService`。`LoggingService`
    是一个抽象类，它声明了一个方法，`log()`。
- en: Listing 12.24\. logging.service.ts
  id: totrans-419
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.24\. logging.service.ts
- en: '[PRE38]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Because this class is abstract, it can’t be instantiated, and you’ll create
    the class `ConsoleLoggingService` shown in the following listing.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个类是抽象的，所以不能被实例化，你将创建如下所示的 `ConsoleLoggingService` 类。
- en: Listing 12.25\. console.logging.service.ts
  id: totrans-422
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.25\. console.logging.service.ts
- en: '[PRE39]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You may be wondering why you create the abstract class for such a simple logging
    service. It’s because in real-world apps, you may want to introduce logging, not
    only on the browser’s console, but also on the server. Having an abstract class
    would allow you to use it as a token for declaring a provider:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么你会为这样一个简单的日志服务创建一个抽象类。这是因为在实际应用中，你可能不仅想在浏览器的控制台中引入日志，还可能在服务器上引入。拥有一个抽象类将允许你将其用作声明提供者的令牌：
- en: '[PRE40]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Later on, you can create a class called `ServerLoggingService` that implements
    `LoggingService`, and to switch from console to server logging, you’ll need to
    change the provider without having to modify components that use it:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你可以创建一个名为 `ServerLoggingService` 的类，该类实现了 `LoggingService`，并且要从控制台日志切换到服务器日志，你需要更改提供者，而无需修改使用它的组件：
- en: '[PRE41]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If your interceptor receives an error, you’ll do the following:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的拦截器收到错误，你会做以下操作：
- en: '**1**.  Log it on the console.'
  id: totrans-429
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**.  在控制台上记录它。'
- en: '**2**.  Replace the `HttpErrorResponse` with a new instance of `HttpResponse`
    that will contain the error message.'
  id: totrans-430
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**.  将 `HttpErrorResponse` 替换为包含错误消息的新实例 `HttpResponse`。'
- en: '**3**.  Return the new `HttpResponse` so the client can show it to the user.'
  id: totrans-431
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**.  返回新的 `HttpResponse`，以便客户端可以向用户显示它。'
- en: The interceptor class will use the `catchError` operator on the observable returned
    by `HttpHandler.next()`, where you’ll implement these steps. Your interceptor
    is implemented in the logging.interceptor.service.ts file.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 拦截器类将在 `HttpHandler.next()` 返回的可观察对象上使用 `catchError` 操作符，你将在其中实现这些步骤。你的拦截器在
    logging.interceptor.service.ts 文件中实现。
- en: Listing 12.26\. logging.interceptor.service.ts
  id: totrans-433
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.26\. logging.interceptor.service.ts
- en: '[PRE42]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '***1* Injects the console logging service**'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 注入控制台日志服务**'
- en: '***2* Forwards requests to the server and responses to the client**'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将请求转发到服务器，将响应转发到客户端**'
- en: '***3* Catches the response errors returned by the server**'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 捕获服务器返回的响应错误**'
- en: '***4* Logs the error message on the console**'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 在控制台上记录错误消息**'
- en: '***5* Replaces HttpErrorResponse with HttpResponse**'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 用 `HttpResponse` 替换 `HttpErrorResponse`**'
- en: '***6* The new HttpResponse will contain the error message.**'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 新的 `HttpResponse` 将包含错误消息。**'
- en: The code for the application component has no references to the interceptor
    class, as you’ll see in the following listing. It’ll be always receiving `HttpResponse`
    objects that contain either a message that the server successfully added a new
    product, or an error message.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序组件的代码没有拦截器类的引用，如下所示。它将始终接收包含服务器成功添加新产品或错误消息的消息的 `HttpResponse` 对象。
- en: Listing 12.27\. app.component.ts
  id: totrans-442
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.27\. app.component.ts
- en: '[PRE43]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '***1* Renders any messages received from the server (including errors)**'
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 渲染从服务器接收到的任何消息（包括错误）**'
- en: '***2* This observable is for the interceptor’s responses.**'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 这个可观察对象是拦截器的响应。**'
- en: '***3* Expects the server’s responses to HTTP POST as {message: string}**'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 期望服务器对 HTTP POST 的响应为 {message: string}**'
- en: '***4* Extracts the text of the message property**'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 提取消息属性的文本**'
- en: When you compare this app with the one from the previous section, note that
    you don’t handle errors in the component, which renders the messages to the UI.
    Now the `LoggingInterceptor` will handle all HTTP errors.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将此应用与上一节中的应用进行比较时，请注意，你不需要在组件中处理错误，该组件将消息渲染到UI上。现在`LoggingInterceptor`将处理所有HTTP错误。
- en: To see this app in action, run the following command and monitor the browser
    console for logging messages.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此应用的实际运行情况，请运行以下命令并监控浏览器控制台中的日志消息。
- en: '[PRE44]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This app should give you an idea of how to implement a cross-cutting concern
    like a global error-logging service for all HTTP responses without the need to
    modify any application components or services that use the `HttpClient` service.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用应能给你一个如何实现跨切面关注点，如全局错误日志服务，用于所有HTTP响应的思路，而无需修改任何使用`HttpClient`服务的应用程序组件或服务。
- en: An HTTP request runs asynchronously and can generate a number of progress events
    that you might want to intercept and handle. Let’s look at how you’d do that.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP请求是异步的，可以生成多个你可能想要拦截和处理的事件。让我们看看如何做到这一点。
- en: 12.7\. Progress events
  id: totrans-453
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.7\. 进度事件
- en: Sometimes uploading or downloading certain assets (like large data files or
    images) takes time, and you should keep the user informed about the progress.
    `HttpClient` offers progress events that contain information like total size of
    the asset, current number of bytes that are already uploaded or downloaded, and
    more.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 有时上传或下载某些资产（如大型数据文件或图像）需要时间，你应该让用户了解进度。`HttpClient`提供了包含资产总大小、当前已上传或下载的字节数等信息的事件。
- en: 'To enable progress events tracking, make your requests using the `HttpRequest`
    object with the option `{reportProgress: true}`. For example, you can make an
    HTTP GET request that reads the my_large_file.json file.'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '要启用进度事件跟踪，请使用带有选项`{reportProgress: true}`的`HttpRequest`对象发出请求。例如，你可以发出一个HTTP
    GET请求来读取my_large_file.json文件。'
- en: Listing 12.28\. Making a GET request with events tracking
  id: totrans-456
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表12.28\. 使用事件跟踪进行GET请求
- en: '[PRE45]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '***1* Declares an intention to make a GET request**'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 声明发起GET请求的意图**'
- en: '***2* Specifies the file to read**'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 指定要读取的文件**'
- en: '***3* Enables progress event**'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 启用进度事件**'
- en: '***4* Makes a request**'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 发起请求**'
- en: In the `subscribe()` method, check whether the emitted value is an event of
    the type you’re interested in, for example, `HttpEventType.DownloadProgress` or
    `HttpEventType.UploadProgress`. These events have the `loaded` property for the
    current number of transferred bytes and the `total` property, which knows the
    total size of the transfer.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 在`subscribe()`方法中，检查发射的值是否是你感兴趣的事件类型，例如`HttpEventType.DownloadProgress`或`HttpEventType.UploadProgress`。这些事件具有`loaded`属性，表示当前已传输的字节数，以及`total`属性，表示传输的总大小。
- en: The next app shows how to handle a progress event for calculating and showing
    the percentage of the file download. This app comes with a large 48 MB JSON file.
    The content of the file is irrelevant in this case. [Figure 12.12](#ch12fig12)
    shows the app when the download of the file is complete. The percentage on the
    left is changing as this file is being loaded by `HttpClient`. This app also reports
    the progress on the browser’s console.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个应用展示了如何处理进度事件以计算和显示文件下载的百分比。此应用包含一个大的48 MB JSON文件。在此情况下，文件内容无关紧要。[图12.12](#ch12fig12)显示了文件下载完成后应用的状态。左侧的百分比在文件通过`HttpClient`加载时正在变化。此应用还会在浏览器的控制台中报告进度。
- en: Figure 12.12\. Reporting progress while reading a file
  id: totrans-464
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.12\. 读取文件时的进度报告
- en: '![](Images/12fig12_alt.jpg)'
  id: totrans-465
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/12fig12_alt.jpg)'
- en: This app is located in the progressevents directory, and the content of app.component
    .ts is shown in the next listing.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用位于progressevents目录中，app.component.ts文件的内容如下所示。
- en: Listing 12.29\. app.component.ts
  id: totrans-467
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表12.29\. app.component.ts
- en: '[PRE46]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '***1* Renders the current percentage**'
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 渲染当前百分比**'
- en: '***2* Declares an intention to make a GET request**'
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 声明发起GET请求的意图**'
- en: '***3* Specifies the file to read**'
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 指定要读取的文件**'
- en: '***4* Enables the progress event tracking**'
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 启用进度事件跟踪**'
- en: '***5* Checks the type of the progress event**'
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 检查进度事件的类型**'
- en: '***6* Calculates the current percentage**'
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 计算当前百分比**'
- en: '***7* Emitted value is not a progress event**'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 发射的值不是进度事件**'
- en: 'To see this app in action, run the following command:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此应用的实际运行情况，请运行以下命令：
- en: '[PRE47]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This app concludes our coverage of communicating with web servers using HTTP.
    In the next chapter, you’ll see how an Angular client can communicate with web
    servers using WebSockets.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用总结了使用HTTP与Web服务器通信的内容。在下一章中，您将看到Angular客户端如何使用WebSockets与Web服务器通信。
- en: Summary
  id: totrans-479
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Angular comes with the `HttpClient` service, which supports HTTP communications
    with web servers.
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular自带`HttpClient`服务，该服务支持与Web服务器的HTTP通信。
- en: Public methods of `HttpClient` return an `Observable` object, and only when
    the client subscribes to it is the request to the server made.
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HttpClient`的公共方法返回一个`Observable`对象，并且只有当客户端订阅它时，才会向服务器发出请求。'
- en: An Angular client can communicate with web servers implemented in different
    technologies.
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular客户端可以与使用不同技术实现的Web服务器通信。
- en: You can intercept and replace HTTP requests and responses with modified ones
    to implement cross-cutting concerns.
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以拦截并替换HTTP请求和响应，以实现跨切面关注点。
