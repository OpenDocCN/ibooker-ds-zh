- en: 3 Series methods
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 个 `Series` 方法
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Importing CSV data sets with the `read_csv` function
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `read_csv` 函数导入 CSV 数据集
- en: Sorting `Series` values in ascending and descending order
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按升序和降序排序 `Series` 值
- en: Retrieving the largest and smallest values in a `Series`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `Series` 中检索最大和最小值
- en: Counting occurrences of unique values in a `Series`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `Series` 中计数唯一值的出现次数
- en: Invoking a function with every value in a `Series`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `Series` 的每个值上调用函数
- en: In chapter 2, we began exploring the `Series` object, a one-dimensional labeled
    array of homogeneous values. We populated our `Series` with data from different
    sources, including lists, dictionaries, and NumPy `ndarrays`. We observed how
    pandas assigned each `Series` value an index label and an index position. We learned
    how to apply mathematical operations to `Series`.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2章中，我们开始探索 `Series` 对象，这是一个一维的、带有同质值的标签数组。我们从不同的来源填充了我们的 `Series`，包括列表、字典和
    NumPy `ndarrays`。我们观察了 pandas 如何为每个 `Series` 值分配一个索引标签和一个索引位置。我们学习了如何对 `Series`
    应用数学运算。
- en: With the basics under our belt, we’re ready to explore some real-world data
    sets! In this chapter, we’ll introduce lots of advanced `Series` operations, including
    sorting, counting, and bucketing. We’ll also start to see how these methods can
    help us derive insights from our data. Let’s dive in.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握基础知识后，我们准备探索一些真实世界的数据集！在本章中，我们将介绍许多高级 `Series` 操作，包括排序、计数和分桶。我们还将开始看到这些方法如何帮助我们从数据中得出见解。让我们深入探讨。
- en: 3.1 Importing a data set with the read_csv function
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 使用 `read_csv` 函数导入数据集
- en: 'A *CSV* is a plain-text file that separates each row of data with a line break
    and each row value with a comma. The first row in the file holds the column headers
    for the data. This chapter has three CSV files for us to play with:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*CSV* 是一个纯文本文件，它使用换行符分隔每行数据，使用逗号分隔每行值。文件的第一行包含数据的列标题。本章为我们提供了三个 CSV 文件来操作：'
- en: '*pokemon.csv*—A list of more than 800 Pokémon, the cartoon monsters from Nintendo’s
    popular media franchise. Each Pokémon has one or more associated types, such as
    Fire, Water, and Grass.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*pokemon.csv*—一个包含超过800种宝可梦的列表，这些宝可梦是任天堂流行媒体系列的卡通怪物。每种宝可梦都关联一个或多个类型，例如火、水、草。'
- en: '*google_stock.csv*—A collection of daily stock prices in U.S. dollars for the
    technology company Google from its market debut in August 2004 to October 2019.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*google_stock.csv*—从2004年8月上市到2019年10月的谷歌科技公司每日美元股价集合。'
- en: '*revolutionary_war.csv*—A record of battles during the American Revolutionary
    War. Each skirmish is associated with a start date and a U.S. state.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*revolutionary_war.csv*—美国独立战争期间战斗的记录。每次小冲突都与一个开始日期和一个美国州相关联。'
- en: Let’s begin by importing the data sets. As we proceed, we’ll talk through some
    optimizations we can make to pave the way for easier analysis.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们先导入数据集。在继续的过程中，我们将讨论我们可以进行的优化，以简化分析。 '
- en: 'Our first step is spinning up a new Jupyter Notebook and importing the pandas
    library. Make sure to create the notebook in the same directory as the CSV files:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步是启动一个新的 Jupyter Notebook 并导入 pandas 库。确保在 CSV 文件所在的目录中创建笔记本：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Pandas has more than a dozen import functions to load various file formats.
    The functions are available at the library’s top level and begin with the prefix
    `read.` In our case, to import a CSV, we want the `read_csv` function. The function’s
    first parameter, `filepath_or_buffer`, expects a string with the filename. Make
    sure that the string includes the .csv extension (`"pokemon.csv"`, for example,
    instead of `"pokemon"`). By default, pandas looks for the file in the same directory
    as the Notebook:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas 有十几个导入函数来加载各种文件格式。这些函数在库的最高级别可用，并以前缀 `read.` 开头。在我们的情况下，要导入 CSV，我们想要
    `read_csv` 函数。该函数的第一个参数 `filepath_or_buffer` 期望一个包含文件名的字符串。确保该字符串包含 .csv 扩展名（例如
    `"pokemon.csv"`，而不是 `"pokemon"`）。默认情况下，pandas 在笔记本所在的目录中查找文件：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Regardless of the number of columns in a data set, the `read_csv` function always
    imports the data into a `DataFrame`, a two-dimensional pandas data structure that
    supports multiple rows and columns. We’ll introduce this object in greater detail
    in chapter 4\. There’s nothing wrong with using the `DataFrame`, but we want to
    practice a bit more with the `Series`, so let’s store the CSV’s data in the smaller
    data structure.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 无论数据集中有多少列，`read_csv` 函数总是将数据导入一个 `DataFrame`，这是一个支持多行多列的二维 pandas 数据结构。我们将在第4章中详细介绍这个对象。使用
    `DataFrame` 没有问题，但我们想更多地练习 `Series`，所以让我们将 CSV 的数据存储在较小的数据结构中。
- en: 'Our first issue is that the data set has two columns (Pokemon and Type), but
    a `Series` supports only one column of data. One simple solution is setting one
    of the data set’s columns as the `Series` index. We can use the `index_col` parameter
    to set the index column. Be mindful of case sensitivity: the string must match
    the header in the data set. Let’s pass `"Pokemon"` as the argument to `index_col`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遇到的第一问题是数据集有两个列（宝可梦和类型），但 `Series` 只支持一列数据。一个简单的解决方案是将数据集的一个列设置为 `Series`
    索引。我们可以使用 `index_col` 参数来设置索引列。请注意大小写敏感性：字符串必须与数据集中的标题匹配。让我们将 `"Pokemon"` 作为 `index_col`
    的参数传递：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We’ve successfully set the Pokemon column as the `Series` index, but pandas
    still defaults to importing the data into a `DataFrame`. After all, a container
    capable of holding multiple columns of data can technically hold one column of
    data. To force pandas to use a `Series`, we need to add another parameter called
    `squeeze` and pass it an argument of `True`. The `squeeze` parameter coerces a
    one-column `DataFrame` into a `Series`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功将 Pokemon 列设置为 `Series` 索引，但 pandas 仍然默认将数据导入到 `DataFrame` 中。毕竟，一个能够容纳多列数据的容器在技术上也可以容纳一列数据。要强制
    pandas 使用 `Series`，我们需要添加另一个名为 `squeeze` 的参数，并传递一个值为 `True` 的参数。`squeeze` 参数将一列
    `DataFrame` 强制转换为 `Series`：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We officially have a `Series`. Hooray! The index labels are the Pokémon names,
    and the values are the Pokémon types.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正式拥有了一个 `Series`。太好了！索引标签是宝可梦的名字，值是宝可梦的类型。
- en: 'The output below the values reveals some important details:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 值下面的输出揭示了某些重要细节：
- en: Pandas has assigned the `Series` a name of Type, the column’s name from the
    CSV file.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pandas 将 `Series` 命名为 Type，这是 CSV 文件中的列名。
- en: The `Series` has 809 values.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Series` 有 809 个值。'
- en: '`dtype:` `object` tells us that it’s a `Series` of string values. `object`
    is pandas’ internal lingo for strings and more-complex data structures.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dtype:` `object` 告诉我们这是一个字符串值的 `Series`。`object` 是 pandas 对字符串和更复杂数据结构的内部术语。'
- en: 'The final step is assigning the `Series` to a variable. `pokemon` feels suitable
    here:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将 `Series` 赋值给一个变量。在这里 `pokemon` 感觉很合适：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The remaining two data sets carry some additional complexity. Let’s take a
    peek at google_stock.csv:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的两个数据集有一些额外的复杂性。让我们看一下 google_stock.csv：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When importing a data set, pandas infers the most suitable data type for each
    column. Sometimes, the library plays it safe and avoids making assumptions about
    our data. google_stocks.csv, for example, includes a Date column with datetime
    values in YYYY-MM-DD format (such as 2010-08-04). Unless we tell pandas to treat
    the values as datetimes, the library defaults to importing them as strings. A
    string is a more generic and versatile data type; it can represent any value.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当导入数据集时，pandas 会推断每个列最适合的数据类型。有时，库会采取保守的做法，避免对我们的数据进行假设。例如，google_stocks.csv
    包含一个日期列，其值为 YYYY-MM-DD 格式的日期时间（例如 2010-08-04）。除非我们告诉 pandas 将这些值视为日期时间，否则库默认将它们导入为字符串。字符串是一种更通用和灵活的数据类型；它可以表示任何值。
- en: Let’s explicitly tell pandas to convert the values in the Date column to datetimes.
    Although we won’t cover datetimes until chapter 11, it’s considered to be a best
    practice to store each column’s data in the most accurate type. When pandas knows
    that it has datetimes, it enables additional methods that are not available on
    plain strings, such as calculating the weekday of a date.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们明确告诉 pandas 将日期列中的值转换为日期时间。虽然我们不会在第 11 章介绍日期时间，但将每列数据存储在最准确的数据类型中被认为是最佳实践。当
    pandas 知道它有日期时间时，它将启用在普通字符串上不可用的额外方法，例如计算日期的星期几。
- en: 'The `read_csv` function’s `parse_dates` parameter accepts a list of strings
    denoting the columns whose text values pandas should convert to datetimes. The
    next example passes a list containing `"Date"`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`read_csv` 函数的 `parse_dates` 参数接受一个字符串列表，表示 pandas 应将其文本值转换为日期时间的列。下一个示例传递了一个包含
    `"Date"` 的列表：'
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'There is no visual difference in the output, but pandas is storing a different
    data type for the Date column under the hood. Let’s set the Date column as the
    `Series` index with the `index_col` parameter; a `Series` works fine with datetime
    indexes. Finally, let’s add the `squeeze` parameter to force a `Series` object
    instead of a `DataFrame`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 输出中没有视觉差异，但 pandas 在底层为日期列存储了不同的数据类型。让我们使用 `index_col` 参数将日期列设置为 `Series` 索引；`Series`
    与日期索引配合得很好。最后，让我们添加 `squeeze` 参数来强制使用 `Series` 对象而不是 `DataFrame`：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Looks good. We have a `Series` of datetime index labels and floating-point
    values. Let’s save this `Series` to a `google` variable:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错。我们有一个由日期时间索引标签和浮点值组成的`Series`。让我们将这个`Series`保存到`google`变量中：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We have one more data set to import: Revolutionary War battles. This time around,
    let’s preview the last five rows on import. We’ll chain the `tail` method to the
    `DataFrame` returned by the `read_csv` function:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个数据集要导入：美国独立战争战役。这次，让我们在导入时预览最后五行。我们将`tail`方法链接到`read_csv`函数返回的`DataFrame`：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Take a look at the State column. Uh-oh—this data set has some missing values.
    As a reminder, pandas uses the `NaN` (not a number) designation to mark absent
    values. `NaN` is a NumPy object used to represent nothingness or the absence of
    a value. This data set contains missing/absent values for battles without a definitive
    start date or those fought outside U.S. territory.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下“州”列。哎呀——这个数据集有一些缺失值。提醒一下，pandas使用`NaN`（不是一个数字）来标记缺失值。`NaN`是一个NumPy对象，用于表示无或值的缺失。这个数据集包含没有确定开始日期的战役或在美国领土外作战的战役的缺失/不存在值。
- en: 'Let’s set the Start Date column as the index. We’ll again use the `index_col`
    parameter to set the index and the `parse_dates` parameter to convert the Start
    Date strings to datetime values. Pandas can recognize this data set’s date format
    (M/D/YYYY):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将“开始日期”列设置为索引。我们再次使用`index_col`参数来设置索引，并使用`parse_dates`参数将开始日期字符串转换为日期时间值。Pandas可以识别这个数据集的日期格式（M/D/YYYY）：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'By default, the `read_csv` function imports all columns from a CSV. We’ll have
    to limit the import to two columns if we want a `Series`: one column for the index
    and the other for the values. The `squeeze` parameter by itself is insufficient
    in this scenario; pandas will ignore the parameter if there is more than one column
    of data.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`read_csv`函数从CSV文件中导入所有列。如果我们想得到一个`Series`，我们必须限制导入到两列：一列作为索引，另一列作为值。在这种情况下，`squeeze`参数本身是不够的；如果有多于一列的数据，pandas将忽略该参数。
- en: 'The `read_csv` function’s `usecols` parameter accepts a list of columns that
    pandas should import. Let’s include only Start Date and State:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`read_csv`函数的`usecols`参数接受一个列列表，pandas应该导入这些列。让我们只包括开始日期和州：'
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Perfect! We have a `Series` consisting of a datetime index and string values.
    Let’s assign this one to a `battles` variable:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！我们有一个由日期时间索引和字符串值组成的`Series`。让我们将其分配给一个`battles`变量：
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now that we’ve imported our data sets into `Series` objects, let’s see what
    we can do with them.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将数据集导入到`Series`对象中，让我们看看我们可以用它们做什么。
- en: 3.2 Sorting a Series
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 对Series进行排序
- en: We can sort a `Series` by its values or its index, in ascending or descending
    order.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按值或索引对`Series`进行排序，按升序或降序排序。
- en: 3.2.1 Sorting by values with the sort_values method
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.1 使用`sort_values`方法按值排序
- en: 'Suppose that we’re curious about the lowest and highest stock prices that Google
    has had. The `sort_values` method returns a new `Series` with the values sorted
    in ascending order. *Ascending* means increasing in size—in other words, smallest
    to greatest. The index labels move with their value counterparts:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想知道谷歌公司最低和最高的股价。`sort_values`方法返回一个新`Series`，其中的值按升序排序。*升序*意味着大小增加——换句话说，从小到大。索引标签与其值对应移动：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Pandas sorts a `Series` of strings in alphabetical order. *Ascending* means
    from the start of the alphabet to the end of the alphabet:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas按字母顺序对字符串`Series`进行排序。*升序*意味着从字母表的开始到结束：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Pandas sorts uppercase characters before lowercase characters. Thus, a capital
    `"Z"` comes before a lowercase `"a"`. In the next example, notice that the string
    `"adam"` appears *after* `"Ben"`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas在排序时将大写字母排在小写字母之前。因此，大写字母`"Z"`在小写字母`"a"`之前。在下一个例子中，请注意字符串`"adam"`出现在`"Ben"`之后：
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `ascending` parameter sets the sort order, and it has a default argument
    of `True`. To sort `Series` values in descending order (largest to smallest),
    pass the parameter an argument of `False`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`ascending`参数设置排序顺序，默认参数为`True`。要按降序（从大到小）排序`Series`值，将参数传递一个`False`的参数：'
- en: '[PRE16]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'A descending sort will arrange a `Series` of strings in reverse alphabetical
    order. *Descending* means from the end of the alphabet to the start of the alphabet:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 降序排序将字符串`Series`按逆字母顺序排列。*降序*意味着从字母表的末尾到开头：
- en: '[PRE17]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `na_position` parameter configures the placement of `NaN` values in the
    returned `Series` and has a default argument of `"last"`. By default, pandas places
    missing values at the end of a sorted `Series`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`na_position` 参数配置返回的 `Series` 中 `NaN` 值的位置，其默认参数为 `"last"`。默认情况下，pandas 将缺失值放置在排序后的
    `Series` 的末尾：'
- en: '[PRE18]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To display the missing values first, pass the `na_position` parameter an argument
    of `"first"`. The resulting `Series` shows all `NaN`s first, followed by the sorted
    values:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要首先显示缺失值，可以将 `na_position` 参数的值设置为 `"first"`。结果 `Series` 首先显示所有 `NaN`，然后是排序后的值：
- en: '[PRE19]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'What if we wanted to remove `NaN` values? The `dropna` method returns a `Series`
    with all missing values removed. Note that the method targets only `NaN`s in the
    `Series`’ values, not the index. The next example filters our battles to those
    with a present location:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想移除 `NaN` 值呢？`dropna` 方法返回一个没有缺失值的 `Series`。注意，该方法仅针对 `Series` 中的 `NaN`
    值，而不是索引。下一个示例过滤出具有当前位置的战斗：
- en: '[PRE20]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The previous `Series` is predictably shorter than `battles`. Pandas has removed
    70 `NaN` values from `battles`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的 `Series` 比预期的 `battles` 要短。Pandas 从 `battles` 中移除了 70 个 `NaN` 值。
- en: 3.2.2 Sorting by index with the sort_index method
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.2 使用 sort_index 方法按索引排序
- en: 'Sometimes, our area of focus may lie in the index rather than the values. Luckily,
    we can sort a `Series` by index as well with the `sort_index` method. With this
    option, the values move alongside their index counterparts. Like `sort_values`,
    `sort_index` accepts an `ascending` parameter, and its default argument is also
    `True`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们的关注点可能在于索引而不是值。幸运的是，我们可以使用 `sort_index` 方法按索引对 `Series` 进行排序。使用此选项，值会与其索引对应项一起移动。与
    `sort_values` 类似，`sort_index` 也接受一个 `ascending` 参数，其默认参数也是 `True`：
- en: '[PRE21]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When sorting a collection of datetimes in ascending order, pandas sorts from
    the earliest date to the latest. The `battles` `Series` offers a great opportunity
    to see this sort in action:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当按升序对日期时间集合进行排序时，pandas 从最早的日期排序到最新的日期。`battles` `Series` 提供了一个很好的机会来观察这个排序的实际应用：
- en: '[PRE22]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We see a new type of value toward the end of the sorted `Series`. Pandas uses
    another NumPy object, `NaT`, in place of missing date values (`NaT` stands for
    not a time). The `NaT` object maintains data integrity with the index’s datetime
    type.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在排序后的 `Series` 的末尾，我们看到了一种新的值类型。Pandas 使用另一个 NumPy 对象 `NaT`（代表 not a time）来代替缺失的日期值。`NaT`
    对象与索引的日期时间类型保持数据完整性。
- en: 'The `sort_index` method also includes the `na_position` parameter for altering
    the placement of `NaN` values. The next example displays the missing values first,
    followed by the sorted datetimes:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort_index` 方法还包括 `na_position` 参数，用于改变 `NaN` 值的位置。下一个示例首先显示缺失值，然后是排序后的日期时间：'
- en: '[PRE23]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To sort in descending order, we can pass the `ascending` parameter an argument
    of `False`. A descending sort displays dates from latest to earliest:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要按降序排序，我们可以将 `ascending` 参数的值设置为 `False`。降序排序显示从最新到最早的日期：
- en: '[PRE24]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The data set’s earliest battle took place on January 22, 1783, in Virginia.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集最早的战斗发生在 1783 年 1 月 22 日，在弗吉尼亚州。
- en: 3.2.3 Retrieving the smallest and largest values with the nsmallest and nlargest
    methods
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.3 使用 nsmallest 和 nlargest 方法检索最小和最大值
- en: 'Suppose that we wanted to find the five dates on which Google’s stock performed
    best. One option is to sort the `Series` in descending order and then limit the
    results to the first five rows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想找到谷歌股票表现最佳的五个日期。一个选项是将 `Series` 按降序排序，然后限制结果为前五行：
- en: '[PRE25]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The operation is fairly common, so pandas offers a helper method to save us
    a few characters. The `nlargest` method returns the largest values from a `Series`.
    Its first parameter, `n`, sets the number of records to return. The `n` parameter
    has a default argument of `5`. Pandas sorts the values in descending order in
    the returned `Series`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作相当常见，因此 pandas 提供了一个辅助方法来节省我们一些字符。`nlargest` 方法返回 `Series` 中的最大值。它的第一个参数
    `n` 设置要返回的记录数。`n` 参数的默认参数为 `5`。Pandas 在返回的 `Series` 中按降序排序值：
- en: '[PRE26]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The complementary `nsmallest` method returns the smallest values from a `Series`,
    sorted in ascending order. Its `n` parameter also has a default argument of `5`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 补充的 `nsmallest` 方法返回 `Series` 中的最小值，并按升序排序。它的 `n` 参数也有一个默认参数 `5`：
- en: '[PRE27]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that neither of these methods works on `Series` of strings.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这两个方法都不适用于字符串 `Series`。
- en: 3.3 Overwriting a Series with the inplace parameter
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 使用 inplace 参数覆盖 Series
- en: 'All the methods that we’ve invoked in this chapter return new `Series` objects.
    The original `Series` objects referenced by our `pokemon`, `google`, and `battles`
    variables have remained unaffected throughout our operations thus far. As an example,
    let’s observe `battles` before and after a method call; the `Series` does not
    change:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中调用的所有方法都会返回新的 `Series` 对象。我们用 `pokemon`、`google` 和 `battles` 变量引用的原始 `Series`
    对象在我们的操作过程中始终保持未受影响。作为一个例子，让我们观察方法调用前后的 `battles`；`Series` 并没有改变：
- en: '[PRE28]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: What if we wanted to modify the `battles` `Series`? Many methods in pandas include
    an `inplace` parameter that, when passed an argument of `True`, appears to modify
    the object on which the method is invoked.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想修改 `battles` `Series` 呢？pandas 中的许多方法包括一个 `inplace` 参数，当传递 `True` 作为参数时，它似乎会修改被调用的对象。
- en: 'Compare the previous example with the next one. Here, we once again invoke
    the `sort_values` method, but this time around, we pass an argument of `True`
    to the `inplace` parameter. If we use `inplace`, the method returns `None`, leading
    to no output in Jupyter Notebook. When we output `battles`, we can see that it
    has changed:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 将上一个例子与下一个例子进行比较。在这里，我们再次调用 `sort_values` 方法，但这次我们传递 `True` 作为 `inplace` 参数的参数。如果我们使用
    `inplace`，该方法将返回 `None`，导致 Jupyter Notebook 中没有输出。当我们输出 `battles` 时，我们可以看到它已经改变了：
- en: '[PRE29]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `inplace` parameter is a frequent point of confusion. Its name suggests
    that it modifies or mutates the existing object rather than creating a copy. Developers
    are tempted to use `inplace` because reducing the number of copies we create decreases
    memory use. But even with the `inplace` parameter, pandas creates a copy of an
    object whenever we invoke a method. The library always creates a duplicate; the
    `inplace` parameter reassigns our existing variable to the new object. Thus, contrary
    to popular belief, the `inplace` parameter does not offer any performance benefits.
    These two lines are technically equivalent:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`inplace` 参数是一个常见的混淆点。它的名字暗示它修改或突变现有对象，而不是创建一个副本。开发者可能会被 `inplace` 诱惑，因为减少我们创建的副本数量可以减少内存使用。但即使有
    `inplace` 参数，pandas 在我们调用方法时总是会创建一个对象的副本。库始终创建一个副本；`inplace` 参数将我们的现有变量重新分配给新对象。因此，与普遍看法相反，`inplace`
    参数并不提供任何性能优势。这两行在技术上等效：'
- en: '[PRE30]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Why did the pandas developers choose this implementation? What advantage do
    we gain from always creating copies? You can find more detailed explanations online,
    but the short answer is that immutable data structures tend to lead to fewer bugs.
    Remember that an immutable object is incapable of change. We can copy an immutable
    object and manipulate the copy, but we can’t alter the original object. A Python
    string is an example. An immutable object is less likely to enter a corrupted
    or invalid state; it is also easier to test.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么 pandas 开发者选择了这种实现？我们总是创建副本我们能获得什么优势？你可以在网上找到更详细的解释，但简短的答案是不可变数据结构往往导致更少的错误。记住，不可变对象无法改变。我们可以复制一个不可变对象并操作副本，但我们不能改变原始对象。Python
    字符串就是一个例子。不可变对象不太可能进入损坏或无效的状态；它也更容易测试。
- en: The pandas development team has discussed removing the `inplace` parameter from
    the library in future versions. My recommendation is to avoid using it if possible.
    The alternative solution is to reassign a method’s return value to the same variable
    or create a separate, more descriptive variable. We can assign the `sort_values`
    method return value to a variable such as `sorted_battles`, for example.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: pandas 开发团队已经讨论过在未来的版本中从库中移除 `inplace` 参数。我的建议是如果可能的话避免使用它。替代方案是将方法的返回值重新分配给相同的变量或创建一个更具有描述性的变量。例如，我们可以将
    `sort_values` 方法的返回值分配给一个如 `sorted_battles` 的变量。
- en: 3.4 Counting values with the value_counts method
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 使用 value_counts 方法计数值
- en: 'Here’s a reminder of what the `pokemon` `Series` looks like:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个关于 `pokemon` `Series` 的提醒：
- en: '[PRE31]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'How can we find out the most common types of Pokémon? We need to group the
    values into buckets and count the number of elements in each bucket. The `value_counts`
    method, which counts the number of occurrences of each `Series` value, solves
    the problem perfectly:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何找出最常见的宝可梦类型？我们需要将值分组到桶中，并计算每个桶中元素的数量。`value_counts` 方法，它计算每个 `Series` 值出现的次数，完美地解决了这个问题：
- en: '[PRE32]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `value_counts` method returns a new `Series` object. The index labels are
    the `pokemon` `Series`’ values, and the values are their respective counts. Sixty-five
    of the Pokémon are classified as Normal, 61 are classified as Water, and so on.
    For those who are curious, “Normal” Pokémon are those that excel in physical attacks.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`value_counts`方法返回一个新的`Series`对象。索引标签是`pokemon` `Series`的值，值是它们各自的计数。有65只宝可梦被归类为正常，61只被归类为水，等等。对于那些好奇的人，“正常”宝可梦是那些在物理攻击方面表现出色的宝可梦。'
- en: 'The length of the `value_counts` `Series` is equal to the number of unique
    values in the `pokemon` `Series`. As a reminder, the `nunique` method returns
    this piece of information:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`value_counts` `Series`的长度等于`pokemon` `Series`中唯一值的数量。作为提醒，`nunique`方法返回此信息：'
- en: '[PRE33]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Data integrity is paramount in situations like these. The presence of an extra
    space or the different casing of a character will cause pandas to deem two values
    unequal and count them separately. We’ll discuss data cleanup in chapter 6.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，数据完整性至关重要。额外的空格或字符的不同大小写会导致pandas认为两个值不相等，并将它们分别计数。我们将在第六章中讨论数据清理。
- en: 'The `value_counts` method’s `ascending` parameter has a default argument of
    `False`. Pandas sorts the values in descending order, from most occurrences to
    least occurrences. To sort the values in ascending order, pass the `ascending`
    parameter a value of `True`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`value_counts`方法的`ascending`参数的默认参数为`False`。Pandas按降序对值进行排序，从出现次数最多到最少。要按升序排序值，将`ascending`参数传递一个值为`True`：'
- en: '[PRE34]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We may be more interested in the ratio of a Pokémon type relative to all the
    types. Set the `value_counts` method’s `normalize` parameter to `True` to return
    the frequencies of each unique value. A value’s frequency is the portion of the
    data set that the value makes up:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能对宝可梦类型相对于所有类型的比率更感兴趣。将`value_counts`方法的`normalize`参数设置为`True`以返回每个唯一值的频率。一个值的频率是该值在数据集中所占的比例：
- en: '[PRE35]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can multiply the values in the frequency `Series` by 100 to get the percentage
    each Pokémon type contributes to the whole. Do you recall the syntax from chapter
    2? We can use a plain mathematical operator like a multiplication symbol with
    a `Series`. Pandas will apply the operation to each value:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将频率`Series`中的值乘以100，以得到每种宝可梦类型对整体贡献的百分比。你还记得第二章中的语法吗？我们可以使用像乘号这样的普通数学运算符与`Series`一起使用。Pandas将对每个值应用此操作：
- en: '[PRE36]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Normal Pokémon make up 8.034611% of the data set, Water Pokémon make up 7.540173%,
    and so on. Interesting!
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 正常宝可梦占数据集的8.034611%，水宝可梦占7.540173%，等等。真有趣！
- en: 'Let’s say we wanted to limit the precision of the percentages. We can round
    a `Series`’ values with the `round` method. The method’s first parameter, `decimals`,
    sets the number of digits to leave after the decimal point. The next example rounds
    the values to two digits; it wraps code from the previous example in parentheses
    to avoid a syntactical error. We want to make sure that pandas first multiplies
    each value by 100 and then invokes `round` on the resulting `Series`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要限制百分比的精度。我们可以使用`round`方法对`Series`的值进行四舍五入。该方法的第一参数`decimals`设置小数点后保留的位数。下一个示例将值四舍五入到两位数字；它将前一个示例中的代码用括号括起来以避免语法错误。我们想要确保pandas首先将每个值乘以100，然后对结果`Series`调用`round`方法：
- en: '[PRE37]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `value_counts` method operates identically on a numeric `Series`. The next
    example counts the occurrences of each unique stock price in the `google` `Series`.
    It turns out that no stock price appears more than three times in the data set:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`value_counts`方法在数值`Series`上操作相同。下一个示例计算`google` `Series`中每个唯一股票价格的出现次数。结果发现，数据集中没有股票价格出现超过三次：'
- en: '[PRE38]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To identify trends in numeric data sets, it can be more beneficial to group
    values into predefined intervals rather than count distinct values. Let’s begin
    by determining the difference between the smallest and largest values within the
    `google` `Series.` The `Series`’ `max` and `min` methods work well here. An alternative
    option is passing the `Series` into Python’s built-in `max` and `min` functions:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了识别数值数据集中的趋势，将值分组到预定义的区间中可能比计数唯一值更有益。让我们首先确定`google` `Series`中最小值和最大值之间的差异。`Series`的`max`和`min`方法在这里工作得很好。另一个选择是将`Series`传递给Python内置的`max`和`min`函数：
- en: '[PRE39]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We have a range of ~1,250 between the smallest and largest values. Let’s group
    the stock prices into buckets of 200, starting at 0 and working up to 1,400\.
    We can define these intervals as values in a list and pass the list to the `value_counts`
    method’s `bins` parameter. Pandas will use every two subsequent list values as
    the lower and upper ends of an interval:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最小值和最大值之间有大约1,250的范围。让我们将股价分成200的桶，从0开始，一直工作到1,400。我们可以将这些区间定义为列表中的值，并将列表传递给`value_counts`方法的`bins`参数。Pandas将使用列表中每两个后续值作为区间的下限和上限：
- en: '[PRE40]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The output tells us that Google’s stock price was between $200 and $400 for
    1,568 values in the data set.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 输出告诉我们，在数据集中，谷歌的股价在$200到$400之间有1,568个值。
- en: 'Note that pandas sorted the previous `Series` in descending order by the number
    of values in each bucket. What if we wanted to sort the results by the intervals
    instead? We simply have to mix and match a few pandas methods. The intervals are
    the index labels in the returned `Series`, so we can use the `sort_index` method
    to sort them. This technique of invoking multiple methods in sequence is called
    *method chaining*:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，pandas按每个桶中的值的数量降序对之前的`Series`进行了排序。如果我们想按区间排序结果呢？我们只需要混合匹配几个pandas方法。这些区间是返回的`Series`中的索引标签，因此我们可以使用`sort_index`方法来排序它们。这种连续调用多个方法的技巧称为**方法链**：
- en: '[PRE41]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can achieve an identical result by passing a value of `False` to the `sort`
    parameter of the `value_counts` method:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将`False`传递给`value_counts`方法的`sort`参数来获得相同的结果：
- en: '[PRE42]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Notice that the first interval includes the value -0.001 instead of 0\. When
    pandas organizes the `Series`’ values into buckets, it may extend any bin’s range
    up to .1% in either direction. The symbols around intervals have significance:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，第一个区间包含-0.001而不是0。当pandas将`Series`的值组织到桶中时，它可能将任何桶的范围扩展到.1%的任一方向。区间周围的符号具有意义：
- en: A parenthesis marks a value as *excluded* from the interval.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个括号标记一个值作为区间外的**排除**值。
- en: A square bracket marks a value as *included* in the interval.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个方括号标记一个值作为区间内的**包含**值。
- en: Consider the interval `(-0.001,` `200.0]`. -0.001 is excluded, and 200 is included.
    Thus, the interval captures all values greater than -0.001 and less than or equal
    to 200.0.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑区间 `(-0.001, 200.0]`。-0.001被排除，200被包含。因此，该区间捕获了所有大于-0.001且小于或等于200.0的值。
- en: A *closed interval* includes both endpoints. An example is `[5,` `10]` (greater
    than or equal to 5, less than or equal to 10).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一个**闭区间**包含两个端点。例如 `[5, 10]`（大于等于5，小于等于10）。
- en: An *open interval* excludes both endpoints. An example is `(5,` `10)` (greater
    than 5, less than 10).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一个**开区间**不包含两个端点。例如 `(5, 10)`（大于5，小于10）。
- en: The `value_counts` method with a `bin` parameter returns *half-open* intervals.
    Pandas will include one of the endpoints and exclude the other.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 带有`bin`参数的`value_counts`方法返回**半开区间**。Pandas将包含一个端点并排除另一个端点。
- en: 'The `value_counts` method’s `bins` parameter also accepts an integer argument.
    Pandas will automatically calculate the difference between the maximum and minimum
    values in the `Series` and divide the range into the specified number of bins.
    The next example splits the stock prices in `google` into six bins. Note that
    the bins/buckets may not be perfectly equal in size (due to the possible .1% extension
    of any interval in any direction) but will be reasonably close:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`value_counts`方法的`bins`参数还接受一个整数参数。Pandas将自动计算`Series`中最大值和最小值之间的差值，并将范围分成指定的数量个桶。下一个示例将`google`中的股价分成六个桶。请注意，桶的大小可能不完全相等（由于任何方向上任何区间的可能.1%扩展），但将非常接近：'
- en: '[PRE43]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'What about our `battles` data set? We haven’t seen it for a while:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`battles`数据集怎么样了？我们有一段时间没看到它了：
- en: '[PRE44]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We can use the `value_counts` method to see which states had the most battles
    in the Revolutionary War:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`value_counts`方法查看在独立战争中哪个州发生了最多的战斗：
- en: '[PRE45]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Pandas will exclude `NaN` values from the `value_counts` `Series` by default.
    Pass the `dropna` parameter an argument of `False` to count null values as a distinct
    category:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas默认会从`value_counts` `Series`中排除`NaN`值。将`dropna`参数的值设置为`False`以将空值计为一个不同的类别：
- en: '[PRE46]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'A `Series` index also supports the `value_counts` method. We have to access
    the index object via the `index` attribute before invoking the method. Let’s find
    out which dates had the most battles during the Revolutionary War:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`Series`索引也支持`value_counts`方法。在调用方法之前，我们必须通过`index`属性访问索引对象。让我们找出在独立战争中哪一天发生了最多的战斗：'
- en: '[PRE47]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: It looks as though no date saw more than two battles.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来没有哪一天发生了超过两场战斗。
- en: 3.5 Invoking a function on every Series value with the apply method
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5 使用 apply 方法对每个 Series 值调用函数
- en: A function is a *first-class object* in Python, which means that the language
    treats it like any other data type. A function may feel like a more abstract entity,
    but it’s as valid a data structure as any other.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，函数是一个 *一等对象*，这意味着语言将其视为任何其他数据类型。函数可能感觉像是一个更抽象的实体，但它与其他任何数据结构一样有效。
- en: 'Here’s the simplest way to think about first-class objects. Anything that you
    can do with a number, you can do with a function. You can do all the following
    things, for example:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 关于一等对象的简单思考方式是：你可以用数字做的任何事情，你都可以用函数做。例如，你可以做所有以下事情：
- en: Store a function in a list.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数存储在列表中。
- en: Assign a function as a value for a dictionary key.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数分配为字典键的值。
- en: Pass a function into another function as an argument.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一个函数作为参数传递给另一个函数。
- en: Return a function from another function.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从另一个函数中返回一个函数。
- en: It’s important to distinguish between a function and a function invocation.
    A *function* is a sequence of instructions that produces an output; it is a “recipe”
    that has not been cooked yet. By comparison, a *function invocation* is the actual
    execution of the instructions; it is the cooking of the recipe.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 区分函数和函数调用非常重要。一个 *函数* 是一系列产生输出的指令；它是一个“食谱”，尚未烹饪。相比之下，一个 *函数调用* 是指令的实际执行；它是食谱的烹饪。
- en: 'The next example declares a `funcs` list that stores three Python built-in
    functions. The `len`, `max`, and `min` functions are not invoked within the list.
    The list stores references to the functions themselves:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例声明了一个 `funcs` 列表，该列表存储了三个 Python 内置函数。`len`、`max` 和 `min` 函数在列表中没有被调用。列表存储了函数本身的引用：
- en: '[PRE48]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The next example iterates over the `funcs` list with a `for` loop. Over three
    iterations, the `current_func` iterator variable represents the uninvoked `len`,
    `max`, and `min` functions. During each iteration, the loop invokes the dynamic
    `current_func` function, passes in the `google` `Series`, and prints the return
    value:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例使用 `for` 循环遍历 `funcs` 列表。在三次迭代中，`current_func` 迭代变量代表未调用的 `len`、`max` 和
    `min` 函数。在每次迭代中，循环调用动态的 `current_func` 函数，传入 `google` `Series` 并打印返回值：
- en: '[PRE49]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The output includes the sequential return values of the three functions: the
    length of the `Series`, the maximum value in the `Series`, and the minimum value
    in the `Series`.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 输出包括三个函数的连续返回值：`Series` 的长度、`Series` 中的最大值和最小值。
- en: 'The key takeaway here is that we can treat a function like any other object
    in Python. So how does this fact apply to pandas? Suppose that we want to round
    each floating-point value in our `google` `Series` up or down to the closest integer.
    Python has a convenient `round` function for this purpose. The function rounds
    a value above 0.5 up and any value below 0.5 down:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键点是我们可以像对待 Python 中的任何其他对象一样对待函数。那么这个事实如何应用到 pandas 中呢？假设我们想要将 `google`
    `Series` 中的每个浮点值向上或向下舍入到最接近的整数。Python 有一个方便的 `round` 函数来完成这个任务。该函数将大于 0.5 的值向上舍入，将小于
    0.5 的值向下舍入：
- en: '[PRE50]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Wouldn’t it be great if we could apply this `round` function to every value
    in our `Series`? We’re in luck. The `Series` has a method called `apply` that
    invokes a function once for each `Series` value and returns a new `Series` consisting
    of the return values of the function invocations. The `apply` method expects the
    function it will invoke as its first parameter, `func`. The next example passes
    Python’s built-in `round` function:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够将这个 `round` 函数应用到我们的 `Series` 中的每个值上，那岂不是很好？我们很幸运。`Series` 有一个名为 `apply`
    的方法，它为每个 `Series` 值调用一次函数，并返回一个由函数调用返回值组成的新 `Series`。`apply` 方法期望它将调用的函数作为其第一个参数
    `func`。下一个示例传递了 Python 的内置 `round` 函数：
- en: '[PRE51]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We’ve rounded every `Series` value!
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将每个 `Series` 的值都四舍五入过了！
- en: Again, please take a moment to notice that we’re passing the `apply` method
    the uninvoked `round` function. We’re passing in the recipe. Somewhere in the
    internals of pandas, the `apply` method knows to invoke our function on every
    `Series` value. Pandas abstracts away the complexity of the operation.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 再次请注意，我们正在将未调用的 `round` 函数传递给 `apply` 方法。我们传递的是食谱。在 pandas 的内部某个地方，`apply` 方法知道要在每个
    `Series` 值上调用我们的函数。Pandas 抽象掉了操作的复杂性。
- en: The `apply` method also accepts custom functions. Define the function to accept
    a single parameter and have it return the value that you’d like pandas to store
    in the aggregated `Series`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply`方法也接受自定义函数。定义一个函数，它接受一个参数并返回你希望pandas存储在聚合`Series`中的值。'
- en: 'Let’s say we wanted to find out how many of our Pokémon have one type (such
    as Fire) and how many have two or more types. We need to apply the same logic,
    the categorization of a Pokémon, to each `Series` value. A function is an ideal
    container for encapsulating that logic. Let’s define a utility function called
    `single_or_multi` that accepts a single Pokémon type and determines whether it
    has one or several types. If a Pokémon has multiple types, the string separates
    them with a slash (`"Fire` `/ Ghost"`). We can use Python’s `in` operator to check
    for the inclusion of a forward slash in the argument string. The `if` statement
    executes a block only if its condition evaluates to `True`. In our case, if a
    `/` is present, the function will return the string `"Multi"`; otherwise, it’ll
    return `"Single"`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想知道有多少宝可梦是单一类型的（例如火）以及有多少宝可梦是两种或更多类型的。我们需要将相同的逻辑，即宝可梦的分类，应用于每个`Series`值。函数是一个封装该逻辑的理想容器。让我们定义一个名为`single_or_multi`的实用函数，它接受一个宝可梦类型并确定它是一个或多个类型。如果一个宝可梦有多个类型，字符串会使用斜杠（`"Fire
    / Ghost"`）分隔它们。我们可以使用Python的`in`运算符来检查参数字符串中是否存在前斜杠。`if`语句仅在条件评估为`True`时执行一个块。在我们的情况下，如果存在`/`，则函数将返回字符串`"Multi"`；否则，它将返回`"Single"`：
- en: '[PRE52]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now we can pass the `single_or_multi` function to the `apply` method. Here’s
    a quick refresher on what `pokemon` looks like:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将`single_or_multi`函数传递给`apply`方法。以下是对`pokemon`外观的快速回顾：
- en: '[PRE53]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The next example calls the `apply` method with the `single_or_multi` function
    as its argument. Pandas invokes the `single_or_multi` function for every `Series`
    value:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例调用`apply`方法，将`single_or_multi`函数作为其参数。Pandas会对每个`Series`值调用`single_or_multi`函数：
- en: '[PRE54]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Our first specimen, Bulbasaur, is classified as a Grass / Poison Pokémon, so
    the `single_or_multi` function returns `"Multi"`. By comparison, our fourth specimen,
    Charmander, is classified as a Fire Pokémon, so the function returns `"Single"`.
    The same logic repeats for the remaining `pokemon` values.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一种样本，妙蛙种子，被归类为草/毒宝可梦，因此`single_or_multi`函数返回`"Multi"`。相比之下，我们的第四种样本，小火龙，被归类为火宝可梦，因此函数返回`"Single"`。对于剩余的`pokemon`值，相同的逻辑重复出现。
- en: 'We have a new `Series` object! Let’s find out how many Pokémon fall into each
    classification by invoking `value_counts`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个新的`Series`对象！让我们通过调用`value_counts`来找出有多少宝可梦属于每个分类：
- en: '[PRE55]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: It turns out that there’s a fairly even split of single-power and multipower
    Pokémon. I hope that this knowledge will prove to be useful at some point in your
    life.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 单一能量和多能量宝可梦的分布相当均匀。我希望这些知识在某个时刻对你的生活有所帮助。
- en: 3.6 Coding challenge
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.6 编程挑战
- en: Let’s tackle a challenge that combines several ideas introduced in this chapter
    and chapter 2.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解决一个结合了本章和第2章中介绍的一些想法的挑战。
- en: 3.6.1 Problems
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6.1 问题
- en: 'Suppose that a historian reaches out to us and asks us to determine which day
    of the week saw the most battles during the Revolutionary War. The final output
    should be a `Series` with the days (Sunday, Monday, and so on) as index labels
    and a count of battles on each day as the values. Starting from scratch, import
    the revolutionary_war.csv data set, and perform the necessary operations to arrive
    at the following data:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一位历史学家向我们求助，要求我们确定在革命战争中哪一天发生了最多的战斗。最终输出应该是一个`Series`，其中包含星期（星期日、星期一等）作为索引标签，以及每天战斗的数量作为值。从头开始，导入revolutionary_war.csv数据集，并执行必要的操作以获得以下数据：
- en: '[PRE56]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'You’ll need one additional piece of Python knowledge to solve this problem.
    If you have a single datetime object, you can invoke the `strftime` method on
    it with an argument of `"%A"` to return the day of a week a date falls on (such
    as `"Sunday"`). See the following example and appendix B for a more-extensive
    overview of a datetime object:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题你需要额外的Python知识。如果你有一个单独的datetime对象，你可以使用`strftime`方法并传入参数`"%A"`来返回日期所在的星期几（例如`"Sunday"`）。参见以下示例和附录B，以获取关于datetime对象的更全面概述：
- en: '[PRE57]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: HINT Declaring a custom function to calculate a date’s day of the week may prove
    to be helpful.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：声明一个自定义函数来计算日期的星期几可能很有帮助。
- en: Good luck!
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 祝你好运！
- en: 3.6.2 Solutions
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6.2 解决方案
- en: 'Let’s reimport the revolutionary_war.csv data set and remind ourselves of its
    original shape:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新导入revolutionary_war.csv数据集，并提醒自己其原始形状：
- en: '[PRE58]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We do not need the Battle and State columns for this analysis. You’re welcome
    to use either column as the index or stick with the default numeric one.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要分析中的战斗和状态列。你可以使用任一列作为索引，或者坚持使用默认的数字索引。
- en: 'The critical step is coercing the string values in the Start Date column to
    datetimes. If we’re working with dates, we can invoke date-related methods such
    as `strftime`. We do not have the same power with plain strings. Let’s select
    the Start Date column with the `usecols` parameter and convert its values to datetimes
    with the `parse_ dates` parameter. Finally, remember to pass `True` to the `squeeze`
    parameter to create a `Series` instead of a `DataFrame`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 关键步骤是将开始日期列中的字符串值强制转换为 datetime。如果我们处理的是日期，我们可以调用与日期相关的函数，如 `strftime`。对于普通字符串，我们没有同样的能力。让我们使用
    `usecols` 参数选择开始日期列，并使用 `parse_dates` 参数将其值转换为 datetime。最后，记得将 `True` 传递给 `squeeze`
    参数以创建一个 `Series` 而不是 `DataFrame`：
- en: '[PRE59]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Our next challenge is extracting the day of the week for each date. One solution
    (using only the tools we know now) is to pass each `Series` value to a function
    that will return that date’s day of the week. Let’s declare that function now:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个挑战是提取每个日期的一周中的某一天。一个解决方案（仅使用我们目前所知的工具）是将每个 `Series` 值传递给一个函数，该函数将返回该日期的一周中的某一天。现在让我们声明这个函数：
- en: '[PRE60]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: How can we invoke the `day_of_week` function once for each `Series` value? We
    can pass the `day_of_week` function as the argument to the `apply` method. We
    expect to get the days of the week, except that...
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何为每个 `Series` 值调用一次 `day_of_week` 函数？我们可以将 `day_of_week` 函数作为参数传递给 `apply`
    方法。我们期望得到一周中的某一天，但结果却...
- en: '[PRE61]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Uh-oh—our Start Date column has missing values. Unlike a datetime object, a
    `NaT` object does not have a `strftime` method, so pandas runs into trouble when
    passing it into the `day_of_week` function. The simple solution is to drop all
    missing datetime values from the `Series` before we call the `apply` method. We
    can do so with the `dropna` method:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀——我们的开始日期列有缺失值。与 datetime 对象不同，`NaT` 对象没有 `strftime` 方法，所以当将其传递给 `day_of_week`
    函数时，pandas 会遇到麻烦。简单的解决方案是在调用 `apply` 方法之前从 `Series` 中删除所有缺失的 datetime 值。我们可以使用
    `dropna` 方法做到这一点：
- en: '[PRE62]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now we’re getting somewhere! We need a way to count the number of occurrences
    for each weekday. The `value_counts` method does the trick:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有进展了！我们需要一种方法来计算每个工作日的出现次数。`value_counts` 方法就做到了这一点：
- en: '[PRE63]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Perfect! The result is a tie between Friday and Saturday. Congratulations on
    completing the coding challenge!
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！结果是周五和周六打平。恭喜你完成编码挑战！
- en: Summary
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: The `read_csv` function imports a CSV’s contents into a pandas data structure.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`read_csv` 函数将 CSV 的内容导入 pandas 数据结构中。'
- en: The `read_csv` function’s parameters can customize the imported columns, the
    index, the data types, and more.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`read_csv` 函数的参数可以自定义导入的列、索引、数据类型等。'
- en: The `sort_values` method sorts a `Series`’ values in ascending or descending
    order.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sort_values` 方法按升序或降序对 `Series` 的值进行排序。'
- en: The `sort_index` method sorts a `Series`’ index in ascending or descending order.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sort_index` 方法按升序或降序对 `Series` 的索引进行排序。'
- en: We can use the `inplace` parameter to reassign the copy returned from a method
    to the original variable holding an object. There are no performance benefits
    to using `inplace`.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用 `inplace` 参数将方法返回的副本重新分配给原始变量。使用 `inplace` 没有性能上的好处。
- en: The `value_counts` method counts the occurrences of each unique value in a `Series`.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value_counts` 方法计算 `Series` 中每个唯一值的出现次数。'
- en: The `apply` method invokes a function on each `Series` value and returns the
    results in a new `Series`.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apply` 方法在 `Series` 的每个值上调用一个函数，并将结果返回到一个新的 `Series` 中。'
