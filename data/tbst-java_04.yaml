- en: 3 Finding problem root causes using advanced debugging techniques
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 使用高级调试技术查找问题根本原因
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了
- en: Using conditional breakpoints to investigate specific scenarios
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用条件断点来调查特定场景
- en: Using breakpoints to log debug messages in the console
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用断点在控制台记录调试消息
- en: Changing data while debugging to force the app to act in a specific way
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调试过程中更改数据以强制应用程序以特定方式执行
- en: Rerunning a certain part of the code while debugging
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调试过程中重新运行代码的某个部分
- en: In chapter 2, we started discussing the most common ways to use a debugger.
    When debugging a certain piece of implemented logic, developers often use code
    navigation operations such as stepping over, stepping into, and stepping out of
    a line. Knowing how to properly use these operations helps you to investigate
    a piece of code to better understand or find an issue.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2章中，我们开始讨论使用调试器的最常见方法。当调试某个已实现的逻辑部分时，开发者通常会使用代码导航操作，如跳过、进入和退出一行。了解如何正确使用这些操作有助于您调查代码，以便更好地理解或找到问题。
- en: But a debugger is a more powerful tool than many developers are aware of. Developers
    sometimes struggle when debugging code using only the basic navigation, whereas
    they could save a lot of time if they used some of the other (lesser-known) approaches
    a debugger offers.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 但调试器是一个比许多开发者所意识到的更强大的工具。开发者们在仅使用基本导航进行代码调试时有时会感到困难，而如果他们使用调试器提供的其他（不太为人所知）方法，则可以节省大量时间。
- en: 'In this chapter, you’ll learn how to get the most out of the features a debugger
    offers:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解如何充分利用调试器提供的功能：
- en: Conditional breakpoints
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件断点
- en: Breakpoints as log events
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断点作为日志事件
- en: Modifying in-memory data
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改内存中的数据
- en: Dropping execution frames
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 丢弃执行帧
- en: We’ll discuss some beyond-basic ways to navigate the code you are investigating,
    and you’ll learn how and when to use these approaches. We’ll use code examples
    to discuss these investigation approaches so that you understand how you can use
    them to save time and when to avoid them.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论一些超越基本方式的代码导航方法，您将了解如何以及何时使用这些方法。我们将使用代码示例来讨论这些调查方法，以便您了解如何使用它们来节省时间，以及在何时避免使用它们。
- en: 3.1 Minimizing investigation time with conditional breakpoints
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 使用条件断点最小化调查时间
- en: In this section, we discuss the use of *conditional breakpoints* to pause the
    app’s execution on a line of code under specific conditions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论使用*条件断点*来在满足特定条件下暂停应用程序执行的代码行。
- en: DEFINITION A conditional breakpoint is a breakpoint you associate with a condition,
    so that the debugger only pauses the execution if the condition is fulfilled.
    Conditional breakpoints are helpful in investigation scenarios when you are only
    interested in how a part of the code works with given values; using conditional
    breakpoints where appropriate saves you time and helps you to more easily understand
    how your app works.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 定义：条件断点是与条件关联的断点，因此调试器只有在条件满足时才会暂停执行。在调查场景中，当您只对代码部分与给定值如何工作感兴趣时，条件断点非常有用；在适当的情况下使用条件断点可以节省您的时间，并帮助您更容易地理解应用程序的工作方式。
- en: '![](../../OEBPS/Images/icon_girl2.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/icon_girl2.png)'
- en: Let’s look at an example to understand how conditional breakpoints work and
    typical cases in which you’ll want to use them. Listing 3.1 presents a method
    that returns the sum of the digits in a list of `String` values. You might already
    be familiar with this method from chapter 2\. We’ll use this piece of code here
    as well to discuss conditional breakpoints. We’ll then compare this simplified
    example with similar situations you may encounter in real-world cases. This example
    can be found in project da-ch3-ex1 provided with the book.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来了解条件断点是如何工作的，以及您可能希望使用它们的典型情况。列表3.1展示了一个返回字符串值列表中数字之和的方法。您可能已经从第2章中熟悉了这种方法。我们也将使用这段代码来讨论条件断点。然后，我们将把这个简化示例与您可能在现实世界案例中遇到的类似情况进行比较。这个例子可以在本书提供的项目da-ch3-ex1中找到。
- en: Listing 3.1 Using conditional breakpoints for investigation
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.1 使用条件断点进行调查
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When debugging a piece of code, you are often only interested in how the logic
    works for specific values. For example, say you suspect the implemented logic
    doesn’t work well in a given case (e.g., some variable has a certain value), and
    you want to prove it. Or you simply want to understand what happens in a given
    situation to have a better overview of the entire functionality.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当调试一段代码时，你通常只对特定值下的逻辑工作方式感兴趣。例如，假设你怀疑实现的逻辑在某个特定情况下（例如，某些变量具有特定值）工作得不好，并且你想证明这一点。或者你只是想了解在特定情况下发生了什么，以便更好地了解整个功能。
- en: Suppose that, in this case, you only want to investigate why the variable `sum`
    is sometimes zero. How can you only work on this specific case? You could use
    the step over operation to navigate the code until you observe that the method
    returns zero. This approach is likely acceptable in a demo example such as this
    one (small enough). But in a real-world case, you may have to step over a lot
    of times until you reach the case you expect. In fact, in a real-world scenario,
    you may not even know when the specific case you want to investigate appears.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在这种情况下，你只想调查变量`sum`有时为零的原因。你如何只关注这个特定案例呢？你可以使用单步跳过操作来导航代码，直到你观察到方法返回零。这种方法在像这样的演示示例（足够小）中可能是可接受的。但在现实世界的案例中，你可能需要多次跳过才能达到预期的案例。实际上，在现实世界的场景中，你可能甚至不知道你想要调查的特定情况何时出现。
- en: '![](../../OEBPS/Images/CH03_F01_Spilca3.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH03_F01_Spilca3.png)'
- en: Figure 3.1 Using a conditional breakpoint to pause the execution just for specific
    cases. In this figure, we want to pause the execution on line 14 only if `sum`
    is zero. We can apply a condition on the breakpoint that instructs the debugger
    to consider that breakpoint only if the given state is true. This helps you more
    quickly get to a scenario you want to investigate.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 使用条件断点暂停特定情况的执行。在这个图中，我们只想在`sum`为零的情况下暂停第14行的执行。我们可以在断点上应用一个条件，指示调试器只有在给定状态为真时才考虑该断点。这有助于你更快地到达想要调查的场景。
- en: Using conditional breakpoints is more efficient than navigating through code
    until you get to the conditions you want to research. Figure 3.1 shows you how
    to apply a condition to a breakpoint in IntelliJ IDEA. Right-click the breakpoint
    you want to add the condition for and write the condition to which the breakpoint
    applies. The condition needs to be a Boolean expression (it should be something
    that can be evaluated as true or false). Using the `sum == 0` condition on the
    breakpoint, you tell the debugger to consider that breakpoint and pause the execution
    only when it reaches a case where the variable sum is zero.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用条件断点比在代码中导航到想要研究的条件更高效。图3.1展示了如何在IntelliJ IDEA中应用条件到断点上。右键点击你想要添加条件的断点，并写下该断点所应用的条件。条件需要是一个布尔表达式（它应该是可以评估为真或假的某种东西）。在断点上使用`sum
    == 0`条件，你告诉调试器只有在变量`sum`为零的情况下才考虑该断点并暂停执行。
- en: When you run the app with the debugger, the execution pauses only when the loop
    first iterates on a string that contains no digits, as you observe in figure 3.2\.
    This situation causes the variable `sum` to be zero, and thus the condition on
    the breakpoint is evaluated as true.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用调试器运行应用程序时，执行只有在如图3.2所示的循环首次迭代一个不包含数字的字符串时才会暂停。这种情况导致变量`sum`为零，因此断点上的条件被评估为真。
- en: '![](../../OEBPS/Images/CH03_F02_Spilca3.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH03_F02_Spilca3.png)'
- en: Figure 3.2 A conditional breakpoint. Line 14 in the figure was executed multiple
    times, but the debugger only paused the execution when the variable `sum` was
    zero. This way, we skipped over all the cases we were not interested in so that
    we can start with the conditions relevant to our investigation.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 一个条件断点。图中第14行被多次执行，但调试器只有在变量`sum`为零时才会暂停执行。这样，我们就跳过了所有我们不感兴趣的案例，从而可以开始关注与我们的调查相关的条件。
- en: A conditional breakpoint saves you time since you don’t have to search for the
    specific case you want to investigate. Instead, you allow the app to run, and
    the debugger pauses the execution when a certain condition is met, allowing you
    to begin your investigation at this point. Although using conditional breakpoints
    is easy, many developers seem to forget about this approach and waste a lot of
    time investigating scenarios that could be simplified with conditional breakpoints.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 条件断点可以节省你的时间，因为你不需要搜索你想要调查的特定情况。相反，你允许应用程序运行，当满足某个条件时，调试器会暂停执行，让你可以从这一点开始调查。尽管使用条件断点很容易，但许多开发者似乎忘记了这种方法，浪费了大量时间调查本可以用条件断点简化的情况。
- en: Setting conditional breakpoints is an excellent way to investigate code. However,
    they have their downside. Conditional breakpoints can dramatically affect the
    performance of the execution since the debugger must continuously intercept the
    values of the variables in the scope you use, and evaluate the breakpoint conditions.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 设置条件断点是调查代码的绝佳方式。然而，它们也有其缺点。条件断点可能会显著影响执行性能，因为调试器必须持续拦截你使用的范围内的变量值，并评估断点条件。
- en: TIP Use a small number of conditional breakpoints. Preferably, use only one
    conditional breakpoint at a time to avoid slowing down the execution too much.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：使用少量条件断点。最好一次只使用一个条件断点，以避免过多地减慢执行速度。
- en: '![](../../OEBPS/Images/icon_guy.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/icon_guy.png)'
- en: Another way to use conditional breakpoints is to log specific execution details
    such as various expression values and the stack traces for particular conditions
    (figure 3.3).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用条件断点的另一种方法是记录特定的执行细节，例如各种表达式值和特定条件的堆栈跟踪（图3.3）。
- en: '![](../../OEBPS/Images/CH03_F03_Spilca3.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH03_F03_Spilca3.png)'
- en: Figure 3.3 To apply advanced configuration on the breakpoint in IntelliJ, you
    can click the More button.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 要在IntelliJ中对断点进行高级配置，你可以点击更多按钮。
- en: Unfortunately, this feature only works in certain IDEs. For example, even though
    you can use conditional breakpoints in Eclipse in the same way as described here,
    Eclipse does not allow you to use breakpoints just for logging execution details
    (figure 3.4).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这个功能仅在特定的IDE中工作。例如，尽管你可以在Eclipse中以与这里描述相同的方式使用条件断点，但Eclipse不允许你仅为了记录执行细节而使用断点（图3.4）。
- en: '![](../../OEBPS/Images/CH03_F04_Spilca3.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH03_F04_Spilca3.png)'
- en: Figure 3.4 Not all IDEs offer the same debugging tools. All IDEs give you the
    basic operations, but some features, such as logging the execution details instead
    of pausing the execution, may be missing. In Eclipse, you can define conditional
    breakpoints, but you can’t use the logging feature.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 并非所有IDE都提供相同的调试工具。所有IDE都提供基本操作，但某些功能，如记录执行细节而不是暂停执行，可能不存在。在Eclipse中，你可以定义条件断点，但你不能使用日志功能。
- en: You might ask yourself whether you should only use IntelliJ IDEA for these examples.
    Even if most examples in this book use IntelliJ IDEA, that doesn’t mean this IDE
    is better than others. I’ve used many IDEs with Java, such as Eclipse, Netbeans,
    and JDeveloper. My recommendation is that you shouldn’t become too comfortable
    with using one IDE. Instead, try to use various options so that you can decide
    which is a better fit for you and your team.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问自己是否应该只为这些示例使用IntelliJ IDEA。即使本书中的大多数示例都使用IntelliJ IDEA，这并不意味着这个IDE比其他IDE更好。我使用过许多与Java相关的IDE，例如Eclipse、Netbeans和JDeveloper。我的建议是，你不应该过于习惯使用一个IDE。相反，尝试使用各种选项，这样你可以决定哪个更适合你和你所在的团队。
- en: 3.2 Using breakpoints that don’t pause the execution
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 使用不会暂停执行的断点
- en: In this section, we discuss using breakpoints to log messages you can later
    use to investigate the code. One of my favorite ways to use breakpoints is to
    log details that can help me to understand what happened during the app’s execution
    without pausing the execution. As you’ll learn in chapter 5, logging is an excellent
    investigation practice in some cases. Many developers struggle with adding log
    instructions when they could have simply used a conditional breakpoint.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论使用断点记录你可以稍后用于调查代码的消息。我最喜欢的使用断点的方式是记录可以帮助我了解应用程序执行期间发生了什么的细节，而无需暂停执行。正如你将在第5章中学到的，在某些情况下，记录是一种出色的调查实践。许多开发者在与添加日志指令时挣扎，而他们本可以简单地使用条件断点。
- en: '![](../../OEBPS/Images/CH03_F05_Spilca3.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH03_F05_Spilca3.png)'
- en: Figure 3.5 Conditional breakpoint advanced configuration. In addition to specifying
    a condition for the breakpoint, you can instruct the debugger to not suspend the
    execution for the given breakpoint. Instead, you can simply log the data you need
    to understand your case.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 条件断点高级配置。除了指定断点的条件外，你还可以指示调试器不要为给定的断点暂停执行。相反，你可以简单地记录你需要了解情况的数据。
- en: Figure 3.5 shows you how to configure a conditional breakpoint that doesn’t
    pause the execution. Instead, the debugger logs a message every time the line
    marked with the breakpoint is reached. In this case, the debugger logs the value
    of the `digits` variable and the execution stack trace.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5展示了如何配置一个不会暂停执行的条件断点。相反，当达到带有断点的行时，调试器会记录一条消息。在这种情况下，调试器记录了`digits`变量的值和执行堆栈跟踪。
- en: '![](../../OEBPS/Images/CH03_F06_Spilca3.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH03_F06_Spilca3.png)'
- en: Figure 3.6 Using breakpoints without pausing the execution. Instead, the debugger
    logs a message when the line has been reached. The debugger also logs the value
    of the `digits` variable and the execution stack trace.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 使用不暂停执行的断点。相反，当行被达到时，调试器会记录一条消息。调试器还会记录`digits`变量的值和执行堆栈跟踪。
- en: 'Figure 3.6 shows the result of running the app with the conditional breakpoint
    configured. Notice that the debugger logged the execution stack trace in the console,
    and the value of the `digits` variable is an empty list: `[]`. This kind of information
    can help you to solve the puzzles of the code you investigate in real-world scenarios.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6显示了配置了条件断点后运行应用程序的结果。注意，调试器在控制台中记录了执行堆栈跟踪，`digits`变量的值是一个空列表：`[]`。这类信息可以帮助你解决你在现实场景中调查的代码的难题。
- en: 3.3 Dynamically altering the investigation scenario
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 动态改变调查场景
- en: 'In this section, you’ll learn another valuable technique that will make your
    code investigations easier: changing the values of the variables in scope while
    debugging. In some cases, this approach can save a significant amount of time.
    We’ll begin with discussing the scenarios in which changing variables’ values
    on the fly is the most effective approach. Then I will demonstrate how to use
    this approach with an example.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习另一种非常有价值的技巧，这将使你的代码调查更容易：在调试过程中更改作用域内变量的值。在某些情况下，这种方法可以节省大量时间。我们将从讨论在实时更改变量值最有效的方法的场景开始。然后我将通过一个示例演示如何使用这种方法。
- en: 'Earlier in this chapter, we discussed conditional breakpoints. Conditional
    breakpoints allow you to tell the debugger to pause the execution under specific
    conditions (e.g., when a given variable has a certain value). Often, we investigate
    logic that executes in a short time, and using conditional breakpoints is enough.
    For cases such as debugging a piece of logic called through a REST endpoint (especially
    if you have the right data to reproduce a problem in your environment), you would
    simply use a conditional breakpoint to pause the execution when appropriate. That’s
    because you know it won’t take long to execute something called through an endpoint.
    But consider the following scenarios:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期，我们讨论了条件断点。条件断点允许你告诉调试器在特定条件下暂停执行（例如，当给定变量具有某个值时）。通常，我们调查的是执行时间很短的逻辑，使用条件断点就足够了。对于像通过REST端点调用的逻辑（特别是如果你有在环境中重现问题的正确数据）这样的案例，你只需在适当的时候使用条件断点来暂停执行。这是因为你知道通过端点调用的东西不会花费很长时间。但考虑以下场景：
- en: You investigate an issue with a process that takes a long time to execute. Say
    it’s a scheduled process that sometimes takes over an hour to complete its execution.
    You suspect that some given parameter values are causing the wrong output, and
    you want to confirm your suspicion before you decide how to correct the problem.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你调查了一个执行时间很长的进程的问题。比如说，这是一个计划中的进程，有时需要超过一个小时才能完成其执行。你怀疑某些给定的参数值导致了错误的输出，你想要在决定如何纠正问题之前确认你的怀疑。
- en: You have a piece of code that executes quickly, but you can’t reproduce the
    issue in your environment. The problem appears only in the production environment
    to which you don’t have access due to security constraints. You believe the issue
    appears when certain parameters have specific values. You want to prove your theory
    is right.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你有一段执行速度很快的代码，但你无法在你的环境中重现问题。这个问题只出现在你无法访问的、由于安全限制而无法访问的生产环境中。你认为问题出现在某些参数具有特定值时。你想要证明你的理论是正确的。
- en: In scenario 1, breakpoints (conditional or not) aren’t so helpful. Unless you
    investigate some logic that happens at the very beginning of the process, running
    the process and waiting for the execution to pause on a line marked with a breakpoint
    would take too much time (figure 3.7).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在场景1中，断点（无论是条件断点还是非条件断点）并不那么有帮助。除非你调查的是在过程开始时发生的某些逻辑，否则运行过程并等待执行在带有断点的行上暂停会花费太多时间（图3.7）。
- en: '![](../../OEBPS/Images/CH03_F07_Spilca3.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图3.7](../../OEBPS/Images/CH03_F07_Spilca3.png)'
- en: Figure 3.7 Usually, when investigating issues in a long-running process, using
    breakpoints is not really an option. It can take a long time for the execution
    to reach the part of code you are investigating, and if you have to rerun the
    process several times, you will definitely spend too much time on it.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 通常情况下，在调查长时间运行过程中的问题时，使用断点并不是一个真正的选择。执行达到你要调查的代码部分可能需要很长时间，如果你不得不多次重新运行该过程，你肯定会花费太多时间在上面。
- en: 'Execution stack trace: Visual vs. text representation'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 执行堆栈跟踪：视觉表示与文本表示
- en: Notice the way the stack trace is printed in the console. You’ll often find
    the execution stack trace in a text format rather than a visual one. The advantage
    of the text representation is that it can be stored in any text format output,
    such as the console or a log file.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意控制台打印堆栈跟踪的方式。你通常会找到以文本格式而不是视觉格式表示的执行堆栈跟踪。文本表示的优点是它可以存储在任何文本格式输出中，例如控制台或日志文件。
- en: The following figure shows you a comparison between the visual representation
    of the execution stack trace provided by the debugger and its textual representation.
    In both cases, the debugger provides the same essential details that can help
    you to understand how a specific line of code was executed.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了调试器提供的执行堆栈跟踪的视觉表示和文本表示之间的比较。在这两种情况下，调试器都提供了可以帮助你理解特定代码行是如何执行的相同基本细节。
- en: In this particular case, the stack trace tells us that the execution started
    from the `main()` method of the `Main` class. Remember that the first layer of
    the stack trace is the bottom one. On line 9, the `main()` method called the `decode()`
    method in the `Decoder` class (layer 2), which then called the line we marked
    with the breakpoint.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的情况下，堆栈跟踪告诉我们执行是从`Main`类的`main()`方法开始的。记住，堆栈跟踪的第一层是底部的一层。在第9行，`main()`方法调用了`Decoder`类的`decode()`方法（层2），然后调用了我们标记为断点的行。
- en: '![](../../OEBPS/Images/CH03_UN03_Spilca3.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图3.7](../../OEBPS/Images/CH03_UN03_Spilca3.png)'
- en: A comparison between the visual representation of the execution stack trace
    in the debugger and its text representation. The stack trace shows you how a method
    was called and provides you enough details to understand the execution path.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器中执行堆栈跟踪的视觉表示与其文本表示的比较。堆栈跟踪显示了方法是如何被调用的，并提供了足够详细的说明，以便你理解执行路径。
- en: For scenario 2, using breakpoints may sometimes be possible. In chapter 4, we’ll
    discuss remote debugging, and you’ll learn how and when remote debugging is a
    helpful investigation technique. But let’s assume for the moment (since we haven’t
    discussed it yet) that you can’t apply remote debugging in this case. Instead,
    if you have an idea of what causes the problem and you just need to prove it but
    don’t have the right data, you can use on-the-fly changes in variables’ values.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于场景2，使用断点有时可能是可能的。在第4章中，我们将讨论远程调试，你将了解何时远程调试是一种有用的调查技术。但让我们暂时假设（因为我们还没有讨论过）在这种情况下不能应用远程调试。相反，如果你对导致问题的原因有一个想法，你只需要证明它但没有正确的数据，你可以使用变量值的即时更改。
- en: Figure 3.8 shows you how to change the data in one of the variables in the scope
    when the debugger pauses the execution. In IntelliJ IDEA, you right-click the
    variable whose value you want to change. You complete this action in the frame
    where the debugger shows the current values of the variables in scope. Let’s look
    at the our previous example, da-ch3-ex1.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8展示了当调试器暂停执行时如何更改作用域中某个变量的数据。在IntelliJ IDEA中，你右键单击想要更改值的变量。你在这个动作中完成，调试器显示作用域中变量的当前值。让我们看看我们之前的例子，da-ch3-ex1。
- en: '![](../../OEBPS/Images/CH03_F08_Spilca3.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图3.8](../../OEBPS/Images/CH03_F08_Spilca3.png)'
- en: Figure 3.8 Setting a new value in a variable in scope. The debugger shows you
    the values for the variables in scope when it pauses the execution on a given
    line. You can also change the values to create a new investigation case. In some
    cases, this approach can help you to validate your suspicions about what the code
    does.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 在作用域内设置变量的新值。当调试器在给定行上暂停执行时，它会显示作用域内变量的值。你也可以更改这些值以创建一个新的调查案例。在某些情况下，这种方法可以帮助你验证关于代码行为的怀疑。
- en: Once you select which variable you want to change, set the value as presented
    in figure 3.9\. Remember that you have to use a value according to the variable’s
    type. That means that if you change a `String` variable, you still need to use
    a `String` value; you cannot use a `long` or a `Boolean` value.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你选择了想要更改的变量，按照图3.9所示设置值。记住，你必须使用符合变量类型的值。这意味着如果你更改一个`String`变量，你仍然需要使用一个`String`值；你不能使用`long`或`Boolean`值。
- en: '![](../../OEBPS/Images/CH03_F09_Spilca3.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH03_F09_Spilca3.png)'
- en: Figure 3.9 Change the variable's value to observe how the app’s execution behaves
    in different conditions.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9 将变量的值更改以观察应用程序在不同条件下的执行行为。
- en: When you continue the execution, as presented in figure 3.10, the app now uses
    the new value. Instead of calling `extractDigits()` for value `"ab1c"`, the app
    used the value `"abcd"`. The list the method returns is empty because the string
    `"abcd"` doesn’t contain digits.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当你继续执行时，如图3.10所示，应用程序现在使用新的值。而不是为值`"ab1c"`调用`extractDigits()`，应用程序使用了值`"abcd"`。该方法返回的列表为空，因为字符串`"abcd"`不包含数字。
- en: '![](../../OEBPS/Images/CH03_F10_Spilca3.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH03_F10_Spilca3.png)'
- en: Figure 3.10 When using the step over operation, the app uses the new value you
    set to the `s` variable. `extractDigits()` returns an empty list because string
    `"abcd"` doesn’t contain digits. Setting values in variables on the fly allows
    you to test different scenarios even if you don’t have the input data you need.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10 当使用单步执行操作时，应用程序使用你设置的`s`变量的新值。`extractDigits()`返回一个空列表，因为字符串`"abcd"`不包含数字。在变量上动态设置值允许你在没有所需输入数据的情况下测试不同的场景。
- en: Let’s compare the conditional breakpoints approach we discussed in section 3.1
    to changing data on the fly. In both cases, you need to first have an idea of
    the part of the code that is potentially causing the problem. You can use conditional
    breakpoints if
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较第3.1节中讨论的条件断点方法与动态更改数据。在这两种情况下，你首先需要有一个关于可能引起问题的代码部分的思路。如果你
- en: You have the data that causes the scenario you want to investigate. In our example,
    we need the value necessary to execute the behavior in the provided list.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你拥有导致你想要调查的场景的数据。在我们的例子中，我们需要执行提供列表中行为所需的价值。
- en: The code you’re investigating doesn’t take too long to execute. For example,
    suppose we have a list with many elements, and for each element it takes several
    seconds for the app to process it. In this case, using a conditional breakpoint
    may mean you will have to invest a lot of time to investigate your case.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你正在调查的代码执行时间不会太长。例如，假设我们有一个包含许多元素的列表，并且应用程序处理每个元素需要几秒钟。在这种情况下，使用条件断点可能意味着你将不得不投入大量时间来调查你的案例。
- en: You can use the approach of changing a variable’s value if
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你可以使用更改变量值的策略
- en: You don’t have the data necessary to cause the scenario you want to investigate.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你没有导致你想要调查的场景所需的数据。
- en: Executing the code takes too long.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行代码花费的时间太长了。
- en: 'I know what you are thinking now: why are we using conditional breakpoints
    at all? It might look like you should avoid using conditional breakpoints entirely
    since you can create any environment you need to investigate simply by changing
    the variables’ values on the fly.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道你现在在想什么：我们为什么要使用条件断点呢？看起来你可能应该完全避免使用条件断点，因为你可以通过在变量上动态更改值来创建任何你需要的用于调查的环境。
- en: Both techniques have advantages and disadvantages. Changing the values of the
    variables may be an excellent approach if you only need to change a couple of
    values. But when your changes become more extensive, the complexity of the scenario
    becomes increasingly challenging to manage.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种技术都有优点和缺点。如果你只需要更改几个值，改变变量的值可能是一个很好的方法。但是，当你的更改变得更加广泛时，场景的复杂性就变得越来越难以管理。
- en: 3.4 Rewinding the investigation case
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 回滚调查案例
- en: We can't go back in time. However, with debugging, rewinding the investigation
    is sometimes possible. In this section, we discuss when and how we can “go back
    in time” while investigating code with a debugger. We call this approach *dropping
    frames*, *dropping execution frames*, or *quitting execution frames*.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能回到过去。然而，通过调试，有时可以回溯调查。在本节中，我们讨论在调试代码时何时以及如何“回到过去”。我们称这种方法为*丢弃帧*、*丢弃执行帧*或*退出执行帧*。
- en: We’ll look an example using IntelliJ IDEA. We’ll compare this approach with
    the ones we discussed in the previous sections of this chapter, and then we’ll
    also determine when this technique can’t be used.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用IntelliJ IDEA来查看一个示例。我们将比较本章前几节中讨论的方法，然后我们还将确定何时不能使用这种技术。
- en: Dropping an execution frame is, in fact, going back one layer in the execution
    stack trace. For example, suppose you stepped into a method and want to go back;
    you can drop the execution frame to return to where the method was called.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 丢弃执行帧实际上是在执行堆栈跟踪中回退一层。例如，假设你进入了一个方法并想要返回；你可以丢弃执行帧以返回到方法被调用的位置。
- en: Many developers confuse dropping a frame with stepping out, most likely because
    the current investigation plan closes in both cases, and the execution returns
    to where the method is called. However, there’s a big difference. When you step
    out of a method, the execution continues in the current plan until the method
    returns or throws an exception. Then, the debugger pauses the execution right
    after the current method exits.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者混淆了丢弃帧和退出，很可能是因为当前的调查计划在这两种情况下都会关闭，并且执行返回到方法被调用的位置。然而，这里有一个很大的区别。当你从方法中退出时，执行会在当前计划中继续，直到方法返回或抛出异常。然后，调试器会在当前方法退出后暂停执行。
- en: Figure 3.11 shows you how stepping out works using the example in project da-ch3-ex1\.
    You are in the `extractDigits()` method, which, as you can see from the execution
    stack trace, has been called from the `decode()` method in the `Decoder` class.
    If you use the step out operation, the execution continues in the method that
    called `extractDigits()`until the method returns. Then, the debugger pauses the
    execution in the `decode()` method. In other words, stepping out is like fast-forwarding
    this execution plan to close it and return to the previous one.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11展示了如何使用项目da-ch3-ex1中的示例来工作。你处于`extractDigits()`方法中，正如你可以从执行堆栈跟踪中看到的那样，它已经被`Decoder`类中的`decode()`方法调用。如果你使用退出操作，执行将继续在调用`extractDigits()`的方法中，直到该方法返回。然后，调试器会在`decode()`方法中暂停执行。换句话说，退出就像是快进这个执行计划来关闭它并返回到上一个计划。
- en: '![](../../OEBPS/Images/CH03_F11_Spilca3.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH03_F11_Spilca3.png)'
- en: Figure 3.11 Stepping out closes the current investigation plan by executing
    the method and then pausing the execution right after the method call. This operation
    allows you to continue the execution and return one layer in the execution stack.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11 退出操作通过执行方法并在方法调用后立即暂停执行来关闭当前调查计划。这个操作允许你继续执行并返回执行堆栈中的一层。
- en: When you drop an execution frame, the execution returns in the previous plan
    before the method is called, unlike stepping out. This way, you can replay the
    call. If the step out operation is like fast-forwarding, dropping an execution
    frame (figure 3.12) is like rewinding.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当你丢弃执行帧时，执行会返回到方法调用之前的前一个计划，这与退出不同。这样，你可以重新播放调用。如果退出操作像是快进，那么丢弃执行帧（图3.12）就像是倒带。
- en: '![](../../OEBPS/Images/CH03_F12_Spilca3.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH03_F12_Spilca3.png)'
- en: Figure 3.12 When you drop a frame, you return to the previous layer in the execution
    stack trace before the method call. This way, you can replay the method execution
    either by stepping into it again or stepping over it.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12 当你丢弃一个帧时，你会返回到方法调用之前执行堆栈跟踪中的上一层。这样，你可以通过再次进入或跳过它来重新播放方法执行。
- en: Figure 3.13 shows you, relative to our example, a comparison between stepping
    out from the `extractDigits()` method and dropping the frame created by the `extractDigits()`
    method. If you step out, you’ll go back to line 12 in the `decode()` method, from
    where `extractDigits()` is called, and the next line the debugger will execute
    is line 13\. If you drop the frame, the debugger goes back to the `decode()` method,
    but the next line that will execute is line 12\. Basically, the debugger returns
    to the line before the execution of the `extractDigits()` method.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13展示了相对于我们的示例，从`extractDigits()`方法中退出与回退由`extractDigits()`方法创建的帧之间的比较。如果你退出，你会回到`decode()`方法的第12行，从那里调用`extractDigits()`，调试器将要执行的下一行是第13行。如果你回退帧，调试器会回到`decode()`方法，但将要执行的下一行是第12行。基本上，调试器会回到`extractDigits()`方法执行之前的行。
- en: '![](../../OEBPS/Images/CH03_F13_Spilca3.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH03_F13_Spilca3.png)'
- en: Figure 3.13 Dropping a frame versus stepping out. When you drop a frame, you
    return to the line before the method’s execution. When you step out, you continue
    the execution but close the current investigation plan (represented by the current
    layer in the execution stack).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13 回退帧与退出。当你回退帧时，你会回到方法执行之前的行。当你退出时，你会继续执行，但关闭当前的调查计划（由执行栈中的当前层表示）。
- en: Figure 3.14 shows you how to use the drop frame functionality in IntelliJ IDEA.
    To drop the current execution frame, right-click the method’s layer in the execution
    stack trace and select Drop Frame.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.14展示了如何在 IntelliJ IDEA 中使用回退帧功能。要回退当前执行帧，请在执行栈跟踪中右键单击方法的层，然后选择“回退帧”。
- en: '![](../../OEBPS/Images/CH03_F14_Spilca3.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH03_F14_Spilca3.png)'
- en: Figure 3.14 When using IntelliJ IDEA, you can drop a frame by right-clicking
    the method’s layer in the execution stack trace and then selecting Drop Frame.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.14 当使用 IntelliJ IDEA 时，你可以通过在执行栈跟踪中右键单击方法的层来回退帧，然后选择“回退帧”。
- en: Why is the drop frame useful, and how does it help save time? Whether you use
    an endpoint to find a specific case you want to investigate or create one by changing
    the values of the variables, as discussed in section 3.3, you’ll still sometimes
    find it useful to repeat the same execution several times. Understanding a certain
    piece of code is not always trivial, even if you use the debugger to pause the
    execution and take it step by step. But going back now and then to review the
    steps and how specific code instructions change the data may help you to understand
    what’s going on.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么回退帧（drop frame）是有用的，它是如何帮助节省时间的？无论你是通过端点查找你想要调查的特定案例，还是通过改变变量的值来创建一个，正如第3.3节中讨论的，你有时会发现重复执行相同的操作几次是有用的。理解某段代码并不总是那么简单，即使你使用调试器暂停执行并逐步进行，也是如此。但时不时地回顾步骤以及特定的代码指令如何改变数据，可能有助于你理解正在发生的事情。
- en: 'You also need to pay attention when you decide to repeat particular instructions
    by dropping the frame. This approach can sometimes be more confusing than helpful.
    Remember that if you run any instruction that changes values outside of the app’s
    internal memory, you can’t undo that change by dropping the frame. Examples of
    such cases are (figure 3.15) as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当你决定通过回退帧重复特定的指令时，也需要注意。这种方法有时可能比有帮助更令人困惑。记住，如果你运行任何改变应用内部内存外值的指令，你不能通过回退帧撤销该更改。这样的例子包括（图3.15）如下：
- en: Modifying data in a database (insert, update, or delete)
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改数据库中的数据（插入、更新或删除）
- en: Changing the filesystem (creating, removing, or changing files)
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变文件系统（创建、删除或更改文件）
- en: Calling another app, which changes the data for that app
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用另一个应用，该应用会改变该应用的数据
- en: Adding a message into a queue that is read by a different app, which changes
    data for that app
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向由不同应用读取的消息队列中添加消息，该应用会改变该应用的数据
- en: Sending an email message
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送电子邮件消息
- en: You can drop a frame that results in committing a transaction that changes data
    in a database, but going back to a previous instruction won’t undo the changes
    made by the transaction. If the app calls an endpoint that posts something into
    a different service, the changes resulting from the endpoint call cannot be undone
    by dropping the frame. If the app sends an email message, dropping the frame cannot
    take back the message, and so on (figure 3.15).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以回退导致提交事务并更改数据库中数据的帧，但回到之前的指令不会撤销事务所做的更改。如果应用调用一个端点将内容发布到不同的服务，端点调用产生的更改不能通过回退帧撤销。如果应用发送电子邮件消息，回退帧不能撤回消息，等等（图3.15）。
- en: '![](../../OEBPS/Images/CH03_F15_Spilca3.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH03_F15_Spilca3.png)'
- en: Figure 3.15 Using the drop frame operation can result in some events that can’t
    be undone. Examples include changing data in the database, changing data in the
    filesystem, calling another app, or sending an email message.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.15 使用丢弃帧操作可能会导致一些无法撤销的事件。例如，更改数据库中的数据，更改文件系统中的数据，调用另一个应用程序，或发送电子邮件消息。
- en: You need to be careful when data is changed outside the app, as sometimes repeating
    the same code won’t have the same result. Take as an example a simple piece of
    code (listing 3.2, which you can find in project da-ch3-ex2). What happens if
    you drop the frame after the execution of the line that creates a file?
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据在应用程序外部更改时，你需要小心，因为有时重复相同的代码不会得到相同的结果。以一个简单的代码片段（列表 3.2，你可以在项目 da-ch3-ex2
    中找到）为例。如果你在创建文件的行执行后丢弃帧，会发生什么？
- en: '[PRE1]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The created file remains in the filesystem, and after the second time you execute
    the code after dropping the frame, you get an exception (because the file already
    exists). This is a simple example of when going back in time while debugging is
    not helpful. The worst part is that, in real-world cases, it’s not this obvious.
    My recommendation is to avoid repeating the execution of large pieces of code
    and, before deciding to use this approach, make sure that part of the logic doesn’t
    make external changes.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的文件会保留在文件系统中，在你丢弃帧后第二次执行代码后，你会遇到异常（因为文件已经存在）。这是一个调试时回溯时间不有帮助的简单例子。最糟糕的是，在现实世界的案例中，这并不那么明显。我的建议是避免重复执行大量代码，并且在决定使用这种方法之前，确保逻辑部分不会进行外部更改。
- en: If you notice differences that seem unusual after running a dropped frame again,
    it may be because the code changed something externally. Often in large apps,
    observing such behavior is not straightforward. For example, your app may use
    a cache or log data that accesses a certain library to observe or execute code
    that is completely decoupled through interceptors (aspects).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到再次运行丢弃帧后出现的不寻常的差异，可能是因为代码在外部进行了更改。在大型应用程序中，观察这种行为往往并不简单。例如，你的应用程序可能使用缓存或记录数据，这些数据访问某个库以观察或执行通过拦截器（方面）完全解耦的代码。
- en: Calling the `Files.createFile()` method creates a new file in the filesystem.
    If you drop the frame after running this line, you’ll return to the line before
    the `createFile()` method is called. However, this doesn’t undo the file creation.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `Files.createFile()` 方法会在文件系统中创建一个新文件。如果你在运行此行代码后丢弃帧，你会回到调用 `createFile()`
    方法之前的行。然而，这并不会撤销文件创建。
- en: Listing 3.2 A method that makes changes outside the app when executing
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.2 执行时在应用程序外部进行更改的方法
- en: '[PRE2]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Creating a new file in the filesystem.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在文件系统中创建一个新文件。
- en: Summary
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: A conditional breakpoint is a breakpoint associated with a Boolean condition.
    The debugger pauses the execution only if the provided condition is true—that
    is, only when particular conditions apply. This way, you save the time of navigating
    through code until you get to the desired point to begin your investigation.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件断点是与布尔条件关联的断点。只有当提供的条件为真时，即只有当特定条件适用时，调试器才会暂停执行。这样，你可以节省在代码中导航直到到达你想要开始调查的点的时间。
- en: You can use breakpoints to log the values of certain variables in the console
    that don’t suspend the app’s execution. This approach is quite helpful because
    you can add log messages without changing the code.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用断点在控制台记录某些变量的值，而不会挂起应用程序的执行。这种方法非常有帮助，因为你可以在不更改代码的情况下添加日志消息。
- en: When the debugger pauses the execution on specific lines of code, you can alter
    the data on the fly to create custom scenarios according to what you want to investigate.
    This way, you don’t have to wait until the execution gets to a conditional breakpoint.
    In some cases, when you don’t have an appropriate environment, changing data while
    debugging saves you time you would have needed to prepare the data in the environment.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当调试器在特定代码行上暂停执行时，你可以实时更改数据，以根据你想要调查的内容创建自定义场景。这样，你不必等到执行到达条件断点。在某些情况下，当你没有适当的环境时，在调试过程中更改数据可以节省你本来需要准备数据的时间。
- en: Changing variables’ values to create a custom investigation scenario can be
    an efficient technique when trying to understand just a piece of the logic of
    a long-running process or when you don’t have the desired data in the environment
    where you run the app. However, changing more than one or two variable values
    at a time may add considerable complexity and make your investigation more challenging.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过更改变量的值来创建自定义调查场景，在试图理解长时间运行过程的某个逻辑部分或当你没有在运行应用的环境中获取到所需数据时，可以是一种有效的技术。然而，一次更改一个或两个以上的变量值可能会增加相当大的复杂性，使你的调查更具挑战性。
- en: You can step out of an investigation plan and return to the point before the
    method was called. This is called dropping a frame, but it can sometimes introduce
    an unwanted side effect. If the app changed anything externally (e.g., committed
    a transaction and changed some database records, changed a file in the filesystem,
    or made a RESTful call to another app), returning to a previous execution step
    won’t undo these changes.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以跳出调查计划并返回到方法调用之前的位置。这被称为丢弃帧，但有时可能会引入不希望出现的副作用。如果应用在外部进行了任何更改（例如，提交了事务并更改了一些数据库记录，更改了文件系统中的文件，或向另一个应用发出了RESTful调用），返回到之前的执行步骤不会撤销这些更改。
