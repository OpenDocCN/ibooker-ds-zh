- en: Appendix B. Groovy by feature
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附录B. Groovy按特性
- en: Some people learn by example. Some people learn by feature. In this book I’m
    trying to satisfy both. If you’re a Java developer with only passing familiarity
    with Groovy, hopefully either this appendix or [chapter 2](kindle_split_012.html#ch02),
    “Groovy by example,” will bring you up to speed on the Groovy language.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人通过例子学习。有些人通过特性学习。在这本书中，我试图满足两者。如果你是一个只有粗略了解Groovy的Java开发者，希望这个附录或[第2章](kindle_split_012.html#ch02)，“Groovy按例子”，能让你对Groovy语言有所了解。
- en: 'This appendix walks through most of the major features of Groovy and provides
    short snippets of code illustrating them. While this chapter does not claim to
    be an exhaustive reference like *Groovy in Action* (Manning, 2007; called *GinA*
    in the rest of this appendix), it has a couple of features that favor it over
    the more comprehensive treatment: (1) it’s considerably shorter, and (2) it has
    the words “Don’t Panic!” written in nice, friendly letters in the appendix (in
    this sentence, actually).^([[1](#app02fn01)]) More seriously, in this [appendix
    I](kindle_split_023.html#app01) review the major features of the Groovy programming
    language that are used throughout the book.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这个附录概述了Groovy的大部分主要特性，并提供了简短的代码片段来展示它们。虽然这一章并不声称像《Groovy实战》（Manning，2007；在本附录的其余部分称为GinA）那样是一个详尽的参考，但它有几个特点使其优于更全面的处理方法：（1）它相对较短，并且（2）附录中用友好的大字写着“不要慌张！”（实际上就在这句话中).^([[1](#app02fn01)])
    更严肃地说，在这个[附录I](kindle_split_023.html#app01)中，我回顾了本书中使用的Groovy编程语言的主要特性。
- en: ¹ For those born too late, that was a *Hitchhiker’s Guide to the Galaxy* reference.
    I could go on to say that this chapter “contains much that is apocryphal, or at
    least wildly inaccurate,” but that probably wouldn’t be good for sales.
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹ 对于那些出生太晚的人来说，这是一个对《银河系漫游指南》的引用。我可以说这一章“包含很多伪经，或者至少是非常不准确的内容”，但这可能对销售没有好处。
- en: 'Because this isn’t going to be a comprehensive treatment, I’ve chosen aspects
    of Groovy to review based on two criteria: (1) how often they’re used in practice
    and (2) how much they offer an advantage over corresponding features in Java (assuming
    the corresponding feature in Java even exists). After getting the basics of Groovy
    out of the way (like how to run Groovy programs and basic data types like numbers
    and strings), I’ll move on to issues like collections, I/O, XML, and more. Some
    topics, like SQL, are covered in other chapters, but you’ll find the essentials
    here.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这不会是一个全面的处理，我选择基于两个标准来审查Groovy的方面：（1）它们在实践中使用得多频繁，以及（2）它们相对于Java中相应特性（假设Java中甚至存在相应的特性）提供了多少优势。在掌握Groovy的基本知识（如如何运行Groovy程序和基本数据类型，如数字和字符串）之后，我将继续讨论集合、I/O、XML等问题。一些主题，如SQL，在其他章节中有所涉及，但你会发现这里的基本内容。
- en: B.1\. Scripts and the traditional example
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.1\. 脚本和传统例子
- en: 'Assuming you already have Groovy installed,^([[2](#app02fn02)]) I’ll start
    with the traditional “Hello, World!” program, as shown here:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经安装了Groovy，^([[2](#app02fn02)]) 我将从传统的“Hello, World!”程序开始，如下所示：
- en: ² See [appendix A](kindle_split_023.html#app01) for details.
  id: totrans-7
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ² 详细内容请见[附录A](kindle_split_023.html#app01)。
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: That’s the whole program. In Java, you need a `main` method inside a class,
    and inside the `main` method you call `System.out.println` to write to the console.
    Java developers are used to it, but there are roughly 8 to 10 different object-oriented
    concepts involved, depending on how you count them.^([[3](#app02fn03)]) In Groovy,
    the whole program is a single line.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是整个程序。在Java中，你需要在类内部有一个`main`方法，并在`main`方法内部调用`System.out.println`来写入控制台。Java开发者对此已经习惯了，但根据你如何计算，大约有8到10个面向对象的概念涉及其中.^([[3](#app02fn03)])
    在Groovy中，整个程序只有一行。
- en: ³ A rough count includes classes, methods, strings, arrays, public access, static
    methods and attributes, void return types, overloaded methods like `println`,
    and more. It’s no accident that Bruce Eckel’s *Thinking in Java* (Prentice-Hall,
    2002) takes over 100 pages just to get to his first “Hello, World” program.
  id: totrans-10
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³ 粗略统计包括类、方法、字符串、数组、公共访问、静态方法和属性、void返回类型、重载方法如`println`等。布鲁斯·艾克尔（Bruce Eckel）的《Java编程思想》（Prentice-Hall，2002）之所以需要超过100页才能到达他的第一个“Hello,
    World”程序，这并非偶然。
- en: To demonstrate, consider one of the two execution environments that come with
    Groovy, the `groovysh` command, which starts the Groovy shell. The Groovy shell
    is a REPL^([[4](#app02fn04)]) that allows you to execute Groovy code a line at
    a time. All of the lines in the following listing produce the same result.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，考虑 Groovy 伴随的两个执行环境之一，即 `groovysh` 命令，它启动 Groovy 壳。Groovy 壳是一个 REPL^[[[4](#app02fn04))]，允许你逐行执行
    Groovy 代码。以下列表中的所有行都会产生相同的结果。
- en: ⁴ Read-Eval-Print Loop; see [http://en.wikipedia.org/wiki/REPL](http://en.wikipedia.org/wiki/REPL)
    for details.
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴ 读取-评估-打印循环；有关详细信息，请参阅 [http://en.wikipedia.org/wiki/REPL](http://en.wikipedia.org/wiki/REPL)。
- en: Listing B.1\. Running “Hello, World!” in the Groovy shell
  id: totrans-13
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 B.1\. 在 Groovy 壳中运行“Hello, World!”
- en: '![](296fig01_alt.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](296fig01_alt.jpg)'
- en: In each case the `println` method prints to the console and returns `null`.
    When there’s no ambiguity, the parentheses can be omitted. Semicolons work as
    in Java, but they’re optional.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，`println` 方法都会打印到控制台并返回 `null`。当没有歧义时，可以省略括号。分号的作用与 Java 中的相同，但它们是可选的。
- en: This is an example of a Groovy *script*. A script is a code listing that doesn’t
    explicitly include a class definition. In Java, everything has to be inside a
    class. Groovy is able to work with both scripts and classes.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 Groovy *脚本* 的例子。脚本是一个不显式包含类定义的代码列表。在 Java 中，一切都必须在类内部。Groovy 能够同时处理脚本和类。
- en: 'A Groovy script is a form of *syntactic sugar*.^([[5](#app02fn05)]) A class
    is, in fact, involved. If I compile this script and then run the `javap` command
    on it, I get the following response:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy 脚本是一种 *语法糖*。[^([[5](#app02fn05))]] 一个类实际上也是涉及的。如果我编译这个脚本并对其运行 `javap`
    命令，我会得到以下响应：
- en: ⁵ Syntactic sugar is syntax that simplifies writing code but doesn’t change
    anything under the hood. There may be some evidence that an overuse of syntactic
    sugar leads to syntactic diabetes.
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁵ 语法糖是简化代码编写的语法，但不会在底层改变任何东西。过度使用语法糖可能会导致语法糖尿病。
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There are about 30 more lines of output from the `javap` command, mostly involving
    superclass methods. The interesting part is that the `groovy` command generates
    a class called `hello_world`, along with a pair of constructors and a `main` method.
    The class is generated at compile time and extends a class from the Groovy library
    called `groovy.lang.Script`. In effect, scripts in Groovy become classes in Java,
    where the code in the script ultimately (after a few layers of indirection) is
    executed by the `main` method. I don’t want to give the impression that Groovy
    is generating Java, however. Groovy code is compiled directly into bytecodes for
    the JVM.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`javap` 命令大约有 30 行输出，主要涉及超类方法。有趣的部分是 `groovy` 命令生成一个名为 `hello_world` 的类，以及一对构造函数和一个
    `main` 方法。该类在编译时生成，并扩展了来自 Groovy 库的 `groovy.lang.Script` 类。实际上，Groovy 中的脚本成为 Java
    中的类，其中脚本中的代码最终（经过几层间接）由 `main` 方法执行。然而，我不想给人留下 Groovy 生成 Java 的印象。Groovy 代码直接编译成
    JVM 的字节码。'
- en: '|  |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Compiled Groovy
  id: totrans-22
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 编译后的 Groovy
- en: Groovy is compiled, not interpreted. It’s not a code generator; the compiler
    generates Java bytecodes directly.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy 是编译的，而不是解释的。它不是一个代码生成器；编译器直接生成 Java 字节码。
- en: '|  |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Because the bytecodes run on the JVM, you can execute Groovy scripts using
    the `java` command as long as you include the necessary JAR file in your classpath:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字节码在 JVM 上运行，只要你在类路径中包含必要的 JAR 文件，就可以使用 `java` 命令执行 Groovy 脚本：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '|  |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Executing Groovy
  id: totrans-28
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行 Groovy
- en: At runtime, Groovy is just another JAR file. As long as the groovy-all JAR file
    is in the classpath, Java is perfectly happy to execute compiled Groovy code.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，Groovy 只是一个 JAR 文件。只要 groovy-all JAR 文件在类路径中，Java 就可以完美地执行编译后的 Groovy 代码。
- en: '|  |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The `groovy` command is used to execute Groovy programs. It can be used with
    either the compiled code (similar to the `java` command) or Groovy source. If
    you use the source, the `groovy` command first compiles the code and then executes
    it.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`groovy` 命令用于执行 Groovy 程序。它可以与编译后的代码（类似于 `java` 命令）或 Groovy 源代码一起使用。如果你使用源代码，`groovy`
    命令首先编译代码然后执行它。'
- en: B.2\. Variables, numbers, and strings
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.2\. 变量、数字和字符串
- en: Groovy is an optionally typed language. Groovy uses classes to define data types,
    just as Java does, but Groovy variables can either have a static type or use the
    `def` keyword.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy 是一种可选类型的语言。Groovy 使用类来定义数据类型，就像 Java 一样，但 Groovy 变量可以是静态类型或使用 `def` 关键字。
- en: 'For example, I’m perfectly free to declare variables of type `int`, `String`,
    or `Employee`, using the standard Java syntax:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我完全可以自由地声明类型为 `int`、`String` 或 `Employee` 的变量，使用标准的 Java 语法：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If I don’t know the type of the variable, or I don’t care, Groovy provides
    the keyword `def`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我不知道变量的类型，或者我不在乎，Groovy 提供了关键字 `def`：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '|  |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Typed vs. untyped variables**'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**类型化变量与无类型变量**'
- en: 'When should you use `def` as opposed to the actual type? There’s no strict
    answer, but recently I had a (very mild) Twitter debate about this issue with
    Dierk Koenig (lead author of *GinA*), Andres Almiray (lead author of *Griffon
    in Action* and head of the Griffon project), and Dave Klein (lead author of *Grails:
    A Quick-Start Guide*). Dierk had the best recommendation I’ve ever heard on the
    subject. He said, “If I think of a type, I type it (pun intended).”'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '当你应该使用 `def` 而不是实际类型时？没有严格的答案，但最近我关于这个问题与 Dierk Koenig（*GinA* 的主要作者）、Andres
    Almiray（*Griffon in Action* 的主要作者和 Griffon 项目负责人）以及 Dave Klein（*Grails: A Quick-Start
    Guide* 的主要作者）进行了一场（非常温和的）Twitter 讨论。Dierk 在这个话题上给出了我听过的最好的建议。他说：“如果我想到了一个类型，我就输入它（字面意思）。”'
- en: My own experience is that as I get more experienced with Groovy, I tend to use
    `def` less and less. I agree with Dierk’s recommendation, with the added advice
    that now when I declare a type, I pause for a moment to see if any actual type
    occurs to me. If so, I use it.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我自己的经验是，随着我对 Groovy 的经验越来越丰富，我越来越少使用 `def`。我同意 Dierk 的建议，并额外建议现在当我声明一个类型时，我会停下来片刻，看看是否有什么实际类型浮现在我的脑海中。如果有，我就使用它。
- en: In some cases `def` is preferred, most notably when using mock objects in testing.
    That subject is discussed in [chapter 6](kindle_split_017.html#ch06).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，`def` 更受欢迎，尤其是在使用测试中的模拟对象时。这个主题在第 [6 章](kindle_split_017.html#ch06) 中讨论。
- en: '|  |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Moving on to data types themselves, Java makes a distinction between primitives
    and classes. In Groovy there are no primitives. Numbers in Groovy are first-class
    objects, with their own set of methods.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们来看看数据类型本身。Java 在原始类型和类之间做出了区分。在 Groovy 中没有原始类型。Groovy 中的数字是一等对象，有自己的方法集。
- en: B.2.1\. Numbers
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: B.2.1. 数字
- en: 'Because in Groovy numbers are objects, I can determine their data types. For
    integer literals, the data type depends on the value, as shown in this script:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在 Groovy 中数字是对象，我可以确定它们的数据类型。对于整型字面量，数据类型取决于值，如下面的脚本所示：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There are a few points to be made about this script. First, the variable `x`
    doesn’t have a declaration at all. This is only legal in a script, where the variable
    becomes part of the script’s binding and can be set and accessed from outside.
    Details of this procedure are shown in [chapter 3](kindle_split_013.html#ch03)
    on integration with Java. Suffice it to say here that this is legal in a script,
    but not in a class. If it makes you feel more comfortable, you’re free to add
    the word `def` in front of x.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个脚本有几个要点需要注意。首先，变量 `x` 完全没有声明。这只有在脚本中才是合法的，其中变量成为脚本绑定的一部分，可以从外部设置和访问。关于这个过程的详细信息请参阅
    [第 3 章](kindle_split_013.html#ch03) 关于与 Java 的集成。这里只需说，这在脚本中是合法的，但在类中不是。如果你觉得更舒服，你可以在
    x 前面自由地添加单词 `def`。
- en: '|  |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Script Variables
  id: totrans-50
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 脚本变量
- en: If a variable in a script is not declared, it becomes part of the script’s binding.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果脚本中的一个变量没有被声明，它就成为了脚本绑定的一个部分。
- en: '|  |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: As mentioned earlier, the script lacks semicolons. Semicolons as statement separators
    are optional in Groovy and can be omitted if there’s no ambiguity. Again, you’re
    free to add them in without a problem.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，脚本缺少分号。在 Groovy 中，分号作为语句分隔符是可选的，如果没有歧义，可以省略。再次强调，你可以自由地添加它们而不会出现问题。
- en: '|  |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Semicolons
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 分号的使用
- en: In Groovy, semicolons work but are optional.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Groovy 中，分号是有效的，但不是必需的。
- en: '|  |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Next, Groovy uses the method called `assert` extensively. The word `assert`
    can be written without parentheses, as done here, or you can surround an expression
    with them. The resulting expression must evaluate to a Boolean, but that’s a much
    looser requirement than in Java. In Java, the only available Booleans are `true`
    and `false`. In Groovy, non-null references are true, as are nonzero numbers,
    non-empty collections, non-empty strings, and the Boolean value `true`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，Groovy 广泛使用名为 `assert` 的方法。单词 `assert` 可以不带括号书写，就像这里一样，或者你可以用它们包围一个表达式。结果表达式必须评估为布尔值，但这比
    Java 中的要求宽松得多。在 Java 中，唯一可用的布尔值是 `true` 和 `false`。在 Groovy 中，非空引用是 true，非零数字、非空集合、非空字符串以及布尔值
    `true` 都是 true。
- en: That bears repeating and goes by the term *The Groovy Truth*.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要重复强调，被称为 *Groovy 真理*。
- en: '|  |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The Groovy Truth
  id: totrans-61
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Groovy 真理
- en: In Groovy, non-null references, non-empty collections, non-empty strings, nonzero
    numbers, and the Boolean value `true` are all true.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Groovy 中，非空引用、非空集合、非空字符串、非零数字以及布尔值 `true` 都是真实的。
- en: '|  |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Finally, the default data type for floating-point values in Java is `double`,
    but in Groovy it’s `java.math.BigDecimal`. The `double` type in Java has approximately
    17 decimal places of precision, but if you want to get depressed about its accuracy,
    try this tiny sample:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Java 中浮点值的默认数据类型是 `double`，但在 Groovy 中是 `java.math.BigDecimal`。Java 中的 `double`
    类型大约有 17 位十进制精度，但如果你想对其准确性感到沮丧，可以尝试这个微小的示例：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `d` appended to the literals makes them doubles. You would expect the answer
    here to be 0.9, but in fact it’s 0.8999999999999999. That’s not much of a difference,
    but I’ve only done a single subtraction and I’m already off. That’s not good.
    That’s why any serious numerical calculations in Java require `java.math.BigDecimal`,
    but that means you can’t use the standard operators (`+`, `-`, `*`, `/`) anymore
    and have to use method calls instead.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在字面量后附加的 `d` 使其成为双精度浮点数。你可能会期望这里的答案是 0.9，但实际上它是 0.8999999999999999。这并不是很大的差异，但我只做了一次减法，就已经出现了偏差。这并不好。这就是为什么任何严肃的数值计算在Java中都需要
    `java.math.BigDecimal`，但这意味着你不能再使用标准运算符（`+`、`-`、`*`、`/`）了，而必须使用方法调用。
- en: 'Groovy handles that issue without a problem. Here’s the analogous Groovy script:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy 无需处理这个问题。以下是对应的 Groovy 脚本：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The answer in this case is 0.9, as expected. Because the calculations are done
    with `BigDecimal`, the answer is correct. Groovy also has operator overloading,
    so the plus operator can be used with the `BigDecimal` values. To summarize:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，答案是 0.9，正如预期的那样。因为计算使用了 `BigDecimal`，所以答案是正确的。Groovy 也支持运算符重载，因此加法运算符可以与
    `BigDecimal` 值一起使用。总结如下：
- en: '|  |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Literals
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 字面量
- en: Numbers without a decimal point are of type `Integer`, `Long`, or `java.math.BigInteger`,
    depending on size. Numbers with a decimal point are of type `java.math.BigDecimal.`
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 没有小数点的数字类型为 `Integer`、`Long` 或 `java.math.BigInteger`，具体取决于大小。有小数点的数字类型为 `java.math.BigDecimal`。
- en: '|  |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Because numbers are objects, they have methods as well. [Listing B.2](#app02ex02)
    shows a script putting some numbers through their paces. Several of the expressions
    use closures, which are the subject of [section B.4](#app02lev1sec4). The simplest
    definition is to consider them a block of code that’s executed as though it’s
    an anonymous method call.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 因为数字是对象，所以它们也有方法。[B.2 列表](#app02ex02) 展示了一个脚本，它对一些数字进行了测试。其中一些表达式使用了闭包，这是 [B.4
    节](#app02lev1sec4) 的主题。最简单的定义是，将它们视为一个代码块，就像它是匿名方法调用一样执行。
- en: Listing B.2\. `numbers.groovy`, showing method calls on numeric literals
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 B.2\. `numbers.groovy`，显示对数字字面量的方法调用
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Groovy has an exponentiation operator, unlike Java. Numbers have methods like
    `times`, `upto`, and `downto`. The `times` operation takes a single argument of
    type `Closure`. When the last argument to a method is a closure, you can put it
    after the parentheses. Because the method has no other arguments, you can leave
    out the parentheses altogether.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy 有一个指数运算符，与 Java 不同。数字有 `times`、`upto` 和 `downto` 等方法。`times` 操作接受一个类型为
    `Closure` 的单个参数。当方法参数的最后一个参数是闭包时，可以将其放在括号之后。因为方法没有其他参数，所以可以完全省略括号。
- en: '|  |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Closure Arguments
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 闭包参数
- en: If the last argument to a method is a closure, it can be placed after the parentheses.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果方法参数的最后一个参数是闭包，则可以将其放在括号之后。
- en: '|  |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The `upto` and `downto` methods take two arguments, so the parentheses are shown
    in the former and a comma is used in the latter to indicate that both the number
    and the closure are arguments to the method. The `countDown` variable is a list,
    which will be discussed in [section B.3](#app02lev1sec3). The left-shift operator
    has been overloaded to append to the collection, and its argument here is a parameterized
    string. Groovy has two types of strings, discussed in the next section.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`upto` 和 `downto` 方法接受两个参数，因此前者显示了括号，后者使用逗号来表示数字和闭包都是方法的参数。`countDown` 变量是一个列表，将在
    [B.3 节](#app02lev1sec3) 中讨论。左移运算符被重载以向集合中添加元素，这里的参数是一个参数化字符串。Groovy 有两种字符串类型，将在下一节讨论。'
- en: B.2.2\. Strings and Groovy strings
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: B.2.2\. 字符串和Groovy字符串
- en: In Java, single quotes delimit characters (a primitive) and double quotes surround
    instances of `java.lang.String`. In Groovy, both single and double quotes are
    used for strings, but there’s a difference. Double-quoted strings are used for
    parameter replacement. They’re not instances of `java.lang.String`, but rather
    instances of `groovy.lang.GString`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，单引号用于界定字符（原始类型）而双引号包围`java.lang.String`的实例。在Groovy中，单引号和双引号都用于字符串，但存在区别。双引号字符串用于参数替换。它们不是`java.lang.String`的实例，而是`groovy.lang.GString`的实例。
- en: 'Here are a couple of examples to show how they’re used:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些示例，展示了它们的用法：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Single-quoted strings are always instances of `java.lang.String`. Double-quoted
    strings may or may not be Groovy strings, depending on whether parameter replacement
    is done or not.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 单引号字符串始终是`java.lang.String`的实例。双引号字符串可能是Groovy字符串，也可能不是，这取决于是否进行了参数替换。
- en: 'Groovy also has multiline strings, with either single or double quotes. The
    difference again is whether or not parameter replacement is done:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy还有多行字符串，可以是单引号或双引号。区别再次在于是否进行了参数替换：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There’s one final kind of string, used for regular expressions. Java has had
    regular-expression capabilities since version 1.4, but most developers either
    aren’t aware of them or avoid them.^([[6](#app02fn06)]) One particularly annoying
    part of regular expressions in Java is that the backslash character, `\`, is used
    as an escape character, but if you want to use it in a regular expression, you
    have to backslash the backslash. This leads to annoying expressions where you
    have to double-backslash the backslashes, making the resulting expressions almost
    unreadable.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后还有一种字符串类型，用于正则表达式。Java从1.4版本开始就具备正则表达式功能，但大多数开发者要么不知道，要么避免使用它们.^([[6](#app02fn06)])
    Java中正则表达式的一个特别令人烦恼的部分是反斜杠字符`\`用作转义字符，但如果你想在正则表达式中使用它，你必须对反斜杠进行转义。这导致了一些令人烦恼的表达式，其中你必须对反斜杠进行双重转义，使得结果表达式几乎无法阅读。
- en: ⁶ Perl programmers love regular expressions. Ruby developers are fond of them,
    but reasonable about it. Java developers take one look at the JavaDocs for the
    `java.util.regex.Pattern` class and recoil in horror.
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁶ Perl程序员热爱正则表达式。Ruby开发者也喜欢它们，但态度比较理性。Java开发者一看到`java.util.regex.Pattern`类的JavaDocs，就会感到恐惧。
- en: Groovy provides what’s called the *slashy* syntax. If you surround an expression
    with forward slashes, it’s assumed to be a regular expression, and you don’t have
    to double-backslash anymore.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy提供了所谓的*斜杠语法*。如果你用斜杠包围一个表达式，它就被假定为正则表达式，你不再需要双重转义。
- en: '|  |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Strings
  id: totrans-94
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 字符串
- en: Groovy uses single quotes for regular strings, double quotes for parameterized
    strings, and forward slashes for regular expressions.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy使用单引号表示普通字符串，双引号表示参数化字符串，斜杠用于正则表达式。
- en: '|  |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Here’s an example that checks strings to see if they are palindromes: that
    is, if they are the same forward and backward. To check for palindromes you first
    need to remove any punctuation and ignore case before reversing the string:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例，用于检查字符串是否是回文：也就是说，如果它们正向和反向相同。要检查回文，你首先需要移除任何标点符号，并在反转字符串之前忽略大小写：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Once again, a little Groovy code packs a lot of power. The method `eachLine`
    has been added to the `String` class to break multiline strings at line breaks.
    It takes a closure as an argument. In this case, no dummy variables were used
    in the closure, so each string is assigned to the default variable called `it`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 再次证明，一点Groovy代码就能包含很多功能。`String`类中添加了`eachLine`方法，用于在换行处分割多行字符串。它接受一个闭包作为参数。在这种情况下，闭包中没有使用虚拟变量，因此每个字符串都分配给默认变量`it`。
- en: '|  |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The it variable
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: it变量
- en: In a closure, if no dummy name is specified the term `it` is used by default.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在闭包中，如果没有指定虚拟名称，则默认使用术语`it`。
- en: '|  |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The `trim` method is applied to the line to remove any leading and trailing
    spaces. Then the `replaceAll` method is used to replace all non-word characters
    with an empty string. Finally, the string is converted to lowercase.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`trim`方法应用于行以移除任何前导和尾随空格。然后使用`replaceAll`方法将所有非单词字符替换为空字符串。最后，将字符串转换为小写。'
- en: The assert test uses another method added by Groovy to `String`, called `reverse`.
    Java has a `reverse` method in `StringBuffer`, but not `String`. Groovy adds the
    `reverse` method to `String` for convenience.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: assert测试使用了Groovy添加到`String`的另一个方法，称为`reverse`。Java在`StringBuffer`中有`reverse`方法，但不是在`String`中。Groovy为了方便，将`reverse`方法添加到`String`。
- en: Groovy adds lots of methods to the Java standard libraries. Collectively these
    are known as the *Groovy* *JDK* and are one of the best features of Groovy. The
    Groovy documentation includes GroovyDocs for both the Groovy standard library
    and the Groovy JDK.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy向Java标准库添加了许多方法。这些方法统称为*Groovy* *JDK*，并且是Groovy的最佳特性之一。Groovy文档包括Groovy标准库和Groovy
    JDK的GroovyDocs。
- en: '|  |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The Groovy JDK
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Groovy JDK
- en: Through its metaprogramming capabilities, Groovy adds many convenient methods
    to the standard Java libraries. These additional methods are known as the Groovy
    JDK.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 通过其元编程能力，Groovy向标准Java库添加了许多便利方法。这些额外的方法被称为Groovy JDK。
- en: '|  |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: In summary, Groovy uses numbers and objects and has both regular and parameterized
    strings with additional methods. Another area where Groovy greatly simplifies
    Java is collections.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，Groovy使用数字和对象，并且具有常规和参数化的字符串以及额外的方法。Groovy在简化Java的另一个领域是集合。
- en: B.3\. Plain Old Groovy Objects
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.3\. Plain Old Groovy Objects
- en: Java classes with getters and setters for the attributes are often known as
    POJOs, or Plain Old Java Objects. In Groovy, the same classes are Plain Old Groovy
    Objects, or POGOs.^([[7](#app02fn07)]) POGOs have additional characteristics that
    are discussed in this section.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 具有属性获取器和设置器的Java类通常被称为POJOs，或Plain Old Java Objects。在Groovy中，相同的类被称为Plain Old
    Groovy Objects，或POGOs.^([[7](#app02fn07)]) 本节讨论了POGOs的额外特性。
- en: ⁷ Python occasionally uses the term POPOs, which sounds vaguely disgusting.
    If you really want to annoy a Ruby developer, refer to POROs. Ruby people hate
    anything that sounds like Java.
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁷ Python偶尔使用POPOs这个术语，听起来有点令人作呕。如果你真的想惹恼一个Ruby开发者，可以提到POROs。Ruby开发者讨厌任何听起来像Java的东西。
- en: 'Consider the following `Person` class in Groovy:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下Groovy中的`Person`类：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: POGOs don’t require access modifiers, because in Groovy attributes are private
    by default and methods are public by default. The class is public by default,
    as well. Any property without an access modifier automatically gets a public getter
    and setter method. If you want to add `public` or `private` you can, and either
    on an attribute will prevent the generation of the associated getter and setter.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: POGOs不需要访问修饰符，因为在Groovy中属性默认是私有的，方法默认是公共的。类也是默认公共的。任何没有访问修饰符的属性都会自动获得公共的获取器和设置器方法。如果你想添加`public`或`private`，你可以这样做，并且对属性的任何指定都会阻止生成相关的获取器和设置器。
- en: '|  |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Groovy properties
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Groovy属性
- en: In Groovy, property access is done through dynamically generated getter and
    setter methods.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在Groovy中，属性访问是通过动态生成的获取器和设置器方法完成的。
- en: '|  |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Here’s a script using the `Person` class:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用`Person`类的脚本示例：
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The script shows that you also get a default, *map-based* constructor, so called
    because it uses the same `property:value` syntax used by Groovy maps.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本显示，你还可以获得一个默认的、*基于映射的*构造函数，之所以称为这样，是因为它使用了Groovy映射中使用的相同的`property:value`语法。
- en: This idiom is so common in Groovy that getter and setter methods anywhere in
    the standard library are typically accessed with the property notation. For example,
    `Calendar.instance` is used to invoke the `getInstance` method on the `Calendar`
    class.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个习惯用法在Groovy中非常常见，以至于标准库中的任何地方的获取器和设置器方法通常都使用属性表示法来访问。例如，`Calendar.instance`用于在`Calendar`类上调用`getInstance`方法。
- en: Moving now to collections of instances, I’ll start with ranges, then move to
    lists, and finally look at maps.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在转向实例集合，我将从范围开始，然后转向列表，最后查看映射。
- en: B.4\. Collections
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.4\. 集合
- en: Since J2SE 1.2, the Java standard library has included the collections framework.
    The framework defines interfaces for lists, sets, and maps, and provides a small
    but useful set of implementation classes for each interface, as well as a set
    of polymorphic utility methods in the class `java.util.Collections`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 自从J2SE 1.2以来，Java标准库已经包括了集合框架。该框架定义了列表、集合和映射的接口，并为每个接口提供了一组小型但实用的实现类，以及`java.util.Collections`类中的一组多态实用方法。
- en: 'Groovy can use all of these collections but adds a lot:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy可以使用所有这些集合，但还添加了很多：
- en: Native syntax for lists and maps
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表和映射的原生语法
- en: A `Range` class
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`Range`类
- en: Many additional convenience methods
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多额外的便利方法
- en: I’ll present examples of each in this section.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在本节中展示每个示例。
- en: B.4.1\. Ranges
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: B.4.1\. 范围
- en: '*Ranges* are collections in Groovy consisting of two values separated by a
    pair of dots. Ranges are normally used as parts of other expressions, like loops,
    but they can be used by themselves.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*范围*是Groovy中的集合，由一对点分隔的两个值组成。范围通常用作其他表达式的部分，如循环，但也可以单独使用。'
- en: 'The class `groovy.lang.Range` has methods for accessing the boundaries of a
    range, as well as checking whether it contains a particular element. Here’s a
    simple example:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`groovy.lang.Range` 类提供了访问范围边界的方法，以及检查它是否包含特定元素的功能。以下是一个简单的示例：'
- en: '[PRE14]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Using two dots includes the boundaries. To exclude the upper boundary, use
    a less-than sign:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用两个点包括边界。要排除上限，请使用小于号：
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'A range of numbers iterates over the contained integers. Other library classes
    can be used in ranges. Strings go letter by letter:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 数字范围会遍历包含的整数。其他库类也可以用于范围。字符串按字母顺序遍历：
- en: '[PRE16]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Dates iterate over the contained days, as shown in the next listing.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 日期遍历包含的日期，如下一列表所示。
- en: Listing B.3\. Using dates in a range with Java’s `Calendar` class
  id: totrans-143
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 B.3\. 使用 Java 的 `Calendar` 类在范围中使用日期
- en: '![](304fig01_alt.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图片](304fig01_alt.jpg)'
- en: For all its gifts, even Groovy can’t tame Java’s awkward `java.util.Date` and
    `java.util` `.Calendar` classes, but it can make the code for using them a bit
    simpler. `Calendar` is an abstract class with the factory method `getInstance`,
    so in Groovy I call it by accessing the `instance` property. The Groovy JDK adds
    the `format` method to `Date`, so it isn’t necessary to separately instantiate
    `SimpleDateFormat`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Groovy拥有众多优点，但它也无法驯服Java中略显笨拙的 `java.util.Date` 和 `java.util.Calendar` 类，但它可以使使用它们的代码变得更加简单。`Calendar`
    是一个具有工厂方法 `getInstance` 的抽象类，因此我在Groovy中通过访问 `instance` 属性来调用它。Groovy JDK 为 `Date`
    添加了 `format` 方法，因此不需要单独实例化 `SimpleDateFormat`。
- en: In the listing, after setting the year, month, and day, the `Date` instance
    is retrieved by invoking `getTime`.^([[8](#app02fn08)]) In this case, that’s equivalent
    to accessing the `time` property. The dates are used as the boundaries of a range
    by the `each` method, which appends each one to a list.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表中，在设置年份、月份和日期之后，通过调用 `getTime` 获取 `Date` 实例。^([[8](#app02fn08)]) 在这种情况下，这相当于访问
    `time` 属性。日期被 `each` 方法用作范围的边界，该方法将每个日期追加到列表中。
- en: ⁸ Yes, you read that correctly. You *get* the *date* by calling ... `getTime`.
    Hey, I didn’t write it.
  id: totrans-147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁸ 是的，您没有看错。您通过调用 ... `getTime` 来获取 *日期*。嘿，这不是我写的。
- en: 'In fact, any class can be made into a range if it includes three features:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，任何包含三个特征的类都可以被转换为范围：
- en: A `next()` method, for forward iteration
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `next()` 方法，用于正向迭代
- en: A `previous()` method, for backward iteration
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `previous()` 方法，用于反向迭代
- en: An implementation of the `java.util.Comparable` interface, for ordering
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 `java.util.Comparable` 接口，用于排序
- en: Here the range is used as the basis of a loop, where the dates are appended
    to a list.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，范围用作循环的基础，日期被追加到列表中。
- en: B.4.2\. Lists
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: B.4.2. 列表
- en: 'Lists in Groovy are the same as lists in Java, except that the syntax is easier
    and there are some additional methods available. Create a list in Groovy by including
    values between square brackets:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy 中的列表与 Java 中的列表相同，只是语法更简单，并且有一些额外的方法可用。在 Groovy 中创建列表，请将值放在方括号之间：
- en: '[PRE17]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The default list is of type `java.util.ArrayList`. If you prefer to use a `LinkedList`,
    instantiate it in the normal way.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 默认列表类型为 `java.util.ArrayList`。如果您想使用 `LinkedList`，请按常规方式实例化它。
- en: 'Groovy has operator overloading. The Groovy JDK shows that the plus, minus,
    and left-shift operators have been defined to work with lists:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy 具有操作符重载。Groovy JDK 显示，加号、减号和左移操作符已被定义为与列表一起工作：
- en: '[PRE18]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Accessing elements of a list can be done with array-like syntax. Again, this
    is done by overriding a method—in this case, the `getAt` method:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用类似数组的语法访问列表的元素。同样，这是通过重写方法来实现的——在这种情况下，是 `getAt` 方法：
- en: '[PRE19]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As shown in [figure B.1](#app02fig01), access to elements from the left end
    starts at index 0\. Access from the right end starts at index –1\. You can use
    a range in the square brackets, too:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [图 B.1](#app02fig01) 所示，从左侧访问元素从索引 0 开始。从右侧访问从索引 -1 开始。您也可以使用方括号中的范围：
- en: '[PRE20]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Figure B.1\. Access any linear collection using an index from either end. The
    first element is at index 0\. The last element is at index –1\. You can also use
    subranges, as in mylist[-4..-2].
  id: totrans-163
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 B.1\. 使用索引从两端访问任何线性集合。第一个元素在索引 0。最后一个元素在索引 -1。您还可以使用子范围，例如 mylist[-4..-2]。
- en: '![](bfig01.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图片](bfig01.jpg)'
- en: '|  |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Array-like Access
  id: totrans-166
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 类似数组的访问
- en: Linear collections support element access through an index from either end,
    or even using a range.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 线性集合支持从两端通过索引访问元素，甚至可以使用范围。
- en: '|  |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Groovy adds methods like `pop`, `intersect`, and `reverse` to collections. See
    the GroovyDocs for details.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy 为集合添加了 `pop`、`intersect` 和 `reverse` 等方法。详细信息请参阅 GroovyDocs。
- en: 'There are two ways to apply a function to each element. The *spread-dot* operator
    (`.*`) makes it easy to access a property or apply a method to each element:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以将函数应用于每个元素。*扩展点*操作符 (`.*`) 使得访问属性或对每个元素应用方法变得容易：
- en: '[PRE21]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `collect` method takes a closure as an argument and applies it to each
    element of the collection, returning a list with the results. This is similar
    to the spread-dot operator, but can do more general operations:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`collect` 方法接受一个闭包作为参数，并将其应用于集合的每个元素，返回一个包含结果的列表。这与扩展点操作符类似，但可以进行更通用的操作：'
- en: '[PRE22]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The word `city` here used before the arrow is like a dummy argument for a method
    call. The closure extracts the first three letters of each element of the list
    and then converts them to lowercase.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在箭头之前使用的单词 `city` 作为一个方法调用的占位符。闭包提取列表中每个元素的前三个字母，并将它们转换为小写。
- en: 'One particularly interesting feature of collections is that they support type
    coercion using the `as` operator. What does that mean? It’s not terribly difficult
    to convert a Java list into a set, because there’s a constructor for that purpose.
    Converting a list into an array, however, involves some awkward, counterintuitive
    code. Here’s Groovy’s take on the process:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 集合的一个特别有趣的特点是它们支持使用 `as` 操作符进行类型强制转换。这意味着什么？将 Java 列表转换为集合并不困难，因为有一个构造函数用于此目的。然而，将列表转换为数组则需要一些笨拙、反直觉的代码。以下是
    Groovy 对此过程的看法：
- en: '[PRE23]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: That was easy.^([[9](#app02fn09)]) A set in Groovy is just like a set in Java,
    meaning it doesn’t contain duplicates and doesn’t guarantee order.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单.^([[9](#app02fn09)]) Groovy 中的集合就像 Java 中的集合一样，这意味着它不包含重复项，也不保证顺序。
- en: ⁹ I know I say that a lot, but with Groovy I think it a lot, too.
  id: totrans-178
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁹ 我知道我经常这么说，但用 Groovy 我也经常这么想。
- en: '|  |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The as operator
  id: totrans-180
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: as 操作符
- en: Groovy uses the keyword `as` for many purposes. One of them is type coercion,
    which converts an instance of one class into an instance of another.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy 使用关键字 `as` 用于许多目的。其中之一是类型强制转换，它将一个类的实例转换为另一个类的实例。
- en: '|  |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'One of the nicest features of Groovy collections is that they’re searchable.
    Groovy adds both `find` and `findAll` methods to collections. The `find` method
    takes a closure and returns the first element that satisfies the closure:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy 集合最令人愉悦的特性之一是它们是可搜索的。Groovy 为集合添加了 `find` 和 `findAll` 方法。`find` 方法接受一个闭包，并返回满足闭包的第一个元素：
- en: '[PRE24]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `findAll` method returns all the elements that satisfy the closure. This
    example returns all the cities that have the letter *e* in their name:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`findAll` 方法返回满足闭包的所有元素。此示例返回所有名字中包含字母 *e* 的城市：'
- en: '[PRE25]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Groovy also supplies the methods `any` and `every`, which also take closures:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy 还提供了 `any` 和 `every` 方法，这些方法也接受闭包：
- en: '[PRE26]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The first expression states that there’s at least one city whose name is less
    than 7 characters. The second expression says that all of the city names are 10
    characters or less.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个表达式表示至少有一个城市的名字少于 7 个字符。第二个表达式说明所有城市名字的长度都不超过 10 个字符。
- en: '[Table B.1](#app02table1) summarizes the searchable methods.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 B.1](#app02table1) 总结了添加到 Groovy 集合中的可搜索方法。'
- en: Table B.1\. Searchable methods added to Groovy collections
  id: totrans-191
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Table B.1\. 添加到 Groovy 集合中的可搜索方法
- en: '| Method | Description |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| any | Returns true if any element satisfies closure |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| any | 如果任何元素满足闭包则返回 true |'
- en: '| every | Returns true if all elements satisfy closure |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| every | 如果所有元素满足闭包则返回 true |'
- en: '| find | Returns first element satisfying closure |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| find | 返回满足闭包的第一个元素 |'
- en: '| findAll | Returns list of all elements satisfying closure |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| findAll | 返回满足闭包的所有元素的列表 |'
- en: 'Finally, the `join` method concatenates all the elements of the list into a
    single string, using the supplied separator:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`join` 方法使用提供的分隔符将列表中的所有元素连接成一个单独的字符串：
- en: '[PRE27]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The combination of native syntax and added convenience methods makes Groovy
    lists much easier to work with than their Java counterparts. As it turns out,
    maps are improved the same way.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 原生语法和附加便利方法的组合使得 Groovy 列表比它们的 Java 对应物更容易处理。实际上，映射也是以同样的方式改进的。
- en: B.4.3\. Maps
  id: totrans-201
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: B.4.3\. 映射
- en: Groovy maps are like Java maps, but again with a native syntax and additional
    helper methods. Groovy uses the same square-bracket syntax for maps as for lists,
    but each entry in the map uses a colon to separate the key from its corresponding
    value.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy 映射类似于 Java 映射，但再次具有原生语法和额外的辅助方法。Groovy 使用与列表相同的方括号语法来表示映射，但映射中的每个条目都使用冒号来分隔键和其对应的值。
- en: 'You can populate a map right away by adding the elements when you declare the
    map itself:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在声明映射本身时立即通过添加元素来填充映射：
- en: '[PRE28]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This defines a map with three entries. When adding elements to the map, the
    keys are assumed to be strings, so you don’t need to put quotes around them. The
    values can be anything.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了一个包含三个条目的映射。当向映射中添加元素时，假设键是字符串类型，因此不需要在它们周围放置引号。值可以是任何内容。
- en: '|  |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Map keys
  id: totrans-207
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 映射键
- en: When adding to a map, the keys are assumed to be of type `string`, so no quotes
    are necessary.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在向映射中添加内容时，假设键的类型为 `string`，因此不需要引号。
- en: '|  |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'You can add to a map using either Java or Groovy syntax:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 Java 或 Groovy 语法向映射中添加内容：
- en: '[PRE29]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ^(10) For non-baseball people, ALEast is short for the Eastern division of the
    American League.
  id: totrans-212
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^（10）对于非棒球爱好者来说，ALEast 是美国联盟东部分区的缩写。
- en: 'Accessing values can be done with either the array-like syntax shown, or using
    a dot. If the key has spaces in it, wrap the key in quotes:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用显示的数组语法或使用点来访问值。如果键中包含空格，请将键用引号括起来：
- en: '[PRE30]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'I’ve been using `def` to define the map reference, but Groovy understands Java
    generics:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我一直使用 `def` 来定义映射引用，但 Groovy 理解 Java 泛型：
- en: '[PRE31]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Maps have a `size` method that returns the number of entries. Actually, the
    `size` method is universal.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 映射有一个 `size` 方法，它返回条目的数量。实际上，`size` 方法是通用的。
- en: '|  |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Size
  id: totrans-219
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 大小
- en: In Groovy, the `size` method works for arrays, lists, maps, strings, and more.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Groovy 中，`size` 方法适用于数组、列表、映射、字符串等。
- en: '|  |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Maps have an overloaded `plus` operation that combines the entries from two
    maps:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 映射有一个重载的 `plus` 操作，它将两个映射的条目组合起来：
- en: '[PRE32]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Like Java maps, you can extract the set of keys from a map using the `keySet`
    method:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Java 映射一样，您可以使用 `keySet` 方法从映射中提取键集：
- en: '[PRE33]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Maps also have a rather controversial method that lets you add a new element
    with a default in case the element doesn’t exist:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 映射还有一个相当有争议的方法，允许您在元素不存在的情况下添加一个具有默认值的元素：
- en: '[PRE34]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here I’m trying to retrieve a value using a key that isn’t in the map (`Toronto`).
    If the key exists, its value is returned. If not, it’s added to the map, with
    the second argument to the `get` method being its new value. This is convenient,
    but it means that if you accidentally misspell a key when trying to retrieve it
    you don’t get an error; instead, you wind up adding it. That’s not true when using
    the single-argument version of `get`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我尝试使用不在映射中的键（`Toronto`）来检索值。如果键存在，则返回其值。如果不存在，则将其添加到映射中，`get` 方法的第二个参数是其新值。这很方便，但这也意味着如果您在尝试检索时意外拼写错误，您不会收到错误；相反，您最终会添加它。使用
    `get` 的单参数版本则不是这样。
- en: 'Finally, when you iterate over a map using a closure, the number of dummy arguments
    determines how the map is accessed. Using two arguments means that the map is
    accessed as keys and values:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当您使用闭包迭代映射时，虚拟参数的数量决定了如何访问映射。使用两个参数意味着映射作为键和值被访问：
- en: '[PRE35]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `each` iterator has two dummy variables, so the first represents the key
    and the second the value. This closure appends the keys to a string, separated
    by vertical bars. The values are added to a list.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`each` 迭代器有两个虚拟变量，因此第一个代表键，第二个代表值。这个闭包将键追加到一个字符串中，键之间用竖线分隔。值被添加到一个列表中。'
- en: 'Alternatively, using a single argument assigns each entry to the specified
    argument, or `it` if none:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，使用单个参数将每个条目分配给指定的参数，或者如果没有指定，则分配给 `it`：
- en: '[PRE36]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Because a single dummy argument was used in the closure, I need to access its
    `key` and `value` properties (equivalent to invoking the `getKey` and `getValue`
    methods, as usual) to do the same operation as in the previous example.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 因为闭包中使用了单个虚拟参数，所以我需要访问其 `key` 和 `value` 属性（相当于通常调用 `getKey` 和 `getValue` 方法）来执行与上一个示例相同的操作。
- en: 'Both mechanisms produce the same results:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 两种机制产生相同的结果：
- en: '[PRE37]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Throughout this section I’ve used closures in examples without defining what
    they are. That’s the subject of the next section.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我在示例中使用了闭包，但没有定义它们是什么。这是下一节的主题。
- en: B.5\. Closures
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.5. 闭包
- en: Like many developers, I started out in the procedural world. I started my career
    as a research scientist, studying unsteady aerodynamics and acoustics. Most of
    that involved numerically solving partial differential equations.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 和许多开发者一样，我最初是从过程式世界开始的。我以研究科学家的身份开始了我的职业生涯，研究不稳定的空气动力学和声学。大部分工作都涉及数值求解偏微分方程。
- en: 'That meant that unless I wanted to write all my own libraries, I had to adopt
    Fortran as my professional language of choice.^([[11](#app02fn11)]) My first assignment
    in my first job was to take a 3000-line program my boss had written in Fortran
    IV^([[12](#app02fn12)]) and add functionality to it. The best part was that the
    original program had only two subroutines in it: one that was about 25 lines long,
    and the other 2975\. Needless to say, I learned refactoring long before I knew
    the actual term.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着除非我想编写自己的所有库，否则我必须选择Fortran作为我的首选专业语言。[^([11](#app02fn11))] 我在第一份工作中的第一个任务是取我老板用Fortran
    IV编写的3000行程序，并为其添加功能。最好的部分是原始程序中只有两个子程序：一个大约25行长，另一个2975行。不用说，我在知道实际术语之前就学会了重构。
- en: ^(11) The fact that I seriously considered writing those libraries in a different
    language anyway was yet another sign I was in the wrong profession.
  id: totrans-241
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([11]) 我认真考虑用不同的语言编写那些库的事实，是我处于错误职业的另一个迹象。
- en: ^(12) Shudder. Holy arithmetic-if statements, Batman. The nightmares have stopped,
    but it took a while.
  id: totrans-242
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([12]) 不寒而栗。哦，数学-if语句，蝙蝠侠。噩梦已经停止，但花了一些时间。
- en: I rapidly learned what at the time were considered good development practices,
    meaning that I wrote structured programs that used existing libraries as much
    as possible. It was only in the mid-90s, when I first learned Java, that I was
    introduced to object-oriented programming.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我迅速学会了当时被认为是良好的开发实践，这意味着我写了尽可能使用现有库的结构化程序。直到90年代中期，当我第一次学习Java时，我才接触到面向对象编程。
- en: That’s when I first encountered what influential blogger Steve Yegge has since
    referred to as the subjugation of verbs in the kingdom of the nouns.^([[13](#app02fn13)])
    In most OO languages, methods (verbs) can only exist as part of nouns (classes).
    Java certainly works that way. Even static methods that don’t require objects
    still have to be defined inside classes somewhere.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 那是我第一次遇到后来有影响力的博主Steve Yegge称之为名词王国中动词的屈服现象。[^([13](#app02fn13))] 在大多数面向对象的语言中，方法（动词）只能作为名词（类）的一部分存在。Java当然就是这样工作的。即使是那些不需要对象的静态方法，也必须定义在某个地方的类内部。
- en: ^(13) “Execution in the Kingdom of Nouns,” at [http://mng.bz/E4MB](http://mng.bz/E4MB)
  id: totrans-245
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([13]) “在名词王国的执行”，在 [http://mng.bz/E4MB](http://mng.bz/E4MB)
- en: The first language I learned that changed all that was JavaScript, which is
    an object-based language rather than object-oriented. In JavaScript, even the
    classes are functions. Then, because the methods in the classes are also functions,
    you wind up with functions operating inside of functions, possibly passing around
    references to still other functions, and suddenly everything gets confusing and
    difficult. Closures in JavaScript are confusing not because functions are difficult,
    but because a closure includes the environment in which it executes. A closure
    may have references to variables declared outside of it, and in JavaScript it’s
    easy to get lost determining the values.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种改变这一切的语言是JavaScript，它是一种基于对象的语言，而不是面向对象的语言。在JavaScript中，甚至类也是函数。然后，因为类中的方法也是函数，你最终会得到函数在函数内部运行，可能传递对其他函数的引用，突然之间一切变得混乱和困难。JavaScript中的闭包之所以令人困惑，并不是因为函数本身复杂，而是因为闭包包含了其执行的
    环境。闭包可能引用其外部声明的变量，在JavaScript中，确定这些值很容易迷失方向。
- en: I had no idea how simple closures could be until I encountered Groovy.^([[14](#app02fn14)])
    In Groovy, it’s easy enough to treat a closure as a block of code, but it’s always
    clear where the nonlocal variables are evaluated because there’s no confusion
    about the current object.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我直到遇到Groovy才知道闭包可以有多简单。[^([14](#app02fn14))] 在Groovy中，将闭包视为代码块很容易，但总是很清楚非局部变量在哪里被评估，因为没有关于当前对象的混淆。
- en: ^(14) Others can say the same about Ruby or other JVM languages. This is my
    history, though.
  id: totrans-248
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([14]) 其他人也可以说Ruby或其他JVM语言。这是我的历史。
- en: '|  |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Closures
  id: totrans-250
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 闭包
- en: In practice, a closure is a block of code along with its execution environment.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，闭包是一段代码及其执行环境。
- en: '|  |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'In Groovy, the term *closure* is used broadly to refer to blocks of code, even
    if they don’t contain explicit references to external variables. Closures feel
    like methods and can be invoked that way. Consider this trivial example, which
    returns whatever it’s sent:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在Groovy中，术语“闭包”被广泛用来指代代码块，即使它们不包含对外部变量的显式引用。闭包感觉像方法，可以那样调用。考虑这个简单的例子，它返回它所接收的任何内容：
- en: '[PRE38]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `echo` reference is assigned to the block of code (a closure) delimited
    by curly braces. The closure contains a variable whose default name is `it`, whose
    value is supplied when the closure is invoked. If you think of the variable like
    a method parameter, you’ve got the basic idea.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`echo` 引用被分配给由大括号分隔的代码块（闭包）。闭包包含一个默认名为 `it` 的变量，其值在闭包被调用时提供。如果你把变量想象成方法参数，你就抓住了基本概念。'
- en: 'The closure can be invoked in one of two ways: either by using the reference
    as though it’s a method call, or by explicitly invoking the `call` method on it.
    Because the last value computed by a closure is returned automatically, both ways
    return the argument to the closure, which is why it was called `echo` in the first
    place.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包可以通过两种方式之一被调用：要么像方法调用一样使用引用，要么通过显式调用其上的 `call` 方法。由于闭包计算出的最后一个值会自动返回，所以两种方式都返回闭包的参数，这也是为什么它最初被称为
    `echo` 的原因。
- en: '|  |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Closure Return Values
  id: totrans-258
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 闭包返回值
- en: The last evaluated expression in a closure is returned automatically.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包中最后评估的表达式会自动返回。
- en: '|  |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'If a closure takes more than one argument, or if you don’t want to use the
    default name, use an arrow to separate the dummy argument names from the body
    of the closure. Here’s a simple sum, once with the default and once with a named
    argument:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果闭包接受多个参数，或者你不想使用默认名称，请使用箭头将虚拟参数名称与闭包体分开。以下是一个简单的求和示例，一次使用默认名称，一次使用命名参数：
- en: '[PRE39]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Closures are used throughout this book and fill an entire chapter in *GinA*.
    This little amount of information is enough to make a lot of progress.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包在本书中被广泛使用，并在 *GinA* 中占据了一整章。这么一点信息就足以让你取得很大进步。
- en: Returning to the basic constructs of the language, I’ll now show how Groovy
    differs from Java when using loops and conditional tests.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 回到语言的基本结构，我现在将展示 Groovy 在使用循环和条件测试时与 Java 的不同之处。
- en: B.6\. Loops and conditionals
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.6. 循环和条件
- en: 'In this section, I’ll discuss two features that appear in any programming language:
    looping through a set of values and making decisions.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将讨论任何编程语言中都会出现的两个特性：遍历一组值和做出决策。
- en: B.6.1\. Loops
  id: totrans-267
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: B.6.1. 循环
- en: 'When Groovy was first created, and for some time afterward, it didn’t support
    the standard Java `for` loop:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Groovy 首次创建时，以及在此之后的一段时间内，它不支持标准的 Java `for` 循环：
- en: '[PRE40]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In version 1.6, however, the core committers decided that it was more important
    to support Java constructs than to try to keep the language free of that somewhat
    awkward syntax that Java inherited from its predecessors. Many demonstrations
    of Groovy start with a Java class, rename it with a `.groovy` extension, and show
    that it still compiles successfully with the Groovy compiler. The result is far
    from idiomatic Groovy, but it does illustrate a valid point: Groovy is the closest
    to Java of the new family of JVM languages.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 1.6 版本中，核心贡献者决定支持 Java 构造比尝试保持语言不受从其前辈那里继承的有些尴尬的语法更重要。许多 Groovy 的演示从 Java
    类开始，将其重命名为 `.groovy` 扩展名，并显示它仍然可以用 Groovy 编译器成功编译。结果是远非 Groovy 的典型用法，但它确实说明了有效观点：Groovy
    是 JVM 新家族语言中最接近 Java 的。
- en: '|  |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Java Loops
  id: totrans-272
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Java 循环
- en: Groovy supports the standard Java `for` loop and `for-each` loop, as well as
    the `while` loop. It does not, however, support the `do-while` construct.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy 支持标准的 Java `for` 循环和 `for-each` 循环，以及 `while` 循环。然而，它不支持 `do-while` 构造。
- en: '|  |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'The `for-each` loop in Java was introduced in Java SE 1.5 and works for any
    linear collection, including both arrays and lists:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: Java 中的 `for-each` 循环是在 Java SE 1.5 中引入的，适用于任何线性集合，包括数组和列表：
- en: '[PRE41]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `for-each` loop is helpful, because it means you don’t always need to get
    an iterator to loop over the elements of a list. The price you pay is that there’s
    no explicit index. Inside the loop, you know what element you’re currently on,
    but not where it appears in the list. If you need to know the index, you can either
    keep track of the index yourself or go back to the traditional `for` loop.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`for-each` 循环很有用，因为它意味着你不必总是获取迭代器来遍历列表的元素。你付出的代价是没有显式的索引。在循环内部，你知道当前在哪个元素上，但不知道它在列表中的位置。如果你需要知道索引，你可以自己跟踪索引，或者回到传统的
    `for` 循环。'
- en: 'Groovy supplies a variation on the `for-each` loop that avoids the colon syntax,
    called a `for-in` loop:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy 提供了一种对 `for-each` 循环的变体，避免了冒号语法，称为 `for-in` 循环：
- en: '[PRE42]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Note that unlike the `for-each` loop, the value variable is not declared to
    have a type: not even `def`.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与 `for-each` 循环不同，值变量没有被声明为具有类型：甚至不是 `def`。
- en: 'Still, none of those loops are the most common way of iterating in Groovy.
    Rather than write an explicit loop, as in the previous examples, Groovy prefers
    a more direct implementation of the Iterator design pattern. Groovy adds the `each`
    method, which takes a closure as an argument, to collections. The `each` method
    then applies the closure to each element of the collection:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，这些循环都不是Groovy中最常见的迭代方式。与前面的例子中显式编写循环不同，Groovy更喜欢直接实现迭代器设计模式。Groovy向集合添加了`each`方法，该方法接受一个闭包作为参数。然后`each`方法将闭包应用于集合的每个元素：
- en: '[PRE43]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Again, because the closure is the last argument of the method, it can be placed
    after the parentheses. Because there are no other arguments to the `each` method,
    the parentheses can be eliminated entirely.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，因为闭包是方法的最后一个参数，所以它可以放在括号之后。因为没有其他参数传递给`each`方法，所以可以完全省略括号。
- en: '|  |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Each
  id: totrans-285
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 每个
- en: The `each` method is the most common looping construct in Groovy.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`each`方法是Groovy中最常见的循环结构。'
- en: '|  |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The Iterator design pattern recommends separating the way you walk through the
    elements of a collection from what you plan to do with those elements. The `each`
    method does the iterating internally. The user determines what to do with the
    elements by supplying a closure, as shown. Here the closure prints its argument.
    The `each` method supplies each value in the range, one by one, to the closure,
    so the result is to print the numbers from zero to five.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器设计模式建议将遍历集合元素的方式与计划对这些元素做什么分开。`each`方法在内部执行迭代。用户通过提供闭包来确定如何处理元素，如所示。这里闭包打印其参数。`each`方法逐个将范围内的每个值提供给闭包，因此结果是打印从零到五的数字。
- en: 'Like the `for-in` loop, inside the closure you have access to each element,
    but not to the index. If you want the index, though, there’s an additional method
    available called `eachWithIndex`:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`for-in`循环一样，在闭包内部你可以访问每个元素，但不能访问索引。但是，如果你想得到索引，有一个额外的`eachWithIndex`方法可用：
- en: '[PRE44]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The closure supplied to the `eachWithIndex` method takes two dummy arguments.
    The first is the value from the collection, and the second is the index.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`eachWithIndex`方法的闭包接受两个虚拟参数。第一个是集合中的值，第二个是索引。
- en: I should mention that although all these loops work correctly, there can be
    differences in how much time each of them takes. If you’re dealing with a collection
    of a few dozen elements or less, the differences will probably not be noticeable.
    If the number of iterations is going to be in the tens of thousands or more, you
    probably should profile the resulting code.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我应该提到，尽管所有这些循环都工作正常，但它们在执行时间上可能会有所不同。如果你处理的是一个包含几十个元素或更少的集合，这些差异可能不会很明显。如果迭代的次数将达到数万次或更多，你可能应该对生成的代码进行性能分析。
- en: B.6.2\. Conditionals
  id: totrans-293
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: B.6.2\. 条件语句
- en: 'Java has two types of conditional statements: the `if` statement and its related
    constructs, like `if-else` and `switch` statements. Both are supported by Groovy.
    The `if` statement works pretty much the same way it does in Java. The `switch`
    statement, however, has been taken from Java’s crippled form and restored to its
    former glory.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: Java有两种类型的条件语句：`if`语句及其相关结构，如`if-else`和`switch`语句。两者都由Groovy支持。`if`语句的工作方式与Java中几乎相同。然而，`switch`语句是从Java的受损形式中提取出来的，并恢复到其以前的辉煌。
- en: Groovy’s version of the `if` statement is similar to Java’s, with the difference
    being the so-called Groovy Truth. In Java, the argument to an `if` statement must
    be a Boolean expression, or the statement won’t compile. In Groovy, lots of things
    evaluate to true other than Boolean expressions.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy的`if`语句版本与Java的类似，区别在于所谓的Groovy真理。在Java中，`if`语句的参数必须是布尔表达式，否则语句无法编译。在Groovy中，除了布尔表达式之外，许多东西都会评估为true。
- en: 'For example, nonzero numbers are true:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，非零数字是真实的：
- en: '[PRE45]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The result is `true`. This expression wouldn’t work in Java. There you would
    have to compare the argument to another value, resulting in a Boolean expression.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是`true`。这个表达式在Java中不起作用。在那里，你必须将参数与另一个值进行比较，从而产生布尔表达式。
- en: '|  |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Return to C?**'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '**回归C？**'
- en: The Groovy Truth is a case where Java restricted something C supported (non-Boolean
    expressions in decision statements), but Groovy brought it back. That can certainly
    lead to bugs that Java would avoid.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy 的真理是一个Java限制而C支持的情况（决策语句中的非布尔表达式），但Groovy将其恢复。这当然可能导致Java会避免的bug。
- en: From a philosophical point of view, why do it? By restricting what was allowed,
    Java made certain types of bugs much less likely. Groovy, by restoring those features,
    increases the possibility of those bugs again. Is the gain worth it?
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 从哲学的角度来看，为什么要这样做？通过限制允许的内容，Java 使得某些类型的错误发生的可能性大大降低。Groovy 通过恢复这些特性，再次增加了这些错误的可能性。这种收益是否值得？
- en: My opinion is that this is a side effect of the increased emphasis on testing
    that has swept through the development community. If you’re going to have to write
    tests to prove your code is correct anyway, why not take advantage of the greater
    power? Sure, you’ve introduced the possibility of getting some bugs past the compiler,
    but just because it compiles doesn’t mean it’s right. The tests prove correctness,
    so why not use shorter, more powerful code when you can?
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这是开发社区中测试重要性增加的副作用。如果你必须编写测试来证明你的代码是正确的，为什么不利用这种更大的能力呢？当然，你引入了编译器可能无法捕捉到一些错误的可能性，但仅仅因为编译成功并不意味着它是正确的。测试证明了正确性，所以为什么不在可能的情况下使用更短、更强大的代码呢？
- en: '|  |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Returning to decision statements, Java also supports a ternary operator, and
    Groovy does the same:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 回到决策语句，Java 也支持三元操作符，Groovy 也是如此：
- en: '[PRE46]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The ternary expression reads, is five greater than three? If so, assign the
    result to `x`, otherwise use `y`. It’s like an `if` statement, but shorter.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 三元表达式读作：五是否大于三？如果是，将结果分配给 `x`，否则使用 `y`。它就像一个 `if` 语句，但更短。
- en: 'There’s a reduced form of the ternary operator that highlights both Groovy’s
    helpfulness and its sense of humor: the Elvis operator.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 三元操作符的简化形式突出了 Groovy 的有用性和幽默感：Elvis 操作符。
- en: B.6.3\. Elvis
  id: totrans-309
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: B.6.3\. Elvis
- en: Consider the following use case. You’re planning to use an input value, but
    it’s optional. If the client supplies it, you’ll use it. If not, you plan to use
    a default instead.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下用例。你计划使用一个输入值，但它不是必需的。如果客户端提供了它，你将使用它。如果没有，你计划使用默认值。
- en: 'I’ll use a variable called `name` as an example:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我将以一个名为 `name` 的变量为例：
- en: '[PRE47]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This means if `name` is not null, use it for `displayName`. Otherwise, use a
    default. I’m using a standard ternary operator to check whether `name` is null
    or not. The way this is written has some repetition in it. After all, I want to
    use `name` if it’s available, so why do I have to repeat myself?
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果 `name` 不为 null，则使用它作为 `displayName`。否则，使用默认值。我正在使用标准的三元操作符来检查 `name`
    是否为 null。这种写法有一些重复。毕竟，如果 `name` 可用，我想使用它，为什么我还要重复自己呢？
- en: 'That’s where the Elvis operator comes in. Here’s the revised code:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 Elvis 操作符发挥作用的地方。以下是修改后的代码：
- en: '[PRE48]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The Elvis operator is the combination of a question mark and a colon formed
    by leaving out the value in between them in the ternary operator. The idea is
    that if the variable in front of the question mark is not null, use it. The `?:`
    operator is called Elvis because if you turn your head to the side, the result
    looks vaguely like the King:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: Elvis 操作符是三元操作符中省略中间值形成的一个问号和冒号的组合。理念是如果问号前面的变量不为 null，则使用它。`?:` 操作符被称为 Elvis，因为如果你侧过头来看，结果看起来有点像国王：
- en: '[PRE49]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `greet` method takes a parameter called `name` and uses the Elvis operator
    to determine what to return. This way it still has a reasonable value, even if
    the input argument is null.^([[15](#app02fn15)])
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`greet` 方法接受一个名为 `name` 的参数，并使用 Elvis 操作符来确定要返回的内容。这样即使输入参数为 null，它仍然有一个合理的值。^([[15](#app02fn15)])'
- en: ^(15) Thank you, thank you very much.
  id: totrans-319
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(15) 非常感谢，非常感谢。
- en: B.6.4\. Safe de-reference
  id: totrans-320
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: B.6.4\. Safe de-reference
- en: There’s one final conditional operator that Groovy provides that saves many
    lines of coding. It’s called the safe de-reference operator, written as `?.`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy 提供了一个可以节省许多代码行的最终条件操作符，它被称为安全解引用操作符，写作 `?.`。
- en: 'The idea is to avoid having to constantly check for nulls. For example, suppose
    you have classes called `Employee`, `Department`, and `Location`. If each employee
    instance has a department, and each department has a location, then if you want
    the location for an employee, you would write something like this (in Java):'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是避免不断检查 null 值。例如，假设你有名为 `Employee`、`Department` 和 `Location` 的类。如果每个员工实例都有一个部门，每个部门都有一个位置，那么如果你想为员工获取位置，你将编写如下代码（在
    Java 中）：
- en: '[PRE50]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: But what happens if the employee reference is null? Or what happens if the employee
    hasn’t been assigned a department, so the `getDepartment` method returns `null`?
    Those possibilities mean the code expands to
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果员工引用为 null 呢？或者如果员工尚未分配部门，`getDepartment` 方法返回 `null` 呢？这些可能性意味着代码会扩展为
- en: '[PRE51]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'That’s quite an expansion just to check for nulls. Here’s the Groovy version:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 仅为了检查空值就进行了如此大的扩展。以下是Groovy版本：
- en: '[PRE52]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The safe de-reference operator returns `null` if the reference is null. Otherwise
    it proceeds to access the property. It’s a small thing, but the savings in lines
    of code is nontrivial.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 安全解引用操作符如果引用为null则返回`null`。否则，它将继续访问属性。这是一件小事，但节省的代码行数却非同小可。
- en: Continuing on the theme of simplifying code over the Java version, consider
    input/output streams. Groovy introduces several methods in the Groovy JDK that
    help Groovy simplify Java code when dealing with files and directories.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在简化代码的主题上继续，考虑输入/输出流。Groovy在Groovy JDK中引入了几个方法，帮助Groovy在处理文件和目录时简化Java代码。
- en: B.7\. File I/O
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.7\. 文件输入/输出
- en: File I/O in Groovy isn’t fundamentally different from the Java approach. Groovy
    adds several convenience methods and handles issues like closing your files for
    you. A few short examples should suffice to give you a sense of what’s possible.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy中的文件I/O在本质上与Java方法没有区别。Groovy添加了几个便利方法，并处理了像为你关闭文件这样的问题。几个简短的例子就足以让你了解可能实现的内容。
- en: 'First, Groovy adds a `getText` method to `File`, which means that by asking
    for the text property you can retrieve all the data out of a file at once in the
    form of a string:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Groovy向`File`类添加了一个`getText`方法，这意味着通过请求文本属性，你可以一次性以字符串的形式检索文件中的所有数据：
- en: '[PRE53]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Accessing the `text` property invokes the `getText` method, as usual, and returns
    all the text in the file. Alternatively, you can retrieve all the lines in the
    file and store them in a list using the `readLines` method:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 访问`text`属性会调用`getText`方法，就像通常一样，并返回文件中的所有文本。或者，你可以使用`readLines`方法检索文件中的所有行并将它们存储在一个列表中：
- en: '[PRE54]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The `trim` method is used in this example with the spread-dot operator to remove
    leading and trailing spaces on each line. If your data is formatted in a specific
    way, the `splitEachLine` method takes a delimiter and returns a list of the elements.
    For example, if you have a data file that contains the following lines
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`trim`方法与扩展点操作符一起使用，用于删除每行的前导和尾随空格。如果你的数据以特定方式格式化，`splitEachLine`方法接受一个分隔符并返回一个元素列表。例如，如果你有一个包含以下行的数据文件
- en: '[PRE55]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'then the data can be retrieved and parsed at the same time:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 那么数据可以同时检索和解析：
- en: '[PRE56]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Writing to a file is just as easy:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 向文件写入同样简单：
- en: '[PRE57]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In Java, it’s critical to close a file if you’ve written to it, because otherwise
    it may not flush the buffer and your data may never make into the file. Groovy
    does that for you automatically.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，如果你已经向文件写入，关闭文件是至关重要的，因为否则它可能不会刷新缓冲区，你的数据可能永远无法进入文件。Groovy会自动为你处理这个问题。
- en: 'Groovy also makes it easy to append to a file:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy还使得向文件追加内容变得非常简单：
- en: '[PRE58]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `append` method does what it sounds like, and the left-shift operator has
    been overridden to do the same.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '`append`方法做的是它听起来像的事情，左移操作符也被重载以执行相同的操作。'
- en: Several methods are available that iterate over files, like `eachFile`, `eachDir`,
    and even `eachFileRecurse`. They each take closures that can filter what you want.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以遍历文件，如`eachFile`、`eachDir`，甚至`eachFileRecurse`。它们各自接受闭包以过滤你想要的内容。
- en: 'Finally, I have to show you an example that illustrates how much simpler Groovy
    I/O streams are than Java streams. Consider writing a trivial application that
    does the following:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我必须给你举一个例子，说明Groovy的I/O流比Java流简单得多。考虑编写一个简单的应用程序，它执行以下操作：
- en: '**1**.  Prompts the user to enter numbers on a line, separated by spaces'
  id: totrans-348
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 提示用户在一行中输入数字，数字之间用空格分隔'
- en: '**2**.  Reads the line'
  id: totrans-349
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 读取行'
- en: '**3**.  Adds up the numbers'
  id: totrans-350
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. 计算数字总和'
- en: '**4**.  Prints the result'
  id: totrans-351
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**. 打印结果'
- en: Nothing to it, right? The next listing shows the Java version.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 没什么特别的，对吧？下一个列表显示了Java版本。
- en: Listing B.4\. `SumNumbers.java`, an application to read a line of numbers and
    add them
  id: totrans-353
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表B.4\. `SumNumbers.java`，一个读取一行数字并求和的应用程序
- en: '![](316fig01_alt.jpg)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![](316fig01_alt.jpg)'
- en: That’s nearly 30 lines to do something extremely simple. All Java code has to
    be in a class with a `main` method. The input stream `System.in` is available,
    but I want to read a full line of data, so I wrap the stream in an `InputStreamReader`
    and wrap that in a `BufferedReader`, all so I can call `readLine`. That may throw
    an I/O exception, so I need a `try`/`catch` block for it. Finally, the incoming
    data is in string form, so I need to parse it before adding up the numbers and
    printing the results.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 仅用30行代码就完成了极其简单的事情。所有Java代码都必须在一个包含`main`方法的类中。输入流`System.in`是可用的，但我想读取一整行数据，所以我将流包装在`InputStreamReader`中，然后再将其包装在`BufferedReader`中，这样我就可以调用`readLine`方法。这可能会抛出I/O异常，所以我需要为它提供一个`try`/`catch`块。最后，传入的数据是字符串形式，所以在将数字相加并打印结果之前，我需要解析它。
- en: 'Here’s the corresponding Groovy version:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是相应的Groovy版本：
- en: '[PRE59]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: That’s the whole program. The `withReader` method creates a `Reader` implementation
    that has a `readLine` method and automatically closes it when the closure completes.
    Several similar methods are available for both input and output, including `withReader`,
    `withInputStream`, `withPrintWriter`, and `withWriterAppend`.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是整个程序。`withReader`方法创建了一个具有`readLine`方法的`Reader`实现，并在闭包完成后自动关闭它。对于输入和输出，都有几个类似的方法可用，包括`withReader`、`withInputStream`、`withPrintWriter`和`withWriterAppend`。
- en: 'That was fun, but here’s another version that has more capabilities. In this
    case, the code has a loop that sums each line and prints its result until no input
    is given:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 那很有趣，但这里还有一个功能更强大的版本。在这种情况下，代码中有一个循环，它会累加每一行的值并打印出结果，直到没有输入为止：
- en: '[PRE60]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The `eachLine` method repeats the closure until the line variable is empty.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '`eachLine`方法会重复执行闭包，直到行变量为空。'
- en: Groovy’s contribution to file I/O is to add convenience methods that simplify
    the Java API and ensure that streams or files are closed correctly. It provides
    a clean façade on the Java I/O package.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy对文件I/O的贡献是添加了一些便利方法，这些方法简化了Java API并确保流或文件被正确关闭。它为Java I/O包提供了一个干净的界面。
- en: Groovy makes input/output streams much simpler to deal with than in Java, so
    if I have a Java system and I need to work with files, I try to add a Groovy module
    for that purpose. That’s a savings, but nothing compared to the savings that result
    from using Groovy over Java when dealing with XML, as shown in the next section.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy使得输入/输出流比Java中更容易处理，所以如果我在一个Java系统中工作并且需要处理文件，我会尝试添加一个Groovy模块来达到这个目的。这是一个节省，但与在处理XML时使用Groovy而不是Java所带来的节省相比，这微不足道。在下一节中，我们将展示这一点。
- en: B.8\. XML
  id: totrans-364
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.8\. XML
- en: I’ve saved the best for last. XML is where the ease-of-use gap between Groovy
    and Java is the largest. Working with XML in Java is a pain at best, while parsing
    and generating XML in Groovy is almost trivial. If I ever have to deal with XML
    in a Java system, I always add a Groovy module for that purpose. This section
    is intended to show why.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 我把最好的留到了最后。XML是Groovy和Java之间易用性差距最大的地方。在Java中处理XML最多是痛苦的，而在Groovy中解析和生成XML几乎是微不足道的。如果我在Java系统中必须处理XML，我总是会添加一个Groovy模块来达到这个目的。本节旨在展示原因。
- en: B.8.1\. Parsing and slurping XML
  id: totrans-366
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: B.8.1\. 解析和读取XML
- en: 'Some time ago, I was teaching a training course on XML and Java. One of the
    exercises started by presenting an XML file similar to this one:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 很久以前，我教了一个关于XML和Java的培训课程。其中一个练习是从展示一个类似于这个的XML文件开始的：
- en: '[PRE61]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The goal of the exercise was to parse this file and print out the title of
    the second book. Because this file is small, you might as well use a DOM parser
    to read it. To do that in Java you need a factory, which then yields the parser,
    and then you can invoke a `parse` method to build the DOM tree. Then, to extract
    the data, there are three options:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习的目标是解析这个文件并打印出第二本书的标题。因为这个文件很小，你可以使用DOM解析器来读取它。在Java中这样做，你需要一个工厂，然后它会产生解析器，然后你可以调用`parse`方法来构建DOM树。然后，为了提取数据，有三个选项：
- en: Walk the tree by getting child elements and iterating over them.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过获取子元素并遍历它们来遍历树。
- en: Use the `getElementById` method to find the right node, and then get the first
    text child and retrieve its value.
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`getElementById`方法找到正确的节点，然后获取第一个文本子节点并检索其值。
- en: Use the `getElementsByTagName` method, iterate over the resulting `NodeList`
    to find the right node, and then retrieve the value of the first text child.
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`getElementsByTagName`方法，遍历结果`NodeList`以找到正确的节点，然后检索第一个文本子节点的值。
- en: The first approach runs into problems with whitespace. This document has carriage
    returns and tabs in it, and because no DTD or schema is provided, the parser doesn’t
    know which whitespace elements are significant. Traversing the DOM is complicated
    by the fact that methods like `getFirstChild` will return whitespace nodes as
    well as elements. It can be done, but you’ll need to check the node type of each
    element to make sure you are working with an element rather than a text node.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法会遇到空白字符的问题。这份文档包含回车符和制表符，因为没有提供 DTD 或模式，解析器不知道哪些空白字符是重要的。由于 `getFirstChild`
    等方法会返回空白节点以及元素，遍历 DOM 变得复杂。这是可以做到的，但你将需要检查每个元素的节点类型，以确保你正在处理元素而不是文本节点。
- en: The second approach only works if the elements have an attribute of type `ID`,
    and that’s not the case here.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法仅在元素具有类型为 `ID` 的属性时才有效，但这里不是这种情况。
- en: 'You’re left with the `getElementsByTagName` method, which results in the following
    code:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用 `getElementsByTagName` 方法，这将导致以下代码：
- en: '[PRE62]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Parsing the document can throw all sorts of exceptions, as shown. Assuming nothing
    goes wrong, after parsing, the code retrieves all the `title` elements. After
    getting the proper element out of the `NodeList` and casting it to type `Element`,
    you then have to remember that the character data in the element is in the first
    text child of the element rather than the element itself.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 解析文档可能会抛出各种异常，如所示。假设没有出错，解析后，代码检索所有 `title` 元素。在从 `NodeList` 中获取适当的元素并将其转换为
    `Element` 类型后，你必须记住元素中的字符数据位于元素的第一个文本子节点中，而不是元素本身。
- en: 'Here’s the Groovy solution:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 Groovy 的解决方案：
- en: '[PRE63]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Wow. Groovy includes the `XmlSlurper` class, which is in the `groovy.util` package
    (no import required). `XmlSlurper` has a `parse` method that builds the DOM tree
    and returns the root element. Then it’s a question of walking the tree, using
    the dot notation for child elements. Elements that appear multiple times form
    a collection that can be accessed with an index in the normal way. The contrast
    in both size and complexity between the Groovy version and the Java version is
    clear.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 哇。Groovy 包含了 `XmlSlurper` 类，该类位于 `groovy.util` 包中（无需导入）。`XmlSlurper` 有一个 `parse`
    方法，它构建 DOM 树并返回根元素。然后就是遍历树，使用点表示法来表示子元素。元素多次出现形成一个集合，可以通过索引以正常方式访问。Groovy 版本和
    Java 版本在大小和复杂性方面的对比是明显的。
- en: The next listing demonstrates working with the XML file.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表演示了如何处理 XML 文件。
- en: Listing B.5\. Slurping XML
  id: totrans-382
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 B.5\. 吞噬 XML
- en: '[PRE64]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Groovy uses two different classes for working with XML. The previous example
    used an `XmlSlurper`. Groovy also includes an `XmlParser`. The `XmlParser` creates
    a tree of `Node` instances, so if you need to approach the file from a node point
    of view, use the parser. The result is that you’ll need to invoke a `text` method
    on each node to retrieve the text data, but otherwise the two approaches are virtually
    the same.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy 使用两个不同的类来处理 XML。上一个例子使用了 `XmlSlurper`。Groovy 还包括一个 `XmlParser`。`XmlParser`
    创建一个 `Node` 实例的树，所以如果你需要从节点角度接近文件，请使用解析器。结果是，你需要在每个节点上调用 `text` 方法来检索文本数据，但除此之外，两种方法几乎相同。
- en: Parsing XML is therefore quite easy. What about generating XML? That’s the subject
    of the next subsection.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 解析 XML 因此相当简单。那么生成 XML 呢？这是下一小节的主题。
- en: B.8.2\. Generating XML
  id: totrans-386
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: B.8.2\. 生成 XML
- en: So far, most of the Groovy capabilities presented are similar to what Java can
    do, just simpler or easier. In this section I’ll show a Groovy builder, which
    uses Groovy’s metaprogramming to go beyond what Java can do.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，Groovy 展示的大多数功能与 Java 可以做到的类似，只是更简单或更容易。在本节中，我将展示一个 Groovy 构建器，它使用 Groovy
    的元编程来超越 Java 可以做到的。
- en: To generate XML, Groovy provides a class called `groovy.xml.MarkupBuilder`.
    You use a `MarkupBuilder` by invoking methods that don’t exist, and the builder
    interprets them by generating XML elements and attributes.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成 XML，Groovy 提供了一个名为 `groovy.xml.MarkupBuilder` 的类。你通过调用不存在的方法来使用 `MarkupBuilder`，构建器通过生成
    XML 元素和属性来解释它们。
- en: That sounds strange, but is simple in practice. The next listing shows an example.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来很奇怪，但在实践中很简单。接下来的列表显示了示例。
- en: Listing B.6\. Generating XML using a `MarkupBuilder`
  id: totrans-390
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 B.6\. 使用 `MarkupBuilder` 生成 XML
- en: '[PRE65]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: After instantiating the `MarkupBuidler` I invoke the `department` method on
    it, omitting the optional parentheses. There’s no `department` method on `MarkupBuilder`,
    so what does Groovy do?
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在实例化 `MarkupBuidler` 后，我在它上面调用了 `department` 方法，省略了可选的括号。`MarkupBuilder` 上没有
    `department` 方法，那么 Groovy 会做什么呢？
- en: If this was Java, I would fail with something like a `MissingMethodException`.
    Every class in Groovy has an associated `meta` class, however, and the `meta`
    class has a method called `methodMissing`. The `meta` class is the key to Groovy’s
    code generation capabilities. When the `methodMissing` method in `MarkupBuilder`
    is called, the implementation ultimately is to generate an XML element with the
    method name as the element name.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是Java，我会因为`MissingMethodException`而失败。然而，每个Groovy类都有一个相关的`meta`类，而`meta`类有一个名为`methodMissing`的方法。`meta`类是Groovy代码生成能力的关键。当`MarkupBuilder`中的`methodMissing`方法被调用时，其实施最终是生成一个以方法名作为元素名的XML元素。
- en: The braces that follow are interpreted to mean a child element is next. The
    name of the child element will be `deptName`, and its character data will be the
    supplied string. The next element is an `employee`, and the map-like syntax for
    the `id` implies an attribute on the employee element is needed, and so on.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的花括号表示下一个子元素。子元素的名称将是`deptName`，其字符数据将是提供的字符串。下一个元素是`employee`，`id`的映射语法暗示在员工元素上需要一个属性，依此类推。
- en: The result of executing this script is
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此脚本的结果是
- en: '[PRE66]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The `MarkupBuilder` generates the XML. It’s hard to imagine a simpler way to
    solve that problem.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '`MarkupBuilder`生成XML。很难想象有比这更简单的方法来解决该问题。'
- en: I want to illustrate one final aspect of XML processing with Groovy, which involves
    validating a document.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 我想用Groovy演示XML处理的一个最终方面，这涉及到验证一个文档。
- en: B.8.3\. Validation
  id: totrans-399
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: B.8.3\. 验证
- en: 'XML documents are validated in one of two ways: through either a Document Type
    Definition (DTD) or an XML schema. The DTD system is older, simpler, and much
    less useful, but the Java parsers have been able to validate against them almost
    from the beginning. Schema validation came much later but is far more important,
    especially when dealing with, for example, web services.'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: XML文档可以通过两种方式之一进行验证：通过文档类型定义（DTD）或XML架构。DTD系统较老，较简单，但不太有用，但Java解析器几乎从一开始就能对它们进行验证。架构验证来得较晚，但更为重要，尤其是在处理，例如，网络服务时。
- en: Validating XML with Groovy is an interesting demonstration both of what Groovy
    provides, and what to do if Groovy doesn’t provide anything.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Groovy验证XML是一个有趣的演示，展示了Groovy提供了什么，以及如果Groovy没有提供任何东西时应该怎么做。
- en: 'First, consider validation against a DTD. Here’s a DTD for the library XML
    shown earlier:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，考虑对DTD的验证。这是前面显示的图书馆XML的DTD：
- en: '[PRE67]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The idea is that a `library` element contains one or more `book`s. A `book`
    element contains a `title`, one or more `author` elements, and a `price`, in that
    order. The `book` element has an attribute called `isbn`, which is a simple string
    but is required. The `title`, `author`, and `price` elements all consist of simple
    strings.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 想法是`library`元素包含一个或多个`book`元素。`book`元素包含一个`title`，一个或多个`author`元素，以及一个`price`，顺序如下。`book`元素有一个名为`isbn`的属性，它是一个简单的字符串，但必需。`title`、`author`和`price`元素都由简单的字符串组成。
- en: 'To tie the XML file to the DTD, I add the following line before the root element:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将XML文件与DTD关联起来，我在根元素之前添加以下行：
- en: '[PRE68]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Validating the XML file against the DTD is then almost trivial. The `XmlSlurper`
    class has an overloaded constructor that takes two arguments, both of which are
    Booleans. The first is to trigger validation, and the second is namespace awareness.
    Namespaces aren’t relevant when discussing a DTD, but it doesn’t hurt to turn
    on both properties:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 将XML文件与DTD进行验证几乎是微不足道的。`XmlSlurper`类有一个重载的构造函数，它接受两个参数，都是布尔值。第一个参数用于触发验证，第二个参数用于命名空间感知。在讨论DTD时，命名空间并不相关，但开启这两个属性也无妨：
- en: '[PRE69]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: That’s all that’s needed to do the validation. If the XML data doesn’t satisfy
    the DTD, errors will be reported by the parsing process.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是进行验证所需的所有内容。如果XML数据不满足DTD，解析过程将报告错误。
- en: Validation against an XML schema has always been more of a challenge. Schemas
    understand namespaces and namespace prefixes, and there are many things you can
    do in a schema that you can’t do in a DTD.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 与XML架构的验证一直是一个更大的挑战。架构理解命名空间和命名空间前缀，并且在架构中你可以做很多在DTD中不能做的事情。
- en: Consider the next listing, which shows a schema for the library.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑下面的列表，它展示了图书馆的架构。
- en: Listing B.7\. An XML schema for the library XML
  id: totrans-412
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表B.7\. 图书馆XML的XML架构
- en: '[PRE70]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'This is the same as the DTD, except that it says that price elements have two
    decimal places, and `isbn` attributes are composed of either 10 or 13 decimal
    digits. Tying the XML document to this schema can be done by modifying the root
    element as follows:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 这与DTD相同，只是它指出价格元素有两位小数，而`isbn`属性由10或13位十进制数字组成。通过修改根元素如下，可以将XML文档绑定到这个模式：
- en: '[PRE71]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The rest of the `library` is the same as before. Here’s the code used to validate
    the XML document against the schema:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '`library`的其余部分与之前相同。以下是用于验证XML文档与模式的代码：'
- en: '[PRE72]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'This looks relatively simple, but here’s the interesting part: the mechanism
    used is Java. If I was to write this code in Java, it would look almost identical.
    Unlike the `XmlSlurper` used for DTD validation, Groovy doesn’t add anything special
    to do schema validation. So you fall back on the Java approach and write it in
    Groovy. Because Groovy didn’t add anything, these lines could be written in either
    language, depending on your needs.'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来相对简单，但有趣的部分是：所使用的机制是Java。如果我要用Java编写这段代码，它看起来几乎相同。与用于DTD验证的`XmlSlurper`不同，Groovy没有添加任何特殊的功能来进行模式验证。因此，你将回退到Java方法并在Groovy中编写它。因为Groovy没有添加任何东西，这些行可以根据你的需要用任何一种语言编写。
- en: Still, Groovy normally does help, as most of the code in this appendix shows.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，Groovy通常还是有所帮助的，正如本附录中的大部分代码所示。
- en: Whenever the issue of XML comes up these days, someone always asks about JSON
    support. I’ll address that issue in the next section.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当提到XML时，总有人询问关于JSON支持的问题。我将在下一节中解决这个问题。
- en: B.9\. JSON support
  id: totrans-421
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.9. JSON支持
- en: The trend in the industry has been away from XML and toward JavaScript Object
    Notation, known as JSON. If your client is written in JavaScript, JSON is a natural,
    because JSON objects are native to the language. Java doesn’t include a JSON parser,
    but several good libraries are available.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 行业趋势已经从XML转向JavaScript对象表示法（JSON）。如果你的客户端是用JavaScript编写的，JSON是自然的，因为JSON对象是语言的原生部分。Java不包含JSON解析器，但有几个好的库可用。
- en: As of Groovy 1.8, Groovy includes a `groovy.json` package, which includes a
    JSON slurper and a JSON builder.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 截至1.8版本的Groovy，Groovy包括一个`groovy.json`包，其中包含一个JSON解析器和JSON构建器。
- en: B.9.1\. Slurping JSON
  id: totrans-424
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: B.9.1. 吞噬JSON
- en: The `groovy.json` package includes a class called `JsonSlurper`. This class
    is not quite as versatile as the `XmlSlurper` class because it has fewer methods.
    It contains a `parse` method that takes a `Reader` as an argument, as well as
    a `parseText` method that takes a `String`.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '`groovy.json` 包含一个名为`JsonSlurper`的类。这个类并不像`XmlSlurper`类那样多功能，因为它有更少的方法。它包含一个`parse`方法，该方法接受一个`Reader`作为参数，以及一个`parseText`方法，该方法接受一个`String`。'
- en: 'A JSON object looks like a map inside curly braces. Parsing it results in a
    map in Groovy:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 一个JSON对象看起来就像花括号内的一个映射。解析它会在Groovy中产生一个映射：
- en: '[PRE73]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Instantiate the slurper and call its `parseText` method, and the result is
    a map that can be accessed in the usual way, as shown. Lists work as well:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化解析器并调用其`parseText`方法，结果是一个可以按常规方式访问的映射，如下所示。列表也可以工作：
- en: '[PRE74]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The two children wind up in an instance of `ArrayList`. You can also add numbers
    and even contained objects:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个子元素最终会出现在一个`ArrayList`实例中。你还可以添加数字，甚至包含的对象：
- en: '[PRE75]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The `age` becomes an integer. The `address` object is also parsed into a map,
    whose properties are also available in the standard way. Here, by the way, I used
    the `with` method, which prepends whatever value it’s invoked on to the contained
    expressions. `wife` is short for `result.wife`, and so on.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '`age` 变成了整数。`address` 对象也被解析成一个映射，其属性也可以按照标准方式访问。顺便说一句，我使用了`with`方法，它会将调用它的任何值添加到包含的表达式之前。`wife`
    是 `result.wife` 的简称，以此类推。'
- en: If parsing is easy, building is also a simple operation, much like using `MarkupBuilder`.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 如果解析简单，构建也是一个简单的操作，就像使用`MarkupBuilder`一样。
- en: B.9.2\. Building JSON
  id: totrans-434
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: B.9.2. 构建JSON
- en: I discussed builders earlier, and I use them throughout the book. In various
    chapters I use `MarkupBuilder` (shown in this chapter), `SwingBuilder`, and `AntBuilder`.
    Here I’ll illustrate the builder for generating JSON, called `JsonBuilder`.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前讨论了构建器，并在整本书中使用它们。在各个章节中，我使用了`MarkupBuilder`（在本章中展示）、`SwingBuilder`和`AntBuilder`。在这里，我将展示用于生成JSON的构建器，称为`JsonBuilder`。
- en: 'The `JsonBuilder` class can be used with lists, maps, or methods. For example,
    here’s a trivial list:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '`JsonBuilder`类可以与列表、映射或方法一起使用。例如，这里有一个简单的列表：'
- en: '[PRE76]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'This builder takes a list of numbers as an argument and builds a JSON object
    containing them. Here’s an example of using a map:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 这个构建器接受一个数字列表作为参数，并构建一个包含这些数字的JSON对象。这里是一个使用映射的示例：
- en: '[PRE77]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The result is a standard JSON object (contained in braces), whose properties
    are the strings provided in the builder.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个标准的 JSON 对象（包含在大括号中），其属性是构建器中提供的字符串。
- en: 'In the builder syntax you can use parentheses to build a contained object,
    so let’s continue on with the example:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建器语法中，您可以使用括号来构建一个包含的对象，所以让我们继续使用示例：
- en: '[PRE78]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The generated JSON can get difficult to read, so the class adds a `toPrettyString`()
    method:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 JSON 可能难以阅读，因此该类添加了一个 `toPrettyString()` 方法：
- en: '[PRE79]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'This results in nicely formatted output, as shown:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生格式良好的输出，如下所示：
- en: '[PRE80]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: JSON data is therefore almost as easy to manage as XML, both when creating it
    and when managing it.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，JSON 数据在创建和管理时几乎与 XML 一样容易处理。
