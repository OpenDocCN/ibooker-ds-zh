- en: 14 Completing a real project
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14 完成真实项目
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节涵盖了
- en: Setting up virtual environments
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置虚拟环境
- en: Building data models
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建数据模型
- en: Working with a local database
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与本地数据库一起工作
- en: Building a web app
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个Web应用
- en: Chapters 2-12 focused on individual techniques, with considerable cross-referencing
    of pertinent techniques. When I introduced built-in data types (chapters 2-5),
    for example, we created functions to perform some repeated work. When I discussed
    functions (chapters 6 and 7) and classes (chapters 8 and 9), we used built-in
    data types. From examples in the context of the task management app, you’ve seen
    that these techniques depend on one another to solve realistic problems. Solving
    these isolated problems is fun in the sense of learning pertinent techniques.
    The ultimate purpose of learning these individual techniques, however, is to use
    them collectively to complete a real project from beginning to end.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 第2章至第12章专注于单个技术，并对相关技术进行了大量交叉引用。例如，当我介绍内置数据类型（第2章至第5章）时，我们创建了函数来执行一些重复工作。当我讨论函数（第6章和第7章）和类（第8章和第9章）时，我们使用了内置数据类型。从任务管理应用的环境中的例子，你已经看到这些技术相互依赖以解决实际问题。在学习的意义上，解决这些孤立的问题很有趣。然而，学习这些单个技术的最终目的是将它们共同使用，以从头到尾完成一个真实的项目。
- en: In this chapter, we’re going to complete the task management app project (section
    1.4.3) from the beginning, creating a virtual environment (section 14.1), defining
    the proper data models (section 14.2), using the backend database (section 14.3),
    implementing the frontend app (section 14.4), and publishing our package for distribution
    (appendix E online). As an important note, although we’re going to learn a few
    new techniques, such as using a local database, we’ll focus on synthesizing the
    techniques that we learned in chapters 2-12.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从头开始完成任务管理应用项目（1.4.3节），创建虚拟环境（14.1节），定义适当的数据模型（14.2节），使用后端数据库（14.3节），实现前端应用（14.4节），并发布我们的包以供分发（附录E在线）。作为一个重要的注意事项，尽管我们将学习一些新技术，例如使用本地数据库，但我们将会专注于综合我们在第2章至第12章中学到的技术。
- en: 14.1 How do I use a virtual environment for my project?
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.1 我如何为我的项目使用虚拟环境？
- en: As mentioned in chapter 1 (section 1.2), we have many choices of open source
    Python packages to use in our project. We can install third-party packages with
    Python’s package installer pip (see appendix B online), which is a command-line
    tool that allows you to install and uninstall Python packages with one line of
    command.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如第1章（1.2节）所述，我们在项目中有很多选择使用开源Python包。我们可以使用Python的包安装器pip（参见附录B在线）安装第三方包，这是一个命令行工具，允许你通过一行命令安装和卸载Python包。
- en: By default, these packages are installed at the system level, which means that
    all your projects must share these packages. Different projects, however, may
    require distinct versions of the packages, and you can’t reconcile these conflicts
    easily if the systemwide packages that your projects share are in different versions
    than the ones required by your project. In this section, I’ll show you how to
    reconcile this dilemma by using virtual environments.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，这些包是在系统级别安装的，这意味着所有你的项目都必须共享这些包。然而，不同的项目可能需要不同版本的包，如果共享的系统级包与项目所需版本不同，那么解决这些冲突并不容易。在本节中，我将向你展示如何通过使用虚拟环境来解决这个困境。
- en: 14.1.1 Understanding the rationale for virtual environments
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.1 理解虚拟环境的原因
- en: Virtual environments reconcile the problem of different projects requiring packages
    in multiple versions. What is a virtual environment, and what can it do? This
    section answers these questions.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟环境解决了不同项目需要多个版本的包的问题。什么是虚拟环境，它能做什么？本节将回答这些问题。
- en: First, I’ll elaborate on the package conflict problem. When you have only one
    project, you’re fine in terms of using packages. Often, you’re probably working
    on multiple projects simultaneously—a situation that can introduce a package management
    problem. In one project, you use package A, version 1.0; in another project, you
    need package A, version 1.5, so you upgrade the package to version 1.5\. You’ve
    likely created a dilemma. When you go back to your first project, your code may
    break, because chances are that some of the features in package A are removed
    in version 1.5.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我将详细说明包冲突问题。当你只有一个项目时，在包的使用方面没有问题。通常，你可能同时处理多个项目——这种情况可能会引入包管理问题。在一个项目中，你使用包
    A 的版本 1.0；在另一个项目中，你需要包 A 的版本 1.5，因此你将包升级到版本 1.5。你可能已经陷入了两难。当你回到第一个项目时，你的代码可能会出错，因为很可能包
    A 在版本 1.5 中删除了一些功能。
- en: You can certainly downgrade to version 1.0 to work on the first project, but
    when you want to work on your second project, you must run the upgrade again.
    I don’t think you want to do a lot of back-and-forth downgrading and upgrading.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你当然可以将版本降级到 1.0 以便处理第一个项目，但当你想要处理第二个项目时，你必须再次运行升级。我不认为你想进行大量的来回降级和升级。
- en: The best solution is to use virtual environments. *Virtual environments* are
    isolated work directories in which you install the packages you need for a project.
    Because each project has its own virtual environment, you can install different
    packages (or packages of different versions) in their respective work directories.
    Moreover, in advanced virtual environment management tools such as conda, you
    can have a distinct Python version for each virtual environment, together with
    different packages, giving you greater flexibility to manage environments for
    separate projects, as shown in figure 14.1.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳解决方案是使用虚拟环境。*虚拟环境* 是隔离的工作目录，在其中你可以为项目安装所需的包。因为每个项目都有自己的虚拟环境，你可以在它们各自的工作目录中安装不同的包（或不同版本的包）。此外，在高级虚拟环境管理工具如
    conda 中，你可以为每个虚拟环境拥有一个独特的 Python 版本，以及不同的包，这为你提供了更大的灵活性来管理不同项目的环境，如图 14.1 所示。
- en: Concept A *virtual environment* is a directory tree that contains Python and
    third-party dependencies that are isolated from the installations—including Python
    and third-party dependencies—on the computer.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 概念 A *虚拟环境* 是一个目录树，其中包含 Python 和第三方依赖，这些依赖与计算机上的安装（包括 Python 和第三方依赖）是隔离的。
- en: '![CH14_F01_Cui](../Images/CH14_F01_Cui.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![CH14_F01_Cui](../Images/CH14_F01_Cui.png)'
- en: Figure 14.1 Creating multiple virtual environments for each project. In each
    virtual environment, you can have a distinct version of Python and a different
    set of third-party dependencies.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.1 为每个项目创建多个虚拟环境。在每个虚拟环境中，你可以拥有一个独特的 Python 版本和一组不同的第三方依赖。
- en: Figure 14.1 shows three projects with virtual environments. In the virtual environment,
    you use the needed Python version and the third-party dependencies with their
    applicable versions. By using a distinct virtual environment, you don’t need to
    worry about different projects requiring conflicting versions of a package, because
    each project uses its own dependencies.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.1 展示了具有虚拟环境的三个项目。在虚拟环境中，你使用所需的 Python 版本和相应的第三方依赖。通过使用独立的虚拟环境，你不需要担心不同项目需要冲突的包版本，因为每个项目使用它自己的依赖。
- en: Maintainability Create a distinct virtual environment for each project to prevent
    your projects from having conflicting dependencies.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 可维护性 为每个项目创建一个独立的虚拟环境，以防止项目之间出现冲突的依赖。
- en: 14.1.2 Creating a virtual environment for each project
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.2 为每个项目创建虚拟环境
- en: The root cause of the dilemma described in section 14.1.1 is that you share
    packages on your computer because you installed them at the system level. What
    if you could install packages separately for each project? This is exactly how
    a virtual environment works.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 14.1.1 节中描述的两难困境的根本原因是你因为是在系统级别安装的包，所以你在计算机上共享了这些包。如果你能为每个项目分别安装包会怎样？这正是虚拟环境的工作方式。
- en: As part of the standard Python library, the venv module provides the core functionalities
    for virtual environment management. Several third-party tools, such as conda and
    virtualenv, can manage virtual environments in Python. Although they have slightly
    different features, the fundamentals are about the same as what the built-in venv
    module offers. For this reason, I’ll use the venv module to show the core techniques.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 作为标准 Python 库的一部分，venv 模块提供了虚拟环境管理的核心功能。一些第三方工具，如 conda 和 virtualenv，可以管理 Python
    中的虚拟环境。尽管它们的功能略有不同，但基本原理与内置的 venv 模块提供的类似。因此，我将使用 venv 模块来展示核心技术。
- en: 'To create a virtual environment, you need to open a command-line tool, such
    as Terminal for Mac or the cmd tool for Windows. For your app project, you create
    the taskier_app directory, which I refer to throughout this chapter. Navigate
    to the taskier_app directory (use the cd command to change the directory), and
    run the following command:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个虚拟环境，你需要打开一个命令行工具，例如 Mac 的 Terminal 或 Windows 的 cmd 工具。对于你的应用程序项目，你创建一个
    taskier_app 目录，我在本章中会一直提到这个目录。导航到 taskier_app 目录（使用 cd 命令更改目录），并运行以下命令：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you use Windows, you may need to use python instead of python3, which I use
    because I’m using a Mac. The command creates a virtual environment named taskier-env,
    as you’re using this environment to build your task management app taskier. You
    should name the environment related to the project so that when you have multiple
    environments, you’ll know which environment is for which project. That is, each
    project will have its own properly named virtual environment for dependency management,
    and there will be no dependency conflicts between projects.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Windows，你可能需要使用 python 而不是 python3，我之所以使用 python3 是因为我使用的是 Mac。该命令创建了一个名为
    taskier-env 的虚拟环境，因为你正在使用这个环境来构建你的任务管理应用程序 taskier。你应该为与项目相关的环境命名，这样当你有多个环境时，你会知道哪个环境是为哪个项目准备的。也就是说，每个项目都将拥有自己的正确命名的虚拟环境，用于依赖管理，并且项目之间不会有依赖冲突。
- en: Maintainability Name the virtual environment related to the project that it
    serves.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 可维护性：为项目服务的虚拟环境命名。
- en: You’ll notice that a folder named taskier-env appears in the directory. This
    folder holds all the folders and files needed for the virtual environment. If
    you’re curious, the bin folder (macOS only; in Windows, you’ll see a folder called
    Scripts or something similar) contains the essential tools for the environment,
    including the link to the Python interpreter, pip (section 14.1.3), and activation
    scripts (section 14.1.3).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到目录中出现了一个名为 taskier-env 的文件夹。这个文件夹包含了创建虚拟环境所需的所有文件夹和文件。如果你好奇，bin 文件夹（仅限
    macOS；在 Windows 上，你会看到一个名为 Scripts 或类似名称的文件夹）包含了环境所需的基本工具，包括指向 Python 解释器的链接、pip（第
    14.1.3 节）和激活脚本（第 14.1.3 节）。
- en: 14.1.3 Installing packages in the virtual environment
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.3 在虚拟环境中安装包
- en: You understand that virtual environments are isolated work directories for your
    projects and that it’s safe to install any packages needed for this project without
    affecting other projects. In this section, I’ll show you how to install packages
    in a virtual environment.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你明白虚拟环境是项目隔离的工作目录，并且安装此项目所需的任何包都不会影响其他项目，这是安全的。在本节中，我将向你展示如何在虚拟环境中安装包。
- en: 'First, create the virtual environment taskier-env for the project. To use this
    environment, run the following command:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为项目创建一个名为 taskier-env 的虚拟环境。要使用此环境，请运行以下命令：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'NOTE If the command doesn’t work in your command-line tool, see this page of
    the official Python website for further instructions: [https://docs.python.org/3/library/venv.html](https://docs.python.org/3/library/venv.html).'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果命令在你的命令行工具中不起作用，请参阅官方 Python 网站的此页面以获取进一步说明：[https://docs.python.org/3/library/venv.html](https://docs.python.org/3/library/venv.html)。
- en: The command *activates* the virtual environment, allowing you to install packages
    in the virtual environment. You’ll see that the command line has the virtual environment’s
    name as a prefix (taskier-env), which signifies that the environment is activated
    and ready for package installation.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令 *激活* 虚拟环境，允许你在虚拟环境中安装包。你会看到命令行有一个虚拟环境名称作为前缀（taskier-env），这表示环境已激活并准备好安装包。
- en: 'The most common Python package installation tool is pip; you can find detailed
    instructions on how to use pip in appendix B online. In brief, you’ll install
    the streamlit library for the task management app, and this library will provide
    the tools to build the frontend for the project as a web app. I chose this library
    because it’s easy to build a web app with it, which allows you to focus on the
    content instead of the layout of the web elements. This command installs streamlit
    (version 1.10.0 at the time this book was written):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的 Python 软件包安装工具是 pip；您可以在附录 B 在线找到有关如何使用 pip 的详细说明。简而言之，您将为任务管理应用程序安装 streamlit
    库，该库将为项目提供构建前端作为网络应用程序的工具。我选择这个库是因为使用它很容易构建网络应用程序，这使您能够专注于内容而不是网络元素布局。此命令安装 streamlit（在本书编写时为版本
    1.10.0）：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: For best reproducibility, I recommend that you install the same version. It’s
    entirely possible, however, that your web app will still run with the latest streamlit
    version.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最佳的可重复性，我建议您安装相同的版本。然而，您的网络应用程序仍然可以使用最新的 streamlit 版本运行。
- en: 14.1.4 Using virtual environments in Visual Studio Code
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.4 在 Visual Studio Code 中使用虚拟环境
- en: For this project, you’ll use Visual Studio Code (VSC) as your coding tool because
    it’s an open source integrated development environment (IDE) with powerful extension
    capability. (See appendix A online for installation instructions.) In this section,
    I’ll show you how to use virtual environments in VSC.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，你将使用 Visual Studio Code (VSC) 作为你的编码工具，因为它是一个具有强大扩展能力的开源集成开发环境 (IDE)。（有关安装说明，请参阅附录
    A 在线内容。）在本节中，我将向你展示如何在 VSC 中使用虚拟环境。
- en: 'Open the project directory (taskier_app) in VSC; press Cmd+Shift+P (Mac) or
    Ctrl+Shift+P (Windows) to display the command menu; and enter **Python: Select
    Interpreter**, which brings up the list of available virtual environments. You
    should be able to see the virtual environment taskier-env in the list. Select
    the ''taskier-env'': venv option (figure 14.2).'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '在 VSC 中打开项目目录（taskier_app）；按 Cmd+Shift+P（Mac）或 Ctrl+Shift+P（Windows）以显示命令菜单；并输入
    **Python: Select Interpreter**，这将显示可用的虚拟环境列表。您应该能够在列表中看到虚拟环境 taskier-env。选择 ''taskier-env'':
    venv 选项（图 14.2）。'
- en: Note You need to open the project directory (taskier_app) by choosing File >
    Open Folder in VSC. Otherwise, you may not see the environment in the list.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您需要通过选择 VSC 中的文件 > 打开文件夹来打开项目目录（taskier_app）。否则，您可能看不到列表中的环境。
- en: '![CH14_F02_Cui](../Images/CH14_F02_Cui.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![CH14_F02_Cui](../Images/CH14_F02_Cui.png)'
- en: Figure 14.2 Selecting the proper interpreter in the correct virtual environment.
    Note that you may not see other options on your computer; this figure shows the
    full list of virtual environments available on my computer.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.2 在正确的虚拟环境中选择合适的解释器。请注意，您可能看不到计算机上的其他选项；此图显示了我在计算机上可用的虚拟环境的完整列表。
- en: To verify that you’re indeed using this environment, create a file (say, test_env.py)
    in the parent directory (taskier_app). When you open this file, you should see
    the status bar at the bottom of the VSC window, as shown in figure 14.3.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证您确实正在使用此环境，在父目录（taskier_app）中创建一个文件（例如，test_env.py）。当您打开此文件时，您应该在 VSC 窗口的底部看到状态栏，如图
    14.3 所示。
- en: '![CH14_F03_Cui](../Images/CH14_F03_Cui.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![CH14_F03_Cui](../Images/CH14_F03_Cui.png)'
- en: Figure 14.3 The status bar showing key information on running Python in VSC,
    including the Python version, the virtual environment, and the environment’s creation
    tool (venv).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.3 显示在 VSC 中运行 Python 的状态栏，包括 Python 版本、虚拟环境和环境的创建工具（venv）。
- en: Please note that although your project is going to be completed with Python
    3.10.4, it should be compatible with earlier versions (Python 3.8 and later),
    as the techniques I’ve been covering are stable core features of Python.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管您的项目将使用 Python 3.10.4 完成，但它应该与早期版本（Python 3.8 及以后版本）兼容，因为我所涵盖的技术是 Python
    的稳定核心功能。
- en: 14.1.5 Discussion
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.5 讨论
- en: 'The venv module provides essential features for creating a virtual environment
    and is convenient to use because it comes with the standard Python library. The
    module has a drawback, however: by default, it uses the systemwide Python. If
    you want to use a specific version of Python for your project, you should use
    other virtual environment management tools, such as conda. With conda, you can
    enjoy all the benefits of installing environment-specific packages that you have
    with venv. Moreover, you can have an isolated Python installation in the virtual
    environment, giving you greater flexibility in project configuration in terms
    of Python version and third-party packages.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: venv 模块提供了创建虚拟环境的基本功能，并且使用方便，因为它包含在标准 Python 库中。然而，该模块有一个缺点：默认情况下，它使用系统范围内的
    Python。如果你想为你的项目使用特定的 Python 版本，你应该使用其他虚拟环境管理工具，例如 conda。使用 conda，你可以享受到与 venv
    相同的安装环境特定包的所有好处。此外，你可以在虚拟环境中拥有独立的 Python 安装，这为你提供了在项目配置方面（就 Python 版本和第三方包而言）更大的灵活性。
- en: Using conda for virtual environment management
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 conda 进行虚拟环境管理
- en: 'To have a distinct Python interpreter for your project, you can use conda to
    manage the virtual environments. You can find installation instructions on its
    official website: [https://conda.io](https://conda.io). After you install conda,
    you can use it to create virtual environments in your preferred command-line tool.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要为你的项目拥有一个独立的 Python 解释器，你可以使用 conda 来管理虚拟环境。你可以在其官方网站上找到安装说明：[https://conda.io](https://conda.io)。安装
    conda 后，你可以使用它在你喜欢的命令行工具中创建虚拟环境。
- en: 'For your project, you have Python 3.10.4 and the dependency of streamlit 1.10.0\.
    You can use the following command to create the desired virtual environment:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你的项目，你拥有 Python 3.10.4 和 streamlit 1.10.0 的依赖。你可以使用以下命令来创建所需的虚拟环境：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: (Please note that if you run the following code after creating the virtual environment
    with venv, you may see two virtual environments with the same name and distinct
    file paths.) After running this command, you can activate this environment by
    running conda activate taskier-env and then work on this virtual environment.
    To set up the environment in VSC, bring up the Python interpreter list, and choose
    the one in the taskier-env environment.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: （请注意，如果你在用 venv 创建虚拟环境后运行以下代码，你可能会看到两个具有相同名称但不同文件路径的虚拟环境。）运行此命令后，你可以通过运行 conda
    activate taskier-env 来激活此环境，然后在这个虚拟环境中工作。要在 VSC 中设置环境，请显示 Python 解释器列表，并选择 taskier-env
    环境中的那个。
- en: 14.1.6 Challenge
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.6 挑战
- en: Jerry works as a data scientist at a real estate company. He knows that it’s
    a good idea to have separate virtual environments for his project. As a practice,
    how can he create a virtual environment named python-env? In the environment,
    he needs to install the pandas library. After the installation, he also wants
    to configure VSC to use this environment.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 杰瑞在一家房地产公司担任数据科学家。他知道为他的项目拥有独立的虚拟环境是个好主意。作为一个练习，他如何创建一个名为 python-env 的虚拟环境？在这个环境中，他需要安装
    pandas 库。安装后，他还想配置 VSC 使用这个环境。
- en: Hint Follow the instructions covered in this section.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：遵循本节中涵盖的说明。
- en: 14.2 How do I build the data models for my project?
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.2 如何为我的项目构建数据模型？
- en: The core of any application is data, although data takes a variety of forms,
    such as text and image. Regardless of the form of the data, when we build an application,
    we typically define custom classes to represent the data as attributes. We prepare
    and process data through functions or methods within the custom classes. This
    data and related operations are collectively referred to as *data models* for
    an application. In this section, we’ll review the data models used in our task
    management app.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 任何应用程序的核心都是数据，尽管数据有多种形式，如文本和图像。无论数据的形式如何，当我们构建应用程序时，我们通常定义自定义类来表示数据作为属性。我们通过自定义类内的函数或方法准备和处理数据。这些数据和相关的操作统称为应用程序的
    *数据模型*。在本节中，我们将回顾我们在任务管理应用程序中使用的数据模型。
- en: 14.2.1 Identifying the business needs
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2.1 识别业务需求
- en: The data models should serve the business needs of our project. To build the
    data models properly, we must first identify the features of our task management
    app. The app is a demonstration project, so I’ll include sufficient features to
    serve as a backbone to show you the essential techniques of Python. Please note
    that I don’t want to overcomplicate the app, which would make it hard to focus
    on learning these essentials.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 数据模型应该服务于我们项目的业务需求。为了正确构建数据模型，我们首先必须确定任务管理应用的功能。该应用是一个演示项目，所以我会包括足够的功能作为骨干来展示Python的基本技术。请注意，我不想使应用过于复杂，这会使我们难以专注于学习这些基本技术。
- en: In our app, users can create a new task, view the list of tasks, edit a task,
    and delete a task. It would also be helpful if users could sort and filter the
    tasks by specific criteria. Figure 14.4 summarizes these features.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用中，用户可以创建一个新的任务，查看任务列表，编辑任务，以及删除任务。如果用户能够根据特定标准对任务进行排序和筛选，那将非常有帮助。图14.4总结了这些功能。
- en: '![CH14_F04_Cui](../Images/CH14_F04_Cui.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![CH14_F04_Cui](../Images/CH14_F04_Cui.png)'
- en: Figure 14.4 The key features of the task management app. In the app, users can
    create a new task; view, sort, and filter tasks; view a task’s details; and delete
    a task.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.4 任务管理应用的关键功能。在应用中，用户可以创建新的任务；查看、排序和筛选任务；查看任务的详细信息；以及删除任务。
- en: 'As shown in figure 14.4, each task has a few attributes: title (title), desc
    (description), urgency (level of urgency), and status (status). When you build
    a real application with many more features, you’ll need to design the app’s user
    interface (the frontend) in such a way that you can determine whether you have
    all the features you need and how the features interact. For our task management
    app, I’ll keep the interface simple, focusing on the coding portion instead of
    on the app’s interface design.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如图14.4所示，每个任务都有一些属性：标题（title）、描述（desc）、紧急程度（urgency）和状态（status）。当你构建具有更多功能的真实应用时，你需要以这种方式设计应用的用户界面（前端），以便确定你是否拥有所有需要的功能以及这些功能如何交互。对于我们的任务管理应用，我会保持界面简单，专注于编码部分而不是应用界面设计。
- en: Peek We’ll build a web app as our app’s frontend. Because the streamlit framework
    helps us lay out the elements of a web app (such as text display and input boxes),
    we’ll use it as our tool.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 查看我们将构建一个网络应用作为我们的应用前端。由于streamlit框架帮助我们布局网络应用的元素（如文本显示和输入框），我们将使用它作为我们的工具。
- en: 14.2.2 Creating helper classes and functions
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2.2 创建辅助类和函数
- en: 'Before analyzing the code for the Task class (section 14.2.3), I want to introduce
    the needed helper classes and functions in this section. We’re going to create
    a file named taskier.py to store the Task class. At the head of this file, we’re
    importing the necessary dependencies as follows (and please note that I’ll cover
    the use of these modules when I discuss the pertinent code):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析任务类（第14.2.3节）的代码之前，我想在本节中介绍所需的辅助类和函数。我们将创建一个名为taskier.py的文件来存储任务类。在这个文件的头部，我们正在导入必要的依赖项如下（并且请注意，当讨论相关代码时，我会介绍这些模块的使用）：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A task has three possible statuses: created, ongoing, and completed. We’ll
    use enumeration to represent these statuses:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一个任务有三个可能的状态：创建、进行中和完成。我们将使用枚举来表示这些状态：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In section 9.1, we learned about enumeration by subclassing the Enum class.
    Here, we subclass IntEnum class, which is like the Enum class but has an added
    benefit: we can sort statuses because their raw values are integer numbers. In
    this enumeration class, we define a class method (section 8.2), which creates
    a list of strings to be used in our web app (section 14.4).'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在第9.1节中，我们通过子类化Enum类学习了枚举。在这里，我们子类化IntEnum类，它类似于Enum类，但有一个额外的优点：我们可以对状态进行排序，因为它们的原始值是整数。在这个枚举类中，我们定义了一个类方法（第8.2节），它创建了一个字符串列表，用于在我们的网络应用中（第14.4节）使用。
- en: 'In section 11.2, we studied how to process tabulated data by using the csv
    module. To show you the pertinent techniques, I’ll use a CSV file as the data
    source, even though a CSV file typically isn’t preferred as the database; as a
    formal database choice, I’ll show you how to use SQLite in section 14.3\. To include
    both options in the web app, we can use an enumeration class:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在第11.2节中，我们学习了如何使用csv模块处理表格数据。为了展示相关技术，我将使用CSV文件作为数据源，尽管CSV文件通常不是首选的数据库；作为正式的数据库选择，我将在第14.3节中展示如何使用SQLite。为了在Web应用中包含这两种选项，我们可以使用枚举类：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We created a global variable app_db to track the database option. Now we default
    it to the CSV file option. In the web app, for demonstration purposes, we let
    users choose the database option, and we use the function in the next listing
    to update the database choice.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个全局变量 app_db 来跟踪数据库选项。现在我们将其默认设置为 CSV 文件选项。在 Web 应用程序中，为了演示目的，我们让用户选择数据库选项，并使用下一列表中的函数来更新数据库选择。
- en: Listing 14.1 Setting the database option for the app
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14.1 设置应用程序的数据库选项
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Checks a path’s existence
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 检查路径是否存在
- en: Because we’re changing the variable in the global scope, we need to use the
    global keyword before we can change it (section 10.4). If the file doesn’t exist
    at the path, we’re going to create the data file and load some seeding data for
    demonstration purposes, using the Task’s load_seed_data method (section 14.2.3).
    Although I’ll talk more about the SQLite database in section 14.3, listing 14.1
    includes a line of code (Task.con = sqlite3.connect(app_db)) that creates a connection
    to the database when the database option is SQLite.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在更改全局作用域中的变量，我们需要在更改它之前使用 global 关键字（第 10.4 节）。如果文件不存在于该路径，我们将创建数据文件并加载一些用于演示的种子数据，使用
    Task 的 load_seed_data 方法（第 14.2.3 节）。尽管我将在第 14.3 节中更多地讨论 SQLite 数据库，但列表 14.1 包含一行代码（Task.con
    = sqlite3.connect(app_db)），当数据库选项为 SQLite 时，它将创建到数据库的连接。
- en: 'From the exception-handling perspective, we’ll create our own exception class,
    allowing us to raise custom exceptions. As discussed in section 12.5, our exception
    class is a subclass of the Exception class:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 从异常处理的角度来看，我们将创建自己的异常类，允许我们引发自定义异常。如第 12.5 节所述，我们的异常类是 Exception 类的子类：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Because we can provide custom error messages when we use this class, we don’t
    need to implement any methods; we’ll use the pass statement to fulfill the syntax
    requirement. Please note that if we want to provide more specific exceptions,
    we can create subclasses from the TaskierError class.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可以在使用此类时提供自定义错误消息，因此我们不需要实现任何方法；我们将使用 pass 语句来满足语法要求。请注意，如果我们想提供更具体的异常，我们可以从
    TaskierError 类创建子类。
- en: 14.2.3 Creating the Task class to address these needs
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2.3 创建 Task 类以满足这些需求
- en: We’ve identified the core features of our app, and we’re ready to implement
    the Task class to address our business needs. In this section, we’ll build the
    Task class. To facilitate teaching, I’ll analyze the code directly with an emphasis
    on individual methods.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定了应用程序的核心功能，并准备好实现 Task 类以满足我们的业务需求。在本节中，我们将构建 Task 类。为了便于教学，我将直接分析代码，并侧重于单个方法。
- en: Creating and saving tasks
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 创建和保存任务
- en: In our app, each task is modeled as an instance of the Task class. We create
    instance objects to model the tasks. In this section, I’ll show you the code that
    creates and saves instance objects to a file.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，每个任务都被建模为 Task 类的一个实例。我们创建实例对象来建模任务。在本节中，我将向您展示创建并保存实例对象到文件的代码。
- en: 'The initialization method allows us to define custom attributes for the instance
    objects (section 8.1). We override the __init__ method to configure the instantiation.
    In the definition, we use the type hints (section 6.3) for each of the arguments.
    We also provide docstrings for the method by using Google style (section 6.5.1):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化方法允许我们为实例对象定义自定义属性（第 8.1 节）。我们重写 __init__ 方法来配置实例化。在定义中，我们为每个参数使用类型提示（第 6.3
    节）。我们还通过使用 Google 风格（第 6.5.1 节）为该方法提供文档字符串：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We use a form to collect the title, description, and urgency level, and then
    use this information to create an instance of the Task class. As you can see in
    the following code snippet, task_from_form_entry is a class method because we
    don’t need to access or manipulate per-instance data. Instead, this method accesses
    the class’s constructor:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用表单来收集标题、描述和紧急程度，然后使用这些信息来创建 Task 类的实例。正如您在以下代码片段中可以看到的，task_from_form_entry
    是一个类方法，因为我们不需要访问或操作每个实例的数据。相反，此方法访问类的构造函数：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note I could have specified that the class method’s return type is Self, which
    refers to the class, but it’s not available until Python 3.11\. For compatibility
    with earlier Python versions, I omitted the type hints for the return type.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我本可以指定类方法的返回类型为 Self，它指的是类，但它在 Python 3.11 之前不可用。为了与早期 Python 版本兼容，我省略了返回类型的类型提示。
- en: 'In this class method, we call the random_string method to get a random string
    as the new task’s ID number. Because the generation of the random string can be
    a utility function for other purposes, we implement it as a static method, as
    it doesn’t use the class or instance-related attributes:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类方法中，我们调用random_string方法来获取一个随机字符串作为新任务的ID号。因为随机字符串的生成可以是其他目的的实用函数，所以我们将其实现为静态方法，因为它不使用类或实例相关的属性：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this method, we use the lowercase ASCII character set (imported from the
    string module) as our source, randomly pick eight characters using the choice
    function in the random module, and concatenate these characters using the join
    method (section 2.3). When we’ve created the instance, we need to save it to the
    database, and we can use the save_to_db method, as shown in the following listing.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，我们使用小写ASCII字符集（从string模块导入）作为我们的源，使用random模块中的choice函数随机选择八个字符，并使用join方法（第2.3节）将这些字符连接起来。当我们创建实例后，我们需要将其保存到数据库中，可以使用save_to_db方法，如下所示。
- en: Listing 14.2 Saving a record to the database
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14.2 将记录保存到数据库
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We open the CSV file in append mode using the with statement (section 11.1).
    Using the CSV writer, we can write a row of data into the CSV file. As you may
    notice, we call the protected method _formatted_db_record to obtain the record
    we’re going to write to the file. The underscore prefix indicates that the method
    is nonpublic (section 8.3.1).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用with语句（第11.1节）以追加模式打开CSV文件。使用CSV writer，我们可以将一行数据写入CSV文件。正如你可能注意到的，我们调用受保护的方法_formatted_db_record来获取我们打算写入文件的记录。下划线前缀表示该方法是非公开的（第8.3.1节）。
- en: Reading tasks from the data source
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 从数据源读取任务
- en: When we have multiple tasks in the database, it’s time to read and display the
    tasks. To load tasks from the database, we create the load_tasks method, as the
    next listing shows.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在数据库中有多个任务时，是时候读取和显示任务了。为了从数据库中加载任务，我们创建load_tasks方法，如下一列表所示。
- en: Listing 14.3 Loading tasks from the database
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14.3 从数据库加载任务
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Uses find to search a substring
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用find搜索子字符串
- en: Note The type hint usage list[TaskStatus] is available in Python 3.9 and later.
    If you experience an exception related to this usage, it’s likely that you’re
    using an older version of Python.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：类型提示使用list[TaskStatus]在Python 3.9及以后版本中可用。如果你遇到与此使用相关的异常，很可能是你正在使用较旧的Python版本。
- en: 'In listing 14.3, I want to highlight the following techniques:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表14.3中，我想强调以下技术：
- en: The created CSV reader from the file can be used as a generator (section 11.2),
    with each item representing a row of data.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从文件创建的CSV reader可以用作生成器（第11.2节），其中每个项目代表一行数据。
- en: We use tuple unpacking (section 4.4) to obtain the six data elements sequentially.
    Each of these elements is in the form of a string.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用元组解包（第4.4节）依次获取六个数据元素。这些元素都是字符串形式。
- en: We obtain the desired urgency and status attributes by using the int and TaskStatus
    constructors, respectively. Please note that we could have used a try...except...
    statement to obtain the data, but we’re sure about the data integrity here, so
    the conversion should work. When we’re processing outside data, we should use
    the exception-handling techniques.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过使用int和TaskStatus构造函数分别获取所需的urgency和status属性。请注意，我们本可以使用try...except...语句来获取数据，但我们确信数据完整性，因此转换应该可以工作。当我们处理外部数据时，我们应该使用异常处理技术。
- en: When we search a substring, we prefer using find, as it doesn’t raise an exception,
    unlike the index method (section 4.3.2).
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们搜索子字符串时，我们更喜欢使用find，因为它不会引发异常，与index方法（第4.3.2节）不同。
- en: Related to the substring searching, the built-in all function returns True if
    all the items in the list are evaluated to be True. The entire line means that
    if the function call specifies the content argument, and we can’t find any match
    in the note, desc, or title, we’ll skip the current row by triggering the continue
    statement.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与子字符串搜索相关，内置的all函数如果列表中的所有项都被评估为True，则返回True。整个行意味着如果函数调用指定了content参数，并且我们在note、desc或title中找不到任何匹配项，我们将通过触发continue语句跳过当前行。
- en: Because our app allows users to select tasks that meet specific criteria—including
    statuses, urgencies, and content (for title, description, and completion note)—we
    want to define the load_tasks method that can load not only all the tasks, but
    also a subset of tasks. If the argument statuses is not None, and the current
    row’s status is not in the statuses, we can skip the current row by calling the
    continue statement. The same logic applies to the urgencies and content arguments.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为我们的应用程序允许用户选择符合特定标准（包括状态、紧急程度和内容，即标题、描述和完成备注）的任务，我们希望定义一个load_tasks方法，它可以加载不仅所有任务，还可以是任务的一个子集。如果statuses参数不为None，并且当前行的状态不在statuses中，我们可以通过调用continue语句跳过当前行。同样的逻辑适用于urgencies和content参数。
- en: Updating a task in the data source
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 更新数据源中的任务
- en: When the user makes changes to a task, we need to update the record in the database.
    For this purpose, we use the update_in_db method, as the next listing shows.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户对任务进行更改时，我们需要更新数据库中的记录。为此，我们使用update_in_db方法，如下所示。
- en: Listing 14.4 Updating a record in the database
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14.4 在数据库中更新记录
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ Compiles the regular expression pattern
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 编译正则表达式模式
- en: In this method, I want to show you the usefulness of regular expressions. In
    essence, we read all the text data from the CSV file. The pattern is to search
    the string that starts with the task ID number and ends with a newline break.
    The replacement is the updated record that we obtain by calling the _formatted_db_record
    method. Note that because we’re writing text data to the file, we need to convert
    the formatted record’s data to strings using the map function (section 7.2.2).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我想向你展示正则表达式的实用性。本质上，我们从CSV文件中读取所有文本数据。模式是搜索以任务ID数字开头并以换行符结尾的字符串。替换是我们通过调用_formatted_db_record方法获得的更新记录。请注意，因为我们正在将文本数据写入文件，所以我们需要使用map函数（第7.2.2节）将格式化记录的数据转换为字符串。
- en: From a performance perspective, we can replace the updated record directly without
    searching for its existence. But because of the design of our app (section 14.4.3),
    it’s possible that the user may be trying to update a task that has been removed.
    To accommodate this need, we’re raising an exception when the record doesn’t exist.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 从性能的角度来看，我们可以直接替换更新记录，而无需搜索其存在。但由于我们应用程序的设计（第14.4.3节），用户可能正在尝试更新一个已经被删除的任务。为了满足这一需求，当记录不存在时，我们抛出一个异常。
- en: Although we didn’t have a chance to discuss the seek and truncate methods in
    section 11.1, they’re easy to understand. In essence, we call seek(0) to move
    the cursor of the file stream to the beginning and call truncate to remove all
    the text data. When the file is empty, we can write the updated_records to the
    file.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们没有机会在11.1节中讨论seek和truncate方法，但它们很容易理解。本质上，我们调用seek(0)将文件流的指针移动到开始位置，并调用truncate来删除所有文本数据。当文件为空时，我们可以将updated_records写入文件。
- en: Deleting a task from the data source
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 从数据源中删除任务
- en: If the user wants to delete a task, it’s possible for them to do so. We can
    define the delete_from_db method to address this need, as shown in the next listing.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户想要删除一个任务，他们可以这样做。我们可以定义delete_from_db方法来满足这一需求，如下所示。
- en: Listing 14.5 Deleting a record from the database
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14.5 从数据库中删除记录
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this method, we call readlines (section 11.1) to obtain the text data as
    a list object. We use this method because list objects are mutable (section 3.1),
    allowing us to remove a task. For each line, we examine whether it starts with
    the task ID number, and when we find it, we call the break statement to exit the
    for loop immediately. After the lines object is updated, we can write it back
    to the file by calling the writelines method.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们调用readlines（第11.1节）以列表对象的形式获取文本数据。我们使用这个方法是因为列表对象是可变的（第3.1节），允许我们删除一个任务。对于每一行，我们检查它是否以任务ID数字开头，当我们找到它时，我们调用break语句立即退出for循环。在lines对象更新后，我们可以通过调用writelines方法将其写回文件。
- en: 'We define a method, load_seed_data, to load some tasks so that the app can
    display some data. In this method, we create three tasks and save them to the
    database by calling the save_to_db method:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个名为load_seed_data的方法，用于加载一些任务，以便应用程序可以显示一些数据。在这个方法中，我们创建了三个任务，并通过调用save_to_db方法将它们保存到数据库中：
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Last but not least, we define the string representation methods, __str__ and
    __repr__ (section 8.4):'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们定义了字符串表示方法__str__和__repr__（第8.4节）：
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: NOTE _str_ is for informational purposes and _repr_ is for coding development
    purposes, if you’re wondering about the difference between these two methods.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 备注 `_str_` 用于信息目的，而 `_repr_` 用于编码开发目的，如果您想知道这两种方法之间的区别。
- en: 14.2.4 Discussion
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2.4 讨论
- en: Our data models should serve our business needs. It’s important to identify
    the app’s features before we implement our data models. Although I’m showing the
    final version of the code, it has taken me considerable time with multiple iterations
    of the code to arrive at this version. Be patient with yourself when you work
    on any project.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据模型应该满足我们的业务需求。在实现我们的数据模型之前，确定应用程序的功能非常重要。尽管我展示了代码的最终版本，但到达这个版本花费了我相当多的时间和多次代码迭代。当您在处理任何项目时，请对自己有耐心。
- en: PEEK The Task class serves the web app that we’re going to build in section
    14.4.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: PEEK 任务类为我们将在 14.4 节中构建的 Web 应用程序提供服务。
- en: 14.2.5 Challenge
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2.5 挑战
- en: While Kathy is studying this book, she writes all the code to learn all the
    topics covered in this book. When she works on the Task class, she thinks it’s
    possible that users may try to delete a task that has already been removed from
    the database. How can she update the delete_from_db method to make it raise an
    exception when the record doesn’t exist?
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当凯西在学习这本书时，她编写了所有代码来学习这本书涵盖的所有主题。当她处理任务类时，她认为用户可能会尝试删除已从数据库中删除的任务。她如何更新 delete_from_db
    方法，使其在记录不存在时引发异常？
- en: Hint You can examine whether the record has been located before carrying out
    the desired operation.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 提示 您可以在执行所需操作之前检查记录是否已被定位。
- en: 14.3 How do I use SQLite as my application’s database?
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.3 如何将 SQLite 用作我的应用程序数据库？
- en: A database hosts the data for your application. Depending on the nature of your
    application, such as data volume and processing requirements, you have a variety
    of options for the database—Microsoft SQL, Oracle, MySQL, and PostgreSQL, to name
    a few. These options are generally for enterprise-level applications, and it takes
    time and resources to set up the infrastructure and maintain its performance.
    Unlike these enterprise database solutions, SQLite is a kind of lightweight database
    that requires virtually no setup on your computer, as it uses your computer’s
    disk directly as the storage mechanism. In this section, I’ll show you how to
    use SQLite as our application’s database.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库为您的应用程序存储数据。根据您应用程序的性质，例如数据量和处理需求，您有多种数据库选择——例如 Microsoft SQL、Oracle、MySQL
    和 PostgreSQL。这些选项通常用于企业级应用程序，设置基础设施和维护其性能需要时间和资源。与这些企业数据库解决方案不同，SQLite 是一种轻量级数据库，几乎不需要在您的计算机上进行设置，因为它直接使用您的计算机磁盘作为存储机制。在本节中，我将向您展示如何使用
    SQLite 作为我们应用程序的数据库。
- en: 14.3.1 Creating the database
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3.1 创建数据库
- en: The creation of an SQLite database is almost instant, requiring only a few function
    calls. Specifically, we’ll use the built-in sqlite3 module, which is in the standard
    Python library. This module provides all the application programming interfaces
    (APIs) needed to create and manipulate the SQLite database. We’ll start with creating
    a database.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 SQLite 数据库几乎是瞬时的，只需要调用几个函数。具体来说，我们将使用内置的 sqlite3 模块，它位于标准 Python 库中。此模块提供了创建和操作
    SQLite 数据库所需的所有应用程序编程接口 (API)。我们将从创建数据库开始。
- en: 'Because the database is shared by all the instances of the Task class, we’ll
    define the connection to the database as a class attribute. Through this connection,
    we’ll perform all database-related operations, such as data query and updating.
    We don’t work on the database directly at the physical level because we want other
    processes to use the database if necessary. Therefore, we establish a connection
    and work on it as we create a file object on a file instead of manipulating the
    file directly:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 因为数据库被任务类的所有实例共享，所以我们将数据库连接定义为类属性。通过这个连接，我们将执行所有数据库相关操作，如数据查询和更新。我们不直接在物理级别上工作在数据库上，因为我们希望其他进程在必要时可以使用数据库。因此，我们建立连接，就像创建文件对象一样工作，而不是直接操作文件：
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To create a database, we define the create_sqlite_database method:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建数据库，我们定义 create_sqlite_database 方法：
- en: '[PRE19]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Saves it as a class variable
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将其保存为类变量
- en: 'We perform two operations in this method:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在此方法中，我们执行两个操作：
- en: '*By calling* connect *function, we’re establishing a connection to the database
    at the specified path.* Notably, if the database doesn’t exist at the path, this
    function call also creates the database. We use the with statement, which creates
    a context manager to commit the execution automatically.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通过调用* connect *函数，我们正在建立与指定路径数据库的连接。*值得注意的是，如果路径上不存在数据库，此函数调用也会创建数据库。我们使用with语句，它创建一个上下文管理器来自动提交执行。'
- en: '*We’re adding a new table,* task*, to the database.* Please note that this
    code runs only when there is no database. The command is CREATE TABLE table_name
    (field0_name field0_type, field1_name field1_type, ...). Another thing you may
    notice is that we create a cursor to run the statement—a standard operation in
    SQLite and SQL databases in general.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*我们正在向数据库添加一个新的表，* task *。请注意，此代码仅在不存在数据库时运行。命令是CREATE TABLE table_name (field0_name
    field0_type, field1_name field1_type, ...)。你可能还会注意到，我们创建了一个游标来运行该语句——这是SQLite和SQL数据库中的一般标准操作。'
- en: 'We intend to call this create_sqlite_database method when users set the database
    option, so we need to update the set_db_option function in listing 14.1 as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打算在用户设置数据库选项时调用这个create_sqlite_database方法，因此我们需要更新列表14.1中的set_db_option函数，如下所示：
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: I boldfaced the added code, which is a simple call of the create_sqlite_database
    method when the database doesn’t exist. As a side note on the elif portion, when
    the SQLite database exists and the database choice is SQLite, we establish a connection
    to the database. Before we jump into the code to perform data operations using
    the SQLite database, take a quick look at figure 14.5, which depicts the most
    common operations.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我将添加的代码加粗了，这是一个简单的调用create_sqlite_database方法，当数据库不存在时。作为对elif部分的补充说明，当SQLite数据库存在且数据库选择为SQLite时，我们建立与数据库的连接。在我们跳入代码以使用SQLite数据库执行数据操作之前，快速看一下图14.5，它描述了最常见的操作。
- en: '![CH14_F05_Cui](../Images/CH14_F05_Cui.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![CH14_F05_Cui](../Images/CH14_F05_Cui.png)'
- en: 'Figure 14.5 Common operations with an SQLite database: query, insert, update,
    and delete. Query retrieves records from the database, insert saves a new record
    to the database, update updates an existing record, and delete removes an existing
    record.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.5 使用SQLite数据库的常见操作：查询、插入、更新和删除。查询从数据库中检索记录，插入将新记录保存到数据库中，更新更新现有记录，删除删除现有记录。
- en: 'As shown in figure 14.5, we perform four common operations when we use an SQLite
    database (or any database in general): query (retrieving records from the database),
    insert (saving a new record to the database), update (updating an existing record),
    and delete (removing a record from the database). The following sections address
    these four operations individually.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如图14.5所示，当我们使用SQLite数据库（或任何数据库）时，我们执行四个常见的操作：查询（从数据库中检索记录）、插入（将新记录保存到数据库中）、更新（更新现有记录）和删除（从数据库中删除记录）。以下各节将分别介绍这四个操作。
- en: 14.3.2 Retrieving records from the database
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3.2 从数据库中检索记录
- en: To display data in our app, we need to retrieve records from the database. We’ve
    seen how we can use the csv module to read data from a CSV file (section 14.2.3).
    Here, I show you how to retrieve data by using the SQLite database.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的应用程序中显示数据，我们需要从数据库中检索记录。我们看到了如何使用csv模块从CSV文件中读取数据（第14.2.3节）。这里，我将向您展示如何使用SQLite数据库检索数据。
- en: We’ve defined the load_tasks method (listing 14.3) to obtain the tasks data.
    Now we’ll update this method to let it work with the SQLite database (listing
    14.6). Please note that I’m showing you only the code that is pertinent for reading
    data from the SQLite database and omitting the code for using the CSV file.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了load_tasks方法（列表14.3）来获取任务数据。现在我们将更新此方法，使其能够与SQLite数据库一起工作（列表14.6）。请注意，我只展示了与从SQLite数据库读取数据相关的代码，省略了使用CSV文件的代码。
- en: Listing 14.6 Loading data from the SQLite database
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14.6 从SQLite数据库加载数据
- en: '[PRE21]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Note the following points about this code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下关于此代码的要点：
- en: Because I want to create a single SQL statement to handle two scenarios—all
    the tasks (using no filtering conditions for the arguments) and a subset of tasks
    (using filtering conditions for the arguments)—I list all the statuses when the
    statuses argument is None by running statuses = tuple(map(int, TaskStatus)).
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为我想创建一个SQL语句来处理两种情况——所有任务（不使用过滤条件）和任务子集（使用过滤条件）——所以我通过运行statuses = tuple(map(int,
    TaskStatus))列出当statuses参数为None时的所有状态。
- en: Similar logic applies to the urgencies argument. When the user wants to retrieve
    all the tasks, we require the records’ urgency field to fall in the range 1-5,
    which is the possible range of urgency levels.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相似的逻辑也适用于 urgencies 参数。当用户想要检索所有任务时，我们要求记录的紧急程度字段在 1-5 的范围内，这是紧急程度可能的范围。
- en: One tricky part to understand is that when statuses and urgencies are not None,
    I use tuple(statuses) * 2 and tuple(urgencies) * 2. I do this to fulfil the SQL
    statement syntax requirement when users pick only one item for status or urgency.
    Specifically, if users specify one urgency level, such as 2, from this input,
    we’re going to have a one-item tuple object (2,). Using this tuple object directly
    in the sql_stmt is invalid, so we duplicate the items in the tuple object, changing
    (2,) to (2,2), which is a valid SQL statement.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要理解的一个复杂部分是，当状态和紧急程度不为 None 时，我使用 tuple(statuses) * 2 和 tuple(urgencies) *
    2。我这样做是为了满足 SQL 语句语法要求，当用户只选择一个状态或紧急程度的项目时。具体来说，如果用户从输入中指定一个紧急程度级别，例如 2，那么我们将有一个只有一个元素的元组对象
    (2,)。直接使用这个元组对象在 sql_stmt 中是无效的，因此我们复制元组对象中的项目，将 (2,) 改为 (2,2)，这是一个有效的 SQL 语句。
- en: The LIKE operation is SQL syntax for obtaining records that match the specified
    substring. We update the sql_stmt only when the content argument is set. The portion
    content is evaluated as True if the string contains any characters.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LIKE 操作是 SQL 语法，用于获取与指定子串匹配的记录。只有当内容参数被设置时，我们才更新 sql_stmt。内容部分如果字符串包含任何字符，则评估为
    True。
- en: The fetchall function retrieves all the records as a list object based on the
    executed SQL statement. Each record is returned as a tuple object in the form
    of (task_id, title, desc, urgency, status, completion_note). Using list comprehension,
    we convert these tuple objects to Task instance objects.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: fetchall 函数根据执行的 SQL 语句检索所有记录作为一个列表对象。每条记录以 (task_id, title, desc, urgency,
    status, completion_note) 的形式作为元组对象返回。使用列表推导，我们将这些元组对象转换为 Task 实例对象。
- en: During the conversion from a tuple object to an instance, we use the asterisk
    operation, which unpacks the tuple object and sends the items to the constructor.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在将元组对象转换为实例的过程中，我们使用星号操作，该操作解包元组对象并将项目发送到构造函数。
- en: 14.3.3 Saving records to the database
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3.3 将记录保存到数据库
- en: When we have created records, we need to save them to the database. We can save
    the records one by one or save them all together. In this section, I’ll show both
    techniques.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建了记录后，我们需要将它们保存到数据库中。我们可以逐个保存记录，也可以一次性保存所有记录。在本节中，我将展示这两种技术。
- en: Listing 14.2 defines the save_to_db method for the CSV file as the data source.
    We’re going to update this method to make it compatible with the SQLite database
    (listing 14.7).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14.2 定义了 CSV 文件作为数据源的 save_to_db 方法。我们将更新此方法以使其与 SQLite 数据库兼容（列表 14.7）。
- en: Listing 14.7 Saving a record to the SQLite database
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14.7 保存记录到 SQLite 数据库
- en: '[PRE22]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The syntax for saving a record to an SQLite database is INSERT INTO table VALUES
    (?, ?, ...). The question mark represents a placeholder, and the number of placeholders
    (six, in our case) should match the number of items in the record, as obtained
    by calling _formatted_db_record. Please note that you can execute a statement
    without using placeholders, as we did in listing 14.6\. If you use the placeholders,
    you specify these values as the second argument in the execute function call.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 将记录保存到 SQLite 数据库的语法是 INSERT INTO table VALUES (?, ?, ...)。问号代表占位符，占位符的数量（在我们的例子中是六个）应与记录中的项目数量相匹配，这些项目是通过调用
    _formatted_db_record 获得的。请注意，您可以在不使用占位符的情况下执行语句，就像我们在列表 14.6 中所做的那样。如果您使用占位符，您将这些值指定为
    execute 函数调用中的第二个参数。
- en: Another thing to note is that we call self.con to retrieve the connection to
    the database. Although we define con as the class attribute, when we access the
    con attribute of an instance, it uses the class attribute as the fallback.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 另一点需要注意的是，我们调用 self.con 来获取数据库的连接。尽管我们将 con 定义为类属性，但当我们访问实例的 con 属性时，它使用类属性作为后备。
- en: What should we do if we want to save multiple records in a single SQL statement?
    That feature is supported. Instead of calling execute, we call the executemany
    function. In the function call, the second argument is a list of records. Although
    we’re not going to implement it in the Task class (the instance method save_to_db
    is sufficient for demonstration purposes), the next listing shows how to save
    multiple records to an SQLite database.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在单个 SQL 语句中保存多条记录，我们应该怎么做？这个功能是支持的。我们不是调用 execute，而是调用 executemany 函数。在函数调用中，第二个参数是记录列表。虽然我们不会在
    Task 类（实例方法 save_to_db 对于演示目的已经足够）中实现它，但下一个列表显示了如何将多条记录保存到 SQLite 数据库中。
- en: Listing 14.8 Saving multiple records to the SQLite database
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14.8 将多条记录保存到 SQLite 数据库
- en: '[PRE23]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 14.3.4 Updating a record in a database
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3.4 在数据库中更新记录
- en: Our task management app allows users to edit a task. After editing the task,
    we need to update the record in the database. This section shows how to update
    a record in the SQLite database.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务管理应用允许用户编辑任务。编辑任务后，我们需要更新数据库中的记录。本节展示了如何在 SQLite 数据库中更新记录。
- en: 'The update_in_db method is responsible for updating a record. The following
    code updates the method to include the code for the SQLite database portion:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: update_in_db 方法负责更新记录。以下代码更新了该方法，以包含 SQLite 数据库部分的代码：
- en: '[PRE24]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ Counts the existing records
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 计算现有记录数
- en: Note that we first examine the number of records that match the task ID number,
    which should be 1—thus, greater than 0. If the record has been removed, we raise
    an exception indicating that fact, as we did in listing 14.4 when we implemented
    this method using a CSV file as our data source.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们首先检查与任务 ID 号匹配的记录数，这个数字应该是 1——因此，大于 0。如果记录已被删除，我们将抛出一个异常来指示这一点，就像我们在 14.4
    列表中实现此方法时使用 CSV 文件作为数据源时所做的那样。
- en: The syntax for updating a record in an SQLite database is UPDATE table SET field0_name
    = ?, field1_name = ?, ... WHERE condition. In this syntax, we shouldn’t omit the
    WHERE clause, which filters the record; if we do, we’ll update all the records
    accidentally. Again, we’re using placeholders for the execute function call. In
    the clause, we specify the task_id using !r as the conversion, which produces
    the task ID in single quotes ('example_id') as opposed to example_id.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQLite 数据库中更新记录的语法是 UPDATE table SET field0_name = ?, field1_name = ?, ...
    WHERE condition。在这个语法中，我们不应该省略 WHERE 子句，它用于过滤记录；如果我们省略了它，我们可能会意外地更新所有记录。再次强调，我们仍在使用占位符为
    execute 函数调用。在子句中，我们使用 !r 作为转换指定 task_id，它将任务 ID 以单引号 ('example_id') 的形式输出，而不是
    example_id。
- en: 14.3.5 Deleting a record from the database
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3.5 从数据库中删除记录
- en: Our task management app allows users to remove a task. When a task is removed,
    we need to delete the record from the database. In this section, I’ll show how
    to address this need.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务管理应用允许用户删除任务。当任务被删除时，我们需要从数据库中删除记录。在本节中，我将展示如何解决这个问题。
- en: 'The delete_from_db method is responsible for deleting a record. The following
    code updates the method to include the code for the SQLite database portion:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: delete_from_db 方法负责删除一条记录。以下代码更新了该方法，以包含 SQLite 数据库部分的代码：
- en: '[PRE25]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The syntax for deleting a record in an SQLite database is DELETE FROM table
    WHERE condition. The only thing to note is that we still use !r for the task’s
    ID number to create a string within single quotes.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQLite 数据库中删除记录的语法是 DELETE FROM table WHERE condition。需要注意的是，我们仍然使用 !r 为任务的
    ID 号创建一个单引号内的字符串。
- en: 14.3.6 Discussion
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3.6 讨论
- en: Because SQLite is a lightweight database with little configuration, we can use
    it when we prototype our application. When we’re moving the application to production,
    we can upgrade it by using a larger database, such as Oracle and MySQL. Although
    I’ve focused on text and integers as the data types, which satisfies our business
    needs, SQLite has limitations. For one, it doesn’t support all data types, such
    as date and Boolean values. As a workaround, we can use strings in the format
    MMDDYYHHMMSS, the number of seconds since a reference date for the date, and integers
    0 and 1 for false and true.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 SQLite 是一个配置简单的轻量级数据库，我们可以在原型化我们的应用程序时使用它。当我们将应用程序迁移到生产环境时，我们可以通过使用更大的数据库（如
    Oracle 和 MySQL）来升级它。尽管我专注于文本和整数作为数据类型，这满足了我们的业务需求，但 SQLite 有局限性。一方面，它不支持所有数据类型，例如日期和布尔值。作为解决方案，我们可以使用格式为
    MMDDYYHHMMSS 的字符串，这是自参考日期以来的秒数，以及用于 false 和 true 的整数 0 和 1。
- en: 14.3.7 Challenge
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3.7 挑战
- en: We’ve seen that we can use a CSV file and SQLite as our database option. Can
    you write a decorator to log the time needed to call a method? You can compare
    which is faster by using a CSV file or an SQLite database for data-related manipulations.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，我们可以使用 CSV 文件和 SQLite 作为我们的数据库选项。你能编写一个装饰器来记录调用方法所需的时间吗？你可以通过使用 CSV 文件或
    SQLite 数据库进行数据相关操作来比较哪个更快。
- en: Hint Section 7.3 discusses creating a decorator.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 提示第 7.3 节讨论了创建装饰器。
- en: 14.4 How do I build a web app as the frontend?
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.4 如何构建网络应用程序作为前端？
- en: Web apps are a popular choice for many programming projects. Their most significant
    benefit is their cross-platform compatibility. They can run on any web browser,
    which means that you can access the app on any computer, any smartphone, and even
    any television set that supports web browsers. In addition, web apps require zero
    installation and configuration on the client’s side because they run on a web
    browser, and all the features of a web app are loaded as web elements.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 网络应用程序是许多编程项目的热门选择。它们最重要的好处是跨平台兼容性。它们可以在任何网络浏览器上运行，这意味着你可以在任何电脑、任何智能手机，甚至任何支持网络浏览器的电视上访问该应用程序。此外，由于网络应用程序在浏览器上运行，因此客户端无需安装和配置，所有网络应用程序的功能都作为网页元素加载。
- en: As you can tell, web apps provide the most attractive outlet for any business.
    In this section, I’ll show you how to build a web app by using streamlit, a third-party
    Python framework for web developments. Please note that this framework provides
    a wide range of features, and I won’t provide a comprehensive tutorial on using
    this framework. Instead, I’ll focus on implementing the features of our task management
    application in the form of a web app.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，网络应用程序为任何业务提供了最有吸引力的出口。在本节中，我将展示如何使用 streamlit，一个用于网络开发的第三方 Python 框架，来构建网络应用程序。请注意，这个框架提供了一系列功能，我不会提供使用此框架的全面教程。相反，我将专注于以网络应用程序的形式实现我们的任务管理应用程序的功能。
- en: 14.4.1 Understanding the essential features of streamlit
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.4.1 理解 streamlit 的基本功能
- en: To use streamlit to create the web app, you should have a good understanding
    of this framework. In this section, I’ll introduce essential knowledge of this
    framework.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 streamlit 创建网络应用程序，你应该对这个框架有一个很好的理解。在本节中，我将介绍这个框架的基本知识。
- en: After we install streamlit in our virtual environment (taskier-env; section
    14.1), in addition to using the framework in our Python files, the installation
    of streamlit includes using command line-based functionalities—that is, we can
    use a command-line tool as the interface to invoke actions relevant to manipulating
    web apps built with streamlit. The most important command is streamlit run taskier_app.py.
    As indicated by its name, this command launches a web app running in your default
    web browser, using taskier_app.py as the source file.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的虚拟环境中（taskier-env；第 14.1 节）安装 streamlit 之后，除了在我们的 Python 文件中使用该框架之外，streamlit
    的安装还包括使用基于命令行的功能——也就是说，我们可以使用命令行工具作为接口来调用与操作使用 streamlit 构建的网络应用程序相关的操作。最重要的命令是
    streamlit run taskier_app.py。正如其名称所示，此命令使用 taskier_app.py 作为源文件，在默认网络浏览器中启动一个网络应用程序。
- en: The first essential feature of streamlit is converting a Python script file
    to a web app. That’s the major reason why streamlit is a popular web framework
    choice for Python developers. If you know Python, you can use streamlit to build
    a web app.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Streamlit 的第一个基本功能是将 Python 脚本文件转换为网络应用程序。这就是为什么 streamlit 是 Python 开发者流行的网络框架选择的主要原因。如果你知道
    Python，你可以使用 streamlit 来构建网络应用程序。
- en: The other essential feature of streamlit is automatic layout of web elements,
    such as buttons and text-input boxes. This framework provides common web elements
    (widgets) out of the box. Figure 14.6 shows the available widgets implemented
    in the framework. Please note that these widgets may change in the latest release
    of the streamlit framework.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Streamlit 的另一个基本功能是自动布局网页元素，如按钮和文本输入框。这个框架提供了一些常见的网页元素（小部件）。图 14.6 展示了框架中实现的可用小部件。请注意，这些小部件可能在
    streamlit 框架的最新版本中有所变化。
- en: '![CH14_F06_Cui](../Images/CH14_F06_Cui.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![CH14_F06_Cui](../Images/CH14_F06_Cui.png)'
- en: Figure 14.6 The available widgets in the streamlit framework. The six categories
    are Clickable (buttons), Single or Multiple Choice, Numeric Data, Textual Data,
    Multimedia, and Date and Time.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.6 streamlit 框架中的可用小部件。六个类别是可点击的（按钮）、单选或复选、数值数据、文本数据、多媒体和日期和时间。
- en: I won’t discuss how to use the widgets because they’re straightforward to use;
    also, you can find instructions at [https://streamlit.io/](https://streamlit.io/).
    I’ll show some screenshots in section 14.4.2\. You’ll see that when you use these
    widgets in your script, you specify the widget type with the necessary configurations,
    such as the text shown on the button, leaving the heavy work of laying out the
    elements to the framework.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会讨论如何使用小部件，因为它们的使用很简单；此外，您可以在 [https://streamlit.io/](https://streamlit.io/)
    找到说明。我将在 14.4.2 节中展示一些截图。您会看到，当您在脚本中使用这些小部件时，您需要指定小部件类型以及必要的配置，例如按钮上显示的文本，将元素布局的繁重工作留给框架。
- en: 'Another notable feature of the streamlit framework is the reloading of the
    entire script linearly (from top to bottom) when there is any change in the input,
    such as users having selected an option of the radio widget. This feature is the
    core of this framework’s execution model. Some beginning users of this framework
    may be frustrated because their experience of using a web app has taught them
    that a page doesn’t reload automatically when they click an option of the radio
    widget. Although it can be a drawback in some use cases, we have a workaround
    to address this problem: session state (section 14.4.3).'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Streamlit 框架的另一个显著特点是，当输入有任何变化时（例如，用户选择了单选小部件的选项），整个脚本将线性地（从上到下）重新加载。这个特性是这个框架执行模型的核心。一些初学者可能会感到沮丧，因为他们的使用
    Web 应用的经验告诉他们，当点击单选小部件的选项时，页面不会自动重新加载。尽管在某些用例中这可能是一个缺点，但我们有一个解决方案来解决这个问题：会话状态（第
    14.4.3 节）。
- en: 14.4.2 Understanding the app’s interface
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.4.2 理解应用程序的界面
- en: Before I show you the code for creating the web app, you need to see what the
    app looks like. This section shows the app’s interface.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在我向您展示创建 Web 应用程序的代码之前，您需要看到应用程序的外观。本节展示了应用程序的界面。
- en: The first page shows the list of tasks (figure 14.7). On the left side is a
    sidebar, which includes the menu options, such as showing tasks and choosing the
    database option. On the right side is the main content area. In this case, the
    content is the list of tasks. You can choose how to sort and filter the list of
    tasks by using the sidebar. For clarity, we show the sort/filter menu only when
    we show the list of tasks.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 第一页显示任务列表（图 14.7）。左侧是一个侧边栏，包括菜单选项，如显示任务和选择数据库选项。右侧是主要内容区域。在这种情况下，内容是任务列表。您可以使用侧边栏选择如何排序和过滤任务列表。为了清晰起见，我们仅在显示任务列表时显示排序/过滤菜单。
- en: '![CH14_F07_Cui](../Images/CH14_F07_Cui.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![CH14_F07_Cui](../Images/CH14_F07_Cui.png)'
- en: Figure 14.7 The interface for showing the list of tasks. The main interface
    includes a sidebar, which shows menu information. The main content area shows
    the tasks.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.7 显示任务列表的界面。主界面包括一个侧边栏，显示菜单信息。主要内容区域显示任务列表。
- en: For each task in the list, you can click the View Detail button to display the
    details of the task (figure 14.8). On the left side, we’re adding some widgets,
    which allow users to delete the task. On the right side, we’re showing the task’s
    details in the main content area, which includes an Update Task button for saving
    the updated task to the database.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 对于列表中的每个任务，您都可以点击“查看详情”按钮来显示任务的详细信息（图 14.8）。在左侧，我们添加了一些小部件，允许用户删除任务。在右侧，我们在主要内容区域显示任务的详细信息，其中包括一个“更新任务”按钮，用于将更新后的任务保存到数据库中。
- en: '![CH14_F08_Cui](../Images/CH14_F08_Cui.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![CH14_F08_Cui](../Images/CH14_F08_Cui.png)'
- en: Figure 14.8 The interface for showing a task’s details. In the sidebar, we display
    some widgets that allow users to delete the task. In the main content area, we
    display the task’s details.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.8 显示任务详细信息的界面。在侧边栏中，我们显示一些小部件，允许用户删除任务。在主要内容区域，我们显示任务的详细信息。
- en: If users click the New Task button on the sidebar, they’ll be directed to a
    form where they can create a task (figure 14.9). In the main content area, we’re
    displaying a form, which collects the data needed for a new task. Users click
    Save Task to save the record to the database.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户在侧边栏中点击“新建任务”按钮，他们将被引导到一个表单，在那里他们可以创建任务（图 14.9）。在主要内容区域，我们显示一个表单，收集创建新任务所需的数据。用户点击“保存任务”将记录保存到数据库中。
- en: '![CH14_F09_Cui](../Images/CH14_F09_Cui.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![CH14_F09_Cui](../Images/CH14_F09_Cui.png)'
- en: Figure 14.9 The interface for creating a new task. After entering the data,
    users can click the Save Task button to save it to the database.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.9 创建新任务的界面。输入数据后，用户可以点击“保存任务”按钮将其保存到数据库中。
- en: 14.4.3 Tracking user activities using session state
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.4.3 使用会话状态跟踪用户活动
- en: As a loose definition to facilitate the discussion of streamlit, I refer to
    a *session* as users accessing a web app in a web browser, typically in the form
    of a tab in modern browsers. While the tab is active without being refreshed,
    we can use session state to track users’ activity, stored as key-value pairs.
    This section shows what data we need to track for our app.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于讨论streamlit，我将用户通过网页浏览器访问网络应用称为一个“会话”，通常在现代浏览器中以标签页的形式出现。当标签页处于活动状态且未刷新时，我们可以使用会话状态来跟踪用户的活动，这些活动以键值对的形式存储。本节展示了我们需要为我们的应用跟踪哪些数据。
- en: 'We’ll create the taskier_app.py file as the script for our web app, and all
    the code discussed in this section will go into this file unless noted otherwise.
    At the top of this file, we import the dependencies. We’ll talk about these dependencies
    when they become relevant in the context of the code; for now, we’ll focus on
    streamlit. As a convention, we typically use st as an alias for streamlit, making
    it easier to refer to the framework. We call st.session_state to retrieve session
    data, for example:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建taskier_app.py文件作为我们网络应用的脚本，本节中讨论的所有代码都将放入此文件，除非另有说明。在文件顶部，我们导入依赖项。当这些依赖项在代码的上下文中变得相关时，我们将讨论这些依赖项；现在，我们将专注于streamlit。按照惯例，我们通常使用st作为streamlit的别名，这使得引用框架更加容易。我们调用st.session_state来检索会话数据，例如：
- en: '[PRE26]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Besides dependencies, this code includes variables that we refer to often in
    the app, and all of these variables are concerned either with setting up the sidebar
    or the session state.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 除了依赖项之外，此代码还包括我们在应用中经常引用的变量，所有这些变量都与设置侧边栏或会话状态有关。
- en: 'The first item that we want to track in a session is the selected menu option.
    We want to show three main pages (section 14.4.2): the list of tasks, a task’s
    details, and a form for creating a new task. Because a session state stores data
    in the form of key-value pairs, for this item, we’ll call the key selected_menu_option,
    which saves one of these three menu options that are implemented as an enumeration
    class in the taskier_app_helper.py file:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在会话中，我们想要跟踪的第一个项目是选定的菜单选项。我们希望显示三个主要页面（第14.4.2节）：任务列表、任务详情以及创建新任务的表单。由于会话状态以键值对的形式存储数据，对于这个项目，我们将键命名为selected_menu_option，它保存了这三个菜单选项中的一个，这些选项在taskier_app_helper.py文件中实现为一个枚举类：
- en: '[PRE27]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You may notice that we define the TaskierFilterKey class in the helper file.
    This class pertains to the second item we’re tracking in session state: how users
    choose to sort and filter the list of tasks. Users can view only tasks with an
    urgency level of 3, for example. These sorting and filtering parameters are saved
    as a dict object by means of the key sorting_params in session state.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到我们在辅助文件中定义了TaskierFilterKey类。这个类与我们正在会话状态中跟踪的第二个项目相关：用户如何选择对任务列表进行排序和过滤。例如，用户只能查看紧急程度为3的任务。这些排序和过滤参数通过会话状态中的key
    sorting_params以字典对象的形式保存。
- en: Note We could have used two dict objects to track sorting and filtering parameters
    separately. But many web apps, including ours, have the same user interface for
    filtering and sorting. It’s cleaner for us to use one dict object to track these
    parameters generated from a single user interface. Unless I specify otherwise,
    I refer to sorting and filtering parameters interchangeably.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们可以使用两个字典对象分别跟踪排序和过滤参数。但许多网络应用，包括我们的应用，都有相同的过滤和排序用户界面。对我们来说，使用一个字典对象来跟踪由单个用户界面生成的这些参数会更简洁。除非我明确说明，否则我将排序和过滤参数互换使用。
- en: 'When the user wants to view a task’s details, we need to track which task the
    user is viewing. In session state, we use the working_task key to store this task,
    which is an instance of the Task class. As we need to update several key-value
    pairs in a variety of functions in the session, it’s a good idea to define a function
    for this job in the taskier_ app.py file:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户想要查看任务详情时，我们需要跟踪用户正在查看哪个任务。在会话状态中，我们使用working_task键来存储这个任务，它是一个Task类的实例。由于我们需要在会话中的多个函数中更新多个键值对，因此在taskier_app.py文件中定义一个用于此任务的函数是个好主意：
- en: '[PRE28]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can use the update_session_tracking function to update the values for the
    corresponding keys. Notably, streamlit runs the entire script from top to bottom
    whenever any change in user input occurs. Thus, we want to set the keys to their
    initial values only when the session doesn’t have these keys. If these keys have
    been set, we don’t want to override their existing values, which we use to track
    users’ activity. The following code snippet shows how we set the initial session
    state:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 update_session_tracking 函数来更新对应键的值。值得注意的是，每当用户输入发生变化时，streamlit 都会从头到尾运行整个脚本。因此，我们只想在会话没有这些键时将键设置为它们的初始值。如果这些键已经设置，我们不想覆盖它们现有的值，这些值用于跟踪用户的活动。以下代码片段显示了如何设置初始会话状态：
- en: '[PRE29]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Because we use streamlit to run the file as a script, it’s good practice to
    use if __name__ == "__main__" at the end of the file in case we want to use this
    file as a module, as shown in the following listing.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用 streamlit 将文件作为脚本运行，因此将 if __name__ == "__main__" 放在文件末尾是一个好习惯，以防我们想将此文件作为模块使用，如以下列表所示。
- en: Listing 14.9 Calling the functions to create the web app
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14.9 调用创建网络应用程序的函数
- en: '[PRE30]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ❶ Initiates the session
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 启动会话
- en: As annotated in listing 14.9, we call the init_session function, which sets
    up the session state that can track users’ activity. The next function we call
    is setup_sidebar, discussed in section 14.4.4.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如列表 14.9 所注解，我们调用 init_session 函数，该函数设置可以跟踪用户活动的会话状态。我们接下来调用的函数是 setup_sidebar，这在
    14.4.4 节中讨论过。
- en: 14.4.4 Setting up the sidebar
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.4.4 设置侧边栏
- en: We typically use a sidebar to show menu or optional configuration settings.
    In this section, I’ll show how to set up the sidebar for our app. We configure
    the sidebar by calling the setup_sidebar function, as shown in the next listing.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常使用侧边栏来显示菜单或可选配置设置。在本节中，我将展示如何为我们的应用程序设置侧边栏。我们通过调用 setup_sidebar 函数来配置侧边栏，如下一列表所示。
- en: Listing 14.10 Setting up the sidebar
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14.10 设置侧边栏
- en: '[PRE31]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ❶ Adds a button
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 添加一个按钮
- en: ❷ Adds a radio
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 添加一个单选按钮
- en: ❸ Adds a divider
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 添加一个分隔符
- en: Concept Markdown is a lightweight markup language for creating formatted text.
    In these examples, we use three underlines ___, which translate to a divider widget
    that forms a visual separator between sections.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 概念 Markdown 是一种轻量级标记语言，用于创建格式化文本。在这些示例中，我们使用三个下划线 ___, 它们转换为一个分隔小部件，用于在部分之间形成视觉分隔。
- en: 'Listing 14.10 is the first time that we add widgets to our web app. In general,
    we add a widget in the following syntax: st.widget_name(widget_label, value_or_options,
    key=widget_id, on_click=on_click_if_applicable, args=args_if_any). For a sidebar,
    we can use sidebar.widget_name. Using the button and radio widgets as examples,
    figure 14.10 illustrates the anatomy of the pertinent code.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14.10 是我们第一次向我们的网络应用程序添加小部件。一般来说，我们按照以下语法添加小部件：st.widget_name(widget_label,
    value_or_options, key=widget_id, on_click=on_click_if_applicable, args=args_if_any)。对于侧边栏，我们可以使用
    sidebar.widget_name。以按钮和单选按钮小部件为例，图 14.10 展示了相关代码的结构。
- en: '![CH14_F10_Cui](../Images/CH14_F10_Cui.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![CH14_F10_Cui](../Images/CH14_F10_Cui.png)'
- en: Figure 14.10 Dissecting the code for adding a button and a radio in streamlit.
    Calling st.button adds a button to the web page and returns a Boolean that indicates
    the button’s click status. Calling st.radio adds a radio to the web page and returns
    an integer that indicates the selected option’s index. Each function includes
    additional arguments that configure the widgets.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.10 解构在 streamlit 中添加按钮和单选按钮的代码。调用 st.button 在网页上添加一个按钮，并返回一个布尔值，表示按钮的点击状态。调用
    st.radio 在网页上添加一个单选按钮，并返回一个整数，表示所选选项的索引。每个函数都包括额外的参数，用于配置小部件。
- en: When we add a widget, such as a radio (figure 14.10), we can optionally use
    the return value of the function call. st.radio adds the radio, for example, and
    when users pick an option, we can obtain the index from this function call. In
    our case, we use this index to know which database option is chosen by calling
    the set_db_option function (listing 14.1). When the database option is selected,
    we’ll configure the database behind the scenes, such as by creating the SQLite
    database and adding the task table. Related to this widget, to help you interact
    with this app from the learning perspective, I’m adding a Load Data to Database
    button to add more data to the database.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们添加一个小部件，如单选按钮（图14.10）时，我们可以选择使用函数调用的返回值。例如，st.radio添加单选按钮，当用户选择一个选项时，我们可以从该函数调用中获取索引。在我们的情况下，我们使用这个索引通过调用set_db_option函数（列表14.1）来知道哪个数据库选项被选中。当数据库选项被选中时，我们将在幕后配置数据库，例如通过创建SQLite数据库并添加任务表。与此小部件相关，为了帮助您从学习角度与该应用程序交互，我添加了一个“将数据加载到数据库”按钮，以便向数据库添加更多数据。
- en: 'When users elect to show the tasks, we display the options for sorting and
    filtering by calling the setup_filters function. In case you wonder whether it’s
    necessary to make this function private (we’re writing a script for developers,
    not for other users), it’s fine to name functions without using an underscore
    prefix, which would otherwise reduce readability:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择显示任务时，我们通过调用setup_filters函数来显示排序和过滤选项。如果您想知道是否需要将此函数设为私有（我们正在为开发者编写脚本，而不是为其他用户），不使用下划线前缀来命名函数是可以的，否则这会降低可读性：
- en: '[PRE32]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Because the sorting and filtering parameters belong to the same conceptual
    category, I use an expander widget named Sort and Filter. In the expander, we
    define five widgets: a selectbox to pick one of the tasks’ attributes (title,
    description, urgency, status, or completion note) for sorting; a radio to determine
    the sort order (descending or ascending); a multiselect to specify the selected
    statuses; another multiselect to specify the selected urgency levels; and a text_input
    to filter tasks with the specified content. Figure 14.11 shows how to select a
    subset of tasks by specifying these parameters.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 由于排序和过滤参数属于同一概念类别，我使用了一个名为“Sort and Filter”的展开小部件。在展开小部件中，我们定义了五个小部件：一个选择框用于选择用于排序的任务属性（标题、描述、紧急程度、状态或完成备注）；一个单选按钮用于确定排序顺序（降序或升序）；一个多选框用于指定选定的状态；另一个多选框用于指定选定的紧急程度级别；以及一个文本输入用于过滤具有指定内容的任务。图14.11显示了如何通过指定这些参数来选择任务的一个子集。
- en: '![CH14_F11_Cui](../Images/CH14_F11_Cui.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![CH14_F11_Cui](../Images/CH14_F11_Cui.png)'
- en: Figure 14.11 Selecting a subset of tasks by using the Sort and Filter widget.
    After users specify the sorting and filtering parameters, the tasks are retrieved
    based on these criteria and displayed in the main content area.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.11 使用“Sort and Filter”小部件选择任务的一个子集。用户指定排序和过滤参数后，根据这些标准检索任务，并在主要内容区域显示。
- en: 'When the user views a task’s detail in the main content area, we show the deletion
    option in the sidebar by calling the setup_deletion function:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在主要内容区域查看任务的详细信息时，我们通过调用setup_deletion函数在侧边栏中显示删除选项：
- en: '[PRE33]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this function, we retrieve the task by accessing the session’s working_task
    key. To prevent users from deleting a task accidentally, we require them to type
    the task’s title before removing it from the database. The new feature calls the
    success and error functions, which are useful for providing real-time positive
    and negative feedback on the actions the users performed (figure 14.12).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在此函数中，我们通过访问会话的working_task键来检索任务。为了防止用户意外删除任务，我们要求他们在从数据库中删除任务之前输入任务的标题。新功能调用成功和错误函数，这些函数对于提供对用户执行的操作的实时正面和负面反馈非常有用（图14.12）。
- en: '![CH14_F12_Cui](../Images/CH14_F12_Cui.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![CH14_F12_Cui](../Images/CH14_F12_Cui.png)'
- en: Figure 14.12 Success and error feedback in the web app. We call st.success to
    provide positive feedback and st.error to provide negative feedback.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.12 网页应用程序中的成功和错误反馈。我们调用st.success来提供正面反馈，调用st.error来提供负面反馈。
- en: 14.4.5 Showing the tasks
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.4.5 显示任务
- en: In a task management app, it’s useful to show the list of available tasks that
    users can work on. Thus, the page that shows the tasks is important. This section
    shows how to implement this feature by using streamlit. In listing 14.9, we called
    the show_tasks function to configure the web elements for showing the tasks. The
    next listing shows how the show_tasks function is implemented.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在任务管理应用中，显示用户可以工作的可用任务列表是有用的。因此，显示任务的页面非常重要。本节展示了如何使用streamlit实现此功能。在列表14.9中，我们调用了show_tasks函数来配置显示任务的Web元素。下一个列表展示了show_tasks函数的实现。
- en: Listing 14.11 Showing the tasks in the web app
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14.11 在Web应用中显示任务
- en: '[PRE34]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: ❶ Retrieves the data
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 获取数据
- en: ❷ Creates two columns as a grid for clearer display
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建两列作为网格以实现更清晰的显示
- en: ❸ Displays the data
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 显示数据
- en: This code has two parts. The first part retrieves the data, with and without
    using the sorting and filtering parameters, and the second part displays the data
    by using the widgets.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码有两部分。第一部分检索数据，包括使用和不使用排序和过滤参数的情况，第二部分通过使用小部件显示数据。
- en: 'The first part of listing 14.11 involves two steps:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14.11的第一部分涉及两个步骤：
- en: '*Obtain the filtering parameters from user input by calling the* get_reading_params
    *function.* We’ll discuss this function later in this section.'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*通过调用get_reading_params函数从用户输入中获取过滤参数。* 我们将在本节的后面讨论这个函数。'
- en: '*Sort the tasks based on the sorting parameters provided.* Because we use list,
    a mutable object (section 3.1), to store tasks, we can sort the tasks by using
    the sort method (section 3.2). Because the sorting key can change, such as from
    title to desc, it can be tedious if we’re creating different lambda functions
    as the key argument, such as lambda x: x.title to sort by the title and lambda
    x: x.urgency to sort by the urgency level. Thus, we’re using a generic approach
    to retrieve the corresponding attribute dynamically: lambda x: getattr(x, sorting_key).'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*根据提供的排序参数对任务进行排序。* 由于我们使用列表（第3.1节），一个可变对象来存储任务，我们可以通过使用排序方法（第3.2节）对任务进行排序。因为排序键可能会改变，例如从标题到降序，如果我们需要为每个键参数创建不同的lambda函数，比如lambda
    x: x.title来按标题排序和lambda x: x.urgency来按紧急程度排序，那么这可能会变得繁琐。因此，我们采用了一种通用方法来动态检索相应的属性：lambda
    x: getattr(x, sorting_key)。'
- en: 'The second part of listing 14.11 uses applicable widgets to display the tasks.
    Here, I’m using a new widget called columns, which is an invisible widget used
    for organizational purposes. Specifically, the call st.columns([3, 1]) creates
    two columns with a width ratio of 3:1, and the return value of this call is a
    tuple that represents these two columns. Using tuple unpacking, we’re getting
    the references to them, named col1 and col2, and we can add widgets to the columns.
    One of these widgets is the View Detail button, and when it’s clicked, we show
    the details for the task in the main content area, as discussed next in section
    14.4.6\. Here’s how the get_reading_params function works:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14.11的第二部分使用适用的小部件来显示任务。在这里，我使用了一个新的小部件，称为columns，这是一个用于组织目的的不可见小部件。具体来说，调用st.columns([3,
    1])创建了两列，宽度比为3:1，这个调用的返回值是一个表示这两列的元组。通过元组解包，我们获得了它们的引用，分别命名为col1和col2，我们可以向这些列添加小部件。其中一个小部件是查看详情按钮，当它被点击时，我们将在主要内容区域显示任务的详情，如第14.4.6节所述。以下是get_reading_params函数的工作方式：
- en: '[PRE35]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As shown in figure 14.11, users can configure three filtering parameters: status,
    urgency, and content. Everything should be straightforward in this code snippet
    except for one new technique that we haven’t seen before: *assignment expression**.*
    This technique uses the := symbol (nicknamed the *walrus operator*), which was
    introduced in Python 3.8\. The code selected_statuses := filter_params[TaskierFilterKey.SELECTED_STATUSES.value],
    for example, means that we’re trying to retrieve the value of the selected_statuses
    key in the filter_params dictionary and assign it to a variable called selected_statuses.
    If this value isn’t None, we’re going to run the code within the if statement.
    Typically, an assignment is a statement, so we can’t use it in an if statement,
    which requires the clause to be an expression. As you can see, assignment expression
    does two things: assigns a value and evaluates it.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如图14.11所示，用户可以配置三个过滤参数：状态、紧急程度和内容。在这个代码片段中，除了我们之前没有见过的**赋值表达式**之外，一切都应该很简单。这种技术使用:=符号（昵称“海象操作符”），它在Python
    3.8中被引入。例如，代码selected_statuses := filter_params[TaskierFilterKey.SELECTED_STATUSES.value]意味着我们正在尝试检索filter_params字典中selected_statuses键的值，并将其分配给名为selected_statuses的变量。如果这个值不是None，我们将运行if语句内的代码。通常，赋值是一个语句，所以我们不能在需要子句为表达式的if语句中使用它。正如你所看到的，赋值表达式做两件事：分配一个值并评估它。
- en: Reminder An expression evaluates to an object, whereas a statement performs
    an action without returning a value. See section 2.1.3 for a detailed discussion
    of the differences between expressions and statements.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒：表达式求值得到一个对象，而语句执行一个动作而不返回值。请参阅第2.1.3节，以详细了解表达式和语句之间的差异。
- en: 14.4.6 Showing a task’s details
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.4.6 显示任务详情
- en: The list of tasks provides overall information for each task. We can display
    more detailed information about the task. This section shows how to address this
    need.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 任务列表为每个任务提供整体信息。我们可以显示有关任务的更详细信息。本节展示了如何满足这一需求。
- en: 'For the View Detail button, we set the on_click argument using the wants_task_
    detail function and the args argument using (task,). If a user clicks this button,
    we’ll call wants_task_detail(task):'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 对于查看详情按钮，我们使用wants_task_detail函数设置on_click参数，并使用(args参数)(task,)。如果用户点击此按钮，我们将调用wants_task_detail(task)：
- en: '[PRE36]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This function call does two things:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数调用做了两件事：
- en: It sets the task associated with the View Detail button as the current working
    task.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将关联到查看详情按钮的任务设置为当前工作任务。
- en: It changes the selected menu to show a task’s details. By changing the menu,
    when the web app reloads, we show the task detail page by calling the show_task_detail
    function, as shown in the next listing.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它更改选定的菜单以显示任务的详情。通过更改菜单，当Web应用程序重新加载时，我们通过调用show_task_detail函数来显示任务详情页面，如下一列表所示。
- en: Listing 14.12 Showing a task’s detail
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14.12 显示任务详情
- en: '[PRE37]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Note three things in listing 14.12:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表14.12中注意以下三点：
- en: We’re using the form widget to group individual widgets, such as slider and
    text_input. The form widget can remember the user’s input for its contained widgets
    so that when the web page is reloaded, it shows the user’s input.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在使用表单小部件来组合单个小部件，例如滑块和文本输入。表单小部件可以记住其包含小部件的用户输入，这样当网页重新加载时，它会显示用户的输入。
- en: When we’re done with the updating, we call the form_submit_button, which adds
    the Submit button to the form and uses the return value, which is True when the
    button is clicked.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们完成更新后，我们调用form_submit_button，它将提交按钮添加到表单中，并使用返回值，当按钮被点击时返回True。
- en: When we’re submitting this form to update the record in our database, we’re
    using the try...except...else... statement (sections 12.3 and 12.4). We use exception
    handling here because it’s possible that the user may have deleted the task by
    using the deletion option on the sidebar or may have used another tab to delete
    the task.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们提交这个表单以更新数据库中的记录时，我们使用try...except...else...语句（第12.3和12.4节）。我们在这里使用异常处理，因为用户可能已经通过侧边栏上的删除选项删除了任务，或者可能已经使用另一个标签页删除了任务。
- en: Please note that in an actual web app, you may not want to design your interface
    this way. If the user has deleted an item, you should direct them to a page that
    doesn’t show the deleted item. I provide this example purely for demonstration
    purposes to show how to use exception handling in a project.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在实际的Web应用程序中，你可能不希望以这种方式设计你的界面。如果用户已删除项目，你应该引导他们到一个不显示已删除项目的页面。我提供这个示例纯粹是为了演示目的，以展示如何在项目中使用异常处理。
- en: 14.4.7 Creating a new task
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.4.7 创建新任务
- en: In the task management app, we allow users to create a new task. This section
    shows how to implement this feature in our web app. For this feature, we’re defining
    the show_new_task_entry function, as the following listing shows.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在任务管理应用中，我们允许用户创建一个新任务。本节展示了如何在我们的Web应用中实现此功能。为此功能，我们定义了show_new_task_entry函数，如下面的列表所示。
- en: Listing 14.13 Creating a new task in the web app
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14.13 在Web应用中创建新任务
- en: '[PRE38]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As we did in the task detail page, we’re using the form widget for new task
    entry. What’s different from listing 14.12 is that we’re using the with statement
    for the form, creating a context manager (section 11.1). In the with statement,
    when we call st.text_input to create a text-input box, streamlit knows that the
    box should be placed within the form because of the context manager. By contrast,
    when we didn’t use a context manager in listing 14.12, we explicitly called form.text_input
    to add a text-input box to the form. Both approaches—using and not using a context
    manager—are acceptable.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在任务详情页中所做的那样，我们使用表单小部件进行新任务输入。与列表14.12的不同之处在于，我们使用with语句为表单创建上下文管理器（第11.1节）。在with语句中，当我们调用st.text_input创建文本输入框时，由于上下文管理器，streamlit知道该框应放置在表单内。相比之下，在列表14.12中没有使用上下文管理器时，我们明确调用form.text_input将文本输入框添加到表单中。这两种方法——使用和不使用上下文管理器——都是可接受的。
- en: 14.4.8 Organizing your project
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.4.8 组织你的项目
- en: We’ve seen how we implement our features individually. From the maintainability
    perspective, it’s essential to organize your project so that it’s easier for team
    members to read and locate the pertinent functionalities. In this section, I’ll
    show the best practice to organize your project by using streamlit to develop
    the web app. Because the final product is a web app, I’ll focus first on the script
    file taskier_app.py, which is responsible for creating the web app.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了我们如何单独实现我们的功能。从可维护性的角度来看，组织你的项目以便团队成员更容易阅读和定位相关功能是至关重要的。在本节中，我将展示使用streamlit开发Web应用的最佳实践来组织你的项目。因为最终产品是一个Web应用，所以我首先关注负责创建Web应用的脚本文件taskier_app.py，它负责创建Web应用。
- en: 'In general, this script consists of three components: dependencies, global
    variables, and functions for configuring the interface. For our web app, the script
    uses the Task class as its core data model. Although the script file is the only
    place to use the Task class in our app, we don’t want to put the class in the
    script file for two reasons:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，此脚本由三个组件组成：依赖项、全局变量和配置界面的函数。对于我们的Web应用，脚本使用Task类作为其核心数据模型。尽管脚本文件是我们应用中使用Task类的唯一地方，但我们不希望将类放在脚本文件中，原因如下：
- en: We’re making it hard to read the script file to understand how the web app is
    built because the Task class occupies considerable space in the code, and it doesn’t
    contribute to the web app’s interface.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使脚本文件难以阅读以了解Web应用是如何构建的，因为Task类在代码中占据了相当大的空间，而且它并没有对Web应用界面做出贡献。
- en: It would be inconvenient to use this class for other purposes, such as building
    a desktop app. Thus, it’s critical to use a separate file to implement our data
    model.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用此类进行其他目的，例如构建桌面应用，将非常不便。因此，使用单独的文件来实现我们的数据模型至关重要。
- en: 'When we use the data model in our app, we import it as a dependency. For the
    script file, we place the dependencies at the top of the file, as shown in the
    following code snippet. The dependencies not only serve the code in the script,
    but also provide important information that readers of the code (such as teammates)
    want to know, such as what libraries and packages the script uses:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在应用中使用数据模型时，我们将其作为依赖项导入。对于脚本文件，我们将依赖项放置在文件顶部，如下面的代码片段所示。依赖项不仅服务于脚本中的代码，还提供了代码读者（如队友）想要了解的重要信息，例如脚本使用了哪些库和包：
- en: '[PRE39]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As you may notice, we’re saving the TaskierMenuOption and TaskierFilterKey classes
    in a different file (taskier_app_helper.py) so that the taskier_app.py file includes
    only the code for building the web’s interface.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能注意到的，我们将TaskierMenuOption和TaskierFilterKey类保存在不同的文件（taskier_app_helper.py）中，以便taskier_app.py文件只包含构建Web界面的代码。
- en: After clarifying the organization of the dependencies, we can analyze the organization
    of the script file’s components. Figure 14.13 provides a graphic analysis.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在明确依赖项的组织结构后，我们可以分析脚本文件组件的组织结构。图14.13提供了图形分析。
- en: '![CH14_F13_Cui](../Images/CH14_F13_Cui.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![CH14_F13_Cui](../Images/CH14_F13_Cui.png)'
- en: 'Figure 14.13 The organization of the taskier_app.py file. The file has three
    components: dependencies, global variables, and configuration of the interface.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.13 taskier_app.py文件的组织。该文件有三个组件：依赖项、全局变量和界面配置。
- en: For the code that configures the interface, I’ve organized the functions based
    on their intended purposes. Related functions are grouped together. The code for
    session tracking is at the top because it’s the driving force for tracking user
    activity. In the middle are the functions for configuring the main content area.
    At the end are the functions that set up the sidebar.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 对于配置界面的代码，我已经根据其预期用途组织了函数。相关函数被分组在一起。会话跟踪的代码位于顶部，因为它是跟踪用户活动的驱动力。中间是配置主要内容区域的函数。最后是设置侧边栏的函数。
- en: 14.4.9 Running the app
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.4.9 运行应用程序
- en: 'We’ve completed the code and organized it nicely. It’s time to run the app
    and give it a try. (Please note that when you work on app development, you should
    run the app in a browser so that you can see the code’s performance in real time.)
    To run the app, enter the streamlit command in the command-line tool:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了代码并很好地组织了它。现在是时候运行应用程序并尝试一下了。（请注意，当您进行应用程序开发时，您应该在浏览器中运行应用程序，以便您可以看到代码的实时性能。）要运行应用程序，请在命令行工具中输入streamlit命令：
- en: '[PRE40]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Make sure that you run the command *after* you navigate to the directory where
    the taskier_app.py file is saved; otherwise, you need to specify the full path
    to the script file. You should see a new tab in your default browser, with our
    app running in the tab.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在导航到保存taskier_app.py文件的目录后运行命令*之后*；否则，您需要指定脚本的完整路径。您应该在默认浏览器中看到一个新标签页，其中运行着我们的应用程序。
- en: 14.4.10 Discussion
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.4.10 讨论
- en: It takes some time to get familiar with a framework such as streamlit. This
    section isn’t about the technicalities of using this framework. Instead, by building
    this web app, including its interface and its supporting data models, you saw
    how the techniques covered in the book contribute to a real project. Toward the
    end of this section, I showed you how to organize the project. Although this app
    is a toy project, it’s still important to organize your code in a readable, maintainable
    way.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉像streamlit这样的框架需要一些时间。本节不是关于使用此框架的技术细节。相反，通过构建这个网络应用程序，包括其界面及其支持的数据模型，您可以看到书中涵盖的技术是如何贡献于实际项目的。在本节的末尾，我向您展示了如何组织项目。尽管这个应用程序是一个玩具项目，但以可读性和可维护的方式组织代码仍然很重要。
- en: NOTE The company behind the streamlit framework allows you to publish your web
    app for free if you host your app’s code publicly on GitHub. You can find information
    about sharing your apps at [https://share.streamlit.io/](https://share.streamlit.io/).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：streamlit框架背后的公司允许您在GitHub上公开托管应用程序代码时免费发布您的网络应用程序。您可以在[https://share.streamlit.io/](https://share.streamlit.io/)找到有关共享应用程序的信息。
- en: 14.4.11 Challenge
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.4.11 挑战
- en: 'One of the global variables that we define is sorting_keys, which is a dict
    object: {"Title": "title", "Description": "desc", "Urgency": "urgency", "Status":
    "status", "Note": "completion_note"}. We use this object when we create a selectbox
    widget: st.selectbox("Sorted by", sorting_keys). In this call, we use the dict
    object as options for the widget. Why can we use a dict object instead of a list
    object, such as list(sorting_keys.keys())?'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '我们定义的一个全局变量是sorting_keys，它是一个字典对象：{"标题": "title", "描述": "desc", "紧急性": "urgency",
    "状态": "status", "备注": "completion_note"}。我们在创建selectbox小部件时使用此对象：st.selectbox("Sorted
    by", sorting_keys)。在这个调用中，我们使用字典对象作为小部件的选项。为什么我们可以使用字典对象而不是列表对象，例如list(sorting_keys.keys())？'
- en: Hint We can send any iterable to the selectbox as the options. A dict object
    is iterable, using its keys as the iterator’s elements by default.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：我们可以将任何可迭代对象发送到selectbox作为选项。字典对象是可迭代的，默认情况下使用其键作为迭代器的元素。
- en: Summary
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: You should create a virtual environment for each project, forming an isolated
    environment to manage the dependencies for the project and avoiding dependency
    requirements between projects.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您应该为每个项目创建一个虚拟环境，形成一个隔离的环境来管理项目的依赖项，避免项目之间的依赖项要求。
- en: The venv module is the built-in solution for managing virtual environments.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: venv模块是管理虚拟环境的内置解决方案。
- en: Some third-party tools, such as conda, allow you to have a distinct Python interpreter
    for each virtual environment, which can give you more flexibility if your projects
    use different versions of Python.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些第三方工具，如conda，允许您为每个虚拟环境拥有一个独立的Python解释器，如果您的项目使用不同的Python版本，这可以提供更多的灵活性。
- en: Data models should serve the business needs of your project. Thus, before writing
    code for implementing your data models, you should identify your needs.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据模型应该满足你项目的业务需求。因此，在编写实现数据模型的代码之前，你应该确定你的需求。
- en: Your code files should be readable. For a class, you should write docstrings
    for each method you’re defining.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的代码文件应该是可读的。对于一个类，你应该为每个你定义的方法编写文档字符串。
- en: SQLite is a lightweight database that requires no preconfiguration. You can
    create an SQLite database in all major operating systems, including those for
    portable devices such as smartphones.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite是一个轻量级数据库，无需预先配置。你可以在所有主流操作系统上创建SQLite数据库，包括智能手机等便携式设备的操作系统。
- en: Compared with CSV files, an SQLite database is a more formal database choice.
    I used a CSV file as a data source for tutorial purposes, but for a real project,
    you should always consider using a formal database.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与CSV文件相比，SQLite数据库是一个更正式的数据库选择。我使用CSV文件作为教程的数据源，但对于真实项目，你应该始终考虑使用正式的数据库。
- en: Web apps are great options for showcasing your projects, as they’re platform-agnostic.
    Python supports several web frameworks, including streamlit, which all Python
    developers can use to build a web app easily.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web应用是展示你项目的绝佳选择，因为它们是平台无关的。Python支持多个Web框架，包括streamlit，所有Python开发者都可以使用这些框架轻松构建Web应用。
- en: Although the project you created for this book is a tiny one, you should organize
    your files and their internal code. This is critical for improving readability
    and maintainability.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管你为这本书创建的项目很小，但你应该组织你的文件及其内部代码。这对于提高可读性和可维护性至关重要。
