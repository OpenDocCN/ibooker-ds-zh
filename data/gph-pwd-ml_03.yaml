- en: 2 Graph data engineering
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 图形数据工程
- en: The main challenges related to big data as input to machine learning
  id: totrans-1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与机器学习输入相关的主要大数据挑战
- en: How to handle big data analysis with graph models and graph databases
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用图模型和图数据库处理大数据分析
- en: The shape and features of a graph database
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图形数据库的形状和特征
- en: 'Chapter 1 highlighted the key role played by data in a machine learning project.
    As we saw, training the learning algorithm on a larger quantity of high-quality
    data increases the accuracy of the model more than fine tuning or replacing the
    algorithm itself. In an interview about big data [Coyle, 2016], Greg Linden, who
    invented the now widely used item-to-item collaborative filtering algorithm for
    Amazon, replied:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 第一章强调了数据在机器学习项目中的关键作用。正如我们所见，在大量高质量数据上训练学习算法比微调或替换算法本身更能提高模型的准确性。在一次关于大数据的访谈[Coyle,
    2016]中，发明了现在广泛使用的亚马逊项目到项目协同过滤算法的Greg Linden回答说：
- en: '*Big data is why Amazon’s recommendations work so well. Big data is what tunes
    search and helps us find what we need. Big data is what makes web and mobile intelligent.*'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*大数据是亚马逊推荐工作得如此之好的原因。大数据是调整搜索并帮助我们找到所需内容的原因。大数据是使网络和移动智能化的原因。*'
- en: 'In the past few years, we have been experiencing an exponential growth in the
    amount of data generated in a broad range of sectors: information technology,
    industry, healthcare, the Internet of Things (IoT), and others. Back in 2013,
    IBM estimated that 2.5 quintillion bytes of data were being created every day—which
    meant that 90% of the data in the world had been created in the previous two years
    [Johnson, 2013]. This data comes from everywhere: sensors used to gather climate
    information, posts to social media sites, digital pictures and videos, purchase
    transaction records, and cell-phone GPS signals, to name a few sources. This data
    is *big data*. Figure 2.1 presents some statistics on the current volume of data
    generated from well-known applications or platforms every single minute [Domo,
    2020].'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年里，我们在各个领域（信息技术、工业、医疗保健、物联网（IoT）等）产生的数据量呈指数级增长。回到2013年，IBM估计每天有2500亿字节的数据被创造——这意味着世界上90%的数据在过去两年内已经被创造出来[Johnson,
    2013]。这些数据来自各个地方：用于收集气候信息的传感器、社交媒体网站上的帖子、数字图片和视频、购买交易记录以及手机GPS信号，仅举几例。这些数据是*大数据*。图2.1展示了每分钟从知名应用程序或平台产生的当前数据量的统计数据[Domo,
    2020]。
- en: '![CH02_F01_Negro](../Images/CH02_F01_Negro.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F01_Negro](../Images/CH02_F01_Negro.png)'
- en: Figure 2.1 The data generated every minute in 2020 (courtesy of Domo, Inc.)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 2020年每分钟产生的数据（由Domo, Inc.提供）
- en: What caused the dramatic change over the past decade was neither the explosion
    of the internet-using population nor the creation of new systems like data sensors.
    The change was generated by a greater awareness of the importance of data as a
    source of knowledge. The strong desire to know more about users, customers, businesses,
    and organizations of all kinds generated new needs and new requirements for data
    collection, gathering, and processing. This desire has led to a change in the
    way in which data scientists collect data for analysis. Years ago, they had to
    scrabble around in unorganized and dirty data silos for data in some weird format.
    Now that companies have discovered the value hidden in the data they produce,
    data scientists lead the data generation and collection efforts.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 过去十年发生的巨大变化既不是互联网用户数量的激增，也不是像数据传感器这样的新系统的创造。这种变化是由对数据作为知识来源重要性的认识增强所引发的。对了解用户、客户、各种企业和组织的强烈愿望产生了新的数据收集、聚集和处理需求。这种愿望导致了数据科学家收集分析数据方式的变化。几年前，他们不得不在一些奇怪格式的非组织化和脏乱的数据孤岛中寻找数据。现在，随着公司发现了他们产生的数据中隐藏的价值，数据科学家领导了数据生成和收集的努力。
- en: Whereas a travel website once might have collected only the star ratings for
    a simple recommendation engine, for example, now it uses the informational power
    available in every user-provided review as a more detailed source of knowledge.
    This mental process generates a kind of virtuous loop (figure 2.2) that is capable
    of collecting more data in each cycle.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个旅游网站曾经可能只为简单的推荐引擎收集星级评分，而现在它使用每个用户提供的评论中的信息力量作为更详细的知识来源。这个过程产生了一种良性循环（图2.2），能够在每个循环中收集更多数据。
- en: '![CH02_F02_Negro](../Images/CH02_F02_Negro.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F02_Negro](../Images/CH02_F02_Negro.png)'
- en: Figure 2.2 The data collection loop
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 数据收集循环
- en: This unprecedented availability of data sources allows the machine learning
    practitioner to access a tremendous amount of data, available in multiple shapes.
    But if finding and accessing this data is relatively easy, storing and managing
    it can be a completely different story. Specifically, for machine learning processes,
    it is necessary to identify and extract the set of relevant *features*, or measurable
    properties or characteristics of the observed phenomenon. Choosing informative,
    discriminating, and independent features is a crucial step in creating effective
    learning algorithms, because these features define the input structure for the
    training phase of the algorithm and determine the accuracy of the predictions.
    The requirements for the list of features change according to the class of the
    algorithm, but in general terms, more accurate data generates better models. If
    you could run a forecast taking into account 300 factors rather than 6, you could
    predict demand better. With more factors, however, you run into the risk of overfitting.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这种前所未有的数据源可用性使得机器学习从业者能够访问大量以多种形式存在的数据。但尽管找到和访问这些数据相对容易，存储和管理它们可能完全不同。特别是对于机器学习过程，有必要识别和提取与观察现象相关的*特征*，即可测量的属性或特征。选择信息丰富、区分度高和独立的特征是创建有效学习算法的关键步骤，因为这些特征定义了算法训练阶段的输入结构，并决定了预测的准确性。特征列表的要求根据算法类别而变化，但一般来说，更准确的数据会产生更好的模型。如果你能运行一个考虑300个因素而不是6个因素的预测，你就能更好地预测需求。然而，随着因素的增多，你也会面临过拟合的风险。
- en: 'The life cycle of the systems that analyze big data is composed of a series
    of steps that start with collecting data from multiple data sources. Specialized
    tools and frameworks are required to ingest the data from different sources into
    the defined big data storage. The data is stored in specific storage solutions
    (such as distributed filesystems or nonrelational databases) that are designed
    to scale. More formally, the steps required to accomplish these tasks can be summarized
    as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 分析大数据的系统生命周期由一系列步骤组成，这些步骤从从多个数据源收集数据开始。需要专门的工具和框架将来自不同源的数据摄入到定义的大数据存储中。数据存储在特定的存储解决方案中（如分布式文件系统或非关系型数据库），这些解决方案旨在可扩展。更正式地说，完成这些任务所需的步骤可以总结如下：
- en: '*Collect.* Data from multiple data sources is gathered and collected.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*收集.* 从多个数据源收集和汇总数据。'
- en: '*Store.* The data is stored in a proper way in a single (or occasionally more
    than one) easy-to-access data store so that it’s ready for the next phases.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*存储.* 数据以适当的方式存储在单个（或偶尔超过一个）易于访问的数据存储中，以便为下一阶段做好准备。'
- en: '*Clean.* The data is merged, cleaned, and (whenever possible) normalized by
    using a unified and homogeneous schema.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*清洁.* 数据通过使用统一和一致的架构进行合并、清洗，并在可能的情况下进行归一化。'
- en: '*Access.* The data is available. Multiple views or access patterns are provided
    to simplify and speed access to the dataset that will be used for training purposes.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*访问.* 数据可用。提供多种视图或访问模式，以简化并加快用于训练目的的数据集的访问。'
- en: 'This chapter focuses on the last three of these four steps: storing, cleaning,
    and accessing the data. The chapter describes the main characteristics of big
    data and discusses the methods to handle it. Specific approaches based on graph
    models and graph databases are illustrated in detail, with best practices.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍这四个步骤中的最后三个：存储、清洗和访问数据。本章描述了大数据的主要特征，并讨论了处理大数据的方法。详细介绍了基于图模型和图数据库的特定方法，并提供了最佳实践。
- en: 2.1 Working with big data
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 处理大数据
- en: To tame the beast—to define the requirements for a big data analytics platform—we
    need to know it. Let’s consider the underlying characteristics that qualify big
    data as *big*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了驯服这个巨兽——定义大数据分析平台的需求——我们需要了解它。让我们考虑使大数据成为“大”的基本特征。
- en: 'In 2001 (yes, more than 20 years ago!), Doug Laney, an analyst with the META
    Group, published a research note titled “3D Data Management: Controlling Data
    Volume, Velocity, and Variety” [Laney, 2001]. Although the term itself does not
    appear in Laney’s note, a decade later the *three Vs*—volume, velocity, and variety—have
    become the generally accepted three defining dimensions of big data.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在2001年（是的，超过20年前！），META Group的分析师道格·兰尼（Doug Laney）发表了一篇题为“3D数据管理：控制数据量、速度和多样性”的研究报告[Laney,
    2001]。尽管这个术语本身并没有出现在兰尼的报告里，但十年后，“三个V”——量、速度和多样性——已经成为大数据普遍接受的三维定义维度。
- en: 'Later, another dimension was added: *veracity*, referring to the quality, accuracy,
    or truthfulness of the dataset or data source. With the advent of new, untrusted,
    and unverified data sources, such as the user-generated content in Web 2.0, the
    reliability and quality of the information gathered became a big concern, leading
    to the general acceptance of veracity as a valuable, important dimension of big
    data platforms. Figure 2.3 recaps the main aspects of the *four Vs*, which are
    described in more detail in the following sections.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，又增加了一个维度：“真实性”，指的是数据集或数据源的质量、准确性或真实性。随着新的、不可信和未经验证的数据源的出现，例如Web 2.0中的用户生成内容，收集到的信息的可靠性和质量成为了一个大问题，导致真实性作为大数据平台的一个有价值的、重要的维度被普遍接受。图2.3回顾了“四个‘V’”的主要方面，这些方面将在以下章节中更详细地描述。
- en: '![CH02_F03_Negro](../Images/CH02_F03_Negro.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F03_Negro](../Images/CH02_F03_Negro.png)'
- en: Figure 2.3 The four Vs of big data
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 大数据的四个“V”
- en: Over the years, as the term *big data* began to gather a lot of attention and
    become trendy, analysts and tech journalists added more and more Vs to the list
    of dimensions. At last check, the count stood at 42 [Shafer, 2017]; as time goes
    on, more will undoubtedly be added.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 几年来，随着“大数据”这个术语开始受到越来越多的关注并变得流行，分析师和技术记者不断地在维度的列表中添加更多的“V”。截至最后一次检查，数量达到了42个[Shafer,
    2017]；随着时间的推移，无疑还会增加更多。
- en: We will focus on the original three Vs plus veracity, because they remain the
    most commonly accepted. These dimensions are used throughout the book to highlight
    the role of graph models and databases in managing large amounts of data.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重点关注原始的三个“V”加上真实性，因为它们仍然是普遍接受的。这些维度在整本书中用于强调图模型和数据库在管理大量数据中的作用。
- en: 2.1.1 Volume
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.1 量
- en: The benefits gained from *volume* (figure 2.4)—the ability to process large
    amounts of information—are the main attractions of big data for machine learning.
    Having more and better data beats having better models. Simple mathematical operations
    can be incredibly effective given large amounts of data.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 从“量”（图2.4）中获得的收益——处理大量信息的能力——是大数据对机器学习的主要吸引力。拥有更多和更好的数据胜过拥有更好的模型。在大量数据的情况下，简单的数学运算可以非常有效。
- en: '![CH02_F04_Negro](../Images/CH02_F04_Negro.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F04_Negro](../Images/CH02_F04_Negro.png)'
- en: Figure 2.4 Volume in big data
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 大数据量
- en: 'Suppose that you would like to use a machine-learning approach that employs
    a wide variety of electronic health record (EHR) data to make real-time predictions
    regarding the kinds of treatments necessary for different symptoms. The amount
    of patient health data is increasing exponentially, which means that the amount
    of legacy EHR data is skyrocketing as well. According to Health Data Archiver
    [2018]:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你希望使用一种机器学习方法，该方法使用各种电子健康记录（EHR）数据来对治疗不同症状所需的类型进行实时预测。患者健康数据量呈指数增长，这意味着遗留的EHR数据量也在急剧增加。根据Health
    Data Archiver [2018]：
- en: '*A report from EMC and the research firm IDC offers a few imaginative ways
    at visualizing the health information proliferation, anticipating an overall increase
    in health data of 48 percent annually. The report pegs the volume of healthcare
    data at 153 Exabytes in 2013\. At the projected growth rate, that figure will
    swell to 2,314 Exabytes by 2020.*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*来自EMC和研究公司IDC的一份报告提出了一些富有创意的方式来可视化健康信息的激增，预计健康数据将每年增长48%。报告将2013年的医疗数据量定为153艾字节。按照预测的增长率，这个数字将在2020年增加到2,314艾字节。*'
- en: As stated previously, the volume of data generated by modern IT, industrial,
    healthcare, IoT, and other systems is growing exponentially. This growth is driven
    on the one side by the lowering costs of data storage and processing architectures
    and on the other side by the capabilities (which create new needs) to extract
    valuable insights from the data—insights that improve business processes, efficiency,
    and the services delivered to end users or customers. Although there is no fixed
    threshold for a volume of data to be considered “big,” typically the term denotes
    data of a scale that is “difficult to store, manage, and process using traditional
    relational database systems and data processing architectures” [Bahga and Madisetti,
    2016].
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，现代IT、工业、医疗保健、物联网和其他系统生成数据的量呈指数级增长。这种增长一方面是由于数据存储和处理架构成本的降低，另一方面是由于从数据中提取有价值见解的能力（这些能力创造了新的需求），这些见解可以改善业务流程、效率和提供给最终用户或客户的服务的质量。尽管没有固定阈值来定义数据的量是否为“大数据”，但通常这个术语表示的数据规模是“难以使用传统的数据库系统和数据处理架构存储、管理和处理”
    [Bahga和Madisetti, 2016]。
- en: 'Trying to continuously collect and analyze this big data has become one of
    the leading challenges across all of IT. The solutions to this challenge fall
    into two main categories:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 试图持续收集和分析这些大数据已成为IT领域的主要挑战之一。解决这个挑战的方案主要分为两大类：
- en: '*Scalable storage—Scaling storage* generally refers to adding more machines
    and distributing the load (reads, writes, or both) over them. This process is
    known as scaling *horizontally*. Scalability can also be achieved through query
    or access mechanisms that provide multiple access points to a subset of the full
    data store, without the need to go over the entire dataset by using filters or
    index lookups. Native graph databases belong in this second group, which will
    be discussed in section 2.3.4.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可扩展存储—扩展存储*通常指的是添加更多机器并将（读取、写入或两者）负载分布到这些机器上。这个过程被称为水平扩展。通过查询或访问机制也可以实现可扩展性，这些机制提供了对整个数据存储子集的多个访问点，无需通过过滤器或索引查找来遍历整个数据集。原生图数据库属于第二组，将在2.3.4节中讨论。'
- en: '*Scalable processing*—The horizontal scaling of processing doesn’t only mean
    having multiple machines executing tasks in parallel; it also requires a distributed
    approach to querying, a protocol for effective communication over the network,
    orchestration, monitoring, and a specific paradigm for distributed processing
    (such as divide and conquer, iterative, and pipeline).'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可扩展处理*—处理水平扩展不仅意味着有多个机器并行执行任务；它还需要分布式查询方法、网络中有效通信的协议、编排、监控以及分布式处理的具体范式（如分而治之、迭代和管道）。'
- en: During the data understanding and data preparation phases of the CRISP-DM life
    cycle (figure 2.5), it is necessary to identify the data sources and the size
    and structure of each phase to design the model and identify the database management
    system (DBMS) that will be used.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在CRISP-DM生命周期（图2.5）的数据理解和数据准备阶段，有必要确定数据源以及每个阶段的大小和结构，以设计模型并确定将使用的数据库管理系统（DBMS）。
- en: '![CH02_F05_Negro](../Images/CH02_F05_Negro.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F05_Negro](../Images/CH02_F05_Negro.png)'
- en: Figure 2.5 Data understanding and data preparation in the CRISP-DM model
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 CRISP-DM模型中的数据理解和数据准备
- en: 'Graphs can provide valuable support during these phases, helping solve issues
    related to volume. A graph-based model enables data from multiple data sources
    to be stored in a single, highly connected, and homogeneous source of truth that
    offers multiple fast access patterns. Specifically, in a big data platform, graphs
    can help address volume issues by playing two roles:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图形在这些阶段可以提供有价值的支持，帮助解决与数据量相关的问题。基于图模型的数据可以从多个数据源存储在一个单一、高度连接和同质化的真相来源中，提供多种快速访问模式。具体来说，在大数据平台上，图形可以通过扮演两个角色来帮助解决数据量问题：
- en: '*Main data source*—In this case, the graph contains all data with the lowest
    granularity. The learning algorithms access the graph directly to perform their
    analyses. In this sense, according to the type of analysis, a proper graph database
    for big data has to expose'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*主要数据源*—在这种情况下，图包含所有最低粒度的数据。学习算法直接访问图以执行其分析。从这个意义上说，根据分析类型，大数据的正确图数据库必须暴露'
- en: An indexing structure (common in other SQL and NoSQL databases) to support random
    access
  id: totrans-43
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种索引结构（常见于其他SQL和NoSQL数据库）以支持随机访问
- en: An access pattern for accessing only a small portion of the graph, eliminating
    the need for complex index lookups or database scanning
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种仅访问图的一小部分的访问模式，消除了复杂索引查找或数据库扫描的需求
- en: '*Materialized views*—In this case, the graph represents a subset of the main
    dataset or an aggregated version of data in it, and is useful for analysis, visualization,
    or results communication. The views could be either the input or the output of
    an analytic process, and the global and local access patterns provided by the
    graph also provide valuable help in this case.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*物化视图*——在这种情况下，图表示主数据集的子集或其中数据的聚合版本，对于分析、可视化和结果沟通很有用。视图可以是分析过程的输入或输出，图提供的全局和本地访问模式也为此提供了宝贵的帮助。'
- en: Section 2.2 illustrates these opposite approaches by presenting two example
    scenarios and their related implementations.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 2.2节通过展示两个示例场景及其相关实现来阐述这些相反的方法。
- en: 2.1.2 Velocity
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.2 速度
- en: '*Velocity* (figure 2.6) refers to how rapidly data is generated, accumulated,
    or processed. Receiving and processing 1,000 search requests in an hour, for example,
    is different from receiving and processing the same number of requests in a fraction
    of a second. Some applications have strict time constraints for data analysis,
    including stock trading, online fraud detection, and real-time applications generally.
    The importance of data velocity has followed a pattern similar to that of volume.
    Problems previously restricted to particular segments of industry are now presenting
    themselves in a much broader setting.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*速度*（图2.6）指的是数据生成、积累或处理的快速程度。例如，在一小时内接收和处理1,000个搜索请求，与在几秒钟内接收和处理相同数量的请求是不同的。一些应用程序对数据分析有严格的时间限制，包括股票交易、在线欺诈检测和实时应用等。数据速度的重要性遵循与数据量类似的模式。以前仅限于特定行业段的问题现在正在更广泛的背景下出现。'
- en: '![CH02_F06_Negro](../Images/CH02_F06_Negro.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F06_Negro](../Images/CH02_F06_Negro.png)'
- en: Figure 2.6 Velocity in big data
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 大数据中的速度
- en: Suppose that you are working on a self-driving car. Each car that should drive
    autonomously has access to many sensors, such as cameras, radar, sonar, GPS, and
    lidar.[¹](#pgfId-1010755) Each sensor generates a lot of data every second, as
    reported in table 2.1 [Nelson, 2016].
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在开发自动驾驶汽车。每辆应该自动驾驶的汽车都可以访问许多传感器，例如摄像头、雷达、声纳、GPS和激光雷达。[¹](#pgfId-1010755)
    每个传感器每秒都会生成大量数据，如表2.1 [Nelson, 2016]所述。
- en: Table 2.1 Data generated every second by a self-driving car’s sensors
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.1 自驾驶汽车传感器每秒生成数据
- en: '| Sensor | Amount of data generated every second |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 传感器 | 每秒生成数据量 |'
- en: '| Cameras | ~20-40 MB/s |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 摄像头 | ~20-40 MB/s |'
- en: '| Radar | ~10-100 KB/s |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 雷达 | ~10-100 KB/s |'
- en: '| Sonar | ~10-100 KB/s |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 声纳 | ~10-100 KB/s |'
- en: '| GPS | ~50 KB/s |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| GPS | ~50 KB/s |'
- en: '| Lidar | ~10-70 MB/s |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 激光雷达 | ~10-70 MB/s |'
- en: In such a scenario, the system you are designing should be able not only to
    process this data at speed, but also to generate a prediction as fast as possible
    to avoid, for example, hitting a pedestrian crossing the street.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种场景下，你设计的系统不仅应该能够快速处理这些数据，还应该尽可能快地生成预测，以避免例如撞到正在过马路的行人。
- en: 'But the velocity of the incoming data is not the only issue: it is possible
    to solve this problem by streaming fast-moving data into bulk storage for later
    batch processing, for example. The importance of velocity lies in the overall
    speed of the *feedback loop* (figure 2.7), which involves taking data from input
    to a decision:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 但 incoming data 的速度并不是唯一的问题：例如，可以通过将快速移动的数据流式传输到批量存储中进行后续批量处理来解决这个问题。速度的重要性在于
    *反馈循环*（图2.7）的整体速度，它涉及从输入到决策的数据处理：
- en: '*With a feedback loop, the system learns continuously by monitoring the effectiveness
    of predictions and retraining when needed. Monitoring and using the resulting
    feedback are at the core of machine learning.*[²](#pgfId-1010776)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*通过反馈循环，系统通过监控预测的有效性并在需要时重新训练来持续学习。监控和使用产生的反馈是机器学习的核心。[²](#pgfId-1010776)'
- en: '![CH02_F07_Negro](../Images/CH02_F07_Negro.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F07_Negro](../Images/CH02_F07_Negro.png)'
- en: Figure 2.7 An example of a feedback loop
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 反馈循环的一个示例
- en: An advertisement for IBM makes the point that you wouldn’t cross the road if
    all you had to go on was a five-minute-old snapshot of the traffic. This example
    illustrates the fact that at times, you won’t be able to wait for a report to
    run or a Hadoop job to complete. In other words, “the tighter the feedback loop,
    the greater the competitive advantage” [Wilder-James, 2012]. Ideally, a real-time
    machine learning platform should be able to analyze data instantly, as it is generated.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一则 IBM 的广告指出，如果你所依赖的只是五分钟前的交通快照，你就不会过马路。这个例子说明了有时你无法等待报告运行或 Hadoop 作业完成。换句话说，“反馈循环越紧密，竞争优势越大”
    [Wilder-James, 2012]。理想情况下，实时机器学习平台应该能够即时分析数据，就像数据生成时一样。
- en: Over time, machine learning architectural best practices have emerged for the
    management of big data. The Lambda Architecture [Marz and Warren, 2015], an architectural
    pattern for building real-time data-intensive systems, is one of these practices;
    we’ll look at a graph-based implementation in section 2.2.1.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，针对大数据管理的一些机器学习架构最佳实践已经出现。Lambda 架构 [Marz and Warren, 2015]，这是一种用于构建实时数据密集型系统的架构模式，是这些实践之一；我们将在
    2.2.1 节中查看基于图实现的例子。
- en: A data infrastructure that copes with velocity has to provide quick access to
    the necessary data, which could be a portion of the whole data. Suppose that you
    are going to implement a real-time recommendation engine for renting holiday homes.
    The learning algorithm uses the user’s most recent clicks and searches to suggest
    houses. In such a case, the engine doesn’t have to access the entire dataset;
    it checks the last N number of clicks or the clicks in the last X size of time
    frame and makes the prediction. A native graph database (described in section
    2.3.4) maintains the list of relationships for each node. Starting from the last
    click—and having a proper graph model—the engine can navigate back through the
    previous clicks, following the relationships of each node back. This example is
    one illustration of the highly performant access to small portions of the dataset
    that graphs provide to serve velocity.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 能够应对速度的数据基础设施必须提供对必要数据的快速访问，这可能只是整个数据的一部分。假设你打算实现一个针对度假房屋的实时推荐引擎。学习算法使用用户的最新点击和搜索记录来推荐房屋。在这种情况下，引擎不需要访问整个数据集；它检查最后
    N 次点击或在过去 X 时间段内的点击，并做出预测。一个本地的图数据库（在第 2.3.4 节中描述）维护每个节点的关联列表。从最后一次点击开始——拥有适当的图模型——引擎可以沿着每个节点的关联回溯。这个例子是图提供的高性能访问数据集小部分的一个说明，以服务于速度。
- en: 2.1.3 Variety
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.3 多样性
- en: '*Variety* (figure 2.8) has to do with the different types and nature of the
    data that is analyzed. Data varies in format, structure, and size; rarely does
    it present itself in a form that’s perfectly ordered and ready for processing.
    Because it is collected from different and varied sources, big data comes in multiple
    shapes (structured, unstructured, or semistructured) and formats; it can include
    textual data, images, videos, sensor data, and so on. Any big data platform needs
    to be flexible enough to handle such variety, especially considering the data’s
    potentially unpredictable evolution.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*多样性*（图 2.8）与被分析的数据的不同类型和性质有关。数据在格式、结构和大小上有所不同；很少以完美有序和准备处理的形式出现。由于它来自不同的和多样化的来源，大数据以多种形状（结构化、非结构化或半结构化）和格式出现；它可以包括文本数据、图像、视频、传感器数据等等。任何大数据平台都需要足够灵活，能够处理这种多样性，特别是考虑到数据的潜在不可预测的演变。'
- en: '![CH02_F08_Negro](../Images/CH02_F08_Negro.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F08_Negro](../Images/CH02_F08_Negro.png)'
- en: Figure 2.8 Variety in big data
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8 大数据多样性
- en: Suppose that you would like to organize all of a company’s knowledge, distributed
    across multiple data silos, to create a knowledge base for an insight engine.[³](#pgfId-1010790)
    The data could be in different formats, from well-structured relational databases
    to unstructured user reviews for products or services offered by the company,
    from PDF documents to social network data. To be processed by a machine learning
    platform, the data needs to be organized, stored, and managed as a unit in an
    homogeneous way.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要组织一个公司所有分散在多个数据孤岛中的知识，为洞察引擎创建一个知识库。[³](#pgfId-1010790) 数据可能以不同的格式存在，从结构良好的关系型数据库到公司提供的产品或服务的非结构化用户评论，从
    PDF 文档到社交网络数据。为了被机器学习平台处理，数据需要以统一的方式组织、存储和管理。
- en: 'Despite the popularity and familiarity of relational databases, they are no
    longer the destination of choice for big data platforms. Certain data types are
    better suited to certain types of databases than others. Social network relations,
    for example, are graphs by nature and so are well adapted to storage in graph
    databases such as Neo4j (described in appendix B), which make operations on connected
    data simple and efficient. Additionally, other classes of data fit well in a graph
    model due to the graph’s versatility in managing connected data. As Edd Wilder-James
    [2012] puts it:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管关系型数据库广受欢迎且熟悉，但它们不再是大数据平台的首选目的地。某些数据类型比其他数据类型更适合某些类型的数据库。例如，社交网络关系本质上就是图，因此非常适合存储在像Neo4j（附录B中描述）这样的图数据库中，这使得对连接数据的操作变得简单高效。此外，由于图在管理连接数据方面的多功能性，其他类别的数据也适合图模型。正如Edd
    Wilder-James [2012]所说：
- en: '*Even where there’s not a radical data type mismatch, a disadvantage of the
    relational database is the static nature of its schemas. In an agile, exploratory
    environment, the results of computations will evolve with the detection and extraction
    of more signals. Semi-structured NoSQL databases meet this need for flexibility:
    they provide enough structure to organize data, but do not require the exact schema
    of the data before storing it.*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*即使没有根本性的数据类型不匹配，关系型数据库的一个缺点是其模式的静态性质。在一个敏捷、探索性的环境中，计算的成果会随着更多信号的检测和提取而演变。半结构化的NoSQL数据库满足了这种灵活性的需求：它们提供了足够的数据结构来组织数据，但在存储之前并不需要数据的精确模式。*'
- en: Graph databases, as a type of NoSQL database, are no exception. The simple model
    based on nodes and edges provides great flexibility in terms of data representation.
    Furthermore, new types of nodes and edges can appear later in the design process
    without affecting the previously defined model, giving graphs a high level of
    extensibility.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种NoSQL数据库，图数据库也不例外。基于节点和边的简单模型在数据表示方面提供了极大的灵活性。此外，在设计过程中后期可以出现新的节点和边类型，而不会影响先前定义的模型，这使得图具有高度的扩展性。
- en: 2.1.4 Veracity
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.4 真实性
- en: '*Veracity* (figure 2.9) is related to the quality and/or trustworthiness of
    the data collected. Data-driven applications can reap the benefits of big data
    only when the data is correct, meaningful, and accurate.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*真实性*（图2.9）与收集到的数据的质量和/或可信度相关。只有当数据是正确的、有意义的和准确的时，数据驱动型应用才能从大数据中获益。'
- en: '![CH02_F09_Negro](../Images/CH02_F09_Negro.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F09_Negro](../Images/CH02_F09_Negro.png)'
- en: Figure 2.9 Veracity in big data
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9 大数据中的真实性
- en: 'Suppose that you would like to create a recommendation engine for a travel
    website by using reviews. This type of engine is the new trend in the recommendation
    field, because reviews contain much more information than the old-style star ratings
    do. The issue resides in the veracity of such reviews:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想通过使用评论来为旅游网站创建一个推荐引擎。这种类型的引擎是推荐领域的新趋势，因为评论包含的信息比旧式的星级评分要多得多。问题在于这种评论的真实性：
- en: '*For online retailers, the war on the fake-review industry is now a major part
    of the business. Today, when a review is submitted to TripAdvisor, it goes through
    a tracking system that examines hundreds of different attributes, from basic data
    points, such as the IP address of the reviewer, to more detailed information,
    such as the screen resolution of the device that was used to submit the review.*[⁴](#pgfId-1010814)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*对于在线零售商来说，打击虚假评论行业的战争现在是业务的重要组成部分。今天，当评论提交给TripAdvisor时，它会通过一个跟踪系统，该系统检查数百个不同的属性，从基本的数据点，如评论者的IP地址，到更详细的信息，如提交评论所使用的设备的屏幕分辨率。[⁴](#pgfId-1010814)*'
- en: As discussed in chapter 1, the combination of the quality and quantity of data
    in the training dataset directly affects the quality of the model inferred. The
    wrong data could affect the entire processing pipeline. The resulting predictions
    are definitely affected.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如第1章所述，训练数据集中质量和数量的组合直接影响推断出的模型质量。错误的数据可能会影响整个处理流程。产生的预测结果肯定会受到影响。
- en: Data rarely comes wholly accurate and complete, which is why a cleaning process
    is necessary. This task can be accomplished with graph approaches. Specifically,
    graph access patterns make it easy to spot issues based on the relationships among
    elements. Moreover, by combining multiple sources in a single connected source
    of truth, it is possible to merge information, reducing data sparsity.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 数据很少完全准确和完整，这就是为什么需要进行清理过程的原因。这项任务可以通过图方法完成。具体来说，图访问模式使得根据元素之间的关系发现问题变得容易。此外，通过将多个来源合并到一个单一的真实来源中，可以合并信息，减少数据稀疏性。
- en: 2.2 Graphs in the big data platform
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 大数据平台中的图
- en: Working with big data is a complex task. A machine learning platform requires
    access to data to extract insights and deliver predictive services to end users.
    Table 2.2 summarizes the challenges related to the four Vs, pairing each with
    the requirements for storing, managing, accessing, and analyzing data.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 与大数据打交道是一项复杂的工作。机器学习平台需要访问数据以提取洞察力并向最终用户提供预测服务。表 2.2 总结了与四个“V”相关的挑战，将每个挑战与存储、管理、访问和分析数据的要求配对。
- en: Table 2.2 Big data challenges
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.2 大数据挑战
- en: '| Big data Vs | Challenge |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 大数据对比 | 挑战 |'
- en: '| Volume | The database should be able to store large amounts of data, or the
    model defined should be able to compress the data through aggregation so that
    it can be accessed quickly but the model can perform all the analysis required.
    |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 体积 | 数据库应该能够存储大量数据，或者定义的模型应该能够通过聚合压缩数据，以便可以快速访问，同时模型可以执行所有必需的分析。|'
- en: '| Velocity | The data generally comes at a high rate, which requires a queue
    for decoupling the data ingestion from the storage mechanism. The ingestion rate
    and storage rate must be adequately balanced such that data can be transformed
    and stored quickly enough to prevent the accumulation of elements in the queue.
    |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 速度 | 数据通常以高速度到达，这需要队列来解耦数据摄取与存储机制。摄取速率和存储速率必须得到适当的平衡，以便数据能够快速转换和存储，从而防止队列中元素的积累。|'
- en: '| Variety | The database schema needs to be sufficiently flexible to store
    multiple kinds of information at the same time, using a model that allows the
    storage of all the current classes of data and any classes that could appear later
    in the project. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 多样性 | 数据库模式需要足够灵活，能够同时存储多种类型的信息，使用一个模型可以存储所有当前的数据类别以及项目后期可能出现的任何类别。|'
- en: '| Veracity | The model designed and the database selected should allow for
    easy, fast navigation of data and identification of incorrect, invalid, or undesirable
    data. There should be a way to clean the data, allowing for the removal of noise.
    The task of simplifying and merging data (to combat data sparsity) should also
    be supported. |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 真实性 | 设计的模型和选择的数据库应该允许轻松、快速地导航数据，并识别不正确、无效或不受欢迎的数据。应该有一种方法来清理数据，允许去除噪声。简化数据（以对抗数据稀疏性）的任务也应得到支持。|'
- en: 'The approaches that deal with these challenges can be grouped into two categories:
    methodological (or design) and technological. To get the best from both, you should
    use them in combination, harmonically.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这些挑战的方法可以分为两类：方法论（或设计）和技术。为了从两者中获取最佳效果，您应该将它们结合起来，和谐地使用。
- en: '*Methodological* approaches include all the design decisions that involve the
    architecture, algorithms, storage schema, and cleaning methods; we’ll look at
    these approaches in this section in relation to some specific, concrete scenarios.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*方法论*方法包括涉及架构、算法、存储模式和清理方法的所有设计决策；我们将在本节中查看这些方法，并与一些具体的、具体的情况相关联。'
- en: '*Technological* approaches include the design aspects related to the DBMS to
    use, the cluster configuration to adopt, and the reliability of the solution to
    deliver. Those aspects are considered in section 2.3.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*技术*方法包括与所使用的数据库管理系统相关的设计方面，采用的集群配置，以及提供解决方案的可靠性。这些方面将在第 2.3 节中考虑。'
- en: Two scenarios are presented here to show the value of graphs in managing big
    data as part of the machine learning project pipeline and extracting insights
    from it. Whereas both scenarios are related to the methodological approach, they
    also highlight some aspects of the technological approach that will be discussed
    later in the chapter.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提供了两个场景，以展示图在作为机器学习项目管道中管理大数据的价值以及从中提取洞察力。虽然这两个场景都与方法论方法相关，但它们也突出了将在本章后面讨论的技术方法的一些方面。
- en: 2.2.1 Graphs are valuable for big data
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.1 图在大数据中的价值
- en: 'To see the value provided by graphs in the big data panorama, we’ll explore
    a complex use case that requires processing a lot of data to be effective. In
    this case, the graphs can handle the problem complexity, providing a complete
    set of features to store, process and analyze the data. Consider the following
    scenario:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到图在大数据全景中提供的价值，我们将探索一个复杂的用例，该用例需要处理大量数据才能有效。在这种情况下，图可以处理问题复杂性，提供一套完整的特征来存储、处理和分析数据。考虑以下场景：
- en: You are a police officer. How can you track a suspect by using cellular tower
    data collected from the continuous monitoring of signals every phone sends to
    (or receives from) all towers it can reach?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你是一名警察。你如何通过使用从每个手机发送到（或接收自）所有可达基站的连续监测信号收集的蜂窝基站数据来追踪嫌疑人？
- en: An interesting article by Eagle, Quinn, and Clauset [2009] addresses the problem
    of using cellular tower data collected from the continuous monitoring signals
    that cell phones exchange with every tower in reach (figure 2.10). The goal of
    our example scenario is to use such monitoring data to create a predictive model
    that identifies location clusters relevant for the subject’s life and that predicts
    and anticipates subsequent movements according to the subject’s current location.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一篇由Eagle、Quinn和Clauset于2009年发表的有趣文章，探讨了使用从手机与可达的每个基站之间交换的连续监测信号收集的蜂窝基站数据的问题（图2.10）。我们示例场景的目标是利用此类监测数据创建一个预测模型，该模型能够识别与主题生活相关的位置聚类，并根据主题的当前位置预测和预测后续移动。
- en: '![CH02_F10_Negro](../Images/CH02_F10_Negro.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F10_Negro](../Images/CH02_F10_Negro.png)'
- en: Figure 2.10 Phones communicating with cellular towers
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10 手机与蜂窝基站通信
- en: The relevant aspect of this approach is that it uses a graph as a way to collapse
    and organize the data available from cellular towers and creates a *graph-based
    materialized view* of the subject’s movements. The resulting graph is analyzed
    with a graph algorithm that identifies clusters of positions. Those positions
    are used in the next algorithm in the analytics pipeline to build the position
    prediction model. At this stage of the book, I won’t describe the details of the
    algorithms, because the purpose of the scenario is to show how to use a graph
    model as a valuable method for preprocessing and organizing the data in complex
    problems. The graph condenses information so that it is suitable for the analysis
    that has to be accomplished.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的相关之处在于，它使用图作为从蜂窝基站获取的数据的折叠和组织方式，并创建了一个基于图的物化视图，以展示主题的移动。该图通过识别位置聚类的图算法进行分析。这些位置在分析管道中的下一个算法中使用，以构建位置预测模型。在本书的这一阶段，我不会描述算法的细节，因为场景的目的是展示如何使用图模型作为在复杂问题中预处理和组织数据的宝贵方法。图压缩信息，使其适合完成的分析。
- en: For the mental model in this scenario, a graph model is used to store and manage
    the data sources, a graph algorithm is used in the processing pipeline, and a
    graph is used to store the intermediate model (figure 2.11).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此场景的心理模型，使用图模型来存储和管理数据源，在处理管道中使用图算法，并使用图来存储中间模型（图2.11）。
- en: '![CH02_F11_Negro](../Images/CH02_F11_Negro.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F11_Negro](../Images/CH02_F11_Negro.png)'
- en: Figure 2.11 The areas of our mental map relevant to this scenario
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11 与此场景相关的心理地图区域
- en: Every mobile phone in use today has continuous access to information about the
    nearby cellular towers. Studying these data streams can provide valuable insight
    into a user’s movements and behavior. The methods of obtaining continuous cellular
    tower data are
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 今天使用的每部移动电话都能持续访问有关附近蜂窝基站的信息。研究这些数据流可以为用户的移动和行为提供有价值的见解。获取连续蜂窝基站数据的方法包括
- en: Installing a logging application on the mobile phone itself to capture the continuous
    data stream
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在手机本身上安装日志应用程序以捕获连续数据流
- en: Using (when available) raw continuous data from the cellular towers
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用（当可用时）来自蜂窝基站的原始连续数据
- en: This example uses a continuous data aggregation process for merging data about
    a specific phone, so we will use the first use case in this scenario to simplify
    the description.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用连续数据聚合过程来合并特定手机的数据，因此我们将使用此场景中的第一个用例来简化描述。
- en: Each subject’s phone records the four nearest towers—the towers with the strongest
    signal—at 30-second intervals. Once collected, this data can be represented as
    a *cellular tower network* (CTN), in which the nodes are unique cellular towers.
    An edge exists between each pair of nodes that co-occur in the same record, and
    each edge is weighted according to the total amount of time the pair co-occurred
    over all records. A CTN is generated for each subject that includes every tower
    logged by the subject’s phone during the monitoring period [Eagle, Quinn, and
    Clauset, 2009]. Figure 2.12 shows an example of the resulting graph for a single
    subject.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 每个受试者的电话记录在30秒间隔内记录最近的四个塔——信号最强的塔。一旦收集到这些数据，就可以表示为一个*蜂窝塔网络*（CTN），其中节点是唯一的蜂窝塔。如果两个节点在同一个记录中同时出现，则它们之间存在一条边，每条边的权重根据这对节点在所有记录中共同出现的总时间来计算。为每个受试者生成一个CTN，包括受试者电话在监控期间记录的所有塔[Eagle,
    Quinn, and Clauset, 2009]。图2.12显示了单个受试者产生的图例。
- en: '![CH02_F12_Negro](../Images/CH02_F12_Negro.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F12_Negro](../Images/CH02_F12_Negro.png)'
- en: Figure 2.12 A graph representation of a CTN for a single subject
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12 单个受试者的CTN图表示
- en: A node’s strength is determined by summing the weights of all its edges. The
    nodes with the highest total edge weights identify the towers that are most often
    close to the subject’s phone. Groups of highly weighted nodes, therefore, should
    correspond to locations where the subject spends a significant amount of time.
    Building on this idea, the graph can be segmented into clusters by means of different
    clustering algorithms. (We’ll discuss these algorithms throughout the book, starting
    in part 2.) The result of such a clustering process will look something like figure
    2.13.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一个节点的强度是通过求和其所有边的权重来确定的。总边权重最高的节点识别出最常靠近受试者电话的塔。因此，高权重节点的组应该对应于受试者花费大量时间的地点。基于这个想法，可以通过不同的聚类算法将图分割成簇。（我们将在本书的第二部分开始讨论这些算法。）这种聚类过程的结果将类似于图2.13。
- en: '![CH02_F13_Negro](../Images/CH02_F13_Negro.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F13_Negro](../Images/CH02_F13_Negro.png)'
- en: Figure 2.13 A clustered view of the CTN
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.13 CTN的聚类视图
- en: The clusters represent areas where the subject spends a significant amount of
    time—perhaps at home, at the office, at the gym, or in a shop. The relationships
    crossing the clusters, connecting a node in one cluster to a node in another,
    represent the transitions between one area and another, such as moving from home
    to the office in the morning and making the reverse journey in the afternoon.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这些簇代表受试者花费大量时间的区域——可能是家、办公室、健身房或商店。跨越簇的关系，连接一个簇中的一个节点到另一个簇中的一个节点，代表从一个区域到另一个区域的过渡，例如早上从家到办公室，下午反向行程。
- en: The clusters of towers identified can be converted to the states of a dynamic
    model. Given a sequence of locations visited by a subject, it is possible to learn
    patterns in their behavior and calculate the probability that they will move to
    various locations in the future. (Different techniques can be used for this purpose,
    but these techniques are out of scope for this discussion.) When the prediction
    model is computed, it can be used to make a prediction about the future movements
    of a subject, considering the last positions revealed from the same source of
    data.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 识别出的塔簇可以被转换为动态模型的状态。给定一个受试者访问的地点序列，可以学习他们的行为模式，并计算他们将来移动到各种地点的概率。（可以为此目的使用不同的技术，但这些技术超出了本次讨论的范围。）当预测模型计算出来后，可以使用它来预测受试者的未来移动，考虑到从同一数据源揭示的最后位置。
- en: This scenario illustrates a methodological approach in which a graph model is
    used as a powerful view of the data that can be used as the input for some machine
    learning algorithm or as a visualization tool for analysts. Furthermore, because
    the graph model is schemaless, the aggregated version of the historical data (generally
    a lot of data, indicating things such as how much time the subject spent in each
    location) and the real-time value (which cellular towers the subject’s phone is
    currently able to reach, which indicates where they are now) can coexist in the
    same model.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这种场景说明了方法论方法，其中使用图模型作为数据的有力视图，可以用作某些机器学习算法的输入或分析师的可视化工具。此外，因为图模型是无模式的，历史数据的聚合版本（通常数据量很大，表示受试者在每个位置花费的时间等）和实时值（受试者的电话当前能够到达的蜂窝塔，这表明他们现在的位置）可以存在于同一个模型中。
- en: 'From the specific model, it is possible to abstract a more generic approach.
    The problem and process can be generalized as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 从具体模型中，可以抽象出一个更通用的方法。问题和过程可以概括如下：
- en: There is a lot of data in the form of *events* (the monitoring data available
    from the cellular towers or the phone).
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在大量以*事件*形式的数据（来自蜂窝基站或手机的监控数据）。
- en: The data is distributed across *multiple data sources* (each cellular tower
    or phone).
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据分布在*多个数据源*（每个蜂窝基站或手机）。
- en: The data needs to be *aggregated* and organized in a form that simplifies further
    processes and analysis (the CTN).
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要将数据*聚合*并组织成一种简化后续处理和分析（CTN）的格式。
- en: From the first aggregation format, some views are created (the clustering algorithm
    and the position prediction model).
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从第一个聚合格式中，创建了某些视图（聚类算法和位置预测模型）。
- en: At the same time, some real-time view of the last events needs to be stored
    to react fast to those events.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同时，还需要存储一些最近事件的实时视图，以便快速对这些事件做出反应。
- en: 'Some important and relevant aspects of this data flow affect the architecture
    of the machine learning project:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此数据流的一些重要和相关的方面会影响机器学习项目的架构：
- en: The *events* logged by the phones or the cellular towers are *raw*, *immutable*,
    and *true*. They will not change because of the analysis performed; they just
    happen. If a phone pinged a cellular tower, this event will not change because
    of a different analysis purpose. It is necessary to store the events one time
    and in a raw format.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手机或蜂窝基站记录的*事件*是*原始的*、*不可变的*和*真实的*。它们不会因为分析而改变；它们只是发生。如果一个手机向蜂窝基站发送了ping请求，这个事件不会因为不同的分析目的而改变。有必要一次性以原始格式存储这些事件。
- en: Multiple *views* are created as functions (aggregation is one example) on this
    data, and they can change according to the algorithms used for the analysis.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在此数据上创建了多个*视图*，作为分析使用的算法的函数（聚合是一个例子），并且它们可以根据分析使用的算法而改变。
- en: The *view-building process* generally operates on the entire set of data, and
    this process can take time, especially when it operates on a large amount of data,
    as in our specific use case. The time required to process the data creates a gap
    between the view of current events and previous events.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*视图构建过程*通常在数据集的整个集合上操作，这个过程可能需要时间，尤其是在处理大量数据时，如我们的具体用例。处理数据所需的时间在当前事件视图和先前事件视图之间产生了差距。'
- en: To have a *real-time* view of the data, it is necessary to fill this gap. The
    real-time view requires a kind of streaming process that reads the events and
    appends information to the views.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要有一个*实时*的数据视图，有必要填补这个差距。实时视图需要一个读取事件并向视图追加信息的流处理过程。
- en: 'The architectural problems described here are addressed by a specific type
    of architecture introduced by Nathan Marz and James Warren in their book *Big
    Data: the Lambda Architecture*, which “provides a general-purpose approach to
    implementing an arbitrary function on an arbitrary dataset and having the function
    return its results with low latency” [Marz and Warren, 2015]. The primary concept
    of the Lambda Architecture is to build big data systems as a series of three layers:
    batch, serving, and speed. The architectural schema is presented in figure 2.14.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这里描述的架构问题通过Nathan Marz和James Warren在他们所著的《大数据：Lambda架构》一书中介绍的一种特定类型的架构来解决，该架构“提供了一种通用的方法，可以在任意数据集上实现任意函数，并以低延迟返回函数的结果”
    [Marz and Warren, 2015]。Lambda架构的核心概念是将大数据系统构建为三个层级的系列：批处理、服务和速度。架构方案在图2.14中展示。
- en: '![CH02_F14_Negro](../Images/CH02_F14_Negro.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F14_Negro](../Images/CH02_F14_Negro.png)'
- en: Figure 2.14 The Lambda Architecture [Marz and Warren, 2015]
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.14 Lambda架构 [Marz and Warren, 2015]
- en: Each layer satisfies a subset of the requirements and builds on the functionality
    provided by the other layers. Everything starts from the *query* = *function(all
    data)* equation. In our example scenario, the query is “Get the locations where
    the user spends a significant amount of time.”
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 每一层都满足一组需求，并建立在其他层提供的功能之上。一切始于*查询* = *函数(所有数据)*的等式。在我们的示例场景中，查询是“获取用户花费大量时间的地点。”
- en: Ideally, we could run the query on the fly to get the results. But this approach
    is generally infeasible due to the amount of data to be processed and the distributed
    nature of the data sources to be accessed. Moreover, it would take a huge amount
    of resources, would be unreasonably expensive, and would take a long time. It
    would also be unsuitable for any real-time monitoring and prediction system.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们可以即时运行查询以获取结果。但由于需要处理的数据量以及要访问的数据源的分布式特性，这种方法通常不可行。此外，这将消耗大量资源，成本不合理，且耗时较长。它也不适合任何实时监控和预测系统。
- en: 'The most obvious alternative approach is to precompute the result of the query
    function or an intermediate value that speeds the final query results. Let’s call
    the precomputed query result, final or intermediate, the *batch view*. Instead
    of computing the query on the fly, we compute the results from this view, which
    needs to be stored in a way that provides quick access to it. Then the previous
    equation is split as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最明显的替代方法是预先计算查询函数的结果或加速最终查询结果的中间值。让我们称预先计算的查询结果，无论是最终结果还是中间结果，为*批量视图*。我们不是即时计算查询，而是从这个视图中计算结果，这个视图需要以提供快速访问的方式存储。然后，前面的方程式如下拆分：
- en: '*batch view = function(all data)*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*批量视图 = 函数（所有数据）*'
- en: '*query = function(batch view)*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*查询 = 函数（批量视图）*'
- en: All the data in the raw format is stored in the batch layer. This layer is also
    responsible for the raw-data access and the batch-view computation and extraction.
    The resulting views are stored in the serving layer, where they are indexed in
    a proper way and accessed during the queries (figure 2.15).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 所有原始格式的数据都存储在批量层中。该层还负责原始数据的访问、批量视图的计算和提取。生成的视图存储在服务层，其中它们以适当的方式索引并在查询期间访问（图
    2.15）。
- en: '![CH02_F15_Negro](../Images/CH02_F15_Negro.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F15_Negro](../Images/CH02_F15_Negro.png)'
- en: Figure 2.15 Batch-layer process
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.15 批量层过程
- en: 'In the cellular tower scenario, a first batch view is the CTN, which is a graph.
    The function that operates on such a view is the graph cluster algorithm, which
    produces another view: the clustered network. Figure 2.16 shows the batch layer
    producing subject graphs as batch views. Those views are computed for each monitored
    subject as shown in figure 2.12.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在蜂窝基站场景中，第一个批量视图是 CTN，它是一个图。在此视图上操作的函数是图聚类算法，它产生另一个视图：聚类网络。图 2.16 显示了批量层生成作为批量视图的主题图。这些视图如图
    2.12 所示，为每个监控对象进行计算。
- en: '![CH02_F16_Negro](../Images/CH02_F16_Negro.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F16_Negro](../Images/CH02_F16_Negro.png)'
- en: Figure 2.16 Batch-layer process producing graph views
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.16 批量层生成图视图
- en: The main difference in figure 2.16 is that both the batch views and, later,
    the real-time views are modeled as graphs. This modeling decision has advantages
    in several scenarios in which the graph representation not only allows us to reply
    faster to queries, but also facilitates analysis. In the specific scenario considered,
    the CTN is created as a function on all the raw cellular data collected and supports
    the clustering algorithm.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.16 中的主要区别在于，批量视图和随后的实时视图都被建模为图。这种建模决策在几个场景中具有优势，在这些场景中，图表示不仅使我们能够更快地响应用户查询，而且也便于分析。在考虑的具体场景中，CTN
    被创建为一个对所有收集到的原始蜂窝数据的函数，并支持聚类算法。
- en: The serving layer is updated whenever the batch layer finishes precomputing
    a batch view. Because the precomputation requires time, the latest data to reach
    the architecture entry point is not represented in the batch view. The speed layer
    solves this issue by providing some views of the more recent data, filling the
    gap between the batch layer and the newest incoming data. These views could have
    the same structure as in the serving layer or could have a different structure
    and serve a different purpose.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当批量层完成预计算批量视图时，服务层会进行更新。由于预计算需要时间，因此最新到达架构入口点的新数据在批量视图中没有得到表示。速度层通过提供一些较新数据的视图来解决此问题，填补了批量层和最新传入数据之间的差距。这些视图可以与服务层中的结构相同，也可以具有不同的结构并服务于不同的目的。
- en: One big difference between the two layers is that the speed layer only looks
    at recent data, whereas the batch layer looks at all the data. In the cellular
    tower scenario, the real-time views provide information on the last locations
    of the subjects and the transitions between locations.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 两个层之间的一大区别是，速度层只关注最近的数据，而批量层关注所有数据。在蜂窝基站场景中，实时视图提供了关于主体最后位置和位置之间转换的信息。
- en: The Lambda Architecture is *technology agnostic*; it is possible to use different
    approaches to realize it. The specific technologies you use might change depending
    on the requirements, but the Lambda Architecture defines a consistent approach
    to choosing those technologies and to wiring them together to meet your requirements.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda架构是*技术无关的*；可以使用不同的方法来实现它。您使用的具体技术可能会根据要求而变化，但Lambda架构定义了选择这些技术并将它们连接起来以满足您要求的一致方法。
- en: The scenario presented in this section shows how to use a graph model as part
    of the serving layer and the speed layer. The resulting final architecture is
    represented in figure 2.17.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中提出的场景展示了如何将图模型作为服务层和速度层的一部分来使用。最终架构在图2.17中表示。
- en: '![CH02_F17_Negro](../Images/CH02_F17_Negro.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F17_Negro](../Images/CH02_F17_Negro.png)'
- en: Figure 2.17 Graph-based Lambda Architecture
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.17 基于图的Lambda架构
- en: This new subtype of Lambda Architecture can be defined as a *graph-based Lambda
    Architecture*. In this scenario, the speed layer keeps track only of each subject’s
    last known location based on the last cellular tower reached by their phone. Then
    this information is used in combination with the cluster and prediction model
    to predict where the subjects will be in the future.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这种新的Lambda架构子类型可以被定义为一种基于*图的Lambda架构*。在这种情况下，速度层仅跟踪每个主题最后已知的位置，该位置基于他们手机最后到达的蜂窝基站。然后，这些信息与聚类和预测模型结合使用，以预测主题未来将在何处。
- en: The master dataset in the architecture in figure 2.17 can be stored by any database
    management system or a simple data store that can hold large amounts of data.
    The most commonly used data stores are HDFS, Cassandra, and similar NoSQL DBMSs.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.17架构中的主数据集可以通过任何数据库管理系统或可以存储大量数据的简单数据存储来存储。最常用的数据存储是HDFS、Cassandra和类似的NoSQL数据库管理系统。
- en: In the specific scenario considered, it is necessary to merge the data before
    extracting it in the form of a graph. HDFS provides a basic access mechanism based
    on filesystem storage, whereas Cassandra offers more flexible access patterns.
    Storing the graph views requires a graph database. The generic features of such
    a database and a specific tool are presented in section 2.3.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑的具体场景中，在以图的形式提取数据之前，需要合并数据。HDFS提供了一个基于文件系统存储的基本访问机制，而Cassandra提供了更灵活的访问模式。存储图视图需要图数据库。此类数据库的通用特性和特定工具在2.3节中介绍。
- en: 'The graph-based Lambda Architecture and the scenario described here are one
    example of the important role that graphs can play in the analysis of big data
    in the machine learning panorama. It is possible to use the same architecture
    in multiple scenarios, including the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 基于图的Lambda架构和此处描述的场景是图在机器学习大数据分析中发挥重要作用的例子之一。在多个场景中，包括以下场景，可以使用相同的架构：
- en: Analyzing bank transactions for fraud detection
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析银行交易以检测欺诈
- en: Analyzing server logs in a web farm to identify cyberattacks
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析Web农场中的服务器日志以识别网络攻击
- en: Analyzing phone-call data to identify communities of people
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析电话数据以识别人群社区
- en: 2.2.2 Graphs are valuable for master data management
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.2 图对于主数据管理很有价值
- en: 'In section 2.2.1, we saw how graphs can be used to create views on top of a
    master dataset (batch layer) or real-time (speed layer) representations of part
    of the data available. In that approach, the transactional data resides elsewhere:
    in the master dataset. That option is useful when you can query and perform analysis
    on aggregated data stored in the serving layer.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在2.2.1节中，我们看到了如何使用图在主数据集（批量层）或实时（速度层）表示的部分数据上创建视图。在那个方法中，事务数据驻留在其他地方：在主数据集中。当您可以在服务层存储的聚合数据上查询和执行分析时，此选项很有用。
- en: 'Other types of analysis, however, cannot be performed on an aggregate version
    of the data. Such algorithms require more detailed information to be effective;
    they need access to the fine-grained version of the data to accomplish their job.
    This type of analysis can also use the graph model as a way of representing connections
    and exploiting insights from the data. Understanding the connections between data
    and deriving meaning from these links provides capabilities not offered by classical
    analytical methods that are not based on graphs. In this case, the graph is the
    main source of knowledge, and it models a single connected source of truth. This
    concept brings us to our second example scenario:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，其他类型的分析不能在数据的汇总版本上执行。这些算法需要更详细的信息才能有效；它们需要访问数据的细粒度版本来完成其工作。这种分析还可以使用图模型作为表示连接和利用数据洞察的一种方式。理解数据之间的连接并从中提取意义提供了经典基于图的分析方法所不具备的能力。在这种情况下，图是知识的主要来源，它模型化了一个单一连接的真实来源。这个概念带我们来到了我们的第二个示例场景：
- en: You would like to create a simple but effective fraud detection platform for
    banks.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望为银行创建一个简单但有效的欺诈检测平台。
- en: 'Banks and credit card companies lose billions of dollars every year due to
    fraud. Traditional methods of fraud detection, such as rule-based, play an important
    role in minimizing these losses. But fraudsters constantly develop increasingly
    sophisticated methods to elude discovery, making rule-based fraud detection methods
    fragile and quickly obsolete. We will focus here on a specific type of fraud:
    credit card theft. Criminals can steal credit card data by using several methods,
    including Bluetooth-enabled data skimming devices installed in the cash machines,
    mass breaches by hackers, or small devices that cards are swiped through by checkout-line
    clerks or restaurant workers. People with legitimate access to your card can even
    surreptitiously jot down the relevant information on a piece of paper [Villedieu,
    n.d.]. To reveal such fraud, it is necessary to identify the source of the “breach”:
    the credit card thieves and where they operate. By representing credit card transactions
    as a graph, we can look for commonalities and track down the point of origin of
    the scam. Unlike most other ways of looking at data, graphs are designed to express
    relatedness. Graph databases can uncover patterns that are difficult to detect
    using traditional representations such as tables.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 银行和信用卡公司每年因欺诈而损失数十亿美元。传统的欺诈检测方法，如基于规则的，在最大限度地减少这些损失方面发挥着重要作用。但欺诈者不断开发越来越复杂的手段来逃避发现，使得基于规则的欺诈检测方法变得脆弱且很快过时。我们将重点关注一种特定的欺诈类型：信用卡盗窃。犯罪分子可以通过多种方式窃取信用卡数据，包括在自动取款机上安装的蓝牙数据读取设备、黑客的大规模入侵或通过收银员或餐厅工作人员的结账线刷卡的设备。甚至有权访问您的卡的人也可以在一张纸上偷偷记下相关信息[Villedieu,
    n.d.]。为了揭露这种欺诈，有必要确定“漏洞”的来源：信用卡窃贼及其活动地点。通过将信用卡交易表示为图，我们可以寻找共同点并追踪诈骗的起源点。与其他查看数据的方式不同，图是设计用来表达相关性的。图数据库可以揭示使用传统表示方法（如表格）难以检测到的模式。
- en: Suppose that the transactions database in table 2.3 contains data for a subset
    of users who have disputed some transactions.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 假设表2.3中的交易数据库包含了一部分有争议交易的用户的交易数据。
- en: Table 2.3 User transactions[⁵](#pgfId-1010826)
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.3 用户交易[⁵](#pgfId-1010826)
- en: '| User identifier | Timestamp | Amount | Merchant | Validity |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 用户标识符 | 时间戳 | 金额 | 商户 | 有效性 |'
- en: '| User A | 01/02/2018 | $250 | Hilton Barcelona | Undisputed |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| 用户A | 2018年2月1日 | $250 | Hilton Barcelona | 无争议 |'
- en: '| User A | 02/02/2018 | $220 | AT&T | Undisputed |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 用户A | 2018年2月2日 | $220 | AT&T | 无争议 |'
- en: '| User A | 12/03/2018 | $15 | Burger King New York | Undisputed |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 用户A | 2018年3月12日 | $15 | Burger King New York | 无争议 |'
- en: '| User A | 14/03/2018 | $100 | Whole Foods | Disputed |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 用户A | 2018年3月14日 | $100 | Whole Foods | 有争议 |'
- en: '| User B | 12/04/2018 | $20 | AT&T | Undisputed |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 用户B | 2018年4月12日 | $20 | AT&T | 无争议 |'
- en: '| User B | 13/04/2018 | $20 | Hard Rock | Undisputed |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 用户B | 2018年4月13日 | $20 | Hard Rock | 无争议 |'
- en: '| User B | 14/04/2018 | $8 | Burger King New York | Undisputed |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| 用户B | 2018年4月14日 | $8 | Burger King New York | 无争议 |'
- en: '| User B | 20/04/2018 | $8 | Starbucks | Disputed |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 用户B | 2018年4月20日 | $8 | Starbucks | 有争议 |'
- en: '| User C | 03/05/2018 | $15 | Whole Foods | Undisputed |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| 用户C | 2018年3月5日 | $15 | Whole Foods | 无争议 |'
- en: '| User C | 05/05/2018 | $15 | Burger King New York | Undisputed |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| 用户C | 2018年5月5日 | $15 | Burger King New York | 无争议 |'
- en: '| User C | 12/05/2018 | $15 | Starbucks | Disputed |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| 用户C | 2018年5月12日 | $15 | Starbucks | 有争议 |'
- en: 'Starting from this transaction dataset, let’s define a graph model. Each transaction
    involves two nodes: a person (the customer or user) and a merchant. The nodes
    are linked by the transactions themselves. Each transaction has a date and a status:
    *undisputed* for legitimate transactions and *disputed* for reported fraudulent
    transactions. Figure 2.18 presents the data as a graph.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个交易数据集开始，让我们定义一个图模型。每笔交易涉及两个节点：一个人（客户或用户）和一个商人。节点通过交易本身相互连接。每笔交易都有一个日期和状态：*无争议*表示合法交易，*争议*表示报告的欺诈交易。图2.18将数据表示为图。
- en: In this figure, the red connections are disputed transactions; the others are
    regular (undisputed) transactions. The resulting graph is large, but the graph’s
    dimensions do not affect the kind of analysis that has to be performed. Starting
    from such a dataset, the analysis steps to spot the source of fraud are
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，红色连接是争议交易；其他的是常规（无争议）交易。生成的图很大，但图的维度不会影响必须执行的分析类型。从这样的数据集开始，检测欺诈来源的分析步骤是
- en: '*Filter the fraudulent transactions.* Identify the people and the cards involved
    in the attack.'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*过滤欺诈交易*。识别攻击中涉及的人和卡。'
- en: '*Spot the point of origin of the fraud.* Search for all the transactions before
    the beginning of the fraud.'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*找出欺诈的源头*。搜索欺诈开始之前的所有交易。'
- en: '*Isolate the thieves.* Identify some common pattern, such as a merchant in
    common, that could be the origin of the fraud.'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*隔离小偷*。识别一些共同模式，例如共同的商人，这可能是欺诈的起源。'
- en: '![CH02_F18_Negro](../Images/CH02_F18_Negro.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F18_Negro](../Images/CH02_F18_Negro.png)'
- en: Figure 2.18 A sample graph model for credit card fraud detection
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.18 信用卡欺诈检测的示例图模型
- en: According to the sample graph in figure 2.18, the fraudulent transactions and
    the people affected are those listed in table 2.4.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 根据图2.18中的示例图，欺诈交易和受影响的人列在表2.4中。
- en: Table 2.4 Disputed transactions
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.4 争议交易
- en: '| User identifier | Timestamp | Amount | Merchant | Validity |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| 用户标识符 | 时间戳 | 金额 | 商人 | 有效性 |'
- en: '| User A | 14/03/2018 | $100 | Whole Foods | Disputed |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| 用户A | 14/03/2018 | $100 | Whole Foods | 争议 |'
- en: '| User B | 20/04/2018 | $8 | Starbucks | Disputed |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| 用户B | 20/04/2018 | $8 | 星巴克 | 争议 |'
- en: '| User C | 12/05/2018 | $15 | Starbucks | Disputed |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| 用户C | 12/05/2018 | $15 | 星巴克 | 争议 |'
- en: All these transactions happened during different months. Now, for each user,
    let’s consider all the transactions executed before the disputed transaction date,
    along with the related merchants. The results are shown in table 2.5.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些交易发生在不同的月份。现在，对于每个用户，让我们考虑在争议交易日期之前执行的交易，以及相关的商人。结果如表2.5所示。
- en: Table 2.5 All transactions before the disputed transactions
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.5 争议交易之前的所有交易
- en: '| User identifier | Timestamp | Amount | Merchant | Validity |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| 用户标识符 | 时间戳 | 金额 | 商人 | 有效性 |'
- en: '| User A | 01/02/2018 | $250 | Hilton Barcelona | Undisputed |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 用户A | 01/02/2018 | $250 | 希尔顿巴塞罗那 | 无争议 |'
- en: '| User A | 02/02/2018 | $220 | AT&T | Undisputed |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 用户A | 02/02/2018 | $220 | AT&T | 无争议 |'
- en: '| User A | 12/03/2018 | $15 | Burger King New York | Undisputed |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| 用户A | 12/03/2018 | $15 | 汉堡王纽约 | 无争议 |'
- en: '| User B | 12/04/2018 | $20 | AT&T | Undisputed |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| 用户B | 12/04/2018 | $20 | AT&T | 无争议 |'
- en: '| User B | 13/04/2018 | $20 | Hard Rock | Undisputed |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| 用户B | 13/04/2018 | $20 | 硬石 | 无争议 |'
- en: '| User B | 14/04/2018 | $8 | Burger King New York | Undisputed |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| 用户B | 14/04/2018 | $8 | 汉堡王纽约 | 无争议 |'
- en: '| User C | 03/05/2018 | $15 | Whole Foods | Undisputed |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| 用户C | 03/05/2018 | $15 | Whole Foods | 无争议 |'
- en: '| User C | 05/05/2018 | $15 | Burger King New York | Undisputed |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| 用户C | 05/05/2018 | $15 | 汉堡王纽约 | 无争议 |'
- en: Let’s group the transactions by store. The results are listed in table 2.6.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将交易按商店分组。结果列在表2.6中。
- en: Table 2.6 Aggregated transactions
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.6 聚合交易
- en: '| Merchant | Count | Users |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| 商人 | 数量 | 用户 |'
- en: '| Burger King New York | 3 | [User A, User B, User C] |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| 汉堡王纽约 | 3 | [用户A, 用户B, 用户C] |'
- en: '| AT&T | 2 | [User A, User B] |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| AT&T | 2 | [用户A, 用户B] |'
- en: '| Whole Foods | 1 | [User A] |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| Whole Foods | 1 | [用户A] |'
- en: '| Hard Rock | 1 | [User B] |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| 硬石 | 1 | [用户B] |'
- en: '| Hilton Barcelona | 1 | [User A] |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| 希尔顿巴塞罗那 | 1 | [用户A] |'
- en: It is clear from this table that the thief is operating in the Burger King restaurant,
    because it is the only merchant that all the users have in common and because
    in each case the fraud started after a transaction there.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 从这张表中可以清楚地看出，小偷在汉堡王餐厅进行操作，因为这是所有用户都有的唯一商人，并且因为每次欺诈都是在那里交易之后开始的。
- en: Starting from this result, the analysis can go deeper, using the graph to search
    for other kinds of patterns, and the result can be converted to a decline action
    that will prevent any further transactions from the identified point of origin
    until further investigations have been conducted.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个结果开始，分析可以进一步深入，使用图形来寻找其他类型的模式，并将结果转换为一种下降行动，防止从识别的源头进行任何进一步的交易，直到进一步的调查完成。
- en: In this scenario, the graph is used to store the single source of truth on which
    analysis is performed by using graph queries. Furthermore, the data can be visualized
    in the form of a graph for further analysis and investigation. The related mental
    model is shown in figure 2.19.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，图被用来存储分析所使用的单一真实来源，数据可以以图形的形式进行可视化，以便进行进一步的分析和调查。相关的心智模型如图2.19所示。
- en: '![CH02_F19_Negro](../Images/CH02_F19_Negro.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F19_Negro](../Images/CH02_F19_Negro.png)'
- en: Figure 2.19 The areas of our mental map that are relevant to this scenario
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.19 与此场景相关的我们心智地图的区域
- en: 'This example is a simplification of the approach to revealing fraud, but it
    showcases some of the advantages of using a graph database for this type of analysis.
    Such advantages can be summarized as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子是对揭示欺诈方法的简化，但它展示了使用图数据库进行此类分析的一些优点。这些优点可以总结如下：
- en: '*Multiple data sources*, such as geographical or GPS information, social network
    data, user personal profiles, family data, and the like, can be merged in a single
    connected source of truth.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*多个数据源*，如地理或GPS信息、社交网络数据、用户个人资料、家庭数据等，可以合并到一个单一的真实来源中。'
- en: Existing data can be extended with *external sources of knowledge* (shop locations,
    people’s addresses, and so on) or with *contextual information* (a new shop, other
    complaints, and the like) that can be used to improve the analysis.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以用*外部知识来源*（商店位置、人们的地址等）或*上下文信息*（新商店、其他投诉等）来扩展现有数据，这些信息可以用以提高分析。
- en: The same data model can support *several analysis techniques* (to uncover a
    fraud ring,[⁶](#pgfId-1010842) for example).
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相同的数据模型可以支持*多种分析技术*（例如，揭露欺诈团伙[⁶](#pgfId-1010842)）。
- en: Data can be *visualized as a graph* to speed the manual analysis.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据可以*以图形的形式可视化*，以加快手动分析的速度。
- en: The analysis can be extended to multiple levels of interaction, considering
    *multiple hops*.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析可以扩展到多个交互级别，考虑到*多个跳数*。
- en: The structure *simplifies the merging and cleaning* operation, thanks to the
    flexible access pattern provided by the graph model.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该结构*简化了合并和清理操作*，这得益于图形模型提供的灵活访问模式。
- en: In the fraud-analysis scenario, the graph represents the *main source of knowledge*
    for the merged, cleaned, and extended data, on top of which the analysis is performed
    and based on which any decisions are taken. Unlike in the graph-based Lambda Architecture
    described in section 2.2.1, here the graph plays the role of master dataset and
    is the foundation for *master data management* (MDM)—the practice of identifying,
    cleaning, storing, and governing data [Robinson et al., 2015]. The key concerns
    of MDM include
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在欺诈分析场景中，图代表了合并、清理和扩展数据的主要知识来源，分析是在其上进行的，并且任何决策都是基于它做出的。与第2.2.1节中描述的基于图形的Lambda架构不同，在这里，图扮演了主数据集的角色，是*主数据管理*（MDM）的基础——识别、清理、存储和管理数据[Robinson等人，2015]。MDM的关键关注点包括
- en: '*Managing changes* over time as organizational structures change, businesses
    merge, and business rules evolve'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着组织结构的变化、企业的合并和业务规则的演变，*管理变化*。
- en: Incorporating *new sources* of data
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结合*新的数据来源*
- en: Supplementing existing data with *external data sources*
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用*外部数据源*补充现有数据
- en: Addressing the needs of reporting, compliance, and business intelligence consumers
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 满足报告、合规性和商业智能消费者的需求
- en: '*Versioning data* as its values and schema change'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着其值和模式的变化，*版本化数据*。
- en: 'MDM is not an alternative or modern version of data warehousing (DW), although
    the two practices have a lot in common. DW relates to the storage of historical
    data, whereas MDM deals with current data. An MDM solution contains the current
    and complete information for all business entities within a company. DW contains
    only historical data to be used for some kind of static analysis. When done correctly,
    MDM has numerous advantages that can be summarized as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: MDM不是数据仓库（DW）的替代品或现代版本，尽管这两种实践有很多共同之处。DW与历史数据的存储有关，而MDM处理当前数据。MDM解决方案包含公司内所有业务实体的当前和完整信息。DW仅包含用于某种静态分析的历史数据。当正确实施时，MDM具有许多优势，可以概括如下：
- en: '*Streamlining* data sharing among personnel and departments'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*简化*人员与部门之间的数据共享'
- en: '*Facilitating* computing in multiple system architectures, platforms, and applications'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*促进*在多个系统架构、平台和应用中的计算'
- en: '*Removing* inconsistencies and duplications from data'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*消除*数据中的不一致性和重复'
- en: '*Reducing* unnecessary frustration when searching for information'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*减少*在搜索信息时产生的无谓挫折'
- en: '*Simplifying* business procedures'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*简化*业务流程'
- en: '*Improving* communication throughout the organization'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*提高*组织内的沟通效率'
- en: Furthermore, when a proper MDM solution is in place, more faith can be placed
    in the data analysis provided by the system, improving confidence in decisions
    made based on that data. In this context, graph databases “don’t provide a full
    MDM solution; they are, however, ideally suited to the modeling, storing, and
    querying of hierarchies, master data metadata, and master data models. Such models
    include type definitions, constraints, relationships between entities, and the
    mappings between the model and the underlying source systems” [Robinson et al.,
    2015].
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当适当的MDM解决方案到位时，可以更多地相信系统提供的数据分析，从而提高基于该数据的决策的信心。在这种情况下，图数据库“并不提供完整的MDM解决方案；然而，它们非常适合于层次结构、主数据元数据和主数据模型的建模、存储和查询。这些模型包括类型定义、约束、实体之间的关系以及模型与底层源系统之间的映射”
    [Robinson等人，2015]。
- en: 'Graph-based MDM has the following advantages:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 基于图的MDM具有以下优势：
- en: '*Flexibility*—The data captured can be easily changed to include additional
    attributes and objects.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*灵活性*—捕获的数据可以轻松更改，以包括额外的属性和对象。'
- en: '*Extensibility*—The model allows the rapid evolution of the master data model
    in line with changing business needs.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可扩展性*—该模型允许主数据模型随着业务需求的变化而快速演变。'
- en: '*Search capability*—Each node, each relationship, and all their related properties
    are search entry points.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*搜索能力*—每个节点、每个关系以及它们的所有相关属性都是搜索入口点。'
- en: '*Indexing capability*—Graph databases are naturally indexed by both relationships
    and nodes, providing faster access compared to relational data.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*索引能力*—图数据库自然由关系和节点索引，与关系型数据相比提供更快的访问速度。'
- en: A graph-based MDM solution addresses different types of functionality. In the
    fraud-detection scenario, as well as in the rest of the book, it is considered
    to be part of the analytics/machine learning platform, operating as the main data
    source and extended by the resulting model, and represents an alternative approach
    to the graph-based Lambda Architecture.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 基于图的MDM解决方案解决了不同类型的功能。在欺诈检测场景中，以及本书的其余部分，它被视为分析/机器学习平台的一部分，作为主要数据源，并由生成的模型扩展，代表了基于图Lambda架构的替代方法。
- en: Another interesting scenario in which graphs can represent MDM systems storing
    data for training purposes is in recommendation engines. In this case, the graph
    can store the user-to-item matrix containing the interaction history between the
    users and the items. We will consider this scenario in more detail in chapter
    3.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图可以表示存储用于训练目的的数据的MDM系统的一个有趣场景是推荐引擎。在这种情况下，图可以存储包含用户与项目之间交互历史的用户-项目矩阵。我们将在第3章中更详细地考虑这个场景。
- en: 2.3 Graph databases
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 图数据库
- en: Section 2.2 introduced some methodological machine learning approaches that
    use graphs and presented concrete examples illustrating how to use graphs as storage
    and access models for data to empower predictive analysis. To use such models
    in an optimal way, you have to be able to store, manipulate, and access the graphs
    in the same way that you are thinking about them in your data flow or in your
    algorithms. To accomplish this task, you need a graph database as a storage engine.
    A *graph database* allows you to store and manipulate entities (also known as
    *nodes*) and the connections between these entities (also known as *relationships*).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 第2.2节介绍了一些使用图的机器学习方法，并展示了如何将图作为数据存储和访问模型来增强预测分析的具体示例。为了以最佳方式使用这些模型，您必须能够以与您在数据流或算法中思考它们相同的方式存储、操作和访问图。为了完成这项任务，您需要一个图数据库作为存储引擎。*图数据库*允许您存储和操作实体（也称为*节点*）以及这些实体之间的连接（也称为*关系*）。
- en: This section describes the technological aspects related to graph management.
    This perspective is relevant in a machine learning project’s life cycle, during
    which you have to manipulate, store, and access real data. Furthermore, in most
    cases you will be working with big data, so you must take scalability issues into
    account. *Sharding* (splitting data horizontally across multiple servers) and
    *replication* (copying data across multiple servers, for high availability and
    scalability purposes) are presented in this context.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了与图管理相关的技术方面。这种视角在机器学习项目的生命周期中是相关的，在此期间您必须操作、存储和访问真实数据。此外，在大多数情况下，您将处理大数据，因此您必须考虑可伸缩性问题。*分片*（在多个服务器上水平分割数据）和*复制*（为了高可用性和可伸缩性目的在多个服务器上复制数据）在此背景下介绍。
- en: Many graph databases are available, but not all of them are *native* (built
    from the ground up for graphs); instead, they offer a graph “view” on top of a
    nongraph storage model. This nonnative approach leads to performance issues during
    storage and querying. A proper native graph database, on the other hand, uses
    a graph model for storing and processing the data, making graph manipulation straightforward,
    intuitive, and performant. The key differences are highlighted in section 2.3.4.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 许多图数据库都可用，但并非所有都是*原生*（从头开始为图构建的）；相反，它们在非图存储模型之上提供了一个图“视图”。这种非原生方法会导致存储和查询时的性能问题。另一方面，适当的原生图数据库使用图模型来存储和处理数据，使得图操作简单、直观且高效。关键差异在第2.3.4节中突出显示。
- en: In many cases, I would say almost always, because you need at least a node identification,
    it could be useful to add some properties to nodes and relationships. In other
    words, it is necessary to group nodes in the same class. These “features” dramatically
    improve the expressivity and modeling capability of graph databases. Label property
    graphs, which satisfy such needs, are introduced in section 2.3.5.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，我可以说几乎总是如此，因为您至少需要一个节点标识，可能还需要为节点和关系添加一些属性。换句话说，有必要将节点分组在同一类别中。这些“特征”显著提高了图数据库的表达能力和建模能力。满足此类需求的标签属性图在第2.3.5节中介绍。
- en: Although all the theories, examples, and use cases presented in the book are
    completely technology agnostic, we will use Neo4j (introduced in appendix B) as
    the reference database platform. Neo4j not only is one of the few proper graph
    databases available that provide high performance, but also has a powerful and
    intuitive query language called Cypher.[⁷](#pgfId-1010878)
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本书中展示的所有理论、示例和用例都是完全技术无关的，但我们将使用Neo4j（附录B中介绍）作为参考数据库平台。Neo4j不仅是最少数几个提供高性能的适当图数据库之一，而且还有一个功能强大且直观的查询语言，称为Cypher。[⁷](#pgfId-1010878)
- en: 2.3.1 Graph database management
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.1 图数据库管理
- en: Using graphs in a machine learning project requires you to store, access, query,
    and manage each of those graphs. All those tasks fall into the general category
    of graph database management, as depicted in figure 2.20.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器学习项目中使用图需要您存储、访问、查询和管理这些图中的每一个。所有这些任务都属于图数据库管理的范畴，如图2.20所示。
- en: '![CH02_F20_Negro](../Images/CH02_F20_Negro.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F20_Negro](../Images/CH02_F20_Negro.png)'
- en: Figure 2.20 Graph database management tasks
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.20 图数据库管理任务
- en: 'This figure shows the three main areas into which graph data management tasks
    can be grouped:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 此图显示了可以将图数据管理任务分为的三个主要区域：
- en: '*Graph modeling*—In general terms, the graph model is the fundamental abstraction
    behind a database system—the conceptual tool used to model representations of
    real-world entities and the relationships among them. One of the main features
    of a graph structure is the simplicity of modeling unstructured data. In graph
    models, the separation between schema and data is less substantial than in the
    classical relational model [Angles and Gutierrez, 2017]. At the same time, a graph
    model is flexible and extensible. The same aspect of reality or the same problem
    can be mapped in multiple ways in a graph model. Different models can address
    different problems from different perspectives, so defining the right model requires
    effort and experience. Luckily, the “schemaless” nature of graphs means that the
    models, even those defined during the early stages of a project, can be changed
    with relatively little effort. When you’re using other types of NoSQL databases
    or relational databases, on the other hand, a change in the model could require
    a complete reingestion. This operation on big data could be an expensive task
    in terms of money, time, and effort. Furthermore, the model design affects the
    performance of all the queries and analyses performed on the graph. Therefore,
    modeling is a crucial aspect of data management. Some model examples are described
    earlier in this chapter, and in the following chapters, we’ll look at several
    more use cases and consider the advantages and drawbacks of the related models.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*图建模*—从一般意义上讲，图模型是数据库系统背后的基本抽象——用于建模现实世界实体及其之间关系的概念工具。图结构的一个主要特征是建模非结构化数据的简单性。在图模型中，模式与数据之间的分离不如在经典的关系模型中那么显著[Angles
    and Gutierrez, 2017]。同时，图模型是灵活和可扩展的。在图模型中，现实或问题的同一方面可以以多种方式映射。不同的模型可以从不同的角度解决不同的问题，因此定义正确的模型需要努力和经验。幸运的是，图的“无模式”特性意味着模型，即使在项目的早期阶段定义的模型，也可以相对容易地进行更改。另一方面，当你使用其他类型的NoSQL数据库或关系数据库时，模型的变化可能需要完全重新导入。在大数据中，这种操作可能从金钱、时间和努力的角度来看是一项昂贵的任务。此外，模型设计会影响在图上执行的所有查询和分析的性能。因此，建模是数据管理的一个关键方面。本章前面已描述了一些模型示例，在接下来的章节中，我们将探讨几个更多的用例，并考虑相关模型的优缺点。'
- en: '*Graph storage*—When the model is defined, the data has to be stored in a persistent
    layer. Graph DBMSs are specifically designed to manage graphlike data, following
    the common principles of database systems: persistent data storage, memory use,
    caching, physical/logical data independence, query languages, data integrity and
    consistency, and so on. Additionally, the graph database vendor has to take care
    of all the aspects related to scalability, reliability, and performance, such
    as backup, recovery, horizontal and vertical scalability, and data redundancy.
    We will discuss the key concepts of graph DBMSs in this section—specifically,
    those that affect the model and the way in which data is accessed during processing.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*图存储*—当模型定义完成后，数据必须存储在一个持久层中。图数据库管理系统（Graph DBMSs）专门设计用于管理类似图的数据，遵循数据库系统的通用原则：持久数据存储、内存使用、缓存、物理/逻辑数据独立性、查询语言、数据完整性和一致性等。此外，图数据库供应商还需要负责与可扩展性、可靠性和性能相关的所有方面，例如备份、恢复、横向和纵向可扩展性以及数据冗余。在本节中，我们将讨论图数据库管理系统（Graph
    DBMSs）的关键概念——特别是那些影响模型以及在处理过程中访问数据的方式的概念。'
- en: '*Graph processing*—These tasks involve frameworks (such as tools, query languages,
    and algorithms) for processing and analysis of graphs. Sometimes, processing graphs
    involves using multiple machines to improve performance. Some processing features,
    such as query languages and some graph access patterns, are available in the graph
    DBMS itself; others are available as algorithms or external platforms that have
    to be implemented on top of the graphs and the graph DBMS.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*图处理*—这些任务涉及用于处理和分析图的框架（例如工具、查询语言和算法）。有时，处理图需要使用多台机器以提高性能。一些处理功能，如查询语言和某些图访问模式，在图数据库管理系统（Graph
    DBMS）本身中可用；其他则作为算法或外部平台提供，这些平台必须建立在图和图数据库管理系统之上。'
- en: 'Graph processing is a wide-ranging topic, and the related tasks can be broadly
    divided into a few categories. Özsu [2015] presents an interesting way of classifying
    graph processing, organized along three dimensions: graph dynamism, algorithm
    types, and workload types (see figure 2.21).'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图处理是一个广泛的话题，相关任务可以大致分为几个类别。Özsu [2015] 提出了一种有趣的图处理分类方法，该方法沿三个维度组织：图动态性、算法类型和工作负载类型（见图2.21）。
- en: '![CH02_F21_Negro](../Images/CH02_F21_Negro.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F21_Negro](../Images/CH02_F21_Negro.png)'
- en: Figure 2.21 Property graph processing taxonomy [Özsu, 2015]
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.21 属性图处理分类法 [Özsu, 2015]
- en: The complex topic of graph processing will be discussed throughout the book.
    Different algorithms will be presented along the way, and they will be mapped
    with specific real use cases or examples of applications in which they are useful
    for extracting insight.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图处理这一复杂主题将在整本书中讨论。将介绍不同的算法，并将它们与特定的实际用例或应用实例相对应，这些实例展示了它们在提取洞察力方面的有用性。
- en: 2.3.2 Sharding
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.2 分片
- en: Looking at big data applications from a pure data storage perspective, the main
    four Vs challenges are
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 从纯粹的数据存储角度来看，大数据应用面临的主要四个V挑战是
- en: '*Volume*—The volume of the data involved is so large that it is hard to store
    the data on a single machine.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数据量*——涉及的数据量如此之大，以至于难以存储在单台机器上。'
- en: '*Velocity*—A single machine can serve only a limited number of concurrent users.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*速度*—单台机器只能服务有限数量的并发用户。'
- en: Although vertical scaling—such as the addition of increased compute, storage,
    and memory resources—can be a temporary solution to handle large volumes of data
    and improve the response times for multiple concurrent users, the data will ultimately
    become too large to be stored on a single node and the number of users too high
    to be handled by a single machine.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管垂直扩展——如增加计算、存储和内存资源——可以作为一种临时解决方案来处理大量数据并提高多个并发用户的响应时间，但数据最终会变得太大，无法存储在单个节点上，用户的数量也会太高，无法由单台机器处理。
- en: In NoSQL databases, one common scaling technique is *sharding*, wherein a large
    dataset is split, and subsets are distributed across several shards on different
    servers. These shards or subsets are typically replicated across multiple servers
    to increase reliability and performance. A *sharding strategy* determines which
    data partitions should be sent to which shards. Sharding can be accomplished by
    means of various strategies, which can be managed by the application or by the
    data storage system itself.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在NoSQL数据库中，一种常见的扩展技术是*分片*，其中大型数据集被分割，子集被分布到不同服务器上的多个分片中。这些分片或子集通常在多个服务器上复制，以提高可靠性和性能。*分片策略*决定了哪些数据分区应该发送到哪些分片。分片可以通过各种策略实现，这些策略可以由应用程序或数据存储系统本身管理。
- en: For aggregate-oriented data models like key/value, column family, and document
    databases [Fowler and Sadalage, 2012], in which the only way to express relations
    between concepts is to aggregate them in a single data entry by using a value
    or document, this solution is a sensible one. In these kinds of stores, the key
    used to retrieve any item is known and stable, and the lookup mechanism is fast
    and predictable, so directing clients that want to store or retrieve data to an
    appropriate shard is straightforward [Webber, 2011].
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 对于面向聚合的数据模型，如键/值、列族和文档数据库[Fowler and Sadalage, 2012]，在这些模型中，表达概念之间关系的方式是将它们聚合在单个数据条目中，使用值或文档，这种解决方案是合理的。在这些类型的存储中，用于检索任何项目的键是已知且稳定的，查找机制快速且可预测，因此将想要存储或检索数据的客户端定向到适当的分片是直接的[Webber,
    2011]。
- en: 'The graph data model, on the other hand, is highly relationship-oriented. Each
    node can be related to any other node, so a graph doesn’t have predictable lookups.
    It also has a highly mutable structure: with few new links and few new nodes,
    the connection structure can change heavily. In these circumstances, sharding
    a graph database isn’t straightforward at all [Webber, 2011]. One possible solution
    would be to colocate related nodes and, hence, the related edges. This solution
    would boost graph traversal performance, but having too many connected nodes on
    the same database shard would make it heavily loaded, because a lot of data will
    be on the same shard, making it unbalanced. Figures 2.22 and 2.23 illustrate these
    concepts.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，图数据模型高度关系导向。每个节点都可以与任何其他节点相关联，因此图没有可预测的查找。它还具有高度可变的结构：在只有少量新链接和新节点的情况下，连接结构可以发生很大变化。在这些情况下，对图数据库进行分片并不简单[Webber,
    2011]。一个可能的解决方案是将相关的节点和相关的边放置在同一位置。这种解决方案将提高图遍历性能，但同一数据库分片上有太多连接的节点会使它负载过重，因为大量数据将位于同一分片上，导致其不平衡。图2.22和2.23说明了这些概念。
- en: Figure 2.22 shows how navigating a graph could involve crossing shard boundaries
    multiple times. This cross-shard traversal is quite expensive because it requires
    many network hops, resulting in substantially increased query times. In such a
    scenario, performance degrades quickly compared with the case in which everything
    happens on the same shard.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.22展示了在导航一个图时可能需要多次跨越分片边界。这种跨分片遍历非常昂贵，因为它需要许多网络跳转，导致查询时间显著增加。在这种情况下，与所有操作都在同一分片上的情况相比，性能会迅速下降。
- en: '![CH02_F22_Negro](../Images/CH02_F22_Negro.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F22_Negro](../Images/CH02_F22_Negro.png)'
- en: Figure 2.22 Traversing relationships belonging to different shards
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.22 不同分片间的关系遍历
- en: In figure 2.23, to overcome this issue, the related nodes are stored on the
    same shard. The graph traversal is faster, but the load between shards is highly
    unbalanced. Moreover, due to the dynamic nature of the graphs, graphs and their
    access patterns can change rapidly and unpredictably at run time, making this
    solution inconvenient to implement in practice.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在图2.23中，为了克服这个问题，相关的节点被存储在同一分片上。图遍历更快，但分片间的负载极不平衡。此外，由于图具有动态特性，图及其访问模式在运行时可能会迅速且不可预测地发生变化，这使得在实际中实施这种解决方案不太方便。
- en: 'With these challenges in mind, generally speaking, there are three techniques
    for scaling a graph database:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些挑战，一般来说，有三种技术可以用于扩展图数据库：
- en: '![CH02_F23_Negro](../Images/CH02_F23_Negro.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F23_Negro](../Images/CH02_F23_Negro.png)'
- en: Figure 2.23 Overloading of a single shard (shard 2)
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.23 单个分片（分片2）的过载
- en: '*Application-level sharding*—In this case, the sharding of the data is accomplished
    on the application side by using domain-specific knowledge. For a global business,
    nodes that relate to North America can be created on one server, and nodes that
    relate to Asia can be on another. This application-level sharding needs to understand
    that nodes are stored on physically different databases. The sharding could also
    be based on the different types of analysis or graph processing that have to be
    performed on the data. In such cases, each shard contains all the data required
    to execute the algorithm, and some nodes can be replicated across the shards.
    Figure 2.24 depicts application-level sharding.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*应用级分片*——在这种情况下，数据的分片是在应用层面通过使用领域特定知识完成的。对于一个全球业务，与北美相关的节点可以创建在一个服务器上，而与亚洲相关的节点可以位于另一个服务器上。这种应用级分片需要理解节点存储在物理上不同的数据库中。分片也可以基于必须对数据进行的不同类型分析或图处理。在这种情况下，每个分片包含执行算法所需的所有数据，并且一些节点可以在分片之间进行复制。图2.24描述了应用级分片。'
- en: '*Increasing the RAM or using cache sharding*—It is possible to scale the server
    vertically, adding more RAM so that the entire database fits in memory. This solution
    makes graph traversal extremely fast but is both unreasonable and unfeasible for
    large databases. In such a case, it is possible to adopt a technique called cache
    sharding to maintain high performance with a dataset whose size far exceeds the
    main memory space. Cache sharding isn’t sharding in the traditional sense, because
    we expect the full dataset to be present on each database instance. To implement
    cache sharing, we partition the workload undertaken by each database instance
    to increase the likelihood of hitting a warm cache for a given request. (Warm
    caches in graph databases like Neo4j are highly performant.)'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*增加RAM或使用缓存分片*——可以垂直扩展服务器，添加更多RAM，使整个数据库适合内存。这种解决方案使图遍历非常快，但对于大型数据库来说既不合理也不可行。在这种情况下，可以采用一种称为缓存分片的技术，以保持高性能，同时数据集的大小远超过主内存空间。缓存分片在传统意义上不是分片，因为我们期望完整的数据集存在于每个数据库实例上。为了实现缓存共享，我们将每个数据库实例承担的工作量进行分区，以增加给定请求命中热缓存的可能性。（在像Neo4j这样的图数据库中，热缓存性能非常高。）'
- en: '*Replication*—It is possible to achieve scaling of the database by adding more
    (identical) copies of the database that act as followers with read-only access.
    When you pair a relatively high number of follower database instances, which are
    read-only, with a small number of leader database instances, you can achieve a
    high level of scalability. This technique is described in section 2.3.3\. Other
    techniques have other pros and cons and are not discussed here.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*复制*——可以通过添加更多（相同的）数据库副本来实现数据库的扩展，这些副本作为只读访问的跟随者。当您将相对较高数量的只读跟随者数据库实例与少量领导者数据库实例配对时，可以实现高度的扩展性。这种技术在第2.3.3节中描述。其他技术有其优缺点，这里不予讨论。'
- en: '![CH02_F24_Negro](../Images/CH02_F24_Negro.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F24_Negro](../Images/CH02_F24_Negro.png)'
- en: Figure 2.24 Application-level isolation of sharding
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.24 应用级分片隔离
- en: 'Sharding is more effective in some situations than others. Consider the two
    scenarios discussed earlier in this chapter:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，分片比其他情况更有效。考虑本章前面讨论的两个场景：
- en: In the cellular tower monitoring example, a graph is created for each monitored
    subject, so the machine learning model produces multiple independent graphs that
    will be accessed in isolation. In this case, application-level sharding is an
    easy task, because all the graphs are isolated. To generalize, in the graph-based
    Lambda Architecture scenario, with multiple graph views created on the same dataset,
    we can store the views in multiple database instances because they are accessed
    in an independent way.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在蜂窝基站监控示例中，为每个监控对象创建一个图，因此机器学习模型会产生多个独立的图，这些图将单独访问。在这种情况下，应用级分片是一个简单的任务，因为所有图都是隔离的。为了推广，在基于图的Lambda架构场景中，在同一个数据集上创建了多个图视图，我们可以将视图存储在多个数据库实例中，因为它们以独立的方式访问。
- en: In the second use case (fraud detection), sharding would be tricky because in
    theory, all the nodes can be connected. Some heuristics can be applied to reduce
    cross-shard traversals or to keep nodes that are frequently accessed together
    on the same shard, but the graph cannot be divided into multiple isolated graphs,
    as in the preceding use case. In such cases, another option is to use replication
    to scale read performance and speed analysis time.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第二个用例（欺诈检测）中，分片会很棘手，因为在理论上，所有节点都可以连接。可以应用一些启发式方法来减少跨分片遍历，或将频繁访问的节点保持在同一分片上，但图不能像前一个用例那样分成多个独立的图。在这种情况下，另一种选择是使用复制来扩展读取性能并加快分析时间。
- en: 2.3.3 Replication
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.3 复制
- en: 'As discussed in section 2.3.2, sharding is a difficult task in graph databases.
    A valid alternative for dealing with velocity and availability is replication.
    Data replication consists of maintaining multiple copies of data, called *replicas*,
    on separate computers. Replication has several purposes [Özsu and Valduriez, 2011]:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如第2.3.2节所述，在图数据库中，分片是一个困难的任务。处理速度和可用性的一个有效替代方案是复制。数据复制包括在多个不同的计算机上维护数据的多个副本，这些副本被称为*副本*。复制有几个目的
    [Özsu and Valduriez, 2011]：
- en: '*System availability*—Replication removes single points of failure from distributed
    DBMSs by making data items accessible from multiple sites. Even when some cluster
    nodes are down, data should remain available.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*系统可用性*——通过使数据项可以从多个站点访问，复制从分布式数据库管理系统中移除了单点故障。即使某些集群节点关闭，数据也应保持可用。'
- en: '*Performance*—Replication enables us to reduce latency by locating the data
    closer to its access points.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*性能*——复制使我们能够通过将数据定位在其访问点附近来减少延迟。'
- en: '*Scalability*—Replication allows systems to grow, both geographically and in
    terms of the number of access requests, while maintaining acceptable response
    times.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可扩展性*——复制允许系统在地理上和访问请求的数量上增长，同时保持可接受的响应时间。'
- en: '*Application requirements*—As part of their operational specifications, applications
    may require multiple copies of the data to be maintained.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*应用需求*——作为它们操作规范的一部分，应用程序可能需要维护数据的多个副本。'
- en: 'Data replication has clear benefits, but keeping the different copies synchronized
    is a challenge. A fundamental design decision in defining a replication protocol
    is where the database updates are first performed. The techniques can be characterized
    as follows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 数据复制具有明显的优势，但保持不同副本同步是一个挑战。在定义复制协议时，数据库更新首先在哪里执行是一个基本的设计决策。这些技术可以按以下方式描述：
- en: '*Centralized* if they first perform updates on a master copy. Centralized techniques
    can be further identified as *single master* when there is only one master database
    copy for all data items in the system or *primary copy* when there can be a single
    master copy for each data item or set of data items.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*集中式*如果它们首先在主副本上执行更新。集中式技术可以根据系统中的所有数据项只有一个主数据库副本被进一步识别为*单主节点*，或者当每个数据项或数据项集可以有一个单独的主副本时，被识别为*主副本*。'
- en: '*Distributed* if they allow updates to any replica.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分布式*如果它们允许对任何副本进行更新。'
- en: Due to the highly connected nature of graphs, implementing either a centralized
    primary copy protocol or a distributed protocol is a difficult task, one that
    has serious effects on performance and data consistency, to mention the most critical.
    (In a graph, a data item could be a node or a relation; a relation is connected,
    by definition, to two other data items—the nodes—and a node is likely to be connected
    to other nodes through multiple relationships.) Therefore, we will focus on the
    centralized approach with a single master, also described as *master/slave replication*.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 由于图的高度连通性，实现集中式主副本协议或分布式协议是一项困难的任务，这对性能和数据一致性有严重影响。（在图中，数据项可以是节点或关系；根据定义，关系连接到两个其他数据项——节点，而节点可能通过多个关系与其他节点连接。）因此，我们将重点关注具有单个主节点的集中式方法，也称为*主/从复制*。
- en: 'In this approach, one node is designated as the authoritative source for the
    data, known as the *master*, *leader*, or *primary*. This node is typically responsible
    for processing any updates to that data. Even when slaves accept writes, those
    operations have to pass through the master to be performed (see figure 2.25).
    Master/slave replication is most useful if most of your data access is reads.
    By adding more slave nodes and routing all read requests to the slaves, you can
    scale horizontally. Master/slave replication also provides read resilience: if
    the master fails, the slaves can still handle requests [Fowler and Sadalage, 2012].'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，一个节点被指定为数据的主授权源，被称为*主节点*、*领导者*或*主副本*。这个节点通常负责处理对该数据的任何更新。即使从节点接受写入操作，这些操作也必须通过主节点执行（见图2.25）。如果大部分数据访问都是读取操作，主/从复制非常有用。通过添加更多从节点并将所有读取请求路由到从节点，可以实现水平扩展。主/从复制还提供了读取弹性：如果主节点失败，从节点仍然可以处理请求
    [Fowler and Sadalage, 2012]。
- en: '![CH02_F25_Negro](../Images/CH02_F25_Negro.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F25_Negro](../Images/CH02_F25_Negro.png)'
- en: Figure 2.25 Replication based on a master/slave protocol
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.25 基于 master/slave 协议的复制
- en: Most implementations of the master/slave protocol allow the slaves to vote for
    a different master if the current one becomes unavailable. This approach increases
    the availability and the reliability of the architectural stack. Specifically,
    in a machine learning project, replication allows the reading load to be spread
    across all the nodes during the training or prediction phase.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数主/从协议的实现允许从节点在当前主节点不可用时投票选择不同的主节点。这种方法增加了架构堆栈的可用性和可靠性。具体来说，在一个机器学习项目中，复制允许在训练或预测阶段将读取负载分散到所有节点。
- en: 2.3.4 Native vs. non-native graph databases
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.4 原生与非原生图数据库
- en: This book describes multiple methods by which graphs can empower a machine learning
    project. To get the greatest advantages from the graph model, a proper graph DBMS
    for storing, accessing, and processing graphs is required. Although the model
    itself is reasonably consistent across the multiple graph database implementations,
    there are numerous ways to encode and represent graphs in the different database
    engines. A DBMS built to handle graph workloads across the entire computing stack,
    from the query language to the database management engine and filesystem and from
    clustering to backup and monitoring, is called a *native graph database* [Webber,
    2018]. Native graph databases are designed to use the filesystem in a way that
    not only understands but also supports graphs, which means that they are both
    highly performant and safe for graph workloads. In more detail, a native graph
    DBMS exhibits a property called *index-free adjacency*, which means that each
    node maintains direct references to its adjacent nodes. The adjacency list representation
    is one of the most common ways to represent sparse graphs.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 本书描述了多种方法，通过这些方法图可以增强机器学习项目。为了从图模型中获得最大的优势，需要一个合适的图数据库管理系统来存储、访问和处理图。尽管模型本身在多个图数据库实现中相对一致，但在不同的数据库引擎中编码和表示图的方法有很多。一个旨在处理整个计算堆栈上的图工作负载的数据库管理系统，从查询语言到数据库管理引擎和文件系统，从集群到备份和监控，被称为
    *原生图数据库* [Webber, 2018]。原生图数据库被设计为以理解并支持图的方式使用文件系统，这意味着它们不仅对图工作负载性能高，而且安全。更详细地说，原生图数据库管理系统具有一种称为
    *无索引邻接* 的属性，这意味着每个节点都维护对其相邻节点的直接引用。邻接表表示是表示稀疏图最常见的方法之一。
- en: Formally, this representation of a graph G = (V, E) consists of an array Adj
    of lists, one for each vertex in V. For each vertex u in V, the adjacency list
    Adj[u] contains all the vertices v for which there exists an edge E[uv] between
    u and v in E. In other words, Adj[u] consists of all the vertices adjacent to
    u in G [Cormen et al., 2009].
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 从形式上讲，这种表示图 G = (V, E) 的方法由一个邻接表数组 Adj 组成，每个顶点 V 中都有一个列表。对于 V 中的每个顶点 u，邻接表 Adj[u]
    包含所有与 u 相邻的顶点 v，其中在 E 中存在边 E[uv]。换句话说，Adj[u] 包含 G 中与 u 相邻的所有顶点 [Cormen 等人，2009]。
- en: Figure 2.26(b) is an adjacency list representation of the undirected graph in
    figure 2.26(a). Vertex 1, for example, has two neighbors, 2 and 5, so Adj[1] is
    the list [2,5]. Vertex 2 has three neighbors, 1, 4, and 5, so Adj[2] is [1,4,5].
    The other lists are created in the same way. It is worth nothing here that because
    there is no order in the relationships, there is no specific order in the lists;
    hence, Adj[1] could be [2,5] as well as [5, 2].
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.26(b) 是图 2.26(a) 中无向图的邻接表表示。例如，顶点 1 有两个邻居，2 和 5，因此 Adj[1] 是列表 [2,5]。顶点 2
    有三个邻居，1、4 和 5，因此 Adj[2] 是 [1,4,5]。其他列表以相同的方式创建。这里值得注意的是，由于关系没有顺序，列表中也没有特定的顺序；因此，Adj[1]
    也可以是 [2,5] 或 [5, 2]。
- en: '![CH02_F26_Negro](../Images/CH02_F26_Negro.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F26_Negro](../Images/CH02_F26_Negro.png)'
- en: Figure 2.26 An undirected graph (a) and the related representation as an adjacency
    list (b)
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.26 一个无向图（a）及其作为邻接表的表示（b）
- en: Similarly, figure 2.27(b) is an adjacency list representation of the directed
    graph in figure 2.27(a). Such a list is visualized as a linked list, in which
    each entry contains a reference to the next one. In the adjacency list for node
    1, the first element is node 2 and the reference to the next one is the element
    for node 5\. This approach is one of the most common for storing the adjacency
    list, because it makes addition and deletion elements efficient. In this case,
    we consider only the outgoing relationships, but we can do the same thing with
    the ingoing relationships; what is important is to choose a direction and keep
    it consistent during the creation of the adjacency list. Here, vertex 1 has only
    one outgoing relationship, with vertex 2, so Adj[1] will be [2]. Vertex 2 has
    two outgoing relationships, with 4 and 5, so Adj[2] is [4,5]. Vertex 4 has no
    outgoing relationships, so Adj[4] is empty ([]).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，图 2.27(b) 是图 2.27(a) 中有向图的邻接表表示。这种列表被表示为链表，其中每个条目都包含对下一个条目的引用。在节点 1 的邻接表中，第一个元素是节点
    2，对下一个元素的引用是节点 5 的元素。这种方法是存储邻接表最常见的方法之一，因为它使得添加和删除元素变得高效。在这种情况下，我们只考虑出边关系，但我们可以用相同的方法处理入边关系；重要的是要选择一个方向并在创建邻接表的过程中保持一致性。在这里，顶点
    1 只有一个出边关系，与顶点 2 相连，因此 Adj[1] 将是 [2]。顶点 2 有两个出边关系，与 4 和 5 相连，因此 Adj[2] 是 [4,5]。顶点
    4 没有出边关系，因此 Adj[4] 是空的 ([])。
- en: '![CH02_F27_Negro](../Images/CH02_F27_Negro.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F27_Negro](../Images/CH02_F27_Negro.png)'
- en: Figure 2.27 A directed graph (a) and the related representation as an adjacency
    list (b)
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.27 一个有向图（a）及其相关的邻接表表示（b）
- en: If G is a directed graph, the sum of the lengths of all the adjacency lists
    is |E|. Because every edge can be traversed in a single direction, E[uv] will
    appear only in Adj[u]. If G is an undirected graph, the sum of the lengths of
    all the adjacency lists is 2 × |E| because if E[uv] is an undirected edge, E[uv]
    appears in Adj[u] and Adj[v]. The memory required by an adjacency list representation
    of either a directed or an undirected graph is directly proportional to |V| +
    |E|.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果G是一个有向图，所有邻接表长度的总和是|E|。因为每条边只能沿一个方向遍历，所以E[uv]只会出现在Adj[u]中。如果G是一个无向图，所有邻接表长度的总和是2
    × |E|，因为如果E[uv]是一个无向边，E[uv]将出现在Adj[u]和Adj[v]中。无向或有向图的邻接表表示所需的内存与|V| + |E|成正比。
- en: Adjacency lists can be easily adapted to represent weighted graphs by storing
    the weight w of the edge E[uv] in Adj[u]. The adjacency list representation can
    be similarly modified to support many other graph variants too. In such a representation,
    each node acts as a microindex of other nearby nodes, which is much cheaper than
    using global indexes. A traversal across a relationship in such a database has
    a constant cost, irrespective of the size of the graph. Also, the query times
    are independent of the total size of the graph; instead, they are proportional
    to the amount of the graph searched.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在Adj[u]中存储边E[uv]的权重w，邻接表可以很容易地适应表示加权图。邻接表表示法也可以类似地修改以支持许多其他图变体。在这种表示中，每个节点都充当其他附近节点的微观索引，这比使用全局索引便宜得多。在这样的数据库中，跨关系的遍历具有恒定的成本，与图的大小无关。此外，查询时间与图的总大小无关；相反，它们与搜索的图量成正比。
- en: 'The alternative is a *nonnative graph database*. Database systems in this group
    can be divided into two categories:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是**非原生图数据库**。这个组中的数据库系统可以分为两类：
- en: Those that layer a graph API on top of an existing different data structure,
    such as key/value, relational, document, or column-based store
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在现有不同数据结构（如键/值、关系型、文档型或基于列的存储）之上叠加图API的那些
- en: Those that claim multimodel semantics, in which one system purportedly can support
    several data models
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声称多模型语义的那些，即一个系统据说可以支持几种数据模型
- en: A nonnative graph engine is optimized for an alternative storage model, such
    as columnar, relational, document, or key/value data, so when dealing with graphs,
    the DBMS has to perform costly translations to and from the primary model of the
    database. Implementers can try to optimize these translations through radical
    denormalization, but this approach typically leads to high latency when querying
    graphs. In other words, a nonnative graph database will realistically never be
    as performant as a native graph database, for the simple reason that a translation
    process will need to occur.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 非原生图引擎针对的是替代存储模型，如列式、关系型、文档型或键/值数据，因此在处理图时，数据库管理系统必须执行昂贵的转换，从数据库的主模型转换到图模型。实施者可以通过极端的反规范化来尝试优化这些转换，但这种方法通常会导致查询图时的高延迟。换句话说，非原生图数据库在现实情况下永远不会像原生图数据库那样高效，简单的理由是转换过程是必需的。
- en: 'Understanding how the graph is stored helps you define a better model for it,
    with the “native” nature of a graph database being of critical importance. This
    concern is also related to the philosophy of this book:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 理解图是如何存储的有助于你为其定义一个更好的模型，其中图数据库的“原生”特性至关重要。这一关注点也与本书的哲学思想相关：
- en: In a successful machine learning project, every single aspect is relevant to
    delivering an efficient and performant service to the end user, where *efficient*
    and *performant* mean not only *accurate*, but also *delivered on time*.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个成功的机器学习项目中，每个方面都与向最终用户提供高效和性能良好的服务相关，其中“高效”和“性能良好”不仅意味着“准确”，还意味着“按时交付”。
- en: A highly accurate recommendation on a website, for example, would be useless
    if it were delivered in 30 seconds, as by that time, the user would likely be
    elsewhere.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个网站上的高度准确的推荐，如果它在30秒内送达，那么它将是无用的，因为到那时，用户可能已经去了别处。
- en: 'Sometimes, those aspects are considered to be secondary. A common misconception
    is that nonnative graph technology is good enough. To better understand the value
    of native support for graphs in the database engine for a machine learning project,
    let’s consider an example:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，这些方面被认为次要。一个常见的误解是，非本地图技术已经足够好。为了更好地理解在机器学习项目中数据库引擎对图的原生支持的价值，让我们考虑一个例子：
- en: You have to implement a supply chain management system that analyzes the entire
    chain to predict stock inventory issues in the future or spot bottlenecks in the
    network.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须实现一个供应链管理系统，该系统分析整个链以预测未来的库存问题或发现网络中的瓶颈。
- en: The Council of Supply Chain Management Professionals defines supply chain management
    as a system that “encompasses the planning and management of all activities involved
    in sourcing and procurement, conversion, and all logistics management activities.”[⁸](#pgfId-1010894)
    A supply chain can be modeled naturally as a graph, as shown in figure 2.28.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 供应链管理专业协会将供应链管理定义为“涵盖所有涉及采购、转换以及所有物流管理活动的计划和管理工作。”[⁸](#pgfId-1010894) 供应链可以自然地建模为图，如图2.28所示。
- en: '![CH02_F28_Negro](../Images/CH02_F28_Negro.png)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F28_Negro](../Images/CH02_F28_Negro.png)'
- en: Figure 2.28 A supply chain network
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.28 供应链网络
- en: Suppose now that you would like to store the supply chain network model by using
    a relational database or any other NoSQL database based on a global index. The
    relationships among the elements in the supply chain are represented in figure
    2.29.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 假设现在您想使用基于全局索引的关系数据库或任何其他NoSQL数据库来存储供应链网络模型。供应链中元素之间的关系如图2.29所示。
- en: '![CH02_F29_Negro](../Images/CH02_F29_Negro.png)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F29_Negro](../Images/CH02_F29_Negro.png)'
- en: Figure 2.29 A tabular model for storing the supply chain network
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.29 存储供应链网络的表格模型
- en: As the figure shows, these indexes add a layer of indirection to each traversal,
    thereby incurring greater computational cost. To find where Finished Product B
    will be delivered after it is produced, we first have to perform an index lookup,
    at cost O(log n),[⁹](#pgfId-1010909) and then get the list of next nodes in the
    chain. This approach may be acceptable for occasional or shallow lookups, but
    it quickly becomes intolerably expensive when we reverse the direction of the
    traversal (to find the intermediate steps required to create Finished Product
    C, for example).
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如图中所示，这些索引为每次遍历添加了一层间接层，从而增加了计算成本。要找到生产完成后B型成品将运往何处，我们首先必须执行索引查找，成本为O(log n)，[⁹](#pgfId-1010909)，然后获取链中下一个节点的列表。这种方法对于偶尔或浅层查找可能是可接受的，但当我们反转遍历方向（例如，找到创建C型成品所需的中间步骤）时，它很快就会变得难以忍受地昂贵。
- en: Suppose now that Raw Product A is contaminated or not available anymore, and
    we need to find all the products or shops affected by this issue in the chain.
    We would have to perform multiple index lookups, one for each node that is potentially
    in the chain between the raw product and the shops, which makes the cost far more
    onerous. Whereas it’s O(log n) cost to find out where Finished Product B will
    be delivered, to traverse a network of m steps, the cost of the indexed approach
    is O(m log n). In a native graph database with index-free adjacency, bidirectional
    joins are effectively precomputed and stored in the database as relationships,
    as represented in figure 2.30.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 假设现在原材料A被污染或不再可用，我们需要找到受此问题影响的链中所有产品或商店。我们必须执行多次索引查找，每次查找针对可能位于原材料和商店之间链中的每个节点，这使得成本变得更为沉重。而找到B型成品将运往何处的成本为O(log
    n)，要遍历m步网络，索引方法的成本为O(m log n)。在一个具有无索引邻接关系的本地图数据库中，双向连接实际上是预先计算并存储在数据库中的关系，如图2.30所示。
- en: '![CH02_F30_Negro](../Images/CH02_F30_Negro.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F30_Negro](../Images/CH02_F30_Negro.png)'
- en: Figure 2.30 A graph-based model for storing the supply chain
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.30 存储供应链的基于图模型
- en: In this representation, the cost of traversing a relationship when you have
    the first node is O(1), and it points directly to the next node. Performing the
    same traversal required before now costs only O(m). Not only is the graph engine
    faster, but also, the cost is related only to the number of hops (m), not to the
    total number of relationships (n).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种表示中，当你有第一个节点时，遍历关系的成本为O(1)，它直接指向下一个节点。执行之前所需的相同遍历现在只需O(m)。不仅图引擎更快，而且成本仅与跳数（m）有关，而不是与关系的总数（n）有关。
- en: Imagine now that you need to identify bottlenecks in the supply chain. One common
    method for spotting bottlenecks in a network is *betweenness centrality*, which
    is a measure of centrality (importance) in a graph based on calculating the shortest
    paths between nodes. The betweenness centrality of each node is the number of
    these shortest paths that pass through that node. In this case, the impact of
    the cost for an index lookup—O(log n)—will greatly affect the performance of the
    computation.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 假设现在你需要识别供应链中的瓶颈。在网络上发现瓶颈的一种常见方法是 *中介中心性*，它是一种基于计算节点之间最短路径的图中心性（重要性）度量。每个节点的中介中心性是通过该节点经过的最短路径的数量。在这种情况下，索引查找的成本——O(log
    n）将对计算性能产生重大影响。
- en: 'To recap, a native graph architecture provides many advantages that make it
    generally superior to a nonnative approach to managing graph models. We can summarize
    these advantages as follows:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，原生图架构提供了许多优势，使其在管理图模型方面通常优于非原生方法。我们可以将这些优势总结如下：
- en: '*“Minutes-to-milliseconds” performance*—Native graph databases handle connected
    data queries far faster than nonnative graph databases. Even on modest hardware,
    native graph databases can easily handle millions of traversals per second between
    nodes in a graph on a single machine and many thousands of transactional writes
    per second [Webber, 2017].'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*“分钟到毫秒”的性能*—原生图数据库处理连接数据查询的速度远快于非原生图数据库。即使在普通的硬件上，原生图数据库也可以轻松处理每秒数百万次图上节点的遍历，以及每秒数千次的事务性写入
    [Webber, 2017]。'
- en: '*Read efficiency*—Native graph databases can deliver constant-time traversals
    with index-free adjacency without complex schema design and query optimizations.
    The intuitive property graph model eliminates the need to create any additional,
    and often complex, application logic to process connections [Webber, 2017].'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*读效率*—原生图数据库可以在没有复杂模式设计和查询优化的情况下，通过无索引邻接实现常数时间遍历。直观的属性图模型消除了创建任何额外且通常复杂的应用程序逻辑来处理连接的需求
    [Webber, 2017]。'
- en: '*Disk space optimization*—To improve performance in a nonnative graph, it is
    possible to denormalize indexes or create new indexes, or a combination of both,
    affecting the amount of space required to store the same amount of information.'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*磁盘空间优化*—为了提高非原生图性能，可以非规范化索引或创建新索引，或者两者结合，这将影响存储相同信息所需的空间量。'
- en: '*Write efficiency*—Index denormalization also has an effect on write performance
    because all those additional index structures need to be updated as well.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*写效率*—索引非规范化也会对写性能产生影响，因为所有这些额外的索引结构也需要更新。'
- en: 2.3.5 Label property graphs
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.5 标签属性图
- en: A graph that is used to represent complex networks needs to store more information
    than a simple list of nodes and relationships. Fortunately, such simple structures
    can be easily extended to a richer model that contains additional information
    in the form of *properties*. Moreover, it is necessary to group nodes in classes
    and assign different types of relationships. Graph database management system
    providers introduced the *label property graph model* to tie a set of attributes
    to graph structures (nodes and relationships) and add classes or types to nodes
    and relationships. This data model allows a more complex set of query features
    typical of any DBMS, such as projection, filtering, grouping, and counting.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 用于表示复杂网络的图需要存储比简单的节点和关系列表更多的信息。幸运的是，这种简单的结构可以很容易地扩展到一个更丰富的模型，该模型包含以 *属性* 形式存在的附加信息。此外，有必要将节点分组到类中，并为不同类型的关系分配不同的类型。图数据库管理系统提供商引入了
    *标签属性图模型*，将一组属性与图结构（节点和关系）关联，并为节点和关系添加类或类型。这种数据模型允许具有任何数据库管理系统典型查询功能的更复杂的查询集，例如投影、过滤、分组和计数。
- en: According to the openCypher project,[^(10)](#pgfId-1010933) a label property
    graph is defined as “a directed, vertex-labeled, edge-labeled multigraph with
    self-edges,[^(11)](#pgfId-1010948) where edges have their own identity.” In a
    property graph, we use *node* to denote a vertex and *relationship* to denote
    an edge.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 openCypher 项目，[^(10)](#pgfId-1010933) 标签属性图被定义为“一个有向、顶点标记、边标记的多重图，[^(11)](#pgfId-1010948)
    其中边具有自己的标识。”在属性图中，我们用 *节点* 来表示顶点，用 *关系* 来表示边。
- en: 'A property graph has the following properties (defined here in a platform-agnostic
    way):'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 属性图具有以下属性（以下以平台无关的方式定义）：
- en: The graph consists of a set of *entities*. An entity represents either a *node*
    or a *relationship*.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图由一组*实体*组成。实体代表一个*节点*或一个*关系*。
- en: Each entity has an *identifier* that uniquely identifies it across the entire
    graph.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个实体都有一个*标识符*，它在整个图中唯一地标识它。
- en: Each relationship has a *direction*, a *name* that identifies the type of the
    relationship, a *start node*, and an *end node*.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个关系都有一个*方向*、一个*名称*，该名称标识关系的类型、一个*起始节点*和一个*结束节点*。
- en: An entity can have a set of *properties*, which are typically represented as
    key/value pairs.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体可以有一组*属性*，这些属性通常表示为键/值对。
- en: Nodes can be tagged with one or more *labels*, which group nodes and indicate
    the roles they play within the dataset.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点可以被标记为一个或多个*标签*，这些标签将节点分组并指示它们在数据集中的角色。
- en: A property graph is still a graph, but the communication capability is greater
    than before. In figure 2.31, you can easily see that the Person Alessandro WORKS_FOR
    the Company GraphAware, as do Michal and Christophe. name is a property of the
    node Person, whereas start_date and role are properties of the relationship WORKS_FOR.
    The nationality of each Person is stored by using the relationship HAS_NATIONALITY,
    which connects the Person to a Country node that has the property name for storing
    the country name.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 属性图仍然是一个图，但通信能力比以前更强。在图2.31中，你可以轻松地看到，亚历山德罗·佩尔森为GraphAware公司工作，正如米哈尔和克里斯托夫一样。name是节点Person的属性，而start_date和role是关系WORKS_FOR的属性。每个Person的国籍是通过使用关系HAS_NATIONALITY存储的，该关系将Person连接到一个具有存储国家名称属性的Country节点。
- en: As for relational databases, there are some best practices or style rules for
    defining a model for a graph. The labels for nodes should be singular, for example,
    because they represent a specific entity, whereas the names for the relationships
    should reflect the direction.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 对于关系数据库，定义图模型有一些最佳实践或风格规则。节点的标签应该是单数，例如，因为它们代表一个特定的实体，而关系的名称应该反映方向。
- en: Obviously, there are multiple ways of representing the same set of concepts.
    In the model in figure 2.31, for example, the nationality could be stored as a
    property of the Person nodes. The schema could change significantly according
    to the specific needs in terms of access patterns and the underlying graph DBMS.
    In the second part of the book, we will see numerous models for representing data,
    each of which has a specific scope and satisfies the specific requirements of
    a target application.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，表示同一组概念的方法有很多种。例如，在图2.31中的模型中，国籍可以存储为Person节点的属性。根据访问模式和底层图数据库管理系统（DBMS）的具体需求，模式可能会发生显著变化。在本书的第二部分，我们将看到许多表示数据的方法，每种方法都有特定的范围并满足特定目标应用的需求。
- en: '![CH02_F31_Negro](../Images/CH02_F31_Negro.png)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F31_Negro](../Images/CH02_F31_Negro.png)'
- en: Figure 2.31 A property graph
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.31 属性图
- en: Summary
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter described some of the challenges related to management of data
    in machine learning applications and discussed how the graph model helps address
    those challenges. The chapter illustrated specific aspects by using concrete scenarios
    with descriptions of related graph-based solutions. You learned the following:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了与机器学习应用数据管理相关的一些挑战，并讨论了图模型如何帮助解决这些挑战。本章通过使用具体场景和相关图解决方案的描述来具体说明。你学到了以下内容：
- en: 'How to deal with the four Vs of big data: volume, velocity, variety, and veracity.
    The four-Vs model describes the multiple critical issues a machine learning project
    faces with regard to the scale of the data, the speed at which new data is generated,
    the heterogeneous structure the data exhibits, and the uncertainty of the sources.'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何处理大数据的四个V：量（volume）、速度（velocity）、多样性（variety）和真实性（veracity）。四V模型描述了机器学习项目在数据规模、新数据生成的速度、数据展现出的异构结构和数据来源的不确定性等方面面临的多个关键问题。
- en: How to design architectures to handle large amounts of training data. Predictive
    analytics and machine learning in general require a lot of data during training
    to be effective. Having more data beats having better models.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何设计架构以处理大量训练数据。预测分析和机器学习通常在训练过程中需要大量数据才能有效。拥有更多数据胜过拥有更好的模型。
- en: How to design a proper Lambda Architecture that uses graphs for storing views
    of the data. In the graph-based Lambda Architecture, a graph model is used for
    storing and accessing batch or real-time views. These views represent precomputed
    and easy-to-query views of the master dataset, which contains raw data in the
    original format.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何设计一个使用图来存储数据视图的适当Lambda架构。在基于图的Lambda架构中，图模型用于存储和访问批量或实时视图。这些视图代表预先计算且易于查询的主数据集视图，其中包含原始格式的原始数据。
- en: How to plan your MDM platform. MDM is the practice of identifying, cleaning,
    storing, and, (most important) governing data. In this context, graphs expose
    more flexibility and extensibility in the data model together with search and
    index capabilities.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何规划您的MDM平台。MDM是指识别、清理、存储以及（最重要的是）管理数据的过程。在此背景下，图模型在数据模型中提供了更多的灵活性和可扩展性，同时具备搜索和索引功能。
- en: How to decide on a replication schema suitable for the application’s needs.
    Replication allows you to distribute the analysis load across multiple nodes in
    the graph data cluster.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何选择适合应用程序需求的复制模式。复制允许您在图数据集群的多个节点之间分配分析负载。
- en: What the advantages of a native graph database are. Native graph DBMSs are preferable
    to non-native ones because they map the model (the way in which we represent the
    data) one-to-one with the underlying data engine. Such a match allows better performance.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原生图数据库的优势是什么。与非原生图数据库相比，原生图数据库管理系统更可取，因为它们将模型（我们表示数据的方式）与底层数据引擎一一映射。这种匹配允许更好的性能。
- en: References
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[Angles and Gutierrez, 2017] Angles, Renzo, and Claudio Gutierrez. “An Introduction
    to Graph Data Management.” arXiv, December 29, 2017\. [https://arxiv.org/pdf/
    1801.00036.pdf](https://arxiv.org/pdf/1801.00036.pdf).'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '[Angles 和 Gutierrez, 2017] Angles, Renzo, 和 Claudio Gutierrez. “图数据管理简介。” arXiv,
    2017年12月29日。[https://arxiv.org/pdf/1801.00036.pdf](https://arxiv.org/pdf/1801.00036.pdf).'
- en: '[Bahga and Madisetti, 2016] Bahga, Arshdeep and Madisetti, Vijay K. *Big Data
    Science & Analytics: A Hands-on Approach*. VPT, 2016.'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '[Bahga 和 Madisetti, 2016] Bahga, Arshdeep 和 Madisetti, Vijay K. *大数据科学与分析：动手实践方法*。VPT,
    2016。'
- en: '[Corbo et al., 2017] Corbo, Jacomo, Carlo Giovine, and Chris Wigley. “Applying
    Analytics in Financial Institutions’ Fight Against Fraud.” McKinsey & Company,
    April 2017\. [http://mng.bz/xGZq](http://mng.bz/xGZq).'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '[Corbo 等人，2017] Corbo, Jacomo, Carlo Giovine, 和 Chris Wigley. “在金融机构打击欺诈中应用分析。”
    McKinsey & Company, 2017年4月。[http://mng.bz/xGZq](http://mng.bz/xGZq).'
- en: '[Cormen et al., 2009] Cormen, Thomas H., Charles E. Leiserson, Ronald L. Rivest,
    and Clifford Stein. *Introduction to Algorithms*. 3rd ed. Boston, MA: MIT Press,
    2009.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '[Cormen 等人，2009] Cormen, Thomas H., Charles E. Leiserson, Ronald L. Rivest,
    和 Clifford Stein. *算法导论*。第3版。波士顿，MA: MIT Press, 2009。'
- en: '[Coyle, 2016] Coyle, Peadar. “Interview with a Data Scientist: Greg Linden.”
    October 12, 2016\. [http://mng.bz/l2Zz](http://mng.bz/l2Zz).'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '[Coyle, 2016] Coyle, Peadar. “数据科学家访谈：Greg Linden。” 2016年10月12日。[http://mng.bz/l2Zz](http://mng.bz/l2Zz).'
- en: '[Domo, 2020] Domo. “Data Never Sleeps 8.0.” 2020\. [https://www.domo.com/learn/data-never-sleeps-8](https://www.domo.com/learn/data-never-sleeps-8).'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '[Domo, 2020] Domo. “数据永不眠8.0。” 2020。[https://www.domo.com/learn/data-never-sleeps-8](https://www.domo.com/learn/data-never-sleeps-8).'
- en: '[Eagle, Quinn and Clauset, 2009] Eagle, Nathan, John A. Quinn, and Aaron Clauset.
    “Methodologies for Continuous Cellular Tower Data Analysis.” *Proceedings of the
    7th International Conference on Pervasive Computing* (2009): 342-353.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '[Eagle, Quinn 和 Clauset, 2009] Eagle, Nathan, John A. Quinn, 和 Aaron Clauset.
    “连续蜂窝塔数据分析方法。” *第7届国际普适计算会议论文集* (2009): 342-353.'
- en: '[Fowler and Sadalage, 2012] Fowler, Martin, and Pramod J. Sadalage. *NoSQL
    Distilled: A Brief Guide to the Emerging World of Polyglot Persistence*. Upper
    Saddle River, NJ: Addison-Wesley Professional, 2012.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '[Fowler 和 Sadalage, 2012] Fowler, Martin, 和 Pramod J. Sadalage. *NoSQL精粹：多语言持久性的新兴世界简明指南*。Upper
    Saddle River, NJ: Addison-Wesley Professional, 2012。'
- en: '[Gatner, 2017] Gartner. “Master Data Management (MDM).” 2017\. [http://mng.bz/rmZE](http://mng.bz/rmZE).'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '[Gatner, 2017] Gartner. “主数据管理（MDM）。” 2017。[http://mng.bz/rmZE](http://mng.bz/rmZE).'
- en: '[Health Data Archiver, 2018] Health Data Archiver (2018). “Health Data Volumes
    Skyrocket, Legacy Data Archives on the Rise.” August 3, 2018\. [http://mng.bz/dmWz](http://mng.bz/dmWz).'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '[Health Data Archiver, 2018] Health Data Archiver (2018). “健康数据量激增，传统数据归档在增加。”
    2018年8月3日。[http://mng.bz/dmWz](http://mng.bz/dmWz).'
- en: '[Johnson, 2013] Johnson, Ralph. “2.5 Quintillion Bytes of Data Created Every
    Day. How Does CPG & Retail Manage It?” IBM Consumer Products Industry blog, April
    24, 2013.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '[Johnson, 2013] Johnson, Ralph. “每天产生2500亿字节的数据。CPG和零售如何管理它？” IBM消费品行业博客，2013年4月24日。'
- en: '[Jürgensen, 2016] Jürgensen, Knut. “Master Data Management (MDM): Help or Hindrance?”
    Redgate Hub, May 16, 2016\. [http://mng.bz/ZY9j](http://mng.bz/ZY9j).'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '[Jürgensen, 2016] Jürgensen, Knut. “主数据管理（MDM）：是帮助还是阻碍？” Redgate Hub，2016年5月16日。[http://mng.bz/ZY9j](http://mng.bz/ZY9j)。'
- en: '[Laney, 2001] Laney, Douglas. “3D Data Management: Controlling Data Volume,
    Velocity, and Variety.” META Group, February 6, 2001\. [http://mng.bz/BKzq](http://mng.bz/BKzq).'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '[Laney, 2001] Laney, Douglas. “3D 数据管理：控制数据量、速度和多样性。” META Group，2001年2月6日。[http://mng.bz/BKzq](http://mng.bz/BKzq)。'
- en: '[Marz and Warren, 2015] Marz, Nathan, and James Warren. *Big Data*. Shelter
    Island, NY: Manning, 2015.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '[Marz 和 Warren, 2015] Marz, Nathan, 和 James Warren. *大数据*。纽约州舍尔特岛：Manning，2015年。'
- en: '[Nelson, 2016] Nelson, Patrick. “Just One Autonomous Car Will Use 4,000 GB
    of Data/Day.” *Network World*, December 7, 2016\. [http://mng.bz/Paw2](http://mng.bz/Paw2).'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '[Nelson, 2016] Nelson, Patrick. “一辆自动驾驶汽车每天将使用4,000 GB的数据。” *网络世界*，2016年12月7日。[http://mng.bz/Paw2](http://mng.bz/Paw2)。'
- en: '[Özsu, 2015] Özsu, M. Tamer. “An Overview of Graph Data Management and Analysis.”
    ADC PhD School, June 4, 2015\. [http://hkbutube.lib.hkbu.edu.hk/st/display.php?bibno=
    b3789774](http://hkbutube.lib.hkbu.edu.hk/st/display.php?bibno=b3789774).'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '[Özsu, 2015] Özsu, M. Tamer. “图数据管理和分析概述。” ADC 博士学校，2015年6月4日。[http://hkbutube.lib.hkbu.edu.hk/st/display.php?bibno=
    b3789774](http://hkbutube.lib.hkbu.edu.hk/st/display.php?bibno=b3789774)。'
- en: '[Özsu and Valduriez, 2011] Özsu, M. Tamer, and Patrick Valduriez. *Principles
    of Distributed Database Systems*. 3rd ed. New York: Springer, 2011.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '[Özsu 和 Valduriez, 2011] Özsu, M. Tamer, 和 Patrick Valduriez. *分布式数据库系统原理*。第3版。纽约：Springer，2011年。'
- en: '[Parkin, 2018] Parkin, Simon. “The Never-Ending War on Fake Reviews.” *The
    New Yorker*, May 31, 2018\. [http://mng.bz/1A5Z](http://mng.bz/1A5Z).'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '[Parkin, 2018] Parkin, Simon. “对虚假评论的永无止境的战争。” *《纽约客》*，2018年5月31日。[http://mng.bz/1A5Z](http://mng.bz/1A5Z)。'
- en: '[Puget and Thomas, 2016] Puget, Jean Francois, and Rob Thomas. “A Practical
    Guide to Machine Learning: Understand, Differentiate, and Apply.” IBM Community,
    August 16, 2016.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '[Puget 和 Thomas, 2016] Puget, Jean Francois, 和 Rob Thomas. “机器学习的实用指南：理解、区分和应用。”
    IBM 社区，2016年8月16日。'
- en: '[Robinson et al., 2015] Robinson, Ian, Jim Webber, and Emil Eifrem. *Graph
    Databases*. 2nd ed. Sebastopol, CA: O’Reilly, 2015.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '[Robinson 等人，2015] Robinson, Ian, Jim Webber, 和 Emil Eifrem. *图数据库*。第2版。加利福尼亚州塞巴斯蒂波尔：O’Reilly，2015年。'
- en: '[Rund, 2017] Rund, Ben. “The Good, The Bad, and the Hype About Graph Databases
    for MDM.” *TDWI*, March 14, 2017\. [http://mng.bz/VG9r](http://mng.bz/VG9r).'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '[Rund, 2017] Rund, Ben. “关于图数据库在主数据管理（MDM）中的优点、缺点和炒作。” *TDWI*，2017年3月14日。[http://mng.bz/VG9r](http://mng.bz/VG9r)。'
- en: '[Shafer, 2017] Shafer, Tom. “The 42 V’s of Big Data and Data Science.” Elder
    Research, April 1, 2017\. [https://www.elderresearch.com/blog/42-v-of-big-data](https://www.elderresearch.com/blog/42-v-of-big-data).'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '[Shafer, 2017] Shafer, Tom. “大数据和数据科学的42个特征。” Elder Research，2017年4月1日。[https://www.elderresearch.com/blog/42-v-of-big-data](https://www.elderresearch.com/blog/42-v-of-big-data)。'
- en: '[Shannon, 2017] Shannon, Sarah. “Updated for 2018: The Five Vs of Big Data:
    How Can They Help Your Business?” XSI, February 15, 2017.'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '[Shannon, 2017] Shannon, Sarah. “更新至2018年：大数据的五大特征：它们如何帮助您的业务？” XSI，2017年2月15日。'
- en: '[Villedieu, n.d.] Villedieu, Jean. “GraphGist: Credit Card Fraud Detection.”
    Neo4j. [http://mng.bz/A1GE](http://mng.bz/A1GE).'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '[Villedieu, n.d.] Villedieu, Jean. “GraphGist：信用卡欺诈检测。” Neo4j。[http://mng.bz/A1GE](http://mng.bz/A1GE)。'
- en: '[Webber, 2011] Webber, Jim. “On Sharding Graph Databases.” World Wide Webber,
    February 16, 2011.'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '[Webber, 2011] Webber, Jim. “关于图数据库分片。” World Wide Webber，2011年2月16日。'
- en: '[Webber, 2017] Webber, Jim. “The Motivation for Native Graph Databases.” May
    17, 2017\. [http://mng.bz/2z6N](http://mng.bz/2z6N).'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '[Webber, 2017] Webber, Jim. “原生图数据库的动机。” 2017年5月17日。[http://mng.bz/2z6N](http://mng.bz/2z6N)。'
- en: '[Webber, 2018] Webber, Jim. “Not All Graph Databases Are Created Equal: Why
    You Need a Native Graph.” *Database Trends and Applications*, March 7, 2018\.
    [http://mng.bz/RKwn](http://mng.bz/RKwn).'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '[Webber, 2018] Webber, Jim. “并非所有图数据库都是相同的：为什么您需要一个原生图数据库。” *数据库趋势与应用*，2018年3月7日。[http://mng.bz/RKwn](http://mng.bz/RKwn)。'
- en: '[Wilder-James, 2012] Wilder-James, Edd. “What Is Big Data? An Introduction
    to the Big Data Landscape.” [https://www.oreilly.com/ideas/what-is-big-data](https://www.oreilly.com/ideas/what-is-big-data).'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '[Wilder-James, 2012] Wilder-James, Edd. “什么是大数据？大数据领域的介绍。” [https://www.oreilly.com/ideas/what-is-big-data](https://www.oreilly.com/ideas/what-is-big-data)。'
- en: '[Woodie, 2016] Woodie, Alex. “Neo4j Pushes Graph DB Limits Past a Quadrillion
    Nodes.” Datanami, April 26, 2016\. [http://mng.bz/Jvwp](http://mng.bz/Jvwp).'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '[Woodie, 2016] Woodie, Alex. “Neo4j 将图数据库的节点限制推至超过一千万亿个。” Datanami，2016年4月26日。[http://mng.bz/Jvwp](http://mng.bz/Jvwp)。'
- en: '* * *'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '^(1.)“Lidar works much like radar, but instead of sending out radio waves it
    emits pulses of infrared light—aka lasers invisible to the human eye—and measures
    how long they take to come back after hitting nearby objects.” Source: [http://mng.bz/jBZ9](https://shortener.manning.com/jBZ9).'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: (1.) “激光雷达的工作原理与雷达类似，但它不是发送无线电波，而是发射红外光脉冲——即人眼看不见的激光——并测量它们击中附近物体后返回所需的时间。”来源：[http://mng.bz/jBZ9](https://shortener.manning.com/jBZ9)。
- en: ^(2.)Puget and Thomas [2016].
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: (2.) Puget和Thomas [2016]。
- en: '^(3.)“Insight engines apply relevancy methods to describe, discover, organize
    and analyze data. This allows existing or synthesized information to be delivered
    proactively or interactively, and in the context of digital workers, customers
    or constituents at timely business moments.” (Source: [http://mng.bz/WrwX](https://shortener.manning.com/WrwX).)'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: (3.) “洞察引擎应用相关性方法来描述、发现、组织和分析数据。这使得现有或合成信息能够主动或交互式地传递，并在数字工作者、客户或利益相关者的及时业务时刻传递。”（来源：[http://mng.bz/WrwX](https://shortener.manning.com/WrwX)）
- en: ^(4.)Parkin [2018].
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: (4.) Parkin [2018]。
- en: ^(5.)The merchant names here are used as examples to make the use case more
    concrete.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: (5.) 这里使用的商家名称作为示例，以使用例更加具体。
- en: ^(6.)According to the Law Dictionary ([https://thelawdictionary.org/fraud-ring](https://thelawdictionary.org/fraud-ring)),
    a *fraud ring* is “an organization focused to defraud people. Forgery, false claims,
    stealing identities, counterfeiting checks and currencies are all fraudulent activities.”
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: (6.) 根据《法律词典》（[https://thelawdictionary.org/fraud-ring](https://thelawdictionary.org/fraud-ring)），“欺诈团伙”是指“一个专注于欺诈人们的组织。伪造、虚假陈述、窃取身份、伪造支票和货币都是欺诈行为。”
- en: ^(7.)[https://www.opencypher.org](https://www.opencypher.org).
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: (7.) [https://www.opencypher.org](https://www.opencypher.org)。
- en: ^(8.)[http://mng.bz/8WXg](https://shortener.manning.com/8WXg).
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: (8.) [http://mng.bz/8WXg](https://shortener.manning.com/8WXg)
- en: '^(9.)Big O notation “is used in computer science to describe the performance
    or complexity of an algorithm. Big O specifically describes the worst-case scenario,
    and can be used to describe the execution time required or the space used (e.g.
    in memory or on disk) by an algorithm.” (Source and examples: [https://mng.bz/8WXg](https://mng.bz/8WXg).)'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: (9.) 大O符号“在计算机科学中用于描述算法的性能或复杂度。大O特别描述了最坏的情况，可以用来描述算法所需的执行时间或使用的空间（例如在内存或磁盘上）。”（来源和示例：[https://mng.bz/8WXg](https://mng.bz/8WXg)）
- en: ^(10.)[http://mng.bz/N8wX](https://shortener.manning.com/N8wX).
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: (10.) [http://mng.bz/N8wX](https://shortener.manning.com/N8wX)
- en: ^(11.)*Self-edges*, also referred to as *sloops*, are edges for which the source
    and destination nodes are the same.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: (11.) *自环*，也称为 *sloops*，是指源节点和目标节点相同的边。
