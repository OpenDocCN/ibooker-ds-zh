- en: 4 Creating a robot shell
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 创建机器人外壳
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了
- en: The basics of creating interactive custom shells in Python
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python中创建交互式自定义外壳的基本知识
- en: Creating a command loop for moving the robot forward and backward
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建用于使机器人前后移动的命令循环
- en: Handling command arguments in shell commands
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在外壳命令中处理命令参数
- en: Centralizing argument-handling logic in code shells
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在代码外壳中集中处理参数逻辑
- en: Executing custom shell scripts in Python
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python中执行自定义外壳脚本
- en: This chapter will teach you how to create a custom interactive REPL (read–evaluate–print
    loop) robot shell. Shells provide a powerful interactive interface that enables
    direct interaction with software or, in this case, robotic hardware. They are
    a tried-and-true method for user interaction, and the Python standard library
    provides a built-in functionality to create custom shells. The chapter starts
    with a simple robotic shell and then progresses to add more movement functions
    with more customized options. The chapter ends by showing how a set of commands
    can be saved and run in one go in the shell, as is done in many other shells.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向您介绍如何创建一个自定义的交互式REPL（读取-评估-打印循环）机器人外壳。外壳提供了一种强大的交互式界面，允许直接与软件或在此情况下，与机器人硬件进行交互。它们是用户交互的一种经过验证和有效的方法，Python标准库提供了创建自定义外壳的内置功能。本章从简单的机器人外壳开始，然后逐步添加更多带有更多定制选项的运动功能。本章最后展示了如何在外壳中一次性保存并运行一组命令，就像在许多其他外壳中做的那样。
- en: 4.1 What’s a REPL or shell?
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 什么是REPL或外壳？
- en: A REPL or command-line shell is a program that loops endlessly, waiting to receive
    user input, which is then taken and executed, and the output is printed as needed.
    They are also called *line-oriented command interpreters* because they take commands
    as a line of user input and interpret or execute the given line. Figure 4.1 illustrates
    the three states that a REPL goes through.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: REPL或命令行外壳是一个无限循环的程序，等待接收用户输入，然后执行输入，并根据需要打印输出。它们也被称为*面向行的命令解释器*，因为它们将命令作为用户输入的一行并解释或执行该行。图4.1说明了REPL经历的三种状态。
- en: '![](../Images/CH04_F01_Alsabbagh.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F01_Alsabbagh.png)'
- en: 'Figure 4.1 Read–evaluate–print loop: the REPL goes endlessly between the read–evaluate–print
    states.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 读取-评估-打印循环：REPL在读取-评估-打印状态之间无限循环。
- en: 4.2 Benefits of a REPL
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 REPL的好处
- en: 'In the book so far, we have already interacted with two very popular programs
    that provide a REPL interface: Python and Bash. Here are some of the features
    and benefits of the shells created in this chapter:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中到目前为止，我们已经与两个提供REPL界面的非常流行的程序进行了交互：Python和Bash。以下是本章创建的外壳的一些功能和好处：
- en: Fast and direct execution of commands.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速直接执行命令。
- en: Simple line-by-line execution.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的逐行执行。
- en: The live help command lists available commands.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出可用命令的实时帮助命令。
- en: Tab auto-completion of commands.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令的Tab自动完成。
- en: Command history, which can be accessed with up and down keys.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过上下键访问的命令历史记录。
- en: Optional arguments for each command.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个命令的可选参数。
- en: Execution of commands in a script file.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在脚本文件中执行命令。
- en: These features will be used by the robot shell created in this chapter. With
    our robot shell, we will be able to issue movement commands quickly and easily
    to our robot from the terminal. We can also use the command history feature to
    replay past movements we have applied to the robot.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能将用于本章创建的机器人外壳。有了我们的机器人外壳，我们能够从终端快速轻松地发出运动命令给我们的机器人。我们还可以使用命令历史记录功能来重放我们之前应用到机器人上的运动。
- en: 4.3 Hardware stack
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 硬件栈
- en: Figure 4.2 shows the hardware stack discussed, with the specific components
    used in this chapter highlighted. The REPL utilizes keyboard interaction by employing
    Tab auto-completion and arrow keys to access the command history.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2显示了讨论的硬件栈，本章使用的特定组件被突出显示。REPL通过使用Tab自动完成和箭头键来访问命令历史记录进行键盘交互。
- en: '![](../Images/CH04_F02_Alsabbagh.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F02_Alsabbagh.png)'
- en: 'Figure 4.2 Hardware stack: the robot shell controls the DC motor through the
    CRICKIT board.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 硬件栈：机器人外壳通过CRICKIT板控制直流电机。
- en: The robot shell will be running on the Raspberry Pi hardware. The commands executed
    through the shell will communicate with the CRICKIT board, which will then send
    the signals to the DC motors to make the requested motor movements.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人外壳将在Raspberry Pi硬件上运行。通过外壳执行的命令将与CRICKIT板通信，然后CRICKIT板将发送信号到直流电机以执行所需的电机运动。
- en: 4.4 Software stack
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 软件栈
- en: Details of the specific software used in this chapter are illustrated in figure
    4.3 and described in the text that follows. With each new application, we will
    add more features and enhancements to our shell implementations.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的特定软件的详细信息在图4.3中展示，并在随后的文本中进行描述。随着每个新应用的加入，我们将向我们的shell实现添加更多功能和增强。
- en: '![](../Images/CH04_F03_Alsabbagh.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F03_Alsabbagh.png)'
- en: 'Figure 4.3 Software stack: the robot shell will run on the Python interpreter.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 软件堆栈：机器人shell将在Python解释器上运行。
- en: Python and Bash both have a REPL feature, and both run directly on Linux using
    the `readline` library. The `motor` module from the previous chapter will be used
    to control the DC motors. The robot shell in this chapter will be implemented
    using Python, so it will be running on top of Python. Users do not have to worry
    about how it is implemented and can interact with it as with any other shell program
    on their computer.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Python和Bash都有REPL功能，并且都直接在Linux上使用`readline`库运行。上一章中的`motor`模块将被用来控制直流电机。本章中的机器人shell将使用Python实现，因此它将在Python之上运行。用户不需要担心它的实现方式，可以像与计算机上的任何其他shell程序一样与之交互。
- en: 4.5 Creating the robot shell
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5 创建机器人shell
- en: 'In this section, we will use Python to write a program that implements a custom
    REPL robot shell to obtain basic robot actions of forward and backward movements.
    This script requires two modules, which we import as shown in the following code.
    The `cmd` module is part of the Python standard library and provides a framework
    for creating REPL applications such as the robot shell. The `cmd` module ([https://docs.python.org/3/library/cmd.html](https://docs.python.org/3/library/cmd.html))
    documentation is an excellent resource for learning more about the library. The
    `motor` module is the library created in the previous chapter for controlling
    the robot:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用Python编写一个程序，实现一个自定义的REPL机器人shell以获取基本的机器人前进和后退动作。此脚本需要两个模块，我们按照以下代码所示导入它们。`cmd`模块是Python标准库的一部分，它为创建REPL应用程序（如机器人shell）提供了一个框架。`cmd`模块([https://docs.python.org/3/library/cmd.html](https://docs.python.org/3/library/cmd.html))的文档是学习更多关于该库的绝佳资源。`motor`模块是上一章中创建的用于控制机器人的库：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we define our `RobotShell` class, which is a subclass of `cmd.Cmd`. The
    `intro` provides a welcome message when the shell is first started. The `prompt`
    text appears when the user is prompted, indicating they are now in the robot shell.
    Each method that starts with the name `do_` is automatically called to handle
    its related command. In this way, the `do_forward` method gets called to handle
    `forward` commands. Each time it is called, it moves the robot forward by calling
    `motor.forward`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义我们的`RobotShell`类，它是`cmd.Cmd`的子类。`intro`方法在shell首次启动时提供欢迎信息。当用户被提示时，`prompt`文本会显示，表明他们现在处于机器人shell中。以`do_`开头的每个方法都会自动调用以处理其相关命令。这样，`do_forward`方法就会被调用以处理`forward`命令。每次调用时，它都会通过调用`motor.forward`将机器人向前移动：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we define the `do_backward` method to handle the `backward` command:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义`do_backward`方法来处理`backward`命令：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The final line of code will run the event loop that starts the shell, read
    commands from user input, and execute the corresponding command method:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行代码将运行事件循环，启动shell，从用户输入中读取命令，并执行相应的命令方法：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The full script can be saved as `basic_shell.py` on the Pi and then executed.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的脚本可以保存为`basic_shell.py`在Pi上，然后执行。
- en: 'Listing 4.1 `basic_shell.py`: Providing basic robot movements in a shell'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.1 `basic_shell.py`：在shell中提供基本的机器人运动
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When executing the script, make sure that `motor.py` is in the same directory
    so that it can be imported by `basic_shell.py`. The following code shows an example
    of a session in the robot shell where `help` and movement commands have been executed:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行脚本时，请确保`motor.py`与`basic_shell.py`在同一目录下，以便它可以被`basic_shell.py`导入。以下代码显示了在机器人shell中执行`help`和运动命令的一个会话示例：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We can run the shell remotely over an SSH connection like any other Python script.
    When running the shell, the Tab key can be pressed to use the auto-complete feature,
    and the up and down arrows can be used to access the command history feature.
    Press the F key and then the Tab key to have the command `forward` get auto-completed.
    When you finish using the robot shell, you can press CTRL+C to exit like you would
    in other programs.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像其他Python脚本一样通过SSH连接远程运行shell。在运行shell时，可以按Tab键使用自动完成功能，上箭头和下箭头可以用来访问命令历史记录功能。按F键然后按Tab键，可以使命令`forward`自动完成。当您完成使用机器人外壳后，可以按CTRL+C来退出，就像在其他程序中一样。
- en: 'Going deeper: Importing libraries'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 深入探讨：导入库
- en: In this chapter, we are building on the code from the previous chapter by importing
    the `motor` library. We can keep all the scripts and libraries we create in the
    `/home/robo/bin/` directory to simplify the process of importing modules. But
    where are the other libraries we have been using located, and how does the Python
    interpreter figure out where to find them when we import modules?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过导入`motor`库来构建前一章的代码。我们可以将创建的所有脚本和库保存在`/home/robo/bin/`目录中，以简化导入模块的过程。但其他我们一直在使用的库在哪里，Python解释器在导入模块时是如何找到它们的？
- en: 'We can pop into the REPL to get answers to these questions. We import the `sys`
    module and then inspect the contents of `sys.path`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进入REPL（交互式Python解释器）来获取这些问题的答案。我们导入`sys`模块，然后检查`sys.path`的内容：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In `sys.path`, there is a list of strings that are the paths to be searched
    when importing modules. If we check out these directories, we will find the modules
    that we have been importing in the book. For example, the location of the `cmd`
    module that is part of the standard library can be listed using
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在`sys.path`中，有一个字符串列表，这些路径是在导入模块时需要搜索的路径。如果我们检查这些目录，我们将找到我们在书中导入的模块。例如，标准库中`cmd`模块的位置可以使用以下方式列出：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can open this file and investigate its source code like any other Python
    script. We can also find the location of third-party libraries that we have installed
    in our virtual environment using the `pip` command. Here is the location of the
    Adafruit CRICKIT library that we used to control the DC motors:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以打开这个文件，像其他Python脚本一样调查其源代码。我们还可以使用`pip`命令找到我们在虚拟环境中安装的第三方库的位置。以下是用于控制直流电机的Adafruit
    CRICKIT库的位置：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can see that the libraries in the Python standard library are in the system
    location shared by all virtual environments, while the third-party packages installed
    in our virtual environment are all located in the `/home/robo/pyenv` location
    we created for our virtual environment. For further details on importing packages
    in Python, the documentation for the `importlib` ([https://docs.python.org/3/library/importlib.html](https://docs.python.org/3/library/importlib.html))
    module is a great resource.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，Python标准库中的库位于所有虚拟环境共享的系统位置，而我们在为虚拟环境创建的`/home/robo/pyenv`位置安装的第三方包都位于那里。有关Python中导入包的更多详细信息，`importlib`模块的文档([https://docs.python.org/3/library/importlib.html](https://docs.python.org/3/library/importlib.html))是一个很好的资源。
- en: 4.6 Handling command arguments
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.6 处理命令参数
- en: We have implemented a basic robot shell with the two movement commands, `forward`
    and `backward`. However, they can’t handle any arguments provided after the movement
    command. We will add support for providing the `duration` argument for each movement
    command. We will also improve the way we exit the shell by properly handling end-of-file
    (EOF) on input.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了一个基本的机器人外壳，包含两个运动命令，`forward`（前进）和`backward`（后退）。然而，它们无法处理运动命令之后提供的任何参数。我们将添加对每个运动命令提供`duration`（持续时间）参数的支持。我们还将改进退出外壳的方式，通过正确处理输入的文件结束符（EOF）。
- en: 'We now enhance the `do_forward` method to check if a duration has been provided.
    The text after the `forward` command will be provided in the `line` argument,
    which we can parse to get the duration. If a duration is found, it will be converted
    into a `float` value and used when calling the `motor.forward` function:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们增强`do_forward`方法，以检查是否提供了持续时间。`forward`命令之后的文本将通过`line`参数提供，我们可以解析它以获取持续时间。如果找到持续时间，它将被转换为`float`值，并在调用`motor.forward`函数时使用：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The same process is then applied to the `do_backward` method:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将相同的流程应用于`do_backward`方法：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `do_EOF` method is added to the class to handle when an EOF condition is
    encountered in the input data. The method returns a `True` value to signal to
    the event loop that the shell is to be exited:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在类中添加了 `do_EOF` 方法来处理在输入数据中遇到 EOF 条件的情况。该方法返回 `True` 值以向事件循环发出信号，外壳应退出：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The full script can be saved as `arg_shell.py` on the Pi and then executed.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的脚本可以保存为 Pi 上的 `arg_shell.py` 并执行。
- en: 'Listing 4.2 `arg_shell.py`: Supporting command arguments in the shell'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.2 `arg_shell.py`：在外壳中支持命令参数
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'What follows is an example of a session in the robot shell where movement commands
    with different durations are called:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是在机器人外壳中调用不同持续时间移动命令的会话示例：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the example session, the movement commands were called with durations expressed
    as integers and floats. The commands can also be called without providing any
    duration that will use the default duration value. When you want to exit the robot
    shell, you press CTRL+D instead of CTRL+C. This will exit the shell in a much
    cleaner fashion, as CTRL+D will send an EOF, whereas pressing CTRL+C will end
    the shell spitting out a `Traceback` error. Using CTRL+D to exit a shell is a
    standard procedure, and the same process will work with Bash and the Python REPL.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例会话中，移动命令使用整数和浮点数表示的持续时间调用。也可以不提供任何持续时间，将使用默认的持续时间值。当你想要退出机器人外壳时，按下 CTRL+D
    而不是 CTRL+C。这将以一种更干净的方式退出外壳，因为 CTRL+D 会发送 EOF，而按下 CTRL+C 将导致外壳输出 `Traceback` 错误。使用
    CTRL+D 退出外壳是一个标准程序，与 Bash 和 Python REPL 的相同过程将起作用。
- en: 4.7 Adding a speed argument
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.7 添加速度参数
- en: To support multiple optional arguments, we will have to do a little extra work.
    As we need to upgrade our argument-handling behavior, it would be better if we
    don’t have to change it in multiple places. So the first step will be to centralize
    our argument-handing code for all movement commands in one function and then upgrade
    that function.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持多个可选参数，我们不得不做一些额外的工作。由于我们需要升级我们的参数处理行为，最好是在多个地方不需要更改它。因此，第一步将是将所有移动命令的参数处理代码集中在一个函数中，然后升级该函数。
- en: 'We create a new function, `get_kwargs`, that will take the `line` value and
    return a `dict` object with all the required key-value pairs. The following definition
    will cover the existing behavior of taking the first optional argument as the
    value for `duration`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个新的函数 `get_kwargs`，它将接受 `line` 值并返回一个包含所有必需键值对的 `dict` 对象。以下定义将覆盖现有的行为，即取第一个可选参数作为
    `duration` 的值：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We then update the definitions of `do_forward` and `do_backward` to use `get_kwargs`.
    They call `get_kwargs` and directly use what is returned as the keyword arguments
    for the function call to their associated movement functions:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们更新 `do_forward` 和 `do_backward` 的定义以使用 `get_kwargs`。它们调用 `get_kwargs` 并直接使用返回值作为函数调用到相关移动函数的关键字参数：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'At this stage, we could run the shell, and it would work with the previous
    behavior. We can now upgrade the `get_kwargs` function and add the handling of
    the second keyword argument `speed`. This argument is expected to be of type `int`,
    so it is typecast to that data type:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们可以运行外壳，它将使用之前的行为。现在我们可以升级 `get_kwargs` 函数并添加处理第二个关键字参数 `speed` 的功能。这个参数预期是
    `int` 类型，因此将其转换为该数据类型：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The full script can be saved as `speed_shell.py` on the Pi and then executed.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的脚本可以保存为 Pi 上的 `speed_shell.py` 并执行。
- en: 'Listing 4.3 `speed_shell.py`: Controlling movement speed in the shell'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.3 `speed_shell.py`：在外壳中控制移动速度
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here is an example of a session in the upgraded robot shell:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是在升级后的机器人外壳中的一个会话示例：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the example session, the movement commands can now be called with the duration
    specified and default speed, with a specific duration and speed or with the default
    duration and speed settings.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例会话中，现在可以指定持续时间并使用默认速度调用移动命令，也可以指定特定的持续时间或速度，或者使用默认的持续时间或速度设置。
- en: 4.8 Running robot shell scripts
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.8 运行机器人外壳脚本
- en: 'In this section, the challenge is to make the robot shell have the capability
    of executing a script of commands and adding the remaining movement commands.
    We add the methods `do_right`, `do_left`, `do_spin_right`, and `do_spin_left`.
    They follow the same style as our previous movement methods:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，挑战是使机器人外壳能够执行命令脚本并添加剩余的移动命令。我们添加了 `do_right`、`do_left`、`do_spin_right`
    和 `do_spin_left` 方法。它们遵循我们之前的移动方法的相同风格：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When we have the shell execute the commands in a script file, it would be great
    to get some visual feedback regarding which command is being executed. We can
    do this by adding a `precmd` method. This method gets called before executing
    any command. It is a feature that comes as part of the `cmd.Cmd` object. We will
    use it to print the command that is about to be executed. It must return the value
    of `line` to have the event loop process the command:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在shell中执行脚本文件中的命令时，能够得到一些关于正在执行哪个命令的视觉反馈将会很棒。我们可以通过添加一个`precmd`方法来实现这一点。这个方法在执行任何命令之前被调用。这是`cmd.Cmd`对象的一部分功能。我们将使用它来打印即将执行的命令。为了使事件循环处理命令，它必须返回`line`的值：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The full script can be saved as `shell.py` on the Pi and then executed.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的脚本可以保存为Pi上的`shell.py`，然后执行。
- en: 'Listing 4.4 `shell.py`: Creating a shell supporting all robot movements'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.4 `shell.py`：创建支持所有机器人动作的shell
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following text file of commands should be saved as `move.txt` on the Pi:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令文本文件应保存为Pi上的`move.txt`：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As an initial test, we can use `echo` to feed a single command into the robot
    shell:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 作为初始测试，我们可以使用`echo`将单个命令输入到机器人shell中：
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can also use `cat` to feed a whole set of saved commands into the robot
    shell:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用`cat`将一组保存的命令输入到机器人shell中：
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this way, we can design our own shell using a set of commands that best suits
    our needs. A set of robot shell commands can either be run interactively or saved
    in a single file to be executed directly by the robot shell.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，我们可以使用一组最适合我们需求的命令来设计自己的shell。一组机器人shell命令可以交互式运行，或者保存到一个单独的文件中，然后直接由机器人shell执行。
- en: 'Going deeper: Enhancing the shell'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 深入探讨：增强shell
- en: We can take our shell further and add some more powerful features. In the documentation
    for `cmd` ([https://docs.python.org/3/library/cmd.html](https://docs.python.org/3/library/cmd.html)),
    there is one feature that is very useful for our robot use case. The documentation
    shows how a REPL session can be recorded and then played back later by creating
    commands that record and play back the session. Let’s say we are using the robot
    shell to move the robot around a physical course with a certain set of movements
    that work. Instead of having to retype them all, we can record and play back the
    robot’s movements whenever we want.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将我们的shell进一步扩展并添加一些更强大的功能。在`cmd`的文档（[https://docs.python.org/3/library/cmd.html](https://docs.python.org/3/library/cmd.html)）中，有一个对我们机器人的用例非常有用的功能。文档展示了如何通过创建记录和回放会话的命令来记录并稍后回放REPL会话。假设我们正在使用机器人shell通过一组有效的动作来移动机器人绕行一个物理课程。而不是每次都需要重新输入它们，我们可以随时记录和回放机器人的动作。
- en: 'Another common and powerful feature is to execute robot commands through command
    line arguments. The Python Module of the Week website is a great resource for
    diving deeper into different parts of the Python standard modules, and their documentation
    on the `cmd` module ([https://pymotw.com/3/cmd/](https://pymotw.com/3/cmd/)) shows
    many different ways of using the module, including how to parse commands from
    the command line arguments. The Python interpreter itself has this functionality.
    We have used the REPL before in the book, but we can also evaluate Python code
    by passing the code as a command line argument to the interpreter directly. What
    follows is a simple example demonstrating how to use this feature:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见且强大的功能是通过命令行参数执行机器人命令。Python Module of the Week网站是一个深入了解Python标准模块不同部分的绝佳资源，它关于`cmd`模块的文档（[https://pymotw.com/3/cmd/](https://pymotw.com/3/cmd/））展示了使用该模块的许多不同方式，包括如何从命令行参数解析命令。Python解释器本身就有这个功能。我们在书中之前已经使用过REPL，但我们也可以通过将代码作为命令行参数直接传递给解释器来评估Python代码。以下是一个简单示例，演示如何使用此功能：
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'A third useful feature we could add to the shell is the ability to retain our
    command history between shell sessions. Currently, when we use our shell, we can
    use the up and down arrows to go back through commands we have issued. But once
    we exit our shell, we lose this history. Other shells such as the Python REPL
    retain the history between REPL sessions. This is done by saving a history file
    when we exit the shell and loading it back when we start a new shell. We can see
    this in action with the Python REPL. Open a REPL and evaluate some Python expressions.
    Now exit the REPL and open a new one. If you press the up arrow, you will find
    the commands in your history. We can find the file that stores this history and
    output its contents using the following commands:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加到外壳的第三个有用功能是能够在外壳会话之间保留我们的命令历史。目前，当我们使用我们的外壳时，我们可以使用上箭头和下箭头来回溯我们发出的命令。但一旦我们退出外壳，我们就失去了这个历史。其他外壳，如Python
    REPL，在REPL会话之间保留历史。这是通过我们在退出外壳时保存历史文件并在启动新外壳时重新加载它来实现的。我们可以通过以下命令查看这一功能：打开一个REPL并评估一些Python表达式。现在退出REPL并打开一个新的。如果你按上箭头，你将找到你的历史命令。我们可以找到存储这个历史的文件，并使用以下命令输出其内容：
- en: '[PRE26]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: To implement this feature in our robot shell, we would use the `readline` module
    ([https://docs.python.org/3/library/readline.html](https://docs.python.org/3/library/readline.html)),
    which is what is handling the command history functionality of our shell. It has
    a set of functions that will let us save and load the history to a history file.
    The Python Module of the Week page for the `readline` module ([https://pymotw.com/3/readline/](https://pymotw.com/3/readline/))
    has an excellent example that implements this feature. We would only need to add
    a few lines of code to our shell startup to load the history file and then some
    code when we exit the shell to save the history file.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的机器人外壳中实现此功能，我们将使用`readline`模块（[https://docs.python.org/3/library/readline.html](https://docs.python.org/3/library/readline.html)），这是处理我们外壳命令历史功能的东西。它有一组函数，将允许我们将历史保存到历史文件中。`readline`模块的Python模块每周页面有一个实现此功能的优秀示例（[https://pymotw.com/3/readline/](https://pymotw.com/3/readline/)）。我们只需要在我们的外壳启动时添加几行代码来加载历史文件，然后在退出外壳时添加一些代码来保存历史文件。
- en: Summary
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: A REPL is a program that loops endlessly, waiting to receive user input.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REPL是一个无限循环的程序，等待接收用户输入。
- en: The commands executed through the robot shell will communicate with the CRICKIT
    board, which will then send the signals to the DC motors to make the requested
    motor movements.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过机器人外壳执行的命令将与CRICKIT板通信，然后CRICKIT板将发送信号到直流电机以执行所需的电机运动。
- en: Python and Bash both have a REPL feature, and both run directly on Linux.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python和Bash都有REPL功能，并且两者都直接在Linux上运行。
- en: The `cmd` module is a part of the Python standard library and provides a framework
    for creating REPL applications such as the robot shell.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmd`模块是Python标准库的一部分，它提供了一个创建REPL应用程序（如机器人外壳）的框架。'
- en: The `do_EOF` method is used to handle EOF conditions encountered in the input
    data.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`do_EOF`方法用于处理输入数据中遇到的EOF条件。'
- en: Optional arguments make it possible to call movement commands with duration
    specified and default speed, with a specific duration and speed, or with default
    duration and speed settings.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选参数使得可以以指定持续时间和默认速度、特定持续时间和速度，或默认持续时间和速度设置来调用移动命令。
- en: The `cat` command can be used to feed a set of saved commands into the robot
    shell.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用`cat`命令将一组保存的命令输入到机器人外壳中。
