- en: Chapter 8\. Advanced list handling
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第8章. 高级列表处理
- en: '***This chapter covers***'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '***本章涵盖的内容***'
- en: Speeding list processing with memoization
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用记忆化加速列表处理
- en: Composing `List` and `Result`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合 `List` 和 `Result`
- en: Implementing indexed access on lists
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在列表上实现索引访问
- en: Unfolding lists
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展开列表
- en: Automatic parallel list processing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动并行列表处理
- en: In [chapter 5](kindle_split_012.xhtml#ch05), you created your first data structure,
    the singly linked list. At that point, you didn’t have at your disposal all the
    techniques needed to make it a complete tool for data handling. One particularly
    useful tool you were missing was some way to represent operations producing optional
    data, or operations that can produce an error. In [chapters 6](kindle_split_013.xhtml#ch06)
    and [7](kindle_split_014.xhtml#ch07), you learned how to represent optional data
    and errors. In this chapter, you’ll learn how to compose operations that produce
    optional data or errors with lists.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '在 [第5章](kindle_split_012.xhtml#ch05) 中，你创建了你的第一个数据结构，单链表。在那个时刻，你没有掌握所有使它成为数据处理完整工具所需的技巧。你特别缺少的一个有用工具是表示产生可选数据或可能产生错误的操作的方式。在
    [第6章](kindle_split_013.xhtml#ch06) 和 [第7章](kindle_split_014.xhtml#ch07) 中，你学习了如何表示可选数据和错误。在本章中，你将学习如何将产生可选数据或错误的操作与列表组合。 '
- en: You also developed some functions that were far from optimal, such as `length`,
    and I said that you’d eventually learn more-efficient techniques for these operations.
    In this chapter, you’ll learn how to implement these techniques. You’ll also learn
    how to automatically parallelize some list operations in order to benefit from
    the multicore architecture of today’s computers.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你还开发了一些远非最优的函数，例如 `length`，我说你最终会学到这些操作的更有效的方法。在本章中，你将学习如何实现这些技术。你还将学习如何自动并行化一些列表操作，以利用当今计算机的多核架构。
- en: 8.1\. The problem with length
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1. 长度问题
- en: Folding a list involves starting with a value and composing it successively
    with each element of the list. This obviously takes an amount of time proportional
    to the length of the list. Is there any way to make this operation faster? Or,
    at least, is there a way to make it appear faster?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 折叠列表涉及从一个值开始，并依次将其与列表的每个元素组合。这显然需要与列表长度成比例的时间。有没有办法使这个操作更快？或者，至少有没有办法让它看起来更快？
- en: 'As an example of a fold application, you created a `length` method in `List`
    in exercise 5.9 with the following implementation:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 作为折叠应用的一个例子，你在练习5.9中在 `List` 中创建了一个 `length` 方法，其实现如下：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this implementation, the list is folded using an operation that consists
    of adding 1 to the result. The starting value is `0`, and the value of each element
    of the list is simply ignored. This is what allows you to use the same definition
    for all lists. Because the list elements are ignored, the list element’s type
    is irrelevant.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现中，列表是通过一个操作折叠的，该操作由将1加到结果中组成。起始值是 `0`，列表中每个元素的值被简单地忽略。这就是为什么你可以为所有列表使用相同的定义。因为列表元素被忽略，所以列表元素的类型无关紧要。
- en: 'You can compare the preceding operation with one that computes the sum of a
    list of integers:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将前面的操作与计算整数列表和的操作进行比较：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The main difference here is that the `sum` method can only work with integers,
    whereas the `length` method works for any type. Notice that `foldRight` is only
    a way to abstract recursion. The length of a list can be defined as 0 for an empty
    list and 1 plus the length of the tail for a non-empty list. In the same way,
    the sum of a list of integers can be defined recursively as 0 for an empty list,
    and head plus the sum of the tail for a non-empty one.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要区别在于 `sum` 方法只能与整数一起工作，而 `length` 方法适用于任何类型。请注意，`foldRight` 只是一种抽象递归的方式。列表的长度可以定义为空列表的0，非空列表的长度加1。同样，整数列表的和可以递归地定义为空列表的0，非空列表的头元素加上尾部的和。
- en: 'There are other operations that can be applied to lists in this way, and, among
    them, several for which the type of the list elements is irrelevant:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有其他操作可以以这种方式应用于列表，其中一些操作与列表元素的类型无关：
- en: The hash code of a list can be computed by simply adding the hash codes of its
    elements. Because the hash code is an integer (at least for Java objects), this
    operation doesn’t depend on the object’s type.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表的哈希码可以通过简单地将其元素的哈希码相加来计算。因为哈希码是一个整数（至少对于Java对象来说是这样），这个操作不依赖于对象的类型。
- en: The string representation of a list, as returned by the `toString` method, can
    be computed by composing the `toString` representation of the list elements. Once
    again, the actual type of the elements is irrelevant.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表的字符串表示，由`toString`方法返回，可以通过组合列表元素的`toString`表示来计算。再次强调，元素的实际类型是不相关的。
- en: Some operations may depend on some characteristics of the element’s type, but
    not on the specific type itself. For example, a `max` method that returns the
    maximum element of a list will only need the type to be `Comparable` or a `Comparator`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一些操作可能依赖于元素类型的某些特性，而不是具体的类型本身。例如，一个返回列表最大元素的`max`方法只需要类型是`Comparable`或`Comparator`。
- en: 8.1.1\. The performance problem
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.1\. 性能问题
- en: 'All these methods can be implemented using a fold, but such implementations
    have a major drawback: the time needed to compute the result is proportional to
    the length of the list. Imagine you have a list of about a million elements, and
    you want to check the length. Counting the elements may seem the only way to go
    (this is what the fold-based `length` method does). But if you were adding elements
    to the list until it reaches a million, you surely wouldn’t count the elements
    after adding each one.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些方法都可以使用折叠来实现，但这样的实现有一个主要的缺点：计算结果所需的时间与列表的长度成比例。想象一下，你有一个大约一百万个元素的列表，你想要检查它的长度。计数元素似乎是唯一的方法（这就是基于折叠的`length`方法所做的事情）。但如果你在向列表中添加元素直到它达到一百万个元素，你当然不会在添加每个元素后计数。
- en: 'In such a situation, you’d keep a count of the elements somewhere, and add
    one to this count each time you added an element to the list. Maybe you’d have
    to count once if you were starting with a non-empty list, but that’s it. This
    technique is what you learned in [chapter 4](kindle_split_011.xhtml#ch04): memoization.
    The question is, where can you store the memoized value? The answer is obvious:
    in the list itself.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你会在某个地方保留元素的计数，并且每次向列表中添加元素时，都会将这个计数加一。如果你从一个非空列表开始，可能只需要计数一次，但这就足够了。这种技术就是你在[第4章](kindle_split_011.xhtml#ch04)中学到的：记忆化。问题是，你可以在哪里存储记忆化的值？答案是显而易见的：在列表本身。
- en: 8.1.2\. The benefit of memoization
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.2\. 记忆化的好处
- en: Maintaining a count of the elements in a list will take some time, so adding
    an element to a list will be slightly slower than if you didn’t keep the count.
    It might look like you’re trading time against time. If you build a list of 1,000,000
    elements, you’ll lose 1,000,000 times the amount of time needed to add one to
    the count. In compensation, however, the time needed to get the length of the
    list will be near 0 (and obviously constant). Maybe the total time lost in incrementing
    the count will equal the gain when calling `length`. But as soon as you call `length`
    more than once, the gain is absolutely obvious.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 维护列表中元素数量的计数将花费一些时间，因此向列表中添加元素会比不保持计数时稍微慢一些。这看起来像是你在时间与时间之间进行交易。如果你构建一个包含1,000,000个元素的列表，你将失去1,000,000倍于添加一个元素到计数所需的时间。然而，作为补偿，获取列表长度所需的时间将接近0（并且显然是恒定的）。也许在增加计数时损失的总时间将与调用`length`时的收益相等。但一旦你多次调用`length`，这种收益就绝对明显了。
- en: 8.1.3\. The drawbacks of memoization
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.3\. 记忆化的缺点
- en: Memoization can turn a function that works in O(*n*) time (time proportional
    to the number of elements) into O(1) time (constant time). This is a huge benefit,
    although it has a time cost, because it makes the insertion of elements slightly
    slower. But slowing insertion is generally not a big problem.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 记忆化可以将一个在O(*n*)时间（与元素数量成比例的时间）内工作的函数转换为O(1)时间（恒定时间）。这是一个巨大的好处，尽管它有一个时间成本，因为它使得元素的插入稍微慢一些。但减慢插入通常不是一个大问题。
- en: A much more important problem is the increase in memory space. Data structures
    implementing in-place mutation don’t have this problem. In a mutable list, nothing
    keeps you from memoizing the list length as a mutable integer, which takes only
    32 bits. But with an immutable list, you have to memoize the length in each element.
    It’s difficult to know the exact increase in size, but if the size of a singly
    linked list is around 40 bytes per node (for the nodes themselves), plus two 32-bit
    references for the head and the tail (on a 32-bit JVM), this would result in about
    100 bytes per element. In this case, adding the length would cause an increase
    of slightly over 30%. The result would be the same if the memoized values were
    references, such as memoizing the `max` or `min` of a list of `Comparable` objects.
    On a 64-bit JVM, it’s even more difficult to calculate due to some optimization
    in the size of the references, but you get the idea.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更加重要的问题是内存空间的增加。实现原地修改的数据结构没有这个问题。在可变列表中，没有什么能阻止你将列表长度记忆化为一个可变整数，它只需要32位。但是，对于不可变列表，你必须在每个元素中记忆化长度。很难知道确切的尺寸增加，但如果单链表的每个节点大小约为40字节（对于节点本身），加上头和尾的两个32位引用（在32位JVM上），这将导致每个元素约为100字节。在这种情况下，添加长度会导致增加略超过30%。如果记忆化的值是引用，比如记忆化`Comparable`对象列表的`max`或`min`，结果也会相同。在64位JVM上，由于一些优化，计算甚至更加困难，但你可以理解这个概念。
- en: '|  |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Sizes of object references
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 对象引用的大小
- en: For more information about the size of object references in Java 7 and Java
    8, see Oracle’s documentation on compressed oops ([http://mng.bz/TjY9](http://mng.bz/TjY9))
    and JVM performance enhancements ([http://mng.bz/8X0o](http://mng.bz/8X0o)).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Java 7和Java 8中对象引用大小的更多信息，请参阅Oracle关于压缩Oops的文档([http://mng.bz/TjY9](http://mng.bz/TjY9))和JVM性能增强([http://mng.bz/8X0o](http://mng.bz/8X0o))。
- en: '|  |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: It’s up to you to decide whether you want to use memoization in your data structures.
    It may be a valid option for functions that are often called and don’t create
    new objects for their results. For example, the `length` and `hashCode` functions
    return integers, and the `max` and `min` functions return references to already
    existing objects, so they may be good candidates. On the other hand, the `toString`
    function creates new strings that would have to be memoized, so that would probably
    be a huge waste of memory space. The other factor to take into consideration is
    how often the function is used. The `length` function may be used more often than
    `hashCode`, because using lists as map keys is not a common practice.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 是否在数据结构中使用记忆化（memoization）取决于你。对于经常被调用且不为其结果创建新对象的函数来说，这可能是一个有效的选项。例如，`length`和`hashCode`函数返回整数，而`max`和`min`函数返回对已存在对象的引用，因此它们可能是很好的候选者。另一方面，`toString`函数创建新的字符串，这些字符串需要被记忆化，这可能会造成巨大的内存空间浪费。另一个需要考虑的因素是函数的使用频率。`length`函数可能比`hashCode`函数使用得更频繁，因为使用列表作为映射键不是一种常见的做法。
- en: Exercise 8.1
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习8.1
- en: Create a memoized version of the `length` method. Its signature in the `List`
    class will be
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`length`方法的记忆化版本。在`List`类中的签名将是
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Solution 8.1
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案8.1
- en: 'The implementation in the `Nil` class is exactly the same as for the nonmemoized
    `length` method:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Nil`类中的实现与未记忆化的`length`方法完全相同：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To implement the `Cons` version, you must first add the memoizing field to
    the class and initialize it in the constructor:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现`Cons`版本，你必须首先将记忆化字段添加到类中，并在构造函数中初始化它：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then you can implement the `lengthMemoized` method to simply return the length:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以实现`lengthMemoized`方法，简单地返回长度：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This version will be much faster than the original one. One interesting thing
    to note is the relationship between the `length` and `isEmpty` methods. You might
    tend to think that `isEmpty` is equivalent to `length == 0`, but although this
    is true from the logical point of view, there can be a huge difference in implementation,
    and thus in performance.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本将比原始版本快得多。一个有趣的现象是`length`和`isEmpty`方法之间的关系。你可能倾向于认为`isEmpty`等价于`length
    == 0`，但从逻辑角度来看，尽管这是真的，但在实现和性能上可能会有很大的差异。
- en: Note that memoizing the maximum or minimum value in a list of `Comparable` could
    be done the same way (although with a static method), but it wouldn’t help in
    the case where you want to remove the max or min value from the list. Min or max
    elements are often accessed to retrieve elements by priority. In that case, the
    elements’ `compareTo` method would compare their priorities. Memoizing priority
    would let you know immediately which element has the maximum priority, but it
    wouldn’t help much because what you often need is to remove the corresponding
    element. For such use cases, you’ll need a different data structure, which you’ll
    learn to create in [chapter 11](kindle_split_018.xhtml#ch11).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，以相同的方式（尽管是静态方法）缓存`Comparable`列表中的最大值或最小值是可能的，但在你想从列表中移除最大或最小值的情况下，这并没有帮助。最小或最大元素通常通过优先级来检索元素。在这种情况下，元素的`compareTo`方法会比较它们的优先级。缓存优先级会让你立即知道哪个元素具有最高优先级，但这帮助不大，因为你通常需要移除相应的元素。对于这样的用例，你需要一个不同的数据结构，你将在第11章（[chapter
    11](kindle_split_018.xhtml#ch11)）中学习如何创建它。
- en: 8.1.4\. Actual performance
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.4\. 实际性能
- en: As I said, it’s up to you to decide if you should memoize some functions of
    the `List` class. A few experiments should help you make your decision. Measuring
    the available memory size just before and after the creation of a list of 1,000,000
    integers shows a very small increase when using memoization. Although this measurement
    method isn’t very precise, the average decrease in available memory is about 22
    MB in both cases (with or without memoization), varying between 20 MB and 25 MB.
    This shows that the theoretical increase of 4 MB (1,000,000 x 4 bytes) isn’t as
    significant as you’d expected. On the other hand, the increase in performance
    is huge. Asking for the length ten times might cost more than 200 milliseconds
    without memoization. With memoization, the time is 0 (too short a time to be measured
    in milliseconds).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我所说，决定是否应该缓存`List`类的一些函数取决于你。一些实验应该能帮助你做出决定。在创建一个包含1,000,000个整数的列表前后测量可用内存大小，使用缓存时内存增加非常小。尽管这种测量方法不是很精确，但在两种情况下（有或没有缓存），可用内存的平均减少量约为22
    MB，介于20 MB和25 MB之间。这表明理论上的4 MB（1,000,000 x 4字节）的增加并不像你预期的那么显著。另一方面，性能的提升是巨大的。在没有缓存的情况下，请求长度十次可能需要超过200毫秒。有了缓存，时间几乎为0（短到无法用毫秒来测量）。
- en: Note that although adding an element increases the cost (adding one to the tail
    length and storing the result), removing an element has zero cost, because the
    tail length is already memoized.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管添加一个元素会增加成本（将长度加一并存储结果），但移除一个元素没有成本，因为尾部长度已经被缓存。
- en: 'Another way to go, if memoization isn’t desirable, is to optimize the `length`
    method. Instead of using a fold, you can resort to imperative style, with a loop
    and a local mutable variable. Here’s the `length` implementation borrowed from
    the Scala `List` class:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不希望使用缓存，另一种方法是优化`length`方法。而不是使用折叠，你可以求助于命令式风格，使用循环和局部可变变量。以下是从Scala `List`类借用的`length`实现：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Although it doesn’t look very functional in style, this implementation is perfectly
    compatible with the definition of functional programming. It’s a pure function
    without any observable effect from the outside world. The main problem is that
    it’s only five times faster than the fold-based implementation, where the memoized
    implementation can be millions of times faster for very large lists.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它在风格上看起来不太像函数式编程，但这种实现与函数式编程的定义完全兼容。它是一个纯函数，没有任何外部世界可观察的效果。主要问题是它只比基于折叠的实现快五倍，而对于非常大的列表，缓存实现可以快数百万倍。
- en: 8.2\. Composing List and Result
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2\. 列表与结果的组合
- en: In the previous chapter, you saw that `Result` and `List` are very similar data
    structures, mainly differing in their cardinality but sharing some of their most
    important methods, such as `map`, `flatMap`, and even `foldLeft` and `foldRight`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你看到了`Result`和`List`是非常相似的数据结构，主要区别在于它们的基数，但它们共享一些最重要的方法，例如`map`、`flatMap`，甚至`foldLeft`和`foldRight`。
- en: You saw how lists could be composed with lists, and results with results. Now,
    you’re going to see how results can be composed with lists.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到了如何用列表来组合列表，以及结果与结果的组合。现在，你将看到结果如何与列表组合。
- en: 8.2.1\. Methods on List returning Result
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.1\. 列表方法返回结果
- en: At this point, you’ve noticed that I try to avoid accessing the elements of
    results and lists directly. Accessing the head or the tail of a list will throw
    an exception if the list is `Nil`, and throwing an exception is one of the worst
    things that can happen in functional programming. But you saw that you could safely
    access the value in a `Result` by providing a default value to be used in the
    case of a failure or empty result. Can you do the same when accessing the head
    of a list? Not exactly, but you can return a `Result`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经注意到我试图避免直接访问结果和列表的元素。如果列表是`Nil`，访问列表的头部或尾部将抛出异常，而在函数式编程中抛出异常是可能发生的最糟糕的事情之一。但是你看到，通过提供一个用于失败或空结果的情况的默认值，你可以安全地访问`Result`中的值。你能否在访问列表的头部时做同样的事情？不是完全一样，但你可以返回一个`Result`。
- en: Exercise 8.2
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 8.2
- en: Implement a `headOption` method in `List<A>` that will return a `Result<A>`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在`List<A>`中实现一个`headOption`方法，该方法将返回一个`Result<A>`。
- en: Hint
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: 'Use the following abstract method declaration in `List`, and implement it in
    each subclass:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在`List`中使用以下抽象方法声明，并在每个子类中实现它：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that the method is called `headOption` to indicate that a value is optional,
    although you’ll use `Result` for the type.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，方法被命名为`headOption`是为了表明一个值是可选的，尽管你将使用`Result`作为类型。
- en: Solution 8.2
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 8.2
- en: 'The implementation of the `Nil` class returns `Empty`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`Nil`类的实现返回`Empty`：'
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `Cons` implementation returns a `Success` holding the head value:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cons`实现返回一个包含头值的`Success`：'
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Exercise 8.3
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 8.3
- en: Create a `lastOption` method returning a `Result` of the last element in the
    list.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个返回列表中最后一个元素的`Result`的`lastOption`方法。
- en: Hint
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Don’t use explicit recursion, but try to build on the methods you developed
    in [chapter 5](kindle_split_012.xhtml#ch05). You should be able to define a single
    method in the `List` class.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用显式递归，而是尝试构建你在[第5章](kindle_split_012.xhtml#ch05)中开发的方法。你应该能够在`List`类中定义一个单一的方法。
- en: Solution 8.3
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 8.3
- en: 'A trivial solution is to use explicit recursion:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的解决方案是使用显式递归：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This solution has several problems. It’s stack-based recursive, so you should
    transform it to make it heap-based, plus you have to handle the case of the empty
    list, where `tail().lastOption()` would throw an NPE.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解决方案有几个问题。它是基于栈的递归，所以你应该将其转换为基于堆的，另外你还需要处理空列表的情况，其中`tail().lastOption()`会抛出NPE。
- en: 'But you can simply use a fold, which abstracts recursion for you! All you need
    to do is create the right function for folding. You need to always keep the last
    value if it exists. This might be the function to use:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 但你可以简单地使用折叠，它为你抽象了递归！你需要做的只是创建正确的折叠函数。你需要始终保留存在的最后一个值。这可能就是你要使用的函数：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Or use a method reference:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 或者使用方法引用：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then you just have to `foldLeft` the list using `Result.Empty` as the identity:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你只需要使用`Result.Empty`作为恒等元`foldLeft`列表：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Exercise 8.4
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 8.4
- en: Can you replace the `headOption` method with a single implementation in the
    `List` class? What would be the benefits and drawbacks of such an implementation?
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你能否在`List`类中用单个实现替换`headOption`方法？这种实现的好处和缺点是什么？
- en: Solution 8.4
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 8.4
- en: 'It’s possible to create such an implementation:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能创建这样的实现：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The only benefit is that it’s more fun if you like it that way. When devising
    the `last-Option` implementation, you knew you had to traverse the list in order
    to find the last element. To find the first element, you don’t need to traverse
    the list. Using `fold-Right` here is exactly the same as reversing the list and
    then traversing the result to find the last element (which is the first element
    of the original list). Not very efficient! And by the way, this is exactly what
    the `lastOption` method does to find the last element: reverses the list and takes
    the first element of the result. So except for the fun, there’s really no reason
    to use this implementation.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的好处是如果你喜欢这种方式，它会更有趣。在设计`last-Option`实现时，你知道你必须遍历列表以找到最后一个元素。要找到第一个元素，你不需要遍历列表。在这里使用`fold-Right`与反转列表然后遍历结果以找到最后一个元素（这是原始列表的第一个元素）完全相同。这并不高效！顺便说一句，这正是`lastOption`方法找到最后一个元素的方式：反转列表并取结果的第一个元素。所以除了有趣之外，实际上没有理由使用这种实现。
- en: 8.2.2\. Converting from List<Result> to Result<List>
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.2. 将List<Result>转换为Result<List>
- en: 'When a list contains the results of some computations, it will often be a `List<Result>`.
    For example, mapping a function from `T` to `Result<U>` on a list of `T` will
    produce a list of `Result<U>`. Such values will often have to be composed with
    functions taking a `List<T>` as their argument. This means you’ll need a way to
    convert the resulting `List<Result<U>>` into a `List<U>`, which is the same kind
    of flattening involved in the `flatMap` method, with the huge difference that
    two different data types are involved: `List` and `Result`. You can apply several
    strategies to this conversion:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个列表包含一些计算的结果时，它通常是一个 `List<Result>`。例如，将函数从 `T` 映射到 `Result<U>` 应用到一个 `T`
    的列表上，将产生一个 `Result<U>` 的列表。这些值通常需要与接受 `List<T>` 作为参数的函数组合。这意味着你需要一种方法将结果 `List<Result<U>>`
    转换成一个 `List<U>`，这与 `flatMap` 方法中的扁平化类似，但有一个巨大的区别：涉及两种不同的数据类型：`List` 和 `Result`。你可以应用几种策略来完成这个转换：
- en: Throw away all failures or empty results and produce a list of `U` from the
    remaining list of successes. If there’s no success in the list, the result could
    simply contain an empty `List`.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 丢弃所有失败或空结果，并从剩余的成功列表中生成一个 `U` 的列表。如果列表中没有成功，结果可以简单地包含一个空的 `List`。
- en: Throw away all failures or empty results and produce a list of `U` from the
    remaining list of successes. If there’s no success in the list, the result would
    be a `Failure`.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 丢弃所有失败或空结果，并从剩余的成功列表中生成一个 `U` 的列表。如果列表中没有成功，结果将是一个 `Failure`。
- en: Decide that all elements must be successes for the whole operation to succeed.
    Construct a list of `U` with the values if all are successes and return it as
    a `Success <List<U>>`, or return a `Failure<List<U>>` otherwise.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决定所有元素都必须是成功，整个操作才能成功。如果所有元素都是成功，则使用值构造一个 `U` 的列表，并作为 `Success<List<U>>` 返回，否则返回
    `Failure<List<U>>`。
- en: The first solution would correspond to a list of results where all results are
    optional. The second solution means that there should be at least one success
    in the list for the result to be a success. The third solution corresponds to
    the case where all results are mandatory.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个解决方案对应于所有结果都是可选的结果列表。第二个解决方案意味着列表中至少有一个成功，结果才是一个成功。第三个解决方案对应于所有结果都是必需的情况。
- en: Exercise 8.5
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 8.5
- en: 'Write a method called `flattenResult` that takes a `List<Result<A>>` as its
    argument and returns a `List<A>` containing all the success values in the original
    list, ignoring the failures and empty values. This will be a static method in
    `List` with the following signature:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个名为 `flattenResult` 的方法，它接受一个 `List<Result<A>>` 作为其参数，并返回一个包含原始列表中所有成功值的
    `List<A>`，忽略失败和空值。这将是 `List` 中的一个静态方法，其签名如下：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Try not to use explicit recursion but to compose methods from the `List` and
    `Result` classes.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量不要使用显式递归，而是组合 `List` 和 `Result` 类的方法。
- en: Hint
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: The name chosen for the method is an indication of what you have to do.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为该方法选择的名字是你要做的指示。
- en: Solution 8.5
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 8.5
- en: 'To solve this exercise, you can use the `foldRight` method to fold the list
    with a function producing a list of lists. Each `Success` will be transformed
    into a list of one element containing the value, whereas each `Failure` or `Empty`
    will be transformed into an empty list. Here’s the function:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个练习，你可以使用 `foldRight` 方法将列表折叠成一个由函数生成的列表列表。每个 `Success` 将被转换成一个包含单个元素的列表，其中包含值，而每个
    `Failure` 或 `Empty` 将被转换成一个空列表。以下是该函数：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Once you have this function, you can use it to fold the list to the right,
    producing a list of lists of values, with some elements being empty lists:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了这个函数，你可以用它来将列表向右折叠，生成一个包含值的列表列表，其中一些元素是空列表：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'All that’s left to do is to `flatten` the result. The complete method is as
    follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的工作就是将结果 `flatten`。完整的方法如下：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Please note that this is not the most efficient way to do it. Take this mostly
    as an exercise.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这不是最有效的方法。这主要是一个练习。
- en: Exercise 8.6
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 8.6
- en: 'Write a `sequence` function that combines a `List<Result<T>>` into a `Result<List<T>>`.
    It will be a `Success<List<T>>` if all values in the original list were `Success`
    instances, or a `Failure<List<T>>` otherwise. Here’s its signature:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个 `sequence` 函数，它将 `List<Result<T>>` 合并成一个 `Result<List<T>>`。如果原始列表中的所有值都是
    `Success` 实例，则它将是一个 `Success<List<T>>`，否则是一个 `Failure<List<T>>`。以下是它的签名：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Hint
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Once again, use the `foldRight` method and not explicit recursion. You’ll also
    need the `map2` method you defined in the `Result` class.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用 `foldRight` 方法而不是显式递归。你还需要在 `Result` 类中定义的 `map2` 方法。
- en: Solution 8.6
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 8.6
- en: 'Here’s the implementation using `foldRight` and `map2`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用 `foldRight` 和 `map2` 的实现方法：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Note that this implementation handles an empty `Result` as if it were a `Failure`
    and returns the first failing case it encounters, which can be a `Failure` or
    an `Empty`. This may or may not be what you need. To stick with the idea that
    `Empty` means optional data, you’d need to first filter the list to remove the
    `Empty` elements:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个实现将空的 `Result` 处理成 `Failure`，并返回它遇到的第一个失败案例，这可能是一个 `Failure` 或一个 `Empty`。这可能是你需要的，也可能不是。为了坚持
    `Empty` 表示可选数据的想法，你需要首先过滤列表以移除 `Empty` 元素：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Ultimately you should abstract the removal of empty elements into a separate
    method in the `List` class. But for the rest of this book, we’ll continue considering
    `Empty` as a `Failure` in the context of the `sequence` method.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，你应该将移除空元素的操作抽象成一个单独的方法，在 `List` 类中。但在本书的其余部分，我们仍将 `Empty` 视为 `sequence` 方法上下文中的
    `Failure`。
- en: Exercise 8.7
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 8.7
- en: 'Define a more generic `traverse` method that traverses a list of `A` while
    applying a function from `A` to `Result<B>` and producing a `Result<List<B>>`.
    Here’s its signature:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个更通用的 `traverse` 方法，它遍历一个 `A` 的列表，同时应用一个从 `A` 到 `Result<B>` 的函数，并生成一个 `Result<List<B>>`。以下是它的签名：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Then define a new version of `sequence` in terms of `traverse`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然后用 `traverse` 方法定义 `sequence` 的新版本。
- en: Hint
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Don’t use recursion. Prefer the `foldRight` method, which abstracts recursion
    for you.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用递归。优先使用 `foldRight` 方法，它为你抽象了递归。
- en: Solution 8.7
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 8.7
- en: 'First define the `traverse` method:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 首先定义 `traverse` 方法：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then you can redefine the `sequence` method in terms of `traverse`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以用 `traverse` 方法来重新定义 `sequence` 方法：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 8.3\. Abstracting common List use cases
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3. 抽象化常见的列表使用场景
- en: Many common use cases of the `List` data type deserve to be abstracted so you
    don’t have to repeat the same code again and again. You’ll regularly find yourself
    discovering new use cases that can be implemented by combining basic functions.
    You should never hesitate to incorporate these use cases as new functions in the
    `List` class. The following exercises show several of the most common use cases.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 `List` 数据类型的常见使用场景值得抽象化，这样你就不必一次又一次地重复相同的代码。你经常会发现自己发现新的使用场景，这些场景可以通过组合基本函数来实现。你永远不应该犹豫将这些使用场景作为
    `List` 类中的新函数来包含。以下练习展示了几个最常见的使用场景。
- en: 8.3.1\. Zipping and unzipping lists
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.1. 压缩和解压缩列表
- en: Zipping is the process of assembling two lists into one by combining the elements
    of the same index. Unzipping is the reverse procedure, consisting of making two
    lists out of one by “deconstructing” the elements, such as producing two lists
    of `x` and `y` coordinates from one list of points.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩（Zipping）是将两个列表组合成一个列表的过程，通过合并相同索引的元素。解压缩（Unzipping）是相反的过程，通过“解构”元素来从单个列表中生成两个列表，例如从一个点列表中生成
    `x` 和 `y` 坐标的两个列表。
- en: Exercise 8.8
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 8.8
- en: 'Write a `zipWith` method that combines the elements of two lists of different
    types to produce a new list, given a function argument. Here’s the signature:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个 `zipWith` 方法，它结合两个不同类型的列表的元素，并使用一个函数参数生成一个新的列表。以下是它的签名：
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This method takes a `List<A>` and a `List<B>` and produces a `List<C>` with
    the help of a function from `A` to `B` to `C`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法接受一个 `List<A>` 和一个 `List<B>`，通过一个从 `A` 到 `B` 到 `C` 的函数，生成一个 `List<C>`。
- en: Hint
  id: totrans-138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: The zipping should be limited to the length of the shortest list.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩应该限制在最短列表的长度内。
- en: Solution 8.8
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 8.8
- en: 'For this exercise, you must use explicit recursion because recursion must be
    done on both lists simultaneously. You don’t have any abstraction at your disposal
    for this. Here’s the solution:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个练习，你必须使用显式递归，因为递归必须在两个列表上同时进行。你没有任何抽象可以使用。以下是解决方案：
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `zipWith_` helper method is called with an empty list as the starting accumulator.
    If one of the two argument lists is empty, recursion is stopped and the current
    accumulator is returned. Otherwise, a new value is computed by applying the function
    to the head value of both lists, and the helper function is called recursively
    with the tails of both argument lists.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`zipWith_` 辅助方法使用空列表作为起始累加器被调用。如果两个参数列表中的任意一个为空，递归停止，并返回当前的累加器。否则，通过将函数应用于两个列表的头部值来计算一个新的值，并递归地使用两个参数列表的尾部调用辅助函数。'
- en: Exercise 8.9
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 8.9
- en: The previous exercise consisted of creating a list by matching elements of both
    lists by their indexes. Write a `product` method that will produce a list of all
    possible combinations of elements taken from both lists. In other words, given
    the two lists `list("a", "b", "c")` and `list("d", "e", "f")` and string concatenation,
    the product of the two lists should be `List("ad", "ae", "af", "bd", "be", "bf",
    "cd", "ce", "cf")`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个练习是通过对两个列表的元素按索引匹配来创建一个列表。编写一个`product`方法，该方法将生成从两个列表中取出的所有可能元素组合的列表。换句话说，给定两个列表`list("a",
    "b", "c")`和`list("d", "e", "f")`以及字符串连接，两个列表的乘积应该是`List("ad", "ae", "af", "bd",
    "be", "bf", "cd", "ce", "cf")`。
- en: Hint
  id: totrans-146
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: For this exercise, you don’t need to use explicit recursion.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个练习，你不需要使用显式递归。
- en: Solution 8.9
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 8.9
- en: The solution is similar to the comprehension pattern you used to compose `Result`
    in [chapter 7](kindle_split_014.xhtml#ch07). The only difference here is that
    it produces as many combinations as the product of the number of elements in the
    lists, whereas for combining `Result`, the number of combinations was always limited
    to one.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案与你在第7章中用来组合`Result`的推导模式类似。唯一的区别是它产生的组合数量与列表中元素数量的乘积一样多，而对于组合`Result`，组合的数量总是限制为1。
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that it’s possible to compose more than two lists this way. The only problem
    is that the number of combinations will grow exponentially.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这样可以通过组合超过两个列表。唯一的问题是组合的数量将以指数级增长。
- en: 'One of the common use cases for `product` and `zipWith` is to use a constructor
    for the combination function. Here’s an example using the `Tuple` constructor:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`product`和`zipWith`的常见用例之一是使用组合函数的构造函数。以下是一个使用`Tuple`构造函数的示例：'
- en: '[PRE28]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The first line will produce a list of all possible tuples constructed from
    the elements of both lists:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行将产生由两个列表的元素构建的所有可能元组的列表：
- en: '[PRE29]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The second line will only produce the list of tuples built from elements with
    the same index:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行将只产生由具有相同索引的元素构建的元组列表：
- en: '[PRE30]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Of course, you may use any constructor of any class. (Java objects are in fact
    tuples with special names.)
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以使用任何类的任何构造函数。（Java对象实际上是具有特殊名称的元组。）
- en: Exercise 8.10
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 8.10
- en: 'Write an `unzip` static method to transform a list of tuples into a tuple of
    lists. Here’s its signature:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个`unzip`静态方法，将元组列表转换为元组列表。以下是它的签名：
- en: '[PRE31]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Hint
  id: totrans-162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Don’t use explicit recursion. A simple call to `foldRight` should do the job.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用显式递归。一个简单的`foldRight`调用就可以完成工作。
- en: Solution 8.10
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 8.10
- en: 'You need to `foldRight` the list using a tuple of two empty lists as the identity:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要使用一个包含两个空列表的元组作为恒等元素来`foldRight`列表：
- en: '[PRE32]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Exercise 8.11
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 8.11
- en: 'Generalize the `unzip` function so it can transform a list of any type into
    a tuple of lists, given a function that takes an object of the list type as its
    argument, and produces a tuple. For example, given a list of `Payment` instances,
    you should be able to produce a tuple of lists: one containing the credit cards
    used to make the payments, and the other containing payment amounts. Implement
    this method as an instance method in `List` with the following signature:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 将`unzip`函数泛化，使其可以将任何类型的列表转换为元组列表，给定一个接受列表类型对象作为其参数并产生元组的函数。例如，给定一个`Payment`实例的列表，你应该能够生成一个包含用于支付的信用的列表和一个包含支付金额的列表的元组。将此方法实现为`List`的实例方法，其签名如下：
- en: '[PRE33]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Hint
  id: totrans-170
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: The solution is pretty much the same as for exercise 8.10.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案与练习8.10的解决方案几乎相同。
- en: Solution 8.11
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 8.11
- en: 'One important thing is that the result of the function is to be used twice.
    In order not to apply the function twice, you must use a multiline lambda:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，函数的结果将被使用两次。为了不将函数应用两次，你必须使用多行lambda：
- en: '[PRE34]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 8.3.2\. Accessing elements by their index
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.2. 通过索引访问元素
- en: The singly linked list isn’t the best structure for indexed access to its elements,
    but sometimes it’s necessary to use indexed access. As usual, you should abstract
    such a procedure into `List` methods.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 单链表不是访问其元素的索引的最佳结构，但有时有必要使用索引访问。像往常一样，你应该将此类过程抽象为`List`方法。
- en: Exercise 8.12
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 8.12
- en: Write a `getAt` method that takes an index as its argument and returns the corresponding
    element. The method should not throw an exception in the case of the index being
    out of bounds.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个`getAt`方法，该方法接受一个索引作为其参数，并返回相应的元素。该方法在索引超出范围的情况下不应抛出异常。
- en: Hint
  id: totrans-179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: 'This time, start with an explicitly recursive version. Then try to answer the
    following questions:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，从一个显式的递归版本开始。然后尝试回答以下问题：
- en: Is it possible to do it with a fold? Right or left?
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否可以使用折叠操作完成？是左折叠还是右折叠？
- en: Why is the explicit recursive version better?
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么显式的递归版本更好？
- en: Can you see a way to solve the problem?
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你能找到解决问题的方法吗？
- en: Solution 8.12
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解答 8.12
- en: 'The explicitly recursive solution is easy:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 显式的递归解决方案很简单：
- en: '[PRE35]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: First, you can check the index to see if it’s positive and less than the list
    length. If it isn’t, just return a `Failure`. Otherwise, call the helper method
    to process the list recursively. This method checks whether the index is 0\. If
    it is, it returns the head of the list. Otherwise, it calls itself recursively
    on the tail of the list with a decremented index.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以检查索引是否为正且小于列表长度。如果不是，就返回一个`Failure`。否则，调用辅助方法递归地处理列表。此方法检查索引是否为0。如果是，则返回列表的头部。否则，它将递归地调用自身在列表的尾部，并使用递减的索引。
- en: 'This looks like the best possible recursive solution. Is it possible to use
    a fold? Yes, it is, and it should be a left fold. But the solution is tricky:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来是最好的可能递归解决方案。是否可以使用折叠操作？是的，可以，而且应该是一个左折叠。但解决方案很棘手：
- en: '[PRE36]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: First you have to define the identity value. Because this value must hold both
    the result and the index, it will be a `Tuple` holding the `Failure` case. Then
    you can check the index for validity. If it’s found invalid, make the temporary
    result (`rt`) equal to `identity`. Otherwise, fold to the left with a function
    returning either the already computed result (`ta`) if the index is less than
    0, or a new `Success` otherwise.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你必须定义恒等值。因为这个值必须同时持有结果和索引，所以它将是一个包含`Failure`情况的`Tuple`。然后你可以检查索引的有效性。如果发现无效，将临时结果（`rt`）设置为`identity`。否则，使用返回已计算结果（`ta`）的函数向左折叠，如果索引小于0，或者如果否则返回一个新的`Success`。
- en: 'This solution might seem smarter, but it’s not, for three reasons:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案可能看起来更聪明，但实际上并非如此，原因有三：
- en: It’s far less legible. This may be subjective, so it’s up to you to decide.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的可读性远低。这可能具有主观性，所以这取决于你决定。
- en: You have to use an intermediate result (`rt`) because Java can’t infer the right
    type. Try replacing `rt` with its value in the last line if you don’t believe
    me.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你必须使用一个中间结果（`rt`），因为Java无法推断正确的类型。如果你不相信我，尝试在最后一行将`rt`替换为其值。
- en: It’s less efficient because it will continue folding the whole list even after
    it finds the searched-for value.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它效率较低，因为它会在找到搜索到的值之后继续折叠整个列表。
- en: Exercise 8.13 (hard and optional)
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 8.13（困难且可选）
- en: Find a solution that makes the fold-based version terminate as soon as the result
    is found.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 找到一个解决方案，使得基于折叠的版本在找到结果后立即终止。
- en: Hint
  id: totrans-197
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: You’ll need a special version of `foldLeft` for this, and also a special version
    of `Tuple`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要为这个特殊版本提供`foldLeft`，以及一个特殊的`Tuple`版本。
- en: Solution 8.13
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解答 8.13
- en: 'First, you need a special version of `foldLeft` in which you can escape the
    fold when the absorbing element (or “zero” element) of the folding operation is
    found. Think of a list of integers that you want to fold by multiplying them.
    The absorbing element for the multiplication is 0\. Here’s the declaration of
    a short-circuiting (or escaping) version of `foldLeft` in the `List` class:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要一个特殊的`foldLeft`版本，其中可以在找到折叠操作的吸收元素（或“零”元素）时退出折叠。想象一下你想要通过乘法折叠的整数列表。乘法的吸收元素是0。以下是`List`类中短路（或退出）版本的`foldLeft`声明：
- en: '[PRE37]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '|  |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The zero element
  id: totrans-203
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 零元素
- en: It’s by analogy that the absorbing element of any operation is sometimes called
    “zero,” but remember that it’s not always equal to 0\. The 0 value is only the
    absorbing element for multiplication. For the addition of positive integers, it
    would be infinity.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 通过类比，任何操作的吸收元素有时被称为“零”，但请记住，它并不总是等于0。0值只是乘法的吸收元素。对于正整数的加法，它将是无穷大。
- en: '|  |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'And here’s the `Cons` implementation:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`Cons`的实现：
- en: '[PRE38]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As you can see, the only difference is that if the accumulator value is found
    to be “zero,” recursion is stopped and the accumulator is returned.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，唯一的区别是，如果累加器的值被发现在是“零”，递归就会停止，并返回累加器。
- en: 'Now you need a zero value for your fold. The zero value is a `Tuple<Result<A,
    Integer>` with the `Integer` value equal to `-1` (the first value smaller than
    0). Can you use a standard `Tuple` for this? No, you can’t, because it must have
    a special equals method, returning `true` when the integer values are equal, whatever
    the `Result<A>` is. The complete method is as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你需要一个零值用于 fold。零值是一个 `Tuple<Result<A, Integer>`，其中 `Integer` 的值为 `-1`（第一个小于
    0 的值）。你能使用标准的 `Tuple` 吗？不，你不能，因为它必须有一个特殊的等于方法，当整数值相等时返回 `true`，无论 `Result<A>`
    是什么。完整的方法如下：
- en: '[PRE39]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note that I’ve omitted the `hashCode` and `toString` methods to make the code
    shorter.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我已经省略了 `hashCode` 和 `toString` 方法，以使代码更短。
- en: 'Now the fold will automatically stop as soon as the searched-for element is
    found. Of course, you can use the new `foldLeft` method for escaping any computation
    with a zero element. (Remember: zero, not 0.)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 fold 将在找到搜索到的元素后自动停止。当然，你可以使用新的 `foldLeft` 方法来逃逸任何带有零元素的计算。（记住：零，不是 0。）
- en: 8.3.3\. Splitting lists
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.3\. 分割列表
- en: Sometimes you need to split a list into two parts at a specific position. Although
    the singly linked list is far from ideal for this kind of operation, it’s relatively
    simple to implement. Splitting a list has several useful applications, among which
    is processing its parts in parallel using several threads.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你需要将列表在特定位置分割成两部分。尽管单链表对于这种操作来说远非理想，但实现起来相对简单。分割列表有几个有用的应用，其中之一是使用多个线程并行处理其部分。
- en: Exercise 8.14
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 8.14
- en: Write a `splitAt` method that takes an `int` as its parameter and returns two
    lists by splitting the list at the given position. There shouldn’t be any `IndexOutOfBound-Exception`s.
    Instead, an index below `0` should be treated as `0`, and an index above max should
    be treated as the maximum value for the index.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个 `splitAt` 方法，该方法接受一个 `int` 作为参数，并在给定位置分割列表，返回两个列表。不应该有任何 `IndexOutOfBound-Exception`。相反，一个小于
    `0` 的索引应该被视为 `0`，一个大于最大值的索引应该被视为索引的最大值。
- en: Hint
  id: totrans-217
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Make the method explicitly recursive.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 使方法显式递归。
- en: Solution
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解答
- en: 'An explicitly recursive solution is easy to design:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 设计一个显式递归的解法很简单：
- en: '[PRE40]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note that the first method uses recursion to adjust the value of the index.
    There’s no need for using `TailCall`, however, because this method will recurse
    at most once. The second method is very similar to the `getAt` method, with the
    difference that the list is first reversed. The method accumulates the elements
    until the index position is reached, so the accumulated list is in the correct
    order, but the remaining list has to be reversed back.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，第一个方法使用递归来调整索引的值。然而，不需要使用 `TailCall`，因为这个方法最多只会递归一次。第二个方法与 `getAt` 方法非常相似，不同之处在于列表首先被反转。该方法累积元素直到达到索引位置，因此累积的列表是正确的顺序，但剩余的列表需要反转回来。
- en: Exercise 8.15 (not so hard if you’ve done exercise 8.13)
  id: totrans-223
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 8.15（如果你已经完成了练习 8.13，那么这个练习就不会那么难）
- en: Can you think of an implementation using a fold instead of explicit recursion?
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你能想到一个使用 fold 而不是显式递归的实现吗？
- en: Hint
  id: totrans-225
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: An implementation traversing the whole list is easy. An implementation traversing
    the list only until the index is found is much more difficult and will need a
    new special version of `foldLeft` with escape, returning both the escaped value
    and the rest of the list.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 一个遍历整个列表的实现很简单。一个只遍历到找到索引为止的列表实现则要复杂得多，并且需要一个带有逃逸的新特殊版本的 `foldLeft`，返回逃逸值和列表的其余部分。
- en: Solution 8.15
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解答 8.15
- en: 'A solution traversing the whole list could be as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 一个遍历整个列表的解决方案可能如下：
- en: '[PRE41]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The result of the fold is accumulated in the first list accumulator until the
    index is reached (after the index value has been adjusted to avoid index out of
    bounds). Once the index is found, the list traversal continues, but the remaining
    values are accumulated in the second list accumulator.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: fold 的结果累积在第一个列表累加器中，直到达到索引（在调整索引值以避免索引越界之后）。一旦找到索引，列表遍历继续，但剩余的值累积在第二个列表累加器中。
- en: 'One problem with this implementation is that by accumulating the remaining
    values in the second list accumulator, you reverse this part of the list. Not
    only should you not need to traverse the remainder of the list, but it’s done
    twice here: once for accumulating in reverse order, and once for eventually reversing
    the result. To avoid this, you should modify the special “escaping” version of
    `foldLeft` so it will return not only the escaped result (the absorbing, or zero
    element), but also the rest of the list, untouched. To achieve this, you must
    change the signature to return a `Tuple`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现的一个问题是，通过在第二个列表累加器中累积剩余值，你反转了列表的这一部分。不仅不应该需要遍历列表的剩余部分，而且在这里它被做了两次：一次是为了以相反的顺序累积，一次是为了最终反转结果。为了避免这种情况，你应该修改特殊的“逃逸”版本的
    `foldLeft`，使其不仅返回逃逸结果（吸收元素或零元素），还返回未受影响的列表的其余部分。为了实现这一点，你必须更改签名以返回一个 `Tuple`：
- en: '[PRE42]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then you need to change the implementation in the `Nil` class:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你需要更改 `Nil` 类的实现：
- en: '[PRE43]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Finally, you must change the `Cons` implementation to return the remainder
    of the list:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你必须将 `Cons` 实现改为返回列表的剩余部分：
- en: '[PRE44]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now you can rewrite the `splitAt` method using this special `foldLeft` method:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用这个特殊的 `foldLeft` 方法重写 `splitAt` 方法：
- en: '[PRE45]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Here, you again need a specific `Tuple3` class with a special `equals` method
    returning `true` when the third elements are equal, not taking into account the
    two first elements. Note that the second resulting list doesn’t need to be reversed.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，你同样需要一个特定的 `Tuple3` 类，它有一个特殊的 `equals` 方法，当第三个元素相等时返回 `true`，而不考虑前两个元素。请注意，第二个结果列表不需要反转。
- en: '|  |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**When not to use folds**'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '**何时不使用 fold**'
- en: 'Just because it’s possible to use a fold doesn’t mean you should do so. The
    preceding exercises are just that: exercises. As a functional library designer,
    you need to choose the most efficient implementation.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 只因为可以使用 fold 并不意味着你应该这样做。前面的练习只是练习而已。作为一个函数式库的设计者，你需要选择最有效的实现方式。
- en: A functional library must have a functional interface and must respect the functional
    programming requirements, which means all functions must be true functions with
    no side effects, and all must respect referential transparency. What happens inside
    the library is irrelevant. A functional library in an imperative-oriented language
    like Java can be compared to a compiler for a functional-oriented language. The
    compiled code will always be imperative because this is what the computer understands.
    A functional library gives more choice. Some functions may be implemented in functional
    style and others in imperative style; it doesn’t matter. Splitting a singly linked
    list or finding an element by its index is much easier and much faster when it’s
    implemented imperatively than functionally because the singly linked list isn’t
    adapted for such an operation.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数式库必须有一个函数式接口，并且必须遵守函数式编程的要求，这意味着所有函数都必须是真正的函数，没有副作用，并且都必须遵守引用透明性。库内部发生的事情无关紧要。在像
    Java 这样的命令式语言中，函数式库可以与函数式语言的编译器相提并论。编译后的代码总是命令式的，因为这是计算机能理解的。函数式库提供了更多的选择。一些函数可能以函数式风格实现，而另一些则以命令式风格实现；这无关紧要。当以命令式方式实现时，分割单链表或通过索引查找元素比以函数式方式实现要容易得多，也快得多，因为单链表并不适合这种操作。
- en: The most functional way to go is probably not to implement these functions based
    on folds, but to avoid implementing them at all. If you need structures with functional
    implementations of these functions, the best thing to do is to create specific
    structures, as you’ll see in [chapter 10](kindle_split_017.xhtml#ch10).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 最函数式的方法可能不是基于 fold 实现这些函数，而是根本不实现它们。如果你需要具有这些函数的函数式实现的结构，最好的做法是创建特定的结构，正如你将在第
    10 章中看到的。[第 10 章](kindle_split_017.xhtml#ch10)。
- en: '|  |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 8.3.4\. Searching for sublists
  id: totrans-246
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.4\. 搜索子列表
- en: One common use case for lists is searching to find out whether a list is contained
    in another (longer) list. In other words, you want to know whether a list is a
    sublist of another list.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 列表的一个常见用途是搜索以确定一个列表是否包含在另一个（更长的）列表中。换句话说，你想要知道一个列表是否是另一个列表的子列表。
- en: Exercise 8.16
  id: totrans-248
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 8.16
- en: 'Implement a `hasSubList` method to check whether a list is a sublist of another.
    For example, the list (3, 4, 5) is a sublist of (1, 2, 3, 4, 5) but not of (1,
    2, 4, 5, 6). Implement it as a static method with the following signature:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个 `hasSubList` 方法来检查一个列表是否是另一个列表的子列表。例如，列表 (3, 4, 5) 是列表 (1, 2, 3, 4, 5)
    的子列表，但不是列表 (1, 2, 4, 5, 6) 的子列表。将其实现为一个具有以下签名的静态方法：
- en: '[PRE46]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Hint
  id: totrans-251
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: You’ll first have to implement a `startsWith` method to determine whether a
    list starts with a sublist. Once this is done, you’ll test this method recursively,
    starting from each element of the list.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先必须实现一个`startsWith`方法来确定列表是否以子列表开头。一旦完成，你将递归地测试这个方法，从列表的每个元素开始。
- en: Solution 8.16
  id: totrans-253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案8.16
- en: 'An explicitly recursive `startsWith` method can be implemented as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 可以显式地实现一个`startsWith`方法，如下所示：
- en: '[PRE47]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This is a stack-based version that can be transformed into a heap-based one
    using `TailCall`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基于栈的版本，可以使用`TailCall`转换为基于堆的版本：
- en: '[PRE48]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'From there, implementing `hasSubList` is straightforward:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，实现`hasSubList`是直接的：
- en: '[PRE49]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 8.3.5\. Miscellaneous functions for working with lists
  id: totrans-260
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.5. 用于处理列表的杂项函数
- en: Many other useful functions can be developed to work with lists. The following
    exercises will give you some practice in this domain. Note that the proposed solutions
    are certainly not the only ones. Feel free to invent your own.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 可以开发出许多其他有用的函数来处理列表。以下练习将为你提供在这个领域的一些实践。请注意，提出的解决方案当然不是唯一的。你可以自由地发明自己的。
- en: Exercise 8.17
  id: totrans-262
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习8.17
- en: Create a `groupBy` method taking a function from `A` to `B` as a parameter and
    returning a `Map,` where keys are the result of the function applied to each element
    of the list and values are lists of elements corresponding to each key. In other
    words, given a list of `Payment`s such as these,
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`groupBy`方法，该方法接受一个从`A`到`B`的函数作为参数，并返回一个`Map`，其中键是函数应用于列表中每个元素的输出，值是与每个键对应的元素列表。换句话说，给定如下`Payment`列表，
- en: '[PRE50]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'the following code should create a `Map` containing (key/value) pairs where
    each key is a name and the corresponding value is the list of `Payment`s made
    by the corresponding person:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码应该创建一个包含（键/值）对的`Map`，其中每个键是一个名称，相应的值是相应人员做出的`Payment`列表：
- en: '[PRE51]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Hint
  id: totrans-267
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Use the functional `Map` wrapper from previous chapters. This time, try to create
    an imperative version first. Then create a functional version based on a fold.
    Which one do you prefer?
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前几章中的函数式`Map`包装器。这次，先尝试创建一个命令式版本，然后基于折叠创建一个函数式版本。你更喜欢哪一个？
- en: Solution 8.17
  id: totrans-269
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案8.17
- en: 'Here’s an imperative version. There’s not much to say about it, because it’s
    just traditional imperative code with a local mutable state:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个命令式版本的示例。对此没有太多可说的，因为它只是传统的命令式代码，带有局部可变状态：
- en: '[PRE52]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note that this implementation is perfectly functional because no state mutation
    is visible from outside the method. But the style is quite imperative, with a
    `while` loop and local variables.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个实现是完全功能性的，因为从方法外部看不到任何状态变化。但风格相当命令式，使用了一个`while`循环和局部变量。
- en: 'Here’s a version in a more functional style, using a fold:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个更函数式风格的版本，使用折叠操作：
- en: '[PRE53]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: It’s up to you to choose the style you prefer. Obviously, the second version
    is more compact. But the main advantage is that it better expresses the intent.
    `groupBy` is a fold. Choosing the imperative style is re-implementing the fold,
    whereas choosing the functional style is reusing the abstraction.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 选择你喜欢的风格由你决定。显然，第二个版本更紧凑。但主要优势是它更好地表达了意图。`groupBy`是一个折叠操作。选择命令式风格是重新实现折叠，而选择函数式风格是重用抽象。
- en: Exercise 8.18
  id: totrans-276
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习8.18
- en: 'Write an `unfold` method that takes a starting element `S` and a function `f`
    from `S` to `Result<Tuple<A, S>>` and produces a `List<A>` by successively applying
    `f` to the `S` value as long as the result is a `Success`. In other words, the
    following code should produce a list of integers from 0 to 9:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个`unfold`方法，该方法接受一个起始元素`S`和一个从`S`到`Result<Tuple<A, S>>`的函数`f`，并通过连续应用`f`到`S`值（只要结果是`Success`）来生成一个`List<A>`。换句话说，以下代码应该生成从0到9的整数列表：
- en: '[PRE54]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Solution 8.18
  id: totrans-279
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案8.18
- en: 'A simple non-stack-safe recursive version is easy to implement:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的非栈安全递归版本很容易实现：
- en: '[PRE55]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Unfortunately, although this solution is smart, it will blow the stack for
    a little more than 1,000 recursion steps. To solve this problem, you can create
    a tail recursive version and use the `TailCall` class to make recursion happen
    on the heap:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，尽管这个解决方案很聪明，但它会在超过1,000次递归步骤后耗尽栈空间。为了解决这个问题，你可以创建一个尾递归版本，并使用`TailCall`类在堆上执行递归：
- en: '[PRE56]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Note, however, that this reverses the list. This might not be a big problem
    for small lists, but it could be for huge ones. In such cases, reverting to imperative
    style might be an option.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，然而，这将反转列表。这可能在小型列表中不是大问题，但对于大型列表可能是。在这种情况下，回到命令式风格可能是一个选择。
- en: Exercise 8.19
  id: totrans-285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习8.19
- en: Write a `range` method that takes two integers as its parameters and produces
    a list of all integers greater than or equal to the first and less than the second.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个 `range` 方法，它接受两个整数作为参数，并生成一个所有大于或等于第一个整数且小于第二个整数的整数列表。
- en: Hint
  id: totrans-287
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Of course, you should use methods you’ve already defined.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你应该使用你已经定义的方法。
- en: Solution 8.19
  id: totrans-289
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解答 8.19
- en: 'This is very simple if you reuse the method from exercise 8.18:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你重用练习 8.18 中的方法，这会非常简单：
- en: '[PRE57]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Exercise 8.20
  id: totrans-292
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 8.20
- en: Create an `exists` method that takes a function from `A` to `Boolean` representing
    a condition, and that returns `true` if the list contains at least one element
    satisfying this condition. Don’t use explicit recursion, but try to build on the
    methods you’ve already defined.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 `exists` 方法，它接受一个从 `A` 到 `Boolean` 的函数，表示一个条件，如果列表中至少有一个元素满足这个条件，则返回 `true`。不要使用显式递归，但尝试基于你已定义的方法构建。
- en: Hint
  id: totrans-294
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: There’s no need to evaluate the condition for all elements of the list. The
    method should return as soon as the first element satisfying the condition is
    found.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 没有必要评估列表中所有元素的条件。该方法应在找到满足条件的第一个元素时立即返回。
- en: Solution 8.20
  id: totrans-296
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解答 8.20
- en: 'A recursive solution could be defined as follows:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 递归解决方案可以定义为以下：
- en: '[PRE58]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Because the `||` operator lazily evaluates its second argument, the recursive
    process will stop as soon as an element is found that satisfies the condition
    expressed by the predicate `p`. But this is a non-tail-recursive stack-based method,
    and it will blow the stack if the list is long and no satisfying element is found
    in the first 1,000 or 2,000 elements. Incidentally, it will also throw an exception
    if the list is empty, so you’d have to define an abstract method in the `List`
    class with a specific implementation for the `Nil` subclass.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `||` 运算符会惰性评估其第二个参数，所以一旦找到满足谓词 `p` 表达的条件的一个元素，递归过程就会停止。但这是一个非尾递归的基于栈的方法，如果列表很长且在前
    1,000 或 2,000 个元素中没有找到满足条件的元素，它将会耗尽栈空间。顺便提一下，如果列表为空，它也会抛出异常，因此你必须在 `List` 类中定义一个抽象方法，并为
    `Nil` 子类提供一个特定的实现。
- en: 'A much better solution consists of reusing the `foldLeft` method with a zero
    parameter:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的解决方案是重用 `foldLeft` 方法，并使用零参数：
- en: '[PRE59]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Exercise 8.21
  id: totrans-302
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 8.21
- en: Create a `forAll` method that takes a function from `A` to `Boolean` representing
    a condition, and that returns `true` if all the elements in the list satisfy this
    condition.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 `forAll` 方法，它接受一个从 `A` 到 `Boolean` 的函数，表示一个条件，如果列表中的所有元素都满足这个条件，则返回 `true`。
- en: Hint
  id: totrans-304
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Don’t use explicit recursion. And once again, you don’t always need to evaluate
    the condition for all elements of the list. The `forAll` method will be very similar
    to the `exists` method.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用显式递归。而且，你并不总是需要评估列表中所有元素的条件。`forAll` 方法将与 `exists` 方法非常相似。
- en: Solution 8.21
  id: totrans-306
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解答 8.21
- en: 'The solution is very close to the `exists` method with two differences: the
    identity and zero values are inverted, and the `Boolean` operator is `&&` instead
    of `||`:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案与 `exists` 方法非常相似，有两个不同之处：恒等值和零值被反转，布尔运算符是 `&&` 而不是 `||`：
- en: '[PRE60]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Note that another possibility is to reuse the `exists` method:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，另一种可能性是重用 `exists` 方法：
- en: '[PRE61]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This methods checks whether an element exists that doesn’t meet the inverse
    of the condition.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法检查是否存在不满足条件的元素。
- en: 8.4\. Automatic parallel processing of lists
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4\. 列表的自动并行处理
- en: Most computations that are applied to lists resort to folds. A fold involves
    applying an operation as many times as there are elements in the list. For very
    long lists and long-lasting operations, a fold can take a considerable amount
    of time. Because most computers are now equipped with multicore processors (if
    not multiple processors), you may be tempted to find a way to make the computer
    process a list in parallel.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 应用于列表的大多数计算都会依赖于折叠。折叠涉及将操作应用于列表中的每个元素。对于非常长的列表和持续时间长的操作，折叠可能需要相当长的时间。因为现在大多数计算机都配备了多核处理器（如果不是多个处理器），你可能想找到一种方法让计算机并行处理列表。
- en: 'In order to parallelize a fold, you need only one thing (beside a multicore
    processor, of course): an additional operation allowing you to recompose the results
    of each parallel computation.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 为了并行化一个折叠操作，你只需要一件事情（当然，除了多核处理器）：一个额外的操作，允许你重新组合每个并行计算的结果。
- en: 8.4.1\. Not all computations can be parallelized
  id: totrans-315
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.4.1\. 并非所有计算都可以并行化
- en: Take the example of a list of integers. Finding the mean of all integers isn’t
    something you can directly parallelize. You could break the list into four pieces
    (if you have a computer with four processors) and compute the mean of each sublist.
    But you wouldn’t be able to compute the mean of the list from the means of the
    sublists.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 以整数列表为例。计算所有整数的平均值并不是可以直接并行化的任务。你可以将列表分成四部分（如果你有一台有四个处理器的计算机），然后计算每个子列表的平均值。但你无法从子列表的平均值中计算出整个列表的平均值。
- en: On the other hand, computing the mean of a list implies computing the sum of
    all elements and then dividing it by the number of elements. And computing the
    sum is something that can be easily parallelized by computing the sums of the
    sublists, and then computing the sum of the sublist sums.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，计算列表的平均值意味着计算所有元素的总和，然后除以元素的数量。而计算总和是可以通过计算子列表的总和，然后计算子列表总和的总和来轻松并行化的。
- en: 'This is a very particular example, where the operation used for the fold (the
    addition) is the same as the operation used to assemble the sublist results. This
    isn’t always the case. Take the example of a list of characters that’s folded
    by adding a character to a `String`. To assemble the intermediate results, you
    need a different operation: string concatenation.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常特殊的例子，其中用于折叠的操作（加法）与用于组装子列表结果的操作相同。这并不总是情况。以一个通过添加字符到 `String` 来折叠的字符列表为例。为了组装中间结果，你需要不同的操作：字符串连接。
- en: 8.4.2\. Breaking the list into sublists
  id: totrans-319
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.4.2\. 将列表拆分为子列表
- en: 'First, you must break the list into sublists, and you must do this automatically.
    One important question is how many sublists you should obtain. At first glance,
    you might think that one sublist for each available processor would be ideal,
    but this isn’t exactly the case. The number of processors (or, more precisely,
    the number of logical cores) isn’t the most important factor. There’s a more crucial
    question: will all sublist computations take the same amount of time? Probably
    not, but this depends on the type of computation. If you were to divide the list
    into four sublists because you decided to dedicate four threads to parallel processing,
    some threads might finish very quickly, while others might have to make a much
    longer computation. This would ruin the benefit of parallelization, because it
    might result in most of the computing task being handled by a single thread.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你必须将列表拆分为子列表，并且必须自动完成这项操作。一个重要的问题是应该获得多少个子列表。乍一看，你可能认为每个可用的处理器一个子列表是理想的，但这并不完全正确。处理器的数量（或者更精确地说，逻辑核心的数量）并不是最重要的因素。还有一个更关键的问题：所有子列表的计算是否需要相同的时间？可能不是，这取决于计算的类型。如果你决定将列表分成四个子列表，因为你要将四个线程
    dedicate 给并行处理，一些线程可能会非常快地完成，而其他线程可能需要进行更长时间的计算。这会破坏并行化的好处，因为它可能会导致大部分计算任务由单个线程处理。
- en: A better solution is to divide the list into a large number of sublists, and
    then submit each sublist to a pool of threads. This way, as soon as a thread finishes
    processing a sublist, it’s handed a new one to process. So the first task is to
    create a method that will divide a list into sublists.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的解决方案是将列表分成大量的子列表，然后将每个子列表提交给线程池。这样，一旦一个线程完成处理一个子列表，它就会得到一个新的子列表来处理。因此，首要任务是创建一个将列表拆分为子列表的方法。
- en: Exercise 8.22
  id: totrans-322
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 8.22
- en: 'Write a `divide(int depth)` method that will divide a list into a number of
    sublists. The list will be divided in two, and each sublist recursively divided
    in two, with the `depth` parameter representing the number of recursion steps.
    This method will be implemented in the `List` parent class with the following
    signature:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个 `divide(int depth)` 方法，该方法将列表分成一定数量的子列表。列表将被分成两部分，每个子列表递归地分成两部分，`depth`
    参数表示递归步骤的数量。此方法将在 `List` 父类中实现，以下是其签名：
- en: '[PRE62]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Hint
  id: totrans-325
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: 'You’ll first define a new version of the `splitAt` method that returns a list
    of lists instead of a `Tuple<List, List>`. Let’s call this method `splitListAt`
    and give it the following signature:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先定义一个新的 `splitAt` 方法版本，它返回一个列表的列表，而不是一个 `Tuple<List, List>`。让我们称这个方法为 `splitListAt`，并给它以下签名：
- en: '[PRE63]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Solution 8.22
  id: totrans-328
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 8.22
- en: 'The `splitListAt` method is an explicitly recursive method made stack-safe
    through the use of the `TailCall` class:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '`splitListAt` 方法是一个显式递归方法，通过使用 `TailCall` 类来确保栈安全：'
- en: '[PRE64]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This method will, of course, always return a list of two lists. Then you can
    define the `divide` method as follows:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，此方法将始终返回一个包含两个列表的列表。然后你可以定义 `divide` 方法如下：
- en: '[PRE65]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Note that you don’t need to make this method stack-safe because the number of
    recursion steps will only be log(length). In other words, you’ll never have enough
    heap memory to hold a list long enough to cause a stack overflow.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您不需要使此方法堆栈安全，因为递归步骤的数量将只有log(length)。换句话说，您永远不会拥有足够的堆内存来持有足够长的列表以导致堆栈溢出。
- en: 8.4.3\. Processing sublists in parallel
  id: totrans-334
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.4.3\. 并行处理子列表
- en: To process the sublists in parallel, you’ll need a special version of the method
    to execute, which will take as an additional parameter an `ExecutorService` configured
    with the number of threads you want to use in parallel.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 要并行处理子列表，您需要一个特殊版本的方法来执行，它将接受一个额外的参数，即配置了您想要并行使用的线程数的`ExecutorService`。
- en: Exercise 8.23
  id: totrans-336
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 8.23
- en: 'Create a `parFoldLeft` method in `List<A>` that will take the same parameters
    as `fold-Left` plus an `ExecutorService` and a function from `B` to `B` to `B`
    and that will return a `Result<List<B>>`. The additional function will be used
    to assemble the results from the sublists. Here’s the signature of the method:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在`List<A>`中创建一个`parFoldLeft`方法，它将接受与`fold-Left`相同的参数，加上一个`ExecutorService`和一个从`B`到`B`到`B`的函数，并返回一个`Result<List<B>>`。额外的函数将用于组装子列表的结果。以下是方法的签名：
- en: '[PRE66]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Solution 8.23
  id: totrans-339
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 8.23
- en: 'First, you must define the number of sublists you want to use and divide the
    list accordingly:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您必须定义您想要使用的子列表数量，并相应地分割列表：
- en: '[PRE67]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Then, you’ll map the list of sublists with a function that will submit a task
    to the `Executor-Service`. This task consists of folding each sublist and returning
    a `Future` instance. The list of `Future` instances is mapped to a function calling
    `get` on each `Future` to produce a list of results (one for each sublist). Note
    that you must catch the potential exceptions.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您将使用一个将任务提交给`Executor-Service`的函数映射子列表。该任务包括折叠每个子列表并返回一个`Future`实例。将`Future`实例的列表映射到调用每个`Future`上的`get`的函数，以生成一个结果列表（每个子列表一个）。请注意，您必须捕获潜在的异常。
- en: Eventually, the list of results is folded with the second function, and the
    result is returned in a `Result.Success`. In the case of an exception, a `Failure`
    is returned.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，结果列表将与第二个函数折叠，并将结果以`Result.Success`的形式返回。在发生异常的情况下，返回`Failure`。
- en: '[PRE68]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: You’ll find an example benchmark of this method in the accompanying code ([https://github.com/fpinjava/fpinjava](https://github.com/fpinjava/fpinjava)).
    The benchmark consists of computing 10 times the Fibonacci value of 35,000 random
    numbers between 1 and 30 with a very slow algorithm. On a four-core Macintosh,
    the parallel version executes in 22 seconds, whereas the serial version needs
    83 seconds.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在附带的代码中找到一个此方法的示例基准测试（[https://github.com/fpinjava/fpinjava](https://github.com/fpinjava/fpinjava)）。基准测试包括使用非常慢的算法计算1到30之间35,000个随机数的10次斐波那契值。在四核Macintosh上，并行版本执行时间为22秒，而串行版本需要83秒。
- en: Exercise 8.24
  id: totrans-346
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 8.24
- en: 'Although mapping can be implemented through a fold (and thus can benefit from
    automatic parallelization), it can also be implemented in parallel without using
    a fold. This is probably the simplest automatic parallelization that can be implemented
    on a list. Create a `parMap` method that will automatically apply a given function
    to all elements of a list in parallel. Here’s the method signature:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然映射可以通过折叠实现（因此可以受益于自动并行化），但它也可以在不使用折叠的情况下并行实现。这可能是可以在列表上实现的 simplest automatic
    parallelization。创建一个`parMap`方法，它将自动将给定的函数并行应用于列表的所有元素。以下是方法的签名：
- en: '[PRE69]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Hint
  id: totrans-349
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: In fact, there’s nearly nothing to do in this exercise. Just submit each function
    application to the `ExecutorService`, and get the results from each corresponding
    `Callable`.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在这个练习中几乎没有什么要做。只需将每个函数应用提交给`ExecutorService`，并从每个相应的`Callable`获取结果。
- en: Solution 8.24
  id: totrans-351
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 8.24
- en: 'Here’s the solution:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这是解决方案：
- en: '[PRE70]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The benchmark available in the code accompanying this book will allow you to
    measure the increase in performance. This increase may, of course, vary depending
    on the machine running the program.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 伴随此书的代码中可用的基准测试将允许您测量性能的提升。当然，这种提升可能因运行程序的机器而异。
- en: 8.5\. Summary
  id: totrans-355
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5\. 总结
- en: List processing can be made faster through the use of memoization.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用缓存，可以提高列表处理的效率。
- en: You can convert a `List` of `Result` instances into a `Result` of `List`.
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以将`Result`实例的`List`转换为`List`的`Result`。
- en: You can assemble two lists by zipping them. You can also unzip lists of tuples
    to produce a `Tuple` of lists.
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过`zip`操作组装两个列表。您还可以将元组的列表解包以生成列表的`Tuple`。
- en: You can implement indexed access to list elements using explicit recursion.
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用显式递归来实现列表元素的索引访问。
- en: You can implement a special version of `foldLeft` to escape the fold when a
    “zero” result is obtained.
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以实现一个特殊的`foldLeft`版本，以在获得“零”结果时跳出折叠。
- en: You can create lists by unfolding with a function and a terminal condition.
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过一个函数和终止条件来展开创建列表。
- en: Lists can be automatically split, which allows automatic processing of sublists
    in parallel.
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表可以自动拆分，这允许并行处理子列表。
