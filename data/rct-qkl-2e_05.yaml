- en: 5 Making React interactive with states
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 使用状态使React交互
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: The role of state in a component
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件中状态的作用
- en: Using state in functional components
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数组件中使用状态
- en: Converting stateful class-based components to functional components
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将有状态的类组件转换为函数组件
- en: All the components we’ve created so far take some properties and render some
    HTML based on those properties. We can pass a label property to a button, so the
    button is displayed with that exact button text, for instance. But we can’t make
    the button text change when something happens, such as changing between Turn On
    and Turn Off when toggled. That’s because we lack both the ability to react to
    something that happens and the ability to store the single piece of information
    that something has changed dynamically.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止创建的所有组件都接受一些属性，并根据这些属性渲染一些HTML。我们可以将标签属性传递给按钮，例如，按钮就会显示那个确切的按钮文本。但我们不能让按钮文本在发生某些事情时改变，比如在切换时在开启和关闭之间切换。这是因为我们缺乏对发生的事情做出反应的能力，也缺乏存储动态变化的信息的能力。
- en: The output of the components we’ve created so far depends on nothing but their
    properties. In other words, the components are “pure” in functional programming
    terms. The components have no other inputs and no side effects. If you give the
    same component the same properties, you’ll always get the same result and nothing
    but that result.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止创建的组件的输出仅取决于它们的属性。换句话说，从函数式编程的角度来看，组件是“纯”的。组件没有其他输入，也没有副作用。如果你给同一个组件相同的属性，你将始终得到相同的结果，而且只有那个结果。
- en: That’s all good, and it’s exactly what we want—but it’s also kind of boring.
    Such components are vital for presenting data but are useless if we want to create
    an interactive application. If we want to update something when a button is clicked
    or an input is filled, we need to store that somewhere and pass that information
    to some other component to react to it. Imagine a login form. When users enter
    their email and password, we need to store that information somewhere to display
    error messages if filled incorrectly. When users click the Send button, we need
    to send the data to a remote server.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都很好，这正是我们想要的——但它也有些无聊。这样的组件对于展示数据至关重要，但如果我们想要创建一个交互式应用程序，它们就毫无用处。如果我们想在点击按钮或填写输入时更新某些内容，我们就需要将其存储在某个地方，并将该信息传递给其他组件以做出反应。想象一下登录表单。当用户输入他们的电子邮件和密码时，我们需要将信息存储在某个地方，以便在填写错误时显示错误消息。当用户点击发送按钮时，我们需要将数据发送到远程服务器。
- en: Components that depend only on their properties and have no internal logic beyond
    that are also called *stateless* components. The alternative is a *stateful* component.
    In this context, *state* refers to the ability to change over time by using internal
    variables. The same component can have one internal state that results in one
    JavaScript XML (JSX) output at one point, and later have a different state that
    results in a different output. Imagine a push button that can toggle between being
    clicked and not clicked. Whether it’s clicked or not is the state of the button,
    and a component that holds state is *stateful*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 仅依赖于其属性且没有超出这些属性内部逻辑的组件也被称为**无状态**组件。与之相对的是**有状态**组件。在这个上下文中，“状态”指的是通过使用内部变量随时间变化的能力。同一个组件可以在某个时刻有一个内部状态，导致一个JavaScript
    XML（JSX）输出，而稍后可以有不同的状态，导致不同的输出。想象一下一个可以切换点击和未点击状态的按钮。它是否被点击是按钮的状态，而持有状态的组件是**有状态**的。
- en: In this chapter, we’ll cover exactly what a stateful application is and what
    a stateful component does in such an application. We’ll then make this more concrete
    by seeing how you set, update, and use component state inside a functional component.
    Despite the very simple API, which consists of a single function, useState, there’s
    a lot of information to cover.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将详细介绍什么是状态化应用程序，以及在这样的应用程序中有状态组件的作用。然后，我们将通过查看如何在函数组件内部设置、更新和使用组件状态来使这个概念更加具体。尽管API非常简单，仅由一个函数组成，即useState，但有很多信息需要覆盖。
- en: At the end of this chapter, we’ll briefly discuss how setting, updating, and
    using state in a class-based component works. This is done in a related but different
    way, so there are some important things to be aware of.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们将简要讨论在类组件中设置、更新和使用状态的工作方式。这是以相关但不同的方式进行处理的，因此有一些重要的事情需要注意。
- en: When discussing class-based components, we’ll also introduce how to convert
    stateful class-based components to stateful functional components. This will come
    in handy if you’re tasked with working on an older codebase that is still using
    class-based components, but you want to upgrade it to a functional codebase so
    you can use the latest and greatest technology available. This knowledge can also
    help if you find examples and guides online that teach you how to do something
    in a class-based component. There are still thousands of older and useful tutorials
    out there, but to use the advice presented in a modern codebase, you have to convert
    some of the concepts.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当讨论基于类的组件时，我们还将介绍如何将具有状态的基于类的组件转换为具有状态的函数式组件。如果你被要求在一个仍然使用基于类的组件的老旧代码库上工作，但你想将其升级到函数式代码库以便使用最新的最佳技术，这将非常有用。如果你在网上找到的示例和指南教你如何在基于类的组件中做某事，这些知识也可能有所帮助。仍然有数千个老旧但有用的教程，但为了在现代代码库中使用所提供的建议，你必须转换一些概念。
- en: Note The source code for the examples in this chapter is available at [https://rq2e.com/ch05](https://rq2e.com/ch05).
    But as you learned in chapter 2, you can instantiate all the examples directly
    from the command line using a single command.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本章中示例的源代码可在[https://rq2e.com/ch05](https://rq2e.com/ch05)找到。但正如你在第二章中学到的，你可以使用单个命令直接从命令行实例化所有示例。
- en: 5.1 Why is React state relevant?
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 为什么React状态很重要？
- en: State is essential for making any kind of interactive application. If your application
    doesn’t have any state, it means that your application is completely static—it
    can’t change at all once opened in the browser. This might be fine for a blog
    post or a recipe, but if you want users to log in, update, click, or in any other
    way interact with your application to influence what is being shown, you need
    your application to be stateful.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 状态对于创建任何类型的交互式应用至关重要。如果你的应用没有任何状态，这意味着你的应用是完全静态的——一旦在浏览器中打开，就无法进行任何更改。这可能适合博客文章或食谱，但如果你想用户登录、更新、点击或以其他方式与应用交互以影响显示的内容，你需要使你的应用具有状态。
- en: React components are *individually stateful*. Keeping state in a component is
    what makes your React application as a whole stateful.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: React组件是*单独具有状态的*。在组件中保持状态使你的React应用整体具有状态。
- en: Note that while almost all React *applications* are stateful, not all *components*
    are stateful. You might have only a few stateful components in your application,
    but those few components can control state for your entire application and will
    update all the stateless components when necessary. While it’s extremely hard
    to generalize about this, a rough estimate is that probably no more than a third
    of your components are stateful in your final application, and as applications
    grow larger and more complex, that ratio will likely decrease. Imagine a fictional
    component tree for a fictional application, as shown in figure 5.1\. Only the
    dark components are *stateful*, whereas the light ones are *stateless*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然几乎所有的React应用都是具有状态的，但并非所有组件都是具有状态的。你可能只在应用中只有少数几个具有状态的组件，但那些组件可以控制整个应用的状态，并在必要时更新所有无状态组件。虽然很难对此进行概括，但粗略估计，在你的最终应用中，可能不超过三分之一的组件是具有状态的，并且随着应用的规模和复杂性的增加，这个比例可能会降低。想象一个虚构应用的虚构组件树，如图5.1所示。只有暗色组件是*具有状态的*，而亮色组件是*无状态的*。
- en: '![05-01](../Images/05-01.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![05-01](../Images/05-01.png)'
- en: Figure 5.1 The dark components are stateful; the light ones are stateless. Note
    how stateful components often reside toward the top of your component tree, whereas
    stateless components are more prevalent toward the leaves.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 暗色组件是具有状态的；亮色组件是无状态的。注意具有状态的组件通常位于组件树的顶部，而无状态组件则更常见于叶节点。
- en: React doesn’t have tools to make your application as a whole stateful. A React
    application is only defined as the sum of its components, so to make your application
    stateful, you have to make some of your components stateful.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: React没有工具可以使整个应用具有状态。React应用仅定义为其组件的总和，因此要使你的应用具有状态，你必须使一些组件具有状态。
- en: 5.1.1 React component state
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.1 React组件状态
- en: 'Component state is what makes a component stateful rather than stateless:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 组件状态是使组件具有状态而不是无状态的：
- en: '*Stateful component*—A stateful component is independent of its context and
    has the ability to update itself based on internal triggers.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*具有状态的组件*——一个具有状态的组件独立于其上下文，并能够根据内部触发器更新自身。'
- en: '*Stateless component*—A stateless component can only change or update when
    its parent component provides it with new properties.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*无状态组件*—无状态组件只能在父组件提供新属性给它时改变或更新。'
- en: React component state is the mechanism that allows you to store values inside
    your component that can change over time. Imagine the difference between a clock
    component that can display some time of day based on a property passed to it,
    versus a clock component that is able to update itself every second and continually
    display the current time. To do the latter, the component needs to have a way
    to store the current time of day (as well as a way to advance that value).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: React组件状态是允许你在组件内部存储随时间变化的值的机制。想象一下，一个时钟组件可以根据传递给它的属性显示一天中的某个时间，而另一个时钟组件能够每秒更新并持续显示当前时间。要实现后者，组件需要有一种方式来存储一天中的当前时间（以及一种方式来推进这个值）。
- en: Figure 5.2 illustrates the difference between these two approaches.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2展示了这两种方法之间的差异。
- en: '![05-02](../Images/05-02.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![05-02](../Images/05-02.png)'
- en: Figure 5.2 The stateless clock needs its parent component to update it every
    second to display the time, whereas the stateful clock can update itself, and
    the parent need not worry about it.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 无状态时钟需要其父组件每秒更新一次以显示时间，而具有状态的时钟可以自行更新，父组件无需担心。
- en: Note that for the stateless clock in figure 5.2 to actually work, the parent
    has to be stateful because we still need to keep the current time in a state *somewhere*.
    Of course, we could make the parent component stateless as well, but then we would
    have to push the state higher up the tree.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，为了使图5.2中的无状态时钟真正工作，父组件必须是状态化的，因为我们仍然需要在某个地方保持当前时间的状态。当然，我们也可以使父组件无状态化，但那样我们就必须将状态推到树的上层。
- en: 5.1.2 Where should I put state?
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.2 我应该把状态放在哪里？
- en: Okay, so we want our application to be stateful. Now where do we put the state?
    Normally, you would try to put the state as close as possible to the components
    that need it.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们希望我们的应用程序具有状态。那么状态应该放在哪里呢？通常，你会尝试将状态尽可能靠近需要它的组件。
- en: Let’s say you have an application that contains a top menu with a (live and
    functional) clock in it, a main section with many different pages that can update
    as you navigate around the page, and a footer with some static links. You need
    the state for the clock to exist somewhere either inside the clock component itself
    or in any component above it in the tree. If you design your application as in
    figure 5.3, you have a choice of components for where to put your clock state.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个包含（实时且功能性的）时钟的顶部菜单的应用程序，一个包含许多不同页面且可以在你浏览页面时更新的主要内容区域，以及一个包含一些静态链接的页脚。你需要将时钟的状态存在某个地方，要么在时钟组件内部，要么在树中位于其上方的任何组件中。如果你像图5.3中那样设计你的应用程序，你可以在多个组件中选择放置你的时钟状态。
- en: '![05-03](../Images/05-03.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![05-03](../Images/05-03.png)'
- en: Figure 5.3 Clock state is only required in the component marked in a darker
    gray. You can put your clock state in any of the components with a dashed border.
    These represent the clock component and its ancestors.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 只有在较深灰色标记的组件中才需要时钟状态。你可以将你的时钟状态放在任何带有虚线边的组件中。这些代表时钟组件及其祖先。
- en: In this example, it makes sense to put the clock state inside the clock component
    itself. No other component has a need to know about the current time, so we just
    have the state localized to the component that needs it.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，将时钟状态放在时钟组件内部是有意义的。没有其他组件需要知道当前时间，所以我们只需将状态局部化到需要它的组件。
- en: On the other hand, let’s say we also need to keep the state of which page is
    currently displayed in the application. This information is required both in the
    Pages component because it actually needs to display the active page, as well
    as in the Menu component because it needs to display the link to the current page
    with a highlighted background.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，假设我们还需要保持当前显示在应用程序中的页面的状态。这个信息在Pages组件中是必需的，因为它实际上需要显示活动页面，同时在Menu组件中也是必需的，因为它需要显示带有高亮背景的当前页面的链接。
- en: Examining the document tree in figure 5.4 shows that we can put the information
    in either Main or App, as those are the only two components that contain both
    of the components that require the state we care about.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 检查图5.4中的文档树显示，我们可以将信息放在Main或App中，因为这两个组件是唯一包含我们关心的所需状态的组件的两个组件。
- en: '![05-04](../Images/05-04.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![05-04](../Images/05-04.png)'
- en: Figure 5.4 Current page state is required in the two components marked in a
    darker gray. You can then put your current page state in the two components marked
    with a dashed border. These are the common ancestors of the two target components.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 当前页面状态在两个用较深灰色标记的组件中是必需的。然后你可以将你的当前页面状态放在两个用虚线边框标记的组件中。这些是两个目标组件的共同祖先。
- en: Whether you actually decide to put your current page state in Main or App is
    up to you, as it’s probably a matter of taste or personal preference. While there
    is a practical argument to keep state as “low” in the document tree as possible
    (i.e., put it in Main), that component might already have a ton of other responsibilities.
    Therefore, it might make sense to put this information in the parent App for organizational
    purposes.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否决定将当前页面状态放在Main或App中取决于你，因为这可能是一个品味或个人偏好的问题。虽然有一个实际的理由将状态保持在文档树尽可能低的位置（即在Main中），但该组件可能已经有很多其他职责。因此，从组织目的来看，将此信息放在父App中可能更有意义。
- en: 5.1.3 What kind of information do you store in component state?
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.3 你在组件状态中存储什么类型的信息？
- en: 'In general, any state used in a web application belongs to one of three categories:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，任何在Web应用程序中使用的状态都属于以下三个类别之一：
- en: Application data
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用数据
- en: UI state
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI状态
- en: Form data
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表单数据
- en: This isn’t a rule or an artifact of React in particular, but it’s a consequence
    of how stateful applications operate.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一条规则，也不是React特有的一个特性，但它是有状态应用程序操作的结果。
- en: Different types of data are stored in different ways. We’ll cover each of these
    to talk about how to store and use the data appropriately. There might be other
    categories of component state, but most of them fall within one of the preceding
    three categories.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 不同类型的数据以不同的方式存储。我们将涵盖每个这些来讨论如何适当地存储和使用数据。可能会有其他组件状态的类别，但它们中的大多数都包含在前面的三个类别中。
- en: Application data
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 应用数据
- en: Application data is the data the user is working on, updating, or reading. If
    you’re building a web application where users can log in, the information about
    the user is application data. If the user can log in and see available classes
    in the gym, book a class, and so on, all of that data is application data as well.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 应用数据是用户正在处理、更新或读取的数据。如果你正在构建一个用户可以登录的Web应用，用户信息就是应用数据。如果用户可以登录并查看健身房的可选课程、预订课程等，所有这些数据都是应用数据。
- en: Application data is most often stored on a global level in your application.
    If you have a component that displays gym classes, then it would be possible to
    store the list of available classes locally in this component, but that would
    also mean that all the information about the available classes would be lost when
    the component unmounts, and they would have to be reloaded from the server when
    the component mounts again later. These two terms, *mounting* and *unmounting*,
    will be discussed in a lot more detail in the next chapter.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 应用数据通常在应用程序的全球级别存储。如果你有一个显示健身房课程的组件，那么在这个组件中存储可用的课程列表是可能的，但这也会意味着当组件卸载时，所有关于可用课程的信息都会丢失，并且它们必须在组件稍后再次挂载时从服务器重新加载。这两个术语，“挂载”和“卸载”，将在下一章中详细讨论。
- en: A better solution is often to create a data store in a component that is persistent
    in your application so that when data is loaded once, it remains through the application.
    We’ll see different ways of doing this in the future involving built-in React
    functionality (using React Context).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通常更好的解决方案是在应用程序中创建一个持久的数据存储组件，这样当数据被加载一次后，它就会在整个应用程序中保持。我们将在未来看到不同的方法，这些方法将涉及内置的React功能（使用React
    Context）。
- en: UI state
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: UI状态
- en: UI state refers to the current state of UI components, such as which tab is
    currently active, whether a panel is collapsed or not, whether the menu is open
    or not, and so on. In general, this is intermittent data that isn’t persisted
    but just helps the web application render the correct elements in the correct
    way.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: UI状态指的是UI组件的当前状态，例如哪个标签页当前是活跃的，面板是否折叠，菜单是否打开等。通常，这些是间歇性数据，不会持久化，但只是帮助Web应用程序以正确的方式渲染正确的元素。
- en: UI state values are most often kept as local as possible. The information about
    whether the menu is open or not is only of relevance inside the menu component,
    so you can easily store this as local state inside this component only.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: UI状态值通常尽可能保持本地化。关于菜单是否打开的信息仅对菜单组件内部相关，因此你可以轻松地将此信息作为本地状态存储在此组件内部。
- en: Form data
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 表单数据
- en: As you’ll see in chapter 9, form data is another very common use case for component
    state. While the user is interacting with a form, entering data, moving from one
    form field to the next, the current state of the form is often kept in local state
    in the component that covers all the form fields.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在第9章中将会看到的，表单数据是组件状态的另一个非常常见的用例。当用户与表单交互、输入数据、从一个表单字段移动到下一个字段时，表单的当前状态通常保存在覆盖所有表单字段的组件的本地状态中。
- en: 5.1.4 What not to store in state
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.4 不要存储在状态中的内容
- en: 'A number of things should never be stored in state, including the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 应该永远不要存储在状态中的事物包括以下内容：
- en: '*Values that don’t change*—This isn’t just constants like magic numbers but
    also configuration values loaded in at application start. If it can’t change,
    don’t make it variable.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*不改变的价值*——这不仅仅是像魔法数字这样的常量，还包括在应用程序启动时加载的配置值。如果它不能改变，就不要让它成为变量。'
- en: '*Copies of other state values*—You should try to keep a single source of truth.
    If you have some data in a global state in your application, it will get messy
    if you also keep it in a local state in a different component (unless you’re locally
    allowing the user to update the data there in a form).'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*其他状态值的副本*——你应该尽量保持单一的真实来源。如果你的应用程序中有一个全局状态包含一些数据，如果你也在不同组件的本地状态中保留它，将会变得混乱（除非你允许用户在表单中本地更新那里的数据）。'
- en: '*Duplicates of the same data*—If you have two versions of the same data in
    state, you might want to consolidate that data. For instance, if you have both
    first name, last name, and full name in state, you’ll have to update at least
    two of these values every time one of the values change. It would be a lot better
    to only keep the source values, first name and last name, in the state and calculate
    the full name as needed based on the state.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*相同数据的副本*——如果你在状态中有相同数据的两个版本，你可能想合并这些数据。例如，如果你在状态中既有名字、姓氏和全名，每次其中一个值改变时，你至少需要更新这些值中的两个。只保留源值，即名字和姓氏在状态中，并根据需要根据状态计算全名会更好。'
- en: Of course, there are many more things you should never put in state (e.g., your
    car keys), but that list is too long to write out. The preceding list shows the
    common pitfalls that you might think about doing, but probably shouldn’t.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有很多其他你不应该放入状态中的事物（例如，你的车钥匙），但这个列表太长了，无法一一列出。前面的列表显示了你可能考虑做的常见陷阱，但你可能不应该这样做。
- en: 5.2 Adding state to a functional component
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 向函数组件添加状态
- en: So far, we’ve discussed why, where, and what to keep in component state, but
    we still don’t know how to actually do it. Keeping state in a functional component
    has a surprisingly simple API that is both a main attraction and sometimes also
    a headache. Because it’s a very low-level API, you might have to add some functionality
    to get a smooth developer experience; however, it allows you to make simple cases
    of stateful components very, *very*, easily.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了为什么、在哪里以及应该将哪些内容保留在组件状态中，但我们仍然不知道如何实际操作。在函数组件中保持状态有一个非常简单的API，它既是主要吸引力，有时也是头疼的问题。因为它是一个非常底层的API，你可能需要添加一些功能来获得流畅的开发者体验；然而，它允许你非常容易地创建状态组件的简单案例。
- en: Let’s jump right in and see the API in action by creating the simplest possible
    stateful component, a click counter. We need a way to initialize our counter,
    display the current value, and increment the counter every time we click a button.
    However, there is one very important last step. We can’t simply update any old
    variable and hope that the component renders correctly. We need to let React know
    that a value has been updated, which means we need to go through the React-specific
    API. Refer to figure 5.5 for a simple flowchart.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接进入，通过创建最简单的可能的状态组件，一个点击计数器，来看看API的实际应用。我们需要一种初始化计数器、显示当前值以及在点击按钮时增加计数器的方法。然而，有一个非常重要的最后一步。我们不能简单地更新任何旧变量并希望组件正确渲染。我们需要让React知道值已经被更新，这意味着我们需要通过React特定的API。参考图5.5中的简单流程图。
- en: '![05-05](../Images/05-05.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![05-05](../Images/05-05.png)'
- en: Figure 5.5 The flow of state in our counter component. We initialize the variable
    and display it, and, on button click, we increment the value and make sure React
    knows to update the component to display the new value.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5 我们的计数器组件中的状态流程。我们初始化变量并显示它，在按钮点击时，我们增加值并确保React知道更新组件以显示新值。
- en: To do this in a functional component, we need to use a function from the React
    package named useState. It takes an initial value and returns the current state
    and an update function. Let’s add in the required relevant bits of the React-specific
    API, as shown in figure 5.6.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要在函数组件中实现这一点，我们需要使用 React 包中的一个名为 useState 的函数。它接受一个初始值，并返回当前状态和一个更新函数。让我们添加如图
    5.6 所示的 React 特定 API 所需的相关部分。
- en: '![05-06](../Images/05-06.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![05-06](../Images/05-06.png)'
- en: Figure 5.6 The flow of state and the lines of code that refer to each action
    in the chart. The dashes and arrows translate the concept to the actual piece
    of code implementing the given goal.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 图表中状态流和引用每个动作的代码行。虚线和箭头将概念转换为实现给定目标的实际代码片段。
- en: Let’s see the code in its entirety in listing 5.1\. Note that we cover all the
    details of the values passed to and returned from the useState hook later, so
    don’t be too confused at this point about the setCounter function. It will be
    explained in due time.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看整个代码，如列表 5.1 所示。请注意，我们将在后面详细介绍传递给 useState 钩子和从 useState 返回的值的所有细节，所以在这个时候关于
    setCounter 函数不必过于困惑。它将在适当的时候解释。
- en: Listing 5.1 A fully functional counter
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.1 一个完全功能的计数器
- en: '[PRE0]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Imports the function useState from the React package
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从 React 包中导入函数 useState
- en: ❷ Initializes a new state with an initial value and gets the current value and
    a setter function back
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用初始值初始化一个新的状态，并返回当前值和设置器函数
- en: ❸ Displays the value through the current state
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 通过当前状态显示值
- en: ❹ Updates the value through the setter function
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 通过设置器函数更新值
- en: 'Repository: rq05-functional-counter'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库：rq05-functional-counter
- en: 'This example can be seen in repository rq05-functional-counter. You can use
    that repository by creating a new app based on the associated template:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在仓库 rq05-functional-counter 中看到。你可以通过创建一个基于相关模板的新应用程序来使用该仓库：
- en: '[PRE1]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以访问这个网站浏览代码，直接在你的浏览器中查看应用程序的运行情况，或者下载源代码的 zip 文件：
- en: '[https://rq2e.com/rq05-functional-counter](https://rq2e.com/rq05-functional-counter)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq05-functional-counter](https://rq2e.com/rq05-functional-counter)'
- en: Let’s go ahead and run this in the browser right away and get clicking, as we
    have in figure 5.7.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们立即在浏览器中运行这个程序，并开始点击，就像我们在图 5.7 中看到的那样。
- en: '![05-07](../Images/05-07.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![05-07](../Images/05-07.png)'
- en: Figure 5.7 The counter in action after only three clicks, but feel free to keep
    going. The sky’s the limit—or actually 9,007,199,254,740,991 is the limit—but
    you probably won’t get that far.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7 在仅点击三次后，计数器开始工作，但请随意继续。天高任鸟飞——或者实际上 9,007,199,254,740,991 是极限——但你可能不会走那么远。
- en: 'There’s a lot to cover here, so let’s go over these steps one by one:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多内容要介绍，所以让我们一步一步地过一遍这些步骤：
- en: Import the function useState from the React package.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 React 包中导入函数 useState。
- en: Call useState in the functional component and supply an initial value.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数组件中调用 useState 并提供一个初始值。
- en: 'Destructure the response from calling useState as two array elements:'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将调用 useState 的响应解构为两个数组元素：
- en: The first element is the current value.
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个元素是当前值。
- en: The second element is a setter function.
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个元素是设置器函数。
- en: Use the current value however you see fit.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据你的需要使用当前值。
- en: When you want to update the state, call the setter with either a function or
    a plain value.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你想更新状态时，用函数或纯值调用设置器。
- en: We’ll cover each of these steps one at a time in the next subsections. We’ll
    also discover how you can use multiple useStates to create more complex components.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中逐一介绍这些步骤。我们还将发现如何使用多个 useState 创建更复杂的组件。
- en: Oh, and did we mention, useState is a hook? This is the first and simplest of
    the new React hooks that came in React 16.8 and changed everything. Hooks are
    special functions that you can’t treat like any other function. We’ll cover some
    of that in this section, but will go even deeper into the topic of hooks in chapter
    6.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，我们提到过，useState 是一个钩子吗？这是 React 16.8 中引入的新 React 钩子中的第一个也是最简单的一个，它改变了所有的一切。钩子是特殊的函数，你不能像对待其他函数一样对待它们。我们将在本节中介绍一些内容，但在第
    6 章中我们将更深入地探讨钩子的话题。
- en: 5.2.1 Importing and using a hook
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.1 导入和使用钩子
- en: useState is a hook. *Hook* is an umbrella term for a new kind of special function
    that exists in React 16.8 and forward. React comes with a number of built-in hooks,
    and they are hooks because React says so. They don’t do the same things nor provide
    overlapping functionality, but are all “hooks” into the React core functionality
    and require special attention to work correctly.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: useState是一个钩子。*钩子*是一个总称，指的是React 16.8及以后版本中存在的一种新型特殊函数。React自带一些内置钩子，它们之所以被称为钩子，是因为React这样定义的。它们不做相同的事情，也不提供重叠的功能，但都是“钩入”React核心功能的，并且需要特别注意才能正确工作。
- en: The fact that useState is a hook is actually very easy to see because the function
    starts with the word use*. In modern React, it’s now a convention that any function
    starting with the word use* is a hook, and non-hooks should never start with that
    word.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 由于useState是一个钩子，这一点实际上很容易看出，因为函数以use*这个词开头。在现代React中，现在有一个约定，即任何以use*开头的函数都是一个钩子，非钩子函数永远不应该以这个词开头。
- en: So, what’s so special about hooks? Hooks are named like that because they are
    hooks *from* your component *to* the “insides” of the React machinery. You can
    do some magic things that aren’t possible without having this extra access. A
    functional component is just a function, so it can’t really do much beyond controlling
    a single render if we don’t have this deeper access.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，钩子有什么特别之处呢？钩子之所以被命名为钩子，是因为它们是从你的组件“到”React“内部机制”的钩子。你可以做一些没有这种额外访问权限不可能做到的神奇事情。一个函数组件只是一个函数，所以如果没有这种更深入的访问权限，它实际上不能做很多超出控制单个渲染的事情。
- en: React comes with 15 hooks (as of React 18), which are low-level units that can
    be combined to create all sorts of advanced components. New built-in hooks can
    be added to the React API over time, so by the time you’re reading this, there
    might be more than 15.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: React自带15个钩子（截至React 18），它们是低级单元，可以组合成各种高级组件。随着时间的推移，可以添加新的内置钩子到React API中，所以当你阅读这篇文章时，可能会有超过15个。
- en: You can create your own custom hooks on top of the React hooks. If you do, you
    should name your custom hooks use* as well. For example, we could have created
    a useCounter hook for the preceding component. We’ll cover custom hooks in chapter
    10.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在React钩子之上创建自己的自定义钩子。如果你这样做，你应该将你的自定义钩子命名为use*。例如，我们可以为前面的组件创建一个useCounter钩子。我们将在第10章中介绍自定义钩子。
- en: Rules of hooks
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 钩子规则
- en: When you use a hook in a component, you must always use that hook. In addition,
    you must use the exact same hooks in the exact same order every time you render
    the component. This might seem weird, but it’s required by React to make your
    function work correctly.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在组件中使用钩子时，你必须始终使用该钩子。此外，每次渲染组件时，你必须使用完全相同的钩子，并且顺序完全一致。这听起来可能有些奇怪，但这是React为了使你的函数正确工作所必需的。
- en: By “always use,” we mean that the same hook must always be called every time
    the component renders, that is, every time the component definition function runs.
    This means that you can’t conditionally run a hook, for example, by putting it
    inside an if block or include it after an optional return statement.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: “始终使用”的意思是，相同的钩子必须在每次组件渲染时被调用，也就是说，每次组件定义函数运行时。这意味着你不能有条件地运行一个钩子，例如，通过将其放在if块中或包含在可选的return语句之后。
- en: Imagine a variant of the counter component where we pass a property to the component
    to indicate whether it should be visible at all. You might think that we would
    be able to do something like figure 5.8.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下计数器组件的一个变体，我们向组件传递一个属性来指示它是否应该完全可见。你可能会认为我们可以做类似于图5.8中的事情。
- en: '![05-08](../Images/05-08.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![05-08](../Images/05-08.png)'
- en: Figure 5.8 Can we check the property first, and, if false, simply ignore initializing
    the state altogether?
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8 我们能否首先检查属性，如果为false，就完全忽略初始化状态？
- en: 'We can implement this as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样实现：
- en: '[PRE2]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ If isVisible is false, we just return null from the very start.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果isVisible为false，我们从一开始就返回null。
- en: ❷ Only if isVisible isn’t false do we actually initialize the state using the
    useState hook. This is wrong!
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 只有当isVisible不为false时，我们才实际使用useState钩子初始化状态。这是错误的！
- en: 'Well, that’s not allowed! What’s wrong here? The hook function, useState, isn’t
    called every time, only sometimes. If the isVisible property is set to true in
    one render, the hook *will* be called, but if it’s set to false in the next render,
    the hook *won’t* be called. And, that’s not just bad, it will completely break
    your React application. React will throw an error message similar to this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这是不允许的！这里有什么问题？钩子函数useState并不是每次都调用，只是有时调用。如果一个渲染中isVisible属性设置为true，钩子*将会*被调用，但如果在下一个渲染中设置为false，钩子*不会*被调用。而且，这不仅仅是不好，它将完全破坏你的React应用程序。React将抛出一个类似于以下错误的消息：
- en: '[PRE3]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: For this reason, you’ll need to sometimes make what looks like suboptimal code.
    You need to put all your hooks before any attempt to return anything in the component,
    as shown in figure 5.9.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，有时你需要编写看似次优的代码。你需要将所有的钩子放在组件中返回任何内容之前，如图5.9所示。
- en: '![05-09](../Images/05-09.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![05-09](../Images/05-09.png)'
- en: Figure 5.9 We have to initialize the state before optionally aborting rendering
    even if we don’t need the state at all.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9 我们必须在可选地中止渲染之前初始化状态，即使我们根本不需要状态。
- en: 'Let’s implement this as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们这样实现：
- en: '[PRE4]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Initializes two variables that might never be needed
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 初始化两个可能永远不会用到的变量
- en: ❷ Only returns something after all our hooks have been executed
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 只在我们所有的钩子执行完毕后返回某些内容
- en: This also means that you can never conditionally run a hook (e.g., inside an
    if block), you can never run a hook in a loop (because that would mean you might
    have a varying number of hook calls), and you can never call a hook inside a callback
    or event handler (it has to run directly in the component body when called). You’ll
    see some examples of some of these restrictions in the next sections and how you
    can work around those restrictions to still achieve the desired goal.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着你永远不能有条件地运行一个钩子（例如，在if块内部），你永远不能在循环中运行一个钩子（因为这意味着你可能有不同数量的钩子调用），而且你永远不能在回调或事件处理程序中调用一个钩子（它必须在组件体中直接调用）。你将在下一节中看到一些这些限制的示例以及如何绕过这些限制以实现预期的目标。
- en: We’ll also cover much more about hooks in the next chapter, where we go deeper
    under the hood of hooks and how they must be used.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们还将详细介绍更多关于钩子的内容，我们将深入探讨钩子的工作原理以及它们应该如何使用。
- en: 5.2.2 Initializing the state
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.2 初始化状态
- en: When you call useState, you must pass an initial value; if not, the initial
    value is assumed to be undefined. Only the value that you pass to useState the
    first time around for each component instance matters. When your hook re-renders
    for whatever reason, the initial value is ignored.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用useState时，你必须传递一个初始值；如果不传递，则假定初始值为undefined。只有你为每个组件实例在第一次调用useState时传递的值才重要。当你的钩子因任何原因重新渲染时，初始值将被忽略。
- en: The most obvious use case for this is setting up a baseline in your component.
    When it mounts the first time, what should the state be? If it should be some
    dynamic value passed in as a property, use that property. If it should be any
    static value, write that. In 99% of cases, you’ll set your initial value to either
    a static value (including null very often) or a property. We’ll cover some examples
    of initialization in the rest of this section.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这种用法最明显的用例是在组件中设置基线。当它第一次挂载时，状态应该是什么？如果应该是作为属性传递的某个动态值，请使用该属性。如果应该是任何静态值，请写入该值。在99%的情况下，你将设置你的初始值为静态值（包括null非常常见）或属性。我们将在本节的其余部分介绍一些初始化的示例。
- en: Initial value
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 初始值
- en: Every state has an initial value. Our counter had an initial value of 0, but
    it didn’t need to be 0, of course. We could have initialized it to 10, 100, or
    even some dynamic value.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 每个状态都有一个初始值。我们的计数器初始值为0，但当然不必是0。我们可以将其初始化为10、100，甚至是某个动态值。
- en: Let’s say we want to create a variant of the counter, where we can initialize
    the value to some property that we pass in. We’ll then create an application with
    three different instances of this counter initialized with different starting
    values. The resulting component tree will look like figure 5.10.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要创建一个计数器的变体，其中我们可以将值初始化为我们传递的某个属性。然后我们将创建一个应用程序，其中包含三个不同实例的此计数器，并使用不同的起始值进行初始化。结果组件树将类似于图5.10。
- en: '![05-10](../Images/05-10.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![05-10](../Images/05-10.png)'
- en: Figure 5.10 We now want to have three counters initialized to different starting
    values because it looks cool.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.10 我们现在想要有三个计数器，它们初始化为不同的起始值，因为这样看起来很酷。
- en: We can implement this as shown in the following listing. The result in a browser
    will look like figure 5.11.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像以下列表所示实现这一点。在浏览器中的结果将看起来像图5.11。
- en: '![05-11](../Images/05-11.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![05-11](../Images/05-11.png)'
- en: Figure 5.11 Our three counters before we start clicking any of them
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.11 在我们点击任何计数器之前，我们的三个计数器
- en: Listing 5.2 Triple counters
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.2 三重计数器
- en: '[PRE5]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ The property passed to this component is named start.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 传递给此组件的属性名为start。
- en: ❷ We use that property to initialize our state.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们使用这个属性来初始化我们的状态。
- en: ❸ Three instances of the counter with three different start values
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 具有三个不同起始值的三个计数器实例
- en: 'Repository: rq05-triple-counter'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库：rq05-triple-counter
- en: 'This example can be seen in repository rq05-triple-counter. You can use that
    repository by creating a new app based on the associated template:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在rq05-triple-counter存储库中看到。你可以通过创建一个基于相关模板的新应用程序来使用该存储库：
- en: '[PRE6]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以访问这个网站来浏览代码，直接在你的浏览器中查看应用程序的运行情况，或者下载源代码的zip文件：
- en: '[https://rq2e.com/rq05-triple-counter](https://rq2e.com/rq05-triple-counter)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq05-triple-counter](https://rq2e.com/rq05-triple-counter)'
- en: 'The following are other common static initial values besides numbers:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 除了数字之外，以下是一些常见的静态初始值：
- en: true *or* false *for Booleans*—If your menu is hidden until a button is clicked,
    the isMenuVisible state is initialized to false.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于布尔值来说，是**true**还是**false**——如果你的菜单在点击按钮之前是隐藏的，那么`isMenuVisible`状态将被初始化为`false`。
- en: '*Empty string,* ""—If you have an input for a login email address, you’ll initialize
    your state to the empty value so the input is empty until the user starts typing.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**空字符串**，""——如果你有一个登录电子邮件地址的输入，你将初始化你的状态为空值，这样输入就是空的，直到用户开始输入。'
- en: null—If you have a complex value that hasn’t been set to anything yet, null
    is the perfect placeholder value for indicating that no value exists yet.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`null`——如果你有一个尚未设置任何值的复杂值，`null`是表示尚未存在值的完美占位符。'
- en: The most common dynamic initial value is to use a property. We did that with
    the previous counter. Similarly, you would use a property if you had a component
    to change your name. You would pass in the current name as a property and initialize
    your state based on that.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的动态初始值是使用一个属性。我们之前在计数器中就是这样做的。同样，如果你有一个组件需要更改你的名字，你也会使用一个属性。你会传入当前的名字作为属性，并根据这个属性初始化你的状态。
- en: You could also initialize your state to a value from a cookie or similar local
    storage. For a login form, you could initialize the email address state with the
    last known email address used in this same form as stored in a cookie.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将你的状态初始化为cookie或类似本地存储中的值。对于一个登录表单，你可以使用存储在cookie中的最后已知电子邮件地址来初始化电子邮件地址状态。
- en: Only the first initial value matters
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 只有第一个初始值是重要的
- en: Let’s make a new variant of the counter with a variable start value. This time,
    we want to add a new button outside the counter that will change the start value
    of the counter. So, instead of initializing the value to 0 every time, we have
    a button that, if clicked, will lower the start value of the counter by 10, as
    illustrated in a flowchart in figure 5.12\. We’re actually creating a stateful
    component on top of our stateful component.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个具有可变起始值的计数器的新变体。这次，我们想在计数器外部添加一个新按钮，该按钮将改变计数器的起始值。因此，我们不是每次都初始化值为0，而是有一个按钮，如果点击，将计数器的起始值减少10，如图5.12中的流程图所示。我们实际上是在我们的状态组件之上创建了一个有状态的组件。
- en: '![05-12](../Images/05-12.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![05-12](../Images/05-12.png)'
- en: Figure 5.12 We now have state in both the app and the counter, and we want to
    use the app state to initialize the counter state.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.12 现在我们在应用程序和计数器中都有状态，我们想使用应用程序状态来初始化计数器状态。
- en: Rather than blindly implementing this, let’s think through some scenarios. What
    happens in this scenario?
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是盲目地实现这个功能，让我们思考一些场景。在这个场景中会发生什么？
- en: At first, the counter will be initialized with a start value of 0.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，计数器将以初始值0开始。
- en: We then click the button to lower the start value, so the start value should
    now be -10.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们点击按钮来降低起始值，所以起始值现在应该是-10。
- en: Does the counter then update to -10?
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 那么计数器是否会更新到-10？
- en: 'Let’s expand with another scenario:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再通过另一个场景来扩展：
- en: At first, the counter will be initialized with a start value of 0.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，计数器将以初始值0开始。
- en: We then click Increment in the counter to increase the counter value to 1.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们点击计数器中的“增加”按钮，将计数器的值增加到1。
- en: We then click the button to lower the start value (which was 0), so the start
    value should now be -10.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们点击按钮来降低起始值（原本是0），所以起始值现在应该是-10。
- en: Does the counter then update to -10? Or does it update to -9?
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 那么计数器会更新到-10吗？还是会更新到-9？
- en: In fact, both of these scenarios are meaningless because, as we’ve briefly mentioned,
    only the first value passed to useState is used as the value for the state. If
    the initial value changes in a subsequent render, the state never updates. This
    is both good and bad. It’s good because otherwise our counter would always be
    the same value, as we keep passing the same value in every render. The bad thing
    is that if we actually want the value to change based on some passed parameter,
    we can’t do that (not in this way, at least).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这两种场景都是没有意义的，因为我们之前简要提到过，只有传递给useState的第一个值被用作状态的值。如果初始值在后续渲染中发生变化，状态永远不会更新。这既有好的一面也有不好的一面。好的一面是，否则我们的计数器将始终是相同的值，因为我们每次渲染都传递相同的值。不好的一面是，如果我们实际上想根据某个传递的参数来改变值，我们无法做到（至少不是用这种方式）。
- en: In this instance, it wasn’t actually clear what we wanted to happen if we started
    lowering the start value after we had begun counting. It’s important to figure
    out exactly what we want to happen before we try to implement it in code.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果我们开始计数后降低起始值，实际上并不清楚我们想要发生什么。在我们尝试在代码中实现它之前，弄清楚我们确切想要发生什么是很重要的。
- en: It’s possible to have a state value update based on a property, but that requires
    other hooks—in particular, the useEffect hook—that we’ll introduce in the next
    chapter.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能让状态值根据一个属性更新，但这需要其他钩子——特别是我们将在下一章中介绍的useEffect钩子。
- en: Initializer function
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化函数
- en: There are times when you want to set the initial value to the result of some
    calculation. Let’s say you have a password input that you want to initialize to
    a good, strong password, but once the user starts typing, you just use whatever
    the user types. We have an expensive function somewhere else in our codebase,
    generatePassword, that we’ll use to create this initial password. Let’s go ahead
    and diagram this as earlier, in figure 5.13.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能想将初始值设置为某个计算的结果。比如说，你有一个密码输入框，你想将其初始化为一个好的、强大的密码，但一旦用户开始输入，你就使用用户输入的内容。我们在代码库的某个地方有一个昂贵的函数generatePassword，我们将使用它来创建这个初始密码。让我们像之前一样，在图5.13中绘制这个流程。
- en: '![05-13](../Images/05-13.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![05-13](../Images/05-13.png)'
- en: Figure 5.13 The state flow when we use a function to generate the initial value
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.13 使用函数生成初始值时的状态流程
- en: 'If we implement this using the initial value, we get something like this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用初始值来实现这个功能，我们得到的结果可能如下所示：
- en: '[PRE7]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: However, this generatePassword() function will actually be called on every render
    (because it’s executed on every render), while the return value will be ignored
    on every render except the first, as just explained. It might be a complex function
    that runs a lot of expensive algorithms, so we should avoid running it if we don’t
    need the returned value.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个generatePassword()函数实际上会在每次渲染时被调用（因为它在每次渲染时都会执行），而除了第一次渲染之外，每次渲染都会忽略返回值，正如之前解释的那样。它可能是一个运行很多昂贵算法的复杂函数，所以如果我们不需要返回值，我们应该避免运行它。
- en: For this purpose, the initial value can instead be a function that returns the
    initial value. In such a setup, the initial value function will only be invoked
    the first time around and will be ignored for future renders, as shown in figure
    5.14.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，初始值可以是一个返回初始值的函数。在这种设置中，初始值函数只会在第一次调用，对于未来的渲染将被忽略，如图5.14所示。
- en: '![05-14](../Images/05-14.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![05-14](../Images/05-14.png)'
- en: Figure 5.14 We don’t actually call generatePassword in this instance. We rather
    instruct the hook to call the function itself only when it needs to (which is
    only the first time around).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.14 在这个例子中，我们实际上并没有调用generatePassword。我们而是指示钩子仅在需要时调用该函数（即第一次）。
- en: We can do that generally as
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常可以这样操作
- en: '[PRE8]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'or, in this instance, much simpler:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，在这个例子中，更简单：
- en: '[PRE9]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Because generatePassword is already a function, we can pass it as is. However,
    if the function took an argument, perhaps the length of the generated password,
    we would have to use the former form:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 因为generatePassword已经是一个函数，所以我们可以直接传递它。然而，如果这个函数需要一个参数，比如生成密码的长度，我们就必须使用前面的形式：
- en: '[PRE10]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Initializing to a function
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 通过函数初始化
- en: What if your state is a function? If we pass a function to the initial value,
    it will be called, so how can we store a function as the initial value? We make
    another function that returns the first one. It sounds a bit weird, but it actually
    can make sense.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的状态是一个函数怎么办？如果我们传递一个函数给初始值，它将被调用，那么我们如何将函数作为初始值存储？我们创建另一个函数，它返回第一个函数。这听起来有点奇怪，但实际上是有道理的。
- en: 'Let’s say that we have a calculator component with which we can do some mathematical
    operation (e.g., addition, subtraction, and multiplication) on two values entered
    in two input fields. This calculation is a function that takes two values and
    returns a single response. We can implement this as an enum-like type as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个计算器组件，我们可以对两个输入字段中输入的两个值执行一些数学运算（例如，加法、减法和乘法）。这个计算是一个函数，它接受两个值并返回一个单一响应。我们可以将其实现为一个类似于枚举的类型，如下所示：
- en: '[PRE11]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This looks pretty good, but it doesn’t work. What we’ve done is shown in figure
    5.15.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来相当不错，但它不起作用。我们所做的是在图 5.15 中展示的。
- en: '![05-15](../Images/05-15.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![05-15](../Images/05-15.png)'
- en: Figure 5.15 Because we pass in a function as the initial value, React treats
    it as an initializer function and invokes it—just like before.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.15 因为我们将函数作为初始值传递，React 会将其视为初始化函数并调用它——就像之前一样。
- en: If you type the preceding code snippet into a component, the operator will initialize
    to the value NaN. That’s, of course, because useState is invoked with a function
    as initializer, so it calls the function, but that function doesn’t know what
    to do without arguments, so it just returns NaN. What we need is a function that
    returns the operator, as shown in figure 5.16.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将前面的代码片段输入到一个组件中，操作符将初始化为值 NaN。这当然是因为 useState 以一个函数作为初始化器被调用，所以它调用了该函数，但该函数不知道如何在没有参数的情况下操作，所以它只返回
    NaN。我们需要的是一个返回操作符的函数，如图 5.16 所示。
- en: '![05-16](../Images/05-16.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![05-16](../Images/05-16.png)'
- en: Figure 5.16 This time, we’ll still pass in a function as the initializer value,
    but that function will then return our desired value (which happens to be a function).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.16 这次，我们仍然会将一个函数作为初始化值传递，但该函数将返回我们所需的价值（碰巧也是一个函数）。
- en: We can implement that as
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其实现为
- en: '[PRE12]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This works and is a perfectly fine construction. You’ll see this construction
    repeated when we talk about the setter function in a bit.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这可行，并且是一个完美的构造。当我们稍后讨论设置函数时，你会看到这种构造被重复使用。
- en: 5.2.3 Destructuring the state value and setter
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.3 解构状态值和设置器
- en: 'When we need a stateful component, we use the useState hook. This hook returns
    a value, which we’ve destructured into a state value and a setter function like
    this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要一个有状态的组件时，我们使用 useState 钩子。这个钩子返回一个值，我们将它解构为一个状态值和一个设置函数，如下所示：
- en: '[PRE13]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is as close to mandatory as it gets. There are other ways to do it, but
    everyone uses the useState hook in this manner. If you do the same thing, your
    code will make sense to other developers. This is simply a necessary convention
    when using this hook. Other hooks work in similar ways, and you just have to get
    used to this notation.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎就是强制性的了。有其他方法可以做到这一点，但每个人都会以这种方式使用 useState 钩子。如果你这样做，你的代码对其他开发者来说也是有意义的。这只是在使用此钩子时的一种必要约定。其他钩子以类似的方式工作，你只需要习惯这种符号。
- en: The useState return value
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: useState 返回值
- en: 'The useState hook return value is a bit cryptic. The hook returns an array
    with two elements. The first element is the current value of the state, and the
    second element is the setter function. There are many ways we could “accept” this
    return value and change it to our use. We could store the returned array in a
    variable and address the two items as value[0] and value[1], respectively, or
    we could copy those elements to two other variables. But the recommended and most
    common way is to destructure the array directly in the assignment of the return
    value to a variable and name the two returned values as we see fit:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: useState 钩子返回的值有点难以理解。钩子返回一个包含两个元素的数组。第一个元素是状态的当前值，第二个元素是设置函数。我们可以以许多方式“接受”这个返回值并将其转换为我们的使用。我们可以将返回的数组存储在一个变量中，并将两个项目分别称为
    value[0] 和 value[1]，或者我们可以将那些元素复制到两个其他变量中。但推荐且最常见的方式是在将返回值赋值给变量时直接解构数组，并按我们的意愿命名两个返回值：
- en: '[PRE14]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: At this point, for most React developers, this is just instinctive. Because
    this is how you use the useState hook, after a while, you don’t really think about
    it. The only thing to think about here is the naming of the two destructured variables.
    The common approach is to name the state value after what we store in it, and
    name the setter function the same, but with a set* prefix. This is what we did
    earlier with counter and setCounter, respectively.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，对于大多数React开发者来说，这只是一个本能。因为这就是你使用useState钩子的方式，过了一段时间，你实际上并没有真正思考过。这里唯一需要思考的是两个解构变量的命名。常见的方法是将状态值命名为我们存储的内容，并将设置函数命名为相同，但带有set*前缀。这就是我们之前用counter和setCounter分别做的。
- en: Teams will often come up with their own naming standards or apply those from
    others, but what we’ve suggested here is a safe default. The only potential deviation
    is when it comes to Boolean state values. You might have a state value called
    isCollapsed. The setter function would then be called setIsCollapsed, which just
    sounds like terrible English, so some might just call it setCollapsed and skip
    the prefix of is* or has* that Boolean variables often have.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 团队通常会制定自己的命名标准或采用他人的标准，但我们在这里建议的是一个安全的默认值。唯一的潜在偏差是当涉及到布尔状态值时。你可能有一个名为isCollapsed的状态值。那么，设置函数将被命名为setIsCollapsed，这听起来就像糟糕的英语，所以有些人可能只是将其命名为setCollapsed，并跳过布尔变量通常具有的is*或has*前缀。
- en: Why useState returns an array
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么useState返回一个数组
- en: Okay, you understand that useState returns an array and that’s just how it is.
    But, why does useState return an array with two unrelated values? It’s clearly
    not a list of something!
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，你理解useState返回一个数组，而且就是这样。但是，为什么useState返回一个包含两个无关值的数组？这显然不是一个列表！
- en: Imagine that you’re a React core developer creating the useState hook. The useState
    function needs to return two values. One value is the current state, which can
    be any type. The second value is the setter function, and it’s a function that
    can take any value or even an update function.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你是一个创建useState钩子的React核心开发者。useState函数需要返回两个值。一个值是当前状态，可以是任何类型。第二个值是设置函数，它是一个可以接受任何值或甚至更新函数的函数。
- en: JavaScript doesn’t have tuples or structures, where you can structurally combine
    different types in a “nice” way. You might think we could return an object with
    the two properties and just have to agree on their naming, for example, obj.value
    and obj.set. These would also destructure well as simply
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript没有元组或结构，你可以以“优雅”的方式结构性地组合不同类型。你可能认为我们可以返回一个具有两个属性的对象，并且只需要就它们的命名达成一致，例如，obj.value和obj.set。这些也可以简单地解构为
- en: '[PRE15]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'But as you’re inclined to have multiple states in the same component, you would
    have to rename them often. Even if you only have a single state, you might still
    want to have a more descriptive name, and destructuring the named properties in
    an object to different local variables is more verbose than doing it for an array:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，由于你倾向于在同一个组件中拥有多个状态，你将不得不经常重命名它们。即使你只有一个状态，你也可能想要一个更具描述性的名称，并且将对象中的命名属性解构到不同的局部变量中比将其解构到数组中更冗长：
- en: '[PRE16]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: That’s a lot of extra typing and unnecessary overhead. So, rather than returning
    a more well-defined object with the two named properties, the React developers
    chose the array for ease of use.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要很多额外的输入和不必要的开销。因此，与其返回一个具有两个命名属性的定义更明确的对象，React开发者选择了数组以方便使用。
- en: Because React developers know this useState function so well, and it’s used
    so many times in their daily workflow, the unusual syntax just becomes muscle
    memory, and they don’t really think about it. But we agree that it’s actually
    a bit weird.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 因为React开发者对useState函数非常熟悉，并且他们在日常工作中使用了无数次，所以这种不寻常的语法已经变成了肌肉记忆，他们实际上并没有真正思考过。但我们同意，这实际上有点奇怪。
- en: 5.2.4 Using the state value
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.4 使用状态值
- en: Imagine our counter from earlier. What would happen if we changed the Increment
    button from incrementing the value to setting the value to the string "hi there"?
    So, it’s not a number anymore, but a string. This would look like figure 5.17.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下我们之前的计数器。如果我们把增加按钮从增加值改为将值设置为字符串"hi there"，会发生什么？所以，它不再是数字，而是一个字符串。这看起来就像图5.17。
- en: '![05-17](../Images/05-17.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![05-17](../Images/05-17.png)'
- en: Figure 5.17 We set the counter value to a string when we click the button.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.17 当我们点击按钮时，我们将计数器的值设置为字符串。
- en: 'Let’s try to implement that:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试实现它：
- en: '[PRE17]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ Initializes the counter to a number
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将计数器初始化为数字
- en: ❷ Displays whatever the counter currently is
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 显示计数器当前是什么
- en: ❸ On click, changes the value of the counter to a string
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 点击时，将计数器的值更改为字符串
- en: This actually works. If we click the button, the result will look like figure
    5.18.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上有效。如果我们点击按钮，结果将看起来像图5.18。
- en: '![05-18](../Images/05-18.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![05-18](../Images/05-18.png)'
- en: Figure 5.18 Our “counter” value is now a string, and it’s still displayed because
    we don’t actually check if it’s a number.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.18我们的“计数器”值现在是一个字符串，它仍然被显示，因为我们实际上并没有检查它是否是一个数字。
- en: It’s pretty nonsensical to change the type of a state, just like it’s nonsensical
    to change the type of any other variable.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 改变状态类型是非常没有意义的，就像改变任何其他变量的类型一样没有意义。
- en: The state value returned by the useState hook is whatever you set it to. You
    can change the type, complexity, and so on. You have full control over the value.
    The value will start at whatever you pass in as the initial value, and from then
    on, it will be whatever you pass to the setter function.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: useState钩子返回的状态值是你设置的值。你可以改变类型、复杂性等。你对值有完全的控制权。值将从你作为初始值传递的值开始，然后它将是传递给setter函数的值。
- en: Most of the time, your state type should not change, however. Just as any other
    variable in your codebase, keeping the type consistent is a huge help, even though
    JavaScript doesn’t put any such constraints on you. For instance, you can initialize
    a value to null and later set it to a number, where null would represent that
    you don’t know what the number would be yet, so initializing to 0 would be misleading.
    This could be the case with an age input, for example. Just because you haven’t
    typed your age yet, doesn’t mean that it’s 0\. This would be a change of type,
    where the type is initially null but later changes to a number.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，大多数时候，你的状态类型不应该改变。就像你的代码库中的任何其他变量一样，保持类型的一致性是一个巨大的帮助，即使JavaScript没有对你施加任何这样的约束。例如，你可以初始化一个值为null，然后将其设置为数字，其中null表示你还不确定这个数字是什么，所以初始化为0将是误导性的。例如，对于一个年龄输入来说，仅仅因为你还没有输入你的年龄，并不意味着它是0。这将是类型的变化，其中类型最初是null，但后来变为数字。
- en: 'You can, of course, have object literals in the state, which might make sense
    for related values that you either always update together or use together. You
    might, for instance, have a loader component that displays the loading progress
    of a file in both a percentage and in text with loaded bytes out of total bytes:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以在状态中拥有对象字面量，这对于你总是一起更新或一起使用的相关值来说可能是有意义的。例如，你可能有一个显示文件加载进度的加载组件，它以百分比和以已加载的字节数（相对于总字节数）的文本形式显示：
- en: '[PRE18]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is a partial example only, as we don’t actually load anything here, so
    we would need more logic to actually fetch something and check the values. But
    it is an example of related values stored in a single state value.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个部分示例，因为我们在这里实际上没有加载任何内容，所以我们需要更多的逻辑来实际获取某些内容并检查其值。但这是一个示例，展示了存储在单个状态值中的相关值。
- en: In later sections, we’ll discuss how you can use multiple states rather than
    cram all your states into a single value. You should only put multiple values
    into a single state when the values are tightly related, as in the preceding Loader
    example.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在后面的章节中，我们将讨论如何使用多个状态而不是将所有状态都压缩到一个值中。你应该只在值紧密相关时将多个值放入单个状态中，就像前面的Loader示例中那样。
- en: 5.2.5 Setting the state
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.5 设置状态
- en: Setting the state is fairly straightforward in that it works exactly like setting
    the initial value, with all the same quirks and workarounds. We can update the
    state either by setting it to a static value or by using an update function that
    returns the new value to be set.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 设置状态相当直接，因为它的工作方式与设置初始值完全一样，具有所有相同的怪癖和解决方案。我们可以通过将其设置为静态值或使用返回要设置的新值的更新函数来更新状态。
- en: Setting to a static value
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 设置为静态值
- en: Let’s create a simple accordion component where you can expand and collapse
    the contents. The headline contains two buttons with a plus and minus, respectively.
    Clicking the Plus button will expand the accordion and show the contents, and
    clicking the Minus button will collapse the accordion and hide the contents. This
    is illustrated as a diagram in figure 5.19 and implemented in listing 5.3.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的手风琴组件，你可以展开和折叠内容。标题包含两个按钮，分别带有加号和减号。点击加号按钮将展开手风琴并显示内容，点击减号按钮将折叠手风琴并隐藏内容。这如图5.19中的图解所示，并在列表5.3中实现。
- en: '![05-19](../Images/05-19.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![05-19](../Images/05-19.png)'
- en: Figure 5.19 The flowchart for an accordion. The Boolean is set to true or false
    depending on which button is clicked.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.19 折叠面板的流程图。布尔值根据哪个按钮被点击设置为true或false。
- en: Listing 5.3 A simple accordion
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.3 简单折叠面板
- en: '[PRE19]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Initializes the state to false
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 初始化状态为false
- en: ❷ Invokes the setter with either true or false when a button is clicked
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 当按钮被点击时，使用true或false调用设置器
- en: ❸ Displays the secret accordion contents if the Boolean is true
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果布尔值为true，则显示隐藏的折叠面板内容
- en: 'Repository: rq05-accordion'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库：rq05-accordion
- en: 'This example can be seen in repository rq05-accordion. You can use that repository
    by creating a new app based on the associated template:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在rq05-accordion仓库中看到。您可以通过创建一个基于相关模板的新应用程序来使用该仓库：
- en: '[PRE20]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以访问这个网站浏览代码，直接在浏览器中查看应用程序的实际效果，或者下载源代码的zip文件：
- en: '[https://rq2e.com/rq05-accordion](https://rq2e.com/rq05-accordion)'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq05-accordion](https://rq2e.com/rq05-accordion)'
- en: The result in a browser will look like figure 5.20\. This component is an example
    of using the setter with a static value. The minus button always sets the state
    value to false no matter how many times you click it. Because we set it to a fixed
    value, we don’t need to look at the current value.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器中的结果将类似于图5.20。这个组件是使用设置器与静态值的一个例子。减号按钮无论您点击多少次，总是将状态值设置为false。因为我们将其设置为固定值，所以我们不需要查看当前值。
- en: '![05-20](../Images/05-20.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![05-20](../Images/05-20.png)'
- en: Figure 5.20 After clicking the Plus button, the secret accordion contents are
    revealed.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.20 点击加号按钮后，隐藏的折叠面板内容被揭示。
- en: Setting using an update function
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 使用更新函数进行设置
- en: You can set the value as either a direct value as we’ve just done or with an
    update function that returns the new value. If you use an update function, it
    will be passed the current state as an argument.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将值设置为直接值，就像我们刚才所做的那样，或者使用一个返回新值的更新函数。如果您使用更新函数，它将作为参数传递当前状态。
- en: 'We’ve already seen an example of using an update function:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了使用更新函数的一个例子：
- en: '[PRE21]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This updates the value in the state by using a simple increment function that
    takes an argument and returns the argument + 1.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用一个简单的增量函数来更新状态值，该函数接受一个参数并返回参数+1。
- en: Setting to a function
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 设置为函数
- en: To set the state value to a function, we have to use the same workaround as
    with the initial value. We need a function that returns our operator function.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 要将状态值设置为函数，我们必须使用与初始值相同的解决方案。我们需要一个返回我们的操作函数的函数。
- en: So, if we expand our calculator example from earlier with buttons to change
    the operator, we would be implementing a full application. Let’s first look at
    the diagram of the state flow in figure 5.21 and then see its implementation in
    listing 5.4.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们扩展之前带有更改操作符按钮的计算器示例，我们就会实现一个完整的应用程序。让我们首先看看图5.21中的状态流程图，然后看看列表5.4中的实现。
- en: '![05-21](../Images/05-21.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![05-21](../Images/05-21.png)'
- en: Figure 5.21 The expanded calculator example now has three buttons to change
    the operator.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.21 扩展的计算器示例现在有三个按钮来更改操作符。
- en: Listing 5.4 Simple calculator
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.4 简单计算器
- en: '[PRE22]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ Initializes the state with a function returning the default operator function
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用返回默认操作符函数的函数初始化状态
- en: ❷ Updates the state with a function returning the clicked operator function
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用返回被点击操作函数的函数更新状态
- en: ❸ We can now call the state value as a function because we’ve made sure it’s
    always a function.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 我们现在可以调用状态值作为函数，因为我们已经确保它始终是一个函数。
- en: 'Repository: rq05-calculator'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库：rq05-calculator
- en: 'This example can be seen in repository rq05-calculator. You can use that repository
    by creating a new app based on the associated template:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在rq05-calculator仓库中看到。您可以通过创建一个基于相关模板的新应用程序来使用该仓库：
- en: '[PRE23]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以访问这个网站浏览代码，直接在浏览器中查看应用程序的实际效果，或者下载源代码的zip文件：
- en: '[https://rq2e.com/rq05-calculator](https://rq2e.com/rq05-calculator)'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq05-calculator](https://rq2e.com/rq05-calculator)'
- en: See this fancy (but a bit simple) calculator in action in figure 5.22.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在图5.22中查看这个花哨（但有点简单）的计算器在实际操作中的效果。
- en: '![05-22](../Images/05-22.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![05-22](../Images/05-22.png)'
- en: Figure 5.22 Our calculator with the default operator, PLUS. We don’t actually
    display anywhere what the operator is, we just display the result of the calculation
    of applying that operator to the two operands.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.22 我们的计算器默认操作符为PLUS。实际上，我们没有在任何地方显示操作符是什么，我们只是显示应用该操作符到两个操作数上的计算结果。
- en: Setting and rendering
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 设置和渲染
- en: What happens if we keep clicking the Plus button in the calculator? Does the
    component re-render every time, doing the calculation every time? We set the state
    to the exact same value every time, so why should it?
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在计算器中持续点击加号按钮会发生什么？组件每次都会重新渲染并执行计算吗？我们每次都将状态设置为完全相同的值，那么为什么应该这样呢？
- en: Actually, the component won’t re-render. React includes built-in optimization,
    so useState will wait until the end of the current cycle to update the component.
    It checks whether the value actually changed and then only re-renders the component
    if it has changed. Because of this, there can be situations where you call the
    state setter function, but no re-render happens (because no re-render should be
    necessary as nothing has changed).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，组件不会重新渲染。React包含内置优化，所以useState会等待当前周期的结束来更新组件。它会检查值是否实际改变，然后只有当值改变时才重新渲染组件。正因为如此，可能会出现调用状态设置函数但没有重新渲染的情况（因为实际上没有必要重新渲染，因为没有变化）。
- en: Let’s expand our counter from earlier and add a Reset button that resets the
    counter to 0\. The state flowchart now looks like figure 5.23.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展之前创建的计数器，并添加一个重置按钮，该按钮将计数器重置为0。现在状态流程图看起来像图5.23。
- en: '![05-23](../Images/05-23.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![05-23](../Images/05-23.png)'
- en: Figure 5.23 The new Reset button sets the counter to 0 regardless of the old
    value.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.23 新的重置按钮将计数器设置为0，无论旧值是多少。
- en: If we implement this, we get the following listing. You can see this new resettable
    counter in figure 5.24.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们实现这个功能，我们会得到以下列表。您可以在图5.24中看到这个新的可重置计数器。
- en: '![05-24](../Images/05-24.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![05-24](../Images/05-24.png)'
- en: Figure 5.24 A resettable counter that we’ve just set back to 0
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.24 我们刚刚将计数器重置为0的可重置计数器
- en: Listing 5.5 A resettable counter
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.5 可重置计数器
- en: '[PRE24]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ When you click Reset, the counter is set to 0.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 当您点击重置时，计数器被设置为0。
- en: 'Repository: rq05-reset-counter'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库：rq05-reset-counter
- en: 'This example can be seen in repository rq05-reset-counter. You can use that
    repository by creating a new app based on the associated template:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例可在rq05-reset-counter存储库中看到。您可以通过创建基于相关模板的新应用程序来使用该存储库：
- en: '[PRE25]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您也可以访问这个网站来浏览代码，直接在浏览器中查看应用的实际效果，或者下载源代码的zip文件：
- en: '[https://rq2e.com/rq05-reset-counter](https://rq2e.com/rq05-reset-counter)'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq05-reset-counter](https://rq2e.com/rq05-reset-counter)'
- en: 'Clicking Reset works by resetting the value to 0\. If we click the button again,
    nothing happens. But how can you tell if the component re-rendered or not? The
    answer is a very useful plugin available for Chrome, Firefox, and modern versions
    of Edge, called *React Developer Tools*. It’s available for download from their
    respective stores:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 点击重置会将值重置为0。如果我们再次点击按钮，则不会发生任何操作。但你怎么知道组件是否重新渲染了呢？答案是Chrome、Firefox和现代版本的Edge都可用的一个非常有用的插件，称为*React开发者工具*。您可以从它们各自的商店下载：
- en: 'Chrome and Edge: [http://mng.bz/wvoq](http://mng.bz/wvoq)'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Chrome和Edge: [http://mng.bz/wvoq](http://mng.bz/wvoq)'
- en: 'Firefox: [http://mng.bz/qrYw](http://mng.bz/qrYw)'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Firefox: [http://mng.bz/qrYw](http://mng.bz/qrYw)'
- en: With this plugin, we’re able to see when any component renders. React Developer
    Tools instructions are shown in figure 5.25.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此插件，我们能够看到任何组件何时渲染。React开发者工具的说明如图5.25所示。
- en: '![05-25](../Images/05-25.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![05-25](../Images/05-25.png)'
- en: Figure 5.25 Open the Components panel for React Developer Tools, open the gear
    menu, and select the Highlight Updates When Components Render check box.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.25 打开React开发者工具的组件面板，打开齿轮菜单，并选择“组件渲染时突出显示更新”复选框。
- en: When finished, go back to the resettable counter application and click the increment
    counter, and you’ll see a blue outline around the entire component flash briefly
    every time the counter increases. It should look like figure 5.26.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，回到可重置计数器应用程序并点击增加计数器，您会看到每次计数器增加时，整个组件周围都会出现一个蓝色轮廓，并短暂闪烁。它应该看起来像图5.26。
- en: '![05-26](../Images/05-26.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![05-26](../Images/05-26.png)'
- en: Figure 5.26 The blue outline around the entire component indicates that it has
    just rendered due to the state changing.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.26 整个组件周围的蓝色轮廓表明它刚刚因为状态改变而重新渲染。
- en: If you click the Reset button when the counter isn’t at 0, you’ll see the blue
    outline flash because the component renders. But if you click the Reset button
    when the counter is already at 0, no blue outline appears. React is smart enough
    to know that if the state is unchanged, the component output is (or at least should
    be) unchanged.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果计数器不在0时点击重置按钮，您会看到蓝色轮廓闪烁，因为组件会重新渲染。但如果你在计数器已经是0时点击重置按钮，就不会出现蓝色轮廓。React足够智能，知道如果状态没有改变，组件输出（或至少应该是）没有改变。
- en: State must be set to a new value
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 状态必须设置为新的值
- en: This condition on the re-render also means that if you set the state value to
    the same object it already is, even if you changed the object “on the inside,”
    nothing will happen because there isn’t a re-render. This can occur, for example,
    if you have an array in your state. If you manipulate the array in place and set
    the same array as the state value again, the component won’t render because nothing
    has changed (from a referential equality perspective, at least).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这个重新渲染的条件还意味着，如果您将状态值设置为它已经是的对象，即使您在内部改变了对象，也不会发生任何事情，因为没有重新渲染。例如，如果您在状态中有一个数组。如果您就地操作数组并将其作为状态值再次设置，组件不会渲染，因为没有任何变化（至少从引用相等的角度来看）。
- en: Let’s see this in action and discuss how we can fix this. For that purpose,
    we’re going to build a simple to-do application. We have a list of items we can
    tick off the list, and as we tick off an item, we remove it from the array and
    then render the list again.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个实际效果，并讨论我们如何修复它。为此，我们将构建一个简单的待办事项应用程序。我们有一个可以勾选的项列表，当我们勾选一个项时，我们将其从数组中删除，然后再次渲染列表。
- en: The wrong way to do this is to set the state to the same array every time. It
    doesn’t matter if we edit the array before setting it as state again because React
    doesn’t look inside our state value, but only at the reference. This wrong approach
    in sketched out in figure 5.27.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事的错误方式是每次都将状态设置为相同的数组。我们编辑数组后再将其设置为状态值无关紧要，因为React不会查看我们的状态值内部，它只看引用。这种错误方法在图5.27中概述。
- en: '![05-27](../Images/05-27.png)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![05-27](../Images/05-27.png)'
- en: Figure 5.27 The wrong way to use an array as a state value is to set the state
    to the same array every time. The problem here is that React actually won’t see
    that anything changed, and it won’t cause our component to re-render.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.27 错误地使用数组作为状态值的方式是每次都将状态设置为相同的数组。这里的问题是React实际上看不到任何变化，它不会导致我们的组件重新渲染。
- en: While we now understand that this is wrong, let’s try to implement it anyway,
    so we can also see that it actually doesn’t work for real.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们现在明白这是错误的，但让我们还是尝试实现它，这样我们也可以看到它实际上不起作用。
- en: Listing 5.6 A broken to-do list application
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.6 一个损坏的待办事项列表应用程序
- en: '[PRE26]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ Modifies the array in place
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 修改数组的内容
- en: ❷ Updates the state to the same value it already has (which we changed though,
    right?)
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 更新状态为它已经拥有的相同值（尽管我们改变了它，对吧？）
- en: 'Repository: rq05-bad-todo'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库：rq05-bad-todo
- en: 'This example can be seen in repository rq05-bad-todo. You can use that repository
    by creating a new app based on the associated template:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例可在rq05-bad-todo存储库中看到。您可以通过创建基于相关模板的新应用程序来使用该存储库：
- en: '[PRE27]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以访问此网站浏览代码，在浏览器中直接查看应用程序的实际应用，或下载源代码的zip文件：
- en: '[https://rq2e.com/rq05-bad-todo](https://rq2e.com/rq05-bad-todo)'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq05-bad-todo](https://rq2e.com/rq05-bad-todo)'
- en: Let’s try this out and click those Delete buttons shown in figure 5.28\. Nothing
    happens when you click. If you try enabling update outlines in the React Developer
    Tools plugin, you’ll see that the component doesn’t actually re-render because
    the state value is identical by reference, even though it might have been “updated.”
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一下，点击图5.28中显示的删除按钮。点击时没有任何反应。如果您尝试在React开发者工具插件中启用更新轮廓，您会看到组件实际上并没有重新渲染，因为状态值在引用上相同，即使它可能已经被“更新”。
- en: '![05-28](../Images/05-28.png)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![05-28](../Images/05-28.png)'
- en: Figure 5.28 Our functional to-do list application looks right, but doesn’t work—nothing
    happens when we click the buttons.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.28 我们的功能待办事项应用程序看起来是正确的，但不起作用——点击按钮时没有任何反应。
- en: For this reason, it’s not merely recommended that you don’t mutate state directly,
    it’s absolutely necessary that you don’t. Doing this correctly requires setting
    the state value to a new array, which is a duplicate of the old one but without
    the spliced item. One way is to use the spread operator on a slice of the array
    before and after the item to be deleted. We can fix the model so it becomes like
    figure 5.29 by creating a new array and setting *that* as the new state. This
    is implemented in listing 5.7, which follows the figure.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，不仅建议您不要直接修改状态，这是绝对必要的。正确地做到这一点需要将状态值设置为一个新的数组，它是旧数组的副本，但不包含被删除的项。一种方法是在删除元素之前和之后对数组的一个切片使用扩展运算符。我们可以通过创建一个新的数组并将其设置为新的状态来修复模型，使其类似于图5.29。这已在列表5.7中实现，它遵循该图。
- en: '![05-29](../Images/05-29.png)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![05-29](../Images/05-29.png)'
- en: Figure 5.29 We now pass a new array to the setter function every time an item
    is removed. React correctly identifies that state as updated and will re-render
    the component.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.29 现在我们每次从数组中删除一个项目时，都会传递一个新的数组到设置函数。React正确地识别出状态已更新，并将重新渲染组件。
- en: Listing 5.7 A proper to-do list application
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.7 一个合适的待办事项列表应用程序
- en: '[PRE28]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '❶ Sets the state to a new array, which is the concatenation of two things:
    the old array sliced from the start to just before the deleted element, plus the
    old array sliced just after the deleted element to the end'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将状态设置为一个新的数组，这是两个东西的连接：从开始到删除元素之前的旧数组切片，加上从删除元素之后到结束的旧数组切片
- en: 'Repository: rq05-proper-todo'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库：rq05-proper-todo
- en: 'This example can be seen in repository rq05-proper-todo. You can use that repository
    by creating a new app based on the associated template:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在rq05-proper-todo仓库中看到。您可以通过创建基于相关模板的新应用程序来使用该仓库：
- en: '[PRE29]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以访问此网站浏览代码，直接在浏览器中查看应用程序的实际应用，或下载源代码的zip文件：
- en: '[https://rq2e.com/rq05-proper-todo](https://rq2e.com/rq05-proper-todo)'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq05-proper-todo](https://rq2e.com/rq05-proper-todo)'
- en: This looks the same as before, but now we can actually delete items from the
    list, as you can see in figure 5.30.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来和以前一样，但现在我们实际上可以从列表中删除项目，如图5.30所示。
- en: '![05-30](../Images/05-30.png)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![05-30](../Images/05-30.png)'
- en: Figure 5.30 Our functional to-do list application now actually works as here
    we’ve completed two of the items on the task list for the day. Now, go run a bath;
    this is gonna be messy!
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.30 我们的功能性待办事项列表应用程序现在实际上按这里所示工作，因为我们已经完成了当天任务列表上的两个项目。现在，去洗个澡；这会变得很乱！
- en: 5.2.6 Using multiple states
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.6 使用多个状态
- en: We’ve hinted at this a few times, but just to confirm it—yes, you can have multiple
    useState hooks in the same component, and you often will. As an example, let’s
    expand our new to-do list application. Let’s stop deleting items from the array
    when we complete them. Instead, we’ll mark them as completed. Completed items
    will be rendered in the list with a strike-through. On top of that, we’ll also
    add a new filter at the top, where you can decide if you want to see all items
    or only uncompleted items.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经暗示过几次，但只是为了确认——是的，您可以在同一个组件中拥有多个useState钩子，并且您通常会这样做。作为一个例子，让我们扩展我们的新待办事项列表应用程序。让我们在完成任务时停止从数组中删除项目，而是将它们标记为已完成。完成的项将以删除线的方式在列表中显示。除此之外，我们还会在顶部添加一个新的过滤器，您可以选择是否要查看所有项目或仅查看未完成的项。
- en: To filter the list, we need to remember whether we should filter out completed
    items or not. The perfect way to do this is to add another state value that holds
    this filter flag, as illustrated in figure 5.31\. The implementation is shown
    in listing 5.8.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 要过滤列表，我们需要记住是否应该过滤掉已完成的项。最完美的方法是为这个过滤器标志添加另一个状态值，如图5.31所示。实现方式在列表5.8中展示。
- en: '![05-31](../Images/05-31.png)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![05-31](../Images/05-31.png)'
- en: Figure 5.31 We can now update state in three different ways. If an item is marked
    as completed, we still have to remember to create a new array, but with the item
    in question marked as completed. If we toggle the filter flag, we simply set the
    relevant state flag.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.31 我们现在可以通过三种不同的方式更新状态。如果一个项目被标记为已完成，我们仍然需要记得创建一个新的数组，但将该项目标记为已完成。如果我们切换过滤器标志，我们只需设置相关的状态标志。
- en: Listing 5.8 To-do app with a filter
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.8 带过滤器的待办事项应用程序
- en: '[PRE30]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ❶ Creates a little utility function that takes an array of task objects and
    returns a new array of the same objects, except one of them will be marked as
    done, as indicated by the second argument
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个小的实用函数，该函数接受任务对象数组，并返回一个新数组，其中包含相同的对象，但其中一个对象将被标记为完成，如第二个参数所示
- en: ❷ Still initializes the task list using the useState hook
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 仍然使用useState钩子初始化任务列表
- en: ❸ But now we have a second instance of the useState hook for the new filter
    flag, which we default to false.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 但现在我们为新的过滤器标志创建了useState钩子的第二个实例，我们将其默认设置为false。
- en: ❹ Uses the filter flag to optionally filter the list of to-do items to display
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用过滤器标志可选地过滤要显示的任务列表
- en: ❺ The two filter buttons call the filter setter function with either true or
    false.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 两个过滤器按钮调用带有true或false的过滤器设置函数。
- en: ❻ Now we must remember to use the new (optionally filtered) list.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 现在我们必须记住使用新的（可选过滤的）列表。
- en: ❼ Renders the task with a strike-through if it has been completed
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 如果任务已完成，则使用删除线渲染任务
- en: ❽ If not completed, renders a button that will call our utility function and
    updates the task list state
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 如果未完成，则渲染一个按钮，该按钮将调用我们的实用函数并更新任务列表状态
- en: ❾ Creates the list of initial items as a list of objects, each marked as not
    done yet. Note that we need to remember the original position of each item, as
    the index in the filtered array will be different from the original index position.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 将初始项目列表作为一个对象列表创建，每个对象都标记为尚未完成。请注意，我们需要记住每个项目的原始位置，因为过滤数组中的索引将与原始索引位置不同。
- en: 'Repository: rq05-filter-todo'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库：rq05-filter-todo
- en: 'This example can be seen in repository rq05-filter-todo. You can use that repository
    by creating a new app based on the associated template:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在rq05-filter-todo仓库中看到。您可以通过创建一个基于相关模板的新应用来使用该仓库：
- en: '[PRE31]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您也可以访问这个网站来浏览代码，直接在浏览器中查看应用程序的运行情况，或者下载源代码的zip文件：
- en: '[https://rq2e.com/rq05-filter-todo](https://rq2e.com/rq05-filter-todo)'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq05-filter-todo](https://rq2e.com/rq05-filter-todo)'
- en: Let’s see this in action in figure 5.32 and try to use the various buttons.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在图5.32中看看这个动作，并尝试使用各种按钮。
- en: '![05-32](../Images/05-32.png)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![05-32](../Images/05-32.png)'
- en: Figure 5.32 After completing the two easy items, we can decide whether to see
    the full list and bask in our 67% completed progress or only see the remaining
    items and get a bit overwhelmed because of the single daunting task.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.32 在完成两个简单项目后，我们可以决定是查看完整列表并享受67%的完成进度，还是只查看剩余项目，因为单个令人畏惧的任务而感到有些不知所措。
- en: Of course, you’re not limited to two state values in a single component. You
    can use as many as you want, though it might get a bit hard to follow if the number
    exceeds 10\. We suggest using either context providers, reducers, or custom hooks—or
    all three—if states get more complex. We’ll get back to how these more advanced
    techniques work in chapter 10.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您在单个组件中不限于使用两个状态值。您可以使用尽可能多的状态值，但如果数量超过10，可能会变得难以跟踪。我们建议在状态变得复杂时使用上下文提供者、reducer或自定义钩子——或者三者都使用。我们将在第10章中回到这些更高级技术是如何工作的。
- en: 5.2.7 State scope
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.7 状态作用域
- en: In all the components we created previously, we accessed and updated the state
    inside the component itself, as opposed to accessing or updating the state outside
    the component, where we defined the state. But what if we want to have state that
    spans multiple components? What if we want to access the value in one component,
    but update it in another? We hinted at this at the beginning of the chapter, when
    we talked about the number of stateful components in the entire application component
    tree, but we haven’t actually done it yet.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前创建的所有组件中，我们都在组件内部访问和更新状态，而不是在定义状态的组件外部访问或更新状态。但如果我们想要跨多个组件的状态呢？如果我们想在组件中访问值，但在另一个组件中更新它呢？我们在本章开头提到了这一点，当时我们讨论了整个应用程序组件树中状态组件的数量，但我们还没有实际做到这一点。
- en: To do this, we can use properties to pass state values and state setters to
    the relevant components. The state flowchart is the same as before; the difference
    is the component tree. Where we just had a single component handle everything,
    we’re now going to introduce a number of components. The TodoApplication component
    is still our stateful component holding the two state values. To aid this one,
    we add a FilterButton and a Task, which take care of rendering the top filter
    buttons and individual tasks in the list, respectively. Figure 5.33 shows this
    new component tree as well as all the properties.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，我们可以使用属性传递状态值和状态设置函数到相关组件。状态流程图与之前相同；不同的是组件树。我们之前只有一个组件处理所有事情，现在我们将引入多个组件。TodoApplication
    组件仍然是我们的状态组件，持有两个状态值。为了辅助这个组件，我们添加了一个 FilterButton 和一个 Task，分别负责渲染顶部的过滤器按钮和列表中的单个任务。图
    5.33 展示了这个新的组件树以及所有属性。
- en: '![05-33](../Images/05-33.png)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![05-33](../Images/05-33.png)'
- en: Figure 5.33 The component tree of our multicomponent to-do application. We render
    a variable number of Task instances, one for every item in the list, and always
    exactly two filter buttons.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.33 我们多组件待办事项应用程序的组件树。我们渲染了可变数量的 Task 实例，每个列表项一个，并且总是恰好两个过滤器按钮。
- en: Let’s now put this all together in a single application in listing 5.9, and,
    while we’re at it, let’s also make things look a bit nicer with some styles.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将这些内容整合到一个单独的应用程序中，如列表 5.9 所示，并且，趁此机会，让我们也用一些样式让它看起来更美观。
- en: Listing 5.9 Advanced multicomponent to-do application
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.9 高级多组件待办事项应用程序
- en: '[PRE32]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: ❶ The FilterButton takes four properties and renders a nice button based on
    these.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ FilterButton 接受四个属性，并根据这些属性渲染一个漂亮的按钮。
- en: ❷ In particular, the onClick property on the button calls the passed setter
    function with the passed value.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 特别是，按钮上的 onClick 属性会调用传递的设置函数，并传入传递的值。
- en: ❸ Similarly, the Task component takes a number of properties, including a callback.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 同样，Task 组件接受多个属性，包括一个回调函数。
- en: ❹ This time, we just invoke the passed callback when we click the button because
    it does the required work, but only if the item wasn’t already done.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 这次，我们只是在点击按钮时调用传递的回调，因为如果项目尚未完成，它就会执行所需的工作。
- en: ❺ Two filter buttons in the final component with almost identical properties
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 最终组件中的两个过滤器按钮具有几乎相同的属性
- en: ❻ For each task item, creates a Task component instance
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 对于每个任务项，创建一个 Task 组件实例
- en: ❼ Sets the markDone to the same updating function as before
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 将 markDone 设置为与之前相同的更新函数。
- en: 'Repository: rq05-nice-todo'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库：rq05-nice-todo
- en: 'This example can be seen in repository rq05-nice-todo. You can use that repository
    by creating a new app based on the associated template:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在仓库 rq05-nice-todo 中看到。你可以通过创建一个基于相关模板的新应用程序来使用该仓库：
- en: '[PRE33]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以访问这个网站来浏览代码，直接在浏览器中查看应用程序的运行情况，或者下载源代码的 zip 文件：
- en: '[https://rq2e.com/rq05-nice-todo](https://rq2e.com/rq05-nice-todo)'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq05-nice-todo](https://rq2e.com/rq05-nice-todo)'
- en: And there we have it—our first complete, useful, and well-architected application
    in React! It looks just like before, except it looks a lot nicer, as you can see
    in figure 5.34.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: And there we have it—our first complete, useful, and well-architected application
    in React! It looks just like before, except it looks a lot nicer, as you can see
    in figure 5.34.
- en: '![05-34](../Images/05-34.png)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![05-34](../Images/05-34.png)'
- en: Figure 5.34 Our fully developed to-do application with a lovely UI, even! Currently,
    the filter is set to Show All, but if we toggle it to Hide Done, only the last
    item would be displayed—just like before.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.34 我们完全开发的待办事项应用程序，甚至拥有可爱的 UI！目前，过滤器设置为显示所有，但如果我们将它切换到隐藏完成，则只会显示最后一个条目——就像之前一样。
- en: The ideas used in this application are the same ideas that fuel any application.
    We store state in one level and pass it around to other components where applicable
    to render the result we need. In our latest to-do application, state is stored
    “globally” in the TodoApplication component and not just locally inside each of
    the child components.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序中使用的思想是任何应用程序的动力源泉。我们在一个级别存储状态，并在适用的情况下将其传递到其他组件，以渲染我们所需的结果。在我们的最新待办事项应用程序中，状态存储在
    TodoApplication 组件中，而不仅仅是在每个子组件内部。
- en: If we were to add another component to this that existed next to the task list
    but would need access to the same state values as the task list does, we would
    need to lift the states from the TodoApplication component up to the App component
    and then pass the values and the setters down to the TodoApplication component.
    All of this work of passing state values and setters around can get a bit complex,
    but we’ll see how to solve that in a better way in chapter 10 using React Context.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要添加另一个组件到这个列表中，它位于任务列表旁边，但需要访问与任务列表相同的州值，我们就需要将状态从TodoApplication组件提升到App组件，然后将值和设置器传递到TodoApplication组件。所有这些传递状态值和设置器的工作可能会变得有些复杂，但我们将看到如何在第10章中使用React
    Context以更好的方式解决这个问题。
- en: 5.3 Stateful class-based components
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3 具有状态的类组件
- en: So far, we’ve covered how to add component state to functional components. But
    stateful components existed before the emergence of hooks. In fact, state was
    a primary feature built into the functionality of class-based components.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了如何向函数组件添加组件状态。但具有状态的组件在hooks出现之前就已经存在了。事实上，状态是内置到基于类组件功能中的主要特性。
- en: 'In class-based components, state works the same way and has the same four steps
    shown in figure 5.5:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在类组件中，状态的工作方式与图5.5中显示的相同四个步骤相同：
- en: Initialize state.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化状态。
- en: Display current value.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示当前值。
- en: Update state.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新状态。
- en: Inform React that state has been updated.
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通知React状态已更新。
- en: We’ve seen a ton of examples of how we do these four steps in a functional component.
    Now let’s look at how to do the same in a class-based component. The API is similar,
    but the syntax is a bit different, and the behavior also varies slightly. The
    basic concept is the same, however.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了很多如何在函数组件中执行这四个步骤的例子。现在让我们看看如何在基于类组件中执行相同的操作。API是相似的，但语法略有不同，行为也略有差异。基本概念是相同的。
- en: 'The code for a (partial) counter component looks like this:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 一个（部分）计数组件的代码如下所示：
- en: '[PRE34]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now, take a look at figure 5.35 for a quick overview of how the different parts
    relate to the different bits of the state cycle. Rather than store values as local
    variables as we do in a functional component, we store the state values on the
    class member called this.state.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请查看图5.35，快速了解不同部分如何与状态循环的不同位相关联。与我们在函数组件中一样作为局部变量存储值不同，我们在名为this.state的类成员上存储状态值。
- en: '![05-35](../Images/05-35.png)'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
  zh: '![05-35](../Images/05-35.png)'
- en: Figure 5.35 The flowchart of data in our click counter with code added. The
    dashed arrows connect the state in the flowchart to the corresponding bit of code
    responsible for that particular action.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.35 添加代码后的点击计数器数据流程图。虚线箭头将流程图中的状态连接到负责该特定操作的相应代码部分。
- en: In this section, we’ll first cover how adding state to class-based components
    is similar to adding state to functional components, but with a slightly different
    syntax; then, we’ll discuss how this is also fundamentally different due to three
    larger changes in behavior; and, finally, we’ll briefly go over how to convert
    a stateful class-based component to a functional component. Note that we’re not
    going to provide full examples in this section, merely explain the differences.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们首先介绍如何将状态添加到基于类的组件与添加到函数组件类似，但语法略有不同；然后，我们将讨论由于行为上的三个较大变化，这也有根本性的不同；最后，我们将简要介绍如何将具有状态的类组件转换为函数组件。请注意，我们本节不会提供完整的示例，只是解释差异。
- en: 5.3.1 Similarities with the useState hook
  id: totrans-397
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.1 与useState钩子的相似之处
- en: Everything we’ve done so far in functional components could just as well have
    been done in class-based components. Initializing, updating, and displaying state
    is the name of the game, and we can do that with a slightly different syntax.
    See table 5.1 for an overview of how the syntax deviates.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在函数组件中迄今为止所做的一切也可以在基于类组件中完成。初始化、更新和显示状态是游戏的名字，我们可以用略有不同的语法来做这件事。参见表5.1，了解语法差异的概述。
- en: Table 5.1 State in functional components and class-based components
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.1 函数组件和类组件中的状态
- en: '| Functional component | Class-based component |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
  zh: '| 函数组件 | 类组件 |'
- en: '|'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE35]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This is the case if state is initialized to a static value. |
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 如果状态是从静态值初始化的，则情况就是这样。|
- en: '[PRE36]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: When we initialize state to a static value here, we can use a class member.
    |
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在这里将状态初始化为静态值时，我们可以使用类成员。|
- en: '|'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE37]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This is the case if state is initialized to a dynamic value from a property.
    |
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 如果状态是从属性初始化为动态值，则情况就是这样。|
- en: '[PRE38]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here, we have to access the property in the constructor and initialize the state
    using this.state. |
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们必须在构造函数中访问属性，并使用 this.state 初始化状态。|
- en: '|'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE39]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '|'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE40]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '|'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE41]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: If we’re setting the state to a fixed value, we can use the nonfunctional variant
    of the setter. |
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将状态设置为固定值，我们可以使用设置器的非函数版本。|
- en: '[PRE42]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We do the same thing here, except we need to make it an object. |
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的是同样的事情，但我们需要将其变成一个对象。|
- en: '|'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE43]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: If we use an update function, we simply use the old value and return a new one
    using whatever type we have in the state. |
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用更新函数，我们只需使用旧值，并使用我们在状态中拥有的任何类型返回一个新的值。|
- en: '[PRE44]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: If we’re setting the state to a dynamic value based on the current state, we
    can use the functional update variant of the setter, but we have to return an
    object based on the old state object. |
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将状态设置为基于当前状态的动态值，我们可以使用设置器的函数更新版本，但我们必须基于旧状态对象返回一个对象。|
- en: 5.3.2 Differences from the useState hook
  id: totrans-426
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.2 与 useState 钩子的区别
- en: 'There are also differences in how state is used in class-based components.
    Those differences are significant and will affect how you use state in class-based
    components as opposed to functional components. The main differences are listed
    here:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于类的组件中，状态的使用方式也存在差异。这些差异是显著的，并将影响你在基于类的组件中与函数组件相比如何使用状态。主要区别如下：
- en: You can only have one state object, which is always an object.
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你只能有一个状态对象，它始终是一个对象。
- en: Components *always re-render if updated,* even if nothing changed.
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件*在更新时总是重新渲染，*即使没有任何变化。
- en: Objects are merged when you update the state, so *partial updates are possible*.
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新状态时，对象会合并，因此*部分更新是可能的*。
- en: We’ll go over each of these differences with a short example in the following
    subsections.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下小节中通过简短的示例来介绍这些区别。
- en: Only one state object
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一个状态对象
- en: As you saw in table 5.1, class-based component state lives inside a state object.
    Even if you only have a single value—for example, a counter—you have to create
    it on the state object, update it on the state object, and display it from the
    state object.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在表 5.1 中看到的，基于类的组件状态位于状态对象内部。即使你只有一个值——例如，一个计数器——你也必须在该状态对象上创建它，更新它，并从状态对象中显示它。
- en: The upside is that moving from a single state value to multiple state values
    is very smooth. You simply add a second property to the state object, and you’re
    good to go. As soon as you have introduced state into a class-based component,
    you can support one or multiple state values without any problem.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 优点是，从单个状态值移动到多个状态值非常平滑。你只需在状态对象中添加第二个属性，就可以继续进行。一旦你将状态引入基于类的组件，你就可以无任何问题地支持一个或多个状态值。
- en: Components always render when state is updated
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 组件在状态更新时总是渲染
- en: We mentioned in section 5.2.5 that the useState hook will only cause the component
    to re-render if the state actually updates. If you set a state value to 0 when
    it’s already 0, it won’t update the component. React assumes that our components
    are pure and that the component will render the same if the state hasn’t updated.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 5.2.5 节中提到，useState 钩子只会导致组件重新渲染，如果状态实际上已经更新。如果你将状态值设置为 0，而它已经是 0，则不会更新组件。React
    假设我们的组件是纯的，并且如果状态没有更新，组件将渲染相同的内容。
- en: It was different in the old days, and some applications actually depended on
    this back then. In a class-based component, you can call setState with the same
    values or even no values, and React will re-render your component.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，情况有所不同，当时一些应用程序实际上依赖于这一点。在基于类的组件中，你可以使用相同的值或甚至没有值调用 setState，React 将重新渲染你的组件。
- en: State objects are merged
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 状态对象是合并的
- en: Because the state in a class-based component is a single big object with potentially
    dozens of state values, it would be annoying to have to remember to set all of
    them.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 由于基于类的组件中的状态是一个可能包含数十个状态值的单个大对象，因此必须记住设置所有这些值会非常麻烦。
- en: 'Imagine that you reset a counter with the following snippet:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你使用以下片段重置计数器：
- en: '[PRE45]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If you had a number of other state values in this same component, imagine that
    this would reset or even delete all these other state values because you didn’t
    include them in the object that you passed to setState. That would be quite annoying.
    If that happened, you would have to do something like this every time to copy
    all the existing values into the new object:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这个相同的组件中有其他一些状态值，想象一下，这将重置或甚至删除所有这些其他状态值，因为你没有在传递给 setState 的对象中包含它们。这会很烦人。如果发生这种情况，你每次都必须这样做，将所有现有值复制到新对象中：
- en: '[PRE46]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Fortunately, you don’t have to do that. React automatically does this for class-based
    components. When you pass a new object (or an update function that returns an
    object) to the setState method, React automatically merges this new object onto
    the existing state object. It will do exactly what is shown in the previous snippet,
    so you don’t have to remember to do that every time.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，您不必这样做。React 会自动为基于类的组件执行此操作。当您将新对象（或返回对象的更新函数）传递给 setState 方法时，React 会自动将此新对象合并到现有状态对象上。它将执行与上一个代码片段中显示的完全相同的功能，因此您不必每次都记住这样做。
- en: 5.4 Quiz
  id: totrans-445
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.4 习题
- en: Which of the following would you store in component state?
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个应该存储在组件状态中？
- en: Dynamic application data
  id: totrans-447
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动态应用程序数据
- en: Component properties
  id: totrans-448
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组件属性
- en: Constant values
  id: totrans-449
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 常量值
- en: Which of the following is the correct way to initialize a simple numeric state
    in a functional component?
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪种是初始化函数组件中简单数值状态的正确方法？
- en: const { value, setter } = useState(0);
  id: totrans-451
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: const { value, setter } = useState(0);
- en: const [ value, setter ] = useState(0);
  id: totrans-452
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: const [ value, setter ] = useState(0);
- en: 'const { value, setter } = useState({ value: 0 });'
  id: totrans-453
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'const { value, setter } = useState({ value: 0 });'
- en: 'const [ value, setter ] = useState({ value: 0 });'
  id: totrans-454
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'const [ value, setter ] = useState({ value: 0 });'
- en: You can only have a single useState hook in each functional component. *True*
    or *false*?
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您在每个函数组件中只能有一个 useState 钩子。*正确*还是*错误*？
- en: When updating a component state value through a useState setter function, the
    component will always re-render. *True* or *False*?
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当通过 useState setter 函数更新组件状态值时，组件总是会重新渲染。*正确*还是*错误*？
- en: Which of the following would you use to read a single numerical value from state
    in a class-based component?
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个用于在基于类的组件中从状态中读取单个数值？
- en: '<p>Value: {this.state}.</p>'
  id: totrans-458
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <p>值：{this.state}。</p>
- en: '<p>Value: {this.counter}.</p>'
  id: totrans-459
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <p>值：{this.counter}。</p>
- en: '<p>Value: {this.state.counter}.</p>'
  id: totrans-460
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <p>值：{this.state.counter}。</p>
- en: Quiz answers
  id: totrans-461
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 习题答案
- en: You should definitely store dynamic application data in state but never properties
    (you already have them in the properties object), and neither should you store
    unchanging values in state.
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您绝对应该在状态中存储动态应用程序数据，但永远不要存储属性（您已经在属性对象中有了它们），也不应该将不变的值存储在状态中。
- en: const [ value, setter ] = useState(0);. You provide the initial value to useState
    as a simple value and destruct the returned value as an array, not an object.
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: const [ value, setter ] = useState(0);. 您将初始值作为简单值提供给 useState，并将返回值解构为数组，而不是对象。
- en: '*False*. You can have as many useState hooks in each component as you desire.'
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*错误*。您可以在每个组件中拥有任意数量的 useState 钩子。'
- en: '*False*. The component will only render if the new value passed to the setter
    function is different from the existing value. The comparison is done using referential
    equality, so even if an object has updated internally, if it’s still the same
    object, it won’t cause a re-render.'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*错误*。组件只有在传递给 setter 函数的新值与现有值不同时才会重新渲染。比较是通过引用相等性进行的，因此即使对象内部已更新，如果它仍然是同一个对象，则不会导致重新渲染。'
- en: '<p>Value: {this.state.counter}.</p>. Remember that state in a class-based component
    is always an object, and your state values are properties of that object.'
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <p>值：{this.state.counter}。</p>。请记住，在基于类的组件中，状态始终是一个对象，而您的状态值是该对象的属性。
- en: Summary
  id: totrans-467
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Component state is used to make your application interactive. You’ll get just
    about nowhere in your application development if you don’t have stateful components.
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件状态用于使您的应用程序交互式。如果您没有状态组件，您的应用程序开发将几乎无法取得任何进展。
- en: You can have state in both class-based components and functional components.
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在基于类的组件和函数组件中都有状态。
- en: State in functional components is initialized as separate distinct calls to
    useState that have a separate setter per state value.
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数组件中的状态是通过单独的 distinct 调用 useState 初始化的，每个状态值都有一个单独的 setter。
- en: You can initialize the value of a useState hook by providing a static value,
    a dynamic value, or even a function that returns the initial value.
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过提供静态值、动态值，甚至返回初始值的函数来初始化 useState 钩子的值。
- en: You can update the value of a useState hook at any time, but only in a callback
    or other hook, and never directly in the component definition.
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在任何时间更新 useState 钩子的值，但只能在回调或其他钩子中，而不能直接在组件定义中。
- en: When updating the value of a useState hook, you can either provide a new value
    directly or provide a function that returns a new value based on the old value.
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当更新 useState 钩子的值时，您可以直接提供新值，也可以提供基于旧值的返回新值的函数。
- en: State in class-based components is initialized as a single object and updated
    using the setState method.
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类组件中，状态初始化为一个单一的对象，并使用setState方法进行更新。
- en: Conversion from a stateful class-based component to a stateful functional component
    might require a bigger refactor as the two approaches are significantly different.
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将有状态的类组件转换为有状态的函数组件可能需要进行较大的重构，因为这两种方法有显著的不同。
