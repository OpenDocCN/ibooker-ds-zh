- en: 2 Creating your first microservice
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 创建你的第一个微服务
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Our philosophy of development
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的开发哲学
- en: Establishing a single-service development environment
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立单一服务的开发环境
- en: Building a microservice for video streaming
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建视频流微服务
- en: Setting up for production and development
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生产环境和开发环境的设置
- en: Using Node.js to run our microservice
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Node.js运行我们的微服务
- en: Our goal for this book is to assemble an application that consists of multiple
    microservices. But before we can build multiple microservices, we must first learn
    how to build a single microservice.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这本书的目标是组装一个由多个微服务组成的应用程序。但在我们能够构建多个微服务之前，我们首先必须学会如何构建单个微服务。
- en: Because we have to start somewhere, in this chapter, we’ll create our first
    microservice. It’s a simple microservice, doing very little, but it illustrates
    the process so that you can understand it and repeat it. Indeed, it is the process
    we’ll use to create multiple microservices through the course of the book.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们必须从某个地方开始，在本章中，我们将创建我们的第一个微服务。这是一个简单的微服务，做得很少，但它说明了这个过程，以便你可以理解并重复它。实际上，这就是我们将通过本书的进程来创建多个微服务的方法。
- en: This first microservice is a simple HTTP server that delivers streaming video
    to a user watching in a web browser. This is the first step on our road to building
    FlixTube, our video-streaming application. Video streaming might sound difficult,
    but the simple code we examine at this stage should not present much trouble.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第一个微服务是一个简单的HTTP服务器，它向在网页浏览器中观看的用户提供流媒体视频。这是我们通往构建FlixTube（我们的视频流应用）道路上的第一步。视频流可能听起来很困难，但在这个阶段我们检查的简单代码不应该带来太多麻烦。
- en: In this book, our microservices are programmed with JavaScript and run on Node.js.
    It’s important to note, though, that we could use any tech stack for our microservices.
    Building applications with microservices gives us a lot of freedom in the tech
    stack we use.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们的微服务是用JavaScript编写的，并在Node.js上运行。但重要的是要注意，我们可以为我们的微服务使用任何技术栈。使用微服务构建应用程序给了我们在技术栈选择上很大的自由度。
- en: You don’t have to use JavaScript to build microservices. You can just as easily
    build your microservices using Python, C#, Ruby, Java, Go, or whatever language
    is in vogue by the time you read this book. I had to make a choice, however, because
    this is a practical book, and we need to get down to the nitty-gritty of actual
    coding. But, keep in mind that you can just as easily use your own favorite programming
    language to build your microservices.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必使用JavaScript来构建微服务。你可以同样容易地使用Python、C#、Ruby、Java、Go或你阅读这本书时流行的任何语言来构建你的微服务。然而，我必须做出选择，因为这是一本实用的书，我们需要深入实际的编码细节。但请记住，你可以同样容易地使用你自己的首选编程语言来构建你的微服务。
- en: We are about to embark on a whirlwind tour of Node.js. Of course, we can’t cover
    the full details, and as is the theme in this book, we are only going to skim
    the surface of what’s possible. At the end of the chapter, you’ll find references
    to other books on Node.js to drill down for a deeper knowledge.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将开始对Node.js进行快速浏览。当然，我们无法涵盖所有细节，正如本书的主题，我们只会简要地介绍可能的内容。在本章结束时，你将找到关于Node.js的其他书籍的参考，以便深入了解。
- en: If you already know Node.js, then you’ll find much of this chapter to be familiar,
    and you might be tempted to skip it. But skim through it because there are some
    important notes on setting up your development environment, preparing for production
    deployment, and getting ready for fast iterative development that we’ll rely on
    throughout the book.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经熟悉Node.js，那么你会发现本章的大部分内容都很熟悉，你可能想跳过它。但请快速浏览一下，因为其中有一些关于设置开发环境、准备生产部署以及为快速迭代开发做准备的重要提示，这些内容将在整本书中用到。
- en: Hold onto your hats! This book starts out simple, but in no time at all it turns
    into a pretty wild ride.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 带好你的帽子！这本书一开始很简单，但很快就会变成一段非常刺激的旅程。
- en: 2.1 New tools
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 新工具
- en: 'Because this book is all about the tools, in most chapters we’ll start with
    the new tools you need to install to follow along with the examples in the chapter.
    Starting with our first microservice, table 2.1 shows the tools we need: Git,
    Node.js, and Visual Studio (VS) Code. We’ll use Git to get the code. We’ll use
    Node.js to run and test our first microservice, and we’ll use VS Code to edit
    our code and work on our Node.js project.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这本书全部关于工具，所以在大多数章节中，我们都会从您需要安装的新工具开始，以便跟随章节中的示例。从我们的第一个微服务开始，表 2.1 展示了我们需要使用的工具：Git、Node.js
    和 Visual Studio (VS) Code。我们将使用 Git 获取代码。我们将使用 Node.js 运行和测试我们的第一个微服务，并使用 VS Code
    编辑我们的代码和 Node.js 项目。
- en: Throughout the book, I’ll tell you the version numbers for each tool used to
    develop the examples in this book. This gives you a version number that you can
    use to follow along with the examples.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我会告诉您每个工具的版本号，这些工具用于开发本书中的示例。这将为您提供可以用来跟随示例的版本号。
- en: Later versions of these tools should also work because good tools are usually
    backward compatible, but occasional major increments to versions can break old
    examples. If that happens, let me know by logging an issue in GitHub (see the
    next section).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具的后续版本也应该可以工作，因为好的工具通常具有向后兼容性，但偶尔的版本重大更新可能会破坏旧示例。如果发生这种情况，请通过在 GitHub 上记录问题（见下一节）来通知我。
- en: Table 2.1 Tools introduced in chapter 2
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.1 第 2 章中引入的工具
- en: '| Tool | Version | Purpose |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 工具 | 版本 | 用途 |'
- en: '| Git | 2.27.0 | Version control is an essential part of day-to-day development,
    in this chapter, we use Git to get a copy of the chapter 2 code. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| Git | 2.27.0 | 版本控制是日常开发中不可或缺的一部分，在本章中，我们使用 Git 获取第 2 章的代码副本。|'
- en: '| Node.js | 12.18.1 | We use Node.js to run our microservices. |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| Node.js | 12.18.1 | 我们使用 Node.js 运行我们的微服务。|'
- en: '| Visual Studio (VS) Code | 1.46.1 | We use VS Code for editing our code and
    other assets. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| Visual Studio (VS) Code | 1.46.1 | 我们使用 VS Code 编辑我们的代码和其他资产。|'
- en: Of course, you can use some other integrated development environment (IDE) or
    text editor for editing your code. I recommend VS Code because you can’t go wrong
    with it!
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您可以使用其他一些集成开发环境（IDE）或文本编辑器来编辑您的代码。我推荐 VS Code，因为它不会出错！
- en: 2.2 Getting the code
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 获取代码
- en: Numerous working example projects accompany this book. The code for each project
    is available on GitHub. You can clone or download the code repositories there
    to follow along with the examples in the book. I strongly recommend that you run
    these examples as you work through the book. That’s the best way for you to get
    practical experience and the most out of your learning.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本书附带许多工作示例项目。每个项目的代码都可在 GitHub 上找到。您可以在那里克隆或下载代码仓库，以跟随书中的示例。我强烈建议您在阅读本书时运行这些示例。这是您获得实践经验并充分利用学习效果的最佳方式。
- en: Following standard conventions, these examples are easy to run and all have
    a similar setup. Once you understand the fundamentals (which we’ll cover), you’ll
    find it easy to run the examples. The examples become more complex as we progress,
    but still, I’ll keep these as accessible as possible, explain how they work, and
    help you get them up and running.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 按照标准惯例，这些示例易于运行，并且都具有类似的设置。一旦您了解了基础知识（我们将介绍），您会发现运行这些示例很容易。随着我们的进展，示例会变得更加复杂，但我仍会尽量让它们易于访问，解释它们的工作原理，并帮助您启动和运行。
- en: To find the Bootstrapping Microservices organization on GitHub, point your web
    browser to [https://github.com/bootstrapping-microservices](https://github.com/bootstrapping-microservices).
    Here you will see a collection of code repositories organized by chapter, starting
    with the chapter-2 repository for this chapter.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到 GitHub 上的 Bootstrapping Microservices 组织，请将您的网络浏览器指向 [https://github.com/bootstrapping-microservices](https://github.com/bootstrapping-microservices)。在这里，您将看到按章节组织的代码仓库集合，从本章的
    chapter-2 仓库开始。
- en: Each chapter has its own code repository, for example, [https://github.com/
    bootstrapping-microservices/chapter-2](https://github.com/bootstrapping-microservices/chapter-2).
    Under each repository, you can find the code organized by the example project
    that is listed throughout that chapter. If you find any problems with the code,
    or you are having trouble getting it working, log an issue against the appropriate
    code repository on GitHub so that I can help you get it working.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 每章都有自己的代码仓库，例如，[https://github.com/bootstrapping-microservices/chapter-2](https://github.com/bootstrapping-microservices/chapter-2)。在每个仓库下，您可以找到按本章中列出的示例项目组织的代码。如果您发现代码有任何问题，或者您在尝试运行它时遇到困难，请在
    GitHub 上针对相应的代码仓库记录问题，以便我可以帮助您使其工作。
- en: 2.3 Why Node.js?
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 为什么选择 Node.js？
- en: In this book, we use Node.js to build our microservices. Why is that? One of
    the advantages of building microservices is that we can choose the tech stack
    that we like. I happen to like Node.js, but I also have other reasons for choosing
    it.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们使用Node.js来构建我们的微服务。为什么是Node.js呢？构建微服务的一个优点是我们可以选择我们喜欢的技术栈。我恰好喜欢Node.js，但我选择它的原因还有其他。
- en: Building our microservices with Docker (which we look at in chapter 3) means
    we can actually compose applications from multiple tech stacks. That might sound
    like it just makes things more confusing, and it probably does, but it gives us
    the ability to mix and match technologies. We can use this to ensure we are using
    the most appropriate stack that each situation demands.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker（我们将在第3章中探讨）构建我们的微服务意味着我们可以从多个技术栈中组合应用程序。这听起来可能像会让事情变得更复杂，而且可能确实如此，但它给了我们混合和匹配技术的能力。我们可以用它来确保我们使用的是每种情况下最合适的栈。
- en: Note Node.js is well suited to building microservices. It’s network orientated
    and high performance. We plan to build many services, so let’s be kind to ourselves
    and choose a platform that makes our work easier.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Node.js非常适合构建微服务。它是面向网络的，并且性能高。我们计划构建许多服务，所以让我们善待自己，选择一个让我们的工作变得更简单的平台。
- en: Node.js is also popular and well known. That might not sound like much, but
    it’s important because it means there’s an ecosystem of people, tools, and resources
    around Node.js. Having a big community to fall back on when you need help is important.
    That makes it easier to find assistance while learning, and it’s also good to
    have the support during ongoing software development.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js也非常流行且广为人知。这听起来可能不多，但很重要，因为它意味着围绕Node.js有一个由人、工具和资源组成的生态系统。在你需要帮助时有一个庞大的社区可以依靠是很重要的。这使得在学习过程中寻找帮助变得更加容易，而且在持续软件开发期间得到支持也是一件好事。
- en: Node.js is made for microservices. It’s all there in the name. *Node* implies
    it’s use for building nodes in distributed network-based applications. (JavaScript
    moved from the browser 11 years ago and has since established itself as an extremely
    competent server-side programming language.)
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js是为微服务而生的。从名字上就能看出这一点。"Node"暗示了它在构建基于分布式网络的应用程序节点方面的用途。（JavaScript从11年前开始从浏览器中移出，并从此确立了自己作为一款极富竞争力的服务器端编程语言的地位。）
- en: Node.js is made for creating small, high-performance and lightweight services,
    and it forgoes the baggage that comes with many other platforms. Building an HTTP
    server in Node.js is trivial. This makes it easy for us to bootstrap new microservices
    quickly. That’s a good motivator because we are planning to create many small
    services. Node.js is also convenient for this book because it means that you don’t
    need to spend a lot of time learning how to code a basic microservice and, as
    you’ll soon see, that we can build a microservice with a small amount of code
    using Node.js.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js是为创建小型、高性能和轻量级服务而生的，它摒弃了其他许多平台带来的负担。在Node.js中构建HTTP服务器是微不足道的。这使得我们能够快速启动新的微服务变得容易。这是一个很好的动力，因为我们计划创建许多小型服务。Node.js对这本书来说也很方便，因为它意味着你不需要花很多时间学习如何编写基本的微服务代码，而且正如你很快就会看到的，我们可以使用Node.js用很少的代码构建微服务。
- en: Using JavaScript promotes full-stack coding. These days there aren’t many places
    JavaScript doesn’t go. We can use it in our application’s backend to build microservices.
    We can use it in our web-based front end (that’s where JavaScript was born of
    course). Not only that, but we can also use JavaScript for desktop development
    (Electron), mobile development (Ionic), embedded development (IoT devices), and
    as I showed in my previous book, *Data Wrangling with JavaScript*, we can use
    JavaScript when working with data, a domain normally dominated by Python. Using
    JavaScript as much as possible means we can go anywhere in our application without
    triggering a mental context switch.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JavaScript可以促进全栈编程。如今，JavaScript几乎无处不在。我们可以在应用程序的后端使用它来构建微服务。我们也可以在基于Web的前端使用它（当然，JavaScript就是从这里诞生的）。不仅如此，我们还可以使用JavaScript进行桌面开发（Electron）、移动开发（Ionic）、嵌入式开发（物联网设备）。正如我在上一本书《用JavaScript进行数据处理》中展示的那样，我们还可以在处理数据时使用JavaScript，而数据领域通常由Python主导。尽可能多地使用JavaScript意味着我们可以在应用程序的任何地方自由穿梭，而不会触发心理上的上下文切换。
- en: The other big thing we get with Node.js is *npm,* the Node Package Manager,
    which is a command-line tool used to install Node.js code libraries. This isn’t
    specifically related to building microservices, but it is extraordinarily useful
    to have a fantastic package manager and a vast amount of open-source packages
    at our fingertips. My superpower as a developer is that I have over 350,000 code
    libraries (when it was reported in 2017) within easy access. Whatever I need to
    do it is often just a quick npm search away!
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 Node.js 获得的另一件大事是 *npm*，即 Node 包管理器，这是一个用于安装 Node.js 代码库的命令行工具。这并不特别与构建微服务相关，但拥有一个出色的包管理器和大量开源包在指尖上是非常有用的。作为开发者，我的超级能力是拥有超过
    350,000 个代码库（截至 2017 年报道时）并且可以轻松访问。无论我需要做什么，通常只需进行一次快速的 npm 搜索即可！
- en: Note Node.js is open source and you can find the code for it on GitHub at [https://github.com/nodejs/node.](https://github.com/nodejs/node)
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 Node.js 是开源的，你可以在 GitHub 上找到它的代码，网址为 [https://github.com/nodejs/node.](https://github.com/nodejs/node)
- en: What is npm?
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是 npm？
- en: Npm is the Node Package Manager. It is a command-line application that talks
    to the npm repository online and allows you to manage third-party packages in
    your Node.js project. Installing a readily available package is a fast way to
    solve a problem you’d otherwise have to write more code to achieve! You can search
    for packages on the npm website at [https://www.npmjs.com](https://www.npmjs.com).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Npm 是 Node 包管理器。它是一个与在线 npm 仓库通信的命令行应用程序，允许你在 Node.js 项目中管理第三方包。安装现成的包是快速解决你原本需要编写更多代码才能解决的问题的方法！你可以在
    npm 网站上搜索包，网址为 [https://www.npmjs.com](https://www.npmjs.com)。
- en: 2.4 Our philosophy of development
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4 我们的开发哲学
- en: 'Before we get into the coding, I want to brief you on my philosophy of development,
    which we’ll use throughout this book. You will see this manifested time and again,
    so a quick explanation is in order. I’ll sum up my philosophy of development with
    the following three points:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编码之前，我想简要介绍一下我的开发哲学，我们将在这本书的整个过程中使用它。你将看到这一点会反复出现，所以一个简短的解释是必要的。我将用以下三个要点总结我的开发哲学：
- en: Iterate
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代
- en: Keep it working
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持其工作状态
- en: Move from simple to complex
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从简单到复杂
- en: '*Iteration* is a key ingredient. I’m talking about personal iterations of coding
    and not the larger iterations in agile that are commonly known as sprints*.* We
    build the code for our application through a series of personal iterations. We’ll
    add code, iteration by iteration, as shown in figure 2.1\. Each iteration gives
    us feedback. Feedback allows us to discover when we are veering off track and
    to do immediate course corrections. Fast iteration allows us to align our work
    closely with our evolving goals.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*迭代* 是关键因素。我指的是个人编码迭代，而不是敏捷中通常被称为冲刺的更大迭代。我们通过一系列个人迭代构建应用程序的代码。我们将像图 2.1 所示那样，一次迭代一次地添加代码。每次迭代都会给我们反馈。反馈使我们能够发现我们是否偏离了轨道，并立即进行课程修正。快速迭代使我们能够将我们的工作与不断发展的目标紧密对齐。'
- en: Note Small, fast-paced increments of coding are essential for a productive software
    developer.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 小而快速的编码增量对于高效的软件开发者是必不可少的。
- en: At each iteration, we do a small amount of coding. How small? It depends on
    what we are doing and how difficult it is. But the key is that it should be small
    enough so that we can easily understand and test the code we just wrote.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次迭代中，我们进行少量的编码。多小？这取决于我们正在做什么以及有多难。但关键是它应该足够小，以至于我们可以轻松理解和测试我们刚刚编写的代码。
- en: Each iteration must produce working and tested code. This is the most important
    factor. Have you ever typed in a whole page of code then struggled for hours to
    get it working? When we work in small and well-tested iterations of code, the
    sum total at the end of a day’s coding is a large body of *working* code. You
    can see how this works in figure 2.1.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 每次迭代都必须产生可工作和经过测试的代码。这是最重要的因素。你有没有输入过一整页的代码然后挣扎数小时才让它工作？当我们以小而经过良好测试的代码迭代工作，一天编码结束时，累积的结果是一大块
    *可工作* 的代码。你可以在图 2.1 中看到这是如何工作的。
- en: '![](../Images/CH02_F01_Davis4.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F01_Davis4.png)'
- en: Figure 2.1 A series of small code changes results in a large body of working
    code.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 一系列小的代码更改最终产生大量可工作的代码。
- en: 'This notion of producing a large body of working code demonstrates my second
    point: *keep it working*. We will rarely get into trouble if we work in small,
    easily tested increments. When typing large amounts of code, we face many difficulties
    getting that code to work. Most likely we’ll have a large amount of broken (*non-working*)
    code. But even if the code does appear to work, it probably still harbors many
    “nasties” that are yet to be found.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 产生大量可工作代码的概念展示了我的第二个要点：**保持其工作状态**。如果我们以小、易于测试的增量工作，我们很少会遇到麻烦。当输入大量代码时，我们面临许多困难，使代码工作。很可能会有一大堆损坏（不可工作）的代码。但即使代码看起来似乎可以工作，它可能仍然隐藏着许多尚未发现的“坏东西”。
- en: Note Each small iteration of coding should produce working and tested code.
    The sum total of a series of such iterations results in a large amount of rock-solid
    code.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每次小的编码迭代都应该产生可工作且经过测试的代码。一系列此类迭代的总和将产生大量坚如磐石的代码。
- en: When we get into trouble, we can easily wind our code back to the previous iteration
    to restore it to working order. Because each iteration of our code is small, we
    don’t give up much progress when we need to revert back. Getting into trouble
    really isn’t any trouble at all!
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们遇到麻烦时，我们可以轻松地将代码回滚到先前的迭代，以恢复其工作状态。因为我们的代码迭代很小，所以在需要回滚时，我们不会失去太多进度。遇到麻烦根本就不是什么麻烦！
- en: Of course, restoration of the previous iteration implies that you are staging
    or committing your code to Git or some other form of version control. That should
    go without saying. Even if you aren’t using version control (you really should
    be), then it’s up to you to find another way to preserve the results of your iterations.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，恢复先前的迭代意味着您正在将代码提交到Git或其他形式的版本控制中。这一点不言而喻。即使您没有使用版本控制（您真的应该使用），那么找到另一种方式来保存迭代结果的责任就落在您身上。
- en: The third and final point in my philosophy of coding is to *start simple**.*
    We should start coding at the simplest possible starting point and iterate our
    application toward greater complexity. All applications grow complex over time;
    that’s unavoidable in the long run. But we definitely shouldn’t start with complexity.
    Don’t try and lay down a complex system all at once in the “big bang” style. That
    probably won’t work out well for you.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我的编程哲学中的第三和最后一个要点是**从简单开始**。我们应该从最简单的起点开始编码，并逐步迭代我们的应用程序以增加复杂性。所有应用程序都会随着时间的推移而变得复杂；从长远来看，这是不可避免的。但我们绝对不应该从复杂性开始。不要试图一次性以“大爆炸”的方式构建一个复杂的系统。这可能不会对您产生好的结果。
- en: Note Complexity is where applications *always* end up, but it doesn’t mean that’s
    where they have to start. Each code change should also be simple, avoiding too
    much complexity in any single iteration.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，复杂性是应用程序**总是**会达到的地方，但这并不意味着它们必须从那里开始。每次代码更改也应该简单，避免在任何单一迭代中引入过多的复杂性。
- en: Start with the simplest possible code, then iteration by iteration, you can
    build it up to something more complex. This process is illustrated in figure 2.2\.
    Don’t be too eager to take on complexity. Keep it simple for as long as you can.
    As our application becomes more and more complex, we need to bring in tools, techniques,
    processes, and patterns to help us manage that complexity.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 从最简单的代码开始，然后通过一次迭代一次迭代地构建，您可以将其构建得更加复杂。这个过程如图2.2所示。不要急于承担复杂性。尽可能保持简单。随着我们的应用程序变得越来越复杂，我们需要引入工具、技术、流程和模式来帮助我们管理这种复杂性。
- en: Building with microservices is one such tool for managing complexity. Again,
    any given microservice should be simple. It should be small. Making a small update
    to an existing microservice should be easy. And adding a new microservice to an
    existing application should be effortless. These statements are true, even when
    the application itself has become extremely complex.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用微服务构建是管理复杂性的一个工具。再次强调，任何给定的微服务都应该简单。它应该小巧。对现有微服务进行小更新应该容易。将新的微服务添加到现有应用程序中应该毫不费力。即使应用程序本身已经变得极其复杂，这些说法也是正确的。
- en: As our code becomes more complex, it doesn’t mean that our iterations need to
    be that way. We should strive to keep every modification to the code as simple
    as possible. Simple changes are easy to understand, simpler to test and to integrate
    into the application. All this increases the probability that the evolving system
    continues to behave as we had hoped it would.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的代码变得更加复杂，这并不意味着我们的迭代也需要这样。我们应该努力保持每次代码修改尽可能简单。简单的更改易于理解，更容易测试，并集成到应用程序中。所有这些都有助于提高正在发展的系统继续按我们希望的方式表现的概率。
- en: Tip When solving problems in complex applications, don’t be afraid to extract
    the problem from the application and reproduce it in a simpler environment. If
    you can isolate a problem with a smaller amount of code, that problem has less
    space in which to hide!
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：在解决复杂应用程序中的问题时，不要害怕将问题从应用程序中提取出来，并在更简单的环境中重现它。如果你能用更少的代码隔离一个问题，那么这个问题就有更少的空间来隐藏！
- en: If we encounter problems in a complex application that we can’t easily solve,
    we have a new option now. As indicated in figure 2.2, where the arrow goes from
    the end back to the beginning, at any time, we can extract our problematic code
    from the complex application and reproduce it in a simpler environment.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在一个复杂的应用程序中遇到难以解决的问题，我们现在有一个新的选择。如图2.2所示，箭头从末端回到起点，在任何时候，我们都可以从复杂的应用程序中提取出有问题的代码，并在一个更简单的环境中重现它。
- en: '![](../Images/CH02_F02_Davis4.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F02_Davis4.png)'
- en: Figure 2.2 Start simple and work up to complex through a series of small iterations
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 从简单开始，通过一系列小迭代逐步过渡到复杂
- en: Thankfully, this is fairly easy to do when coding in JavaScript. We might load
    our code in a unit test where we can repeatedly run the code to troubleshoot and
    fix it. If that’s not possible, we might extract the code to a separate Node.js
    project to isolate the problem and make it easier to solve. I often start up Data-Forge
    Notebook (an application that I built and have released to the public) to run
    isolated code and make it easier to solve problems.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，当用JavaScript编码时，这相当容易做到。我们可能会在单元测试中加载我们的代码，这样我们就可以反复运行代码来调试和修复它。如果这不可能，我们可能会将代码提取到一个单独的Node.js项目中，以隔离问题并使其更容易解决。我经常启动Data-Forge
    Notebook（一个我构建并公开发布的应用程序）来运行隔离的代码，使其更容易解决问题。
- en: But what can we do if the code isn’t so easy to extract? In that situation,
    what I like to do is teardown the application around the problematic code. Pull
    code out of the application (as much as is possible) until you have isolated the
    problem as best you can.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们无法轻松提取代码怎么办？在这种情况下，我喜欢做的就是围绕有问题的代码拆解应用程序。尽可能地将代码从应用程序中提取出来（直到你尽可能好地隔离了问题）。
- en: Why would we do this? It’s because when you have isolated a problem it has nowhere
    to hide. Finding problems is usually much more time-consuming than fixing them
    once they are found. So having faster ways to triangulate the location of problems
    in our code is one of the best ways for us to enhance our productivity. We’ll
    talk more about the debugging process and isolating problems in chapter 10.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么要这样做呢？这是因为当你隔离了一个问题，它就没有藏身之处。发现问题通常比发现问题后解决它们要花费更多的时间。因此，拥有更快的方法来定位我们代码中问题的位置，是我们提高生产力的最佳方式之一。我们将在第10章中更多地讨论调试过程和隔离问题。
- en: This is another thing to love about microservices. Our application is already
    compartmentalized, so it should be easy for us to tear out non-essential microservices.
    Having said that, eliminating code from your application in this way *is* an advanced
    technique and can easily result in a broken application!
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是我们喜欢微服务的一个原因。我们的应用程序已经模块化了，因此我们应该能够轻松地移除非必要的微服务。话虽如此，以这种方式从应用程序中删除代码确实是一种高级技术，很容易导致应用程序损坏！
- en: I’ve covered my philosophy of development here because I think it can help you
    to be a better and more productive developer. The evolution of our software in
    small and well-tested increments is the main goal. We are taking our code on a
    journey of iterations from working state to working state. At no time should our
    code ever be fundamentally broken.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里阐述我的开发哲学，因为我认为它可以帮助你成为一个更好、更高效的开发者。我们的软件通过小而经过充分测试的增量进行演变，这是我们的主要目标。我们将代码从一个工作状态迭代到另一个工作状态。我们的代码在任何时候都不应该出现根本性的错误。
- en: You’ll see this philosophy in action in this chapter and throughout the book.
    Start simple. Start small. Iterate with small changes. Keep it working. Before
    you know it, we’ll have built something big and complex! But that doesn’t happen
    all at once. It happens through a series of small changes that, taken together,
    add up to something huge.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在本章以及整本书中看到这一哲学在行动。从简单开始。从小处着手。通过小步迭代。保持其运作。不知不觉中，我们将构建出庞大而复杂的成果！但这并不是一蹴而就的。它是通过一系列小变化实现的，这些变化累积起来，最终成为巨大的成就。
- en: 2.5 Establishing our single-service development environment
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.5 建立我们的单一服务开发环境
- en: To create and work on a microservice, we need to set up our development environment.
    This provides a way for us to create and edit code and then run it to make sure
    it works. In this chapter, we’ll build a single microservice and we’ll run it
    using Node.js directly on our development workstation (or personal computer).
    We will edit our code using VS Code or some other IDE or text editor of your choice.
    Let’s begin by setting up our environment.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建和开发微服务，我们需要设置我们的开发环境。这为我们提供了一个创建和编辑代码的方法，然后运行它以确保它工作。在本章中，我们将构建一个单微服务，并直接在我们的开发工作站（或个人电脑）上使用
    Node.js 运行它。我们将使用 VS Code 或其他你选择的 IDE 或文本编辑器来编辑我们的代码。让我们从设置我们的环境开始。|
- en: Node.js itself is easy to install and run on any of the main operating systems,
    so you can choose Linux, Windows, or MacOS for the development of your microservice.
    (Your choices are summarized in table 2.2.)
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 本身易于在任何主要操作系统上安装和运行，因此你可以选择 Linux、Windows 或 MacOS 来开发你的微服务。（你的选择在表 2.2
    中总结。）|
- en: Running a single service under Node.js directly is fairly easy, as you’ll see
    in the coming sections of this chapter. But when it comes to developing and testing
    multiple microservices, which we’ll cover in chapter 4, things become more complicated.
    That’s when we’ll need to enlist the help of Docker (from chapter 3 and on). For
    now, let’s focus on running our microservice directly under Node.js in our chosen
    operating system.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node.js 下直接运行单个服务相当简单，正如你将在本章接下来的部分中看到的那样。但是，当涉及到开发测试多个微服务时，我们将在第 4 章中介绍，事情会变得更加复杂。那时，我们将需要借助
    Docker（从第 3 章开始）的帮助。现在，让我们专注于在我们的选择操作系统下直接在 Node.js 下运行我们的微服务。|
- en: Even after we start developing and testing multiple microservices, there will
    be times during development, testing, and troubleshooting that we’ll want to pull
    a single microservice out of the application and run it so that we can focus on
    just that isolated part without having to worry about the application and all
    the baggage that it brings. Having a single-service development environment isn’t
    just a convenient stepping stone in the early stages. It is useful to have on
    standby and ready to be called into action at any time during ongoing development.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们在开发、测试和调试多个微服务之后，在开发、测试和故障排除过程中，我们有时也会想要将单个微服务从应用程序中提取出来单独运行，以便我们可以专注于这个隔离的部分，而无需担心整个应用程序及其带来的所有负担。拥有一个单服务开发环境不仅是在早期阶段的一个方便的垫脚石，而且在持续开发过程中随时可以投入使用。|
- en: Table 2.2 Options for running Node.js
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.2 运行 Node.js 的选项|
- en: '| Platform | Notes |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 平台 | 备注 |'
- en: '| Linux | Node.js was built for Linux, so it works pretty well there!For this
    book, I demonstrate most commands under Ubuntu Linux. If you also run Ubuntu or
    another variant of Linux, you are well placed to follow along with the examples
    in the book. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| Linux | Node.js 是为 Linux 构建的，因此在 Linux 上运行得相当不错！在本章中，我将大多数命令演示在 Ubuntu Linux
    上。如果你也在使用 Ubuntu 或其他 Linux 变体，你将能够很好地跟随书中的示例。|'
- en: '| Windows | Node.js also works well under Windows. In fact, I do most of my
    day-to-day development, testing, and troubleshooting with Windows. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| Windows | Node.js 也在 Windows 下运行良好。实际上，我大部分日常的开发、测试和故障排除都是使用 Windows。|'
- en: '| MacOS | Node.js also works well under MacOS. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| MacOS | Node.js 也在 MacOS 下运行良好。|'
- en: Note When working with just Node.js, you can use it on any platform, and there
    really isn’t one that is better than any other!
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 备注：当仅使用 Node.js 时，你可以在任何平台上使用它，实际上并没有一个比其他任何更好的平台！|
- en: '![](../Images/CH02_F03_Davis4.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH02_F03_Davis4.png)|'
- en: Figure 2.3 Our single-service development environment for chapter 2
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 第 2 章的单服务开发环境|
- en: 'Figure 2.3 gives you an indication of what our single-microservice development
    environment looks like. We will edit our code in VS Code or an alternative editor.
    Our microservice project is a Node.js project with JavaScript code. (I’ll show
    you how to create this soon.) Executing our project under Node.js produces a running
    instance of our microservice. All of this is running on our development workstation
    on our host operating system of choice: Linux, Windows, or MacOS.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 展示了我们的单微服务开发环境的样子。我们将使用 VS Code 或其他替代编辑器编辑我们的代码。我们的微服务项目是一个 Node.js 项目，包含
    JavaScript 代码。（我很快会展示如何创建它。）在 Node.js 下运行我们的项目会产生一个正在运行的微服务实例。所有这些都在我们选择的宿主操作系统上运行：Linux、Windows
    或 MacOS。|
- en: 2.5.1 Installing Git
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.1 安装 Git|
- en: The example projects and code for this book are in GitHub under the Bootstrapping
    Microservices organization (see the links in section 2.2). Figure 2.4 shows how
    each code repository is structured. Each subdirectory (example-1, example-2, and
    so forth) are working projects that you can run yourself to follow along with
    the book (assuming you don’t want to type in all the code yourself).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的示例项目和代码位于 GitHub 上的 Bootstrapping Microservices 组织下（参见第 2.2 节中的链接）。图 2.4
    展示了每个代码仓库的结构。每个子目录（example-1、example-2 等等）都是你可以自己运行以跟随本书的项目（假设你不想自己输入所有代码）。
- en: '![](../Images/CH02_F04_Davis4.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH02_F04_Davis4.png)'
- en: Figure 2.4 Each example project in the GitHub repository is a complete working
    project that you can run for yourself.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 GitHub 仓库中的每个示例项目都是一个完整的可运行项目，你可以自己运行。
- en: The simplest way to get the code is to *download* it as a zip file from GitHub.
    To do this, you should go to the code repository (e.g., the repository chapter-2
    for chapter 2) and look for the Clone or Download button. Click it and then choose
    Download ZIP.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 获取代码最简单的方式是从 GitHub 下载它作为 zip 文件。为此，你应该前往代码仓库（例如，第 2 章的 chapter-2 仓库）并寻找克隆或下载按钮。点击它，然后选择下载
    ZIP。
- en: The best way to get the code, of course, is to use Git to *clone* the code repository.
    To do this, you first need to install Git. You might already have it installed,
    for instance, if you (like me) use it for everyday work. Or you might be running
    a variant of Linux that comes with Git pre-installed. On MacOS, you might have
    Xcode installed, which comes with Git.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，获取代码的最佳方式是使用 Git 来 *克隆* 代码仓库。为此，你首先需要安装 Git。你可能已经安装了它，例如，如果你（像我一样）用它来日常工作。或者你可能运行的是预装了
    Git 的 Linux 变体。在 MacOS 上，你可能已经安装了 Xcode，它自带了 Git。
- en: 'How do we know if we have Git installed? To find out which version of Git you
    have (if any), open a terminal (on Windows open the Command Prompt, or even better
    install Windows Terminal from the Microsoft Store) and run the following command:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何知道我们是否安装了 Git？要找出你安装了哪个版本的 Git（如果有），打开一个终端（在 Windows 上打开命令提示符，或者更好的是安装来自微软商店的
    Windows Terminal）并运行以下命令：
- en: '[PRE0]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If Git is already installed, you’ll see its version number, which is something
    like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Git 已经安装，你会看到它的版本号，可能像这样：
- en: '[PRE1]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you don’t already have Git, installing it isn’t difficult. See the Git website
    at [https://git-scm.com](https://git-scm.com) and follow the instructions there
    to download and install on your platform.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有 Git，安装它并不困难。请访问 Git 网站 [https://git-scm.com](https://git-scm.com)，并按照那里的说明在你的平台上下载和安装。
- en: New to using the command line?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你是命令行的新手吗？
- en: Using the command line is one of the best and most productive ways to work as
    a software developer. Using UIs and visual editors is great for doing the most
    common everyday tasks, but for more complex or customized tasks, we need to be
    comfortable using the command line. If you are new to it, consider first doing
    a tutorial for using the command line for your operating system.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令行是作为软件开发者工作最优秀和最高效的方式之一。使用用户界面和可视化编辑器对于完成最常见的日常任务来说很棒，但对于更复杂或定制的任务，我们需要习惯使用命令行。如果你是初学者，建议首先为你的操作系统做一次命令行教程。
- en: 2.5.2 Cloning the code repo
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.2 克隆代码仓库
- en: 'With Git installed, you can now clone the code repository for each chapter
    of this book. For example, at this point, you should clone the repo for chapter
    2 so you can follow along with this chapter:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了 Git 后，你现在可以克隆这本书每一章的代码仓库。例如，在这个时候，你应该克隆第 2 章的仓库，以便你可以跟随这一章：
- en: git clone [https://github.com/bootstrapping-microservices/chapter-2.git](https://github.com/bootstrapping-microservices/chapter-2.git)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: git clone [https://github.com/bootstrapping-microservices/chapter-2.git](https://github.com/bootstrapping-microservices/chapter-2.git)
- en: This command gets a copy of the code repository from GitHub and places it on
    your local hard drive (in the current working directory) under a directory named
    chapter-2\. I won’t explain how to clone a repository again in future chapters.
    But at the start of each new chapter, I’ll show you where to get the code for
    that chapter, then you can use Git to get your own copy. Feel free to return here
    at any time for a reminder of how to use Git.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令从 GitHub 获取代码仓库的副本，并将其放置在你的本地硬盘上（在当前工作目录下）的名为 chapter-2 的目录下。我不会在未来章节中再次解释如何克隆仓库。但在每个新章节的开始，我会告诉你如何获取该章节的代码，然后你可以使用
    Git 获取自己的副本。随时回来这里提醒如何使用 Git。
- en: 2.5.3 Getting Visual Studio (VS) Code
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.3 获取 Visual Studio (VS) Code
- en: I use Visual Studio (VS) Code for all my coding. I’m recommending it to you
    because I think it’s a great environment for editing code. You can find the download
    and installation instructions for Windows, Linux, and MacOS on the VS Code website
    at
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用 Visual Studio (VS) Code 进行所有编码。我推荐它给你，因为它是一个编辑代码的绝佳环境。你可以在 VS Code 网站上找到
    Windows、Linux 和 MacOS 的下载和安装说明。
- en: '[https://code.visualstudio.com](https://code.visualstudio.com)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://code.visualstudio.com](https://code.visualstudio.com)'
- en: I like VS Code because it’s lightweight, has great performance, and is configurable.
    It’s also commonly used for Node.js and JavaScript projects. You don’t need any
    extra plugins for this book, but it’s worth noting, there is a vast range of easily
    installable plugins for different programming languages and tasks. You can also
    customize VS Code for all your development needs.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢 VS Code，因为它轻量级、性能出色且可配置。它也常用于 Node.js 和 JavaScript 项目。这本书不需要任何额外的插件，但值得注意的是，有大量易于安装的插件适用于不同的编程语言和任务。你还可以根据你的所有开发需求自定义
    VS Code。
- en: Of course, if you already have your own favorite IDE or text editor, feel free
    to use it, as it doesn’t really make any difference. When I mention VS Code throughout
    the book, you’ll just have to pretend it’s your preferred text editor instead!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你已经有了自己偏好的 IDE 或文本编辑器，请随意使用，因为这实际上并不会造成任何区别。当我在整本书中提到 VS Code 时，你只需假装它是你偏好的文本编辑器即可！
- en: 2.5.4 Installing Node.js
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.4 安装 Node.js
- en: 'To run our microservice, we need Node.js. That’s something we can’t do without
    because the example microservices in this book are Node.js projects. All the code
    examples are written in JavaScript, which runs on Node.js. If you already have
    Node.js installed, you can open a terminal and check the version with the following
    commands:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行我们的微服务，我们需要 Node.js。这是我们不能没有的东西，因为这本书中的示例微服务都是 Node.js 项目。所有的代码示例都是用 JavaScript
    编写的，它运行在 Node.js 上。如果你已经安装了 Node.js，你可以打开一个终端，使用以下命令检查版本：
- en: '[PRE2]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These are the versions I currently use for node and npm. You can use these versions
    or later ones.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我目前用于 node 和 npm 的版本。你可以使用这些版本或更新的版本。
- en: Note We use the `npm` command for installing third-party packages. When you
    install Node.js, you get npm as well.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们使用 `npm` 命令来安装第三方包。当你安装 Node.js 时，你也会得到 npm。
- en: Installing Node.js for any platform is straightforward. To install Node.js,
    see the Node.js website at [https://nodejs.org](https://nodejs.org) for download
    and installation instructions. It’s not difficult and you shouldn’t have any issues.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何平台上安装 Node.js 都很简单。要安装 Node.js，请访问 Node.js 网站 [https://nodejs.org](https://nodejs.org)
    以获取下载和安装说明。这并不困难，你不应该有任何问题。
- en: If you already have Node.js installed and want to get a newer version, or if
    you’d like to manage multiple versions of Node.js, it’s worth looking at NVM described
    in the second sidebar that follows.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经安装了 Node.js 并且想要获取一个新版本，或者如果你想管理多个版本的 Node.js，那么查看接下来的第二个侧边栏中描述的 NVM 是值得的。
- en: 'After installing Node.js, open a terminal and double-check that it installed
    OK. To do this, print the version numbers:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Node.js 后，打开一个终端并再次确认它已正确安装。为此，请打印版本号：
- en: '[PRE3]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now that we have Node.js installed, we are ready to build and run our first
    microservice.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了 Node.js，我们准备好构建和运行我们的第一个微服务了。
- en: It’s important to know what version you are using!
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 了解你正在使用哪个版本是很重要的！
- en: Using the `--version` argument is a good way to check if you have something
    installed, but it’s also important to know what version you have. When you are
    working on a real system, it’s crucial that you use the same version in development
    as you use in production. That’s the best way to know that your code will run
    in production.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `--version` 参数是一个检查你是否已安装某些内容的不错方法，但了解你拥有哪个版本也很重要。当你在一个真实系统中工作时，确保你在开发和生产中使用相同的版本是至关重要的。这是确保你的代码将在生产中运行的最好方式。
- en: Need to run different versions of Node.js?
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 需要运行不同版本的 Node.js 吗？
- en: What about if you need to run multiple versions of Node.js? This can happen
    quite easily, actually.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要运行多个版本的 Node.js 呢？这实际上很容易发生。
- en: Say you are maintaining or have to work on multiple production applications
    that are built with different versions of Node.js. Or maybe that you are just
    working on a single application, but it has been in development for quite some
    time, and different microservices are on different versions of Node.js. In these
    cases, I highly recommend you use nvm (the Node Version Manager) to install different
    versions of Node.js and switch between them.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在维护或需要处理多个使用不同版本的 Node.js 构建的生产应用程序。或者，也许你只是在单个应用程序上工作，但它已经开发了一段时间，不同的微服务使用不同的
    Node.js 版本。在这些情况下，我强烈建议你使用 nvm（Node 版本管理器）来安装不同的 Node.js 版本并在它们之间切换。
- en: 'There are actually two different applications called nvm and which one you
    choose depends on your operating system. See the following links for setup instructions:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上存在两个不同的应用程序，分别称为 nvm 和，你选择哪一个取决于你的操作系统。请参阅以下链接以获取设置说明：
- en: 'For Linux and MacOS, you want this one: [https://github.com/nvm-sh/nvm](https://github.com/nvm-sh/nvm).'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 Linux 和 MacOS，你需要这个：[https://github.com/nvm-sh/nvm](https://github.com/nvm-sh/nvm)。
- en: 'For Windows, use: [https://github.com/coreybutler/nvm-windows](https://github.com/coreybutler/nvm-windows).'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 Windows，请使用：[https://github.com/coreybutler/nvm-windows](https://github.com/coreybutler/nvm-windows)。
- en: This isn’t for the faint of heart! You must be proficient at using the command
    line to install this software.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是给胆小的人做的！你必须熟练使用命令行来安装此软件。
- en: 2.6 Building an HTTP server for video streaming
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.6 构建视频流 HTTP 服务器
- en: Now that we have our development environment, we can build our first microservice.
    This isn’t a difficult project, and we are just building it to illustrate the
    process of creating a basic microservice. It’s the first step in creating our
    example microservices application FlixTube. You can follow along with the code
    while reading this chapter, typing in the code as you see it, or you can read
    it first and then try out the example projects that are available in the chapter
    2 repository on GitHub.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的开发环境，我们可以构建我们的第一个微服务。这不是一个困难的项目，我们只是构建它来展示创建基本微服务的过程。这是创建我们的示例微服务应用程序
    FlixTube 的第一步。你可以在阅读本章时跟随代码，逐行输入你看到的代码，或者你可以先阅读它，然后尝试 GitHub 上第 2 章仓库中可用的示例项目。
- en: The microservice we are building is a simple video-streaming service. Streaming
    video might sound difficult and it is something that can become complicated in
    a real production application. But we are starting with something that’s much
    simpler. You might be surprised at just how little code we actually need to create
    this.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在构建的微服务是一个简单的视频流服务。流媒体视频可能听起来很复杂，在真实的生产应用程序中，这确实可能变得复杂。但我们是从小事做起。你可能会惊讶于我们实际上需要多少代码来创建这个服务。
- en: Figure 2.5 shows the output for the end result of this chapter’s project. Our
    microservice delivers streaming video to the web browser via port 3000 and the
    route *video*. We can watch the video directly through our browser by pointing
    it at http://localhost:3000/video.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 显示了本章项目最终结果的输出。我们的微服务通过端口 3000 和路由 *video* 将流媒体视频发送到网络浏览器。我们可以直接通过浏览器观看视频，只需将其指向
    http://localhost:3000/video。
- en: '![](../Images/CH02_F05_Davis4.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH02_F05_Davis4.png)'
- en: Figure 2.5 Watching the streaming video from our microservice directly in Chrome
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 在 Chrome 中直接观看我们的微服务的流媒体视频
- en: In figure 2.5, you can see we use Chrome to watch the video. The sample video
    we are using was downloaded from [https://sample-videos.com](https://sample-videos.com).
    Here, we used the shortest possible video, but feel free to download one of the
    larger sample videos for your own testing.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在图 2.5 中，你可以看到我们使用 Chrome 来观看视频。我们使用的示例视频是从 [https://sample-videos.com](https://sample-videos.com)
    下载的。在这里，我们使用了尽可能短的视频，但你可以自由下载较大的示例视频进行自己的测试。
- en: 'To create our microservice, we must go through the following steps:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建我们的微服务，我们必须经过以下步骤：
- en: Create a Node.js project for our microservice.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的微服务创建一个 Node.js 项目。
- en: Install Express and create a simple HTTP server.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 Express 并创建一个简单的 HTTP 服务器。
- en: Add an HTTP GET route /video that retrieves the streaming video.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 HTTP GET 路由 /video 来检索流媒体视频。
- en: After creating this basic first microservice, we’ll talk briefly about how we
    can configure our microservices. Then we’ll cover some fundamentals for production
    and development setup.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建这个基本的第一个微服务之后，我们将简要讨论我们如何配置我们的微服务。然后我们将介绍一些生产环境和开发设置的基本原则。
- en: 2.6.1 Creating a Node.js project
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.6.1 创建 Node.js 项目
- en: 'Before we can start writing code, we need a Node.js project where our code
    can live. The project we’ll soon create is shown in figure 2.6\. This is a basic
    Node.js project with a single entry point: the script file index.js. You can also
    see package.json and package-lock.json, which are the files that track the dependencies
    and metadata for our project. The dependencies themselves are installed under
    the node_modules directory. Let’s create this project!'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写代码之前，我们需要一个Node.js项目，我们的代码可以存储在其中。我们即将创建的项目如图2.6所示。这是一个基本的Node.js项目，具有单个入口点：脚本文件index.js。您还可以看到package.json和package-lock.json，这些文件跟踪我们项目的依赖项和元数据。依赖项本身安装在node_modules目录下。让我们创建这个项目吧！
- en: '![](../Images/CH02_F06_Davis4.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH02_F06_Davis4.png)'
- en: Figure 2.6 Our first Node.js project
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 我们的第一个Node.js项目
- en: Definition A *Node.js project* contains the source code and configuration for
    our Node.js application. It’s where we edit the code that creates the features
    of our microservice.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 A *Node.js项目* 包含了我们的Node.js应用程序的源代码和配置。这是我们编辑创建微服务功能的代码的地方。
- en: 'If you are creating a project from scratch (and not just running the code from
    GitHub), you must first create a directory for the project. You can do this from
    the terminal on Linux and MacOS using the `mkdir` command:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是从头创建项目（而不仅仅是运行GitHub上的代码），您必须首先为项目创建一个目录。您可以在Linux和MacOS的终端中使用`mkdir`命令来完成此操作：
- en: '[PRE4]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you are working on Windows, you can instead use the `md` command:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用Windows，您可以使用`md`命令代替：
- en: '[PRE5]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now change into your new directory using the `cd` command:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用`cd`命令切换到您的新目录：
- en: '[PRE6]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You are now ready to create a *stub* Node.js project. What this means is that
    we are creating our package.json file. We can do this using the npm `init` command:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以创建一个 *stub* Node.js项目。这意味着我们正在创建我们的package.json文件。我们可以使用npm `init`命令来完成此操作：
- en: '[PRE7]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `-y` argument means that we don’t have to answer any interactive questions
    while initializing our project. That simply makes it a little bit faster to create
    our project.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`-y` 参数意味着在初始化我们的项目时，我们不需要回答任何交互式问题。这仅仅使得创建我们的项目稍微快一点。'
- en: After running `npm init`, we now have a package.json file with all its fields
    set to defaults. You can see an example of this in listing 2.1\. Because the fields
    in this file have default values, you might want to come back later and set these
    to values more appropriate to your project. For the moment though, we’ll leave
    these as they are.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `npm init` 后，我们现在有一个所有字段都设置为默认值的package.json文件。您可以在列表2.1中看到一个示例。由于此文件中的字段具有默认值，您可能希望在以后回来并将这些值设置为更适合您项目的值。不过，目前我们将保持这些值不变。
- en: Listing 2.1 The empty Node.js package file we just generated
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.1 我们刚刚生成的空Node.js包文件
- en: '[PRE8]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ① The package name. It defaults to the name of the directory that contains the
    package; in this case, my-new-project because we initialized it in the my-new-project
    directory we just created.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ① 包名。默认为包含包的目录名；在这种情况下，my-new-project，因为我们是在我们刚刚创建的my-new-project目录中初始化的。
- en: ② These fields are important if you publish this package to [https://www.npmjs.com.](https://www.npmjs.com)
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ② 如果您要将此包发布到[https://www.npmjs.com.](https://www.npmjs.com)，这些字段就很重要。
- en: ③ npm scripts go here. We’ll talk more about this later in the chapter.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ③ npm 脚本放在这里。我们将在本章后面更详细地讨论这一点。
- en: ④ These fields are important if you publish this package to [https://www.npmjs.com.](https://www.npmjs.com)
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 如果您要将此包发布到[https://www.npmjs.com.](https://www.npmjs.com)，这些字段就很重要。
- en: After creating your Node.js project, I encourage you to open the folder in VS
    Code and explore your new project by opening the package.json file and examining
    it. With the project opened in VS Code, you are now ready to start adding some
    code to your project.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建您的Node.js项目后，我鼓励您在VS Code中打开文件夹，通过打开package.json文件并检查它来探索您的新项目。在VS Code中打开项目后，您现在就可以开始向项目中添加一些代码了。
- en: Package.json vs. package-lock.json
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: package.json 与 package-lock.json
- en: Although package.json is automatically generated and updated by npm, it can
    also be edited by hand. That way you can manually change the metadata and npm
    module dependencies for your Node.js project.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然package.json是由npm自动生成和更新的，但您也可以手动编辑它。这样，您可以手动更改Node.js项目的元数据和npm模块依赖项。
- en: Usually, package.json doesn’t specify exact version numbers for dependencies
    (although it can if you want it to). Instead, package.json generally sets the
    minimum version for each dependency, and it can also set a range of versions.
    In addition, package.json only tracks top-level dependencies for the project.
    You don’t need to specify dependencies of dependencies; that’s handled automatically
    for you. This makes package.json smaller, more concise, and therefore more human-readable.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，package.json不会指定依赖项的确切版本号（尽管如果你想的话，也可以指定）。相反，package.json通常为每个依赖项设置最小版本，并且也可以设置版本范围。此外，package.json仅跟踪项目的顶级依赖项。你不需要指定依赖项的依赖项；这会自动为你处理。这使得package.json更小、更简洁，因此更易于人类阅读。
- en: The problem with package.json is that you and your colleagues can end up running
    different versions of dependencies. Even worse, you could be running different
    versions compared to what’s in production. That’s because package.json usually
    doesn’t specify exact versions, so depending on when you invoke `npm install`,
    you can get different versions from everyone else. This is a recipe for chaos!
    Indeed, it makes it difficult to replicate production issues because you aren’t
    guaranteed to be able to reproduce the exact configuration that is running in
    production.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: package.json的问题在于你和你的同事可能会运行不同版本的依赖项。更糟糕的是，你运行的版本可能与生产环境中的版本不同。这是因为package.json通常不指定确切的版本，因此根据你何时调用`npm
    install`，你可能会从其他人那里得到不同的版本。这是一场混乱的预兆！确实，这使得重现生产问题变得困难，因为你不能保证能够重现生产环境中运行的精确配置。
- en: Package-lock.json was introduced in npm version 5 to solve this problem. It
    is a generated file and is not designed to be hand edited. Its purpose is to track
    the entire tree of dependencies (including dependencies of dependencies) and the
    exact version of each dependency.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: package-lock.json是在npm版本5中引入的，用于解决这个问题。它是一个生成的文件，并不设计用于手动编辑。它的目的是跟踪整个依赖项树（包括依赖项的依赖项）以及每个依赖项的确切版本。
- en: You should commit package-lock.json to your code repository. Sharing this file
    with teammates and the production environment is the best way to make sure that
    everyone has the same configuration for their copy of the project.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该将package-lock.json提交到你的代码仓库。与队友和生产环境共享此文件是确保每个人对其项目副本都有相同配置的最佳方式。
- en: 2.6.2 Installing Express
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.6.2 安装Express
- en: To stream video from our microservice, we’ll make it an HTTP server (also known
    as a *web server*). That is to say that it will respond to HTTP requests from
    a browser, in this case, a browser’s request to play streaming video. To implement
    our HTTP server, we’ll use Express.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从我们的微服务中流式传输视频，我们将将其作为一个HTTP服务器（也称为*web服务器*）。也就是说，它将响应对浏览器的HTTP请求，在这种情况下，是浏览器请求播放流媒体视频。为了实现我们的HTTP服务器，我们将使用Express。
- en: Note Express is the de facto standard framework for building HTTP servers on
    Node.js. It’s easier for us to do this using Express than it is to use the low-level
    Node.js API.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Express是Node.js上构建HTTP服务器的既定标准框架。使用Express比使用低级Node.js API更容易做到这一点。
- en: Express is the most popular code library for building HTTP servers on Node.js.
    You can find documentation and examples for it on the Express web site at [http://expressjs
    .com/](http://expressjs.com/). While there, I’d encourage you to explore the many
    other features of Express as well. Of course, we could build an HTTP server directly
    on Node.js without Express, but Express allows us to do this at a higher level
    of abstraction, with less code, and without the nuts and bolts code we’d otherwise
    need using the low-level Node.js API.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Express是Node.js上构建HTTP服务器的最受欢迎的代码库。你可以在Express网站上找到它的文档和示例，网址为[http://expressjs.com/](http://expressjs.com/)。在那里，我鼓励你探索Express的许多其他功能。当然，我们可以在没有Express的情况下直接在Node.js上构建HTTP服务器，但Express允许我们在更高的抽象级别上以更少的代码、无需使用低级Node.js
    API所需的螺丝钉代码来完成这项工作。
- en: 'Using Express is also a good excuse for us to learn how to install an npm package
    for use in our microservice. npm is the package manager for Node.js, and it puts
    at our fingertips a whole world of packages. This includes many libraries and
    frameworks like Express that we can use to quickly and easily do a whole range
    of jobs when coding. Otherwise, we’d have to write a lot more code (and probably
    cause a load of bugs in the process) to achieve the same effect. We can install
    Express from the terminal using the command `npm install` as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Express 也是一个很好的理由，让我们学习如何在微服务中安装 npm 包。npm 是 Node.js 的包管理器，它为我们提供了整个包的世界。这包括许多库和框架，如
    Express，我们可以使用它们在编码时快速轻松地完成一系列工作。否则，我们可能需要编写更多的代码（并且在过程中可能引发大量错误）才能达到相同的效果。我们可以使用以下命令从终端安装
    Express：`npm install`。
- en: '[PRE9]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Running this command installs the express package into our project. The `--save`
    argument causes the dependency to be added to and tracked in the package.json
    file. Note that `--save` isn’t actually necessary anymore. In older versions of
    Node.js, this was required; these days, it’s the default. I’ve included `--save`
    explicitly so that I can highlight what it does, but you don’t actually have to
    use this anymore.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令会将 express 包安装到我们的项目中。`--save` 参数会导致依赖项被添加到并跟踪在 package.json 文件中。请注意，`--save`
    现实中并不是必需的。在 Node.js 的旧版本中，这是必需的；如今，这是默认设置。我明确地包含了 `--save` 以便突出其功能，但您实际上不再需要使用它。
- en: '![](../Images/CH02_F07_Davis4.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH02_F07_Davis4.png)'
- en: Figure 2.7 Note where the express subdirectory is installed into the node_modules
    directory.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7 注意 express 子目录安装到 node_modules 目录的位置。
- en: You can see the result of our package install in figure 2.7 and listing 2.2\.
    Figure 2.7 shows that an express subdirectory was created in the node_modules
    directory of our Node.js project. You’ll also note that many other packages have
    been installed alongside Express. These other packages are the dependencies for
    Express, and npm has automatically installed these for us.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在图 2.7 和列表 2.2 中看到我们的包安装结果。图 2.7 显示，在 Node.js 项目的 node_modules 目录中创建了一个 express
    子目录。您还会注意到，与 Express 一起安装了许多其他包。这些其他包是 Express 的依赖项，npm 已经为我们自动安装了它们。
- en: Listing 2.2 shows our updated package.json file after installing Express. The
    difference from listing 2.1 is that we now have a `dependencies` field that includes
    Express version 4.17.1\. This identifies the version of Express that our Node.js
    project depends on.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.2 展示了安装 Express 后更新的 package.json 文件。与列表 2.1 的区别在于，我们现在有一个包含 Express 版本
    4.17.1 的 `dependencies` 字段。这标识了我们的 Node.js 项目所依赖的 Express 版本。
- en: 'Notice also in the title of listing 2.2 that there is a reference to the actual
    file that exists in the chapter-2 code repository on GitHub. This shows you where
    to find the working copy of that file. In this case, it’s the chapter-2/example-1/package.json.
    If you go to the chapter-2 repository ([https://github.com/bootstrapping-microservices/
    chapter-2](https://github.com/bootstrapping-microservices/chapter-2)) and then
    look in the example-1 subdirectory, you’ll see the file package .json. It’s the
    same file that is shown in this code listing. You can find this file directly
    by putting this link in your web browser:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 还请注意，在列表 2.2 的标题中，有一个指向 GitHub 上 chapter-2 代码库中实际存在的文件的引用。这显示了您可以在哪里找到该文件的副本。在这种情况下，它是
    chapter-2/example-1/package.json。如果您访问 chapter-2 仓库 ([https://github.com/bootstrapping-microservices/chapter-2](https://github.com/bootstrapping-microservices/chapter-2))
    并在 example-1 子目录中查找，您将看到文件 package.json。这正是本代码列表中显示的文件。您可以通过将此链接放入您的网络浏览器中直接找到此文件：
- en: '[https://github.com/bootstrapping-microservices/chapter-2/blob/master/example-1/
    package.json](https://github.com/bootstrapping-microservices/chapter-2/blob/master/example-1/package.json).'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/bootstrapping-microservices/chapter-2/blob/master/example-1/package.json](https://github.com/bootstrapping-microservices/chapter-2/blob/master/example-1/package.json)。'
- en: Most of the listings in this book follow this convention. They show a snippet
    of a file (or in this case, a complete version) that is part of a working example
    project on GitHub. To see this file in context, you can follow the reference to
    its location in GitHub or in the copy of the code repository that you cloned locally.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的大多数列表都遵循此约定。它们显示了一个文件（或在这种情况下，一个完整版本）的片段，该文件是 GitHub 上一个工作示例项目的一部分。要查看此文件在上下文中的情况，您可以遵循其
    GitHub 位置的引用或您本地克隆的代码库副本中的引用。
- en: From there, you can either just inspect the code as it exists within its project,
    or rather, you can (you should) run the code because every example in this book
    (in this case, example-1 in chapter-2) is a working project that you can easily
    get running for yourself to cement into place what you are learning.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，你可以要么检查代码在项目中的存在，要么（你应该）运行代码，因为这本书中的每个示例（在这种情况下，第 2 章的 example-1）都是一个可以轻松运行的项目，你可以自己运行它来巩固你所学的内容。
- en: Listing 2.2 The package file with Express installed (chapter-2/example-1/package.json)
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.2 安装了 Express 的包文件（chapter-2/example-1/package.json）
- en: '[PRE10]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ① Version 4.17.1 for the express package that I installed was current when this
    book was written.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ① 当这本书编写时，我安装的 express 包的版本是 4.17.1。
- en: Having the dependencies tracked through the package.json file means you can
    easily pass your project and code to other programmers (your teammates, for example)
    so that they can easily replicate your work. It also means I can make this code
    available to you and that you can easily get it working.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 package.json 文件跟踪依赖项意味着你可以轻松地将你的项目和代码传递给其他程序员（例如你的队友），以便他们可以轻松地复制你的工作。这也意味着我可以将此代码提供给你，并且你可以轻松地让它运行起来。
- en: 'For example, say you want to get example-1 working. First you need to clone
    the chapter-2 code repository as was shown in section 2.6.2, then from the terminal,
    change the directory to the code repository:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你想让 example-1 运行。首先，你需要像第 2.6.2 节中展示的那样克隆 chapter-2 代码仓库，然后从终端，切换到代码仓库目录：
- en: '[PRE11]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now change the directory into the particular example that you want to get running.
    In this case, it’s example-1:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在切换到你想运行的特定示例目录。在这种情况下，是 example-1：
- en: '[PRE12]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then you can use npm to install all the dependencies:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用 npm 安装所有依赖项：
- en: '[PRE13]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The command `npm install` by itself (not specifying any particular package)
    installs all the dependencies listed in package.json. In this case, it’s only
    Express that is listed so only that is installed (plus its dependencies). For
    other examples in this book, there will be more dependencies. But we still only
    need to invoke `npm install` once per example, and that’s enough to install everything
    you need to run each example project.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 命令 `npm install`（不指定任何特定包）会安装 package.json 中列出的所有依赖项。在这种情况下，只列出了 Express，因此只安装了它（及其依赖项）。对于本书中的其他示例，可能会有更多的依赖项。但我们仍然只需要在每个示例中调用一次
    `npm install`，这就足够安装运行每个示例项目所需的所有内容。
- en: 2.6.3 Creating the Express boilerplate
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.6.3 创建 Express 模板
- en: Before we add video streaming to our microservice, we must first create the
    standard Express boilerplate HTTP server. Listing 2.3 is the customary Hello World
    example that you get by following the official Express getting started guide (available
    at [https://expressjs.com/](https://expressjs.com/)).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将视频流添加到我们的微服务之前，我们必须首先创建标准的 Express 模板 HTTP 服务器。列表 2.3 是官方 Express 入门指南（可在
    [https://expressjs.com/](https://expressjs.com/) 获取）中获得的传统 Hello World 示例。
- en: This is only a small amount of code, but it’s the simple starting point that
    we need for this project. You should now create an index.js file in your Node.js
    project and type in the code. If that’s too much work, then just open example-1
    from the chapter-2 repository and examine the pre-cooked index.js file you’ll
    find there.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一小段代码，但这是我们项目需要的简单起点。你现在应该在 Node.js 项目中创建一个 index.js 文件，并输入这段代码。如果觉得这项工作太多，那么只需打开
    chapter-2 仓库中的 example-1，检查你将找到的预配置的 index.js 文件。
- en: The code in listing 2.3 starts a web server, albeit the simplest possible web
    server. It uses Express’, `get` function to define a route handler that returns
    the string `Hello World!`. The `listen` function is then called to start this
    HTTP server, listening for HTTP requests on port 3000.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.3 中的代码启动了一个网络服务器，尽管是最简单的网络服务器。它使用 Express 的 `get` 函数定义了一个路由处理程序，返回字符串 `Hello
    World!`。然后调用 `listen` 函数来启动这个 HTTP 服务器，监听端口 3000 上的 HTTP 请求。
- en: Listing 2.3 A minimal Express web server (chapter-2/example-1/index.js)
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.3 一个最小的 Express 网络服务器（chapter-2/example-1/index.js）
- en: '[PRE14]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ① Loads the Express library for use in our code
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ① 加载 Express 库以在我们的代码中使用
- en: ② Creates an instance of an Express app
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ② 创建一个 Express 应用实例
- en: ③ Our HTTP server will listen on port 3000.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们的服务器将在端口 3000 上监听。
- en: ④ Creates a handler for the main HTTP route
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 创建主 HTTP 路由的处理程序
- en: ⑤ The handler prints Hello World! in the web browser.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 处理程序在网页浏览器中打印 Hello World！
- en: ⑥ Initiates the HTTP server
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 启动 HTTP 服务器
- en: ⑦ The callback prints a message when the server has started.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 当服务器启动时，回调会打印一条消息。
- en: We called the file index.js; why is that? This is the standard name for the
    main entry point of a Node.js application. It’s simply a convention that it is
    called index.js. We could just as easily have called it something else, like main.js
    or server.js. The choice is up to you. By calling it index.js, we are giving it
    a name that many other Node.js developers will immediately recognize as being
    the *main* file.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将文件命名为 index.js；为什么是这个名字呢？这是 Node.js 应用程序主入口点的标准名称。它只是一个约定，所以叫 index.js。我们也可以很容易地将其命名为其他名称，比如
    main.js 或 server.js。选择权在你。通过将其命名为 index.js，我们给它起了一个许多其他 Node.js 开发者会立即认出为 *主*
    文件的名字。
- en: The port number allows us to run multiple HTTP servers on the same computer.
    The servers can each have their own port number so they won’t conflict with each
    other. The choice of port 3000 is another convention. It’s customary to set your
    Node.js application to listen on port 3000, but in production, we’ll often want
    to set this to the standard HTTP port 80\. Later on, we’ll see how to set the
    port number as a configuration option supplied to the microservice when it’s booted
    up.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 端口号允许我们在同一台计算机上运行多个 HTTP 服务器。每个服务器都可以有自己的端口号，这样它们就不会相互冲突。选择端口 3000 是另一个约定。通常，我们会将
    Node.js 应用程序设置为监听端口 3000，但在生产环境中，我们通常会将其设置为标准的 HTTP 端口 80。稍后，我们将看到如何将端口号设置为在微服务启动时提供的配置选项。
- en: We could have chosen another port and, if you are already running something
    else on port 3000, you might have to do so. For example, if port 3000 doesn’t
    work for you, try changing it to a different number, say port 4000.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以选择另一个端口，如果你已经在端口 3000 上运行了其他东西，你可能需要这样做。例如，如果你发现端口 3000 不适用于你，尝试将其更改为不同的数字，比如端口
    4000。
- en: We’ll use the series of port numbers starting at 4000 (4000, 4001, and so forth)
    later, when we run multiple microservices at the same time. Now we are ready to
    run this ultra simple web server.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用从 4000 开始的一系列端口号（4000、4001 等等），当我们同时运行多个微服务时。现在我们准备好运行这个超简单的 Web 服务器了。
- en: What is index.js?
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: index.js 是什么？
- en: By convention, index.js is the JavaScript file that is the entry point for the
    Node.js application. When trying to understand an existing Node.js project, index.js
    is the place you should start.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，index.js 是 Node.js 应用的入口点 JavaScript 文件。在尝试理解现有的 Node.js 项目时，index.js 是你应该开始的地方。
- en: 2.6.4 Running our simple web server
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.6.4 运行我们的简单 Web 服务器
- en: To test our fledgling HTTP server, we’ll run it from the terminal. First, we
    need to make sure we are in the same directory that contains the index.js file
    from listing 2.3\. If you built the project yourself from scratch, you’ll have
    to change to the directory that you created. For example
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试我们的初出茅庐的 HTTP 服务器，我们将从终端运行它。首先，我们需要确保我们处于包含列表 2.3 中的 index.js 文件的同一目录。如果你是从头开始构建项目的，你将需要切换到你创建的目录。例如
- en: '[PRE15]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Otherwise, if you are using the code from the chapter-2 GitHub repository,
    you should change to the example-1 directory:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，如果你正在使用第 2 章GitHub 仓库中的代码，你应该切换到 example-1 目录：
- en: '[PRE16]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now you can use Node.js to run the JavaScript code and start the HTTP server:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以使用 Node.js 来运行 JavaScript 代码并启动 HTTP 服务器：
- en: '[PRE17]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'What we are doing here is running Node.js with `index.js` as the argument.
    We are telling Node.js to run our script file. Node.js executes the JavaScript
    code in this file, and if successful, we’ll see the following output in our terminal:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是用 `index.js` 作为参数运行 Node.js。我们正在告诉 Node.js 运行我们的脚本文件。Node.js 执行该文件中的
    JavaScript 代码，如果成功，我们将在终端看到以下输出：
- en: '[PRE18]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now we can test that this has worked. Open your web browser and point it at
    http://localhost:3000\. You should see the `Hello World` message displayed.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以测试一下这是否成功了。打开你的网页浏览器，将其指向 http://localhost:3000。你应该会看到显示的 `Hello World`
    消息。
- en: 'We can also use cURL, which you might have if you are working on Linux or MacOS
    (and Windows, if you have Git Bash), as a quick means for testing HTTP endpoints.
    With your HTTP server already running in one terminal, open a new terminal and
    use cURL to hit your endpoint:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 cURL，如果你在 Linux 或 MacOS（如果你有 Git Bash，Windows 也可以）上工作，那么你可能已经安装了它，作为测试
    HTTP 端点的一种快速手段。在你的 HTTP 服务器已经在另一个终端运行的情况下，打开一个新的终端，并使用 cURL 来访问你的端点：
- en: '[PRE19]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You should see output like this:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到如下输出：
- en: '[PRE20]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note Using cURL means you can run quick tests like this from the command line
    without having to open your web browser.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：使用 cURL 意味着你可以从命令行运行这样的快速测试，而无需打开你的网页浏览器。
- en: We now have a basic HTTP server running and it’s time for us to add streaming
    video to it. When you are ready to stop your HTTP server, go back to the terminal
    where it is running and press Ctrl-C to quit the Node.js application.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个基本的 HTTP 服务器正在运行，是时候向其中添加流式视频了。当你准备好停止你的 HTTP 服务器时，回到它运行的终端并按 Ctrl-C
    退出 Node.js 应用程序。
- en: 2.6.5 Adding streaming video
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.6.5 添加流式视频
- en: In listing 2.3, we only had a single HTTP route handler that returned Hello
    World. Now we’ll change this and create a REST API for streaming video to the
    browser.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 2.3 中，我们只有一个返回“Hello World”的 HTTP 路由处理程序。现在我们将改变这一点，并为浏览器创建一个流式视频的 REST
    API。
- en: A REST API (often just called an API) is a representational state transfer (REST)
    application programming interface (API). The name makes it sound complicated,
    but it really isn’t. A REST API in its simplest sense is just a collection of
    HTTP route handlers that interface with systems and logic running in the backend.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: REST API（通常只称为 API）是一种表示状态转移（REST）应用程序编程接口（API）。这个名字听起来很复杂，但实际上并不复杂。在 simplest
    sense，REST API 只是一组 HTTP 路由处理程序，它们与后端运行的系统和服务进行交互。
- en: Often routes in REST APIs return data, but we’ll add a new route that returns
    streaming video. You can see what it looks like in figure 2.8\. The diagram shows
    how our HTTP server will read the video from the filesystem and deliver it to
    the web browser via port 3000 and the video route.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 通常 REST API 的路由会返回数据，但我们将添加一个新的路由，返回流式视频。你可以在图 2.8 中看到它的样子。该图显示了我们的 HTTP 服务器如何从文件系统中读取视频，并通过端口
    3000 和视频路由将其传递给网页浏览器。
- en: '![](../Images/CH02_F08_Davis4.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH02_F08_Davis4.png)'
- en: Figure 2.8 How the web browser interacts with our microservice through the video
    route
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8 网页浏览器通过视频路由与我们的微服务交互
- en: We define the new video route as shown in listing 2.4\. If you are following
    along with the code, you can update the Express boilerplate HTTP server that you
    created earlier. Otherwise, you can open example-2 from the chapter-2 repository
    in VS Code to see how the updated index.js looks.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了新的视频路由，如列表 2.4 所示。如果你正在跟随代码，你可以更新你之前创建的 Express 模板 HTTP 服务器。否则，你可以打开章节-2
    存储库中的 example-2，在 VS Code 中查看更新的 index.js 的样子。
- en: Listing 2.4 reads a video from the local filesystem and streams it to the browser.
    This is a simple starting point that does just what we need, which is streaming
    video, the core feature for our microservices application FlixTube. The video
    itself can be found in the videos subdirectory under example-2\. Feel free to
    inspect the video yourself before trying to run this code. We’ll use this example
    video throughout the book for testing so you will come to know it very well!
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.4 从本地文件系统中读取视频并将其流式传输到浏览器。这是一个简单的起点，只做了我们需要的，那就是流式视频，这是我们的微服务应用 FlixTube
    的核心功能。视频本身可以在 example-2 目录下的 videos 子目录中找到。在尝试运行此代码之前，请随意检查视频。我们将在这个示例视频中整本书进行测试，所以你会非常熟悉它！
- en: Listing 2.4 Simple streaming video server with Node.js (chapter-2/example-2/index.js)
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.4 使用 Node.js 的简单流式视频服务器（chapter-2/example-2/index.js）
- en: '[PRE21]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ① Loads the (built-in) fs library so we can use the Node.js filesystem API.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ① 加载（内置）fs 库，以便我们可以使用 Node.js 文件系统 API。
- en: ② Defines the HTTP route for streaming video. This is a REST API for streaming
    video!
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: ② 定义流式视频的 HTTP 路由。这是一个流式视频的 REST API！
- en: ③ The path of the video file that we’ll stream to the browser
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们将流式传输到浏览器的视频文件路径
- en: ④ Retrieves the video file size. We’ll encode this in the HTTP header as a response
    to the web browser.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 获取视频文件大小。我们将将其编码在 HTTP 头部作为对网页浏览器的响应。
- en: ⑤ Handles any errors that may occur
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 处理可能发生的任何错误
- en: ⑥ Sends a response header to the web browser, including the content length and
    mime type
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 向网页浏览器发送响应头，包括内容长度和 MIME 类型
- en: ⑦ Streams the video to the web browser. Yes it’s this simple!
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 将视频流式传输到网页浏览器。是的，就这么简单！
- en: The code in listing 2.4 is an example of Node.js streaming. This is a more complicated
    topic than we have time to get into here, but suffice it to say that here we are
    opening a readable stream from the video file. Then we are piping the stream to
    our HTTP response (look for the call to the `pipe` function).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.4 中的代码是 Node.js 流的一个示例。这是一个比我们在这里有时间深入探讨的更复杂的话题，但简单来说，我们在这里是从视频文件中打开一个可读流。然后我们将流通过管道传输到我们的
    HTTP 响应（查找对 `pipe` 函数的调用）。
- en: 'We have created a conduit through which to stream the video byte by byte to
    the browser. We set up this pipeline for video streaming and then let Node.js
    and Express take care of the rest. Node.js and Express make this easy! To run
    this code, first change to the example-2 subdirectory:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个通道，通过它可以将视频字节逐字节流送到浏览器。我们为视频流设置了这条管道，然后让Node.js和Express处理其余部分。Node.js和Express使这变得很容易！要运行此代码，首先切换到example-2子目录：
- en: '[PRE22]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then install the dependencies:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 然后安装依赖项：
- en: '[PRE23]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now start the first iteration of our streaming video microservice like this:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在以这种方式启动我们的流媒体视频微服务的第一个迭代：
- en: '[PRE24]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We can now point our browser to http://localhost:3000/video to watch the video.
    It’s going to look similar to what was shown earlier in figure 2.5.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将浏览器指向http://localhost:3000/video来观看视频。它看起来将与图2.5中显示的相似。
- en: Note Don’t use cURL for testing at this point; it doesn’t work well with streaming
    video. It’s going to print a massive stream of garbage into your terminal if you
    do that. When viewing the output of JSON REST APIs, however, cURL is really useful,
    so it’s advantageous to have in your toolbox.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在此阶段不要使用cURL进行测试；它与流媒体视频配合得不好。如果你这样做，它将在你的终端中打印出大量的垃圾信息。然而，当查看JSON REST API的输出时，cURL非常有用，所以将其放在工具箱中是有利的。
- en: To test the code for this book, I’ve used the Chrome web browser. I discovered
    that such simple video streaming doesn’t work under the Safari web browser. For
    details on how to make video streaming work for Safari, see my blog post on “The
    Data Wrangler” at [http://mng.bz/l1Xd](http://mng.bz/l1Xd). We’ll talk more about
    ways we can test our microservices in chapter 8.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试本书的代码，我使用了Chrome网络浏览器。我发现这样的简单视频流在Safari网络浏览器下无法工作。有关如何在Safari中使视频流工作的详细信息，请参阅我在“The
    Data Wrangler”博客上的文章“[http://mng.bz/l1Xd](http://mng.bz/l1Xd)”。我们将在第8章中更多地讨论我们可以测试微服务的方法。
- en: 2.6.6 Configuring our microservice
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.6.6 配置我们的微服务
- en: At this point, it’s worthwhile to spend a moment thinking about how we can configure
    our microservices. This is an important concern and will help us make better use
    of the microservices that we create. In future chapters, we’ll see examples of
    how we can wire together microservices using their configurations. For now, though,
    let’s look at a simple example to demonstrate how to configure a microservice.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，花一点时间思考我们如何配置我们的微服务是值得的。这是一个重要的关注点，并将帮助我们更好地利用我们创建的微服务。在未来的章节中，我们将看到如何使用它们的配置将微服务连接起来的示例。然而，现在，让我们看看一个简单的例子，以展示如何配置一个微服务。
- en: We need a way to configure our microservice so it knows the port number to use
    when starting the HTTP server. There are a number of techniques we might use to
    configure our microservice, such as configuration files and command-line arguments.
    These techniques work, but another has emerged as the standard way to configure
    a microservice, and it is well supported by the tools we will be using.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方法来配置我们的微服务，使其知道在启动HTTP服务器时使用哪个端口号。我们可以使用多种技术来配置微服务，例如配置文件和命令行参数。这些技术是有效的，但另一种技术已成为配置微服务的标准方式，并且得到了我们将使用的工具的良好支持。
- en: We will configure our microservices using *environment variables*. Specifically,
    in this case, we need a single environment variable to set the port number for
    the HTTP server. Figure 2.9 shows how we will wire the PORT environment variable
    to our microservice.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用*环境变量*来配置我们的微服务。具体来说，在这种情况下，我们需要一个单独的环境变量来设置HTTP服务器的端口号。图2.9显示了我们将如何将PORT环境变量连接到我们的微服务。
- en: '![](../Images/CH02_F09_Davis4.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F09_Davis4.png)'
- en: Figure 2.9 Using the PORT environment variable to configure our microservice
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9 使用PORT环境变量配置我们的微服务
- en: Using environment variables to configure our code in Node.js is quite easy.
    We simply access the appropriately named field of process.env. You can see how
    this works in listing 2.5, where our code uses `process.env.PORT` to get the value
    for the port number. The code throws an error if the PORT environment variable
    is not supplied. I like to add this error checking so that the microservice clearly
    states the configuration it is expecting. This means we can’t accidentally start
    our microservice in production without configuring it. If we try that, the microservice
    will refuse to start, and it’s going to tell us the reason why.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node.js 中使用环境变量配置我们的代码相当简单。我们只需访问 process.env 中相应命名的字段。您可以在列表 2.5 中看到它是如何工作的，我们的代码使用
    `process.env.PORT` 来获取端口号的值。如果未提供 PORT 环境变量，代码会抛出错误。我喜欢添加这种错误检查，这样微服务就可以清楚地声明它期望的配置。这意味着我们不可能在不配置的情况下意外启动我们的微服务。如果我们这样做，微服务将拒绝启动，并且会告诉我们原因。
- en: I think it’s better that the microservice refuse to start rather than operate
    on potentially the wrong configuration simply because we forgot to configure it.
    The microservice then shows us how to fix the problem. This means we don’t have
    to go rooting around in the code to figure it out.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为微服务拒绝启动比仅仅因为忘记配置而操作可能错误的配置要好。微服务随后会向我们展示如何解决问题。这意味着我们不必在代码中四处寻找以解决问题。
- en: Listing 2.5 Configuring a microservice (extract from chapter-2/example-3/index.js)
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.5 配置微服务（摘自第 2 章第 3 个示例的 index.js）
- en: '[PRE25]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ① Throws an error when the required environment variable isn’t supplied. If
    not specified, you could also choose a default value.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: ① 当所需的 environment variable 未提供时抛出错误。如果没有指定，您也可以选择一个默认值。
- en: ② Copies the environment variable to a global variable for easy access
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: ② 将环境变量复制到全局变量以方便访问
- en: ③ Starts the HTTP server using the port number that was input to the microservice
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 使用输入到微服务的端口号启动 HTTP 服务器
- en: 'Now let’s run this code:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们运行这段代码：
- en: '[PRE26]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Oops. We forgot to configure the required environment variable, and our microservice
    has thrown the error. How did we forget so soon about the environment variable
    we were supposed to configure? No problem. The error log conveniently gives us
    a helpful message telling us how to fix the problem:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀。我们忘记配置所需的 environment variable，我们的微服务已经抛出了错误。我们怎么这么快就忘记了应该配置的环境变量？没问题。错误日志方便地提供了一个有用的消息，告诉我们如何修复问题：
- en: '[PRE27]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now we must set the PORT environment variable before trying to run the code
    again. On Linux and MacOS, we’ll set it using this command:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须在再次尝试运行代码之前设置 PORT 环境变量。在 Linux 和 MacOS 上，我们将使用以下命令来设置它：
- en: '[PRE28]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If working on Windows, do this instead:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 Windows 上工作，请这样做代替：
- en: '[PRE29]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Run the file again:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行文件：
- en: '[PRE30]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now it should work correctly. We set the PORT environment variable so the microservice
    knows which port number to use for its HTTP server. To test this, we can point
    our browser at http://localhost:3000/video. We should see our video playing the
    same as before.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该可以正常工作了。我们设置了 PORT 环境变量，这样微服务就知道它应该使用哪个端口号来运行其 HTTP 服务器。为了测试这一点，我们可以将浏览器指向
    http://localhost:3000/video。我们应该看到我们的视频像之前一样播放。
- en: Now that we can configure the port for the HTTP server, we can easily start
    multiple separate microservices directly on our development workstation. We can
    only do that if they have different port numbers. Because we can set the port
    number, we can easily start each microservice using a different port.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以为 HTTP 服务器配置端口，因此我们可以在我们的开发工作站上直接轻松启动多个独立的微服务。只有当它们具有不同的端口号时，我们才能这样做。因为我们可以设置端口号，所以我们很容易使用不同的端口启动每个微服务。
- en: Configuring our microservices through environment variables is important and
    is something we’ll use again in future chapters. For example, we are going to
    need it when we add the database to our application (chapter 4) and when we connect
    our microservices to a message queue server (chapter 5).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 通过环境变量配置我们的微服务非常重要，并且这是我们将在未来的章节中再次使用的方法。例如，当我们向应用程序添加数据库（第 4 章）以及将我们的微服务连接到消息队列服务器（第
    5 章）时，我们将需要它。
- en: We can also use environment variables to pass secret and sensitive data into
    a microservice (e.g., the password for our database). We need to treat this information
    carefully, and we shouldn’t store it in the code where everyone in the company
    can see it. In chapter 11*,* we’ll touch on the important issue of managing sensitive
    configuration such as passwords and API keys.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用环境变量将秘密和敏感数据传递给微服务（例如，我们数据库的密码）。我们需要小心处理这些信息，并且不应该将其存储在任何人都可以看到的代码中。在第11章中，我们将讨论管理敏感配置（如密码和API密钥）的重要问题。
- en: 2.6.7 Setting up for production
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.6.7 生产环境设置
- en: So far, we set up our microservice to run on our development workstation. That’s
    all well and good, but before we get to the fun stuff (Docker, Kubernetes, and
    Terraform), we need to know how to set up our microservice to run in the production
    environment.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经设置了我们的微服务在我们的开发工作站上运行。这很好，但在我们进入有趣的部分（Docker、Kubernetes和Terraform）之前，我们需要知道如何设置我们的微服务以在生产环境中运行。
- en: When I say *production environment*, you might be wondering what I’m talking
    about. Production environment simply means our *customer-facing* environment.
    That’s where our application is hosted so it can be accessed by our customers.
    For this book, our production environment is Kubernetes, and we are gearing up
    to run our application in a Kubernetes cluster to make it publicly accessible.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 当我说 *生产环境* 时，你可能想知道我在说什么。生产环境简单地说就是我们的 *面向客户* 的环境。那就是我们的应用程序托管的地方，以便我们的客户可以访问它。对于这本书，我们的生产环境是Kubernetes，我们正在准备在我们的Kubernetes集群中运行我们的应用程序，使其公开可访问。
- en: 'I’ve already said that to get an existing Node.js project ready to run, you
    must first install dependencies like this:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经说过，为了使现有的Node.js项目准备好运行，你必须首先安装依赖项，如下所示：
- en: '[PRE31]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Well, to get our microservice ready to run in production, we need to use a
    slightly different version of this command:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，为了使我们的微服务准备好在生产环境中运行，我们需要使用这个命令的稍作不同的版本：
- en: '[PRE32]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We added the argument `--only=production` to install only dependencies that
    are required in production. This is important because when creating a Node.js
    project, we’ll usually have a bunch of so-called *dev dependencies* that we only
    need for development and we don’t want to install these into our production environment.
    You haven’t seen an example of dev dependencies yet, but you will see it coming
    up in the next section. Up until now, we have run our HTTP server on our dev workstation
    like this:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了参数 `--only=production` 来安装仅在生产环境中需要的依赖项。这很重要，因为当我们创建Node.js项目时，我们通常会有一些所谓的
    *开发依赖项*，我们只需要在开发中使用，我们不想将这些安装到我们的生产环境中。你还没有看到开发依赖项的示例，但在下一节中你将看到。到目前为止，我们像这样在我们的开发工作站上运行我们的HTTP服务器：
- en: '[PRE33]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'That’s OK, but we’d like to run it using the following convention:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可以的，但我们希望使用以下惯例来运行它：
- en: '[PRE34]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Running the command `npm start` is the conventional way to start a Node.js application.
    This is a special case of an npm *script* that we can use to start our application.
    In listing 2.6, you can see that we’ve updated the package.json file to include
    a start script under the `scripts` field. This simply runs Node.js with `index.js`
    as the argument.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 运行命令 `npm start` 是启动Node.js应用程序的常规方法。这是我们用来启动应用程序的npm *脚本*的一个特例。在列表2.6中，你可以看到我们已经更新了package.json文件，在`scripts`字段下添加了一个start脚本。这仅仅是通过`index.js`作为参数运行Node.js。
- en: No surprises here, but the nice thing about this convention is that for almost
    any Node.js project (at least those that follow the convention), you can run `npm
    start` and you don’t have to actually know if the main file is called index.js
    or if it has some other name. You also don’t need to know if the application takes
    any special command-line arguments, because these can be recorded here as well.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 没有惊喜，但这个惯例的好处是，对于几乎任何Node.js项目（至少是遵循这个惯例的项目），你可以运行 `npm start`，而无需知道主文件是否名为index.js或是否有其他名称。你也不需要知道应用程序是否接受任何特殊的命令行参数，因为这些也可以在这里记录。
- en: This gives you one command to remember regardless of which project you are looking
    at and how the particular application is started. It makes it much easier to understand
    how to use any Node.js project, even those created by other people.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这为你提供了一个无论你查看哪个项目以及特定应用程序如何启动都要记住的命令。这使得理解如何使用任何Node.js项目变得容易得多，即使是其他人创建的项目。
- en: Listing 2.6 Adding a start script to package.json (chapter-2/example-1/package.json)
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.6 向package.json添加start脚本（第2章/示例-1/package.json）
- en: '[PRE35]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: ① Adding the npm start script to package.json lets us run this project with
    “npm start”.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: ① 将npm start脚本添加到package.json中，让我们可以用“npm start”运行此项目。
- en: Try this for yourself. You’ll note in listing 2.6 that I updated the example-3
    package.json to include an npm start script. To try it out, change your directory
    to example-3 and run `npm start` (make sure you run `npm install` to get the dependencies
    first or execute `npm install --only=production` if you only want the production
    dependencies).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下。你会在2.6列表中注意到，我已经更新了example-3的package.json文件，以包含一个npm start脚本。要尝试它，请将你的目录更改为example-3，并运行`npm
    start`（确保你先运行`npm install`来获取依赖项，或者如果你只想获取生产依赖项，则执行`npm install --only=production`）。
- en: From now on in this book, we’ll use `npm start` to run each of our microservices
    in production. In the future, I’ll refer to this as running our microservice in
    *production mode*. It’s worth remembering this command because so many other Node.js
    applications you’ll encounter in the wild conform to this convention, and it’s
    a shortcut you can remember that will help you get other people’s code working.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在起，在这本书中，我们将使用`npm start`来在生产环境中运行我们的每个微服务。将来，我会将这称为以*生产模式*运行我们的微服务。记住这个命令是值得的，因为你在野外遇到的许多其他Node.js应用程序都遵循这个约定，这是一个你可以记住的快捷方式，有助于你使其他人的代码工作。
- en: We are going to use the commands we’ve just learned for getting our microservice
    working in production. These are the commands we’ll use to get our microservice
    running in Docker in chapter 3, so we’ll come back to these then.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用刚刚学到的命令来使我们的微服务在生产环境中运行。这些命令将在第3章中用来在我们的Docker中运行微服务，所以到时候我们会回到这些命令。
- en: Another useful command you might have heard of is `npm test`. This is the command
    that is conventionally used by a Node.js project to initiate automated testing.
    It’s something we’ll come back to and investigate in chapter 8.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个你可能听说过的有用命令是`npm test`。这是Node.js项目传统上用来启动自动化测试的命令。我们将在第8章中回到并调查这个问题。
- en: 2.6.8 Live reloading for fast iteration
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.6.8 实时重新加载以实现快速迭代
- en: Now that we have a convenient way to set up and run our microservice in production,
    we can also look for a better way to run it in development. Live reloading our
    code as we are editing helps streamline our development workflow and fosters productivity.
    As we change code, we can immediately see the results of executing the code. Whether
    the result is an error or output from a successful run doesn’t matter. What matters
    is that we get fast feedback that shortens the cycle time for our iterations and
    increases the pace of our development.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了方便的方式来设置和运行我们的微服务在生产环境中，我们也可以寻找更好的方法来在开发中运行它。在我们编辑代码时实时重新加载我们的代码有助于简化我们的开发工作流程并促进生产力。当我们更改代码时，我们可以立即看到代码执行的结果。无论结果是错误还是成功的输出都不重要。重要的是我们得到了快速反馈，这缩短了我们的迭代周期，并加快了我们的开发速度。
- en: In this section, we’ll get set up for live reload. This way of working is illustrated
    in figure 2.10, and it’s important because it automates the restarting of our
    microservice (during development). This helps us cycle more quickly through our
    personal coding iterations, see instant results, and become more productive. Iteration
    and fast feedback are crucial in my philosophy of development as I pointed out
    in section 2.4\. (Live reload also works well with test-driven development, which
    we’ll talk about in chapter 8.)
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将为实时重新加载做好准备。这种工作方式如图2.10所示，它非常重要，因为它自动化了我们的微服务（在开发过程中的）重启。这有助于我们更快地通过个人编码迭代，看到即时结果，并提高生产力。迭代和快速反馈是我开发哲学中的关键，正如我在第2.4节中指出的。（实时重新加载也与测试驱动开发（TDD）很好地配合，我们将在第8章中讨论。）
- en: '![](../Images/CH02_F10_Davis4.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F10_Davis4.png)'
- en: Figure 2.10 Setting up for live reload helps us to be more productive.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10 设置实时重新加载有助于我们提高生产力。
- en: To create our live reload pipeline, we’ll install a package called nodemon.
    Figure 2.10 shows how it works. We use nodemon to run our microservice, and it
    automatically watches for code changes in our project. When a code change is detected,
    nodemon automatically restarts our microservice for us, saving us the effort of
    doing so manually.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建我们的实时重新加载管道，我们将安装一个名为nodemon的包。图2.10显示了它是如何工作的。我们使用nodemon来运行我们的微服务，并且它自动监视我们项目中的代码更改。当检测到代码更改时，nodemon会自动为我们重启微服务，节省我们手动重启的麻烦。
- en: 'This might not sound like it does much at all, but I have found that it makes
    for a fast and fluid development cycle. Once you have tried it you might wonder
    how you ever did without it in the first place. We can install nodemon in our
    Node.js project as follows:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能听起来并没有做什么，但我发现它使得开发周期变得快速而流畅。一旦你尝试过它，你可能会 wonder 你最初是如何没有它也能做到的。我们可以在 Node.js
    项目中按照以下方式安装 nodemon：
- en: '[PRE36]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note that this time we use the `--save-dev` argument. This makes npm install
    this package as a *dev dependency* rather than a *normal dependency*. I mentioned
    this in the previous section when talking about installing production only dependencies
    for running in the production environment. Here you can see why it’s useful for
    installing a dependency that you want to have in development but excluded from
    production.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这次我们使用了 `--save-dev` 参数。这使得 npm 将此包作为 *dev dependency* 而不是 *normal dependency*。我在上一节讨论仅在生产环境中运行的生产只依赖项安装时提到了这一点。在这里，你可以看到为什么安装一个你希望在开发中拥有但排除在生产中的依赖项是有用的。
- en: We use nodemon during development, but there’s no need to have it installed
    in production where, at best, it’s just useless bloat and, at worst, it might
    be a security concern. Not that I have any reason to believe nodemon in particular
    has any security issues. But generally, the less we install in our production
    environment, the better. This is a topic we’ll return to in chapter 11 when we
    talk about security.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在开发期间使用 nodemon，但在生产环境中不需要安装它，在那里，它至多是无用的冗余，在最坏的情况下，可能还存在安全风险。我并没有理由相信 nodemon
    特定有任何安全问题。但一般来说，我们在生产环境中安装的越少，越好。这是一个我们将在第 11 章讨论安全问题时再次讨论的话题。
- en: 'This means that when we run `npm install --only=production`, then the packages
    we install to help with development, like nodemon, will be excluded. Normally,
    when we run our Node.js code, we do it like this:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当我们运行 `npm install --only=production` 时，我们将排除帮助我们进行开发的包，如 nodemon。通常，当我们运行
    Node.js 代码时，我们这样做：
- en: '[PRE37]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now that we are going to be using nodemon instead, we’ll replace `node` with
    `nodemon` and run it like this:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用 nodemon，我们将用 `nodemon` 替换 `node` 并这样运行它：
- en: '[PRE38]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: What’s this `npx` command that’s suddenly appeared? This is a useful command
    that comes with Node.js and allows us to run installed dependencies from the command
    line. Before `npx` was added to Node.js, we used to install modules like nodemon
    globally. Now we can run tools like this directly from the current project’s dependencies.
    This really helps us use the right versions of modules and stops our system from
    getting cluttered up by globally installed modules.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这是什么突然出现的 `npx` 命令？这是一个随 Node.js 一起提供的有用命令，它允许我们从命令行运行已安装的依赖项。在 `npx` 被添加到 Node.js
    之前，我们通常全局安装模块，如 nodemon。现在我们可以直接从当前项目的依赖中运行这样的工具。这真有助于我们使用模块的正确版本，并防止我们的系统因全局安装的模块而变得杂乱无章。
- en: Stopping the microservice running under nodemon is the same as when it’s running
    under Node.js. Just type Ctrl-C at the terminal where it’s running, and the microservice
    stops.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 停止在 nodemon 下运行的微服务与在 Node.js 下运行时相同。只需在运行它的终端中键入 Ctrl-C，微服务就会停止。
- en: I usually like to wrap nodemon in an npm script called *start:dev*. This is
    a personal convention of mine, but I find that many other developers have something
    similar, often with a different name. You can see how our updated project setup
    looks in listing 2.7\. At the bottom of the package.json, nodemon has been added
    as a `devDependency`, and you can see our new script, start:dev, in the `scripts`
    section.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我通常喜欢将 nodemon 包裹在一个名为 *start:dev* 的 npm 脚本中。这是我的个人约定，但我发现许多其他开发者也有类似的做法，通常只是名字不同。你可以在列表
    2.7 中看到我们更新后的项目设置。在 package.json 的底部，nodemon 已被添加为 `devDependency`，你可以在 `scripts`
    部分看到我们新的脚本，start:dev。
- en: Listing 2.7 Adding a start script for development (chapter-2/example-3/package.json)
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.7 为开发添加启动脚本（chapter-2/example-3/package.json）
- en: '[PRE39]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: ① Normal start script starts the service in our production or testing environment.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: ① 正常的启动脚本在生产和测试环境中启动服务。
- en: ② Our new start:dev script starts the service in our development environment.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们新的 start:dev 脚本在开发环境中启动服务。
- en: ③ Development dependencies go here; these are dependencies that aren’t installed
    in production.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 开发依赖项在这里；这些是在生产环境中未安装的依赖项。
- en: ④ The new dependency on the nodemon package that we just added
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 我们刚刚添加的 nodemon 包的新依赖项
- en: 'In the previous section you learned about the convention of using `npm start`.
    We configured our project so that we could run our code in production mode like
    this:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你学习了使用`npm start`的约定。我们配置了我们的项目，以便我们可以这样在生产模式下运行我们的代码：
- en: '[PRE40]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now that we have defined the `start:dev` command, we can run our microservice
    in development mode like this:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了`start:dev`命令，我们可以这样在开发模式下运行我们的微服务：
- en: '[PRE41]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Notice the use of `npm run` to run our new script. We can use `npm run` to run
    any npm script that we add to our package.json file. We can omit the `run` part
    for `npm start` and `npm test` (which we will learn about in chapter 8) because
    npm has special support for these particular conventions.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用`npm run`来运行我们的新脚本。我们可以使用`npm run`来运行我们添加到package.json文件中的任何npm脚本。对于`npm
    start`和`npm test`（我们将在第8章中学习），我们可以省略`run`部分，因为npm对这些特定的约定有特殊支持。
- en: Now this tells you that this start:dev script *isn’t* a Node.js convention the
    way `start` and `test` are. That’s why we have to specifically use the `npm` `run`
    command to invoke it. Using start:dev to run in development is simply my own personal
    convention. We’ll use it throughout this book though, and I’m sure you’ll also
    find it useful in your own development process.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这告诉你，这个`start:dev`脚本*不是*像`start`和`test`那样的Node.js约定。这就是为什么我们必须特别使用`npm run`命令来调用它。使用`start:dev`来在开发模式下运行只是我个人的约定。不过，我们将在整本书中使用它，我相信你也会在自己的开发过程中发现它很有用。
- en: With these commands in place, we can run our microservice in either production
    mode or development mode. It’s important to make this distinction so that we can
    cater separately to the differing needs of each mode.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些命令就绪后，我们可以在生产模式或开发模式下运行我们的微服务。区分这一点很重要，这样我们就可以分别满足每种模式的不同需求。
- en: In development mode, we’d like to optimize for fast iterations and productivity.
    Alternately, in production mode, we’d like to optimize for performance and security.
    These needs are at odds with each other; hence, these must be treated separately.
    You’ll see this become important again in chapters 6 and 7 as we approach production
    deployment of our application.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发模式下，我们希望优化以实现快速迭代和生产力。相反，在生产模式下，我们希望优化性能和安全。这些需求相互矛盾；因此，这些需求必须分别处理。当我们的应用程序接近生产部署时，你将在第6章和第7章中再次看到这一点，这一点变得很重要。
- en: Note All of the microservices that are forthcoming in this book follow the conventions
    that we have laid down in the last two sections.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本书中即将出现的所有微服务都遵循我们在前两节中规定的约定。
- en: 2.6.9 Running the finished code from this chapter
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.6.9 运行本章完成的代码
- en: If you get to this point and you haven’t yet tried out the code in this chapter,
    now is the time to do so. Here’s a quick summary to show you how easy it is to
    get the examples in this chapter running. Get a local copy of the chapter-2 code,
    either by downloading it or cloning the chapter-2 repository from GitHub.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你到了这一步还没有尝试本章的代码，现在就是时候了。这里有一个快速总结，以展示运行本章示例是多么简单。获取第2章代码的本地副本，无论是下载它还是从GitHub克隆第2章存储库。
- en: To look at the streaming video, you’ll want to try out example-2.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要查看流媒体视频，你想尝试example-2。
- en: To see the example of configuring a microservice using environment variables,
    try example-3.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要查看使用环境变量配置微服务的示例，请尝试example-3。
- en: 'As an example, let’s say you want to try out example-3\. Open a terminal and
    change to the appropriate subdirectory:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你想尝试example-3。打开终端并切换到适当的子目录：
- en: '[PRE42]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now install dependencies:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 现在安装依赖项：
- en: '[PRE43]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If you wanted to simulate a production deployment, you’d do this instead:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要模拟生产部署，你可以这样做：
- en: '[PRE44]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Now to run it like you would in production, type
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 现在要像在生产环境中运行一样运行它，请输入
- en: '[PRE45]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Or to run it with live reload for fast development, you’d type this:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，要使用实时重载快速开发，你可以输入这个：
- en: '[PRE46]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: These are the main commands you need to remember to run any Node.js example
    in this book. Put a bookmark on this page and jump back to it whenever you need
    to remember how to do this.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是你需要记住的主要命令，以便在本书中运行任何Node.js示例。将此页标记为书签，并在需要记住如何做的时候跳回它。
- en: 2.7 Node.js review
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.7 Node.js复习
- en: Before we move on, we have time for a quick review of all the Node.js commands
    we have learned in this chapter. Table 2.3 lists these commands.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们有时间快速复习一下本章学到的所有Node.js命令。表2.3列出了这些命令。
- en: Table 2.3 Review of Node.js commands `(continued)`
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.3 Node.js命令复习（续）
- en: '| Command | Description |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| 命令 | 描述 |'
- en: '| `node --version` | Checks that Node.js is installed; prints the version number.
    |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| `node --version` | 检查 Node.js 是否已安装；打印版本号。|'
- en: '| `npm init -y` | Creates a default Node.js project with a stub for our package.json,
    the file that tracks metadata and dependencies for our Node.js project. |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| `npm init -y` | 创建一个默认的 Node.js 项目，其中包含我们的 package.json 的占位符，该文件跟踪我们的 Node.js
    项目的元数据和依赖项。|'
- en: '| `npm install --save` ➥ `<package-name>` | Installs an npm package. There
    are many other packages available on npm, and you can install any by inserting
    a specific package name. |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| `npm install --save` ➥ `<package-name>` | 安装一个 npm 包。npm 上有许多其他包可供选择，你可以通过插入特定的包名来安装任何包。|'
- en: '| `npm install` | Installs all dependencies for a Node.js project. This also
    installs all the packages that have been previously recorded in package.json.
    |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| `npm install` | 安装 Node.js 项目的所有依赖项。这也安装了所有在 package.json 中之前记录的包。|'
- en: '| `node <script-file>` | Runs a Node.js script file. We invoke the `node` command
    and give it the name of our script file as an argument. You can call your script
    main.js or server.js if you want, but it’s probably best to stick to the convention
    and just call it index.js. |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| `node <script-file>` | 运行一个 Node.js 脚本文件。我们调用 `node` 命令，并给它提供我们的脚本文件名作为参数。如果你想，你可以将你的脚本命名为
    main.js 或 server.js，但最好遵守约定，只将其命名为 index.js。|'
- en: '| `npm start` | The conventional npm script for starting a Node.js application
    regardless of what name the main script file has or what command-line parameters
    it expects.Typically this translates into node index.js in the package.json file,
    but it depends on the author of the project and how they have set it up. The nice
    thing is that no matter how a particular project is structured, you only have
    to remember npm start. |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| `npm start` | 不论主脚本文件的名称是什么或它期望的命令行参数是什么，都是传统的 npm 脚本用于启动 Node.js 应用程序。通常这会转换为
    package.json 文件中的 node index.js，但它取决于项目的作者以及他们如何设置它。好事是，无论特定项目结构如何，你只需要记住 npm
    start。|'
- en: '| `npm run start:dev` | My personal convention for starting a Node.js project
    in development. I add this to the scripts in package.json. Typically, it runs
    something like nodemon to enable live reload of your code as you work on it. |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| `npm run start:dev` | 我个人用于启动开发中 Node.js 项目的约定。我将此添加到 package.json 中的脚本中。通常，它会运行类似
    nodemon 的东西，以便在你工作时实时重新加载你的代码。|'
- en: 2.8 Continue your learning
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.8 继续学习
- en: 'This chapter has been a fast-paced introduction to building a barebones HTTP
    server with Node.js. Unfortunately, we have barely scratched the surface. But
    this book isn’t about Node.js; that is simply the vehicle we are using to travel
    to the land of microservices. I do however have some references for you to learn
    more should you wish to drill deeper and gain more expertise in Node.js and Git:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是关于使用 Node.js 构建基本 HTTP 服务器的快速介绍。不幸的是，我们只是触及了表面。但本书不是关于 Node.js 的；那只是我们用来到达微服务之地的交通工具。然而，我确实有一些参考资料供你学习，如果你希望深入了解并提高你在
    Node.js 和 Git 方面的专业知识：
- en: '*Getting MEAN with Mongo, Express, Angular, and Node*, 2nd ed. by Simon Holmes
    and Clive Harber (Manning, 2019)'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*Getting MEAN with Mongo, Express, Angular, and Node*》，第2版，由 Simon Holmes 和
    Clive Harber 著（Manning，2019）
- en: '*Node.js in Practice* by Alex R. Young and Marc Harter (Manning, 2014)'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*Node.js in Practice*》由 Alex R. Young 和 Marc Harter 著（Manning，2014）
- en: '*Node.js in Action*, 2nd ed., by Alex R. Young, Bradley Meck, and Mike Cantelon
    (Manning, 2017)'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*Node.js in Action*》，第2版，由 Alex R. Young、Bradley Meck 和 Mike Cantelon 著（Manning，2017）
- en: '*Learn Git in a Month of Lunches* by Rick Umali (Manning, 2015)'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*Learn Git in a Month of Lunches*》由 Rick Umali 著（Manning，2015）
- en: Also, see the extensive Node.js documentation that you can find online at [https://
    nodejs.org/en/docs/](https://nodejs.org/en/docs/).
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还可以查看在线上可找到的广泛的 Node.js 文档，网址为 [https:// nodejs.org/en/docs/](https://nodejs.org/en/docs/)。
- en: Next, we’ll move onto packaging and publishing our microservice so that it’s
    ready for deployment to the cloud. For this, we’ll use Docker, a tool that has
    become ubiquitous and indispensable in our industry. Docker has made microservices
    more accessible and has done nothing less than revolutionized the way we build
    and deploy our software.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将转向打包和发布我们的微服务，使其准备好部署到云端。为此，我们将使用 Docker，这是一个在我们的行业中变得无处不在且不可或缺的工具。Docker
    使微服务更加易于访问，并且对我们的软件构建和部署方式产生了革命性的影响。
- en: Summary
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'We discussed a philosophy of development: iterate, keep it working, start simple.'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们讨论了开发哲学：迭代，保持其工作状态，从简单开始。
- en: We established our development environment for working on a single microservice.
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为在一个单一微服务上工作建立了我们的开发环境。
- en: You learned how to create a new Node.js project.
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你学习了如何创建一个新的 Node.js 项目。
- en: We created a simple HTTP server.
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个简单的HTTP服务器。
- en: We added video streaming to our server.
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为服务器添加了视频流功能。
- en: We setup our project for use in production.
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为生产环境设置了我们的项目。
- en: We used live reload of our code for fast iterations in development.
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在开发中使用代码的实时重载来快速迭代。
