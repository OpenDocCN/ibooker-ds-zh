- en: 20 Improving your parameterized script
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 20 提高你的参数化脚本
- en: In the previous chapter, we left you with a pretty cool script that had been
    parameterized. The idea of a parameterized script is that someone else can run
    the script without having to worry about or mess with its contents. Script users
    provide input through a designated interface—parameters—and that’s all they can
    change. In this chapter, we’re going to take things a bit further.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们给你留下了一个相当酷的脚本，它已经被参数化了。参数化脚本的想法是，其他人可以运行脚本而无需担心或修改其内容。脚本用户通过指定的接口——参数——提供输入，而且他们只能更改这些。在这一章中，我们将更进一步。
- en: Heads UP Just a reminder that this chapter is very Windows focused as far as
    the examples are concerned.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：仅就示例而言，本章非常侧重于 Windows。
- en: 20.1 Starting point
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 20.1 起点
- en: 'Just to make sure we’re on the same page, let’s agree to use listing 20.1 as
    a starting point. This script features comment-based help, two input parameters,
    and a command that uses those input parameters. We’ve made one minor change since
    the previous chapter: we changed the output to be selected objects, rather than
    a formatted table that we used in section 19.4.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们处于同一页面上，让我们同意以列表 20.1 作为起点。这个脚本具有基于注释的帮助、两个输入参数以及使用这些输入参数的命令。自从上一章以来，我们做了一处小的改动：我们将输出改为选择对象，而不是我们在第
    19.4 节中使用的格式化表格。
- en: 'Listing 20.1 Starting point: Get-DiskInventory.ps1'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 20.1 起点：Get-DiskInventory.ps1
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Notice the Select-Object as opposed to Format-Table we used in chapter 19.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 注意到我们使用了 Select-Object 而不是在第 19 章中使用的 Format-Table。
- en: 'Why did we switch to `Select-Object` instead of `Format-Table`? We generally
    feel it’s a bad idea to write a script that produces preformatted output. After
    all, if someone needed this data in a CSV file, and the script was outputting
    formatted tables, that person would be out of luck. With this revision, we can
    run our script this way to get a formatted table:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们切换到 Select-Object 而不是 Format-Table？我们通常认为编写生成预格式化输出的脚本是一个坏主意。毕竟，如果有人需要将数据放在
    CSV 文件中，而脚本输出的是格式化表格，那么这个人就会很不幸。通过这次修订，我们可以这样运行我们的脚本来获取格式化表格：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Or we could run it this way to get that CSV file:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以这样运行它来获取那个 CSV 文件：
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The point is that outputting objects (which `Select-Object` does), as opposed
    to formatting displays, makes our script more flexible in the long run.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 重点是输出对象（Select-Object 所做的），而不是格式化显示，从长远来看，使我们的脚本更加灵活。
- en: 20.2 Getting PowerShell to do the hard work
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 20.2 让 PowerShell 做艰苦的工作
- en: We’re going to turn on some PowerShell magic by adding just one line to our
    script. This technically turns our script into an *advanced script*, which enables
    a whole slew of useful PowerShell capabilities. The following listing shows the
    revision.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过在脚本中添加一行来开启一些 PowerShell 魔法。从技术上讲，这使我们的脚本变成了一个 *高级脚本*，从而启用了一系列有用的 PowerShell
    功能。以下列表显示了修订版。
- en: Listing 20.2 Making Get-DiskInventory.ps1 an advanced script
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 20.2 将 Get-DiskInventory.ps1 转换为高级脚本
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ The [CmdletBinding()] must be the first line after the comment-based help;
    PowerShell knows to look for it here.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ [CmdletBinding()] 必须是注释帮助之后的第一个行；PowerShell 知道在这里寻找它。
- en: As noted, it’s important that the `[CmdletBinding()]` directive be the first
    line in the script after the comment-based help. PowerShell knows to look for
    it only there. With this one change, the script will continue to run normally,
    but we’ve enabled several neat features that we’ll explore next.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所提到的，确保 `[CmdletBinding()]` 指令是脚本中注释帮助之后的第一个行是非常重要的。PowerShell 只知道在那里寻找它。通过这个改动，脚本将继续正常运行，但我们已经启用了一些很酷的功能，我们将在下一部分进行探索。
- en: 20.3 Making parameters mandatory
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 20.3 使参数成为强制性的
- en: From here, we could say we are all done, but that wouldn’t be much fun, now,
    would it? Our script is in its existing form because it provides a default value
    for the `-ComputerName` parameter—and we’re not sure one is really needed. We’d
    rather prompt for that value than rely on a hardcoded default. Fortunately, PowerShell
    makes it easy—again, adding just one line will do the trick, as shown in the next
    listing.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们可以说我们已经完成了，但这现在不会很有趣，对吧？我们的脚本之所以以现有的形式存在，是因为它为 `-ComputerName` 参数提供了一个默认值——我们不确定是否真的需要它。我们更愿意提示输入该值，而不是依赖于硬编码的默认值。幸运的是，PowerShell
    使这变得很容易——再次，只需添加一行即可，如下一列表所示。
- en: Listing 20.3 Giving Get-DiskInventory.ps1 a mandatory parameter
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 20.3 给 Get-DiskInventory.ps1 添加强制参数
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ The [Parameter(Mandatory=$True)] decorator will make PowerShell prompt for
    a computer name if whoever runs this script forgets to provide one.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `[Parameter(Mandatory=$True)]`装饰器将使PowerShell在运行此脚本的人忘记提供计算机名称时提示输入。
- en: Above and beyond
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外
- en: When someone runs your script but doesn’t provide a mandatory parameter, PowerShell
    will prompt them for it. There are two ways to make PowerShell’s prompt more meaningful
    to that user.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当某人运行你的脚本但没有提供必需的参数时，PowerShell将提示他们提供该参数。有两种方法可以使PowerShell的提示对用户更有意义。
- en: First, use a good parameter name. Prompting someone to fill in *comp* isn’t
    as helpful as prompting them to provide a `computerName`, so try to use parameter
    names that are descriptive and consistent with what other PowerShell commands
    use.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用一个好的参数名称。提示某人填写*comp*并不像提示他们提供`computerName`那样有帮助，因此尽量使用描述性且与其他PowerShell命令一致的参数名称。
- en: 'You can also add a help message:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以添加一条帮助信息：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Some PowerShell hosts will display that help message as part of the prompt,
    making it even clearer to the user, but not every host application will use this
    attribute, so don’t be dismayed if you don’t see it all the time as you’re testing.
    We like including it anyway, when we’re writing something intended to be used
    by other people. It never hurts. But for brevity, we’ll omit `HelpMessage` from
    our running example in this chapter.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一些PowerShell宿主将帮助信息作为提示的一部分显示，这使得对用户来说更加清晰，但并非每个宿主应用程序都会使用此属性，所以如果你在测试时并不总是看到它，请不要沮丧。我们仍然喜欢在编写供其他人使用的内容时包含它。这永远不会有害。但为了简洁，我们将在本章的运行示例中省略`HelpMessage`。
- en: 'Just that one *decorator*, `[Parameter(Mandatory=$True)]`, will make PowerShell
    prompt for a computer name if whoever runs this script forgets to provide one.
    To help PowerShell even further, we’ve given both of our parameters a data type:
    `[string]` for `-ComputerName`, and `[int]` (which means *integer*) for `-drivetype`.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样一个*装饰器*，`[Parameter(Mandatory=$True)]`，将使PowerShell在运行此脚本的人忘记提供计算机名称时提示输入。为了进一步帮助PowerShell，我们给我们的两个参数都指定了数据类型：`-ComputerName`为`[string]`，`-drivetype`为`[int]`（表示整数）。
- en: Adding these kinds of attributes to parameters can become confusing, so let’s
    examine the `Param()` block syntax more closely—look at figure 20.1.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些类型的属性添加到参数中可能会变得令人困惑，因此让我们更仔细地检查`Param()`块的语法——参见图20.1。
- en: '![](Images/CH20_F01_Plunk.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH20_F01_Plunk.png)'
- en: Figure 20.1 Breaking down the `Param()` block syntax
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.1 解构`Param()`块语法
- en: 'Here are the important things to notice:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些需要注意的重要事项：
- en: All of the parameters are enclosed within the `Param()` block’s parentheses.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有参数都包含在`Param()`块的括号内。
- en: A single parameter can include multiple decorators, which can be either strung
    out on one line or placed on separate lines, as we’ve done in figure 20.1\. We
    think multiple lines are more readable—but the important bit is that they all
    go together. Here, the `Mandatory` attribute modifies only `-ComputerName`; it
    has no effect at all on `-drivetype`.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个参数可以包含多个装饰器，这些装饰器可以放在一行上，也可以像我们在图20.1中那样放在不同的行上。我们认为多行更易于阅读——但重要的是它们都是一起的。在这里，`Mandatory`属性仅修改`-ComputerName`；它对`-drivetype`没有任何影响。
- en: Each parameter name except the last one is followed by a comma.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了最后一个参数名之外，每个参数名后面都跟着一个逗号。
- en: For better readability, we also like to put a blank line between parameters.
    We think it helps to visually separate them better, making the `Param()` block
    less confusing.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了提高可读性，我们喜欢在参数之间添加一个空行。我们认为这有助于更好地在视觉上分离它们，使`Param()`块不那么令人困惑。
- en: We define each parameter as if it were a variable `$computername` and `$drivetype`,
    but someone who runs this script will treat them as normal PowerShell command-line
    parameters, such as `-ComputerName` and `-drivetype`.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将每个参数定义为一个变量`$computername`和`$drivetype`，但运行此脚本的人将把它们当作正常的PowerShell命令行参数，如`-ComputerName`和`-drivetype`。
- en: Try it Now Try saving the script in listing 20.3 and running it in the shell.
    Don’t specify a `-ComputerName` parameter, and see how PowerShell prompts you
    for that information.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看 Try 将脚本保存到列表20.3中，并在shell中运行它。不要指定`-ComputerName`参数，看看PowerShell如何提示你提供该信息。
- en: 20.4 Adding parameter aliases
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 20.4 添加参数别名
- en: Is *computername* the first thing that comes to mind when you think about computer
    names? Possibly not. We used `-ComputerName` as our parameter name because it’s
    consistent with the way other PowerShell commands are written. Look at `Get-Service`,
    `Get-CimInstance`, `Get-Process`, and others, and you’ll see a `-ComputerName`
    parameter on them all. So we went with that.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想到计算机名时，*computername* 是第一个出现在你脑海中的吗？可能不是。我们使用 `-ComputerName` 作为参数名，因为它与其他
    PowerShell 命令的书写方式保持一致。看看 `Get-Service`、`Get-CimInstance`、`Get-Process` 等，你会在它们上面看到
    `-ComputerName` 参数。所以我们选择了这个。
- en: But if something like `-host` comes more easily to your mind, you can add that
    as an alternative name, or alias, for the parameter. It’s just another decorator,
    as shown in the following listing. Don’t use `-hostname`, however, as that indicates
    an SSH connection when using PowerShell Remoting.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你更倾向于使用 `-host` 这样的名称，你可以将其添加为参数的另一个名称或别名。它只是另一个装饰器，如以下列表所示。然而，不要使用 `-hostname`，因为在使用
    PowerShell 远程时，它会指示 SSH 连接。
- en: Listing 20.4 Adding a parameter alias to Get-DiskInventory.ps1
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 20.4 向 Get-DiskInventory.ps1 添加参数别名
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ This addition is part of the -ComputerName parameter; it has no effect on
    -drivetype.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这个添加是 `-ComputerName` 参数的一部分；它对 `-drivetype` 没有影响。
- en: 'With this minor change, we can now run this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个小的改动，我们现在可以运行以下命令：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note Remember, you have to type only enough of a parameter name for PowerShell
    to understand which parameter you mean. In this case, `-host` was enough for PowerShell
    to identify `-hostname`. We could also have typed the full thing.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 记住，你只需要输入足够多的参数名，以便 PowerShell 能够理解你指的是哪个参数。在这个例子中，`-host` 已经足够 PowerShell
    识别 `-hostname`。我们也可以输入完整的名称。
- en: 'Again, this new addition is part of the `-ComputerName` parameter; it has no
    effect on `-drivetype`. The `-ComputerName` parameter’s definition now occupies
    three lines of text, although we could also have strung everything together on
    one line:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这个新的添加是 `-ComputerName` 参数的一部分；它对 `-drivetype` 没有影响。现在 `-ComputerName`
    参数的定义占据了三行文本，尽管我们也可以将所有内容放在一行中：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We just think that’s a lot harder to read.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是觉得这样读起来更困难。
- en: 20.5 Validating parameter input
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 20.5 验证参数输入
- en: Let’s play with the `-drivetype` parameter a little bit. According to the MSDN
    documentation for the `Win32_LogicalDisk` WMI class (do a search for the class
    name, and one of the top results will be the documentation), drive type 3 is a
    local hard disk. Type 2 is a removable disk, which should also have a size and
    free space measurement. Drive types 1, 4, 5, and 6 are less interesting (does
    anyone use RAM drives, type 6, anymore?), and in some cases they might not have
    an amount of free space (type 5, for optical disks). So we’d like to prevent anyone
    from using those types when they run our script. This listing shows the minor
    change we need to make.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微玩一下 `-drivetype` 参数。根据 `Win32_LogicalDisk` WMI 类的 MSDN 文档（搜索类名，其中一个顶部结果将是文档），驱动器类型
    3 是本地硬盘。类型 2 是可移动磁盘，它应该也有大小和可用空间测量。驱动器类型 1、4、5 和 6 没有那么有趣（还有谁现在还在使用 RAM 驱动器，类型
    6？），在某些情况下，它们可能没有可用空间（类型 5，对于光盘）。因此，我们希望阻止任何人在运行我们的脚本时使用这些类型。这个列表显示了我们需要做的微小改动。
- en: Listing 20.5 Adding parameter validation to Get-DiskInventory.ps1
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 20.5 向 Get-DiskInventory.ps1 添加参数验证
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ We add [ValidateSet(2,3)] to the script to tell PowerShell that only two values,
    2 and 3, are accepted by our -drivetype parameter and that 3 is the default.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们在脚本中添加了 `[ValidateSet(2,3)]` 来告诉 PowerShell，只有两个值，2 和 3，是被我们的 `-drivetype`
    参数接受的，并且 3 是默认值。
- en: There are a bunch of other validation techniques you can add to a parameter,
    and when it makes sense to do so, you can add more than one to the same parameter.
    Run `help about_functions_advanced_parameters` for a full list. We’ll stick with
    `ValidateSet()` for now.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以添加许多其他的验证技术到一个参数中，并且当这样做有意义时，你可以向同一个参数添加多个。运行 `help about_functions_advanced_parameters`
    获取完整的列表。我们现在继续使用 `ValidateSet()`。
- en: Try it Now Save this script and run it again. Try specifying `-drivetype 5`
    and see what PowerShell does.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 保存这个脚本并再次运行。尝试指定 `-drivetype 5` 并看看 PowerShell 会做什么。
- en: 20.6 Adding the warm and fuzzies with verbose output
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 20.6 通过冗长的输出添加温暖和舒适感
- en: In chapter 17, we mentioned how we prefer to use `Write-Verbose` over `Write-Host`
    for producing the step-by-step progress information that some folks like to see
    their scripts produce. Now’s the time for a real example. We’ve added a few verbose
    output messages in the following listing.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在第17章中，我们提到了我们更喜欢使用`Write-Verbose`而不是`Write-Host`来生成一些喜欢看到脚本产生的逐步进度信息的用户的信息。现在是一个真正的例子的时候了。我们在下面的列表中添加了一些详细输出的消息。
- en: Listing 20.6 Adding verbose output to Get-DiskInventory.ps1
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 列表20.6 向Get-DiskInventory.ps1添加详细输出
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Adds in three verbose output messages
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 添加了三个详细输出消息
- en: 'Now try running this script in two ways. This first attempt shouldn’t display
    any of the verbose output:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在以两种方式尝试运行此脚本。第一次尝试不应该显示任何详细输出：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now for a second attempt, where we want the verbose output displayed:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是第二次尝试，我们希望显示详细输出：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Try it Now This is a lot cooler when you see it for yourself. Run the script
    as we’ve shown here, and see the differences for yourself.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看 这当你亲自看到的时候会更酷。按照我们在这里展示的方式运行脚本，亲自看看差异。
- en: How cool is that? When you want verbose output (pointed out in code listing
    20.6), you can get it—and you don’t have to code the `-Verbose` parameter at all!
    It comes for free when you add `[Cmdlet-Binding()]`. And a really neat part is
    that it will also activate verbose output for every command that your script contains!
    So any commands you use that are designed to produce verbose output will do so
    “automagically.” This technique makes it easy to turn the verbose output on and
    off, making it a lot more flexible than `Write-Host`. And you don’t have to mess
    around with the `$VerbosePreference` variable to make the output show up onscreen.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这有多酷？当你想要详细的输出（如代码列表20.6所示），你可以得到它——而且你根本不需要编写`-Verbose`参数！当你添加`[Cmdlet-Binding()]`时，它会免费提供。而且一个真正酷的地方是，它还会激活脚本中每个命令的详细输出！所以任何设计用于产生详细输出的命令都将“自动”这样做。这种技术使得开启和关闭详细输出变得很容易，比`Write-Host`更加灵活。而且你不需要与`$VerbosePreference`变量纠缠，以使输出显示在屏幕上。
- en: 'Also, notice in the verbose output how we made use of PowerShell’s double quotation
    mark trick: by including a variable (`$computername`) within double quotes, the
    output is able to include the contents of the variable so we can see what PowerShell
    is up to.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在详细输出中，我们如何利用PowerShell的双引号技巧：通过在双引号内包含一个变量（`$computername`），输出能够包含变量的内容，这样我们就可以看到PowerShell在做什么。
- en: 20.7 Lab
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 20.7 实验室
- en: This lab requires you to recall some of what you learned in chapter 19, because
    you’ll be taking the following command, parameterizing it, and turning it into
    a script—just as you did for the lab in chapter 19\. But this time we also want
    you to make the `-ComputerName` parameter mandatory and give it a `host` alias.
    Have your script display verbose output before and after it runs this command
    too. Remember, you have to parameterize the computer name—but that’s the only
    thing you have to parameterize in this case.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实验室要求你回忆一下第19章中学到的一些内容，因为你将使用以下命令，对其进行参数化，并将其转换为脚本——就像你在第19章的实验室中所做的那样。但这次我们还想让你将`-ComputerName`参数设置为必填项，并给它一个`host`别名。让脚本在运行此命令前后显示详细输出。记住，你必须参数化计算机名——但在这个情况下，你只需要参数化这一项。
- en: 'Be sure to run the command as is before you start modifying it, to make sure
    it works on your system:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始修改之前，确保按原样运行命令，以确保它在你的系统上工作：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To reiterate, here’s your complete task list:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 重申一下，这是你的完整任务列表：
- en: Make sure the command runs as is before modifying it.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在修改之前确保命令按原样运行。
- en: Parameterize the computer name.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数化计算机名。
- en: Make the computer name parameter mandatory.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使计算机名参数成为必填项。
- en: Give the computer name parameter an alias, `hostname`.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给计算机名参数一个别名，`hostname`。
- en: Add comment-based help with at least one example of how to use the script.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加基于注释的帮助，至少包含一个如何使用脚本的示例。
- en: Add verbose output before and after the modified command.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在修改命令前后添加详细输出。
- en: Save the script as Get-PhysicalAdapters.ps1.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将脚本保存为Get-PhysicalAdapters.ps1。
- en: 20.8 Lab answer
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 20.8 实验室答案
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Above and beyond
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外
- en: Take what you have learned so far and modify the script we made in chapter 19,
    Get-FilePath.ps1 (listing 19.2) and
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 将你到目前为止学到的知识应用到我们在第19章中制作的脚本Get-FilePath.ps1（列表19.2）中，
- en: Make it an advanced function.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使其成为一个高级函数。
- en: Add mandatory parameters.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加必填参数。
- en: Add verbose output.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加详细输出。
- en: Adapt the formatting to make exporting to a CSV easier.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整格式以使导出到CSV文件更容易。
