- en: 6 Effects and the React component life cycle
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 效果和React组件生命周期
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Running effects inside components
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在组件内部运行效果
- en: A complete guide to the React component life cycle
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React组件生命周期的完整指南
- en: Mounting, unmounting, and rendering components
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件的挂载、卸载和渲染
- en: Introducing life cycle methods for class-based components
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍类组件的生命周期方法
- en: React components use JavaScript XML (JSX) to send information to the user in
    the form of HTML. But components need to do a lot more than that to be useful
    in an application. In React, everything that happens, happens in some component,
    so if your application wants to set a cookie, load some data, handle form input,
    display the user’s camera, start or stop a timer, or a myriad of other dynamic
    capabilities, you need more than just JSX.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: React组件使用JavaScript XML (JSX)以HTML的形式向用户发送信息。但组件需要做更多的事情才能在应用程序中变得有用。在React中，所有发生的事情都发生在某个组件中，所以如果你的应用程序想要设置cookie、加载数据、处理表单输入、显示用户的摄像头、启动或停止计时器，或者有无数其他动态功能，你需要的不仅仅是JSX。
- en: If you want your component to load some data from a server, you want the effect
    to run as soon as the component loads, but then you don’t need the effect to run
    again even if your component re-renders. On the other hand, if you want to set
    a cookie with the last username entered into the login field, you want that effect
    to run every time the user types in the input field. If you want to display a
    timer inside your component, you want the timer to start ticking as your component
    loads, but you also want the timer to stop ticking as your component later unloads,
    to avoid unnecessarily clogging up resources.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望你的组件从服务器加载数据，你希望效果在组件加载时立即运行，但即使组件重新渲染，也不需要效果再次运行。另一方面，如果你想在登录字段中设置最后输入的用户名作为cookie，你希望该效果在用户每次输入输入字段时运行。如果你想在组件内显示计时器，你希望计时器在组件加载时开始滴答作响，但你也不想当组件稍后卸载时计时器仍在滴答，以避免不必要地占用资源。
- en: What you need are effects. *Effects* are functions that run inside a component
    under certain circumstances. To run an effect, you have to specify under which
    circumstances the effect should run. To fully understand this, we have to dive
    into the topic of the React component life cycle.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要的是效果。*效果*是在组件的特定情况下运行的函数。要运行一个效果，你必须指定效果应在何种情况下运行。要完全理解这一点，我们必须深入研究React组件生命周期的主题。
- en: We’ll properly define some terminology that we’ve already used previously, but
    not properly explained, such as mounting, unmounting, and re-rendering. The latter
    is especially important. When and why do components re-render, and how can you
    hook into this process to either control it or react to it?
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将正确定义一些我们之前已经使用过但未充分解释的术语，例如挂载、卸载和重新渲染。后者尤为重要。组件何时以及为什么重新渲染，你如何挂钩到这个过程中来控制它或对其做出反应？
- en: We’ll finally give a brief introduction to how life cycle methods work in class-based
    components and what they compare to in functional components. The difference between
    the two component types becomes even more pronounced than what we’ve seen previously.
    The life cycle methods of a class-based component are extraordinarily complex
    and hard to understand compared with the simplicity of an effect in a functional
    component. With all that to cover, let’s get started!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在课堂上简要介绍生命周期方法如何在类组件中工作，以及它们与函数组件相比是什么。这两种组件类型之间的差异比我们之前看到的更为明显。与函数组件中效果的简单性相比，类组件的生命周期方法异常复杂且难以理解。考虑到所有这些内容，让我们开始吧！
- en: Note The source code for the examples in this chapter is available at [https://rq2e.com/ch06](https://rq2e.com/ch06).
    But as you learned in chapter 2, you can instantiate all the examples directly
    from the command line using a single command.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本章中示例的源代码可在[https://rq2e.com/ch06](https://rq2e.com/ch06)找到。但正如你在第二章中学到的，你可以使用单个命令直接从命令行实例化所有示例。
- en: 6.1 Running effects in components
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 在组件中运行效果
- en: Let’s say you have a timer component, and you want it to display the number
    of seconds it has been mounted. The first thing that comes to mind is to create
    an interval with setInterval inside the function body, which increments a counter
    state value every second. But when you change the state value, the whole component
    re-renders, which would start another interval rendering your component twice
    every second, which would start another two intervals rendering it four times
    every second, and so on. That’s clearly not the way to do it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个计时器组件，并且你希望它显示已经挂载的秒数。首先想到的是在函数体内使用`setInterval`创建一个间隔，每秒增加一个计数器状态值。但是当你改变状态值时，整个组件会重新渲染，这会导致每秒重新渲染两次组件，然后每秒再启动两个间隔，使其每秒渲染四次，以此类推。这显然不是正确的方法。
- en: Another idea is to use a timeout with setTimeout. In this situation, 1 second
    after the component renders, we increment the counter state value, which in turn
    causes a re-render, starting a new timeout. This seems like a reasonable approach.
    But what if your component re-renders for other reasons? A component can re-render
    because a property changes or because it has multiple state values that can change
    independently of the counter. If your component unmounts because it isn’t needed
    anymore, the timeout continues to run and, after a second, will try to update
    a component that no longer exists. That’s unfortunately also not a good way to
    do it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个想法是使用`setTimeout`。在这种情况下，组件渲染1秒后，我们增加计数器状态值，这反过来又会导致重新渲染，启动一个新的超时。这似乎是一个合理的方案。但是，如果你的组件因为其他原因重新渲染怎么办？组件可以因为属性变化或因为它有多个可以独立于计数器变化的独立状态值而重新渲染。如果你的组件因为不再需要而卸载，超时将继续运行，并在一秒后尝试更新一个不再存在的组件。这显然也不是一个好的方法。
- en: 'To solve this problem, React introduced an *effect* *hook*, called useEffect
    (notice the important use* prefix used on all hooks). An effect in a useEffect
    hook is triggered when any value in a set of dependencies changes. Furthermore,
    when an effect in useEffect runs, it can define a cleanup function that should
    run in one of two cases: before the effect is triggered again or if the component
    unmounts. Figure 6.1 shows this flow.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，React 引入了一个名为 `useEffect` 的 *effect* *hook*（注意所有 hooks 都使用了重要的 use*
    前缀）。当依赖集中任何值发生变化时，useEffect hook 中的效果会被触发。此外，当 useEffect 中的效果运行时，它可以定义一个清理函数，该函数应在以下两种情况下运行：在效果再次触发之前或组件卸载时。图
    6.1 展示了这种流程。
- en: '![06-01](../Images/06-01.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![06-01](../Images/06-01.png)'
- en: Figure 6.1 The useEffect hook here is displayed both as a code snippet and a
    flowchart. The hook contains an optional effect as well as an optional cleanup
    function. The effect runs on mount, and the cleanup runs on unmount—if they’re
    defined, of course. Furthermore, if the effect has a dependency array, the cleanup
    and effect will also run every time any value reference in the dependency array
    changes.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 这里将 useEffect hook 以代码片段和流程图的形式展示。hook 包含一个可选的效果以及一个可选的清理函数。效果在挂载时运行，清理在卸载时运行——如果它们被定义的话。此外，如果效果有一个依赖数组，清理和效果也会在依赖数组中任何值引用改变时运行。
- en: This diagram is pretty complex, so we’ll take you through it one step at a time
    by introducing functions that do just a few things at a time. The trick to this
    diagram is that you can set up your useEffect call so that you can define just
    the effect, just the cleanup function, or both, when it suits your needs. Furthermore,
    by carefully crafting the dependency array with the right values, you can trigger
    your effect and cleanup to run at exactly the desired instances.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图表相当复杂，所以我们将一步一步地通过介绍一次只做几件事情的函数来带你了解它。这个图表的技巧在于你可以设置`useEffect`调用，以便在需要时只定义效果、只定义清理函数或两者都定义。此外，通过精心构建包含正确值的依赖数组，你可以触发效果和清理在精确期望的实例上运行。
- en: 'There are five likely scenarios that you want your effect and cleanup function
    to run under. We’ll go through all five scenarios with examples of each:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望你的效果和清理函数在五种可能的情况下运行。我们将通过每个示例的例子来介绍所有五种情况：
- en: You’re loading some external data in a component. To correctly do that in an
    effect, you need it to run as your component mounts.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你在一个组件中加载一些外部数据。为了在效果中正确地做到这一点，你需要它在组件挂载时运行。
- en: You’re creating a timer using an interval. To achieve this, you need to run
    such an effect as your component mounts, but also clean it up again as your component
    later unmounts.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你正在使用间隔创建一个计时器。为了实现这一点，你需要在组件挂载时运行这样的效果，但也要在组件稍后卸载时清理它。
- en: You want to track when a dialog is closed regardless of how it’s closed. To
    do this properly, you need to run such an effect only as your component unmounts.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您想跟踪对话框何时关闭，无论它是如何关闭的。为了正确地做到这一点，您需要在组件卸载时仅运行这样的效果。
- en: You want to update the browser window (or tab) title with the title of the page
    currently displayed. To achieve this in an effect, you need it to run every time
    the title property changes, but not when any other property changes, as long as
    the title remains the same.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您想更新浏览器窗口（或标签）的标题，以显示当前显示的页面的标题。为了在效果中实现这一点，您需要它在标题属性每次更改时运行，但只要标题保持不变，就不需要更改任何其他属性。
- en: You want to run a timer but only if the timer is active as denoted by an isActive
    flag. To achieve this, you need to run such an effect and its cleanup every time
    the isActive flag changes, but not if other properties or values change, as long
    as the isActive flag remains the same.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您想运行一个计时器，但只有当计时器处于活动状态，即由isActive标志表示时。为了实现这一点，您需要在isActive标志每次更改时运行这样的效果及其清理，但只要isActive标志保持不变，就不需要更改其他属性或值。
- en: 6.1.1 Running an effect on mount
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.1 在挂载时运行效果
- en: Let’s say we want to create a drop-down component that loads data from an external
    server to be displayed in the drop-down. We need to load this data as an effect
    that runs on mount, and then it shouldn’t ever run again (because we already have
    the data). In this scenario, only the part of the diagram highlighted in figure
    6.2 is relevant.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要创建一个下拉组件，该组件从外部服务器加载数据以在下拉列表中显示。我们需要在组件挂载时加载数据作为运行效果，然后它就不再运行（因为我们已经有了数据）。在这种情况下，只有图6.2中突出显示的图部分是相关的。
- en: '![06-02](../Images/06-02.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![06-02](../Images/06-02.png)'
- en: Figure 6.2 The execution of an effect hook when the effect is only desired as
    the component mounts. Note how the dependency array is kept empty, and there’s
    no cleanup function. This means that the effect is only ever executed on mount
    and never as the component re-renders.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 当效果只希望在组件挂载时运行时效果钩子的执行。注意依赖数组保持为空，并且没有清理函数。这意味着效果仅在挂载时执行，而不会在组件重新渲染时执行。
- en: You can see the code in listing 6.1 and the result in figure 6.3.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在列表6.1中看到代码，在图6.3中看到结果。
- en: '![06-03](../Images/06-03.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![06-03](../Images/06-03.png)'
- en: Figure 6.3 Our Star Wars character drop-down in action. May the source be with
    you!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 我们在行动中的星球大战角色下拉列表。愿源代码与你同在！
- en: Listing 6.1 Drop-down loading options from remote
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.1 从远程加载下拉选项
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ We need a state to have a place to hold the values once the options have been
    fetched.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们需要一个状态来存储在选项被检索后保留的值。
- en: ❷ In our effect hook, we load this URL (which is a list of characters in Star
    Wars).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在我们的效果钩子中，我们加载这个URL（这是一个星球大战角色的列表）。
- en: ❸ As the result is parsed, we set our state value with an array of character
    names.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 当结果被解析时，我们使用字符名称的数组设置我们的状态值。
- en: ❹ Finally, we make sure to pass an empty dependency array, so this effect only
    runs on mount and never again.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 最后，我们确保传递一个空的依赖数组，这样这个效果只在挂载时运行，而不会再次运行。
- en: 'Repository: rq06-remote-dropdown'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库：rq06-remote-dropdown
- en: 'This example can be seen in repository rq06-remote-dropdown. You can use that
    repository by creating a new app based on the associated template:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在rq06-remote-dropdown仓库中看到。您可以通过创建一个基于相关模板的新应用来使用该仓库：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以访问此网站来浏览代码，直接在浏览器中查看应用程序的运行情况，或者下载源代码的zip文件：
- en: '[https://rq2e.com/rq06-remote-dropdown](https://rq2e.com/rq06-remote-dropdown)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq06-remote-dropdown](https://rq2e.com/rq06-remote-dropdown)'
- en: This is a pretty classic setup that you’ll often see in web apps loading data
    that is relevant only inside a small part of the overall application. It does
    have a small problem though. What happens if, for some reason, the component unmounts
    before the response comes back from the server—maybe because the internet connection
    is flaky or the server is experiencing a lot of load? We’ll have to deal with
    that in a cleanup function. Cue next section.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当经典的设置，您在加载只与整体应用程序的小部分相关的数据的Web应用程序中经常会看到。但是，它确实有一个小问题。如果由于某种原因，组件在服务器响应返回之前卸载了——可能是因为互联网连接不稳定或服务器负载很大——我们将不得不在清理函数中处理这个问题。下一节将介绍。
- en: 6.1.2 Running an effect on mount and cleanup on unmount
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.2 在挂载时运行效果并在卸载时清理
- en: We’ve been tasked with creating a stopwatch component. It should start an interval
    as soon as the component mounts that just keeps incrementing as time passes; however,
    if the component is ever unmounted in the future (e.g., because the user closes
    it), we must make sure to stop the interval. This requires an effect that runs
    on mount but also runs a cleanup function on unmount. In this scenario, only the
    part of the diagram highlighted in figure 6.4 is relevant.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务是创建一个计时器组件。组件挂载后应立即启动一个间隔，随着时间的流逝不断递增；然而，如果组件在未来任何时候被卸载（例如，因为用户关闭它），我们必须确保停止间隔。这需要一个在挂载时运行但在卸载时也运行清理函数的效果。在这种情况下，只有图6.4中突出显示的图示部分是相关的。
- en: '![06-04](../Images/06-04.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![06-04](../Images/06-04.png)'
- en: Figure 6.4 To make the effect hook activate with an effect and cleanup only
    on mount and unmount, respectively, you must add an empty dependency array to
    make sure that the effect and cleanup never runs just because the component is
    re-rendering.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4为了使效果钩子仅在挂载和卸载时分别激活效果和清理，您必须添加一个空依赖数组，以确保效果和清理永远不会仅仅因为组件重新渲染而运行。
- en: You can see the code for such a component in the following listing. Figure 6.5
    shows the component in action.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下列表中看到此类组件的代码。图6.5显示了组件的运行情况。
- en: '![06-05](../Images/06-05.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![06-05](../Images/06-05.png)'
- en: Figure 6.5 Our stopwatch is ticking away.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5我们的计时器正在滴答作响。
- en: Listing 6.2 Stopwatch
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.2计时器
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ In our effect function, we start an interval, to be run every second, that
    increments the counter.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在我们的效果函数中，我们启动了一个每秒运行一次的间隔，用于递增计数器。
- en: ❷ Using the browser built-in function setInterval, we can have our increment
    function invoked at a steady rate.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用浏览器内置函数setInterval，我们可以以稳定的速率调用递增函数。
- en: ❸ Cancels the ongoing interval in the cleanup function using the built-in function
    clearInterval
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在清理函数中使用内置函数clearInterval取消正在进行的间隔
- en: ❹ Conditionally renders the stopwatch to see the cleanup function do its job
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 条件渲染计时器以查看清理函数执行其工作
- en: 'Repository: rq06-stopwatch'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库：rq06-stopwatch
- en: 'This example can be seen in repository rq06-stopwatch. You can use that repository
    by creating a new app based on the associated template:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在rq06-stopwatch仓库中看到。您可以通过创建一个基于相关模板的新应用来使用该仓库：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以访问此网站浏览代码，直接在浏览器中查看应用程序的运行情况，或下载源代码的zip文件：
- en: '[https://rq2e.com/rq06-stopwatch](https://rq2e.com/rq06-stopwatch)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq06-stopwatch](https://rq2e.com/rq06-stopwatch)'
- en: Even though we’re using the variable setSeconds inside the effect, we don’t
    list it as a dependency because it’s a stable variable that doesn’t change. The
    state update function as returned by the useState hook is always the same function
    by reference. You can include it in the array, and the hook works the same, so
    if you find this part a bit too complex to remember, just include the function
    in the array.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在效果内部使用了setSeconds变量，但我们没有将其列为依赖项，因为它是一个稳定的变量，不会改变。由useState钩子返回的状态更新函数在引用上始终是相同的函数。您可以将它包含在数组中，钩子的工作方式相同，所以如果您觉得这部分有点复杂难以记住，只需将函数包含在数组中即可。
- en: Events
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 事件
- en: Another common example of using an effect only for mount and unmount is listening
    for events. For example, you might want your component to update itself when the
    whole web page resizes (listening to the resize event) or when a certain element
    scrolls (listening to the scroll event). We’ll see a number of examples of this
    happening in chapter 8, which is dedicated to events.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个仅用于挂载和卸载的效果的常见例子是监听事件。例如，您可能希望当整个网页大小调整（监听调整大小事件）或某个元素滚动（监听滚动事件）时，组件能够更新自己。我们将在第8章中看到许多此类示例，该章节专门讨论事件。
- en: Canceling action if unmounted
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 取消未挂载时的操作
- en: The third type of use case for mount and unmount is an extension of the example
    in the previous section. Our RemoteDropdown loads data when mounted, but what
    would happen if the data transfer was slow, and the user somehow navigated away
    from the part of the application with the drop-down before the response came in?
    We would be trying to update state on a component that no longer existed!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 挂载和卸载的第三种用例是前一小节中示例的扩展。我们的RemoteDropdown在挂载时加载数据，但如果数据传输缓慢，用户在响应到来之前就导航到了应用程序中带有下拉菜单的部分，会发生什么？我们将会尝试更新不再存在的组件的状态！
- en: 'This can be mitigated in one of two ways: you can either cancel the request
    in a cleanup function (in JavaScript, via AbortController), or you can have a
    local flag that remembers whether the component is still mounted and only updates
    the component state if the flag is true. If not, the component just ignores the
    returned response.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过两种方式之一来缓解：你可以在清理函数中取消请求（在JavaScript中通过AbortController），或者你可以有一个局部标志来记住组件是否仍然挂载，并且只有当标志为true时才更新组件状态。如果不是，组件将忽略返回的响应。
- en: 'Canceling the request using an AbortController on unmount looks something like
    this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件卸载时使用AbortController取消请求看起来是这样的：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Creates an abort controller inside the effect
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在效果函数内创建一个abort控制器
- en: ❷ Makes sure to pass the abort controller to the fetch function
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 确保将abort控制器传递给fetch函数
- en: ❸ In the cleanup function, we ask the abort controller to do its job. If the
    request already went through, nothing happens if we try to abort anyway.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在清理函数中，我们要求abort控制器执行其任务。如果请求已经通过，即使尝试取消也不会发生任何事情。
- en: 'The former option of aborting is the better option, as we can just cancel the
    request; however, that might not always be possible. If we can’t cancel the request
    for some reason, we can keep track of whether the component is still mounted as
    follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 取消请求的前一种方法是更好的选择，因为我们可以直接取消请求；然而，这并不总是可能的。如果我们无法取消请求，我们可以如下跟踪组件是否仍然挂载：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Keeps a local variable in our effect function that is initially set to true
    and reflects the fact that, as far as we know, the component is currently mounted
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在我们的效果函数中保持一个局部变量，初始设置为true，反映的是，就我们所知，组件目前处于挂载状态
- en: ❷ Once the data comes in, we’ll first check whether the component is still mounted.
    If not, just abort now.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 数据到达后，我们首先检查组件是否仍然挂载。如果不是，现在就取消。
- en: ❸ Flips the Boolean flag in a cleanup function, which will only be invoked if
    our component unmounts
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在清理函数中翻转布尔标志，这将仅在组件卸载时被调用
- en: This setup works for any type of delayed callback running in an effect hook.
    It could be a promise that resolves, a timeout that executes, or anything like
    that. You set a local variable inside the effect to false when the component unmounts
    and then make sure to just abort the callback when triggered.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设置适用于任何类型在效果钩子中运行的延迟回调。这可能是一个解决的承诺，一个执行的超时，或者任何类似的东西。当组件卸载时，你在效果中设置一个局部变量为false，然后确保在触发时仅取消回调。
- en: 6.1.3 Running cleanup on unmount
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.3 在卸载时运行清理
- en: Imagine we’re working on a large application with a dialog component that is
    displayed when some kind of alert has to be presented to the user. This dialog
    can be closed in a number of ways, including clicking the little x in the corner,
    pressing escape on the keyboard, clicking the OK button at the bottom, and so
    on. We’re tasked with adding an analytics call as the dialog closes. We could
    manually add this little piece of code to all the different ways the dialog can
    be closed, but we know we can run an effect as a component unmounts instead. In
    this scenario, only the part of the diagram highlighted in figure 6.6 is relevant.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 想象我们正在开发一个大型应用程序，其中包含一个在需要向用户展示某种警报时显示的对话框组件。这个对话框可以通过多种方式关闭，包括点击角落的小x，按键盘上的escape键，点击底部的OK按钮等。我们的任务是添加一个分析调用，当对话框关闭时。我们可以在对话框关闭的所有不同方式中手动添加这段代码，但我们知道我们可以在组件卸载时运行一个效果。在这种情况下，只有图6.6中突出显示的部分是相关的。
- en: '![06_06](../Images/06_06.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![06_06](../Images/06_06.png)'
- en: Figure 6.6 If only the cleanup function is relevant, there’s no need to specify
    any effect code, only return a function from the effect function. With an empty
    dependency array once again, this code will never run just because the component
    re-renders.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6 如果只有清理函数是相关的，就没有必要指定任何效果代码，只需从效果函数中返回一个函数。再次使用空的依赖数组，这段代码将永远不会因为组件重新渲染而运行。
- en: 'We can do this in our dialog as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在对话框中这样做：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Double arrow notation is required, as we want our effect function to return
    a function when executed.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 双箭头符号是必需的，因为我们希望我们的效果函数在执行时返回一个函数。
- en: Note that this is only a partial example, as it assumes our dialog is part of
    a larger application with a lot more functionality.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这只是一个部分示例，因为它假设我们的对话框是更大应用程序的一部分，具有更多的功能。
- en: Another example, which coincidentally also involves a dialog, is focus management.
    When you use a keyboard to tab your way to a button and press Enter to open a
    dialog, if you then later dismiss the dialog, you want the keyboard focus returned
    to that *same button*, so you can keep tabbing from there to other buttons in
    the user interface. When the dialog opens, we want the keyboard focus to move
    inside the dialog, but once unmounted, we must make sure to reset the keyboard
    focus to whatever element had focus before the dialog was opened. This could be
    done in a useEffect hook with only a cleanup function.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子，巧合的是它还涉及对话框管理。当您使用键盘通过Tab键导航到一个按钮并按Enter键打开对话框后，如果您稍后关闭对话框，您希望键盘焦点返回到那个*相同的按钮*，以便您可以从那里继续Tab键导航到用户界面中的其他按钮。当对话框打开时，我们希望键盘焦点移动到对话框内部，但一旦卸载，我们必须确保将键盘焦点重置到对话框打开之前的任何具有焦点的元素。这可以通过一个只有清理函数的useEffect钩子来完成。
- en: You might note that both of the preceding examples are a bit far-fetched or
    at least very specific to some narrow use cases. That’s because this flow of only
    using a useEffect hook for its cleanup function on unmount is a bit unusual and
    doesn’t happen that often in components in the real world.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到，前面的两个例子都有些牵强，或者至少非常具体于某些狭窄的使用案例。这是因为仅使用useEffect钩子的清理函数在卸载时进行清理的这种流程有些不寻常，在现实世界的组件中并不常见。
- en: 'A much more common use case for the cleanup function is to do exactly what
    it’s named for: clean up after a useEffect that leaves some sort of functionality
    in place after it unmounts, in order to not misuse resources or have memory leaks
    in our application. You saw an example of that in the previous subsection, and
    you’ll see a lot more examples in the future.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 清理函数的一个更常见的用例是做它名字所暗示的事情：清理在卸载后留下某种功能性的useEffect，以避免在应用程序中误用资源或产生内存泄漏。您在前面的小节中看到了一个例子，未来您还将看到更多这样的例子。
- en: 6.1.4 Running an effect on some renders
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.4 在某些渲染上运行效果
- en: Wouldn’t it be wonderful if the title of the tab in the browser updates as the
    user navigates around on our blog? We created the whole blog website in React,
    and it has a component that can dynamically display any blog post. We now want
    to change the document title in an effect that runs every time the blog title
    changes, but it doesn’t need to run if any other property changes. In this scenario,
    only the part of the diagram highlighted in figure 6.7 is relevant. You can see
    this component in listing 6.3.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果浏览器中的标签页标题在用户在我们博客中导航时更新，那岂不是很好？我们使用React创建了整个博客网站，并且有一个可以动态显示任何博客文章的组件。现在我们想在每次博客标题更改时在效果中更改文档标题，但如果任何其他属性更改则不需要运行。在这种情况下，只有图6.7中突出显示的图示部分是相关的。您可以在列表6.3中看到此组件。
- en: '![06-07](../Images/06-07.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![06-07](../Images/06-07.png)'
- en: Figure 6.7 This time, we’ll utilize the dependency array. We want our effect
    to run on mount, but also every time a certain property changes. However, we don’t
    want it to run just because other properties change, so we’re careful about including
    only the relevant variables in the dependency array.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7 这次，我们将利用依赖数组。我们希望我们的效果在挂载时运行，但也每次某个属性更改时运行。然而，我们不想仅仅因为其他属性更改而运行，所以我们小心地只包括依赖数组中的相关变量。
- en: Listing 6.3 Side effect executed in hook
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.3 钩子中执行的效果
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Our effect inside useEffect sets the document title to the value of the title
    property.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们在useEffect中的效果将文档标题设置为标题属性的值。
- en: ❷ Putting only the title in the dependency array ensures that the document title
    is updated only when the post title is.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 只在依赖数组中放置标题确保只有当帖子标题更新时，文档标题才会更新。
- en: 'Repository: rq06-blog-title'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库：rq06-blog-title
- en: 'This example can be seen in repository rq06-blog-title. You can use that repository
    by creating a new app based on the associated template:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例可在rq06-blog-title存储库中查看。您可以通过创建基于相关模板的新应用程序来使用该存储库：
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以访问这个网站浏览代码，直接在浏览器中查看应用程序的实际应用，或者下载源代码的zip文件：
- en: '[https://rq2e.com/rq06-blog-title](https://rq2e.com/rq06-blog-title)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq06-blog-title](https://rq2e.com/rq06-blog-title)'
- en: This is probably the perfect textbook example of what useEffect is meant for,
    that is, to execute side effects of a component. You can’t update the document
    title through the DOM, so it has to be a side effect; for that, useEffect is the
    perfect solution.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是useEffect旨在实现的最佳教科书示例，即执行组件的副作用。你不能通过DOM更新文档标题，所以它必须是一个副作用；为此，useEffect是完美的解决方案。
- en: Updating from a property
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 从属性更新
- en: Another common use case is to update a state value based on a property. You
    might remember from the previous chapter that if we initialize a state in useState
    to the value of a property, it is only set to that property when the component
    renders the first time around on mount. If the component later re-renders with
    a new property value, the state won’t automatically update to that value.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的用例是基于属性更新状态值。你可能还记得，在前一章中，如果我们将状态初始化为useState中的属性值，那么在组件首次渲染并挂载时，它只会设置为那个属性值。如果组件后来以新的属性值重新渲染，状态不会自动更新到那个值。
- en: We can fix that using an effect that depends on the value of the property and
    updates the state value based on it. Let’s build a very simple email input component
    where the user can input their email address. However, we’ll allow the email address
    to be prefilled from the “outside” from a parent component using a property.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一个依赖于属性值的effect来修复这个问题，并根据它更新状态值。让我们构建一个非常简单的电子邮件输入组件，用户可以在其中输入他们的电子邮件地址。然而，我们将允许电子邮件地址通过属性从“外部”由父组件预先填充。
- en: Listing 6.4 State updated from property
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.4 从属性更新的状态
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ We create a new state value, but we don’t initialize it to anything.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们创建了一个新的状态值，但并没有将其初始化为任何内容。
- en: ❷ That’s because on every render where the property value changes, we’ll (re)set
    the email state value to the property. We remember to add a dependency array,
    which is only the value property.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 这是因为在每次属性值变化的渲染中，我们都会（重新）设置电子邮件状态值为属性值。我们记得添加一个依赖数组，它只包含值属性。
- en: ❸ We update the email input field in a new way in this component (discussed
    further in chapter 8).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在这个组件中，我们以新的方式更新电子邮件输入字段（在第八章中进一步讨论）。
- en: ❹ Finally, we update the state value every time the input changes.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 最后，我们每次输入更改时都会更新状态值。
- en: 'Repository: rq06-email-input'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库：rq06-email-input
- en: 'This example can be seen in repository rq06-email-input. You can use that repository
    by creating a new app based on the associated template:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在rq06-email-input存储库中看到。你可以通过创建一个基于相关模板的新应用程序来使用那个存储库：
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以访问这个网站来浏览代码，直接在你的浏览器中查看应用程序的运行情况，或者下载源代码的zip文件：
- en: '[https://rq2e.com/rq06-email-input](https://rq2e.com/rq06-email-input)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq06-email-input](https://rq2e.com/rq06-email-input)'
- en: The use case here can be a little hard to understand, but it’s a pretty common
    pattern in controlled input components.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的用例可能有点难以理解，但在受控输入组件中，这是一个相当常见的模式。
- en: 6.1.5 Running an effect and cleanup on some renders
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.5 在某些渲染上运行效果和清理
- en: This time, rather than a stopwatch that counts up, we’re going to create a countdown
    component that—you guessed it—counts down. This countdown can now be paused and
    resumed. To do that, we still need to run an interval in an effect, but we need
    to stop and start this interval every time the countdown is paused and resumed,
    respectively. To do this, we need to create an effect (with a cleanup function)
    that has a dependency. In this scenario, everything in the diagram shown in figure
    6.8 is relevant.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们不会创建一个向上计时的计时器，而是要创建一个倒计时组件——正如你所猜到的——它会倒计时。现在，这个倒计时可以被暂停和恢复。要做到这一点，我们仍然需要在effect中运行一个间隔，但每次倒计时被暂停和恢复时，我们需要停止和启动这个间隔。为此，我们需要创建一个具有依赖项的effect（带有清理函数）。在这种情况下，图6.8中显示的图中的一切都是相关的。
- en: '![06-08](../Images/06-08.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![06-08](../Images/06-08.png)'
- en: Figure 6.8 Everything in the effect hook is relevant when effect and cleanup
    on some renders are the goals.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8 在某些渲染中，效果钩子中的所有内容都与效果和清理相关。
- en: A countdown component is an example of a component in which we want to run cleanup
    on unmount. This component is different from the stopwatch component from earlier
    in that you can pause, start, and stop the clock whenever you like without unmounting
    and remounting the component (the only way to stop the stopwatch component from
    earlier).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 倒计时组件是我们想要在卸载时运行清理的组件的例子。这个组件与之前提到的计时器组件不同，您可以在不卸载和重新挂载组件的情况下随时暂停、开始和停止时钟（这是停止之前计时器组件的唯一方法）。
- en: The countdown component will be initialized with the starting time of the counter,
    which is 10 in this example. It also has a Reset button that will reset the counter
    to the initial value at any point. Furthermore, there’s a Pause/Resume button
    that will toggle whether the counter is running or not. Finally, there’s the actual
    countdown decreasing every second, pausing the counter once it reaches 0\. To
    make sure we can’t start the counter again at 0, the Pause/Resume button is disabled
    if the countdown is over. This sounds complicated, but take a look at the state
    flowchart for this component in figure 6.9.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 倒计时组件将使用计数器的起始时间初始化，在这个例子中是10。它还有一个重置按钮，可以在任何时间点将计数器重置到初始值。此外，还有一个暂停/继续按钮，可以切换计数器是否运行。最后，还有实际的每秒递减的倒计时，一旦达到0就会暂停计数器。为了确保我们不能在0时再次启动计数器，如果倒计时结束，暂停/继续按钮将被禁用。这听起来很复杂，但请参阅图6.9中此组件的状态流程图。
- en: '![06-09](../Images/06-09.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![06-09](../Images/06-09.png)'
- en: Figure 6.9 The flow of state in the countdown component as time passes and the
    user interacts with the component. Notice in particular how clicking Reset doesn’t
    stop or start the countdown, but just leaves it either running or not. In addition,
    note how the time stops when time runs out.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9 随着时间的推移和用户与组件交互，倒计时组件的状态流。特别注意点击重置不会停止或开始倒计时，只是让它继续运行或停止。此外，注意时间在时间耗尽时停止。
- en: You can see this implemented in the next listing. The result is shown in figure
    6.10.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在下一列表中看到这个实现的示例。结果如图6.10所示。
- en: '![06-10](../Images/06-10.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![06-10](../Images/06-10.png)'
- en: Figure 6.10 The countdown component while running
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.10 运行中的倒计时组件
- en: Listing 6.5 An interactive countdown
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.5 一个交互式倒计时
- en: '[PRE11]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Initializes the seconds to the value of the initial property
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将秒数初始化为初始属性的值
- en: ❷ Initializes the isRunning flag to false
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将isRunning标志初始化为false
- en: ❸ The first thing we check in the effect is whether the countdown is running
    at all. If not, we just abort silently (and return nothing—nothing to clean up).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在效果中，我们首先检查倒计时是否正在运行。如果没有，我们就会静默地终止（并且返回空值——没有要清理的内容）。
- en: ❹ If the countdown is running, we define an interval that updates the state
    value every second.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 如果倒计时正在运行，我们定义一个间隔，每秒更新状态值。
- en: ❺ When we update the state value, we check if the value was 1 (or less); if
    so, we make sure to stop the countdown.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 当我们更新状态值时，我们检查值是否为1（或更少）；如果是，我们确保停止倒计时。
- en: ❻ Returns one less than the current value of the counter
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 返回计数器当前值减一
- en: ❼ Ensures our effect returns a cleanup function that cancels the interval completely
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 确保我们的效果返回一个完全取消间隔的清理函数
- en: ❽ We make our effect depend on the value of the isRunning state value. Whenever
    this value changes, our effect runs (and the cleanup of the last effect runs just
    before it).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 我们使我们的效果依赖于isRunning状态值的值。每当这个值发生变化时，我们的效果就会运行（并且在上一个效果运行之前清理上一个效果）。
- en: ❾ In our component JSX, we have a button that resets the counter and only that
    (it doesn’t change the value of the run flag).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 在我们的组件JSX中，我们有一个重置计数器的按钮，而且只有这个按钮（它不会改变运行标志的值）。
- en: ❿ Another button flips the value of the run flag but doesn’t change the counter.
    This button is disabled, however, if the counter is at zero.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ 另一个按钮会翻转运行标志的值，但不会改变计数器的值。然而，如果计数器为零，则此按钮将被禁用。
- en: ⓫ We vary the text on the toggle button depending on the current state of the
    run flag.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ⓫ 我们根据运行标志的当前状态改变切换按钮上的文本。
- en: 'Repository: rq06-countdown'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库：rq06-countdown
- en: 'This example can be seen in repository rq06-countdown. You can use that repository
    by creating a new app based on the associated template:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例可以在rq06-countdown仓库中看到。您可以通过创建一个基于相关模板的新应用程序来使用该仓库：
- en: '[PRE12]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以访问此网站浏览代码，直接在浏览器中查看应用程序的运行情况，或下载源代码的zip文件：
- en: '[https://rq2e.com/rq06-countdown](https://rq2e.com/rq06-countdown)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq06-countdown](https://rq2e.com/rq06-countdown)'
- en: There’s quite a lot happening in this component, and we use the three hooks
    in a clever combination to achieve the desired goals. One thing you might notice
    is that when our counter reaches zero, we don’t directly stop the interval. In
    listing 6.5, we toggle the running flag to false with setRunning(false);. Doing
    so will force our component to re-render, causing the effect to rerun because
    isRunning is listed as a dependency for the effect. As the effect reruns, the
    cleanup function will stop the interval. So, setting the isRunning flag to false
    will indirectly stop the interval, but only through the magic of the hook.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件中发生了很多事情，我们巧妙地组合使用了三个钩子来实现预期的目标。你可能注意到，当我们的计数器达到零时，我们并没有直接停止间隔。在列表6.5中，我们使用setRunning(false)将运行标志切换为false。这样做将迫使我们的组件重新渲染，因为isRunning被列为效果的依赖项。随着效果的重新运行，清理函数将停止间隔。因此，将isRunning标志设置为false将间接停止间隔，但这是通过钩子的魔法实现的。
- en: This is a pretty advanced component, so it’s okay if you don’t understand it
    at first. We strongly recommend that you download the code for the preceding app
    and play around with it. Try changing parts of the code to see what makes it tick
    and how it works the way it does.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当高级的组件，所以如果你一开始不理解它，那也是正常的。我们强烈建议你下载前面应用的代码，并对其进行操作。尝试更改代码的部分，看看是什么让它运转，以及它是如何工作的。
- en: 6.1.6 Running an effect synchronously
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.6 同步运行效果
- en: Now we’re going to talk about an even more hypothetical situation than we normally
    do. Imagine that we’re creating a component that has a bunch of text in it, and
    we want to count how many letters there are in total and display that number.
    The text is all static, so we could go ahead and count them all by hand before
    creating the component, but we want to make sure the component automatically updates
    the count if we change the text later.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将讨论一个比我们通常讨论的更假设的情况。想象一下，我们正在创建一个包含大量文本的组件，我们想要计算总共有多少个字母，并显示这个数字。文本都是静态的，所以我们可以在创建组件之前手动计算所有字母，但我们要确保如果以后更改文本，组件可以自动更新计数。
- en: One way to create this is to add a state value to the component that will contain
    the letter count and initialize this to zero. Then, we add an effect to the component
    that runs after the component has rendered, counts all the letters, and updates
    the state. When the component re-renders, it will display the correct count. This
    will combine the data flows of an effect hook with that of a state hook, as illustrated
    in figure 6.11.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这种效果的一种方法是为组件添加一个状态值，该值将包含字母计数，并将其初始化为零。然后，我们添加一个效果到组件中，该效果在组件渲染后运行，计算所有字母，并更新状态。当组件重新渲染时，它将显示正确的计数。这将结合效果钩子和状态钩子的数据流，如图6.11所示。
- en: '![06-11](../Images/06-11.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![06-11](../Images/06-11.png)'
- en: Figure 6.11 The state flow as we update state and run an effect. The problem
    here is the darker box. As we update the UI, the user will see the initial 0 displayed
    before the component quickly re-renders and displays the correct number of letters.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.11 更新状态和运行效果时的状态流。这里的问题是较暗的框。当我们更新UI时，用户会在组件快速重新渲染并显示正确的字母数量之前，看到最初显示的0。
- en: The problem with the flow as described and displayed in figure 6.11 is that
    the browser updates the UI and displays it to the user before the effect hook
    runs. This means that the user will see the component render a 0 briefly before
    the component re-renders and displays the correct number of letters.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如图6.11所示，描述和显示的流程问题在于浏览器在效果钩子运行之前就更新了UI并显示给用户。这意味着用户会在组件重新渲染并显示正确的字母数量之前，短暂地看到组件渲染了0。
- en: What if we instead could run an effect *after* React generates the required
    HTML but *before* the browser updates the UI and displays it to the user? Well,
    surprise, surprise, we can do exactly that. We can run a *layout effect hook*
    instead, which does two things differently than the regular effect hook. First,
    it runs before the browser updates the UI, but—just as important—it also runs
    instantly as the DOM is generated. If React detects a state update from a layout
    effect, it will immediately re-render the component with the updated state. We
    can see that in figure 6.12\. By replacing useEffect with useLayoutEffect in this
    special instance, we can avoid a brief flash of the wrong content.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够在 React 生成所需的 HTML 之后，但在浏览器更新 UI 并将其显示给用户之前运行一个效果会如何？嗯，惊喜，惊喜，我们确实可以做到这一点。我们可以运行一个
    *布局效果钩子*，它比常规效果钩子做两件事不同。首先，它在浏览器更新 UI 之前运行，但——同样重要的是——它也随着 DOM 的生成而立即运行。如果 React
    检测到来自布局效果的 state 更新，它将立即使用更新后的状态重新渲染组件。我们可以在图 6.12 中看到这一点。通过在这个特殊实例中将 useEffect
    替换为 useLayoutEffect，我们可以避免错误内容的一闪而过。
- en: '![06-12](../Images/06-12.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![06-12](../Images/06-12.png)'
- en: Figure 6.12 Now that we’re using a layout effect, it will run before the browser
    UI is updated, and the new state will render immediately as the effect updates
    it, which makes the UI correct the first time around.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.12 现在我们正在使用布局效果，它将在浏览器 UI 更新之前运行，并且新的状态将随着效果的更新立即渲染，这使得 UI 在第一次就正确无误。
- en: Do note that useEffect is the correct hook to use in almost all use cases, and
    useLayoutEffect is only relevant in a few specialized instances. Always try useEffect
    first, and only if that doesn’t work for your purpose, see if useLayoutEffect
    might be the right choice instead.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，useEffect 几乎适用于所有用例的正确钩子，而 useLayoutEffect 只在少数特殊情况下相关。始终首先尝试 useEffect，只有当它不符合你的目的时，才考虑
    useLayoutEffect 可能是正确的选择。
- en: Technical details of a layout effect
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 布局效果的详细技术
- en: The useLayoutEffect hook is a variant of useEffect. It’s identical to useEffect
    in every way except *when* it’s called. Similar to useEffect, the useLayoutEffect
    hook also takes a function and a dependency array as arguments. When any dependency
    changes, the cleanup function (if any) of the previous effect is run, and then
    the effect is run for this instance while capturing any potential returned cleanup
    function resulting from the effect.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: useLayoutEffect 钩子是 useEffect 的一个变体。它在所有方面都与 useEffect 相同，除了它被调用的 *时机*。与 useEffect
    类似，useLayoutEffect 钩子也接受一个函数和一个依赖数组作为参数。当任何依赖项发生变化时，上一个效果的清理函数（如果有的话）将被运行，然后为这个实例运行效果，同时捕获任何由效果产生的潜在返回的清理函数。
- en: The difference between useEffect and useLayoutEffect is a bit technical but
    boils down to timing. useLayoutEffect is called *synchronously* in the same execution
    cycle as when the components are rendered into the DOM (but before the browser
    has had a chance to *paint* the DOM to the browser window). On the other hand,
    useEffect is invoked *asynchronously* on the next execution cycle where the DOM
    has been painted to the window and all CSS has taken effect and been calculated.
    The timing of the two events is shown in figure 6.13.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: useEffect 和 useLayoutEffect 之间的区别有点技术性，但归结为时机。useLayoutEffect 在组件渲染到 DOM 中的同一执行周期内被
    *同步调用*（但在浏览器有机会将 DOM 绘制到浏览器窗口之前）。另一方面，useEffect 在下一个执行周期中被异步调用，此时 DOM 已被绘制到窗口，所有
    CSS 都已生效并被计算。这两个事件的时机在图 6.13 中显示。
- en: '![06-13](../Images/06-13.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![06-13](../Images/06-13.png)'
- en: Figure 6.13 The timing of useLayoutEffect versus useEffect. Note how the layout
    effect is run just after the DOM is updated, but before the browser has had a
    chance to lay out the elements using CSS. (Sorry for the crowded diagram!)
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.13 useLayoutEffect 与 useEffect 的时机。注意布局效果是在 DOM 更新后立即运行的，但在浏览器有机会使用 CSS
    布局元素之前。（对于拥挤的图表表示歉意！）
- en: As you can see in figure 6.13, we hid some details from the previous diagrams
    of useEffect execution. Note that here we have a useEffect and a useLayoutEffect
    with the same dependencies. These dependencies can vary, which would make the
    flow run differently for different renders, as some would only run layout effects
    and cleanups, others would run regular effects and cleanups, and still others
    might run both.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在图 6.13 中所见，我们从前面的 useEffect 执行图中隐藏了一些细节。请注意，这里我们有一个 useEffect 和一个 useLayoutEffect，它们具有相同的依赖项。这些依赖项可以变化，这会使不同渲染的流程运行不同，因为一些只会运行布局效果和清理，其他会运行常规效果和清理，还有一些可能会运行两者。
- en: One consequence of a layout effect running synchronously after the render is
    that if the effect is complex, the screen doesn’t update until the effect is complete.
    The UI is basically blocked while the layout effect runs. For this reason, extra
    caution should be used when writing layout effects to make sure they take up as
    few CPU cycles as possible.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 布局效果在渲染后同步运行的一个后果是，如果效果复杂，屏幕不会更新直到效果完成。UI在布局效果运行期间基本上被阻塞。因此，在编写布局效果时应该格外小心，以确保它们尽可能少地占用CPU周期。
- en: If you don’t fully understand the difference between regular effects and layout
    effects, you shouldn’t worry too much about it. In 99% of cases, you ought to
    use the useEffect hook. Only in very rare instances, where you need to update
    the DOM in an effect before it’s painted to the window but after the component
    has rendered, do you need to use the useLayoutEffect hook.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有完全理解常规效果和布局效果之间的区别，你不必过于担心。在99%的情况下，你应该使用useEffect钩子。只有在非常罕见的情况下，你需要在一个效果在绘制到窗口之前但组件已经渲染后更新DOM时，你才需要使用useLayoutEffect钩子。
- en: 6.2 Understanding rendering
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2 理解渲染
- en: In the previous section, we talked about components re-rendering many times.
    In this section, we’ll go into some more technical details about what it means
    for a component to (re-)render. Note that this isn’t directly useful in practice,
    but it’s very important background information to understand what is going on
    in your application.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们讨论了组件多次重新渲染的情况。在本节中，我们将深入探讨一个组件（重新）渲染的技术细节。请注意，这在实际应用中并不直接有用，但它对于理解应用程序中发生的事情是非常重要的背景信息。
- en: 'A functional component will render for one of three reasons:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数组件会因以下三个原因之一进行渲染：
- en: The component has just been *mounted* (as in, the component wasn’t in the component
    tree before, and it is now).
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件刚刚被*挂载*（即，组件之前不在组件树中，现在在）。
- en: The parent component re-rendered.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 父组件重新渲染了。
- en: The component uses stateful hooks, which have updated.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件使用了有状态的钩子，并且已经更新了。
- en: That’s it. If *none* of the preceding things happen, your component *won’t*
    re-render, and that’s a guarantee. If *either* of the three happens, your component
    *will* re-render, for sure. However, React might batch rendering after several
    of these happen, so if both a state value changes and the parent component re-renders,
    the component might only re-render once, or it might re-render twice. That is
    controlled by React and depends on subtle timing details. We’ll give detailed
    examples of all of these scenarios, discuss how you can see these things happen,
    and what you can do when they happen.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了。如果前面的任何一项都没有发生，你的组件*不会*重新渲染，这是一个保证。如果这三个中的任何一个发生，你的组件*一定会*重新渲染。然而，React可能会在发生多次这些情况后批量渲染，所以如果状态值发生变化并且父组件重新渲染，组件可能只重新渲染一次，或者可能重新渲染两次。这由React控制，并取决于微妙的时机细节。我们将给出所有这些场景的详细示例，讨论如何观察这些事情的发生，以及当它们发生时你可以做什么。
- en: Note that we’re talking about your component re-rendering *as a whole*. You
    might have functions or callbacks in your component that render some part of your
    output, and they can re-render for any of a myriad of reasons depending on your
    usage. This is particularly the case if you’re using so-called *render props*,
    which are often used in older codebases and in the non-hook variant of the React
    Context API. You might still see render props in modern and more complex codebases,
    as they can be used to render partial content in a generic component. We’ll discuss
    this topic at the end of this section.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们讨论的是组件整体重新渲染。你可能在组件中拥有函数或回调，它们渲染输出的一部分，并且它们可以根据你的使用情况因无数原因而重新渲染。这尤其适用于你使用所谓的“渲染属性”，这些属性常用于较老的代码库和React上下文API的非钩子变体。你可能在现代和更复杂的代码库中仍然看到渲染属性，因为它们可以用于在通用组件中渲染部分内容。我们将在本节末尾讨论这个话题。
- en: 6.2.1 Rendering on mount
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.1 挂载时的渲染
- en: Imagine that we have a component that loads some external data. We can use the
    example of our remote drop-down from earlier. When it mounts, it loads data from
    a remote server and stores it locally in the component. When it unmounts, the
    data is forgotten.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个加载一些外部数据的组件。我们可以用我们之前提到的远程下拉列表作为例子。当它挂载时，它会从远程服务器加载数据并将其存储在组件中。当它卸载时，数据就会被遗忘。
- en: The render of a component that happens on mount is the most trivial and obvious.
    Note that if a component is included *conditionally* in a parent component, it
    will mount and unmount depending on *that condition*. This isn’t always what you
    want.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 组件在挂载时发生的渲染是最简单和最明显的。请注意，如果组件以*条件性*方式包含在父组件中，它将根据*该条件*挂载和卸载。这并不总是你想要的。
- en: 'If we conditionally render the previously mentioned RemoteDropdown component
    in a parent component, thus toggling it on and off many times, we’ll many times
    load the external data and throw it away, wasting time and bandwidth on the same
    request. While network caching will help somewhat, we can mitigate this in two
    ways. We can either move the data storage and data fetching up to a higher-level
    component, which is always included in the application, or we can conditionally
    render the component differently. You’ll see this sometimes in everyday components.
    Normally we conditionally render a component like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在父组件中条件性地渲染之前提到的 RemoteDropdown 组件，从而多次切换其开/关状态，我们将会多次加载外部数据并将其丢弃，浪费相同请求的时间和带宽。虽然网络缓存会在一定程度上有所帮助，但我们有两种方法可以减轻这种情况。我们可以将数据存储和数据获取移动到更高层次的组件，该组件始终包含在应用程序中，或者我们可以条件性地以不同的方式渲染组件。你有时会在日常组件中看到这种情况。通常，我们会以这种方式条件性地渲染一个组件：
- en: '[PRE13]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ If the Boolean is true, we mount the component. If it is later set to false,
    the component is unmounted.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果布尔值为真，我们挂载组件。如果后来设置为假，组件将被卸载。
- en: 'We can instead do it like this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样做：
- en: '[PRE14]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ We always mount the component and simply toggle a flag as a property.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们始终挂载组件，并简单地切换一个作为属性的标志。
- en: 'We would need to modify the component to use this flag as an indicator about
    whether to render anything at all:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要修改组件以使用此标志作为指示器，表示是否渲染任何内容：
- en: '[PRE15]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ We first include all the hooks that we need in the component.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们首先在组件中包含所有需要的钩子。
- en: ❷ Only after all hooks have been evaluated can we check if we need to render
    anything at all.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 只有在所有钩子都被评估之后，我们才能检查是否需要渲染任何内容。
- en: While this approach to conditional rendering is generally not recommended (and
    the former approach is), this can be a handy tool when you don’t want your component
    to mount and unmount again and again, but you want to keep it in the document
    all the time while only sometimes actually rendering anything.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种条件渲染的方法通常不推荐（以及前一种方法），但在你不希望组件反复挂载和卸载，但希望始终将其保留在文档中，而只是偶尔实际渲染任何内容时，这可以是一个有用的工具。
- en: 6.2.2 Rendering on parent render
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.2 在父组件渲染时渲染
- en: 'This might come partially as a surprise, but every child component also renders
    when their parent component renders. Let’s create this simple example of an icon
    inside a push button:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能部分令人惊讶，但每个子组件在其父组件渲染时也会渲染。让我们创建一个简单的例子，一个图标在按钮内部：
- en: '[PRE16]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '❶ The icon component is extremely simple: it never changes nor updates based
    on anything.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 图标组件非常简单：它从不改变也不根据任何内容更新。
- en: ❷ The button component has internal state and renders every time the state changes.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 按钮组件具有内部状态，并且每次状态改变时都会渲染。
- en: If we test this out in the browser, what do you think will happen? Every time
    we click the button, the enabled flag flips, and the button renders again. But
    what about the icon? Will it render again (as in, will the function named Icon
    be executed again)? Yes, it will. React doesn’t assume that components are “pure,”
    and they might not be. For that reason, React will render the component every
    time that the parent renders. If the component takes properties, React will render
    the component every time, regardless of whether these properties change or not.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在浏览器中测试这个功能，你认为会发生什么？每次我们点击按钮，启用标志都会翻转，按钮会重新渲染。但图标呢？它是否会再次渲染（即，函数名为 Icon
    的函数是否会再次执行）？是的，它会。React 并不假设组件是“纯”的，它们可能不是。因此，每当父组件渲染时，React 都会渲染组件。如果组件有属性，React
    会无论这些属性是否改变都渲染组件。
- en: Let’s imagine a different scenario, where we’re actively utilizing this behavior.
    We can create a dice roller, where we can roll three dice. You can see the code
    in listing 6.6 and the output in figure 6.14.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一个不同的场景，其中我们正在积极利用这种行为。我们可以创建一个骰子投掷器，我们可以投掷三个骰子。你可以在列表 6.6 中看到代码，在图 6.14
    中看到输出。
- en: '![06-14](../Images/06-14.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![06-14](../Images/06-14.png)'
- en: Figure 6.14 Our dice roller after five rolls
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.14 五次投掷后的骰子投掷器
- en: Listing 6.6 A dice roller
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.6 骰子投掷器
- en: '[PRE17]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ Even though our Die component appears to be pure, it actually has an external
    source of information (Math.random) and (potentially) returns something new on
    every render.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 尽管我们的骰子组件看起来是纯的，但实际上它有一个外部信息源（Math.random）并且在每次渲染时（可能）返回新的内容。
- en: ❷ Our DiceRoller component is stateful.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们的DiceRoller组件是有状态的。
- en: ❸ When we click the button, we increase the roll count, which forces a complete
    render of the component, causing all the child components to render and giving
    us new dice values in turn.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 当我们点击按钮时，我们增加投掷次数，这会强制组件完全渲染，导致所有子组件渲染，并依次给我们新的骰子值。
- en: ❹ Three separate instances of the same Die component—each with its own internal
    random source of information
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 同一个骰子组件的三个独立实例——每个实例都有自己的内部随机信息源
- en: 'Repository: rq06-dice-roller'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库：rq06-dice-roller
- en: 'This example can be seen in repository rq06-dice-roller. You can use that repository
    by creating a new app based on the associated template:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在rq06-dice-roller仓库中看到。你可以通过创建一个基于相关模板的新应用程序来使用该仓库：
- en: '[PRE18]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以访问这个网站浏览代码，直接在浏览器中查看应用程序的运行情况，或者下载源代码的zip文件：
- en: '[https://rq2e.com/rq06-dice-roller](https://rq2e.com/rq06-dice-roller)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq06-dice-roller](https://rq2e.com/rq06-dice-roller)'
- en: On a general level, you should always put such variable content (e.g., the value
    of a die roll) inside component state, and not depend on it just magically updating
    on every render as in the preceding example. Please don’t do this at home. This
    makes the previous example a terrible React design pattern. For example, we can’t
    display the sum of the dice in the parent component because it doesn’t know the
    values of the child components.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在一般层面上，你应该始终将此类变量内容（例如，骰子点数的总和）放在组件状态中，而不是依赖它在每次渲染时神奇地更新，就像前面的例子那样。请不要在家这样做。这使得前面的例子成为一个糟糕的React设计模式。例如，我们无法在父组件中显示骰子总和，因为它不知道子组件的值。
- en: A much better structure is for the parent component to generate three random
    numbers and pass them to the dice as properties. But for demonstration purposes,
    this does highlight how even seemingly pure components render when their parent
    component does.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的结构是父组件生成三个随机数并将它们作为属性传递给骰子。但为了演示目的，这确实突出了即使看似纯组件，当它们的父组件渲染时，它们也会进行渲染。
- en: 6.2.3 Rendering on state update
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.3 状态更新时的渲染
- en: When you update the state inside a stateful hook (see chapter 7 for more details
    about stateful hooks), your component using that hook will render. That’s the
    whole purpose of updating the state, so this flow is pretty obvious and even desired.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在有状态钩子（详见第7章有关有状态钩子的更多细节）内部更新状态时，使用该钩子的组件将会进行渲染。这就是更新状态的整个目的，因此这个流程非常明显，甚至可以说是期望的。
- en: But you can also render too often if your state contains data that updates often.
    You want to avoid components rendering all the time, as it can be very CPU and/or
    memory intensive for the browser, as well as annoying for the user.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你的状态包含经常更新的数据，你也会渲染得太频繁。你想要避免组件不断渲染，因为这可能会对浏览器非常CPU和/或内存密集，同时也会对用户造成困扰。
- en: A potential source of frequently updated information is something like the mouse
    position. A user can move the mouse around a lot—many times per second. If you
    have multiple components that store the mouse position in state, you’ll have multiple
    components rendering many times per second, which will slow down your computer.
    Next, we’ll look at two different instances with this setup and how you can minimize
    renders on state updates.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可能频繁更新的信息来源是鼠标位置。用户可以频繁地移动鼠标——每秒多次。如果你有多个组件在状态中存储鼠标位置，你将会有多个组件每秒渲染多次，这会减慢你的计算机速度。接下来，我们将查看两种不同配置的实例以及如何最小化状态更新时的渲染。
- en: Storing higher-level information
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 存储高级信息
- en: Imagine a component that has a yellow background when the cursor is on the left
    side and a blue background when the cursor is on the right side. Let’s say the
    component is 200 pixels wide, so if the cursor is more than 100 pixels from the
    left edge, the cursor is on the right; otherwise, it’s on the left.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个组件，当光标在左侧时背景为黄色，当光标在右侧时背景为蓝色。假设组件宽度为200像素，因此如果光标距离左侧边缘超过100像素，光标就在右侧；否则，就在左侧。
- en: 'The first way to implement this is to save the cursor offset from the left
    side in a state value and, on each render, check which background color to display:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的第一种方法是将光标从左侧的偏移量保存到状态值中，并在每次渲染时检查显示哪种背景颜色：
- en: '[PRE19]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ The state holds the mouse position.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 状态保存鼠标位置。
- en: ❷ Records the mouse position in the state when the mouse moves
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 记录鼠标在移动时的位置状态
- en: ❸ Determines which color to use every time the component renders
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 每次组件渲染时确定使用哪种颜色
- en: 'This method wastes a ton of render cycles, though, because all the time you’re
    moving the mouse around on only one side of the component, it will render again
    and again for every position. A much smarter approach is to just store in state
    whether the cursor is on the left or right side, and nothing else. That way, our
    component only renders when the cursor changes sides:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法浪费了大量的渲染周期，因为当你只在组件的一侧移动鼠标时，它将因为每个位置而一次又一次地重新渲染。一个更聪明的做法是只在状态中存储光标是在左侧还是右侧，其他什么也不存储。这样，我们的组件只有在光标改变方向时才会渲染。
- en: '[PRE20]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ The state holds only a Boolean flag.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 状态只保存一个布尔标志。
- en: ❷ Records the mouse position in the state when the mouse moves
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 记录鼠标在移动时的位置状态
- en: ❸ Determines which color to use every time the component renders
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 每次组件渲染时确定使用哪种颜色
- en: In this example, we utilize the fact that React only renders a component on
    a state update if the state actually changed value. We call the setter function
    just as often as in the previous example, but because we only store a Boolean
    value, which only changes from true to false as the cursor moves over the center
    of the component, most calls to the setter are simply ignored, as they don’t alter
    the component state. This new example results in a much cleaner data flow, and
    now our component only renders when something happens that affects the output.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们利用了React只在实际状态值发生变化时才渲染组件的事实。我们调用setter函数的频率与上一个例子相同，但由于我们只存储一个布尔值，该值仅在鼠标光标移过组件中心时从true变为false，因此大多数setter调用都被简单地忽略，因为它们不会改变组件状态。这个新例子导致数据流更加清晰，现在我们的组件只有在影响输出的某些事情发生时才会渲染。
- en: Manipulating DOM elements directly
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 直接操作DOM元素
- en: In this example, we want to have a component that moves an element in sync with
    the cursor at all times. It seems like we’re doomed with this one. How can we
    update the style of an element in a component without storing it in component
    state?
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们希望有一个组件能够始终与光标同步移动元素。看起来我们注定要失败。我们如何在组件中更新元素样式而不将其存储在组件状态中？
- en: 'For such a case, we might want to look at circumventing React and directly
    updating the DOM instead. To do this, we need a reference to the element in question
    (this requires another hook, useRef, discussed in chapter 7), and on mouse move,
    we’ll update the style of the element directly:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种情况，我们可能想要考虑绕过React并直接更新DOM。为此，我们需要一个指向相关元素的引用（这需要另一个钩子，即第7章中讨论的useRef），然后在鼠标移动时，我们将直接更新元素的样式：
- en: '[PRE21]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ Creates a reference that will point to our DOM element
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个引用，该引用将指向我们的DOM元素
- en: ❷ Directly updates the DOM element through the reference whenever the mouse
    moves
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 每当鼠标移动时，直接通过引用更新DOM元素
- en: ❸ Remember to put the ref on the element that we want to manipulate.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 记得将ref放在我们想要操作的元素上。
- en: This component never re-renders. It renders as it’s mounted, and then it just
    stays around. The mouse event will change the appearance of the component, but
    that is outside React’s control. As seen from React’s perspective, this is a static
    component that doesn’t ever change.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件永远不会重新渲染。它在挂载时渲染，然后只是保持在那里。鼠标事件会改变组件的外观，但这超出了React的控制。从React的角度来看，这是一个永远不会改变的静态组件。
- en: The problem here is that if we need to use the mouse position for other things
    in our application—do some math, check collisions, and so on—we’ll have to store
    it in state anyway. However, if at all possible, we want to avoid updating the
    state often.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是我们如果需要在应用程序的其他地方使用鼠标位置——做一些数学运算、检查碰撞等——我们仍然必须将其存储在状态中。然而，如果可能的话，我们希望避免频繁更新状态。
- en: 6.2.4 Rendering inside functions
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.4 函数内的渲染
- en: A component doesn’t have to render directly inside another component; it can
    also render inside a function, for example. If that’s the case, the component
    will render every time the function runs. Sometimes, such a function only runs
    when the parent component renders, so the result is the same; however, you might
    also have a function that can run at other times, causing the render to happen
    at different times.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 一个组件不必直接在另一个组件内部渲染；它也可以在函数内部渲染，例如。如果是这种情况，组件将在函数每次运行时渲染。有时，这样的函数仅在父组件渲染时运行，所以结果是相同的；然而，你也可能有一个可以在其他时间运行的函数，导致渲染在不同时间发生。
- en: Imagine a button component that allows the parent to specify an icon for the
    component. The button is a push button, so it has a state of either pressed or
    not pressed. Sometimes you want the icon to be different for those two states.
    You can make the component accept two different properties to use for the two
    states, or you can instead accept a function that will receive the state of the
    button as an argument and then return the proper icon.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个按钮组件，允许父组件指定组件的图标。按钮是一个推按钮，因此它有两种状态：按下或未按下。有时你希望这两种状态下的图标不同。你可以让组件接受两个不同的属性来用于这两种状态，或者你可以接受一个函数，该函数将接收按钮的状态作为参数，然后返回适当的图标。
- en: Listing 6.7 A push button with an icon function
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.7 带有图标函数的推按钮
- en: '[PRE22]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ A general icon component embeds an image loaded from the right folder.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 一个通用图标组件嵌入从正确文件夹加载的图像。
- en: ❷ Our button calls the getIcon function with its current state on every render.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们的按钮在每次渲染时都会调用getIcon函数，并传递其当前状态。
- en: ❸ Defines getIcon to return one of two icons
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 定义getIcon以返回两个图标中的一个
- en: 'Repository: rq06-push-button'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库：rq06-push-button
- en: 'This example can be seen in repository rq06-push-button. You can use that repository
    by creating a new app based on the associated template:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在rq06-push-button仓库中看到。你可以通过创建一个基于相关模板的新应用程序来使用该仓库：
- en: '[PRE23]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以访问这个网站来浏览代码，在你的浏览器中直接查看应用程序的运行情况，或者下载源代码的zip文件：
- en: '[https://rq2e.com/rq06-push-button](https://rq2e.com/rq06-push-button)'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq06-push-button](https://rq2e.com/rq06-push-button)'
- en: In this setup, we render the icon component inside a function and not directly
    inside our component. However, the function is only called inside the button component
    directly when it renders, so it’s as if we include an icon conditionally directly
    in the render—we just do it through a function. This does change some of the things
    we know about components, however, and it can be a bit hard to optimize this bit
    of source code or even figure out exactly what’s going on.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种设置中，我们在函数内部渲染图标组件，而不是直接在我们的组件内部渲染。然而，这个函数仅在按钮组件直接渲染时调用，所以这就像我们直接在渲染中条件性地包含一个图标一样——我们只是通过函数来做这件事。然而，这确实改变了一些关于组件的已知事实，优化这部分源代码或甚至弄清楚到底发生了什么可能有点困难。
- en: However, we can also achieve the same result in a much more familiar way. Take
    another look at that getIcon function. It’s a function that returns JSX based
    on some arguments. Does that sound familiar? That’s exactly what a functional
    component does. So, we can alter this slightly to instead make the getIcon function
    into a custom component.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们也可以用一种更熟悉的方式达到相同的结果。再次看看那个getIcon函数。这是一个基于一些参数返回JSX的函数。这听起来熟悉吗？这正是函数组件所做的。因此，我们可以稍作修改，将getIcon函数变成一个自定义组件。
- en: Listing 6.8 A push button with an icon component
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.8 带有图标组件的推按钮
- en: '[PRE24]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ The button component now expects a (capitalized) ButtonIcon property rather
    than a getIcon function as before.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 按钮组件现在期望一个（大写）ButtonIcon属性，而不是之前的getIcon函数。
- en: ❷ Because it’s a component we expect, we can render it as such directly in the
    body.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 因为它是一个我们期望的组件，所以我们可以直接在主体中将其渲染。
- en: ❸ getIcon is now not just a function, but a fully fledged functional component
    (by accepting properties rather than a simple argument).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ getIcon现在不仅是一个函数，而是一个完整的函数组件（通过接受属性而不是简单的参数）。
- en: ❹ Finally, we just supply LockIcon as a property, which is legal to do even
    though we haven’t done it before.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 最后，我们只是将LockIcon作为一个属性提供，尽管我们之前没有这样做过，但这在法律上是允许的。
- en: 'Repository: rq06-push-button2'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库：rq06-push-button2
- en: 'This example can be seen in repository rq06-push-button2. You can use that
    repository by creating a new app based on the associated template:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在rq06-push-button2仓库中看到。你可以通过创建一个基于相关模板的新应用程序来使用该仓库：
- en: '[PRE25]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以访问这个网站来浏览代码，直接在你的浏览器中查看应用程序的运行情况，或者下载源代码的 zip 文件：
- en: '[https://rq2e.com/rq06-push-button2](https://rq2e.com/rq06-push-button2)'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq06-push-button2](https://rq2e.com/rq06-push-button2)'
- en: This works great—and looks so much cleaner! We can, of course, further optimize
    this (e.g., by moving the ternary conditional to the property that changes inside
    the LockIcon component), but that is beyond this example.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这效果很好——看起来干净多了！我们当然可以进一步优化这个例子（例如，通过将三元条件运算符移动到 LockIcon 组件内部更改的属性），但这超出了这个示例的范围。
- en: The concept of providing functions that render JSX is called *render props*
    and was a pretty common approach in older React codebases. However, with functional
    components, almost all such cases are better solved by converting the argument
    to a full component as we did here. It makes the whole flow of data much easier
    to understand and solves ~95% of the cases of a function (i.e., *not* a functional
    component) rendering JSX.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 提供渲染 JSX 的函数的概念被称为 *render props*，这在旧的 React 代码库中是一个相当常见的方法。然而，随着函数组件的出现，几乎所有这些情况都通过将参数转换为完整的组件来更好地解决，就像我们在这里所做的那样。这使得整个数据流更容易理解，并解决了函数（即，*不是*
    函数组件）渲染 JSX 的 ~95% 的情况。
- en: React Context
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: React Context
- en: One of the remaining reasons for rendering JSX in functions is if you use the
    non-hook version of the React Context API with a MyContext.Consumer component.
    This component takes a function as a child component (a mind-blowing concept in
    itself). But that’s quite a special case and not one that you’re likely to encounter
    in a modern React codebase with functional components. If that does happen, you
    should check the online React documentation for how to use the React Context API.
    Even better, convert the component to a functional component and use the useContext
    hook if possible (see chapters 7 and 10 for more details on how to use this hook).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数中使用 JSX 渲染的剩余原因之一是如果你使用 React Context API 的非钩子版本与 MyContext.Consumer 组件。这个组件将一个函数作为子组件（本身就是一个令人震惊的概念）。但这是一个非常特殊的情况，你不太可能在现代使用函数组件的
    React 代码库中遇到这种情况。如果确实发生了这种情况，你应该查看在线 React 文档以了解如何使用 React Context API。更好的做法是将组件转换为函数组件，并在可能的情况下使用
    useContext 钩子（参见第 7 章和第 10 章以获取更多关于如何使用此钩子的详细信息）。
- en: 6.3 The life cycle of a class-based component
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3 基于类的组件的生命周期
- en: When a class-based component mounts, renders, and unmounts, rather than using
    hooks, you can use life cycle methods to react to the different stages in the
    component life cycle. The methods are named after what they do and where they
    fit into the life cycle, so they’re fairly self-evident most of the time.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 当基于类的组件挂载、渲染和卸载时，而不是使用钩子，你可以使用生命周期方法来响应组件生命周期的不同阶段。这些方法的命名是根据它们所做的工作以及它们在生命周期中的位置来命名的，因此在大多数情况下它们是相当直观的。
- en: Some life cycle methods are executed in multiple events. Other life cycle methods
    allow you to interfere with React’s regular scheduling of component updates if
    you have inside knowledge that React doesn’t have. React used to have more life
    cycle methods, but they’ve been deprecated in newer versions of React because
    of their troublesome behavior.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 一些生命周期方法在多个事件中执行。其他生命周期方法允许你在拥有 React 没有的内部知识的情况下，干扰 React 的常规组件更新调度。React 以前有更多的生命周期方法，但由于它们的行为问题，它们在新版本的
    React 中已被弃用。
- en: You ought to be using functional components, but if you do come across a class-based
    component, and you want to refactor it to a functional one, there are some general
    tips for how to make this conversion. Note that this isn’t an exact science, and
    rewriting or completely rethinking the feature might be required.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该使用函数组件，但如果你遇到基于类的组件，并且想要将其重构为函数组件，有一些通用的提示可以帮助你完成这种转换。请注意，这并不是一门精确的科学，可能需要重写或完全重新思考功能。
- en: 6.3.1 Life cycle methods
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.1 生命周期方法
- en: 'When a component mounts, these class methods are called (in this order):'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件挂载时，这些类方法会按顺序被调用：
- en: constructor()
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: constructor()
- en: static getDerivedStateFromProps()
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: static getDerivedStateFromProps()
- en: render()
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: render()
- en: componentDidMount()
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: componentDidMount()
- en: 'When a class-based component updates (for any of the previously mentioned reasons),
    the following methods are invoked (in this order):'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 当基于类的组件更新（由于之前提到的任何原因）时，以下方法会按顺序被调用：
- en: static getDerivedStateFromProps()
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: static getDerivedStateFromProps()
- en: shouldComponentUpdate()
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: shouldComponentUpdate()
- en: render()
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: render()
- en: getSnapshotBeforeUpdate()
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: getSnapshotBeforeUpdate()
- en: componentDidUpdate()
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: componentDidUpdate()
- en: 'Actually, that’s not completely true. shouldComponentUpdate() is special here,
    in that if defined, you can halt the render loop if you return false. It seems
    like a great way to minimize renders, but it can be very tricky to do and, if
    used incorrectly, can lead to components that are out of sync with their actual
    DOM representation. When a component unmounts, the following method is invoked:
    componentDidUnmount().'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这并不完全正确。shouldComponentUpdate() 在这里很特殊，如果你定义了它，并且返回 false，你可以停止渲染循环。这似乎是一个最小化渲染的好方法，但它可能非常棘手，如果使用不当，可能会导致组件与其实际的
    DOM 表示形式不同步。当组件卸载时，将调用以下方法：componentDidUnmount()。
- en: 6.3.2 Legacy life cycle methods
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.2 遗留的生命周期方法
- en: 'A number of life cycle methods existed previously that you might still see
    in some legacy codebases, as these were quite popular to use, but came with a
    lot of problems, hence their deprecation. The methods have been renamed for now,
    but still exist in the React codebase—even in React 18\. At some point, they will
    be removed and not work anymore, but they still work for now. Albeit, if you use
    them, you’ll be aware of how fragile they are based on their current naming. The
    methods *were* called:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 之前存在许多生命周期方法，你可能在一些遗留代码库中仍然看到它们，因为这些方法非常受欢迎，但它们带来了很多问题，因此被弃用。目前这些方法已经被重命名，但仍然存在于
    React 代码库中——甚至在 React 18 中也是如此。在某个时刻，它们将被移除并且不再工作，但到目前为止它们仍然有效。尽管如此，如果你使用它们，你会意识到它们根据当前的命名方式是多么脆弱。这些方法**曾经**被称为：
- en: componentWillMount()
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: componentWillMount()
- en: componentWillUpdate()
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: componentWillUpdate()
- en: componentWillReceiveProps()
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: componentWillReceiveProps()
- en: 'All three have been renamed, and you now have to create the following class
    methods to be able to use the functionality:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个方法都已经重命名，你现在必须创建以下类方法才能使用这些功能：
- en: UNSAFE_componentWillMount()
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UNSAFE_componentWillMount()
- en: UNSAFE_componentWillUpdate()
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UNSAFE_componentWillUpdate()
- en: UNSAFE_componentWillReceiveProps()
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UNSAFE_componentWillReceiveProps()
- en: Typing UNSAFE will get most developers to realize that they probably shouldn’t
    be using this method or at least should have a plan for how to get rid of it fairly
    soon.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 UNSAFE 将让大多数开发者意识到他们可能不应该使用此方法，或者至少应该有一个计划，以便尽快将其淘汰。
- en: We won’t cover their functionality, as they are strongly discouraged. If you
    find them in a codebase, check the online documentation for their functionality,
    so you’re able to recreate the features without these methods.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会介绍它们的功能，因为强烈建议不要使用它们。如果你在代码库中找到它们，请查看在线文档以了解它们的功能，这样你就可以在不使用这些方法的情况下重新创建功能。
- en: 6.3.3 Converting life cycle methods to hooks
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.3 将生命周期方法转换为钩子
- en: 'Converting a class-based component can be tricky. We’ve already seen how to
    deal with some of the tasks involved, which got a bit complicated as we introduced
    stateful components. Now that we add life cycle methods, it gets even more daunting.
    The following lists these methods and describes how you can implement similar
    functionality using hooks:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 将基于类的组件转换为函数组件可能很棘手。我们已经看到了如何处理一些相关的任务，随着我们引入了有状态组件，这些任务变得有些复杂。现在，当我们添加生命周期方法时，它变得更加令人畏惧。以下列出了这些方法，并描述了如何使用钩子实现类似的功能：
- en: constructor()—This method can be implemented either using a useEffect() with
    no dependencies or, if used for precalculating expensive values, in useMemo()
    with no dependencies.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: constructor()——此方法可以通过无依赖项的 useEffect() 实现，或者如果用于预计算昂贵值，则可以在无依赖项的 useMemo()
    中实现。
- en: getDerivedStateFromProps()—This can be implemented with a useEffect() hook with
    the relevant properties as dependencies.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: getDerivedStateFromProps()——这可以通过具有相关属性的 useEffect() 钩子来实现。
- en: render()—The entire functional component is the render function.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: render()——整个函数组件就是渲染函数。
- en: componentDidMount()—This method is mostly used for exactly what a useEffect()
    hook with no dependencies achieves. It’s often used together with componentDidUnmount(),
    which is then the equivalent cleanup function for the hook. Note that to be technically
    correct, componentDidMount runs *synchronously*, whereas useEffect runs *asynchronously*,
    so to achieve the same effect, you might have to use useLayoutEffect. Most of
    the time, however, useEffect will do just fine because the synchronous aspect
    is rarely a factor relevant for this life cycle method.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: componentDidMount()——此方法主要用于实现与无依赖项的 useEffect() 钩子相同的效果。它通常与 componentDidUnmount()
    一起使用，后者是钩子的等效清理函数。请注意，为了在技术上正确，componentDidMount 是**同步**运行的，而 useEffect 是**异步**运行的，因此为了达到相同的效果，你可能需要使用
    useLayoutEffect。然而，大多数时候，useEffect 就足够好了，因为同步方面很少是与此生命周期方法相关的因素。
- en: shouldComponentUpdate()—This method has no hook equivalent, but it’s also not
    necessary when using hooks. If you want to minimize the renders of a functional
    component, use the memoization hooks briefly introduced in the next chapter.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: shouldComponentUpdate()—这个方法没有钩子等效，但在使用钩子时也不必要。如果你想最小化功能组件的渲染次数，请使用下一章简要介绍的
    memoization 钩子。
- en: getSnapshotBeforeUpdate()—This is a weird method that’s seldom used. It’s almost
    exclusively used for a single specific purpose, which is to record the scroll
    position of some part of a component *before* the component updates, so you can
    restore that position *after* the component updates with new data. This specific
    behavior can be emulated in a functional component by wrapping the state setter
    in a custom function that records the old scroll position in a reference before
    updating the component and causing a new render.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: getSnapshotBeforeUpdate()—这是一个很少使用的奇怪方法。它几乎仅用于单一特定目的，即记录组件更新前的某个部分的滚动位置，这样你就可以在组件更新后使用新数据恢复该位置。这种特定行为可以通过在更新组件和导致新渲染之前，在自定义函数中记录旧滚动位置的方式在功能组件中模拟。
- en: componentDidUpdate()—This can be emulated with a useEffect hook with dependencies
    set to the relevant values that have changed and caused whatever changed behavior
    that you want to react to.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: componentDidUpdate()—这个方法可以通过设置相关值作为依赖项的 useEffect 钩子来模拟，这些值导致了你想要响应的任何改变行为。
- en: componentDidUnmount()—Functionality in this method can be moved to a cleanup
    function in a useEffect (or useLayoutEffect) hook with no dependencies. This is
    often used to cancel subscriptions or intervals set on mount, so it goes together
    with the effect in the same hook.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: componentDidUnmount()—这个方法中的功能可以移动到没有依赖项的 useEffect（或 useLayoutEffect）钩子中的清理函数。这通常用于取消在挂载时设置的订阅或间隔，因此它与同一钩子中的副作用一起使用。
- en: 6.4 Quiz
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4 习题
- en: It’s not possible to run side effects inside functional components, as only
    class-based components can do that. *True* or *false*?
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在功能组件内部无法运行副作用，因为只有基于类的组件才能这样做。*正确*还是*错误*？
- en: When can you run an effect using an effect hook?
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以在何时使用 effect 钩子运行副作用？
- en: As the component *mounts*
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当组件 *挂载*
- en: As the component *unmounts*
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当组件 *卸载*
- en: As the component *updates*
  id: totrans-311
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当组件 *更新*
- en: All of the above
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有上述选项
- en: If you want to load data in a component as soon as it’s displayed, but then
    not reload the data even if the component updates, your dependency array should
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你希望在组件显示时立即加载数据，但在组件更新后不重新加载数据，你的依赖数组应该
- en: Be skipped
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 被跳过
- en: Be empty
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持为空
- en: Contain only the URL of the data
  id: totrans-316
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅包含数据的 URL
- en: When a parent component renders, the child components only re-render if their
    properties update. *True* or *false*?
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当父组件渲染时，子组件只有在它们的属性更新时才会重新渲染。*正确*还是*错误*？
- en: What is the correct syntax for an effect hook that only runs as the component
    unmounts?
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于仅在组件卸载时运行的副作用钩子的正确语法是什么？
- en: useEffect(() => runOnUnmount(), []);
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: useEffect(() => runOnUnmount(), []);
- en: useEffect(() => () => runOnUnmount(), []);
  id: totrans-320
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: useEffect(() => () => runOnUnmount(), []);
- en: useEffect(() => runOnUnmount());
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: useEffect(() => runOnUnmount());
- en: useEffect(() => () => runOnUnmount());
  id: totrans-322
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: useEffect(() => () => runOnUnmount());
- en: Quiz answers
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 习题答案
- en: '*False*. Via the useEffect (and alternatively useLayoutEffect) hook, you can
    run side effects inside functional components too.'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*错误*。通过 useEffect（以及备选的 useLayoutEffect）钩子，你同样可以在功能组件内部运行副作用。'
- en: You can run an effect on any particular render of the component and even as
    it unmounts, so all of the scenarios are true.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以在组件的任何特定渲染上运行副作用，甚至在它卸载时，所以所有这些场景都是正确的。
- en: If you want to run an effect only as a component mounts, you should supply an
    empty dependency array.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你只想在组件挂载时运行副作用，你应该提供一个空的依赖数组。
- en: '*False*. Any time a component renders, all the child components of that component
    will render too, regardless of whether their properties change or not.'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*错误*。每当组件渲染时，该组件的所有子组件也会渲染，无论它们的属性是否改变。'
- en: useEffect(() => () => runOnUnmount(), []);. An unmount (also known as a cleanup)
    effect has to be returned by the effect function, so double function notation
    is required. In addition, the dependency array has to be empty, not skipped.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: useEffect(() => () => runOnUnmount(), []);. 卸载（也称为清理）副作用必须由副作用函数返回，因此需要双重函数表示法。此外，依赖数组必须是空的，不能被跳过。
- en: Summary
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: A React component has an individual life cycle for each instance of the component.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 React 组件的每个实例都有一个独立的生命周期。
- en: The useEffect hook is the primary way to trigger side effects that are relevant
    for the particular component as a component mounts, renders, and unmounts.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: useEffect 钩子是触发与特定组件挂载、渲染和卸载相关的副作用的主要方式。
- en: By carefully crafting the dependency array, you can trigger an effect hook to
    run at exactly the times you need it to run, which is how you can make smart components
    that interact with the browser, network, and user in many different ways.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过精心构建依赖数组，你可以触发副作用钩子恰好在你需要它运行的时间点运行，这就是如何创建能够以多种方式与浏览器、网络和用户交互的智能组件的方法。
- en: 'Components render whenever React determines that they need to under three main
    circumstances: when the component mounts, when the state of the component updates,
    and when the parent component renders.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件在以下三种主要情况下会被渲染：当组件挂载时，当组件的状态更新时，以及当父组件渲染时。
- en: Class-based components can’t use hooks but rely on life cycle methods for similar
    behavior. These can be converted to hooks, but the conversion isn’t always straightforward.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于类的组件不能使用钩子，而是依赖于生命周期方法来实现类似的行为。这些方法可以被转换为钩子，但转换并不总是直接的。
