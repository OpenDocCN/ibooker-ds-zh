- en: 17 Input and output
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 17 输入和输出
- en: Up to this point in the book, we’ve primarily been relying on PowerShell’s native
    ability to output tables and lists. As you start to combine commands into more
    complex scripts, you’ll probably want to gain more precise control over what’s
    displayed. You may also need to prompt a user for input. In this chapter, you’ll
    learn how to collect that input and how to display whatever output you might desire.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到本书的这一部分，我们主要依赖 PowerShell 的原生能力来输出表格和列表。当你开始将命令组合成更复杂的脚本时，你可能希望对显示的内容有更精确的控制。你可能还需要提示用户输入。在本章中，你将学习如何收集输入以及如何显示你可能需要的任何输出。
- en: We want to point out, however, that the contents of this chapter are useful
    only for scripts that interact with human eyeballs and fingertips. For scripts
    that run unattended, these aren’t appropriate techniques, because there won’t
    be a human being around to interact with.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们想指出，本章的内容仅适用于与人类眼睛和手指交互的脚本。对于无人值守运行的脚本，这些技术并不适用，因为没有人在场进行交互。
- en: 17.1 Prompting for, and displaying, information
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.1 提示和显示信息
- en: The way PowerShell displays and prompts for information depends on how it’s
    being run. You see, PowerShell is built as a kind of under-the-hood engine.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 显示和提示信息的方式取决于它的运行方式。你知道，PowerShell 是作为一种底层的引擎构建的。
- en: What you interact with is called a *host application*. The command-line console
    you see when running the PowerShell executable in a terminal application is often
    called the *console host*. Another common host is called the *integrated host*,
    which is represented as the PowerShell Integrated Console supplied by the PowerShell
    extension for Visual Studio Code. Other non-Microsoft applications can host the
    shell’s engine as well. In other words, you, as the user, interact with the hosting
    application, and it, in turn, passes your commands through to the engine. The
    hosting application displays the results that the engine produces.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你与之交互的应用程序称为 *宿主应用程序*。当你在一个终端应用程序中运行 PowerShell 可执行文件时看到的命令行控制台通常被称为 *控制台宿主*。另一个常见的宿主称为
    *集成宿主*，它由 Visual Studio Code 的 PowerShell 扩展提供的 PowerShell 集成控制台表示。其他非微软应用程序也可以托管
    shell 的引擎。换句话说，作为用户，你与宿主应用程序交互，然后它将你的命令传递给引擎。宿主应用程序显示引擎产生的结果。
- en: Note Another well-known host is in the PowerShell worker for Azure Functions.
    Azure Functions is Microsoft Azure’s serverless offering, which is fancy talk
    for a service that allows you to run an arbitrary PowerShell script in the cloud
    without managing the underlying environment that script is running in. This host
    is interesting—because it’s run unattended, there’s no interactive element of
    this host, unlike the console or integrated host.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 另一个著名的宿主是 PowerShell worker for Azure Functions。Azure Functions 是微软 Azure
    的无服务器服务，这听起来像是允许你在云中运行任意 PowerShell 脚本而不需要管理脚本运行在其中的底层环境的一种服务。这个宿主很有趣——因为它是不受监督运行的，所以这个宿主没有交互元素，与控制台或集成宿主不同。
- en: Figure 17.1 illustrates the relationship between the engine and the various
    hosting applications. Each hosting application is responsible for physically displaying
    any output the engine produces and physically collecting any input the engine
    requests. That means PowerShell can display output and manage input in different
    ways.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.1 阐述了引擎与各种宿主应用程序之间的关系。每个宿主应用程序负责物理显示引擎产生的任何输出，并物理收集引擎请求的任何输入。这意味着 PowerShell
    可以以不同的方式显示输出和管理输入。
- en: '![](Images/CH17_F01_Plunk.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH17_F01_Plunk.png)'
- en: Figure 17.1 Various applications are capable of hosting the PowerShell engine.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.1 不同的应用程序能够托管 PowerShell 引擎。
- en: We want to point out these differences because it can sometimes be confusing
    to newcomers. Why would one command behave one way in the command-line window
    but behave differently in, say, Azure Functions? It’s because the hosting application
    determines the way in which you interact with the shell, not the PowerShell engine.
    The commands we’re about to show you exhibit slightly different behavior depending
    on where you run them.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想指出这些差异，因为有时对于新手来说可能会感到困惑。为什么一个命令在命令行窗口中表现一种方式，但在 Azure Functions 等地方表现不同？这是因为宿主应用程序决定了你与
    shell 交互的方式，而不是 PowerShell 引擎。我们即将展示的命令根据你运行它们的位置会表现出略微不同的行为。
- en: 17.2 Read-Host
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.2 Read-Host
- en: 'PowerShell’s `Read-Host` cmdlet is designed to display a text prompt and then
    collect text input from the user. Because you saw us use this for the first time
    in the previous chapter, the syntax may seem familiar:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 的 `Read-Host` 命令用于显示文本提示并从用户那里收集文本输入。由于你在上一章中第一次看到我们使用它，所以语法可能看起来很熟悉：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This example highlights two important facts about the cmdlet:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子突出了关于该命令的两个重要事实：
- en: A colon is appended to the end of the line of text.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在文本行的末尾附加一个冒号。
- en: Whatever the user types is returned as the result of the command (technically,
    it’s placed into the pipeline, but more on that later).
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户输入的任何内容都将作为命令的结果返回（技术上，它被放入管道中，但稍后我们会详细介绍这一点）。
- en: 'You’ll often capture the input into a variable, which looks like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常会捕获输入到一个变量中，它看起来像这样：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Try it Now Time to start following along. At this point, you should have a valid
    computer name in the `$computername` variable. Don’t use SERVER-UBUNTU unless
    that’s the name of the computer you’re working on.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 是时候开始跟进了。在这个时候，你应该在 `$computername` 变量中有一个有效的计算机名。除非你正在工作的计算机的名称是 SERVER-UBUNTU，否则不要使用
    SERVER-UBUNTU。
- en: 17.3 Write-Host
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.3 Write-Host
- en: Now that you can collect input, you’ll want some way of displaying output. The
    `Write-Host` cmdlet is one way. It’s not always the best way, but it’s available
    to you, and it’s important that you understand how it works.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你能够收集输入，你可能需要一种显示输出的方式。`Write-Host` 命令就是这样一种方式。它并不总是最好的方式，但它可供你使用，并且了解它是如何工作的是非常重要的。
- en: 'As figure 17.2 illustrates, `Write-Host` runs in the pipeline like any other
    cmdlet, but it doesn’t place anything into the pipeline. Instead, it does two
    things: writes a record into the “information stream” (don’t worry, we’ll cover
    this later!) and writes directly to the hosting application’s screen.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 正如图 17.2 所示，`Write-Host` 与其他任何命令一样在管道中运行，但它不会将任何内容放入管道。相反，它做了两件事：将一条记录写入“信息流”（别担心，我们稍后会介绍这一点！）并直接写入宿主应用程序的屏幕。
- en: '![](Images/CH17_F02_Plunk.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH17_F02_Plunk.png)'
- en: Figure 17.2 `Write-Host` bypasses the pipeline and writes directly to the hosting
    application’s display.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.2 `Write-Host` 跳过管道并直接写入宿主应用程序的显示。
- en: Now, because `Write-Host` writes directly to the host app’s screen, it’s able
    to use alternate foreground and background colors through its `-ForegroundColor`
    and `-BackgroundColor` command-line parameters. You can see all the available
    colors by running `get-help -command write-host`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，因为 `Write-Host` 直接写入宿主应用程序的屏幕，所以它能够通过其 `-ForegroundColor` 和 `-BackgroundColor`
    命令行参数使用交替的前景色和背景色。你可以通过运行 `get-help -command write-host` 来查看所有可用的颜色。
- en: Try it Now Run `Get-Help Write-Host`. What colors are available for the `ForegroundColor`
    and `BackgroundColor` parameters? Now that we know what colors are available,
    let’s have a little fun.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 运行 `Get-Help Write-Host`。`ForegroundColor` 和 `BackgroundColor` 参数有哪些可用的颜色？现在我们知道了有哪些颜色可用，让我们来点乐趣。
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Try it Now You’ll want to run this command yourself to see the colorful results.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 你需要自己运行这个命令来查看多彩的结果。
- en: Note Not every application that hosts PowerShell supports alternate text colors,
    and not every application supports the full set of colors. When you attempt to
    set colors in such an application, it will usually ignore any colors it doesn’t
    like or can’t display. That’s one reason we tend to avoid relying on special colors
    at all.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 并非所有支持 PowerShell 的宿主应用程序都支持交替的文本颜色，也并非所有应用程序都支持完整的颜色集。当你尝试在这样一个应用程序中设置颜色时，它通常会忽略它不喜欢或无法显示的任何颜色。这也是我们倾向于完全不依赖特殊颜色的一个原因。
- en: The `Write-Host` command has a bad reputation because in earlier version of
    Power-Shell, it didn’t do much. It acted as a mechanism to display information
    to the user via the console and didn’t muddy any of the streams (yes, we know,
    we keep talking about these pesky things, and we will get to them, we promise).
    But starting in PowerShell 5, the `Write-Host` command was redesigned. It is now
    a wrapper for the `Write-Information` command, as it needed to be backward compatible.
    It still will output the text to your screen but will also put your text into
    the information stream so you can use it later. But `Write-Host` does have its
    limitations and may not always be the correct cmdlet for the job.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`Write-Host` 命令有一个坏名声，因为在 PowerShell 的早期版本中，它并没有做什么。它作为一个机制，通过控制台向用户显示信息，并且不会弄脏任何流（是的，我们知道，我们一直在谈论这些讨厌的东西，我们承诺会涉及到它们）。但是从
    PowerShell 5 开始，`Write-Host` 命令被重新设计。现在它是一个 `Write-Information` 命令的包装器，因为它需要向后兼容。它仍然会将文本输出到您的屏幕上，但也会将您的文本放入信息流中，以便您稍后使用。但是
    `Write-Host` 确实有其局限性，并且可能并不总是完成这项工作的正确 cmdlet。'
- en: For example, you should never use `Write-Host` to manually format a table. You
    can find better ways to produce the output, using techniques that enable PowerShell
    itself to handle the formatting. We won’t dive into those techniques in this book,
    because they belong more in the realm of heavy-duty scripting and tool making.
    However, you can check out *Learn PowerShell Scripting in a Month of Lunches by
    Don Jones and Jeffery Hicks* (Manning, 2017) for full coverage of those output
    techniques.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您永远不应该使用 `Write-Host` 来手动格式化表格。您可以使用更好的方法来生成输出，使用能够使 PowerShell 本身处理格式的技术。我们不会在本书中深入探讨这些技术，因为它们更适合重型脚本和工具制作领域。然而，您可以查阅
    Don Jones 和 Jeffery Hicks 所著的 *《一个月午餐时间学习 PowerShell 脚本编程》*（Manning，2017），以全面了解这些输出技术。
- en: '`Write-Host` is also not the best way to produce error messages, warnings,
    debugging messages, and so on—again, you can find more specific ways to do those
    things, and we’ll cover those in this chapter. The only time you will really be
    using `Write-Host` is if you want to make a message on the screen with fancy colors
    in it.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`Write-Host` 也不是产生错误消息、警告、调试消息等最佳方式——再次强调，您可以找到更多具体的方法来做这些事情，我们将在本章中介绍这些方法。您真正会使用
    `Write-Host` 的情况是，如果您想在屏幕上显示带有花哨颜色的消息。'
- en: Note We often see people using `Write-Host` to display what we call “warm and
    fuzzy” messages—things like “Now connecting to SERVER2,” and “Testing for folder.”
    We suggest you use the `Write-Verbose` messages instead. The reason we suggest
    this is because the output being sent the `Verbose` stream (which can be suppressed)
    as opposed to the `Information` stream.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们经常看到人们使用 `Write-Host` 来显示我们所说的“温馨舒适”的消息——比如“现在连接到 SERVER2”和“测试文件夹”。我们建议您使用
    `Write-Verbose` 消息。我们建议这样做的原因是，输出被发送到 `Verbose` 流（可以抑制），而不是 `Information` 流。
- en: Above and beyond
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 超越
- en: We’ll dive into `Write-Verbose` and the other `Write` cmdlets a bit more in
    chapter 20\. But if you try `Write-Verbose` now, you might be disappointed to
    discover that it doesn’t produce any output. Well, not by default.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 20 章中更深入地探讨 `Write-Verbose` 和其他 `Write` cmdlet。但是，如果您现在尝试 `Write-Verbose`，您可能会失望地发现它没有产生任何输出。好吧，默认情况下没有。
- en: If you plan to use `Write` cmdlets, the trick is to turn them on first. For
    example, set `$VerbosePreference="Continue"` to enable `Write-Verbose`, and `$Verbose-Preference="SilentlyContinue"`
    to suppress its output. You’ll find similar “preference” variables for `Write-Debug`
    (`$DebugPreference`) and `Write-Warning` (`$WarningPreference`).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您计划使用 `Write` cmdlet，技巧是首先将其打开。例如，设置 `$VerbosePreference="Continue"` 以启用 `Write-Verbose`，以及
    `$Verbose-Preference="SilentlyContinue"` 以抑制其输出。您会发现类似“偏好”变量用于 `Write-Debug` (`$DebugPreference`)
    和 `Write-Warning` (`$WarningPreference`)。
- en: Chapter 20 includes an even cooler way to use `Write-Verbose`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 第 20 章介绍了一种更酷的 `Write-Verbose` 使用方法。
- en: It may seem much easier to use `Write-Host`, and if you want to, you can. But
    keep in mind that by using the other cmdlets, such as `Write-Verbose`, you’re
    going to be following PowerShell’s own patterns more closely, resulting in a more
    consistent experience.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Write-Host` 可能看起来更容易，如果您愿意，您可以使用它。但请记住，通过使用其他 cmdlet，例如 `Write-Verbose`，您将更紧密地遵循
    PowerShell 的自身模式，从而获得更一致的经验。
- en: 17.4 Write-Output
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.4 Write-Output
- en: Unlike `Write-Host`, `Write-Output` can send objects into the pipeline. Because
    it isn’t writing directly to the display, it doesn’t permit you to specify alternative
    colors or anything. In fact, `Write-Output` (or its alias, `Write`) isn’t technically
    designed to display output at all. As we said, it sends objects into the pipeline—it’s
    the pipeline itself that eventually displays those objects. Figure 17.3 illustrates
    how this works.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `Write-Host` 不同，`Write-Output` 可以将对象发送到管道。因为它不是直接写入显示，所以不允许你指定替代颜色或其他任何内容。实际上，`Write-Output`（或其别名
    `Write`）在技术上并不是为了显示输出而设计的。正如我们所说的，它将对象发送到管道——是管道本身最终显示那些对象。图 17.3 展示了这是如何工作的。
- en: '![](Images/CH17_F03_Plunk.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH17_F03_Plunk.png)'
- en: Figure 17.3 `Write-Output` puts objects into the pipeline, which in some cases
    eventually results in those objects being displayed.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.3 `Write-Output` 将对象放入管道，在某些情况下最终会导致这些对象被显示。
- en: 'Refer to chapter 11 for a quick review of how objects go from the pipeline
    to the screen. Let’s look at the basic process:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 参考第 11 章快速回顾对象如何从管道到屏幕的过程。让我们看看基本过程：
- en: '`Write-Output` puts the `String` object `Hello` into the pipeline.'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Write-Output` 将 `String` 对象 `Hello` 放入管道。'
- en: Because nothing else is in the pipeline, `Hello` travels to the end of the pipeline,
    where `Out-Default` always sits.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为管道中没有其他内容，`Hello` 会移动到管道的末端，而 `Out-Default` 总是坐在那里。
- en: '`Out-Default` passes the object to `Out-Host`.'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Out-Default` 将对象传递给 `Out-Host`。'
- en: '`Out-Host` asks PowerShell’s formatting system to format the object. Because
    in this example it’s a simple `String`, the formatting system returns the text
    of the string.'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Out-Host` 要求 PowerShell 的格式化系统格式化对象。因为在这个例子中它是一个简单的 `String`，格式化系统返回字符串的文本。'
- en: '`Out-Host` places the formatted result onto the screen.'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Out-Host` 将格式化后的结果放置到屏幕上。'
- en: 'The results are similar to what you’d get using `Write-Host`, but the object
    takes a different path to get there. That path is important, because the pipeline
    could contain other things. For example, consider the following command (which
    you’re welcome to try):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 结果与使用 `Write-Host` 得到的结果相似，但对象到达那里的路径不同。这个路径很重要，因为管道中可能包含其他内容。例如，考虑以下命令（你可以尝试一下）：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You don’t see any output from this command, and figure 17.4 illustrates why.
    `Hello` is placed into the pipeline. But before it gets to `Out-Default`, it has
    to pass through `Where-Object`, which filters out anything having a `Length` property
    of less than or equal to `10`, which in this case includes our poor `Hello`. Our
    `Hello` gets dropped out of the pipeline, and because there’s nothing left in
    the pipeline for `Out-Default`, there’s nothing to pass to `Out-Host`, so nothing
    is displayed. Contrast that command with the following one:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你看不到这个命令的任何输出，图 17.4 展示了原因。`Hello` 被放入管道。但在到达 `Out-Default` 之前，它必须通过 `Where-Object`，该对象会过滤掉任何具有小于或等于
    `10` 的 `Length` 属性的对象，在这个例子中包括我们可怜的 `Hello`。我们的 `Hello` 被从管道中移除，因为管道中已经没有其他内容留给
    `Out-Default`，所以没有内容传递给 `Out-Host`，因此没有显示。将此命令与以下命令进行对比：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![](Images/CH17_F04_Plunk.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH17_F04_Plunk.png)'
- en: Figure 17.4 Placing objects into the pipeline means they can be filtered out
    before they’re displayed.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.4 将对象放入管道意味着它们可以在显示之前被过滤掉。
- en: All we’ve done is replace `Write-Output` with `Write-Host`. This time, `Hello`
    goes directly to the screen, not into the pipeline. `Where-Object` has no input
    and produces no output, so nothing is displayed by `Out-Default` and `Out-Host`.
    But because `Hello` has been written directly to the screen, we see it anyway.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的只是将 `Write-Output` 替换为 `Write-Host`。这次，`Hello` 直接显示在屏幕上，而不是进入管道。`Where-Object`
    没有输入也不产生输出，所以 `Out-Default` 和 `Out-Host` 都没有显示任何内容。但是因为 `Hello` 已经直接写入屏幕，所以我们仍然看到了它。
- en: '`Write-Output` may seem new, but it turns out you’ve been using it all along.
    It’s the shell’s default cmdlet. When you tell the shell to do something that
    isn’t a command, the shell passes whatever you typed to `Write-Output` behind
    the scenes.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`Write-Output` 可能看起来很新，但事实上你一直在使用它。它是 shell 的默认 cmdlet。当你告诉 shell 做一些不是命令的事情时，shell
    会将你输入的内容传递给 `Write-Output`。'
- en: 17.5 Other ways to write
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.5 其他写入方式
- en: PowerShell has a few other ways to produce output. None of these write to the
    pipeline as `Write-Output` does; they work a bit more like `Write-Host`. But all
    of them produce output in a way that can be suppressed.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 有几种其他产生输出的方式。它们都不像 `Write-Output` 那样写入管道；它们的工作方式更类似于 `Write-Host`。但它们都以可以抑制的方式产生输出。
- en: The shell comes with built-in configuration variables for each of these alternative
    output methods. When the configuration variable is set to `Continue`, the commands
    we’re about to show you do indeed produce output. When the configuration variable
    is set to `SilentlyContinue`, the associated output command produces nothing.
    Table 17.1 contains the list of cmdlets.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 为这些替代输出方法中的每一个都内置了配置变量。当配置变量设置为 `Continue` 时，我们即将向您展示的命令确实会产生输出。当配置变量设置为
    `SilentlyContinue` 时，相关的输出命令不会产生任何输出。表 17.1 包含了 cmdlet 的列表。
- en: Table 17.1 Alternative output cmdlets
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 表 17.1 替代输出 cmdlet
- en: '| Cmdlet | Purpose | Configuration variable |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| Cmdlet | 目的 | 配置变量 |'
- en: '| `Write-Warning` | Displays warning text, in yellow by default, and preceded
    by the label `WARNING:` | `$WarningPreference (Continue by default)` |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `Write-Warning` | 默认以黄色显示警告文本，并在其前加上标签 `WARNING:` | `$WarningPreference (默认为
    Continue)` |'
- en: '| `Write-Verbose` | Displays additional informative text, in yellow by default,
    and preceded by the label `VERBOSE:` | `$VerbosePreference (SilentlyContinue by
    default)` |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `Write-Verbose` | 显示额外的信息性文本，默认以黄色显示，并在其前加上标签 `VERBOSE:` | `$VerbosePreference
    (默认为 SilentlyContinue)` |'
- en: '| `Write-Debug` | Displays debugging text, in yellow by default, and preceded
    by the label `DEBUG:` | `$DebugPreference (SilentlyContinue by default)` |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `Write-Debug` | 默认以黄色显示调试文本，并在其前加上标签 `DEBUG:` | `$DebugPreference (默认为 SilentlyContinue)`
    |'
- en: '| `Write-Error` | Produces an error message | `$ErrorActionPreference (Continue
    by default)` |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `Write-Error` | 生成错误消息 | `$ErrorActionPreference (默认为 Continue)` |'
- en: '| `Write-Information` | Displays informational messages and allows structured
    data to be written to an information stream | `$InformationPreference (SilentlyContinue
    by default)` |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `Write-Information` | 显示信息性消息，并允许结构化数据写入信息流 | `$InformationPreference (默认为
    SilentlyContinue)` |'
- en: Note `Write-Host` uses `Write-Information` under the hood, which means that
    `Write-Host` messages get sent to the information stream in addition to the host
    application. This gives us the ability to do more with `Write-Host` by controlling
    its behavior with `$InformationPreference`, among other things that we can do
    with PowerShell streams.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `Write-Host` 在底层使用 `Write-Information`，这意味着 `Write-Host` 消息除了发送到宿主应用外，还会发送到信息流。这使得我们能够通过控制
    `$InformationPreference` 等其他我们可以对 PowerShell 流做的事情，来使用 `Write-Host` 做更多的事情。
- en: '`Write-Error` works a bit differently because it writes an error to PowerShell’s
    error stream. PowerShell also has a `Write-Progress` cmdlet that can display progress
    bars, but it works entirely differently. Feel free to read its help for more information
    and for examples; we don’t cover it in this book.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`Write-Error` 的工作方式略有不同，因为它会将错误写入 PowerShell 的错误流。PowerShell 还有一个 `Write-Progress`
    cmdlet 可以显示进度条，但它的工作方式完全不同。你可以自由地阅读其帮助文档以获取更多信息，以及示例；我们在这本书中不会涉及它。'
- en: To use any of these cmdlets, first make sure that its associated configuration
    variable is set to `Continue`. (If it’s set to `SilentlyContinue`, which is the
    default for a couple of them, you won’t see any output at all.) Then use the cmdlet
    to output a message.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这些 cmdlet 中的任何一个，首先确保其相关的配置变量设置为 `Continue`。（如果设置为 `SilentlyContinue`，这是其中一些的默认设置，你将看不到任何输出。）然后使用
    cmdlet 输出一个消息。
- en: Note Some PowerShell hosting applications may display the output from these
    cmdlets in a different location. In Azure Functions, for example, debugging text
    is written to a log in Application Insights (an Azure log-reporting service) instead
    of a terminal window because in a serverless environment, you’re not looking at
    a terminal; the PowerShell script is running somewhere up in the cloud. This is
    done for ease of debugging your scripts and so that you can see the output somewhere.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意某些 PowerShell 宿主应用可能会将这些 cmdlet 的输出显示在不同的位置。例如，在 Azure Functions 中，调试文本被写入到
    Application Insights（一个 Azure 日志报告服务）中的日志，而不是终端窗口，因为在无服务器环境中，你不会看到终端；PowerShell
    脚本正在云中的某个地方运行。这样做是为了便于调试脚本，并且你可以看到输出。
- en: 17.6 Lab
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.6 实验
- en: Note For this lab, you need a computer running the OS of your choice with PowerShell
    v7 or later.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意对于这个实验，你需要一台运行你选择的操作系统且安装了 PowerShell v7 或更高版本的计算机。
- en: '`Write-Host` and `Write-Output` can be a bit tricky to work with. See how many
    of these tasks you can complete, and if you get stuck, it’s okay to peek at the
    sample answers available at the end of this chapter.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`Write-Host` 和 `Write-Output` 在使用时可能有点棘手。看看你能完成多少这些任务，如果你卡住了，查看本章末尾提供的示例答案是可以的。'
- en: Use `Write-Output` to display the result of 100 multiplied by 10.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Write-Output` 显示 100 乘以 10 的结果。
- en: Use `Write-Host` to display the result of 100 multiplied by 10.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Write-Host` 显示 100 乘以 10 的结果。
- en: Prompt the user to enter a name, and then display that name in yellow text.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提示用户输入一个名字，然后以黄色文本显示该名字。
- en: Prompt the user to enter a name, and then display that name only if it’s longer
    than five characters. Do this all with a single PowerShell expression—don’t use
    a variable.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提示用户输入一个名字，然后仅当该名字的长度超过五个字符时显示该名字。使用单个 PowerShell 表达式完成所有这些操作——不要使用变量。
- en: That’s all for this lab. Because these cmdlets are all straightforward, we want
    you to spend more time experimenting with them on your own. Be sure to do that—we’ll
    offer some ideas in section 17.8.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实验就到这里。因为这些 cmdlet 都很简单，我们希望你在自己身上花更多的时间进行实验。一定要这样做——我们将在第17.8节中提供一些想法。
- en: Try it Now After you’ve completed this lab, try completing review lab 3, which
    you’ll find in the appendix of this book.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 完成这个实验后，尝试完成附录中的复习实验3。
- en: 17.7 Lab answers
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.7 实验答案
- en: '`write-output (100*10)`'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`write-output (100*10)`'
- en: 'or simply type the formula: `100*10`'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者直接输入公式：`100*10`
- en: 'Any of these approaches works:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些方法中的任何一种都适用：
- en: '`$a= 100*10`'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`$a= 100*10`'
- en: '`Write-Host $a`'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Write-Host $a`'
- en: '`Write-Host "The value of 100*10 is $a"`'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Write-Host "The value of 100*10 is $a"`'
- en: '`Write-Host (100*10)`'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Write-Host (100*10)`'
- en: '`$name = Read-Host "Enter a name"`'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`$name = Read-Host "Enter a name"`'
- en: '`Write-host $name -ForegroundColor Yellow`'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Write-host $name -ForegroundColor Yellow`'
- en: '`Read-Host "Enter a name" | where {$_.length -gt 5}`'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Read-Host "Enter a name" | where {$_.length -gt 5}`'
- en: 17.8 Further exploration
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.8 进一步探索
- en: Spend some time getting comfortable with all of the cmdlets in this chapter.
    Make sure you can display `Verbose` output, and accept input. You’ll be using
    the commands from this chapter often from here on out, so you should read their
    help files and even jot down quick syntax reminders for future reference.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 花些时间熟悉本章中所有的 cmdlet。确保你能显示 `Verbose` 输出，并接受输入。从现在开始，你将经常使用本章中的命令，所以你应该阅读它们的帮助文件，并甚至为将来参考写下快速语法提示。
