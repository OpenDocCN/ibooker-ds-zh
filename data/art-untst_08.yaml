- en: 6 Unit testing asynchronous code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 单元测试异步代码
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Async, `done()`, and awaits
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步、`done()` 和 await
- en: Integration and unit test levels for async
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步的集成和单元测试级别
- en: The Extract Entry Point pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取入口点模式
- en: The Extract Adapter pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取适配器模式
- en: Stubbing, advancing, and resetting timers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟、推进和重置计时器
- en: When we’re dealing with regular synchronous code, waiting for actions to finish
    is *implicit*. We don’t worry about it, and we don’t really think about it too
    much. When dealing with asynchronous code, however, waiting for actions to finish
    becomes an *explicit* activity that is under our control. Asynchronicity makes
    code, and the tests for that code, potentially trickier because we have to be
    explicit about waiting for actions to complete.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理常规同步代码时，等待动作完成是 *隐式的*。我们不必担心它，并且我们并不真正过多地考虑它。然而，当处理异步代码时，等待动作完成变成了一种 *显式*
    的活动，这在我们自己的控制之下。异步性使得代码及其测试变得可能更复杂，因为我们必须明确等待动作完成。
- en: Let’s start with a simple fetching example to illustrate the issue.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的获取示例开始，以说明这个问题。
- en: 6.1 Dealing with async data fetching
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 处理异步数据获取
- en: Let’s say we have a module that checks whether our website at example.com is
    alive. It does this by fetching the context from the main URL and checking for
    a specific word, “illustrative,” to determine if the website is up. We’ll look
    at two different and very simple implementations of this functionality. The first
    uses a `callback` mechanism, and the second uses an `async`/`await` mechanism.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个模块，用于检查 example.com 上的网站是否活跃。它是通过从主 URL 获取上下文并检查特定的单词“说明”来确定网站是否运行。我们将查看这个功能的不同且非常简单的两种实现。第一个使用
    `callback` 机制，第二个使用 `async`/`await` 机制。
- en: Figure 6.1 illustrates their entry and exit points for our purposes. Note that
    the callback arrow is pointed differently, to make it more obvious that it’s a
    different type of exit point.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 展示了它们为我们目的的入口和出口点。注意回调箭头指向不同，这使得它更明显地表明它是一个不同类型的出口点。
- en: '![06-01](../Images/06-01.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![06-01](../Images/06-01.png)'
- en: Figure 6.1 `IsWebsiteAlive()` callback vs. the `async/await` version
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 `IsWebsiteAlive()` 回调与 `async/await` 版本
- en: The initial code is shown in the following listing. We’re using `node-fetch`
    to get the URL’s content.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了初始代码。我们使用 `node-fetch` 来获取 URL 的内容。
- en: Listing 6.1 `IsWebsiteAlive()` callback and await versions
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.1 `IsWebsiteAlive()` 回调和 await 版本
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Throwing a custom error to handle problems in our code
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 抛出自定义错误以处理我们代码中的问题
- en: ❷ Throwing a custom error to handle problems in our code
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 抛出自定义错误以处理我们代码中的问题
- en: ❸ Wrapping the error into a response
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将错误包装到响应中
- en: Note In the preceding code, I’m assuming you know how promises work in JavaScript.
    If you need more information, I recommend reading the Mozilla documentation on
    promises at [http://mng.bz/W11a](http://mng.bz/W11a).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在前面的代码中，我假设你知道 JavaScript 中 promises 的工作方式。如果你需要更多信息，我建议阅读 Mozilla 关于 promises
    的文档，网址为 [http://mng.bz/W11a](http://mng.bz/W11a)。
- en: In this example, we are converting any errors from connectivity failures or
    missing text on the web page to either a callback or a return value to denote
    a failure to the user of our function.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将任何来自连接失败或网页上缺少文本的错误转换为回调或返回值，以向我们的函数用户表示失败。
- en: 6.1.1 An initial attempt with an integration test
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.1 使用集成测试的初步尝试
- en: Since everything is hardcoded in listing 6.1, how would you test this? Your
    initial reaction might involve writing an integration test. The following listing
    shows how we could write an integration test for the callback version.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于列表 6.1 中所有内容都是硬编码的，你将如何测试它呢？你最初的反应可能是编写一个集成测试。下面的列表展示了我们如何为回调版本编写一个集成测试。
- en: Listing 6.2 An initial integration test
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.2 一个初始的集成测试
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To test a function whose exit point is a callback function, we pass it our own
    callback function in which we can
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试一个出口点是回调函数的函数，我们传递给它我们自己的回调函数，在其中我们可以
- en: Check the correctness of the passed-in values
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查传入值的正确性
- en: Tell the test runner to stop waiting through whatever mechanism is given to
    us by the test framework (in this case, that’s the `done()` function)
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 告诉测试运行器通过测试框架提供给我们的任何机制停止等待（在这种情况下，那就是 `done()` 函数）
- en: 6.1.2 Waiting for the act
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.2 等待动作
- en: Because we’re using callbacks as exit points, our test has to explicitly wait
    until the parallel execution completes. That parallel execution could be on the
    JavaScript event loop or it could be in a separate thread, or even in a separate
    process if you’re using another language.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们使用回调作为出口点，所以我们的测试必须显式等待并行执行完成。这种并行执行可能是在 JavaScript 事件循环中，也可能是在单独的线程中，或者如果你使用的是其他语言，甚至可能在单独的进程中。
- en: In the Arrange-Act-Assert pattern, the act part is the thing we need to wait
    out. Most test frameworks will allow us to do so with special helper functions.
    In this case, we can use the optional `done` callback that Jest provides to signal
    that the test needs to wait until we explicitly call `done()`. If `done()` isn’t
    called, our test will time out and fail after the default 5 seconds (which is
    configurable, of course).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Arrange-Act-Assert 模式下，act 部分是我们需要等待的部分。大多数测试框架都会允许我们通过特殊的辅助函数来完成。在这种情况下，我们可以使用
    Jest 提供的可选 `done` 回调来指示测试需要等待我们显式调用 `done()`。如果没有调用 `done()`，我们的测试将在默认的 5 秒后超时并失败（当然，这也可以配置）。
- en: Jest has other means for testing asynchronous code, a couple of which we’ll
    cover later in the chapter.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 有其他测试异步代码的方法，其中一些我们将在本章后面介绍。
- en: 6.1.3 Integration testing of async/await
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.3 异步/await 的集成测试
- en: What about the `async`/`await` version? We could technically write a test that
    looks almost exactly like the previous one, since `async`/`await` is just syntactic
    sugar over promises.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 那么 `async`/`await` 版本呢？从技术上讲，我们可以编写一个看起来几乎与上一个测试完全相同的测试，因为 `async`/`await` 只是基于承诺的语法糖。
- en: Listing 6.3 Integration test with callbacks and `.then()`
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.3 带回调和 `.then()` 的集成测试
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: However, a test that uses callbacks such as `done()` and `then()` is much less
    readable than one using the Arrange-Act-Assert pattern. The good news is there’s
    no need to complicate our lives by forcing ourselves to use callbacks. We can
    use the `await` syntax in our test as well. This will force us to put the `async`
    keyword in front of the test function, but, overall, our test becomes simpler
    and more readable, as you can see here.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用回调如 `done()` 和 `then()` 的测试比使用 Arrange-Act-Assert 模式的测试可读性差得多。好消息是，我们不需要通过强迫自己使用回调来复杂化我们的生活。我们也可以在我们的测试中使用
    `await` 语法。这将迫使我们把 `async` 关键字放在测试函数的前面，但总体而言，我们的测试变得更加简单和可读，正如你在这里可以看到的。
- en: Listing 6.4 Integration test with `async/await`
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.4 带有 `async/await` 的集成测试
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Having asynchronous code that allows us to use the `async`/`await` syntax turns
    our test into *almost* a run-of-the-mill value-based test. The entry point is
    also the exit point, as we saw in figure 6.1.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 允许我们使用 `async`/`await` 语法的不同步代码将我们的测试转变为几乎是一个普通的基于值的测试。入口点也是出口点，正如我们在图 6.1 中所看到的。
- en: Even though the call is simplified, the call is still asynchronous underneath,
    which is why I still call this an integration test. What are the caveats for this
    type of test? Let’s discuss.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 即使调用被简化了，调用仍然是异步的，这就是为什么我仍然称之为集成测试。这种类型测试的注意事项是什么？让我们来讨论。
- en: 6.1.4 Challenges with integration tests
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.4 集成测试的挑战
- en: 'The tests we’ve just written aren’t horrible as far as integration tests go.
    They’re relatively short and readable, but they still suffer from what any integration
    test suffers from:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚编写的测试从集成测试的角度来看并不糟糕。它们相对较短且可读，但它们仍然受到任何集成测试都会受到的困扰：
- en: '*Lengthy run time*—Compared to unit tests, integration tests are orders of
    magnitude slower, sometimes taking seconds or even minutes.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*运行时间长*—与单元测试相比，集成测试的速度慢得多，有时需要几秒甚至几分钟。'
- en: '*Flaky*—Integration tests can present inconsistent results (different timings
    based on where they run, inconsistent failures or successes, etc.)'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*不可靠的*—集成测试可能会呈现不一致的结果（基于运行位置的不同时间，不一致的失败或成功等）。'
- en: '*Tests possibly irrelevant code and environment conditions*—Integration tests
    test multiple pieces of code that might be unrelated to what we care about. (In
    our case, it’s the `node-fetch` library, network conditions, firewall, external
    website functionality, etc.)'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*测试可能与无关代码和环境条件相关*—集成测试测试多个可能与我们所关心的无关的代码片段。（在我们的例子中，是 `node-fetch` 库、网络条件、防火墙、外部网站功能等。）'
- en: '*Longer investigations*—When an integration test fails, it requires more time
    for investigation and debugging because there are many possible reasons for a
    failure.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*更长的调查时间*—当集成测试失败时，需要更多的时间来进行调查和调试，因为失败可能有多种原因。'
- en: '*Simulation is harder*—It is harder than it needs to be to simulate a negative
    test with an integration test (simulating wrong website content, website down,
    network down, etc.)'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*模拟更困难*—使用集成测试来模拟负测试（模拟错误的网站内容、网站宕机、网络中断等）比所需的要困难'
- en: '*Harder to trust results*—We might believe the failure of an integration test
    is due to an external issue when in fact it’s a bug in our code. I’ll talk about
    trust more in the next chapter.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*结果难以信任*—我们可能会认为集成测试的失败是由于外部问题，而实际上是我们代码中的错误。我将在下一章更多地讨论信任问题。'
- en: Does all this mean you shouldn’t write integration tests? No, I believe you
    should absolutely have integration tests, but you don’t need to have that many
    of them to get enough confidence in your code. Whatever integration tests don’t
    cover should be covered by lower-level tests, such as unit, API, or component
    tests. I’ll discuss this strategy at length in chapter 10, which focuses on testing
    strategies.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否意味着你不应该编写集成测试？不，我相信你应该绝对有集成测试，但你不需要有那么多集成测试来对你的代码有足够的信心。任何没有被集成测试覆盖的部分都应该由更低级别的测试来覆盖，例如单元测试、API测试或组件测试。我将在第10章详细讨论这种策略，该章专注于测试策略。
- en: 6.2 Making our code unit-test friendly
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2 使我们的代码适合单元测试
- en: 'How can we test the code with a unit test? I’ll show you some patterns that
    I use to make the code more unit testable (i.e., to more easily inject or avoid
    dependencies, and to check exit points):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何用单元测试测试代码？我将向你展示一些我用来使代码更容易进行单元测试的模式（即更容易注入或避免依赖，并检查退出点）：
- en: '*Extract Entry Point pattern*—Extracting the parts of the production code that
    are pure logic into their own functions, and treating those functions as entry
    points for our tests'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*提取入口点模式*—将生产代码中纯逻辑的部分提取到它们自己的函数中，并将这些函数作为我们测试的入口点'
- en: '*Extract Adapter pattern*—Extracting the thing that is inherently asynchronous
    and abstracting it away so that we can replace it with something that is synchronous'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*提取适配器模式*—提取本质上异步的部分，并将其抽象化，以便我们可以用同步的东西来替换它'
- en: 6.2.1 Extracting an entry point
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.1 提取入口点
- en: 'In this pattern, we take a specific unit of async work and split it into two
    pieces:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模式中，我们将一个特定的异步工作单元分成两部分：
- en: The async part (which stays intact).
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步部分（保持不变）。
- en: The callbacks that are invoked when the async execution finishes. These are
    extracted as new functions, which eventually become entry points for a purely
    logical unit of work that we can invoke with pure unit tests.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当异步执行完成时被调用的回调函数。这些被提取为新的函数，最终成为我们可以用纯单元测试调用的纯逻辑工作单元的入口点。
- en: 'Figure 6.2 depicts this idea: In the *before* diagram, we have a single unit
    of work that contains asynchronous code mixed with logic that processes the async
    results internally and returns a result via a callback or promise mechanism. In
    step 1, we extract the logic into its own function (or functions) that contains
    only the results of the async work as inputs. In step 2, we externalize those
    functions so that we can use them as entry points for our unit tests.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2展示了这个想法：在*之前*的图中，我们有一个包含异步代码与内部处理异步结果并返回结果的逻辑混合的单个工作单元，通过回调或承诺机制返回。在第1步中，我们将逻辑提取到它自己的函数（或函数）中，该函数只包含异步工作的结果作为输入。在第2步中，我们将这些函数外部化，以便我们可以将它们用作单元测试的入口点。
- en: '![06-02](../Images/06-02.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![06-02](../Images/06-02.png)'
- en: Figure 6.2 Extracting the internal processing logic into a separate unit of
    work helps simplify the tests, because we are able to verify the new unit of work
    synchronously and without involving external dependencies.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 将内部处理逻辑提取到单独的工作单元中有助于简化测试，因为我们能够同步验证新的工作单元，而不涉及外部依赖。
- en: This provides us with the important ability to test the logical processing of
    the async callbacks (and to simulate inputs easily). At the same time, we can
    choose to write a higher-level integration test against the original unit of work
    to gain confidence that the async orchestration works correctly as well.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了测试异步回调的逻辑处理的重要能力（并且可以轻松模拟输入）。同时，我们可以选择编写针对原始工作单元的高级集成测试，以获得信心，即异步编排也正确工作。
- en: If we do integration tests only for all our scenarios, we would end up in a
    world of many long-running and flaky tests. In the new world, we’re able to have
    most of our tests be fast and consistent, and to have a small layer of integration
    tests on top to make sure all the orchestration works in between. This way we
    don’t sacrifice speed and maintainability for confidence.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只为所有场景进行集成测试，我们最终会陷入一个有很多长时间运行且不可靠的测试的世界。在新世界中，我们能够使大多数测试变得快速且一致，并在其上有一个小的集成测试层，以确保所有编排工作在之间正常进行。这样我们就不会为了信心而牺牲速度和可维护性。
- en: Example of extracting a unit of work
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 提取工作单元的示例
- en: 'Let’s apply this pattern to the code from listing 6.1\. Figure 6.3 shows the
    steps we’ll follow:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个模式应用到列表 6.1 中的代码。图 6.3 显示了我们将要遵循的步骤：
- en: ❶ The *before* state contains processing logic that is baked into the `isWebsiteAlive()`
    function.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ *之前* 状态包含处理逻辑，这些逻辑被嵌入到 `isWebsiteAlive()` 函数中。
- en: '❷ We’ll extract any logical code that happens at the edge of the fetch results
    and put it in two separate functions: one for handling the success case, and the
    other for the error case.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们将提取在获取结果边缘发生的任何逻辑代码，并将其放入两个单独的函数中：一个用于处理成功情况，另一个用于处理错误情况。
- en: ❸ We’ll then externalize these two functions so that we can invoke them directly
    from unit tests.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 然后，我们将外部化这两个函数，以便我们可以直接从单元测试中调用它们。
- en: '![06-03](../Images/06-03.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![06-03](../Images/06-03.png)'
- en: Figure 6.3 Extracting the success and error-handling logic from `isWebsiteAlive()`
    to test that logic separately
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 从 `isWebsiteAlive()` 中提取成功和错误处理逻辑以单独测试该逻辑
- en: The following listing shows the refactored code.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了重构后的代码。
- en: Listing 6.5 Extracting entry points with `callback`
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.5 使用 `callback` 提取入口点
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ New entry points (units of work)
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 新入口点（工作单元）
- en: As you can see, the original unit we started with now has three entry points
    instead of the single one we started with. The new entry points can be used for
    unit testing, while the original one can still be used for integration testing,
    as shown in figure 6.4.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们最初开始的原始单元现在有三个入口点，而不是我们最初的一个。新的入口点可以用于单元测试，而原始的一个仍然可以用于集成测试，如图 6.4 所示。
- en: '![06-04](../Images/06-04.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![06-04](../Images/06-04.png)'
- en: Figure 6.4 New entry points introduced after extracting the two new functions.
    The new functions can now be tested with simpler unit tests instead of the integration
    tests that were required before the refactoring.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 提取两个新函数后引入的新入口点。现在，新的函数可以使用更简单的单元测试来测试，而不是重构之前所需的集成测试。
- en: We’d still want an integration test for the original entry point, but not more
    than one or two of those. Any other scenario can be simulated using the purely
    logical entry points, quickly and painlessly.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然想要一个针对原始入口点的集成测试，但不超过一个或两个。任何其他场景都可以使用纯逻辑入口点快速且无痛苦地模拟。
- en: Now we’re free to write unit tests that invoke the new entry points, like this.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以自由地编写调用新入口点的单元测试，如下所示。
- en: Listing 6.6 Unit tests with extracted entry points
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.6 使用提取的入口点的单元测试
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Invoking the new entry points
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 调用新的入口点
- en: Notice that we are invoking the new entry points directly, and we’re able to
    simulate various conditions easily. Nothing is asynchronous in these tests, but
    we still need the `done()` function, since the callbacks might not be invoked
    at all, and we’ll want to catch that.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在直接调用新的入口点，并且能够轻松地模拟各种条件。在这些测试中没有异步操作，但我们仍然需要 `done()` 函数，因为回调可能根本不会被调用，我们希望捕获这一点。
- en: We still need at least one integration test that gives us confidence that the
    asynchronous orchestration works between our entry points. That’s where the original
    integration test can help, but we don’t need to write all our test scenarios as
    integration tests anymore (more on this in chapter 10).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要至少一个集成测试，以让我们有信心我们的入口点之间的异步编排工作正常。这就是原始集成测试可以提供帮助的地方，但我们不再需要将所有测试场景都写成集成测试（关于这一点，请参阅第
    10 章）。
- en: Extracting an entry point with await
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 await 提取入口点
- en: The same pattern we just applied can work well for standard `async`/`await`
    function structures. Figure 6.5 illustrates that refactoring.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才应用的模式也可以很好地适用于标准的 `async`/`await` 函数结构。图 6.5 阐述了这种重构。
- en: '![06-05](../Images/06-05.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![06-05](../Images/06-05.png)'
- en: Figure 6.5 Extracting entry points with `async/await`
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 使用 `async/await` 提取入口点
- en: By providing the `async`/`await` syntax, we can go back to writing code in a
    linear fashion, without using callback arguments. The `isWebsiteAlive()` function
    starts looking almost exactly the same as regular synchronous code, only returning
    values and throwing errors when needed.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提供`async`/`await`语法，我们可以回到以线性方式编写代码，而不使用回调参数。`isWebsiteAlive()`函数看起来几乎与常规同步代码完全相同，仅在需要时返回值和抛出错误。
- en: Listing 6.7 shows how that looks in our production code.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.7 显示了我们的生产代码中的样子。
- en: Listing 6.7 The function written with `async/await` instead of callbacks
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.7 使用`async/await`而不是回调编写的函数
- en: '[PRE6]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Returning a value instead of calling a callback
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 返回值而不是调用回调
- en: Notice that, unlike the callback examples, we’re using `return` or `throw` to
    denote success or failure. This is a common pattern of writing code using `async`/`await`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与回调示例不同，我们使用`return`或`throw`来表示成功或失败。这是使用`async`/`await`编写代码的常见模式。
- en: Our tests are simplified as well, as shown in the following listing.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试也简化了，如下所示。
- en: Listing 6.8 Testing entry points extracted from `async/await`
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.8 从`async/await`提取的测试入口点
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Again, notice that we don’t need to add any kind of `async`/`await`-related
    keywords or to be explicit about waiting for execution, because we’ve separated
    the logical unit of work from the asynchronous pieces that make our lives more
    complicated.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意，我们不需要添加任何`async`/`await`相关的关键字，也不需要明确等待执行，因为我们已经将工作逻辑单元与使我们的生活更加复杂的异步部分分离开来。
- en: 6.2.2 The Extract Adapter pattern
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.2 提取适配器模式
- en: The Extract Adapter pattern takes the opposite view from the previous pattern.
    We look at the asynchronous piece of code just like we look at any dependency
    we’ve discussed in the previous chapters—as something we’d like to replace in
    our tests to gain more control. Instead of extracting the logical code into its
    own set of entry points, we’ll extract the asynchronous code (our *dependency*)
    and abstract it away under an adapter, which we can later inject, just like any
    other dependency. Figure 6.6 shows this.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 提取适配器模式与之前的模式观点相反。我们看待异步代码的方式就像我们看待之前章节中讨论的任何依赖项一样——我们希望在我们的测试中替换它以获得更多控制。我们不会将逻辑代码提取到自己的入口点集合中，而是将异步代码（我们的*依赖项*）提取出来，并在适配器下抽象它，我们可以在以后将其注入，就像任何其他依赖项一样。图6.6显示了这一点。
- en: '![06-06](../Images/06-06.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![06-06](../Images/06-06.png)'
- en: Figure 6.6 Extracting a dependency and wrapping it with an adapter helps us
    simplify that dependency and replace it with a fake in tests.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6 提取依赖关系并将其用适配器包装，帮助我们简化该依赖关系，并在测试中用模拟对象替换它。
- en: It’s also common to create a special interface for the adapter that is simplified
    for the needs of the consumer of the dependency. Another name for this approach
    is the *interface segregation principle*. In this case, we’ll create a `network-adapter`
    module that hides the real fetching functionality and has its own custom functions,
    as shown in figure 6.7.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 通常还会为适配器创建一个特殊的接口，该接口针对依赖项的消费者需求进行了简化。这种方法的另一个名称是*接口隔离原则*。在这种情况下，我们将创建一个`network-adapter`模块，它隐藏了实际的获取功能，并具有自己的自定义函数，如图6.7所示。
- en: '![06-07](../Images/06-07.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![06-07](../Images/06-07.png)'
- en: Figure 6.7 Wrapping the `node-fetch` module with our own `network-adapter` module
    helps us expose only the functionality our application needs, expressed in the
    language most suitable for the problem at hand.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7 使用我们自己的`network-adapter`模块包装`node-fetch`模块，帮助我们仅暴露应用程序需要的功能，以最合适的问题语言表达。
- en: Interface segregation principle
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接口隔离原则
- en: 'The term *interface segregation principle* was coined by Robert Martin. Imagine
    a database dependency with dozens of functions hidden behind an adapter whose
    interface might only contain a couple of functions with custom names and parameters.
    The adapter serves to hide the complexity and simplify both the consumer’s code
    and the tests that simulate it. For more information on interface segregation,
    see the Wikipedia article about it: [https://en.wikipedia.org/wiki/Interface_segregation_principle](https://en.wikipedia.org/wiki/Interface_segregation_principle).'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*接口隔离原则*由罗伯特·马丁提出。想象一下，一个数据库依赖关系，背后隐藏着数十个功能，这些功能通过一个适配器实现，而适配器的接口可能只包含几个具有自定义名称和参数的功能。适配器的作用是隐藏复杂性，并简化消费者的代码以及模拟它的测试。有关接口隔离的更多信息，请参阅维基百科上的相关文章：[https://en.wikipedia.org/wiki/Interface_segregation_principle](https://en.wikipedia.org/wiki/Interface_segregation_principle)。
- en: The following listing shows what the `network-adapter` module looks like.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了`network-adapter`模块的外观。
- en: Listing 6.9 The `network-adapter` code
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.9 `network-adapter`代码
- en: '[PRE8]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that the `network-adapter` module is the only module in the project that
    imports `node-fetch`. If that dependency changes at some point in the future,
    this increases the chances that only the current file would need to change. We’ve
    also simplified the function both by name and by functionality. We’re hiding the
    need to fetch the status and the text from the URL, and we’re abstracting them
    both under a single easier-to-use function.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`network-adapter`模块是项目中唯一一个导入`node-fetch`的模块。如果这个依赖在未来某个时刻发生变化，这增加了只有当前文件需要更改的可能性。我们还通过名称和功能简化了该函数。我们隐藏了从URL获取状态和文本的需求，并将它们都抽象成一个更容易使用的函数。
- en: Now we get to choose how to use the adapter. First, we can use it in the modular
    style. Then we’ll use a functional approach and an object-oriented one with a
    strongly typed interface.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以选择如何使用适配器。首先，我们可以以模块化风格使用它。然后我们将使用功能方法和具有强类型接口的面向对象方法。
- en: Modular adapter
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化适配器
- en: The following listing shows a modular use of `network-adapter` *by our initial*
    `isWebsiteAlive()` *function.*
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了`network-adapter`的模块化使用，这是我们的初始`isWebsiteAlive()`函数。
- en: Listing 6.10 `isWebsiteAlive()` using the `network-adapter` module
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.10 使用`network-adapter`模块的`isWebsiteAlive()`
- en: '[PRE9]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this version, we are directly importing the `network-adapter` module, which
    we’ll fake in our tests later on.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本中，我们直接导入`network-adapter`模块，我们将在后面的测试中对其进行模拟。
- en: The unit tests for this module are shown in the following listing. Because we’re
    using a modular design, we can fake the module using `jest.mock()` in our tests.
    We’ll also inject the module in later examples, don’t worry.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块的单元测试如下所示。因为我们使用了模块化设计，我们可以在测试中使用`jest.mock()`来模拟该模块。我们将在后面的示例中注入该模块，请放心。
- en: Listing 6.11 Faking `network-adapter` with `jest.mock`
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.11 使用`jest.mock`模拟`network-adapter`
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Faking the network-adapter module
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 模拟网络适配器模块
- en: ❷ Importing the fake module
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 导入模拟模块
- en: ❸ Resetting all the stubs to avoid any potential issues in other tests
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 重置所有存根以避免其他测试中的潜在问题
- en: ❹ Simulating a return value from the stub module
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 模拟存根模块的返回值
- en: ❺ Using await in our tests
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 在我们的测试中使用await
- en: Notice that we are using `async`/`await` again, because we are back to using
    the original entry point we started with at the beginning of the chapter. But
    just because we’re using `await` doesn’t mean our tests are running asynchronously.
    Our test code, and the production code it invokes, actually runs linearly, with
    an async-friendly signature. We’ll need to use `async`/`await` for the functional
    and object-oriented designs as well, because the entry point requires it.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们再次使用了`async`/`await`，因为我们回到了本章开头使用的原始入口点。但仅仅因为我们使用了`await`并不意味着我们的测试是异步运行的。我们的测试代码以及它调用的生产代码实际上是线性运行的，具有异步友好的签名。我们还需要在功能性和面向对象的设计中使用`async`/`await`，因为入口点需要它。
- en: I’ve named our fake network `stubSyncNetwork` to make the synchronous nature
    of the test clearer. Otherwise, it’s hard to tell just by looking at the test
    whether the code it invokes runs linearly or asynchronously.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我将我们的模拟网络命名为`stubSyncNetwork`，以使测试的同步性质更清晰。否则，仅通过查看测试很难判断它调用的代码是线性运行还是异步运行。
- en: Functional adapter
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 功能适配器
- en: In the functional design pattern, the design of the `network-adapter` module
    stays the same, but we enable its injection into our `website-verifier` differently.
    As you can see in the next listing, we add a new parameter to our entry point.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在功能设计模式中，`network-adapter`模块的设计保持不变，但我们以不同的方式启用其注入到我们的`website-verifier`中。正如您在下一列表中可以看到的，我们在入口点添加了一个新参数。
- en: Listing 6.12 A functional injection design for `isWebsiteAlive()`
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.12 为`isWebsiteAlive()`设计的功能注入
- en: '[PRE11]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this version, we’re expecting the `network-adapter` module to be injected
    through a common parameter to our function. In a functional design, we can use
    higher-order functions and currying to configure a pre-injected function with
    our own network dependency. In our tests, we can simply send in a fake network
    via this parameter. As far as the design of the injection goes, almost nothing
    else has changed from previous samples, other than the fact that we don’t import
    the `network-adapter` module anymore. Reducing the amount of imports and requires
    can help maintainability in the long run.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本中，我们期望`network-adapter`模块通过一个公共参数注入到我们的函数中。在功能设计中，我们可以使用高阶函数和柯里化来配置一个预先注入的函数，使其具有我们自己的网络依赖。在我们的测试中，我们可以简单地通过这个参数发送一个模拟网络。在设计注入方面，除了不再导入`network-adapter`模块之外，几乎没有什么变化。减少导入和`require`的数量可以在长期内帮助维护性。
- en: Our tests are simpler in the following listing, with less boilerplate code.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的列表中，我们的测试更加简单，样板代码更少。
- en: Listing 6.13 Unit test with functional injection of `network-adapter`
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.13使用功能注入的`network-adapter`单元测试
- en: '[PRE12]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ A new helper function to create a custom object that matches the important
    parts of the network-adapter’s interface
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个新辅助函数来创建一个与网络适配器接口的重要部分相匹配的自定义对象
- en: ❷ Injecting the custom object
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 注入自定义对象
- en: Notice that we don’t need a lot of the boilerplate at the top of the file, as
    we did in the modular design. We don’t need to fake the module indirectly (via
    `jest.mock`), we don’t need to re-import it for our tests (via `require`), and
    we don’t need to reset Jest’s state using `jest.resetAllMocks`. All we need to
    do is call our new `makeStubNetworkWithResult` helper function from each test
    to generate a new fake network adapter, and then inject the fake network by sending
    it as a parameter to our entry point.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不需要在文件顶部添加很多样板代码，就像我们在模块化设计中做的那样。我们不需要间接地伪造模块（通过`jest.mock`），我们不需要为了测试而重新导入它（通过`require`），也不需要使用`jest.resetAllMocks`来重置Jest的状态。我们只需要在每个测试中调用我们的新`makeStubNetworkWithResult`辅助函数来生成一个新的模拟网络适配器，然后将模拟网络通过将其作为参数发送到我们的入口点来注入。
- en: Object-oriented, interface-based adapter
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象，基于接口的适配器
- en: We’ve taken a look at the modular and functional designs. Let’s now turn our
    attention to the object-oriented side of the equation. In the object-oriented
    paradigm, we can take the parameter injection we’ve done before and promote it
    into a constructor injection pattern. We’ll start with the network adapter and
    its interfaces (public API and results signature) in the following listing.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经研究了模块化和功能设计。现在，让我们将注意力转向方程的面向对象方面。在面向对象的范式下，我们可以将之前所做的参数注入提升为构造函数注入模式。以下列表中，我们将从网络适配器及其接口（公共API和结果签名）开始。
- en: Listing 6.14 `NetworkAdapter` and its interfaces
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.14`NetworkAdapter`及其接口
- en: '[PRE13]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the next listing, we create a `WebsiteVerifier` class that has a constructor
    that receives an `INetworkAdapter` parameter.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个列表中，我们创建了一个具有接收`INetworkAdapter`参数的构造函数的`WebsiteVerifier`类。
- en: Listing 6.15 `WebsiteVerifier` class with constructor injection
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.15具有构造函数注入的`WebsiteVerifier`类
- en: '[PRE14]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The unit tests for this class can instantiate a fake network adapter and inject
    it through a constructor. In the following listing, we’ll use substitute.js to
    create a fake object that fits the new interface.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的单元测试可以实例化一个模拟网络适配器并通过构造函数注入它。在以下列表中，我们将使用substitute.js创建一个符合新接口的模拟对象。
- en: Listing 6.16 Unit tests for the object-oriented `WebsiteVerifier`
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.16面向对象的`WebsiteVerifier`单元测试
- en: '[PRE15]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ Helper function to simulate the network adapter
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 模拟网络适配器的辅助函数
- en: ❷ Generating the fake object
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 生成模拟对象
- en: ❸ Making the fake object return what the test requires
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使模拟对象返回测试所需的内容
- en: This type of Inversion of Control (IOC) and Dependency Injection (DI) works
    well. In the object-oriented world, constructor injection with interfaces is very
    common and can, in many instances, provide a valid and maintainable solution for
    separating your dependencies from your logic.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这种控制反转（IOC）和依赖注入（DI）类型的工作得很好。在面向对象的世界里，使用接口的构造函数注入非常常见，并且在许多情况下，可以为分离你的依赖项和逻辑提供一个有效且可维护的解决方案。
- en: 6.3 Dealing with timers
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3 处理计时器
- en: 'Timers, such as `setTimeout`, represent a very JavaScript-specific problem.
    They are part of the domain and are used, for better or worse, in many pieces
    of code. Instead of extracting adapters and entry points, sometimes it’s just
    as useful to disable these functions and work around them. We’ll look at two patterns
    for getting around timers:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 计时器，如 `setTimeout`，代表了非常 JavaScript 特定的问题。它们是领域的一部分，并且在许多代码片段中被使用，无论是好是坏。有时，与其提取适配器和入口点，不如禁用这些函数并绕过它们。我们将探讨两种绕过计时器的方法：
- en: Directly monkey-patching the function
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接模拟该函数
- en: Using Jest and other frameworks to disable and control them
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Jest 和其他框架来禁用和控制它们
- en: 6.3.1 Stubbing timers out with monkey-patching
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.1 使用 monkey-patching 模拟计时器
- en: Monkey-patching is a way for a program to extend or modify supporting system
    software locally (affecting only the running instance of the program). Programming
    languages and runtimes such as JavaScript, Ruby, and Python can accommodate monkey-patching
    pretty easily. It’s much more difficult to do with more strongly typed and compile-time
    languages such as C# and Java. I discuss monkey-patching in more detail in the
    appendix.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Monkey-patching 是一种程序扩展或修改本地支持系统软件（仅影响程序的运行实例）的方法。像 JavaScript、Ruby 和 Python
    这样的编程语言和运行时可以很容易地容纳 monkey-patching。对于像 C# 和 Java 这样更严格类型化和编译时语言来说，这要困难得多。我将在附录中更详细地讨论
    monkey-patching。
- en: Here’s one way to do it in JavaScript. We’ll start with the following piece
    of code that uses the `setTimeout` method.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是在 JavaScript 中实现的一种方法。我们将从以下使用 `setTimeout` 方法的代码片段开始。
- en: Listing 6.17 Code with `setTimeout` we’d like to monkey-patch
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.17 我们想要模拟的 `setTimeout` 代码
- en: '[PRE16]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We can monkey-patch the `setTimeout` function to be synchronous by literally
    setting that function’s prototype in memory, as follows.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在内存中设置该函数的原型来将 `setTimeout` 函数模拟为同步的，如下所示。
- en: Listing 6.18 A simple monkey-patching pattern
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.18 一个简单的 monkey-patching 模式
- en: '[PRE17]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ Saving the original setTimeout
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 保存原始 setTimeout
- en: ❷ Restoring the original setTimeout
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 恢复原始的 setTimeout
- en: ❸ Monkey-patching the setTimeout
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 模拟 setTimeout
- en: Since everything is synchronous, we don’t need to use `done()` to wait for a
    callback invocation. We are replacing `setTimeout` with a purely synchronous implementation
    that invokes the received callback immediately.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一切都是同步的，我们不需要使用 `done()` 来等待回调调用。我们正在用纯同步实现替换 `setTimeout`，立即调用接收到的回调。
- en: The only downside to this approach is that it requires a bunch of boilerplate
    code and is generally more error prone, since we need to remember to clean up
    correctly. Let’s look at what frameworks like Jest provide us with to handle these
    situations.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的唯一缺点是它需要大量的样板代码，并且通常更容易出错，因为我们需要记住正确地清理。让我们看看 Jest 等框架为我们提供了什么来处理这些情况。
- en: 6.3.2 Faking setTimeout with Jest
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.2 使用 Jest 模拟 setTimeout
- en: 'Jest provides us with three major functions for handling most types of timers
    in JavaScript:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 为我们提供了三个主要函数来处理 JavaScript 中大多数类型的计时器：
- en: '`jest.useFakeTimers`—Stubs out all the various timer functions, such as `setTimetout`'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jest.useFakeTimers`——模拟所有各种计时器函数，如 `setTimeout`'
- en: '`jest.resetAllTimers`—Resets all fake timers to the real ones'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jest.resetAllTimers`——将所有模拟计时器重置为真实计时器'
- en: '`jest.advanceTimersToNextTimer`—Triggers any fake timer so that any callbacks
    are triggered'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jest.advanceTimersToNextTimer`——触发任何模拟计时器，以便触发任何回调'
- en: Together, these functions take care of most of the boilerplate code for us.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数共同处理了大部分的样板代码。
- en: Here’s the same test we just did in listing 6.18, this time using Jest’s helper
    functions.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们在列表 6.18 中刚刚进行的相同测试，这次使用 Jest 的辅助函数。
- en: Listing 6.19 Faking `setTimeout` with Jest
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.19 使用 Jest 模拟 `setTimeout`
- en: '[PRE18]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notice that, once again, we don’t need to call `done()`, since everything is
    synchronous. At the same time, we have to use `advanceTimersToNextTimer` because,
    without it, our fake `setTimeout` would be stuck forever. `advanceTimersToNextTimer`
    is also useful for scenarios such as when the module being tested schedules a
    `setTimeout` whose callback schedules another `setTimeout` recursively (meaning
    the scheduling never stops). In these scenarios, it’s useful to be able to run
    forward in time, step by step.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，再次强调，我们不需要调用 `done()`，因为一切都是同步的。同时，我们必须使用 `advanceTimersToNextTimer`，因为没有它，我们的模拟
    `setTimeout` 将永远卡住。`advanceTimersToNextTimer` 也在处理如下场景时很有用：当被测试的模块安排了一个 `setTimeout`，其回调又安排了另一个
    `setTimeout` 递归调用（意味着调度永远不会停止）。在这些场景中，能够逐步向前运行非常有用。
- en: With `advanceTimersToNextTimer`, you could potentially advance all timers by
    a specified number of steps to simulate the passage of steps that will trigger
    the next timer callback waiting in line.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `advanceTimersToNextTimer`，您可以潜在地将所有计时器向前推进指定的步数，以模拟即将触发的下一个计时器回调的步骤。
- en: The same pattern also works well with `setInterval`, as shown next.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `setInterval` 的工作模式相同，如以下所示。
- en: Listing 6.20 A function that uses `setInterval`
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.20 使用 `setInterval` 的函数
- en: '[PRE19]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this case, our function takes in two callbacks as parameters: one to provide
    the inputs to calculate, and the other to call back with the calculation result.
    It uses `setInterval` to continuously get more inputs and calculate their results.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们的函数接受两个回调作为参数：一个用于提供计算所需的输入，另一个用于返回计算结果。它使用 `setInterval` 持续获取更多输入并计算其结果。
- en: The following listing shows a test that will advance our timer, trigger the
    interval twice, and expect the same result from both invocations.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了一个测试，它将推进我们的计时器，触发两次间隔，并期望两次调用都得到相同的结果。
- en: Listing 6.21 Advancing fake timers in a unit test
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.21 在单元测试中推进模拟计时器
- en: '[PRE20]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ Incrementing a variable to verify the number of callbacks
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 增加变量以验证回调次数
- en: ❷ Invoking setInterval twice
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 两次调用 `setInterval`
- en: In this example, we verify that the new values are being calculated and stored
    correctly. Notice that we could have written the same test with only a single
    invocation and a single expect, and we would have gotten close to the same amount
    of confidence that this more elaborate test provides, but I like to put in additional
    validation when I need more confidence.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们验证新的值是否被正确计算和存储。请注意，我们只用一个调用和一个 `expect` 就可以编写相同的测试，并且我们会得到与这个更复杂的测试几乎相同程度的信心，但我喜欢在需要更多信心时添加额外的验证。
- en: 6.4 Dealing with common events
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4 处理常见事件
- en: I can’t talk about async unit testing and not discuss the basic events flow.
    Hopefully the topic of async unit testing now seems relatively straightforward,
    but I want to go over the events part explicitly.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我不能谈论异步单元测试而不讨论基本的事件流程。希望现在异步单元测试的主题看起来相对简单明了，但我想要明确地回顾事件部分。
- en: 6.4.1 Dealing with event emitters
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.1 处理事件发射器
- en: 'To make sure we’re all on the same page, here’s a clear and concise definition
    of event emitters from DigitalOcean’s “Using Event Emitters in Node.js” tutorial
    ([http://mng.bz/844z](http://mng.bz/844z)):'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们都在同一页面上，这里有一个来自 DigitalOcean 的“在 Node.js 中使用事件发射器”教程的清晰简洁的事件发射器定义（[http://mng.bz/844z](http://mng.bz/844z)）：
- en: Event emitters are objects in Node.js that trigger an event by sending a message
    to signal that an action was completed. JavaScript developers can write code that
    listens to events from an event emitter, allowing them to execute functions every
    time those events are triggered. In this context, events are composed of an identifying
    string and any data that needs to be passed to the listeners.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 事件发射器是 Node.js 中的对象，通过发送消息来触发事件，以表示操作已完成。JavaScript 开发者可以编写代码来监听事件发射器的事件，允许他们在每次这些事件被触发时执行函数。在这种情况下，事件由一个标识字符串和任何需要传递给监听器的数据组成。
- en: Consider the `Adder` class in the following listing, which emits an event every
    time it adds something.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下列表中的 `Adder` 类，每次添加东西时都会发射一个事件。
- en: Listing 6.22 A simple event-emitter-based `Adder`
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.22 基于事件发射器的简单 `Adder`
- en: '[PRE21]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The simplest way to write a unit test that verifies that the event is emitted
    is to literally subscribe to the event in our test and verify that it triggers
    when we call the `add` function.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 验证事件发射的最简单方法是在我们的测试中直接订阅该事件，并验证我们在调用 `add` 函数时它是否被触发。
- en: Listing 6.23 Testing an event emitter by subscribing to it
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.23 通过订阅测试事件发射器
- en: '[PRE22]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: By using `done()`, we are verifying that the event actually was emitted. If
    we didn’t use `done()`, and the event wasn’t emitted, our test would pass because
    the subscribed code never executed. By adding `expect(x).toBe(y)`, we are also
    verifying the values sent in the event parameters, as well as implicitly testing
    that the event was triggered.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `done()`，我们正在验证事件实际上已被发射。如果我们没有使用 `done()`，并且事件没有被发射，我们的测试将通过，因为订阅的代码从未执行。通过添加
    `expect(x).toBe(y)`，我们也在验证事件参数中发送的值，以及隐式地测试事件是否被触发。
- en: 6.4.2 Dealing with click events
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.2 处理点击事件
- en: What about those pesky UI events, such as `click`? How can we test that we have
    bound them correctly via our scripts? Consider the simple web page and associated
    logic in listings 6.24 and 6.25.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 那些讨厌的UI事件，比如`click`，我们如何测试我们是否通过脚本正确地绑定了它们？考虑列表 6.24 和 6.25 中的简单网页及其相关逻辑。
- en: Listing 6.24 A simple web page with JavaScript `click` functionality
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.24 带有JavaScript `click`功能的简单网页
- en: '[PRE23]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Listing 6.25 The logic for the web page in JavaScript
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.25 网页的JavaScript逻辑
- en: '[PRE24]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We have a very simple piece of logic that makes sure our button sets a special
    message when clicked. How can we test this?
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一段非常简单的逻辑，确保当按钮被点击时设置一个特殊的信息。我们如何测试这个功能？
- en: 'Here’s an antipattern: we could subscribe to the click event in our tests and
    make sure it is triggered, but this would provide no value to us. What we care
    about is that the click has actually done something useful, other than triggering.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个反模式：我们可以在测试中订阅点击事件并确保它被触发，但这对我们没有任何价值。我们关心的是点击实际上做了些有用的事情，而不仅仅是触发。
- en: 'Here’s a better way: we can trigger the click event and make sure it has changed
    the correct value inside the page—this will provide real value. Figure 6.8 shows
    this.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个更好的方法：我们可以触发点击事件并确保它已经更改了页面内的正确值——这将提供真正的价值。图 6.8 展示了这一点。
- en: '![06-08](../Images/06-08.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![06-08](../Images/06-08.png)'
- en: Figure 6.8 Click as an entry point, and element as an exit point
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.8 点击作为入口点，元素作为退出点
- en: The following listing shows what our test might look like.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了我们的测试可能的样子。
- en: Listing 6.26 Triggering a click event, and testing an element’s text
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.26 触发点击事件，并测试元素的文本
- en: '[PRE25]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ❶ Applying the browser-simulating jsdom environment just for this file
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 仅为此文件应用浏览器模拟的jsdom环境
- en: ❷ Simulating the document.load event
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 模拟document.load事件
- en: ❸ Triggering the click
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 触发点击
- en: ❹ Verifying that an element in our document has actually changed
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 验证我们的文档中的元素实际上已经改变
- en: In this example, I’ve extracted two utility methods, `loadHtml` and `loadHtmlAndGetUIElements`,
    so that I can write cleaner, more readable tests, and so I’ll have fewer issues
    changing my tests if UI item locations or IDs change in the future.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我提取了两个实用方法，`loadHtml`和`loadHtmlAndGetUIElements`，这样我可以编写更干净、更易读的测试，并且如果将来UI项的位置或ID发生变化，我将拥有更少的测试更改问题。
- en: In the test itself, we’re simulating the `document.load` event, so that our
    custom script under test can start running and then triggering the `click`, as
    if the user had clicked the button. Finally, the test verifies that an element
    in our document has actually changed, which means our code successfully subscribed
    to the event and did its work.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试本身中，我们正在模拟`document.load`事件，以便我们的测试脚本可以开始运行并触发`click`，就像用户点击了按钮一样。最后，测试验证我们的文档中的某个元素实际上已经改变，这意味着我们的代码成功订阅了事件并完成了其工作。
- en: Notice that we don’t actually care about the underlying logic inside the index
    helper file. We just rely on observed state changes in the UI, which acts as our
    final exit point. This allows less coupling in our tests, so that if our code
    under test changes, we are less likely to need to change the test, unless the
    observable (publicly noticeable) functionality has truly changed.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们实际上并不关心索引辅助文件内部的底层逻辑。我们只是依赖于UI中观察到的状态变化，这充当我们的最终退出点。这允许我们的测试耦合度更低，因此如果我们要测试的代码发生变化，我们不太可能需要更改测试，除非可观察的（公开可见的）功能确实发生了变化。
- en: 6.5 Bringing in the DOM testing library
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.5 引入DOM测试库
- en: Our test has a lot of boilerplate code, mostly for finding elements and verifying
    their contents. I recommend looking into the open source DOM Testing Library written
    by Kent C. Dodds ([https://github.com/kentcdodds/dom-testing-library-with-anything](https://github.com/kentcdodds/dom-testing-library-with-anything)).
    This library has variants applicable to most frontend JavaScript frameworks today,
    such as React, Angular, and Vue.js. We’ll be using the vanilla version of it named
    DOM Testing Library.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试有很多样板代码，主要是用于查找元素和验证其内容。我建议查看由Kent C. Dodds编写的开源DOM测试库（[https://github.com/kentcdodds/dom-testing-library-with-anything](https://github.com/kentcdodds/dom-testing-library-with-anything)）。这个库有适用于今天大多数前端JavaScript框架的变体，例如React、Angular和Vue.js。我们将使用它的纯版本，名为DOM
    Testing Library。
- en: What I like about this library is that it aims to allow us to write tests closer
    to the point of view of the user interacting with our web page. Instead of using
    IDs for elements, we query by element text; firing events is a bit cleaner; and
    querying and waiting for elements to appear or disappear is cleaner and hidden
    under syntactic sugar. It’s quite useful once you use it in multiple tests.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢这个库的地方在于，它旨在允许我们编写更接近与我们的网页交互的用户视角的测试。而不是使用元素的ID，我们通过元素文本进行查询；触发事件更为简洁；查询和等待元素出现或消失更为简洁，并且隐藏在语法糖之下。一旦在多个测试中使用，它就非常有用。
- en: Here’s what our test looks like with this library.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用此库的测试看起来像什么。
- en: Listing 6.27 Using the DOM Testing Library in a simple test
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.27 在简单测试中使用DOM测试库
- en: '[PRE26]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ Importing some of the library APIs to be used
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入一些将要使用的库API
- en: ❷ Library APIs require the document element as the basis for most of the work.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 库API需要以文档元素为基础进行大部分工作。
- en: ❸ Using the library’s fireEvent API to simplify event dispatching
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用库的fireEvent API简化事件分发
- en: ❹ This query will wait until the item is found or will timeout within 1 second.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 此查询将等待直到找到项目或将在1秒内超时。
- en: Notice how the library allows us to use the regular text of the page items to
    get the items, instead of their IDs or test IDs. This is part of the way the library
    pushes us to work so things feel more natural and from the user’s point of view.
    To make the test more sustainable over time, we’re using the `exact:` `false`
    flag so that we don’t have to worry about uppercasing issues or missing letters
    at the start or end of strings. This removes the need to change the test for small
    text changes that are less important.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 注意图书馆如何允许我们使用页面元素的常规文本来获取元素，而不是它们的ID或测试ID。这是图书馆推动我们以更自然的方式工作的方式之一，从用户的角度来看。为了使测试在长时间内更具可持续性，我们使用了`exact:`
    `false`标志，这样我们就不必担心大写问题或字符串开头或结尾缺少字母。这消除了因小文本变化而更改测试的需要。
- en: Summary
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Testing asynchronous code directly results in flaky tests that take a long
    time to execute. To fix these issues, you can take two approaches: extract an
    entry point or extract an adapter.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接测试异步代码会导致测试不稳定，执行时间很长。为了解决这些问题，你可以采取两种方法：提取入口点或提取适配器。
- en: Extracting an entry point is when you extract the pure logic into separate functions
    and treat those functions as entry points for your tests. The extracted entry
    point can either accept a callback as an argument or return a value. Prefer return
    values over callbacks for simplicity.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取入口点是指将纯逻辑提取到单独的函数中，并将这些函数作为测试的入口点。提取的入口点可以接受回调作为参数，也可以返回一个值。为了简单起见，优先考虑返回值而不是回调。
- en: 'Extracting an adapter involves extracting a dependency that is inherently asynchronous
    and abstracting it away so that you can replace it with something that is synchronous.
    The adapter may be of different types:'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取适配器涉及提取一个本质上异步的依赖项，并将其抽象化，以便你可以用同步的东西替换它。适配器可能具有不同的类型：
- en: '*Modular*—When you stub the whole module (file) and replace specific functions
    in it.'
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*模块化*——当你对整个模块（文件）进行存根处理并替换其中的特定函数时。'
- en: '*Functional*—When you inject a function or value into the system under test.
    You can replace the injected value with a stub in tests.'
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*函数式*——当你向待测试的系统注入一个函数或值。你可以在测试中用存根替换注入的值。'
- en: '*Object-oriented*—When you use an interface in the production code and create
    a stub that implements that interface in the test code.'
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*面向对象*——当你使用生产代码中的接口并在测试代码中创建一个实现该接口的存根时。'
- en: Timers (such as `setTimeout` and `setInterval`) can be replaced either directly
    with monkey-patching or by using Jest or another framework to disable and control
    them.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定时器（如`setTimeout`和`setInterval`）可以通过猴子补丁直接替换，或者使用Jest或其他框架来禁用和控制它们。
- en: Events are best tested by verifying the end result they produce—changes in the
    HTML document the user can see. You can do this either directly or by using libraries
    such as the DOM Testing Library.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件测试的最佳方式是验证它们产生的最终结果——用户可以看到的HTML文档中的变化。你可以直接这样做，或者使用DOM测试库等库。
