- en: 3  Built-In Data Structures, Functions, and Files
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 内置数据结构、函数和文件
- en: 原文：[https://wesmckinney.com/book/python-builtin](https://wesmckinney.com/book/python-builtin)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://wesmckinney.com/book/python-builtin](https://wesmckinney.com/book/python-builtin)
- en: '*This Open Access web version of *Python for Data Analysis 3rd Edition* is
    now available as a companion to the [print and digital editions](https://amzn.to/3DyLaJc).
    If you encounter any errata, [please report them here](https://oreilly.com/catalog/0636920519829/errata).
    Please note that some aspects of this site as produced by Quarto will differ from
    the formatting of the print and eBook versions from O’Reilly.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个*Python数据分析第三版*的开放访问网络版本现在作为[印刷和数字版本](https://amzn.to/3DyLaJc)的伴侣可用。如果您遇到任何勘误，请[在此处报告](https://oreilly.com/catalog/0636920519829/errata)。请注意，由Quarto制作的本网站的某些方面与O''Reilly的印刷和电子书版本的格式不同。'
- en: If you find the online edition of the book useful, please consider [ordering
    a paper copy](https://amzn.to/3DyLaJc) or a [DRM-free eBook](https://www.ebooks.com/en-us/book/210644288/python-for-data-analysis/wes-mckinney/?affId=WES398681F)
    to support the author. The content from this website may not be copied or reproduced.
    The code examples are MIT licensed and can be found on GitHub or Gitee.*  *This
    chapter discusses capabilities built into the Python language that will be used
    ubiquitously throughout the book. While add-on libraries like pandas and NumPy
    add advanced computational functionality for larger datasets, they are designed
    to be used together with Python's built-in data manipulation tools.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发现本书的在线版本有用，请考虑[订购纸质副本](https://amzn.to/3DyLaJc)或[无DRM的电子书](https://www.ebooks.com/en-us/book/210644288/python-for-data-analysis/wes-mckinney/?affId=WES398681F)以支持作者。本网站的内容不得复制或再生产。代码示例采用MIT许可证，可在GitHub或Gitee上找到。*本章讨论了内置到Python语言中的功能，这些功能将在整本书中被广泛使用。虽然像pandas和NumPy这样的附加库为更大的数据集添加了高级计算功能，但它们旨在与Python的内置数据操作工具一起使用。
- en: 'We''ll start with Python''s workhorse data structures: tuples, lists, dictionaries,
    and sets. Then, we''ll discuss creating your own reusable Python functions. Finally,
    we''ll look at the mechanics of Python file objects and interacting with your
    local hard drive.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从Python的主要数据结构开始：元组、列表、字典和集合。然后，我们将讨论如何创建自己可重用的Python函数。最后，我们将看看Python文件对象的机制以及如何与本地硬盘交互。
- en: 3.1 Data Structures and Sequences
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 数据结构和序列
- en: Python’s data structures are simple but powerful. Mastering their use is a critical
    part of becoming a proficient Python programmer. We start with tuple, list, and
    dictionary, which are some of the most frequently used *sequence* types.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Python的数据结构简单而强大。掌握它们的使用是成为熟练的Python程序员的关键部分。我们从元组、列表和字典开始，它们是一些最常用的*序列*类型。
- en: Tuple
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元组
- en: 'A *tuple* is a fixed-length, immutable sequence of Python objects which, once
    assigned, cannot be changed. The easiest way to create one is with a comma-separated
    sequence of values wrapped in parentheses:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*元组*是Python对象的固定长度、不可变序列，一旦分配，就无法更改。创建元组的最简单方法是使用括号括起的逗号分隔的值序列：'
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In many contexts, the parentheses can be omitted, so here we could also have
    written:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，括号可以省略，所以这里我们也可以这样写：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can convert any sequence or iterator to a tuple by invoking `tuple`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过调用`tuple`将任何序列或迭代器转换为元组：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Elements can be accessed with square brackets `[]` as with most other sequence
    types. As in C, C++, Java, and many other languages, sequences are 0-indexed in
    Python:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 元素可以使用方括号`[]`访问，就像大多数其他序列类型一样。与C、C++、Java和许多其他语言一样，在Python中，序列是从0开始索引的：
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When you''re defining tuples within more complicated expressions, it’s often
    necessary to enclose the values in parentheses, as in this example of creating
    a tuple of tuples:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在更复杂的表达式中定义元组时，通常需要将值括在括号中，就像在创建元组的示例中一样：
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'While the objects stored in a tuple may be mutable themselves, once the tuple
    is created it’s not possible to modify which object is stored in each slot:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然存储在元组中的对象本身可能是可变的，但一旦创建了元组，就无法修改存储在每个槽中的对象：
- en: '[PRE5]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If an object inside a tuple is mutable, such as a list, you can modify it in
    place:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果元组中的对象是可变的，比如列表，您可以就地修改它：
- en: '[PRE6]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can concatenate tuples using the `+` operator to produce longer tuples:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`+`运算符连接元组以生成更长的元组：
- en: '[PRE7]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Multiplying a tuple by an integer, as with lists, has the effect of concatenating
    that many copies of the tuple:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 将元组乘以一个整数，与列表一样，会产生该元组的多个副本的效果：
- en: '[PRE8]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that the objects themselves are not copied, only the references to them.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对象本身并没有被复制，只有对它们的引用。
- en: Unpacking tuples
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解包元组
- en: 'If you try to *assign* to a tuple-like expression of variables, Python will
    attempt to *unpack* the value on the righthand side of the equals sign:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试对类似元组的变量表达式进行*赋值*，Python将尝试在等号右侧*解包*值：
- en: '[PRE9]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Even sequences with nested tuples can be unpacked:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 即使包含嵌套元组的序列也可以解包：
- en: '[PRE10]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Using this functionality you can easily swap variable names, a task that in
    many languages might look like:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个功能，您可以轻松交换变量名，这在许多语言中可能看起来像：
- en: '[PRE11]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'But, in Python, the swap can be done like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在Python中，交换可以这样做：
- en: '[PRE12]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'A common use of variable unpacking is iterating over sequences of tuples or
    lists:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 变量解包的常见用途是迭代元组或列表的序列：
- en: '[PRE13]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Another common use is returning multiple values from a function. I'll cover
    this in more detail later.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见用途是从函数返回多个值。我稍后会更详细地介绍这个问题。
- en: 'There are some situations where you may want to "pluck" a few elements from
    the beginning of a tuple. There is a special syntax that can do this, `*rest`,
    which is also used in function signatures to capture an arbitrarily long list
    of positional arguments:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些情况下，您可能希望从元组的开头“摘取”一些元素。有一种特殊的语法可以做到这一点，`*rest`，这也用于函数签名中捕获任意长的位置参数：
- en: '[PRE14]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This `rest` bit is sometimes something you want to discard; there is nothing
    special about the `rest` name. As a matter of convention, many Python programmers
    will use the underscore (`_`) for unwanted variables:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`rest`位有时是您想要丢弃的内容；`rest`名称没有特殊之处。作为一种惯例，许多Python程序员会使用下划线（`_`）表示不需要的变量：
- en: '[PRE15]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Tuple methods
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 元组方法
- en: 'Since the size and contents of a tuple cannot be modified, it is very light
    on instance methods. A particularly useful one (also available on lists) is `count`,
    which counts the number of occurrences of a value:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于元组的大小和内容不能被修改，因此实例方法非常少。一个特别有用的方法（也适用于列表）是`count`，它计算值的出现次数：
- en: '[PRE16]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: List
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表
- en: 'In contrast with tuples, lists are variable length and their contents can be
    modified in place. Lists are mutable. You can define them using square brackets
    `[]` or using the `list` type function:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 与元组相反，列表是可变长度的，其内容可以就地修改。列表是可变的。您可以使用方括号`[]`定义它们，也可以使用`list`类型函数：
- en: '[PRE17]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Lists and tuples are semantically similar (though tuples cannot be modified)
    and can be used interchangeably in many functions.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 列表和元组在语义上是相似的（尽管元组不能被修改），并且可以在许多函数中互换使用。
- en: 'The `list` built-in function is frequently used in data processing as a way
    to materialize an iterator or generator expression:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`list`内置函数在数据处理中经常用作实例化迭代器或生成器表达式的方法：'
- en: '[PRE18]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Adding and removing elements
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加和删除元素
- en: 'Elements can be appended to the end of the list with the `append` method:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 元素可以使用`append`方法附加到列表的末尾：
- en: '[PRE19]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Using `insert` you can insert an element at a specific location in the list:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`insert`可以在列表中的特定位置插入元素：
- en: '[PRE20]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The insertion index must be between 0 and the length of the list, inclusive.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 插入索引必须在列表的长度之间，包括0和长度。
- en: '*Warning* *`insert` is computationally expensive compared with `append`, because
    references to subsequent elements have to be shifted internally to make room for
    the new element. If you need to insert elements at both the beginning and end
    of a sequence, you may wish to explore `collections.deque`, a double-ended queue,
    which is optimized for this purpose and found in the Python Standard Library.*  *The
    inverse operation to `insert` is `pop`, which removes and returns an element at
    a particular index:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*警告* *与`append`相比，`insert`的计算成本较高，因为必须在内部移动后续元素的引用以为新元素腾出空间。如果需要在序列的开头和结尾插入元素，您可能希望探索`collections.deque`，这是一个双端队列，专为此目的进行了优化，并且包含在Python标准库中。*
    *`insert`的反向操作是`pop`，它会删除并返回特定索引处的元素：'
- en: '[PRE21]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Elements can be removed by value with `remove`, which locates the first such
    value and removes it from the list:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`remove`按值删除元素，它会定位第一个这样的值并将其从列表中删除：
- en: '[PRE22]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If performance is not a concern, by using `append` and `remove`, you can use
    a Python list as a set-like data structure (although Python has actual set objects,
    discussed later).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不关心性能，通过使用`append`和`remove`，可以使用Python列表作为类似集合的数据结构（尽管Python有实际的集合对象，稍后讨论）。
- en: 'Check if a list contains a value using the `in` keyword:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`in`关键字检查列表是否包含一个值：
- en: '[PRE23]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The keyword `not` can be used to negate `in`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字`not`可以用来否定`in`：
- en: '[PRE24]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Checking whether a list contains a value is a lot slower than doing so with
    dictionaries and sets (to be introduced shortly), as Python makes a linear scan
    across the values of the list, whereas it can check the others (based on hash
    tables) in constant time.*  *#### Concatenating and combining lists
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 检查列表是否包含一个值比使用字典和集合慢得多（即将介绍），因为Python会在线性扫描列表的值，而可以在常量时间内检查其他值（基于哈希表）。*  *####
    连接和组合列表
- en: 'Similar to tuples, adding two lists together with `+` concatenates them:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 与元组类似，使用`+`将两个列表相加会将它们连接起来：
- en: '[PRE25]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If you have a list already defined, you can append multiple elements to it
    using the `extend` method:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果已经定义了一个列表，可以使用`extend`方法将多个元素附加到其中：
- en: '[PRE26]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Note that list concatenation by addition is a comparatively expensive operation
    since a new list must be created and the objects copied over. Using `extend` to
    append elements to an existing list, especially if you are building up a large
    list, is usually preferable. Thus:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，通过加法进行列表连接是一种相对昂贵的操作，因为必须创建一个新列表并复制对象。通常最好使用`extend`将元素附加到现有列表中，特别是如果您正在构建一个大列表。因此：
- en: '[PRE27]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'is faster than the concatenative alternative:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 比连接替代方案更快：
- en: '[PRE28]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Sorting
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 排序
- en: 'You can sort a list in place (without creating a new object) by calling its
    `sort` function:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过调用其`sort`函数就地对列表进行排序（而不创建新对象）：
- en: '[PRE29]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`sort` has a few options that will occasionally come in handy. One is the ability
    to pass a secondary *sort key*—that is, a function that produces a value to use
    to sort the objects. For example, we could sort a collection of strings by their
    lengths:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort`有一些选项，偶尔会派上用场。其中之一是能够传递一个次要*排序键*——即生成用于对对象进行排序的值的函数。例如，我们可以按字符串的长度对字符串集合进行排序：'
- en: '[PRE30]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Soon, we'll look at the `sorted` function, which can produce a sorted copy of
    a general sequence.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 很快，我们将看一下`sorted`函数，它可以生成一份排序后的一般序列的副本。
- en: Slicing
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 切片
- en: 'You can select sections of most sequence types by using slice notation, which
    in its basic form consists of `start:stop` passed to the indexing operator `[]`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用切片表示法选择大多数序列类型的部分，其基本形式是将`start:stop`传递给索引运算符`[]`：
- en: '[PRE31]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Slices can also be assigned with a sequence:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 切片也可以用序列赋值：
- en: '[PRE32]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: While the element at the `start` index is included, the `stop` index is *not
    included*, so that the number of elements in the result is `stop - start`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`start`索引处的元素被包括在内，但`stop`索引*不包括*在内，因此结果中的元素数量为`stop - start`。
- en: 'Either the `start` or `stop` can be omitted, in which case they default to
    the start of the sequence and the end of the sequence, respectively:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`start`或`stop`可以省略，此时它们分别默认为序列的开头和序列的结尾：'
- en: '[PRE33]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Negative indices slice the sequence relative to the end:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 负索引相对于末尾切片序列：
- en: '[PRE34]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Slicing semantics takes a bit of getting used to, especially if you’re coming
    from R or MATLAB. See [Figure 3.1](#fig-figure_seq_slicing) for a helpful illustration
    of slicing with positive and negative integers. In the figure, the indices are
    shown at the "bin edges" to help show where the slice selections start and stop
    using positive or negative indices.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 切片语义需要一点时间来适应，特别是如果你是从R或MATLAB过来的。参见[图3.1](#fig-figure_seq_slicing)以了解使用正整数和负整数进行切片的有用示例。在图中，索引显示在“箱边缘”，以帮助显示使用正整数或负整数索引开始和停止的切片选择。
- en: '![](../Images/fe1beb3f93e0617bb1f4800840b8dc37.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/fe1beb3f93e0617bb1f4800840b8dc37.png)'
- en: 'Figure 3.1: Illustration of Python slicing conventions'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1：Python切片约定的示例
- en: 'A `step` can also be used after a second colon to, say, take every other element:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个冒号后也可以使用`step`，比如，每隔一个元素取一个：
- en: '[PRE35]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'A clever use of this is to pass `-1`, which has the useful effect of reversing
    a list or tuple:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个巧妙用法是传递`-1`，这样可以有效地反转列表或元组：
- en: '[PRE36]*  *### Dictionary'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE36]*  *### 字典'
- en: 'The dictionary or `dict` may be the most important built-in Python data structure.
    In other programming languages, dictionaries are sometimes called *hash maps*
    or *associative arrays*. A dictionary stores a collection of *key-value* pairs,
    where *key* and *value* are Python objects. Each key is associated with a value
    so that a value can be conveniently retrieved, inserted, modified, or deleted
    given a particular key. One approach for creating a dictionary is to use curly
    braces `{}` and colons to separate keys and values:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 字典或`dict`可能是Python中最重要的内置数据结构。在其他编程语言中，字典有时被称为*哈希映射*或*关联数组*。字典存储一组*键-值*对，其中*键*和*值*是Python对象。每个键都与一个值关联，以便可以方便地检索、插入、修改或删除给定特定键的值。创建字典的一种方法是使用大括号`{}`和冒号来分隔键和值：
- en: '[PRE37]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You can access, insert, or set elements using the same syntax as for accessing
    elements of a list or tuple:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用与访问列表或元组元素相同的语法来访问、插入或设置元素：
- en: '[PRE38]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You can check if a dictionary contains a key using the same syntax used for
    checking whether a list or tuple contains a value:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用与检查列表或元组是否包含值相同的语法来检查字典是否包含键：
- en: '[PRE39]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You can delete values using either the `del` keyword or the `pop` method (which
    simultaneously returns the value and deletes the key):'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`del`关键字或`pop`方法（同时返回值并删除键）来删除值：
- en: '[PRE40]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `keys` and `values` method gives you iterators of the dictionary''s keys
    and values, respectively. The order of the keys depends on the order of their
    insertion, and these functions output the keys and values in the same respective
    order:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`keys`和`values`方法分别为你提供字典的键和值的迭代器。键的顺序取决于它们插入的顺序，这些函数以相同的顺序输出键和值：'
- en: '[PRE41]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If you need to iterate over both the keys and values, you can use the `items`
    method to iterate over the keys and values as 2-tuples:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要同时迭代键和值，可以使用`items`方法以2元组的形式迭代键和值：
- en: '[PRE42]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You can merge one dictionary into another using the `update` method:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`update`方法将一个字典合并到另一个字典中：
- en: '[PRE43]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `update` method changes dictionaries in place, so any existing keys in the
    data passed to `update` will have their old values discarded.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`update`方法会直接更改字典，因此传递给`update`的数据中的任何现有键都将丢弃其旧值。'
- en: Creating dictionaries from sequences
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从序列创建字典
- en: 'It’s common to occasionally end up with two sequences that you want to pair
    up element-wise in a dictionary. As a first cut, you might write code like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通常会偶尔出现两个你想要逐个元素配对的序列。作为第一步，你可能会编写这样的代码：
- en: '[PRE44]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Since a dictionary is essentially a collection of 2-tuples, the `dict` function
    accepts a list of 2-tuples:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字典本质上是2元组的集合，`dict`函数接受一个2元组的列表：
- en: '[PRE45]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Later we’ll talk about *dictionary comprehensions*, which are another way to
    construct dictionaries.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后我们将讨论*字典推导*，这是构建字典的另一种方法。
- en: Default values
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 默认值
- en: 'It’s common to have logic like:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通常会有类似以下逻辑：
- en: '[PRE46]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Thus, the dictionary methods `get` and `pop` can take a default value to be
    returned, so that the above `if-else` block can be written simply as:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，字典方法`get`和`pop`可以接受要返回的默认值，因此上述`if-else`块可以简单地写为：
- en: '[PRE47]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '`get` by default will return `None` if the key is not present, while `pop`
    will raise an exception. With *setting* values, it may be that the values in a
    dictionary are another kind of collection, like a list. For example, you could
    imagine categorizing a list of words by their first letters as a dictionary of
    lists:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`get`默认情况下会返回`None`，如果键不存在，而`pop`会引发异常。在*设置*值时，可能字典中的值是另一种集合，比如列表。例如，你可以想象将单词列表按照它们的首字母分类为列表的字典：'
- en: '[PRE48]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `setdefault` dictionary method can be used to simplify this workflow. The
    preceding `for` loop can be rewritten as:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`setdefault`字典方法可用于简化此工作流程。前面的`for`循环可以重写为：'
- en: '[PRE49]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The built-in `collections` module has a useful class, `defaultdict`, which
    makes this even easier. To create one, you pass a type or function for generating
    the default value for each slot in the dictionary:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的`collections`模块有一个有用的类`defaultdict`，使这更加容易。要创建一个，你需要传递一个类型或函数，用于为字典中的每个槽生成默认值：
- en: '[PRE50]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Valid dictionary key types
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 有效的字典键类型
- en: 'While the values of a dictionary can be any Python object, the keys generally
    have to be immutable objects like scalar types (int, float, string) or tuples
    (all the objects in the tuple need to be immutable, too). The technical term here
    is *hashability*. You can check whether an object is hashable (can be used as
    a key in a dictionary) with the `hash` function:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然字典的值可以是任何Python对象，但键通常必须是不可变对象，如标量类型（int、float、string）或元组（元组中的所有对象也必须是不可变的）。这里的技术术语是*可哈希性*。你可以使用`hash`函数检查对象是否可哈希（可以用作字典中的键）：
- en: '[PRE51]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The hash values you see when using the `hash` function in general will depend
    on the Python version you are using.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，使用`hash`函数时看到的哈希值将取决于你使用的Python版本。
- en: 'To use a list as a key, one option is to convert it to a tuple, which can be
    hashed as long as its elements also can be:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要将列表用作键，一种选择是将其转换为元组，只要其元素也可以被散列：
- en: '[PRE52]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Set
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集合
- en: 'A *set* is an unordered collection of unique elements. A set can be created
    in two ways: via the `set` function or via a *set literal* with curly braces:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*集合*是一个无序的唯一元素集合。可以通过`set`函数或使用花括号的*集合字面值*来创建集合：'
- en: '[PRE53]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Sets support mathematical *set operations* like union, intersection, difference,
    and symmetric difference. Consider these two example sets:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 集合支持数学*集合操作*，如并集、交集、差集和对称差集。考虑这两个示例集合：
- en: '[PRE54]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The union of these two sets is the set of distinct elements occurring in either
    set. This can be computed with either the `union` method or the `|` binary operator:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个集合的并集是两个集合中出现的不同元素的集合。可以使用`union`方法或`|`二进制运算符来计算：
- en: '[PRE55]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The intersection contains the elements occurring in both sets. The `&` operator
    or the `intersection` method can be used:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 交集包含两个集合中都出现的元素。可以使用`&`运算符或`intersection`方法：
- en: '[PRE56]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: See [Table 3.1](#tbl-table_set_operations) for a list of commonly used set methods.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见[表3.1](#tbl-table_set_operations)以获取常用集合方法的列表。
- en: 'Table 3.1: Python set operations'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.1：Python集合操作
- en: '| Function | Alternative syntax | Description |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 替代语法 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `a.add(x)` | N/A | Add element `x` to set `a` |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `a.add(x)` | N/A | 将元素`x`添加到集合`a`中 |'
- en: '| `a.clear()` | N/A | Reset set `a` to an empty state, discarding all of its
    elements |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `a.clear()` | N/A | 将集合`a`重置为空状态，丢弃所有元素 |'
- en: '| `a.remove(x)` | N/A | Remove element `x` from set `a` |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `a.remove(x)` | N/A | 从集合`a`中删除元素`x` |'
- en: '| `a.pop()` | N/A | Remove an arbitrary element from set `a`, raising `KeyError`
    if the set is empty |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `a.pop()` | N/A | 从集合`a`中删除一个任意元素，如果集合为空则引发`KeyError` |'
- en: '| `a.union(b)` | `a &#124; b` | All of the unique elements in `a` and `b` |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `a.union(b)` | `a &#124; b` | `a`和`b`中所有唯一的元素 |'
- en: '| `a.update(b)` | `a &#124;= b` | Set the contents of `a` to be the union of
    the elements in `a` and `b` |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `a.update(b)` | `a &#124;= b` | 将`a`的内容设置为`a`和`b`中元素的并集 |'
- en: '| `a.intersection(b)` | `a & b` | All of the elements in *both* `a` and `b`
    |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `a.intersection(b)` | `a & b` | `a`和`b`中*都*存在的所有元素 |'
- en: '| `a.intersection_update(b)` | `a &= b` | Set the contents of `a` to be the
    intersection of the elements in `a` and `b` |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `a.intersection_update(b)` | `a &= b` | 将`a`的内容设置为`a`和`b`中元素的交集 |'
- en: '| `a.difference(b)` | `a - b` | The elements in `a` that are not in `b` |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `a.difference(b)` | `a - b` | `a`中不在`b`中的元素 |'
- en: '| `a.difference_update(b)` | `a -= b` | Set `a` to the elements in `a` that
    are not in `b` |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `a.difference_update(b)` | `a -= b` | 将`a`设置为`a`中不在`b`中的元素 |'
- en: '| `a.symmetric_difference(b)` | `a ^ b` | All of the elements in either `a`
    or `b` but *not both* |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `a.symmetric_difference(b)` | `a ^ b` | `a`或`b`中的所有元素，但*不是*两者都有的 |'
- en: '| `a.symmetric_difference_update(b)` | `a ^= b` | Set `a` to contain the elements
    in either `a` or `b` but *not both* |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `a.symmetric_difference_update(b)` | `a ^= b` | 将`a`设置为`a`或`b`中的元素，但*不是*两者都有的
    |'
- en: '| `a.issubset(b)` | `<=` | `True` if the elements of `a` are all contained
    in `b` |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `a.issubset(b)` | `<=` | 如果`a`的元素都包含在`b`中，则为`True` |'
- en: '| `a.issuperset(b)` | `>=` | `True` if the elements of `b` are all contained
    in `a` |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `a.issuperset(b)` | `>=` | 如果`b`的元素都包含在`a`中，则为`True` |'
- en: '| `a.isdisjoint(b)` | N/A | `True` if `a` and `b` have no elements in common
    |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `a.isdisjoint(b)` | N/A | 如果`a`和`b`没有共同元素，则为`True` |'
- en: '*Note* *If you pass an input that is not a set to methods like `union` and
    `intersection`, Python will convert the input to a set before executing the operation.
    When using the binary operators, both objects must already be sets.*  *All of
    the logical set operations have in-place counterparts, which enable you to replace
    the contents of the set on the left side of the operation with the result. For
    very large sets, this may be more efficient:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* *如果将不是集合的输入传递给`union`和`intersection`等方法，Python将在执行操作之前将输入转换为集合。在使用二进制运算符时，两个对象必须已经是集合。*
    *所有逻辑集合操作都有原地对应物，这使您可以用结果替换操作左侧集合的内容。对于非常大的集合，这可能更有效率：*'
- en: '[PRE57]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Like dictionary keys, set elements generally must be immutable, and they must
    be *hashable* (which means that calling `hash` on a value does not raise an exception).
    In order to store list-like elements (or other mutable sequences) in a set, you
    can convert them to tuples:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 与字典键类似，集合元素通常必须是不可变的，并且它们必须是*可散列*的（这意味着对值调用`hash`不会引发异常）。为了将类似列表的元素（或其他可变序列）存储在集合中，可以将它们转换为元组：
- en: '[PRE58]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'You can also check if a set is a subset of (is contained in) or a superset
    of (contains all elements of) another set:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以检查一个集合是否是另一个集合的子集（包含在内）或超集（包含所有元素）：
- en: '[PRE59]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Sets are equal if and only if their contents are equal:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当集合的内容相等时，集合才相等：
- en: '[PRE60]*  *### Built-In Sequence Functions'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE60]*  *### 内置序列函数'
- en: Python has a handful of useful sequence functions that you should familiarize
    yourself with and use at any opportunity.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Python有一些有用的序列函数，您应该熟悉并在任何机会使用。
- en: enumerate
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: enumerate
- en: 'It’s common when iterating over a sequence to want to keep track of the index
    of the current item. A do-it-yourself approach would look like:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在迭代序列时，通常希望跟踪当前项目的索引。自己动手的方法如下：
- en: '[PRE61]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Since this is so common, Python has a built-in function, `enumerate`, which
    returns a sequence of `(i, value)` tuples:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种情况很常见，Python有一个内置函数`enumerate`，它返回一个`(i, value)`元组序列：
- en: '[PRE62]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: sorted
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: sorted
- en: 'The `sorted` function returns a new sorted list from the elements of any sequence:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`sorted`函数从任何序列的元素返回一个新的排序列表：'
- en: '[PRE63]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The `sorted` function accepts the same arguments as the `sort` method on lists.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`sorted`函数接受与列表的`sort`方法相同的参数。'
- en: zip
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: zip
- en: '`zip` “pairs” up the elements of a number of lists, tuples, or other sequences
    to create a list of tuples:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`zip`将多个列表、元组或其他序列的元素“配对”起来，以创建一个元组列表：'
- en: '[PRE64]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '`zip` can take an arbitrary number of sequences, and the number of elements
    it produces is determined by the *shortest* sequence:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`zip`可以接受任意数量的序列，并且它生成的元素数量由*最短*的序列决定：'
- en: '[PRE65]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'A common use of `zip` is simultaneously iterating over multiple sequences,
    possibly also combined with `enumerate`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`zip`的一个常见用法是同时迭代多个序列，可能还与`enumerate`结合使用：'
- en: '[PRE66]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: reversed
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 反转
- en: '`reversed` iterates over the elements of a sequence in reverse order:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`reversed`以相反的顺序迭代序列的元素：'
- en: '[PRE67]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Keep in mind that `reversed` is a generator (to be discussed in some more detail
    later), so it does not create the reversed sequence until materialized (e.g.,
    with `list` or a `for` loop).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`reversed`是一个生成器（稍后将更详细讨论），因此它不会创建反转的序列，直到实现（例如，使用`list`或`for`循环）。
- en: List, Set, and Dictionary Comprehensions
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表、集合和字典推导
- en: '*List comprehensions* are a convenient and widely used Python language feature.
    They allow you to concisely form a new list by filtering the elements of a collection,
    transforming the elements passing the filter into one concise expression. They
    take the basic form:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表推导*是Python语言中一个方便且广泛使用的特性。它们允许您通过过滤集合的元素，将通过过滤的元素转换为一个简洁的表达式来简洁地形成一个新列表。它们的基本形式如下：'
- en: '[PRE68]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'This is equivalent to the following `for` loop:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这等同于以下的`for`循环：
- en: '[PRE69]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The filter condition can be omitted, leaving only the expression. For example,
    given a list of strings, we could filter out strings with length `2` or less and
    convert them to uppercase like this:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤条件可以被省略，只留下表达式。例如，给定一个字符串列表，我们可以过滤出长度为`2`或更少的字符串，并将它们转换为大写：
- en: '[PRE70]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Set and dictionary comprehensions are a natural extension, producing sets and
    dictionaries in an idiomatically similar way instead of lists.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 集合和字典推导是一个自然的扩展，以一种类似的方式产生集合和字典，而不是列表。
- en: 'A dictionary comprehension looks like this:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 字典推导看起来像这样：
- en: '[PRE71]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'A set comprehension looks like the equivalent list comprehension except with
    curly braces instead of square brackets:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 集合推导看起来与等效的列表推导相同，只是用花括号代替方括号：
- en: '[PRE72]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Like list comprehensions, set and dictionary comprehensions are mostly conveniences,
    but they similarly can make code both easier to write and read. Consider the list
    of strings from before. Suppose we wanted a set containing just the lengths of
    the strings contained in the collection; we could easily compute this using a
    set comprehension:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 与列表推导类似，集合和字典推导大多是便利性的，但它们同样可以使代码更易于编写和阅读。考虑之前的字符串列表。假设我们想要一个集合，其中只包含集合中包含的字符串的长度；我们可以很容易地使用集合推导来计算：
- en: '[PRE73]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We could also express this more functionally using the `map` function, introduced
    shortly:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以更加功能化地使用`map`函数，稍后介绍：
- en: '[PRE74]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'As a simple dictionary comprehension example, we could create a lookup map
    of these strings for their locations in the list:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个简单的字典推导示例，我们可以创建一个查找这些字符串在列表中位置的查找映射：
- en: '[PRE75]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Nested list comprehensions
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 嵌套列表推导
- en: 'Suppose we have a list of lists containing some English and Spanish names:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个包含一些英文和西班牙名字的列表列表：
- en: '[PRE76]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Suppose we wanted to get a single list containing all names with two or more
    `a`’s in them. We could certainly do this with a simple `for` loop:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要获得一个包含所有包含两个或更多个`a`的名称的单个列表。我们可以通过一个简单的`for`循环来实现：
- en: '[PRE77]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'You can actually wrap this whole operation up in a single *nested list comprehension*,
    which will look like:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，您可以将整个操作封装在一个单独的*嵌套列表推导*中，看起来像：
- en: '[PRE78]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'At first, nested list comprehensions are a bit hard to wrap your head around.
    The `for` parts of the list comprehension are arranged according to the order
    of nesting, and any filter condition is put at the end as before. Here is another
    example where we “flatten” a list of tuples of integers into a simple list of
    integers:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，嵌套列表推导可能有点难以理解。列表推导的`for`部分按照嵌套的顺序排列，任何过滤条件都放在最后。这里是另一个示例，我们将整数元组的列表“展平”为一个简单的整数列表：
- en: '[PRE79]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Keep in mind that the order of the `for` expressions would be the same if you
    wrote a nested `for` loop instead of a list comprehension:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果您写一个嵌套的`for`循环而不是列表推导，`for`表达式的顺序将是相同的：
- en: '[PRE80]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'You can have arbitrarily many levels of nesting, though if you have more than
    two or three levels of nesting, you should probably start to question whether
    this makes sense from a code readability standpoint. It’s important to distinguish
    the syntax just shown from a list comprehension inside a list comprehension, which
    is also perfectly valid:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以有任意多层的嵌套，尽管如果您有超过两三层的嵌套，您可能应该开始质疑这是否在代码可读性方面是有意义的。重要的是要区分刚刚显示的语法与列表推导内部的列表推导，后者也是完全有效的：
- en: '[PRE81]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: This produces a list of lists, rather than a flattened list of all of the inner
    elements.**  **## 3.2 Functions
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生一个列表的列表，而不是所有内部元素的扁平化列表。** **## 3.2 函数
- en: '*Functions* are the primary and most important method of code organization
    and reuse in Python. As a rule of thumb, if you anticipate needing to repeat the
    same or very similar code more than once, it may be worth writing a reusable function.
    Functions can also help make your code more readable by giving a name to a group
    of Python statements.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数*是Python中代码组织和重用的主要和最重要的方法。作为一个经验法则，如果您预计需要重复相同或非常相似的代码超过一次，编写可重用的函数可能是值得的。函数还可以通过给一组Python语句命名来使您的代码更易读。'
- en: 'Functions are declared with the `def` keyword. A function contains a block
    of code with an optional use of the `return` keyword:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 函数使用`def`关键字声明。函数包含一个代码块，可选使用`return`关键字：
- en: '[PRE82]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'When a line with `return` is reached, the value or expression after `return`
    is sent to the context where the function was called, for example:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当到达带有`return`的行时，`return`后的值或表达式将发送到调用函数的上下文，例如：
- en: '[PRE83]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'There is no issue with having multiple `return` statements. If Python reaches
    the end of a function without encountering a `return` statement, `None` is returned
    automatically. For example:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 有多个`return`语句是没有问题的。如果Python在函数结尾处没有遇到`return`语句，将自动返回`None`。例如：
- en: '[PRE84]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Each function can have *positional* arguments and *keyword* arguments. Keyword
    arguments are most commonly used to specify default values or optional arguments.
    Here we will define a function with an optional `z` argument with the default
    value `1.5`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数可以有 *位置* 参数和 *关键字* 参数。关键字参数最常用于指定默认值或可选参数。在这里，我们将定义一个带有默认值 `1.5` 的可选 `z`
    参数的函数：
- en: '[PRE85]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: While keyword arguments are optional, all positional arguments must be specified
    when calling a function.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然关键字参数是可选的，但在调用函数时必须指定所有位置参数。
- en: 'You can pass values to the `z` argument with or without the keyword provided,
    though using the keyword is encouraged:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以向 `z` 参数传递值，可以使用关键字也可以不使用关键字，但建议使用关键字：
- en: '[PRE86]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The main restriction on function arguments is that the keyword arguments *must*
    follow the positional arguments (if any). You can specify keyword arguments in
    any order. This frees you from having to remember the order in which the function
    arguments were specified. You need to remember only what their names are.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 对函数参数的主要限制是关键字参数 *必须* 跟在位置参数（如果有的话）后面。您可以以任何顺序指定关键字参数。这使您不必记住函数参数的指定顺序。您只需要记住它们的名称。
- en: Namespaces, Scope, and Local Functions
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名空间、作用域和本地函数
- en: 'Functions can access variables created inside the function as well as those
    outside the function in higher (or even *global*) scopes. An alternative and more
    descriptive name describing a variable scope in Python is a *namespace*. Any variables
    that are assigned within a function by default are assigned to the local namespace.
    The local namespace is created when the function is called and is immediately
    populated by the function’s arguments. After the function is finished, the local
    namespace is destroyed (with some exceptions that are outside the purview of this
    chapter). Consider the following function:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以访问函数内部创建的变量以及函数外部在更高（甚至 *全局*）作用域中的变量。在 Python 中描述变量作用域的另一种更具描述性的名称是 *命名空间*。在函数内部分配的任何变量默认分配给本地命名空间。本地命名空间在函数调用时创建，并立即由函数的参数填充。函数完成后，本地命名空间将被销毁（有一些例外情况超出了本章的范围）。考虑以下函数：
- en: '[PRE87]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'When `func()` is called, the empty list `a` is created, five elements are appended,
    and then `a` is destroyed when the function exits. Suppose instead we had declared
    `a` as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `func()` 时，将创建空列表 `a`，附加五个元素，然后在函数退出时销毁 `a`。假设我们改为这样声明 `a`：
- en: '[PRE88]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Each call to `func` will modify list `a`:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用 `func` 都会修改列表 `a`：
- en: '[PRE89]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Assigning variables outside of the function''s scope is possible, but those
    variables must be declared explicitly using either the `global` or `nonlocal`
    keywords:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数范围之外分配变量是可能的，但这些变量必须使用 `global` 或 `nonlocal` 关键字显式声明：
- en: '[PRE90]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '`nonlocal` allows a function to modify variables defined in a higher-level
    scope that is not global. Since its use is somewhat esoteric (I never use it in
    this book), I refer you to the Python documentation to learn more about it.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`nonlocal` 允许函数修改在非全局高级作用域中定义的变量。由于它的使用有些神秘（我在这本书中从未使用过它），我建议您查阅 Python 文档以了解更多信息。'
- en: '*Caution* *I generally discourage use of the `global` keyword. Typically, global
    variables are used to store some kind of state in a system. If you find yourself
    using a lot of them, it may indicate a need for object-oriented programming (using
    classes).*  *### Returning Multiple Values'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* *我通常不鼓励使用 `global` 关键字。通常，全局变量用于在系统中存储某种状态。如果您发现自己使用了很多全局变量，这可能表明需要使用面向对象编程（使用类）*  *###
    返回多个值'
- en: 'When I first programmed in Python after having programmed in Java and C++,
    one of my favorite features was the ability to return multiple values from a function
    with simple syntax. Here’s an example:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在 Java 和 C++ 中编程后第一次在 Python 中编程时，我最喜欢的功能之一是能够以简单的语法从函数中返回多个值。这里有一个例子：
- en: '[PRE91]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'In data analysis and other scientific applications, you may find yourself doing
    this often. What’s happening here is that the function is actually just returning
    *one* object, a tuple, which is then being unpacked into the result variables.
    In the preceding example, we could have done this instead:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据分析和其他科学应用中，您可能经常这样做。这里发生的是函数实际上只返回一个对象，一个元组，然后将其解包为结果变量。在前面的例子中，我们可以这样做：
- en: '[PRE92]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'In this case, `return_value` would be a 3-tuple with the three returned variables.
    A potentially attractive alternative to returning multiple values like before
    might be to return a dictionary instead:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`return_value` 将是一个包含三个返回变量的 3 元组。与之前返回多个值的一个潜在有吸引力的替代方法可能是返回一个字典：
- en: '[PRE93]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: This alternative technique can be useful depending on what you are trying to
    do.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这种替代技术可以根据您尝试做什么而有用。
- en: Functions Are Objects
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数是对象
- en: 'Since Python functions are objects, many constructs can be easily expressed
    that are difficult to do in other languages. Suppose we were doing some data cleaning
    and needed to apply a bunch of transformations to the following list of strings:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Python 函数是对象，许多构造可以很容易地表达，而在其他语言中很难做到。假设我们正在进行一些数据清理，并需要对以下字符串列表应用一系列转换：
- en: '[PRE94]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Anyone who has ever worked with user-submitted survey data has seen messy results
    like these. Lots of things need to happen to make this list of strings uniform
    and ready for analysis: stripping whitespace, removing punctuation symbols, and
    standardizing proper capitalization. One way to do this is to use built-in string
    methods along with the `re` standard library module for regular expressions:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 任何曾经处理过用户提交的调查数据的人都会看到这样混乱的结果。需要做很多事情才能使这个字符串列表统一并准备好进行分析：去除空格、删除标点符号，并标准化适当的大写。其中一种方法是使用内置的字符串方法以及
    `re` 标准库模块进行正则表达式：
- en: '[PRE95]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The result looks like this:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE96]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'An alternative approach that you may find useful is to make a list of the operations
    you want to apply to a particular set of strings:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会发现有用的另一种方法是制作一个要应用于特定字符串集的操作列表：
- en: '[PRE97]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Then we have the following:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有以下内容：
- en: '[PRE98]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: A more *functional* pattern like this enables you to easily modify how the strings
    are transformed at a very high level. The `clean_strings` function is also now
    more reusable and generic.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样的更*函数式*模式使您能够轻松修改字符串在非常高级别上的转换方式。`clean_strings`函数现在也更具可重用性和通用性。
- en: 'You can use functions as arguments to other functions like the built-in `map`
    function, which applies a function to a sequence of some kind:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将函数用作其他函数的参数，比如内置的`map`函数，它将一个函数应用于某种序列：
- en: '[PRE99]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '`map` can be used as an alternative to list comprehensions without any filter.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`可以作为替代方案用于列表推导而不需要任何过滤器。'
- en: Anonymous (Lambda) Functions
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 匿名（Lambda）函数
- en: 'Python has support for so-called *anonymous* or *lambda* functions, which are
    a way of writing functions consisting of a single statement, the result of which
    is the return value. They are defined with the `lambda` keyword, which has no
    meaning other than “we are declaring an anonymous function”:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: Python支持所谓的*匿名*或*lambda*函数，这是一种编写由单个语句组成的函数的方式，其结果是返回值。它们使用`lambda`关键字定义，该关键字除了“我们正在声明一个匿名函数”之外没有其他含义：
- en: '[PRE100]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'I usually refer to these as lambda functions in the rest of the book. They
    are especially convenient in data analysis because, as you’ll see, there are many
    cases where data transformation functions will take functions as arguments. It’s
    often less typing (and clearer) to pass a lambda function as opposed to writing
    a full-out function declaration or even assigning the lambda function to a local
    variable. Consider this example:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我通常在本书的其余部分中将这些称为lambda函数。它们在数据分析中特别方便，因为正如您将看到的，有许多情况下，数据转换函数将接受函数作为参数。与编写完整函数声明或甚至将lambda函数分配给本地变量相比，传递lambda函数通常更少输入（更清晰）。考虑这个例子：
- en: '[PRE101]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: You could also have written `[x * 2 for x in ints]`, but here we were able to
    succinctly pass a custom operator to the `apply_to_list` function.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以写成`[x * 2 for x in ints]`，但在这里我们能够简洁地将自定义运算符传递给`apply_to_list`函数。
- en: 'As another example, suppose you wanted to sort a collection of strings by the
    number of distinct letters in each string:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，假设你想按每个字符串中不同字母的数量对字符串集合进行排序：
- en: '[PRE102]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Here we could pass a lambda function to the list’s `sort` method:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以将一个lambda函数传递给列表的`sort`方法：
- en: '[PRE103]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Generators
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成器
- en: 'Many objects in Python support iteration, such as over objects in a list or
    lines in a file. This is accomplished by means of the *iterator protocol*, a generic
    way to make objects iterable. For example, iterating over a dictionary yields
    the dictionary keys:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的许多对象支持迭代，例如列表中的对象或文件中的行。这是通过*迭代器协议*实现的，这是一种使对象可迭代的通用方法。例如，对字典进行迭代会产生字典键：
- en: '[PRE104]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'When you write `for key in some_dict`, the Python interpreter first attempts
    to create an iterator out of `some_dict`:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 当您写`for key in some_dict`时，Python解释器首先尝试从`some_dict`创建一个迭代器：
- en: '[PRE105]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'An iterator is any object that will yield objects to the Python interpreter
    when used in a context like a `for` loop. Most methods expecting a list or list-like
    object will also accept any iterable object. This includes built-in methods such
    as `min`, `max`, and `sum`, and type constructors like `list` and `tuple`:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器是任何对象，在上下文中像`for`循环中使用时，将向Python解释器产生对象。大多数期望列表或类似列表的对象的方法也将接受任何可迭代对象。这包括内置方法如`min`、`max`和`sum`，以及类构造函数如`list`和`tuple`：
- en: '[PRE106]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'A *generator* is a convenient way, similar to writing a normal function, to
    construct a new iterable object. Whereas normal functions execute and return a
    single result at a time, generators can return a sequence of multiple values by
    pausing and resuming execution each time the generator is used. To create a generator,
    use the `yield` keyword instead of `return` in a function:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '*生成器*是一种方便的方式，类似于编写普通函数，来构造一个新的可迭代对象。普通函数一次执行并返回一个结果，而生成器可以通过暂停和恢复执行每次使用生成器时返回多个值的序列。要创建一个生成器，请在函数中使用`yield`关键字而不是`return`：'
- en: '[PRE107]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'When you actually call the generator, no code is immediately executed:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 当您实际调用生成器时，不会立即执行任何代码：
- en: '[PRE108]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'It is not until you request elements from the generator that it begins executing
    its code:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 直到您请求生成器的元素时，它才开始执行其代码：
- en: '[PRE109]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '*Note* *Since generators produce output one element at a time versus an entire
    list all at once, it can help your program use less memory.*  *#### Generator
    expressions'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* *由于生成器一次产生一个元素的输出，而不是一次产生整个列表，这可以帮助您的程序使用更少的内存。* *#### 生成器表达式'
- en: 'Another way to make a generator is by using a *generator expression*. This
    is a generator analogue to list, dictionary, and set comprehensions. To create
    one, enclose what would otherwise be a list comprehension within parentheses instead
    of brackets:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种生成器的方法是使用*生成器表达式*。这是列表、字典和集合推导的生成器类比。要创建一个，将否则是列表推导的内容括在括号中而不是方括号中：
- en: '[PRE110]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'This is equivalent to the following more verbose generator:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这等同于以下更冗长的生成器：
- en: '[PRE111]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Generator expressions can be used instead of list comprehensions as function
    arguments in some cases:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器表达式可以在某些情况下用作函数参数，而不是列表推导：
- en: '[PRE112]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Depending on the number of elements produced by the comprehension expression,
    the generator version can sometimes be meaningfully faster.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 根据推导表达式产生的元素数量，生成器版本有时可以更有意义地更快。
- en: itertools module
  id: totrans-303
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: itertools模块
- en: 'The standard library `itertools` module has a collection of generators for
    many common data algorithms. For example, `groupby` takes any sequence and a function,
    grouping consecutive elements in the sequence by return value of the function.
    Here’s an example:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库`itertools`模块具有许多常见数据算法的生成器集合。例如，`groupby`接受任何序列和一个函数，通过函数的返回值对序列中的连续元素进行分组。这里是一个例子：
- en: '[PRE113]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: See [Table 3.2](#tbl-table_itertools) for a list of a few other `itertools`
    functions I’ve frequently found helpful. You may like to check out [the official
    Python documentation](https://docs.python.org/3/library/itertools.html) for more
    on this useful built-in utility module.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[表3.2](#tbl-table_itertools)以获取我经常发现有用的其他一些`itertools`函数列表。您可能想查看[官方Python文档](https://docs.python.org/3/library/itertools.html)以获取有关这个有用的内置实用程序模块的更多信息。
- en: 'Table 3.2: Some useful `itertools` functions'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.2：一些有用的`itertools`函数
- en: '| Function | Description |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `chain(*iterables)` | Generates a sequence by chaining iterators together.
    Once elements from the first iterator are exhausted, elements from the next iterator
    are returned, and so on. |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| `chain(*iterables)` | 通过将迭代器链接在一起生成序列。一旦第一个迭代器的元素用尽，将返回下一个迭代器的元素，依此类推。 |'
- en: '| `combinations(iterable, k)` | Generates a sequence of all possible `k`-tuples
    of elements in the iterable, ignoring order and without replacement (see also
    the companion function `combinations_with_replacement`). |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| `combinations(iterable, k)` | 生成可迭代对象中所有可能的`k`元素元组的序列，忽略顺序且不重复（另请参阅伴随函数`combinations_with_replacement`）。|'
- en: '| `permutations(iterable, k)` | Generates a sequence of all possible `k`-tuples
    of elements in the iterable, respecting order. |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| `permutations(iterable, k)` | 生成可迭代对象中所有可能的`k`元素元组的序列，保持顺序。|'
- en: '| `groupby(iterable[, keyfunc])` | Generates `(key, sub-iterator)` for each
    unique key. |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| `groupby(iterable[, keyfunc])` | 为每个唯一键生成`(key, sub-iterator)`。|'
- en: '| `product(*iterables, repeat=1)` | Generates the Cartesian product of the
    input iterables as tuples, similar to a nested `for` loop. |*  *### Errors and
    Exception Handling'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '| `product(*iterables, repeat=1)` | 生成输入可迭代对象的笛卡尔积作为元组，类似于嵌套的`for`循环。 |*  *###
    错误和异常处理'
- en: 'Handling Python errors or *exceptions* gracefully is an important part of building
    robust programs. In data analysis applications, many functions work only on certain
    kinds of input. As an example, Python’s `float` function is capable of casting
    a string to a floating-point number, but it fails with `ValueError` on improper
    inputs:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 处理Python错误或*异常*的优雅是构建健壮程序的重要部分。在数据分析应用中，许多函数只对特定类型的输入有效。例如，Python的`float`函数能够将字符串转换为浮点数，但在不当输入时会引发`ValueError`异常：
- en: '[PRE114]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Suppose we wanted a version of `float` that fails gracefully, returning the
    input argument. We can do this by writing a function that encloses the call to
    `float` in a `try`/`except` block (execute this code in IPython):'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要一个版本的`float`，它能够优雅地失败，返回输入参数。我们可以通过编写一个函数，在其中将对`float`的调用封装在`try`/`except`块中来实现这一点（在IPython中执行此代码）：
- en: '[PRE115]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'The code in the `except` part of the block will only be executed if `float(x)`
    raises an exception:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 块中的`except`部分的代码只有在`float(x)`引发异常时才会执行：
- en: '[PRE116]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'You might notice that `float` can raise exceptions other than `ValueError`:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到`float`可能引发除`ValueError`之外的异常：
- en: '[PRE117]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'You might want to suppress only `ValueError`, since a `TypeError` (the input
    was not a string or numeric value) might indicate a legitimate bug in your program.
    To do that, write the exception type after `except`:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能只想抑制`ValueError`，因为`TypeError`（输入不是字符串或数值）可能表明程序中存在合法错误。要做到这一点，请在`except`后面写上异常类型：
- en: '[PRE118]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'We have then:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有：
- en: '[PRE119]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'You can catch multiple exception types by writing a tuple of exception types
    instead (the parentheses are required):'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过编写异常类型的元组来捕获多个异常类型（括号是必需的）：
- en: '[PRE120]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'In some cases, you may not want to suppress an exception, but you want some
    code to be executed regardless of whether or not the code in the `try` block succeeds.
    To do this, use `finally`:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您可能不想抑制异常，但您希望无论`try`块中的代码是否成功，都执行一些代码。要做到这一点，请使用`finally`：
- en: '[PRE121]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Here, the file object `f` will *always* get closed. Similarly, you can have
    code that executes only if the `try:` block succeeds using `else`:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，文件对象`f`将*始终*被关闭。同样，您可以使用`else`来执行仅在`try:`块成功时执行的代码：
- en: '[PRE122]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Exceptions in IPython
  id: totrans-333
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在IPython中的异常
- en: 'If an exception is raised while you are `%run`-ing a script or executing any
    statement, IPython will by default print a full call stack trace (traceback) with
    a few lines of context around the position at each point in the stack:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`%run`脚本或执行任何语句时引发异常，默认情况下IPython将打印完整的调用堆栈跟踪（traceback），并在堆栈中的每个位置周围显示几行上下文：
- en: '[PRE123]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Having additional context by itself is a big advantage over the standard Python
    interpreter (which does not provide any additional context). You can control the
    amount of context shown using the `%xmode` magic command, from `Plain` (same as
    the standard Python interpreter) to `Verbose` (which inlines function argument
    values and more). As you will see later in [Appendix B: More on the IPython System](/book/ipython),
    you can step *into the stack* (using the `%debug` or `%pdb` magics) after an error
    has occurred for interactive postmortem debugging.**  **## 3.3 Files and the Operating
    System'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅通过附加上下文本身就是与标准Python解释器相比的一个巨大优势（标准Python解释器不提供任何额外上下文）。您可以使用`%xmode`魔术命令来控制显示的上下文量，从`Plain`（与标准Python解释器相同）到`Verbose`（内联函数参数值等）。正如您将在[附录B：更多关于IPython系统](/book/ipython)中看到的，您可以在错误发生后进行交互式事后调试，进入堆栈（使用`%debug`或`%pdb`魔术）。
- en: Most of this book uses high-level tools like `pandas.read_csv` to read data
    files from disk into Python data structures. However, it’s important to understand
    the basics of how to work with files in Python. Fortunately, it’s relatively straightforward,
    which is one reason Python is so popular for text and file munging.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的大部分内容使用高级工具如`pandas.read_csv`从磁盘读取数据文件到Python数据结构中。然而，了解如何在Python中处理文件的基础知识是很重要的。幸运的是，这相对简单，这也是Python在文本和文件处理方面如此受欢迎的原因。
- en: 'To open a file for reading or writing, use the built-in `open` function with
    either a relative or absolute file path and an optional file encoding:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 要打开一个文件进行读取或写入，请使用内置的`open`函数，使用相对或绝对文件路径以及可选的文件编码：
- en: '[PRE124]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Here, I pass `encoding="utf-8"` as a best practice because the default Unicode
    encoding for reading files varies from platform to platform.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我传递 `encoding="utf-8"` 作为最佳实践，因为默认的Unicode编码读取文件在不同平台上有所不同。
- en: 'By default, the file is opened in read-only mode `"r"`. We can then treat the
    file object `f` like a list and iterate over the lines like so:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，文件以只读模式 `"r"` 打开。然后我们可以像处理列表一样处理文件对象 `f` 并迭代文件行：
- en: '[PRE125]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'The lines come out of the file with the end-of-line (EOL) markers intact, so
    you’ll often see code to get an EOL-free list of lines in a file like:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 行从文件中出来时保留了行尾（EOL）标记，因此您经常会看到代码以获取文件中无行尾的行列表，如下所示：
- en: '[PRE126]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'When you use `open` to create file objects, it is recommended to close the
    file when you are finished with it. Closing the file releases its resources back
    to the operating system:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `open` 创建文件对象时，建议在完成后关闭文件。关闭文件会将其资源释放回操作系统：
- en: '[PRE127]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'One of the ways to make it easier to clean up open files is to use the `with`
    statement:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 使得清理打开文件更容易的一种方法是使用 `with` 语句：
- en: '[PRE128]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: This will automatically close the file `f` when exiting the `with` block. Failing
    to ensure that files are closed will not cause problems in many small programs
    or scripts, but it can be an issue in programs that need to interact with a large
    number of files.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 当退出 `with` 块时，这将自动关闭文件 `f`。确保关闭文件在许多小程序或脚本中不会导致问题，但在需要与大量文件交互的程序中可能会出现问题。
- en: If we had typed `f = open(path, "w")`, a *new file* at *examples/segismundo.txt*
    would have been created (be careful!), overwriting any file in its place. There
    is also the `"x"` file mode, which creates a writable file but fails if the file
    path already exists. See [Table 3.3](#tbl-table_file_modes) for a list of all
    valid file read/write modes.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们输入 `f = open(path, "w")`，*examples/segismundo.txt* 将会创建一个*新文件*（小心！），覆盖原来的任何文件。还有
    `"x"` 文件模式，它创建一个可写文件，但如果文件路径已经存在则失败。查看 [Table 3.3](#tbl-table_file_modes) 获取所有有效的文件读写模式列表。
- en: 'Table 3.3: Python file modes'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 'Table 3.3: Python文件模式'
- en: '| Mode | Description |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| 模式 | 描述 |'
- en: '| --- | --- |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `r` | Read-only mode |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| `r` | 只读模式 |'
- en: '| `w` | Write-only mode; creates a new file (erasing the data for any file
    with the same name) |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| `w` | 只写模式；创建一个新文件（擦除同名文件的数据） |'
- en: '| `x` | Write-only mode; creates a new file but fails if the file path already
    exists |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| `x` | 只写模式；创建一个新文件，但如果文件路径已经存在则失败 |'
- en: '| `a` | Append to existing file (creates the file if it does not already exist)
    |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| `a` | 追加到现有文件（如果文件不存在则创建文件） |'
- en: '| `r+` | Read and write |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| `r+` | 读取和写入 |'
- en: '| `b` | Add to mode for binary files (i.e., `"rb"` or `"wb"`) |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| `b` | 用于二进制文件的附加模式（即 `"rb"` 或 `"wb"`） |'
- en: '| `t` | Text mode for files (automatically decoding bytes to Unicode); this
    is the default if not specified |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| `t` | 文件的文本模式（自动将字节解码为Unicode）；如果未指定，则为默认模式 |'
- en: 'For readable files, some of the most commonly used methods are `read`, `seek`,
    and `tell`. `read` returns a certain number of characters from the file. What
    constitutes a "character" is determined by the file encoding or simply raw bytes
    if the file is opened in binary mode:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 对于可读文件，一些最常用的方法是 `read`、`seek` 和 `tell`。`read` 从文件返回一定数量的字符。什么构成一个“字符”取决于文件编码，或者如果文件以二进制模式打开，则是原始字节：
- en: '[PRE129]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'The `read` method advances the file object position by the number of bytes
    read. `tell` gives you the current position:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`read` 方法通过读取的字节数推进文件对象位置。`tell` 给出当前位置：'
- en: '[PRE130]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Even though we read 10 characters from the file `f1` opened in text mode, the
    position is 11 because it took that many bytes to decode 10 characters using the
    default encoding. You can check the default encoding in the `sys` module:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们从以文本模式打开的文件 `f1` 中读取了 10 个字符，位置也是 11，因为使用默认编码解码 10 个字符需要这么多字节。您可以在 `sys`
    模块中检查默认编码：
- en: '[PRE131]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: To get consistent behavior across platforms, it is best to pass an encoding
    (such as `encoding="utf-8"`, which is widely used) when opening files.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '为了在各个平台上获得一致的行为，最好在打开文件时传递一个编码（例如 `encoding="utf-8"`，这是广泛使用的）。 '
- en: '`seek` changes the file position to the indicated byte in the file:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '`seek` 将文件位置更改为文件中指定的字节：'
- en: '[PRE132]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Lastly, we remember to close the files:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们记得关闭文件：
- en: '[PRE133]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'To write text to a file, you can use the file’s `write` or `writelines` methods.
    For example, we could create a version of *examples/segismundo.txt* with no blank
    lines like so:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 要将文本写入文件，可以使用文件的 `write` 或 `writelines` 方法。例如，我们可以创建一个没有空行的 *examples/segismundo.txt*
    版本如下：
- en: '[PRE134]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: See [Table 3.4](#tbl-table_file_methods) for many of the most commonly used
    file methods.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 [Table 3.4](#tbl-table_file_methods) 获取许多最常用的文件方法。
- en: 'Table 3.4: Important Python file methods or attributes'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 'Table 3.4: 重要的Python文件方法或属性'
- en: '| Method/attribute | Description |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '| 方法/属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `read([size])` | Return data from file as bytes or string depending on the
    file mode, with optional `size` argument indicating the number of bytes or string
    characters to read |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '| `read([size])` | 根据文件模式返回文件数据作为字节或字符串，可选的 `size` 参数指示要读取的字节数或字符串字符数 |'
- en: '| `readable()` | Return `True` if the file supports `read` operations |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '| `readable()` | 如果文件支持 `read` 操作则返回 `True` |'
- en: '| `readlines([size])` | Return list of lines in the file, with optional `size`
    argument |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '| `readlines([size])` | 返回文件中行的列表，带有可选的 `size` 参数 |'
- en: '| `write(string)` | Write passed string to file |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '| `write(string)` | 将传递的字符串写入文件 |'
- en: '| `writable()` | Return `True` if the file supports `write` operations |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '| `writable()` | 如果文件支持 `write` 操作则返回 `True` |'
- en: '| `writelines(strings)` | Write passed sequence of strings to the file |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '| `writelines(strings)` | 将传递的字符串序列写入文件 |'
- en: '| `close()` | Close the file object |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: '| `close()` | 关闭文件对象 |'
- en: '| `flush()` | Flush the internal I/O buffer to disk |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '| `flush()` | 刷新内部I/O缓冲区到磁盘 |'
- en: '| `seek(pos)` | Move to indicated file position (integer) |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
  zh: '| `seek(pos)` | 移动到指定的文件位置（整数） |'
- en: '| `seekable()` | Return `True` if the file object supports seeking and thus
    random access (some file-like objects do not) |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
  zh: '| `seekable()` | 如果文件对象支持寻找并且随机访问则返回 `True`（某些类似文件的对象不支持） |'
- en: '| `tell()` | Return current file position as integer |'
  id: totrans-388
  prefs: []
  type: TYPE_TB
  zh: '| `tell()` | 返回当前文件位置作为整数 |'
- en: '| `closed` | `True` if the file is closed |'
  id: totrans-389
  prefs: []
  type: TYPE_TB
  zh: '| `closed` | 如果文件已关闭则为`True` |'
- en: '| `encoding` | The encoding used to interpret bytes in the file as Unicode
    (typically UTF-8) |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
  zh: '| `encoding` | 用于将文件中的字节解释为Unicode的编码（通常为UTF-8） |'
- en: Bytes and Unicode with Files
  id: totrans-391
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字节和Unicode与文件
- en: 'The default behavior for Python files (whether readable or writable) is *text
    mode*, which means that you intend to work with Python strings (i.e., Unicode).
    This contrasts with *binary mode*, which you can obtain by appending `b` to the
    file mode. Revisiting the file (which contains non-ASCII characters with UTF-8
    encoding) from the previous section, we have:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: Python文件的默认行为（无论是可读还是可写）是*文本模式*，这意味着您打算使用Python字符串（即Unicode）。这与*二进制模式*相反，您可以通过在文件模式后附加`b`来获得。重新访问上一节中包含UTF-8编码的非ASCII字符的文件，我们有：
- en: '[PRE135]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'UTF-8 is a variable-length Unicode encoding, so when I request some number
    of characters from the file, Python reads enough bytes (which could be as few
    as 10 or as many as 40 bytes) from the file to decode that many characters. If
    I open the file in `"rb"` mode instead, `read` requests that exact number of bytes:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: UTF-8是一种可变长度的Unicode编码，因此当我从文件请求一些字符时，Python会读取足够的字节（可能少至10个或多至40个字节）来解码相应数量的字符。如果我以“rb”模式打开文件，`read`请求确切数量的字节：
- en: '[PRE136]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Depending on the text encoding, you may be able to decode the bytes to a `str`
    object yourself, but only if each of the encoded Unicode characters is fully formed:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 根据文本编码，您可能可以自己将字节解码为`str`对象，但前提是每个编码的Unicode字符都是完整形式的：
- en: '[PRE137]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Text mode, combined with the `encoding` option of `open`, provides a convenient
    way to convert from one Unicode encoding to another:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 文本模式，结合`open`的`encoding`选项，提供了一种方便的方法来将一个Unicode编码转换为另一个：
- en: '[PRE138]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Beware using `seek` when opening files in any mode other than binary. If the
    file position falls in the middle of the bytes defining a Unicode character, then
    subsequent reads will result in an error:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在除了二进制模式之外的任何模式下打开文件时要小心使用`seek`。如果文件位置落在定义Unicode字符的字节中间，那么后续的读取将导致错误：
- en: '[PRE139]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: If you find yourself regularly doing data analysis on non-ASCII text data, mastering
    Python's Unicode functionality will prove valuable. See [Python's online documentation](https://docs.python.org)
    for much more.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您经常在非ASCII文本数据上进行数据分析，掌握Python的Unicode功能将会很有价值。查看[Python的在线文档](https://docs.python.org)获取更多信息。
- en: 3.4 Conclusion
  id: totrans-403
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 结论
- en: With some of the basics of the Python environment and language now under your
    belt, it is time to move on and learn about NumPy and array-oriented computing
    in Python.*****
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Python环境和语言的一些基础知识现在掌握，是时候继续学习Python中的NumPy和面向数组的计算了。
