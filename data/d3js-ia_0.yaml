- en: Part 1\. D3.js fundamentals
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第1部分\. D3.js基础知识
- en: The first three chapters introduce you to the fundamental aspects of D3 and
    get you started with creating graphical elements in SVG using data. [Chapter 1](../Text/kindle_split_010.html#ch01)
    lays out how D3 relates to the DOM, HTML, CSS, and JavaScript, and provides a
    few examples of how to use D3 to create elements on a web page. [Chapter 2](../Text/kindle_split_011.html#ch02)
    focuses on loading, measuring, processing, and transforming your data in preparation
    for data visualization using the various functions D3 includes for data manipulation.
    [Chapter 3](../Text/kindle_split_012.html#ch03) turns toward design and explains
    how you can use D3 color functions for more effective data visualization, as well
    as load external elements such as HTML for modal dialogs or icons in raster and
    vector formats. [Chapter 4](../Text/kindle_split_013.html#ch04) deals with the
    fundamental usage of D3.js to create individual chart components with an emphasis
    on generating scatterplots and line charts. [Chapter 5](../Text/kindle_split_014.html#ch05)
    shows off the basic data visualization layouts that you’ll need to create common
    data visualization products such as pie charts and bar charts. In all, [part 1](#part01)
    shows you how to load, process, and visually represent data in SVG without relying
    on built-in layouts or components, which is critical for visualizing data.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 前三章介绍了D3的基本方面，并指导你如何使用数据在SVG中创建图形元素。 [第1章](../Text/kindle_split_010.html#ch01)
    阐述了D3与DOM、HTML、CSS和JavaScript的关系，并提供了一些使用D3在网页上创建元素的示例。 [第2章](../Text/kindle_split_011.html#ch02)
    专注于使用D3包含的各种数据操作函数来加载、测量、处理和转换你的数据，为数据可视化做准备。 [第3章](../Text/kindle_split_012.html#ch03)
    转向设计，解释了你可以如何使用D3颜色函数进行更有效的数据可视化，以及加载外部元素，如用于模态对话框的HTML或位图和矢量格式中的图标。 [第4章](../Text/kindle_split_013.html#ch04)
    处理使用D3.js创建单个图表组件的基本用法，重点在于生成散点图和折线图。 [第5章](../Text/kindle_split_014.html#ch05)
    展示了创建常见数据可视化产品（如饼图和柱状图）所需的基本数据可视化布局。 总的来说，[第1部分](#part01) 展示了如何在SVG中加载、处理和可视化数据，而不依赖于内置布局或组件，这对于数据可视化至关重要。
- en: Chapter 1\. An introduction to D3.js
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第1章\. D3.js简介
- en: '*This chapter covers*'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: The basics of HTML, CSS, and the Document Object Model (DOM)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML、CSS和文档对象模型（DOM）的基本知识
- en: The principles of Scalable Vector Graphics (SVG)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可缩放矢量图形（SVG）的原则
- en: Node and ES2015 functionality
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点和ES2015功能
- en: Data-binding and selections with D3
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用D3进行数据绑定和选择
- en: Different data types and their data visualization methods
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的数据类型及其数据可视化方法
- en: D3 is behind nearly all the most innovative and exciting information visualization
    on the web today. *D3* stands for *data-driven documents*. It’s a brand name,
    but also a class of applications that have been offered on the web in one form
    or another for years. In my career, I’ve made many things that could be considered
    data-driven documents. These include everything from one-off dynamic maps or social
    network diagrams to robust visual explorations of time and place. You’ll be using
    D3 whether you’re building data visualization prototypes for research or big data
    dashboards at the top tech companies.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: D3是今天几乎所有最创新和令人兴奋的信息可视化的背后。 *D3* 代表 *数据驱动的文档*。 它是一个品牌名称，也是一个多年来以某种形式在网络上提供的一类应用程序。
    在我的职业生涯中，我制作了许多可以被认为是数据驱动文档的东西。 这些包括从一次性动态地图或社交网络图到对时间和地点的稳健视觉探索的一切。 无论你是为研究构建数据可视化原型，还是在顶级科技公司构建大数据仪表板，你都会使用D3。
- en: 1.1\. What is D3.js?
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1\. 什么是D3.js？
- en: D3.js was created to fill a pressing need for web-accessible, sophisticated
    data visualization. Let’s say your company has used Business Intelligence tools
    for a while, but they don’t show you the kind of patterns in the data that your
    team needs. You need to build a custom dashboard that shows exactly how your customers
    are behaving, tailored for your specific domain. That dashboard needs to be fast,
    interactive, and shareable around the organization. You’re going to use D3 for
    that.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: D3.js的创建是为了满足对网络可访问、复杂数据可视化的迫切需求。 假设你的公司已经使用了一段时间的商业智能工具，但它们没有显示出你的团队需要的数据模式。
    你需要构建一个定制的仪表板，精确显示你的客户是如何行为的，针对你特定的领域进行定制。 该仪表板需要快速、交互式，并在组织内共享。 你将使用D3来完成这项工作。
- en: D3.js’s creator, Mike Bostock, originally created D3 to take advantage of emerging
    web standards, which, as he puts it, “avoids proprietary representation and affords
    extraordinary flexibility, exposing the full capabilities of web standards such
    as CSS3, HTML5, and SVG” ([http://d3js.org](http://d3js.org)). D3.js version 4,
    the latest iteration of this popular library, continues this trend by modularizing
    the various pieces of D3 to make it more useful in modern application development.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: D3.js的创造者迈克·博斯特克最初创建D3是为了利用新兴的Web标准，正如他所说的，“避免了专有表示，提供了非凡的灵活性，揭示了CSS3、HTML5和SVG等Web标准的全部功能”([http://d3js.org](http://d3js.org))。D3.js版本4，这个流行库的最新迭代，继续这一趋势，通过模块化D3的各个部分，使其在现代应用开发中更有用。
- en: D3 provides developers with the ability to create rich interactive and animated
    content based on data and tie that content to existing web page elements. It gives
    you the tools to create high-performance data dashboards and sophisticated data
    visualization, and to dynamically update traditional web content.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: D3为开发者提供了基于数据创建丰富交互和动画内容的能力，并将该内容与现有的网页元素绑定。它为你提供了创建高性能数据仪表板和复杂数据可视化的工具，并能够动态更新传统的网页内容。
- en: You might have already experimented with D3 and found that it isn’t easy to
    get into. Maybe that’s because you expected it to be a simple charting library.
    A case in point is the pie chart layout, which you’ll see in [chapter 5](../Text/kindle_split_014.html#ch05).
    D3 doesn’t have one single function to create a pie chart. Rather, it has a function
    that processes your dataset with the necessary angles so that if you pass the
    dataset to D3’s `arc` function, you get the drawing code necessary to represent
    those angles. And you need to use yet another function to create the paths necessary
    for that code. It’s a much longer process than using dedicated charting libraries,
    but the explicit manner in which D3 deals with data and graphics is also its strength.
    Although other charting libraries conveniently allow you to make line graphs and
    pie charts, they quickly break down when you want to make something different
    than that. Not D3, which allows you to build whatever data-driven graphics and
    interactivity you can imagine.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经尝试过使用D3，并发现它并不容易上手。也许那是因为你期望它是一个简单的图表库。一个典型的例子是饼图布局，你将在[第5章](../Text/kindle_split_014.html#ch05)中看到。D3没有创建饼图的单个函数。相反，它有一个函数可以处理你的数据集，并使用必要的角度，这样如果你将数据集传递给D3的`arc`函数，你将得到表示这些角度所需的绘图代码。而且你需要使用另一个函数来创建该代码所需的路径。这个过程比使用专门的图表库要长得多，但D3处理数据和图形的明确方式也是它的优势。尽管其他图表库方便地允许你创建线形图和饼图，但当你想要创建不同于这些的内容时，它们很快就会崩溃。不是D3，它允许你构建你能想象到的任何数据驱动的图形和交互性。
- en: 1.2\. How D3 works
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2. 如何D3工作
- en: Let’s look at the principles of data visualization, as well as how D3 works
    in general. In [figure 1.1](#ch01fig01) you see a rough map of how you might start
    with data and use D3 to process and represent that data, as well as add interactivity
    and optimize the data visualization you’ve created. In this chapter, we’ll start
    by establishing the principles of how D3 selections and data-binding work and
    learning how D3 interacts with SVG and HTML in the DOM. Then we’ll look at data
    types that you’ll commonly encounter. Finally, we’ll use D3 to create simple DOM
    and SVG elements.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看数据可视化的原则，以及D3的一般工作方式。在[图1.1](#ch01fig01)中，你可以看到如何使用D3从数据开始，处理和表示数据，以及添加交互性和优化你创建的数据可视化的大致地图。在本章中，我们将首先建立D3选择和数据绑定的原则，并学习D3如何在DOM中与SVG和HTML交互。然后我们将查看你将经常遇到的数据类型。最后，我们将使用D3创建简单的DOM和SVG元素。
- en: Figure 1.1\. A map of how to approach data visualization with D3.js that highlights
    the approach in this book. Start at the top with data and then follow the path
    depending on the type of data and the needs you’re addressing.
  id: totrans-17
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.1. 使用D3.js进行数据可视化的方法图，突出本书中的方法。从顶部开始，使用数据，然后根据数据类型和你要解决的问题的需求，沿着路径前进。
- en: '![](../Images/01fig01_alt.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/01fig01_alt.jpg)'
- en: 1.2.1\. Data visualization is more than charts
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.1. 数据可视化不仅仅是图表
- en: You may think of data visualization as limited to pie charts, line charts, and
    the variety of charting methods popularized by Edward Tufte and deployed in research.
    It’s much more than that. One of the core strengths of D3.js is that it allows
    for the creation of vector graphics for traditional charting, but also the creation
    of geospatial and network visualizations, as well as rich animation and interactivity.
    This broad-based approach to data visualization, where a map or a network graph
    or a table is another kind of representation of data, is the core of the D3.js
    library’s appeal for application development.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会认为数据可视化仅限于饼图、折线图以及由 Edward Tufte 推广并在研究中应用的多种图表方法。实际上，它远不止这些。D3.js 的一个核心优势是它允许创建用于传统图表的矢量图形，同时也允许创建地理空间和网络可视化，以及丰富的动画和交互性。这种基于数据可视化的广泛方法，其中地图、网络图或表格是数据的另一种表示形式，是
    D3.js 库对应用开发的核心吸引力。
- en: '[Figures 1.2](#ch01fig02) through [1.8](#ch01fig08) show data visualization
    pieces that I’ve created with D3\. They include maps and networks, along with
    more traditional pie charts and completely custom data visualization layouts based
    on the specific needs of my clients.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1.2](#ch01fig02) 至 [1.8](#ch01fig08) 展示了我使用 D3 创建的数据可视化组件。它们包括地图和网络，以及更多传统的饼图和基于客户特定需求的完全自定义数据可视化布局。'
- en: Figure 1.2\. D3 can be used for simple charts, such as this donut chart (explained
    in [chapter 5](../Text/kindle_split_014.html#ch05)).
  id: totrans-22
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.2\. D3 可以用于创建简单的图表，例如这个饼图（在第 5 章中解释）。
- en: '![](../Images/01fig02.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/01fig02.jpg)'
- en: Figure 1.3\. D3 can also be used to create web maps (see [chapter 8](../Text/kindle_split_018.html#ch08)),
    such as this map showing the ethnic makeup of major metropolitan areas in the
    United States.
  id: totrans-24
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.3\. D3 也可以用来创建网络地图（见[第 8 章](../Text/kindle_split_018.html#ch08)），例如这个展示美国主要大都市地区民族构成的地图。
- en: '![](../Images/01fig03.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/01fig03.jpg)'
- en: Figure 1.4\. Maps in D3 aren’t limited to traditional Mercator web maps. They
    can be interactive globes, like this map of undersea communication cables, or
    other, more
  id: totrans-26
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.4\. D3 中的地图不仅限于传统的墨卡托网络地图。它们可以是交互式地球仪，例如这个海底通信电缆地图，或者其他更多样化的地图。
- en: '![](../Images/01fig04.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/01fig04.jpg)'
- en: Figure 1.5\. D3 also provides robust capacities to create interactive network
    visualizations (see [chapter 7](../Text/kindle_split_017.html#ch07)). Here you
    see the social and coauthorship network of archaeologists working at the same
    dig for nearly 25 years.
  id: totrans-28
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.5\. D3 还提供了强大的能力来创建交互式网络可视化（见[第 7 章](../Text/kindle_split_017.html#ch07)）。在这里，您可以看到在同一个挖掘地点工作了近
    25 年的考古学家之间的社会和合著网络。
- en: '![](../Images/01fig05.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/01fig05.jpg)'
- en: Figure 1.6\. D3 includes a library of common data visualization layouts, such
    as the dendrogram (explained in [chapter 6](../Text/kindle_split_016.html#ch06)),
    that let you represent data, such as this word tree.
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.6\. D3 包含了一个常见的数据可视化布局库，例如树状图（在第 6 章中解释），它允许您表示数据，例如这个单词树。
- en: '![](../Images/01fig06_alt.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/01fig06_alt.jpg)'
- en: Figure 1.7\. D3 has SVG and canvas drawing functions (see [chapter 4](../Text/kindle_split_013.html#ch04))
    so you can create your own custom visualizations, such as this representation
    of musical scores.
  id: totrans-32
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.7\. D3 提供了 SVG 和 canvas 绘图功能（见[第 4 章](../Text/kindle_split_013.html#ch04)），因此您可以创建自己的自定义可视化，例如这种音乐乐谱的表示。
- en: '![](../Images/01fig07.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/01fig07.jpg)'
- en: Figure 1.8\. You can combine these layouts and functions to create a data dashboard
    like we’ll do in [chapter 9](../Text/kindle_split_020.html#ch09). You can also
    use the drawing functions to make your bar charts look distinctive, such as this
    “sketchy” style.
  id: totrans-34
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.8\. 您可以将这些布局和功能组合起来创建一个数据仪表板，就像我们在[第 9 章](../Text/kindle_split_020.html#ch09)中将要做的那样。您还可以使用绘图功能使您的条形图看起来与众不同，例如这种“草图”风格。
- en: '![](../Images/01fig08.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/01fig08.jpg)'
- en: Although the ability to create rich and varied graphics is one of D3’s strong
    points, more important for modern web development is the ability to embed the
    high level of interactivity that users expect. With D3, every element of every
    chart, from a spinning globe to a single, thin slice of a pie chart, is made interactive
    in the same way. And because D3 was written by someone well versed in data visualization
    practice, it includes interactive components and behaviors that are standard in
    data visualization and web development.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然创建丰富多样的图形是 D3 的一个优点，但对于现代 Web 开发来说，更重要的是能够嵌入用户期望的高级别交互性。使用 D3，每个图表的每个元素，从旋转的地球到饼图的单薄切片，都以相同的方式实现交互。而且因为
    D3 是由一位对数据可视化实践非常熟悉的人编写的，它包括数据可视化和 Web 开发中标准化的交互组件和行为。
- en: You don’t invest your time learning D3 so that you can deploy Excel-style charts
    on the web. For that, easier, more convenient libraries exist. You learn D3 because
    it gives you the ability to implement almost every major data visualization technique.
    It also gives you the power to create *your own* data visualization techniques,
    something a more general library can’t do. To see the variety of possibilities
    available with D3, look at [http://blockbuilder.org/search](http://blockbuilder.org/search).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 您学习 D3 不是为了让您能够在网络上部署 Excel 风格的图表。为此，存在更简单、更方便的库。您学习 D3 是因为它让您能够实现几乎每一种主要的数据可视化技术。它还让您能够创建**您自己的**数据可视化技术，这是更通用的库所无法做到的。要了解
    D3 提供的多种可能性，请查看 [http://blockbuilder.org/search](http://blockbuilder.org/search)。
- en: D3.js affords developers the capacity to make not only richly interactive applications
    but also applications that are styled and served like traditional web content.
    This makes them more portable, more amenable to the growing, linked data web,
    and more easily maintained by large teams where other team members don’t know
    the specific syntax of D3 but, for instance, can use CSS to style the data visualization
    elements.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: D3.js 为开发者提供了制作不仅丰富且交互性强，而且像传统网络内容一样样式化和提供应用程序的能力。这使得它们更易于携带，更适应不断增长、链接的数据网络，并且更容易由大型团队维护，其中其他团队成员不了解
    D3 的特定语法，但例如可以使用 CSS 来样式化数据可视化元素。
- en: The decision on Bostock’s part to deal broadly with data and to create a library
    capable of presenting maps as easily as charts, as easily as networks, as easily
    as ordered lists, also means that a developer doesn’t need to try to understand
    the abstractions and syntax of one library for maps, and another for dynamic text
    content, and another for data visualization. Instead, the code for running an
    interactive, force-directed network layout is close to pure JavaScript and also
    similar to the code representing dynamic points of interest (POIs) on a D3.js
    map. Not only are the methods the same, but the data also could be the same, formulated
    in one way for lists and paragraphs and spans, while formulated in another way
    for geospatial representation.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 博斯托克决定广泛处理数据并创建一个能够像图表、网络、有序列表一样轻松展示地图的库，这也意味着开发者不需要试图理解一个用于地图的库的抽象和语法，另一个用于动态文本内容，另一个用于数据可视化的库。相反，运行交互式、力导向网络布局的代码接近纯
    JavaScript，并且与代表 D3.js 地图上动态兴趣点（POIs）的代码相似。不仅方法相同，数据也可能相同，对于列表、段落和跨度，以一种方式表达，而对于地理空间表示，以另一种方式表达。
- en: 1.2.2\. D3 is about selecting and binding
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.2\. D3 是关于选择和绑定
- en: 'Throughout this chapter, you’ll see code snippets that you can run in your
    browser to make changes to the graphical appearance of elements on your website.
    At the end of the chapter is an application written in D3 that explains the basics
    of the code we’re running in JavaScript. But before that we’ll explore the principles
    of web development using D3, and you’ll see this pattern of code over and over
    again: selecting.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将看到可以在浏览器中运行的代码片段，以更改您网站上元素的图形外观。本章末尾是一个用 D3 编写的应用程序，它解释了我们正在用 JavaScript
    运行的代码的基本原理。但在那之前，我们将探讨使用 D3 进行 Web 开发的原则，您将反复看到这种代码模式：选择。
- en: Imagine we have a set of data, such as the price and size of a few houses, and
    a set of web page elements, whether graphics or `<div>` elements, and that we
    want to represent the dataset, whether with text or through size and color. A
    *selection* is the group of the data and elements together. We perform actions
    on the elements in the group, such as moving them or changing their color. We
    can likewise update the values in the data. Though we can work with the data and
    the web page elements separately, the real power of D3 comes from using selections
    to combine data and web page elements.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一组数据，例如几所房子的价格和大小，以及一组网页元素，无论是图形还是`<div>`元素，而我们想用文本或通过大小和颜色来表示数据集。*选择*是数据和元素组合的组。我们对组中的元素执行操作，例如移动它们或改变它们的颜色。我们同样可以更新数据中的值。尽管我们可以单独处理数据和网页元素，但D3真正的力量来自于使用选择来结合数据和网页元素。
- en: 'Here’s a selection without any data:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个没有数据的选择：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This takes each circle on our page with the CSS class of `a`, turns it red,
    and moves it so that its center is 100 pixels to the right of the left side of
    our `<svg>` canvas. Likewise, this code turns every div on our web page red and
    changes its class to `b`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将我们页面上的具有CSS类`a`的每个圆形变成红色，并将其移动到我们的`<svg>`画布左侧100像素的位置。同样，这段代码会将我们网页上的每个`div`变成红色，并将其类更改为`b`：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: But before we can change our circles and divs, we’ll need to create them, and
    before we do that, it’s best to understand what’s happening in this pattern.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们能够改变圆形和`div`之前，我们需要创建它们，而在我们这样做之前，最好理解这个模式中发生了什么。
- en: '|  |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Is selecting necessary?**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**选择是否必要？**'
- en: Later in [chapter 11](../Text/kindle_split_022.html#ch11) you’ll see how to
    use D3 with React, a view renderer. Typically, MVC libraries like Angular or view
    rendering libraries like React are responsible for creating and destroying HTML
    elements and associating them with certain data-points. In those cases, you might
    stop using D3 to create and update elements and use it purely as a visualization
    kernel for your application.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第11章](../Text/kindle_split_022.html#ch11)的后面，你会看到如何使用D3与React（一个视图渲染器）结合使用。通常，MVC库如Angular或视图渲染库如React负责创建和销毁HTML元素，并将它们与某些数据点关联起来。在这些情况下，你可能停止使用D3来创建和更新元素，而将其纯粹用作应用程序的可视化内核。
- en: '|  |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'The first part of that line of code, `d3.selectAll()`, is part of the core
    functionality necessary for understanding D3: selections. Selections can be made
    with `d3.select()`, which selects the first single element found, but more often
    you’ll use `d3.select-All()`, which can be used to select multiple elements. Selections
    are groups of one or more web page elements that may be associated with a set
    of data, like the following code, which binds the elements in the array [1,5,11,3]
    to `<div>` elements with the class of `market`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 那行代码的第一部分，`d3.selectAll()`，是理解D3核心功能所必需的：选择。选择可以使用`d3.select()`进行，它选择找到的第一个单个元素，但更常见的是使用`d3.selectAll()`，它可以用来选择多个元素。选择是一组一个或多个网页元素，这些元素可能关联一组数据，如下面的代码所示，它将数组[1,5,11,3]中的元素绑定到具有`market`类的`<div>`元素：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This association is known in D3 as *binding data*, and you can think of a selection
    as a set of web page elements and a corresponding, associated set of data. Sometimes
    more data elements exist than DOM elements, or vice versa, in which case D3 has
    functions designed to create or remove elements that you can use to generate content.
    [Chapter 2](../Text/kindle_split_011.html#ch02) covers selections and data binding
    in detail. Selections might not include any data binding, and won’t for most of
    the examples in this chapter, but the inclusion allows the powerful information
    visualization techniques of D3\. You can make a selection on any elements in a
    web page, including items in a list, circles, or even regions on a map of Africa.
    The same way the elements can take a number of shapes, the data associated with
    those elements (where applicable) can take many forms.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在D3中，这种关联被称为*绑定数据*，你可以将选择视为一组网页元素及其对应的相关数据集。有时数据元素可能多于DOM元素，或者相反，在这种情况下，D3有创建或删除元素的功能，你可以使用这些功能来生成内容。[第2章](../Text/kindle_split_011.html#ch02)详细介绍了选择和数据绑定。选择可能不包含任何数据绑定，在本章的大部分示例中也是如此，但包含数据绑定允许使用D3强大的信息可视化技术。你可以在网页上的任何元素上进行选择，包括列表中的项目、圆形，甚至是非洲地图上的区域。同样，元素可以采取多种形状，与这些元素相关联的数据（如果适用）也可以采取多种形式。
- en: 1.2.3\. D3 is about deriving the appearance of web page elements from bound
    data
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.3\. D3是关于从绑定数据中推导网页元素的外观
- en: After you have a selection, you can then use D3 to modify the appearance of
    web page elements to reflect differences in the data. You may want to make the
    length of a line equal to the value of the data, or change the color to one that
    corresponds to a class of data. You may want to hide or show elements as they
    correspond to a user’s navigation of a dataset. As you can see in [figure 1.9](#ch01fig09),
    after the page has loaded, you use D3 to select elements and bind data for creating,
    removing, or changing DOM elements. You continue to use this process in response
    to user interaction.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在你有一个选择之后，你可以然后使用D3来修改网页元素的外观，以反映数据的不同。你可能想要使线的长度等于数据的值，或者改变颜色以对应于数据的一个类别。你可能想要根据用户对数据集的导航来隐藏或显示元素。正如你在[图1.9](#ch01fig09)中可以看到的，在页面加载后，你使用D3选择元素并绑定数据以创建、删除或更改DOM元素。你将继续使用这个过程来响应用户交互。
- en: Figure 1.9\. An application created with D3 can use selections and data binding
    over and over again, together and separately, to update the content of the data
    visualization based on interaction.
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.9\. 使用D3创建的应用程序可以反复使用选择和数据绑定，一起和单独地，根据交互更新数据可视化的内容。
- en: '![](../Images/01fig09_alt.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01fig09_alt.jpg)'
- en: You modify the appearance of elements by using selections to reference the data
    bound to an element in a selection. D3 iterates through the elements in your selection
    and performs the same action using the bound data, which results in different
    graphical effects. Although the action you perform is the same, the effect is
    different because it’s based on the variation in the data. You’ll see data binding
    first at the end of this chapter, and in much more detail throughout this book.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用选择来引用绑定到选择中元素的数据来修改元素的外观。D3遍历你的选择中的元素，并使用绑定数据执行相同的操作，这会产生不同的图形效果。尽管你执行的操作是相同的，但由于它基于数据的差异，效果是不同的。你将在本章末尾首先看到数据绑定，并在整本书中详细讨论。
- en: 1.2.4\. Web page elements can now be divs, countries, and flowcharts
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.4\. 网页元素现在可以是divs、国家和流程图
- en: We’ve grown accustomed to thinking of web pages as consisting of text elements
    with containers for pictures, videos, or embedded applications. But as you grow
    more familiar with D3, you’ll begin to recognize that every element on the page
    can be treated with the same high-level abstractions. The most basic element on
    a web page, a `<div>` that represents a rectangle into which you can drop paragraphs,
    lists, and tables, can be selected and modified in the same way you can select
    and modify a country on a web map, or individual circles and lines that make up
    a complex data visualization.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经习惯了将网页视为由文本元素组成，其中包含图片、视频或嵌入应用的容器。但随着你对D3越来越熟悉，你将开始认识到页面上每个元素都可以用相同的高级抽象来处理。网页上最基本元素，一个代表可以放入段落、列表和表格的矩形的`<div>`，可以像选择和修改地图上的国家或构成复杂数据可视化的单个圆圈和线条一样被选择和修改。
- en: 1.3\. The power of HTML5
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3\. HTML5的力量
- en: We’ve come a long way from the days when animated GIFs and frames were the pinnacle
    of dynamic content on the web. In [figure 1.10](#ch01fig10), you can see why GIFs
    never caught on for robust data visualization on the web. GIFs, like the infoviz
    libraries designed to use VML, were necessary for earlier browsers, but D3 is
    designed for the modern browsers that no longer need backward compatibility.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从那些动画GIF和帧是网络动态内容巅峰的日子走了很长的路。在[图1.10](#ch01fig10)中，你可以看到为什么GIF从未在网络上用于稳健的数据可视化。GIF，就像设计用来使用VML的信息可视化库一样，对于早期的浏览器是必要的，但D3是为不再需要向后兼容性的现代浏览器设计的。
- en: Figure 1.10\. Before GIFs were weaponized to share cute animal behavior, they
    were your only hope for animated data visualization on the web. Few examples from
    the 1990s like [dpgraph.com](http://dpgraph.com) still exist, but this page has
    more than enough GIFs to remind us of their dangers.
  id: totrans-64
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.10\. 在GIF被用于分享可爱的动物行为之前，它们是你唯一的希望，可以在网络上进行动画数据可视化。像[dpgraph.com](http://dpgraph.com)这样的1990年代例子已经很少见了，但这个页面有足够的GIF来提醒我们它们的危险。
- en: '![](../Images/01fig10.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01fig10.jpg)'
- en: '|  |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-67
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: SVG knowledge is foundational to understanding D3.js, but if you’re already
    experienced with the DOM, SVG, and CSS, you can skim this section to refresh your
    memory, or skip ahead to [section 1.3.6](#ch01lev2sec10) or [1.4](#ch01lev1sec4).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: SVG知识是理解D3.js的基础，但如果您已经对DOM、SVG和CSS有经验，您可以快速浏览本节以刷新记忆，或者跳到[第1.3.6节](#ch01lev2sec10)或[1.4节](#ch01lev1sec4)。
- en: '|  |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: A modern browser typically can not only display SVG graphics and obey CSS3 rules,
    but also has great performance. Along with Cascading Style Sheets (CSS) and Scalable
    Vector Graphics (SVG), the other elements you need to know about for web development
    are the DOM (Document Object Model) and JavaScript. The following sections deal
    with each of them broadly and include code you can run to see how D3 uses their
    functionality to create interactive and dynamic web content.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现代浏览器不仅可以显示SVG图形并遵守CSS3规则，而且性能出色。除了层叠样式表（CSS）和可缩放矢量图形（SVG）之外，您还需要了解的Web开发元素还包括DOM（文档对象模型）和JavaScript。以下各节将广泛地介绍每个元素，并包括您可以运行的代码，以查看D3如何使用它们的函数来创建交互性和动态的Web内容。
- en: 1.3.1\. The DOM
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.1\. DOM
- en: A web page is structured according to the DOM. You need a passing familiarity
    with the DOM to do web development, so we’ll take a quick look at DOM elements
    and structure in a simple web page in your browser and touch on the basics of
    the DOM. To get started, you’ll need a web server that you can access from the
    computer that you’re using to code. With that in place, you can download the D3
    library from [d3js.org](http://d3js.org) (d3.js or d3.min.js for the minified
    version) and place that in the directory where you’ll make your web page. You’ll
    create a page called d3ia.html in the text editor with the contents in the following
    listing.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 网页的结构是根据DOM来组织的。您需要对DOM有基本的了解才能进行Web开发，因此我们将快速查看浏览器中的简单网页的DOM元素和结构，并简要介绍DOM的基本知识。要开始，您需要一个可以从您用于编码的计算机访问的Web服务器。有了这个，您可以从[d3js.org](http://d3js.org)（d3.js或d3.min.js用于压缩版本）下载D3库，并将其放置在您将创建网页的目录中。您将在文本编辑器中创建一个名为d3ia.html的页面，其内容如下所示。
- en: Listing 1.1\. A simple web page demonstrating the DOM
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表1.1\. 一个演示DOM的简单网页
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1* A child element of <html>**'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* `<html>`的子元素**'
- en: '***2* A child element of <body>**'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* `<body>`的子元素**'
- en: '***3* A child element of <div>**'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* `<div>`的子元素**'
- en: Basic HTML like this follows the DOM. It defines a set of nested elements, starting
    with an `<html>` element with all its child elements and their child elements
    and so on. In this example, the `<script>` and `<body>` elements are children
    of the `<html>` element, and the `<div>` element is a child of the `<body>` element.
    The `<script>` element loads the D3 library here, or it can have inline JavaScript
    code, whereas any content in the `<body>` element shows up onscreen when you navigate
    to this page.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的HTML结构，如上所示，遵循DOM（文档对象模型）。它定义了一组嵌套的元素，从包含所有子元素及其子元素的`<html>`元素开始。在这个例子中，`<script>`和`<body>`元素是`<html>`元素的子元素，而`<div>`元素是`<body>`元素的子元素。`<script>`元素在这里加载D3库，或者它可以包含内联JavaScript代码，而`<body>`元素中的任何内容在您导航到这个页面时都会显示在屏幕上。
- en: 'Three categories of information about each element determine its behavior and
    appearance: styles, attributes, and properties. *Styles* can determine transparency,
    color, size, borders, and so on. *Attributes* include classes, IDs, and interactive
    behavior, though certain attributes can also determine appearance, depending on
    which type of element you’re dealing with. *Properties* typically refer to states,
    such as the “checked” property of a check box, which is `true` if the box is checked
    and `false` if the box is unchecked. D3 has three corresponding functions to modify
    these values. If we wanted to modify the HTML elements in the previous example,
    we could use D3 functions that abstract this process:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 每个元素的三个信息类别决定了其行为和外观：样式、属性和属性。*样式*可以确定透明度、颜色、大小、边框等。*属性*包括类、ID和交互行为，尽管某些属性也可以根据您处理的是哪种类型的元素来决定外观。*属性*通常指状态，例如复选框的“checked”属性，如果复选框被选中则为`true`，如果没有选中则为`false`。D3有三个相应的函数来修改这些值。如果我们想修改上一个例子中的HTML元素，我们可以使用D3函数来抽象这个过程：
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Like many D3 functions of this kind, if you don’t signify a new value, then
    the function returns the existing value. This way of exposing getter/setter behavior
    in JavaScript was popularized in JQuery and shows up in most of the D3 examples.
    You’ll see this in action throughout this book, and later in the chapter as you
    write more code, but for now remember that these three functions allow you to
    change how an element appears and interacts.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多此类D3函数一样，如果你没有指定新值，那么函数将返回现有值。在JavaScript中通过这种方式公开getter/setter行为在JQuery中变得流行，并在大多数D3示例中都有体现。你将在整本书中看到这一点，在编写更多代码的章节中也会看到，但就目前而言，请记住这三个函数允许你更改元素的外观和交互方式。
- en: The DOM also determines the onscreen drawing order of elements, with child elements
    drawn after and inside parent elements. Although you have partial control over
    drawing elements above or below each other with traditional HTML using `z-index`,
    this won’t be available with SVG elements until the SVG2 spec is implemented.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: DOM还决定了元素在屏幕上的绘制顺序，子元素在父元素之后和内部绘制。尽管你可以使用传统的HTML和`z-index`在元素之间部分控制绘制顺序，但在SVG2规范实现之前，这不会适用于SVG元素。
- en: Examining the DOM in the console
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在控制台中检查DOM
- en: Navigate to d3ia.html, and you can get exposure to how D3 works. The page isn’t
    too impressive, with only a single, black-outlined rectangle. You could modify
    the look and feel of this web page by updating d3ia.html, but you’ll find that
    it’s easy to modify the page by using your web browser’s developer console. This
    is useful for testing changes to classes or elements before implementing them
    in your code. Open the developer console, and you’ll have two useful screens,
    shown in [figures 1.11](#ch01fig11) and [1.12](#ch01fig12), which we’ll go back
    to again and again.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到d3ia.html，你可以了解D3是如何工作的。这个页面并不太令人印象深刻，只有一个黑色轮廓的矩形。你可以通过更新d3ia.html来修改这个网页的外观和感觉，但你发现使用你的网络浏览器的开发者控制台来修改页面更容易。这在测试在代码中实现之前更改类或元素时很有用。打开开发者控制台，你将有两个有用的屏幕，如图1.11和1.12所示，我们将反复回到这些屏幕。
- en: Figure 1.11\. The developer tools in Chrome place the JavaScript console on
    the rightmost tab, labeled Console, with the element inspector available using
    the arrow in a rectangle (circled above) on the top left or by browsing the DOM
    in the Elements tab.
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.11。Chrome的开发者工具将JavaScript控制台放置在最右侧的标签上，标签名为“控制台”，元素检查器可以通过左上角矩形中的箭头（如图所示）或通过在“元素”标签中浏览DOM来访问。
- en: '![](../Images/01fig11_alt.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01fig11_alt.jpg)'
- en: Figure 1.12\. You can run JavaScript code in the console and call global variables
    or declare new ones as necessary. Any code you write in the console and changes
    made to the web page are lost as soon as you reload the page.
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.12。你可以在控制台中运行JavaScript代码，根据需要调用全局变量或声明新的变量。你在控制台中编写的任何代码和对网页所做的更改，在页面重新加载后都会丢失。
- en: '![](../Images/01fig12_alt.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01fig12_alt.jpg)'
- en: '|  |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-90
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You’ll see the console in this first chapter, but in [chapter 2](../Text/kindle_split_011.html#ch02),
    once you’re familiar with it, I’ll show only the output.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在第一章中看到控制台，但在[第二章](../Text/kindle_split_011.html#ch02)，一旦你熟悉它，我将只展示输出。
- en: '|  |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The element inspector allows you to look at the elements that make up your web
    page by navigating through the DOM (represented as nested text, where each child
    element is shown indented). You can also select an element onscreen graphically,
    typically represented as a magnifying glass or cursor icon.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 元素检查器允许你通过导航DOM（表示为嵌套文本，其中每个子元素都显示为缩进）来查看构成你的网页的元素。你还可以通过图形方式选择屏幕上的元素，通常表示为放大镜或光标图标。
- en: The other screen you’ll want to use quite often is the console ([figure 1.12](#ch01fig12)),
    which allows you to write and run JavaScript code right on your web page. The
    developer tools have other valuable features, such as setting breakpoints and
    the ability to inspect network calls, but we’re going to focus on using the console
    to change elements and run code.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会经常使用另一个屏幕，那就是控制台（[图1.12](#ch01fig12)），它允许你在网页上直接编写和运行JavaScript代码。开发者工具还有其他有价值的特性，例如设置断点和检查网络调用，但我们将专注于使用控制台来更改元素和运行代码。
- en: The examples in this book use Google Chrome and its developer console, but you
    could use Safari’s or Firefox’s developer tools with the same functionality and
    slightly different look-and-feel, or use your code editor and refresh the page.
    You can see and manipulate DOM elements such as `<div>` or `<body>` by clicking
    the element inspector or looking at the DOM as represented in HTML. You can click
    one of these elements and change its appearance by modifying it in the console.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的示例使用Google Chrome及其开发者控制台，但你也可以使用Safari或Firefox的开发者工具，它们具有相同的功能和略有不同的外观和感觉，或者使用你的代码编辑器并刷新页面。你可以通过点击元素检查器或查看HTML中表示的DOM来查看和操作DOM元素，如`<div>`或`<body>`。你可以点击这些元素之一，并通过在控制台中修改它来更改其外观。
- en: 'You can even delete elements in the console. Give it a try: select the div
    either in the DOM or visually and press Delete. Now your web page is lonely. Press
    Refresh so your page reloads the HTML and your div comes back. You can adjust
    the size and color of your div by adding new styles or changing the existing one,
    so you can increase the width of the border and make it dashed by changing the
    border style to Black 5px Dashed. You can add content to the div in the form of
    other elements, or you can add text by right-clicking on the element and selecting
    Edit as HTML, as shown in [figures 1.13](#ch01fig13) and [1.14](#ch01fig14).'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以在控制台中删除元素。试试看：在DOM中或在视觉上选择div，然后按Delete键。现在你的网页显得孤单。按刷新键，以便你的页面重新加载HTML，你的div就会回来。你可以通过添加新样式或更改现有样式来调整div的大小和颜色，例如，你可以通过将边框样式更改为黑色5像素虚线来增加边框的宽度。你可以在div中添加其他元素的形式的内容，或者你可以通过右键单击元素并选择“编辑为HTML”，如[图1.13](#ch01fig13)和[1.14](#ch01fig14)所示来添加文本。
- en: Figure 1.13\. Rather than adding or modifying individual styles and attributes,
    you can rewrite the HTML code as you would in a text editor. As with any changes,
    these only last until you reload the page.
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.13. 与添加或修改单个样式和属性不同，你可以像在文本编辑器中一样重写HTML代码。与任何更改一样，这些更改只持续到你重新加载页面。
- en: '![](../Images/01fig13.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/01fig13.jpg)'
- en: Figure 1.14\. Changing the content of a DOM element is as simple as adding text
    between the opening and ending brackets of the element.
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.14. 改变DOM元素的内容就像在元素的开始和结束括号之间添加文本一样简单。
- en: '![](../Images/01fig14.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/01fig14.jpg)'
- en: You can then write whatever you like in between the opening and closing HTML.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在HTML的开始和结束标签之间写入任何你想要的内容。
- en: Any changes you make, regardless of whether they’re well structured or not,
    will be reflected on the web page. In [figure 1.15](#ch01fig15) you see the results
    of modifying the HTML, which is rendered immediately on your page.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你所做的任何更改，无论它们是否结构良好，都会反映在网页上。在[图1.15](#ch01fig15)中，你可以看到修改HTML的结果，这些结果会立即在你的页面上渲染。
- en: Figure 1.15\. The page is updated as soon as you finish making your changes.
    Writing HTML manually in this way is only useful for planning how you might want
    to dynamically update the content.
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.15. 你完成更改后，页面会立即更新。以这种方式手动编写HTML仅适用于规划你如何动态更新内容。
- en: '![](../Images/01fig15_alt.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/01fig15_alt.jpg)'
- en: In this way, you could slowly and painstakingly create a web page in the console.
    We’re not going to do that. Instead, we’ll use D3 to create elements on the fly
    with size, position, shape, and content based on our data.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，你可以缓慢而细致地在控制台中创建一个网页。我们不会这样做。相反，我们将使用D3根据我们的数据动态创建具有大小、位置、形状和内容的元素。
- en: 1.3.2\. Coding in the console
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.2. 在控制台中编码
- en: 'You’ll do most your coding in the IDE or text editor of your choice, but one
    of the great things about web development is that you can test JavaScript code
    changes by using your console. Later you’ll focus on writing JavaScript, but for
    now, to demonstrate how the console works, copy the following code into your console
    and press Enter:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在你选择的IDE或文本编辑器中编写大部分代码，但关于Web开发的一个好处是你可以通过使用你的控制台来测试JavaScript代码的更改。稍后你将专注于编写JavaScript，但现在，为了演示控制台的工作原理，请将以下代码复制到你的控制台并按Enter键：
- en: '[PRE5]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You should see the effect shown in [figure 1.16](#ch01fig16).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能看到[图1.16](#ch01fig16)中显示的效果。
- en: Figure 1.16\. The D3 `select` syntax modifies style using the `.style()` function,
    and traditional HTML content using the `.html()` function.
  id: totrans-110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.16. D3的`select`语法使用`.style()`函数修改样式，使用`.html()`函数修改传统的HTML内容。
- en: '![](../Images/01fig16_alt.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/01fig16_alt.jpg)'
- en: 'You’ll see a few more uses of traditional HTML elements in this chapter, and
    then again in [chapter 3](../Text/kindle_split_012.html#ch03), but then you won’t
    see traditional DOM elements again in great detail. You can use D3 to create complex,
    data-driven spreadsheets and galleries using `<div>`, `<table>`, and `<select>`
    elements, but that’s not a common use case in the real world. If all D3 could
    do was select HTML elements and change their style and content like this, then
    it wouldn’t be that useful for data visualization. To do more, we have to move
    away from traditional HTML and focus on a special type of element in the DOM:
    SVG.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在本章中看到一些传统 HTML 元素的更多用途，然后在第 [3 章](../Text/kindle_split_012.html#ch03) 中再次看到，但之后你将不再详细看到传统
    DOM 元素。你可以使用 D3 通过 `<div>`、`<table>` 和 `<select>` 元素创建复杂的数据驱动电子表格和画廊，但在现实世界中这不是一个常见的用例。如果
    D3 只能像这样选择 HTML 元素并更改它们的样式和内容，那么它对数据可视化的用途就不会很大。为了做得更多，我们必须摆脱传统的 HTML，并专注于 DOM
    中的特殊类型元素：SVG。
- en: 1.3.3\. SVG
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.3\. SVG
- en: A major value of HTML5 is the integrated support for Scalable Vector Graphics
    (SVG). SVG allows for simple mathematical representation of images that scale
    and are amenable to animation and interaction. Part of the attractiveness of D3
    is that it provides an abstraction layer for drawing SVG, because SVG drawing
    can be a little confusing. SVG drawing instructions for complex shapes, known
    as `<path>` elements, are written a bit like the old LOGO programming language.
    You start at a point on a canvas and draw a line from that point to another. If
    you want it to curve, you can give the SVG drawing code coordinates on which to
    make that curve. If you want to draw the line on the left, you’d create a `<path>`
    element in an `<svg>` canvas element in your web page, and all those drawing instructions
    (that’s what they look like on the left of [figure 1.17](#ch01fig17)) go into
    the `d` attribute of that `<path>` element.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5 的一大优点是集成了对可缩放矢量图形（SVG）的支持。SVG 允许以简单的数学方式表示图像，这些图像可以缩放，并且易于动画和交互。D3 的吸引力之一在于它提供了一个用于绘制
    SVG 的抽象层，因为 SVG 绘图可能会有些令人困惑。用于复杂形状（称为 `<path>` 元素）的 SVG 绘图指令有点像旧的 LOGO 编程语言。你从一个画布上的点开始，从这个点画一条线到另一个点。如果你想让它弯曲，你可以给出
    SVG 绘图代码上的坐标，以在该坐标上绘制曲线。如果你想绘制左侧的线，你将在网页中的 `<svg>` 画布元素中创建一个 `<path>` 元素，并且所有这些绘图指令（这就是它们在
    [图 1.17](#ch01fig17) 左侧看起来像的样子）都放入该 `<path>` 元素的 `d` 属性中。
- en: Figure 1.17\. The commands to draw an SVG path (right) and the resulting graphic
    (left)
  id: totrans-115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.17\. 绘制 SVG 路径的命令（右）和生成的图形（左）
- en: '![](../Images/01fig17_alt.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/01fig17_alt.jpg)'
- en: But you’d almost never want to create SVG by manually writing drawing instructions
    like this. Instead, you’ll want to use D3 to do the drawing with a variety of
    helper functions, or rely on other SVG elements that represent simple shapes (known
    as geometric or graphical primitives) using more readable attributes. You’ll start
    doing that in [chapter 4](../Text/kindle_split_013.html#ch04), where you’ll use
    `d3.svg.line` and `d3.svg.area` to create line and area charts. For now, you’ll
    update d3ia.html to look like the following listing, which includes the necessary
    code for displaying SVG, as well as examples of the various shapes you might use.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 但你几乎不会想手动编写这样的绘图指令来创建 SVG。相反，你可能会想使用 D3 通过各种辅助函数来绘制图形，或者依赖其他使用更易读的属性来表示简单形状（称为几何或图形原语）的
    SVG 元素。你将在第 [4 章](../Text/kindle_split_013.html#ch04) 中开始这样做，在那里你将使用 `d3.svg.line`
    和 `d3.svg.area` 来创建折线图和面积图。现在，你需要更新 d3ia.html 以看起来像以下列表，其中包含显示 SVG 所需的代码，以及你可能使用的各种形状的示例。
- en: Listing 1.2\. A sample web page with SVG elements
  id: totrans-118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 1.2\. 带有 SVG 元素的示例网页
- en: '[PRE6]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can inspect the elements like you would the traditional elements we looked
    at earlier, as you can see in [figure 1.18](#ch01fig18), and you can manipulate
    these elements using traditional JavaScript selectors like `document.getElementById`
    or with D3, removing them or changing the style like so.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像检查我们之前看到的传统元素一样检查这些元素，就像你在 [图 1.18](#ch01fig18) 中看到的那样，并且你可以使用传统的 JavaScript
    选择器（如 `document.getElementById`）或使用 D3 来操作这些元素，例如删除它们或更改样式，如下所示。
- en: '[PRE7]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '***1* Deletes the circle**'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 删除圆圈**'
- en: '***2* Changes the rectangle color to purple**'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将矩形颜色更改为紫色**'
- en: Figure 1.18\. Inspecting the DOM of a web page with an SVG canvas reveals the
    nested graphical elements as well as the style and attributes that determine their
    position. Notice that the circle and rectangle exist as child elements of a group.
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.18\. 使用SVG画布检查网页的DOM，可以揭示嵌套的图形元素以及确定它们位置的样式和属性。请注意，圆形和矩形作为组的孩子元素存在。
- en: '![](../Images/01fig18_alt.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01fig18_alt.jpg)'
- en: Now refresh your page and let’s look at the new elements. You’re familiar with
    divs, and it’s useful to put an SVG canvas in a div so you can access the parent
    container for layout and styling. Let’s look at each of the elements we’ve added.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在刷新您的页面，让我们看看新添加的元素。您熟悉div，将SVG画布放在div中很有用，这样您就可以访问父容器以进行布局和样式设置。让我们看看我们添加的每个元素。
- en: <svg> container
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`<svg>` 容器'
- en: This is your canvas on which everything is drawn. The top-left corner is 0,0,
    and the canvas clips anything drawn beyond its defined height and width of 500,500
    (the rectangle in our example). An `<svg>` element can be styled with CSS to have
    different borders and backgrounds. The `<svg>` element can also be dynamically
    resized using the `viewBox` attribute, which is more complex and beyond the scope
    of the overview here.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您的画布，所有内容都在上面绘制。左上角是0,0，画布裁剪超出其定义的高度和宽度500,500（我们例子中的矩形）之外的内容。可以使用CSS对`<svg>`元素进行样式设置，以具有不同的边框和背景。`<svg>`元素还可以使用`viewBox`属性动态调整大小，这更复杂，超出了此处概述的范围。
- en: 'You can use CSS (which we’ll touch on later in this chapter) to style your
    SVG canvas or use D3 to add inline styles like this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用CSS（我们将在本章后面讨论）来设置SVG画布的样式，或者使用D3添加内联样式，如下所示：
- en: '[PRE8]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '***1* Infoviz is always cooler on a dark background**'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 信息可视化在深色背景上总是更酷**'
- en: '|  |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The x-axis is drawn left to right, but the y-axis is drawn top-to-bottom, so
    you’ll see that the circle is set 200 pixels to the right and 100 pixels down.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: x轴从左到右绘制，但y轴从上到下绘制，因此您会看到圆形被设置为向右200像素和向下100像素。
- en: '|  |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**<canvas>**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**<canvas>**'
- en: 'There’s a second mode of drawing available with HTML5 using `<canvas>` elements
    to draw bitmaps. We won’t go into detail here, but you’ll see this method used
    in [chapter 11](../Text/kindle_split_022.html#ch11) for its rendering performance.
    The <`canvas>` element creates static graphics drawn in a manner similar to SVG
    that can then be saved as images. Here are three main reasons to use `canvas`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用HTML5和`<canvas>`元素绘制位图，有第二种绘图模式可用。我们这里不会详细介绍，但您将在第11章（[chapter 11](../Text/kindle_split_022.html#ch11)）中看到这种方法被用于其渲染性能。`<canvas>`元素创建的静态图形绘制方式类似于SVG，然后可以将其保存为图像。以下是使用`canvas`的三个主要原因：
- en: '***Creating static images—*** You can draw your data visualization with `canvas`
    to save views as snapshots for thumbnail and gallery views.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***创建静态图像—*** 您可以使用`canvas`绘制您的数据可视化，将视图保存为快照以用于缩略图和画廊视图。'
- en: '***Large amounts of data—*** SVG creates individual elements in the DOM, and
    although this is great for attaching events and styling, it can overwhelm a browser
    and cause significant slowdown (this is what we’ll use `canvas` for in [chapter
    11](../Text/kindle_split_022.html#ch11)).'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***大量数据—*** SVG在DOM中创建单个元素，虽然这对于附加事件和样式很有用，但它可能会使浏览器过载并导致显著减速（这就是我们在第11章（[chapter
    11](../Text/kindle_split_022.html#ch11)）中使用`canvas`的原因）。'
- en: '*WebGL*—The <`canvas>` element allows you to use WebGL to draw, so that you
    can create 3D objects. You can also create 3D objects like globes and polyhedrons
    using SVG, which we’ll get into a bit in [chapter 8](../Text/kindle_split_018.html#ch08)
    as we examine geospatial information visualization.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*WebGL*—`<canvas>`元素允许您使用WebGL进行绘制，因此您可以创建3D对象。您还可以使用SVG创建类似地球和多面体的3D对象，我们将在第8章（[chapter
    8](../Text/kindle_split_018.html#ch08)）中稍作介绍，当我们考察地理空间信息可视化时。'
- en: '|  |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: <circle>, <rect>, <line>, <polygon> shape primitives
  id: totrans-143
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`<circle>`、`<rect>`、`<line>`、`<polygon>` 形状原语'
- en: SVG provides a set of common shapes, each of which has *attributes* that determine
    their size and position to make them easier to deal with than the generic `d`
    attribute you saw earlier. These attributes vary depending on the element you’re
    dealing with, so that `<rect>` has `x` and `y` attributes that determine the shape’s
    top-left corner, as well as `height` and `width` attributes that determine its
    overall form. In comparison, the `<circle>` element has `cx` and `cy` attributes
    that determine the center of the circle, and an `r` attribute that determines
    the radius of the circle. The `<line>` element has `x1` and `y1` attributes that
    determine the starting point of the line and `x2` and `y2` attributes that determine
    its end point. Other simple shapes are similar to these, such as the `<ellipse>`,
    and other more complex shapes, like the `<polygon>` with a `points` attribute
    that holds a set of comma-separated xy coordinates, in clockwise order, determine
    the area bounded by the polygon.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: SVG提供了一套常见的形状，每个形状都有*属性*，这些属性决定了它们的大小和位置，使得它们比之前看到的通用`d`属性更容易处理。这些属性根据你处理的元素而变化，所以`<rect>`元素有`x`和`y`属性，它们决定了形状的左上角，以及`height`和`width`属性，它们决定了形状的整体形状。相比之下，`<circle>`元素有`cx`和`cy`属性，它们决定了圆的中心，以及一个`r`属性，它决定了圆的半径。`<line>`元素有`x1`和`y1`属性，它们决定了线的起点，以及`x2`和`y2`属性，它们决定了线的终点。其他简单形状与这些类似，例如`<ellipse>`，而其他更复杂的形状，如具有`points`属性的`<polygon>`，它包含一组以顺时针顺序分隔的xy坐标，决定了多边形围成的区域。
- en: '|  |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Infoviz term: geometric primitive**'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**信息可视化术语：几何基本形状**'
- en: Accomplished artists can draw anything with vector graphics, but you’re probably
    not looking at D3 because you’re an artist. Instead, you’re dealing with graphics
    and have more pragmatic goals in mind. From that perspective, it’s important to
    understand the concept of geometric primitives (also known as graphical primitives).
    *Geometric primitives* are simple shapes such as points, lines, circles, and rectangles.
    These shapes, which can be combined to make more complex graphics, are particularly
    useful for visually displaying information.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的艺术家可以用矢量图形绘制任何东西，但你可能不是在查看D3，因为你是一位艺术家。相反，你正在处理图形，并且有更实际的目标。从这个角度来看，理解几何基本形状的概念（也称为图形基本形状）非常重要。*几何基本形状*是简单的形状，如点、线、圆和矩形。这些形状可以组合成更复杂的图形，对于视觉显示信息特别有用。
- en: Primitives are also useful for understanding complex information visualizations
    that you see out in the real world. Dendrograms, like the one shown in [figure
    1.20](#ch01fig20), are far less intimidating when you realize they’re only circles
    and lines. Interactive timelines are easier to understand and create when you
    think of them as collections of rectangles and points. Even geographic data, which
    primarily comes in the form of polygons, points, and lines, is less confusing
    when you break it down into its most basic graphical structures.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 基本形状对于理解现实世界中看到的复杂信息可视化也非常有用。例如，像[图1.20](#ch01fig20)中展示的树状图，当你意识到它们只是圆圈和线条时，就会显得不那么令人畏惧。当你把它们看作是矩形和点的集合时，交互式时间轴就更容易理解和创建。即使是地理数据，主要以多边形、点和线的形式出现，当你将其分解为其最基本的图形结构时，也会变得不那么令人困惑。
- en: '|  |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Each of these attributes can be hand-edited in HTML to adjust its size, form,
    and position. Open your element inspector and click the `<rect>`. Change its `width`
    to 25 and its `height` to 25, as shown in [figure 1.19](#ch01fig19).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这些属性都可以在HTML中手动编辑以调整其大小、形状和位置。打开你的元素检查器并点击`<rect>`。将其`width`更改为25，将其`height`也改为25，如图[图1.19](#ch01fig19)所示。
- en: Figure 1.19\. Modifying the height and width attributes of a `<rect>` element
    changes the appearance of that element. Inspecting the element also shows how
    the stroke adds to the computed size of the element.
  id: totrans-151
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.19。修改`<rect>`元素的宽度和高度属性会改变该元素的外观。检查该元素还会显示如何通过描边增加元素的计算尺寸。
- en: '![](../Images/01fig19_alt.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01fig19_alt.jpg)'
- en: Now you’ve learned why there’s no SVG `<square>`. The color, stroke, and transparency
    of any shape can be changed by adjusting the style of the shape, with `fill` determining
    the color of the area of the shape and `stroke`, `stroke-width`, `stroke-dasharray`
    determining its outline.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了为什么没有SVG `<square>`。任何形状的颜色、描边和透明度都可以通过调整形状的样式来改变，其中`fill`决定了形状区域的颜色，而`stroke`、`stroke-width`、`stroke-dasharray`决定了其轮廓。
- en: Notice, though, that the inspected element has a measurement of 27 px x 27 px.
    That’s because the 1-px stroke is drawn on the outside of the shape. That makes
    sense, once you know the rule, but if you change the `stroke-width` to `2px` it
    will still be 27 px x 27 px. That’s because the stroke is drawn evenly over the
    inside and outside borders, as seen in [figure 1.20](#ch01fig20). This may not
    seem too big a deal, but it’s something to remember when you’re trying to line
    up your shapes later.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，然而，检查的元素有一个 27 px x 27 px 的测量值。这是因为 1-px 线条绘制在形状的外部。一旦你知道规则，这就有意义了，但如果你将
    `stroke-width` 更改为 `2px`，它仍然会是 27 px x 27 px。这是因为线条均匀地绘制在内部和外部边界上，如 [图 1.20](#ch01fig20)
    所示。这可能看起来不是什么大问题，但当你试图稍后对齐形状时，这是一个需要记住的事情。
- en: Figure 1.20\. The same 25 x 25 `<rect>` with no, 1-px, 2-px, 3-px, 4-px, and
    5-px strokes. Though these are drawn on a retina screen using half-pixels, the
    second and third report the same width and height (27 px x 27 px) as the fourth
    and fifth (29 px x 29 px).
  id: totrans-155
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.20. 无、1-px、2-px、3-px、4-px 和 5-px 线条的相同 25 x 25 `<rect>`。尽管这些线条是在视网膜屏幕上使用半像素绘制的，但第二和第三个报告的宽度和高度（27
    px x 27 px）与第四和第五个（29 px x 29 px）相同。
- en: '![](../Images/01fig20_alt.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01fig20_alt.jpg)'
- en: 'Change the style parameters of the rectangle to the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 将矩形的样式参数更改为以下内容：
- en: '[PRE9]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Congratulations! You’ve now successfully visualized the complex and ambiguous
    phenomenon known as “ugly.”
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你现在已经成功地可视化了被称为“丑陋”的复杂而模糊的现象。
- en: <text>
  id: totrans-160
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`<text>`'
- en: SVG provides the capacity to write text as well as shapes. SVG text, though,
    doesn’t have the formatting support found in HTML elements, so it’s primarily
    used for labels. If you do want to do basic formatting, you can nest `<tspan>`
    elements in `<text>`
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: SVG 提供了写入文本以及形状的能力。然而，SVG 文本没有像 HTML 元素中找到的格式化支持，因此它主要用于标签。如果你想进行基本的格式化，你可以在
    `<text>` 中嵌套 `<tspan>` 元素。
- en: <g> grouping element
  id: totrans-162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`<g>` 分组元素'
- en: 'The `<g>` or group element is distinct from the SVG elements we’ve discussed
    in that it has no graphical representation and doesn’t exist as a bounded space.
    Instead, it’s a logical grouping of elements. You’ll want to use `<g>` elements
    extensively when creating graphical objects that are made up of several shapes
    and text. For instance, if you wanted to have a circle with a label above it and
    move the label and the circle at the same time, then you’d place them inside a
    `<g>` element:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`<g>` 或组元素与我们在前面讨论的 SVG 元素不同，因为它没有图形表示，也不存在于一个有界空间中。相反，它是一组元素的逻辑分组。当你创建由多个形状和文本组成的图形对象时，你会希望广泛使用
    `<g>` 元素。例如，如果你想有一个圆圈，上面有一个标签，并且同时移动标签和圆圈，那么你应该将它们放在一个 `<g>` 元素内：'
- en: '[PRE10]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Moving a `<g>` around your canvas requires you to adjust the `transform` attribute
    of the `<g>` element. The `transform` attribute is more intimidating than the
    various xy attributes of shapes because it accepts a structured description in
    text of how you want to transform a shape. One of those structures is `translate()`,
    which accepts a pair of coordinates that move the element to the xy position defined
    by the values in `translate (x,y)`. If you want to move a `<g>` element 100 pixels
    to the right and 50 pixels down, then you need to set its `transform` attribute
    to `transform="translate (100,50)"`. The transform attribute also accepts a `scale()`
    setting so you can change the rendered scale of the shape as you can see in the
    example in [listing 1.3](#ch01ex03). You can see these settings in action by modifying
    the previous example with the results shown in [figure 1.21](#ch01fig21).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在画布上移动 `<g>` 元素需要你调整 `<g>` 元素的 `transform` 属性。`transform` 属性比形状的各种 xy 属性更令人畏惧，因为它接受一个文本中的结构化描述，说明你想要如何变换一个形状。这些结构之一是
    `translate()`，它接受一对坐标，将元素移动到由 `translate (x,y)` 中的值定义的 xy 位置。如果你想将 `<g>` 元素向右移动
    100 像素，向下移动 50 像素，那么你需要将其 `transform` 属性设置为 `transform="translate (100,50)"`。`transform`
    属性还接受 `scale()` 设置，这样你就可以像在 [列表 1.3](#ch01ex03) 中的示例中看到的那样改变形状的渲染比例。你可以通过修改前面的示例并显示在
    [图 1.21](#ch01fig21) 中的结果来看到这些设置的实际效果。
- en: Figure 1.21\. All SVG elements can be affected by the `transform` attribute,
    but this is particularly salient when working with `<g>` elements, which require
    this approach to adjust their position. The child elements are drawn by using
    the position of their parent `<g>` as their relative 0,0 position. The `scale()`
    setting in the `transform` attribute then affects the scale of any of the size
    and position attributes of the child elements.
  id: totrans-166
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.21\. 所有SVG元素都可以受到`transform`属性的影响，但在使用`<g>`元素时这一点尤为明显，因为调整这些元素的位置需要这种方法。子元素是通过使用其父`<g>`的位置作为它们的相对0,0位置来绘制的。`transform`属性中的`scale()`设置会影响子元素的大小和位置属性的缩放。
- en: '![](../Images/01fig21_alt.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01fig21_alt.jpg)'
- en: Listing 1.3\. Grouping SVG elements
  id: totrans-168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表1.3\. SVG元素的分组
- en: '[PRE11]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: <path>
  id: totrans-170
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <path>
- en: A path is an area determined by its `d` attribute. Paths can be open or closed,
    meaning the last point connects to the first if closed and doesn’t if open. The
    open or closed nature of a path is determined by the absence or presence of the
    letter *Z* at the end of the text string in the `d` attribute. It can still be
    filled either way. You can see the difference in [figure 1.22](#ch01fig22) (the
    code for which is shown in the following listing).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 路径是由其 `d` 属性确定的区域。路径可以是开放的或闭合的，这意味着如果闭合，最后一个点会连接到第一个点，如果开放则不会。路径的开放或闭合性质由 `d`
    属性中文字字符串末尾是否存在字母 *Z* 决定。无论哪种方式，都可以填充路径。您可以在[图1.22](#ch01fig22)中看到差异（其代码如下所示）。
- en: Figure 1.22\. Each path shown here uses the same coordinates in its `d` attribute,
    with the only differences between them being the presence or absence of the letter
    *Z* at the end of the text string defining the `d` attribute, the settings for
    fill and stroke, and the position via the `transform` attribute.
  id: totrans-172
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.22\. 这里显示的每个路径在其`d`属性中使用相同的坐标，它们之间的唯一区别是定义`d`属性的文本字符串末尾是否存在字母 *Z*，填充和描边的设置，以及通过`transform`属性的位置。
- en: '![](../Images/01fig22_alt.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01fig22_alt.jpg)'
- en: Listing 1.4\. SVG path fill and closing
  id: totrans-174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表1.4\. SVG路径填充和闭合
- en: '[PRE12]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Although sometimes you may want to write that `d` attribute yourself, it’s
    more likely that your experience crafting SVG will come in one of three ways:
    using geometric primitives such as circles, rectangles, or polygons, drawing SVG
    using a vector graphics editor like Adobe Illustrator or Inkscape, or drawing
    SVG parametrically using handwritten constructors or built-in constructors in
    D3\. Most of this book focuses on using D3 to create SVG, but don’t overlook the
    possibility of creating SVG using an external application or another library and
    then manipulating them using D3, like we’ll do using d3.html in [chapter 3](../Text/kindle_split_012.html#ch03).'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有时您可能想自己编写`d`属性，但您的SVG制作经验更有可能来自以下三种方式之一：使用几何原语，如圆、矩形或多边形，使用Adobe Illustrator或Inkscape等矢量图形编辑器绘制SVG，或使用手写的构造函数或D3内置构造函数参数化地绘制SVG。本书的大部分内容都集中在使用D3创建SVG上，但不要忽视使用外部应用程序或另一个库创建SVG的可能性，然后使用D3来操作它们，就像我们在[第3章](../Text/kindle_split_012.html#ch03)中使用的d3.html一样。
- en: 1.3.4\. CSS
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.4\. CSS
- en: CSS are used to style the elements in the DOM. A style sheet can exist as a
    separate .css file that you include in your HTML page or can be embedded directly
    in the HTML page. Style sheets refer to an ID, class, or type of element and determine
    the appearance of that element. The terminology used to define the style is a
    *CSS selector* and is the same type of selector used in the `d3.select()` syntax.
    You can set inline styles (that are applied to only a single element) by using
    `d3.select(#someElement).style(opacity, .5)` to set the opacity of an element
    to 50%. Let’s update your d3ia.html to include a style sheet, as shown in the
    following listing.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: CSS用于在DOM中设置元素的样式。样式表可以作为一个单独的.css文件存在，并将其包含在您的HTML页面中，或者可以直接嵌入到HTML页面中。样式表引用ID、类或元素类型，并确定该元素的外观。用于定义样式的术语是*CSS选择器*，它与`d3.select()`语法中使用的选择器类型相同。您可以通过使用`d3.select(#someElement).style(opacity,
    .5)`来设置元素的透明度为50%，从而设置内联样式（仅应用于单个元素）。让我们更新您的d3ia.html以包含一个样式表，如下所示。
- en: Listing 1.5\. A sample web page with a style sheet
  id: totrans-179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表1.5\. 带有样式表的示例网页
- en: '[PRE13]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '***1* The reference to the D3 library so we can use that code in our app**'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 对D3库的引用，这样我们就可以在我们的应用中使用该代码**'
- en: '***2* CSS rules for our elements**'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 我们元素的CSS规则**'
- en: '***3* The fixed content of our page (we’ll work on adding more content dynamically
    later)**'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 我们页面的固定内容（我们将在稍后添加更多动态内容）**'
- en: The results stack on each other, so when you examine the rectangle element,
    as shown in [figure 1.23](#ch01fig23), you see that its style is set by the reference
    to `rect` in the style sheet as well as the class attribute of `active`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 结果会叠加在一起，因此当你检查矩形元素时，如图[图1.23](#ch01fig23)所示，你会看到其样式是由样式表中`rect`的引用以及`active`类的属性设置的。
- en: Figure 1.23\. Examining an SVG rectangle in the console shows that it inherits
    its fill style from the CSS style applied to `<rect>` types and its stroke style
    from the `.active` class.
  id: totrans-185
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.23。在控制台中检查SVG矩形显示，它从应用于`<rect>`类型的CSS样式继承其填充样式，并从`.active`类继承其描边样式。
- en: '![](../Images/01fig23_alt.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](../Images/01fig23_alt.jpg)'
- en: 'Style sheets can also refer to a state of the element, so with `:hover` you
    can change the way an element looks when the user mouses over that element. You
    can learn about other complex CSS selectors in more detail in a book devoted to
    that subject. For this book, we’ll focus mostly on using CSS classes and IDs for
    selection and to change style. The most useful way to do this is to have CSS classes
    associated with particular stylistic changes and then change the class of an element.
    You can change the class of an element, which is an attribute of an element, by
    selecting and modifying the class attribute. The circle shown in [figure 1.24](#ch01fig24)
    is affected by two overlapping classes: `.active` and `.tentative`.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 样式表还可以引用元素的状态，因此使用`:hover`，你可以改变用户将鼠标悬停在元素上时元素的外观。你可以在专门介绍该主题的书中详细了解其他复杂的CSS选择器。对于本书，我们将主要关注使用CSS类和ID进行选择和更改样式。最实用的方法是让CSS类与特定的样式更改相关联，然后更改元素的类。你可以通过选择和修改类属性来更改元素的类，这是元素的一个属性。图[图1.24](#ch01fig24)中显示的圆圈受到两个重叠类的影响：`.active`和`.tentative`。
- en: Figure 1.24\. The SVG circle has its fill value set by its type in the style
    sheet, with its opacity set by its membership in the `.tentative` class and its
    stroke set by its membership in the `.active` class. Notice that the stroke settings
    from the `.tentative` class are overwritten by the stroke settings in the later
    declared `.active` class.
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.24。SVG圆圈的填充值由样式表中的其类型设置，其透明度由其在`.tentative`类中的成员资格设置，其描边由其在`.active`类中的成员资格设置。请注意，`.tentative`类的描边设置被后来声明的`.active`类的描边设置覆盖。
- en: '![](../Images/01fig24_alt.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](../Images/01fig24_alt.jpg)'
- en: 'In [listing 1.5](#ch01ex05) we see a couple of possibly overlapping classes,
    with tentative, active, and inactive all applying different style changes to your
    shape (such as the highlighted circle in [figure 1.23](#ch01fig23)). When an element
    needs only be assigned to one of these classes, you can overwrite the class attribute
    entirely:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表1.5](#ch01ex05)中，我们看到一些可能重叠的类，包括尝试、活动和非活动，它们都对形状（如[图1.23](#ch01fig23)中的高亮圆圈）应用了不同的样式更改。当一个元素只需要分配给这些类中的一个时，你可以完全覆盖类属性：
- en: '[PRE14]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The results, as shown in [figure 1.25](#ch01fig25), are what we’d expect. This
    overwrites the entire class attribute to the value you set. But elements can have
    multiple classes, and sometimes an element is both active and tentative or inactive
    and tentative, so let’s reload the page and take advantage of the helper function
    `d3.classed()`, which allows you to add or remove a class from the classes in
    an element.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图1.25](#ch01fig25)所示的结果是我们预期的。这会覆盖整个类属性到设置的值。但是元素可以有多个类，有时一个元素既是活动的又是尝试的，或者既是非活动的又是尝试的，所以让我们重新加载页面并利用辅助函数`d3.classed()`，它允许你向元素中的类添加或删除类。
- en: '[PRE15]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Figure 1.25\. An SVG circle with fill style determined by its type and its opacity
    and stroke settings determined by its membership in the `tentative` class
  id: totrans-194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.25。一个填充样式由其类型决定，其透明度和描边设置由其在`tentative`类中的成员资格决定的SVG圆圈
- en: '![](../Images/01fig25.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](../Images/01fig25.jpg)'
- en: By using `.classed()`, you don’t overwrite the existing attribute, but rather
    append or remove the named class from the list. You can see the results of two
    classes with conflicting styles defined. The active style overwrites the tentative
    style because it occurs later in the style sheet. Another rule to remember is
    that more specific rules overwrite more general rules. There’s more to CSS, but
    this book won’t go into that.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `.classed()`，你不会覆盖现有的属性，而是将命名的类从列表中添加或删除。你可以看到两个具有冲突样式的类的结果。由于在样式表中出现的顺序较晚，活动样式会覆盖尝试样式。另一个需要记住的规则是，更具体的规则会覆盖更一般的规则。CSS还有很多内容，但本书不会深入探讨。
- en: By defining style in your style sheet and changing appearance based on class
    membership, you create code that’s more maintainable and readable. You’ll need
    to use inline styles to set the graphical appearance of a set of elements to a
    variety of different values, for example, changing the fill color to correspond
    to a color ramp based on the data bound to that set of elements. You’ll see that
    functionality in action later when you deal with bound data. But as a general
    rule, setting inline styles should only be used when you can’t use traditional
    classes and states defined in a style sheet.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在样式表中定义样式并根据类成员资格更改外观，你可以创建更易于维护和阅读的代码。你可能需要使用内联样式来设置一组元素的图形外观，例如，将填充颜色更改为与绑定到该组元素的颜色的渐变相匹配。你将在处理绑定数据时看到该功能的实际应用。但作为一般规则，设置内联样式应仅在你无法使用样式表中定义的传统类和状态时使用。
- en: 1.3.5\. JavaScript
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.5\. JavaScript
- en: D3, like many information visualization libraries in JavaScript, provides functions
    to abstract the process of creating and modifying web page elements. On top of
    that, it provides mechanisms to link data and web page elements in a way that
    makes the drawing and updating of these SVG elements reusable and maintainable.
    But these mechanisms are also applicable to more traditional HTML elements such
    as paragraphs and divs.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: D3，像JavaScript中的许多信息可视化库一样，提供了抽象创建和修改网页元素过程的函数。在此基础上，它还提供了将数据与网页元素链接起来的机制，使得这些SVG元素的绘制和更新变得可重用和维护。但这些机制也适用于更传统的HTML元素，如段落和div。
- en: 'When writing JavaScript with D3, you should familiarize yourself with two subjects:
    method chaining and arrays.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用D3编写JavaScript时，你应该熟悉两个主题：方法链式调用和数组。
- en: Method chaining
  id: totrans-201
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 方法链式调用
- en: 'D3 examples, like many examples written in JavaScript, use method chaining
    extensively. Method chaining, also known as function chaining, is facilitated
    by returning the method itself with the successful completion of functions associated
    with a method. One way to think of method chaining is to think of how we talk
    and refer to each other. Imagine you were talking to someone at a party, and you
    asked about another guest:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: D3示例，像许多用JavaScript编写的示例一样，广泛使用了方法链式调用。方法链式调用，也称为函数链式调用，是通过在函数成功完成后返回该函数本身来实现的。思考方法链式调用的一种方式是想象我们如何相互交谈和指称。想象你在聚会上和某人交谈，并询问另一位客人：
- en: “What’s her name?”
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: “她叫什么名字？”
- en: “Her name is Lindsay.”
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: “她叫林赛。”
- en: “Where does she work?”
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: “她在哪里工作？”
- en: “She works at Tesla.”
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: “她在特斯拉工作。”
- en: “Where does she live?”
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: “她住在哪里？”
- en: “She lives in Cupertino.”
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: “她住在库比蒂诺。”
- en: “Does she have any children?”
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: “她有孩子吗？”
- en: “Yes, she has a daughter.”
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: “是的，她有一个女儿。”
- en: “What’s her name?”
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: “她叫什么名字？”
- en: 'Do you think the answer to that last question would be “Lindsay”? Of course
    not. You’d expect the answer to refer to Lindsay’s daughter, even though all the
    previous questions referred to Lindsay. Method chaining is like that. It returns
    the same function as long as you use getter and setter methods of that function
    and returns the new function when you call a method that creates something new.
    Method chaining is used a lot in D3 examples, which means you’ll see something
    like this written on one line or formatted (but functionally identical) to something
    written on multiple lines:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为上一个问题的答案会是“林赛”吗？当然不是。你会期望答案指的是林赛的女儿，尽管所有之前的问题都指的是林赛。方法链式调用就是这样。只要使用该函数的getter和setter方法，它就会返回相同的函数；当你调用创建新内容的方法时，它会返回新的函数。方法链式调用在D3示例中用得很多，这意味着你可能会看到一行或格式化（但功能相同）的代码，如下所示：
- en: '[PRE16]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'That line is the same as the following code. The only change is in the use
    of line breaks, which JavaScript ignores:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 该行与以下代码相同。唯一的区别在于行中断的使用，JavaScript忽略行中断：
- en: '[PRE17]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '***1* Returns a selection, an object with various functions available**'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 返回一个selection，一个具有各种可用函数的对象**'
- en: '***2* Sets the data on the selection and returns the selection**'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在selection上设置数据并返回selection**'
- en: '***3* Returns the selection.enter() object**'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 返回selection.enter()对象**'
- en: '***4* Sets .append() behavior on the selection.enter object and returns the
    selection.enter object**'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 在selection.enter对象上设置Sets.append()行为并返回selection.enter对象**'
- en: '***5* Sets .html() for the selection.enter object and returns the selection.enter
    object**'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 为selection.enter对象设置.html()并返回selection.enter对象**'
- en: '***6* Sets the append() behavior on the selection.enter object and returns
    the enter.append object**'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 在selection.enter对象上设置append()行为并返回enter.append对象**'
- en: '***7* Sets the html() for the enter.append object and returns the enter.append
    object**'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 为 enter.append 对象设置 html() 并返回 enter.append 对象**'
- en: '***8* Sets the font-weight style on the enter.append object and returns the
    enter.append object**'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 为 enter.append 对象设置字体粗细样式并返回 enter.append 对象**'
- en: 'You could write each line separately, declaring the different variables as
    you go, and achieve the same effect. That might make more sense if you haven’t
    been exposed to method chaining before:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以单独编写每一行，逐个声明不同的变量，以达到相同的效果。如果你之前没有接触过方法链，这可能会更有意义：
- en: '[PRE18]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can see this when you run the code in your console. This is the first time
    you’ve used the `.data()` function, which along with `.select()` is at the core
    of developing with D3\. When you use `.data(array)`, you bind each element in
    your selection to each item in an array (if you don’t pass anything to `.data()`
    you get back the items bound to your selection). When binding data, if you have
    more items in your array than elements in your selection, then you can use the
    `.enter()` function to define what to do with each extra element. In the previous
    function, you select all the `<div>` elements in the `<body>` and the `.enter()`
    function tells D3 to `.append()` a new div when there are more elements in the
    array than elements in the selection. Given that your d3ia.html page already has
    one div, if you bind an array with more than one value, D3 appends, or adds, a
    div for each value in the array beyond the first.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在你的控制台中运行代码时看到这一点。这是你第一次使用 `.data()` 函数，它与 `.select()` 一起构成了使用 D3 进行开发的核心。当你使用
    `.data(array)` 时，你将你的选择集中的每个元素绑定到数组中的每个项目（如果你没有传递任何内容给 `.data()`，你将得到绑定到你的选择集中的项目）。在绑定数据时，如果你的数组中的项目多于你的选择集中的元素，那么你可以使用
    `.enter()` 函数来定义如何处理每个额外的元素。在前一个函数中，你选择了 `<body>` 中的所有 `<div>` 元素，而 `.enter()`
    函数告诉 D3 当数组中的元素多于选择集中的元素时，添加一个新的 div。鉴于你的 d3ia.html 页面已经有一个 div，如果你绑定了一个包含多个值的数组，D3
    将为数组中超出第一个值的每个值添加或添加一个 div。
- en: A corresponding `.exit()` function defines how to respond when an array has
    fewer values than a selection. For now, you’ll run the code as it appears in the
    examples, and in later chapters we’ll get into much more detail on the way selections
    and binding work.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的 `.exit()` 函数定义了当数组中的值少于选择集时如何响应。现在，你将按照示例中的代码运行，在后面的章节中，我们将更详细地介绍选择集和绑定的工作方式。
- en: 'With this example, you’re not doing anything with the data in the array and
    only creating elements based on the size of the array (one `<div>` for each element
    in the array). This example assumes that you already have a `<div>` in your HTML
    with a gray border (as seen in [figure 1.25](#ch01fig25)). Here’s the HTML that
    would get that done:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你并没有对数组中的数据进行任何操作，只是根据数组的大小（数组中的每个元素一个 `<div>`）创建元素。这个例子假设你已经在你的 HTML
    中有一个带有灰色边框的 `<div>`（如图 1.25 所示）。以下是完成这个任务的 HTML 代码：
- en: '[PRE19]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'For this to work, you need to give `someData` a value. With that in place,
    you can run your code:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这可行，你需要给 `someData` 赋予一个值。有了这个，你就可以运行你的代码：
- en: '[PRE20]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The result, as shown in [figure 1.26](#ch01fig26), is the addition of three
    lines of text. It might surprise you that this code is three lines, given that
    the array has four values. Although the data was bound to the existing `<div>`
    element on the page, the actions that changed the contents were only applied to
    the `.enter()` function. This means they were only applied to the newly created
    `<div>` elements that were “entering” the DOM for the first time.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，如图 1.26 所示，增加了三行文本。考虑到数组中有四个值，这个代码只有三行可能会让你感到惊讶。尽管数据被绑定到了页面上的现有 `<div>` 元素上，但改变内容的行为仅应用于
    `.enter()` 函数。这意味着它们仅应用于第一次“进入”DOM的新创建的 `<div>` 元素。
- en: Figure 1.26\. By binding an array of four values to a selection of `<div>` elements
    on the page, the `.enter()` function created three new `<div>` elements to reflect
    the size mismatch between the data array and the selection.
  id: totrans-233
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.26\. 通过将四个值的数组绑定到页面上的 `<div>` 元素选择集，`.enter()` 函数创建了三个新的 `<div>` 元素，以反映数据数组和选择集之间的大小不匹配。
- en: '![](../Images/01fig26_alt.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01fig26_alt.jpg)'
- en: When you inspect the DOM, as shown in [figure 1.27](#ch01fig27), you see that
    the method chaining operated in the manner previously described. A `<div>` was
    added, and its HTML content was set to `Wow`. A `<span>` element with a different
    style was appended to the `<div>`, and its HTML content was set to `Even More
    Wow`. There’s more you can do, but first you need to examine the array object
    you’re binding and focus on JavaScript arrays and array functions.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当您检查 DOM，如图[图1.27](#ch01fig27)所示，您会看到方法链以先前描述的方式操作。添加了一个 `<div>`，其 HTML 内容设置为
    `Wow`。然后向 `<div>` 添加了一个具有不同样式的 `<span>` 元素，其 HTML 内容设置为 `Even More Wow`。您还可以做更多的事情，但首先您需要检查您要绑定的数组对象，并专注于
    JavaScript 数组和数组函数。
- en: Figure 1.27\. Inspecting the DOM shows that the new `<div>` elements have been
    created with unformatted content followed by the child `<span>` element with style
    and content set by your code.
  id: totrans-236
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.27\. 检查 DOM 显示，新的 `<div>` 元素已经创建，内容未格式化，随后是您的代码设置的样式和内容的子 `<span>` 元素。
- en: '![](../Images/01fig27_alt.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01fig27_alt.jpg)'
- en: Arrays and array functions
  id: totrans-238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 数组和数组函数
- en: 'D3 is all about arrays, and so it’s important to understand the structure of
    arrays and the options available to you to prepare those arrays for binding to
    data. Your array might be an array of string or number literals, such as this:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: D3 全是关于数组的，因此理解数组的结构和您可用于准备这些数组的选项非常重要。您的数组可能是一个字符串或数字字面量的数组，例如这个：
- en: '[PRE21]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Or it may be an array of JavaScript objects, which will become more common
    as you do more interesting things with D3:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 或者它可能是一个 JavaScript 对象的数组，随着您使用 D3 做更多有趣的事情，这将会变得更加常见：
- en: '[PRE22]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'One example of a useful array function is `.filter()`, which returns an array
    whose elements satisfy a test you provide. For instance, here’s how to create
    an array out of `someNumbers` that had values greater than 40:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有用的数组函数的例子是 `.filter()`，它返回一个满足您提供的测试的元素的数组。例如，这是如何从 `someNumbers` 创建一个值大于
    40 的数组的示例：
- en: '[PRE23]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Likewise, here’s how you could create an array out of `someColors` with names
    shorter than five letters:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这是如何从 `someColors` 创建一个由五个字母以下名称组成的数组的示例：
- en: '[PRE24]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The function `.filter()` is a method of an array and accepts a function that
    iterates through the array with the variable you’ve named. In this function, you
    name that variable `d`, and the function runs a test on each value by testing
    on `d`. When that test evaluates `true`, the element is kept in our new array.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`.filter()` 函数是一个数组的方法，它接受一个迭代数组的函数，您为该变量命名。在这个函数中，您将变量命名为 `d`，该函数通过在 `d` 上进行测试来对每个值进行测试。当该测试评估为
    `true` 时，该元素保留在我们的新数组中。'
- en: 'The result of this `.filter()` function, which you can see in [figure 1.28](#ch01fig28),
    returns either the element or nothing (depending on if it satisfies the test),
    building a new array consisting only of the elements that do:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `.filter()` 函数的结果，您可以在[图1.28](#ch01fig28)中看到，返回元素或无（取决于它是否满足测试），构建一个只包含满足测试的元素的新数组。
- en: Figure 1.28\. Running JavaScript in the console allows you to test your code.
    Here you’ve created a new array called `smallerNumbers` that consists of only
    three values, which you can then use as your data in a selection to update and
    create new elements.
  id: totrans-249
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.28\. 在控制台中运行 JavaScript 允许您测试您的代码。在这里，您创建了一个名为 `smallerNumbers` 的新数组，它只包含三个值，然后您可以使用这些值作为选择中的数据来更新和创建新元素。
- en: '![](../Images/01fig28_alt.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01fig28_alt.jpg)'
- en: '[PRE25]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The resulting code creates two new divs from your three-value array `smallerNumbers`.
    (Remember that one div already exists, and so the `.enter()` function doesn’t
    trigger even though data is bound to that existing div.) The contents of the div
    are the values in your array. This is done through an anonymous function (sometimes
    referred to in D3 examples as an *accessor*) in your `.html()` function and is
    another key aspect of D3\. Any anonymous function called when setting the `.style()`,
    `.attr()`, `.property()`, `.html()`, or other function of a selection can provide
    you with the data bound to that selection. As you explore examples, you’ll see
    this function deployed again and again:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的代码从您的三个值数组 `smallerNumbers` 中创建了两个新的 div。 (记住，已经存在一个 div，因此尽管数据绑定到该现有 div，`.enter()`
    函数也不会触发。) div 的内容是您的数组中的值。这是通过在 `.html()` 函数中的匿名函数（有时在 D3 示例中称为 *访问器*）完成的，这是 D3
    的另一个关键方面。任何在设置 `.style()`、`.attr()`、`.property()`、`.html()` 或其他选择函数时调用的匿名函数都可以提供您绑定到该选择的数据。随着您探索示例，您将看到这个函数被一次又一次地部署：
- en: '[PRE26]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In every case, the first variable (typically represented with the letter *d*,
    but you can declare it as whatever you want) contains the data value bound to
    that element, and the second variable returns the array position (known as an
    index, hence the variable name *i*) of the value bound to that element. This may
    seem a bit strange, but you’ll get used to it as you see it used in a variety
    of ways in the upcoming chapters.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，第一个变量（通常用字母 *d* 表示，但你也可以声明为任何你想要的）包含绑定到该元素的数据值，第二个变量返回绑定到该元素值的数组位置（称为索引，因此变量名为
    *i*）。这可能会有些奇怪，但当你看到它在接下来的章节中以各种方式使用时，你会习惯它的。
- en: JavaScript has many other array functions, and you can do much more than I’ve
    covered here, but that’s the subject of several other books. It’s time to look
    at the kinds of data you’ll work with.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 有许多其他的数组函数，你可以做比这里所涵盖的更多的事情，但这将是几本其他书的主题。现在是时候看看你将处理的数据类型了。
- en: 1.3.6\. ES2015 and Node
  id: totrans-256
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.6\. ES2015 和 Node
- en: JavaScript has seen some major changes in the last couple years. The two biggest
    trends in modern JS are the rise of node.js and the broad implementation among
    browsers and through transpilers for EcmaScript 6 (Known as ES2015). What that
    means for you is that with Node servers you can write code that runs in the front
    end or on the server without any changes. This is known as *isomorphic* or *universal*
    Java-Script. We’re not going to do that in this book, but it provides incredible
    flexibility for JavaScript applications.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，JavaScript 经历了一些重大变化。现代 JavaScript 的两个最大趋势是 node.js 的兴起以及 EcmaScript
    6（也称为 ES2015）在浏览器和 transpilers 中的广泛应用。这意味着对于你来说，使用 Node 服务器，你可以编写在前端或服务器上运行而无需任何更改的代码。这被称为
    *同构* 或 *通用* JavaScript。我们在这本书中不会这样做，但它为 JavaScript 应用程序提供了极大的灵活性。
- en: For this book, the major Node technology that we want to be aware of is NPM,
    or Node Package Manager. NPM allows you to install “modules” or small libraries
    of JS code for use in your applications. You don’t have to include a bunch of
    `<script>` tag references to individual files and, if the module has been built
    so that it’s not one monolithic structure, you can reduce the amount of code you’re
    including in your applications.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这本书，我们想要了解的主要 Node 技术是 NPM，即 Node 包管理器。NPM 允许你安装“模块”或 JS 代码的小型库，用于你的应用程序。你不需要包含大量的
    `<script>` 标签引用到单个文件，如果模块被构建成不是单一的结构，你可以减少你包含在应用程序中的代码量。
- en: D3.js version 4, which came out in mid-2016, is structured to take advantage
    of module importing. Throughout this book, you’ll see examples of using D3 in
    one of two ways. Either we’ll include the entire D3 file, as we have with examples
    in this chapter, or we’ll include only the individual parts of D3 that we need,
    as you’ll see in later examples. For the examples in this book, we’ll mostly see
    this done with script tags, but remember that if you use NPM in your coding, you
    can `require` or `import` individual D3v4 modules into your code as you need them.
    There isn’t enough space in this book to get into this in detail but it’s considered
    more and more to be standard practice in JavaScript development, so you’ll need
    to be familiar with it.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: D3.js 版本 4，于 2016 年中发布，其结构旨在利用模块导入。在这本书的整个过程中，你会看到使用 D3 的两种方式之一。要么我们会包含整个 D3
    文件，就像我们在本章的例子中所做的那样，要么我们会包含我们需要的 D3 的单个部分，就像你将在后面的例子中看到的那样。对于这本书的例子，我们主要会看到使用
    script 标签来完成，但请记住，如果你在编码中使用 NPM，你可以根据需要将单个 D3v4 模块 `require` 或 `import` 到你的代码中。这本书中没有足够的空间来详细讨论这个问题，但它被认为是
    JavaScript 开发中的标准做法，所以你需要熟悉它。
- en: The `import` syntax is one new piece of ES2015’s advanced functionality. It
    also includes support for classes, promises, string templating, spread operators,
    symbols, and a host of new functionality that JS developers should know if they
    want to succeed. Because ES2015 isn’t yet fully supported, you’ll need to use
    a *transpiler* to transform ES2015 code into ES5 code. I’m not going to include
    much ES2015 in this book, so that if you’re not yet familiar with ES2015 that
    won’t stop you from learning D3, but one thing you’ll see are arrow functions,
    which are a more terse way of writing functions. Instead of
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`import` 语法是 ES2015 高级功能中的一个新特性。它还包括对类、承诺、字符串模板、扩展运算符、符号以及许多其他新功能的支持，如果 JavaScript
    开发者想要成功，他们应该了解这些功能。由于 ES2015 还未得到完全支持，你需要使用 *transpiler* 将 ES2015 代码转换为 ES5 代码。我不会在这本书中包含太多的
    ES2015 内容，这样如果你还不熟悉 ES2015，也不会阻碍你学习 D3，但你会看到箭头函数，这是一种更简洁的编写函数的方式。而不是'
- en: '[PRE27]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'an arrow function would be written as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 一个箭头函数可以这样编写：
- en: '[PRE28]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The parameter after the arrow is returned unless surrounded by brackets, and
    arrow functions in their cleaner form can be used anywhere, such as in an array
    `forEach`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头后面的参数除非被括号包围，否则会被返回，并且更简洁的箭头函数可以在任何地方使用，例如在数组的 `forEach` 中：
- en: '|'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE29]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '|'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE30]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '|'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: One thing to remember with arrow functions is that the context of the function
    (`this`) is whatever the context it’s created in. If that sounds arcane, don’t
    worry about it—the important thing to remember is that when you see examples in
    this book or online where `this` is being used in a D3 function, typically as
    a reference to the HTML node to which data is attached, that you won’t have access
    to the same `this` in an arrow function as you would with the older function declaration
    type.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在箭头函数中要记住的一件事是函数的上下文（`this`）是它在其中创建的上下文。如果这听起来很神秘，不要担心——重要的是要记住，当你在这本书或网上看到
    `this` 在 D3 函数中使用时，通常作为引用附加数据的 HTML 节点，你将无法在箭头函数中获得与旧函数声明类型相同的 `this`。
- en: 1.4\. Data standards
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4\. 数据标准
- en: 'One reason we have the freedom to make so many amazing kinds of data visualization
    is because we’ve settled on regular ways of representing different kinds of data.
    Data can be formatted in a variety of manners for a variety of purposes, but it
    tends to fall into a few recognizable classes: *tabular* data, *nested* data,
    *network* data, *geographic* data, *raw* data, and *objects*.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有如此多的数据可视化类型的自由，一个原因是我们已经确定了表示不同类型数据的常规方法。数据可以以各种方式格式化以适应各种目的，但它往往落入几个可识别的类别：*表格*数据、*嵌套*数据、*网络*数据、*地理*数据、*原始*数据和*对象*。
- en: 1.4.1\. Tabular data
  id: totrans-273
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.4.1\. 表格数据
- en: Tabular data appears in columns and rows typically found in a spreadsheet or
    a table in a database. Although you invariably end up creating arrays of objects
    in D3, it’s often more efficient and easier to pull in data in tabular format.
    Tabular data is delimited with a particular character, and that delimiter determines
    its format. You can have Comma-Separated Values (CSV), where the delimiter is
    a comma, or tab-delimited values, or a semicolon or a pipe symbol acting as the
    delimiter. For instance, you may have a spreadsheet of user information that includes
    age and salary. If you export it in a delimited form, it will look like [table
    1.1](#ch01table01). Here a dataset stores name, age, and salary of two people
    using commas, spaces, or the bar symbol to delimit the different fields.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 表格数据以列和行形式出现，通常在电子表格或数据库中的表格中找到。尽管你不可避免地会在 D3 中创建对象的数组，但通常以表格格式获取数据更高效且更容易。表格数据由特定的字符分隔，分隔符决定了其格式。你可以有逗号分隔值
    (CSV)，其中分隔符是逗号，或者制表符分隔值，或者分号或管道符号作为分隔符。例如，你可能有一个包含年龄和薪水的用户信息的电子表格。如果你以分隔形式导出它，它将看起来像[表
    1.1](#ch01table01)。在这里，一个数据集存储了两个人的姓名、年龄和薪水，使用逗号、空格或条形符号来分隔不同的字段。
- en: 'D3 provides three different functions to pull in tabular data: `d3.csv()`,
    `d3.tsv()`, and `d3.dsv()`. The only difference between them is that `d3.csv()`
    is built for comma-delimited files, `d3.tsv()` is built for tab-delimited files,
    and `d3.dsv()` allows you to declare the delimiter. You’ll see them in action
    throughout the book.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: D3 提供了三个不同的函数来获取表格数据：`d3.csv()`、`d3.tsv()` 和 `d3.dsv()`。它们之间的唯一区别是 `d3.csv()`
    是为逗号分隔的文件构建的，`d3.tsv()` 是为制表符分隔的文件构建的，而 `d3.dsv()` 允许你声明分隔符。你将在整本书中看到它们的应用。
- en: Table 1.1\. Delimited data can be expressed in different forms
  id: totrans-276
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 1.1\. 分隔数据可以表示为不同的形式
- en: '| Name,Age,Salary | Name Age Salary | Name&#124;Age&#124;Salary |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| 姓名,年龄,薪水 | 姓名 年龄 薪水 | 姓名|年龄|薪水 |'
- en: '| --- | --- | --- |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1.1.1 d3.csv | 1.1.2 d3.tsv | 1.1.3 d3.dsv |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| 1.1.1 d3.csv | 1.1.2 d3.tsv | 1.1.3 d3.dsv |'
- en: '| 1.1.4 Sal,34,50000 | 1.1.5 Sal 34 50000 | 1.1.6 Sal&#124;34&#124;50000 |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| 1.1.4 Sal,34,50000 | 1.1.5 Sal 34 50000 | 1.1.6 Sal|34|50000 |'
- en: '| 1.1.7 Nan,22,75000 | 1.1.8 Nan 22 75000 | 1.1.9 Nan&#124;22&#124;75000 |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| 1.1.7 Nan,22,75000 | 1.1.8 Nan 22 75000 | 1.1.9 Nan|22|75000 |'
- en: 1.4.2\. Nested data
  id: totrans-282
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.4.2\. 嵌套数据
- en: Data that’s nested, with objects existing as children of objects recursively,
    is common. Many of the most intuitive layouts in D3 are based on nested data,
    which can be represented as trees, such as the one in [figure 1.29](#ch01fig29),
    or packed in circles or boxes. Data isn’t often output in such a format, and requires
    a bit of scripting to organize it as such, but the flexibility of this representation
    is worth the effort. You’ll see hierarchical data in detail in [chapter 6](../Text/kindle_split_016.html#ch06).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套的数据，其中对象作为对象的递归子对象存在，很常见。D3 中许多最直观的布局都是基于嵌套数据，这些数据可以表示为树，例如[图 1.29](#ch01fig29)中的那个，或者打包在圆圈或盒子中。数据通常不以这种格式输出，需要一些脚本组织它，但这种表示的灵活性值得付出努力。你将在[第
    6 章](../Text/kindle_split_016.html#ch06)中详细了解层次数据。
- en: Figure 1.29\. Nested data represents parent/child relationships of objects,
    typically with each object having an array of child objects, and is represented
    in a number of forms, such as this dendrogram. Notice that each object can have
    only one parent.
  id: totrans-284
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.29\. 嵌套数据表示对象之间的父子关系，通常每个对象都有一个子对象数组，并以多种形式表示，例如这个树状图。请注意，每个对象只能有一个父对象。
- en: '![](../Images/01fig29.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![图片 1.29](../Images/01fig29.jpg)'
- en: 1.4.3\. Network data
  id: totrans-286
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.4.3\. 网络数据
- en: 'Networks are everywhere. Whether they’re the raw output of social networking
    streams, transportation networks, or a flowchart, networks are a powerful method
    of delivering an understanding of complex systems. Networks are often represented
    as node-link diagrams, as shown in [figure 1.30](#ch01fig30). Like geographic
    data, network data has many standards, but this text focuses only on two forms:
    node/edge lists and connected arrays. Network data can also be easily transformed
    into these data types by using a freely available network analysis tool like Gephi
    (available at [gephi.org](http://gephi.org)). We’ll examine network data and network
    data standards when we deal with network visualization in [chapter 7](../Text/kindle_split_017.html#ch07).'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 网络无处不在。无论是社交网络流的原始输出、交通网络还是流程图，网络都是理解复杂系统的一种强大方法。网络通常表示为节点-边图，如[图 1.30](#ch01fig30)所示。与地理数据一样，网络数据有许多标准，但本文只关注两种形式：节点/边列表和连接数组。网络数据也可以通过使用像
    Gephi 这样的免费网络分析工具（可在[gephi.org](http://gephi.org)获取）轻松转换为这些数据类型。当我们处理网络可视化时，我们将在[第
    7 章](../Text/kindle_split_017.html#ch07)中检查网络数据和网络数据标准。
- en: Figure 1.30\. Network data consists of objects and the connections between them.
    The objects are typically referred to as nodes or vertices, and the connections
    are referred to as edges or links. Networks are often represented using force-directed
    algorithms, such as the example here, that arrange the network in such a way as
    to pull connected nodes toward each other.
  id: totrans-288
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.30\. 网络数据由对象及其之间的连接组成。对象通常被称为节点或顶点，连接被称为边或链接。网络通常使用如这里所示的力导向算法来表示，这些算法将网络排列成使连接的节点相互吸引的方式。
- en: '![](../Images/01fig30.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![图片 1.30](../Images/01fig30.jpg)'
- en: 1.4.4\. Geographic data
  id: totrans-290
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.4.4\. 地理数据
- en: 'Geographic data refers to locations either as points or shapes, and is used
    to create the variety of online maps seen on the web today, such as the map of
    the United States in [figure 1.31](#ch01fig31). The incredible popularity of web
    mapping means that you can get access to a massive amount of publicly accessible
    geodata for any project. Geographic data has a few standards, but the focus in
    this book is on two: the GeoJSON and Topo-JSON standards. Although geodata may
    come in many forms, readily available geographic information systems (GIS) tools
    such as Quantum GIS allow developers to transform it into GIS format for ready
    delivery to the web. We’ll look at geographic data closely in [chapter 8](../Text/kindle_split_018.html#ch08).'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 地理数据指的是以点或形状表示的位置，用于创建今天在网络上看到的各种在线地图，例如[图 1.31](#ch01fig31)中的美国地图。网络地图的惊人普及意味着你可以获取到任何项目所需的大量公开可访问的地理数据。地理数据有几个标准，但本书的重点是两个：GeoJSON
    和 Topo-JSON 标准。尽管地理数据可能以多种形式存在，但像 Quantum GIS 这样的现成地理信息系统（GIS）工具允许开发者将其转换为 GIS
    格式，以便快速交付到网络上。我们将在[第 8 章](../Text/kindle_split_018.html#ch08)中详细探讨地理数据。
- en: Figure 1.31\. Geographic data stores the spatial geometry of objects, such as
    states. Each of the states in this image is represented as a separate feature
    with an array of values indicating its shape. Geographic data can also consist
    of points, such as for cities, or lines, such as for roads.
  id: totrans-292
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.31. 地理数据存储对象的空问几何形状，例如州。这张图像中的每个州都表示为一个具有表示其形状的值数组的单独特征。地理数据也可以由点组成，例如城市，或由线组成，例如道路。
- en: '![](../Images/01fig31_alt.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![图1.31的替代文本](../Images/01fig31_alt.jpg)'
- en: 1.4.5\. Raw data
  id: totrans-294
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.4.5. 原始数据
- en: As you’ll see in [chapter 2](../Text/kindle_split_011.html#ch02), everything
    is data, including images or blocks of text. Although information visualization
    typically uses shapes encoded by color and size to represent data, sometimes the
    best way to represent it in D3 is with linear narrative text, an image, or a video.
    If you develop applications for an audience that needs to understand complex systems,
    but you consider the manipulation of text or images to be somehow separate from
    the representation of numerical or categorical data as shapes, then you arbitrarily
    reduce your capability to communicate. The layouts and formatting used when dealing
    with text and images, typically tied to older modes of web publication, are possible
    in D3, and we’ll deal with that throughout this book.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在[第2章](../Text/kindle_split_011.html#ch02)中看到的，一切都是数据，包括图像或文本块。尽管信息可视化通常使用颜色和大小编码的形状来表示数据，但有时在D3中表示数据最好的方式是使用线性叙事文本、图像或视频。如果您为需要理解复杂系统的观众开发应用程序，但您认为对文本或图像的处理与以形状表示数值或分类数据是某种程度上的分离，那么您就任意地降低了您沟通的能力。处理文本和图像时使用的布局和格式，通常与较老的网页发布模式相关联，在D3中是可能的，我们将在整本书中处理这个问题。
- en: 1.4.6\. Objects
  id: totrans-296
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.4.6. 对象
- en: 'You’ll use two types of data points with D3: literals and objects. A literal,
    such as a string literal like `Apple` or `beer` or a number literal like `64273`
    or `5.44`, is straightforward. A JavaScript object, or the equivalent JSON (JavaScript
    Object Notation—a way of expressing data similar to JavaScript objects), isn’t
    so straightforward, but is something that you need to understand if you plan to
    do sophisticated data visualization.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用两种类型的数据点与D3一起使用：字面量和对象。字面量，如字符串字面量`Apple`或`beer`或数字字面量`64273`或`5.44`，很简单。JavaScript对象或等效的JSON（JavaScript对象表示法——一种类似于JavaScript对象的数据表示方法）并不那么简单，但这是如果您计划进行复杂的数据可视化，您需要理解的东西。
- en: 'Let’s say you have a dataset that consists of individuals from an insurance
    database, and you need to know how old someone is, whether they’re employed, their
    name, and their children, if any. A JavaScript object that represents each individual
    in such a database would be expressed as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有一个由保险数据库中的个人组成的数据集，您需要知道某人的年龄、他们是否就业、他们的名字，以及如果有，他们的孩子。表示这样一个数据库中每个个人的JavaScript对象可以表示如下：
- en: '[PRE31]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Each object is surround by braces `{}`, and has attributes that have a string,
    number, array, Boolean, or object as their value. You can assign an object to
    a variable and access its attributes by referring to them, like so:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对象都由大括号`{}`包围，并且具有具有字符串、数字、数组、布尔值或对象作为其值的属性。您可以将对象分配给变量，并通过引用它们来访问其属性，如下所示：
- en: '[PRE32]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Objects can be stored in arrays and associated with elements using `d3.select()`
    syntax. But objects can also be iterated through like arrays using a `for` loop:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 对象可以存储在数组中，并使用`d3.select()`语法与元素关联。但对象也可以像数组一样使用`for`循环进行迭代：
- en: '[PRE33]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `x` in the loop represents each attribute in the `person` object. Each `x`
    will be one of the attributes such as `name`, `age`, and so on This allows you
    to iterate through the attributes using `person[x]` to show the value of that
    attribute of the object.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 循环中的`x`代表`person`对象中的每个属性。每个`x`将是属性之一，如`name`、`age`等。这允许您使用`person[x]`迭代属性以显示该对象的该属性值。
- en: Another way to access keys would be to use `Object.keys(person)` and then iterate
    through that array.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 访问键的另一种方式是使用`Object.keys(person)`，然后迭代该数组。
- en: If your data is stored as JSON, then you can import it using `d3.json()`, which
    you’ll see many times in later chapters. But remember that whenever you use `d3.csv()`,
    D3 imports the data as an array of JSON objects. We’ll look at objects more extensively
    as we use them later.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的数据存储为JSON，则可以使用`d3.json()`导入它，您将在后面的章节中多次看到。但请记住，每次您使用`d3.csv()`时，D3都将数据作为JSON对象的数组导入。我们将在使用它们时更深入地研究对象。
- en: 1.5\. Infoviz standards expressed in D3
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.5. 在D3中表达的信息可视化标准
- en: Information visualization (infoviz) has never been so popular as it is today.
    The wealth of maps, charts, and complex representations of systems and datasets
    isn’t present only in the workplace, but also in our entertainment and our everyday
    lives. With this popularity comes a growing library of classes and subclasses
    of representation of data and information using visual means, as well as aesthetic
    rules to promote legibility and comprehension. Your audience, whether the general
    public, academics, or decision makers, has grown accustomed to what we once considered
    incredibly abstract and complicated representations of trends in data. This makes
    libraries such as D3 popular not only among data scientists, but also among journalists,
    artists, scholars, IT professionals, and even fan communities.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 信息可视化（infoviz）从未像今天这样受欢迎。地图、图表以及系统和数据集的复杂表示的丰富性不仅存在于工作场所，也存在于我们的娱乐和日常生活中。随着这种受欢迎程度的增长，使用视觉手段表示数据和信息的类和子类库也在不断增加，以及促进可读性和理解的审美规则。无论受众是普通公众、学者还是决策者，他们都已经习惯了我们曾经认为极其抽象和复杂的数据趋势表示。这使得像D3这样的库不仅受到数据科学家的欢迎，也受到记者、艺术家、学者、IT专业人士甚至粉丝社区的欢迎。
- en: But the wealth of options can seem overwhelming, and the relative ease of modifying
    a dataset to appear in a streamgraph, treemap, or histogram tends to promote the
    idea that information visualization is more about style than substance. Fortunately,
    well-established rules dictate what charts and methods to use for different types
    of data from different systems. Although I can’t cover every rule in the book,
    I’ll touch on ones that are useful to consider as we create more complicated information
    visualizations. Although developers use D3 to revolutionize the use of color and
    layout, most want to create visual representations of data that support practical
    concerns. Because D3 is being developed in this mature information visualization
    environment, it contains numerous helper functions to let developers worry about
    interface and design rather than color and axes.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 但选项的丰富性可能会让人感到不知所措，而且修改数据集以在流图、树状图或直方图中显示的相对容易性往往促使人们认为信息可视化更注重风格而非实质。幸运的是，一些已确立的规则指导着针对不同系统中的不同类型数据应使用哪些图表和方法。尽管我无法在书中涵盖每一条规则，但我将触及一些在我们创建更复杂的信息可视化时值得考虑的规则。尽管开发者使用D3来革新颜色和布局的使用，但大多数人希望创建支持实际关注点的数据视觉表示。因为D3是在这个成熟的信息可视化环境中开发的，它包含了许多辅助函数，让开发者可以更多地关注界面和设计，而不是颜色和坐标轴。
- en: 'Still, to properly deploy information visualization, you should know what to
    do and what not to do. The best way to learn this is to review the work of established
    designers and information visualization practitioners, and you need to have a
    firm understanding not only of your data but of your audience. Although an entire
    library of works deals with these issues, here are a few that I’ve found useful
    and can get you oriented on the basics:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，要正确部署信息可视化，你应该知道该做什么和不该做什么。学习这一点的最好方法是回顾那些知名设计师和信息可视化实践者的作品，并且你需要对你的数据以及你的受众有一个坚定的理解。尽管有整个图书馆的著作都涉及这些问题，但以下是我发现的有用的一些，它们可以帮助你了解基础：
- en: '*The Visual Display of Quantitative Information Envisioning Information*, Edward
    Tufte'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*定量信息的视觉展示：信息构想*，Edward Tufte'
- en: '*Designing for Information*, Isabel Meirelles'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*信息设计*，Isabel Meirelles'
- en: '*Pattern Recognition*, Christian Swinehart'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*模式识别*，Christian Swinehart'
- en: '*Visualization Analysis and Design*, Tamara Munzner'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可视化分析与设计*，Tamara Munzner'
- en: These are by no means the only texts for learning data visualization, but I’ve
    found them useful for getting started. You should pare down and establish fundamental,
    even basic, data visualization practices that clearly represent the trends that
    are salient to your audience. When in doubt, simplify—it’s often better to present
    a histogram than a streamgraph, or a hierarchical network layout (like a dendrogram)
    than a force-directed one. The more visually complex methods of displaying data
    tend to inspire more excitement, but can also lead an audience to see what they
    want to see or focus on the aesthetics of the graphics rather than the data.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这些绝对不是学习数据可视化的唯一文本，但我发现它们对入门很有用。你应该精简并建立基本甚至基本的数据可视化实践，这些实践可以清楚地代表对你受众来说重要的趋势。当不确定时，简化——通常展示直方图比展示流图好，或者展示层次网络布局（如树状图）比展示力导向布局好。展示数据的更复杂视觉方法往往能激发更多的兴奋，但也可能导致观众只看到他们想看到的内容，或者专注于图形的美学而不是数据。
- en: '|  |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Infoviz tip: kill your darlings**'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '**信息可视化技巧：杀死你的宠儿**'
- en: 'One of the best pieces of advice when it comes to working in information visualization
    comes from the practice of writing: “Kill your darlings.” The same way writers
    may become enamored of certain scenes or characters, you can become enamored of
    a particularly elegant or sophisticated-looking graphic. Your love of a cool chart
    or animation can distract you from the goal of communicating the structure and
    patterns in the data. Remember to save your harshest criticism for your most beloved
    pieces, because you may find, much to your chagrin, that they’re not as useful
    and informative as you think they are.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在信息可视化方面，最好的建议之一来自写作实践：“杀死你的宠儿。”就像作家可能会对某些场景或角色产生迷恋一样，你可能会对某个特别优雅或看起来复杂的图形产生迷恋。你对一个酷图表或动画的喜爱可能会让你分心，无法传达数据中的结构和模式。记住，对你的最爱作品要保留最严厉的批评，因为你可能会发现，令你失望的是，它们并不像你想象的那样有用和有信息量。
- en: '|  |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: One thing to keep in mind while reading about data visualization is that the
    literature is often focused on static charts. With D3 you’ll be making interactive
    and dynamic visualizations and not only static ones. You’ll make a dynamic (or
    animated) data visualization before you finish this chapter, and using D3 to make
    a chart interactive is incredibly simple. A few interactive touches can make a
    visualization not only more readable but significantly more engaging. Users who
    feel like they’re exploring rather than reading, even if only with a few mouseover
    events or a simple click to zoom, will find the content of the visualization more
    compelling than in a static page. But this added complexity requires an investment
    in learning principles of interface design and user experience. We’ll get into
    this in more detail in [chapter 9](../Text/kindle_split_020.html#ch09).
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读关于数据可视化的内容时，需要注意的一点是，文献通常专注于静态图表。使用D3，你将制作交互式和动态的可视化，而不仅仅是静态的。在你完成这一章之前，你将制作一个动态的（或动画的）数据可视化，使用D3制作一个交互式的图表非常简单。一些交互式的小技巧可以使可视化不仅更易读，而且更具吸引力。那些感觉自己在探索而不是阅读的用户，即使只是通过几个鼠标悬停事件或简单的点击缩放，也会觉得可视化的内容比静态页面更有吸引力。但是，这种额外的复杂性需要投入学习界面设计和用户体验的原则。我们将在第9章中更详细地探讨这一点。
- en: 1.6\. Your first D3 app
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.6\. 你的第一个D3应用程序
- en: Throughout this chapter, you’ve seen various lines of code and the effect of
    those lines of code on the growing d3ia.html sample page you’ve been building.
    But I’ve avoided explaining the code in too much detail so that you could concentrate
    on the principles at work in D3\. It’s simple to build an application from scratch
    that uses D3 to create and modify elements. Let’s put it all together and see
    how it works. First, let’s start with a clean HTML page that doesn’t have any
    defined styles or existing divs, as shown in the following listing.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经看到了各种代码行以及这些代码行对你一直在构建的d3ia.html示例页面产生的影响。但我避免过多地解释代码，以便你能专注于D3中起作用的原理。从头开始构建一个使用D3创建和修改元素的应用程序很简单。让我们把这些都放在一起，看看它是如何工作的。首先，让我们从一个干净的HTML页面开始，这个页面没有定义任何样式或现有的div，如下面的列表所示。
- en: Listing 1.6\. A simple webpage
  id: totrans-323
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表1.6\. 一个简单的网页
- en: '[PRE34]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 1.6.1\. Hello world with divs
  id: totrans-325
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.6.1\. 使用div的“Hello world”
- en: We can use D3 as an abstraction layer for adding traditional content to the
    page. Although we can write JavaScript inside our .html file or in its own .js
    file, let’s put code in the console and see how it works. Later, we’ll focus on
    the various commands in more detail for layouts and interfaces. We can get started
    with a piece of code that uses D3 to write to our web page, as in the next listing.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 D3 作为向页面添加传统内容的抽象层。虽然我们可以在 .html 文件内部或其自己的 .js 文件中编写 JavaScript，但让我们在控制台中放置代码并看看它的工作方式。稍后，我们将更详细地关注布局和界面的各种命令。我们可以从使用
    D3 将内容写入网页的代码片段开始，如下一个列表所示。
- en: Listing 1.7\. Using d3.select to set style and HTML content
  id: totrans-327
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 1.7\. 使用 d3.select 设置样式和 HTML 内容
- en: '[PRE35]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We can adjust the element on the page and give it interactivity with the inclusion
    of the `.on()` function, show in the next listing.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过包含 `.on()` 函数来调整页面上的元素并使其具有交互性，如下一个列表所示。
- en: Listing 1.8\. Using d3.select to set attributes and event listeners
  id: totrans-330
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 1.8\. 使用 d3.select 设置属性和事件监听器
- en: '[PRE36]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `.on()` function allows us to create an event listener for the currently
    selected element or set of elements. It accepts the variety of events that can
    happen to an element, such as click, mouseover, mouseout, and so on. If you click
    your div, you’ll notice that it gives a response in your console, as shown in
    [figure 1.32](#ch01fig32).
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`.on()` 函数允许我们为当前选定的元素或元素集创建事件监听器。它接受可以发生在元素上的各种事件，例如点击、鼠标悬停、鼠标移出等。如果你点击你的
    div，你会注意到它在你的控制台中给出响应，如[图 1.32](#ch01fig32)所示。'
- en: Figure 1.32\. Using `console.log()`, you can test to see if an event is properly
    firing. Here you create a `<div>` and assign an onclick event handler using the
    `.on()` syntax. When you click that element and fire the event, the action is
    noted in the console.
  id: totrans-333
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.32\. 使用 `console.log()`，你可以测试事件是否被正确触发。在这里，你创建一个 `<div>` 并使用 `.on()` 语法分配一个
    onclick 事件处理器。当你点击该元素并触发事件时，动作会在控制台中记录。
- en: '![](../Images/01fig32_alt.jpg)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.32 替代文本](../Images/01fig32_alt.jpg)'
- en: 1.6.2\. Hello World with circles
  id: totrans-335
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.6.2\. 使用圆圈实现的“Hello World”
- en: 'You didn’t pick up this book to learn how to add divs to a web page, but you
    likely want to deal with graphics like lines and circles. To append shapes to
    a page with D3, you need to have an SVG canvas element somewhere in your page’s
    DOM. You could either add this SVG canvas to the page as you write the HTML, or
    you could append it using the D3 syntax you’ve learned:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 你不是来这本书学习如何向网页添加 div 的，但你可能想处理像线条和圆圈这样的图形。要在 D3 的页面上添加形状，你需要在页面的 DOM 中某个位置有一个
    SVG 画布元素。你可以在编写 HTML 时添加这个 SVG 画布，或者使用你学到的 D3 语法将其附加：
- en: '[PRE37]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Let’s adjust our d3ia.html page to start with an SVG canvas, as shown in the
    following listing.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调整 d3ia.html 页面，从 SVG 画布开始，如下面的列表所示。
- en: Listing 1.9\. A simple web page with an SVG canvas
  id: totrans-339
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 1.9\. 带有 SVG 画布的简单网页
- en: '[PRE38]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: After we have an SVG canvas on our page, we can append various shapes to it
    using the same `select()` and `append()` syntax we’ve been using in [section 1.6.1](#ch01lev2sec17)
    for `<div>` elements, as shown in the following listing.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的页面上有了 SVG 画布之后，我们可以使用与在[第 1.6.1 节](#ch01lev2sec17)中为 `<div>` 元素使用的相同 `select()`
    和 `append()` 语法，向其添加各种形状，如下面的列表所示。
- en: Listing 1.10\. Creating lines and circles with select and append
  id: totrans-342
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 1.10\. 使用 select 和 append 创建线条和圆圈
- en: '[PRE39]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Notice that your circles are drawn over the line, and the text is drawn above
    or below the circle, depending on the order in which you run your commands, as
    you can see in [figure 1.33](#ch01fig33). This happened because the draw order
    of SVG is based on its DOM order. Later you’ll learn methods to adjust that order.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到你的圆圈是在线条上绘制的，文本是根据你运行命令的顺序在圆圈上方或下方绘制的，如[图 1.33](#ch01fig33)所示。这是因为 SVG 的绘制顺序基于其
    DOM 顺序。稍后你将学习调整该顺序的方法。
- en: Figure 1.33\. The result of running [listing 1.10](#ch01ex10) in the console
    is the creation of two circles, a line, and two text elements. The order in which
    these elements are drawn results in the first label covered by the circle drawn
    later.
  id: totrans-345
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.33\. 在控制台中运行[列表 1.10](#ch01ex10)的结果是创建了两个圆圈、一条线和两个文本元素。这些元素绘制的顺序导致后来绘制的圆圈覆盖了第一个标签。
- en: '![](../Images/01fig33.jpg)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.33 替代文本](../Images/01fig33.jpg)'
- en: 1.6.3\. A conversation with D3
  id: totrans-347
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.6.3\. 与 D3 的对话
- en: Writing Hello World with languages is such a common example that I thought we
    should give the world a chance to respond. Let’s add the same big circle and little
    circle from before, but this time, when we add text, we’ll include the `.style
    (opacity)` setting that makes our text invisible, as shown in the following listing.
    We’ll also give each text element a `.attr(id)` setting so that the text near
    the small circle has an `id` attribute with the value of `a`, and the text near
    the large circle has an `id` attribute with the value of `b`.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 使用各种语言编写Hello World是一个如此常见的例子，以至于我认为我们应该给世界一个回应的机会。让我们添加之前相同的大的圆圈和小的圆圈，但这次，当我们添加文本时，我们将包括`.style(opacity)`设置，使我们的文本不可见，如下面的列表所示。我们还将为每个文本元素设置`.attr(id)`，以便靠近小圆圈的文本有一个值为`a`的`id`属性，靠近大圆圈的文本有一个值为`b`的`id`属性。
- en: Listing 1.11\. SVG elements with IDs and transparency
  id: totrans-349
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表1.11\. 带有ID和透明度的SVG元素
- en: '[PRE40]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Two circles, no line, and no text. Now you make the text appear using the `.transition()`
    method with the `.delay()` method, and you should have an end state like the one
    shown in [figure 1.34](#ch01fig34).
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 两个圆圈，没有线条，没有文本。现在你使用带有`.delay()`方法的`.transition()`方法使文本出现，你应该有一个类似于[图1.34](#ch01fig34)中所示的状态。
- en: Figure 1.34\. Transition behavior when associated with a delay results in a
    pause before the application of the attribute or style.
  id: totrans-352
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.34\. 当与延迟相关联时，过渡行为导致在应用属性或样式之前暂停。
- en: '![](../Images/01fig34.jpg)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/01fig34.jpg)'
- en: '[PRE41]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Congratulations! You’ve made your first dynamic data visualization. The `.transition()`
    method indicates that you don’t want your change to be instantaneous. By chaining
    it with the `.delay()` method, you indicate how many milliseconds to wait before
    implementing the style or attribute changes that appear in the chain after that
    `.delay()` setting.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经制作了你的第一个动态数据可视化。`.transition()`方法表明你不想你的变化是瞬间的。通过将其与`.delay()`方法链接，你表明在实施`.delay()`设置之后链中出现的样式或属性更改之前要等待多少毫秒。
- en: 'We’ll get a bit more ambitious later, but before we finish here, let’s look
    at another `.transition()` setting. You can set a `.delay()` before applying the
    new style or attribute, but you can also set a `.duration()` over which the change
    is applied. The results in your browser should move the shapes in the direction
    of the arrows in [figure 1.35](#ch01fig35):'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后变得更加雄心勃勃，但在我们完成之前，让我们看看另一个`.transition()`设置。你可以在应用新样式或属性之前设置`.delay()`，但你也可以设置一个`.duration()`，在它上面应用更改。在你的浏览器中，结果应该是将形状移动到[图1.35](#ch01fig35)中箭头所示的方向。
- en: Figure 1.35\. Transition behavior when associated with position makes the shape
    graphically move to its new position over the course of the assigned duration.
    Because you used the same y position for both circles, the first circle moves
    down and the second circle moves up to the y position you set, which is between
    the two circles.
  id: totrans-357
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.35\. 当与位置相关联时，过渡行为使形状在分配的持续时间内图形化地移动到新位置。由于你为两个圆圈使用了相同的y位置，第一个圆圈向下移动，第二个圆圈向上移动到设置的y位置，即两个圆圈之间。
- en: '![](../Images/01fig35.jpg)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/01fig35.jpg)'
- en: '[PRE42]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `.duration()` method, as you can see, adjusts the setting over the course
    of the amount of time (again, in milliseconds) that you set it for.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`.duration()`方法调整设置，持续时间为你设置的时长（再次强调，以毫秒为单位）。
- en: That covers the basics of how D3 works and how it’s designed, and these fundamental
    concepts will surface again and again throughout the following chapters, where
    you’ll learn more complicated variations on representing and manipulating data.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了D3的工作原理及其设计基础，这些基本概念将在接下来的章节中反复出现，你将学习到更多关于表示和操作数据的复杂变体。
- en: 1.7\. Summary
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.7\. 概述
- en: D3 allows you to create almost any kind of data visualization product you’ve
    seen in an application or newspaper or online.
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: D3允许你创建几乎任何你在应用程序、报纸或在线看到的数据可视化产品。
- en: D3 isn’t only for creating the final graphical product; it’s also got functions
    that allow you to process the data. To get to the more complex data visualization
    types, like those you see in [chapter 6](../Text/kindle_split_016.html#ch06) and
    later, you’ll have to follow several steps in a process to get to data suitable
    for graphical display.
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: D3不仅用于创建最终的图形产品；它还提供了允许你处理数据的函数。要达到更复杂的数据可视化类型，如你在[第6章](../Text/kindle_split_016.html#ch06)和之后的章节中看到的那样，你必须遵循一系列步骤来获取适合图形显示的数据。
- en: Understanding the DOM, SVG, and CSS is necessary for creating complex data visualization
    products.
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 DOM、SVG 和 CSS 对于创建复杂的数据可视化产品是必要的。
- en: D3 data binding allows you to create and remove elements on your web page based
    on data. It also allows you to change the characteristics of those elements—graphical
    or text content—based on your data.
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: D3 数据绑定允许你根据数据在你的网页上创建和删除元素。它还允许你根据数据更改这些元素的特征——图形或文本内容。
- en: Different data types necessitate different approaches to manipulate and visualize
    them. The main types of data you’ll work with are numerical, hierarchical, topological
    (network), and textual.
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的数据类型需要不同的方法来操作和可视化它们。你将主要处理的数据类型包括数值、层次结构、拓扑（网络）和文本。
- en: D3’s built in transitions allow for simple, effective animation right out of
    the box.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: D3 内置的过渡功能允许直接进行简单有效的动画。
- en: Why learn D3?
  id: totrans-369
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么学习 D3？
- en: '*— by Jeffrey Heer, associate professor, Paul G. Allen School of Computer Science
    & Engineering, University of Washington, former Stanford University PhD advisor
    of D3 creator Mike Bostock*'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '*— 由华盛顿大学保罗·G·艾伦计算机科学与工程学院副教授杰弗里·希尔撰写，曾是 D3 创作者迈克·博斯托克的斯坦福大学博士导师*'
- en: 'With a wealth of existing charting libraries and business intelligence tools
    out there, you might wonder: why learn D3? When you’re first building simple charts
    and graphs, D3 may feel low-level and verbose, perhaps with some unfamiliar programming
    constructs to boot! The critical thing to keep in mind is that *D3 is not a charting
    library* (though it can be used as such). D3 is a framework for building an expressive
    range of *customized* and *interactive* web-based graphics. D3 provides fundamental
    building blocks for creating just about any visualization you can imagine. Rather
    than try to shoehorn your data into a more limited set of application-sanctioned
    options, by learning D3 you will be able to create interactive web pages tailored
    to the specifics of your data and use cases.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在现有的图表库和商业智能工具如此丰富的情况下，你可能会想：为什么学习 D3？当你最初构建简单的图表和图形时，D3 可能会感觉比较底层和冗长，也许还伴随着一些不熟悉的编程结构！需要牢记的关键点是
    *D3 不是一个图表库*（尽管它可以这样使用）。D3 是一个用于构建各种 *定制* 和 *交互式* 网页图形的框架。D3 为创建几乎任何你可以想象的可视化提供了基本构建块。通过学习
    D3，你将能够创建针对你的数据和用例定制的交互式网页，而不是试图将你的数据强行塞入更有限的应用程序授权选项中。
- en: There are also additional benefits to learning D3\. D3 leverages web standards
    such as the browser Document Object Model (DOM), Scalable Vector Graphics (SVG),
    and Cascading Style Sheets (CSS). These technologies form part of D3’s learning
    curve but are also invaluable above and beyond D3 itself. Learning D3 thus reaps
    extra dividends on your time investment, helping you to become a more fluent and
    seasoned web developer. D3 is also steeped in visualization design concepts and
    best practices, including facilities for visual encoding, spatial layout, animation,
    and color design. Rather than limit your consideration to a fixed palette of bar
    charts, line charts, and scatter plots, the process of learning D3 can help kickstart
    your journey into the larger world of visualization, introducing you to terms,
    techniques, and examples that will help you think both more deeply and more creatively
    about the craft of information visualization.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 学习 D3 还有其他好处。D3 利用 Web 标准，如浏览器文档对象模型 (DOM)、可缩放矢量图形 (SVG) 和层叠样式表 (CSS)。这些技术构成了
    D3 学习曲线的一部分，但本身也非常宝贵。因此，学习 D3 可以带来额外的回报，帮助你成为更熟练和经验丰富的网络开发者。D3 还深入可视化设计概念和最佳实践，包括视觉编码、空间布局、动画和色彩设计。学习
    D3 的过程可以帮助你开启进入更大可视化世界的旅程，向你介绍术语、技术和示例，帮助你更深入和更有创意地思考信息可视化的技艺。
- en: You should always strive to pick the right tool for the job. In some cases,
    that may be a business intelligence tool or plotting library (many of which are
    built on top of D3 itself). Ideally you pick one that supports rapid generation
    and exploration of visualizations to aid exploration and understanding. But in
    other cases you need customized design, at which point the limitations of other
    tools rapidly becomes apparent. Consider whether novel visual designs or interaction
    techniques might enable more effective communication and engagement with your
    data. Do you seek to build improved tools to help people explore data in new ways?
    Are you tasked with creating a unique look and feel for your organization? Would
    you like to engage with a large and supportive community of visualization designers
    and innovators? If so, learn D3!
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该始终努力选择适合工作的正确工具。在某些情况下，那可能是一个商业智能工具或绘图库（其中许多都是基于 D3 本身构建的）。理想情况下，你选择一个支持快速生成和探索可视化以帮助探索和理解的工具。但在其他情况下，你需要定制设计，这时其他工具的限制迅速变得明显。考虑新颖的视觉设计或交互技术是否可能使与数据的沟通和参与更加有效。你是否寻求构建改进的工具以帮助人们以新的方式探索数据？你是否被要求为你的组织创建独特的视觉风格？你是否希望与一个庞大且支持性的可视化设计师和创新者社区互动？如果是这样，学习
    D3 吧！
- en: Chapter 2\. Information visualization data flow
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二章\. 信息可视化数据流
- en: '*This chapter covers*'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Loading data from external files of various formats
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从各种格式的外部文件加载数据
- en: Working with D3 scales
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 D3 尺度一起工作
- en: Formatting data for analysis and display
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为分析和显示格式化数据
- en: Creating graphics with visual attributes based on data attributes
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据数据属性创建具有视觉属性的图形
- en: Animating and changing the appearance of graphics
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画和改变图形的外观
- en: 'Toy examples and online demos sometimes present data in the format of a Java-Script-defined
    array, the same way we did in [chapter 1](../Text/kindle_split_010.html#ch01).
    But in the real world, your data is going to come from an API or an external file,
    and you’re going to need to load it, format it, and transform it before you start
    creating web elements based on that data. This chapter describes this process
    of getting data into a suitable form and touches on the basic structures that
    you’ll use again and again in D3: loading data from an external source, formatting
    that data, and creating graphical representations of that data, like you see in
    [figure 2.1](#ch02fig01).'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 玩具示例和在线演示有时以 Java-Script 定义的数组格式呈现数据，就像我们在第一章中做的那样[章节 1](../Text/kindle_split_010.html#ch01)。但在现实世界中，你的数据将来自
    API 或外部文件，在你开始基于这些数据创建网络元素之前，你需要加载、格式化和转换它。本章描述了将数据转换为合适形式的过程，并触及了你在 D3 中会反复使用的基本结构：从外部源加载数据，格式化这些数据，以及创建数据的图形表示，就像你在[图
    2.1](#ch02fig01)中看到的那样。
- en: Figure 2.1\. Examples from this chapter, including a diagram of how data-binding
    works (left) from [section 2.3.3](#ch02lev2sec10), a scatterplot with labels (center)
    from [section 2.3](#ch02lev1sec3), and the bar chart (right) we’ll build in [section
    2.2](#ch02lev1sec2).
  id: totrans-382
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.1\. 本章的示例，包括从[第 2.3.3 节](#ch02lev2sec10)的数据绑定工作原理图（左），从[第 2.3 节](#ch02lev1sec3)的带有标签的散点图（中），以及我们在[第
    2.2 节](#ch02lev1sec2)中将要构建的条形图（右）。
- en: '![](../Images/02fig01.jpg)'
  id: totrans-383
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/02fig01.jpg)'
- en: 2.1\. Working with data
  id: totrans-384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1\. 与数据工作
- en: We’ll deal with two small datasets in this chapter and take them through a simplified
    five-step process ([figure 2.2](#ch02fig02)) that will touch on everything you
    need to do with and to data to turn it into a data visualization product with
    D3\. One dataset consists of a few cities and their geographic location and population.
    The other has a few fictional tweets with information about who made them and
    who reacted to them. This is the kind of data you’re often presented with. You’re
    tasked with finding out which tweets have more of an impact than others or which
    cities are more susceptible to natural disasters than others. In this chapter
    you’ll learn how to measure data in D3 in a number of ways and how to use those
    methods to create charts.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将处理两个小型数据集，并将它们通过一个简化的五步过程([图 2.2](#ch02fig02))进行简化，这个过程将涉及你需要对数据进行的一切操作，以将其转换为
    D3 的数据可视化产品。一个数据集包括几个城市及其地理位置和人口。另一个包含一些虚构的推文，其中包含有关谁创建了它们以及谁对它们做出反应的信息。这类数据你经常遇到。你的任务是找出哪些推文比其他推文更有影响力，或者哪些城市比其他城市更容易遭受自然灾害。在本章中，你将学习如何在
    D3 中以多种方式衡量数据，以及如何使用这些方法创建图表。
- en: Figure 2.2\. The data visualization process that we’ll explore in this chapter
    assumes we begin with a set of data and want to create (and update) an interactive
    or dynamic data visualization.
  id: totrans-386
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.2。本章我们将探索的数据可视化过程假设我们从一个数据集开始，并希望创建（并更新）一个交互式或动态的数据可视化。
- en: '![](../Images/02fig02.jpg)'
  id: totrans-387
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/02fig02.jpg)'
- en: Out in the real world, you’ll deal with much larger datasets, with hundreds
    of cities and thousands of tweets, but you’ll use the same principles outlined
    in this chapter. This chapter doesn’t teach you how to create complex data visualizations,
    but it does explain in detail several of the most important core processes in
    D3 that you’ll need.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，你将处理更大的数据集，有成百上千个城市和数千条推文，但你将使用本章中概述的相同原则。本章不会教你如何创建复杂的数据可视化，但它会详细解释D3中最重要的一些核心过程，这些过程你将需要。
- en: 2.1.1\. Loading data
  id: totrans-389
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.1. 加载数据
- en: As we touched on in [chapter 1](../Text/kindle_split_010.html#ch01), our data
    will typically be formatted in various but standardized ways. Regardless of the
    source of the data, it will likely be formatted as single-document data files
    in XML, CSV, or JSON format. D3 provides several functions for importing and working
    with this data (the first step shown in [figure 2.3](#ch02fig03)). One core difference
    between these formats is how they model data. JSON and XML provide the capacity
    to encode nested relationships in a way that delimited formats like CSV don’t.
    Another difference is that `d3.csv()` and `d3.json()`produce an array of JSON
    objects, whereas `d3.xml()`creates an XML document that needs to be accessed in
    a different manner.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第1章](../Text/kindle_split_010.html#ch01)中提到的，我们的数据通常以各种但标准化的方式格式化。无论数据的来源如何，它很可能会以XML、CSV或JSON格式的单文档数据文件格式化。D3提供了几个用于导入和处理此类数据的函数（如图2.3中所示的第一步）。这些格式之间一个核心的区别是它们如何建模数据。JSON和XML提供了以分隔格式（如CSV）无法实现的方式编码嵌套关系的能力。另一个区别是`d3.csv()`和`d3.json()`生成一个JSON对象数组，而`d3.xml()`创建一个需要以不同方式访问的XML文档。
- en: Figure 2.3\. The first step in creating a data visualization is getting the
    data. You can do that by loading the file asynchronously using one of several
    D3 XHR functions, or you can import or include the data. If the data is fixed,
    then either way is suitable, but if you plan to replace your data source with
    a dynamic API call, then the XHR requests are the best approach.
  id: totrans-391
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.3。创建数据可视化的第一步是获取数据。你可以通过使用D3的几个XHR函数之一异步加载文件来实现，或者你可以导入或包含数据。如果数据是固定的，那么两种方式都适用，但如果计划用动态API调用替换数据源，那么XHR请求是最佳方法。
- en: '![](../Images/02fig03_alt.jpg)'
  id: totrans-392
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/02fig03_alt.jpg)'
- en: File formats
  id: totrans-393
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 文件格式
- en: 'D3 has five functions typically used for loading data that correspond to the
    five types of files you’ll likely encounter: `d3.text()`, `d3.xml()`, `d3.json()`,
    `d3.csv()`, and `d3.html()`. These abstract the same XHR requests that a library
    like fetch does. We’ll spend most of our time working with `d3.csv()` and `d3.json()`.
    You’ll see `d3.html()` in the next chapter, where we’ll use it to create complex
    DOM elements that are written as templates. You may find `d3.xml()` and `d3.text()`
    more useful depending on how you typically deal with data. You may be comfortable
    with XML rather than JSON, in which case you can rely on `d3.xml()` and format
    your data functions accordingly. If you prefer working with text strings, you
    can use `d3.text()` to pull in the data and process it using another library or
    code.'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: D3有五个通常用于加载数据的函数，对应于你可能会遇到的五种文件类型：`d3.text()`、`d3.xml()`、`d3.json()`、`d3.csv()`和`d3.html()`。这些抽象了类似于fetch库的相同XHR请求。我们将大部分时间用于处理`d3.csv()`和`d3.json()`。你将在下一章中看到`d3.html()`，我们将使用它来创建作为模板编写的复杂DOM元素。你可能发现`d3.xml()`和`d3.text()`更有用，这取决于你通常如何处理数据。你可能更习惯于XML而不是JSON，在这种情况下，你可以依赖`d3.xml()`并相应地格式化你的数据函数。如果你更喜欢处理文本字符串，你可以使用`d3.text()`来拉取数据并使用另一个库或代码进行处理。
- en: 'Both `d3.csv()` and `d3.json()` use the same format when calling the function,
    by declaring the path to the file being loaded and defining the callback function:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '`d3.csv()`和`d3.json()`在调用函数时使用相同的格式，通过声明正在加载的文件的路径并定义回调函数：'
- en: '[PRE43]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The error variable is optional, and if we only declare a single variable with
    the callback function, it will be the data:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 错误变量是可选的，如果我们只声明一个带有回调函数的单个变量，它将是数据：
- en: '[PRE44]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '|  |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Should I be using XHR?**'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '**我应该使用XHR吗？**'
- en: One of the major patterns you see in D3 examples is the use of d3.csv or d3.json
    to bring data into your application. But asynchronous loading of data isn’t necessary
    if your data is never going to change during the course of the application being
    used. Instead of relying on d3.json or d3.csv, you could as easily format your
    data as Java-Script data and include it using a `<script>` tag or import/require
    the data if you’re working with Node or ES2015.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 你在 D3 示例中看到的主要模式之一是使用 d3.csv 或 d3.json 将数据引入你的应用程序。但如果你的数据在整个应用程序使用过程中永远不会改变，则不需要异步加载数据。除了依赖
    d3.json 或 d3.csv，你同样可以轻松地将数据格式化为 Java-Script 数据，并使用 `<script>` 标签包含它，或者在 Node
    或 ES2015 中使用 import/require 导入数据。
- en: It’s not either/or; you might have some data that never changes (such as the
    geodata you’re using to draw a basemap) and some that does change (the polling
    data you’re using to change the color of your map). In that case, you can include
    the static data and use XHR for the dynamic content.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是非此即彼；你可能有一些数据永远不会改变（例如你用来绘制基本地图的地理数据），而有些数据会改变（你用来改变地图颜色的投票数据）。在这种情况下，你可以包含静态数据，并使用
    XHR 来处理动态内容。
- en: '|  |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'You first get access to the data in the callback function, and you may want
    to declare the data as a global variable so that you can use it elsewhere. Global
    variables are bad practice out in the real world, but we’ll use them in examples
    because it makes it easier to follow along. To get started, you need a data file.
    For this chapter we’ll be working with two data files: a CSV file that contains
    data about cities and a JSON file that contains data about tweets, as shown in
    the following listings.'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先在回调函数中获取对数据的访问权限，你可能想将数据声明为全局变量，这样你就可以在其他地方使用它。在现实世界中，全局变量是坏习惯，但我们在示例中会使用它们，因为这使跟踪更容易。要开始，你需要一个数据文件。对于本章，我们将使用两个数据文件：一个包含城市数据的
    CSV 文件和一个包含推文数据的 JSON 文件，如下所示。
- en: Listing 2.1\. File contents of cities.csv
  id: totrans-405
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.1\. cities.csv 文件的内容
- en: '[PRE45]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Listing 2.2\. File contents of tweets.json
  id: totrans-407
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.2\. tweets.json 文件的内容
- en: '[PRE46]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'With these two files, we can access the data by using the appropriate function
    to load them:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这两个文件，我们可以通过使用适当的函数来加载它们来访问数据：
- en: '[PRE47]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '***1* Prints “Object {tweets: Array[10]}” in the console**'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在控制台打印“Object {tweets: Array[10]}”**'
- en: In both cases, the data file is loaded as an array of JSON objects. For tweets.json,
    this array is found at `data.tweets`, whereas for cities.csv, this array is `data`.
    The function `d3.json()` allows you to load a JSON-formatted file, which can have
    objects and attributes in a way that a loaded CSV can’t. When you load a CSV,
    it returns an array of objects. When you load a JSON file, it will return an object
    with one or more key/value pairs (known as *entries*). In this case, the object
    that’s initialized as `data` has a key of `tweets` that corresponds to an array
    of data. That’s why we need to refer to `data.tweets` after we’ve loaded tweets.json,
    but refer directly to `data` when we load cities.csv.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，数据文件都是以 JSON 对象数组的形式加载的。对于 tweets.json，这个数组位于 `data.tweets`，而对于 cities.csv，这个数组是
    `data`。函数 `d3.json()` 允许你加载一个 JSON 格式的文件，它可以以 CSV 加载时无法实现的方式包含对象和属性。当你加载 CSV 时，它返回一个对象数组。当你加载
    JSON 文件时，它将返回一个包含一个或多个键/值对（称为 *条目*）的对象。在这种情况下，初始化为 `data` 的对象有一个 `tweets` 键，对应一个数据数组。这就是为什么我们在加载
    tweets.json 后需要引用 `data.tweets`，而在加载 cities.csv 时直接引用 `data`。
- en: 'Both d3.csv and d3.json are asynchronous, and will return after the request
    to open the file and not after processing the file. Loading a file, which is typically
    an operation that takes more time than most other functions, won’t be complete
    by the time other functions are called. If you call functions that require the
    loaded data before it’s loaded, then they’ll fail. You can get around this asynchronous
    behavior in two ways. You can nest the functions operating on the data in the
    data-loading function:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: d3.csv 和 d3.json 都是异步的，它们会在打开文件的请求之后返回，而不是在处理文件之后返回。加载文件，这通常是一个比大多数其他函数耗时更长的操作，不会在其他函数被调用之前完成。如果你在数据加载之前调用需要加载数据的函数，那么它们将失败。你可以通过两种方式绕过这种异步行为。你可以在数据加载函数中嵌套操作数据的函数：
- en: '[PRE48]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Or you can use promises (which we’ll use in [chapter 7](../Text/kindle_split_017.html#ch07))
    to trigger events upon completion of the loading of one or more files. You’ll
    see queue.js in action in later chapters. Note that `d3.csv()` has a method `.parse()`
    that you can use on a block of text rather than an external file. If you need
    more direct control over getting data, you should review the documentation for
    `d3-request`, which allows for more fine-grained control of sending and receiving
    data.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用承诺（我们将在[第7章](../Text/kindle_split_017.html#ch07)中使用）在加载一个或多个文件完成后触发事件。您将在后面的章节中看到queue.js的实际应用。请注意，`d3.csv()`有一个`.parse()`方法，您可以使用它来处理一段文本而不是外部文件。如果您需要更直接地控制获取数据，您应该查阅`d3-request`的文档，它允许对发送和接收数据进行更精细的控制。
- en: 2.1.2\. Formatting data
  id: totrans-416
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.2\. 格式化数据
- en: After you load the datasets, you’ll need to define methods so that the attributes
    of the data directly relate to settings for color, size, and position graphical
    elements. If you want to display the cities in the CSV, you probably want to use
    circles, size those circles based on population, and then place them according
    to their geographic coordinates. We have long-established conventions for representing
    cities on maps graphically, but the same can’t be said about tweets. What graphical
    symbol to use to represent a single tweet, how to size it, and where to place
    it are all open questions. To answer these questions, you need to understand the
    forms of data you’ll encounter when doing data visualization. Programming languages
    and ontologies define numerous datatypes, but it’s useful to think of them as
    quantitative, categorical, geometric, temporal, topological, or raw.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在您加载数据集后，您需要定义方法，以便数据的属性直接与颜色、大小和位置图形元素的设置相关。如果您想在CSV中显示城市，您可能想使用圆圈，根据人口大小圆圈，然后根据它们的地理坐标放置它们。我们在地图上图形表示城市有长期确立的惯例，但对于推文来说则不然。如何使用图形符号来表示单个推文，如何调整大小，以及放置在哪里，都是开放性问题。为了回答这些问题，您需要了解在数据可视化过程中会遇到的数据形式。编程语言和本体定义了多种数据类型，但将它们视为定量、分类、几何、时间、拓扑或原始数据类型是有用的。
- en: You’ll typically need to format quantitative data (the second step in creating
    data visualization shown in [figure 2.4](#ch02fig04)) by defining scales using
    `d3.scale`* functions (such as `d3.scaleLinear` and `d3.scaleTime`), as explained
    in [section 2.1.3](#ch02lev2sec3), or by transforming your quantitative data into
    categorical data using techniques like quantiles, which group numeric values.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 您通常需要通过使用`d3.scale`*函数（如`d3.scaleLinear`和`d3.scaleTime`）定义比例，或者通过使用如分位数等技术将定量数据转换为分类数据来格式化定量数据（如图2.4中所示的数据可视化创建的第二步），这些在[第2.1.3节](#ch02lev2sec3)中已有解释。如果您需要更直接地控制获取数据，您应该查阅`d3-request`的文档，它允许对发送和接收数据进行更精细的控制。
- en: Figure 2.4\. After loading data, you need to make sure it’s formatted in such
    a way that it can be used to create graphics. This includes mapping the data to
    positions on the screen, colors that indicate quantity, or bins to nest the data
    visually.
  id: totrans-419
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.4。在加载数据后，您需要确保数据格式正确，以便可以用于创建图形。这包括将数据映射到屏幕上的位置、表示数量的颜色，或用于视觉上嵌套数据的箱。
- en: '![](../Images/02fig04.jpg)'
  id: totrans-420
  prefs: []
  type: TYPE_IMG
  zh: '![图2.4](../Images/02fig04.jpg)'
- en: Quantitative
  id: totrans-421
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定量数据
- en: Numerical or quantitative data is the most common type in data visualization.
    Quantitative data can be effectively represented with size, position, or color.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 数值或定量数据是数据可视化中最常见的类型。定量数据可以用大小、位置或颜色有效地表示。
- en: 'For one of our datasets, we have readily accessible quantitative data: the
    population figures in the cities.csv table. For the tweets dataset, though, it
    seems like we don’t have any quantitative data available, which is why we’ll spend
    time in [section 2.1.3](#ch02lev2sec3) looking at how to transform data.'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的数据集之一，我们有易于访问的定量数据：城市.csv表中的人口数据。然而，对于推文数据集，似乎我们没有可用的定量数据，这就是为什么我们将在[第2.1.3节](#ch02lev2sec3)中花费时间来查看如何转换数据。
- en: Categorical
  id: totrans-424
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 分类数据
- en: Categorical data falls into discrete groups, typically represented by text,
    such as nationality or gender. Categorical data is often represented using shape
    or color. You map the categories to distinct colors or shapes to identify the
    pattern of the groups of elements positioned according to other attributes.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 分类数据分为离散的组，通常用文本表示，例如国籍或性别。分类数据通常用形状或颜色来表示。您可以将类别映射到不同的颜色或形状，以识别根据其他属性定位的元素组的模式。
- en: The tweets data has categorical data in the form of the user data, which you
    can recognize by intuitively thinking of coloring the tweets by the user who made
    them. Later, we’ll discuss methods to derive categorical data.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 推文数据具有以用户数据形式存在的分类数据，你可以通过直观地考虑按创建推文的用户对推文进行着色来识别它。稍后，我们将讨论推导分类数据的方法。
- en: Topological
  id: totrans-427
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 拓扑
- en: Topological data describes the relationship of one piece of data with another,
    which can also be another form of location data. The genealogical connection between
    two people or the distance of a shop from a train station each represents a way
    of defining relationships between objects. Topological attributes can be represented
    with text referring to unique ID values or with pointers to the other objects.
    Later in this chapter we’ll create topological data in the form of nested hierarchies.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 拓扑数据描述了数据之间的一种关系，这也可以是另一种形式的位置数据。两个人之间的家谱关系或商店与火车站的距离都代表了一种定义对象之间关系的方式。拓扑属性可以用引用唯一ID值的文本表示，也可以用指向其他对象的指针表示。在本章的后面部分，我们将以嵌套层次结构的形式创建拓扑数据。
- en: For the cities data, it seems like we don’t have topological data. However,
    we could easily produce it by designating one city, such as San Francisco, to
    be our frame of reference. We could then create a distance-to-San-Francisco measure
    that would give us topological data if we needed it. The tweets data has its topological
    component in the `favorites` and `retweets` arrays, which provide the basis for
    a social network.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 对于城市数据，看起来我们没有拓扑数据。然而，我们可以通过指定一个城市，例如旧金山，作为我们的参考框架来轻松地生成它。然后我们可以创建一个到旧金山的距离度量，如果需要的话，这将提供拓扑数据。推文数据中的拓扑组件在`favorites`和`retweets`数组中，这为社交网络提供了基础。
- en: Geometric
  id: totrans-430
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 几何
- en: Geometric data is most commonly associated with the boundaries and tracks of
    geographic data, such as countries, rivers, cities, and roads. Geometric data
    might also be the SVG code to draw a particular icon that you want to use, the
    text for a class of shape, or a numerical value indicating the size of the shape.
    Geometric data is, not surprisingly, most often represented using shape and size,
    but can also be transformed like other data, for example, into quantitative data
    by measuring area and perimeter.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 几何数据通常与地理数据的边界和轨迹相关联，例如国家、河流、城市和道路。几何数据也可能是你想要使用的特定图标的SVG代码，是形状类别的文本，或者是一个表示形状大小的数值。不出所料，几何数据通常用形状和大小来表示，但也可以像其他数据一样进行转换，例如通过测量面积和周长转换为定量数据。
- en: The cities data has obvious geometric data in the form of traditional latitude
    and longitude coordinates that allow the points to be placed on a map. The tweets
    data, on the other hand, has no readily accessible geometric data.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 城市数据具有明显的几何数据，以传统的纬度和经度坐标的形式存在，这使得点可以在地图上定位。另一方面，推文数据没有易于访问的几何数据。
- en: Temporal
  id: totrans-433
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 时间
- en: Dates and time can be represented using numbers for days, years, or months,
    or with specific date-time encoding for more complex calculations. The most common
    format is ISO 8601, and if your data comes formatted that way as a string, it’s
    easy to turn it into a date datatype in JavaScript, as you’ll see in [section
    2.1.4](#ch02lev2sec4). You’ll work with dates and times often. Fortunately, both
    the built-in functions in JavaScript and a few helper functions in D3 are available
    to handle data that’s tricky to measure and represent.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 日期和时间可以使用数字表示天数、年份或月份，或者使用特定的日期时间编码来进行更复杂的计算。最常用的格式是ISO 8601，如果你的数据以字符串形式按这种方式格式化，那么在JavaScript中将它转换为日期数据类型就很容易，正如你将在[第2.1.4节](#ch02lev2sec4)中看到的。你将经常与日期和时间打交道。幸运的是，JavaScript中的内置函数以及D3中的几个辅助函数都可以用来处理难以测量和表示的数据。
- en: Although the cities dataset has no temporal data, keep in mind that temporal
    data for common entities like cities and countries is often available. In situations
    where you can easily expand your dataset like this, you need to ask yourself if
    it makes sense given the scope of your project. In contrast, the tweets data has
    a string that conforms to RFC 2822 (supported by JavaScript for representing dates
    along with ISO 8601) and can easily be turned into a date datatype in JavaScript.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然城市数据集没有时间数据，但请记住，像城市和国家这样的常见实体的时间数据通常可用。在你可以轻松扩展数据集的情况下，你需要问自己，考虑到你项目的范围，这样做是否有意义。相比之下，推文数据有一个符合RFC
    2822（JavaScript支持用于表示日期，与ISO 8601兼容）的字符串，可以轻松地在JavaScript中转换为日期数据类型。
- en: Raw
  id: totrans-436
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原始
- en: Raw, free, or unstructured data is typically text and image content. Raw data
    can be transformed by measuring it or using sophisticated text and image analysis
    to derive attributes more suited to data visualization. In its unaltered form,
    raw data is used in the content fields of graphical elements, such as in labels
    or snippets.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 原始、自由或非结构化数据通常是文本和图像内容。原始数据可以通过测量或使用复杂的文本和图像分析来转换，以获得更适合数据可视化的属性。在未经修改的形式下，原始数据用于图形元素的文本字段中，例如在标签或片段中。
- en: The city names provide convenient labels for that dataset, but how would we
    label the individual tweets? One way is to use the entire content of the tweet
    as a label, as we’ll do in [chapter 5](../Text/kindle_split_014.html#ch05), but
    when dealing with raw data, the most difficult and important task is coming up
    with ways of summarizing and measuring it effectively.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 城市名称为该数据集提供了方便的标签，但如何为单个推文标记呢？一种方法是将推文的全部内容用作标签，正如我们在[第 5 章](../Text/kindle_split_014.html#ch05)中所做的那样，但处理原始数据时，最困难且最重要的任务是提出有效总结和测量的方法。
- en: 2.1.3\. Further modifying data
  id: totrans-439
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.3\. 进一步修改数据
- en: As you deal with different forms of data, you’ll change data from one type to
    another to better represent it. You can transform data in many ways. Here we’ll
    look at casting, normalizing (or scaling), binning (or grouping), and nesting
    data.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 当你处理不同形式的数据时，你会改变数据类型以更好地表示它。你可以以多种方式转换数据。在这里，我们将探讨转换、归一化（或缩放）、分箱（或分组）和嵌套数据。
- en: 'Casting: changing datatypes'
  id: totrans-441
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 转换：改变数据类型
- en: 'The act of casting data refers to turning one datatype into another from the
    perspective of your programming language, which in this case is JavaScript. When
    you load data, it will often be in a string format, even if it’s a date, integer,
    floating-point number, or array. The date string in the tweets data, for instance,
    needs to be changed from a string into a date datatype if you want to work with
    the date methods available in JavaScript. You should familiarize yourself with
    the JavaScript functions that allow you to transform data. Here are a few:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 从编程语言的角度来看，数据转换的行为是指将一种数据类型转换为另一种类型，在这个例子中是 JavaScript。当你加载数据时，它通常以字符串格式存在，即使它是一个日期、整数、浮点数或数组。例如，推文数据中的日期字符串需要从字符串转换为日期数据类型，以便你可以使用
    JavaScript 中可用的日期方法。你应该熟悉允许你转换数据的 JavaScript 函数。以下是一些示例：
- en: '[PRE49]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '***1* Casts the string 77 into the number 77 with no decimal places**'
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将字符串 77 转换为没有小数位的数字 77**'
- en: '***2* Casts the string 3.14 into the number 3.14 with decimal places**'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将字符串 3.14 转换为带小数点的数字 3.14**'
- en: '***3* Casts an ISO 8601– or RFC 2822–compliant string into a date datatype**'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将符合 ISO 8601– 或 RFC 2822– 格式的字符串转换为日期数据类型**'
- en: '***4* Splits the comma-delimited string into an array, which isn’t strictly
    speaking a casting operation, but changes the type of data**'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将逗号分隔的字符串拆分为一个数组，这严格来说不是一个转换操作，但改变了数据类型**'
- en: '|  |'
  id: totrans-448
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-449
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: JavaScript defaults to type conversion when using the == test, whereas it forces
    no type conversion when using === and the like, so you’ll find your code will
    often work fine without casting. But this will come back to haunt you in situations
    where it doesn’t default to the type you expect, for example, when you try to
    sort an array and JavaScript sorts your numbers alphabetically.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 在使用 == 测试时默认进行类型转换，而在使用 === 等类似操作时则强制不进行类型转换，因此你会发现你的代码在没有转换的情况下通常可以正常工作。但是，在不默认转换为预期类型的情况下，你可能会遇到一些问题，例如，当你尝试对数组进行排序时，JavaScript
    会按字母顺序对数字进行排序。
- en: '|  |'
  id: totrans-451
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Scales and scaling
  id: totrans-452
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尺度和缩放
- en: Numerical data rarely corresponds directly to the position and size of graphical
    elements onscreen. You can use `d3.scale()` functions to normalize your data for
    presentation on a screen (among other things). The first scale we’ll look at is
    `d3.scale().linear()`, which makes a direct relationship between one range of
    numbers and another. Scales have a domain setting and a range setting that accept
    arrays, with the domain determining the ramp of values being transformed and the
    range referring to the ramp to which those values are being transformed. For example,
    if you take the smallest population figure in cities.csv and the largest population
    figure, you can create a ramp that scales from the smallest to the largest so
    that you can display the difference between them easily on a 500-px canvas. In
    [figure 2.5](#ch02fig05) and the code that follows, you can see that the same
    linear rate of change from 500,000 to 13,000,000 maps to a linear rate of change
    from 0 to 500.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 数值数据很少直接对应于屏幕上图形元素的位量和大小。您可以使用 `d3.scale()` 函数来规范化您的数据，以便在屏幕上展示（以及其他事情）。我们将首先查看的刻度是
    `d3.scale().linear()`，它在一组数字的范围和另一组数字的范围之间建立直接关系。刻度有一个域设置和一个范围设置，它们接受数组，其中域确定要转换的值范围，范围指的是这些值要转换到的范围。例如，如果您取
    cities.csv 中城市的最小人口数和最大人口数，您可以创建一个从最小到最大的渐变，这样您就可以在 500-px 的画布上轻松显示它们之间的差异。在 [图
    2.5](#ch02fig05) 和随后的代码中，您可以看到从 500,000 到 13,000,000 的相同线性变化率映射到从 0 到 500 的线性变化率。
- en: Figure 2.5\. Scales in D3 map one set of values (the domain) to another set
    of values (the range) in a relationship determined by the type of scale you create.
  id: totrans-454
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.5\. D3 中的刻度将一组值（域）映射到另一组值（范围），这种关系由您创建的刻度类型确定。
- en: '![](../Images/02fig05.jpg)'
  id: totrans-455
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/02fig05.jpg)'
- en: 'You create this ramp by instantiating a new scale object and setting its domain
    and range values:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过实例化一个新的刻度对象并设置其域和范围值来创建这个渐变：
- en: '[PRE50]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '***1* Returns 20, allowing you to place a country with population 10,000,000
    at 20 px**'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 返回 20，允许您将人口为 10,000,000 的国家放置在 20 px**'
- en: '***2* Returns 340**'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 返回 340**'
- en: '***3* The invert function reverses the transformation, in this case returning
    8325000**'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 反转函数反转了转换，在这种情况下返回 8325000**'
- en: You can also create a color ramp by referencing CSS color names, RGB colors,
    or hex colors in the range field. The effect is a linear mapping of a band of
    colors to the band of values defined in the domain, as shown in [figure 2.6](#ch02fig06).
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过在范围字段中引用 CSS 颜色名称、RGB 颜色或十六进制颜色来创建颜色渐变。这种效果是将颜色带映射到在域中定义的值带上的线性映射，如图 [图
    2.6](#ch02fig06) 所示。
- en: Figure 2.6\. Scales can also be used to map numerical values to color bands,
    to make it easier to denote values using a color scale.
  id: totrans-462
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.6\. 刻度也可以用来将数值映射到颜色带，以便更容易使用颜色刻度表示值。
- en: '![](../Images/02fig06.jpg)'
  id: totrans-463
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/02fig06.jpg)'
- en: 'The code to create this ramp is the same, except for the reference to colors
    in the `range` array:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这个渐变的代码与之前相同，只是 `range` 数组中颜色的引用不同：
- en: '[PRE51]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '***1* Returns “#0a00f5”, allowing you to draw a city with population 1,000,000
    as dark purple**'
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 返回 “#0a00f5”，允许您绘制一个人口为 1,000,000 的城市为深紫色**'
- en: '***2* Returns “#ad0052”**'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 返回 “#ad0052”**'
- en: '***3* The invert function only works with a numeric range, so inverting in
    this case returns NaN**'
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 反转函数仅适用于数值范围，因此在这种情况下反转返回 NaN**'
- en: You can also use `d3.scaleLog()`, `d3.scalePow()`, `d3.scaleOrdinal()`, and
    other less-common scales to map data where these scales are more appropriate to
    your dataset. You’ll see these in action later in the book as we deal with those
    kinds of datasets. Finally, `d3.scaleTime()` provides a linear scale that’s designed
    to deal with date datatypes, as you’ll see later in this chapter.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用 `d3.scaleLog()`、`d3.scalePow()`、`d3.scaleOrdinal()` 以及其他不太常见的刻度来映射数据，在这些刻度更适合您的数据集时。您将在本书后面的部分看到这些刻度的实际应用，当我们处理这些类型的数据集时。最后，`d3.scaleTime()`
    提供了一个线性刻度，它设计用来处理日期数据类型，您将在本章后面的部分看到这一点。
- en: 'Binning: categorizing data'
  id: totrans-470
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 分箱：数据分类
- en: It’s useful to sort quantitative data into categories, placing the values in
    a range or “bin” to group them together. One method is to use quantiles, by splitting
    the array into equal-sized parts. The quantile scale in D3 is, not surprisingly,
    called `d3.scaleQuantile()`, and it has the same settings as other scales. The
    number of parts and their labels are determined by the `.range()` setting. Unlike
    other scales, it gives no error if there’s a mismatch between the number of `.domain()`
    values and the number of `.range()` values in a quantile scale, because it automatically
    sorts and bins the values in the domain into a smaller number of values in the
    range.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 将定量数据分类到类别中，将值放置在范围或“箱”中以将它们分组在一起是有用的。一种方法是使用分位数，通过将数组分割成等大小的部分。D3中的分位数刻度不出所料地被称为`d3.scaleQuantile()`，并且它具有与其他刻度相同的设置。部分的数目及其标签由`.range()`设置确定。与其它刻度不同，如果分位数刻度中`.domain()`值的数目与`.range()`值的数目不匹配，它不会给出错误，因为它会自动将域中的值排序并分箱到范围中的更少数值。
- en: 'The scale sorts the array of numbers in its `.domain()` from smallest to largest
    and automatically splits the values at the appropriate point to create the necessary
    categories. Any number passed into the quantile scale function returns one of
    the set categories based on these break points:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 该刻度将`.domain()`中的数字数组从小到大排序，并自动在适当的位置分割值以创建必要的类别。任何传递给分位数刻度函数的数字都会根据这些断点返回集合中的一个类别：
- en: '[PRE52]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '***1* Returns 2**'
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 返回2**'
- en: '***2* Returns 0**'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 返回0**'
- en: '***3* Returns 2**'
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 返回2**'
- en: Notice that the range values in [figure 2.7](#ch02fig07) are fixed and can accept
    text that may correspond to a particular CSS class, color, or other arbitrary
    value.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到[图2.7](#ch02fig07)中的范围值是固定的，可以接受可能与特定CSS类、颜色或其他任意值相对应的文本。
- en: Figure 2.7\. Quantile scales take a range of values and reassign them into a
    set of equally sized bins.
  id: totrans-478
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.7\. 分位数刻度接受一系列值，并将它们重新分配到一组等大小的箱中。
- en: '![](../Images/02fig07.jpg)'
  id: totrans-479
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/02fig07.jpg)'
- en: '[PRE53]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '***1* Returns “medium**'
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 返回“medium**'
- en: '***2* Returns “small”**'
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 返回“small”**'
- en: '***3* Returns “large”**'
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 返回“large”**'
- en: Nesting
  id: totrans-484
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 嵌套
- en: Hierarchical representations of data are useful and aren’t limited to data with
    more traditional or explicit hierarchies, such as a dataset of parents and their
    children. We’ll get into hierarchical data and representation in more detail in
    [chapters 4](../Text/kindle_split_013.html#ch04) and [5](../Text/kindle_split_014.html#ch05),
    but in this chapter we’ll use the D3 nesting function, which you can probably
    guess is called `d3.nest()`.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 数据的分层表示很有用，并不限于具有更传统或显式层次结构的数据，例如父母及其子女的数据集。我们将在第[4章](../Text/kindle_split_013.html#ch04)和第[5章](../Text/kindle_split_014.html#ch05)中更详细地探讨分层数据和表示，但在这章中，我们将使用D3的嵌套函数，你可能猜到它被称作`d3.nest()`。
- en: 'The concept behind nesting is that shared attributes of data can be used to
    sort them into discrete categories and subcategories. For instance, if we want
    to group tweets by the user who made them, then we’d use nesting:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套背后的概念是，可以使用数据的共享属性将它们排序到离散的类别和子类别中。例如，如果我们想按创建推文的用户分组推文，那么我们会使用嵌套：
- en: '[PRE54]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This nesting function combines the tweets into arrays under new objects labeled
    by the unique `user` attribute values, as shown in [figure 2.8](#ch02fig08).
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 这个嵌套函数将推文组合成由唯一的`user`属性值标记的新对象的数组，如图[2.8](#ch02fig08)所示。
- en: Figure 2.8\. Objects nested into a new array are now child elements of a values
    array of newly created objects that have a key attribute set to the value used
    in the `d3.nest.key` function.
  id: totrans-489
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.8\. 将对象嵌套到新数组中，这些对象现在成为新创建的对象的值数组的子元素，这些新创建的对象有一个键属性被设置为`d3.nest.key`函数中使用的值。
- en: '![](../Images/02fig08_alt.jpg)'
  id: totrans-490
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/02fig08_alt.jpg)'
- en: Now that we’ve loaded our data and transformed it into types that are accessible,
    we’ll investigate the patterns of that data by measuring the data (the third step
    shown in [figure 2.9](#ch02fig09)).
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经加载了数据并将其转换成可访问的类型，我们将通过测量数据（如图[2.9](#ch02fig09)中显示的第三步）来研究这些数据的模式。
- en: Figure 2.9\. After formatting your data, you’ll need to measure it to ensure
    that the graphics you create are appropriately sized and positioned based on the
    parameters of the dataset. You’ll use `d3.extent`, `d3.min`, `d3.mean`, and `d3.max`
    all the time.
  id: totrans-492
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.9\. 在格式化你的数据后，你需要测量它以确保你创建的图形根据数据集的参数适当地大小和定位。你将经常使用`d3.extent`、`d3.min`、`d3.mean`和`d3.max`。
- en: '![](../Images/02fig09.jpg)'
  id: totrans-493
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/02fig09.jpg)'
- en: 2.1.4\. Measuring data
  id: totrans-494
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.4\. 测量数据
- en: After loading your data array, one of the first things you should do is measure
    and sort it. It’s particularly important to know the distribution of values of
    particular attributes, as well as the minimum and maximum values and the names
    of the attributes. D3 provides a set of array functions that can help you understand
    your data.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载您的数据数组后，您应该做的第一件事之一就是测量和排序它。了解特定属性的值分布、最小和最大值以及属性名称非常重要。D3提供了一套数组函数，可以帮助您理解您的数据。
- en: 'You’ll always have arrays filled with data that you’ll want to size and position
    based on the relative value of an attribute compared to the distribution of the
    values in the array. You should therefore familiarize yourself with the ways to
    determine the distributions of values in an array in D3\. You’ll work with an
    array of numbers first before you see these functions in operation with more complex
    and more data-rich JSON object arrays:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 您将始终拥有包含数据的数组，您希望根据属性相对于数组中值分布的相对值来调整大小和位置。因此，您应该熟悉在D3中确定数组中值分布的方法。您将首先处理一个数字数组，然后再看到这些函数在更复杂、数据更丰富的JSON对象数组中的操作：
- en: '[PRE55]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Nearly all the D3 measuring functions follow the same pattern. First, you need
    to designate the array and an accessor function for the value that you want to
    measure. In our case, we’re working with an array of numbers and not an array
    of objects, so the accessor only needs to point at the element itself:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有的D3测量函数都遵循相同的模式。首先，您需要指定数组以及一个访问器函数来获取您想要测量的值。在我们的例子中，我们正在处理一个数字数组而不是对象数组，因此访问器只需要指向元素本身：
- en: '[PRE56]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '***1* Returns the minimum value in the array, 1**'
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 返回数组中的最小值，1**'
- en: '***2* Returns the maximum value in the array, 10000**'
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 返回数组中的最大值，10000**'
- en: '***3* Returns the average of values in the array, 1701.8333333333335**'
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 返回数组中值的平均值，1701.8333333333335**'
- en: 'If you’re dealing with a more complex JSON object array, you’ll need to designate
    the attribute you want to measure. For instance, if we’re working with the array
    of JSON objects from cities.csv, we may want to derive the minimum, maximum, and
    average populations:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您处理的是一个更复杂的JSON对象数组，您需要指定您想要测量的属性。例如，如果我们正在处理来自cities.csv的JSON对象数组，我们可能想要推导出最小、最大和平均人口：
- en: '[PRE57]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '***1* Returns the minimum value of the population attribute of each object
    in the array, 500000**'
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 返回数组中每个对象的属性的最小值，500000**'
- en: '***2* Returns the maximum value of the population attribute of each object
    in the array, 1300000**'
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 返回数组中每个对象的属性的最大值，1300000**'
- en: '***3* Returns the average value of the population attribute of each object
    in the array, 6856250**'
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 返回数组中每个对象的属性的平均值，6856250**'
- en: 'Finally, because dealing with minimum and maximum values is a common occurrence,
    `d3.extent()` conveniently returns `d3.min()` and `d3.max()` in a two-piece array:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于处理最小值和最大值是常见的操作，`d3.extent()`方便地以一个两部分的数组返回`d3.min()`和`d3.max()`：
- en: '[PRE58]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '***1* Returns [500000, 1300000]**'
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 返回 [500000, 1300000]**'
- en: You can also measure nonnumerical data like text by using the JavaScript `.length()`
    function for strings and arrays. When dealing with topological data, you need
    more robust mechanisms to measure network structure, such as centrality and clustering.
    When dealing with geometric data, you can calculate the area and perimeter of
    shapes mathematically, which can become rather difficult with complex shapes.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用JavaScript的`.length()`函数来测量非数值数据，如文本。当处理拓扑数据时，您需要更健壮的机制来测量网络结构，例如中心性和聚类。当处理几何数据时，您可以数学地计算形状的面积和周长，对于复杂的形状来说这可能相当困难。
- en: Now that we’ve loaded, formatted, and measured our data, we can create data
    visualizations. This requires us to use selections and the functions that come
    with them, which we’ll examine in more detail in the next section.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经加载、格式化和测量了我们的数据，我们可以创建数据可视化。这需要我们使用选择以及与之相关的函数，我们将在下一节中更详细地探讨。
- en: 2.2\. Data-binding
  id: totrans-513
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2\. 数据绑定
- en: We touched on data-binding in [chapter 1](../Text/kindle_split_010.html#ch01),
    but here we’ll go into it in more detail, explaining how selections work with
    data-binding to create elements (the fourth step shown in [figure 2.10](#ch02fig10))
    and to change those elements after they’ve been created. Our first example uses
    the data from cities.csv. After that we’ll see the process using this data as
    well as simple numerical arrays, and later we’ll do more interesting things with
    the tweets data.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第1章](../Text/kindle_split_010.html#ch01)中提到了数据绑定，但在这里我们将更详细地介绍它，解释选择如何与数据绑定一起创建元素（如图2.10中所示的第四步）以及创建元素后如何更改这些元素。我们的第一个例子使用了cities.csv中的数据。之后，我们将使用这些数据以及简单的数值数组来展示这个过程，稍后我们还会用tweets数据做一些更有趣的事情。
- en: Figure 2.10\. To create graphics in D3, you use selections that bind data to
    DOM elements.
  id: totrans-515
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.10\. 在D3中创建图形时，您使用选择将数据绑定到DOM元素。
- en: '![](../Images/02fig10.jpg)'
  id: totrans-516
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/02fig10.jpg)'
- en: 2.2.1\. Selections and binding
  id: totrans-517
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.1\. 选择和绑定
- en: You use selections to make changes to the structure and appearance of your web
    page with D3\. Remember that a selection consists of one or more elements in the
    DOM as well as the data, if any, associated with them. You can also create or
    delete elements using selections, and change the style and content. You’ve seen
    how to use `d3.select()` to change a DOM element, and now we’ll focus on creating
    and removing elements based on data. For this example, we’ll use cities.csv as
    our data source. In it are a list of all the cities I’ve lived or always wanted
    to visit, and Fresno. Later we’ll put these cities on a map, but for now we’re
    going to use them as non-map data. First, we need to load cities.csv and trigger
    our data visualization function in the callback to create a set of new `<div>`
    elements on the page using this code, with the results shown in [figure 2.11](#ch02fig11).
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用选择来使用D3更改网页的结构和外观。请记住，选择由DOM中的一个或多个元素以及与之关联的任何数据组成。您还可以使用选择创建或删除元素，并更改样式和内容。您已经看到了如何使用`d3.select()`来更改DOM元素，现在我们将专注于根据数据创建和删除元素。对于这个例子，我们将使用cities.csv作为数据源。其中包含了我住过或一直想去参观的所有城市，以及弗雷斯诺。稍后我们将把这些城市放在地图上，但现在我们将使用它们作为非地图数据。首先，我们需要加载cities.csv并在回调中触发我们的数据可视化函数，使用以下代码在页面上创建一组新的`<div>`元素，结果如图2.11所示。
- en: Figure 2.11\. When our selection binds the cities.csv data to our web page,
    it creates eight new divs, each of which is classed with `"cities"` and with content
    drawn from our data.
  id: totrans-519
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.11\. 当我们的选择将cities.csv数据绑定到我们的网页上时，它创建了八个新的<div>元素，每个元素都被标记为“cities”类，并且内容来自我们的数据。
- en: '![](../Images/02fig11_alt.jpg)'
  id: totrans-520
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/02fig11_alt.jpg)'
- en: '[PRE59]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '***1* An empty selection because there are no <div> elements in <body> with
    class of “cities”**'
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 空选择，因为<body>中没有具有“cities”类的<div>元素**'
- en: '***2* Binds the data to your selection**'
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将数据绑定到您的选择**'
- en: '***3* Defines how to respond when there’s more data than DOM elements in a
    selection**'
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 定义当选择中的数据多于DOM元素时如何响应**'
- en: '***4* Creates an element in the current selection**'
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 在当前选择中创建一个元素**'
- en: '***5* Sets the class of each newly created element**'
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 设置每个新创建的元素的类**'
- en: '***6* Sets the content of the created <div>**'
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 设置创建的<div>的内容**'
- en: The selection and binding procedure shown here is a common pattern throughout
    the rest of this book. A subselection is created when you first select one element
    and then select the elements underneath it, which you’ll see in more detail later.
    First, let’s look at each individual part of this example. See [figure 2.11](#ch02fig11).
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 这里所示的选择和绑定过程是本书其余部分中常见的模式。当您首先选择一个元素，然后选择其下方的元素时，就会创建一个子选择，您将在后面更详细地看到。首先，让我们看看这个例子中的每个单独部分。参见[图2.11](#ch02fig11)。
- en: d3.selectAll()
  id: totrans-529
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: d3.selectAll()
- en: The first part of any selection is `d3.select()` or `d3.selectAll()` with a
    CSS identifier that corresponds to a part of the DOM. Often no elements match
    the identifier, which is referred to as an *empty selection*, because you want
    to create new elements on the page using the .`enter()` function. You can make
    a selection on a selection to designate how to create and modify child elements
    of a specific DOM element. Note that a subselection won’t automatically generate
    a parent. The parent must already exist, or you’ll need to create one using `.append()`.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 任何选择的第一个部分是 `d3.select()` 或 `d3.selectAll()`，后面跟着一个与 DOM 的一部分相对应的 CSS 标识符。通常没有元素匹配该标识符，这被称为
    *空选择*，因为你想使用 `.enter()` 函数在页面上创建新元素。你可以对一个选择进行选择，以指定如何创建和修改特定 DOM 元素的子元素。请注意，子选择不会自动生成父元素。父元素必须已经存在，或者你需要使用
    `.append()` 创建一个。
- en: data()
  id: totrans-531
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: data()
- en: 'Here you associate an array with the DOM elements you selected. Each city in
    our dataset is associated with a DOM element in the selection, and that associated
    data is stored in a `data` attribute of the element. We could access these values
    manually using Java-Script like so:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你将一个数组与所选的 DOM 元素关联起来。我们数据集中的每个城市都与选择中的一个 DOM 元素相关联，相关数据存储在元素的 `data` 属性中。我们可以像这样使用
    Java-Script 手动访问这些值：
- en: '[PRE60]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '***1* Returns a pointer to the object representing San Francisco**'
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 返回代表旧金山的对象指针**'
- en: Later in this chapter we’ll work with those values in a more sophisticated way
    using D3.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将使用 D3 以更复杂的方式处理这些值。
- en: enter() and .exit()
  id: totrans-536
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: enter() 和 .exit()
- en: When binding data to selections, there will be either more, less, or the same
    number of DOM elements as there are data values. When you have more data values
    than DOM elements in the selection, you trigger the `.enter()` function, which
    allows you to define behavior to perform for every value that doesn’t have a corresponding
    DOM element in the selection. In our case, `.enter()` fires eight times, because
    no DOM elements correspond to `"div.cities"` and our `incomingData` array contains
    eight values. When fewer data elements exist, then `.exit()` behavior is triggered,
    and when data values and DOM elements are equal in a selection, then neither `.exit()`
    nor `.enter()` is fired. You’ll notice I didn’t use `.exit()` in the previous
    code. That’s because I knew there weren’t going to be fewer data elements than
    DOM elements. In an application where you know that you’re not going to deal with
    `.exit()` you don’t need to write the behavior for it.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 当将数据绑定到选择时，DOM 元素的数目要么多于、少于，要么等于数据值的数目。当你选择中的数据值多于 DOM 元素时，你会触发 `.enter()` 函数，这允许你为每个没有对应
    DOM 元素的选择值定义行为。在我们的例子中，`.enter()` 会触发八次，因为没有 DOM 元素对应于 `"div.cities"`，而我们的 `incomingData`
    数组包含八个值。当数据元素较少时，则会触发 `.exit()` 行为，而当选择中的数据值和 DOM 元素数量相等时，则既不会触发 `.exit()` 也不会触发
    `.enter()`。你会注意到我之前没有使用 `.exit()`。那是因为我知道数据元素不会少于 DOM 元素。在一个你知道不会处理 `.exit()`
    的应用程序中，你不需要为它编写行为。
- en: Enter and exit often confuse people when they first get started with D3 but
    the pattern, where you make a diff of the current state of the DOM and the data
    being bound, and creating or removing elements as a result, is commonly deployed
    in modern Model-View-Controller (MVC) frameworks. The difference is that when
    you’re using something like React, it abstracts it more, and so you don’t have
    to write separate logic for enter, exit, and update.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 当初开始使用 D3 时，enter() 和 exit() 经常会让人感到困惑，但当你对 DOM 当前状态和数据绑定进行差异比较，并根据结果创建或删除元素的模式在现代模型-视图-控制器
    (MVC) 框架中普遍应用时，这种模式就变得清晰了。区别在于，当你使用像 React 这样的东西时，它会更多地抽象化，因此你不需要为 enter、exit
    和 update 编写单独的逻辑。
- en: append() and .insert()
  id: totrans-539
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: append() 和 .insert()
- en: You’ll almost always want to add elements to the DOM when there are more data
    values than DOM elements. The `.append()` function allows you to add more elements
    and define which elements to add. In our example, we add `<div>` elements, but
    later in this chapter we’ll add SVG shapes, and in other chapters we’ll add tables
    and buttons and any other element type supported in HTML. The `.insert()` function
    is a sister function to `.append()`, but `.insert()` gives you control over where
    in the DOM you add the new element. You can also perform an append or insert directly
    on a selection, which adds one DOM element of the kind you specify for each DOM
    element in your selection.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据值多于DOM元素时，你几乎总是想要向DOM中添加元素。`.append()`函数允许你添加更多元素并定义要添加哪些元素。在我们的例子中，我们添加了`<div>`元素，但在本章的后面部分，我们将添加SVG形状，在其他章节中，我们将添加表格、按钮以及其他任何HTML支持的元素类型。`.insert()`函数是`.append()`的姐妹函数，但`.insert()`让你能够控制新元素在DOM中的位置。你还可以直接在选择上执行append或insert操作，这将为你的选择中的每个DOM元素添加一个指定类型的DOM元素。
- en: attr()
  id: totrans-541
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: attr()
- en: You’re familiar with changing styles and attributes using D3 syntax. The only
    thing to note is that each of the functions you define here will be applied to
    each new element added to the page. In our example, each of our eight new `<div>`
    elements will be created with `class="cities"`. Remember that even though our
    selection referenced `"div.cities"`, we still have to manually declare that we’re
    creating `<div>` elements and also manually set their class to `"cities"`.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 你熟悉使用D3语法更改样式和属性。唯一需要注意的是，你在这里定义的每个函数都将应用于添加到页面上的每个新元素。在我们的例子中，我们创建的八个新`<div>`元素都将带有`class="cities"`。记住，尽管我们的选择引用了`"div.cities"`，我们仍然必须手动声明我们正在创建`<div>`元素，并且还要手动设置它们的类为`"cities"`。
- en: html()
  id: totrans-543
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: html()
- en: For traditional DOM elements, you set the content with a `.html()` function.
    In the next section, you’ll see how to set content based on the data bound to
    the particular DOM element.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 对于传统的DOM元素，你使用`.html()`函数设置内容。在下一节中，你将看到如何根据绑定到特定DOM元素的数据设置内容。
- en: 2.2.2\. Accessing data with inline functions
  id: totrans-545
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.2\. 使用内联函数访问数据
- en: 'If you ran the code in the previous example, you saw that each `<div>` element
    was set with different content derived from the data array that you bound to the
    selection. You did this using an inline anonymous function in your selection that
    automatically provides access to two variables that are critical to representing
    data graphically: the data value itself and the array position of the data. In
    most examples you’ll see these represented as `d` for data and `i` for array index,
    but they could be declared using any available variable name.'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行了前面的示例代码，你会看到每个`<div>`元素都被设置了不同的内容，这些内容是从你绑定到选择的数据数组中派生出来的。你是通过在选择的匿名函数中这样做来实现的，该函数自动提供对两个对图形表示数据至关重要的变量：数据值本身和数据在数组中的位置。在大多数示例中，这些被表示为`d`（数据）和`i`（数组索引），但它们可以使用任何可用的变量名声明。
- en: 'The best way to see this in action is to use our data to create a simple data
    visualization. We’ll keep working with `d3ia.html`, which we created in [chapter
    1](../Text/kindle_split_010.html#ch01), and which is a simple HTML page with minimal
    DOM elements and styles. A histogram or bar chart is one of the most simple and
    effective ways of expressing numerical data broken down by category. We’ll avoid
    the more complex datasets for now and start with a simple array of numbers:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到这个功能在实际中的应用，最好的方法是使用我们的数据创建一个简单的数据可视化。我们将继续使用`d3ia.html`，这是我们[第1章](../Text/kindle_split_010.html#ch01)中创建的，它是一个具有最小DOM元素和样式的简单HTML页面。直方图或条形图是表达按类别分解的数值数据最简单和最有效的方法之一。我们现在将避免更复杂的数据集，并从一个简单的数字数组开始：
- en: '[PRE61]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'If we bind this array to a selection, we can use the values to determine the
    height of the rectangles (our bars in a bar chart). We need to set a width based
    on the space available for the chart, and we’ll start by setting it to 10 px:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这个数组绑定到一个选择上，我们就可以使用这些值来确定矩形的高度（条形图中的条）。我们需要根据图表可用的空间设置宽度，并且我们首先将其设置为10像素：
- en: '[PRE62]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '***1* Sets the width of the rectangles to a fixed value**'
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将矩形宽度设置为固定值**'
- en: '***2* Sets the height equal to the value of the data associated with each element**'
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将高度设置为与每个元素关联的数据值相等**'
- en: When we used the label values of our array to create `<div>` content with labels
    in [section 2.2.1](#ch02lev2sec5), we pointed to the object’s `label` attribute.
    Here, because we’re dealing with an array of number literals, we use the inline
    function to point directly at the value in the array to determine the height of
    our rectangles. The result, shown in [figure 2.12](#ch02fig12), isn’t nearly as
    interesting as you might expect.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在[2.2.1节](#ch02lev2sec5)中使用数组的标签值创建带有标签的`<div>`内容时，我们指向对象的`label`属性。在这里，因为我们处理的是一个数字字面量的数组，我们使用内联函数直接指向数组中的值以确定矩形的长度。如图2.12[所示](#ch02fig12)，结果并不像你预期的那样有趣。
- en: Figure 2.12\. The default setting for any shape in SVG is black fill with no
    stroke, which makes it hard to tell when the shapes overlap each other.
  id: totrans-554
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.12\. SVG中任何形状的默认设置是黑色填充且没有描边，这使得很难判断形状是否重叠。
- en: '![](../Images/02fig12.jpg)'
  id: totrans-555
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/02fig12.jpg)'
- en: All the rectangles overlap each other—they have the same default x and y positions.
    The drawing is easier to see by adjusting their opacity style, as shown in [figure
    2.13](#ch02fig13).
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 所有矩形都相互重叠——它们有相同的默认x和y位置。通过调整它们的透明度样式，如图2.13[所示](#ch02fig13)，绘制更容易看到。
- en: Figure 2.13\. By changing the opacity settings, you can see the overlapping
    rectangles.
  id: totrans-557
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.13\. 通过改变不透明度设置，你可以看到重叠的矩形。
- en: '![](../Images/02fig13.jpg)'
  id: totrans-558
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/02fig13.jpg)'
- en: '[PRE63]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'You may wonder about practical use of the second variable in the inline function,
    typically represented as `i`. One use of the array position of a data value is
    to place visual elements. If we set the x position of each rectangle based on
    the `i` value (multiplied by the width of the rectangle), then we get a step closer
    to a bar chart:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会对内联函数中第二个变量的实际用途感到好奇，通常表示为`i`。数组中数据值的数组位置的一个用途是放置视觉元素。如果我们根据矩形的`i`值（乘以矩形的宽度）设置每个矩形的x位置，那么我们就更接近于一个柱状图：
- en: '[PRE64]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Our histogram seems to be drawn from top to bottom, as seen in [figure 2.14](#ch02fig14),
    because SVG draws rectangles down and to the right from the 0,0 point that we
    specify. To adjust this, we need to move each rectangle so that its y position
    corresponds to a position that is offset based on its height. We know that the
    tallest rectangle will be 100\. The y position is measured based on the distance
    from the top left of the canvas, so if we set the `y` attribute of each rectangle
    equal to 100 minus its length, then the histogram is drawn in the manner we’d
    expect, as shown in [figure 2.15](#ch02fig15). Now that the rectangles aren’t
    overlapping, they also appear to be a light gray color—their default black fill
    with 75% transparency. We’ll lose the opacity and also add fill and stroke color
    to differentiate them.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的直方图看起来是从上到下绘制的，如图2.14[所示](#ch02fig14)，因为SVG从我们指定的0,0点向下和向右绘制矩形。为了调整这一点，我们需要移动每个矩形，使其y位置对应于基于其高度的偏移位置。我们知道最高的矩形将是100。y位置是根据从画布左上角起测量的距离来测量的，所以如果我们将每个矩形的`y`属性设置为100减去其长度，那么直方图就会以我们预期的样子绘制，如图2.15[所示](#ch02fig15)。现在矩形不再重叠，它们看起来也是浅灰色——它们的默认黑色填充带有75%的不透明度。我们将失去不透明度，并添加填充和描边颜色以区分它们。
- en: Figure 2.14\. SVG rectangles are drawn from top to bottom.
  id: totrans-563
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.14\. SVG矩形是从上到下绘制的。
- en: '![](../Images/02fig14.jpg)'
  id: totrans-564
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/02fig14.jpg)'
- en: Figure 2.15\. When we set the y position of the rectangle to the desired y position
    minus the height of the rectangle, the rectangle is drawn from bottom to top from
    that y position.
  id: totrans-565
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.15\. 当我们将矩形的y位置设置为所需的y位置减去矩形的长度时，矩形从该y位置从下到上绘制。
- en: '![](../Images/02fig15.jpg)'
  id: totrans-566
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/02fig15.jpg)'
- en: '[PRE65]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 2.2.3\. Integrating scales
  id: totrans-568
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.3\. 集成刻度
- en: 'This way of building a chart works fine if you’re dealing with an array of
    values that correspond directly to the height of the rectangles relative to the
    height and width of your `<svg>` element. But if you have real data, it tends
    to have widely divergent values that don’t correspond directly to the size of
    the shape you want to draw. Let’s say you need to show the number of social media
    followers of some of your business accounts. Several of these are technical accounts
    with only a handful of followers, and others are public-facing accounts with thousands
    of followers. The previous code doesn’t deal with an array of values like this:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你处理的是一个直接对应于你的`<svg>`元素高度和宽度的矩形高度的值数组，这种构建图表的方式效果很好。但是，如果你有真实数据，它往往具有广泛不同的值，这些值并不直接对应于你想要绘制的形状的大小。比如说，你需要显示一些商业账户的社交媒体粉丝数量。其中一些是技术账户，只有少数几个粉丝，而其他则是面向公众的账户，有数千个粉丝。之前的代码没有处理这样的值数组：
- en: '[PRE66]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: You can see how poorly it works in [figure 2.16](#ch02fig16).
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在图2.16中看到它工作得有多糟糕。
- en: Figure 2.16\. SVG shapes will continue to be drawn offscreen.
  id: totrans-572
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.16\. SVG形状将继续在屏幕外绘制。
- en: '![](../Images/02fig16.jpg)'
  id: totrans-573
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/02fig16.jpg)'
- en: '[PRE67]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'And it works no better if you set a y offset equal to the maximum:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将y偏移设置为最大值，效果也不会更好：
- en: '[PRE68]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'There’s no need to bother with a screenshot. It’s a single bar running vertically
    across your canvas. In this case, it’s best to use D3’s scaling functions to normalize
    the values for display. We’ll use the relatively straightforward `d3.scaleLinear()`
    for this bar chart. A D3 scale has two primary functions: `.domain()` and `.range()`,
    both of which expect arrays and must have arrays of the same length to get the
    right results. The array in `.domain()` indicates the series of values being mapped
    to `.range()`, which will make more sense in practice. First, we make a scale
    for the y-axis:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 没有必要麻烦截图。它是在画布上垂直运行的单一柱状条。在这种情况下，最好使用D3的缩放函数来归一化显示值。我们将使用相对简单的`d3.scaleLinear()`来绘制这个柱状图。D3缩放有两个主要功能：`.domain()`和`.range()`，它们都期望数组，并且必须有相同长度的数组才能得到正确的结果。`.domain()`中的数组表示映射到`.range()`的值序列，这在实践中会更有意义。首先，我们为y轴创建一个刻度：
- en: '[PRE69]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '***1* Returns 0**'
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 返回 0**'
- en: '***2* Returns 0.40816326530612246**'
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 返回 0.40816326530612246**'
- en: '***3* Returns 97.95918367346938**'
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 返回 97.95918367346938**'
- en: As you can see, `yScale` now allows us to map the values in a way suitable for
    display. If we then use `yScale` to determine the height and y position of the
    rectangles, we end up with a bar chart that’s more legible, as shown in [figure
    2.17](#ch02fig17).
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`yScale`现在允许我们以适合显示的方式映射值。如果我们使用`yScale`来确定矩形的高度和y位置，我们最终得到一个更易读的柱状图，如图2.17所示。
- en: Figure 2.17\. A bar chart drawn using a linear scale
  id: totrans-583
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.17\. 使用线性刻度绘制的柱状图
- en: '![](../Images/02fig17.jpg)'
  id: totrans-584
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/02fig17.jpg)'
- en: '[PRE70]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'When you deal with such widely diverging values, it often makes more sense
    to use a polylinear scale. A *polylinear* scale is a linear scale with multiple
    points in the domain and range. Let’s suppose that for our dataset, we’re particularly
    interested in values between 1 and 100, while recognizing that sometimes we get
    interesting values between 100 and 1000, and occasionally we get outliers that
    can be quite large. We could express this in a polylinear scale as follows:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 当你处理这样广泛不同的值时，使用多线性刻度通常更有意义。多线性刻度是一种在定义域和值域中有多个点的线性刻度。假设对于我们的数据集，我们特别关注1到100之间的值，同时认识到有时我们会在100到1000之间得到有趣的价值，偶尔我们还会得到相当大的异常值。我们可以用以下方式在多线性刻度上表示：
- en: '[PRE71]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The previous draw code produces a different chart with this scale, as shown
    in [figure 2.18](#ch02fig18).
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的绘制代码使用这个刻度生成了一个不同的图表，如图2.18所示。
- en: Figure 2.18\. The same bar chart from [figure 2.17](#ch02fig17) drawn with a
    polylinear scale
  id: totrans-589
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.18\. 使用多线性刻度绘制的与图2.17相同的柱状图
- en: '![](../Images/02fig18.jpg)'
  id: totrans-590
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/02fig18.jpg)'
- en: 'There may be a cutoff value, after which it isn’t so important to express how
    large a datapoint is. For instance, let’s say these datapoints represent the number
    of responses for a survey, and it’s deemed a success if you receive more than
    500 responses. We may only want to show the range of the data values between 0
    and 500, while emphasizing the variation at the 0 to 100 level with a scale like
    this:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 可能存在一个截止值，在此之后，表达数据点的规模就不那么重要了。例如，假设这些数据点代表调查的回复数量，如果收到超过500个回复则被视为成功。我们可能只想显示0到500之间的数据值范围，同时使用这样的刻度强调0到100级别的变化：
- en: '[PRE72]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: You may think that’s enough to draw a new chart that caps the bars at a maximum
    height of 100 if the datapoint has a value over 500\. This isn’t the default behavior
    for scales in D3, though. In [figure 2.19](#ch02fig19) you can see what would
    happen running the draw code with that scale.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为这足以绘制一个新的图表，将条形的高度限制在100以内，如果数据点的值超过500。但这并不是D3中刻度的默认行为。在[图2.19](#ch02fig19)中，你可以看到使用该刻度运行绘图代码会发生什么。
- en: Figure 2.19\. A bar chart drawn with a linear scale where the maximum value
    in the domain is lower than the maximum value in the dataset
  id: totrans-594
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.19。使用线性刻度的条形图，其中域的最大值低于数据集的最大值
- en: '![](../Images/02fig19.jpg)'
  id: totrans-595
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/02fig19.jpg)'
- en: 'Notice the rectangles are still drawn above the canvas, as evidenced by the
    lack of a border on the top of the four rectangles with values over 500\. We can
    confirm this is happening by putting a value greater than 500 into the scale function
    we’ve created:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，矩形仍然绘制在画布上方，正如四个值超过500的矩形顶部没有边框所证明的那样。我们可以通过将一个大于500的值放入我们创建的刻度函数中来确认这一点：
- en: '[PRE73]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '***1* Returns 162.5**'
  id: totrans-598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 返回 162.5**'
- en: 'By default, a D3 scale continues to extrapolate values greater than the maximum
    domain value and less than the minimum domain value. If we want it to set all
    such values to the maximum (for greater) or minimum (for lesser) range value,
    we need to use the `.clamp()` function:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，D3刻度会继续外推大于最大域值和小于最小域值的值。如果我们想让它将这些值设置为最大（对于大于）或最小（对于小于）的范围值，我们需要使用`.clamp()`函数：
- en: '[PRE74]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Running the draw code now produces rectangles that have a maximum value of 100
    for height and position, as shown in [figure 2.20](#ch02fig20).
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行绘图代码会生成高度和位置最大值为100的矩形，如图2.20所示。[figure 2.20](#ch02fig20)。
- en: Figure 2.20\. A bar chart drawn with values in the dataset greater than the
    maximum value of the domain of the scale, but with the `clamp()` function set
    to `true`
  id: totrans-602
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.20。使用`clamp()`函数设置为`true`时，绘制数据集中大于域最大值的条形图
- en: '![](../Images/02fig20.jpg)'
  id: totrans-603
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/02fig20.jpg)'
- en: 'We can confirm this by plugging a value into `yScale()` that’s greater than
    500:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将一个大于500的值插入`yScale()`来确认这一点：
- en: '[PRE75]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '***1* Returns 100**'
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 返回 100**'
- en: Scale functions are key to determining position, size, and color of elements
    in data visualization. As you’ll see later in this chapter and throughout the
    book, this is the basic process for using scales in D3.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 尺度函数是确定数据可视化中元素位置、大小和颜色的关键。正如你将在本章后面和整本书中看到的那样，这是在D3中使用刻度的基本过程。
- en: 2.3\. Data presentation style, attributes, and content
  id: totrans-608
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3. 数据呈现风格、属性和内容
- en: It’s finally time to start visualizing real data and not only undifferentiated
    arrays like we’ve used so far. First we’ll look at the size of those beautiful
    cities (and Fresno) as well as learn how to measure our social media success by
    measuring the number of tweets in the tweets data combining the techniques you’ve
    learned in this chapter and [chapter 1](../Text/kindle_split_010.html#ch01). After
    that, we’ll deal with the more complicated methods necessary to represent the
    tweets data in a simple data visualization. Along the way, you’ll learn how to
    set styles and attributes based on the data bound to the elements and explore
    how D3 creates, removes, and changes elements based on changes in the data.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于可以开始可视化真实数据，而不仅仅是像我们迄今为止所使用的那样未区分的数组了。首先，我们将查看那些美丽的城市（以及弗雷斯诺）的大小，以及如何通过测量推文数据中的推文数量来衡量我们的社交媒体成功，结合本章和第1章（[chapter
    1](../Text/kindle_split_010.html#ch01)）中学到的技术。之后，我们将处理更复杂的方法，以在简单的数据可视化中表示推文数据。在这个过程中，你将学习如何根据绑定到元素的数据设置样式和属性，并探索D3如何根据数据的变化创建、删除和更改元素。
- en: 2.3.1\. Visualization from loaded data
  id: totrans-610
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.1. 从加载的数据进行可视化
- en: A bar chart based on the cities.csv data is straightforward, requiring only
    a scale based on the maximum population value, which we can determine using `d3.max()`,
    as shown in the following listing. This bar chart (shown annotated in [figure
    2.21](#ch02fig21)) shows you the distribution of population sizes of the cities
    in our dataset.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 基于cities.csv数据的条形图很简单，只需要一个基于最大人口值的刻度，我们可以使用`d3.max()`来确定，如下所示。这个条形图（如图2.21所示）展示了我们数据集中城市人口规模的分布。
- en: Figure 2.21\. The cities.csv data drawn as a bar chart using the maximum value
    of the population attribute in the domain setting of the scale
  id: totrans-612
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.21。使用域设置中的最大人口属性值绘制的cities.csv数据条形图
- en: '![](../Images/02fig21.jpg)'
  id: totrans-613
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/02fig21.jpg)'
- en: Listing 2.3\. Loading data, casting it, measuring it, and displaying it as a
    bar chart
  id: totrans-614
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.3\. 加载数据，转换它，测量它，并以条形图显示它
- en: '[PRE76]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '***1* Transforms the population value into an integer**'
  id: totrans-616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将人口值转换为整数**'
- en: Creating a bar chart out of the Twitter data requires a bit more transformation.
    As shown in [listing 2.4](#ch02ex04), we use `d3.nest()` to gather the tweets
    under the person making them, and then use the length of that array to create
    a bar chart of the number of tweets (shown annotated in [figure 2.22](#ch02fig22)).
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 从Twitter数据中创建条形图需要更多的转换。如图[代码列表2.4](#ch02ex04)所示，我们使用`d3.nest()`来收集由发布者创建的推文，然后使用该数组的长度来创建推文数量的条形图（如图2.22所示，已标注）。
- en: Figure 2.22\. By nesting data and counting the objects that are nested, we can
    create a bar chart out of hierarchical data.
  id: totrans-618
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.22\. 通过嵌套数据和计算嵌套的对象数量，我们可以从层次数据中创建条形图。
- en: '![](../Images/02fig22.jpg)'
  id: totrans-619
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/02fig22.jpg)'
- en: Listing 2.4\. Loading, nesting, measuring, and representing data
  id: totrans-620
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.4\. 加载、嵌套、测量和表示数据
- en: '[PRE77]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '***1* Specifies data.tweets, where your data array is located**'
  id: totrans-622
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 指定data.tweets，其中你的数据数组所在**'
- en: '***2* Creates a new attribute based on the number of tweets**'
  id: totrans-623
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 基于推文数量创建新的属性**'
- en: 2.3.2\. Setting channels
  id: totrans-624
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.2\. 设置通道
- en: Up to now we’ve only used the height of a rectangle to correspond to a point
    of data, and in cases where you’re dealing with one piece of quantitative data,
    that’s all you need. That’s why bar charts are so popular in spreadsheet applications.
    But most of the time you’ll use multivariate data, such as census data for counties
    or medical data for patients.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只使用矩形的高度来对应数据点，在处理单一量化数据的情况下，这已经足够了。这就是为什么条形图在电子表格应用中如此受欢迎。但大多数时候，你会使用多元数据，例如县的人口普查数据或患者的医疗数据。
- en: '*Multivariate* is another way of saying that each datapoint has multiple data
    characteristics. For instance, your medical history isn’t a single score between
    0 and 100\. Instead, it consists of multiple measures that explain different aspects
    of your health. In cases with multivariate data like that, you need to develop
    techniques to represent multiple data points in the same shape. The technical
    term for how a shape visually expresses data is *channel*, and depending on the
    data you’re working with, different channels are better suited to express data
    graphically.'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: '*多元变量*是另一种说法，即每个数据点具有多个数据特征。例如，你的医疗历史不是一个介于0到100之间的单一分数。相反，它由多个衡量标准组成，解释了你的健康的不同方面。在具有类似多元数据的情况下，你需要开发技术来表示同一形状中的多个数据点。形状视觉表达数据的术语是*通道*，并且根据你处理的数据，不同的通道更适合图形化地表达数据。 '
- en: '|  |'
  id: totrans-627
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Infoviz term: channels**'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: '**信息可视化术语：通道**'
- en: When you represent data using graphics, you need to consider the best visual
    methods to represent the types of data you’re working with. Each graphical object,
    as well as the whole display, can be broken down into component channels that
    relay information visually. These channels, such as height, width, area, color,
    position, and shape, are particularly well suited to represent different classes
    of information. For instance, if you represent magnitude by changing the size
    of a circle, and if you create a direct correspondence between radius and magnitude,
    then your readers will be confused, because we tend to recognize the area of a
    circle rather than its radius. Channels also exist at multiple levels, and several
    techniques use hue, saturation, and value to represent three different pieces
    of information, rather than using color more generically.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用图形表示数据时，你需要考虑最佳的视觉方法来表示你正在处理的数据类型。每个图形对象，以及整个显示，都可以分解为传达视觉信息的组件通道。这些通道，如高度、宽度、面积、颜色、位置和形状，特别适合表示不同类别的信息。例如，如果你通过改变圆的大小来表示大小，并且如果创建半径和大小之间的直接对应关系，那么你的读者会感到困惑，因为我们倾向于识别圆的面积而不是其半径。通道也存在于多个级别，并且一些技术使用色调、饱和度和值来表示三块不同的信息，而不是更通用地使用颜色。
- en: The important thing here is to avoid using too many channels, and instead focus
    on using the channels most suitable to your data. If you aren’t varying shape,
    for instance, if you’re using a bar chart where all the shapes are rectangles,
    then you can use color for category and value (lightness) to represent magnitude.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 这里重要的是避免使用过多的通道，而是专注于使用最适合你数据的通道。例如，如果你没有改变形状，比如你使用的是所有形状都是矩形的条形图，那么你可以使用颜色来表示类别和值（亮度）以表示大小。
- en: '|  |'
  id: totrans-631
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Going back to the tweets.json data, it may seem like there’s not much data available
    to put on a chart, but depending on what factors we want to measure and display,
    we can take a couple different approaches. Let’s imagine we want to measure the
    impact factor of tweets, treating tweets that are favorited or retweeted as more
    important than tweets that aren’t. This time, instead of a bar chart, we’ll create
    a scatterplot, and instead of using array position to place it along the x-axis,
    let’s use time, because there’s good evidence that tweets made at certain times
    are more likely to be favorited or retweeted. We’ll place each tweet along the
    y-axis using a scale based on the maximum impact factor of our set of tweets.
    From this point on, we’ll focus on the `dataViz()` function as in the following
    listing, because you should be familiar now with getting your data in and sending
    it to such a function.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 tweets.json 数据，可能看起来没有多少数据可以放在图表上，但根据我们想要测量和显示的因素，我们可以采取几种不同的方法。让我们想象我们想要测量推文的影响因子，将点赞或转发的推文视为比未点赞或未转发的推文更重要。这次，我们不会创建条形图，而是创建散点图，并且不是使用数组位置来沿
    x 轴放置它，而是使用时间，因为有很好的证据表明在特定时间发布的推文更有可能被点赞或转发。我们将使用基于我们推文集最大影响因子的刻度沿 y 轴放置每个推文。从现在开始，我们将关注以下列表中的
    `dataViz()` 函数，因为现在你应该熟悉如何将数据输入并发送到这样的函数。
- en: Listing 2.5\. Creating a scatterplot
  id: totrans-633
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.5\. 创建散点图
- en: '[PRE78]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '***1* Creates an impact score by totaling the number of favorites and retweets**'
  id: totrans-635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 通过汇总点赞和转发的次数创建影响分数**'
- en: '***2* Transforms the ISO 8906–compliant string into a date datatype**'
  id: totrans-636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将 ISO 8906–compliant 字符串转换为日期数据类型**'
- en: '***3* Returns the earliest and latest times for a scale**'
  id: totrans-637
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 返回刻度的最早和最晚时间**'
- en: '***4* startEnd is an array**'
  id: totrans-638
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* startEnd 是一个数组**'
- en: '***5* Builds a scale that maps impact to a ramp from white to dark red**'
  id: totrans-639
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 建立一个将影响映射到从白色到深红色的斜坡的刻度**'
- en: '***6* Size, color, and vertical position will all be based on impact**'
  id: totrans-640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 大小、颜色和垂直位置都将基于影响**'
- en: As shown in [figure 2.23](#ch02fig23), each tweet is positioned vertically based
    on impact and horizontally based on time. Each tweet is also sized by impact and
    colored darker red based on impact. Later on we’ll want to use color, size, and
    position for different attributes of the data, but for now we’ll tie most of them
    to impact.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [图 2.23](#ch02fig23) 所示，每个推文根据影响垂直定位，根据时间水平定位。每个推文的大小也根据影响确定，并根据影响以更深的红色着色。稍后，我们将想要使用颜色、大小和位置来表示数据的不同属性，但到目前为止，我们将大多数属性与影响联系起来。
- en: Figure 2.23\. Tweets are represented as circles sized by the total number of
    favorites and retweets and are placed on the canvas along the x-axis based on
    the time of the tweet and along the y-axis according to the same impact factor
    used to size the circles. Two tweets with the same impact factor that were made
    at nearly the same time are shown overlapping at the bottom left.
  id: totrans-642
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.23\. 推文以圆圈表示，圆圈大小根据总的点赞和转发次数确定，并在画布上根据推文的时间沿 x 轴放置，根据与圆圈大小相同的相同影响因子沿 y 轴放置。两个影响因子相同且几乎同时发布的推文在左下角重叠显示。
- en: '![](../Images/02fig23_alt.jpg)'
  id: totrans-643
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/02fig23_alt.jpg)'
- en: 2.3.3\. Enter, update, merge, and exit
  id: totrans-644
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.3\. 输入、更新、合并和退出
- en: You’ve used the `.enter()` behavior of a selection many times already. Now let’s
    take a closer look at it and its counterpart, `.exit()`. Both functions operate
    when a mismatch exists between the number of data values bound to a selection
    and the number of DOM elements in the selection. If more data values exist than
    DOM elements, then `.enter()` fires, whereas if fewer data values exist than DOM
    elements, then `.exit()` fires, as in [figure 2.24](#ch02fig24). You use `selection.enter()`
    to define how you want to create new elements based on the data you’re working
    with, and you use `selection.exit()` to define how you want to remove existing
    elements in a selection when the data that corresponds to them has been deleted.
    Updating data, as you’ll see in the next example, is accomplished through reapplying
    the functions you used to create the graphical elements based on your data.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经多次使用了选择集的 `.enter()` 行为。现在让我们更仔细地看看它及其对应的行为 `.exit()`。这两个函数在绑定到选择集的数据值数量与选择集中的
    DOM 元素数量不匹配时操作。如果数据值多于 DOM 元素，则 `.enter()` 触发，而如果数据值少于 DOM 元素，则 `.exit()` 触发，如[图
    2.24](#ch02fig24) 所示。你使用 `selection.enter()` 来定义你希望根据你正在处理的数据创建新元素的方式，并使用 `selection.exit()`
    来定义当与它们对应的数据被删除时，你希望如何从选择集中删除现有元素。正如你将在下一个示例中看到的，更新数据是通过重新应用你用于根据数据创建图形元素的函数来完成的。
- en: Figure 2.24\. Selections where the number of DOM elements and number of values
    in an array don’t match will fire either an `.enter()` event or an `.exit()` event,
    depending on whether there are more or fewer data values than DOM elements, respectively.
    Update, in contrast, is not a function, and simply refers to when you update the
    data bound to the elements.
  id: totrans-646
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.24\. 当 DOM 元素的数目和数组中的值数目不匹配时，将触发一个 `.enter()` 事件或一个 `.exit()` 事件，具体取决于数据值是否多于或少于
    DOM 元素。相比之下，更新不是一个函数，它仅仅指的是你更新绑定到元素的数据时的情况。
- en: '![](../Images/02fig24.jpg)'
  id: totrans-647
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/02fig24.jpg)'
- en: Each `.enter()` or `.exit()` event can include actions taken on child elements.
    This is mostly useful with `.enter()` events, where you use the `.append()` function
    to add new elements. If you declare this new appended element as a variable, and
    if that element is amenable to child elements, like a `<g>` element is, you can
    include any number of child elements. In the case of SVG elements, only `<svg>`,
    `<g>`, and `<text>` can have child elements, but if you’re using D3 with traditional
    DOM manipulation, you can use this method to add `<p>` elements to `<div>` elements
    and so on.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `.enter()` 或 `.exit()` 事件都可以包括对子元素采取的操作。这主要用于 `.enter()` 事件，其中你使用 `.append()`
    函数添加新元素。如果你将这个新附加的元素声明为变量，并且如果该元素可以包含子元素，就像 `<g>` 元素一样，你可以包含任意数量的子元素。在 SVG 元素的情况下，只有
    `<svg>`、`<g>` 和 `<text>` 可以有子元素，但如果你使用 D3 与传统 DOM 操作一起使用，你可以使用这种方法将 `<p>` 元素添加到
    `<div>` 元素中等。
- en: For example, let’s say we want to show a bar chart based on our newly measured
    impact score, and we want the bars on the bar chart to have labels. We need to
    append `<g>` elements, and not shapes, to the `<svg>` canvas in our initial selection.
    Because the data is bound to these elements, we can use the same syntax when we
    add child elements. Because we’re using `<g>` elements, we need to set the position
    using the `transform` attribute. We add child elements using the `.append()` function,
    and we need to declare the returned selection as a variable `tweetG`. This allows
    `tweetG` to stand in for `d3.select("svg").selectAll("g")` so we don’t have to
    retype it throughout the example. The following listing uses all the same scales
    to determine size and position as the previous example.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想要根据我们新测量的影响分数显示一个条形图，并且我们希望条形图上的条形有标签。我们需要将 `<g>` 元素附加到我们初始选择集中的 `<svg>`
    画布上，而不是形状。因为数据绑定到这些元素上，所以当我们添加子元素时，我们可以使用相同的语法。因为我们使用的是 `<g>` 元素，所以我们需要使用 `transform`
    属性来设置位置。我们使用 `.append()` 函数添加子元素，并且需要将返回的选择集声明为变量 `tweetG`。这使得 `tweetG` 可以代表 `d3.select("svg").selectAll("g")`，这样我们就不必在整个示例中重新输入它。以下列表使用与上一个示例相同的比例来确定大小和位置。
- en: Listing 2.6\. Creating labels on `<g>` elements
  id: totrans-650
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.6\. 在 `<g>` 元素上创建标签
- en: '[PRE79]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '***1* <g> requires a transform, which takes a constructed string**'
  id: totrans-652
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* <g> 需要一个转换，它需要一个构造的字符串***'
- en: '***1* Uses .getHours() to make the label a bit more legible**'
  id: totrans-653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用 .getHours() 使标签更易读***'
- en: In [figure 2.25](#ch02fig25) you can see the result of our code, along with
    some annotation. The same circles in the same position show that `translate` works
    much like changing cx and cy for circles, but now we can add other SVG elements,
    like `<text>` for labels.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 2.25](#ch02fig25) 中，你可以看到我们代码的结果，以及一些注释。相同位置上的相同圆圈表明 `translate` 与更改圆圈的
    cx 和 cy 类似，但现在我们可以添加其他 SVG 元素，如 `<text>` 用于标签。
- en: Figure 2.25\. Each tweet is a `<g>` element with a circle and a label appended
    to it. The various tweets by Roy at 7 A.M. happen so close to each other that
    they’re difficult to label.
  id: totrans-655
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.25。每条推文都是一个带有圆圈和标签的 `<g>` 元素。Roy 在早上 7 点发的各种推文彼此之间非常接近，以至于很难为它们标记。
- en: '![](../Images/02fig25_alt.jpg)'
  id: totrans-656
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.25](../Images/02fig25_alt.jpg)'
- en: The labels are illegible in the bottom left, but they’re not much better for
    the rest. Later on, you’ll learn how to make better labels. The inline functions
    such as `.text(d => d.user + "-" + d.tweetTime.getHours())` set the label to be
    the name of the person making the tweet, followed by a dash, followed by the hour
    of the tweet. These functions all refer to the same data elements, because the
    child elements inherit their parents’ data functions. If one of your data elements
    is an array, you may think you could bind it to a selection on the child element,
    and you’d be right. You’ll see that in the next chapter and later in the book.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 底左边的标签难以辨认，但其余部分也好不到哪里去。稍后，你将学会如何制作更好的标签。内联函数，例如 `.text(d => d.user + "-" +
    d.tweetTime.getHours())`，将标签设置为发推者的名字，后面跟着一个连字符，然后是推文的时刻。这些函数都引用了相同的数据元素，因为子元素继承了父元素的数据函数。如果你的数据元素是一个数组，你可能认为你可以将其绑定到子元素的选取上，你会是对的。你将在下一章以及本书的后续部分看到这一点。
- en: Exit
  id: totrans-658
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 退出
- en: 'Corresponding to the `.append()` function is the `.remove()` function available
    with `.exit()`. To see `.exit()` in action, you need to have some elements in
    the DOM, which could already exist, depending on what you put in your HTML, or
    which could have been added with D3\. Let’s stick with the state that the previous
    code creates, which provides us with ample opportunity to test the `.exit()` function.
    DOM element styles and attributes aren’t updated if we make a change to the array
    unless we call the necessary `.style()` and `.attr()` functions. If we bind any
    array to the existing `<g>` elements in your DOM, then we can use `.exit()` to
    remove them:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `.append()` 函数相对应的是，在 `.exit()` 中可用的 `.remove()` 函数。要看到 `.exit()` 的实际应用，你需要有一些
    DOM 元素，这些元素可能已经存在，这取决于你在 HTML 中放入了什么，或者可能是通过 D3 添加的。让我们继续使用前一段代码创建的状态，这为我们提供了充足的机会来测试
    `.exit()` 函数。如果我们不调用必要的 `.style()` 和 `.attr()` 函数，那么如果我们对数组进行更改，DOM 元素的样式和属性不会更新。如果我们把任何数组绑定到
    DOM 中的现有 `<g>` 元素上，那么我们可以使用 `.exit()` 来移除它们：
- en: '[PRE80]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: This code deleted all but four of our `<g>` elements, because we have only four
    values in our array. In most of the explanations of D3’s `.enter()` and `.exit()`
    behavior, you won’t see this kind of binding of an entirely different array to
    a selection. Instead, you’ll see a rebinding of the initial data array after it’s
    been filtered to represent a change via user interaction or other behavior. You’ll
    see an example like this next, and throughout the book. But it’s important to
    understand the difference between your data, your selection, and your DOM elements.
    The data that’s bound to our DOM elements has been overwritten, so our data-rich
    objects from tweets.csv have now been replaced with boring numbers. But the only
    change to the visual representation is that the number has been reduced to reflect
    the size of the array we’ve bound. D3 doesn’t follow the convention that when
    the data changes, the corresponding display is updated; you need to build that
    functionality yourself. Because it doesn’t follow that convention, it gives you
    greater flexibility that we’ll explore in later chapters.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码删除了我们除四个 `<g>` 元素之外的所有元素，因为我们数组中只有四个值。在大多数关于 D3 的 `.enter()` 和 `.exit()`
    行为的解释中，你不会看到将完全不同的数组绑定到选取上的这种绑定。相反，你将看到在经过过滤以表示用户交互或其他行为的变化后，对初始数据数组的重新绑定。你将在接下来的例子中看到这一点，以及本书的整个过程中。但了解你的数据、你的选取和你的
    DOM 元素之间的区别是很重要的。绑定到我们的 DOM 元素上的数据已被覆盖，因此我们来自 tweets.csv 的数据丰富的对象现在已被无聊的数字所取代。但视觉表示的唯一变化是数字已减少，以反映我们绑定的数组的大小。D3
    不遵循当数据更改时，相应的显示也会更新的惯例；你需要自己构建该功能。因为它不遵循该惯例，所以它为你提供了更大的灵活性，我们将在后面的章节中探讨这一点。
- en: Merge
  id: totrans-662
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 合并
- en: D3v4 introduces a new piece of functionality, `d3.merge()`, which allows you
    to combine two selections so that you can act on them both at the same time. This
    way you can use an `enter` selection to set the attributes of your newly created
    elements and then combine that selection with existing elements so you can operate
    on them all at once.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: D3v4引入了一个新的功能，`d3.merge()`，它允许你合并两个选择集，这样你就可以同时作用于它们。这样，你可以使用`enter`选择集来设置新创建元素的属性，然后将该选择集与现有元素合并，这样你就可以一次性操作所有元素。
- en: Updating
  id: totrans-664
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 更新
- en: 'You can see how the visual attributes of an element can change to reflect changes
    in data by updating the `<text>` elements in each `g` to reflect the newly bound
    data:'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过更新每个`g`中的`<text>`元素来反映新绑定的数据，从而看到元素的可视属性如何改变以反映数据的变化：
- en: '[PRE81]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'We have to `.selectAll()` the parent elements and then subselect the child
    elements to re-initialize the data-binding for the child elements. Whenever you
    bind new data to a selection that utilizes child elements, you’ll need to follow
    this pattern. You can see that, because we didn’t update the `<circle>` elements,
    they still have the old data bound to each element:'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须`.selectAll()`父元素，然后子选择子元素来重新初始化子元素的绑定数据。每次你将新数据绑定到一个使用子元素的选择集时，你都需要遵循这个模式。你可以看到，因为我们没有更新`<circle>`元素，它们仍然绑定到每个元素上的旧数据：
- en: '[PRE82]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '***1* Returns values from the newly bound array**'
  id: totrans-669
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从新绑定的数组返回值**'
- en: '***2* Returns values from the newly bound array, because we used a subselect**'
  id: totrans-670
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 返回新绑定的数组，因为我们使用了子选择**'
- en: '***3* Returns values from the old tweetData array, because we haven’t specified
    overwriting with a subselect**'
  id: totrans-671
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 返回旧的tweetData数组，因为我们没有指定使用子选择进行覆盖**'
- en: The `.exit()` function isn’t intended to be used for binding a new array of
    completely different values like this. Instead, it’s meant to update the page
    based on the removal of elements from the array that’s been bound to the selection.
    But if you plan to do this, you need to specify how the `.data()` function binds
    data to your selected elements. By default, `.data()` binds based on the array
    position of the data value. This means, in the previous example, that the first
    four elements in our selection are maintained and bound to the new data, while
    the rest are subject to the `.exit()` function. In general, though, you don’t
    want to rely on array position as your binding key. Rather, you should use something
    meaningful, such as the value of the data object itself. The key requires a string
    or number, so if you pass a JSON object without using JSON.stringify, it treats
    all objects as `"[object object]"` and only returns one unique value. To manually
    set the binding key, we use the second setting in the `.data()` function and use
    the inline syntax typical in D3.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: '`.exit()`函数并不打算用于绑定一个完全不同的新数组，例如这样。相反，它旨在根据绑定到选择集的数组中元素的删除来更新页面。但如果你打算这样做，你需要指定`.data()`函数如何将数据绑定到你的选择元素上。默认情况下，`.data()`根据数据值的数组位置进行绑定。这意味着，在上一个例子中，我们选择集中的前四个元素被保留并绑定到新数据上，其余的则受`.exit()`函数的影响。然而，通常情况下，你不想依赖于数组位置作为你的绑定键。相反，你应该使用一些有意义的值，例如数据对象本身的值。键需要一个字符串或数字，所以如果你传递一个没有使用`JSON.stringify`的JSON对象，它将所有对象视为`"[object
    object]"`，并且只返回一个唯一值。为了手动设置绑定键，我们在`.data()`函数中使用第二个设置，并使用D3中典型的内联语法。'
- en: Listing 2.7\. Setting the key value in data-binding
  id: totrans-673
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.7\. 在数据绑定中设置键值
- en: '[PRE83]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '***1* We could use any unique attribute as the key but using the entire object
    works if we don’t have a unique value, though we have to stringify it first**'
  id: totrans-675
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 我们可以使用任何唯一的属性作为键，但如果我们没有唯一值，使用整个对象也可以，尽管我们首先需要将其字符串化**'
- en: 'The visual results are the same as our earlier scatterplot with the same settings,
    but now if we filter the array we used for the data, and bind that to the selection,
    we can get to the state shown in [figure 2.26](#ch02fig26) by defining useful
    `.exit()` behavior:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 可视结果与之前相同设置下的散点图相同，但现在如果我们过滤用于数据的数组，并将其绑定到选择集，我们可以通过定义有用的`.exit()`行为来达到[图2.26](#ch02fig26)所示的状态：
- en: Figure 2.26\. All elements corresponding to tweets that were not favorited and
    not retweeted were removed.
  id: totrans-677
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.26\. 所有对应于未收藏且未转发的推文的元素都被移除了。
- en: '![](../Images/02fig26.jpg)'
  id: totrans-678
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/02fig26.jpg)'
- en: '[PRE84]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Using the stringified object won’t work if you change the data in the object,
    because then it no longer corresponds with the original binding string. If you
    plan to do significant changing and updating, you’ll need a unique ID for your
    objects to use as your binding key.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字符串化对象将不会工作，如果你更改对象中的数据，因为那时它不再与原始绑定字符串相对应。如果你计划进行重大的更改和更新，你需要为你的对象提供一个唯一的ID，用作你的绑定键。
- en: 2.4\. Summary
  id: totrans-681
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4. 摘要
- en: Load data from external files in CSV and JSON format using `d3-request` functionality.
  id: totrans-682
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`d3-request`功能从外部文件加载数据，格式为CSV和JSON。
- en: CSV is a much more efficient format that JSON for non-hierarchical data.
  id: totrans-683
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于非层次化数据，CSV比JSON更高效。
- en: Format and transform data using D3 scales and built-in JavaScript functions.
  id: totrans-684
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用D3比例和内置JavaScript函数格式化和转换数据。
- en: Binning data using `scaleQuantile` (or similar binning scales we’ve not looked
    at in this chapter, like `scaleThreshold` and `scaleQuantize`) will allow you
    to transform numerical data into categorical data.
  id: totrans-685
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`scaleQuantile`（或类似的本章中未查看的装箱比例，如`scaleThreshold`和`scaleQuantize`）对数据进行装箱将允许你将数值数据转换为分类数据。
- en: Data-binding and the D3 enter/exit/update pattern allow you to create graphical
    elements based on the attributes of the data.
  id: totrans-686
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据绑定和D3的enter/exit/update模式允许你根据数据的属性创建图形元素。
- en: Subselections will let you create complex graphical objects made of multiple
    shapes using the `<g>` element.
  id: totrans-687
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子选择将允许你使用`<g>`元素创建由多个形状组成的复杂图形对象。
- en: Understanding how to create, change, and move elements using `enter()`, `exit()`,
    and selections is the basis for all the complex D3 functionality you’ll see later.
  id: totrans-688
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解如何使用`enter()`、`exit()`和选择来创建、更改和移动元素是所有你将在后面看到的复杂D3功能的基础。
- en: Chapter 3\. Data-driven design and interaction
  id: totrans-689
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3章. 数据驱动设计和交互
- en: '*This chapter covers*'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Enabling interactivity for graphical elements
  id: totrans-691
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用图形元素的交互性
- en: Working with color effectively
  id: totrans-692
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效使用颜色
- en: Loading traditional HTML for use as pop-ups
  id: totrans-693
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载传统的HTML作为弹出窗口使用
- en: Loading external SVG icons into charts
  id: totrans-694
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将外部SVG图标加载到图表中
- en: D3 creates data visualization elements that are part of your web page. It gives
    you the opportunity to integrate the design of your data visualization with the
    design of your more traditional web elements.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: D3创建的数据可视化元素是网页的一部分。它为你提供了将数据可视化的设计与传统网页元素的设计相结合的机会。
- en: You can and should style content you generate with D3 with all the same CSS
    settings as traditional HTML content. You can easily maintain those styles and
    have a consistent look and feel. This is done by using the same style sheet classes
    for what you create with D3 as the ones you use with your traditional page elements
    when possible, and with thoughtful use of color and interactivity for the graphics
    you create using D3.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用与传统的HTML内容相同的CSS设置来样式化你用D3生成的内容。你可以轻松维护这些样式，并保持一致的外观和感觉。这通过尽可能使用与你在传统页面元素中使用的相同样式表类来实现，以及通过深思熟虑地使用颜色和交互性来创建你用D3创建的图形。
- en: This chapter deals with design broadly speaking, touching not only on graphical
    design but on interaction design, project architecture, and the integration of
    pregenerated content. It highlights the connections between D3 and other methods
    of development, whether we’re identifying libraries typically used alongside D3
    or integrating HTML and SVG resources created using other tools. We can’t cover
    all the principles of design (which isn’t one field, but many). Instead, we’ll
    focus on how to use particular D3 functionality to follow the best practices established
    by design professionals to create a simple data visualization based on the statistics
    associated with the 2014 World Cup, as seen in [figure 3.1](#ch03fig01). If you’re
    not a fan of soccer, or football, pretend it’s the results of the World Dota2
    Finals, or if that’s not your thing, that it’s the 2016 Olympic competitive eating
    event.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 这章从广义上讲设计，不仅涉及图形设计，还涉及交互设计、项目架构和预生成内容的集成。它强调了D3与其他开发方法之间的联系，无论是我们识别通常与D3一起使用的库，还是将使用其他工具创建的HTML和SVG资源集成。我们无法涵盖所有设计原则（这不是一个领域，而是多个领域）。相反，我们将专注于如何使用特定的D3功能来遵循设计专业人士建立的最佳实践，以创建基于与2014年世界杯相关的统计数据的简单数据可视化，如图3.1所示。如果你不是足球或橄榄球的粉丝，就假装它是2014年世界Dota2决赛的结果，或者如果你不喜欢这个，那就把它想象成2016年奥运会的竞技吃食比赛。
- en: Figure 3.1\. This chapter covers loading HTML from an external file and updating
    it ([section 3.3.2](#ch03lev2sec11)), as well as loading external images for icons
    ([section 3.3.1](#ch03lev2sec10)), animating transitions ([section 3.2.2](#ch03lev2sec7)),
    and working with color ([section 3.2.4](#ch03lev2sec9)).
  id: totrans-698
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.1. 本章涵盖了从外部文件加载HTML以及更新它（[第3.3.2节](#ch03lev2sec11)），以及加载外部图片作为图标（[第3.3.1节](#ch03lev2sec10)）、动画过渡（[第3.2.2节](#ch03lev2sec7)）和与颜色（[第3.2.4节](#ch03lev2sec9)）的工作。
- en: '![](../Images/03fig01.jpg)'
  id: totrans-699
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/03fig01.jpg)'
- en: 3.1\. Project architecture
  id: totrans-700
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1. 项目架构
- en: When you create a single web page with an interesting visualization on it, you
    don’t need to think too much about where all your files are going to live. But
    if you build an application that provides multiple points of interaction and different
    states, you should identify the resources that you need and plan your project
    accordingly.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个包含有趣可视化的单个网页时，你不需要过多考虑所有文件将存储在哪里。但如果你构建一个提供多个交互点和不同状态的应用程序，你应该确定所需的资源并相应地规划你的项目。
- en: 3.1.1\. Data
  id: totrans-702
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.1. 数据
- en: 'Your data will tend to come in one of two forms: either dynamically delivered
    via server/API or in static files. If you’re pulling data dynamically from a server
    or API, it’s possible that you’ll have static files as well. A good example of
    this is building maps, where the base data layer (such as a map of countries)
    is from a static file and the dynamic data layer (such as the places where tweets
    are made) comes from a server. For this chapter, we’ll use the file worldcup.csv
    to represent statistics for the 2014 World Cup:'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 你的数据通常会以两种形式之一到来：要么是通过服务器/API动态提供，要么是静态文件。如果你从服务器或API动态获取数据，你可能会同时拥有静态文件。一个很好的例子是构建地图，其中基本数据层（如国家地图）来自静态文件，而动态数据层（如推文发布的地方）来自服务器。对于本章，我们将使用worldcup.csv文件来表示2014年世界杯的统计数据：
- en: '[PRE85]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: That’s a lot of data for each team. We could try to come up with a graphical
    object that encodes all nine data points simultaneously (plus labels), but instead
    we’ll use interactive and dynamic methods to provide access to the data.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个团队来说，这些数据量都很大。我们本可以尝试设计一个图形对象，同时编码所有九个数据点（加上标签），但我们将使用交互式和动态方法来提供数据访问。
- en: 3.1.2\. Resources
  id: totrans-706
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.2. 资源
- en: Pregenerated content, like hand-drawn SVG and HTML components, comes as an external
    file that you’ll need to know how to load. You’ll see examples of these later
    in the chapter. Each file contains enough code to draw the shape or traditional
    DOM elements we’ll add to our page. We’ll spend more time with the contents of
    this folder later in [sections 3.3.2](#ch03lev2sec11) and [3.3.3](#ch03lev2sec12)
    when we deal with loading pregenerated content. In more advanced projects, this
    can take the form of templates or resources that are imported or rolled up into
    your project using more sophisticated methods involving a build process. And once
    you get down that road and start integrating applications like Webpack, the boundary
    between static and dynamic resources becomes much fuzzier. We’ll see some of that
    in [chapter 9](../Text/kindle_split_020.html#ch09) when we integrate D3 and React.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 预生成的内容，如手绘SVG和HTML组件，以外部文件的形式提供，你需要知道如何加载这些文件。你将在本章后面看到这些示例。每个文件都包含了足够多的代码来绘制我们将添加到页面上的形状或传统DOM元素。我们将在[第3.3.2节](#ch03lev2sec11)和[第3.3.3节](#ch03lev2sec12)中花更多时间讨论这个文件夹的内容，当我们处理加载预生成内容时。在更高级的项目中，这可以采取模板或资源的形式，通过更复杂的方法导入或打包到你的项目中，这些方法涉及构建过程。一旦你走上了这条路，并开始集成像Webpack这样的应用程序，静态资源和动态资源之间的界限就会变得模糊得多。当我们在[第9章](../Text/kindle_split_020.html#ch09)中集成D3和React时，我们将看到一些这样的例子。
- en: 3.1.3\. Images
  id: totrans-708
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.3. 图片
- en: Later on in this chapter, we’ll use Portable Network Graphics (PNG) images with
    the flags of each team represented in your dataset. The PNGs are named with the
    same as the teams so that it’s more convenient to reference the images in the
    code, as you’ll see later. Every digital file consists of code, but we think of
    images as fundamentally different. This distinction breaks down when you work
    with SVG and you’re accustomed to treating SVG as static images no different than
    raster formats like JPEG and PNG. If you’re working with SVG images as static
    images and not as code that you want to manipulate in D3 (for instance changing
    the fill or stroke), you should put them in your image directory and keep the
    SVG files that you intend to deal with as code in a separate directory.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将使用便携式网络图形 (PNG) 图片，其中包含你的数据集中每个队伍的旗帜。PNG 的命名与队伍相同，这样在代码中引用图片会更方便，正如你稍后将会看到的。每个数字文件都由代码组成，但我们认为图像在本质上与代码不同。当你使用
    SVG 并习惯于将其视为与 JPEG 和 PNG 这样的光栅格式没有区别的静态图像时，这种区别就会消失。如果你将 SVG 图像作为静态图像处理，而不是作为你想要在
    D3 中操作的代码（例如更改填充或描边），你应该将它们放在你的图像目录中，并将你打算处理的 SVG 文件作为代码保存在单独的目录中。
- en: 3.1.4\. Style sheets
  id: totrans-710
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.4\. 样式表
- en: Although we won’t focus on CSS in this chapter too much, you should be aware
    that you can use CSS preprocessors like LESS for greater functionality, and both
    LESS and the later versions of CSS have support for variables. I won’t be dealing
    with these advanced features in this book, but it’s common to take advantage of
    these features in industry. Instead, we’ll use basic CSS here. Our style sheet
    shown in [listing 3.1](#ch03ex01) has classes for the different states of the
    SVG elements we’re dealing with, including SVG text elements. Remember that regular
    text in CSS uses `color` while SVG `<text>` uses `fill` to set its color.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在这章中不会过多关注 CSS，但你应该知道你可以使用像 LESS 这样的 CSS 预处理器来获得更强大的功能，LESS 和 CSS 的后续版本都支持变量。在这本书中，我不会处理这些高级功能，但在行业中通常可以利用这些功能。相反，我们将在这里使用基本的
    CSS。我们展示的样式表（[列表 3.1](#ch03ex01)）包含了我们所处理的 SVG 元素的不同状态类，包括 SVG 文本元素。记住，CSS 中的常规文本使用
    `color`，而 SVG `<text>` 使用 `fill` 来设置其颜色。
- en: Listing 3.1\. d3ia.css
  id: totrans-712
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.1\. d3ia.css
- en: '[PRE86]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '***1* Remember that svg:text elements use fill to set color, unlike HTML text
    elements that use color**'
  id: totrans-714
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 记住，svg:text 元素使用 fill 来设置颜色，与使用 color 的 HTML 文本元素不同**'
- en: 3.1.5\. External libraries
  id: totrans-715
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.5\. 外部库
- en: For the example in this chapter, we’ll use two more .js files besides d3.min.js,
    which is the minified D3 library. The first is soccerviz.js, where we’ll put the
    functions we’ll build and use in this chapter. The second is colorbrewer.js, which
    is available at [http://d3js.org/colorbrewer.v1.min.js](http://d3js.org/colorbrewer.v1.min.js)
    and provides a set of predefined color palettes that we’ll find useful. You include
    CSS files using the link tag in your HTML header, and the external .js files are
    included with script tags.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的示例，我们将使用两个额外的 .js 文件，除了 d3.min.js（这是压缩后的 D3 库）。第一个是 soccerviz.js，我们将在这里放置我们将在本章中构建和使用的函数。第二个是
    colorbrewer.js，它可在 [http://d3js.org/colorbrewer.v1.min.js](http://d3js.org/colorbrewer.v1.min.js)
    找到，并提供一组预定义的颜色调色板，我们将发现它们很有用。你使用 HTML 头部的链接标签包含 CSS 文件，而外部 .js 文件则使用脚本标签包含。
- en: We reference these files in the much cleaner d3ia_2.html.
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在更干净的 d3ia_2.html 中引用了这些文件。
- en: Listing 3.2\. d3ia_2.html
  id: totrans-718
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.2\. d3ia_2.html
- en: '[PRE87]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The `<body>` has two `<div>` elements, one with the ID `viz` and the other with
    the ID `controls`. Notice that the `<body>` element has an `onload` property that
    runs `create-SoccerViz()`, one of our functions in soccerviz.js (shown in the
    following listing). This loads the data and binds it to create a labeled circle
    for each team. It’s not much, as you can see in [figure 3.2](#ch03fig02), but
    it’s a start.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: '`<body>` 有两个 `<div>` 元素，一个具有 ID `viz`，另一个具有 ID `controls`。请注意，`<body>` 元素有一个
    `onload` 属性，它运行 `create-SoccerViz()`，这是我们在 soccerviz.js 中的一个函数（如下面的列表所示）。这加载数据并将其绑定以创建每个队伍的标记圆圈。正如你在
    [图 3.2](#ch03fig02) 中看到的，这并不多，但这是一个开始。'
- en: Figure 3.2\. Circles and labels created from a CSV representing 2014 World Cup
    statistics.
  id: totrans-721
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.2\. 由代表 2014 年世界杯统计数据的 CSV 创建的圆圈和标签。
- en: '![](../Images/03fig02.jpg)'
  id: totrans-722
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/03fig02.jpg)'
- en: Listing 3.3\. `soccerviz.js`
  id: totrans-723
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.3\. `soccerviz.js`
- en: '[PRE88]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '***1* Loads the data and runs createSoccerViz with the loaded data**'
  id: totrans-725
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 加载数据并使用加载的数据运行 createSoccerViz**'
- en: '***2* Appends a <g> to the <svg> canvas to move it and center its contents
    more easily**'
  id: totrans-726
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在 <svg> 画布上附加一个 <g> 以便更容易移动它并居中其内容**'
- en: '***3* Creates a <g> for each team to add labels or other elements as we get
    more ambitious**'
  id: totrans-727
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 为每个团队创建一个 <g> 元素，以便在需要时添加标签或其他元素**'
- en: '***4* Assigns the selection to a variable to refer to it without typing out
    d3.selectAll() every time**'
  id: totrans-728
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将选择分配给变量，以便在不每次都输入 d3.selectAll() 的情况下引用**'
- en: Although you might write an application entirely with D3 and your own custom
    code, for large-scale maintainable projects you’ll have to integrate more external
    libraries. We’ll only use one of those, colorbrewer.js, which isn’t intimidating.
    The colorbrewer library is a set of arrays of colors, which are useful in information
    visualization and mapping. You’ll see this library in action in [section 3.3.2](#ch03lev2sec11).
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可能完全使用 D3 和你自己的自定义代码编写应用程序，但对于大规模可维护的项目，你将不得不集成更多的外部库。我们只会使用其中之一，colorbrewer.js，它并不令人畏惧。colorbrewer
    库是一组颜色数组，在信息可视化和地图制作中非常有用。你将在 [第 3.3.2 节](#ch03lev2sec11) 中看到这个库的实际应用。
- en: 3.2\. Interactive style and DOM
  id: totrans-730
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2\. 交互式样式和 DOM
- en: Creating interactive data visualization is necessary for your users to deal
    with large and complex datasets. And the key to building interactivity into your
    D3 projects is the use of events, which define behaviors based on user activity.
    After you learn how to make your elements interactive, you’ll need to understand
    D3 transitions, which allow you to animate the change from one color or size to
    another. With that in place, you’ll turn to learning how to make changes to an
    element’s position in the DOM so that you can draw your graphics properly. Finally,
    we’ll look more closely at color, which you’ll use often in response to user interaction.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 创建交互式数据可视化对于用户处理大量和复杂的数据集是必要的。将交互性构建到你的 D3 项目中的关键是使用事件，这些事件基于用户活动定义行为。在你学会如何使元素交互之后，你需要了解
    D3 过渡，它允许你从一个颜色或大小动画到另一个颜色或大小。有了这些，你将转向学习如何更改元素在 DOM 中的位置，以便正确绘制你的图形。最后，我们将更仔细地研究颜色，你将经常在用户交互时使用它。
- en: 3.2.1\. Events
  id: totrans-732
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.1\. 事件
- en: 'To get started, let’s update our visualization to add buttons that change the
    appearance of our graphics to correspond with different data. We could handcode
    the buttons in HTML and tie them to functions as in traditional web development,
    but we can also discover and examine the attributes in the data and create buttons
    dynamically. This has the added benefit of scaling to the data, so that if we
    add more attributes to our dataset, this function automatically creates the necessary
    buttons. Notice how we’re using `Object.keys` on the first element in the data,
    so if you had elements with different kinds of keys, you would have to iterate
    through the whole array:'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始，让我们更新我们的可视化，添加按钮以改变图形的外观，以对应不同的数据。我们可以在 HTML 中手动编写按钮并将它们绑定到函数，就像传统的 Web
    开发一样，但我们也可以发现并检查数据中的属性，并动态地创建按钮。这还有一个额外的优点，即可以扩展到数据，因此如果我们向我们的数据集添加更多属性，这个函数将自动创建必要的按钮。注意我们是如何在数据的第一元素上使用
    `Object.keys` 的，所以如果你有不同类型的键的元素，你将不得不遍历整个数组：
- en: '[PRE89]'
  id: totrans-734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '***1* You should use more descriptive names, but d and i are universally used
    in D3 examples to refer to the data and index position in the inline functions**'
  id: totrans-735
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 你应该使用更具描述性的名称，但在 D3 示例中，d 和 i 是通用的，用于在行内函数中引用数据和索引位置**'
- en: '***2* Builds buttons based on the data that’s numerical—we want all attributes
    except the team and region attributes, which store strings**'
  id: totrans-736
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 根据数值数据构建按钮——我们希望所有属性除了团队和区域属性，这些属性存储字符串**'
- en: '***3* Registers an onclick behavior for each button, with a wrapper that gives
    access to the data that was bound to it when it was created**'
  id: totrans-737
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 为每个按钮注册一个 onclick 行为，其中包含一个包装器，它提供了在创建时绑定到它的数据访问权限**'
- en: '***4* dataKeys consists of an array of attribute names, so the d corresponds
    to one of those names and makes a good button title**'
  id: totrans-738
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* dataKeys 包含一个属性名称数组，因此 d 对应于这些名称之一，并可作为良好的按钮标题**'
- en: '***5* The function each button is calling on click, with the bound data sent
    automatically as the first argument**'
  id: totrans-739
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 每个按钮在点击时调用的函数，以及当按钮创建时自动发送的绑定数据作为第一个参数**'
- en: We use `Object.keys` and pass it one of the objects from our array. The `Object.keys`
    function returns the names of the attributes of an object as an array. We’ve filtered
    this array to remove the `team` and `region` attributes because these have nonnumerical
    data and won’t be suitable for the `buttonClick` functionality we define. Obviously,
    in a larger or more complex system, we’ll want to have more robust methods for
    designating attributes than listing them by hand like this. You’ll see that later
    when we deal with more complex datasets. In this case, we bind this filtered array
    to a selection to create buttons for all the remaining attributes and give the
    buttons labels for each of the attributes, as shown in [figure 3.3](#ch03fig03).
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `Object.keys` 并传递我们数组中的一个对象。`Object.keys` 函数返回对象属性名称的数组。我们已过滤此数组以删除 `team`
    和 `region` 属性，因为这些属性包含非数值数据，并且不适合我们定义的 `buttonClick` 功能。显然，在一个更大或更复杂的系统中，我们希望有更健壮的方法来指定属性，而不是像这样手动列出它们。你将在我们处理更复杂的数据集时看到这一点。在这种情况下，我们将此过滤数组绑定到一个选择中，为所有剩余的属性创建按钮，并为每个属性提供标签，如图[图3.3](#ch03fig03)所示。
- en: Figure 3.3\. Buttons for each numerical attribute are appended to the `controls`
    div behind the `viz` div. When a button is clicked, the code runs `buttonClick`.
  id: totrans-741
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.3. 每个数值属性的按钮附加到 `viz` div 后面的 `controls` div 上。当点击按钮时，代码运行 `buttonClick`。
- en: '![](../Images/03fig03.jpg)'
  id: totrans-742
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/03fig03.jpg)'
- en: 'The `.on` function is a wrapper for the traditional HTML mouse events, and
    accepts `"click"`, `"mouseover"`, `"mouseout"`, and so on. We can also access
    those same events using `.attr`, for example, using `.attr("onclick", "console.log(''click'')")`,
    but notice that we’re passing a string in the same way we’d use traditional HTML.
    There’s a D3-specific reason to use the `.on` function: it sends the bound data
    to the function automatically and in the same format as the anonymous inline functions
    we’ve been using to set style and attribute.'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: '`.on` 函数是传统HTML鼠标事件的包装器，接受 `"click"`、`"mouseover"`、`"mouseout"` 等事件。我们也可以使用
    `.attr` 访问相同的事件，例如，使用 `.attr("onclick", "console.log(''click'')")`，但请注意，我们是以与使用传统HTML相同的方式传递字符串的。使用
    `.on` 函数有一个D3特定的原因：它会自动以与我们在设置样式和属性时使用的匿名内联函数相同的格式将绑定数据发送到函数中。'
- en: We can create buttons based on the attributes of the data and dynamically measure
    the data based on the attribute bound to the button. Then we can resize the circles
    representing each team to reflect the teams with the highest and lowest values
    in each category, as shown in [figure 3.4](#ch03fig04).
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据数据的属性创建按钮，并根据绑定到按钮的属性动态测量数据。然后我们可以调整代表每个团队的圆圈的大小，以反映每个类别中值最高和最低的团队，如图[图3.4](#ch03fig04)所示。
- en: Figure 3.4\. Our initial `buttonClick` function resizes the circles based on
    the numerical value of the associated attribute. The radius of each circle reflects
    the number of goals scored against each team, kept in the `ga` attribute of each
    datapoint.
  id: totrans-745
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.4. 我们的初始 `buttonClick` 函数根据相关属性的数值调整圆圈的大小。每个圆圈的半径反映了每个团队所进的球数，这些球数保存在每个数据点的
    `ga` 属性中。
- en: '![](../Images/03fig04.jpg)'
  id: totrans-746
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/03fig04.jpg)'
- en: 'We can use `.on()` to tie events to any object, so let’s add interactivity
    to the circles by having them indicate whether teams are in the same FIFA region:'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `.on()` 将事件绑定到任何对象，因此让我们通过让它们指示团队是否在同一个FIFA区域来增加圆圈的交互性：
- en: '[PRE90]'
  id: totrans-748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Here you see what some people call an *ifsie*, an inline `if` statement that
    compares the region of each element in the selection to the region of the element
    that you moused over, and if true returns “active” and if false returns “inactive”
    as the class of the circle, with results like those in [figure 3.5](#ch03fig05).
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你看到一些人称之为 *ifsie*，一个内联 `if` 语句，它比较选中元素的区域与鼠标悬停元素的区域，如果为真则返回“active”类，如果为假则返回“inactive”类，就像[图3.5](#ch03fig05)中的结果一样。
- en: Figure 3.5\. The effect of our initial `highlightRegion` selects elements with
    the same region attribute and colors them orange, while coloring gray those that
    aren’t in the same region.
  id: totrans-750
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.5. 我们初始的 `highlightRegion` 选择具有相同区域属性的元素并将它们染成橙色，而将不在同一区域的元素染成灰色。
- en: '![](../Images/03fig05.jpg)'
  id: totrans-751
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/03fig05.jpg)'
- en: 'Restoring the circles to their initial color on `mouseout` is simple enough
    that the function can be declared inline with the `.on` function using a selection’s
    built-in classed method, which allows you to selectively turn on or off classes
    of an element by setting it to true or false:'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 当鼠标移出时将圆圈恢复到其初始颜色很简单，可以使用选择器的内置`classed`方法将函数声明为内联，与`.on`函数一起使用，这允许您通过将其设置为true或false来选择性地打开或关闭元素类：
- en: '[PRE91]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: If you want to define custom event handling, you would use `d3.dispatch`, which
    you’ll see in action in [chapter 9](../Text/kindle_split_020.html#ch09).
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想定义自定义事件处理，您将使用`d3.dispatch`，您将在[第9章](../Text/kindle_split_020.html#ch09)中看到它的实际应用。
- en: 3.2.2\. Graphical transitions
  id: totrans-755
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.2\. 图形过渡
- en: One of the challenges of highly interactive, graphics-rich web pages is to ensure
    that the experience of graphical change isn’t jarring. The instantaneous change
    in size or color that we’ve implemented doesn’t only look clumsy, it can prevent
    a reader from understanding the information we’re trying to relay. To smooth things
    out a bit, I’ll introduce transitions, which you saw briefly at the end of [chapter
    1](../Text/kindle_split_010.html#ch01).
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 高度交互式、图形丰富的网页的一个挑战是确保图形变化的经验不会令人感到突兀。我们实现的尺寸或颜色的即时变化不仅看起来笨拙，还可能阻止读者理解我们试图传达的信息。为了使事情变得稍微平滑一些，我将介绍过渡，您在[第1章](../Text/kindle_split_010.html#ch01)的结尾简要地看到了它。
- en: '*Transitions* are defined for a selection and can be set to occur after a certain
    delay using `delay()` or to occur over a set period of time using `duration()`.
    We can easily implement a transition in our `buttonClick` function:'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: '*过渡*是为选择定义的，可以使用`delay()`设置为在一定的延迟后发生，或者使用`duration()`设置为在设定的时间内发生。我们可以在`buttonClick`函数中轻松实现过渡：'
- en: '[PRE92]'
  id: totrans-758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Now when we click our buttons, the sizes of the circles change, and the change
    is also animated. This isn’t only for show. We’re encoding new data in the size
    of the circle, indicating the change between two datapoints using animation. When
    there was no animation, the reader had to remember if there was a difference between
    the ranking in draws and wins for Germany. Now the reader has an animated indication
    that shows Germany visibly shrink or grow to indicate the difference between these
    two datapoints.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们点击按钮时，圆圈的大小会改变，并且这种变化也是动画化的。这不仅仅是为了展示。我们在圆圈的大小中编码了新的数据，通过动画来表示两个数据点之间的变化。当没有动画时，读者必须记住德国在抽签和胜利排名之间是否有差异。现在读者有一个动画指示，显示德国的可见缩小或增长，以表示这两个数据点之间的差异。
- en: The use of transitions also allows us to delay the change through the `.delay()`
    function. Like the `.duration()` function, `.delay()` is set with the wait in
    milliseconds before implementing the change. Slight delays in the firing of an
    event from an interaction can be useful to improve the legibility of information
    visualization, allowing users a moment to reorient themselves to shift from interaction
    to reading. But long delays will usually be misinterpreted as poor web performance.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 过渡的使用还允许我们通过`.delay()`函数延迟变化。像`.duration()`函数一样，`.delay()`通过在实施变化之前等待的毫秒数来设置。从交互事件中触发事件的轻微延迟可以用来提高信息可视化的可读性，使用户有时间重新定位自己，从交互切换到阅读。但长时间的延迟通常会被误解为网络性能不佳。
- en: 'Why else would you delay the firing of an animation? Delays can also draw attention
    to visual elements when they first appear. By making the elements pulse when they
    arrive onscreen, you let users know that these are dynamic objects and tempt users
    to click or otherwise interact with them. Delays, like duration, can be dynamically
    set based on the bound data for each element. You can use delays with another
    feature: transition chaining. This sets multiple transitions one after another,
    and each is activated after the last transition has finished. If we amend the
    code in `overallTeamViz()` that first appends the `<circle>` elements to our `<g>`
    elements, we can see transitions of the kind that produce the screenshot in [figure
    3.6](#ch03fig06).'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么还要延迟动画的触发？延迟也可以在元素首次出现时吸引注意力。通过在元素到达屏幕时使其脉冲，您让用户知道这些是动态对象，并诱使用户点击或以其他方式与之交互。与持续时间一样，延迟可以根据每个元素的绑定数据动态设置。您可以使用延迟与另一个功能一起使用：过渡链。这会设置多个连续的过渡，每个过渡都在上一个过渡完成后激活。如果我们修改`overallTeamViz()`中的代码，该代码首先将`<circle>`元素追加到我们的`<g>`元素中，我们就可以看到产生[图3.6](#ch03fig06)中截图的那种过渡。
- en: Figure 3.6\. A screenshot of your data visualization in the middle of its initial
    drawing, showing the individual circles growing to an exaggerated size and then
    shrinking to their final size in the order in which they appear in the bound dataset.
  id: totrans-762
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.6。你的数据可视化在初始绘制过程中的截图，显示了单个圆圈按其在绑定数据集中出现的顺序增长到夸张的大小，然后缩小到最终大小。
- en: '![](../Images/03fig06.jpg)'
  id: totrans-763
  prefs: []
  type: TYPE_IMG
  zh: '![图3.6](../Images/03fig06.jpg)'
- en: '[PRE93]'
  id: totrans-764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: This causes a pulse because it uses transition chaining to set one transition,
    followed by a second after the completion of the first. You start by drawing the
    circles with a radius of 0, so they’re invisible. Each element has a delay set
    to its array position `i` times 0.1 seconds (100 ms), after which the transition
    causes the circle to grow to a radius of 40 px. After each circle grows to that
    size, a second transition shrinks the circles to 20 px. The effect, which isn’t
    easy to present with a screenshot, causes the circles to pulse sequentially.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 这会导致一个脉冲，因为它使用过渡链来设置一个过渡，然后在第一个过渡完成后设置第二个。你首先绘制半径为0的圆圈，因此它们是不可见的。每个元素都有一个延迟设置为它的数组位置`i`乘以0.1秒（100毫秒），之后过渡使圆圈增长到40像素的半径。每个圆圈增长到那个大小后，第二个过渡将圆圈缩小到20像素。这种效果，用截图很难展示，导致圆圈依次脉冲。
- en: 3.2.3\. DOM manipulation
  id: totrans-766
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.3。DOM操作
- en: Because these visual elements and buttons are all living in the DOM, it’s important
    to know how to access and work with them both with D3 and using built-in JavaScript
    functionality.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这些视觉元素和按钮都存在于DOM中，所以了解如何使用D3以及内置的JavaScript功能来访问和操作它们是很重要的。
- en: 'Although D3 selections are extremely powerful, you sometimes want to deal specifically
    with the DOM element that’s bound to the data. These DOM elements come with a
    rich set of built-in functionality in JavaScript. Getting access to the actual
    DOM element in the selection can be accomplished in one of two ways:'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然D3选择集非常强大，但有时你希望专门处理绑定到数据的具体DOM元素。这些DOM元素在JavaScript中具有丰富的内置功能。在选择集中获取实际DOM元素可以通过两种方式之一实现：
- en: Using `this` in the inline functions (cannot be used with arrow functions)
  id: totrans-769
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在内联函数中使用`this`（不能与箭头函数一起使用）
- en: Using the `.node()` function
  id: totrans-770
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`.node()`函数
- en: Inline functions always have access to the DOM element along with the datapoint
    and array position of that datapoint in the bound data. The DOM element, in this
    case, is represented by the `this` context within the scope of the function. That
    context isn’t available in arrow functions. We can see it in action using the
    `.each()` function of a selection, which performs the same code for each element
    in a selection. We’ll make a selection of one of our circles and then use `.each()`
    to send `d`, `i`, and `this` to the console to see what each corresponds to (which
    should look similar to the results in [figure 3.7](#ch03fig07)).
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 内联函数始终可以访问DOM元素以及该数据点的数组位置。在这种情况下，DOM元素由函数作用域内的`this`上下文表示。在箭头函数中，这个上下文是不可用的。我们可以通过使用选择集的`.each()`函数来看到它的实际应用，该函数对选择集中的每个元素执行相同的代码。我们将选择我们的一个圆圈，然后使用`.each()`将`d`、`i`和`this`发送到控制台以查看它们各自对应的内容（应该类似于图3.7的结果）。
- en: Figure 3.7\. The console results of inspecting a selected element, which show
    first the datapoint in the selection, then its position in the array, and then
    the SVG element itself.
  id: totrans-772
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.7。检查所选元素的控制台结果，首先显示选择中的数据点，然后是其数组中的位置，最后是SVG元素本身。
- en: '![](../Images/03fig07_alt.jpg)'
  id: totrans-773
  prefs: []
  type: TYPE_IMG
  zh: '![图3.7_alt](../Images/03fig07_alt.jpg)'
- en: '[PRE94]'
  id: totrans-774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Unpacking this a bit, we can see the first thing echoed, `d`, is the data bound
    to the circle, which is a JSON object representing the Netherlands team. The second
    thing echoed, `i`, is the array index position of that object in the selection,
    which in this case is 0 and means that `incomingData[0]` is the Netherlands JSON
    object. The last thing echoed to the console, `this`, is the `<circle>` DOM element
    itself.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 稍微展开来说，我们可以看到首先回显的`d`是绑定到圆圈的数据，它是一个表示荷兰队的JSON对象。第二个回显的`i`是该对象在选择集中的数组索引位置，在这种情况下是0，意味着`incomingData[0]`是荷兰的JSON对象。最后回显到控制台的是`this`，即`<circle>`
    DOM元素本身。
- en: 'We can also access this DOM element using the `.node()` function of a selection:'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用选择集的`.node()`函数来访问这个DOM元素：
- en: '[PRE95]'
  id: totrans-777
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Getting to the DOM element, as shown in [figure 3.8](#ch03fig08), lets you take
    advantage of built-in JavaScript functionality to do things like measure the length
    of a `<path>` element or clone an element. One of the most useful built-in functions
    of nodes when working with SVG is the ability to re-append a child element. Remember
    that SVG has no Z-levels, which means that the drawing order of elements is determined
    by their DOM order. Drawing order is important because you don’t want the graphical
    objects you interact with to look like they’re behind the objects that you don’t
    interact with. To see what this means, let’s first adjust our highlighting function
    so that it increases the size of the label when we mouse over each element, as
    in [figure 3.8](#ch03fig08).
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图3.8](#ch03fig08)所示，到达DOM元素，可以利用内置的JavaScript功能执行诸如测量`<path>`元素长度或克隆元素等操作。当使用SVG时，节点的一个非常有用的内置功能是能够重新追加子元素。记住，SVG没有Z级，这意味着元素的绘制顺序由它们的DOM顺序决定。绘制顺序很重要，因为你不希望你与之交互的图形对象看起来像在你不与之交互的对象后面。为了了解这意味着什么，让我们首先调整我们的高亮函数，以便在鼠标悬停在每个元素上时增加标签的大小，如[图3.8](#ch03fig08)所示。
- en: Figure 3.8\. The results of running the `node` function of a selection in the
    console, which is the DOM element itself—in this case, an SVG `<circle>` element.
  id: totrans-779
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.8\. 在控制台中运行选择集的`node`函数的结果，即DOM元素本身——在这种情况下，一个SVG `<circle>`元素。
- en: '![](../Images/03fig08.jpg)'
  id: totrans-780
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/03fig08.jpg)'
- en: '[PRE96]'
  id: totrans-781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '***1* By turning on “active” class for the <g> that we hover over, we take
    advantage of the “g > text.active” rule in CSS that makes any text elements in
    that <g> increase their font size**'
  id: totrans-782
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 通过为我们悬停的`<g>`元素打开“active”类，我们利用了CSS中的“g > text.active”规则，该规则使得该`<g>`中的任何文本元素增加其字体大小**'
- en: 'Because we’re doing a bit more, we should change the `mouseout` event to point
    to a function, which we’ll call `unHighlight`:'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们做了一些更多的事情，我们应该将`mouseout`事件更改为指向一个函数，我们将称之为`unHighlight`：
- en: '[PRE97]'
  id: totrans-784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: As shown in [figure 3.9](#ch03fig09), Netherlands was appended to the DOM before
    Belgium. As a result, when we increase the size of the graphics associated with
    Netherlands, those graphics remain behind any graphics for Belgium, creating a
    visual artifact that looks unfinished and distracting. We can rectify this by
    re-appending the node to the parent `<g>` during that same highlighting event,
    which results in the label being displayed above the other elements, as shown
    in [figure 3.10](#ch03fig10).
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图3.9](#ch03fig09)所示，荷兰在DOM中先于比利时被追加。因此，当我们增加与荷兰相关的图形大小时，这些图形仍然位于比利时图形的后面，创建了一个看起来不完整且分散注意力的视觉效果。我们可以通过在相同的高亮事件期间重新追加节点到父`<g>`元素来纠正这一点，这将导致标签显示在其他元素之上，如[图3.10](#ch03fig10)所示。
- en: Figure 3.9\. The `<text>` element “Netherlands” is drawn at the same DOM level
    as the parent `<g>`, which, in this case, is behind the element to its right.
  id: totrans-786
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.9\. `<text>`元素“荷兰”与父`<g>`元素在同一DOM级别上绘制，在这种情况下，它位于其右侧元素的后面。
- en: '![](../Images/03fig09.jpg)'
  id: totrans-787
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/03fig09.jpg)'
- en: Figure 3.10\. Re-appending the `<g>` element for Germany to the `<svg>` element
    moves it to the end of that DOM region and therefore it’s drawn above the other
    `<g>` elements.
  id: totrans-788
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.10\. 将德国的`<g>`元素重新追加到`<svg>`元素，将其移动到该DOM区域的末尾，因此它绘制在其他`<g>`元素之上。
- en: '![](../Images/03fig10.jpg)'
  id: totrans-789
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/03fig10.jpg)'
- en: '[PRE98]'
  id: totrans-790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'New in D3v4 are several helper functions to let you bump elements up and down
    in the DOM: `selection.raise` and `selection.lower`. These functions will move
    your selected element to the end of the list of its siblings in the DOM or move
    them to the beginning, respectively. This will have the effect of moving them
    forward or backward onscreen (above or below overlapping sibling elements):'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: D3v4中新增了几个辅助函数，让您可以在DOM中上下移动元素：`selection.raise`和`selection.lower`。这些函数将您的选定元素移动到其DOM兄弟列表的末尾或移动到开头，分别。这将使它们在屏幕上向前或向后移动（在重叠的兄弟元素之上或之下）：
- en: '[PRE99]'
  id: totrans-792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'You’ll see in this example that the `mouseout` event becomes less intuitive
    because the event is attached to the `<g>` element, which includes not only the
    circle but the text as well. As a result, mousing over the circle or the text
    fires the event. When you increase the size of the text, and it overlaps a neighboring
    circle, it doesn’t trigger a `mouseout` event. We’ll get into event propagation
    later, but one thing we can do to easily disable mouse events on elements is set
    the style property `"pointer-events"` of those elements to `"none"` inline or
    in your CSS:'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你会看到`mouseout`事件变得不那么直观，因为事件附加到了`<g>`元素上，它不仅包括圆圈，还包括文本。因此，鼠标悬停在圆圈或文本上都会触发事件。当你增大文本大小，并且它与相邻的圆圈重叠时，它不会触发`mouseout`事件。我们将在后面讨论事件传播，但我们可以通过将元素的`style`属性`"pointer-events"`设置为`"none"`来轻松禁用元素上的鼠标事件：内联或在你的CSS中：
- en: '[PRE100]'
  id: totrans-794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 3.2.4\. Using color wisely
  id: totrans-795
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.4\. 智能使用颜色
- en: 'Color seems like a small and dull subject, but when you’re representing data
    with graphics, color selection is of primary importance. There’s good research
    on the use of color in cognitive science and design, but that’s an entire library.
    Here, we’ll deal with a few fundamental issues: mixing colors in color ramps,
    using discrete colors for categorical data, and designing for accessibility factors
    related to colorblindness. We’re going to see a few strategies that will help
    you deal with deploying color wisely later in the chapter.'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色似乎是一个小而枯燥的主题，但当你用图形表示数据时，颜色选择至关重要。在认知科学和设计方面有关于颜色使用的好研究，但这是一个完整的图书馆。在这里，我们将处理几个基本问题：在颜色渐变中混合颜色，为分类数据使用离散颜色，以及针对色盲相关的可访问性因素进行设计。我们将看到一些策略，这些策略将帮助你在本章后面部分明智地部署颜色。
- en: '|  |'
  id: totrans-797
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Infoviz term: color theory**'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: '**信息可视化术语：色彩理论**'
- en: Artists, scholars, and psychologists have thought critically about the use of
    color for centuries. Among them, Josef Albers—who has influenced modern information
    visualization leaders like Edward Tufte—noted that in the visual realm, one plus
    one can equal three. The study of color, referred to as *color theory*, has proved
    that placing certain colors and shapes next to each other has optical consequences,
    resulting in simultaneous and successive contrast as well as accidental color.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 艺术家、学者和心理学家几个世纪以来一直在批判性地思考颜色的使用。其中，约瑟夫·阿尔伯斯——他影响了现代信息可视化领导者如爱德华·图夫特——指出，在视觉领域，一加一可以等于三。对颜色的研究，被称为*色彩理论*，已经证明将某些颜色和形状放在一起会产生光学效应，导致同时性和连续性对比以及偶然的颜色。
- en: It’s worth studying the properties of color—hue, value, intensity, and temperature—to
    ensure the most harmonious color relationships in your work. Leonardo da Vinci
    organized colors into psychological primaries, the colors the eye sees unmixed,
    but the modern exploration of color theory, as with many other phenomena in physics,
    can be attributed to Newton. Newton observed the separation of sunlight into bands
    of color via a prism in 1666 and called it a *color spectrum*. Newton also devised
    a color circle of seven hues, a precursor to the many future charts of color that
    would organize colors and their relationships. About a century later, J. C. Le
    Blon identified the primary colors as red, yellow, and blue, and their mixes as
    the *secondaries*. The work of other more modern color theoreticians such as Josef
    Albers, who emphasized the effects of color juxtaposition, influences the standards
    for presentation in print and on the web.
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 值得研究颜色的特性——色调、明度、强度和温度，以确保你在工作中达到最和谐的颜色关系。列奥纳多·达·芬奇将颜色组织成心理原色，即眼睛看到的不混合的颜色，但现代对色彩理论的探索，正如物理学中的许多其他现象一样，可以归因于牛顿。牛顿在1666年通过棱镜观察到阳光分解成彩色带，并将其称为*色光谱*。牛顿还设计了一个包含七种色调的颜色圆环，这是未来许多颜色图表的先驱，这些图表将颜色及其关系组织起来。大约一个世纪后，J.
    C. Le Blon将原色识别为红色、黄色和蓝色，并将它们的混合物称为*次级色*。其他更现代的色彩理论家如约瑟夫·阿尔伯斯的工作，他强调了颜色并置的效果，影响了印刷和网页上的展示标准。
- en: '|  |'
  id: totrans-801
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Color is typically represented on the web in red, green, and blue coordinates,
    or RGB, using one of three formats: hex, RGB, or CSS color name. The first two
    represent the same information, the level of red, green, and blue in the color,
    but do so with either hexadecimal or comma-delimited decimal notation. CSS color
    names use vernacular names for its 140 colors (you can read all about them at
    [http://en.wikipedia.org/wiki/Web_colors#X11_color_names](http://en.wikipedia.org/wiki/Web_colors#X11_color_names)).
    Red, for instance, can be represented like this:'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络上，颜色通常使用红色、绿色和蓝色坐标来表示，即RGB，并使用三种格式之一：十六进制、RGB或CSS颜色名称。前两种格式表示相同的信息，即颜色中红色、绿色和蓝色的级别，但使用十六进制或逗号分隔的十进制表示。CSS颜色名称使用140种颜色的通俗名称（你可以在[http://en.wikipedia.org/wiki/Web_colors#X11_color_names](http://en.wikipedia.org/wiki/Web_colors#X11_color_names)上阅读所有关于它们的信息）。例如，红色可以表示如下：
- en: '[PRE101]'
  id: totrans-803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '***1* RGB, or red-green-blue, encoded color**'
  id: totrans-804
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* RGB，或红绿蓝编码颜色**'
- en: '***2* Hex, or hexadecimal, formatted**'
  id: totrans-805
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 十六进制格式**'
- en: '***3* CSS3 web color name**'
  id: totrans-806
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* CSS3 网页颜色名称**'
- en: 'D3 has a few helper functions for working with colors. The first is `d3.rgb()`,
    which allows us to create a more feature-rich color object suitable for data visualization.
    To use `d3.rgb()`, we need to give it the red, green, and blue values of our color:'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: D3提供了一些用于处理颜色的辅助函数。第一个是`d3.rgb()`，它允许我们创建一个功能更丰富的颜色对象，适合数据可视化。要使用`d3.rgb()`，我们需要给它提供颜色的红色、绿色和蓝色值：
- en: '[PRE102]'
  id: totrans-808
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'These color objects have two useful methods: `.darker()` and `.brighter()`.
    They do exactly what you’d expect: return a color that’s darker or brighter than
    the color you started with. In our case, we can replace the gray and red that
    we’ve been using to highlight similar teams with darker and brighter versions
    of pink, the color we started with:'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 这些颜色对象有两个有用的方法：`.darker()`和`.brighter()`。它们确实如你所期望的那样工作：返回一个比起始颜色更暗或更亮的颜色。在我们的例子中，我们可以用我们开始使用的粉红色（较暗和较亮的版本）替换我们用来突出显示类似队伍的灰色和红色：
- en: '[PRE103]'
  id: totrans-810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Notice that you can set the intensity for how much brighter or darker you want
    the color to be. Our new version (shown in [figure 3.11](#ch03fig11)) now maintains
    the palette during highlighting, with darker colors coming to the foreground and
    lighter colors receding. Unfortunately, you lose the ability to style with CSS
    because you’re back to using inline styles. As a rule, you should use CSS whenever
    you can, but if you want access to things like dynamic colors and transparency
    using D3 functions, then you’ll need to use inline styling.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你可以设置颜色的亮度，使其变得更亮或更暗。我们的新版本（如图3.11所示）现在在突出显示时保持调色板，较暗的颜色出现在前景，较亮的颜色则退到背景。不幸的是，你失去了使用CSS样式的功能，因为你又回到了使用内联样式。一般来说，你应该尽可能使用CSS，但如果你想要使用D3函数访问动态颜色和透明度等功能，那么你需要使用内联样式。
- en: Figure 3.11\. Using the darker and brighter functions of a `d3.rgb` object in
    the highlighting function produces a darker version of the set color for teams
    from the same region and lighter colors for teams from different regions.
  id: totrans-812
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.11。在突出显示函数中使用`d3.rgb`对象中的较暗和较亮函数，为同一地区的队伍产生较暗的颜色版本，为不同地区的队伍产生较亮的颜色。
- en: '![](../Images/03fig11.jpg)'
  id: totrans-813
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/03fig11.jpg)'
- en: D3 allows you to represent colors in different color spaces, using `d3.hsl,
    d3.lab`, `d3.cubehelix, d3.hcl` and other non-core color libraries such as `d3.hcg`.
    in other ways with various benefits, but we’ll only deal with HSL, which stands
    for hue, saturation, and lightness. The corresponding `d3.hsl()` allows you to
    create HSL color objects in the same way that you would with `d3.rgb()`. The reason
    you may want to use HSL is to avoid the muddying of colors that can happen when
    you build color ramps and mix colors using D3 functions that are going to use
    RGB by default.
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: D3允许你在不同的颜色空间中表示颜色，使用`d3.hsl`、`d3.lab`、`d3.cubehelix`、`d3.hcl`以及其他非核心颜色库，如`d3.hcg`。以各种方式实现，各有其优点，但我们将只处理HSL，它代表色调、饱和度和亮度。相应的`d3.hsl()`允许你以与`d3.rgb()`相同的方式创建HSL颜色对象。你可能想要使用HSL的原因是避免在构建颜色渐变和混合颜色时，使用默认RGB的D3函数可能会导致的颜色混乱。
- en: Color mixing
  id: totrans-815
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 颜色混合
- en: In [chapter 2](../Text/kindle_split_011.html#ch02), we mapped a color ramp to
    numerical data to generate a spectrum of color representing our datapoints. But
    the interpolated values for colors created by these ramps can be quite poor. As
    a result, a ramp that includes yellow can end up interpolating values that are
    muddy and hard to distinguish. You may think this isn’t important, but when you’re
    using a color ramp to indicate a value and your color ramp doesn’t interpolate
    the color in a way that your reader expects, then you can end up showing wrong
    information to your users. Though we should avoid color ramps, we’re forced to
    use them, whether because of expediency or requirement from users, and so you
    need to know how to deploy them with the least amount of damage to your visualization.
    You would be amazed at how quickly someone can lose confidence in your data visualization
    when the colors aren’t mapping the way they expect.
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](../Text/kindle_split_011.html#ch02)中，我们将颜色渐变映射到数值数据，以生成表示我们的数据点的颜色光谱。但由这些渐变创建的颜色插值值可能相当差。结果，包含黄色的渐变最终可能会插值出模糊且难以区分的值。你可能认为这并不重要，但当你使用颜色渐变来指示值，而你的颜色渐变没有以你的读者预期的这种方式插值颜色时，你可能会向你的用户展示错误的信息。尽管我们应该避免使用颜色渐变，但我们被迫使用它们，无论是由于方便还是用户的需要，因此你需要知道如何以最小的损害来部署它们。你会惊讶于当颜色没有以他们预期的方式映射时，有人会多么快地失去对你数据可视化的信心。
- en: In the next section we’re going to explore how color interpolation works and
    see how interpolating colors along a ramp can have unintended consequences. The
    way you encode color (RGB/Hex, HSL, HCL, LAB) doesn’t matter when it comes to
    a single color—you can get different codes for the same display color. It matters
    when you try to come up with the colors in between. When you’re doing that, different
    interpolation methods will result in different in-between colors, and if you need
    to use a ramp, you can be prepared to use the right interpolation method. Let’s
    add a color ramp to our `button-Click` function and use the color ramp to show
    the same information we did with the radius.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨颜色插值的工作原理，并看看沿着渐变插值颜色可能会产生意想不到的后果。当涉及到单色时，你编码颜色的方式（RGB/Hex，HSL，HCL，LAB）并不重要——你可以为相同的显示颜色获得不同的代码。当你试图找出中间的颜色时，它就很重要了。当你这样做的时候，不同的插值方法会导致不同的中间颜色，如果你需要使用渐变，你可以准备好使用正确的插值方法。让我们在我们的`button-Click`函数中添加一个颜色渐变，并使用颜色渐变来展示我们用半径展示的相同信息。
- en: '[PRE104]'
  id: totrans-818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '***1* This is the same kind of color ramp we built in [chapter 2](../Text/kindle_split_011.html#ch02),
    using the maxValue we calculated for our circle radius scale**'
  id: totrans-819
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 这是我们之前在[第2章](../Text/kindle_split_011.html#ch02)中构建的同一种颜色渐变，使用了我们为圆半径比例计算出的最大值**'
- en: You’d be forgiven if you expected the colors in [figure 3.12](#ch03fig12) to
    range from yellow to green to blue. The problem is that the default interpolator
    in the scale we used is mixing the red, green, and blue channels numerically.
    We can change the interpolator in the scale by designating one specifically, for
    instance, using the HSL representation of color ([figure 3.13](#ch03fig13)) that
    we looked at earlier.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你预期[图3.12](#ch03fig12)中的颜色从黄色到绿色再到蓝色变化，你会感到很正常。问题是我们在使用的比例中的默认插值器正在数值上混合红色、绿色和蓝色通道。我们可以通过指定一个特定的插值器来更改比例中的插值器，例如，使用我们之前查看的颜色的HSL表示（[图3.13](#ch03fig13)）。
- en: Figure 3.12\. Color mixing between yellow and blue in the RGB (red-green-blue)
    scale results in muddy, grayish colors displayed for the values between yellow
    and blue.
  id: totrans-821
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.12\. 在RGB（红-绿-蓝）比例中黄色和蓝色之间的颜色混合导致在黄色和蓝色之间的值显示为模糊、灰色的颜色。
- en: '![](../Images/03fig12_alt.jpg)'
  id: totrans-822
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/03fig12_alt.jpg)'
- en: Figure 3.13\. Interpolation of yellow to blue based on hue, saturation, and
    lightness (HSL) results in a different set of intermediary colors from the same
    two starting values.
  id: totrans-823
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.13\. 基于色调、饱和度和亮度（HSL）将黄色插值到蓝色，从相同的两个起始值产生了不同的一组中间颜色。
- en: '![](../Images/03fig13_alt.jpg)'
  id: totrans-824
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/03fig13_alt.jpg)'
- en: '[PRE105]'
  id: totrans-825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '***1* Setting the interpolation method for a scale is necessary when we don’t
    want it to use its default behavior, such as when we want to create a color scale
    with a method other than interpolating the RGB values**'
  id: totrans-826
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 当我们不希望比例使用其默认行为时，例如当我们想使用除插值RGB值之外的方法创建颜色比例时，设置插值方法对于比例是必要的**'
- en: 'D3 supports two other color interpolators, HCL ([figure 3.14](#ch03fig14))
    and LAB ([figure 3.15](#ch03fig15)), which each deal in a different manner with
    the question of what colors are between blue and yellow. First, the HCL ramp and
    then the LAB ramp:'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: D3 支持两种其他颜色插值器，HCL ([图 3.14](#ch03fig14)) 和 LAB ([图 3.15](#ch03fig15))，它们以不同的方式处理蓝色和黄色之间的颜色问题。首先，是
    HCL 渐变，然后是 LAB 渐变：
- en: Figure 3.14\. Interpolation of color based on hue, chroma, and luminosity (HCL)
    provides a different set of intermediary colors between yellow and blue.
  id: totrans-828
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.14\. 基于色调、饱和度和亮度 (HCL) 的颜色插值在黄色和蓝色之间提供了一组不同的中间颜色。
- en: '![](../Images/03fig14_alt.jpg)'
  id: totrans-829
  prefs: []
  type: TYPE_IMG
  zh: '![图片 3.14](../Images/03fig14_alt.jpg)'
- en: Figure 3.15\. Interpolation of color based on lightness and color-opponent space
    (known as LAB; L stands for lightness and A-B stands for the color-opponent space)
    provides yet another set of intermediary colors between yellow and blue.
  id: totrans-830
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.15\. 基于亮度和对立色空间的颜色插值（称为 LAB；L 代表亮度，A-B 代表对立色空间）在黄色和蓝色之间提供了另一组中间颜色。
- en: '![](../Images/03fig15_alt.jpg)'
  id: totrans-831
  prefs: []
  type: TYPE_IMG
  zh: '![图片 3.15](../Images/03fig15_alt.jpg)'
- en: '[PRE106]'
  id: totrans-832
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Finally, the LAB ramp:'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，是 LAB 渐变：
- en: '[PRE107]'
  id: totrans-834
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: As a general rule, you’ll find that the colors interpolated in RGB tend toward
    muddy and gray, unless you break the color ramp into multiple stops. You can experiment
    with different color ramps or stick to ramps that emphasize hue or saturation
    (by using HSL). Or you can rely on experts by using the built-in D3 functions
    for color ramps that are proven to be easier for a reader to distinguish, which
    we’ll look at now.
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一条一般规则，你会发现 RGB 中插值的颜色往往趋向于泥泞和灰色，除非你将颜色渐变分成多个停止点。你可以尝试不同的颜色渐变，或者坚持使用强调色调或饱和度的渐变（通过使用
    HSL）。或者，你可以依靠内置的 D3 函数来使用颜色渐变，这些渐变已被证明对读者更容易区分，我们现在将探讨这些。
- en: Discrete colors
  id: totrans-836
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 离散颜色
- en: 'Oftentimes, we use color ramps to try to map colors to categorical elements.
    It’s better to use the discrete color scales available in D3 for this purpose.
    The popularity of these scales is the reason why so many D3 examples have the
    same palette. D3 includes four collections of discrete color categories: `d3.schemeCategory10`,
    `d3.schemeCategory20`, `d3.schemeCategory20b`, and `d3.schemeCategory20c`. These
    are arrays of colors meant to be passed to `d3.scaleOrdinal`, which can be used
    to map categorical values to particular colors. In our case, we want to distinguish
    the various regions in our dataset, which consists of the top eight FIFA teams
    from the 2010 World Cup, representing four global regions. We want to represent
    these as different colors, and to do so, we need to create a scale with those
    values in an array:'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们使用颜色渐变来尝试将颜色映射到分类元素。使用 D3 中可用的离散颜色尺度来此目的会更好。这些尺度的流行是许多 D3 示例具有相同调色板的原因。D3
    包含四个离散颜色类别的集合：`d3.schemeCategory10`、`d3.schemeCategory20`、`d3.schemeCategory20b`
    和 `d3.schemeCategory20c`。这些是颜色数组，旨在传递给 `d3.scaleOrdinal`，它可以用来将分类值映射到特定的颜色。在我们的案例中，我们想要区分我们数据集中的各个区域，这些区域由
    2010 年世界杯的前八支 FIFA 队伍组成，代表四个全球区域。我们想要用不同的颜色来表示这些区域，为此，我们需要创建一个包含这些值的数组中的尺度：
- en: '[PRE108]'
  id: totrans-838
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: The application of this scale is visible when we click one of our buttons, which
    now resizes the circles as it always has, but also applies one of these distinct
    colors to each team ([figure 3.16](#ch03fig16)).
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击我们的一个按钮时，这个尺度的应用是可见的，它现在会像以前一样调整圆圈的大小，但也会将这些独特的颜色之一应用到每个队伍上 ([图 3.16](#ch03fig16))。
- en: Figure 3.16\. Application of the `schemeCategory10` to an ordinal scale in D3
    assigns distinct colors to each class applied, in this case, the four regions
    in your dataset.
  id: totrans-840
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.16\. 将 `schemeCategory10` 应用到 D3 中的顺序尺度，为每个应用类别分配独特的颜色，在这种情况下，是数据集中的四个区域。
- en: '![](../Images/03fig16_alt.jpg)'
  id: totrans-841
  prefs: []
  type: TYPE_IMG
  zh: '![图片 3.16](../Images/03fig16_alt.jpg)'
- en: A useful feature of `scaleOrdinal` for situations like these is its `.unknown`
    method, which allows you to return a value when passed a value that doesn’t exist
    within the domain, so that you can color using an “unknown” color like we see
    in [figure 3.17](#ch03fig17) with gray. You don’t always need to use gray as your
    unknown color.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: '`scaleOrdinal` 对于这类情况的一个有用特性是其 `.unknown` 方法，它允许你在传入一个域中不存在的值时返回一个值，这样你就可以使用类似于我们在
    [图 3.17](#ch03fig17) 中看到的灰色“未知”颜色进行着色。你并不总是需要使用灰色作为你的未知颜色。'
- en: Figure 3.17\. Utilizing the `.unknown()` method of an ordinal scale to serve
    back values for data that doesn’t have a corresponding entry in the scale’s domain
  id: totrans-843
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.17\. 利用顺序尺度的 `.unknown()` 方法为没有在尺度域中对应条目的数据返回值
- en: '![](../Images/03fig17_alt.jpg)'
  id: totrans-844
  prefs: []
  type: TYPE_IMG
  zh: '![图片 3.17](../Images/03fig17_alt.jpg)'
- en: '[PRE109]'
  id: totrans-845
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Color ramps for numerical data
  id: totrans-846
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 数值数据的颜色渐变
- en: 'Another option is to use color schemes based on the work of Cynthia Brewer,
    who has led the way in defining effective color use in cartography. Helpfully,
    [d3js.org](http://d3js.org) provides colorbrewer.js and colorbrewer.css for this
    purpose. Each array in colorbrewer.js corresponds to one of Brewer’s color schemes,
    designed for a set number of colors. For instance, the reds scale looks like this:'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是使用基于Cynthia Brewer工作的调色板，她在地图制图中定义有效颜色使用方面开辟了先河。方便的是，[d3js.org](http://d3js.org)为此提供了colorbrewer.js和colorbrewer.css。colorbrewer.js中的每个数组都对应Brewer的一个颜色方案，为一定数量的颜色设计。例如，红色尺度看起来是这样的：
- en: '[PRE110]'
  id: totrans-848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'This provides high-legibility, discrete colors in the red spectrum for our
    elements. Again, we’ll color your circles by region, but this time, we’ll color
    them by their magnitude using our `buttonClick` function. We need to use the quantize
    scale that you saw earlier in [chapter 2](../Text/kindle_split_011.html#ch02),
    because the colorbrewer scales, despite being discrete scales, are designed for
    quantitative data that has been separated into categories. In other words, they’re
    built for numerical data, but numerical data that has been sorted into ranges,
    such as when you break down all the ages of adults in a census into categories
    of 18–35, 36–50, 51–65, and 65+:'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了高可读性的红色光谱中的离散颜色。再次强调，我们将通过区域来着色你的圆圈，但这次，我们将使用`buttonClick`函数根据它们的量级来着色它们。我们需要使用你在第二章中看到的量化尺度，因为尽管colorbrewer尺度是离散尺度，但它们是为定量数据设计的，这些数据已经被分类。换句话说，它们是为数值数据设计的，但这些数值数据已经被排序到范围中，例如，当你将人口普查中所有成年人的所有年龄分解为18-35、36-50、51-65和65+等类别时：
- en: '[PRE111]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '***1* Our new buttonClick function sorts the circles in our visualization into
    three categories with colors associated with them**'
  id: totrans-851
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 我们的新buttonClick函数将我们的可视化中的圆圈按颜色分类成三个类别**'
- en: '***2* The quantize scale sorts the numerical data into as many categories as
    there are in the range. Because colorbrewer.Reds[3] is an array of three values,
    the dataset is sorted into three discrete categories, and each category has a
    different shade of red assigned**'
  id: totrans-852
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 量化尺度将数值数据排序成与范围中类别数量一样多的类别。因为colorbrewer.Reds[3]是一个包含三个值的数组，所以数据集被排序成三个离散类别，每个类别分配了不同色调的红色**'
- en: One of the conveniences of using colorbrewer.js dynamically paired to a quantizing
    scale is that if we adjust the number of colors—for instance, from `colorbrewer.Reds[3]`
    (shown in [figure 3.18](#ch03fig18)) to `colorbrewer.Reds[5]`—the range of numerical
    data is represented with five colors instead of three.
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 使用colorbrewer.js动态配对的量化尺度的一个便利之处在于，如果我们调整颜色的数量——例如，从`colorbrewer.Reds[3]`（如图3.18所示）到`colorbrewer.Reds[5]`——数值数据的范围将用五种颜色而不是三种颜色来表示。
- en: Figure 3.18\. Automatic quantizing linked with the ColorBrewer 3-red scale produces
    distinct visual categories in the red family.
  id: totrans-854
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.18. 与ColorBrewer 3-red尺度自动关联的量化产生红色家族中的不同视觉类别。
- en: '![](../Images/03fig18_alt.jpg)'
  id: totrans-855
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/03fig18_alt.jpg)'
- en: Color is important, and it can behave strangely on the web. Colorblindness,
    for instance, is a key accessibility issue that most of the colorbrewer scales
    address. But even though color use and deployment is complex, smart people have
    been thinking about color for a while, and D3 takes advantage of that. I’ve given
    you several of the tools you need to be successful with color, but the most important
    key to success with color is to not simply ignore it or pretend it to be something
    that’s either too hard or already solved.
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色很重要，它在网页上可能会表现得有些奇怪。例如，色盲是一个关键的易用性问题，大多数colorbrewer尺度都解决了这个问题。尽管颜色使用和部署很复杂，但聪明的人已经思考颜色有一段时间了，D3正是利用了这一点。我已经给了你一些你需要成功使用颜色的工具，但成功使用颜色的最重要的关键不是简单地忽略它或假装它太难或已经解决了。
- en: 3.3\. Pregenerated content
  id: totrans-857
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3. 预生成内容
- en: It’s neither fun nor smart to create all your HTML elements using D3 syntax
    with nested selections and appending. More importantly, there’s an entire ecosystem
    of tools out there for creating HTML, SVG, and static images that you’d be foolish
    to ignore because you’re using D3 for your general DOM manipulation and information
    visualization. Fortunately, it’s straightforward and easy to load externally generated
    resources—like images, HTML fragments, and pregenerated SVG—and tie them into
    your graphical elements.
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 D3 语法和嵌套选择来创建所有 HTML 元素既不有趣也不明智。更重要的是，还有一套完整的工具生态系统用于创建 HTML、SVG 和静态图像，如果你因为使用
    D3 进行通用 DOM 操作和信息可视化而忽视它们，那就太愚蠢了。幸运的是，加载外部生成的资源（如图像、HTML 片段和预生成的 SVG）并将其与你的图形元素关联起来既简单又容易。
- en: 3.3.1\. Images
  id: totrans-859
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.1. 图像
- en: '[Chapter 1](../Text/kindle_split_010.html#ch01) noted that GIFs, despite their
    resurgent popularity, aren’t useful for a rich interactive site. But that doesn’t
    mean you should get rid of images entirely. You’ll find that adding images to
    your data visualizations can vastly improve them. In SVG, the image element is
    `<image>`, and its source is defined using the `xlink:href` attribute if it’s
    located in your directory structure. Another way to work with images is to use
    HTML5 Canvas, which you can see in [chapter 11](../Text/kindle_split_022.html#ch11).'
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: '[第一章](../Text/kindle_split_010.html#ch01) 指出，尽管 GIF 图像重新获得了人气，但它们并不适合用于丰富的交互式网站。但这并不意味着你应该完全放弃图像。你会发现，将图像添加到你的数据可视化中可以极大地改善它们。在
    SVG 中，图像元素是 `<image>`，如果它位于你的目录结构中，其源是通过 `xlink:href` 属性定义的。处理图像的另一种方法是使用 HTML5
    Canvas，你可以在[第 11 章](../Text/kindle_split_022.html#ch11)中看到它。'
- en: 'We have files in our images directory that are PNGs of the respective flags
    of each national team. To add them to our data visualization, select the `<g>`
    elements that have the team data already bound to them and add an SVG image:'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的图像目录中，有每个国家队相应国旗的 PNG 文件。要将它们添加到我们的数据可视化中，选择已经绑定团队数据的 `<g>` 元素，并添加 SVG 图像：
- en: '[PRE112]'
  id: totrans-862
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: To make the images show up successfully, use `insert()` instead of `append()`
    because that gives you the capacity to tell D3 to insert the images before the
    text elements. This keeps the labels from being drawn behind the newly added images.
    Because each image name is the same as the team name of each data point, we can
    use an inline function to point to that value, combined with strings for the directory
    and file extension. We also need to define the height and width of the images
    because SVG images, by default, have no setting for height and width and won’t
    display until these are set. We also need to manually center SVG images—here the
    `x` and `y` attributes are set to a negative value of one-half the respective
    height and width, which centers the images in their respective circles, as shown
    in [figure 3.19](#ch03fig19).
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功显示图像，使用 `insert()` 而不是 `append()`，因为这让你有机会告诉 D3 在文本元素之前插入图像。这可以防止标签被绘制在新增图像的后面。因为每个图像名称与每个数据点的国家队名称相同，我们可以使用内联函数指向该值，并结合目录和文件扩展名的字符串。我们还需要定义图像的高度和宽度，因为
    SVG 图像默认没有高度和宽度的设置，并且直到这些设置被设置之前不会显示。我们还需要手动居中 SVG 图像——在这里，`x` 和 `y` 属性被设置为相应高度和宽度的一半的负值，这样图像就可以在其各自的圆圈中居中，如图
    3.19 所示。
- en: Figure 3.19\. Our graphical representations of each team now include a small
    PNG national flag, downloaded from Wikipedia and loaded using an SVG `<image>`
    element.
  id: totrans-864
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.19。我们每个团队的图形表示现在包括一个小 PNG 国家国旗，从维基百科下载并使用 SVG `<image>` 元素加载。
- en: '![](../Images/03fig19_alt.jpg)'
  id: totrans-865
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/03fig19_alt.jpg)'
- en: You can tie image resizing to the button events, but raster images don’t resize
    particularly well, and so you’ll want to use them at fixed sizes.
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将图像缩放与按钮事件相关联，但位图图像的缩放效果并不好，因此你希望使用固定大小。
- en: '|  |'
  id: totrans-867
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Infoviz term: chartjunk**'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: '**信息可视化术语：图表垃圾**'
- en: Now that you’re learning how to add images and icons to everything, let’s remember
    that because you *can* do something doesn’t mean you *should*. When building information
    visualization, the key aesthetic principle is to avoid cluttering your charts
    and interfaces with distracting and useless “chartjunk,” such as unnecessary icons,
    decoration, or skeuomorphic paneling. Remember, simplicity is force.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你正在学习如何将图像和图标添加到一切事物中，让我们记住，因为你 *可以* 做某事并不意味着你 *应该* 做那件事。在构建信息可视化时，关键的美学原则是避免在图表和界面上添加分散注意力和无用的“图表垃圾”，例如不必要的图标、装饰或拟物化面板。记住，简洁是力量。
- en: The term *chartjunk* comes from Tufte, and in general refers to the kind of
    generic and useless clip art that typifies PowerPoint presentations. Although
    icons and images are useful and powerful in many situations, and thus shouldn’t
    be avoided only to maintain an austere appearance, you should always make sure
    that your graphical representations of data are as uncluttered as you can make
    them.
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 术语 *chartjunk* 来自 Tufte，通常指的是典型的 PowerPoint 演示中那种通用且无用的剪贴画。尽管图标和图像在许多情况下都是有用的和强大的，因此不应该仅仅为了保持简朴的外观而避免使用，但您应该始终确保您的数据图形表示尽可能简洁。
- en: '|  |'
  id: totrans-871
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 3.3.2\. HTML fragments
  id: totrans-872
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.2\. HTML 片段
- en: We’ve created traditional DOM elements in this chapter using D3 data-binding
    for our buttons. If you want to, you can use the D3 pattern of selecting and appending
    to create complex HTML objects, such as forms and tables, on the fly. You’ll likely
    be working with designers and other developers who want to use those tools and
    require that those HTML components be included in your application. This isn’t
    a common practice, because most HTML generation is going to be handled by other
    templating libraries or frameworks, but you can use D3 to import and add them.
    For instance, let’s build a dialog box into which we can put the numbers associated
    with the teams. Say we want to see the stats on our teams—one of the best ways
    to do this is to have a dialog box that pops up as you click each team. We can
    write only the HTML we need for the table itself in a separate file, as shown
    in the following listing.
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用 D3 数据绑定创建了传统的 DOM 元素，用于我们的按钮。如果您愿意，您可以使用 D3 的选择和附加模式动态创建复杂的 HTML 对象，例如表单和表格。您可能会与想要使用这些工具并要求这些
    HTML 组件包含在您的应用程序中的设计师和其他开发者合作。这不是一种常见的做法，因为大多数 HTML 生成将由其他模板库或框架处理，但您可以使用 D3 导入并添加它们。例如，让我们构建一个对话框，我们可以将与之相关的数字放入其中。假设我们想查看我们团队的统计数据——做到这一点的一个最好的方法是在点击每个团队时弹出一个对话框。我们可以在一个单独的文件中仅编写所需的表格
    HTML 代码，如下所示。
- en: Listing 3.4\. infobox.html
  id: totrans-874
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.4\. infobox.html
- en: '[PRE113]'
  id: totrans-875
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: And now we’ll add CSS rules for the table and the div that we want to put it
    in. As you see in the following listing, we can use the `position` and `z-index`
    CSS styles because this is a traditional DOM element.
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将添加表格和我们要放入其中的 div 的 CSS 规则。如您在以下列表中看到的那样，我们可以使用 `position` 和 `z-index`
    CSS 样式，因为这是一个传统的 DOM 元素。
- en: Listing 3.5\. Update to d3ia.css
  id: totrans-877
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.5\. d3ia.css 的更新
- en: '[PRE114]'
  id: totrans-878
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Now that we have the table, all we need to do is add a click listener and associated
    function to populate this dialog, as well as a function to create a div with ID
    `"infobox"` into which we add the loaded HTML code using the `.html()` function.
    To do this we use `d3.text` to load the raw text of the file:'
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了表格，我们只需要添加一个点击监听器和相关函数来填充这个对话框，以及一个创建具有 ID `"infobox"` 的新 div 的函数，我们将使用
    `.html()` 函数将加载的 HTML 代码添加到其中。为此，我们使用 `d3.text` 来加载文件的原始文本：
- en: '[PRE115]'
  id: totrans-880
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '***1* Creates a new div with an id corresponding to one in our CSS, and populates
    it with HTML content from infobox.html**'
  id: totrans-881
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建一个新的 div，其 ID 与我们的 CSS 中的一个相匹配，并用 infobox.html 中的 HTML 内容填充**'
- en: '***2* You could also simply use Object.values if you’re developing for browsers
    that support this functionality**'
  id: totrans-882
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 如果您正在为支持此功能的浏览器开发，您也可以简单地使用 Object.values**'
- en: '***3* Selects and updates the td.data elements with the values of the team
    clicked**'
  id: totrans-883
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 选择并更新被点击的团队 td.data 元素**'
- en: The results are immediately apparent when you reload the page. A div with the
    defined table in infobox.html is created, and when you click it, it populates
    the div with values from the data bound to the element you click ([figure 3.20](#ch03fig20)).
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 当您重新加载页面时，结果立即显现。在 infobox.html 中创建了一个具有定义的表格的 div，当您点击它时，它会用绑定到您点击的元素的数据值填充该
    div ([图 3.20](#ch03fig20))。
- en: Figure 3.20\. The infobox is styled based on the defined style in CSS. It’s
    created by loading the HTML data from infobox.html and adding it to the content
    of a newly created div.
  id: totrans-885
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.20\. infobox 是基于 CSS 中定义的样式进行样式的。它是通过从 infobox.html 加载 HTML 数据并将其添加到新创建的
    div 的内容中创建的。
- en: '![](../Images/03fig20.jpg)'
  id: totrans-886
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/03fig20.jpg)'
- en: We used `d3.text()` in this case because when working with HTML, it can be more
    convenoient to load the raw HTML code like this and drop it into the `.html()`
    function of a selected element that you’ve created. If you use `d3.html()`,you
    get HTML nodes that allow you to do more sophisticated manipulation, which you’ll
    see now as we work with pregenerated SVG.
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用了 `d3.text()`，因为在处理 HTML 时，加载原始 HTML 代码并将其放入你创建的选定元素的 `.html()` 函数中会更方便。如果你使用
    `d3.html()`，你会得到 HTML 节点，这允许你进行更复杂的操作，你现在将看到，当我们处理预先生成的 SVG 时。
- en: 3.3.3\. Pregenerated SVG
  id: totrans-888
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.3. 预生成的 SVG
- en: SVG has been around for a while, and there are, not surprisingly, robust tools
    for drawing SVG, such as Adobe Illustrator and the open source tool Inkscape.
    You might want pregenerated SVG for icons, interface elements, and other components
    of your work. If you’re interested in icons, The Noun Project ([http://thenounproject.com](http://thenounproject.com))
    has an extensive repository of SVG icons, including the football (soccer ball)
    in [figure 3.21](#ch03fig21).
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: SVG 已经存在了一段时间，并且不出所料，有强大的工具可以绘制 SVG，例如 Adobe Illustrator 和开源工具 Inkscape。你可能想要预先生成的
    SVG 用于图标、界面元素和工作中其他组件。如果你对图标感兴趣，The Noun Project ([http://thenounproject.com](http://thenounproject.com))
    拥有丰富的 SVG 图标库，包括图 3.21 中的足球（足球球）。
- en: Figure 3.21\. An icon for a soccer ball created by James Zamyslianskyj and available
    at [http://thenounproject.com/term/football/1907/](http://thenounproject.com/term/football/1907/)
    from The Noun Project
  id: totrans-890
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.21. 由 James Zamyslianskyj 创建的足球图标，可在 [http://thenounproject.com/term/football/1907/](http://thenounproject.com/term/football/1907/)
    从 The Noun Project 获取
- en: '![](../Images/03fig21.jpg)'
  id: totrans-891
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/03fig21.jpg)'
- en: 'When you download an icon from The Noun Project, you get it in two forms: SVG
    and PNG. You’ve already learned how to reference images, and you can do the same
    with SVG by pointing the `xlink:href` attribute of an `<image>` element at an
    SVG file. But loading SVG directly into the DOM gives you the capacity to manipulate
    it like any SVG elements that you create in the browser with D3.'
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从 The Noun Project 下载图标时，你将得到两种形式：SVG 和 PNG。你已经学会了如何引用图像，并且你可以通过将 `<image>`
    元素的 `xlink:href` 属性指向 SVG 文件来以相同的方式处理 SVG。但是，将 SVG 直接加载到 DOM 中会给你提供像在浏览器中使用 D3
    创建的任何 SVG 元素一样操作它的能力。
- en: Let’s say we decide to replace our boring circles with balls, and we don’t want
    them to be static images because we want the ability to modify their color and
    shape like other SVG. In that case, we’ll need to find a suitable ball icon and
    download it. For downloads from The Noun Project, this means we’ll need to go
    through the hassle of creating an account, and we’ll need to properly attribute
    the creator of the icon or pay a fee to use the icon without attribution (not
    a hassle, but rather The Right Thing To Do™). Regardless of where we get our icon,
    we might need to modify it before using it in our data visualization. In the case
    of the soccer ball icon in this example, we need to make it smaller and center
    the icon on the 0,0 point of the canvas. This kind of preparation is going to
    be different for every icon, depending on how it was originally drawn and saved.
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们决定用球体来替换我们无聊的圆形，并且我们不希望它们是静态的图片，因为我们想要像其他 SVG 一样修改它们的颜色和形状。在这种情况下，我们需要找到一个合适的球体图标并下载它。对于从
    The Noun Project 下载，这意味着我们需要通过创建账户来麻烦一番，并且我们需要正确地注明图标的创作者或者支付费用以无归属地使用图标（这不是麻烦，而是正确的事情™）。无论我们从哪里获取图标，我们可能在使用它进行数据可视化之前需要对其进行修改。以这个例子中的足球图标为例，我们需要将其缩小并使图标居中在画布的
    0,0 点。这种准备对于每个图标来说都是不同的，这取决于它最初是如何绘制和保存的。
- en: With the table in the dialog box we used earlier, we assumed that we pulled
    in all the code found in infobox.html, and so we could bring it in using `d3.text()`
    and drop the raw HTML as text into the `.html()` function of a selection. But
    in the case of SVG, especially SVG that you’ve downloaded, you often want to ignore
    the verbose settings in the document, which will include its own `<svg>` canvas
    as well as any `<g>` elements that have been not-so-helpfully added. You probably
    want to deal only with the graphical elements. With our soccer ball, we want to
    get only the `<path>` elements. If we load the file using `d3.html()`,the results
    are DOM nodes loaded into a document fragment that we can access and move around
    using D3 selection syntax. Using `d3.html()` is the same as using any of the other
    loading functions, where you designate the file to be loaded and the callback.
    You can see the results of this command in [figure 3.22](#ch03fig22).
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们之前在对话框中使用的表格，我们假设我们拉入了infobox.html中找到的所有代码，因此我们可以使用 `d3.text()` 将其拉入，并将原始HTML作为文本放入选择集的
    `.html()` 函数中。但就SVG而言，尤其是你下载的SVG，你通常希望忽略文档中的冗长设置，这将包括其自己的 `<svg>` 画布以及任何不是很有帮助地添加的
    `<g>` 元素。你可能只想处理图形元素。对于我们的足球，我们只想获取 `<path>` 元素。如果我们使用 `d3.html()` 加载文件，结果是将DOM节点加载到文档片段中，我们可以使用D3选择语法访问和移动它们。使用
    `d3.html()` 与使用其他任何加载函数相同，其中你指定要加载的文件和回调。你可以看到此命令的结果在[图3.22](#ch03fig22)中。
- en: Figure 3.22\. An SVG loaded using `d3.html()` that was created in Inkscape.
    It consists not only of the graphical `<path>` elements that make up the SVG but
    also much data that’s often extraneous.
  id: totrans-895
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.22\. 使用 `d3.html()` 加载的SVG，该SVG是在Inkscape中创建的。它不仅包含构成SVG的图形 `<path>` 元素，还包含许多通常无关的数据。
- en: '![](../Images/03fig22_alt.jpg)'
  id: totrans-896
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/03fig22_alt.jpg)'
- en: '[PRE116]'
  id: totrans-897
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'After we load the SVG into the fragment, we can loop through the fragment to
    get all the paths easily using the `.empty()` function of a selection. The `.empty()`
    function checks to see if a selection still has any elements inside it and eventually
    fires `true` after we’ve moved the paths out of the fragment into our main SVG.
    By including `.empty()` in a `while` statement, we can move all the path elements
    out of the document fragment and load them directly onto the SVG canvas:'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将SVG加载到片段中之后，我们可以通过选择集的 `.empty()` 函数来遍历片段，轻松地获取所有路径。`.empty()` 函数检查选择集内部是否还有任何元素，并在我们将路径从片段移动到主SVG后最终触发
    `true`。通过在 `while` 语句中包含 `.empty()`，我们可以将所有路径元素从文档片段中移出，并直接将它们加载到SVG画布上：
- en: '[PRE117]'
  id: totrans-899
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '***1* The data variable will automatically be passed to loadSVG().**'
  id: totrans-900
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 数据变量将自动传递给 loadSVG() 函数。**'
- en: Notice how we’ve added a `transform` attribute to offset the paths so that they
    won’t be clipped in the top-right corner. Instead, you clearly see a soccer ball
    in the top corner of your `<svg>` canvas. Document fragments aren’t a normal part
    of your DOM, so you don’t have to worry about accidentally selecting the `<svg>`
    canvas in the document fragment, or any other elements.
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何添加了一个 `transform` 属性来偏移路径，这样它们就不会在右上角被裁剪。相反，你可以在 `<svg>` 画布的右上角清楚地看到一个足球。文档片段不是DOM的正常部分，所以你不必担心意外选择文档片段中的
    `<svg>` 画布或任何其他元素。
- en: 'A `while` loop like this is sometimes necessary, but typically the best and
    most efficient method is to use `.each()` with your selection. Remember, `.each()`
    runs the same code on every element of a selection. In this case, we want to select
    our `<svg>` canvas and append the path to that canvas:'
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的 `while` 循环有时是必要的，但通常最好的、最有效的方法是使用 `.each()` 与你的选择集。记住，`.each()` 在选择集的每个元素上运行相同的代码。在这种情况下，我们想要选择我们的
    `<svg>` 画布并将路径附加到该画布：
- en: '[PRE118]'
  id: totrans-903
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: We end up with a soccer ball floating in the top-left corner of our canvas,
    as shown in [figure 3.23](#ch03fig23).
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终在画布的左上角得到一个悬浮的足球，如图[图3.23](#ch03fig23)所示。
- en: Figure 3.23\. A hand-drawn soccer ball icon is loaded onto the `<svg>` canvas,
    along with the other SVG and HTML elements we created in our code.
  id: totrans-905
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.23\. 一个手绘的足球图标被加载到 `<svg>` 画布上，以及我们在代码中创建的其他SVG和HTML元素。
- en: '![](../Images/03fig23.jpg)'
  id: totrans-906
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/03fig23.jpg)'
- en: 'Loading elements from external data sources like this is useful if you want
    to move individual nodes out of your loaded document fragment, but if you want
    to bind the externally loaded SVG elements to data, it’s an added step that you
    can skip. We can’t set the `.html()` of a `<g>` element to the text of our incoming
    elements like we did with the `<div>` when we populated it with the contents of
    infobox.html. That’s because SVG doesn’t have a corresponding property to `innerHTML`,
    and therefore the `.html()` function on a selection of SVG elements has no effect.
    Instead, we have to clone the paths and append them to each `<g>` element representing
    our teams:'
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 从外部数据源加载元素，如本例所示，如果你想要将单个节点从加载的文档片段中移出，这很有用，但如果你想要将外部加载的 SVG 元素绑定到数据，这是一个可以跳过的额外步骤。我们不能像用
    infobox.html 的内容填充 `<div>` 时那样设置 `<g>` 元素的 `.html()`，因为 SVG 没有与 `innerHTML` 对应的属性，因此
    SVG 元素选择上的 `.html()` 函数没有效果。相反，我们必须克隆路径并将它们附加到代表我们球队的每个 `<g>` 元素上：
- en: '[PRE119]'
  id: totrans-908
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '***1* Note that we can’t use arrow functions here because we need to have access
    to this context within the selection that corresponds to the DOM node**'
  id: totrans-909
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 注意，我们在这里不能使用箭头函数，因为我们需要在这个选择中访问与 DOM 节点对应的上下文**'
- en: It may seem backwards to select each `<g>` and then select each loaded `<path>`,
    until you think about how `.cloneNode()` and `.appendChild()` work. We need to
    take each `<g>` element and go through the `<path>-`cloning process for every
    path in the loaded icon, which means we use nested `.each()` statements (one for
    each `<g>` element in our DOM and one for each `<path>` element in the icon).
    By setting `gParent` to the actual `<g>` node (the `this` variable), we can then
    append a cloned version of each path in order. The results are soccer balls for
    each team, as shown in [figure 3.24](#ch03fig24).
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 在你思考了 `.cloneNode()` 和 `.appendChild()` 的工作原理之后，选择每个 `<g>` 元素然后选择每个加载的 `<path>`
    元素可能看起来有些反直觉。我们需要对每个 `<g>` 元素进行处理，并对加载的图标中的每个路径执行 `<path>-` 克隆过程，这意味着我们使用嵌套的 `.each()`
    语句（一个用于我们的 DOM 中的每个 `<g>` 元素，一个用于图标中的每个 `<path>` 元素）。通过将 `gParent` 设置为实际的 `<g>`
    节点（`this` 变量），我们就可以按顺序附加每个路径的克隆版本。结果是为每个球队生成足球图标，如图 3.24 所示。
- en: Figure 3.24\. Each `<g>` element has its own set of paths cloned as child nodes,
    resulting in soccer ball icons overlaid on each element.
  id: totrans-911
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.24\. 每个 `<g>` 元素都有自己的路径集，作为子节点克隆，从而在每个元素上叠加足球图标。
- en: '![](../Images/03fig24.jpg)'
  id: totrans-912
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/03fig24.jpg)'
- en: We can easily do the same thing using the `<image>` syntax from the first example
    in this section, but with our SVG elements individually added to each. And now
    we can style them in the same way as any path element. We could use the national
    colors for each ball, but we’ll settle for making them green, with the results
    shown in [figure 3.25](#ch03fig25).
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用本节第一个示例中的 `<image>` 语法轻松地做同样的事情，但将我们的 SVG 元素单独添加到每个元素中。现在我们可以像任何路径元素一样对它们进行样式设置。我们可以为每个球使用国家颜色，但我们将满足于将它们设置为绿色，结果如图
    3.25 所示。
- en: Figure 3.25\. Football icons with a fill and stroke set by D3
  id: totrans-914
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.25\. 使用 D3 设置填充和描边的足球图标
- en: '![](../Images/03fig25_alt.jpg)'
  id: totrans-915
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/03fig25_alt.jpg)'
- en: '[PRE120]'
  id: totrans-916
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: One drawback to this method is that the paths can’t take advantage of the D3
    `.insert()` method’s ability to place the elements behind the labels or other
    visual elements. To get around this, we’ll need to either append icons to `<g>`
    elements that have been placed in the proper order, or use the `selection.lower()`
    and `selection.raise()` functions to move the paths around the DOM, as described
    earlier in this chapter.
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是路径无法利用 D3 `.insert()` 方法的功能，将元素放置在标签或其他视觉元素后面。为了解决这个问题，我们需要将图标附加到已正确放置的
    `<g>` 元素上，或者使用 `selection.lower()` 和 `selection.raise()` 函数在 DOM 中移动路径，正如本章前面所述。
- en: The other drawback is that because these paths were added using `cloneNode`
    and not `selection#append` syntax, they have no data bound to them. We looked
    at rebinding data back in [chapter 1](../Text/kindle_split_010.html#ch01). If
    we select the `<g>` elements and then select the `<path>` element, this will rebind
    data. But we have numerous `<path>` elements under each `<g>` element, and `selectAll`
    doesn’t rebind data. As a result, we have to take a more involved approach to
    bind the data from the parent `<g>` elements to the child `<path>` elements that
    have been loaded in this manner. The first thing we do is select all the `<g>`
    elements and then use `.each()` to select all the path elements under each `<g>`.
    Then, we separately bind the data from the `<g>` to each `<path>` using `.datum()`.
    What’s `.datum()`? Well, *datum* is the singular of *data*, so a piece of data
    is a datum. The `datum` function is what you use when you’re binding just one
    piece of data to an element. It’s the equivalent of wrapping your variable in
    an array and binding it to `.data()`. After we perform this action, we can dust
    off our old `scaleOrdinal` with a new set of colors and apply it to our new `<path>`
    elements. We can run this code in the console to see the effects, which should
    look like [figure 3.26](#ch03fig26).
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个缺点是，因为这些路径是通过 `cloneNode` 添加的，而不是使用 `selection#append` 语法，所以它们没有绑定任何数据。我们在[第
    1 章](../Text/kindle_split_010.html#ch01)中回顾了重新绑定数据。如果我们选择 `<g>` 元素，然后选择 `<path>`
    元素，这将重新绑定数据。但是，我们每个 `<g>` 元素下都有许多 `<path>` 元素，而 `selectAll` 不会重新绑定数据。因此，我们必须采取更复杂的方法来将父
    `<g>` 元素的数据绑定到以这种方式加载的子 `<path>` 元素。我们首先选择所有 `<g>` 元素，然后使用 `.each()` 选择每个 `<g>`
    下的所有路径元素。然后，我们使用 `.datum()` 分别将 `<g>` 的数据绑定到每个 `<path>`。那么，`.datum()` 是什么？嗯，*datum*
    是 *data* 的单数形式，所以一个数据项就是一个 datum。`datum` 函数是在将单个数据项绑定到元素时使用的函数。它是将变量包裹在数组中并绑定到
    `.data()` 的等效操作。在执行此操作后，我们可以用一组新的颜色应用我们的旧 `scaleOrdinal` 到新的 `<path>` 元素上。我们可以在控制台中运行此代码以查看效果，应该看起来像[图
    3.26](#ch03fig26)。
- en: Figure 3.26\. The paths now have the data from their parent element bound to
    them and respond accordingly when a discrete color scale based on region is applied.
  id: totrans-919
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.26。现在路径已经与父元素的数据绑定，并在应用基于区域的离散颜色尺度时相应地做出反应。
- en: '![](../Images/03fig26_alt.jpg)'
  id: totrans-920
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/03fig26_alt.jpg)'
- en: '[PRE121]'
  id: totrans-921
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Now you have data-driven icons. Use them wisely.
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您有了数据驱动的图标。请明智地使用它们。
- en: 3.4\. Summary
  id: totrans-923
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4. 摘要
- en: D3 includes useful functionality beyond formatting data to create charts, such
    as `text()` and `html()` for loading text and HTML as data.
  id: totrans-924
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: D3 不仅包括用于创建图表的格式化数据的有用功能，如 `text()` 和 `html()` 用于加载数据和 HTML，还提供了其他有用的功能。
- en: Using color right is challenging and color is underutilized, but rules exist
    for using color well. The color functions in D3 and associated with D3, such as
    `colorbrewer.js`, provide the tools to do that.
  id: totrans-925
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确使用颜色具有挑战性，颜色使用不足，但存在良好的颜色使用规则。D3 及其关联的颜色函数，如 `colorbrewer.js`，提供了实现这一点的工具。
- en: Triggering animated transitions with mouse events using `selection.on()` and
    `transition()` is a smart way to improve user experience.
  id: totrans-926
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `selection.on()` 和 `transition()` 通过鼠标事件触发动画转换是提高用户体验的明智方式。
- en: External SVG icons can be loaded and then styled or colored based on data for
    more infographics-style charting.
  id: totrans-927
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部 SVG 图标可以被加载，然后根据数据来样式化或着色，以实现更多信息图表风格的图表。
- en: D3.js in the real world
  id: totrans-928
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D3.js 在现实世界中的应用
- en: Bocoup for Measurement Lab
  id: totrans-929
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Bocoup 为测量实验室
- en: How do you visualize the “health of the Internet”? This was the challenge posed
    to the Data Vis team at Bocoup by our client Measurement Lab, a nonprofit that
    collects millions of Internet speed tests a month from around the world. This
    data is invaluable to policy makers, researchers, and the general public for understanding
    how Internet speeds are changing over time, and to highlight and understand the
    impact of service disruptions. But with petabytes of individual speed test data
    reports as a data source, it can be difficult to make a visualization tool that’s
    engaging and useful for such a broad audience.
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何可视化“互联网的健康状况”？这是我们的客户测量实验室向 Bocoup 的数据可视化团队提出的挑战，测量实验室是一个非营利组织，每月从世界各地收集数百万个互联网速度测试数据。这些数据对于政策制定者、研究人员和公众来说是无价的，因为他们需要了解互联网速度随时间的变化，并突出和了解服务中断的影响。但是，由于有数PB的个人速度测试数据报告作为数据源，制作一个吸引人且对如此广泛的受众有用的可视化工具可能很困难。
- en: '![](../Images/107fig01_alt.jpg)'
  id: totrans-931
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/107fig01_alt.jpg)'
- en: Design in data visualization is a process that, to be successful, should be
    focused on how best to shape the tool to address the needs of the users of that
    tool. We contacted potential users from both policy and research domains and performed
    a series of interviews with them. These interviews started with a few leading
    questions about how the interviewee uses, or could use, the existing data and
    what types of aggregations and groupings would be most insightful. The point of
    the process was to get them talking about their day-to-day needs and listen for
    places where we could facilitate understanding or improve their process. We also
    listened for patterns and permutations that were repeated by multiple individuals.
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 数据可视化设计是一个过程，为了成功，应该专注于如何最好地调整工具以满足该工具用户的需求。我们联系了来自政策和研究领域的潜在用户，并与他们进行了一系列访谈。这些访谈从几个关于受访者如何使用现有数据或可能使用的数据以及哪些类型的聚合和分组会最有洞察力的问题开始。这个过程的目的是让他们谈论他们的日常需求，并倾听我们可以促进理解或改进他们流程的地方。我们还倾听了由多个个体重复出现的模式和排列。
- en: The result was an ordered list of features and functions. We refined this list
    with our stakeholders and it served as a reference point for building and iterating
    on sketches and mockups of the tool. The interviews provided a path through the
    infinite design space toward solutions that packaged the data into useful, high-impact
    visualizations.
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个有序的功能和特性列表。我们与利益相关者一起完善了这个列表，它作为构建和迭代工具草图和原型的参考点。访谈为我们提供了一条途径，通过这条途径我们可以穿越无限的设计空间，找到将数据打包成有用、高影响力的可视化解决方案。
- en: '![](../Images/108fig01_alt.jpg)'
  id: totrans-934
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](../Images/108fig01_alt.jpg)'
- en: 'We arrived at a design that focuses on two ways for users to interact with
    the data: a zoomed-in view of ISP speeds for a particular location and a comparison
    view between locations and ISPs. In both spots, we focused on aggregating individual
    speed tests by ISP to provide a viewpoint in the data that was granular enough
    to be relatable, but could still show meaningful patterns. Simple chart forms
    populate the tool—with a focus on familiarity and functionality. We wanted people
    to spend time browsing the data instead of learning how to read our visualizations.
    Color is used to distinguish different ISPs from one another and is kept consistent
    throughout the site. With so many different ISPs, many colors are repeated, but
    it was important to us that the specific color associated with an ISP stays consistent
    even across users and sessions. This makes sharing and exporting the visualizations,
    which was another critical component of the tool, much less confusing.'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设计了一个专注于两种用户与数据交互方式的设计：特定位置的 ISP 速度的放大视图以及不同位置和 ISP 之间的比较视图。在这两个地方，我们都专注于按
    ISP 聚合单个速度测试，以在数据中提供一个足够细粒度以便相关联，但仍然可以显示有意义模式的视角。简单的图表形式填充了工具——重点是熟悉性和功能性。我们希望人们花时间浏览数据，而不是学习如何阅读我们的可视化。颜色用于区分不同的
    ISP，并在整个网站上保持一致。由于有如此多的不同 ISP，许多颜色被重复使用，但对我们来说，与 ISP 相关的具体颜色即使在用户和会话之间也要保持一致。这使得共享和导出可视化，这是工具的另一个关键组件，变得更加简单易懂。
- en: Chapter 4\. Chart components
  id: totrans-936
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第四章：图表组件
- en: '*This chapter covers*'
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Creating and formatting axis components
  id: totrans-938
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和格式化坐标轴组件
- en: Creating legends
  id: totrans-939
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建图例
- en: Using line and area generators for charts
  id: totrans-940
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用线形和区域生成器进行图表制作
- en: Creating complex shapes consisting of multiple types of SVG elements
  id: totrans-941
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建由多种类型的 SVG 元素组成的复杂形状
- en: D3 provides an enormous library of examples of charts, and GitHub is also packed
    with implementations. It’s easy to format your data to match the existing data
    used in an implementation—and voilà, you have a chart. Likewise, D3 includes layouts
    that allow you to create complex data visualizations from a properly formatted
    dataset. But before you get started with default layouts—which allow you to create
    basic charts like pie charts, as well as more exotic charts—you should first understand
    the basics of creating the elements that typically make up a chart. This chapter
    focuses on widely used pieces of charts created with D3, such as a labeled axis
    or a line. It also touches on the formatting, data modeling, and analytical methods
    most closely tied to creating charts.
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: D3 提供了大量的图表示例库，GitHub 上也充满了实现示例。将你的数据格式化以匹配现有实现中使用的现有数据非常简单——然后，你就有了一个图表。同样，D3
    包含布局，允许你从格式良好的数据集中创建复杂的数据可视化。但在你开始使用默认布局之前——这些布局允许你创建基本的图表，如饼图，以及更奇特的图表——你应该首先了解创建图表中典型元素的基本知识。本章重点介绍使用
    D3 创建的广泛使用的图表部分，例如标签轴或线条。它还涉及与创建图表最密切相关的格式化、数据建模和分析方法。
- en: 'If you’re reading this book in order, then this isn’t your first exposure to
    charts, because we created a scatterplot and bar chart in [chapter 2](../Text/kindle_split_011.html#ch02).
    This chapter introduces you to components and generators. A D3 component, like
    an axis, is a function for drawing all the graphical elements necessary for an
    axis. A generator, like `d3.line()`, lets you draw a straight or curved line across
    many points. The chapter begins by showing you how to add axes to scatterplots
    as well as create line charts, but before the end you’ll create an exotic yet
    simple chart: the streamgraph. By understanding how D3 generators and components
    work, you’ll be able do more than re-create the charts that other people have
    made and posted online (many of which they’re re-creating from somewhere else).'
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按顺序阅读这本书，那么这并不是你第一次接触图表，因为我们已经在第 2 章（../Text/kindle_split_011.html#ch02）中创建了一个散点图和条形图。本章向你介绍组件和生成器。D3
    组件，如轴，是一个用于绘制轴所需所有图形元素的函数。生成器，如 `d3.line()`，允许你在多个点之间绘制直线或曲线。本章首先向你展示如何将轴添加到散点图中以及创建线条图，但在结束之前，你将创建一个既奇特又简单的图表：流图。通过了解
    D3 生成器和组件的工作原理，你将能够做的不只是重新创建其他人已经制作并发布在网上的图表（其中许多是从其他地方重新创建的）。
- en: A chart (and notice here that I don’t use the term *graph* because that’s a
    synonym for *network*) refers to any flat layout of data in a graphical manner.
    The datapoints, which can be individual values or objects in arrays, may contain
    categorical, quantitative, topological, or unstructured data. In this chapter
    we’ll use several datasets to create the charts shown in [figure 4.1](#ch04fig01).
    Although it may seem more useful to use a single dataset for the various charts,
    as the old saying goes, “Horses for courses,” which is to say that different charts
    are more suitable to different kinds of datasets, as you’ll see in this chapter.
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 图表（注意这里我没有使用“图”这个术语，因为它是“网络”的同义词）指的是以图形方式平铺的数据的任何布局。数据点可以是数组中的单个值或对象，可能包含分类、定量、拓扑或非结构化数据。在本章中，我们将使用几个数据集来创建图
    4.1 中所示的图表。尽管使用单个数据集为各种图表似乎更有用，但正如古老的谚语所说，“马有马道”，也就是说，不同的图表更适合不同的数据集，正如你将在本章中看到的。
- en: 'Figure 4.1\. The charts we’ll create in this chapter using D3 generators and
    components. From left to right: a line chart, a boxplot, and a streamgraph.'
  id: totrans-945
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.1. 本章我们将使用 D3 生成器和组件创建的图表。从左到右：线条图、箱线图和流图。
- en: '![](../Images/04fig01_alt.jpg)'
  id: totrans-946
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1](../Images/04fig01_alt.jpg)'
- en: 4.1\. General charting principles
  id: totrans-947
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1. 常规图表原则
- en: All charts consist of several graphical elements that are drawn or derived from
    the dataset being represented. These graphical elements may be graphical primitives,
    like circles or rectangles, or more complex, multipart, graphical objects like
    the boxplots we’ll look at later in the chapter. Or they may be supplemental pieces
    like axes and labels. Although you use the same general processes you explored
    in previous chapters to create any of these elements in D3, it’s important to
    differentiate between the methods available in D3 to create graphics for charts.
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 所有图表都由几个图形元素组成，这些元素是从表示的数据集中绘制或派生出来的。这些图形元素可能是图形原语，如圆或矩形，也可能是更复杂的、多部分的图形对象，如我们在本章后面将要看到的箱线图。或者它们可能是补充元素，如坐标轴和标签。尽管你使用与之前章节中探索的相同的一般过程在D3中创建这些元素，但区分D3创建图表图形的方法是很重要的。
- en: 'You’ve learned how to directly create simple and complex elements with data-binding.
    You’ve also learned how to measure your data and transform it for display. Along
    with these two types of functions, D3 functionality can be placed into three broader
    categories: generators, components, and layouts, which are shown in [figure 4.2](#ch04fig02)
    along with a general overview of how they’re used.'
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学会了如何使用数据绑定直接创建简单和复杂的元素。你也学会了如何测量你的数据并将其转换为显示。除了这两种类型的函数外，D3的功能可以归纳为三个更广泛的类别：生成器、组件和布局，这些类别在[图4.2](#ch04fig02)中展示，并附有它们如何使用的概述。
- en: Figure 4.2\. The three main types of functions found in D3 can be classified
    as generators, components, and layouts. You’ll see components and generators in
    this chapter and layouts in the next chapter.
  id: totrans-950
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.2\. D3中发现的三个主要类型的函数可以分为生成器、组件和布局。你将在本章中看到组件和生成器，在下一章中看到布局。
- en: '![](../Images/04fig02_alt.jpg)'
  id: totrans-951
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/04fig02_alt.jpg)'
- en: 4.1.1\. Generators
  id: totrans-952
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.1\. 生成器
- en: D3 generators consist of functions that take data and return the necessary SVG
    drawing code to create a graphical object based on that data. For instance, if
    you have an array of points and you want to draw a line from one point to another,
    or turn it into a polygon or an area, a few D3 functions can help you with this
    process. These generators simplify the process of creating a complex SVG `<path>`
    by abstracting the process needed to write a `<path> d` attribute. In this chapter,
    we’ll look at `d3.line` and `d3.area`, and in the next chapter you’ll see `d3.arc`,
    which is used to create the pie pieces of pie charts. Another generator that you’ll
    see in [chapter 6](../Text/kindle_split_016.html#ch06) is `d3.diagonal`, used
    for drawing curved connecting lines in dendrograms.
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: D3生成器由接受数据并返回创建基于该数据的图形对象的必要SVG绘图代码的函数组成。例如，如果你有一个点数组，你想从一个点到另一个点画一条线，或者将其变成一个多边形或区域，一些D3函数可以帮助你完成这个过程。这些生成器通过抽象编写`<path>
    d`属性所需的过程，简化了创建复杂SVG `<path>`的过程。在本章中，我们将探讨`d3.line`和`d3.area`，在下一章中你将看到`d3.arc`，它用于创建饼图的饼块。另一个你将在[第6章](../Text/kindle_split_016.html#ch06)中看到的生成器是`d3.diagonal`，用于在树状图中绘制曲线连接线。
- en: 4.1.2\. Components
  id: totrans-954
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.2\. 组件
- en: In contrast with generators, which produce the `d` attribute string necessary
    for a `<path>` element, components create an entire set of graphical objects necessary
    for a particular chart component. The most commonly used D3 component (which you’ll
    see in this chapter) is `d3.axis`, which creates a bunch of `<line>`, `<path>`,
    `<g>`, and `<text>` elements that are needed for an axis based on the scale and
    settings you provide the function. Another component is `d3.brush` (which you’ll
    see later), which creates all the graphical elements necessary for a brush selector.
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 与生成器不同，生成器生成用于`<path>`元素的必要`d`属性字符串，组件则创建一组用于特定图表组件的图形对象。最常用的D3组件（你将在本章中看到）是`d3.axis`，它根据你提供的函数的缩放和设置创建一系列`<line>`、`<path>`、`<g>`和`<text>`元素，这些元素是轴所需的。另一个组件是`d3.brush`（你将在后面看到），它创建所有必要的图形元素，用于刷选择器。
- en: 4.1.3\. Layouts
  id: totrans-956
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.3\. 布局
- en: In contrast to generators and components, D3 layouts can be rather straightforward,
    like the pie chart layout, or complex, like a force-directed network layout. Layouts
    take in one or more arrays of data, and sometimes generators, and append attributes
    to the data necessary to draw it in certain positions or sizes, either statically
    or dynamically. You’ll see several of the simpler layouts in [chapter 5](../Text/kindle_split_014.html#ch05)
    and then focus on more complex layouts in [part 2](../Text/kindle_split_015.html#part02)
    ([chapters 6](../Text/kindle_split_016.html#ch06), [7](../Text/kindle_split_017.html#ch07),
    and [8](../Text/kindle_split_018.html#ch08)).
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: 与生成器和组件不同，D3布局可以是相当直接的，例如饼图布局，也可以是复杂的，例如力导向网络布局。布局接收一个或多个数据数组，有时还有生成器，并将绘制数据所需的位置或大小属性附加到数据上，无论是静态的还是动态的。你将在[第5章](../Text/kindle_split_014.html#ch05)中看到几个简单的布局，然后将在[第2部分](../Text/kindle_split_015.html#part02)（[第6章](../Text/kindle_split_016.html#ch06)、[第7章](../Text/kindle_split_017.html#ch07)和[第8章](../Text/kindle_split_018.html#ch08)）中关注更复杂的布局。
- en: 4.2\. Creating an axis
  id: totrans-958
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2. 创建轴
- en: Scatterplots, which you worked with in [chapters 1](../Text/kindle_split_010.html#ch01)
    and [2](../Text/kindle_split_011.html#ch02), are a simple and extremely effective
    charting method for displaying data. For most line charts, the x position is a
    point in time, and the y position is magnitude. For example, in [chapter 2](../Text/kindle_split_011.html#ch02)
    you placed your tweets along the x-axis according to when the tweets were made
    and along the y-axis according to their impact factor. In contrast, a scatterplot
    places a single symbol on a chart with its xy position determined by quantitative
    data for that datapoint. For instance, you can place a tweet on the y-axis based
    on the number of favorites and on the x-axis based on the number of retweets,
    allowing you to see if certain tweets get higher ratios of retweets to favorites.
    Scatterplots are common in scientific discourse and have grown increasingly common
    in journalism and public discourse for presenting data such as cost compared to
    quality of health care. Because they encode numerical values along each axis,
    they’re the ultimate “show me the data” chart, easily highlighting outliers.
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 散点图，你在[第1章](../Text/kindle_split_010.html#ch01)和[第2章](../Text/kindle_split_011.html#ch02)中处理过，是一种简单且极其有效的图表方法，用于显示数据。对于大多数折线图，x位置是时间点，y位置是幅度。例如，在[第2章](../Text/kindle_split_011.html#ch02)中，你根据推文的发布时间将推文放置在x轴上，根据其影响力因素将推文放置在y轴上。相比之下，散点图在图表上放置一个符号，其xy位置由该数据点的定量数据确定。例如，你可以根据喜欢的数量将推文放置在y轴上，根据转发次数将推文放置在x轴上，这样你就可以看到某些推文的转发与喜欢的比率是否更高。散点图在科学讨论中很常见，并且在新闻和公共讨论中越来越常见，用于展示数据，如医疗保健的成本与质量相比。因为它们在每个轴上编码数值，所以它们是终极的“展示数据”图表，可以轻松突出异常值。
- en: 4.2.1\. Plotting data
  id: totrans-960
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.1. 绘制数据
- en: 'Scatterplots needs to have more than one piece of data associated with them,
    and for a scatterplot that data must be numerical. You need only an array of data
    in which each entry has at least two different numerical values for a scatterplot
    to work. We’ll use an array where every object represents a person for whom we
    know the number of friends they have and the amount of money they make. We can
    see if having more or less friends positively correlates to a high salary associated
    with it, and for a scatterplot that data must be numerical. You need only an array
    of data with two different numerical values for a scatterplot to work. We’ll use
    an array where every object represents a person for whom we know the number of
    friends they have and the amount of money they make. We can see if having more
    or fewer friends positively correlates to a high salary:'
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 散点图需要与多个数据相关联，并且对于散点图，这些数据必须是数值的。你只需要一个数组，其中每个条目至少有两个不同的数值，以便散点图可以工作。我们将使用一个数组，其中每个对象代表一个人，我们了解他们有多少朋友以及他们赚多少钱。我们可以看到拥有更多或更少的朋友是否与高薪正相关，并且对于散点图，这些数据必须是数值的。你只需要一个具有两个不同数值的数组，以便散点图可以工作。我们将使用一个数组，其中每个对象代表一个人，我们了解他们有多少朋友以及他们赚多少钱。我们可以看到拥有更多或更少的朋友是否与高薪正相关：
- en: '[PRE122]'
  id: totrans-962
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: If you think these salary numbers are too high or too low, pretend they’re in
    a foreign currency with an exchange rate that would make them more reasonable.
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为这些薪水数字太高或太低，假设它们是外币，汇率会使它们更合理。
- en: 'Representing this data graphically using circles is easy. You’ve done it several
    times:'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 使用圆形图形表示这些数据很容易。你已经这样做过好几次：
- en: '[PRE123]'
  id: totrans-965
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: By designating `d.friends` for the `cy` position, we get circles placed with
    their depth based on the value of the `friends` attribute. Circles placed lower
    in the chart represent people in our dataset who have more friends. Circles are
    arranged from left to right using the old array-position trick you learned earlier
    in [chapter 2](../Text/kindle_split_011.html#ch02). In [figure 4.3](#ch04fig03),
    you can see that it’s not much of a scatterplot.
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 通过指定`d.friends`为`cy`位置，我们得到基于`friends`属性值的深度放置的圆。图表中位置较低的圆代表我们的数据集中朋友更多的人。圆从左到右排列，使用你在[第2章](../Text/kindle_split_011.html#ch02)中较早学到的旧数组位置技巧。在[图4.3](#ch04fig03)中，你可以看到它不是一个真正的散点图。
- en: Figure 4.3\. Circle positions indicate the number of friends and the array position
    of each datapoint.
  id: totrans-967
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.3\. 圆的位置表示朋友数量和每个数据点的数组位置。
- en: '![](../Images/04fig03.jpg)'
  id: totrans-968
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/04fig03.jpg)'
- en: 'Next, we need to build scales to make this fit better on our SVG canvas:'
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要构建刻度来使它在我们的SVG画布上更好地适应：
- en: '[PRE124]'
  id: totrans-970
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'The result, in [figure 4.4](#ch04fig04), is a true scatterplot, with points
    representing people arranged by number of friends along the y-axis and amount
    of salary along the x-axis. This chart, like most charts, is practically useless
    without a way of expressing to the reader what the position of the elements means.
    One way of accomplishing this is using well-formatted axis labels. Although we
    could use the same method for binding data and appending elements to create lines
    and ticks (which are lines representing equidistant points along an axis) and
    labels for an axis, D3 provides `d3.axisLeft(), d3.axisRight(), d3.axisBottom()`,
    and `d3.axisTop()`selection’s `.call()` method from a selection on a `<g>` element
    where we want these graphical elements to be drawn:'
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，在[图4.4](#ch04fig04)中，是一个真正的散点图，点代表的人按朋友的数量沿y轴排列，按薪水沿x轴排列。这个图表，像大多数图表一样，如果没有一种方法向读者表达元素的位置含义，实际上是没有用的。实现这一目标的一种方法是用格式良好的轴标签。虽然我们可以使用相同的方法来绑定数据和附加元素以创建线和刻度（这些线代表轴上的等距点）以及轴的标签，但D3提供了`d3.axisLeft()`、`d3.axisRight()`、`d3.axisBottom()`和`d3.axisTop()`选择集的`.call()`方法，从我们想要绘制这些图形元素的`<g>`元素上的选择集开始：
- en: '[PRE125]'
  id: totrans-972
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Figure 4.4\. Any point closer to the bottom has more friends, and any point
    closer to the right has a higher salary. But that’s not clear at all without labels,
    which we’re going to make.
  id: totrans-973
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.4\. 任何靠近底部的点有更多的朋友，任何靠近右侧的点有更高的薪水。但如果没有标签，这根本不清楚，我们将添加标签。
- en: '![](../Images/04fig04.jpg)'
  id: totrans-974
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/04fig04.jpg)'
- en: Notice that the `.call()` method of a selection invokes a function with the
    selection that’s active in the method chain, and is the equivalent of writing
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，选择集的`.call()`方法调用一个带有选择集的函数，该选择集在方法链中是活动的，并且等同于写入
- en: '[PRE126]'
  id: totrans-976
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[Figure 4.5](#ch04fig05) shows the pieces of an axis component.'
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4.5](#ch04fig05)显示了轴组件的各个部分。'
- en: Figure 4.5\. Elements of an axis created from `d3.axis` are 1 a `<path.domain>`
    with a size equal to the extent of the axis, 2 a `<g.tick >` that contains a `<line>`
    and 3 a `<text>` for each tick. Not shown, because it’s invisible, is the `<g>`
    element that’s called, and in which these elements are created. By default, a
    path like the domain is with black (this figure shows that fill area in purple),
    but the axis components have some default styles built in to prevent this. SVG
    line elements don’t have stroke by default, but the elements created by D3 axes
    also have default styles in place to make them visible.
  id: totrans-978
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.5\. 由`d3.axis`创建的轴元素包括1个`<path.domain>`，其大小等于轴的范围，2个包含`<line>`的`<g.tick>`，以及3个每个刻度的`<text>`。未显示的是，调用并创建这些元素的`<g>`元素是看不见的。默认情况下，像域这样的路径是黑色的（此图显示填充区域为紫色），但轴组件内置了一些默认样式以防止这种情况。SVG线元素默认没有描边，但由D3轴创建的元素也有默认样式以使它们可见。
- en: '![](../Images/04fig05.jpg)'
  id: totrans-979
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/04fig05.jpg)'
- en: 4.2.2\. Styling axes
  id: totrans-980
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.2\. 轴样式
- en: The `g.tick`, `line`, `text`, and `path.domain` elements are standard SVG elements
    created by the axis function, but they have default styles so you don’t need to
    have styles in your CSS, and should appear as shown in [figure 4.6](#ch04fig06).
    You may still want to go back and adjust your axis styles to match your application.
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: '`g.tick`、`line`、`text`和`path.domain`元素是由轴函数创建的标准SVG元素，但它们有默认样式，因此你不需要在CSS中设置样式，并且应该像[图4.6](#ch04fig06)中所示那样出现。你可能仍然想回去调整你的轴样式以匹配你的应用程序。'
- en: Figure 4.6\. Default styles for an axis display the ticks and don’t fill the
    domain area.
  id: totrans-982
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.6\. 轴显示的默认样式显示刻度，但不填充域区域。
- en: '![](../Images/04fig06_alt.jpg)'
  id: totrans-983
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/04fig06_alt.jpg)'
- en: 'If we use `axisLeft()` or `axisTop()`, it seems like they aren’t drawn. That’s
    because they’re drawn outside the canvas, like our earlier rectangles. To move
    our axes around, we need to adjust the `.attr("translate")` of their parent `<g>`
    elements, either when we draw them or later. This is why it’s important to assign
    an ID to our elements when we append them to the canvas. We can move the x-axis
    to the bottom of this drawing easily:'
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`axisLeft()`或`axisTop()`，它们似乎没有被绘制。这是因为它们被绘制在画布之外，就像我们之前的矩形一样。为了移动我们的轴，我们需要调整其父`<g>`元素的`.attr("translate")`属性，无论是我们在绘制它们时还是之后。这就是为什么在我们将元素附加到画布时分配一个ID很重要的原因。我们可以轻松地将x轴移动到这个绘图的底部：
- en: '[PRE127]'
  id: totrans-985
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Here’s our updated code. It uses the `.tickSize()` function to change the ticks
    to lines and manually sets the number of ticks using the `ticks()` function:'
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的更新后的代码。它使用`.tickSize()`函数将刻度改为线条，并使用`ticks()`函数手动设置刻度数量：
- en: '[PRE128]'
  id: totrans-987
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '***1* Creates a pair of scales to map the values in our dataset to the canvas**'
  id: totrans-988
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1** 创建一对比例，将数据集中的值映射到画布上'
- en: '***2* Uses method chaining to create an axis and explicitly set its orientation,
    tick size, and number of ticks**'
  id: totrans-989
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2** 使用方法链来创建一个轴，并显式设置其方向、刻度大小和刻度数量'
- en: '***3* Appends a <g> element to the canvas, and calls the axis from that <g>
    to create the necessary graphics for the axis**'
  id: totrans-990
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3** 将一个`<g>`元素附加到画布上，并从该`<g>`中调用轴以创建必要的轴图形'
- en: With this in place, we get something a bit more legible, as shown in [figure
    4.7](#ch04fig07).
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 如此一来，我们得到的东西就更加易于阅读，如图4.7所示。
- en: Figure 4.7\. With CSS settings corresponding to the tick `<line>` elements,
    we can draw a rather attractive grid based on our two axes.
  id: totrans-992
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.7。通过与刻度`<line>`元素对应的CSS设置，我们可以基于我们的两个轴绘制一个相当吸引人的网格。
- en: '![](../Images/04fig07.jpg)'
  id: totrans-993
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/04fig07.jpg)'
- en: Take a look at the elements created by the `axisRight()` or `axisBottom()` function
    in [figure 4.8](#ch04fig08) and see how the CSS classes are associated with those
    elements.
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 查看由`axisRight()`或`axisBottom()`函数在[图4.8](#ch04fig08)中创建的元素，并看看CSS类是如何与这些元素关联的。
- en: Figure 4.8\. The DOM shows how tick `<line>` elements are appended along with
    a `<text>` element for the label to one of a set of `<g.tick.major>` elements
    corresponding to the number of ticks.
  id: totrans-995
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.8。DOM显示了如何将`<line>`标记元素附加到`<text>`标记元素上，以形成一个或多个`<g.tick.major>`元素集合，这些元素对应于刻度的数量。
- en: '![](../Images/04fig08_alt.jpg)'
  id: totrans-996
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/04fig08_alt.jpg)'
- en: As you create more complex information visualization, you’ll get used to creating
    your own elements with classes referenced by your style sheet. You’ll also learn
    where D3 components create elements in the DOM and how they’re classed so that
    you can style them properly.
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建更复杂的信息可视化时，你会习惯于使用样式表中的类创建自己的元素。你也会了解到D3组件在哪里创建DOM元素，以及它们是如何分类的，这样你就可以正确地设置样式。
- en: 4.3\. Complex graphical objects
  id: totrans-998
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3。复杂图形对象
- en: Using circles or rectangles for your data won’t work with some datasets—for
    example, if an important aspect of your data has to do with distribution, such
    as user demographics or statistical data. Often, the distribution of data gets
    lost in information visualization or is only noted with a reference to standard
    deviation or other first-year statistics terms that indicate the average doesn’t
    tell the whole story. One particularly useful way of representing data that has
    a distribution (such as a fluctuating stock price) is the use of a boxplot in
    place of a traditional scatterplot. The boxplot uses a complex graphic that encodes
    distribution in its shape. The box in a boxplot typically looks like the one shown
    in [figure 4.9](#ch04fig09). It uses quartiles that have been preprocessed, but
    you could easily use `d3.scaleQuartile()` to create your own values from your
    own dataset.
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 使用圆形或矩形来表示你的数据在某些数据集中可能不起作用——例如，如果你的数据的一个重要方面与分布有关，比如用户人口统计信息或统计数据。通常，数据的分布会在信息可视化中丢失，或者只是通过标准差或其他初学者统计学术语来提及，这些术语表明平均值并不能说明整个故事。表示具有分布（如波动的股价）的数据的一个特别有用的方法是使用箱线图来代替传统的散点图。箱线图使用一种复杂的图形，其形状编码了分布。箱线图中的箱子通常看起来像[图4.9](#ch04fig09)中所示的那样。它使用预处理过的四分位数，但你也可以轻松地使用`d3.scaleQuartile()`从你的数据集中创建自己的值。
- en: 'Figure 4.9\. A box from a boxplot consists of five pieces of information encoded
    in a single shape: (1) the maximum value, (2) the high value of some distribution,
    such as the third quartile, (3) the median or mean value, (4) the corresponding
    low value of the distribution, such as the first quartile, and (5) the minimum
    value.'
  id: totrans-1000
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.9。箱线图中的一个箱体由单个形状中编码的五条信息组成：（1）最大值，（2）某些分布的高值，例如第三四分位数，（3）中位数或平均值，（4）分布的对应低值，例如第一四分位数，以及（5）最小值。
- en: '![](../Images/04fig09.jpg)'
  id: totrans-1001
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/04fig09.jpg)'
- en: Take a moment to examine the amount of data that’s encoded in the graphic in
    [figure 4.9](#ch04fig09). The median value is represented as a gray line. The
    rectangle shows the amount of whatever you’re measuring that falls in a set range
    that represents the majority of the data. The two lines above and below the rectangle
    indicate the minimum and maximum values. Everything except the information in
    the gray line is lost when you map only the average or median value at a datapoint.
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 花点时间检查 [4.9 图](#ch04fig09) 中的图形中编码的数据量。中位数表示为灰色线条。矩形显示了落在代表大多数数据的范围中的测量值。矩形上方的两条线和下方的两条线表示最小值和最大值。当你只映射数据点的平均或中位数值时，除了灰色线条中的信息外，所有信息都将丢失。
- en: To build a reasonable boxplot, we’ll need a set of data with interesting variation
    in those areas. Let’s assume we want to plot the number of registered visitors
    coming to our website by day of the week so that we can compare our stats week
    to week. We have the data for the age of the visitors (based on their registration
    details) and derived the quartiles from that. Maybe we used Excel, Python, or
    `d3.scaleQuartile()`, or maybe it was part of a dataset we downloaded. As you
    work with data, you’ll be exposed to common statistical summaries like this and
    you’ll have to represent them as part of your charts, so don’t be too intimidated
    by it. We’ll use a CSV format for the information.
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个合理的箱线图，我们需要一组在这些区域具有有趣变化的数据。让我们假设我们想要按星期天数绘制注册访问者数量，以便我们可以比较每周的统计数据。我们有访问者年龄的数据（基于他们的注册详情），并从中导出了四分位数。也许我们使用了Excel、Python或
    `d3.scaleQuartile()`，或者它可能是我们下载的数据集的一部分。当你处理数据时，你会接触到像这样的常见统计摘要，你将不得不将它们作为图表的一部分来表示，所以不要对此感到过于害怕。我们将使用CSV格式来表示信息。
- en: The following listing shows our dataset with the number of registered users
    that visit the site each day, and the quartiles of their ages.
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了我们的数据集，包括每天访问网站注册用户的数量以及他们年龄的四分位数。
- en: Listing 4.1\. boxplots.csv
  id: totrans-1005
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.1。boxplots.csv
- en: '[PRE129]'
  id: totrans-1006
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: When we map the median age as a scatterplot as shown in the code in [listing
    4.2](#ch04ex02) and seen in [figure 4.10](#ch04fig10), it looks like there’s not
    too much variation in our user base throughout the week. We do that by drawing
    scatterplot points for each day at the median age of the visitor for that day.
    We’ll also invert the y-axis so that it makes a bit more sense.
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将中位年龄映射为散点图，如图 [4.2 列表](#ch04ex02) 中的代码所示，并在 [4.10 图](#ch04fig10) 中看到，整个星期我们的用户基础变化并不太大。我们通过为每一天的访问者的中位年龄绘制散点图点来实现这一点。我们还将反转y轴，使其更易于理解。
- en: Figure 4.10\. The median age of visitors (y-axis) by day of the week (x-axis)
    as represented by a scatterplot. It shows a slight dip in age on the second and
    third days.
  id: totrans-1008
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.10。按星期天数（x轴）表示的访问者中位年龄（y轴）散点图。它显示在第二天和第三天年龄略有下降。
- en: '![](../Images/04fig10.jpg)'
  id: totrans-1009
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/04fig10.jpg)'
- en: Listing 4.2\. Scatterplot of average age
  id: totrans-1010
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.2。平均年龄散点图
- en: '[PRE130]'
  id: totrans-1011
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '***1* Any value that you use more than once should be stored in a constant,
    so that you only have to change it once later and so others can read your code**'
  id: totrans-1012
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 任何你使用超过一次的值都应该存储在常量中，这样你只需稍后更改一次，其他人也可以阅读你的代码**'
- en: '***2* Scale is inverted, so higher values are drawn higher up and lower values
    toward the bottom**'
  id: totrans-1013
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 比例反转，因此较高的值绘制得更高，较低的值绘制得更低**'
- en: '***3* Offsets the <g> containing the axis**'
  id: totrans-1014
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 偏移包含轴的 <g>**'
- en: '***4* Specifies the exact tick values to correspond with the numbered days
    of the week**'
  id: totrans-1015
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 指定与星期中编号日期相对应的确切刻度值**'
- en: To get a better view of this data, we’ll need to create a boxplot. Building
    a boxplot is similar to building a scatterplot, but instead of appending circles
    for each point of data, you append a `<g>` element. It’s a good rule to always
    use `<g>` elements for your charts, because they allow you to apply labels or
    other important information to your graphical representations. That means you’ll
    need to use the `transform` attribute, which is how `<g>` elements are positioned
    on the canvas. Elements appended to a `<g>` base their coordinates off of the
    coordinates of their parent. When applying `x` and `y` attributes to child elements,
    you need to set them relative to the parent `<g>`.
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地查看这些数据，我们需要创建一个箱线图。构建箱线图与构建散点图类似，但不同之处在于，我们不是为每个数据点附加圆圈，而是附加一个 `<g>` 元素。始终使用
    `<g>` 元素来创建图表是一个好规则，因为它们允许您将标签或其他重要信息应用到您的图形表示中。这意味着您需要使用 `transform` 属性，这是 `<g>`
    元素在画布上的定位方式。附加到 `<g>` 的元素以其父元素的坐标为基础。当将 `x` 和 `y` 属性应用于子元素时，您需要将它们相对于父 `<g>` 设置。
- en: Rather than selecting all the `<g>` elements and appending child elements one
    at a time, as we did in earlier chapters, we’ll use the `.each()` function of
    a selection, which allows us to perform the same code on each element in a selection
    to create the new elements. Like any D3 selection function, `.each()` allows you
    to access the bound data, array position, and DOM element. In [chapter 1](../Text/kindle_split_010.html#ch01)
    we achieved the same functionality by using `selectAll` to select the `<g>` elements
    and directly append `<circle>` and `<text>` elements. That’s a clean method, and
    the only reasons to use `.each()` to add child elements are if you prefer the
    syntax, you plan on doing complex operations involving each data element, or you
    want to add conditional tests to change whether or what child elements you’re
    appending. You can see how to use `.each()` to add child elements in action in
    the following listing, which takes advantage of the scales we created in [listing
    4.3](#ch04ex03) and draws rectangles on top of the circles we’ve already drawn.
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在早期章节中逐个选择所有 `<g>` 元素并附加子元素不同，我们将使用选择集的 `.each()` 函数，这允许我们对选择集中的每个元素执行相同的代码以创建新元素。像任何
    D3 选择函数一样，`.each()` 允许您访问绑定数据、数组位置和 DOM 元素。在 [第1章](../Text/kindle_split_010.html#ch01)
    中，我们通过使用 `selectAll` 选择 `<g>` 元素并直接附加 `<circle>` 和 `<text>` 元素来实现相同的功能。这是一个干净的方法，使用
    `.each()` 添加子元素的唯一原因可能是您更喜欢该语法，您计划执行涉及每个数据元素的复杂操作，或者您想添加条件测试以更改附加的子元素或其内容。您可以在以下列表中看到如何使用
    `.each()` 添加子元素的实际操作，该列表利用了我们在 [列表 4.3](#ch04ex03) 中创建的刻度，并在我们已绘制的圆圈上绘制矩形。
- en: Listing 4.3\. Initial boxplot drawing code
  id: totrans-1018
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.3。初始箱线图绘制代码
- en: '[PRE131]'
  id: totrans-1019
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '***1* Your latest reminder that to get the this context you can’t use arrow
    functions**'
  id: totrans-1020
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 这是您最新的提醒，要获取此上下文，您不能使用箭头函数**'
- en: '***2* Because we’re inside the .each(), we can select(this) to append new child
    elements**'
  id: totrans-1021
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 因为我们在 .each() 中，所以我们可以选择(this)来附加新的子元素**'
- en: '***3* The d and i variables are declared in the .each() anonymous function,
    so each time we access it, we get the data bound to the original element**'
  id: totrans-1022
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* d 和 i 变量在 .each() 匿名函数中声明，所以每次我们访问它时，我们都得到绑定到原始元素的数据**'
- en: The new rectangles indicating the distribution of visitor ages, as shown in
    [figure 4.11](#ch04fig11), aren’t only offset to the right, but also showing the
    wrong values. Day 7, for instance, should range in value from 30 to 50, but instead
    is shown as ranging from 13 to 32\. We know it’s doing that because that’s the
    way SVG draws rectangles. We have to update our code a bit to make it accurately
    reflect the distribution of visitor ages, as shown in [figure 4.11](#ch04fig11).
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 新的表示访客年龄分布的矩形，如图 [4.11](#ch04fig11) 所示，不仅向右偏移，还显示了错误的数据。例如，第7天应该从30到50的范围内变化，但实际显示的是从13到32。我们知道它这样做是因为SVG就是这样绘制矩形的。我们必须稍微更新我们的代码，以便它准确地反映访客年龄的分布，如图
    [4.11](#ch04fig11) 所示。
- en: Figure 4.11\. The `<rect>` elements represent the scaled range of the first
    and third quartiles of visitor age. They’re placed on top of a gray `<circle>`
    in each `<g>` element, which is placed on the chart at the median age. The rectangles
    are drawn, as per SVG convention, from the `<g>` down and to the right.
  id: totrans-1024
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.11。`<rect>` 元素表示访客年龄的第一和第三四分位数范围的缩放。它们放置在每个 `<g>` 元素上的灰色 `<circle>` 上，该
    `<circle>` 位于图表的中位数年龄处。根据 SVG 惯例，矩形从 `<g>` 向下和向右绘制。
- en: '![](../Images/04fig11.jpg)'
  id: totrans-1025
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/04fig11.jpg)'
- en: '[PRE132]'
  id: totrans-1026
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '***1* Sets a negative offset of half the width to center a rectangle horizontally**'
  id: totrans-1027
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 设置负偏移量的一半宽度以水平居中矩形**'
- en: '***2* The height of the rectangle is equal to the difference between its q1
    and q3 values, which means we need to offset the rectangle by the difference between
    the middle of the rectangle (the median) and the high end of the distribution—q3**'
  id: totrans-1028
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 矩形的高度等于其q1和q3值之间的差值，这意味着我们需要将矩形偏移这个差值，即矩形中间（中位数）与分布的高端q3之间的差值**'
- en: We’ll use the same technique we used to create the chart in [figure 4.12](#ch04fig12)
    to add the remaining elements of the boxplot (described in detail in [figure 4.13](#ch04fig13))
    by including several append functions in the `.each()` function, as shown in [listing
    4.4](#ch04ex04). They all select the parent `<g>` element created during the data-binding
    process and append the shapes necessary to build a boxplot.
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与创建图4.12中图表相同的技巧，通过在`.each()`函数中包含几个附加函数，来添加箱线图的剩余元素（在图4.13中详细描述），如[列表4.4](#ch04ex04)所示。它们都选择在数据绑定过程中创建的父`<g>`元素，并附加构建箱线图所需的形状。
- en: Figure 4.12\. The `<rect>` elements are now properly placed so that their top
    and bottom correspond with the visitor age between the first and third quartiles
    of visitors for each day. The circles are completely covered, except for the second
    rectangle where the first quartile value is the same as the median age, so we
    can see half the gray circle peeking out from underneath it.
  id: totrans-1030
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.12\. `<rect>`元素现在被正确放置，以便它们的顶部和底部与每天访问者年龄的第一和第三四分位数相对应。圆圈完全被覆盖，除了第二个矩形，其中第一四分位数值与中位数相同，因此我们可以看到一半的灰色圆圈从下面露出来。
- en: '![](../Images/04fig12.jpg)'
  id: totrans-1031
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/04fig12.jpg)'
- en: Figure 4.13\. How a boxplot can be drawn in D3\. Pay particular attention to
    the relative positioning necessary to draw child elements of a `<g>`. The 0 positions
    for all elements are where the parent `<g>` has been placed, so that `<line.max>`,
    `<rect.distribution>`, and `<line.range>` all need to be drawn with an offset
    placing their top-left corner above this center, whereas `<line.min>` is drawn
    below the center and `<line.median>` has a 0 y-value, because our center is the
    median value.
  id: totrans-1032
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.13\. 在D3中绘制箱线图的方法。特别注意绘制子元素`<g>`所需的相对位置。所有元素的位置0是父`<g>`放置的位置，因此`<line.max>`、`<rect.distribution>`和`<line.range>`都需要绘制带有偏移的形状，使它们的左上角位于这个中心之上，而`<line.min>`则绘制在中心下方，`<line.median>`具有0的y值，因为我们的中心是中位数。
- en: '![](../Images/04fig13_alt.jpg)'
  id: totrans-1033
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/04fig13_alt.jpg)'
- en: Listing 4.4\. The `.each()` function of the boxplot drawing five child elements
  id: totrans-1034
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.4\. 箱线图绘制五个子元素的`.each()`函数
- en: '[PRE133]'
  id: totrans-1035
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '***1* Draws the line from the max to the min value**'
  id: totrans-1036
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从最大值绘制到最小值的线**'
- en: '***2* The top bar of the min-max line**'
  id: totrans-1037
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 最小值到最大值线的顶部条**'
- en: '***3* The bottom bar of the min-max line**'
  id: totrans-1038
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 最小值到最大值线的底部条**'
- en: '***4* The offset so that the rectangle is centered on the median value**'
  id: totrans-1039
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 偏移量使得矩形以中位数为中心**'
- en: '***5* Median line doesn’t need to be moved, because the parent <g> is centered
    on the median value**'
  id: totrans-1040
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 中位数线不需要移动，因为父`<g>`以中位数为中心**'
- en: '[Listing 4.5](#ch04ex05) fulfills the requirement that we should also add an
    x-axis to remind us which day each box is associated with. This takes advantage
    of the explicit `.tick-Values()` function you saw earlier. It also uses a negative
    value passed to `tickSize()` and the corresponding offset of the `<g>` that we
    use to call the axis function.'
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表4.5](#ch04ex05)满足我们应添加x轴以提醒我们每个箱与哪一天相关联的要求。这利用了您之前看到的显式`.tick-Values()`函数。它还使用传递给`tickSize()`的负值和相应的`<g>`偏移量，我们使用它来调用轴函数。'
- en: Listing 4.5\. Adding an axis using `tickValues`
  id: totrans-1042
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.5\. 使用`tickValues`添加轴
- en: '[PRE134]'
  id: totrans-1043
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '***1* A negative tickSize draws the lines above the axis, but we need to make
    sure to offset the axis by the same value**'
  id: totrans-1044
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 负tickSize绘制轴上的线，但我们需要确保轴偏移相同的值**'
- en: '***2* Setting specific tickValues forces the axis to only show the corresponding
    values, which is useful when we want to override the automatic ticks created by
    the axis**'
  id: totrans-1045
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 设置特定的tickValues强制轴只显示相应的值，这在我们需要覆盖轴自动创建的刻度时很有用**'
- en: '***3* Offsets the axis to correspond with our negative tickSize**'
  id: totrans-1046
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将轴偏移以对应我们的负tickSize**'
- en: '***4* We can hide this, because it has extra ticks on the ends that distract
    our readers**'
  id: totrans-1047
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 我们可以隐藏它，因为它在两端有额外的刻度，会分散读者的注意力**'
- en: The end result of all this is a chart where each of our datapoints is represented,
    not by a single circle, but by a multipart graphical element designed to emphasize
    distribution.
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些的结果是一个图表，其中我们的每个数据点不仅由一个圆圈表示，而是一个多部分图形元素，旨在强调分布。
- en: The boxplot in [figure 4.14](#ch04fig14) encodes not only the median age of
    visitors for that day, but the minimum, maximum, and distribution of the age of
    the majority of visitors. This expresses in detail the demographics of visitorship
    clearly and cleanly. It doesn’t include the number of visitors, but we could encode
    that with color, make it available on a click of each boxplot, or make the width
    of the boxplot correspond to the number of visitors.
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.14中的箱线图不仅编码了那天访问者的中位数年龄，还包括了大多数访问者的最小年龄、最大年龄和年龄分布。这清楚地、干净地详细表达了访问者的人口统计信息。它不包括访问者的数量，但我们可以用颜色编码，点击每个箱线图时提供，或者使箱线图的宽度与访问者数量相对应。
- en: Figure 4.14\. Our final boxplot chart. Each day now shows not only the median
    age of visitors but also the range of visiting ages, allowing for a more extensive
    examination of the demographics of site visitorship.
  id: totrans-1050
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.14\. 我们最终的箱线图。现在每一天不仅显示了访问者的中位数年龄，还显示了访问年龄的范围，这使得对网站访问者人口统计的更广泛研究成为可能。
- en: '![](../Images/04fig14.jpg)'
  id: totrans-1051
  prefs: []
  type: TYPE_IMG
  zh: '![图4.14](../Images/04fig14.jpg)'
- en: We looked at boxplots because a boxplot allows you to explore the creation of
    multipart objects while using lines and rectangles. But what’s the value of a
    visualization like this that shows distribution? It encodes a graphical summary
    of the data, providing information about visitor age for the site on Wednesday,
    such as, “Most visitors were between the ages of 18 and 28\. The oldest was 40\.
    The youngest was 15\. The median age was 25.” It also allows you to quickly perform
    visual queries, checking to see whether the median age of one day was within the
    majority of visitor ages of another day.
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 我们查看箱线图是因为箱线图允许您在同时使用线和矩形的情况下探索多部分对象的创建。但像这种显示分布的视觉化的价值是什么？它编码了数据的图形摘要，提供了关于周三网站访问者年龄的信息，例如，“大多数访问者年龄在18至28岁之间。最年长者40岁。最年轻者15岁。中位数年龄为25岁。”它还允许您快速执行视觉查询，检查某一天的中位数年龄是否在另一天的多数访问者年龄范围内。
- en: 'We’ll stop exploring boxplots, and look at a different kind of complex graphical
    object: an interpolated line.'
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将停止探索箱线图，并查看一种不同类型的复杂图形对象：插值线。
- en: 4.4\. Line charts and interpolations
  id: totrans-1054
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4\. 折线图和插值
- en: You create line charts by drawing connections between points. A line that connects
    points and the shaded regions inside or outside the area constrained by the line
    tell a story about the data. Although a line chart is technically a static data
    visualization, it’s also a representation of change, typically over time.
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: 您通过在点之间绘制连接来创建折线图。连接点和线约束区域内部或外部的阴影区域讲述着数据的故事。尽管折线图在技术上是一种静态数据可视化，但它也是变化的表示，通常是随时间的变化。
- en: We’ll start with a new dataset in [listing 4.6](#ch04ex06) that better represents
    change over time. Let’s imagine we have a Twitter account and we’ve been tracking
    the number of tweets, favorites, and retweets to determine at what time we have
    the greatest response to our social media. Although we’ll ultimately deal with
    this kind of data as JSON, we’ll want to start with a comma-delimited file, because
    it’s the most efficient for this kind of data.
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用[列表4.6](#ch04ex06)中的新数据集开始，该数据集更好地代表了随时间的变化。让我们想象我们有一个Twitter账户，我们一直在跟踪推文数量、点赞和转发次数，以确定我们何时对社交媒体有最大的响应。虽然我们最终将以JSON格式处理这类数据，但我们想从一个逗号分隔的文件开始，因为对于这类数据来说，它是最有效的。
- en: Listing 4.6\. tweetdata.csv
  id: totrans-1057
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.6\. tweetdata.csv
- en: '[PRE135]'
  id: totrans-1058
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: First we pull this CSV in using `d3.csv()` as we did in [chapter 2](../Text/kindle_split_011.html#ch02)
    and then we create circles for each datapoint. We do this for each variation on
    the data, with the `.day` attribute determining x position and the other datapoint
    determining y position. We create the usual x and y scales to draw the shapes
    in the confines of our canvas. We also have a couple of axes to frame our results.
    Notice that we differentiated between the three datatypes by coloring them differently.
    See the following listing.
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`d3.csv()`将此CSV文件拉入，就像我们在[第2章](../Text/kindle_split_011.html#ch02)中所做的那样，然后为每个数据点创建圆圈。我们对数据的每个变体都这样做，其中`.day`属性确定x位置，其他数据点确定y位置。我们创建常规的x和y刻度，在画布的范围内绘制形状。我们还有几个轴来框定我们的结果。请注意，我们通过不同的颜色区分了三种数据类型。请参见以下列表。
- en: Listing 4.7\. Callback function to draw a scatterplot from `tweetdata`
  id: totrans-1060
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.7\. 从 `tweetdata` 绘制散点图的回调函数
- en: '[PRE136]'
  id: totrans-1061
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '***1* Our scales, as usual, have margins built in**'
  id: totrans-1062
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 我们的比例尺，像往常一样，内置了边距**'
- en: '***2* Fixes the ticks of the x-axis to correspond to the days**'
  id: totrans-1063
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将x轴的刻度固定为对应的天数**'
- en: '***3* Each of these uses the same dataset but bases the y position on tweets,
    retweets, and favorites values, respectively**'
  id: totrans-1064
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 每个都使用相同的数据库，但分别基于推文、转发和点赞值确定y位置**'
- en: The graphical results of this code, as shown in [figure 4.15](#ch04fig15)—which
    take advantage of the CSS rules we defined earlier—aren’t easily interpreted.
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的图形结果，如图4.15所示——它利用了我们之前定义的CSS规则——并不容易解释。
- en: Figure 4.15\. A scatterplot showing the datapoints for 10 days of activity on
    Twitter, with the number of tweets in blue, the number of retweets in green, and
    the number of favorites in orange.
  id: totrans-1066
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.15\. 显示了Twitter上10天活动数据点的散点图，其中推文数量用蓝色表示，转发数量用绿色表示，点赞数量用橙色表示。
- en: '![](../Images/04fig15.jpg)'
  id: totrans-1067
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/04fig15.jpg)'
- en: 4.4.1\. Drawing a line from points
  id: totrans-1068
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.1\. 从点绘制线条
- en: By drawing a line that intersects each point of the same category, we can compare
    the number of tweets, retweets, and favorites. We can start by drawing a line
    for tweets using `d3.line()`. This line generator expects an array of points as
    data, and we’ll need to tell the generator what values constitute the x and y
    coordinates for each point. By default, this generator expects a two-part array,
    where the first part is the x value and the second part is the y value. Because
    our x value is based on the day of the activity and our y value is based on the
    amount of activity, we need to set specific accessor functions.
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: 通过绘制与同一类别每个点相交的线条，我们可以比较推文、转发和点赞的数量。我们可以从使用 `d3.line()` 绘制推文线条开始。这个线条生成器期望一个包含点的数组作为数据，我们需要告诉生成器每个点的x和y坐标的值。默认情况下，这个生成器期望一个两部分的数组，其中第一部分是x值，第二部分是y值。因为我们的x值基于活动日，我们的y值基于活动量，我们需要设置特定的访问器函数。
- en: The `.x()` accessor function of the line generator needs to point at the scaled
    day value, while the `.y()` accessor function needs to point to the scaled value
    of the appropriate activity. The line function itself takes the entire dataset
    that we loaded from `tweetdata.csv` and returns the SVG drawing code necessary
    for a line between the points in that dataset. To generate three lines, we use
    the dataset three times, with a slightly different generator for each. We not
    only need to write the generator function and define how it accesses the data
    it uses to draw the line, but we also need to append a `<path>` to our canvas
    and set its `d` attribute to equal the generator function we defined.
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: 线生成器的 `.x()` 访问器函数需要指向缩放后的天值，而 `.y()` 访问器函数需要指向相应活动的缩放值。线函数本身接受我们从 `tweetdata.csv`
    加载的整个数据集，并返回在数据集中点之间的SVG绘图代码。为了生成三条线，我们使用了三次数据集，每次使用略有不同的生成器。我们不仅需要编写生成器函数并定义它如何访问用于绘制线的数据，还需要将一个
    `<path>` 添加到我们的画布上，并将其 `d` 属性设置为等于我们定义的生成器函数。
- en: A more advanced feature of `d3.line()` is the defined method, as shown in [listing
    4.8](#ch04ex08). By default, `line.defined()` returns true, which means that every
    datapoint indicates a real section in the line. However, if you have gaps in your
    data, and you don’t want the line to interpolate them, you can use `defined()`
    to create a multipart line with gaps where you don’t have data. To be clear, you
    still need a datapoint at that place in the line, but it should be able to return
    false from the function you’ve sent to defined. For instance, if you set defined
    as
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: '`d3.line()` 的一个更高级的功能是定义方法，如图4.8所示。默认情况下，`line.defined()` 返回true，这意味着每个数据点都表示线上的一个真实部分。然而，如果你数据中存在空缺，并且你不想让线进行插值，你可以使用
    `defined()` 来创建一个有间隙的多部分线，这些间隙是你没有数据的地方。为了清楚起见，你仍然需要在线的那个位置有一个数据点，但它应该能够从你发送给
    `defined()` 的函数返回false。例如，如果你将 `defined` 设置为'
- en: '[PRE137]'
  id: totrans-1072
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: then D3 will draw a gap in your line at any point where the `y` value of that
    point is `null`. We’re not using this feature in the lines drawn here, which don’t
    have any gaps in their data, but if you’re drawing lines with gaps, it will make
    it easier on you.
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，D3将在该点的 `y` 值为 `null` 的任何位置在你的线上绘制一个间隙。我们在这里的线条中没有使用这个功能，因为它们的数据中没有间隙，但如果你在绘制有间隙的线条，这将使你的工作更容易。
- en: Listing 4.8\. New line generator code inside the callback function
  id: totrans-1074
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.8\. 回调函数内的新线生成器代码
- en: '[PRE138]'
  id: totrans-1075
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '***1* Defines an accessor for data like ours—in this case we take the day attribute
    and pass it to xScale first**'
  id: totrans-1076
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 定义了一个访问器，用于像我们这样的数据——在这种情况下，我们取day属性并将其传递给xScale。**'
- en: '***2* This accessor does the same for the number of tweets**'
  id: totrans-1077
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 这个访问器对推文的数量做同样的处理**'
- en: '***3* The appended path is drawn according to the generator with the loaded
    tweetdata variable passed to it**'
  id: totrans-1078
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 添加的路径是根据加载的tweetdata变量传递给生成器的。**'
- en: We draw the line above the circles we already drew, and the line generator produces
    the plot shown in [figure 4.16](#ch04fig16).
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在已经画出的圆圈上方画线，线生成器产生了[图4.16](#ch04fig16)中显示的图表。
- en: Figure 4.16\. The line generator takes the entire dataset and draws a line where
    the x,y position of every point on the canvas is based on its accessor. In this
    case, each point on the line corresponds to the day, and tweets are scaled to
    fit the x and y scales we created to display the data on the canvas.
  id: totrans-1080
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[图4.16]. 线生成器使用整个数据集绘制线条，其中画布上每个点的x,y位置基于其访问器。在这种情况下，线上的每个点对应于一天，推文被缩放到适合我们创建的x和y刻度，以便在画布上显示数据。'
- en: '![](../Images/04fig16.jpg)'
  id: totrans-1081
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/04fig16.jpg)'
- en: 4.4.2\. Drawing many lines with multiple generators
  id: totrans-1082
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.2\. 使用多个生成器绘制多条线
- en: If we build a line constructor for each datatype in our set and call each with
    its own path, as shown in the following listing, then you can see the variation
    over time for each of your datapoints. [Listing 4.9](#ch04ex09) demonstrates how
    to build those generators with our dataset, and [figure 4.17](#ch04fig17) shows
    the results of that code.
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为我们的集合中的每个数据类型构建一个线构造器，并像以下列表中所示的那样调用每个构造器，那么你可以看到每个数据点的随时间变化。[列表4.9](#ch04ex09)演示了如何使用我们的数据集构建这些生成器，[图4.17](#ch04fig17)显示了该代码的结果。
- en: Figure 4.17\. The dataset is first used to draw a set of circles, which creates
    the scatterplot from the beginning of this section. The dataset is then used three
    more times to draw each line.
  id: totrans-1084
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[图4.17]. 数据集首先用于绘制一组圆圈，这从本节的开头创建了散点图。然后数据集被用来绘制三条线。'
- en: '![](../Images/04fig17.jpg)'
  id: totrans-1085
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/04fig17.jpg)'
- en: Listing 4.9\. Line generators for each `tweetdata`
  id: totrans-1086
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.9\. 每个tweetdata的线生成器
- en: '[PRE139]'
  id: totrans-1087
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '***1* Naming and reusing functions is also a good use of const.**'
  id: totrans-1088
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 命名和重用函数也是const的一个良好用途。**'
- en: '***2* A more efficient way to do this would be to define one line generator
    and then modify the .y() accessor on the fly as we call it for each line, but
    it’s easier to see the functionality this way**'
  id: totrans-1089
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 一种更有效的方法是定义一个线生成器，然后在调用它时动态修改.y()访问器，但这样更容易看到功能。**'
- en: '***3* Notice how only the y accessor is different between each line generator.**'
  id: totrans-1090
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 注意到每个线生成器之间只有y访问器不同。**'
- en: '***4* Each line generator needs to be called by a corresponding new <path>
    element.**'
  id: totrans-1091
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 每个线生成器需要通过相应的新`<path>`元素来调用。**'
- en: 4.4.3\. Exploring line interpolation
  id: totrans-1092
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.3\. 探索线插值
- en: D3 provides a number of interpolation methods with which to draw these lines
    (as well as areas and diagonals and radial lines), exposed as the `.curve` method.
    In cases like `tweetdata`, where you have discrete points that represent data
    accurately and not samples, then the default “linear” method shown in [figure
    4.19](#ch04fig19) is appropriate. But in other cases, a different interpolation
    method for the lines, like the ones shown in [figure 4.18](#ch04fig18), may be
    appropriate. Here’s the same data but with the `d3.line()` generator using different
    interpolation methods. You’ll notice I’ve also lightened the axis ticks and labels
    quite significantly. Don’t be afraid to use very light tick marks, and don’t feel
    like your ticks need to only be black or grayscale.
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: D3提供了一系列插值方法来绘制这些线条（以及区域、对角线和径向线），这些方法作为`.curve`方法公开。在像`tweetdata`这样的情况下，你有的离散点准确地代表数据而不是样本，那么[图4.19](#ch04fig19)中显示的默认“线性”方法是合适的。但在其他情况下，可能需要不同的线条插值方法，如[图4.18](#ch04fig18)中所示的方法。这里展示的是相同的数据，但使用了`d3.line()`生成器并采用了不同的插值方法。你会注意到我还显著地淡化了轴的刻度和标签。不要害怕使用非常淡的刻度，也不要觉得你的刻度只能是黑色或灰度。
- en: Figure 4.18\. Three common curve methods you’ll see in charts. Orange is a “basis”
    interpolation that provides an organic curve averaged by the points (and therefore
    rarely touching them); a blue “step” interpolation changes the position of the
    line at right angles; and a green “cardinal” interpolation provides a curve that
    touches each sample point.
  id: totrans-1094
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.18\. 图表中常见的三种曲线方法。橙色是“基”插值，它通过点（因此很少接触它们）提供有机曲线的平均值；蓝色“步”插值改变线条在垂直方向上的位置；绿色“基数”插值提供一条接触每个样本点的曲线。
- en: '![](../Images/04fig18.jpg)'
  id: totrans-1095
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/04fig18.jpg)'
- en: Figure 4.19\. Behold the glory of the streamgraph. Look on my works, ye mighty,
    and despair! (Figure by Pitch Interactive from Wired, November 1, 2010, [www.wired.com/2010/11/ff_311_new_york/all/1](http://www.wired.com/2010/11/ff_311_new_york/all/1).)
    (Wesley Grubbs/WIRED © Condé Nast)
  id: totrans-1096
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.19\. 欣赏流图的辉煌。看看我的作品，你们这些强者，绝望吧！（图片来自Pitch Interactive，Wired杂志，2010年11月1日，[www.wired.com/2010/11/ff_311_new_york/all/1](http://www.wired.com/2010/11/ff_311_new_york/all/1)。（Wesley
    Grubbs/WIRED © Condé Nast）
- en: '![](../Images/04fig19_alt.jpg)'
  id: totrans-1097
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/04fig19_alt.jpg)'
- en: '[PRE140]'
  id: totrans-1098
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '***1* We can add this code right after we create our line generators and before
    we call them to change the interpolate method, or we can set .curve() as we’re
    defining the generator**'
  id: totrans-1099
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 我们可以在创建我们的线条生成器之后、在调用它们之前添加此代码，或者在我们定义生成器时设置 .curve()**'
- en: '|  |'
  id: totrans-1100
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**What’s the best interpolation?**'
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: '**最好的插值是什么？**'
- en: Interpolation modifies the representation of data. Experiment with this drawing
    code to see how the different interpolation settings show different information
    than other interpolators. Data can be visualized in different ways, all correct
    from a programming perspective, and it’s up to you to make sure the information
    you’re visualizing reflects the actual phenomena.
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: 插值会改变数据的表示。通过实验这段绘图代码，看看不同的插值设置如何显示与其他插值器不同的信息。数据可以以不同的方式可视化，从编程角度来看都是正确的，而确保你可视化的信息反映了实际现象则取决于你。
- en: Data visualization deals with the visual representation of statistical principles,
    which means it’s subject to all the dangers of the misuse of statistics. The interpolation
    of lines is particularly vulnerable to misuse, because it changes a clunky-looking
    line into a smooth, “natural” line.
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: 数据可视化处理的是统计原理的视觉表示，这意味着它容易受到统计误用的所有危险。线条的插值尤其容易误用，因为它将看起来笨拙的线条变成了平滑的、“自然”的线条。
- en: '|  |'
  id: totrans-1104
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 4.5\. Complex accessor functions
  id: totrans-1105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5\. 复杂的访问器函数
- en: All the previous chart types we built were based on points. The scatterplot
    is points on a grid, the boxplot consists of complex graphical objects in place
    of points, and line charts use points as the basis for drawing a line. In this
    and earlier chapters, we’ve dealt with rather staid examples of information visualization
    that we might easily create in any traditional spreadsheet. But you didn’t get
    into this business to make Excel charts. You want to wow your audience with beautiful
    data, win awards for your aesthetic *je ne sais quoi*, and evoke deep emotional
    responses with your representation of change over time. You want to make streamgraphs
    like the one in [figure 4.19](#ch04fig19).
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前构建的所有图表类型都是基于点的。散点图是网格上的点，箱线图由代替点的复杂图形对象组成，而折线图使用点作为绘制线条的基础。在本章和前面的章节中，我们处理了一些相对刻板的情报可视化示例，我们可以在任何传统的电子表格中轻松创建它们。但你进入这个领域不是为了制作Excel图表。你想要用美丽的数据震撼你的观众，为你的审美“我不知道什么”赢得奖项，并通过你对时间变化的表示唤起深刻的情感反应。你想要制作像图4.19中那样的流图。
- en: The streamgraph is a sublime piece of information visualization that represents
    variation and change, like the boxplot. It may seem like a difficult thing to
    create, until you start to put the pieces together. Ultimately, a streamgraph
    is a variant of what’s known as a *stacked chart*. The layers accrete upon each
    other and adjust the area of the elements above and below, based on the space
    taken up by the components closer to the center. It appears organic because that
    accretive nature mimics the way many organisms grow, and seems to imply the kinds
    of emergent properties that govern the growth and decay of organisms. We’ll interpret
    its appearance later, but first let’s figure out how to build it.
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: 流图是一种崇高的信息可视化作品，它代表变化和差异，就像箱线图。它可能看起来很难创建，直到你开始将这些部分组合在一起。最终，流图是所谓的堆叠图表的一种变体。层叠在一起，并基于靠近中心的组件所占用的空间调整上方和下方元素的区域。它看起来很自然，因为这种累积性质模仿了许多生物的生长方式，并似乎暗示了控制生物生长和衰亡的涌现性质。我们稍后会解释其外观，但首先让我们弄清楚如何构建它。
- en: The reason we’re looking at a streamgraph is because it’s not that exotic. A
    streamgraph is a stacked graph, which means it’s fundamentally similar to your
    earlier line charts. We’re going to make a simple stacked graph by hand in this
    last section but we won’t make a streamgraph (though you’ll learn how in the next
    chapter). By learning how to write the function to create a stacked graph, you
    can better understand another kind of generator, `d3.area()`. The first thing
    you need is data that’s amenable to this kind of visualization. Let’s follow work
    with the gross earnings for six movies over the course of nine days. Each datapoint
    is therefore the amount of money a movie made on a particular day.
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之所以研究流图，是因为它并不那么奇特。流图是一种堆叠图，这意味着它与您之前的折线图在本质上相似。在本节的最后部分，我们将手动制作一个简单的堆叠图，但不会制作流图（尽管你将在下一章中学习如何制作）。通过学习如何编写创建堆叠图的函数，你可以更好地理解另一种类型的生成器，`d3.area()`。首先，你需要的是适合这种可视化的数据。让我们继续处理九天内六部电影的票房收入。因此，每个数据点都是电影在特定一天所赚取的金额。
- en: Listing 4.10\. movies.csv
  id: totrans-1109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.10。movies.csv
- en: '[PRE141]'
  id: totrans-1110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: To build a stacked graph, you need to get more sophisticated with the way you
    access data and feed it to generators when drawing lines. In our earlier example,
    we created three different line generators for our dataset, but that’s terribly
    inefficient. We also used simple functions to draw the lines. But we’ll need more
    than that to draw something like a streamgraph. Even if you think you won’t want
    to draw streamgraphs (and there are reasons why you may not, which we’ll get into
    at the end of this section), the important thing to focus on when you look at
    the following listing is how you use accessors with D3’s line and, later, area
    generators.
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个堆叠图，你需要更深入地了解你访问数据的方式，并在绘制线条时将其馈送到生成器中。在我们之前的例子中，我们为我们的数据集创建了三个不同的行生成器，但这非常低效。我们还使用了简单的函数来绘制线条。但为了绘制类似流图的东西，我们需要更多。即使你认为你不会想要绘制流图（而且可能有一些原因，我们将在本节末尾讨论），当你查看以下列表时，重要的是要关注的是你如何使用访问器与D3的线条生成器以及稍后的面积生成器。
- en: Listing 4.11\. The callback function to draw movies.csv as a line chart
  id: totrans-1112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.11。绘制movies.csv为折线图的回调函数
- en: '[PRE142]'
  id: totrans-1113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '***1* Iterates through our data attributes with forEach, where x is the name
    of each column from our data (“day”, “movie1”, “movie2”, and so on), which allows
    us to dynamically create and call generators**'
  id: totrans-1114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用forEach遍历我们的数据属性，其中x是数据中每列的名称（“day”，“movie1”，“movie2”等等），这使我们能够动态创建和调用生成器**'
- en: '***2* Instantiates a line generator for each movie**'
  id: totrans-1115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 为每部电影实例化一个行生成器**'
- en: '***3* Every line uses the day column for its x value**'
  id: totrans-1116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 每条线都使用“day”列作为其x值**'
- en: '***4* Dynamically sets the y-accessor function of our line generator to grab
    the data from the appropriate movie for our y variable**'
  id: totrans-1117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 动态设置我们的行生成器的y访问器函数，以从适当的电影中获取我们的y变量数据**'
- en: The line-drawing code produces a cluttered line chart, as shown in [figure 4.20](#ch04fig20).
    As you learned in [chapter 1](../Text/kindle_split_010.html#ch01), lines and filled
    areas are almost exactly the same thing in SVG. You can differentiate them by
    a *Z* at the end of the drawing code that indicates the shape is closed, or the
    presence or absence of a `"fill"` style. D3 provides `d3.line` and `d3.area` generators
    to draw lines or areas. Both of these constructors produce `<path>` elements,
    but `d3.area`, which you can see in use in [listing 4.12](#ch04ex12), provides
    helper functions to bound the lower end of your path to produce areas in charts.
    We need to define a `.y0()` accessor that corresponds to our `y` accessor and
    determines the shape of the bottom of our area. Let’s see how `d3.area()` works.
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: 线绘制代码会产生一个杂乱的线形图，如图 4.20 所示。正如你在第 1 章[学习 SVG](../Text/kindle_split_010.html#ch01)中学到的，线条和填充区域在
    SVG 中几乎是完全相同的东西。你可以通过在绘制代码末尾的 *Z* 来区分它们，这表示形状是闭合的，或者通过 `"fill"` 样式的存在或不存在来区分。D3
    提供了 `d3.line` 和 `d3.area` 生成器来绘制线条或区域。这两个构造函数都产生 `<path>` 元素，但 `d3.area`，如你在[列表
    4.12](#ch04ex12)中看到的那样，提供了辅助函数来将路径的底部端点绑定到图表中的区域。我们需要定义一个 `.y0()` 访问器，它对应于我们的
    `y` 访问器，并确定区域底部的形状。让我们看看 `d3.area()` 是如何工作的。
- en: Figure 4.20\. Each movie column is drawn as a separate line. Notice how the
    “cardinal” interpolation creates a graphical artifact, where it seems several
    movies made negative money.
  id: totrans-1119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.20\. 每个电影列都作为一条单独的线绘制。注意“基数”插值如何创建一个图形伪影，似乎有几部电影亏损。
- en: '![](../Images/04fig20.jpg)'
  id: totrans-1120
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/04fig20.jpg)'
- en: Listing 4.12\. Area accessors
  id: totrans-1121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.12\. 面积访问器
- en: '[PRE143]'
  id: totrans-1122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '***1* This new accessor provides the ability to define where the bottom of
    the path is—in this case, we start by making the bottom equal to the inverse of
    the top, which mirrors the shape**'
  id: totrans-1123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 这个新的访问器提供了定义路径底部位置的能力——在这种情况下，我们首先将底部设置为顶部的倒数，这反映了形状**'
- en: '|  |'
  id: totrans-1124
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Should you always draw filled paths with d3.area?**'
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: '**您是否应该总是使用 d3.area 绘制填充路径？**'
- en: No. Counterintuitively, you should use `d3.line` to draw filled areas. To do
    so, though, you need to append *Z* to the created `d` attribute. This indicates
    that the path is closed.
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: 不。出人意料的是，你应该使用 `d3.line` 来绘制填充区域。但是，为了做到这一点，你需要将 *Z* 添加到创建的 `d` 属性中。这表示路径是闭合的。
- en: '| Open path Explanation | Closed path changes |'
  id: totrans-1127
  prefs: []
  type: TYPE_TB
  zh: '| 开放路径说明 | 闭合路径变化 |'
- en: '| --- | --- |'
  id: totrans-1128
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE144]'
  id: totrans-1130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '|'
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: You write the con structor for the line-drawing code the same regardless of
    whether you want a line or shape, filled or unfilled.
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你想绘制线条还是形状，填充还是非填充，你编写线绘制代码的方式都是相同的。
- en: '|'
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE145]'
  id: totrans-1134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '|'
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE146]'
  id: totrans-1136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '|'
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: When you call theconstructor, you append a `<path>` element. You specify whether
    the line is “closed” by concate nating a Z to the string created by your line
    constructor for the attribute of the `<path>`.
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用构造函数时，你添加一个 `<path>` 元素。你通过将 Z 添加到你的线构造函数创建的字符串中，指定 `<path>` 的属性是否“闭合”。
- en: '![](../Images/158fig01.jpg)'
  id: totrans-1139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/158fig01.jpg)'
- en: When you add a Z to the end of an SVG `<path>` element’s attribute, it draws
    a line connecting the two end points.
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 SVG `<path>` 元素的属性末尾添加一个 Z 时，它会绘制一条连接两个端点的线。
- en: '|'
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE147]'
  id: totrans-1142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '|'
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE148]'
  id: totrans-1144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '|'
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: You may think that only a closed path could be filled, but the fill of a path
    is the same whether or not you close the line by appending Z.
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为只有闭合路径才能填充，但路径的填充与是否通过添加 Z 来闭合线条无关。
- en: '![](../Images/158fig02.jpg)'
  id: totrans-1147
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/158fig02.jpg)'
- en: The area of a path filled is always the same, whether it’s closed or not.
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: 填充路径的面积始终相同，无论它是闭合的还是开放的。
- en: You use d3.line when you want to draw most shapes and lines, whether filled
    or unfilled, or closed or open. You should use d3.area when you want to draw a
    shape where the bottom of the shape can be calculated based on the top of the
    shape as you’re drawing it. It’s suitable for drawing bands of data, such as that
    found in a stacked area chart or streamgraph.
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想绘制大多数形状和线条，无论是填充还是非填充，闭合还是开放时，你使用 d3.line。当你想绘制一个底部可以根据你绘制的形状的顶部来计算的形状时，你应该使用
    d3.area。它适合绘制数据带，例如在堆叠面积图或流图中找到的数据带。
- en: '|  |'
  id: totrans-1150
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: By defining the `y0` function of `d3.area`, as in [listing 4.13](#ch04ex13),
    we’ve mirrored the path created and filled it, as shown in [figure 4.21](#ch04fig21),
    which is a step in the right direction. Notice that we’re presenting inaccurate
    data now, because the area of the path is twice the area of the data. We want
    our areas to draw one on top of the other, so we need `.y0()` to point to a complex
    stacking function that makes the bottom of an area equal to the top of the previously
    drawn area. D3 comes with a stacking function, `d3.stack()`, which we’ll look
    at later, but for the purpose of our example, we’ll write our own.
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: 通过定义`d3.area`的`y0`函数，如[代码列表4.13](#ch04ex13)所示，我们已经镜像了创建的路径并填充了它，如图4.21所示，这是正确方向的一个步骤。注意，我们现在呈现的数据不准确，因为路径的面积是数据面积的两倍。我们希望我们的面积能够一个叠一个地绘制，因此我们需要`.y0()`指向一个复杂的堆叠函数，使得一个面积底部等于之前绘制的面积顶部。D3提供了一个堆叠函数`d3.stack()`，我们将在后面讨论，但为了我们示例的目的，我们将编写自己的函数。
- en: Figure 4.21\. By using an area generator and defining the bottom of the area
    as the inverse of the top, we can mirror our lines to create an area chart. Here
    they’re drawn with semitransparent fills, so that we can see how they overlap.
  id: totrans-1152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.21。通过使用面积生成器并定义面积底部为顶部的倒数，我们可以镜像我们的线条以创建面积图。这里它们以半透明填充的形式绘制，这样我们就可以看到它们是如何重叠的。
- en: '![](../Images/04fig21.jpg)'
  id: totrans-1153
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/04fig21.jpg)'
- en: Listing 4.13\. Callback function for drawing stacked areas
  id: totrans-1154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.13。绘制堆叠面积回调函数
- en: '[PRE149]'
  id: totrans-1155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '***1* Creates a color ramp that corresponds to the six different movies**'
  id: totrans-1156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建一个与六种不同电影对应的颜色渐变条**'
- en: '***2* We won’t draw a line for the day value of each object, because this is
    what provides us with our x coordinate**'
  id: totrans-1157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 我们不会为每个对象的日值绘制线条，因为这为我们提供了x坐标**'
- en: '***3* A d3.area() generator for each iteration through the object that corresponds
    to one of our movies using the day value for the x coordinate, but iterating through
    the values for each movie for the y coordinates**'
  id: totrans-1158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 为每个通过对象迭代的迭代创建一个`d3.area()`生成器，该对象对应于我们的电影之一，使用日值作为x坐标，但对于每个电影的y坐标值进行迭代**'
- en: '***4* Draws a path using the current constructor. We’ll have one for each attribute
    not named “day”. Give it a unique ID based on which attribute we’re drawing an
    area for. Fill the area with a color based on the color ramp we built.**'
  id: totrans-1159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 使用当前构造函数绘制路径。对于每个不命名为“day”的属性，我们将有一个。根据我们为哪个属性绘制面积，给它一个唯一的ID。根据我们构建的颜色渐变条填充面积。**'
- en: '***5* This function takes the incoming bound data and the name of the attribute
    and loops through the incoming data, adding each value until it reaches the current
    named attribute. As a result, it returns the total value for every movie during
    this day up to the movie we’ve sent.**'
  id: totrans-1160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 此函数接受传入的边界数据和属性名称，并遍历传入的数据，添加每个值，直到达到当前命名的属性。因此，它返回在此天及之前发送的电影的每日总价值。**'
- en: The stacked area chart in [figure 4.22](#ch04fig22) is already complex. To make
    it a proper streamgraph, the stacks need to alternate. This requires a more complicated
    stacking function like the kind you’ll see in [chapter 5](../Text/kindle_split_014.html#ch05).
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4.22](#ch04fig22) 中的堆叠面积图已经相当复杂。为了使其成为一个合适的流图，堆叠需要交替。这需要一个更复杂的堆叠函数，就像你将在[第5章](../Text/kindle_split_014.html#ch05)中看到的那样。'
- en: Figure 4.22\. Our stacked area code represents a movie by drawing an area, where
    the bottom of that area equals the total amount of money made by any movies drawn
    earlier for that day.
  id: totrans-1162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.22。我们的堆叠面积代码通过绘制面积来表示电影，其中该面积底部等于当天之前绘制的任何电影的累计收入总额。
- en: '![](../Images/04fig22.jpg)'
  id: totrans-1163
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/04fig22.jpg)'
- en: The purpose of this section is to focus on building complex accessor functions
    to create, from scratch, the kinds of data visualization you’ve seen and likely
    thought of as exotic. Let’s assume this data is correct and take a moment to analyze
    the effectiveness of this admittedly attractive method of visualizing data. Is
    this really a better way to show movie grosses than a simpler line chart? That
    depends on the scale of the questions being addressed by the chart. If you’re
    trying to discover overall patterns of variation in movie grosses, as well as
    spot interactions between them (for instance, seeing if a particularly high-grossing-over-time
    movie interferes with the opening of another movie), then it may be useful. If
    you’re trying to impress an audience with a complex-looking chart, it would also
    be useful. Otherwise, you’ll be better off with something simpler than this. But
    even if you only build less-visually impressive charts, you’ll still use the same
    techniques we’ve gone over in this section.
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的目的在于专注于构建复杂的访问器函数，从头开始创建你所看到的数据可视化类型，你很可能认为它们是异国情调的。让我们假设这些数据是正确的，并花一点时间来分析这种公认吸引人的数据可视化方法的有效性。这真的是比简单的折线图更好地展示电影票房的方式吗？这取决于图表所解决的问题的规模。如果你试图发现电影票房的整体变化模式，以及它们之间的相互作用（例如，查看一个特别高票房的电影是否会干扰另一部电影的上映），那么这可能是有用的。如果你试图用复杂的图表来给观众留下深刻印象，这也会很有用。否则，你将更好地使用比这更简单的东西。但即使你只构建不那么引人注目的图表，你仍然会使用本节中介绍过的相同技术。
- en: 4.6\. Using third-party D3 modules to create legends
  id: totrans-1165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.6\. 使用第三方 D3 模块创建图例
- en: 'Unlike axes, there isn’t anything in core D3 that allows you to easily generate
    a legend for your charts, which is a shame because every chart needs a legend.
    Fortunately, there are additional generators and components created by other software
    developers to extend the D3 library, using the same metaphors and functions. One
    of those is d3-svg-legend created by Susie Lu, which you can read more about at
    [http://d3-legend.susielu.com](http://d3-legend.susielu.com). If you’re using
    NPM you can add it to your project the way you would any other D3 module, `npm
    i d3-svg-legend` or, if you’re building flat untranspiled code like we have in
    our examples, you can use a script tag in your header to include it:'
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: 与轴不同，核心 D3 中没有提供任何可以让你轻松为图表生成图例的功能，这很遗憾，因为每个图表都需要图例。幸运的是，其他软件开发者创建了额外的生成器和组件来扩展
    D3 库，使用相同的隐喻和函数。其中之一是由 Susie Lu 创建的 d3-svg-legend，你可以在 [http://d3-legend.susielu.com](http://d3-legend.susielu.com)
    上了解更多信息。如果你使用 NPM，你可以像添加任何其他 D3 模块一样将其添加到你的项目中，`npm i d3-svg-legend`，或者如果你正在构建像我们示例中的扁平未转换代码，你可以在你的页眉中使用一个脚本标签来包含它：
- en: '[PRE150]'
  id: totrans-1167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'The d3-svg-legend module exposes three kinds of legends that you’d use for
    data visualization: legends that describe items by size, color, or symbol. We’ll
    look at legendColor for our example, but you should explore the documentation
    for d3-svg-legend to see how the other legends work, because you’ll undoubtedly
    have use cases for them. Building off the code from the last section, add what
    you see in the following listing. We’re also changing the SVG width parameter
    to 1000px so we have space to place the legend.'
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: d3-svg-legend 模块公开了三种用于数据可视化的图例类型：描述项目大小、颜色或符号的图例。我们将通过 legendColor 来查看我们的示例，但你应该探索
    d3-svg-legend 的文档，了解其他图例是如何工作的，因为你无疑会有使用这些图例的场景。基于上一节的代码，添加以下列表中的内容。我们还改变了 SVG
    宽度参数为 1000px，以便我们有空间放置图例。
- en: Listing 4.14\. Adding a color legen
  id: totrans-1169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.14\. 添加颜色图例
- en: '[PRE151]'
  id: totrans-1170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: It’s exactly the same way you deal with the axis component, and the result as
    we see in [figure 4.23](#ch04fig23) is that you’ve immediately shown your reader
    which color corresponds to which value you’ve mapped that color to. That’s one
    of the things you should look for when evaluating third-party modules for D3—that
    it exposes an API similar to the existing generators, components, and layouts
    in core D3\. The other things you should look for are wide adoption (number of
    installs on NPM, stars on GitHub) and good documentation. D3-svg-legend checks
    all these boxes.
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: 这与处理轴组件的方式完全相同，我们看到的结果是，你立即向读者展示了哪种颜色对应于你映射的哪种值。这是评估 D3 的第三方模块时应寻找的其中一件事——它暴露了一个类似于现有生成器、组件和核心
    D3 中的布局的 API。其他你应该寻找的事情包括广泛的采用（NPM 上的安装数量，GitHub 上的星标）和良好的文档。D3-svg-legend 检查了所有这些框。
- en: Figure 4.23\. Our stacked chart with a legend telling the reader which color
    corresponds to which movie
  id: totrans-1172
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.23. 我们的堆叠图表，带有图例告诉读者哪种颜色对应哪种电影
- en: '![](../Images/04fig23_alt.jpg)'
  id: totrans-1173
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/04fig23_alt.jpg)'
- en: Another sign that d3-svg-legend is a good module—and one to look for in other
    modules—is that it exposes a number of customization options. By default we get
    the vertical legend with squares like you see in [figure 4.23](#ch04fig23), but
    we can adjust several of its options, like `orient` and `shapePadding`, as seen
    in the following listing, and we’ll get a different legend that looks like [figure
    4.24](#ch04fig24).
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: d3-svg-legend 是一个优秀的模块，并且是其他模块中值得寻找的模块，另一个标志是它暴露了大量的自定义选项。默认情况下，我们得到一个垂直图例，类似于你在[图4.23](#ch04fig23)中看到的，但我们可以调整其多个选项，如
    `orient` 和 `shapePadding`，如以下列表所示，我们将得到一个看起来像[图4.24](#ch04fig24)的不同图例。
- en: Figure 4.24\. A horizontal oriented colorLegend from d3-svg-legend rendered
    with custom settings for `shapePadding`, `shapeWidth`, and `shapeHeight`.
  id: totrans-1175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.24. 使用自定义设置（`shapePadding`、`shapeWidth`和`shapeHeight`）渲染的d3-svg-legend的水平方向颜色图例
- en: '![](../Images/04fig24.jpg)'
  id: totrans-1176
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/04fig24.jpg)'
- en: Listing 4.15\. Adjusted legend settings
  id: totrans-1177
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.15. 调整图例设置
- en: '[PRE152]'
  id: totrans-1178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 4.7\. Summary
  id: totrans-1179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.7. 概述
- en: 'Generators such as `line()` and `area()` in `d3-shape` are the necessary building
    blocks to create the most common and powerful charts available: line charts and
    stacked area charts.'
  id: totrans-1180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d3-shape` 中的 `line()` 和 `area()` 生成器是创建最常见和强大的图表（如折线图和堆叠面积图）的必要构建块。'
- en: Create multipart graphical objects for charts like boxplots to encode several
    different datapoints into a single object.
  id: totrans-1181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为图表如箱线图创建多部分图形对象，以将多个不同的数据点编码到单个对象中。
- en: Implement built-in D3 components such as `axis()` and `legend()` to make your
    chart more legible.
  id: totrans-1182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现内置的D3组件，如 `axis()` 和 `legend()`，以使你的图表更易于阅读。
- en: Don’t be afraid to experiment with custom functionality like a new stacking
    algorithm for complex charts that might better suit your needs than out-of-the-box
    implementations.
  id: totrans-1183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要害怕尝试自定义功能，例如为复杂图表创建新的堆叠算法，这可能比现成的实现更适合你的需求。
- en: Chapter 5\. Layouts
  id: totrans-1184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第5章. 布局
- en: '*This chapter covers*'
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Understanding histogram and pie chart layouts
  id: totrans-1186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解直方图和饼图布局
- en: Learning about simple tweening
  id: totrans-1187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习简单的缓动
- en: Working with stack layouts
  id: totrans-1188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用堆叠布局
- en: Using Sankey diagrams and word clouds
  id: totrans-1189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用桑基图和词云
- en: D3 contains a variety of functions, referred to as *layouts*, that help you
    format your data so that it can be presented using a popular charting method.
    In this chapter we’ll look at several different layouts so that you can understand
    general layout functionality, learn how to deal with D3’s layout structure, and
    deploy one of these layouts (several of which are shown in [figure 5.1](#ch05fig01))
    with your data.
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: D3包含各种称为*布局*的函数，这些函数可以帮助你格式化数据，以便可以使用流行的图表方法展示。在本章中，我们将探讨几种不同的布局，以便你了解一般的布局功能，学习如何处理D3的布局结构，并使用你的数据部署这些布局之一（其中一些在[图5.1](#ch05fig01)中展示）。
- en: Figure 5.1\. Multiple layouts are demonstrated in this chapter, including the
    circle pack ([section 5.3](#ch05lev1sec3)), tree ([section 5.4](#ch05lev1sec4)),
    stack ([section 5.5](#ch05lev1sec5)), and Sankey (section 5.6.1), as well as tweening
    to properly animate shapes like the arcs in pie charts ([section 5.2.3](#ch05lev2sec6)).
  id: totrans-1191
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.1. 本章演示了多种布局，包括圆包布局([第5.3节](#ch05lev1sec3))、树布局([第5.4节](#ch05lev1sec4))、堆叠布局([第5.5节](#ch05lev1sec5))和桑基图布局(第5.6.1节)，以及用于正确动画化形状（如饼图中的弧线）的缓动([第5.2.3节](#ch05lev2sec6))。
- en: '![](../Images/05fig01.jpg)'
  id: totrans-1192
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/05fig01.jpg)'
- en: In each case, as you’ll see with upcoming examples, when a dataset is associated
    with a layout, each of the objects in the dataset has attributes that allow for
    drawing the data. Layouts don’t draw the data, nor are they called like components
    or referred to in the drawing code like generators. Rather, they’re a preprocessing
    step that formats your data so that it’s ready to be displayed in the form you’ve
    chosen. You can update a layout and then if you rebind that altered data to your
    graphical objects, you can use the D3 enter/update/exit syntax you encountered
    in [chapter 2](../Text/kindle_split_011.html#ch02) to update your layout. Paired
    with animated transitions, this can provide you with the framework for an interactive,
    dynamic chart.
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，正如你将在接下来的示例中看到的那样，当数据集与布局相关联时，数据集中的每个对象都有允许绘制数据的属性。布局不会绘制数据，也不是像组件一样被调用或在绘图代码中像生成器一样引用。相反，它们是一个预处理步骤，将你的数据格式化，以便以你选择的形式显示。你可以更新一个布局，然后如果你将更改后的数据重新绑定到你的图形对象上，你可以使用你在[第2章](../Text/kindle_split_011.html#ch02)中遇到的D3
    enter/update/exit语法来更新你的布局。与动画过渡相结合，这可以为你提供一个交互式、动态图表的框架。
- en: This chapter gives an overview of layout structure by implementing popular layouts
    such as the histogram, pie chart, tree, and circle packing. Other layouts, such
    as the chord layout and more exotic ones, follow the same principles and should
    be easy to understand after looking at these. We’ll get started with a kind of
    chart you’ve already worked with, the bar chart or histogram, which has its own
    layout that helps abstract the process of building this kind of chart.
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: 本章通过实现流行的布局，如直方图、饼图、树形图和圆形打包等，概述了布局结构。其他布局，如弦图和更复杂的布局，遵循相同的原则，在查看这些布局后应该容易理解。我们将从一个你已经使用过的图表类型开始，即条形图或直方图，它有自己的布局，有助于抽象构建此类图表的过程。
- en: 5.1\. Histograms
  id: totrans-1195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1\. 直方图
- en: Before we get into charts that you’ll need layouts for, first we’ll create a
    chart that we easily made without a layout. In [chapter 2](../Text/kindle_split_011.html#ch02),
    we made a bar chart based on our Twitter data by using `d3.nest()`. But D3 has
    a layout, `d3.histogram()`, that bins values automatically and provides us with
    the necessary settings to draw a bar chart based on a scale that we’ve defined.
    Many people who get started with D3 think it’s a charting library and that they’ll
    find a function like `d3.histogram` that creates a bar chart in a `<div>` when
    it’s run. But D3 layouts don’t result in charts; they result in the settings necessary
    for charts. You have to put in a bit of extra work for charts, but you have enormous
    flexibility (as you’ll see in this and later chapters) that allows you to make
    diagrams and charts that you can’t find in other libraries.
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究需要布局的图表之前，首先我们将创建一个我们容易制作的图表，而不需要布局。在[第2章](../Text/kindle_split_011.html#ch02)中，我们通过使用`d3.nest()`根据我们的Twitter数据制作了一个条形图。但D3有一个布局，`d3.histogram()`，它可以自动分箱值，并为我们提供必要的设置，以便根据我们定义的刻度绘制条形图。许多刚开始使用D3的人认为它是一个图表库，并且他们会在运行时找到一个像`d3.histogram`这样的函数，在`<div>`中创建一个条形图。但D3布局不会产生图表；它们产生的是图表所需的设置。你必须做一些额外的工作来制作图表，但你将获得巨大的灵活性（正如你将在本章和后续章节中看到的），这允许你制作在其他库中找不到的图表和图形。
- en: 5.1.1\. Drawing a histogram
  id: totrans-1197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.1\. 绘制直方图
- en: '[Listing 5.1](#ch05ex01) shows the code to create a histogram layout and associate
    it with a particular scale. I’ve also included an example of how you can use interactivity
    to adjust the original layout and rebind the data to your shapes. This changes
    the histogram from showing the number of tweets that were favorited to the number
    of tweets that were retweeted.'
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表5.1](#ch05ex01)显示了创建直方图布局并将其与特定刻度关联的代码。我还包括了一个示例，说明你可以如何使用交互性来调整原始布局并将数据重新绑定到你的形状上。这改变了直方图，从显示被赞的推文数量变为显示被转发推文数量。'
- en: Listing 5.1\. Histogram code
  id: totrans-1199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.1\. 直方图代码
- en: '[PRE153]'
  id: totrans-1200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '***1* Creates a new layout function**'
  id: totrans-1201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建一个新的布局函数**'
- en: '***2* Determines the values the histogram bins for**'
  id: totrans-1202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 确定直方图分箱的值**'
- en: '***3* Formats the data**'
  id: totrans-1203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 格式化数据**'
- en: '***4* Formatted data is used to draw the bars**'
  id: totrans-1204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 使用格式化数据绘制条形**'
- en: '***5* Centers the axis labels under the bars**'
  id: totrans-1205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 将轴标签居中于条形下方**'
- en: 'You pass `d3.histogram` an array of data, a number of bins, and a scale, and
    it returns to you an array of bins filled with the data that falls into a particular
    bin at a particular scale, which you can then bind to elements and create a bar
    chart like the one in [figure 5.2](#ch05fig02). In this context, a *bin* is the
    label for data that falls within a certain range, and you’ll hear the term *binning*
    used to refer to aggregating data points into discrete groups of data points based
    on value. Second, you’re still using the same generators and components that you
    needed when you created a bar chart from raw data without the help of a layout.
    The `axisBottom` component is in this case being sent five ticks. Third, the histogram
    is useful because it automatically bins data, whether it’s whole numbers like
    this or it falls in a range of values in a scale. Finally, if you want to change
    a chart using a different dimension of your data, you don’t need to remove the
    original. You need to reformat your data using the layout and rebind it to the
    original elements, preferably with a transition. You’ll see this in more detail
    in your next example, which uses another type of chart: pie charts.'
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: 你将数据数组、桶的数量和比例传递给 `d3.histogram`，它将返回一个包含特定比例下特定桶中数据的桶数组，然后你可以将其绑定到元素上并创建一个类似于[图5.2](#ch05fig02)的条形图。在这种情况下，*桶*是表示落在一定范围内的数据的标签，你将听到*分桶*这个术语被用来指代根据值将数据点聚合到离散的数据点组中。其次，你仍然在使用当你从原始数据创建条形图而不使用布局帮助时所需的相同生成器和组件。在这种情况下，`axisBottom`组件被发送五个刻度。第三，直方图很有用，因为它可以自动分桶数据，无论是像这样是整数还是落在比例值范围内。最后，如果你想使用数据的不同维度更改图表，你不需要删除原始的。你需要使用布局重新格式化你的数据，并将其重新绑定到原始元素上，最好使用过渡效果。你将在下一个示例中更详细地看到这一点，该示例使用另一种类型的图表：饼图。
- en: Figure 5.2\. The histogram in its initial state before we change the measure
    from favorites to retweets by clicking on one of the bars
  id: totrans-1207
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.2。在通过点击其中一个条形将度量从点赞数更改为转发数之前，直方图在其初始状态
- en: '![](../Images/05fig02.jpg)'
  id: totrans-1208
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/05fig02.jpg)'
- en: Let’s look at the data that histogram produces. One way to do this is by `console.log(histoData)`
    after you process it. You’ll see the array in [figure 5.3](#ch05fig03). The array
    has been extended so that each array item has an x0 and x1 value that corresponds
    to the top and bottom thresholds of that bin. The array length indicates the number
    of items in that bin. And that’s all there is to that function, but it’s enough
    to provide us with sufficient drawing instructions to render the chart in [figure
    5.2](#ch05fig02).
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看直方图产生的数据。一种方法是处理数据后通过 `console.log(histoData)` 来查看。你将在[图5.3](#ch05fig03)中看到数组。数组已被扩展，以便每个数组项都有一个x0和x1值，对应于该桶的顶部和底部阈值。数组的长度表示该桶中的项目数量。这就是该函数的全部内容，但它足以为我们提供足够的绘图指令来渲染[图5.2](#ch05fig02)中的图表。
- en: Figure 5.3\. The processed data from `d3.histogram` returns an array where each
    array item also has an x0 and x1 field.
  id: totrans-1210
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.3。`d3.histogram`处理后的数据返回一个数组，其中每个数组项还有一个x0和x1字段。
- en: '![](../Images/05fig03.jpg)'
  id: totrans-1211
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/05fig03.jpg)'
- en: 5.1.2\. Interactivity
  id: totrans-1212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.2\. 交互性
- en: We can add interactivity to change the chart to render another view of the data
    when we click it. Because the data we used has more than one dimension to it,
    we can re-run `d3.histogram` to bin on another dimension and get updated drawing
    instructions that we can use for a new chart, as in the following listing.
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加交互性，以便在点击图表时渲染数据的另一个视图。因为我们使用的数据具有多个维度，我们可以重新运行 `d3.histogram` 来在另一个维度上分桶，并获取用于新图表的更新绘图指令，如下所示。
- en: Listing 5.2\. Histogram interactivity
  id: totrans-1214
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.2。直方图交互性
- en: '[PRE154]'
  id: totrans-1215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '***1* Changes the value being measured**'
  id: totrans-1216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 改变被测量的值**'
- en: '***2* Binds and redraws the new data**'
  id: totrans-1217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 绑定并重新绘制新数据**'
- en: We’re adding the click event to the individual rect elements out of convenience
    here. In a finished application you’d probably want to assign this to a button
    or other UI element. But for our purposes, this is fine, and clicking a rect produces
    the new chart of retweets in [figure 5.4](#ch05fig04).
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，我们在这里将点击事件添加到单个矩形元素上。在一个完成的应用程序中，你可能希望将其分配给按钮或其他UI元素。但就我们的目的而言，这很好，点击矩形将产生[图5.4](#ch05fig04)中转发次数的新图表。
- en: Figure 5.4\. The histogram chart we’ve built will make an animated transition
    to display tweets binned by the number of retweets instead of the number of favorites.
  id: totrans-1219
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.4。我们构建的直方图将进行动画过渡，以显示按转发次数而不是点赞次数分桶的推文。
- en: '![](../Images/05fig04.jpg)'
  id: totrans-1220
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/05fig04.jpg)'
- en: 5.1.3\. Drawing violin plots
  id: totrans-1221
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.3\. 绘制小提琴图
- en: I’ve taught D3 many people in different environments, and every time someone
    will ask me, “Why do D3 layouts provide such abstract data?” It’s a good question.
    After all, if you have a function called “histogram” shouldn’t it just, you know,
    make a histogram? What good is it to give you this intermediary piece on your
    way to a visualization? The answer is that there are more ways to visualize data
    than there are ways to process data, by the definition of the problem space. Using
    rectangles like I have in this chapter is only one way to show distribution data.
    Another is what we call a violin plot, and we’re going to use `d3.histogram` to
    create one right now.
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: 我在不同的环境中教过很多人D3，每次有人问我，“为什么D3布局提供如此抽象的数据？”这是一个好问题。毕竟，如果你有一个名为“histogram”的函数，你不应该只是，你知道，制作直方图吗？提供这个中间件有什么好处？答案是，根据问题空间的定义，可视化数据的方法比处理数据的方法更多。在本章中，使用矩形来展示分布数据只是其中一种方法。另一种是我们所说的小提琴图，我们将使用
    `d3.histogram` 来创建一个。
- en: A *violin plot* is a mirrored curved area that bulges where many datapoints
    exist and tapers where few exist. They’re commonly seen in medical diagrams dealing
    with dosage and efficacy but also used more generally to show distributions, and
    unlike a boxplot that only shows sample points, the violin plot encodes the entire
    distribution. First, though, we need to generate random data. D3 includes a few
    random number generators, because when you’re generating random numbers, counterintuitively,
    you don’t usually want truly random numbers, particularly when you want to look
    at distributions. We’ll use `d3.randomNormal` to provide normally distributed
    random numbers.
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: '*小提琴图*是一个镜像的弯曲区域，在数据点众多的地方膨胀，在数据点较少的地方变细。它们在处理剂量和效力的医学图表中很常见，也更多地用于展示分布，与只显示样本点的箱线图不同，小提琴图编码了整个分布。首先，我们需要生成随机数据。D3包含几个随机数生成器，因为当你生成随机数时，出人意料的是，你通常不希望得到真正的随机数，尤其是当你想查看分布时。我们将使用
    `d3.randomNormal` 来提供正态分布的随机数。'
- en: If we use `d3.histogram` to bin those random numbers, and then feed the results
    into a `d3.area` generator like we see in the following listing used in the last
    chapter, you’ll get violin plots like the kind you see in [figure 5.5](#ch05fig05).
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 `d3.histogram` 对这些随机数进行分箱，然后将结果输入到我们在上一章中看到的类似 `d3.area` 生成器中，你将得到如图5.5（[figure
    5.5](#ch05fig05)）中看到的小提琴图。
- en: Figure 5.5\. Three violin plots based on the data produced by `d3.histogram`
  id: totrans-1225
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.5\. 基于 `d3.histogram` 生成的三个小提琴图
- en: '![](../Images/05fig05.jpg)'
  id: totrans-1226
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/05fig05.jpg)'
- en: Listing 5.3\. Generating violin plots with d3.histogram
  id: totrans-1227
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.3\. 使用 d3.histogram 生成小提琴图
- en: '[PRE155]'
  id: totrans-1228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '***1* Generate three sample distributions**'
  id: totrans-1229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 生成三个样本分布**'
- en: '***2* The more thresholds, the smoother any distribution chart will look**'
  id: totrans-1230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 阈值越多，任何分布图看起来越平滑**'
- en: '***3* Unlike in the last chapter, we’ll draw these vertically**'
  id: totrans-1231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 与上一章不同，我们将垂直绘制这些图表**'
- en: '***4* Use a Catmull–Rom spline interpolation for the area generator**'
  id: totrans-1232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 使用Catmull-Rom样条插值法进行面积生成器**'
- en: '***5* We’re going to generate the area based on the data transformed by the
    histogram function**'
  id: totrans-1233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 我们将根据直方函数转换后的数据生成面积**'
- en: You see, because D3 provides you with that intermediary transformed data, you
    can decide how you might want to draw the final data visualization.
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: 你看，因为D3为你提供了那个中间转换数据，你可以决定你想要如何绘制最终的数据可视化。
- en: 5.2\. Pie charts
  id: totrans-1235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2\. 饼图
- en: In this section you’ll learn how to create a pie chart and transform it into
    a ring chart. You’ll also learn how to use tweening to properly transition it
    when you change its data source. After you create it, you can pass it an array
    of values (which I’ll call a *dataset*), and it will compute the necessary starting
    and ending angles for each of those values to draw a pie chart. When we pass an
    array of numbers as our dataset to a pie layout in the console, as in the following
    code, it doesn’t produce any kind of graphics like those seen in [figure 5.6](#ch05fig06)
    but rather results in the response shown in [figure 5.7](#ch05fig07).
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何创建饼图并将其转换为环形图。你还将学习如何使用缓动效果在更改数据源时正确过渡它。创建后，你可以传递一个包含值的数组（我将称之为 *数据集*），它将为每个值计算必要的起始和结束角度以绘制饼图。当我们把一个数字数组作为数据集传递给控制台中的饼图布局，如下面的代码所示，它不会产生如图5.6（[figure
    5.6](#ch05fig06)）中看到的任何图形，而是产生如图5.7（[figure 5.7](#ch05fig07)）所示的响应。
- en: Figure 5.6\. The traditional pie chart (bottom right) represents proportion
    as an angled slice of a circle. With slight modification, it can be turned into
    a donut or ring chart (top) or an exploded pie chart (bottom left).
  id: totrans-1237
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.6。传统的饼图（右下角）将比例表示为圆的倾斜切片。经过轻微修改，它可以变成甜甜圈图或环形图（顶部）或爆炸饼图（左下角）。
- en: '![](../Images/05fig06.jpg)'
  id: totrans-1238
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/05fig06.jpg)'
- en: Figure 5.7\. A pie layout applied to an array of [1,1,2] shows objects created
    with a start angle, end angle, and value attribute corresponding to the dataset,
    as well as the original data, which in this case is a number.
  id: totrans-1239
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.7。将饼图布局应用于数组[1,1,2]显示了具有起始角度、结束角度和值属性的对象，这些属性对应于数据集，以及原始数据，在这种情况下是一个数字。
- en: '![](../Images/05fig07_alt.jpg)'
  id: totrans-1240
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/05fig07_alt.jpg)'
- en: '[PRE156]'
  id: totrans-1241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: Our `pieChart` function created a new array of three objects. The `startAngle`
    and `endAngle` for each of the data values draw a pie chart with one piece from
    0 radians to pi radians, the next from pi to 1.5 pi radians, and the last from
    1.5 pi radians to 2 pi radians. But this isn’t a drawing or SVG code like the
    line and area generators produced. It doesn’t even have the virtue of the histogram
    response, which at least seems to map directly to coordinates (or coordinates
    we can pass to a scale).
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `pieChart` 函数创建了一个包含三个对象的新数组。每个数据值的 `startAngle` 和 `endAngle` 绘制一个饼图，从0弧度到π弧度，下一个从π到1.5π弧度，最后一个从1.5π弧度到2π弧度。但这并不是像线条和面积生成器产生的绘图或SVG代码。它甚至没有直方图响应的优点，至少它似乎直接映射到坐标（或我们可以传递给刻度的坐标）。
- en: 5.2.1\. Drawing the pie layout
  id: totrans-1243
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.1. 绘制饼图布局
- en: 'These are settings that need to be passed to a generator to make each of the
    pieces of our pie chart. This particular generator is `d3.arc` and it’s instantiated
    like the D3 generators we worked with in [chapter 4](../Text/kindle_split_013.html#ch04).
    As an aside, JavaScript has a whole class of functions known as *generators*,
    so keep in mind I’m referring to D3 functions that “generate” drawing instructions
    for paths. `d3.arc` has a few settings, but the only one we need for this first
    example is the `outerRadius`, which allows us to set a dynamic or fixed radius
    for our arcs:'
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是需要传递给生成器以制作我们饼图每一部分的设置。这个特定的生成器是 `d3.arc`，它的实例化方式与我们在第4章中使用的D3生成器相同。[第4章](../Text/kindle_split_013.html#ch04)。顺便提一下，JavaScript有一个名为
    *generators* 的函数类，所以请记住，我指的是D3函数，这些函数“生成”路径的绘图指令。`d3.arc`有几个设置，但在这个第一个例子中我们只需要
    `outerRadius`，这允许我们为我们的弧设置动态或固定半径：
- en: '[PRE157]'
  id: totrans-1245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '***1* Gives our arcs and resulting pie chart a radius of 100 px**'
  id: totrans-1246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 给我们的弧和生成的饼图设置一个100 px的半径**'
- en: '***2* Returns the d attribute necessary to draw this arc as a <path> element:
    “M6.123031769111886e-15,100A100,100 0 0,1 -100,1.2246063538223773e-14L0,0Z”**'
  id: totrans-1247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 返回绘制此弧所需的d属性，作为 <path> 元素：“M6.123031769111886e-15,100A100,100 0 0,1 -100,1.2246063538223773e-14L0,0Z”**'
- en: 'Now that you know how the arc constructor works and that it works with our
    data, all we need to do is bind the data created by our pie layout and pass it
    to `<path>` elements to draw our pie chart. The pie layout is centered on the
    0,0 point in the same way as a circle. If we want to draw it at the center of
    our canvas, we need to create a new `<g>` element to hold the `<path>` elements
    we’ll draw and then move the `<g>` to the center of the canvas:'
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了弧构造函数的工作原理，并且它与我们数据兼容，我们只需要绑定由我们的饼图布局创建的数据，并将其传递给 `<path>` 元素以绘制我们的饼图。饼图布局以0,0点为中心，就像一个圆一样。如果我们想在画布中心绘制它，我们需要创建一个新的
    `<g>` 元素来包含我们将绘制的 `<path>` 元素，然后将 `<g>` 移到画布中心：
- en: '[PRE158]'
  id: totrans-1249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '***1* Appends a new <g> and moves it to the middle of the canvas so that it’ll
    be easier to see the results**'
  id: totrans-1250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 添加一个新的 <g> 并将其移动到画布中间，这样就可以更容易地看到结果**'
- en: '***2* Binds the array that was created using the pie layout, not our original
    array or the pie layout itself**'
  id: totrans-1251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 绑定使用饼图布局创建的数组，而不是我们的原始数组或饼图布局本身**'
- en: '***3* Each path drawn based on that array needs to pass through the newArc
    function, which sees the startAngle and endAngle attributes of the objects and
    produces the commensurate SVG drawing code**'
  id: totrans-1252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 基于该数组绘制的每个路径都需要通过新的 `arc` 函数，该函数查看对象的起始角度和结束角度属性，并产生相应的SVG绘图代码**'
- en: '[Figure 5.8](#ch05fig08) shows our pie chart. The pie chart layout, like most
    layouts, grows more complicated when you want to work with JSON object arrays
    rather than number arrays. Let’s bring back our tweets.json from [chapter 2](../Text/kindle_split_011.html#ch02).
    We can nest and measure it to transform it from an array of tweets into an array
    of Twitter users with their number of tweets computed.'
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.8](#ch05fig08) 展示了我们的饼图。饼图布局，就像大多数布局一样，当你想要处理JSON对象数组而不是数字数组时，会变得更加复杂。让我们将我们的tweets.json从[第2章](../Text/kindle_split_011.html#ch02)中恢复出来。我们可以嵌套并测量它，将其从推文数组转换为包含推文数量的Twitter用户数组。'
- en: Figure 5.8\. A pie chart showing three pie pieces that subdivide the circle
    between the values in the array [1,1,2]
  id: totrans-1254
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.8\. 一个饼图，展示了将圆周分割成数组[1,1,2]中的值的三个饼块
- en: '![](../Images/05fig08.jpg)'
  id: totrans-1255
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/05fig08.jpg)'
- en: 'We get there by using `d3.nest()` with keys based on the user attribute of
    tweets. After nesting the tweets, we can measure their attributes and use those
    numerical measures for charts like these:'
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用基于推文用户属性的`d3.nest()`来实现这一点。在嵌套推文之后，我们可以测量它们的属性，并使用这些数值测量来绘制这些图表：
- en: '[PRE159]'
  id: totrans-1257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '***1* Gives the total number of favorites by summing the favorites array length
    of all the tweets**'
  id: totrans-1258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 通过对所有推文的收藏数组长度求和来给出总的收藏数**'
- en: '***2* Gives the total number of retweets by doing the same for the retweets
    array length**'
  id: totrans-1259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 通过对推文数组长度进行相同的操作来给出总的转发数**'
- en: 5.2.2\. Creating a ring chart
  id: totrans-1260
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.2\. 创建环形图
- en: 'If we execute `pieChart(nestedTweets)`as with the earlier array illustrated
    in [figure 5.7](#ch05fig07), it will fail, because it doesn’t know that the numbers
    we should be using to size our pie pieces come from the `.numTweets` attribute.
    Most layouts, pie included, can define where the values are in your array by defining
    an accessor function to get to those values. In the case of `nestedTweets`, we
    define `pieChart.value()` to point at the `numTweets` attribute of the dataset
    it’s being used on. While we’re at it, let’s set a value for our arc generator’s
    `innerRadius` so that we create a donut chart instead of a pie chart:'
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们像[图5.7](#ch05fig07)中较早的数组一样执行`pieChart(nestedTweets)`，它将会失败，因为它不知道我们应该用来确定饼块大小的数字来自`.numTweets`属性。包括饼图在内的大多数布局都可以通过定义一个访问器函数来定义数组中的值的位置。在`nestedTweets`的情况下，我们定义`pieChart.value()`来指向正在使用的数据集的`numTweets`属性。在此同时，让我们为我们的弧生成器的`innerRadius`设置一个值，以便创建一个环形图而不是饼图：
- en: '[PRE160]'
  id: totrans-1262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: With those changes in place, we can use the same code as before to draw the
    pie chart in [figure 5.9](#ch05fig09).
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些更改到位后，我们可以使用之前的相同代码来绘制[图5.9](#ch05fig09)中的饼图。
- en: Figure 5.9\. A donut chart showing the number of tweets from our four users
    represented in the `nestedTweets` dataset.
  id: totrans-1264
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.9\. 一个环形图，显示了`nestedTweets`数据集中我们四个用户的推文数量。
- en: '![](../Images/05fig09.jpg)'
  id: totrans-1265
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/05fig09.jpg)'
- en: 5.2.3\. Transitioning
  id: totrans-1266
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.3\. 转换
- en: 'You’ll notice that for each value in `nestedTweets`, we totaled the number
    of tweets and also used `d3.sum()`to total the number of retweets and favorites
    (if any). Because we have this data, we can adjust our pie chart to show pie pieces
    based not on the number of tweets but on those other values. One of the core uses
    of a layout in D3 is to update the graphical chart. All we need to do is make
    changes to the data or layout and then rebind the data to the existing graphical
    elements. By using a transition, we can see the pie chart change from one form
    to the other. Running the following code first transforms the pie chart to represent
    the number of favorites instead of the number of tweets. The next block causes
    the pie chart to represent the number of retweets. The final forms of the pie
    chart after running that code are shown in [figure 5.10](#ch05fig10):'
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，对于`nestedTweets`中的每个值，我们都计算了推文总数，并使用`d3.sum()`来计算转发数和收藏数（如果有）。因为我们有这些数据，我们可以调整饼图，使其基于推文数量以外的其他值来显示饼块。D3中布局的一个核心用途是更新图形图表。我们只需要更改数据或布局，然后将数据重新绑定到现有的图形元素上。通过使用过渡，我们可以看到饼图从一种形式变为另一种形式。首先运行以下代码将饼图转换为表示收藏数而不是推文数。下一个块导致饼图表示转发数。运行该代码后的饼图最终形式如[图5.10](#ch05fig10)所示：
- en: '[PRE161]'
  id: totrans-1268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: Figure 5.10\. The pie charts representing, on the left, the total number of
    favorites and, on the right, the total number of retweets
  id: totrans-1269
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.10\. 左侧表示总的收藏数，右侧表示总的转发数的饼图
- en: '![](../Images/05fig10.jpg)'
  id: totrans-1270
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/05fig10.jpg)'
- en: Although the results are what we want, the transition can leave a lot to be
    desired. [Figure 5.11](#ch05fig11) shows snapshots of the pie chart transitioning
    from representing the number of tweets to representing the number of favorites.
    As you’ll see by running the code and comparing these snapshots, the pie chart
    doesn’t smoothly transition from one state to another but instead distorts significantly.
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然结果是我们要的，但过渡可以有很多改进的空间。[图 5.11](#ch05fig11) 显示了饼图从表示推文数量过渡到表示点赞数量的快照。正如你通过运行代码并比较这些快照所看到的，饼图并没有平滑地从一种状态过渡到另一种状态，而是发生了显著扭曲。
- en: Figure 5.11\. Snapshots of the transition of the pie chart representing the
    number of tweets to the number of favorites. This transition highlights the need
    to assign key values for data binding and to use tweens for some types of graphical
    transition, such as that used for arcs.
  id: totrans-1272
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.11\. 表示推文数量到点赞数量的饼图过渡的快照。这个过渡突出了为数据绑定分配关键值和使用补间动画进行某些类型图形过渡（如用于弧线的过渡）的必要性。
- en: '![](../Images/05fig11.jpg)'
  id: totrans-1273
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/05fig11.jpg)'
- en: 'The reason you see this wonky transition is because, as you learned earlier,
    the default data-binding key is array position. When the pie layout measures data,
    it also sorts it in order from largest to smallest to create a more readable chart.
    But when you recall the layout, it re-sorts the dataset. The data objects are
    bound to different pieces in the pie chart, and when you transition between them
    graphically, you see the effect shown in [figure 5.11](#ch05fig11). To prevent
    this from happening, we need to disable this sort:'
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到这种奇怪的过渡的原因是因为，正如你之前学到的，默认的数据绑定键是数组位置。当饼图布局测量数据时，它也会按顺序从大到小排序以创建一个更易读的图表。但是当你调用布局时，它会重新排序数据集。数据对象绑定到饼图的不同部分，当你图形化地在它们之间过渡时，你会看到
    [图 5.11](#ch05fig11) 中显示的效果。为了防止这种情况发生，我们需要禁用这个排序：
- en: '[PRE162]'
  id: totrans-1275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: The result is a smooth graphical transition between `numTweets` and `numRetweets`,
    because the object position in the array remains unchanged, and so the transition
    in the drawn shapes is straightforward. But if you look closely, you’ll notice
    that the circle deforms a bit because the default `transition()` behavior doesn’t
    deal with arcs well. It’s not transitioning the radians in our arcs; instead,
    it’s treating each arc as a geometric shape and transitioning from one to another.
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是在 `numTweets` 和 `numRetweets` 之间有一个平滑的图形过渡，因为对象在数组中的位置保持不变，因此绘制的形状之间的过渡是直接的。但如果你仔细观察，你会注意到圆圈有点变形，因为默认的
    `transition()` 行为处理弧线不佳。它没有过渡我们弧线中的弧度；相反，它将每个弧线视为几何形状，并从一个过渡到另一个。
- en: This becomes obvious when you look at the transition from either of those versions
    of our pie chart to one that shows `numFavorites`, because several of the objects
    in our dataset have 0 values for that attribute, and one of them changes size
    dramatically. To clean this all up and make our pie chart transition properly,
    we need to change the code. Some of this you’ve already dealt with, such as using
    key values for your created elements and using them in conjunction with exit and
    update behavior. But to make our pie slices transition in a smooth, graphical
    manner, we need to extend our transitions, as shown in the following listing,
    to include a custom tween to define how an arc can grow or shrink graphically
    into a different arc.
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: 当你查看我们的饼图从这些版本之一过渡到显示 `numFavorites` 的版本时，这变得很明显，因为我们的数据集中的一些对象在该属性的值为 0，其中一个对象的大小发生了显著变化。为了清理这一切并使我们的饼图正确过渡，我们需要更改代码。其中一些你已经处理过了，比如为你的创建元素使用键值，并使用它们与退出和更新行为结合使用。但为了使我们的饼图切片以平滑、图形化的方式过渡，我们需要扩展我们的过渡，如下面的列表所示，包括一个自定义补间来定义弧线如何图形化地增长或缩小到另一个弧线。
- en: Listing 5.4\. Updated binding and transitioning for pie layout
  id: totrans-1278
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.4\. 更新饼图布局的绑定和过渡
- en: '[PRE163]'
  id: totrans-1279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '***1* Don’t sort the pie results so that they stay in the same order as the
    array you send**'
  id: totrans-1280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 不要对饼图结果进行排序，以便它们保持与您发送的数组相同的顺序***'
- en: '***2* Take the original dataset and add to each object the results of the pie
    layout**'
  id: totrans-1281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将原始数据集添加到每个对象中，并包含饼图布局的结果***'
- en: '***3* Notice we’re appending the original dataset because it has the drawing
    instructions now**'
  id: totrans-1282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 注意我们正在附加原始数据集，因为它现在有了绘图指令***'
- en: '***4* I’m only using a named function here instead of an arrow function because
    it’s longer and so it’s easier to read as a separate function**'
  id: totrans-1283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 我在这里使用的是命名函数而不是箭头函数，因为它更长，所以更容易作为一个单独的函数来阅读***'
- en: '***5* attrTween expects a function that takes the current transition value
    (a float between 0 and 1) and returns the interpolated value, in this case an
    arc drawn from the interpolated start and interpolated end angles**'
  id: totrans-1284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* `attrTween`期望一个函数，该函数接受当前的过渡值（介于0和1之间的浮点数）并返回插值值，在这种情况下是一个从插值起始角和插值结束角绘制的弧**'
- en: '***6* Because this is going into a d attribute, make sure to return the drawing
    instructions for the intermediary arc**'
  id: totrans-1285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 因为这要进入d属性，请确保返回中间弧的绘图指令**'
- en: The result of the code in [listing 5.4](#ch05ex04) is a pie chart that cleanly
    transitions the individual arcs.
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表5.4](#ch05ex04)中的代码结果是饼图，它干净地过渡到各个弧线。'
- en: 'We could label each pie piece `<path>` element, color it according to a measurement
    or category, or add interactivity. But rather than spend a chapter creating the
    greatest pie chart application you’ve ever seen, we’ll move on to another kind
    of layout that’s often used: the stack layout.'
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为每个饼图块标记`<path>`元素，根据测量值或类别着色，或添加交互性。但与其花费一整章来创建你见过的最伟大的饼图应用，我们不如继续介绍另一种常用的布局：堆叠布局。
- en: 5.3\. Stack layout
  id: totrans-1288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3\. 堆叠布局
- en: You saw the effects of the stack layout in the last chapter when we created
    a stacked area chart, and which we introduced by referring to the *Wired* streamgraph
    that we see again in [figure 5.12](#ch05fig12). This time, we’ll make a streamgraph,
    but we’ll begin with a simple stacking function and then use it in more complex
    ways. The `d3.stack` layout formats your data so that it can be easily passed
    to `d3.area` to draw a stacked graph or streamgraph.
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，当我们创建堆叠面积图时，你看到了堆叠布局的效果，我们通过引用我们在[图5.12](#ch05fig12)中再次看到的*Wired*流图来介绍它。这次，我们将制作一个流图，但我们将从一个简单的堆叠函数开始，然后以更复杂的方式使用它。`d3.stack`布局格式化你的数据，使其可以轻松传递给`d3.area`以绘制堆叠图或流图。
- en: Figure 5.12\. The streamgraph by Pitch Interactive used in a *Wired* piece describing
    the subject of calls to 311 (a city service for reporting problems) in New York
    (November 1, 2010; [https://www.wired.com/2010/11/ff_311_new_york/all/1](https://www.wired.com/2010/11/ff_311_new_york/all/1))
  id: totrans-1290
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.12\. Pitch Interactive使用的流图，用于描述纽约311（一个报告问题的城市服务）的主题，发布于2010年11月1日；[https://www.wired.com/2010/11/ff_311_new_york/all/1](https://www.wired.com/2010/11/ff_311_new_york/all/1))
- en: '![](../Images/05fig12_alt.jpg)'
  id: totrans-1291
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/05fig12_alt.jpg)'
- en: 'To implement this, we’ll use the area generator in tandem with the stack layout
    in [listing 5.5](#ch05ex05). This general pattern should be familiar to you by
    now:'
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将使用面积生成器与堆叠布局一起使用，如[列表5.5](#ch05ex05)。现在你应该对这个通用模式很熟悉了：
- en: Process the data to match the requirements of the layout.
  id: totrans-1293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理数据以匹配布局的要求。
- en: Set the accessor functions of the layout to align it with the dataset.
  id: totrans-1294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将布局的访问器函数设置为与数据集对齐。
- en: Use the layout to format the data for display.
  id: totrans-1295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用布局来格式化数据以供显示。
- en: Send the modified data either directly to SVG elements or paired with a generator
    like `d3.diagonal`, `d3.arc`, or `d3.area`.
  id: totrans-1296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将修改后的数据直接发送到SVG元素，或者与`d3.diagonal`、`d3.arc`或`d3.area`之类的生成器配对。
- en: The first step is to take our original movies.csv data and transform it into
    an array of movie objects that each have an array of values at points that correspond
    to the thickness of the section of the streamgraph that they represent.
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是将我们的原始`movies.csv`数据转换为包含值的数组，这些值对应于流图表示的各个部分的厚度。
- en: Listing 5.5\. Stack layout example
  id: totrans-1298
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.5\. 堆叠布局示例
- en: '[PRE164]'
  id: totrans-1299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '***1* The movies dataset happens to be perfectly suited to the default stack
    formatting—all you need to do is pass an array of keys for each object, which
    happens to also be the domain of our colorScale**'
  id: totrans-1300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 电影数据集恰好非常适合默认的堆叠格式——你所需要做的就是传递每个对象的键数组，这恰好也是我们的颜色比例的域**'
- en: '***2* The stack layout is going to return an array of two item arrays, the
    first is the lower bound and the second is the upper bound, and the index position
    can be used for the x-position**'
  id: totrans-1301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 堆叠布局将返回两个项目数组的数组，第一个是下限，第二个是上限，索引位置可以用于x位置**'
- en: '***3* Each array of stacked data has a key property that corresponds to the
    keys you sent in your layout generator**'
  id: totrans-1302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 每个堆叠数据的数组都有一个键属性，它与你在布局生成器中发送的键相对应**'
- en: 'After our `stackLayout` function processes our dataset, we can get the results
    by running `stackLayout(stackData)`. The layout creates an array of [ `y0, y1
    ]` values corresponding to the top and bottom of the object at the position of
    the item in the parent array. If we use the stack layout to create a streamgraph,
    it requires a corresponding area generator:'
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`stackLayout`函数处理我们的数据集之后，我们可以通过运行`stackLayout(stackData)`来获取结果。布局创建了一个与父数组中项目位置的物体顶部和底部相对应的`[y0,
    y1]`值的数组。如果我们使用堆叠布局来创建流图，它需要一个相应的区域生成器：
- en: '[PRE165]'
  id: totrans-1304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '***1* When your index position is sufficient, use that—otherwise d.data still
    has the original data, so if you need access to it for your scale, you can use
    that**'
  id: totrans-1305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 当你的索引位置足够时，使用它——否则d.data仍然包含原始数据，所以如果你需要为你的刻度访问它，你可以使用它**'
- en: After we have our data, layout, and area generator in order, we can call them
    all as part of the selection and binding process. This gives a set of SVG `<path>`
    elements the necessary shapes to make our chart. The result, as shown in [figure
    5.13](#ch05fig13), isn’t a streamgraph but rather a stacked area chart of the
    kind we made manually in the last chapter. This isn’t that different from a streamgraph,
    as you’ll soon find out.
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们整理好数据、布局和区域生成器之后，我们可以在选择和绑定过程中调用它们。这给了一组SVG `<path>`元素必要的形状来制作我们的图表。结果，如图5.13所示，不是一个流图，而是一个堆叠面积图，就像我们在上一章中手动制作的图表。这与你很快会发现的不同并不大。
- en: Figure 5.13\. The stack layout default settings, when tied to an area generator,
    produce a stacked area chart like this one.
  id: totrans-1307
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.13. 当与区域生成器关联时，堆叠布局的默认设置会产生这样的堆叠面积图。
- en: '![](../Images/05fig13.jpg)'
  id: totrans-1308
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/05fig13.jpg)'
- en: 'The stack layout has an `.offset()` function that determines the relative positions
    of the areas that make up the chart. Although we can write our own offset functions
    to create exotic charts, D3 includes several functions to achieve the typical
    effects we’re looking for. We’ll use the `d3.stackOffsetSilhouette` keyword, which
    centers the drawing of the stacked areas around the middle. Another method you’ll
    need to take advantage of for creating streamgraphs is `.order()`, which determines
    the order in which areas are drawn so that you can alternate them like in a streamgraph.
    We’ll use `d3.stackOrderInsideOut` because that produces the best streamgraph
    effect. We can change the area constructor to use the `basis` interpolator because
    that gave the best look in our earlier streamgraph example and finally update
    the domain of our yScale to match up with the centered baseline around which the
    streamgraph is drawn:'
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
  zh: 堆叠布局有一个`.offset()`函数，它确定组成图表的区域的相对位置。虽然我们可以编写自己的偏移函数来创建异类图表，但D3包括几个函数来实现我们想要的典型效果。我们将使用`d3.stackOffsetSilhouette`关键字，它将堆叠区域的绘制中心化。另一个你需要利用来创建流图的函数是`.order()`，它确定区域的绘制顺序，以便你可以像在流图中那样交替它们。我们将使用`d3.stackOrderInsideOut`，因为它能产生最佳的流图效果。我们可以将区域构造函数更改为使用`basis`插值器，因为这在我们的早期流图示例中给出了最佳的外观，并最终更新我们的yScale的范围以与流图绘制的中心基线相匹配：
- en: '[PRE166]'
  id: totrans-1310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: This results in a cleaner streamgraph than our example from [chapter 4](../Text/kindle_split_013.html#ch04)
    and is shown in [figure 5.14](#ch05fig14).
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: 这比我们第4章中的示例产生了更干净的流图，并如图5.14所示。
- en: Figure 5.14\. The streamgraph effect from a stack layout with basis interpolation
    for the areas and using the `silhouette` and `inside-out` settings for the stack
    layout. This is similar to our hand-built example from [chapter 4](../Text/kindle_split_013.html#ch04)
    and shows the same graphical artifacts from the basis interpolation.
  id: totrans-1312
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.14. 使用基础插值对区域进行堆叠布局，并使用`silhouette`和`inside-out`设置进行堆叠布局的流图效果。这与我们第4章中的手动构建示例相似，并显示了相同的基础插值图形效果。
- en: '![](../Images/05fig14.jpg)'
  id: totrans-1313
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/05fig14.jpg)'
- en: Is it useful? Well, it *is* useful, for various reasons, not least of which
    is because the area in the chart corresponds graphically to the aggregate profit
    of each movie.
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: 这有用吗？好吧，它确实有用，原因很多，其中最重要的是图表中的面积在图形上对应于每部电影的累计利润。
- en: 'But sometimes a simple stacked bar graph is better. Layouts can be used for
    various types of charts, and the stack layout is no different. If we restore the
    `.offset()` and `.order()` back to the default settings, we can use the stack
    layout to create a set of rectangles that makes a traditional stacked bar chart:'
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
  zh: 但有时一个简单的堆叠条形图更好。布局可以用于各种类型的图表，堆叠布局也不例外。如果我们将`.offset()`和`.order()`恢复到默认设置，我们可以使用堆叠布局创建一组矩形，从而形成一个传统的堆叠条形图：
- en: '[PRE167]'
  id: totrans-1316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '***1* The stacked data is returned in a way so that we iterate through drawing
    each movie’s bars, rather than each day**'
  id: totrans-1317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 返回的堆叠数据是以一种方式进行的，即我们遍历绘制每部电影的条形图，而不是每一天**'
- en: '***2* This function is using p,q instead of d,i as a conventional approach
    for nested arrow functions**'
  id: totrans-1318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 这个函数使用p,q而不是d,i作为嵌套箭头函数的传统方法**'
- en: '***3* Because it’s an SVG:rect, we want it to be placed where its top position
    would be, and then we draw down from there**'
  id: totrans-1319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 因为它是一个SVG:rect，我们希望它被放置在其顶部位置，然后从这里向下绘制**'
- en: In many ways, the stacked bar chart in [figure 5.15](#ch05fig15) is much more
    readable than the streamgraph. It presents the same information, but the y-axis
    tells us exactly how much money a movie made. There’s a reason why bar charts,
    line charts, and pie charts are the standard chart types found in your spreadsheet.
    Streamgraph, stacked bar charts, and stacked area charts are fundamentally the
    same thing and rely on the stack layout to format your dataset to draw it. Because
    you can deploy them equally easily, your decision whether to use one or the other
    can be based on user testing rather than your ability to create awesome dataviz.
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多方面，图5.15中的堆叠条形图比流图更易于阅读。它展示了相同的信息，但y轴告诉我们电影赚了多少钱。条形图、折线图和饼图之所以成为你电子表格中的标准图表类型，是有原因的。流图、堆叠条形图和堆叠面积图在本质上都是相同的东西，并且依赖于堆叠布局来格式化你的数据集以便绘制。因为你可以同样容易地部署它们，所以你选择使用哪种类型的决定可以基于用户测试，而不是你创建出色数据可视化的能力。
- en: Figure 5.15\. A stacked bar chart using the stack layout to determine the position
    of the rectangles that make up each day’s stacked bar
  id: totrans-1321
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.15\. 使用堆叠布局确定构成每天堆叠条形图的矩形位置的堆叠条形图
- en: '![](../Images/05fig15.jpg)'
  id: totrans-1322
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/05fig15.jpg)'
- en: 'The layouts we’ve looked at so far, as well as the associated methods and generators,
    have broad applicability. Now we’ll look at a pair of layouts that don’t come
    with D3 which are designed for more specific kinds of data: the Sankey diagram
    and the word cloud. Even though these layouts aren’t as generic as the layouts
    included in the core D3 library that we’ve looked at, they have some prominent
    examples and can come in handy.'
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止所讨论的布局，以及相关的方法和生成器，具有广泛的应用性。现在我们将探讨一对D3中没有包含的布局，它们是为更具体的数据类型设计的：桑基图和词云。尽管这些布局不如我们之前查看的核心D3库中的布局通用，但它们有一些突出的例子，并且可能非常有用。
- en: 5.4\. Plugins to add new layouts
  id: totrans-1324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4\. 添加新布局的插件
- en: The examples we’ve touched on in this chapter are a few of the layouts that
    come with the core D3 library. You’ll see a few more in later chapters, and we’ll
    focus specifically on the force layout in [chapter 7](../Text/kindle_split_017.html#ch07).
    But layouts outside of core D3 may also be useful to you. These layouts tend to
    use specifically formatted datasets or different terminology for layout functions.
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们提到的例子只是核心D3库附带的一些布局。你将在后面的章节中看到更多，我们将在第7章[章节7](../Text/kindle_split_017.html#ch07)中专门讨论力导向布局。但核心D3之外的布局也可能对你有用。这些布局通常使用特定格式的数据集或不同的术语来描述布局函数。
- en: 5.4.1\. Sankey diagram
  id: totrans-1326
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.1\. 桑基图
- en: '*Sankey diagrams* consist of two types of objects: nodes and edges. In this
    case, the *nodes* are the web pages or events, and the *edges* are the traffic
    between them. This differs from the hierarchical data you worked with before,
    because nodes can have many overlapping connections ([figure 5.16](#ch05fig16))
    to show event flow or user flow from one part of your website to another.'
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: '*桑基图*由两种类型的对象组成：节点和边。在这种情况下，*节点*是网页或事件，而*边*是它们之间的流量。这与你之前处理过的层次数据不同，因为节点可以有多个重叠的连接([图5.16](#ch05fig16))来显示从网站的一个部分到另一个部分的事件流或用户流。'
- en: Figure 5.16\. Google Analytics uses Sankey diagrams to chart event and user
    flow for website visitors.
  id: totrans-1328
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.16\. Google Analytics使用桑基图来绘制网站访客的事件流和用户流。
- en: '![](../Images/05fig16_alt.jpg)'
  id: totrans-1329
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/05fig16_alt.jpg)'
- en: The D3 version of the Sankey layout is a plugin written by Mike Bostock a couple
    years ago and later updated for D3v4 by Kshitij Aranke. You can find it at [https://github.com/d3/d3-sankey](https://github.com/d3/d3-sankey).
    The Sankey layout has a few examples and sparse documentation—one of the drawbacks
    of non-core layouts. Another minor drawback is that non-core layouts don’t always
    follow the patterns of the core layouts in D3\. To understand the Sankey layout,
    you need to examine the format of the data, the examples, and the code itself.
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: D3 版本的 Sankey 布局是由 Mike Bostock 几年前编写的一个插件，后来由 Kshitij Aranke 更新为 D3v4。你可以在
    [https://github.com/d3/d3-sankey](https://github.com/d3/d3-sankey) 找到它。Sankey
    布局有一些示例和稀少的文档——非核心布局的缺点之一。另一个小的缺点是非核心布局并不总是遵循核心布局的 D3 模式。要理解 Sankey 布局，你需要检查数据格式、示例和代码本身。
- en: '|  |'
  id: totrans-1331
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**D3 plugins**'
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
  zh: '**D3 插件**'
- en: The core D3 library comes with a number of layouts and useful functions, but
    you can find even more at [https://github.com/d3/d3-plugins](https://github.com/d3/d3-plugins)
    or by searching NPM. Besides the two non-core layouts discussed in this chapter,
    we’ll look at the geo plugins in [chapter 7](../Text/kindle_split_017.html#ch07)
    when we deal with maps. Also available is a fisheye distortion lens, a canned
    boxplot layout, a layout for horizon charts, and more exotic plugins for Chernoff
    faces and implementing the superformula (a mathematical expression that allows
    you to create thousands of different shape types by modifying variables).
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: 核心D3库包含了许多布局和有用的函数，但你可以在 [https://github.com/d3/d3-plugins](https://github.com/d3/d3-plugins)
    或通过搜索 NPM 找到更多。除了本章中讨论的两个非核心布局外，我们将在第 7 章（../Text/kindle_split_017.html#ch07）中处理地图时查看地理插件。还有鱼眼畸变透镜、预制的箱线图布局、水平图表布局以及更多用于
    Chernoff 面和实现超级公式（一种数学表达式，允许你通过修改变量来创建数千种不同的形状类型）的插件。
- en: '![](../Images/160fig01.jpg)'
  id: totrans-1334
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/160fig01.jpg)'
- en: '|  |'
  id: totrans-1335
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The data is a JSON array of nodes and a second JSON array of links. Get used
    to this format, because it’s the format of most of the network data we’ll use
    in [chapter 7](../Text/kindle_split_017.html#ch07). For our example, we’ll look
    at the traffic flow in a website that sells milk and milk-based products. We want
    to see how visitors move through the site from the home page to the store page
    to the various product pages, as shown in the following listing. In the parlance
    of the data format we need to work with, the *nodes* are the web pages, the *links*
    are the visitors who go from one page to another (if any), and the *value* of
    each link is the total number of visitors who move from that page to the next.
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
  zh: 数据是一个包含节点和第二个包含链接的 JSON 数组的数组。习惯这种格式，因为这是我们将在第 7 章（../Text/kindle_split_017.html#ch07）中使用的网络数据的大多数格式。在我们的例子中，我们将查看一个销售牛奶和基于牛奶产品的网站的流量。我们想看看访客如何从主页移动到商店页面，再到各种产品页面，如下面的列表所示。在需要处理的数据格式术语中，*节点*是网页，*链接*是从一个页面导航到另一个页面的访客（如果有），每个链接的*值*是从该页面移动到下一个页面的总访客数。
- en: Listing 5.6\. sitestats.json
  id: totrans-1337
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.6\. sitestats.json
- en: '[PRE168]'
  id: totrans-1338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '***1* Each entry in this array represents a web page**'
  id: totrans-1339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 该数组中的每个条目代表一个网页**'
- en: '***2* Each entry in this array represents the number of times someone navigated
    from the “source” page to the “target” page**'
  id: totrans-1340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 该数组中的每个条目代表有人从“源”页面导航到“目标”页面的次数**'
- en: 'The nodes array is clear—each object represents a web page. The links array
    is a bit more opaque, until you realize the numbers represent the array position
    of nodes in the node array. When `links[0]` reads `"source": 0`, it means that
    the source is `nodes[0]`, which is the index page of the site. It connects to
    `"target": 1` so to `nodes[1]`, the about page, and `"value": 25` indicates that
    25 people navigated from the home page to the about page. That defines our flow—the
    flow of traffic through a site.'
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
  zh: '节点数组已清空——每个对象代表一个网页。链接数组稍微有点不透明，直到你意识到这些数字代表节点数组中节点的数组位置。当 `links[0]` 读取 `"source":
    0` 时，意味着源是 `nodes[0]`，即网站的索引页。它连接到 `"target": 1`，即 `nodes[1]`，关于页面，而 `"value":
    25` 表示有 25 人从主页导航到关于页面。这定义了我们的流程——网站流量通过网站的流程。'
- en: Depending on how your project is structured, you can install d3-sankey using
    npm I d3-sankey or download the latest release and include it in your HTML using
    script tags.
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的项目结构，你可以使用 npm I d3-sankey 安装 d3-sankey 或下载最新版本并将其包含在 HTML 中，使用脚本标签。
- en: 'The Sankey layout is initialized like any layout:'
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
  zh: Sankey 布局初始化方式与任何布局相同：
- en: '[PRE169]'
  id: totrans-1344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '***1* Where to start and stop drawing the flows between nodes**'
  id: totrans-1345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在节点之间绘制流量的起始和结束位置**'
- en: '***2* The distance between nodes vertically—a lower value creates longer bars
    representing our web pages**'
  id: totrans-1346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 节点垂直方向上的距离——较低的值创建代表我们网页的长条**'
- en: '***3* The number of times to run the layout to optimize placement of flows**'
  id: totrans-1347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 运行布局的次数以优化流程的位置**'
- en: Until now, you’ve only seen `.size()`. It controls the graphical extent that
    the layout uses. The rest you’d need to figure out by looking at the example,
    experimenting with different values, or reading the sankey.js code itself. Most
    of it will quickly make sense, in particular if you’re familiar with the `.nodes()`
    and `.links()` convention used in D3 network visualizations. The .`layout()` setting
    is pretty hard to understand without diving into the code, but I’ll explain that
    next.
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您只看到了 `.size()`。它控制布局使用的图形范围。其余的您需要通过查看示例、尝试不同的值或阅读sankey.js代码本身来找出。其中大部分很快就会变得有意义，尤其是如果您熟悉D3网络可视化中使用的
    `.nodes()` 和 `.links()` 习惯用法。没有深入代码，`.layout()` 设置很难理解，但我会在下一节解释。
- en: After we define our Sankey layout as in [listing 5.7](#ch05ex07), we need to
    draw the chart by selecting and binding the necessary SVG elements. In this case,
    that typically consists of `<rect>` elements for the nodes and `<path>` elements
    for the flows. We’ll also add `<text>` elements to label the nodes.
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们定义Sankey布局，如[代码清单5.7](#ch05ex07)所示后，我们需要通过选择和绑定必要的SVG元素来绘制图表。在这种情况下，这通常包括用于节点的
    `<rect>` 元素和用于流程的 `<path>` 元素。我们还将添加 `<text>` 元素来标记节点。
- en: Listing 5.7\. Sankey drawing code
  id: totrans-1350
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 代码清单5.7。Sankey绘图代码
- en: '[PRE170]'
  id: totrans-1351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '***1* Offsets the parent <g> of the entire chart**'
  id: totrans-1352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 调整整个图表的父级 <g>**'
- en: '***2* Sankey layout’s link() function is a path generator**'
  id: totrans-1353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* Sankey布局的link()函数是一个路径生成器**'
- en: '***3* Note that layout expects us to use a thick stroke and not a filled area**'
  id: totrans-1354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 注意，布局期望我们使用粗线条而不是填充区域**'
- en: '***4* Sets the stroke color using our intensity ramp, black to red indicating
    weak to strong**'
  id: totrans-1355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 使用我们的强度渐变设置线条颜色，从黑色到红色表示从弱到强**'
- en: '***5* Emphasizes the link when we mouse over it by making it less transparent**'
  id: totrans-1356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 当我们鼠标悬停在其上时，通过使其更不透明来强调链接**'
- en: '***6* Calculates node position as x and y coordinates from our data**'
  id: totrans-1357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 根据我们的数据计算节点位置为x和y坐标**'
- en: The implementation of this layout has interactivity, as shown in [figure 5.17](#ch05fig17).
    Diagrams like these, with wavy paths overlapping other wavy paths, need interaction
    to make them legible to your site visitor. In this case, it differentiates one
    flow from another.
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: 该布局的实现具有交互性，如图5.17所示。[图5.17](#ch05fig17)。这类带有波浪路径重叠其他波浪路径的图表，需要交互才能使网站访客易于阅读。在这种情况下，它区分了不同的流程。
- en: Figure 5.17\. A Sankey diagram where the number of visitors is represented in
    the color of the path. The flow between index and contact has an increased opacity
    as the result of a mouseover event.
  id: totrans-1359
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.17。一个Sankey图，其中访客数量用路径的颜色表示。当鼠标悬停在索引和联系之间时，由于鼠标悬停事件，流量具有增加的不透明度。
- en: '![](../Images/05fig17.jpg)'
  id: totrans-1360
  prefs: []
  type: TYPE_IMG
  zh: '![图5.17](../Images/05fig17.jpg)'
- en: 'With a Sankey diagram like this at your disposal, you can track the flow of
    goods, visitors, or anything else through your organization, website, or other
    system. Although you could expand on this example in any number of ways, I think
    one of the most useful is also one of the simplest. Remember, layouts aren’t tied
    to particular shape elements. In certain cases, like with the flows in the Sankey
    diagram, you’ll have a hard time adapting the layout data to any element other
    than a `<path>`, but the nodes don’t need to be `<rect>` elements. If we adjust
    our code, we can easily make nodes that are circles:'
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有这样一个Sankey图，您可以跟踪商品、访客或其他事物通过您的组织、网站或其他系统中的流动。尽管您可以通过任何数量的方式扩展这个示例，但我认为最有用的一种也是最简单的。记住，布局并不局限于特定的形状元素。在某些情况下，如Sankey图中的流程，您可能很难将布局数据适应除
    `<path>` 之外的任何元素，但节点不需要是 `<rect>` 元素。如果我们调整我们的代码，我们可以轻松地使节点成为圆形：
- en: '[PRE171]'
  id: totrans-1362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'Don’t shy away from experimenting with tweaks to traditional charting methods.
    Using circles instead of rectangles, like in [figure 5.18](#ch05fig18), may seem
    frivolous, but it may be a better fit visually, or it may distinguish your Sankey
    from all the boring sharp-edged Sankeys out there. In the same vein, don’t be
    afraid of leveraging D3’s capacity for information visualization to teach yourself
    how a layout works. You’ll remember that `d3.sankey` has a `layout()` function.
    It adjusts and attracts and relaxes the pull of each connected node to each other
    to achieve the most efficient arrangement of nodes and edges`.` You can see how
    it does that by reading the code, but there’s another, more visual way to see
    how this function works: by using transitions and creating a function that updates
    the `.layout()`.property dynamically. This allows you to “see” the layout function
    in action.'
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: '不要害怕尝试调整传统的图表方法。使用圆形而不是矩形，就像在[图 5.18](#ch05fig18)中那样，可能看起来有些轻率，但它可能在视觉上更合适，或者它可能使你的
    Sankey 与所有无聊的锐边 Sankeys 区分开来。同样，不要害怕利用 D3 的信息可视化能力来学习布局的工作原理。你会记得 `d3.sankey`
    有一个 `layout()` 函数。它调整并吸引并放松每个连接节点之间的拉力，以达到节点和边最有效的排列。`You can see how it does
    that by reading the code, but there’s another, more visual way to see how this
    function works: by using transitions and creating a function that updates the
    `.layout()` property dynamically. This allows you to “see” the layout function
    in action.`'
- en: Figure 5.18\. A squid-like Sankey diagram
  id: totrans-1364
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.18\. 类似章鱼的 Sankey 图
- en: '![](../Images/05fig18.jpg)'
  id: totrans-1365
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/05fig18.jpg)'
- en: '|  |'
  id: totrans-1366
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Visualizing algorithms**'
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
  zh: '**可视化算法**'
- en: Although you may think of data visualization as all the graphics in this book,
    it’s also simultaneously a graphical representation of the methods you used to
    process the data. In certain cases, like the Sankey diagram here or the force-directed
    network visualization you’ll see in the next chapter, the algorithm used to sort
    and arrange the graphical elements is front and center. After you have a layout
    that displays properly, you can play with the settings and update the elements
    as you’ve done with the Sankey diagram to better understand how the algorithm
    works visually.
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可能认为数据可视化就是本书中的所有图形，但它同时还是你用来处理数据的方法的图形表示。在某些情况下，比如这里的 Sankey 图或者你将在下一章看到的力导向网络可视化，用于排序和排列图形元素的算法是核心所在。在你得到一个正确显示的布局后，你可以调整设置并更新元素，就像你在
    Sankey 图中所做的那样，以更好地理解算法的视觉工作原理。
- en: '|  |'
  id: totrans-1369
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: First, we need to add an `onclick` function to make the chart interactive, as
    shown in [listing 5.8](#ch05ex08). We’ll attach this function to the `<svg>` element
    itself, but you could as easily add a button the way we did in [chapter 3](../Text/kindle_split_012.html#ch03).
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要添加一个 `onclick` 函数来使图表交互式，如图[列表 5.8](#ch05ex08)所示。我们将此函数附加到 `<svg>` 元素本身，但你也可以像我们在[第
    3 章](../Text/kindle_split_012.html#ch03)中所做的那样添加一个按钮。
- en: The `runMoreLayouts()` function does two things. It updates the `sankey.layout()`
    property by incrementing a variable and setting it to the new value of that variable.
    It also selects the graphical elements that make up your chart (the `<g>` and
    `<path>` elements) and redraws them with the updated settings. By using `transition()`
    and `delay()`, you’ll see the chart dynamically adjust.
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
  zh: '`runMoreLayouts()` 函数做了两件事。它通过增加一个变量并将其设置为该变量的新值来更新 `sankey.layout()` 属性。它还选择组成你的图表的图形元素（`<g>`
    和 `<path>` 元素）并使用更新的设置重新绘制它们。通过使用 `transition()` 和 `delay()`，你会看到图表动态调整。'
- en: Listing 5.8\. Visual layout function for the Sankey diagram
  id: totrans-1372
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.8\. Sankey 图的视觉布局函数
- en: '[PRE172]'
  id: totrans-1373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '***1* Initializes the Sankey with only a single layout pass**'
  id: totrans-1374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 仅使用单个布局遍历初始化 Sankey**'
- en: '***2* I chose 20 passes because it shows some change without requiring us to
    click too much**'
  id: totrans-1375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 我选择了 20 次遍历，因为它显示了一些变化，而不需要我们点击太多**'
- en: '***3* Because the layout updates the dataset, we have to call the drawing functions
    again and they automatically update**'
  id: totrans-1376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 因为布局更新了数据集，我们必须再次调用绘图函数，它们会自动更新**'
- en: The end result is a visual experience of the effect of the `.layout()` function.
    This function specifies the number of passes that `d3.sankey` makes to determine
    the best position of the lines representing flow. You can see snapshots of this
    in [figure 5.19](#ch05fig19) showing the lines sort out and get out of each other’s
    way. This kind of position optimization is a common technique in information visualization
    and drives the force-directed network layout that you’ll see in [chapter 6](../Text/kindle_split_016.html#ch06).
    In the case of our Sankey example, even one pass of the layout provides good positioning.
    That’s because this is a simple dataset and it stabilizes quickly. As you can
    see as you click your chart, and in [figure 5.19](#ch05fig19), the layout doesn’t
    change much with progressively higher numbers of passes in the `layout()` setting.
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果是`.layout()`函数效果的视觉体验。此函数指定`d3.sankey`在确定表示流的最优位置时进行的遍历次数。你可以在[图5.19](#ch05fig19)中看到这一点的快照，显示线条整理并避开彼此。这种位置优化是信息可视化中的一种常见技术，推动了你在[第6章](../Text/kindle_split_016.html#ch06)中将要看到的力导向网络布局。在我们的桑基示例中，即使布局只进行一次遍历也能提供良好的定位。这是因为这是一个简单的数据集，它很快就会稳定下来。正如你在点击图表时可以看到的，以及在[图5.19](#ch05fig19)中，随着`layout()`设置中遍历次数的增加，布局变化不大。
- en: Figure 5.19\. The Sankey layout algorithm attempts to optimize the positioning
    of nodes to reduce overlap. The chart reflects the position of nodes after (from
    left to right) 1 pass, 20 passes, 100 passes, and 200 passes.
  id: totrans-1378
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.19。桑基布局算法试图优化节点的位置以减少重叠。图表反映了节点在（从左到右）1次遍历、20次遍历、100次遍历和200次遍历后的位置。
- en: '![](../Images/05fig19.jpg)'
  id: totrans-1379
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/05fig19.jpg)'
- en: It should be clear by this example that when you update the settings of the
    layout, you can also update the visual display of the layout. You can use animations
    and transitions by calling the elements and setting their drawing code or position
    to reflect the changed data. You’ll see much more of this in later chapters.
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个例子，应该很明显，当你更新布局的设置时，你也可以更新布局的视觉显示。你可以通过调用元素并设置它们的绘制代码或位置来使用动画和过渡，以反映更改后的数据。你将在后面的章节中看到更多这方面的内容。
- en: 5.4.2\. Word clouds
  id: totrans-1381
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.2. 词云
- en: 'One of the most popular information visualization charts is also one of the
    most maligned: the word cloud. Also known as a *tag cloud*, the *word cloud* uses
    text and text size to represent the importance or frequency of words. [Figure
    5.20](#ch05fig20) shows a thumbnail gallery of 15 word clouds derived from text
    in a species biodiversity database. Word clouds often rotate the words to set
    them at right angles or jumble them at random angles to improve the appearance
    of the graphics. Word clouds, like streamgraphs, receive criticism for being hard
    to read or presenting too little information, but both are surprisingly popular
    with audiences.'
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
  zh: 最受欢迎的信息可视化图表之一也是最受诟病的：词云。也称为*标签云*，*词云*使用文本和文本大小来表示单词的重要性或频率。[图5.20](#ch05fig20)展示了由物种生物多样性数据库中的文本生成的15个词云的缩略图。词云通常将单词旋转到直角或随机角度以改善图形的外观。词云，就像流图一样，因为难以阅读或提供的信息太少而受到批评，但它们在观众中却意外地受欢迎。
- en: Figure 5.20\. A word or tag cloud uses the size of a word to indicate its importance
    or frequency in a text, creating a visual summary of text. These word clouds were
    created by the popular online word cloud generator Wordle ([www.wordle.net](http://www.wordle.net)).
  id: totrans-1383
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.20。词云或标签云通过单词的大小来表示其在文本中的重要性或频率，从而创建文本的视觉摘要。这些词云是由流行的在线词云生成器Wordle（[www.wordle.net](http://www.wordle.net)）创建的。
- en: '![](../Images/05fig20.jpg)'
  id: totrans-1384
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/05fig20.jpg)'
- en: I created these word clouds using my data with the popular Java applet Wordle,
    which provides an easy UI and a few aesthetic customization choices. Wordle has
    flooded the Internet with word clouds because it lets anyone create visually arresting
    but problematic graphics by dropping text onto a page. This has caused much consternation
    among data visualization experts, who think word clouds are evil because they
    embed no analysis in the visualization and only highlight superficial data such
    as the quantity of words in a blog post.
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用流行的Java小程序Wordle创建这些词云，它提供了一个简单的用户界面和一些美学定制选项。Wordle通过允许任何人将文本拖放到页面上来创建引人注目但存在问题的图形，从而在互联网上泛滥成灾。这引起了数据可视化专家的极大不满，他们认为词云是邪恶的，因为它们在可视化中没有嵌入分析，只突出表面的数据，如博客文章中的单词数量。
- en: But word clouds aren’t evil. First of all, they’re popular with audiences. But
    more than that, words are remarkably effective graphical objects. If you can identify
    a numerical attribute that indicates the significance of a word, then scaling
    the size of a word in a word cloud relays that significance to your reader.
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
  zh: 但词云并不邪恶。首先，它们受到观众的喜爱。更重要的是，单词是惊人的有效图形对象。如果你能识别出一个表示单词重要性的数值属性，那么在词云中按比例缩放单词的大小，就可以将这种重要性传达给读者。
- en: 'Let’s start by assuming we have the right kind of data for a word cloud. Fortunately,
    we do: the top 20 words used in this chapter, with the number of each word, as
    shown in the following listing.'
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先假设我们拥有适合词云的正确类型的数据。幸运的是，我们确实有：本章中使用的 top 20 个单词及其数量，如下列所示。
- en: Listing 5.9\. worddata.csv
  id: totrans-1388
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.9\. worddata.csv
- en: '[PRE173]'
  id: totrans-1389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: To create a word cloud with D3, you have to use another layout that isn’t in
    the core library, created by Jason Davies (who created the sentence trees using
    the tree layout shown in [chapter 6](../Text/kindle_split_016.html#ch06)) that
    implements an algorithm written by Jonathan Feinberg ([http://static.mrfeinberg.com/bv_ch03.pdf](http://static.mrfeinberg.com/bv_ch03.pdf)).
    The layout, `d3.cloud()`, is available on GitHub updated for v4 at [https://github.com/sly7-7/d3-cloud](https://github.com/sly7-7/d3-cloud).
    It requires that you define what attribute will determine word size and what size
    you want the word cloud to lay out for, as shown in [listing 5.10](#ch05ex10).
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 D3 创建词云，你必须使用另一个不在核心库中的布局，由 Jason Davies 创建（他使用第 6 章中显示的树布局创建了句子树），该布局实现了
    Jonathan Feinberg 编写的算法（[http://static.mrfeinberg.com/bv_ch03.pdf](http://static.mrfeinberg.com/bv_ch03.pdf)）。布局
    `d3.cloud()` 可在 GitHub 上找到，更新为 v4 版本，地址为 [https://github.com/sly7-7/d3-cloud](https://github.com/sly7-7/d3-cloud)。它要求你定义将决定单词大小的属性以及你希望词云布局的大小，如
    [列表 5.10](#ch05ex10) 所示。
- en: Unlike most other layouts, `cloud()`fires a custom event `end` that indicates
    it’s done calculating the most efficient use of space to generate the word cloud.
    The layout then passes to this event the processed dataset with the position,
    rotation, and size of the words. We can then run the cloud layout without ever
    referring to it again, and we don’t even need to assign it to a variable, as we
    do in the following listing. If we plan to reuse the cloud layout and adjust the
    settings, we assign it to a variable like with any other layout.
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数其他布局不同，`cloud()` 触发一个自定义事件 `end`，表示它已经完成了计算生成词云的最有效空间使用方式。布局随后将包含单词位置、旋转和尺寸的处理后数据集传递给此事件。然后我们可以运行云布局，而无需再次引用它，甚至不需要将其分配给变量，就像以下列表中所示。如果我们计划重用云布局并调整设置，我们可以像对任何其他布局一样将其分配给变量。
- en: Listing 5.10\. Creating a word cloud with d3.cloud
  id: totrans-1392
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.10\. 使用 d3.cloud 创建词云
- en: '[PRE174]'
  id: totrans-1393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '***1* Use a scale rather than raw values for the font size (if you scale a
    word too large, the layout won’t draw it)**'
  id: totrans-1394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用比例而不是原始值来设置字体大小（如果你将单词放大得太大，布局将不会绘制它）**'
- en: '***2* Assigns data to the cloud layout using .words()**'
  id: totrans-1395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用 .words() 将数据分配给云布局**'
- en: '***3* Sets the size of each word using our scale**'
  id: totrans-1396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用我们的比例设置每个单词的大小**'
- en: '***4* The cloud layout needs to be initialized—when it’s done it fires “end”
    and runs whatever function “end” is associated with**'
  id: totrans-1397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 云布局需要初始化——完成时它触发“end”并运行与“end”关联的任何函数**'
- en: '***5* We’ve assigned draw() to “end”, which automatically passes the processed
    dataset as the words variable**'
  id: totrans-1398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 我们将 draw() 分配给“end”，它将自动将处理后的数据集作为 words 变量传递**'
- en: '***6* Translation and rotation are calculated by the cloud layout**'
  id: totrans-1399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 平移和旋转由云布局计算**'
- en: This code creates an SVG `<text>` element that’s rotated and placed according
    to the code. None of our words is rotated, so we get the staid word cloud shown
    in [figure 5.21](#ch05fig21).
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码创建了一个根据代码旋转和放置的 SVG `<text>` 元素。我们的单词都没有旋转，所以我们得到了如 [图 5.21](#ch05fig21)
    所示的静态词云。
- en: Figure 5.21\. A word cloud with words that are arranged horizontally
  id: totrans-1401
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.21\. 水平排列的单词云
- en: '![](../Images/05fig21.jpg)'
  id: totrans-1402
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/05fig21.jpg)'
- en: 'It’s simple enough to define rotation, and we only need to set a rotation value
    in the cloud layout’s `.rotate()` function:'
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: 定义旋转很简单，我们只需要在云布局的 `.rotate()` 函数中设置一个旋转值：
- en: '[PRE175]'
  id: totrans-1404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '***1* This scale takes a random number between 0 and 1 and returns an angle
    between –20 degrees and 20 degrees**'
  id: totrans-1405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 此比例在 0 和 1 之间取一个随机数，并返回一个介于 -20 度和 20 度之间的角度**'
- en: '***2* Sets the rotation for each word**'
  id: totrans-1406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 为每个单词设置旋转**'
- en: At this point, we have your traditional word cloud ([figure 5.22](#ch05fig22)),
    and we can tweak the settings and colors to create anything you’ve seen on Wordle.
    But now let’s look at why word clouds get such a bad reputation. We’ve taken an
    interesting dataset, the most common words in this chapter, and other than size
    them by their frequency, done little more than place them on screen and jostle
    them a bit. We have different channels for expressing data visually, and in this
    case the best channels that we have, besides size, are color and rotation.
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有了传统的词云（[图5.22](#ch05fig22)），我们可以调整设置和颜色来创建您在Wordle上看到的一切。但现在让我们看看为什么词云会得到如此糟糕的名声。我们使用了一个有趣的数据集，本章中最常见的单词，除了按频率大小排序外，我们做的很少，只是将它们放在屏幕上并稍微摇动一下。我们有不同的渠道来表达数据，在这种情况下，除了大小之外，我们最好的渠道是颜色和旋转。
- en: Figure 5.22\. A word cloud using the same worddata.csv but with words slightly
    perturbed by randomizing the rotation property of each word.
  id: totrans-1408
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.22。使用相同的worddata.csv文件创建的词云，但每个单词的旋转属性经过随机扰动，使单词略微偏移。
- en: '![](../Images/05fig22.jpg)'
  id: totrans-1409
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/05fig22.jpg)'
- en: With that in mind, let’s create a keyword list for the words that are in the
    index in the back of the book. We’ll place those keywords in an array and use
    them to highlight the words in our word cloud that appear in the glossary. The
    code in the following listing also rotates shorter words 90 degrees and leaves
    the longer words unrotated so that they’ll be easier to read.
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，让我们为书中索引中出现的单词创建一个关键词列表。我们将这些关键词放入数组中，并使用它们突出显示词云中出现在词汇表中的单词。以下列表中的代码还将较短的单词旋转90度，而较长的单词则不旋转，以便更容易阅读。
- en: Listing 5.11\. Word cloud layout with key word highlighting
  id: totrans-1411
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.11。具有关键词高亮的词云布局
- en: '[PRE176]'
  id: totrans-1412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '***1* Our array of keywords**'
  id: totrans-1413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 我们的关键词数组**'
- en: '***2* The rotate function rotates by 90 degrees every word with five or fewer
    characters**'
  id: totrans-1414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 旋转函数将每个具有五个或更少字符的单词旋转90度**'
- en: '***3* If the word appears in the keyword list, color it orange—otherwise, color
    it black**'
  id: totrans-1415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 如果单词出现在关键词列表中，则将其颜色设置为橙色——否则，设置为黑色**'
- en: The word cloud in [figure 5.23](#ch05fig23) is fundamentally the same, but instead
    of using color and rotation for aesthetics, we used them to encode information
    in the dataset. You can read about more controls over the format of your word
    cloud, including selecting fonts and padding, in the layout’s documentation at
    [www.jasondavies.com/wordcloud/about/](http://www.jasondavies.com/wordcloud/about/).
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.23](#ch05fig23)中的词云在本质上与之前相同，但我们不是用颜色和旋转来美化，而是用它们在数据集中编码信息。您可以在布局的文档中了解更多关于控制词云格式的信息，包括选择字体和填充，请访问[www.jasondavies.com/wordcloud/about/](http://www.jasondavies.com/wordcloud/about/)。'
- en: Figure 5.23\. This word cloud highlights keywords and places longer words horizontally
    and shorter words vertically.
  id: totrans-1417
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.23。这个词云突出显示关键词，并将较长的单词水平放置，较短的单词垂直放置。
- en: '![](../Images/05fig23.jpg)'
  id: totrans-1418
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/05fig23.jpg)'
- en: Layouts like the word cloud aren’t suitable for as wide a variety of data as
    other layouts, but because they’re so easy to deploy and customize, you can combine
    them with other charts to represent the multiple facets of your data. You’ll see
    this kind of synchronized chart in [chapter 9](../Text/kindle_split_020.html#ch09).
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他布局相比，像词云这样的布局不适用于那么广泛的数据，但鉴于它们部署和定制非常容易，您可以结合其他图表来表示数据的多个方面。您将在第9章中看到这种同步图表。[第9章](../Text/kindle_split_020.html#ch09)。
- en: 5.5\. Summary
  id: totrans-1420
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5. 摘要
- en: Layout structure is mostly shared between D3 layouts, and the output of the
    layouts doesn’t necessarily need to be expressed with the same graphics or charts.
  id: totrans-1421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: D3布局之间的布局结构大部分是共享的，布局的输出不一定需要用相同的图形或图表来表示。
- en: Animation can rely on default `transition` behavior or custom-defined tweens
    using `attrTween` or `styleTween`.
  id: totrans-1422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画可以依赖于默认的`transition`行为或使用`attrTween`或`styleTween`自定义定义的tweens。
- en: The `stack()` layout can be used to produce a variety of charts, including stacked
    area charts, stacked bar charts, and streamgraphs.
  id: totrans-1423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stack()`布局可用于生成各种图表，包括堆叠面积图、堆叠条形图和流图。'
- en: Third-party layouts like `sankey()` and `wordcloud()` are available to deploy
    less common charts, such as diagrams of flow or text.
  id: totrans-1424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用的第三方布局，如`sankey()`和`wordcloud()`，可以部署不太常见的图表，例如流程图或文本图。
- en: D3.js in the real world
  id: totrans-1425
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D3.js在现实世界中的应用
- en: Adam Pearce Graphics Editor, New York Times
  id: totrans-1426
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 亚当·皮尔斯，纽约时报图形编辑
- en: '*Trump Has Spent a Fraction of What Clinton Has on Ads*'
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
  zh: '*特朗普在广告上的花费仅为克林顿的一小部分*'
- en: I started this piece thinking I’d remake Alicia’s classic stacked area chart
    showing presidential ad buys by state. Graphing the 2016 data presented a problem
    though—Trump spent several weeks during the summer spending little or no money
    on television ads.
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
  zh: 我开始创作这个作品时，以为我会重新制作艾丽西亚的经典堆叠面积图，展示各州总统广告购买情况。然而，2016年的数据图表出现了一个问题——特朗普在夏季的几周里，在电视广告上花费很少或没有钱。
- en: Rather than using a smaller time scale or visualizing the percentage allocation
    of a small amount of money, I decided focus more on the total amount of money
    spent. A streamgraph let me do that while still showing part of each campaign’s
    state by state strategy.
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用较小的时间尺度或可视化一小笔钱的百分比分配，我决定更多地关注花费的总金额。流图让我做到这一点，同时仍然通过各州的策略展示每个竞选活动的部分状态。
- en: To smooth over variations in spending between different days of the week and
    reduce the data sent to the client, I aggregated spending by week and used the
    `d3.curveMonotoneX` interpolater to stop neighboring curves from overlapping each
    other.
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
  zh: 为了平滑不同日子之间的花费变化，并减少发送给客户的数据量，我按周汇总了花费，并使用`d3.curveMonotoneX`插值器来防止相邻曲线相互重叠。
- en: My editor and I went back and forth a bit on the form of the small multiple
    charts at the top. Initially, they were bar charts, but we switched to area charts
    to introduce the rorschach blot form. It isn’t exactly the outline of the streamgraph,
    but `d3.area().y1(d => -y(d.val)).y2(d => y(d.val))` gets close.
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
  zh: 我的编辑和我对顶部的小型多图图表的形式进行了一些讨论。最初，它们是柱状图，但我们改为面积图来引入罗夏墨迹的形式。这并不完全像是流图的轮廓，但`d3.area().y1(d
    => -y(d.val)).y2(d => y(d.val))`却非常接近。
- en: '![](../Images/172fig01_alt.jpg)'
  id: totrans-1432
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/172fig01_alt.jpg)'
- en: Figure from The New York Times, October 21 ©2016 The New York Times. All rights
    reserved. Used by permission and protected by the Copyright Laws of the United
    States. The printing, copying, redistribution, or retransmission of this content
    without express written permission is prohibited.
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
  zh: 图片来自《纽约时报》，2016年10月21日 ©2016《纽约时报》。版权所有。经许可使用，并受美国版权法保护。未经明确书面许可，禁止打印、复制、重新分配或重新传输此内容。
