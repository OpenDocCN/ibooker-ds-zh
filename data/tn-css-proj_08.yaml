- en: 8 Designing a checkout cart
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 设计结账购物车
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Using responsive tables
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用响应式表格
- en: Autopositioning using Grid
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用网格自动定位
- en: Formatting numbers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格式化数字
- en: Conditionally setting CSS based on viewport size via media queries
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于视口大小通过媒体查询条件性地设置 CSS
- en: Using the `nth-of-type()` pseudo-class
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `nth-of-type()` 伪类
- en: Many of us regularly go online to buy items ranging from food to books to entertainment
    and everything in between. Common to this experience is the checkout cart. We
    make our selections by adding them to a virtual cart or basket in which we can
    review our chosen items before making our final purchase. In this chapter, we’ll
    look at how to style a checkout cart so that it works on both narrow and wide
    screens. We’ll also look at how to handle tables for narrow and wide screens.
    Tables are incredibly useful for displaying data, but they can be a bit difficult
    to style for mobile devices, so we’ll look at a CSS solution for narrow screens.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们中的许多人经常上网购买从食物到书籍再到娱乐等所有事物。这种体验的共同点是结账购物车。我们通过将所选项目添加到虚拟购物车或篮子中来做出选择，在最终购买之前我们可以查看所选项目。在本章中，我们将探讨如何对结账购物车进行样式化，使其在窄屏和宽屏上都能正常工作。我们还将探讨如何处理窄屏和宽屏的表格。表格对于显示数据非常有用，但它们在移动设备上可能有点难以样式化，因此我们将探讨窄屏的
    CSS 解决方案。
- en: First, though, we’ll handle some theming. Regardless of the width of our screen,
    elements such as our input fields, links, and buttons will look the same, so we’ll
    style them first. Defining a theme early in the process of putting together a
    user interface can significantly reduce redundant code. It also increases our
    ability to keep our styles consistent, so that whether we’re creating a checkout
    cart or any other page or application, we can apply this process to any number
    of designs.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将处理一些主题。无论屏幕宽度如何，我们的输入字段、链接和按钮等元素看起来都一样，因此我们将首先对它们进行样式化。在组装用户界面的过程中早期定义一个主题可以显著减少冗余代码。它还增加了我们保持样式一致的能力，因此无论我们是在创建结账购物车还是任何其他页面或应用程序，我们都可以将此过程应用于任何数量的设计。
- en: Next, we’ll focus on the layout, moving from narrow to wide. On devices with
    narrow screens, such as phones, we tend to stack things. As screens grow larger,
    we add rules to make use of the full width available to us. Often, it’s easier
    to start with the mobile layout and add to our styles as the screen gets wider
    than to start with wide-screen layout and have to override previously set layout
    elements as screens become smaller.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来，我们将专注于布局，从窄屏到宽屏。在窄屏设备上，如手机，我们倾向于堆叠东西。随着屏幕变大，我们添加规则来利用我们可用的全部宽度。通常，从移动布局开始并随着屏幕变宽添加样式比从宽屏布局开始并在屏幕变小时覆盖之前设置的布局元素更容易。 '
- en: 8.1 Getting started
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1 入门
- en: 'We’ll create styles to accommodate three sizes of screens:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建样式以适应三种屏幕尺寸：
- en: '*Narrow* (most phones)—Maximum width of 549 pixels'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*窄屏*（大多数手机）—最大宽度为 549 像素'
- en: '*Medium* (tablets and small screens)—Between 500 and 955 pixels'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*中屏*（平板电脑和小屏幕）—介于 500 到 955 像素之间'
- en: '*Wide* (desktop computers and high-resolution tablets)—Wider than 955 pixels'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*宽屏*（桌面电脑和高分辨率平板电脑）—宽度超过 955 像素'
- en: Figure 8.1 shows our starting point and the final output for each screen size.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 显示了每个屏幕尺寸的起始点和最终输出。
- en: '![](../Images/08-01.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08-01.png)'
- en: Figure 8.1 Start and end outputs for small, medium, and large screens
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 小、中、大屏幕的起始和结束输出
- en: Regardless of the screen size, we’re going to use the same HTML. We’ll have
    one stylesheet and use media queries to adjust how our elements look depending
    on screen size. Our starting HTML is on GitHub at [http://mng.bz/GRpJ](http://mng.bz/GRpJ)
    and on CodePen at [https://codepen.io/michaelgearon/pen/ExmLNxL](https://codepen.io/michaelgearon/pen/ExmLNxL).
    The code consists of two sections, one for the cart and one for the summary, which
    are wrapped in a container that we’ll use on wide screens to place the sections
    side by side. The cart section includes a heading and a table that contains each
    of the items in the cart. The summary section contains a heading, a description
    list, and two links. Figure 8.2 diagrams the HTML elements.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 无论屏幕大小如何，我们都会使用相同的 HTML。我们将有一个样式表，并使用媒体查询来调整元素的外观，这取决于屏幕大小。我们的起始 HTML 在 GitHub
    上 [http://mng.bz/GRpJ](http://mng.bz/GRpJ) 和 CodePen 上 [https://codepen.io/michaelgearon/pen/ExmLNxL](https://codepen.io/michaelgearon/pen/ExmLNxL)
    可用。代码由两部分组成，一部分用于购物车，另一部分用于摘要，它们被包裹在一个容器中，我们将在宽屏上使用该容器将部分并排放置。购物车部分包括一个标题和一个包含购物车中每个项目的表格。摘要部分包含一个标题、一个描述列表和两个链接。图
    8.2 示意图说明了 HTML 元素。
- en: '![](../Images/08-02.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08-02.png)'
- en: Figure 8.2 Diagram of HTML elements
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 HTML元素图
- en: The following listing is an abridged version of the HTML we’re starting with.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表是我们开始时的HTML的简略版。
- en: Listing 8.1 Starting HTML
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.1 起始HTML
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In addition to the starting HTML, we’ll use a JavaScript file (`script.js`).
    We won’t be editing or interacting with the file; it’s there simply to update
    the totals for the summary sections.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 除了起始的HTML代码，我们还会使用一个JavaScript文件（`script.js`）。我们不会编辑或与该文件交互；它仅仅用于更新总结部分的总额。
- en: 8.2 Theming
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2 主题化
- en: Although our layout has two clearly defined sections (the cart and the summary)
    and needs to work across screen sizes, some styles aren’t going to change regardless
    of where they are or what size the screen is. These styles include
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的布局有两个明确定义的部分（购物车和总结）并且需要适应不同的屏幕尺寸，但某些样式无论它们在哪里或屏幕大小如何都不会改变。这些样式包括
- en: Fonts
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字体
- en: Buttons and link styles
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮和链接样式
- en: Input and error-message styles
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入和错误信息样式
- en: Header size and color
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标题大小和颜色
- en: These styles can be referred to as our *theme,* and to keep them consistent
    across our page, we generally want to write them once and apply them everywhere.
    Let’s start with our fonts.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这些样式可以被称为我们的*主题*，为了在整个页面上保持一致性，我们通常希望只写一次并应用到每个地方。让我们从我们的字体开始。
- en: 8.2.1 Typography
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.1 字体排版
- en: Currently, our `font-family` is our browser’s default. For this project, we’re
    going to import Raleway from Google Fonts and apply it to the body. We’ll import
    both regular and bold, as we’ll need both throughout this project. We’ll also
    set a default text color of `#171717`, which looks almost black, for our text.
    We aren’t using black with this design because it’s a soft design, and pure black
    can be quite harsh.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的`font-family`是浏览器的默认字体。对于这个项目，我们将从Google Fonts导入Raleway并将其应用于body。我们将导入常规和粗体，因为在这个项目中我们都需要它们。我们还将设置默认的文本颜色为`#171717`，这看起来几乎是黑色，用于我们的文本。我们在这个设计中不使用黑色，因为它是一个柔和的设计，纯黑色可能会显得相当刺眼。
- en: Next, we’re going to handle our numbers. A font family by default has either
    old-style or modern numbers. The difference is how the numbers are aligned compared
    with the meanline and baseline, as shown in figure 8.3.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将处理我们的数字。一个字体家族默认有旧式或现代数字。区别在于数字与平均线和基线的对齐方式，如图8.3所示。
- en: '![](../Images/08-03.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08-03.png)'
- en: Figure 8.3 Old-style versus modern figures
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 旧式与现代图表对比
- en: Numbers in old style have portions that peek above and below the baseline; modern
    ones don’t. Because we’re creating a shopping cart, and we want to stack numbers
    to show them being added to create a total, we want to use modern figures so that
    they line up nicely. However, Raleway (the font family we’ve chosen for the page)
    uses old-style figures by default. To make our typeface use modern figures, we
    can use the `font-variant-numeric` property, which lets us set how we want our
    numbers to display. This lesser-known property is handy for handling numbers because
    it allows us to control multiple facets of their display, including
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 旧式数字有部分会超出基线；现代的则不会。因为我们正在创建一个购物车，我们想要堆叠数字以显示它们被添加以创建总额，我们希望使用现代数字以便它们对齐得很好。然而，我们选择的字体家族Raleway默认使用旧式数字。为了使我们的字体使用现代数字，我们可以使用`font-variant-numeric`属性，它允许我们设置我们希望数字如何显示。这个不太为人所知的属性在处理数字时很有用，因为它允许我们控制它们显示的多个方面，包括
- en: Whether zeros are displayed with a slash in them
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零是否以斜杠显示
- en: How the numbers are aligned
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字的对齐方式
- en: How fractions are displayed
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分数的显示方式
- en: We’re going to use a `font-variant-numeric:` `lining-nums` property that will
    change our numbers from old-style to modern. Figure 8.4 shows the summary section
    before and after we apply `font-variant-numeric` to our body rule. In the before
    version, the numerals are different sizes; in the after version, they’re aligned
    and uniformly sized.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`font-variant-numeric:` `lining-nums`属性，这将把我们的数字从旧式改为现代。图8.4显示了应用`font-variant-numeric`到我们的body规则之前和之后的总结部分。在之前的版本中，数字大小不同；在之后的版本中，它们对齐且大小均匀。
- en: '![](../Images/08-04.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08-04.png)'
- en: Figure 8.4 Before and after applying the `font-variant-numeric` property
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 应用`font-variant-numeric`属性前后的对比
- en: Last, we’ll change the color of our headers to teal. After that change, we’ll
    have set the base typography for our page. We applied it directly in the `<body>`
    element so that other child elements within our page will inherit the values.
    Listing 8.2 shows the rules we’ve constructed up to this point.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将更改我们标题的颜色为青色。在这次更改之后，我们将为我们的页面设置基本的排版。我们直接在`<body>`元素中应用了它，以便页面内的其他子元素可以继承这些值。列表8.2显示了到目前为止我们构建的规则。
- en: Listing 8.2 Typography-related styles applied to the `<body>` element
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.2应用于`<body>`元素的排版相关样式
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Figure 8.5 shows our updated output.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5展示了我们的更新后的输出。
- en: '![](../Images/08-05.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08-05.png)'
- en: Figure 8.5 Applied typography
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5应用的排版
- en: Let’s turn our attention to links and buttons.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把注意力转向链接和按钮。
- en: 8.2.2 Links and buttons
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.2 链接和按钮
- en: 'Our page has several links and buttons, but stylistically, all these elements
    look like buttons. They can be categorized by purpose:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的页面有几个链接和按钮，但从风格上讲，所有这些元素看起来都像按钮。它们可以根据目的进行分类：
- en: '*Primary call to action*—Proceed to Checkout link'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*主要行动号召*——前往结账链接'
- en: '*Secondary call to action*—Continue Shopping link'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*次要行动号召*——继续购物链接'
- en: '*Destructive*—Button with an *X* to remove items from the cart'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*破坏性*——带有*X*的按钮用于从购物车中删除项目'
- en: We’re going to use these categories to name our classes so that our rules will
    be easy to reuse.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这些类别来命名我们的类，以便我们的规则可以轻松重用。
- en: Links versus buttons
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 链接与按钮
- en: We have both links and buttons in our project. The decision to use one or the
    other isn’t a matter of preference; it’s based on the intended functionality or
    purpose. For navigating, we should use a link. For performing an action, such
    as removing an item from our cart, we should use a button. We can style these
    elements however we please, but the underlying element should match the intended
    use case.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目中，我们既有链接也有按钮。使用哪一个并不是基于个人喜好；它基于预期的功能或目的。对于导航，我们应该使用链接。对于执行操作，例如从我们的购物车中删除项目，我们应该使用按钮。我们可以随意设计这些元素，但底层元素应该与预期的使用场景相匹配。
- en: The reason for the distinction is that links and buttons have information and
    behaviors tied to them automatically by the browser. These behaviors include their
    capability to focus and, more important, their roles. The role of the element
    is used by assistive technologies to help users interact with the page.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 区分的原因是链接和按钮自动由浏览器关联了信息和行为。这些行为包括它们能够聚焦的能力，更重要的是，它们的角色。元素的角色被辅助技术用来帮助用户与页面交互。
- en: A specific example of a difference in the behavior of a link and a button is
    the user’s ability to right-click it to open the link in a new tab or window.
    If the link is created with a button and JavaScript, this functionality isn’t
    available to the user.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 链接和按钮行为差异的一个具体例子是用户能够右键点击它，在新标签页或窗口中打开链接。如果链接是用按钮和JavaScript创建的，那么这个功能对用户不可用。
- en: In this chapter, we’re dealing with a single page, but this situation is an
    anomaly. In a full application, we have multiple pages or components that will
    reuse the same styles, so instead of naming a class something like `proceed-to-checkout`,
    we’re going to use `primary` so that the class can easily be reused in a different
    context.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们处理的是一个单独的页面，但这种情况是一个异常。在一个完整的应用程序中，我们有多个页面或组件将重用相同的样式，所以而不是将类命名为类似`proceed-to-checkout`的东西，我们将使用`primary`，这样类就可以在不同的上下文中轻松重用。
- en: Before we address the differences among button types, let’s consider the similarities
    and write a baseline for all of our links that look like buttons (which were given
    a class of `button`) and for buttons. After we’ve written a baseline, we’ll make
    rules for each of the button types.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论按钮类型之间的差异之前，让我们先考虑它们的相似之处，并为所有看起来像按钮的链接（这些链接被赋予了`button`类）和按钮本身制定一个基线。在制定基线之后，我们将为每种按钮类型制定规则。
- en: To create our baseline, we’ll start by removing the default gray background
    set by the browser, which we’ll do by using `background:` `none`. We’ll also update
    the `padding`, `border`, and `border-radius` values.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建我们的基线，我们将首先移除浏览器设置的默认灰色背景，我们将通过使用`background:` `none`来完成这项工作。我们还将更新`padding`、`border`和`border-radius`的值。
- en: Finally, because we’re applying this rule to the links and buttons and because
    links are underlined by default, we’re going to remove the underline from the
    links by setting the `text-decoration` property to `none`. The following listing
    shows our base rule for our buttons and links with a class of `button`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，因为我们正在将此规则应用于链接和按钮，并且因为链接默认带有下划线，我们将通过将 `text-decoration` 属性设置为 `none` 来从链接中移除下划线。以下列表显示了我们的按钮和具有
    `button` 类的链接的基本规则。
- en: Listing 8.3 Base styles for buttons
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.3 按钮的基本样式
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ① This rule will be applied to all button elements and to all elements with
    a class of button.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ① 此规则将应用于所有按钮元素以及所有具有 `button` 类的元素。
- en: With the default state of the buttons taken care of, we’ll add style changes
    to apply when a user hovers over a button with their mouse or focuses on it via
    their keyboard. To achieve this goal, we’ll use the `:hover` and `:focus` pseudo-classes.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完按钮的默认状态后，我们将添加样式变化，以应用于用户将鼠标悬停在按钮上或通过键盘聚焦在按钮上时。为了实现这一目标，我们将使用 `:hover` 和
    `:focus` 伪类。
- en: Note A pseudo-class is added to a selector to target a specific state. Adding
    style changes on `hover` and `focus` is important for accessibility, as it provides
    visual feedback, letting the user know that they can interact with the item. For
    keyboard navigation, style changes on `focus` let the user know which element
    they’re about to interact with. Without these visual cues, it’s difficult to know
    what we can click and where we’re focused ([http://mng.bz/zmdA](http://mng.bz/zmdA)).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：为了定位特定状态，会在选择器中添加一个伪类。在 `hover` 和 `focus` 上添加样式变化对于可访问性很重要，因为它提供了视觉反馈，让用户知道他们可以与项目交互。对于键盘导航，`focus`
    上的样式变化让用户知道他们即将与之交互的元素。没有这些视觉提示，很难知道我们可以点击什么，以及我们的焦点在哪里（[http://mng.bz/zmdA](http://mng.bz/zmdA))。
- en: 'On `hover`, we’re going to add a dotted teal outline around our buttons, and
    to give the outline some breathing room, we’re going to offset it by 2 pixels.
    We’ll use two properties: `outline` and `outline-offset`. `outline` works similarly
    to `border`, taking the same three properties, which are `style`, `width`, and
    `color`. `outline-offset` takes a `length` value (which can be negative) that
    dictates the amount of space we want between the outline and the edge of the element.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `hover` 状态下，我们将在按钮周围添加一个点状青色轮廓，为了给轮廓留出一些空间，我们将它偏移 2 像素。我们将使用两个属性：`outline`
    和 `outline-offset`。`outline` 与 `border` 类似，采用相同的三个属性，即 `style`、`width` 和 `color`。`outline-offset`
    采用一个 `length` 值（可以是负值），它决定了轮廓与元素边缘之间的空间量。
- en: For `focus`, we have the same styles as those for `hover`, but instead of having
    a dotted-line outline, we’ll make the line solid. The following listing shows
    our final CSS for the `hover` and `focus` states.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `focus`，我们将使用与 `hover` 相同的样式，但我们将线条改为实线。以下列表显示了我们的最终 CSS，用于 `hover` 和 `focus`
    状态。
- en: Listing 8.4 Button `hover` and `focus` states
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.4 按钮的 `hover` 和 `focus` 状态
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Figure 8.6 shows the styled links and buttons for the `hover` and `focus` states.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6 显示了 `hover` 和 `focus` 状态的样式化链接和按钮。
- en: '![](../Images/08-06.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08-06.png)'
- en: Figure 8.6 Button base styles, including `hover` and `focus`
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6 按钮的基本样式，包括 `hover` 和 `focus`
- en: Now that we have a baseline, we can start focusing on each individual use case.
    We’ll start with our calls to action (the Proceed to Checkout and Continue Shopping
    links). Because we already have a baseline set, all we need to do is edit the
    colors for these use cases, as shown in listing 8.5\. We differentiate between
    the two actions based on which we prefer (or expect) the user to select to highlight
    the primary choice. Being consistent about styling action types throughout the
    application helps us guide our users through the choices they’ll have to make.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了基线，我们可以开始关注每个单独的使用案例。我们将从我们的调用行动（继续结账和继续购物链接）开始。因为我们已经设置了基线，我们只需要编辑这些案例的颜色，如列表
    8.5 所示。我们将根据我们更喜欢（或期望）用户选择的操作来区分这两个动作，以突出主要选择。在整个应用程序中保持动作类型样式的统一性有助于我们引导用户通过他们将要做出的选择。
- en: Listing 8.5 Call-to-action styles
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.5 调用行动样式
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ① Applies to the Proceed to Checkout link
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ① 适用于继续结账链接
- en: ② Applies to the Continue Shopping link
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ② 适用于继续购物链接
- en: Left to style is the Remove button in the table for the items in the cart. This
    button has been given a class of `destructive`. As for the previous two button
    types, we’ll want to change the border, text, and outline colors, this time to
    red instead of teal to emphasize that this action is destructive. We make the
    button look circular by giving it a `border-radius` of `50%`. We also decrease
    the `padding` value; otherwise, the Remove button becomes the most prominent element
    in our table, which is undesirable. Finally, we center the image in the middle
    of the button via the `vertical-align` property. This property, which can be applied
    to both inline- and inline-block-level elements, dictates how the element is aligned
    vertically based on the inline and inline-block elements around it. We want to
    center the image vertically inside the button, so we’ll use a property value of
    `middle`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下要样式化的就是表格中购物项目中的移除按钮。这个按钮被赋予了 `destructive` 类。至于前两种按钮类型，我们想要更改边框、文本和轮廓颜色，这次改为红色而不是青色，以强调这个动作是破坏性的。我们通过给
    `border-radius` 赋值为 `50%` 使按钮看起来是圆形的。我们还减少了 `padding` 值；否则，移除按钮将成为我们表格中最突出的元素，这是不希望的。最后，我们通过
    `vertical-align` 属性在按钮中间居中图像。这个属性可以应用于内联和内联块级元素，它决定了元素根据其周围的内联和内联块元素如何垂直对齐。我们想要在按钮内垂直居中图像，所以我们将使用属性值
    `middle`。
- en: Listing 8.6 shows the CSS for the Remove button. Figure 8.7 shows the output
    for each state.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.6 展示了移除按钮的 CSS。图 8.7 展示了每个状态下的输出。
- en: Listing 8.6 Remove button
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.6 移除按钮
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ① Centers the image inside the button
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ① 在按钮内居中图像
- en: '![](../Images/08-07.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/08-07.png)'
- en: Figure 8.7 Link and button styles
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.7 链接和按钮样式
- en: 8.2.3 Input fields
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.3 输入字段
- en: We’re going to do some minimal styling of the input fields. We won’t handle
    styles for invalid inputs or error messages here because the focus of this chapter
    is creating a responsive layout that contains a table. For a detailed look at
    styling forms, see chapter 10.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对输入字段进行一些最小限度的样式化。我们不会处理无效输入或错误信息的样式，因为本章的重点是创建包含表格的响应式布局。有关样式化表单的详细信息，请参阅第
    10 章。
- en: For this layout, we’re going to give our input fields the same base styles we
    gave the buttons and links. Instead of writing a new rule, however, we’ll add
    the `input` selector to the existing ruleset, as shown in the following listing.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个布局，我们将给我们的输入字段与按钮和链接相同的基样式。然而，我们不会编写新的规则，而是将 `input` 选择器添加到现有的规则集中，如下所示。
- en: Listing 8.7 Adding `input` to base button styles
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.7 向基本按钮样式添加 `input`
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Figure 8.8 shows the styled input fields.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.8 显示了样式化的输入字段。
- en: '![](../Images/08-08.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/08-08.png)'
- en: Figure 8.8 Formatted fields
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.8 格式化字段
- en: 8.2.4 Table
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.4 表格
- en: Next, we’re going to style the table. We’re going to concern ourselves only
    with styles that relate to the theme, such as colors and borders. We’ll handle
    layout and responsiveness in sections 8.3 through 8.5.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将样式化表格。我们将只关注与主题相关的样式，例如颜色和边框。我们将处理布局和响应性，从第 8.3 节到第 8.5 节。
- en: 'Our table is divided into three sections, which we’ll address in order:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将表格分为三个部分，我们将按顺序处理：
- en: '*Header*—`<thead>`'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*头部*—`<thead>`'
- en: '*Body*—`<tbody>`'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*主体*—`<tbody>`'
- en: '*Footer*—`<tfoot>`'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*尾部*—`<tfoot>`'
- en: Styling the table headers
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 样式化表头
- en: We’re going to start by styling our table headers. Because the headers aren’t
    as important as the content of the table itself, we’ll give them a slightly smaller
    font size and lighter color than the rest of the text. We’ll also decrease their
    default `font-weight` of `bold` to `normal`. By subduing the headers a bit, we’re
    creating a visual hierarchy in the table and emphasizing what the user cares most
    about (the items in their shopping cart). The rule is shown in the following listing.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先样式化我们的表头。因为表头不如表格本身的内容重要，所以我们将给它们一个比其他文本略小的字体大小和较浅的颜色。我们还将降低它们的默认 `font-weight`
    的 `bold` 为 `normal`。通过稍微减弱表头，我们在表格中创建了一个视觉层次，并强调了用户最关心的内容（他们购物车中的项目）。规则如下所示。
- en: Listing 8.8 Styling the cells’ contents
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.8 样式化单元格内容
- en: '[PRE7]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: At this point, our table headers look like figure 8.9.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的表头看起来像图 8.9 所示。
- en: '![](../Images/08-09.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/08-09.png)'
- en: Figure 8.9 Styled header cells
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.9 样式化表头单元格
- en: Boldfacing items in the second cell
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个单元格中加粗项目
- en: In the table body (`<tbody>`), we’re going to emphasize the item name (in the
    second column) by making the text bold. To add the `font-weight` property with
    a value of `bold` to the item, we’re going to use the pseudo class `:nth-of-type``()`,
    which allows us to select an element based on its position among its siblings
    of the same tag. To target the second cell—the second `<td>` element—of each row
    in the table’s body, we use `tbody` `td:nth-of-type(2)`. Listing 8.9 shows our
    rule.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在表格体（`<tbody>`）中，我们将通过使文本粗体来强调项目名称（在第二列）。为了给项目添加`font-weight`属性并设置其值为`bold`，我们将使用伪类`:nth-of-type()`，它允许我们根据同一标签的兄弟元素中的位置选择元素。为了定位表格体的每一行的第二个单元格——第二个`<td>`元素——我们使用`tbody
    td:nth-of-type(2)`。列表8.9显示了我们的规则。
- en: Listing 8.9 Boldfacing the second cell of each row in the table’s body
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.9 在表格体的每一行中粗体显示第二个单元格
- en: '[PRE8]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Figure 8.10 shows our updated table with the item names in bold.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10显示了我们的更新后的表格，其中项目名称被粗体显示。
- en: '![](../Images/08-10.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08-10.png)'
- en: Figure 8.10 Item name in bold
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10 粗体显示的项目名称
- en: Striping the rows
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 条纹化行
- en: Next, we’ll stripe the table rows. We’ll use `:nth-of-type()` again, but instead
    of passing in a number, we’ll use the keyword `even`. The rule in the following
    listing selects the even-numbered rows in the table body (`<tbody>`), to which
    we give a light-teal background color.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将条纹化表格的行。我们再次使用`:nth-of-type()`，但这次我们使用关键字`even`。以下列表中的规则选择了表格体（`<tbody>`）中的偶数行，我们给这些行添加了浅青色的背景颜色。
- en: Listing 8.10 Striping the table body’s rows
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.10 条纹化表格体的行
- en: '[PRE9]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Figure 8.11 shows our updated rows.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11 展示了我们的更新后的行。
- en: '![](../Images/08-11.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08-11.png)'
- en: Figure 8.11 Striped rows
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11 条纹化行
- en: Boldfacing the grand total in the footer
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在页脚中粗体显示总金额
- en: We want to bold the grand total, which appears in the table’s footer cell. Because
    we already have a rule that boldfaces text—the one we created to boldface item
    names—we can add the `tfoot` `td` selector to that existing rule, as shown in
    the following listing.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要粗体显示总金额，它出现在表格的页脚单元格中。因为我们已经有了一个粗体显示文本的规则——我们创建的用于粗体显示项目名称的规则——我们可以将`tfoot
    td`选择器添加到现有的规则中，如下面的列表所示。
- en: Listing 8.11 Boldfacing the footer
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.11 粗体显示页脚
- en: '[PRE10]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Our updated footer looks like figure 8.12.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更新的页脚看起来像图8.12。
- en: '![](../Images/08-12.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08-12.png)'
- en: Figure 8.12 Grand total in bold
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12 粗体显示的总金额
- en: Handling borders
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 处理边框
- en: We’ll add a top border to all the rows, regardless of where they are in the
    table. We also want to remove the protruding white lines that appear between cells.
    If we darken the background color of the row, it becomes particularly visible
    (figure 8.13).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在所有行上添加顶部边框，无论它们在表格中的位置如何。我们还想移除单元格之间出现的突出白色线条。如果我们加深行的背景颜色，它就变得特别明显（图8.13）。
- en: '![](../Images/08-13.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08-13.png)'
- en: Figure 8.13 White lines between cells
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.13 单元格之间的白色线条
- en: Let’s start by removing the gaps between our cells. But first, why are these
    white lines present? If we decided to give each cell in our table a border, our
    table would look like figure 8.14.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从移除单元格之间的间距开始。但首先，为什么会有这些白色线条呢？如果我们决定给表格中的每个单元格添加边框，我们的表格就会看起来像图8.14。
- en: '![](../Images/08-14.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08-14.png)'
- en: Figure 8.14 Borders on individual cells
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.14 单个单元格的边框
- en: Notice that each cell has a square around it. The gap we see in our row is the
    gap between the individual cells. If we collapse the borders so that only one
    line appears between the cells, the gap disappears (figure 8.15).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每个单元格周围都有一个方块。我们看到的行间距是单个单元格之间的间距。如果我们折叠边框，使得单元格之间只出现一条线，那么间距就会消失（图8.15）。
- en: '![](../Images/08-15.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08-15.png)'
- en: Figure 8.15 Table with collapsed borders
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.15 带有折叠边框的表格
- en: The CSS property we use to remove the gap and combine the borders is `border-collapse`
    with a value of `collapse`. With this property added, we can also give our rows
    a border. Before we collapsed the borders, only the individual cells could take
    a border. In our project, therefore, we collapse the borders on the table and
    apply a border to the top of each row, as shown in the following listing.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用来移除间距并合并边框的CSS属性是`border-collapse`，其值为`collapse`。添加了这个属性后，我们也可以给我们的行添加边框。在我们折叠边框之前，只有单个单元格可以添加边框。因此，在我们的项目中，我们在表格上折叠边框，并在每一行的顶部应用边框，如下面的列表所示。
- en: Listing 8.12 Handling the table’s borders
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.12 处理表格的边框
- en: '[PRE11]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Figure 8.16 shows our updated table.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.16 展示了我们的更新后的表格。
- en: '![](../Images/08-16.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08-16.png)'
- en: Figure 8.16 Styled table borders
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.16 样式化表格边框
- en: Next, let’s move on to the description list inside the summary section of the
    project.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们继续到项目摘要部分内的描述列表。
- en: 8.2.5 Description list
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.5 描述列表
- en: Still to be themed is the description list (`<dl>`) in the summary section.
    Commonly used for creating glossaries or displaying metadata, a description list
    is perfect for our summary, which contains items and their values. We’re going
    to style the description term (`<dt>`) the same way we did our table headers.
    We want to deemphasize them from the descriptions themselves (`<dd>`), which contains
    the dollar value of each element. Because we want to style them the same way as
    the table headers, we’ll add `dt` as a selector to the existing rule, similar
    to what we did to add input to the button rule in section 8.2.3.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们还需要为主题化摘要部分中的描述列表（`<dl>`）进行样式化。描述列表通常用于创建术语表或显示元数据，对于包含项目和它们值的摘要来说非常合适。我们将以与我们的表格标题相同的方式样式化描述术语（`<dt>`）。我们希望从描述本身（`<dd>`）中淡化它们，其中包含每个元素的美元价值。因为我们想以与表格标题相同的方式样式化它们，所以我们将添加`dt`作为选择器到现有的规则中，类似于我们在8.2.3节中添加输入到按钮规则中所做的。
- en: After that, we’ll add two colons after each `<dt>` by using the pseudo-element
    :`:after` with a property of `content` to insert the character. The CSS and output
    are shown in listing 8.13 and figure 8.17.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将使用`:after`伪元素和`content`属性在每个`<dt>`后添加两个冒号。CSS和输出在列表8.13和图8.17中显示。
- en: Listing 8.13 Styling the description list
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.13 设置描述列表的样式
- en: '[PRE12]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ① Adds a description term to our existing header styles
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ① 为我们现有的标题样式添加描述术语
- en: ② Adds a colon after each description term
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ② 在每个描述术语后添加冒号
- en: '![](../Images/08-17.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/08-17.png)'
- en: Figure 8.17 Description list theme
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.17 描述列表主题
- en: 8.2.6 Cards
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.6 卡片
- en: To give the layout some depth and achieve separation between sections, we’re
    going to style our sections’ containers as cards. *Cards* are a design pattern
    commonly used to separate content by encapsulating it in a box or container reminiscent
    of a playing card. This concept is the same as the one we used to create a profile
    card in chapter 6.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给布局增加深度并在部分之间实现分离，我们将把我们的部分容器样式化为卡片。*卡片*是一种常用的设计模式，通过将内容封装在类似扑克的盒子或容器中来分离内容。这个概念与我们在第6章中创建个人资料卡片时使用的概念相同。
- en: To pull off our card design, we’ll add a pale teal background to the `<body>`
    and outline the sections with a shadow that looks like it’s hovering slightly
    above the `<body>`. To create the shadow, we’ll use the `box-shadow` property,
    which allows us to control the amount of shadow to add on the x- and y-axes, as
    well as the amount of blur (fuzziness), the distance it should spread, and the
    color the shadow should be. Figure 8.18 details how the property values are applied.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现我们的卡片设计，我们将在`<body>`上添加浅青色背景，并用类似悬停于`<body>`之上的阴影来勾勒部分。为了创建阴影，我们将使用`box-shadow`属性，它允许我们控制x轴和y轴上添加的阴影量，以及模糊（模糊度）、它应该扩散的距离以及阴影的颜色。图8.18详细说明了属性值的应用。
- en: '![](../Images/08-18.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/08-18.png)'
- en: Figure 8.18 `box-shadow` property values
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.18 `box-shadow`属性值
- en: Optionally, we can also set a value of `inset` to indicate that the shadow should
    be turned inward within the element rather than around the outside. To finish
    the appearance of our card, we’ll curve the corners with a `border-radius` value
    of `4px`—the same value we used for our links, buttons, and inputs. The following
    listing shows our section rule.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，我们还可以设置一个`inset`的值来指示阴影应该在元素内部而不是外部。为了完成我们卡片的外观，我们将使用`border-radius`值为`4px`来使角落弯曲——这个值与我们用于链接、按钮和输入的值相同。下面的列表显示了我们的部分规则。
- en: Listing 8.14 Styling the sections
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.14 设置部分的样式
- en: '[PRE13]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ① Adds a background color to the page
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ① 为页面添加背景颜色
- en: ② Makes our sections look like cards
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ② 使我们的部分看起来像卡片
- en: Figure 8.19 shows our styled sections. Notice, however, that at the bottom of
    the summary card, the links extend out beyond the card. This effect happens because
    links have a `display` value of `inline` by default.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.19显示了我们的样式化部分。然而，请注意，在摘要卡片底部，链接延伸到卡片之外。这种效果发生是因为链接默认的`display`值为`inline`。
- en: '![](../Images/08-19.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/08-19.png)'
- en: Figure 8.19 Themed sections with overflowing links
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.19 主题部分溢出的链接
- en: When vertical padding is added to an inline element—the links, in this case—the
    height of the element doesn’t increase inside the flow of the page. Thus, it takes
    up only as much room as its content (the text), which is why it isn’t increasing
    the height of the card. To fix this problem, we’ll change their `display` value
    from `inline` to `inline-block`. The following listing shows the updated rule.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当向内联元素（在这种情况下是链接）添加垂直内边距时，元素的高度在页面流中不会增加。因此，它只占据其内容（文本）的空间，这就是为什么它不会增加卡片的高度。为了解决这个问题，我们将它们的
    `display` 值从 `inline` 更改为 `inline-block`。以下列表显示了更新的规则。
- en: Listing 8.15 Section styles
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.15 部分样式
- en: '[PRE14]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With the fix in place, our layout looks like figure 8.20.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在修复到位后，我们的布局看起来像图 8.20。
- en: '![](../Images/08-20.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08-20.png)'
- en: Figure 8.20 Styled cards
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.20 样式卡
- en: With our theme taken care of, we can start focusing on the layout.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完主题后，我们可以开始关注布局。
- en: 8.3 Mobile layout
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3 移动布局
- en: We’ll start with the mobile layout. The first thing we’re going to do is make
    our table responsive.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从移动布局开始。我们首先要做的是使我们的表格响应式。
- en: 8.3.1 Table mobile view
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.1 表格移动视图
- en: A traditional table layout doesn’t work well on mobile devices because tables
    need a lot of width, which phone screens don’t offer. To accommodate mobile phones,
    we’ll make the table rows and cells act more like cards on narrow screens.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的表格布局在移动设备上效果不佳，因为表格需要大量的宽度，而手机屏幕无法提供。为了适应手机，我们将使表格的行和单元格在窄屏幕上表现得更像卡片。
- en: Using a media query
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用媒体查询
- en: 'We’ll start by using a media query to apply a set of rules to the table when
    the viewport is less than or equal to `549px`. The query will be `@media(max-width:`
    `549px)` `{` `}`. Notice that we use `max-width` here. In previous chapters, we
    used `min-width` because we wanted the styles to be applied only when the screen
    reached a certain size. In this case, we’re doing the opposite: we want the styles
    to be applied *until* the screen reaches a certain width.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将首先使用媒体查询，当视口宽度小于或等于 `549px` 时应用一组规则到表格上。查询将是 `@media(max-width: 549px) {
    }`。注意这里我们使用了 `max-width`。在之前的章节中，我们使用了 `min-width`，因为我们只想在屏幕达到一定大小时应用样式。在这种情况下，我们做的是相反的：我们希望样式在屏幕达到一定宽度之前应用。'
- en: Inside this media query, we’ll define what we want the table to look like on
    narrow screens. Figure 8.21 shows what our table currently looks like and what
    we’re trying to achieve.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个媒体查询内部，我们将定义表格在窄屏幕上应该看起来是什么样子。图 8.21 显示了我们的表格当前的样子以及我们想要达到的效果。
- en: '![](../Images/08-21.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08-21.png)'
- en: Figure 8.21 Before and after tables for a mobile device
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.21 移动设备上的前后表格对比
- en: To view the narrow-screen or mobile version, most browsers’ developer tools
    allow us to make the browser simulate the screen of a particular device. In Google
    Chrome, to select a particular device, we toggle the device toolbar by clicking
    the icon with the phone on it at the top of the DevTools bar and then choosing
    the device we want to use, as shown in figure 8.22\. It’s worth noting, however,
    that this simulation is limited and shouldn’t replace testing on the physical
    device itself.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看窄屏幕或移动版本，大多数浏览器的开发者工具允许我们模拟特定设备的屏幕。在 Google Chrome 中，要选择特定设备，我们通过点击 DevTools
    栏顶部的带有手机的图标来切换设备工具栏，然后选择我们想要使用的设备，如图 8.22 所示。然而，值得注意的是，这种模拟是有限的，不应取代在物理设备上的测试。
- en: '![](../Images/08-22.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08-22.png)'
- en: Figure 8.22 Device simulation in Chrome DevTools
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.22 Chrome DevTools 中的设备模拟
- en: Changing the table’s display structure
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 改变表格的显示结构
- en: First, we’ll stack everything vertically rather than have the elements of each
    row represented horizontally. We accomplish this task by giving our rows and cells
    a `display` value of `block`. By default, table cells have a `display` value of
    `table-cell`, whereas rows have a `display` value of `table-row`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将所有内容垂直堆叠，而不是将每行的元素水平表示。我们通过给我们的行和单元格设置 `display` 值为 `block` 来完成这个任务。默认情况下，表格单元格的
    `display` 值为 `table-cell`，而行有 `display` 值为 `table-row`。
- en: Next, we float the image to the left (chapter 7) so that the rest of the contents
    of the row wrap around it. We also include some margin around the image to create
    some whitespace between the image and the rest of the row content. The following
    listing shows the start of our media query and our updated cell styles.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将图片浮动到左侧（第 7 章），这样行的其余内容就可以围绕它包裹。我们还为图片周围添加了一些边距，以在图片和行的其余内容之间创建一些空白。以下列表显示了我们的媒体查询和更新的单元格样式。
- en: Listing 8.16 Mobile cell and row layout
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.16 移动单元格和行布局
- en: '[PRE15]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ① Specifically targets images that are immediate children of the cell to avoid
    floating the image in the button (the red X)
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ① 专门针对单元格的直接子图像，以避免在按钮（红色X）中浮动图像
- en: We’re getting closer to our goal, but our header information isn’t where we
    need it to be. As we see in figure 8.23, header information is at the top of the
    table rather than before each piece of information in the table-body rows.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正越来越接近我们的目标，但我们的表头信息并不在我们需要的位置。如图8.23所示，表头信息位于表格顶部，而不是在表格体行中的每条信息之前。
- en: Displaying content from a data attribute
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 从数据属性显示内容
- en: 'To place the header information before each piece of content, we aren’t going
    to use the header. Instead, we’ll add some data attributes to the cells in our
    HTML: `<td` `data-name="Item">Red` `Grapes,` `1lb</td>`. This data will drive
    labeling each row rather than the header contents in the table head.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要将表头信息放置在每个内容之前，我们不会使用表头。相反，我们将在HTML中的单元格添加一些数据属性：`<td` `data-name="Item">Red`
    `Grapes,` `1lb</td>`。这些数据将驱动对每一行的标签，而不是表头中的内容。
- en: '![](../Images/08-23.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08-23.png)'
- en: Figure 8.23 The table header is at the top of the mobile table.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.23 表头位于移动表格的顶部。
- en: We move the table header offscreen by using absolute positioning, as shown in
    listing 8.17\. We don’t want to use `display:none`, as the information available
    in the header is still needed by assistive technologies. By absolutely positioning
    it offscreen (using a large negative value), we hide it visually but not programmatically.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用绝对定位将表头移出屏幕，如图8.17列表所示。我们不想使用`display:none`，因为表头中的信息仍然需要辅助技术。通过绝对定位将其移出屏幕（使用大负值），我们视觉上隐藏了它，但不是程序上。
- en: Listing 8.17 Hiding the table headers
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.17 隐藏表头
- en: '[PRE16]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With our table head out of the way (figure 8.24), we can focus on extracting
    the data from the `data-name` attribute and displaying it to the user. We notice
    that our content shifted a bit after we removed the header because our table currently
    isn’t taking up the full width of the screen. We’ll remedy that problem later
    in this section. For now, let’s finish handling our header information.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的表头移除后（如图8.24所示），我们可以专注于从`data-name`属性中提取数据并将其显示给用户。我们注意到在移除表头后，内容有所偏移，因为我们的表格目前没有占据整个屏幕宽度。我们将在本节稍后解决这个问题。现在，让我们完成对表头信息的处理。
- en: '![](../Images/08-24.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08-24.png)'
- en: Figure 8.24 Removing the table head from view
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.24 从视图中移除表头
- en: 'To display the attribute value, we use the `attr()` function, which takes an
    attribute name and returns a value. For our use case, our `content` property will
    be `td[data-name]: before` `{` `content:` `attr(data-name)` `":";` `}`. Figure
    8.25 breaks it down in detail.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '要显示属性值，我们使用`attr()`函数，它接受一个属性名并返回一个值。在我们的用例中，我们的`content`属性将是`td[data-name]:
    before` `{` `content:` `attr(data-name)` `":";` `}`。图8.25详细说明了这一点。'
- en: '![](../Images/08-25.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08-25.png)'
- en: Figure 8.25 Adding the header information before the cell
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.25 在单元格前添加表头信息
- en: To align our labels and content, we use a combination of `text-align` and `float`.
    We use `text-align:` `right` in the cell to right-justify the cell contents—the
    item name, unit price, input field, total, and button—and then float the label
    (the content we get from the `data-name` attribute) to the left to create a gap
    between the two elements, as shown in figure 8.26\. We also give the cell some
    padding for added whitespace between the lines of content. Listing 8.18 shows
    the CSS used to align the contents of the table cells.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '为了对齐我们的标签和内容，我们使用`text-align`和`float`的组合。我们在单元格中使用`text-align: right`来右对齐单元格内容——项目名称、单价、输入字段、总计和按钮——然后将标签（从`data-name`属性获取的内容）浮动到左侧以在两个元素之间创建一个间隔，如图8.26所示。我们还为单元格添加了一些填充，以增加内容行之间的空白。列表8.18显示了用于对齐表格单元格内容的CSS。'
- en: Listing 8.18 Displaying the contents of the `data-name` attribute
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.18 显示`data-name`属性的值
- en: '[PRE17]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![](../Images/08-26.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08-26.png)'
- en: Figure 8.26 Aligning the labels and the content
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.26 对齐标签和内容
- en: Now that the data in the `data-name` attribute is being displayed, let’s style
    it to match the definition titles. Rather than copy the styles, we can append
    the selector to the existing rule as shown in the following listing.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在数据在`data-name`属性中已被显示，让我们将其样式调整为与定义标题相匹配。我们不必复制样式，可以将选择器附加到现有规则中，如下列所示。
- en: Listing 8.19 Finishing touches
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.19 完成细节
- en: '[PRE18]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Full width
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 全宽
- en: With the labels styled, let’s turn our attention back to the fact that our table
    isn’t taking up the full width that’s available to it. We can fix this problem
    by giving it a width of `100%` by using the rule `table` `{` `width:` `100%;`
    `}`. Because we’ll want the table to take up the full width available to it regardless
    of screen size, we add this rule *outside* the media query.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 标签样式完成后，让我们将注意力转回到我们的表格并没有占据其可用的全部宽度这个问题上。我们可以通过使用规则 `table` `{` `width:` `100%;`
    `}` 来将其宽度设置为 `100%` 来解决这个问题。因为我们希望表格无论屏幕大小如何都能占据其全部宽度，所以我们将在媒体查询之外添加此规则。
- en: We’re almost done with the mobile styles of the table (figure 8.27). The only
    thing left to do is handle the table foot.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了表格的移动样式（图 8.27）。剩下要做的就是处理表格页脚。
- en: '![](../Images/08-27.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08-27.png)'
- en: Figure 8.27 Full-width table
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.27 宽度全表的表格
- en: Table footer
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 表格页脚
- en: In the table footer (`<tfoot>`), we want to align the text on a single line.
    For this task, we’ll use Flexbox with a `justify-content` property value of `space-between`
    and an `align-items` value of `baseline` to align the label and total at opposite
    ends of the row on the same line. (To see how the CSS Flexbox Layout Module works,
    check out chapter 6.)
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在表格页脚（`<tfoot>`）中，我们希望将文本对齐到单行。为此任务，我们将使用 Flexbox，并设置 `justify-content` 属性值为
    `space-between` 和 `align-items` 属性值为 `baseline`，以在行的两端对齐标签和总计。（要了解 CSS Flexbox
    布局模块的工作原理，请参阅第 6 章。）
- en: Looking at our table-footer HTML (listing 8.20), we notice that our first cell
    is a table header (`<th>`), not a table data cell (`<td>`), which makes sense
    because it describes the contents of that row.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 查看我们的表格页脚 HTML（列表 8.20），我们注意到我们的第一个单元格是一个表格标题（`<th>`），而不是表格数据单元格（`<td>`），这是有道理的，因为它描述了该行的内容。
- en: Listing 8.20 Table-footer HTML
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.20 表格页脚 HTML
- en: '[PRE19]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If we look closely at figure 8.27, we notice that the footer content doesn’t
    have any padding; it goes right up against the edge of the card and row border.
    Earlier, we added padding to all the table data cells, not the headers, so now
    we’ll add padding to the footer. The following listing shows a recap of the styles
    we edited and created to create our mobile table layout along with our changes
    for the table footer.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仔细观察图 8.27，我们会注意到页脚内容没有任何填充；它直接紧挨着卡片和行边框。之前，我们为所有表格数据单元格添加了填充，而不是标题，所以现在我们将为页脚添加填充。以下列表显示了我们对创建我们的移动表格布局所编辑和创建的样式回顾，以及我们对表格页脚的更改。
- en: Listing 8.21 Mobile table CSS
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.21 移动表格 CSS
- en: '[PRE20]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Figure 8.28 shows the finished table.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.28 显示了完成的表格。
- en: '![](../Images/08-28.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08-28.png)'
- en: Figure 8.28 Table displayed as cards for narrow screens
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.28 窄屏幕上显示为卡片的表格
- en: Now that the table looks good on mobile devices, we’ll turn our attention to
    the description list and the overall layout. Unlike the rules that created styles
    specific to small screens, this next set of rules will apply regardless of the
    width of the screen, so they won’t be inside a media query. We’ll start by addressing
    the description list (`<dl>`).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在表格在移动设备上看起来很好，我们将把注意力转向描述列表和整体布局。与创建特定于小屏幕样式的规则不同，下一组规则将适用于任何屏幕宽度，因此它们不会在媒体查询内。我们将首先解决描述列表（`<dl>`）。
- en: 8.3.2 Description list
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.2 描述列表
- en: Unlike the table, which looks completely different on mobile and desktop screens,
    the description list will look the same regardless of screen width. Its position
    will change on wider screens, but the list itself will not. Because the description
    list is the same regardless of screen size, we won’t put the layout styles inside
    a media query.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 与表格不同，表格在移动和桌面屏幕上看起来完全不同，描述列表将不受屏幕宽度的影响而保持相同的外观。在更宽的屏幕上，其位置会改变，但列表本身不会变。因为描述列表不受屏幕大小的影响，所以我们将布局样式放在媒体查询之外。
- en: To display the description list, we’ll use `grid` (chapter 2). We’ll define
    two columns and let items autoposition themselves within the two columns. When
    not given specific placement instructions, child elements of a grid container
    place themselves in the first available space, which is exactly the behavior we’re
    going to exploit. We’ll also define a gap and add some padding to the container
    to space the elements within the grid and card. Finally, we’ll left-justify numbers.
    Listing 8.22 shows the CSS, and figure 8.29 shows the before and after versions
    of the description list.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示项目描述列表，我们将使用 `grid`（第 2 章）。我们将定义两列，并让项目在两列中自动定位。如果没有给出特定的放置指令，网格容器的子元素将放置在第一个可用的空间中，这正是我们要利用的行为。我们还将定义一个间隙，并在容器中添加一些填充，以在网格和卡片中分隔元素。最后，我们将左对齐数字。列表
    8.22 展示了 CSS，图 8.29 展示了项目描述列表的前后布局。
- en: Listing 8.22 Description list styles
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.22 项目描述列表样式
- en: '[PRE21]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ① We use max-content for our second column because we don’t want the numbers
    to wrap, which would make them difficult to read.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们为第二列使用 max-content，因为我们不希望数字换行，这会使它们难以阅读。
- en: '![](../Images/08-29.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/08-29.png)'
- en: Figure 8.29 Before and after layouts for the description list
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.29 项目描述列表前后布局对比
- en: 8.3.3 Call-to-action links
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.3 动作链接
- en: Our description list looks a lot better, but the call-to-action links still
    need some help. As we did for the description list in section 8.3.2, we want our
    call-to-action links to be laid out the same regardless of screen size, so styles
    will go outside our media query.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目描述列表看起来好多了，但动作链接仍然需要一些帮助。正如我们在 8.3.2 节中为项目描述列表所做的，我们希望无论屏幕大小如何，动作链接的布局都相同，因此样式将放在我们的媒体查询之外。
- en: First, we’ll give the links’ containers some padding and use the `text-align`
    property to center them. When there isn’t enough room for links to be side by
    side and they end up stacked, we’ll give them some margin to prevent them from
    running right up against one another. Listing 8.23 displays the code. Figure 8.30
    shows before and after versions of the output.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将为链接的容器添加一些填充，并使用 `text-align` 属性来居中它们。当没有足够的空间让链接并排显示并且它们堆叠时，我们将为它们添加一些边距以防止它们紧挨在一起。列表
    8.23 展示了代码。图 8.30 展示了输出前后的版本。
- en: Listing 8.23 Action links
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.23 动作链接
- en: '[PRE22]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '![](../Images/08-30.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/08-30.png)'
- en: Figure 8.30 Before and after layout of call-to-action links
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.30 动作链接前后布局对比
- en: 8.3.4 Padding, margin, and margin collapse
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.4 填充、边距和边距合并
- en: All the content within our sections except the headers is laid out for mobile
    devices. The browser gives headers a margin by default, but that setting isn’t
    accomplishing what we want it to; instead of creating vertical space between the
    edge of the card and the header, it’s pushing the card down. A margin pushes content
    but doesn’t affect how much room an element or its content occupies, which is
    why the top margin (header) is bleeding out of the card.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们部分内的所有内容（除了标题）都是为移动设备布局的。浏览器默认给标题添加边距，但这个设置并没有达到我们想要的效果；它不是在卡片边缘和标题之间创建垂直空间，而是将卡片向下推。边距会推动内容，但不会影响元素或其内容占据的空间量，这就是为什么顶部的边距（标题）会从卡片中溢出。
- en: If we remove the header’s margin and give it padding instead, the card will
    expand, but the gap between the two cards will disappear. Therefore, we need to
    give the `section` itself some margin to add space between the two cards. If we
    give the sections a `margin` with a value of `1rem` `0` (1-rem top and bottom,
    but not left and right), we’ll still have a 1-rem gap between the two cards—a
    direct result of margin collapse. Unless the positioning of the elements has been
    altered via float or flex, two margins that run up against each other will collapse
    to equal the greater of the two margins. Figure 8.31 diagrams this effect.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们移除标题的边距并为其添加填充，卡片将扩展，但两张卡片之间的间隙将消失。因此，我们需要给 `section` 本身添加一些边距以在两张卡片之间添加空间。如果我们给部分添加一个值为
    `1rem` 的 `margin`（1-rem 顶部和底部，但不是左右），我们仍然会在两张卡片之间保持 1-rem 的间隙——这是边距合并的直接结果。除非通过浮动或弹性改变了元素的定位，否则相邻的两个边距将合并为两个边距中较大的那个。图
    8.31 图解了这一效果。
- en: '![](../Images/08-31.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/08-31.png)'
- en: Figure 8.31 Effects of margins and margin collapse
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.31 边距和边距合并的效果
- en: To add space between the edges of the card and the header, we’ll replace the
    card header’s margin with padding. Then we’ll add section margins to the card
    to regain the lost vertical space. Finally, we’ll add padding to the body so that
    the cards aren’t stuck against the left and right edges of the screen. The following
    listing shows how.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 要在卡片边缘和标题之间添加空间，我们将用填充替换卡片标题的边距。然后，我们将向卡片添加部分边距以恢复丢失的垂直空间。最后，我们将向主体添加填充，以便卡片不会紧贴屏幕的左右边缘。以下列表显示了如何操作。
- en: Listing 8.24 Section margin and header padding
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.24 部分边距和标题填充
- en: '[PRE23]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: With the mobile layout finished (figure 8.32), let’s increase the width of the
    screen for tablets and laptops.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 移动布局完成（图 8.32）后，让我们增加平板电脑和笔记本电脑的屏幕宽度。
- en: '![](../Images/08-32.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08-32.png)'
- en: Figure 8.32 Before and after card headers
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.32 卡片标题前后对比
- en: 8.4 Medium screen layout
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.4 中等屏幕布局
- en: Most of what we did for mobile devices will look great on medium-size screens.
    Because we used a media query to restrict table-layout changes to screens less
    than or equal to 549 pixels wide, the styles we wrote to edit the table won’t
    apply to any screen that’s 550 pixels wide or wider. Figure 8.33 shows the table
    when the viewport is 549 pixels wide and when it’s 550 pixels wide. At 550 pixels
    of width, we’re back to a standard table layout.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为移动设备所做的几乎所有事情在中等尺寸的屏幕上看起来都会很好。因为我们使用媒体查询将表格布局更改限制在宽度小于或等于 549 像素的屏幕上，所以我们编写的用于编辑表格的样式不会应用于任何宽度为
    550 像素或更宽的屏幕。图 8.33 显示了视口宽度为 549 像素和 550 像素时的表格。在 550 像素的宽度时，我们回到了标准的表格布局。
- en: '![](../Images/08-33.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08-33.png)'
- en: Figure 8.33 Break point for table
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.33 表格断点
- en: 8.4.1 Right-justified numbers
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4.1 右对齐数字
- en: Next, we’re going to update the alignments of the values in the table. Because
    it makes computation at a glance easier, it’s customary to right-justify numbers,
    especially if they’re being totaled in a column. We’ll update both the header
    and the cells of the unit price, quantity, and total to be right-justified.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更新表格中值的对齐方式。由于这使直观计算更容易，通常将数字右对齐，特别是如果它们在列中总计。我们将更新单价、数量和总计的标题和单元格，使它们右对齐。
- en: To select the headers and cells, we could use the `:nth-of-type(n)` selector.
    To select the header and cells of the Unit Price column (third column), we’d use
    `th:nth-of-type(3),` `td:nth-of-type(3)` `{` `...` `}` and repeat the same process
    for all the other columns (Quantity, Total, and Actions).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 要选择标题和单元格，我们可以使用 `:nth-of-type(n)` 选择器。要选择单价列（第三列）的标题和单元格，我们将使用 `th:nth-of-type(3),`
    `td:nth-of-type(3)` `{` `...` `}` 并对其他所有列（数量、总计和操作）重复相同的过程。
- en: We could also think about the process a little differently. We want to right-align
    all columns after the first two. Inside `:nth-of-type()`, we can pass not only
    numbers, but also patterns. In section 8.2.4, we used this trick when we set our
    background colors on our rows by passing a parameter of `even`. In this case,
    we’re going to pass a custom pattern, using the parameter `n+3`. This pattern
    indicates that we want to select all matching elements starting with the third
    instance where `n` is the iterator and `3` is the starting point. Figure 8.34
    illustrates the pattern.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以稍微改变一下思考过程。我们想要在第一列之后的所有列中右对齐。在 `:nth-of-type()` 中，我们不仅可以传递数字，还可以传递模式。在
    8.2.4 节中，我们使用这个技巧通过传递参数 `even` 来设置我们行的背景颜色。在这种情况下，我们将传递一个自定义模式，使用参数 `n+3`。这个模式表示我们想要从
    `n` 是迭代器且 `3` 是起始点开始选择所有匹配的元素。图 8.34 说明了这个模式。
- en: '![](../Images/08-34.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08-34.png)'
- en: Figure 8.34 `nth-of-type(n+3)` explained
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.34 `nth-of-type(n+3)` 解释
- en: Using this technique, we can select the third, fourth, fifth, and sixth cells
    for each row and right-align their contents, as shown in listing 8.25\. Notice
    that we put our rule inside a media query with a `min-width` of `550px`. We don’t
    want to apply these changes to smaller screens (defined by our previous media
    query as any screen smaller than or equal to 549 pixels), so we use a second media
    query to apply these styles only to screens that are 550 pixels wide or wider.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种技术，我们可以选择每行的第三、第四、第五和第六个单元格，并将它们的内文右对齐，如列表 8.25 所示。请注意，我们将我们的规则放在一个具有 `min-width`
    为 `550px` 的媒体查询中。我们不希望将这些更改应用于较小的屏幕（根据我们之前的媒体查询定义为任何小于或等于 549 像素的屏幕），因此我们使用第二个媒体查询仅将这些样式应用于宽度为
    550 像素或更宽的屏幕。
- en: Listing 8.25 Right-aligning contents
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.25 右对齐内容
- en: '[PRE24]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After our styles are applied (figure 8.35), we notice a few things:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的样式应用后（图 8.35），我们注意到一些事情：
- en: Our first two columns need their titles to be left-justified to match their
    content.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的前两列需要它们的标题左对齐以匹配其内容。
- en: The numbers inside the fields didn’t right-justify themselves.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字段内的数字没有自动右对齐。
- en: The Remove button is up against the edge of the card.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除按钮紧挨着卡片边缘。
- en: '![](../Images/08-35.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/08-35.png)'
- en: Figure 8.35 Right-aligned number and action columns
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.35 右对齐的数字和操作列
- en: Let’s address these problems in order.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按顺序解决这些问题。
- en: 8.4.2 Left-justifying the first two columns
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4.2 左对齐前两列
- en: We’ll use specificity to our advantage to handle the headers. Because, as a
    selector, `th` is less specific than `th:nth-of-type(n+3)`, we can make a `th`
    rule that aligns the text to the left and keeps our previous rule for the other
    columns. The `th` rule will left-justify the header content for all columns. Then
    we’ll override the `text-align` property value for our number and button columns
    in our `th:nth-of-type(n+3)` rule. The following listing shows the changes.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用具体性来处理标题。因为，作为一个选择器，`th` 比 `th:nth-of-type(n+3)` 更不具体，我们可以创建一个将文本左对齐并保留其他列的先前规则的
    `th` 规则。`th` 规则将使所有列的标题内容左对齐。然后，我们将覆盖 `th:nth-of-type(n+3)` 规则中数字和按钮列的 `text-align`
    属性值。下面的列表显示了所做的更改。
- en: Listing 8.26 Updating the table header rules
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.26 更新表头规则
- en: '[PRE25]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now our first two table headers are left-justified instead of centered (the
    browser’s default setting), and our other columns kept their right justification
    (figure 8.36).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的前两个表头左对齐而不是居中（浏览器的默认设置），我们的其他列保持右对齐（图 8.36）。
- en: '![](../Images/08-36.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/08-36.png)'
- en: Figure 8.36 Styled headers
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.36 样式化标题
- en: 8.4.3 Right-justifying numbers in the input fields
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4.3 在输入字段中右对齐数字
- en: We can choose to right-justify the text inside the input field only in this
    table view or all the time regardless of screen size, and we do that outside the
    media queries. Because we right-aligned our numbers and totals in the mobile view
    as well, it seems logical to update the input-field style for all display sizes
    and include the update in our theme.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以选择仅在表格视图中或无论屏幕大小如何都始终右对齐输入字段内的文本，我们这样做是在媒体查询之外。因为我们也在移动视图中将数字和总计右对齐，所以更新输入字段样式以适用于所有显示尺寸并包含在主题中似乎是合理的。
- en: 'To select inputs of a type number, we can use an attribute selector: `input[type=
    "number"]` `{` `...` `}`. We’ll add `input[type="number"]` `{` `text-align:` `right`
    `}` to our stylesheet *outside* our media queries, as we want to apply it regardless
    of screen size.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 要选择数字类型的输入，我们可以使用属性选择器：`input[type= "number"]` `{` `...` `}`。我们将把 `input[type="number"]`
    `{` `text-align:` `right` `}` 添加到样式表中 *外部* 媒体查询，因为我们希望无论屏幕大小如何都应用它。
- en: With the text inside the input fields aligned (figure 8.37), the last piece
    we need to address is padding in all our table data cells and table headers.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入字段内的文本对齐（图 8.37）后，我们需要解决的最后一部分是我们所有表格数据单元格和表头的填充。
- en: '![](../Images/08-37.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/08-37.png)'
- en: Figure 8.37 Right-aligned text in input field
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.37 输入字段中的右对齐文本
- en: 8.4.4 Cell padding and margin
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4.4 单元格填充和边距
- en: To complete our table (medium-size screen) view, we’ll add padding and margin
    to our cells in the table header, body, and footer. To achieve this effect, we
    add `td,` `th` `{` `padding:` `10px` `}` to our medium-size screen (`min-width:`
    `550px`) media query. The following listing shows the full set of changes we make
    to achieve the table layout.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们的表格（中等屏幕）视图，我们将在表头、主体和页脚的单元格中添加填充和边距。为了实现这种效果，我们在中等屏幕尺寸的媒体查询中添加了 `td,`
    `th` `{` `padding:` `10px` `}`。下面的列表显示了我们所做的全部更改，以实现表格布局。
- en: Listing 8.27 Medium-size screens
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.27 中等尺寸屏幕
- en: '[PRE26]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now that we have both small and medium-size screens styled (figure 8.38), let’s
    go a bit further and handle wide screens.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为小屏幕和中屏幕尺寸进行了样式化（图 8.38），让我们更进一步，处理宽屏幕。
- en: '![](../Images/08-38.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/08-38.png)'
- en: Figure 8.38 Finished mobile and tablet layouts
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.38 完成的移动和平板布局
- en: 8.5 Wide screens
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.5 宽屏幕
- en: As we continue to increase the width of the screen, the summary section becomes
    harder to read because of the increasing distance between the definition titles
    and descriptions (figure 8.39).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们继续增加屏幕宽度，摘要部分由于定义标题和描述之间的距离增加而变得难以阅读（图 8.39）。
- en: '![](../Images/08-39.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/08-39.png)'
- en: Figure 8.39 Desktop view of summary (viewport width 955 pixels)
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.39 桌面视图的摘要（视口宽度 955 像素）
- en: Because we have more horizontal real estate to play with as the screen gets
    wider, we’ll bring the summary section up beside the cart section when the viewport
    reaches 995 pixels wide or larger, as shown in the wireframe in figure 8.40.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 由于屏幕变宽时我们有更多的水平空间可以利用，因此当视口宽度达到 995 像素或更宽时，我们将摘要部分移至购物车部分旁边，如图 8.40 中的线框所示。
- en: '![](../Images/08-40.png)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/08-40.png)'
- en: Figure 8.40 Layout wireframes
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.40 布局线框
- en: To change our layout conditionally based on the screen being 955 pixels wide
    or larger, we’ll create the media query `@media` `(min-width:` `995px)` `{` `}`.
    In the HTML shown in the following listing, we have a container `<div>` around
    our two sections with a class of `section-container`.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '为了根据屏幕宽度为 955 像素或更宽的条件有条件地更改布局，我们将创建媒体查询 `@media` `(min-width: ` `995px`) `{}`。在以下列表中显示的
    HTML 中，我们有两个部分周围有一个具有 `section-container` 类的 `<div>` 容器。'
- en: Listing 8.28 Page HTML
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.28 页面 HTML
- en: '[PRE27]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ① Container for the two cards (My Cart and Summary)
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: ① 两个卡片（购物车和摘要）的容器
- en: ② My Cart card
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: ② 购物车卡片
- en: ③ Summary card
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 摘要卡片
- en: ④ End of container
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 容器结束
- en: Inside our new media query, we’ll give the container a `display` property value
    of `flex`. This value allows the two items to come side by side and align themselves
    on the x-axis. Then we’ll add a gap of `20px` between the two sections.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们新的媒体查询中，我们将容器设置为 `display` 属性值为 `flex`。这个值允许两个项目并排排列并在 x 轴上对齐。然后我们在两个部分之间添加一个
    `20px` 的间隙。
- en: Flexbox will autocalculate the amount of space to give each section. We can
    influence how the browser assigns dimensions via the properties `flex-grow`, `flex-shrink`,
    and `flex-basis`. We’re going to give the summary section a `flex-basis` value
    of `250px` and the cart section a `flex-grow` value of `1`.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: Flexbox 将自动计算为每个部分分配的空间量。我们可以通过 `flex-grow`、`flex-shrink` 和 `flex-basis` 属性来影响浏览器分配尺寸的方式。我们将给摘要部分一个
    `flex-basis` 值为 `250px`，给购物车部分一个 `flex-grow` 值为 `1`。
- en: Applied to the summary card, `flex-basis` will set the initial size of the section
    when the browser starts calculating how much room to assign each section. If the
    content to which flex is being applied can accommodate the section’s being 250
    pixels wide, the browser won’t alter the section’s dimensions; otherwise, the
    browser will adjust the section as necessary. The `flex-grow` property tells the
    browser that if space is left over after `flex` has been applied to the content,
    this element should be made wider to use the extra space. Figure 8.41 shows our
    sections with and without these two properties influencing how the elements are
    sized.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 应用到摘要卡片上，`flex-basis` 将设置浏览器开始计算为每个部分分配多少空间时该部分的初始大小。如果应用 `flex` 的内容可以容纳 250
    像宽的部分，浏览器不会更改该部分的尺寸；否则，浏览器将根据需要调整该部分。`flex-grow` 属性告诉浏览器，如果在 `flex` 应用到内容后还有剩余空间，则应使该元素变宽以使用额外的空间。图
    8.41 显示了这两个属性如何影响元素的大小。
- en: '![](../Images/08-41.png)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/08-41.png)'
- en: Figure 8.41 Influencing the size of elements to which `flex` has been applied
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.41 影响 `flex` 应用的元素大小
- en: With `flex-grow` and `flex-basis`, we can control the width of the table relative
    to the summary card. Therefore, we use the media query in the following listing
    for our project.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `flex-grow` 和 `flex-basis`，我们可以控制表格相对于摘要卡片的宽度。因此，我们在以下列表中使用媒体查询来处理我们的项目。
- en: Listing 8.29 Placing the two cards side by side on wide screens
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.29 在宽屏幕上并排放置两个卡片
- en: '[PRE28]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Figure 8.41 shows our layout when the screen is 955 pixels wide. But if we make
    the screen even wider, such as for the extra-wide curved displays, we eventually
    get to a point where the content once again becomes unreadable (figure 8.42).
    Because we set a `flex-basis` value on the summary card, it stays readable, but
    because the table is made to keep growing (via the `flex-grow` property), it becomes
    unwieldy.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.41 显示了屏幕宽度为 955 像素时的布局。但是，如果我们使屏幕更宽，例如用于额外的宽曲显示屏，我们最终会到达一个点，内容再次变得难以阅读（图
    8.42）。因为我们为摘要卡片设置了 `flex-basis` 值，所以它仍然可读，但由于表格是通过 `flex-grow` 属性来保持增长的，所以它变得难以操作。
- en: '![](../Images/08-42.png)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/08-42.png)'
- en: Figure 8.42 Layout on a screen 2,000 pixels wide
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.42 2,000 像素宽屏幕上的布局
- en: To prevent this growth, we can limit the width of the `<main>` element (inside
    which our main header and cards are contained). This change ensures that no matter
    how wide the user’s display is or how the user chooses to extend the window, the
    content remains usable. We can center the body by giving the left and right margins
    a value of `auto`, as shown in the following listing.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这种增长，我们可以限制 `<main>` 元素的宽度（它包含我们的主要标题和卡片）。这种更改确保无论用户的显示有多宽，或者用户如何选择扩展窗口，内容都保持可用。我们可以通过给左右边距赋值为
    `auto` 来居中文本，如下所示。
- en: Listing 8.30 Maximum width of the `main` element
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.30 `main` 元素的最大宽度
- en: '[PRE29]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If we look at our layout again on an extremely wide screen with these last styles
    applied (figure 8.43), we see that we’ve constrained and centered our content.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次查看我们的布局，在应用了这些最后样式的一个极其宽的屏幕上（如图 8.43），我们会看到我们已经限制了内容并使其居中。
- en: '![](../Images/08-43.png)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/08-43.png)'
- en: Figure 8.43 Constrained-width layout
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.43 限制宽度的布局
- en: With these final edits, our project is complete. From one HTML file, we created
    three distinct layouts based on the width of the screen (figure 8.44).
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 经过这些最后的编辑，我们的项目就完成了。从一个 HTML 文件中，我们根据屏幕宽度创建了三个不同的布局（如图 8.44）。
- en: '![](../Images/08-44.png)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/08-44.png)'
- en: Figure 8.44 Final output for three screen sizes
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.44 三个屏幕尺寸的最终输出
- en: Summary
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Numeral styles can be controlled via the `font-variant-numeric` property.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字样式可以通过 `font-variant-numeric` 属性来控制。
- en: Media queries allow us to apply styles conditionally based on screen size.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 媒体查询允许我们根据屏幕大小有条件地应用样式。
- en: Naming CSS classes based on the content they’re styling or the content they
    represent can be helpful for creating names that are easy to understand and maintain.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据它们所修饰的内容或代表的内容来命名 CSS 类有助于创建易于理解和维护的名称。
- en: HTML attribute values can be used to select elements.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用 HTML 属性值来选择元素。
- en: HTML attributes can be displayed via CSS using pseudo-elements, the `content`
    property, and the `attr()` function.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过 CSS 使用伪元素、`content` 属性和 `attr()` 函数来显示 HTML 属性值。
- en: Margins can collapse.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边距可以合并。
- en: Elements set to `display:flex` can be controlled via `flex-grow`, `flex-shrink`,
    and `flex-basis`.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置为 `display:flex` 的元素可以通过 `flex-grow`、`flex-shrink` 和 `flex-basis` 来控制。
- en: '`:nth-of-type` can take numbers, keywords, or custom patterns to target elements
    based on their position relative to others of the same type of elements inside
    a container.'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:nth-of-type` 可以接受数字、关键词或自定义模式来根据元素相对于容器内相同类型元素的位置来定位元素。'
