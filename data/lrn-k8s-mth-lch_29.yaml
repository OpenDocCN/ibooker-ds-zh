- en: appendix C. Application configuration management in containers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录C. 容器中的应用配置管理
- en: Applications need to load their configuration from the environment they’re running
    in, which is usually a combination of environment variables and files read from
    disk. Docker creates that environment for apps running in containers, and it can
    set environment variables and construct a filesystem from many different sources.
    The pieces are all there to help you build a flexible configuration approach for
    your apps, so when you deploy to production you’re using the same image that passed
    all the test phases. You just need to do some work to bring the pieces together,
    setting up your app to merge configuration values from multiple places.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序需要从它们运行的运行环境中加载其配置，这通常是环境变量和从磁盘读取的文件的组合。Docker为在容器中运行的应用程序创建该环境，它可以设置环境变量并从许多不同的来源构建文件系统。所有这些部件都是为了帮助您为应用程序构建一个灵活的配置方法，因此当您部署到生产环境时，您使用的是通过了所有测试阶段的相同镜像。您只需做一些工作来将这些部件组合在一起，设置您的应用程序以从多个位置合并配置值。
- en: This chapter will take you through the recommended approach (and some alternatives)
    using examples in .NET Core, Java, Go, and Node.js. Some of the work here lives
    in the developer space, bringing in libraries to provide config management, and
    the rest lives in that gray area between dev and ops that relies on communication
    so both sides know how the configuration model works.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将通过.NET Core、Java、Go和Node.js中的示例，向您介绍推荐的方法（以及一些替代方案）。这里的一些工作位于开发空间中，引入库以提供配置管理，其余部分位于开发和运维之间的灰色区域，该区域依赖于沟通，以便双方都了解配置模型的工作方式。
- en: This appendix is reproduced from chapter 18, "Application Configuration Management
    in Containers," from *Learn Docker in a Month of Lunches* by Elton Stoneman (Manning,
    2020). Any chapter references or references to code repositories refer to the
    chapters or code repositories of that book.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录摘自Elton Stoneman所著的《Learn Docker in a Month of Lunches》第18章“容器中的应用配置管理”（Manning,
    2020）。任何章节引用或代码仓库引用均指该书的相关章节或代码仓库。
- en: C.1 A multi-tiered approach to app configuration
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C.1 应用配置的多层方法
- en: 'Your configuration model should reflect the structure of the data you’re storing,
    which is typically one of three types:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 您的配置模型应反映您存储的数据的结构，这通常是以下三种类型之一：
- en: Release-level settings, which are the same for every environment for a given
    release
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本级别的设置，对于给定版本的所有环境都是相同的
- en: Environment-level settings, which are different for every environment
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境级别的设置，对于每个环境都是不同的
- en: Feature-level settings, which can be used to change behavior between releases
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特性级别的设置，可用于在版本之间更改行为
- en: Some of those are fairly static, some are dynamic with a known set of variables,
    and others are dynamic with an unknown set of variables. Figure C.1 shows some
    sample config settings and where they can be read from the environment.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些是相当静态的，一些是动态的，具有一组已知的变量，而其他一些是动态的，具有一组未知的变量。图C.1展示了某些示例配置设置以及它们可以从环境中读取的位置。
- en: '![](../Images/C-1.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![图C-1](../Images/C-1.jpg)'
- en: Figure C.1 A config hierarchy with settings from the image, filesystem, and
    environment variables
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.1 从镜像、文件系统和环境变量中获取设置的配置层次结构
- en: The first example we’ll use is Node.js with a popular config management library
    called node-config. The library lets you read config from multiple file locations
    in a hierarchy and override them all with environment variables. The access-log
    sample app in the exercises for this chapter uses the node-config library and
    sets up two directories to read configuration files from
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的第一个示例是Node.js，以及一个流行的配置管理库node-config。该库允许您从层次结构中的多个文件位置读取配置，并用环境变量覆盖它们。本章练习中的access-log示例应用使用了node-config库，并设置了两个目录来读取配置文件
- en: '`config`—This will be packaged with default settings in the Docker image.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config`—这将与默认设置一起打包到Docker镜像中。'
- en: '`config-override`—This doesn’t exist in the image but can be provisioned in
    the container filesystem from a volume, config object, or secret.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config-override`—该镜像中不存在，但可以从卷、配置对象或密钥中在容器文件系统中配置。'
- en: 'try it now Run the sample app with the default configuration from the image,
    and then the same image with an override file for the development environment:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 运行带有默认配置的示例应用，然后是带有开发环境覆盖文件的相同镜像：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first container only uses the default config file that is packaged in the
    image—that specifies the name of the release cycle (19.12) and sets the Prometheus
    metrics to be enabled. There’s an `UNKNOWN` setting for the environment name—if
    you ever see that, you know the environment-level config settings haven’t been
    correctly applied. The second container loads a local config directory as a volume
    in the expected location for the app to find overrides—it sets the environment
    name and flips the metrics feature to off. You’ll see when you call the config
    API that containers from the same image have applied different settings—mine is
    in figure C.2.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个容器仅使用图像中打包的默认配置文件——该文件指定了发布周期名称（19.12）并设置了要启用的 Prometheus 指标。环境名称有一个`UNKNOWN`设置——如果你看到这个设置，你就知道环境级别的配置设置还没有被正确应用。第二个容器将本地配置目录作为卷加载到应用程序预期的位置以查找覆盖——它设置了环境名称并将指标功能关闭。当你调用配置
    API 时，你会看到来自同一图像的容器应用了不同的设置——我的设置在图 C.2 中。
- en: '![](../Images/C-2.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图 C-2](../Images/C-2.jpg)'
- en: Figure C.2 It’s straightforward to merge config files using volumes, config
    objects, or secrets.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 C.2 使用卷、配置对象或秘密合并配置文件很简单。
- en: Loading config overrides from a known path in your app code lets you provide
    them from any source into the container. I’m using a local bind mount, but the
    source could be a config object or a secret stored in a container cluster and
    the behavior would be the same. There’s one nuance to this pattern—your config
    target can either be a specific file path or a directory. A directory target is
    more flexible (Windows containers don’t support loading volumes from a single
    file), but the source file names need to match the config file names the app expects.
    In this example the bind source is the directory `config/dev`, which has a single
    file—the container sees `/app/config-override/ local.json`, which is where it
    looks for overrides.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 从应用程序代码中已知路径加载配置覆盖，让你可以从任何来源提供它们到容器中。我正在使用本地绑定挂载，但源可以是配置对象或存储在容器集群中的秘密，行为将是相同的。这个模式有一个细微差别——你的配置目标可以是特定的文件路径或目录。目录目标更灵活（Windows
    容器不支持从单个文件加载卷），但源文件名需要与应用程序期望的配置文件名匹配。在这个例子中，绑定源是目录 `config/dev`，它包含一个文件——容器看到
    `/app/config-override/local.json`，这是它查找覆盖的地方。
- en: 'The node-config package can also load settings from environment variables,
    and they override any settings loaded from the file hierarchy. This is the configuration
    approach recommended in “The Twelve-Factor App” ([https://12factor.net](https://12factor.net))-a
    modern style of application architecture, where environment variables always take
    precedence over other config sources. It’s a useful approach that helps you get
    into the mindset that containers are ephemeral because changing environment variables
    to set application config means replacing containers. Node-config has a slightly
    unusual implementation: rather than specifying individual settings as environment
    variables, you need to provide the settings as a JSON-formatted string in the
    environment variable.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 节点配置包还可以从环境变量中加载设置，并且它们会覆盖从文件层次结构加载的任何设置。这是在《十二要素应用》中推荐的方法（[https://12factor.net](https://12factor.net)）——一种现代的应用架构风格，其中环境变量始终优先于其他配置源。这是一个有用的方法，有助于你养成容器是瞬时的思维模式，因为更改环境变量以设置应用程序配置意味着替换容器。Node-config
    有一个稍微不同寻常的实现：不是将单个设置指定为环境变量，你需要以 JSON 格式的字符串形式在环境变量中提供设置。
- en: 'try it now Run a third version of the access log container in development mode
    but with metrics enabled. Use the volume mount to load the dev config and an environment
    variable to override the metrics setting:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看 运行第三个版本的访问日志容器，以开发模式运行但启用指标。使用卷挂载加载开发配置，并使用环境变量覆盖指标设置：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The third container merges config from the default file in the image, the local
    config override file in the volume, and the specific environment variable setting.
    This is a good example of building config to keep the developer workflow running
    smoothly. Devs can run the default settings without metrics enabled (which will
    save CPU cycles and memory), but when they need to turn metrics on for some debugging,
    they can do it with the same image and an environment variable switch. Figure
    C.3 shows my output.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个容器合并了来自镜像中默认文件、卷中的本地配置覆盖文件和特定环境变量设置的配置。这是一个构建配置以使开发者工作流程顺利运行的优秀示例。开发者可以运行默认设置而不启用度量（这将节省CPU周期和内存），但当他们需要为某些调试打开度量时，他们可以使用相同的镜像和环境变量切换来完成。图C.3显示了我的输出。
- en: '![](../Images/C-3.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/C-3.jpg)'
- en: Figure C.3 Merging config from environment variables makes it easy to change
    specific features.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.3 从环境变量合并配置使得更改特定功能变得容易。
- en: This is the core pattern for configuration that you should look to apply in
    all your apps. From this example you can see that the pattern is quite clear,
    but the details are significant, and that’s the gray area where knowledge can
    break down between delivery and deployment. The access-log app lets you override
    the default config file with a new one, but that target file has to be in a specific
    location. You can also override all file settings with environment variables,
    but the environment variable needs to be in JSON format. Ultimately that will
    be documented in the YAML files you use for deployment, but you need to be aware
    that the pattern has the potential for mistakes. An alternative approach removes
    that risk, at the cost of making config management less flexible.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您应该在所有应用程序中应用的配置核心模式。从这个例子中，您可以清楚地看到模式，但细节很重要，这就是在交付和部署之间知识可能崩溃的灰色区域。访问日志应用程序允许您使用新的配置文件覆盖默认配置文件，但该目标文件必须位于特定位置。您还可以使用环境变量覆盖所有文件设置，但环境变量需要是JSON格式。最终，这将在您用于部署的YAML文件中记录，但您需要意识到这种模式有可能出错。一种替代方法可以消除这种风险，但代价是使配置管理变得不那么灵活。
- en: C.2 Packaging config for every environment
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C.2 为每个环境打包配置
- en: 'Many application frameworks support a config management system where you bundle
    all the config files for every environment in your deployment, and at runtime
    you set a single value to specify the name of the environment you’re running in.
    The app platform loads the config file with the matching environment name, and
    your app is fully configured. .NET Core does this with its default configuration
    provider setup, where config settings are merged from these sources:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序框架支持一种配置管理系统，其中您将部署中每个环境的所有配置文件捆绑在一起，在运行时设置单个值以指定正在运行的环境名称。应用程序平台加载与匹配环境名称的配置文件，您的应用程序就完全配置好了。.NET
    Core通过其默认配置提供程序设置来实现这一点，配置设置从以下来源合并：
- en: '`appsettings.json`—The default values for all environments'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`appsettings.json`—所有环境的默认值'
- en: '`appsettings.{Environment}.json`—The overrides for the named environment'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`appsettings.{Environment}.json`—指定环境的覆盖'
- en: '*Environment variables*—Used to specify the environment name, and for setting
    overrides'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*环境变量*—用于指定环境名称，以及设置覆盖'
- en: There’s a new version of the to-do list app for this chapter that uses this
    approach of packaging all the config files in the Docker image. You use a specific
    environment variable to provide the current environment name, and that gets loaded
    in before the rest of the configuration files.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了一种新的待办事项列表应用程序版本，该版本采用将所有配置文件打包到Docker镜像中的方法。您使用特定的环境变量来提供当前环境名称，该名称在加载其他配置文件之前被加载。
- en: 'try it now Run the to-do list app with the default configuration, which is
    set with the environment name Development, and then with the test environment
    settings:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 运行默认配置的待办事项列表应用程序，默认配置设置为环境名称开发，然后使用测试环境设置：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The two containers are running from the same image but loading different configuration
    files. Inside the image there are environment files for development, test, and
    production environments. The first container merges the core `appsettings.json`
    with `appsettings.Development.json`—it runs in development mode because Development
    is set as the default environment in the Dockerfile. The second merges `appsettings.json`
    with `appsettings.Test.json`. Both the environment config files are already present
    in the Docker image, so there’s no need to mount an external source for the new
    config. Browse to http://localhost:8083/diagnostics to see the dev config and
    http://localhost:8084/diagnostics to see the test version. My output is in figure
    C.4.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 两个容器是从相同的镜像运行的，但加载不同的配置文件。在镜像内部，有针对开发、测试和生产环境的配置文件。第一个容器将核心 `appsettings.json`
    与 `appsettings.Development.json` 合并——它以开发模式运行，因为在 Dockerfile 中将 Development 设置为默认环境。第二个容器将
    `appsettings.json` 与 `appsettings.Test.json` 合并。这两个环境配置文件已经存在于 Docker 镜像中，因此不需要挂载外部源以获取新的配置。浏览到
    http://localhost:8083/diagnostics 以查看开发配置，并浏览到 http://localhost:8084/diagnostics
    以查看测试版本。我的输出在图 C.4 中。
- en: '![](../Images/C-4.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片 C-4](../Images/C-4.jpg)'
- en: Figure C.4 Packaging every environment’s config file in the image makes it easy
    to switch environments.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 C.4 将每个环境的配置文件打包到镜像中，使得切换环境变得容易。
- en: This approach can work nicely if you have separate systems to manage your configuration
    files and your source code. The CI/CD pipeline can bring the config files into
    the Docker image as part of the build, so you keep config management separate
    from development. The downside is that you still can’t package every setting,
    because you need to keep confidential information out of the Docker image. You
    need to have a security-in-depth approach and assume that your registry could
    be compromised—in that case you don’t want someone to find all your passwords
    and API keys in nice plain-text files in your images.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个单独的系统来管理你的配置文件和源代码，这种方法可以很好地工作。CI/CD 管道可以将配置文件作为构建的一部分带入 Docker 镜像，这样你就可以将配置管理从开发中分离出来。缺点是，你仍然不能打包每个设置，因为你需要将机密信息从
    Docker 镜像中排除。你需要有一个多层次的安全方法，并假设你的注册表可能会被攻破——在这种情况下，你不想让某人找到你镜像中的所有密码和 API 密钥。
- en: If you like this approach, you still need to allow for override files, and final
    overrides with environment variables. The to-do list app does that, loading files
    from a folder called `config-overrides` if it exists, and using the standard .NET
    Core approach of loading environment variables last. That lets you do useful things
    like run the production environment locally if you’re trying to replicate an issue,
    but override the environment settings to use a database file instead of a remote
    database server.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢这种方法，你仍然需要允许覆盖文件和最终的环境变量覆盖。待办事项列表应用程序就是这样做的，如果存在，它会从名为 `config-overrides`
    的文件夹中加载文件，并使用 .NET Core 的标准方法最后加载环境变量。这让你能够做些有用的事情，比如如果你正在尝试复制一个问题，可以在本地运行生产环境，但覆盖环境设置以使用数据库文件而不是远程数据库服务器。
- en: 'try it now The to-do list app still supports config overrides, even though
    all the environment config is bundled in the app. If you run in production mode,
    the app fails because it’s expecting to find a database server, but you can run
    in production with an override file to use a database file instead:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 尽管所有环境配置都打包在应用程序中，待办事项列表应用程序仍然支持配置覆盖。如果你以生产模式运行，应用程序会失败，因为它期望找到一个数据库服务器，但你可以使用覆盖文件以使用数据库文件而不是数据库服务器来以生产模式运行：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can browse to http://localhost:8085/diagnostics and see that the app is
    running in production mode, but the config file override changes the database
    setting, so the app still works without running a Postgres container. My output
    is in figure C.5.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以浏览到 http://localhost:8085/diagnostics 并看到应用程序正在以生产模式运行，但配置文件覆盖更改了数据库设置，因此应用程序仍然可以在不运行
    Postgres 容器的情况下工作。我的输出在图 C.5 中。
- en: '![](../Images/C-5.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片 C-5](../Images/C-5.jpg)'
- en: Figure C.5 Selecting an environment to run in should still support config overrides
    from additional files.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 C.5 选择运行的环境仍然应该支持来自附加文件的配置覆盖。
- en: This container merges the default `appsettings.json` file with the environment
    file `appsettings.Production.json` and the override file `local.json` in the `prod-local`
    folder. The setup is similar to the Node.js example, so there’s some consistency
    around folder and file names, but .NET Core takes a different approach to setting
    overrides with environment variables. In node-config you pass a JSON string as
    an environment variable to override settings, but in .NET Core you specify individual
    settings as environment variables.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 此容器将默认的`appsettings.json`文件与`prod-local`文件夹中的环境文件`appsettings.Production.json`和重写文件`local.json`合并。设置类似于Node.js示例，因此在文件夹和文件名方面有一些一致性，但.NET
    Core在设置环境变量重写方面采取了不同的方法。在node-config中，你通过将JSON字符串作为环境变量传递来覆盖设置，但在.NET Core中，你指定单个设置作为环境变量。
- en: 'Try it Now Run the same local version of production but with a custom release
    name by overriding that setting with an environment variable:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看 运行与生产相同的本地版本，但通过用环境变量覆盖该设置来使用自定义发布名称：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Browse to http://localhost:8086/diagnostics and you’ll see the custom release
    name from the environment variable. My output is in figure C.6.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览到http://localhost:8086/diagnostics，你会看到来自环境变量的自定义发布名称。我的输出在图C.6中。
- en: '![](../Images/C-6.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图C-6](../Images/C-6.jpg)'
- en: Figure C.6 The config hierarchy overrides values from any of the config files
    with environment variables.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.6 配置层次结构覆盖了任何配置文件中的环境变量值。
- en: I have to say I don’t like this way of packaging multiple config files, although
    it’s a common approach across lots of app platforms. There’s a danger that you’ll
    include some config setting in your image that you don’t think is sensitive, but
    your security team might disagree. Server names, URLs, file paths, logging levels,
    and even cache sizes could all be useful information to anyone trying to hack
    your system. By the time you move all the confidential settings to override files
    that you apply from the runtime, there’s probably very little left in those packaged
    environment files anyway. I also don’t like the split, where some settings are
    managed in source control and others are in a config management system.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我必须说我不喜欢这种打包多个配置文件的方式，尽管这在许多应用平台上是一种常见的做法。存在一种风险，你可能会在镜像中包含一些你认为不敏感的配置设置，但你的安全团队可能不同意。服务器名称、URL、文件路径、日志级别，甚至缓存大小都可能是有意攻击你系统的人有用的信息。在你将所有机密设置移动到从运行时应用的重写文件之前，这些打包的环境文件中可能已经所剩无几了。我也不喜欢这种分割，其中一些设置在源代码控制中管理，而其他设置在配置管理系统中。
- en: The beauty of containers is that you can follow whichever pattern you like,
    so don’t let me decide for you. Some approaches work better, depending on your
    organization and technology stack. Things get more complicated too if you have
    multiple stacks to deal with—you’ll see that in the next example using a Go application.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的美丽之处在于你可以遵循你喜欢的任何模式，所以不要让我为你做决定。某些方法更适合你的组织和技术堆栈。如果你要处理多个堆栈，事情也会变得更加复杂——你将在下一个使用Go应用的示例中看到这一点。
- en: C.3 Loading configuration from the runtime
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C.3 从运行时加载配置
- en: 'Go has a popular configuration module called Viper, which offers much of the
    same functionality as the .NET Core libraries or node-config. You add the module
    to your package list, and in your application code you specify the paths to the
    config directories and whether you want environment variables brought in to override
    the config files. I’ve added it to the image gallery app for this chapter, using
    a similar hierarchy to the other examples:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Go有一个流行的配置模块叫做Viper，它提供了与.NET Core库或node-config类似的许多功能。你将模块添加到你的包列表中，并在你的应用程序代码中指定配置目录的路径以及你是否希望环境变量用来覆盖配置文件。我已经将它添加到本章的图像库应用程序中，使用与其他示例类似的层次结构：
- en: Files are loaded from the `config` directory first which is populated in the
    Docker image.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先从`config`目录加载文件，该目录在Docker镜像中已填充。
- en: Environment-specific files are loaded from the `config-override` directory,
    which is empty in the image and can be the target for a container filesystem mount.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定于环境的文件从`config-override`目录加载，该目录在镜像中为空，可以是容器文件系统挂载的目标。
- en: Environment variables override the file settings.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境变量覆盖文件设置。
- en: Viper supports a wider set of languages for configuration files than the other
    examples. You can use JSON or YAML, but the popular format in the Go world is
    TOML (named after its creator, Tom Preston-Werner). TOML is great for configuration
    files because it maps easily to dictionaries in code, and it’s easier to read
    than JSON or YAML. Listing C.1 shows the TOML configuration for the image gallery
    app.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Viper支持比其他示例更广泛的配置文件语言集。您可以使用JSON或YAML，但在Go世界中流行的格式是TOML（以创建者Tom Preston-Werner命名）。TOML非常适合配置文件，因为它可以轻松地映射到代码中的字典，并且比JSON或YAML更容易阅读。表C.1显示了图像库应用程序的TOML配置。
- en: Listing C.1 The TOML format makes for easily managed config files
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 表C.1 TOML格式使得配置文件易于管理
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You see TOML being used in lots of cloud-native projects because it’s so much
    easier than the alternatives. If you have a choice of formats, TOML is worth considering
    because “easy to read” also means easy to debug, and easy to see the differences
    between versions in a merge tool. Other than the file format, this example works
    in the same way as the Node.js app, with a default `config.toml` file packaged
    into the Docker image.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 您会在许多云原生项目中看到TOML的使用，因为它比替代方案容易得多。如果您可以选择格式，TOML值得考虑，因为“易于阅读”也意味着易于调试，并且易于在合并工具中查看版本之间的差异。除了文件格式之外，此示例与Node.js应用程序以相同的方式工作，默认的`config.toml`文件打包到Docker镜像中。
- en: 'Try it Now Run the app without any additional config setup to check the defaults:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下：运行应用程序，无需任何额外的配置设置，以检查默认值：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When you run this exercise, you’ll see the current app configuration, which
    all comes from the default TOML file. My output is in figure C.7, and it shows
    the release cycle and the default URLs for the APIs that this app consumes.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行此练习时，您将看到当前应用程序配置，所有这些配置都来自默认的TOML文件。我的输出在图C.7中，显示了发布周期和应用程序所消耗的API的默认URL。
- en: '![](../Images/C-7.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/C-7.jpg)'
- en: Figure C.7 You can package your app with default settings that work but aren’t
    a complete environment.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.7 您可以使用默认设置打包应用程序，这些设置可以工作，但不是完整的开发环境。
- en: 'The output is from a config API that returns JSON for the current configuration
    settings. A config API is a very useful feature in your app when you have multiple
    layers of config sources; it makes debugging configuration issues much easier,
    but you need to secure that data. There’s no point using secrets for confidential
    settings if they can be publicly read by anyone who tries browsing to `/config`,
    so if you’re going to add a config API, you need to do three things:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 输出来自一个配置API，该API返回当前配置设置的JSON。当您有多个配置源时，配置API是您应用程序中的一个非常有用的功能；它使得调试配置问题变得容易得多，但您需要保护这些数据。如果任何人尝试浏览到`/config`都可以公开读取机密设置，那么使用机密设置来保护机密设置就没有意义，所以如果您要添加配置API，您需要做三件事：
- en: Don’t just publish the whole config; be selective and never include secrets.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要只发布整个配置；要有选择性，永远不要包含机密信息。
- en: Secure the endpoint so only authorized users can access it.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护端点，以确保只有授权用户可以访问它。
- en: Make the config API a feature that can be enabled through config.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将配置API制作成一个可以通过配置启用的功能。
- en: The image gallery app takes a slightly different approach from the hierarchical
    config model—default settings are saved in the image, but not for any specific
    environment. The expectation is that every environment will specify its own additional
    config file, which extends or overrides settings in the default file to set up
    the full environment.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图像库应用程序采用与分层配置模型略有不同的方法——默认设置保存在图像中，但不是针对任何特定环境。预期是每个环境都将指定自己的附加配置文件，该文件扩展或覆盖默认文件中的设置，以设置完整的开发环境。
- en: 'Try it Now Run the same app again with an override file to build a complete
    environment:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下：再次运行相同的应用程序，使用覆盖文件来构建完整的开发环境：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: My output in figure C.8 shows the app is now fully configured for the dev environment,
    merging the release-level config file in the image with the environment override
    file.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.8 我在图C.8中的输出显示，应用程序现在已完全配置为开发环境，将镜像中的发布级别配置文件与环境覆盖文件合并。
- en: '![](../Images/C-8.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/C-8.jpg)'
- en: Figure C.8 The Go Viper module merges config files in the same way as the node-config
    package.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.8 Go Viper模块以与node-config包相同的方式合并配置文件。
- en: Showing you all these slight variations on the config theme isn’t just a cheap
    way to fill out the chapter. When organizations adopt Docker, they tend to find
    that usage accelerates quickly, and they soon have a lot of apps running in containers
    that each have their own opinions on configuration. Lots of small variations like
    this are bound to happen because the app platforms differ in the features they
    provide and the conventions they expect. You can apply standards at a high level—images
    must come packaged with default config and must support file and environment variable
    overrides—but the details of the config file and environment variable formats
    will be hard to standardize.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 展示所有这些关于配置主题的细微差异并不仅仅是为了填补章节内容。当组织采用Docker时，他们往往会发现使用速度加快，很快就会有大量应用程序在容器中运行，每个应用程序都有自己的配置观点。由于应用程序平台在提供的功能和期望的约定上有所不同，因此必然会发生许多这样的小差异。您可以在高层次上应用标准——镜像必须包含默认配置，并且必须支持文件和环境变量覆盖——但是配置文件和环境变量格式的细节将难以标准化。
- en: We’ll see that in a last example with the Go application. The Viper module supports
    environment variables to override settings in config files, but with a convention
    that is different again from node-config and from .NET Core.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在最后一个Go应用程序的例子中看到这一点。Viper模块支持使用环境变量覆盖配置文件中的设置，但与node-config和.NET Core的约定不同。
- en: 'Try it now Run the container with an environment variable override. The config
    model in this app only uses environment variables prefixed with `IG`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下：使用环境变量覆盖运行容器。这个应用程序中的配置模型只使用以`IG`为前缀的环境变量：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Viper has the convention that you should prefix environment variable names so
    they don’t clash with other environment variables. In this app, the prefix is
    `IG`, followed by an underscore, followed by the config setting name in dot notation
    (so `IG_METRICS .ENABLED` matches the `enabled` value in the `metrics` group in
    the TOML file). You can see from my output in figure C.9 that this setup adds
    the development environment on top of the default settings but then overrides
    the metrics settings to enable Prometheus metrics.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Viper的约定是，你应该在环境变量名称前加上前缀，以避免与其他环境变量冲突。在这个应用程序中，前缀是`IG`，后面跟着一个下划线，然后是配置设置名称的点表示法（因此`IG_METRICS.ENABLED`与TOML文件中`metrics`组中的`enabled`值匹配）。您可以从我的输出中看到，图C.9中的这种设置在默认设置之上添加了开发环境，但随后覆盖了指标设置以启用Prometheus指标。
- en: '![](../Images/C-9.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/C-9.jpg)'
- en: Figure C.9 All the example apps support environment variables for config, but
    with small variations.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.9 所有示例应用程序都支持配置环境变量，但有一些小的差异。
- en: We’ve walked through config modeling with three different apps, and we have
    three slightly different approaches. The differences are manageable and easy to
    document in the application manifest files, and they don’t actually impact how
    you build the image or run the container. We’ll look at one last example in this
    chapter that takes the same configuration model and applies it to an application
    that doesn’t have a nice new configuration library, so it needs some extra work
    to make it behave like a modern app.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经用三个不同的应用程序走过了配置建模，我们有三种略有不同的方法。这些差异是可控的，并且很容易在应用程序清单文件中记录下来，并且实际上它们不会影响您构建镜像或运行容器的方式。在本章中，我们将查看一个最后的例子，它采用相同的配置模型并将其应用于没有漂亮的新配置库的应用程序，因此需要做一些额外的工作来使其表现得像现代应用程序。
- en: C.4 Configuring legacy apps in the same way as new apps
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C.4 以与新型应用程序相同的方式配置传统应用程序
- en: Legacy apps have their own ideas about configuration, which don’t usually involve
    environment variables or file merges. .NET Framework apps on Windows are a good
    example—they expect XML configuration files in specific locations. They don’t
    like looking for files outside the application root folder, and they don’t look
    at environment variables at all. You can still take the same configuration approach
    with those apps, but you need to do some extra work in your Dockerfile.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 传统应用程序对配置有自己的想法，通常不涉及环境变量或文件合并。例如，Windows上的.NET Framework应用程序——它们期望在特定位置有XML配置文件。它们不喜欢在应用程序根文件夹外寻找文件，并且根本不查看环境变量。您仍然可以使用相同的配置方法来处理这些应用程序，但您需要在Dockerfile中做一些额外的工作。
- en: 'The approach here is to package a utility app or set of scripts that transform
    the configuration settings in the container environment into the configuration
    model the application expects. The exact implementation will depend on your app
    framework and how it uses config files, but the logic will be something like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这里采用的方法是将实用应用程序或脚本集打包，将容器环境中的配置设置转换为应用程序期望的配置模型。具体的实现将取决于你的应用程序框架以及它如何使用配置文件，但逻辑可能如下所示：
- en: Read in the config override settings from a specified source file in the container.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从容器中指定的源文件读取配置覆盖设置。
- en: Read in the overrides from environment variables.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从环境变量中读取覆盖设置。
- en: Merge the two sets of overrides, so environment variables take precedence.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 合并两组覆盖设置，使环境变量具有优先权。
- en: Write the merged overrides to the specified target file in the container.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将合并后的覆盖设置写入容器中指定的目标文件。
- en: In the exercises for this chapter, there’s an updated version of the image of
    the day Java API that uses this approach. It’s not actually a legacy app, but
    I’ve built the image with the legacy pattern, as though the app can’t use the
    normal container configuration options. There’s a utility app that runs at startup
    and sets up the configuration, so although the internal configuration mechanism
    is different, users can configure containers in the same way as the other examples.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的练习中，有一个使用此方法的每日图像Java API的更新版本。它实际上不是一个遗留应用程序，但我已经按照遗留模式构建了镜像，好像应用程序不能使用正常的容器配置选项。有一个在启动时运行的实用程序来设置配置，所以尽管内部配置机制不同，用户仍然可以像其他示例一样配置容器。
- en: 'Try it Now Run the “legacy” app with default config settings and with a file
    override:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试运行“遗留”应用程序，使用默认配置设置和文件覆盖：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The user experience is very similar to the other apps—mounting a volume with
    the environment override file (and the source could be a config object or secret)—but
    you have to additionally specify the override file location in an environment
    variable so the startup utility knows where to look. You’ll see in the output
    that the default config in the image specifies the release cycle but not the environment—that
    gets merged in with the override file in the second container. My output is in
    figure C.10.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 用户体验与其他应用程序非常相似——挂载带有环境覆盖文件的卷（源可以是配置对象或密钥）——但你必须另外指定覆盖文件的位置在环境变量中，这样启动实用程序就知道在哪里查找。你将在输出中看到，镜像中的默认配置指定了发布周期，但没有指定环境——这将在第二个容器中的覆盖文件中合并。我的输出在图C.10中。
- en: '![](../Images/C-10.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片C-10](../Images/C-10.jpg)'
- en: Figure C.10 This app has a utility to bootstrap the config model, but the user
    experience is the same.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.10此应用程序有一个实用程序来引导配置模型，但用户体验保持不变。
- en: The magic happens here in a simple Java utility app, which gets compiled and
    packaged in the same multi-stage build as the rest of the app. Listing C.2 shows
    the key parts of the Dockerfile that build the utility and set it to run at startup.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 魔法在这里发生在一个简单的Java实用应用程序中，它与应用程序的其他部分一起编译和打包在同一个多阶段构建中。列表C.2显示了构建实用程序并将其设置为启动时运行的Dockerfile的关键部分。
- en: Listing C.2 Building and using a config load utility in the Dockerfile
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 列表C.2 在Dockerfile中构建和使用配置加载实用程序
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The important takeaway here is that you can extend your Docker image to make
    old apps behave in the same way as new apps. You control the startup logic, so
    you can run any steps you need before starting the actual application. When you
    do this, you’re increasing the amount of time between the container starting and
    the app being ready, and you’re also increasing the risk the container might fail
    (if the startup logic has an error). You should always have health checks in your
    image or your application manifests to mitigate that.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的重要收获是你可以扩展你的Docker镜像，使旧应用程序的行为与新应用程序相同。你控制启动逻辑，因此可以在启动实际应用程序之前运行所需的任何步骤。当你这样做时，你增加了容器启动和应用程序准备就绪之间的时间，同时也增加了容器可能失败的风险（如果启动逻辑有错误）。你应该始终在你的镜像或应用程序清单中包含健康检查，以减轻这种风险。
- en: My config loader utility app supports the 12-factor approach that has environment
    variables override other settings. It merges environment variables with the override
    config file and writes the output as a config file in a location the app expects.
    The utility takes the same approach as Viper, looking for environment variables
    with a specific prefix that helps keep app settings separate from other settings
    in the container.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我的配置加载实用程序应用程序支持12因子方法，其中环境变量覆盖其他设置。它将环境变量与覆盖配置文件合并，并将输出写入应用程序期望的位置的配置文件。该实用程序采用与Viper相同的方法，寻找具有特定前缀的环境变量，这有助于将应用程序设置与其他容器中的设置分开。
- en: Try it now The legacy app doesn’t use environment variables, but the config
    utility sets them up so the user experience is the same as a modern app.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看。遗留应用程序不使用环境变量，但配置实用程序会设置它们，以便用户体验与现代应用程序相同。
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The utility lets me work with my old app in the same way as my other apps. It’s
    mostly transparent to the user—they just set environment variables and load override
    files into volumes. It’s transparent to the app, which just reads the config files
    it expects to see—there are no changes to the original app code here. Figure C.11
    shows that this “legacy” app uses the modern multi-tiered configuration approach.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 该实用程序允许我以与其他应用程序相同的方式使用我的旧应用程序。对用户来说，这主要是透明的——他们只需设置环境变量并将覆盖文件加载到卷中。对应用程序来说也是透明的，它只读取它期望看到的配置文件——这里没有对原始应用程序代码的更改。图C.11显示，这个“遗留”应用程序使用了现代的多层配置方法。
- en: '![](../Images/C-11.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/C-11.jpg)'
- en: Figure C.11 Environment variables make the config model for this old app behave
    like new apps.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.11 环境变量使这个旧应用程序的配置模型表现得像新应用程序。
- en: Now every component in the image gallery app uses the same configuration pattern.
    There’s a level of standardization across all components, but there are also small
    implementation differences. Every component can be configured with a file override
    to run in development mode, and every component can be configured with an environment
    variable to enable Prometheus metrics. How you actually do that differs for each
    app, which is that gray area I mentioned right at the beginning—it’s difficult
    to enforce a standard to say every component will run a Prometheus endpoint if
    the environment variable `ENABLE_METRICS=true`, because app platforms work in
    different ways.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，图像库应用程序中的每个组件都使用相同的配置模式。所有组件之间都有一个标准化水平，但也有一些小的实现差异。每个组件都可以通过文件覆盖来配置以在开发模式下运行，并且每个组件都可以通过环境变量来配置以启用Prometheus指标。您实际上如何做到这一点因应用程序而异，这就是我一开始提到的灰色区域——由于应用程序平台的工作方式不同，很难强制执行一个标准，即当环境变量`ENABLE_METRICS=true`时，每个组件都将运行Prometheus端点。
- en: Documentation is how you remove that confusion, and in the Docker world, deployment
    documentation is best done in the application manifest files. There’s a Docker
    Compose file in the exercises for this chapter that does exactly what I’ve laid
    out in the previous paragraph—setting every component to development mode, but
    enabling Prometheus metrics. Listing C.3 shows the configuration parts of the
    Compose file.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 文档是消除这种混淆的方法，在Docker世界中，部署文档最好在应用程序清单文件中完成。本章的练习中有一个Docker Compose文件，它正好执行了我之前段落中描述的操作——将每个组件设置为开发模式，但启用Prometheus指标。列表C.3显示了Compose文件的配置部分。
- en: Listing C.3 Documenting config settings in Docker Compose
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 列表C.3 在Docker Compose中记录配置设置
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It’s a bit of a lengthy code listing, but I wanted to keep all that in one place
    so you can see how the patterns are the same, although the details are different.
    The Node.js app uses a JSON string in an environment variable to enable metrics,
    and it loads a JSON file as a config override.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一段相当长的代码列表，但我希望将所有这些内容放在一个地方，以便您可以看到模式是相同的，尽管细节不同。Node.js应用程序使用环境变量中的JSON字符串来启用指标，并加载JSON文件作为配置覆盖。
- en: The Java application uses an environment variable that lists the management
    endpoints to include; adding Prometheus in there enables metrics collection. Then
    it loads a config override from a properties file, which is a series of key/value
    pairs.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Java应用程序使用一个环境变量来列出要包含的管理端点；在其中添加Prometheus可以启用指标收集。然后它从属性文件中加载配置覆盖，这是一个键/值对的序列。
- en: The Go application uses a simple `"TRUE"` string in an environment variable
    to enable metrics and loads the config override as a TOML file. I’m using the
    secret support in Docker Compose for the file sources, but the pattern is the
    same for volume mounts or config objects in a cluster.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Go应用程序使用环境变量中的一个简单的`"TRUE"`字符串来启用指标，并以TOML文件的形式加载配置覆盖。我在Docker Compose中使用了文件源的秘密支持，但模式对于集群中的卷挂载或配置对象是一样的。
- en: The user experience here is both good and bad. It’s good because you can easily
    load different environments by changing the source paths for the config overrides,
    and you can change individual settings with environment variables. It’s bad because
    you need to know the quirks of the application. The project team will likely evolve
    various Docker Compose overrides to cover different configurations, so editing
    config settings won’t be a common activity. Running the app will be far more common,
    and that’s as easy as starting any app with Compose.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的用户体验既有好的一面也有不好的一面。好的一面是你可以通过更改配置覆盖的源路径来轻松加载不同的环境，并且你可以使用环境变量更改单个设置。不好的一面是你需要了解应用程序的怪癖。项目团队可能会演变各种Docker
    Compose覆盖来覆盖不同的配置，因此编辑配置设置不会是一个常见的活动。运行应用程序将会更加常见，而且这和用Compose启动任何应用程序一样简单。
- en: 'Try it Now Let’s run the app as a whole with a fixed set of configuration for
    all the components. Start by removing all running containers, and then run the
    app with Docker Compose:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看。让我们使用一组固定的配置来运行所有组件的应用程序。首先，移除所有正在运行的容器，然后使用Docker Compose运行应用程序：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can browse to http:/ /localhost:8010 and use the app in the normal way,
    and browse to the Prometheus endpoints to see the component metrics (on [http://localhost:8010/
    metrics](http://localhost:8010/metrics), http://localhost:8030/metrics, and http://localhost:8020/actuator/prometheus).
    But actually, all the confirmation that the app is configured correctly comes
    from those config APIs.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以浏览到`http:/ /localhost:8010`并按正常方式使用应用程序，并浏览到Prometheus端点以查看组件指标（在[http://localhost:8010/metrics](http://localhost:8010/metrics)，http://localhost:8030/metrics，和http://localhost:8020/actuator/prometheus）。但实际上，所有确认应用程序配置正确的信息都来自那些配置API。
- en: You can see my output in figure C.12\. Every component loads the release cycle
    name from the default config file in the image, the environment name from the
    config override file, and the metrics setting from the environment variable.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在图C.12中看到我的输出。每个组件都从镜像中的默认配置文件加载发布周期名称，从配置覆盖文件中加载环境名称，并从环境变量中加载指标设置。
- en: '![](../Images/C-12.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/C-12.jpg)'
- en: Figure C.12 Docker Compose can document app config settings and start the app
    with that configuration.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.12 Docker Compose可以记录应用程序配置设置，并使用该配置启动应用程序。
- en: That’s all we really need to cover regarding the patterns for building your
    applications to fetch configuration from the container environment. We’ll wrap
    up this chapter with some thoughts on where that multi-tiered configuration model
    can take you.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 关于从容器环境获取配置的应用程序构建模式，我们实际上需要涵盖的就是这些。我们将以关于多级配置模型能带你到哪里的思考来结束这一章。
- en: C.5 Understanding why a flexible configuration model pays off
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C.5 理解为什么灵活的配置模型会带来回报
- en: You’ll package and deploy apps to production using a CI/CD pipeline and the
    core design of that pipeline is that you build one image, and your deployment
    process is about promoting that image through your environments up to production.
    Your apps will need to work slightly differently in each environment, and the
    way to support that while keeping the single-image approach is to use a multi-tiered
    configuration model.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用CI/CD管道将应用程序打包并部署到生产环境中，该管道的核心设计是构建一个镜像，你的部署过程就是将这个镜像通过你的环境提升到生产环境。你的应用程序在每个环境中都需要稍微有所不同，而为了保持单镜像方法同时支持这一点，你可以使用多级配置模型。
- en: In practice you’ll use the release-level settings built into the container image,
    with the environment-level override file provided by the container platform in
    almost all cases, but the ability to set feature-level config with environment
    variables is a useful addition. It means you can react quickly to production issues—tuning
    down the level of logging if that’s a performance issue, or turning off a feature
    that has a security hole. It also means you can create a production—like environment
    on a dev machine to replicate a bug, using the production config override with
    secrets removed, and using environment variables instead.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，你将使用内置在容器镜像中的发布级别设置，几乎在所有情况下，使用容器平台提供的环境级别覆盖文件，但能够使用环境变量设置功能级别的配置是一个有用的补充。这意味着你可以快速响应生产问题——如果这是一个性能问题，则降低日志级别，或者关闭存在安全漏洞的功能。这也意味着你可以在开发机器上创建一个类似生产的环境来复现错误，使用移除机密的配置覆盖，并使用环境变量。
- en: That ability to run the exact same image in any environment is the payback for
    investing time in your config model. Figure C.13 shows the life cycle of an image
    from the CI/CD pipeline onwards.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 能够在任何环境中运行完全相同的镜像，这是在配置模型上投入时间的回报。图C.13显示了从CI/CD管道开始的镜像生命周期。
- en: '![](../Images/C-13.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/C-13.jpg)'
- en: Figure C.13 The CI/CD pipeline produces one image, and you use the config model
    to change behavior.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.13 CI/CD管道生成一个镜像，你使用配置模型来改变行为。
- en: The work you do in producing this flexible configuration model will go a long
    way toward future-proofing your app. All container runtimes support loading files
    into the container from config objects or secrets and setting environment variables.
    The Docker images for this chapter’s image gallery app will work in the same way
    with Docker Compose, Docker Swarm, or Kubernetes. And it’s not just container
    runtimes—standard configuration files and environment variables are the models
    used in platform-as-a-service (PAAS) products and serverless functions too.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你在创建这个灵活的配置模型时所做的努力将大大有助于确保你的应用在未来具有可维护性。所有容器运行时都支持从配置对象或机密中加载文件到容器中，并设置环境变量。本章图像库应用的Docker镜像将以相同的方式与Docker
    Compose、Docker Swarm或Kubernetes一起工作。而且不仅限于容器运行时——标准的配置文件和环境变量也是平台即服务（PAAS）产品和无服务器函数中使用的模型。
- en: C.6 Lab
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C.6 实验室
- en: It can be tricky to dig into the configuration model for a new app and work
    out how to set override files and configure feature overrides, so you’re going
    to get some practice in this lab. You’ll be using the same image gallery app—in
    the lab folder for this chapter there’s a Docker Compose file with the app components
    specified but with no configuration. Your job is to set up every component to
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对于新应用深入挖掘配置模型并找出如何设置覆盖文件和配置功能覆盖可能有些棘手，所以你将在本实验中获得一些练习。你将使用相同的图像库应用——在本章的实验室文件夹中有一个指定了应用组件的Docker
    Compose文件，但没有配置。你的任务是设置每个组件以
- en: Use volumes to load configuration override files.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用卷来加载配置覆盖文件。
- en: Load the configuration overrides for the test environment.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载测试环境的配置覆盖。
- en: Override the release cycle to be “20.01” instead of “19.12”.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将发布周期重置为“20.01”而不是“19.12”。
- en: This should be fairly straightforward, but it will be useful to spend some time
    tweaking app config without making any changes to the apps. When you run the app
    with `docker-compose` `up`, you should be able to browse to http://localhost:8010
    and the app should work. And you should be able to browse to all three config
    APIs and see that the release name is 20.01 and the environment is TEST.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该相当直接，但花些时间调整应用配置而不对应用进行任何更改将很有用。当你使用 `docker-compose` `up` 运行应用时，你应该能够浏览到
    http://localhost:8010，并且应用应该能够正常工作。你应该能够浏览到所有三个配置API，并看到发布名称是20.01，环境是TEST。
- en: 'My solution is in the same folder in the `docker-compose-solution.yml` file,
    or you can check it on GitHub here: [https://github.com/sixeyed/diamol/blob/master/ch18/lab/README.md](https://github.com/sixeyed/diamol/blob/master/ch18/lab/README.md).'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我的解决方案在同一个文件夹中的 `docker-compose-solution.yml` 文件中，或者你可以在GitHub上查看：[https://github.com/sixeyed/diamol/blob/master/ch18/lab/README.md](https://github.com/sixeyed/diamol/blob/master/ch18/lab/README.md)。
