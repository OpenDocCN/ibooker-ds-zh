- en: 8 Linear async flows
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 线性异步流程
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Reviewing a basic Node.js architecture
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查基本的Node.js架构
- en: Working with the JavaScript `Promise` API
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JavaScript `Promise` API
- en: Assembling promise chains to model complex asynchronous flows
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组装承诺链以模拟复杂的异步流程
- en: Using `async`/`await` and asynchronous iterators
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`async`/`await`和异步迭代器
- en: '*For over a decade prophets have voiced the contention that the organization
    of a single computer has reached its limits and that truly significant advances
    can be made only by interconnection of a multiplicity of computers.*'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*超过十年，先知们已经提出论点，认为单个计算机的组织已经达到极限，并且只有通过多个计算机的互联才能取得真正重大的进步。*'
- en: —Gene Amdahl
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: —Gene Amdahl
- en: As Amdhal predicted, the web is a gigantic, distributed, interconnected network,
    and the language we use must rise to the challenge by providing appropriate abstractions
    that facilitate programming this ever-evolving and ever-changing web. Programming
    the web is different from programming local servers, because you can’t make assumptions
    about where the data is located. Is it in local storage, a cache, on the intranet,
    or a million miles away? Hence, one of the main design goals of JavaScript is
    that it needs to have strong abstractions for asynchronous data operations.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 正如Amdahl所预测的，网络是一个庞大、分布式、互联的网络，我们使用的语言必须通过提供适当的抽象来应对挑战，这些抽象有助于编程这个不断演变和变化着的网络。在网络上编程与在本地服务器上编程不同，因为你无法假设数据的位置。它是在本地存储、缓存、内联网，还是在数百万英里之外？因此，JavaScript的主要设计目标之一是它需要具有强大的异步数据操作抽象。
- en: 'JavaScript developers had become accustomed to the callback pattern: “Here’s
    some piece of code. Go and do something else (time) and then call it back when
    you’re done.” Although this pattern kept us going for a while (and still does),
    it also presented difficult and unique challenges, especially when programming
    on a large scale and with added complexity. One common example was when we needed
    to orchestrate events (such as button clicks and mouse movement) with asynchronous
    actions (such as writing an object to a database). It was immediately obvious
    that callbacks don’t scale for executing more than two or three asynchronous calls.
    Perhaps you’ve heard the term pyramid of doom or callback hell.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript开发者已经习惯了回调模式：“这里有一些代码。去做其他事情（时间）然后完成时再调用它。”虽然这种模式让我们维持了一段时间（并且仍然如此），但它也提出了困难和独特的挑战，尤其是在大规模编程和增加复杂性时。一个常见的例子是我们需要协调事件（如按钮点击和鼠标移动）与异步操作（如将对象写入数据库）。很明显，回调在执行超过两个或三个异步调用时无法扩展。也许你已经听说过“灾难金字塔”或“回调地狱”这个术语。
- en: For this book, it’s expected that you are familiar with the callback pattern,
    so we will not get into its pros and cons. What’s most important is the solution.
    Do we have a way to create an abstraction over callbacks that all JavaScript developers
    can use in a consistent manner—perhaps something with a well-defined API, such
    as an algebraic data type (ADT; chapter 5)? From the search for this solution,
    the Promise API was born, and it has become quite popular for representing most
    asynchronous programming tasks. In fact, new APIs, libraries, and frameworks that
    have any asynchronous logic are almost always represented as promises nowadays.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这本书，我们假设你已经熟悉回调模式，因此我们不会深入探讨其优缺点。最重要的是解决方案。我们是否有创建一个所有JavaScript开发者都可以一致使用的回调抽象的方法——可能是一个具有良好定义的API，例如代数数据类型（ADT；第5章）？从寻找这个解决方案的过程中，Promise
    API诞生了，并且它已经成为表示大多数异步编程任务的一种非常流行的选择。事实上，现在几乎所有具有任何异步逻辑的新API、库和框架几乎都表示为承诺。
- en: This chapter begins with a brief review of the architecture of a common JavaScript
    engine, which features, at a high-level, a task queue and an event loop. Understanding
    this architecture at a glance is important for understanding how asynchronous
    code works to provide concurrent processing. Then we move on to the Promise API
    to lay the foundation for JavaScript’s `async`/`await` feature. With this API,
    you can represent asynchronous processes in a linear, synchronous way, similar
    to programming in a procedural style. Promises let you think about the problem
    at hand without having to worry about when a task completes or where data resides.
    Next, you’ll learn how to take advantage of the composability of promises and
    powerful combinators to chain together complex asynchronous logic. Last, you will
    review the dynamic import statement (mentioned briefly in chapter 6), and look
    at features including top-level await and asynchronous iteration.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章从对常见JavaScript引擎架构的简要回顾开始，该架构在高级别上具有任务队列和事件循环的特点。快速理解这一架构对于理解异步代码如何工作以提供并发处理非常重要。然后我们转向Promise
    API，为JavaScript的`async`/`await`特性打下基础。使用这个API，你可以以线性、同步的方式表示异步过程，类似于过程式编程。Promise让你可以思考手头的问题，而无需担心任务何时完成或数据存储在哪里。接下来，你将学习如何利用Promise的可组合性和强大的组合子来链接复杂的异步逻辑。最后，你将回顾动态导入语句（在第6章中简要提及），并查看包括顶层await和异步迭代在内的功能。
- en: It’s hard to talk about asynchronous programming in most programming languages
    without mentioning threads. That’s not the case with JavaScript. What makes asynchronous
    programming so simple is the fact that JavaScript gives you a single-threaded
    model while exploiting the multithreaded capabilities of the underlying platform
    (the browser or Node.js). A single-threaded model is not a disadvantage, but a
    blessing. We’ll start by taking a peek at this architecture.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数编程语言中谈论异步编程而不提及线程是很困难的。JavaScript的情况并非如此。异步编程之所以简单，是因为JavaScript提供了一个单线程模型，同时利用了底层平台（浏览器或Node.js）的多线程能力。单线程模型不是一种劣势，而是一种祝福。我们将首先窥视这一架构。
- en: 8.1 Architecture at a glance
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1 概观架构
- en: You may be somewhat familiar with how Node.js and most JavaScript engines work
    behind the scenes. Without getting into the weeds of any particular runtime implementation
    (V8, Chakra, or Spidermonkey), it’s important to give you a high-level idea of
    how a typical JavaScript engine works under the hood. A typical JavaScript architecture
    is
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能对Node.js和大多数JavaScript引擎在幕后的工作方式有所了解。在不深入任何特定运行时实现（如V8、Chakra或Spidermonkey）的细节的情况下，重要的是要给你一个关于典型JavaScript引擎底层工作方式的概览。典型的JavaScript架构是
- en: Event-driven — The JavaScript engine uses an event loop to constantly monitor
    a task queue, also known as a callback queue. When a task is detected, the event
    loop dequeues the task and runs it to completion.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件驱动 —— JavaScript引擎使用事件循环来持续监控任务队列，也称为回调队列。当检测到任务时，事件循环将任务从队列中取出并运行至完成。
- en: Single-threaded — JavaScript provides a single-threaded model to developers.
    There are no standard, language-level threading APIs to spawn new threads.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单线程 —— JavaScript为开发者提供了一个单线程模型。没有标准、语言级别的线程API来创建新线程。
- en: Asynchronous — All modern JavaScript engines use multiple threads (managed by
    an internal worker pool) so that you can perform nonblocking I/O actions without
    blocking the main thread.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步 —— 所有现代JavaScript引擎都使用多个线程（由内部工作池管理），这样你就可以在不阻塞主线程的情况下执行非阻塞I/O操作。
- en: Figure 8.1 shows that the event loop is at the heart of this architecture. Every
    heartbeat or tick of the event loop picks and runs a new task or slices of a task.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1展示了事件循环是这个架构的核心。事件循环的每一次心跳或tick都会选择并运行一个新的任务或任务的一部分。
- en: '![](../Images/8-1.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1](../Images/8-1.png)'
- en: Figure 8.1 JavaScript’s event-driven, asynchronous architecture. At the heart
    is the event loop (a semi-infinite loop), which is the abstraction used to handle
    concurrent behavior in JavaScript. The event loop takes care of scheduling new
    asynchronous tasks and allocating them to any threads available in the pool. When
    the task completes, the engine triggers the action’s callback function to return
    control to the user.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 JavaScript的事件驱动、异步架构。核心是事件循环（一个半无限循环），这是JavaScript中处理并发行为的抽象。事件循环负责调度新的异步任务并将它们分配给池中可用的任何线程。当任务完成时，引擎触发操作的回调函数以将控制权交还给用户。
- en: Node.js’s engine does a fine job of abstracting the execution of multiple asynchronous
    actions so that they appear to run simultaneously. Behind the scenes, the event
    loop performs fast scheduling and swapping, using its own thread to interact natively
    with the operating system’s kernel APIs or browser thread architecture and to
    perform all the necessary bookkeeping of managing threads (called workers) in
    the pool. The polling loop is infinite, but it’s not always spinning; otherwise,
    it would be resource-intensive. It starts ticking when there are events or actions
    of interest such as button clicks, file reads, and network sockets. When a task
    appears, the event loop dequeues it from the task queue and schedules it to run.
    Each task runs to completion and invokes the provided callback to return control
    to the user, along with the result (if any). This process works like a clock (literally),
    yet the user has no idea that any of it is happening. On the surface, JavaScript
    does not leak or expose any threading-related code.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 的引擎在抽象多个异步操作的执行方面做得很好，使得它们看起来是同时运行的。在幕后，事件循环执行快速的调度和交换，使用自己的线程与操作系统的内核
    API 或浏览器线程架构进行原生交互，并执行管理线程池中线程（称为工作者）的所有必要记录。轮询循环是无限的，但并不总是处于旋转状态；否则，它将非常消耗资源。当有感兴趣的事件或操作，如按钮点击、文件读取和网络套接字时，它才开始计时。当出现任务时，事件循环将其从任务队列中出队，并安排它运行。每个任务都会运行到完成，并调用提供的回调函数将控制权交还给用户，并返回结果（如果有）。这个过程就像时钟一样工作（字面意思），然而用户并不知道这一切正在发生。表面上，JavaScript
    并没有泄露或暴露任何与线程相关的代码。
- en: Furthermore, threads can be created internally by server-side or client-side
    native APIs (DOM, AJAX, sockets, timers, and others) or by any third-party libraries
    that implement native extensions. As JavaScript developers, we are privileged
    to have this technology remove this complexity for us. To top it off, we have
    at our fingertips simple APIs that put even more layers of abstraction between
    us and the engine. Promise is the first line of defense against callback hell
    and the stepping stone to simplifying asynchronous flows.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，线程可以通过服务器端或客户端的本地 API（DOM、AJAX、套接字、定时器等）或任何实现本地扩展的第三方库内部创建。作为 JavaScript
    开发者，我们有幸拥有这项技术为我们移除这种复杂性。更不用说，我们手头上有简单的 API，它们在我们和引擎之间增加了更多的抽象层。Promise 是抵御回调地狱的第一道防线，也是简化异步流程的垫脚石。
- en: 8.2 JavaScript as promised
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2 作为承诺的 JavaScript
- en: Promises were created to address the increasing complexity of having to nest
    callback within callback functions in favor of flattening these calls into a single,
    fluent expression. In this section, you’ll learn how the `Promise` API simplifies
    the mental model of asynchronous programming. It’s important to master this API,
    because it’s the foundation of `async`/`await` and related features.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Promise 的创建是为了解决在回调函数中嵌套回调函数的日益复杂问题，目的是将这些调用扁平化成一个单一的、流畅的表达式。在本节中，你将学习 `Promise`
    API 如何简化异步编程的思维方式。掌握这个 API 非常重要，因为它是 `async`/`await` 和相关特性的基础。
- en: Simply put, a Promise object encapsulates some eventual (to-be-computed) value,
    much like a regular function. It is capable of delivering a single object, whether
    that object is a simple primitive or a complex array. Promises are similar to
    callbacks in that they clearly communicate “Go do something; then (time) go do
    something else,” which makes them good candidates for one-to-one replacement.
    The following listing shows how you’d instantiate a new promise.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，Promise 对象封装了一些最终（待计算）的值，就像一个普通函数一样。它能够传递一个单一的对象，无论这个对象是一个简单的原始值还是一个复杂的数组。Promise
    与回调函数类似，它们清晰地传达了“去做某事；然后（在某个时间点）去做另一件事”的信息，这使得它们成为一对一替换的理想选择。以下列表展示了如何实例化一个新的
    Promise 对象。
- en: Listing 8.1 Instantiating a new `Promise` object
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.1 实例化一个新的 `Promise` 对象
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Promises also rely on a callback function. This function is called the executor.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Promise 也依赖于一个回调函数。这个函数被称为执行器。
- en: ❷ The then method allows you to sequence multiple promises together.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ `then` 方法允许你将多个 Promise 串联起来。
- en: Like callbacks, promises take advantage of the full capabilities of the JavaScript
    architecture. In fact, to the engine, there shouldn’t be any difference. Generally,
    any event for which some form of callback function is provided (mouse event, HTTP
    request, promises, and so on) may use JavaScript’s event loop. (Sometimes, for
    simple operations such as a `setTimeout`, a direct nonblocking system call may
    be used, but it is an engine-specific optimization.) The function passed to the
    `Promise` constructor is called the executor function. The executor runs without
    blocking the main code, and the event loop decides how to schedule the work by
    nicely weaving timed slices of asynchronous blocks together with the main code.
    Figure 8.2 depicts this process.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 与回调一样，Promise利用了JavaScript架构的全部能力。实际上，对于引擎来说，不应该有任何区别。通常，任何提供了某种形式的回调函数的事件（如鼠标事件、HTTP请求、Promise等）都可以使用JavaScript的事件循环。有时，对于简单的操作（如`setTimeout`），可能会使用直接的非阻塞系统调用，但这是一种引擎特定的优化。传递给`Promise`构造函数的函数称为执行器函数。执行器在没有阻塞主代码的情况下运行，事件循环通过巧妙地将异步块的时间片与主代码交织在一起来决定如何安排工作。图8.2描述了这一过程。
- en: '![](../Images/8-2.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2](../Images/8-2.png)'
- en: Figure 8.2 A simplified view of how the Node.js architecture handles asynchronous
    tasks. The event loop time slices these tasks so that code never blocks, providing
    the illusion of concurrency.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 节点.js架构处理异步任务的一个简化视图。事件循环将这些任务分割成时间片，使得代码永远不会阻塞，从而提供了并行的假象。
- en: 'Every programming language nowadays supports a similar API, sometimes called
    a Task or a Future. The general idea is the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现今的每种编程语言都支持类似的API，有时被称为任务或未来。其基本思想如下：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'These tasks will run to completion and may take an arbitrary amount of time
    to run. The `Promise#then` method clearly communicates that promises are abstracting
    over time (or latency). Promises allow you to work with time in a simple manner
    (in plain English, if you will) so that you can focus on solving the real business
    issues. It helps to think of them as being the time-bound instruction separator
    for asynchronous calls, much like what a semicolon does with synchronous statements:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这些任务将运行到完成，可能需要任意长的时间。`Promise#then`方法清楚地表明Promise是在抽象时间（或延迟）。Promise允许你以简单的方式（用普通的英语来说）处理时间，这样你就可以专注于解决真正的业务问题。有助于将它们视为异步调用的时间限制指令分隔符，就像分号在同步语句中所做的那样：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Promises are ideal return wrappers for operations that may involve waiting or
    blocking, such as I/O or HTTP requests. In fact, the Node.js fs library has slowly
    evolved from using synchronous APIs to using callbacks and finally to returning
    promises—a good example of the adoption of this pattern over time. You can find
    both synchronous and asynchronous APIs to access the file system.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Promise是涉及等待或阻塞操作（如I/O或HTTP请求）的理想返回包装器。实际上，Node.js的fs库已经从使用同步API逐渐发展到使用回调，最后到返回Promise——这是随着时间的推移采用此模式的一个很好的例子。你可以找到同步和异步API来访问文件系统。
- en: 'Let’s walk through a simple example that shows this evolution, starting with
    the synchronous approach:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简单的例子来展示这种演变过程，从同步方法开始：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This approach should be your least-preferred option (and the Node.js team intended
    it as such by explicitly labeling it `Sync`), as it pauses the main thread. Blocking
    is the opposite of scaling and goes against the event-driven, single-threaded
    qualities of JavaScript. Use it with caution or only for simple one-off scripts.
    Second in line is the default callback version:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法应该是你最不希望选择的方法（Node.js团队通过明确将其标记为`Sync`来表示这一点），因为它会暂停主线程。阻塞与扩展相反，并且与JavaScript的事件驱动、单线程特性相悖。请谨慎使用，或者仅用于简单的单次脚本。其次是默认的回调版本：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This API uses JavaScript’s internal scheduler so that code never halts on the
    `readFile` call. When the data is ready, the supplied callback is triggered with
    the actual file contents.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此API使用JavaScript的内部调度器，使得代码在`readFile`调用上永远不会停止。当数据准备好时，提供的回调函数会被触发，并带有实际的文件内容。
- en: 'An intermediate step between callbacks and a fully promise-based filesystem
    library is a utility called `util.promisify`, which adapts callback-based functions
    to use Promise:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在回调和完全基于Promise的文件系统库之间有一个中间步骤，是一个名为`util.promisify`的工具，它将基于回调的函数适配为使用Promise：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The caveat is that this utility works with error-first callbacks, a pattern
    prevalent in many JavaScript APIs, stating that callbacks should be right-biased,
    with the error state mapped to the left argument and the success state mapped
    to the right. (You learned about biased APIs in chapter 5.) Like `Validation`
    and other monads, the continuation branch (the branch to which `Functor.map` applies)
    is always on the right. This resemblance is coincidental, however. As you’ll see
    in section 8.2.2, there’s a strong connection between promises and ADTs.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 但有一个限制，这个实用工具与错误优先的回调一起工作，这是一种在许多JavaScript API中普遍存在的模式，表明回调应该是右偏的，错误状态映射到左参数，成功状态映射到右参数。（你在第5章中学习了有偏API。）与`Validation`和其他单子（monads）一样，延续分支（`Functor.map`应用到的分支）始终在右边。然而，这种相似性是巧合的。正如你将在第8.2.2节中看到的，承诺（promises）和ADT之间有一个强烈的联系。
- en: 'Finally, there’s the best approach, which is to use a built-in promisified
    alternative library to access the filesystem, available in Node.js as a separate
    namespace `fs.promises`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，最好的方法是使用内置的承诺化替代库来访问文件系统，在Node.js中作为单独的命名空间`fs.promises`提供：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Arguably, this version is a lot more fluent than the callback-based approach
    because code no longer appears to be nested. With a single asynchronous operation,
    the improvement might not be obvious, but think about the more intensive tasks
    that involve three or four asynchronous calls.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 不可否认，这个版本比基于回调的方法更加流畅，因为代码不再显得嵌套。使用单个异步操作，改进可能并不明显，但想想那些涉及三个或四个异步调用的更密集的任务。
- en: Now that you’ve seen how an API improves with the use of promises, let’s dive
    deeper into why this API was so earth-shaking in the JavaScript world. Earlier,
    I said that promises wrap over values to be computed at some arbitrary time. The
    beauty of this abstraction, though, is that it blurs where the data resides.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了使用承诺（promises）如何改进API，让我们更深入地探讨为什么这个API在JavaScript世界中如此震撼人心。之前我说过，承诺（promises）封装了在某个任意时间要计算的价值。然而，这个抽象的美妙之处在于它模糊了数据所在的位置。
- en: 8.2.1 Principle of data locality
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.1 数据局部性原则
- en: 'Generally speaking, the principle of data locality is the idea of moving the
    data closer to where some computation is taking place, or vice versa. The closer
    the data, the faster it moves to the desired destination, through a system bus
    or through the internet. The varying distances between data and a computing unit,
    for example, are why you have different levels of caching in your CPU architecture
    or even in your JavaScript applications. Promises allow us to use the same programming
    model no matter where the data resides (local or remote) or how long a computation
    takes (two seconds, two minutes, or two hours). This snippet of code can read
    a file whether it lives locally on the server or in some remote location around
    the world:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，数据局部性原则是指将数据移动到某个计算发生的地方附近，或者相反。数据越接近，它移动到期望目的地就越快，无论是通过系统总线还是通过互联网。数据与计算单元之间的不同距离，例如，是你在CPU架构中甚至在你的JavaScript应用程序中有不同级别缓存的原因。承诺（promises）允许我们无论数据位于何处（本地或远程）或计算需要多长时间（两秒、两分钟或两小时），都能使用相同的编程模型。这段代码可以读取文件，无论它位于服务器上的本地位置还是世界某个遥远的地点：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We can say that promises are façades over latency and that data locality will
    not affect your programming model. We’ll circle back to this idea when we discuss
    observables in chapter 9\. Moreover, the idea of modeling a successful or error
    state is not coincidental. Remember `Success` and `Failure` for the `Validation`
    ADT in chapter 5?
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以说承诺（promises）是延迟的伪装，而数据局部性不会影响你的编程模型。当我们讨论第9章中的可观察者（observables）时，我们会回到这个想法。此外，建模成功或错误状态的想法并非巧合。你还记得第5章中`Validation`
    ADT的`Success`和`Failure`吗？
- en: 8.2.2 Are promises algebraic?
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.2 承诺（promises）是代数性的吗？
- en: In chapter 5, we studied ADTs and their importance in programming as tools to
    make certain types of problems composable. They’re also effective at modeling
    an asynchronous task when we consider time to be an effect. In this section, you’ll
    see that the design of ADTs helps you wrap your head around promises by automatically
    porting all the benefits of composability from ADTs to asynchronous code.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5章，我们研究了ADT及其作为编程工具的重要性，它可以帮助我们将某些类型的问题组合起来。当我们考虑时间是一个效果时，它们在建模异步任务时也非常有效。在本节中，你将看到ADT的设计如何帮助你通过自动将ADT的所有组合性优势转移到异步代码中来理解承诺（promises）。
- en: 'First, let’s talk about how promises work. When a `Promise` object is declared,
    it immediately begins its work (the executor function) and sets its status internally
    to pending:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们谈谈 `Promise` 的工作原理。当一个 `Promise` 对象被声明时，它立即开始其工作（执行函数）并将内部状态设置为挂起：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When a promise settles (in this case, after three seconds), there will be only
    two possible states: fulfilled (resolve with a value) or rejected (reject with
    an error). Figure 8.3 captures all the possible states of a `Promise` object.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `Promise` 解决（在这种情况下，在3秒后），将只有两种可能的状态：已履行（带有值解决）或拒绝（带有错误拒绝）。图8.3捕捉了 `Promise`
    对象的所有可能状态。
- en: '![](../Images/8-3.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/8-3.png)'
- en: Figure 8.3 The states in which a single `Promise` object may be its life cycle
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 单个 `Promise` 对象可能的生命周期状态
- en: If you think about what you learned in chapter 5, `Promise` isn’t much different
    from `Validation`. In fact, you can almost stack their diagrams, as shown in figure
    8.4.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回想起第5章学到的内容，`Promise` 并没有多少不同之处于 `Validation`。事实上，你几乎可以将它们的图叠加起来，如图8.4所示。
- en: '![](../Images/8-4.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/8-4.png)'
- en: Figure 8.4 Structure of the `Validation` type. `Validation` offers a choice
    of `Success` or `Failure`—never both. As with promises, computations continue
    on the `Success` branch.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 `Validation` 类型的结构。`Validation` 提供了 `Success` 或 `Failure` 的选择——永远不会同时两者。与
    `Promise` 一样，计算在 `Success` 分支上继续。
- en: 'Validation also models a binary state. It assumes `Success` when initialized
    with a value and then switches depending on the outcome of the operations that
    are mapped to it. You can sort of assume that the same thing happens with promises:
    they start as pending or fulfilled and then switch depending on what happens with
    each reaction or executor function passed to `Promise#then`. By the same token,
    if `Validation` reaches a `Failure` state, the error is recorded and the chain
    of operations falls through, as with `Promise#catch`.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 验证也模拟了二进制状态。它假设在初始化时带有值时为 `Success`，然后根据映射到它的操作的结果进行切换。你可以假设 `Promise` 也会发生类似的事情：它们开始时是挂起或已履行，然后根据传递给
    `Promise#then` 的每个反应或执行函数发生什么而切换。同样，如果 `Validation` 达到 `Failure` 状态，错误将被记录，操作链将中断，就像
    `Promise#catch` 一样。
- en: Looking at the example from an ADT perspective, we can reason that a `Promise`
    is a closed context with enough internal plumbing to abstract over the effects
    of time. Promises follow the Promise/A+ specification ([https://promisesaplus.com](https://promisesaplus.com/)),
    with the goal of standardizing them and making them interoperable across all JavaScript
    engines.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 从ADT（抽象数据类型）的角度来看这个例子，我们可以推断出 `Promise` 是一个封闭的上下文，拥有足够的内部管道来抽象时间的影响。`Promise`
    遵循 Promise/A+ 规范([https://promisesaplus.com](https://promisesaplus.com/))，目标是标准化它们，并使它们在所有JavaScript引擎之间互操作。
- en: Given any ADT `C`, if you think about `Promise#then` as `C.map` and `Promise.resolve`
    as `C.of`, many of the universal properties of ADTs continue to hold, even composability!
    The one small caveat is that `Promise#then` is left-biased, so it defines the
    fulfilled (success) callback as the left argument and the error callback as the
    right. The reason is usability, as most people code with fulfilled callbacks only
    when chaining multiple promises, using a single `Promise#catch` function at the
    end to handle any errors that occur at any point in the chain.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何ADT `C`，如果你将 `Promise#then` 视为 `C.map`，将 `Promise.resolve` 视为 `C.of`，许多ADT的通用属性仍然保持不变，甚至包括可组合性！唯一的小问题是
    `Promise#then` 是左偏的，因此它将已履行（成功）回调定义为左参数，将错误回调定义为右参数。这样做的原因是可用性，因为大多数人只有在链式调用多个
    `Promise` 时才会使用已履行回调，并在链的末尾使用单个 `Promise#catch` 函数来处理链中任何点发生的任何错误。
- en: I’ll briefly illustrate some of the properties that make promises ADT-like.
    The next listing shows some supporting helper functions used in the examples.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我将简要说明一些使 `Promise` 类似ADT的属性。下面的列表显示了在示例中使用的某些辅助函数。
- en: Listing 8.2 Helper functions used in subsequent code samples and figures
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.2 在后续代码示例和图中使用的辅助函数
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Takes a string of letters and removes duplicates, such as “aabb” -> “ab”
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将字母字符串中的重复项移除，例如 “aabb” -> “ab”
- en: ❷ Joins an array into a string
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将数组连接成一个字符串
- en: ❸ Uppercases all characters of the given string
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将给定字符串的所有字符转换为大写
- en: 'To prove that promises can work and be reasoned about like any ADT, here are
    a couple of the universal properties we discussed in chapter 5, this time using
    `Promise`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明 `Promise` 可以像任何ADT一样工作并可以进行推理，这里有一些我们在第5章讨论的通用属性，这次使用 `Promise`：
- en: Identity —Executing the identity function on a `Promise` yields another `Promise`
    with the same value. The expressions
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 身份——在`Promise`上执行恒等函数会产生另一个具有相同值的`Promise`。以下表达式
- en: '[PRE10]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: and
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 和
- en: '[PRE11]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: are equivalent. Both yield
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 是等价的。两者都产生
- en: '[PRE12]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Composition —The composition of two or more functions, such as `f` after `g`,
    is equivalent to applying `g` first and then `f`. The statements
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合——两个或更多函数的组合，如`f`在`g`之后，等价于先应用`g`然后应用`f`。以下语句
- en: '[PRE13]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: and
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 和
- en: '[PRE14]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: are equivalent. Both yield
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 是等价的。两者都产生
- en: '[PRE15]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: So if `Promise#then` is analogous to `Functor.map`, which method is analogous
    to `Monad .flatMap`? As you’ve probably noticed, `Promise#then` allows you to
    return unwrapped values as well as `Promise`-wrapped values; it handles both.
    Therefore, `Promise#then` is `Functor.map` and `Monad.flatMap` combined, with
    the flattening logic handled behind the scenes. The use case in the following
    listing showcases both scenarios.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果`Promise#then`类似于`Functor.map`，那么类似于`Monad.flatMap`的方法是哪个？正如你可能已经注意到的，`Promise#then`允许你返回未包装的值以及`Promise`包装的值；它处理两者。因此，`Promise#then`是`Functor.map`和`Monad.flatMap`的组合，其扁平化逻辑在幕后处理。以下列表展示了这两种场景的使用案例。
- en: Listing 8.3 `Promise#then` flattening a nested `Promise` automatically
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.3 `Promise#then`自动扁平化嵌套的`Promise`
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ Handles simple values
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 处理简单值
- en: ❷ Handles wrapped values
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 处理包装值
- en: Can we conclude that promises are algebraic or monadic? From a theoretical perspective,
    they are not, because promises don’t have all mathematical properties. In fact,
    promises don’t follow the fantasy-land specification (chapter 5) that we’d expect
    from an ADT. But we’re fortunate that on the surface, promises work the same way
    and that we can take advantage of this sound model of programming, which has a
    low barrier of entry that allows us to assemble (compose) chains of promises.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以得出承诺是代数或单子的结论吗？从理论角度来看，它们不是，因为承诺没有所有数学属性。事实上，承诺不遵循我们期望从ADT得到的幻想之地规范（第5章）。但幸运的是，在表面上，承诺以相同的方式工作，我们可以利用这种可靠的编程模型，它具有低门槛，允许我们组装（组合）承诺链。
- en: 8.2.3 Fluent chaining
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.3 流畅链式调用
- en: A promise chain works like any ADT and is created by subsequently calling `Promise#then`
    or `Promise#catch` on returned `Promise` objects. This process is shown in figure
    8.5.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一个承诺链（promise chain）就像任何ADT（抽象数据类型）一样工作，是通过连续调用返回的`Promise`对象的`Promise#then`或`Promise#catch`来创建的。这个过程在图8.5中展示。
- en: '![](../Images/8-5.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/8-5.png)'
- en: Figure 8.5 A detailed view of the execution of a promise chain. Every `Promise`
    object starts as pending and changes states depending on the outcome of the executor
    callback. The result is wrapped in a new pending `Promise`. (Diagram was inspired
    by [http://mng.bz/Xdx6](http://mng.bz/Xdx6).)
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 展示了承诺链的执行细节。每个`Promise`对象最初都是待定的，并根据执行器回调的结果改变状态。结果是包装在一个新的待定`Promise`中。（图表灵感来源于[http://mng.bz/Xdx6](http://mng.bz/Xdx6)。）
- en: Each executor returns a new pending promise that changes states depending on
    the result of its own executor. If successful, the fulfilled values are passed
    to the next promise in the chain, and so on until a non-`Promise` object is returned.
    This process sounds a lot like composition, if you think about it.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 每个执行器都会返回一个新的待定承诺（pending promise），其状态会根据其自身执行器的结果而改变。如果成功，则满足的值会传递到链中的下一个承诺，依此类推，直到返回一个非`Promise`对象。如果你这么想，这个过程听起来很像组合。
- en: Let’s look at different scenarios of how success and error operations execute,
    starting with a simple scenario of a fully linked chain.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看成功和错误操作执行的不同场景，从一个完全链接链的简单场景开始。
- en: Fully linked chain
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 完全链接链
- en: The following listing shows an example of passing three reaction functions that
    are executed only after the preceding promise succeeds. At each step, new `Promise`
    objects are implicitly created.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了传递三个仅在先前的承诺成功后执行的响应函数的例子。在每一步，都会隐式地创建新的`Promise`对象。
- en: Listing 8.4 Fully linked chain of promises
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.4 完全链接的承诺链
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ Executors are called only when the preceding promise is fulfilled.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 执行器仅在先前的承诺得到满足时被调用。
- en: Like ADTs, promises model the conveyor-belt or railway approach to data manipulation.
    Every operation performs a new data transformation step and returns a new pending
    promise that awaits the result of its handler function. If the function is applied
    successfully, it settles as fulfilled. You saw a detailed flow in figure 8.5\.
    To keep things simple for the next use case, I’ll illustrate the final state of
    the promise at each step. Figure 8.6 describes this flow.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与ADT类似，承诺模拟了传送带或铁路方法的数据操作。每个操作执行一个新的数据转换步骤，并返回一个新的待定承诺，等待其处理函数的结果。如果函数成功应用，它将解决为已履行。您在图8.5中看到了详细的流程。为了使下一个用例简单，我将说明每个步骤的承诺的最终状态。图8.6描述了这种流程。
- en: '![](../Images/8-6.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/8-6.png)'
- en: Figure 8.6 Promise chains allow you to manipulate data as a unidirectional,
    forward conveyor belt where every step applies a different transformation of the
    data.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 显示，承诺链允许你将数据视为一个单向、前向的传送带，其中每一步都应用不同的数据转换。
- en: Listing 8.4 represents a chain with a single result, whereas listing 8.5 does
    not.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.4表示一个具有单个结果的链，而列表8.5则不是。
- en: Broken chain
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 破裂的链
- en: The next listing shows a `Promise` object that never links to any other.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了一个永远不会链接到任何其他对象的`Promise`对象。
- en: Listing 8.5 Broken chain of promises
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.5 破裂的承诺链
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '❶ All executors are called when p fulfills in that order and receive the same
    input. This code produces three promises: two fulfilled and one rejected.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 当p按此顺序履行时，所有执行器都会被调用并接收相同的输入。此代码产生三个承诺：两个已履行和一个被拒绝。
- en: In this case, three different, disjointed `Promise` objects were created, none
    of them linked to the others. This code leads to a runtime error, which most likely
    was unintended. Figure 8.7 shows the bug and the values that would be stored inside
    each resulting promise.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，创建了三个不同的、不连续的`Promise`对象，它们都没有链接到其他对象。这段代码会导致运行时错误，这很可能是意外的。图8.7显示了错误和每个结果承诺中存储的值。
- en: '![](../Images/8-7.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/8-7.png)'
- en: 'Figure 8.7 This approach does not form a chain: It’s a bug. The code adds multiple
    handlers to the same `Promise` object, each applying one transformation to the
    original data, and obtains three different and unexpected results.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7 这种方法不会形成链：这是一个错误。代码向同一个`Promise`对象添加了多个处理程序，每个处理程序对原始数据应用一个转换，并得到三个不同且意外的结果。
- en: The example shown in listing 8.5 is a common mistake. In this approach, `unique`,
    `join`, and `toUpper` all receive `'aabbcc'` as input, which is not what the programmer
    likely intended. What happens is that the `Promise` object is passed three different
    reaction functions and then executes them in order against the same input value.
    Not only are the results incorrect, but one of the promises errors out with a
    `TypeError`. Let’s see what would happen if we were to attach an error handler
    to the failing promise (figure 8.8).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.5中显示的示例是一个常见的错误。在这种情况下，`unique`、`join`和`toUpper`都接收`'aabbcc'`作为输入，这并不是程序员可能想要的结果。发生的情况是，`Promise`对象被传递了三个不同的反应函数，然后按顺序对相同的输入值执行它们。不仅结果不正确，而且其中一个承诺因`TypeError`而出错。让我们看看如果我们将错误处理程序附加到失败的承诺会发生什么（图8.8）。
- en: '![](../Images/8-8.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/8-8.png)'
- en: Figure 8.8 Recovering the failing promise and returning a default, empty value.
    This approach returns another pending promise that fulfills immediately with an
    empty value.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8 恢复失败的承诺并返回一个默认的空值。这种方法返回另一个立即解决的待定承诺，其值为空。
- en: As you’d expect, the `Promise#catch` handler function would apply only to the
    isolated `Promise` object and recover, but another one could easily fail. When
    tasks involve multiple asynchronous actions, it’s common to see nested promises.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所料，`Promise#catch`处理函数只会应用于隔离的`Promise`对象并恢复，但另一个可能会轻易失败。当任务涉及多个异步操作时，通常可以看到嵌套的承诺。
- en: Nested chains
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套链
- en: Suppose that you are working with some remote data store, and you want to pull
    data for a specific user together with their shopping-cart items and return the
    response as a single object. To do so, you’d need to merge data from two endpoints
    and combine both responses. The best option would be to use a promise combinator,
    which we’ll look at in section 5.3\. Another way would be to nest promises.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在处理某个远程数据存储，你想要获取特定用户的购物车项并返回一个单一的对象作为响应。为此，你需要合并两个端点的数据并将两个响应结合起来。最佳选择是使用承诺组合器，我们将在第5.3节中探讨。另一种方法是嵌套承诺。
- en: It’s true that promises were designed to avoid having to write nested callbacks
    in favor of a flat chain. The reason why promises are much better than callbacks,
    though, is that a properly nested promise is still a single chained promise, indentation
    aside. This mental model is much easier to reason about, as the next listing illustrates.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，Promise 是为了避免编写嵌套回调而设计的，而是使用扁平链。然而，Promise 比回调更好的原因是，一个正确嵌套的 Promise 仍然是一个单一的链式
    Promise，尽管有缩进。正如下一个列表所示，这种心理模型更容易推理。
- en: Listing 8.6 Nested promise
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.6 嵌套的 Promise
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Links with a nested chain
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 嵌套链的链接
- en: As you can see, even returning a nested promise joins back to the main chain,
    as shown in figure 8.9.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，甚至返回一个嵌套的 Promise 也会与主链连接，如图 8.9 所示。
- en: '![](../Images/8-9.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/8-9.png)'
- en: Figure 8.9 A flow that includes a nested promise. The returned nested promise
    links itself back with the source `Promise` object, modeling a linear flow.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.9 包含嵌套 Promise 的流程。返回的嵌套 Promise 将其自身与源 `Promise` 对象链接起来，模拟线性流程。
- en: The real challenge in nesting is handling errors. How you decide to structure
    your code depends on how you’re planning your data and/or errors to propagate.
    Data propagates by using `Promise#then`. Errors propagate by using `Promise#then(,`
    `onRejected)` or `Promise#catch`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌套中真正的挑战是处理错误。你如何决定结构化你的代码取决于你如何计划你的数据和/或错误传播。数据通过使用 `Promise#then` 来传播。错误通过使用
    `Promise#then(,` `onRejected)` 或 `Promise#catch` 来传播。
- en: 'Which is better: `catch` or `then`?'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 哪个更好：`catch` 还是 `then`？
- en: Each approach has pros and cons, and both work slightly differently. Generally,
    though, `Promise#catch` seems to be the more popular approach and also more familiar
    to developers from a different background, such as Java. Unless you add `Promise#catch`
    after every `Promise#then`, however, any errors in the chain will be handled by
    a downstream `Promise#catch` block, and you won’t know which handler caused it.
    Using `Promise#then` does give you a bit more control of where the error occurred
    (the preceding one) at the expense of being a little less fluent, syntactically
    speaking. Nevertheless, both approaches follow the same chaining rules, as both
    return new pending promises.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 每种方法都有优点和缺点，并且两者工作方式略有不同。不过，一般来说，`Promise#catch` 似乎更受欢迎，并且也更熟悉来自不同背景的开发者，例如
    Java。然而，除非你在每个 `Promise#then` 后添加 `Promise#catch`，否则链中的任何错误都将由下游的 `Promise#catch`
    块处理，你将不知道哪个处理程序导致了它。使用 `Promise#then` 确实可以让你对错误发生的位置（前一个）有更多的控制，但牺牲了语法上的流畅性。尽管如此，两种方法都遵循相同的链式规则，因为它们都返回新的挂起
    Promise。
- en: JavaScript is the language of choice, after all, so use whichever approach works
    best for you and your coding preference. In this book, however, we’ll be sticking
    with `Promise#catch`, because it’s also in line with the downstream pattern of
    error handling present in observables (chapter 9).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，JavaScript 是首选的语言，所以使用最适合你和你编码偏好的方法。然而，在这本书中，我们将坚持使用 `Promise#catch`，因为它也与观察者中存在的错误处理下游模式相一致（第
    9 章）。
- en: The tricky part is determining the root promise object to which you’re attaching
    your reaction functions. To return to our simple use case, let’s cause some function
    in the chain to fail on purpose in the next listing.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 困难的部分是确定你附加反应函数的根 Promise 对象。为了回到我们的简单用例，让我们在下一个列表中故意让链中的某个函数失败。
- en: Listing 8.7 Fully linked chain with error
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.7 完全链接的链带有错误
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ Skipped
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 跳过的
- en: ❷ Catch handler receives the error object and prints Ooops!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 捕获处理程序接收错误对象并打印 Ooops!
- en: The error in the third line triggers the rejection handlers downstream to the
    `Promise#catch` call, effectively skipping the `join` and `toUpper` steps.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 第三行的错误触发了下游的 `Promise#catch` 调用的拒绝处理程序，有效地跳过了 `join` 和 `toUpper` 步骤。
- en: The next listing shows an example of using nested promises with errors.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表展示了使用嵌套 Promise 和错误的示例。
- en: Listing 8.8 Nested promise chain with error
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.8 带有错误的嵌套 Promise 链
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ Nested promise fails with an error but goes unhandled
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 嵌套的 Promise 因错误而失败但未处理
- en: ❷ Throws property access on undefined error
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在未定义的错误上抛出属性访问
- en: 'In this case, you’d expect the nested chain to join the main chain and print
    “Nested Ooops!” at the end. Can you spot the bug that prevents this from happening?
    That’s right: the developer forgot to return the nested promise to be embedded
    properly in the chain. Now that nested promise is essentially a new rogue pending
    promise (figure 8.10).'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你预计嵌套链将加入主链，并在最后打印“嵌套 Ooops!”。你能找到阻止这种情况发生的错误吗？没错：开发者忘记返回嵌套承诺以正确地嵌入链中。现在这个嵌套承诺本质上是一个新的流氓挂起承诺（图
    8.10）。
- en: '![](../Images/8-10.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/8-10.png)'
- en: Figure 8.10 Because the developer forgot to return the `Promise` object, the
    nested promise went off on its own, and its result or error (as the case may be)
    would never join the main promise chain.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.10 因为开发者忘记返回 `Promise` 对象，嵌套承诺自行运行，其结果或错误（视情况而定）永远不会加入主承诺链。
- en: This result usually happens when the author forgets to return the nested promise
    object or wants to use an arrow function but uses curly braces incorrectly. The
    following listing fixes the problem.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结果通常发生在作者忘记返回嵌套的承诺对象，或者想要使用箭头函数但错误地使用了花括号。下面的列表修复了这个问题。
- en: Listing 8.9 Rejoining the nested chain to handle the error properly
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.9 重新加入嵌套链以正确处理错误
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ Removed parenthesis to make an arrow function
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 移除了括号以创建箭头函数
- en: ❷ Prints “Nested Ooops!” to the console
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 打印“嵌套 Ooops!”到控制台
- en: Now the nested promise is properly embedded in the chain, and the data (or error
    in this case) propagates as intended to print “Nested Ooops!” (figure 8.11).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在嵌套承诺已正确嵌入链中，数据（或错误，在这种情况下）按预期传播，打印出“嵌套 Ooops!”（图 8.11）。
- en: '![](../Images/8-11.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/8-11.png)'
- en: Figure 8.11 Fixing the bug effectively flattens the chain. Now each result/error
    is handled and accounted for.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.11 有效地修复了错误，简化了链。现在每个结果/错误都被处理并计入。
- en: The design of promises is also fluent on the `Promise#catch` call. This technique
    is useful for recovering from errors with default values. Consider the trivial
    fix in the following listing.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺的设计在 `Promise#catch` 调用上也是流畅的。这种技术对于使用默认值恢复错误很有用。考虑以下列表中的简单修复。
- en: Listing 8.10 Recovering from an error with a default value
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.10 使用默认值恢复错误
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ When you use the arrow function, the return statement is implicit.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 当你使用箭头函数时，返回语句是隐式的。
- en: 'It’s important to mention that your promise chains must be able to handle error
    cases. If they fail to do so, JavaScript engines emit a warning (at the time of
    this writing). You may have seen this message in your console:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要提到，你的承诺链必须能够处理错误情况。如果它们无法做到这一点，JavaScript 引擎会发出警告（在撰写本文时）。你可能已经在你的控制台中看到过这条消息：
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: What this message tells you is that, internally, the JavaScript engine is handling
    the error for you and failing gracefully. As you might expect, you wouldn’t want
    this situation to continue forever, so if you are seeing this warning now, you’re
    probably missing some error-handling code, and your best bet is to fix the problem
    right away.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这条消息告诉你的事，在内部，JavaScript 引擎正在为你处理错误，并以优雅的方式失败。正如你所预期的，你不会想让这种情况永远继续下去，所以如果你现在看到这个警告，你可能遗漏了一些错误处理代码，最好的办法是立即修复这个问题。
- en: Finally (no pun intended), you can end promise chains with the `Promise#finally`
    method. As you’d expect, the `this` callback has the same semantic structure as
    the `finally` block after a `try` block. The callback executed after the promises
    settles regardless of whether it fulfilled, as the next listing shows.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最后（没有打趣的意思），你可以使用 `Promise#finally` 方法结束承诺链。正如你所期望的，`this` 回调与 `try` 块之后的 `finally`
    块具有相同的语义结构。无论承诺是成功还是失败，回调都会在承诺解决后执行，如下面的列表所示。
- en: Listing 8.11 Promise chain with `Promise#finally`
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.11 使用 `Promise#finally` 的承诺链
- en: '[PRE25]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ❶ Prints 'ABC'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 打印 'ABC'
- en: ❷ Always prints 'Done' regardless of the state of the promise
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 无论承诺的状态如何，总是打印 'Done'
- en: As you can see, maneuvering a promise chain involves carefully threading through
    and connecting promise objects. If you need to nest a promise to perform additional
    asynchronous logic, remember to connect it back to the main line.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，操纵承诺链需要仔细地穿针引线和连接承诺对象。如果你需要嵌套一个承诺来执行额外的异步逻辑，请记住将其连接回主线路。
- en: 8.2.4 Promises in the wild
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.4 野外的承诺
- en: This section provides a couple of real-world examples. The first example uses
    the promisified filesystem API to count all the blocks saved to a file. For this
    task, we’ll program a function called `countBlocksInFile` in the next listing.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 本节提供了一些现实世界的例子。第一个例子使用承诺化的文件系统 API 来计算保存到文件中的所有块。为此任务，我们将在下一列表中编写一个名为 `countBlocksInFile`
    的函数。
- en: Listing 8.12 Counting all blocks in a file
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.12 在文件中计算所有块的数量
- en: '[PRE26]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ fsp.access does not produce a value. If access is granted, it resolves; otherwise,
    it rejects.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ fsp.access 不产生值。如果访问被允许，它将解析；否则，它将拒绝。
- en: 'Here’s another real-world example that implements the complicated logic of
    mining a new block into the chain. This code is complex because it mixes synchronous
    and asynchronous code that involves a couple of nested asynchronous operations:
    a long-running operation to mine a block and a dynamic `import` to read the mining
    reward setting. This service function is implemented in `BitcoinService`.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个另一个现实世界的例子，它将挖掘新块并加入链的复杂逻辑实现。这段代码很复杂，因为它混合了同步和异步代码，涉及几个嵌套的异步操作：一个长时间运行的挖矿操作和一个动态的
    `import` 来读取挖矿奖励设置。这个服务函数在 `BitcoinService` 中实现。
- en: The code in listing 8.13 shows a crucial part of the blockchain protocol—an
    oversimplification, of course. It highlights the extensive work that miners need
    to do to gain any reward. In essence, a miner mines the new block into the chain.
    This mining process also runs the proof-of-work algorithm. After a successful
    mining, the miner would collect any rewards that were previously stored as pending
    transactions. After the block is inserted, a miner validates the entire blockchain
    structure from beginning to end. All these tasks would have run on a single miner
    node, which has its own copy of the entire blockchain tree. In our example, the
    blockchain service takes care of creating a new reward transaction and puts that
    transaction back into the chain as a pending transaction for the next miner to
    come in. All these operations can take varying amounts of time, so using promises
    to smooth over all of them and keep a flat, simple-to-reason-about structure is
    beneficial.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.13 中的代码显示了区块链协议的一个关键部分——当然是一个简化的版本。它突出了矿工为了获得任何奖励需要做的广泛工作。本质上，矿工将新块挖入链中。这个挖矿过程还运行了工作量证明算法。在成功挖矿后，矿工将收集之前作为挂起交易存储的所有奖励。在块被插入后，矿工从开始到结束验证整个区块链结构。所有这些任务都会在一个单独的矿工节点上运行，该节点有自己的整个区块链树的副本。在我们的例子中，区块链服务负责创建一个新的奖励交易，并将该交易作为挂起交易放回链中，以供下一个矿工加入。所有这些操作可能需要不同长度的时间，因此使用承诺来平滑所有这些操作并保持一个平坦、易于推理的结构是有益的。
- en: Listing 8.13 Mining a block in the chain
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.13 在链中挖矿一个块
- en: '[PRE27]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '❶ Mines a new block into the chain: our first async operation.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将新块挖入链中：我们的第一个异步操作。
- en: ❷ Validates the entire chain. As with fs.access, the promise resolves on a successful
    validation. A failed validation translates into a rejection downstream. The catch
    block receives the error and logs it. For more information on the bind operator,
    see appendix A.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 验证整个链。与 fs.access 类似，成功的验证会导致承诺解析。失败的验证会转化为下流拒绝。捕获块接收错误并记录它。有关绑定操作器的更多信息，请参阅附录
    A。
- en: ❸ Dynamically imports the settings. Dynamic import uses promises. This new nested
    async operation is chained back into the existing bigger chain.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 动态导入设置。动态导入使用承诺。这个新的嵌套异步操作被链回到现有的更大的链中。
- en: ❹ Destructures the MINING_REWARD setting. This value is used by the blockchain
    system to insert a transaction that rewards the miner. This reward becomes effective
    when the next block is added to the chain.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 解构 MINING_REWARD 设置。这个值被区块链系统用来插入一个奖励矿工的交易。这个奖励在下一个块被添加到链中时生效。
- en: ❺ More transactions mean more rewards.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 更多交易意味着更多奖励。
- en: ❻ Service creates a new reward transaction.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 服务创建一个新的奖励交易。
- en: ❼ Clears all pending transactions and places reward in chain to incentivize
    next miners
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 清除所有挂起的交易并将奖励放入链中以激励下一个矿工。
- en: Despite the complexity, at this point the chained approach should look familiar
    to you because we’ve been talking about ADTs since chapter 5 and have been building
    sequences of operations. Everything makes more sense when you can relate `Promise#then`
    as `Functor.map` and `Monad.flatMap`. Applying the right abstractions to the problem
    at hand makes your code leaner and more robust, which is why promises win over
    callbacks.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管复杂，但在这个阶段，链式方法应该对你来说很熟悉，因为我们从第5章开始就一直在讨论ADT，并且一直在构建操作序列。当你能够将`Promise#then`与`Functor.map`和`Monad.flatMap`相关联时，一切都会更有意义。将正确的抽象应用于手头的问题会使你的代码更简洁、更健壮，这也是为什么承诺优于回调的原因。
- en: So far, I’ve covered single-file promise chains. Often, you’ll need to handle
    more than one task at a time. Perhaps you’re mashing up data from multiple HTTP
    calls or reading from multiple files. This situation leads to promise chains that
    introduce forks in the road.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我已经介绍了单文件承诺链。通常，你可能需要同时处理多个任务。也许你正在将多个HTTP调用中的数据混合，或者从多个文件中读取。这种情况会导致承诺链中出现分支。
- en: '8.3 API review: Promise combinators'
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3 API回顾：承诺组合子
- en: 'As function combinators (`compose` and `curry`) accept functions and return
    a function, promise combinators take one or more promises and return a single
    promise. As you know, ECMAScript 2015 shipped with two incredibly useful static
    operations: `Promise.all` and `Promise.race`. In this section, I’ll review those
    two APIs and introduce two new combinators that help fill in additional use cases:
    `Promise.allSettled` and `Promise.any`. These combinators are extremely useful
    for reducing complicated asynchronous flows to simple linear chains, especially
    when the task requires you to combine data from multiple remote sources. To illustrate
    these techniques better, we need to find some long-running operation we can use
    to put these APIs to the test.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 函数组合子（`compose`和`curry`）接受函数并返回一个函数，承诺组合子接受一个或多个承诺并返回一个单一的承诺。正如你所知，ECMAScript
    2015附带两个极其有用的静态操作：`Promise.all`和`Promise.race`。在本节中，我将回顾这两个API，并介绍两个新的组合子，它们有助于解决额外的用例：`Promise.allSettled`和`Promise.any`。这些组合子对于将复杂的异步流程简化为简单的线性链非常有用，尤其是在需要从多个远程源组合数据时。为了更好地说明这些技术，我们需要找到一个可以用来测试这些API的长运行操作。
- en: 'Let me pause here to set up the code sample. In chapter 7 (listing 7.8), I
    showed a simple proof-of-work function. Here it is again:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我暂停一下，设置代码示例。在第7章（列表7.8）中，我展示了一个简单的工作量证明函数。这里再次展示：
- en: '[PRE28]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This function uses brute force to recalculate the given block’s hash until its
    value starts with the provided prefix. At every iteration, the block’s `nonce`
    property is updated and factored into the hashing process. This operation may
    occur immediately or may take a few seconds to complete, depending on how long
    `hashPrefix` is and on the nature of the data being hashed. Again, using promises
    means we don’t have to worry about this operation.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数使用暴力重新计算给定块的哈希值，直到其值以提供的前缀开始。在每次迭代中，块的`nonce`属性都会更新并纳入哈希过程。这个操作可能立即发生，也可能需要几秒钟才能完成，具体取决于`hashPrefix`的长度以及正在哈希的数据的性质。再次强调，使用承诺意味着我们不必担心这个操作。
- en: The examples that we’re about to see call the proof-of-work function asynchronously,
    using a new function called `proofOfWorkAsync`. To simulate true concurrency,
    we can use special Node.js libraries that implement the Worker Threads API ([https://
    nodejs.org/api/worker_threads.html](https://nodejs.org/api/worker_threads.html)).
    These libraries are not part of the JavaScript language, of course. JavaScript’s
    memory model is single-threaded, as discussed at the beginning of this chapter.
    Rather, these libraries use low-level OS threading processes with an abstraction
    called a `Worker` (a thread) to execute JavaScript in parallel.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将看到的示例以异步方式调用工作量证明函数，使用一个名为`proofOfWorkAsync`的新函数。为了模拟真正的并发，我们可以使用实现Worker
    Threads API的特殊Node.js库（[https://nodejs.org/api/worker_threads.html](https://nodejs.org/api/worker_threads.html)）。当然，这些库不是JavaScript语言的一部分。JavaScript的内存模型是单线程的，正如本章开头所讨论的。相反，这些库使用低级OS线程进程，并通过一个称为`Worker`（线程）的抽象来并行执行JavaScript。
- en: The `worker_threads` module can help you get around this situation on the server
    and is similar to the Web Workers API in the browser. This function looks like
    the following listing.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`worker_threads`模块可以帮助你在服务器上解决这个问题，它与浏览器中的Web Workers API类似。这个函数看起来如下所示。'
- en: Listing 8.14 Proof-of-work wrapper using the Worker Threads API
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.14 使用Worker Threads API的工作量证明包装器
- en: '[PRE29]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ❶ Wraps the worker execution with a promise
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用承诺包装工作执行
- en: ❷ Passes serialized JSON block data to the proof-of-work script by using the
    toJson helper function, which hooks into the object’s Symbol.for('toJson') (see
    chapter 7)
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 通过使用 `toJson` 辅助函数将序列化的 JSON 区块数据传递给工作量证明脚本，该函数连接到对象的 `Symbol.for('toJson')`（见第
    7 章）
- en: ❸ Handles message posted back from script as a resolve
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 处理从脚本返回的消息作为解析
- en: ❹ Handles error with reject
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 处理拒绝错误
- en: Now let’s look at the code for the worker script. This script loads, calls the
    proof-of-work function, and posts its result back to the calling script. From
    the caller’s point of view, the time from when the worker begins and the “message”
    or “error/exit” events eventually fire is hidden inside the promise, effectively
    removing the notion of time from the equation.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看工作脚本代码。这个脚本加载、调用工作量证明函数，并将结果发送回调用脚本。从调用者的角度来看，从工作开始到“消息”或“错误/退出”事件最终触发的时间隐藏在承诺中，有效地从等式中消除了时间的概念。
- en: The worker code is simple; it deserializes the JSON block string message passed
    to it and then uses it to create a new `Block` object that `proofOfWork` requires.
    Finally, the result is posted back to the main thread, as shown in the next listing.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 工作脚本很简单；它反序列化传递给它的 JSON 区块字符串消息，然后使用它创建一个 `Block` 对象，这是 `proofOfWork` 所需要的。最后，结果被发送回主线程，如下一个列表所示。
- en: Listing 8.15 Web worker logic
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.15 网页工作线程逻辑
- en: '[PRE30]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ❶ Deserializes the JSON representation
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 反序列化 JSON 表示
- en: ❷ Runs proof-of-work algorithm
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 运行工作量证明算法
- en: ❸ Posts the hashed block data back to the main thread
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将哈希过的区块数据发送回主线程
- en: Parallelism is beyond the scope of this book, but the main idea is that you
    instantiate a `Worker` with a handle to a script that performs some task in parallel.
    Then you use message-passing to post data (in this case, the hashed block object)
    back to the main thread.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 并行处理超出了本书的范围，但主要思想是实例化一个 `Worker`，它有一个指向执行某些并行任务的脚本的句柄。然后你使用消息传递将数据（在这种情况下，是哈希过的区块对象）发送回主线程。
- en: The examples that you’re about to see rely on running `proofOfWokAsync` passing
    blocks with different difficulty settings. Because we’re not interested in forming
    a blockchain to track transactions and all the works, we can use the `Block` API
    directly. Also, we’ll use a couple of more helper functions, one to generate random
    hashes to fill in the `previousHash` constructor argument for new blocks and one
    to simulate a rejection after some scheduled amount of time, as shown in the following
    listing.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你即将看到的示例依赖于运行 `proofOfWokAsync`，传递具有不同难度设置的区块。因为我们不感兴趣于形成一个区块链来跟踪交易和所有工作，我们可以直接使用
    `Block` API。此外，我们还将使用几个辅助函数，一个用于生成随机哈希以填充新区块的 `previousHash` 构造函数参数，另一个用于在预定时间后模拟拒绝，如下面的列表所示。
- en: Listing 8.16 Helper functions used in the next `async` examples
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.16 下一个 `async` 示例中使用的辅助函数
- en: '[PRE31]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ❶ This code uses numeric separators that make long numbers more readable, using
    a visual separation between groups of digits.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 此代码使用数字分隔符，使长数字更易于阅读，使用视觉分隔符在数字组之间进行分隔。
- en: Because we’re using a promise to encapsulate this ordeal, the caller has no
    idea how or where the operation is taking place; it’s location-agnostic.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用承诺来封装这个过程，调用者不知道操作是如何或在哪里进行的；它是位置无关的。
- en: Let’s begin reviewing promise combinators, starting with `Promise.all`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始回顾承诺组合器，从 `Promise.all` 开始。
- en: 8.3.1 Promise.all
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.1 Promise.all
- en: You can use `Promise.all` to schedule multiple independent operations in a concurrent
    manner and then collect a single result when all the operations are complete.
    This technique is useful when you need to mash together data from different APIs
    as a single object, taking advantage of the internal multithreading mechanism
    of Node.js (discussed in section 8.1). The next listing shows an example.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `Promise.all` 以并发方式安排多个独立操作，并在所有操作完成后收集单个结果。当需要将来自不同 API 的数据合并为单个对象时，这种技术非常有用，可以利用
    Node.js 的内部多线程机制（在第 8.1 节中讨论）。下一个列表显示了一个示例。
- en: Listing 8.17 Combining promises with `Promise.all`
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.17 使用 `Promise.all` 组合承诺
- en: '[PRE32]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: ❶ Returns an array of all results in the same order as the input array
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 返回一个数组，其顺序与输入数组相同
- en: 'At a high level, this code looks much like the fork-join model: it starts all
    tasks “simultaneously,” waits for them to fulfill, and then joins them into a
    single aggregated result. In the event of a rejection, it rejects with the first
    promise that rejects.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次来看，这段代码看起来很像分叉-合并模型：它“同时”启动所有任务，等待它们完成，然后将它们合并成一个单一的总结果。在拒绝的情况下，它使用第一个拒绝的承诺进行拒绝。
- en: Instead of waiting for all promises to complete, suppose that you’re only interested
    in the first operation that succeeds. In this case, you can use `Promise.race`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是等待所有承诺都完成，假设你只对第一个成功的操作感兴趣。在这种情况下，你可以使用 `Promise.race`。
- en: 8.3.2 Promise.race
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.2 Promise.race
- en: This method returns a promise with the outcome of the first promise that either
    fulfils or rejects, with the value or reason from said promise. `Promise.race`
    solves interesting problems. Suppose that you’re implementing a web frontend with
    a highly available API backend or distributed caches—a common occurrence in modern
    cloud deployments. You have an API backend in the US East region and one in the
    US West region. You can use `Promise.race` to fetch data from both regions at
    the same time. The region with the lowest latency wins. This situation could guarantee
    consistent performance of your backend as your users roam about the country.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回一个承诺，其中包含第一个承诺的结果，无论是履行还是拒绝，以及该承诺的值或原因。`Promise.race` 解决有趣的问题。假设你正在实现一个具有高度可用
    API 后端或分布式缓存的 Web 前端——这是现代云部署中常见的情况。你有一个位于美国东部地区的 API 后端和一个位于美国西部地区的后端。你可以使用 `Promise.race`
    同时从这两个地区获取数据。延迟最低的地区获胜。这种情况可以保证你的后端在用户在全国漫游时的性能一致性。
- en: Let’s use this API to race the hashing of two blocks in the next listing.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这个 API 在下一个列表中同时比较两个块的哈希。
- en: Listing 8.18 Combining promises with `Promise.race`
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.18 使用 `Promise.race` 组合承诺
- en: '[PRE33]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: ❶ Returns a single result
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 返回单个结果
- en: As you would expect, the block with the smaller difficulty value wins the race.
    `Promise .all` short-circuits when any promise is rejected, and `Promise.race`
    short-circuits when any promise is settled. By contrast, `Promise.allSettled`
    and `Promise.any` are less sensitive to errors, allowing you to provide better
    error handling. You see these combinators in action in section 8.3.3.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所预期，难度值较小的块赢得了比赛。`Promise.all` 在任何承诺被拒绝时短路，而 `Promise.race` 在任何承诺解决时短路。相比之下，`Promise.allSettled`
    和 `Promise.any` 对错误的敏感性较低，允许你提供更好的错误处理。你可以在 8.3.3 节中看到这些组合器的作用。
- en: 8.3.3 Promise.allSettled
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.3 Promise.allSettled
- en: The downside to using `Promise.all` is that the promise will reject if any of
    the provided promises rejects. If you’re trying to load data to render multiple
    sections of an application, one failure means that you’ll have to show error messages
    in all sections. If that’s not what you want, perhaps you want to show an error
    only for the sections in which the data fetch operation failed.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Promise.all` 的缺点是，如果提供的任何承诺被拒绝，则承诺将拒绝。如果你试图加载数据以渲染应用程序的多个部分，一个失败意味着你必须在所有部分中显示错误消息。如果你不希望这样，也许你只想在数据获取操作失败的部分显示错误。
- en: As part of ECMAScript 2020, `Promise.allSettled` returns a `Promise` that resolves
    after all the given promises have fulfilled or rejected (settled). The result
    is an array of special objects that describes the outcome of each promise. Each
    outcome object features a `status` property (fulfilled or rejected) and a `value`
    property with the array of the fulfilled results, if applicable.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 ECMAScript 2020 的一部分，`Promise.allSettled` 返回一个在所有给定的承诺都履行或拒绝（解决）后解决的 `Promise`。结果是描述每个承诺结果的特殊对象数组。每个结果对象都有一个
    `status` 属性（已履行或已拒绝）和一个 `value` 属性，其中包含已履行结果的数组，如果适用的话。
- en: Let’s use this API in the next listing with a promise that fulfils and one that
    rejects to show you how it differs from `Promise.all`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这个 API 在下一个列表中，使用一个履行和一个拒绝的承诺来向你展示它如何与 `Promise.all` 区别。
- en: Listing 8.19 Combining promises with `Promise.allSettled`
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.19 使用 `Promise.allSettled` 组合承诺
- en: '[PRE34]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: ❶ Uses setTimeout to call reject after two seconds
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 setTimeout 在两秒后调用 reject
- en: ❷ First result includes the hashed block.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 第一个结果包含哈希块。
- en: ❸ Second result object includes the rejected outcome.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 第二个结果对象包含拒绝的结果。
- en: Up until now, you’ve probably used `Promise.all` to load multiple pieces of
    data at the same time. `Promise.allSettled` is a much better alternative because
    a failure won’t compromise the entire promise result; it does not short-circuit.
    Finally, there’s `Promise.any`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能已经使用 `Promise.all` 来同时加载多个数据片段。`Promise.allSettled` 是一个更好的替代方案，因为失败不会损害整个承诺结果；它不会短路。最后，还有
    `Promise.any`。
- en: 8.3.4 Promise.any
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.4 Promise.allSettled
- en: This method is the opposite of `Promise.all`. If any promise passed in is fulfilled,
    regardless of any rejections, the resulting promise fulfils with the value of
    said promise. This API is beneficial when you care only whether a promise resolves
    from the collection and want to ignore any failures. `Promise.any` returns a rejected
    promise when all promises reject, as the next listing shows.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法与 `Promise.all` 相反。如果传入的任何承诺被履行，无论是否有拒绝，结果承诺都会以该承诺的值履行。当你只关心承诺是否从集合中解决，而想忽略任何失败时，这个
    API 是有益的。`Promise.any` 在所有承诺都拒绝时返回一个拒绝的承诺，如下一个列表所示。
- en: Listing 8.20 Combining promises with `Promise.any`
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.20 使用 `Promise.any` 组合承诺
- en: '[PRE35]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You may think that this API behaves a lot like `Promise.race`. The small subtlety
    is that it returns the first resolved value (if present), whereas `Promise.race`
    returns the first settled (resolve/rejected) value. The one caveat is the return
    value. If any promise is successful, you should expect `then` to execute with
    the result. If all promises reject, however, `Promise#then` returns a new `Error`
    type called `AggregatedError` on the `Promise#catch` block, which contains an
    array of all failures.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为这个 API 的行为很像 `Promise.race`。小的细微差别在于它返回第一个已解析的值（如果有的话），而 `Promise.race`
    返回第一个已解决的（解析/拒绝）值。一个需要注意的问题是返回值。如果任何承诺成功，你应该期望 `then` 方法执行结果。然而，如果所有承诺都拒绝，`Promise#then`
    在 `Promise#catch` 块上返回一个新的 `Error` 类型，称为 `AggregatedError`，它包含所有失败的数组。
- en: At this point, you’ve learned how to instantiate promises, form chains, and
    combine the results of multiple promises. Mastering these techniques is key to
    designing applications that are performant and, better yet, responsive. But if
    promises make asynchronous programming so much easier, why not elevate them from
    APIs to programming-language syntax?
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经学会了如何实例化承诺，形成链，并组合多个承诺的结果。掌握这些技术对于设计性能良好、更好的响应式应用程序至关重要。但是，如果承诺使异步编程变得如此简单，为什么不将它们从
    API 提升到编程语言语法呢？
- en: Section 8.4 shifts the discussion to the `async`/`await` syntax, which is a
    language feature that allows you to accomplish the same things you’ve learned
    about up to now.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 第 8.4 节将讨论转向 `async`/`await` 语法，这是一种语言特性，允许你完成到目前为止所学到的事情。
- en: 8.4 async made easy
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.4 简化 async
- en: 'The `async`/`await` feature is designed to blur the lines between synchronous
    and asynchronous programming at the language level. This feature appeals to developers
    who prefer the imperative coding style, which uses separate statements to solve
    a problem, instead of one long sequence of `then` expressions. `async`/`await`
    also borrows the mental model of `try`/`catch`/`finally` to smooth over the `then(...).catch(...)
    .finally(...)` logic. Here’s an example:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`async`/`await` 功能旨在在语言级别上模糊同步和异步编程的界限。这一特性吸引了喜欢命令式编程风格的开发者，他们使用单独的语句解决问题，而不是一个长的
    `then` 表达式序列。`async`/`await` 还借鉴了 `try`/`catch`/`finally` 的心理模型，以平滑处理 `then(...).catch(...)
    .finally(...)` 逻辑。以下是一个示例：'
- en: '[PRE36]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Promises are among the building blocks of JavaScript’s `async`/`await` feature.
    From a usability standpoint, you can think of both features as working the same
    way. Like promises, `async` functions operate in a separate order from the rest
    of the code via the event loop, returning an implicit `Promise` as its result,
    which you can `Promise#then` or `await`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺是 JavaScript 的 `async`/`await` 功能的构建块之一。从可用性的角度来看，你可以将这两个功能视为以相同的方式工作。像承诺一样，`async`
    函数通过事件循环以单独的顺序运行，返回一个隐式的 `Promise` 作为其结果，你可以使用 `Promise#then` 或 `await`。
- en: 'To understand this way of coding, refactor `countBlocksInFile`. As it stands
    now, this function returns a `Promise` object, and the caller is expected to process
    the result through the `then` method. Here is that function:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这种编码方式，重构 `countBlocksInFile` 函数。目前，这个函数返回一个 `Promise` 对象，调用者预计将通过 `then`
    方法处理结果。以下是该函数：
- en: '[PRE37]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You can refactor the function to take advantage of `async`/`await` systematically.
    Here are the steps:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以重构函数，以系统地利用 `async`/`await`。以下是步骤：
- en: Add `async` to the function signature. This steps communicates a `Promise` object’s
    return value to the caller and makes the function self-documenting (always a good
    thing).
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `async` 添加到函数签名中。这一步将 `Promise` 对象的返回值传递给调用者，并使函数自我文档化（总是好事）。
- en: Move `Promise#catch` to its own `try`/`catch` block that wraps over the entire
    asynchronous logic.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Promise#catch` 移动到它自己的 `try`/`catch` 块中，该块覆盖整个异步逻辑。
- en: Convert every `Promise#then` step to an `await` statement and make the input
    to the success function an explicit local variable. In essence, you unlink the
    promise chain into separate imperative statements.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个`Promise#then`步骤转换为`await`语句，并将成功函数的输入作为一个显式的局部变量。本质上，你将Promise链解耦成单独的命令式语句。
- en: The next listing shows how this function looks after the transformation.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了转换后的函数看起来如何。
- en: Listing 8.21 Using `async`/`await` to count blocks in blocks.txt
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.21 使用`async`/`await`在blocks.txt中计数块
- en: '[PRE38]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: ❶ Denotes an async function that returns a Promise under the covers (required
    to use await in the function body)
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 表示一个异步函数，该函数在底层返回一个Promise（在函数体中使用await所必需的）。
- en: ❷ Tests user’s permissions for the specified path. Underneath, the promise will
    fail if the user is unable to access the file or the file does not exist.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 测试用户对指定路径的权限。如果用户无法访问文件或文件不存在，则Promise将失败。
- en: ❸ All the await calls use promises behind the scenes, so although the code reads
    as though it’s blocking for I/O, everything is asynchronous under the hood.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 所有await调用在幕后都使用Promise，因此尽管代码看起来像是在I/O上阻塞，但实际上一切都是异步的。
- en: ❹ The rejection of any await call (promise) jumps into the catch block.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 任何await调用（Promise）的拒绝都会跳入catch块。
- en: Figure 8.12 shows that when the output of an awaited expression is connected
    to the next as input, the data flows like a promise chain.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12显示，当await表达式的输出连接到下一个作为输入时，数据流就像Promise链一样。
- en: '![](../Images/8-12.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![图8.12](../Images/8-12.png)'
- en: Figure 8.12 `async/await` follow the same chaining rules as promises.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12 `async/await`遵循与Promise相同的链式规则。
- en: 'Technically speaking, `countBlocksInFile` works the same as before. You can
    even mix the new syntax with the `Promise` API, and everything would work the
    same way:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，`countBlocksInFile`与之前的工作方式相同。你甚至可以将新语法与`Promise` API混合，一切都会以相同的方式工作：
- en: '[PRE39]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: To clarify, the `async` keyword in the function signature is acting as a type
    definition. It’s a cue to the caller and the compiler that this function needs
    special handling and will return a `Promise`. Also, the keyword `await` may be
    deceiving. This keyword has been standardized across many languages and makes
    sense from a semantics point of view. But from a technical standpoint, nothing
    is “waiting” or “blocking.”
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 为了澄清，函数签名中的`async`关键字充当类型定义。它是给调用者和编译器的提示，表明这个函数需要特殊处理，并将返回一个`Promise`。此外，关键字`await`可能具有欺骗性。这个关键字在许多语言中已经标准化，并且从语义角度来看是有意义的。但从技术角度来看，没有任何“等待”或“阻塞”。
- en: As mentioned earlier, `async`/`await` turns asynchronous code synchronous, making
    it more verbose and easier to read for people who prefer the imperative style.
    But this syntax has the same caveats as promises in that after you introduce an
    `async` call, every call site that leads to it needs to be `await`-ed. This drawback
    is easy to miss, because the code looks like a synchronous function. The same
    is true of errors. Rejections are easy to miss if you forget to wrap `await`ed
    calls inside `try`/`catch`. If you forget to write `await`, you’ll see the underlying
    `Promise`-wrapped return value instead of the free value.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`async`/`await`将异步代码转换为同步，这使得它对喜欢命令式风格的读者来说更冗长、更易于阅读。但这个语法与Promise有相同的注意事项，即在你引入`async`调用之后，每个导致它的调用点都需要`await`。这种缺点很容易被忽视，因为代码看起来像是一个同步函数。错误也是如此。如果你忘记在`await`调用中包裹`try`/`catch`，拒绝就很容易被忽视。如果你忘记写`await`，你会看到底层的`Promise`包装的返回值而不是自由值。
- en: 'Although `async`/`await` promotes a more imperative style of coding, JavaScript
    remains flexible enough that you can use it functionally. You can use the pipeline
    operator to compose asynchronous calls like this one, for example:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`async`/`await`促进了更命令式的编程风格，但JavaScript仍然足够灵活，你可以以函数式的方式使用它。例如，你可以使用管道操作符来组合异步调用，如下所示：
- en: '[PRE40]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In this case, the resulting path string is input into `countBlocksInFile` and
    `await`ed. The result, as expected, is an `async` value that we can unwrap with
    another `await` to extract its value:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，结果路径字符串被输入到`countBlocksInFile`并使用`await`。结果，正如预期的那样，是一个`async`值，我们可以使用另一个`await`来展开它以提取其值：
- en: '[PRE41]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In our trivial examples so far, we’ve worked with small files that can be easily
    loaded in memory. If you need to find a particular block object, it’s simple to
    read the file entirely into memory and work with the objects there. In the real
    world, this solution won’t always scale, especially with larger files or in devices
    with much lower available memory. A better method is to stream and iterate over
    the file in small chunks. Section 8.5 shows how `async`/`await` can solve this
    problem.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们迄今为止的简单示例中，我们处理的是可以轻松加载到内存中的小文件。如果你需要找到特定的块对象，简单地将整个文件读入内存并处理那里的对象即可。在现实世界中，这种解决方案并不总是可扩展的，尤其是在处理大文件或在可用内存非常低的设备上。更好的方法是流式传输并以小块的形式迭代文件。第8.5节展示了`async`/`await`如何解决这个问题。
- en: 8.5 async iteration
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.5 异步迭代
- en: 'As simple and convenient as an API such as `fsp.readFile` is, these APIs don’t
    scale to larger files because they attempt to load all the file’s content into
    memory at the same time. You can get away with this situation on a server for
    small files, for the most part. But in browsers, especially on mobile devices
    (with reduced memory capacity), this practice is an antipattern. In these cases,
    you need to traverse or iterate over a file as a moving window so that you load
    only a chunk of the file. You face a dilemma, however: reading a file is asynchronous,
    whereas iteration is synchronous. How can we reconcile these two operations?'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管像`fsp.readFile`这样的API简单方便，但这些API无法扩展到更大的文件，因为它们试图同时将整个文件内容加载到内存中。对于服务器上的小文件，你可以大部分情况下避免这种情况。但在浏览器中，尤其是在内存容量减少的移动设备上，这种做法是一种反模式。在这些情况下，你需要像移动窗口一样遍历或迭代文件，以便只加载文件的一部分。然而，你面临一个困境：读取文件是异步的，而迭代是同步的。我们如何协调这两个操作？
- en: In this section, you’ll learn about async iterators, which provide an elegant
    way to work with large amounts of data, regardless of where that data is located.
    The mental model is as simple as iterating through a local array.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将了解异步迭代器，它们提供了一种优雅的方式来处理大量数据，无论这些数据位于何处。这种心理模型就像迭代一个本地数组一样简单。
- en: 'Chapter 7 left off with simple iterators. Recall that you make any object iterable
    by implementing the well-known `@@iterator` symbol. This method returns an `Iterator`
    object with values that have the following shape:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章以简单的迭代器结束。回想一下，你可以通过实现众所周知的`@@iterator`符号来使任何对象可迭代。此方法返回一个具有以下形状的`Iterator`对象：
- en: '[PRE42]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The JavaScript runtime hooks into this symbol and consumes these objects until
    `done` returns `true`. In the synchronous world, the CPU controls the flow of
    data in an expected, sequential way, so the value of the `{value,` `done}` pair
    is known at the correct times. Unfortunately, iterators and loops were not designed
    to work asynchronously, so we will need a little bit of extra help, as the following
    example shows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript运行时会挂钩到这个符号并消耗这些对象，直到`done`返回`true`。在同步世界中，CPU以预期的顺序控制数据流，因此`{value,
    done}`对的值在正确的时间是已知的。不幸的是，迭代器和循环并不是为异步操作设计的，因此我们需要一点额外的帮助，如下面的示例所示：
- en: '[PRE43]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Following the normal loop protocol, the output should be `'a'`, `'b'`, and then
    `'c'`. Instead, it’s `'b'`, `'c'`, and then `'a'`. We must communicate to the
    JavaScript runtime that it needs to wait to synchronize on the latency of the
    values being iterated over. One way is to treat the sequence of promises as a
    composition. Remember that composing is analogous to reducing. You can reduce
    the array of `Promise` objects into a single promise chain. `reduce` will aggregate
    a collection of elements into a single one, starting from an arbitrary initial
    object. In this case, we can start with an empty, fulfilled `Promise` object and
    use it to attach the reduced set of promises, forming a single chain. This approach
    effectively enforces execution in the expected order.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 按照正常的循环协议，输出应该是`'a'`，`'b'`，然后是`'c'`。相反，它是`'b'`，`'c'`，然后是`'a'`。我们必须通知JavaScript运行时，它需要等待同步于正在迭代的值的延迟。一种方法是将承诺序列视为一个组合。记住，组合类似于减少。你可以将`Promise`对象数组减少为一个单一的承诺链。`reduce`将一组元素聚合为单个元素，从一个任意初始对象开始。在这种情况下，我们可以从一个空的、已解决的`Promise`对象开始，并使用它来附加减少的承诺集，形成一个单一的链。这种方法有效地强制执行预期的顺序。
- en: The next listing shows how to execute this task in a single expression.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表展示了如何用单个表达式执行此任务。
- en: Listing 8.22 Reducing an array of promises
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.22 减少一个承诺数组
- en: '[PRE44]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: ❶ Reducer function concatenates the chained promise object to the next and prints
    the value.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 减法函数将链式承诺对象连接到下一个并打印值。
- en: ❷ Initial object, which becomes the first object in the reducer chain
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 初始对象，它成为 reducer 链中的第一个对象
- en: Now the code prints the expected `'a'`, `'b'`, and then `'c'`, in the correct
    order. The way `reduce` is used here is incredibly elegant and terse, but it can
    look obtuse if you don’t understand promise chaining or how `reduce` works (both
    of which are covered in this book). Let’s sugar-coat this logic with `async` iteration
    as a traditional `for...of` loop in the following listing.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在代码按正确的顺序打印出预期的 `'a'`、`'b'`，然后是 `'c'`。这里使用 `reduce` 的方式非常优雅和简洁，但如果你不理解承诺链或
    `reduce` 的工作原理（这两者都在本书中介绍），它可能会显得晦涩难懂。让我们用 `async` 迭代来糖衣这个逻辑，就像以下列表中的传统 `for...of`
    循环一样。
- en: Listing 8.23 Processing an array of promises with `async` iteration
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.23 使用 `async` 迭代处理承诺数组
- en: '[PRE45]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: ❶ Note the use of await in front of the loop condition.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 注意循环条件前使用了 `await`。
- en: '`reduce` helped us create the mental model for how an asynchronous loop works,
    which is depicted in figure 8.13.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce` 帮助我们建立异步循环的工作模型，如图 8.13 所示。'
- en: '![](../Images/8-13.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/8-13.png)'
- en: Figure 8.13 `for...of` processes the collection of tasks sequentially and preserves
    their order.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.13 `for...of` 顺序处理任务集合并保留它们的顺序。
- en: This figure looks familiar. The `await` keyword in front of the loop resolves
    each promise so that the loop variable points to the value wrapped inside it.
    This syntax computes the same result as the one with `reduce` because it takes
    care of unwrapping and executing the asynchronous operation in order as part of
    the iteration behavior. Async iteration significantly cleans up solving complicated
    problems that involve working with input streams, ordering a sequence of asynchronous
    tasks and others.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图看起来很熟悉。循环前的 `await` 关键字解决每个承诺，使循环变量指向它内部包装的值。这种语法计算的结果与使用 `reduce` 的结果相同，因为它负责在迭代行为中按顺序展开和执行异步操作。异步迭代显著简化了涉及处理输入流、对异步任务进行排序等问题。
- en: As an example, let’s rework our `countBlocksInFile` use case, which reads the
    entire file in memory, to use async iteration so that it scales to files of any
    size. Listing 8.24 is a bit more complex than listing 8.21, but it’s well worth
    examining because this function can handle much larger files. Most of the complexity
    inside the body of the loop stems from having to deal with the integrity of the
    individual block objects read in chunks and figure out where one ends and the
    other begins.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们重新设计我们的 `countBlocksInFile` 用例，该用例将整个文件读入内存，改为使用异步迭代，以便它可以扩展到任何大小的文件。列表
    8.24 比列表 8.21 要复杂一些，但它非常值得研究，因为这个函数可以处理更大的文件。循环体内的大多数复杂性都源于必须处理分块读取的各个块对象的完整性，并确定一个块的结束和另一个块的开始。
- en: Listing 8.24 Counting blocks in files of any size
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.24 在任何大小的文件中计数块
- en: '[PRE46]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: ❶ Instead of reading the entire file, create a stream so that you can read chunks
    of “highWaterMark” size.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 不是读取整个文件，而是创建一个流，这样你就可以按“highWaterMark”大小读取数据块。
- en: ❷ For this example, highWaterMark is set to 64 bytes so that data is delivered
    in small chunks.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在这个例子中，highWaterMark 设置为 64 字节，以便数据以小块的形式交付。
- en: ❸ Iterates over the stream, reading the next block of raw text
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 遍历流，读取下一个原始文本块
- en: ❹ Handles the block delimiter (if present) to obtain a clean row of blocks
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 处理块分隔符（如果存在），以获得干净的块行
- en: ❺ Starts the next row after the last delimiter is read to avoid reading incomplete
    block data
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 在读取到最后一个分隔符后开始下一行，以避免读取不完整的块数据
- en: '`async`/`await` gives you the freedom to double down on the logic of the problem
    at hand and forget about the intricacies of asynchronous programming.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`async`/`await` 给你自由，可以专注于手头问题的逻辑，而无需担心异步编程的复杂性。'
- en: Although promises certainly are the more functional, fluent approach, `async`/
    `await` returns us to an imperative paradigm through the automatic wrapping and
    unwrapping of data. Compared with an ADT such as `Validation`, `async` is equivalent
    to a `Success.of`, `await` is analogous to a `Validation.map` (or `Promise#then`),
    and `Promise#catch` models the `Failure` state.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然承诺确实是一种更功能化、流畅的方法，但 `async`/ `await` 通过数据的自动包装和展开，使我们回到了命令式范式。与 `Validation`
    这样的 ADT 相比，`async` 等同于 `Success.of`，`await` 类似于 `Validation.map`（或 `Promise#then`），而
    `Promise#catch` 模拟了 `Failure` 状态。
- en: In listing 8.24, you saw that the object `dataStream` was asynchronously iterated
    over. You may wonder how to make your own objects async-iterable. In chapter 7,
    we discussed how the `@@iterator` symbol allows you to spread and enumerate elements
    of a custom object. Likewise, the `@@asyncIterator` symbol is executed when you
    use `for...of` with `await`, as before, as shown in the next listing.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 8.24 中，你看到了对象 `dataStream` 是如何异步迭代的。你可能想知道如何使你自己的对象异步可迭代。在第 7 章中，我们讨论了 `@@iterator`
    符号如何允许你展开和枚举自定义对象中的元素。同样，当使用 `for...of` 并带有 `await` 时，会执行 `@@asyncIterator` 符号，就像之前一样，如下面的列表所示。
- en: Listing 8.25 Using `async` iteration with a Node.js stream object
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.25 使用 Node.js 流对象进行 `async` 迭代
- en: '[PRE47]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: ❶ Invokes the asyncIterator function-valued property of dataStream
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 调用 `dataStream` 的函数值属性 `asyncIterator`
- en: '`dataStream` has a function-valued symbol property called `Symbol.asyncIterator`.
    As of this writing, no native JavaScript APIs use this symbol, but Node.js ships
    with a few libraries of its own for filesystem streams and HTTP handling. As you
    might expect, the `await` on the loop call site must be matched with an `async`
    value (a promise) returned by the iterator itself. Everything you learned about
    the `Iterator` applies, with the small caveat that calls to `next` must return
    objects of `{value,` `done}` wrapped in a `Promise`. The next listing shows a
    trivial example.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`dataStream` 拥有一个名为 `Symbol.asyncIterator` 的函数值符号属性。截至本文撰写时，没有原生的 JavaScript
    API 使用此符号，但 Node.js 自带了一些用于文件系统流和 HTTP 处理的库。正如你所预期的那样，循环调用点的 `await` 必须与迭代器本身返回的
    `async` 值（一个承诺）相匹配。你所学到的关于 `Iterator` 的所有内容都适用，只是有一点小的例外，即对 `next` 的调用必须返回一个 `{value,
    done}` 对象，该对象被一个 `Promise` 包裹。下面的列表展示了这样一个简单的例子。'
- en: Listing 8.26 `Iterator` object that emits values with a provided delay
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.26 使用延迟发出值的 `Iterator` 对象
- en: '[PRE48]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: ❶ Removes the first task from the list. A task is nothing more than a value
    with a timeout value in the future.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从列表中移除第一个任务。一个任务不过是一个在未来有超时值的值。
- en: ❷ Returns a promise that wraps an Iterator tuple of {value, done}
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 返回一个承诺，该承诺封装了一个 `{value, done}` 迭代器元组
- en: ❸ Signals that the iterator should stop, as there are no more tasks to perform
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 表示迭代器应该停止，因为没有更多的任务要执行
- en: 'It helps to see this iterator used directly first:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 首先直接看到这个迭代器的使用是有帮助的：
- en: '[PRE49]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Run `it.next()` two more times for tasks `''b''`, and `''c''` to print, in
    that order. Finally, the last call emits the `done` value:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `it.next()` 两次以打印任务 `'b'` 和 `'c'`，顺序如下。最后，最后一次调用发出 `done` 值：
- en: '[PRE50]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: With `Symbol.asyncIterator`, we obtain the same result, shown in the following
    code.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Symbol.asyncIterator`，我们得到相同的结果，如下面的代码所示。
- en: Listing 8.27 Hooking into `async` iteration using `@@asyncIterator`
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.27 使用 `@@asyncIterator` 钩入 `async` 迭代
- en: '[PRE51]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: ❶ Internally invokes @@asyncIterator
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 内部调用 `@@asyncIterator`
- en: 'You can also take things up a notch by making `next` an `async` function:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过将 `next` 设为一个 `async` 函数来进一步提高事物的层次：
- en: '[PRE52]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The sky’s the limit in terms of what you can do when you have full control (and
    understanding) of the iteration behavior of your objects, especially when you
    have physical limitations such as bandwidth and amount of memory, which occur
    on slow networks and mobile devices, respectively. Chapter 9 goes one step further
    so that you can see how generators (and their `async` counterpart) blend with
    the iterator protocol. You can not only model a finite amount of data, but also
    model potentially infinite streams of data.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完全控制（并理解）你对象的迭代行为时，你可以做到的事情没有极限，尤其是在你有物理限制，如带宽和内存量时，这些限制分别在慢速网络和移动设备上出现。第
    9 章进一步探讨了如何将生成器（及其 `async` 对应物）与迭代器协议相结合。你不仅可以模拟有限的数据量，还可以模拟可能无限的数据流。
- en: So far, we’ve discussed how to handle asynchronous tasks directly through the
    `Promise` APIs and through `async`/`await`. Most of the discussion centered on
    how data propagates forward through a promise chain. In this chapter, I didn’t
    talk much about error handling, mainly because the rules are nearly the same as
    those for typical imperative code, and a lot of what we discussed about `Promise#then`
    applies uniformly to `Promise#catch`, which is a nice design trait of promises.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了如何通过 `Promise` API 和 `async`/`await` 直接处理异步任务。大部分讨论集中在数据如何通过承诺链向前传播。在本章中，我没有过多地谈论错误处理，主要是因为规则几乎与典型命令式代码的规则相同，我们讨论的许多关于
    `Promise#then` 的内容也适用于 `Promise#catch`，这是承诺的一个很好的设计特性。
- en: 8.6 Top-level await
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.6 顶层 await
- en: Generally, every `await` must be matched with `async`, but there’s an exception.
    Some scenarios require you to initiate a call to load (`await`) something asynchronous
    as the first thing you do. Examples are dynamically loading modules and dependencies
    up front, such as internationalization/language bundles or a database connection
    handle.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，每个 `await` 都必须与 `async` 匹配，但有一个例外。某些场景要求您首先发起一个调用来加载（`await`）某些异步内容。例如，动态加载模块和依赖项，如国际化/语言包或数据库连接句柄。
- en: 'Through regular `async`/`await` syntax, if you wanted to begin asynchronous
    tasks on script launch, you’d have to create an `async` context with a function
    and then immediately invoke it. Here’s an example:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 通过常规 `async`/`await` 语法，如果您想在脚本启动时开始异步任务，您必须使用一个函数创建 `async` 上下文，然后立即调用它。以下是一个示例：
- en: '[PRE53]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In chapter 6, we discussed Immediately Invoked Function Expressions (IIFEs),
    a pattern that performs function declaration and execution directly at the same
    time. In the same vein, we can shorten the preceding code by using an Immediately
    Invoked Async Function Expression (IIAFE):'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 6 章中，我们讨论了立即调用的函数表达式（IIFEs），这是一种直接同时执行函数声明和执行的模式。同样地，我们可以通过使用立即调用的异步函数表达式（IIAFE）来缩短前面的代码：
- en: '[PRE54]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Top-level `await` cleans up this code so that you can use `await` on a task
    without having to create an `async` function explicitly. Behind the scenes, you
    have one big `async` function for the entire module:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 顶级 `await` 清理了这段代码，这样您就可以在不需要显式创建 `async` 函数的情况下使用 `await` 在任务上。幕后，您有一个大的 `async`
    函数用于整个模块：
- en: '[PRE55]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In chapter 6, you saw an example of a dependency fallback from a module that
    loads code dynamically:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 6 章中，您看到了一个从动态加载代码的模块中进行的依赖项回退示例：
- en: '[PRE56]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Top-level `await` is meant to work with ECMAScript Modules out of the box, so
    here’s another good reason to start adopting that module format. This is understandable,
    because top-level `await` would require special support to create an asynchronous
    context for you automatically. (It helps to think of one big `async` function
    surrounding the entire module.) If module A imports module B, and B contains one
    or multiple `await` calls, A needs to wait until B finishes executing before executing
    its own code. Naturally, there are concerns about blocking and waiting at a critical
    stage of the evaluation process. (If you want to know the intricate details of
    this process you can read more about them at [http://mng.bz/9Mwo](http://mng.bz/9Mwo).)
    As you’d expect, however, there are optimizations, so the blocking that occurs
    only with a dependent module does not affect loading other sibling dependencies.
    The event loop architecture schedules these tasks properly and yields control
    to the main thread to continue loading other code, as it would do with any asynchronous
    task. Nevertheless, developer education is key. As with dynamic `import`, use
    these features only when absolutely necessary.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 顶级 `await` 是为了与 ECMAScript 模块无缝配合，因此这是一个开始采用该模块格式的另一个好理由。这是可以理解的，因为顶级 `await`
    需要特殊支持来为您自动创建异步上下文。（有助于将整个模块视为一个大的 `async` 函数。）如果模块 A 导入模块 B，并且 B 包含一个或多个 `await`
    调用，A 需要等待 B 完成执行后才能执行自己的代码。自然地，在评估过程的临界阶段存在阻塞和等待的担忧。（如果您想了解此过程的详细细节，可以阅读更多关于它们的信息，请参阅[http://mng.bz/9Mwo](http://mng.bz/9Mwo)。）然而，正如您所期望的，这里有一些优化，因此仅与依赖模块发生的阻塞不会影响加载其他同级依赖项。事件循环架构适当地安排这些任务，并将控制权交回主线程以继续加载其他代码，就像处理任何异步任务一样。尽管如此，开发者教育是关键。与动态
    `import` 一样，仅在绝对必要时才使用这些功能。
- en: 'As you can see, we’ve come a long way toward removing the issue of latency
    or time from our code. We started with the incumbent callbacks, moved on to an
    API-driven solution (promises), and finally saw an improvement of the language-level
    model via `async`/`await`. Overall, these techniques are behaviorally equivalent,
    and are all in line with JavaScript’s nonblocking, event-driven philosophy. Remember
    that programming is three-dimensional: data, behavior, and time. Applications
    excel when data is local to the behavior or the logic that we write. But in this
    modern, distributed world, this problem is hardly the one you need to solve. Without
    the proper support of the host language, programming can quickly become unwieldy.
    Promises (or `async`/`await`) collapse these dimensions (data, behavior, and time)
    so that we can reason about our code as being two-dimensional, removing time from
    the equation.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们已经朝着从代码中移除延迟或时间问题迈出了很长的路。我们开始于现有的回调，然后过渡到API驱动的解决方案（承诺），最后通过`async`/`await`看到了语言级模型的改进。总的来说，这些技术行为上是等效的，并且都与JavaScript的非阻塞、事件驱动哲学保持一致。记住，编程是三维的：数据、行为和时间。当数据位于我们编写的行为或逻辑附近时，应用程序表现得最好。但在这个现代、分布式的世界中，这个问题几乎不是你需要解决的问题。没有宿主语言的适当支持，编程可以迅速变得难以控制。承诺（或`async`/`await`）将这些维度（数据、行为和时间）合并，这样我们就可以将代码视为二维的，从方程中去除时间。
- en: Promises have some downsides, however. For starters, you can’t cancel the execution
    of a promise in a standard way. Or should you? After all, a promise is meant to
    be kept. Perhaps `Future` or `Task` would have been a better name. Nevertheless,
    third-party libraries employ some form of internal cancellation token, but nothing
    has been made standard. The TC39 committee seeks a general cancellation mechanism
    that could apply to more than promises. You can find more information at [https://github
    .com/tc39/proposal-cancellation](https://github.com/tc39/proposal-cancellation).
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，承诺有一些缺点。首先，你不能以标准方式取消承诺的执行。或者你应该这样做吗？毕竟，承诺的意图是保持不变。也许`Future`或`Task`会是更好的名字。尽管如此，第三方库使用某种形式的内部取消令牌，但还没有成为标准。TC39委员会寻求一种通用的取消机制，该机制可以应用于承诺之外的更多场景。你可以在[https://github.com/tc39/proposal-cancellation](https://github.com/tc39/proposal-cancellation)找到更多信息。
- en: To me, the biggest issue is that promises (`async`/`await)` are not lazy. In
    other words, a promise executor will run regardless of whether there’s a handler
    function down the chain. The other issue is that promises were designed to provide
    single results; they can succeed or fail only once. After a promise settles, you’d
    need to create a new one to request or poll for more data. There are many use
    cases for an API that can deliver or push values to your handling code without
    you having to request more explicitly. This pattern is called a stream, which
    is a convenient and elegant paradigm for working with things like WebSockets,
    file I/O, HTTP, and user-interface events (clicks, mouse moves, and so on). Chapter
    9 takes asynchronous state management to the next level.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我来说，最大的问题是承诺（`async`/`await`）不是懒加载的。换句话说，无论链中是否有处理函数，承诺执行器都会运行。另一个问题是承诺被设计为提供单一结果；它们只能成功或失败一次。承诺确定后，你需要创建一个新的承诺来请求或轮询更多数据。有许多API用例可以在不要求你明确请求更多数据的情况下向你的处理代码提供或推送值。这种模式被称为流，这是一种方便且优雅的范式，用于处理像WebSockets、文件I/O、HTTP和用户界面事件（点击、鼠标移动等）这样的东西。第9章将异步状态管理提升到了新的水平。
- en: Summary
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: JavaScript is based on a single-threaded, event-driven architecture designed
    for scale.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript基于单线程、事件驱动的架构，旨在扩展规模。
- en: A `Promise` is a standard, nearly algebraic data type used as an abstraction
    or wrapper over some asynchronous task to provide a consistent programming model
    that is location-agnostic. Promises free you from worrying about latency and data-locality
    so that you can focus on the task at hand.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Promise`是一种标准、几乎代数的数据类型，用作异步任务的一种抽象或包装，以提供一种一致且位置无关的编程模型。承诺让你摆脱了对延迟和数据本地性的担忧，这样你就可以专注于手头的任务。'
- en: Promises reuse the mechanics of callbacks and the event loop, but with much
    better readability.
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 承诺重用了回调和事件循环的机制，但具有更好的可读性。
- en: ECMAScript 2020 proposes enhancements to the `Promise` API’s surface with the
    addition of `Promise.allSettled` and `Promise.any`. Both composable operators
    allow you to handle multiple tasks at the same time.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECMAScript 2020通过添加`Promise.allSettled`和`Promise.any`对`Promise` API的表面进行了增强。这两个可组合的操作符允许你同时处理多个任务。
- en: '`async`/`await` offers a more familiar, imperative approach to promises that
    convert promise chains to a sequence of statements.'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`async`/`await` 提供了一种更熟悉、命令式的方法来处理承诺，将承诺链转换为一系列语句。'
- en: Async iterator introduces a new symbol called `@@asyncIterator`. You can use
    this symbol to endow any object with the capability of looping, emitting its data
    asynchronously. Node.js uses this symbol in its HTTP and filesystem modules, among
    others.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步迭代器引入了一个名为 `@@asyncIterator` 的新符号。您可以使用此符号赋予任何对象循环和异步发出其数据的特性。Node.js 在其 HTTP
    和文件系统模块等中使用此符号。
- en: Top-level `await` takes advantage of the ESM system to automatically create
    an encompassing `async` context over a module script, under which you can spawn
    any number of `await` calls without having to create `async` functions explicitly.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶层 `await` 利用 ESM 系统自动在模块脚本上创建一个包含的 `async` 上下文，在此上下文中，您可以无需显式创建 `async` 函数即可发出任意数量的
    `await` 调用。
