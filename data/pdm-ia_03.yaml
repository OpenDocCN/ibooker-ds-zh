- en: 2 Command line
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 命令行
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: The Podman command line
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Podman 命令行
- en: Running an OCI application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行 OCI 应用程序
- en: Comparing containers and images
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较容器和镜像
- en: Building an OCI-based image
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建 OCI 基础镜像
- en: Podman is an excellent tool for running and building containerized applications.
    In this chapter, you’ll get started by building a simple web application to demonstrate
    commonly used features of the Podman command line.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 是运行和构建容器化应用程序的优秀工具。在本章中，你将通过构建一个简单的 Web 应用程序来开始，以展示 Podman 命令行中常用的功能。
- en: If you don’t have Podman installed on your machine, you can jump to appendix
    C, and then return here. This chapter assumes that Podman 4.1 or later is already
    installed. Older versions of Podman probably work fine, but all examples were
    tested with Podman 4.1\. The example base image I use is the registry.access.redhat.com/ubi8/httpd-24
    image.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的机器上没有安装 Podman，你可以跳转到附录 C，然后再返回这里。本章假设 Podman 4.1 或更高版本已经安装。Podman 的旧版本可能运行良好，但所有示例都是使用
    Podman 4.1 进行测试的。我使用的示例基础镜像来自 registry.access.redhat.com/ubi8/httpd-24。
- en: Note Universal Base Images (UBI) can be used anywhere, but container software
    maintained and vetted by Red Hat as well as run on a Red Hat operating system
    is fully supported. There are hundreds of Apache images that work similarly to
    this image that you can also try out.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：通用基础镜像（UBI）可以在任何地方使用，但由 Red Hat 维护和审核的容器软件以及运行在 Red Hat 操作系统上的软件完全受支持。有数百个
    Apache 镜像与此镜像类似，你也可以尝试使用。
- en: Chapter 2 shows how Podman is a great tool for working with containers. In this
    chapter, I walk you through running the scenario you might use to build a containerized
    application. You launch a container, modify its contents, create an image, and
    ship it to a registry. Then I explain how you can do this in an automated way
    to maintain the security of your container image. Through it all, you will be
    exposed to many of the Podman command-line interfaces and get a good understanding
    of how to work with Podman.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 第二章展示了 Podman 是一个处理容器的优秀工具。在本章中，我将带你通过运行可能用于构建容器化应用程序的场景。你启动一个容器，修改其内容，创建一个镜像，并将其发送到注册库。然后我解释了如何以自动化的方式执行这些操作以维护容器镜像的安全性。在这个过程中，你将接触到许多
    Podman 命令行界面，并深入了解如何使用 Podman。
- en: If you are an experienced Docker user, you probably just want to skim through
    this chapter. You will know a lot of it, but there are many features unique to
    Podman, such as the ability to mount container images (section 2.2.10) and different
    transports (section 2.2.4). Let’s start by running our first container.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个经验丰富的 Docker 用户，你可能只想快速浏览本章。你会知道很多内容，但 Podman 有许多独特的功能，例如挂载容器镜像（第 2.2.10
    节）和不同的传输方式（第 2.2.4 节）。让我们先运行我们的第一个容器。
- en: Note Podman is an open source project under heavy development. Podman is packaged
    and provided on many different Linux distributions as well as Mac and Windows.
    These distributions might be shipping older versions of Podman without some of
    the current features covered in this book. Some examples in this book assume you
    are using Podman 4.1 or later. If an example does not work, please update your
    version of Podman to the latest version. Refer to appendix C for further information
    on installing Podman.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Podman 是一个处于高度开发中的开源项目。Podman 被打包并提供在许多不同的 Linux 发行版上，以及 Mac 和 Windows 上。这些发行版可能正在运输
    Podman 的旧版本，其中一些当前书籍中涵盖的功能可能不存在。本书中的一些示例假设你正在使用 Podman 4.1 或更高版本。如果示例无法正常工作，请更新你的
    Podman 版本到最新版本。有关安装 Podman 的更多信息，请参阅附录 C。
- en: 2.1 Working with containers
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 与容器一起工作
- en: There are thousands of different container images sitting at container registries.
    Developers, administrators, quality engineers, and general users primarily use
    the `podman` `run` command to pull down and run, test, or explore these container
    images. To start building out containerized applications, the first thing you
    need to do is start working with a base image. In our examples, you pull and run
    the registry.access.redhat.com/ubi8/httpd-24 image to container storage in your
    home directory and start exploring inside the container.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器注册库中坐落着成千上万的不同的容器镜像。开发者、管理员、质量工程师和普通用户主要使用 `podman` `run` 命令来拉取和运行、测试或探索这些容器镜像。要开始构建容器化应用程序，你需要做的第一件事是与基础镜像开始工作。在我们的示例中，你将
    registry.access.redhat.com/ubi8/httpd-24 镜像拉取并运行到你的家目录中的容器存储，并开始探索容器内部。
- en: 2.1.1 Exploring containers
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.1 探索容器
- en: 'In this section, you will examine a typical Podman command, step by step. You
    will execute the `podman` `run` command, which reaches out to the registry.access.redhat.com
    container registry and begins pulling down the image and storing it locally in
    your home directory:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将逐步检查一个典型的 Podman 命令。你将执行 `podman` 的 `run` 命令，该命令连接到 registry.access.redhat.com
    容器注册库，并开始拉取镜像并将其存储在本地主目录中：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now I will break down the command you just executed. By default the `podman`
    `run` command executes the containerized command in the foreground until the container
    exits. In this case, you end up at a Bash prompt running within the container
    and showing the `bash-4.4$` prompt. When you exit this Bash prompt, Podman stops
    the container.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我将分解你刚才执行的命令。默认情况下，`podman` 的 `run` 命令在容器退出前在前台执行容器化的命令。在这种情况下，你最终会在容器内看到一个
    Bash 提示符，显示 `bash-4.4$` 提示符。当你退出这个 Bash 提示符时，Podman 会停止容器。
- en: 'In this example, you used two options: `-t` and `-i`, as `-ti`, which tells
    Podman to hook up to the terminal. This connects to the input, output, and error
    stream of the `bash` process within the container to your screen, which allows
    you to interact within the container:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你使用了两个选项：`-t` 和 `-i`，作为 `-ti`，这告诉 Podman 连接到终端。这会将容器的 `bash` 进程的输入、输出和错误流连接到你的屏幕，允许你在容器内进行交互：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `--rm` option tells Podman to delete the container as soon as the container
    exits, freeing up all of the container’s storage:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`--rm` 选项告诉 Podman 在容器退出时立即删除容器，从而释放容器占用的所有存储空间：'
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Next, specify the container image, registry.access.redhat.com/ubi8/httpd-24,
    you are working with. The `podman` command reaches out to the container registry
    at registry.access.redhat.com and begins copying down the ubi8/httpd-24:latest
    image. Podman copies multiple layers (aka blobs), as shown in the following listing,
    and stores them in the local container storage. You see the progress as the image
    layers are pulled down. Some images are rather large and can take a long time
    while being pulled down. If you later run a different container on the same image,
    Podman skips the image-pulling step, since you already have the correct image
    in local container storage.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，指定你正在使用的容器镜像，即 registry.access.redhat.com/ubi8/httpd-24。`podman` 命令连接到 registry.access.redhat.com
    容器注册库，并开始下载 ubi8/httpd-24:latest 镜像。Podman 会复制多个层（也称为 blob），如下所示，并将它们存储在本地容器存储中。你可以看到随着镜像层的拉取，进度条的变化。一些镜像相当大，拉取时可能需要很长时间。如果你稍后要在同一镜像上运行不同的容器，Podman
    会跳过镜像拉取步骤，因为你已经拥有正确的镜像在本地容器存储中。
- en: Listing 2.1 Pulling and running a container image from a registry
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.1 从注册库拉取并运行容器镜像
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Contact with the registry
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 与注册库建立联系
- en: ❷ Layer pulling is skipped.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 跳过层拉取。
- en: 'Finally, specify the executable to be run within the container, in this case,
    `bash`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，指定容器内要运行的可执行文件，在本例中是 `bash`：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note Images almost always have default commands they execute. You only have
    to specify a command if you want to override the default application the image
    runs with. In the case of the registry.access.redhat.com/ubi8/httpd-24 image,
    it runs the Apache web server.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：镜像几乎总是有默认要执行的命令。只有当你想要覆盖镜像运行的默认应用程序时，才需要指定命令。在 registry.access.redhat.com/ubi8/httpd-24
    镜像的情况下，它运行 Apache 网络服务器。
- en: 'While inside the bash shell container, cat /etc/os-release, and notice it is
    likely a different OS or a different version than the /etc/os-release outside
    the container. Explore around in the container, and notice how different it is
    from your host environment:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 bash shell 容器内部时，运行 `cat /etc/os-release`，并注意它可能是一个不同的操作系统或版本，与容器外部的 `/etc/os-release`
    不同。在容器内四处探索，并注意它与主机环境的不同之处：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: On my host on a different terminal, the same command outputs
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的主机上的另一个终端中，相同的命令输出
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Back inside the container, you will notice there are a lot fewer commands available:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 回到容器内部，你会注意到可用的命令要少得多：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: However, on the host you see
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在主机上你看到
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Execute the `ps` command to see what processes are running inside of the container:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `ps` 命令以查看容器内正在运行哪些进程：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You only see two processes: the `bash` script and the `ps` command. Needless
    to say, on my host machine, there are hundreds of processes running (including
    these two processes). You can further explore the inside of the container to gain
    an understanding of what is going on within a container.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你只能看到两个进程：`bash` 脚本和 `ps` 命令。不用说，在我的主机机器上，有成百上千个进程正在运行（包括这两个进程）。你可以进一步探索容器内部，以了解容器内正在发生的事情。
- en: When you are done, you exit the `bash` script, and the container shuts down.
    Since you ran with the `--rm` option, Podman removes all the container storage
    and deletes the container. The container image remains in container/storage. Now
    that you have explored the inner workings of a container, it is time to start
    working with the default application within the container.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，你退出`bash`脚本，容器将关闭。由于你使用了`--rm`选项，Podman将删除所有容器存储并删除容器。容器镜像仍然保留在`container/storage`中。现在你已经探索了容器的内部工作原理，是时候开始使用容器中的默认应用程序了。
- en: 2.1.2 Running the containerized application
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.2 运行容器化应用程序
- en: In the previous example, you pulled and ran `bash` within a containerized application,
    but you did not run the application the developer intended you to run. In this
    next example, you will run the actual application by removing the command and
    running with a couple of new options.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，你在一个容器化的应用程序中拉取并运行了`bash`，但你没有运行开发者希望你运行的应用程序。在这个下一个示例中，你将通过移除命令并使用几个新选项来运行实际的应用程序。
- en: 'First, remove the `-ti` and the `--rm` options, since you want the container
    to remain running when the `podman` command exits. You are not a shell running
    within the container interactively, since it is just running the containerized
    web service:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，移除`-ti`和`--rm`选项，因为你希望在`podman`命令退出时容器保持运行。你不是一个在容器内交互式运行的shell，因为它只是运行容器化的网络服务：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The first option to notice is the `-d` `(--detach)` option, which tells Podman
    to launch the container and then detach from it. Basically, run the container
    in the background. The Podman command actually exits and leaves the container
    running. Chapter 6 goes much deeper into what is going on behind the scenes:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的选项是`-d`（`--detach`）选项，它告诉Podman启动容器然后从它断开连接。基本上，在后台运行容器。Podman命令实际上会退出并留下容器运行。第6章将更深入地探讨幕后发生的事情：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `-p` `(--publish)` option tells Podman to publish or bind the container
    port `8080` to the host port `8080` when the container is running. With the `-p`
    option, the field before the colon refers to the host port, while the field after
    the colon refers to the container port. In this case, you see that the ports are
    the same. If you specify only one port, Podman considers this port a container
    port and randomly picks a host port on which the container port is bound. You
    can use the `podman` `port` command to discover which ports are bound to a container.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`-p`（`--publish`）选项告诉Podman在容器运行时将容器端口`8080`发布或绑定到主机端口`8080`。使用`-p`选项时，冒号之前的部分指的是主机端口，而冒号之后的部分指的是容器端口。在这种情况下，你可以看到端口是相同的。如果你只指定一个端口，Podman认为这个端口是容器端口，并随机选择一个主机端口来绑定容器端口。你可以使用`podman`
    `port`命令来发现哪些端口绑定到了容器。'
- en: Listing 2.2 Example of the `podman` `port` command
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.2 `podman` `port`命令的示例
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Shows that port 8080/tcp inside the container is bound to all of the host
    networks (0.0.0.0) at port 8080
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 显示容器内部的8080/tcp端口绑定到主机网络的所有网络（0.0.0.0）的8080端口
- en: By default, containers are created within their own network namespace, meaning
    they are not bound to the host network but to their virtualized network. Suppose
    I execute the container without the `-p` option. In that case, the Apache server
    within the container binds to the network interface within the container’s network
    namespace, but Apache is not bound to the host network.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，容器在其自己的网络命名空间内创建，这意味着它们绑定到虚拟化网络而不是主机网络。假设我没有使用`-p`选项来执行容器。在这种情况下，容器内的Apache服务器绑定到容器网络命名空间内的网络接口，但Apache没有绑定到主机网络。
- en: Only processes within the container are able to connect to port `8080` to communicate
    with the web server. By executing the command with the `-p` option, Podman connects
    the port from inside the container to the host network at the specified port.
    The connection allows external processes like a web browser to read from the web
    service.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 只有容器内的进程能够连接到端口`8080`以与网络服务器通信。通过带有`-p`选项的命令执行，Podman将容器内的端口连接到指定端口的主机网络。这个连接允许外部进程，如网络浏览器，从网络服务中读取。
- en: Note If you are running containers in rootless mode, covered in chapter 3, Podman
    users are by default not permitted to bind to ports < 1024 by the kernel. Some
    containers want to bind to lower ports like port 80, which is allowed inside the
    container, but `-p` `80:80` fails, since 80 is less than 1024\. Using `-p` `8080:80`
    causes Podman to bind the host’s port `8080` to port `80` within the container.
    The upstream Podman repo contains troubleshooting information on problems like
    binding to ports less than 1024 and many others (see [http://mng.bz/69ry](http://mng.bz/69ry)).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果您以无根模式运行容器，如第 3 章所述，Podman 用户默认不允许内核绑定端口 < 1024。一些容器想要绑定到较低的端口，如端口 80，这在容器内部是允许的，但
    `-p` `80:80` 会失败，因为 80 小于 1024。使用 `-p` `8080:80` 会导致 Podman 将主机的端口 `8080` 绑定到容器内的端口
    `80`。上游 Podman 仓库包含有关绑定端口小于 1024 以及许多其他问题的故障排除信息（见 [http://mng.bz/69ry](http://mng.bz/69ry)）。
- en: 'The `-p` option can map port numbers inside the container to different port
    numbers outside the container:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`-p` 选项可以将容器内的端口号映射到容器外的不同端口号：'
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the example name, the container `myapp` is using the `--name` `myapp` option.
    Specifying a name makes it easier to find the container, and it allows you to
    specify a name that can then be used for other commands (e.g., `podman` `stop`
    `myapp`). If you don’t specify a name, Podman automatically generates a unique
    container name along with a container ID. All of the Podman commands that interact
    with containers can use either the name or the ID:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例名称中，容器 `myapp` 使用了 `--name` `myapp` 选项。指定名称可以更容易地找到容器，并允许您指定一个名称，然后可以用于其他命令（例如，`podman`
    `stop` `myapp`）。如果您不指定名称，Podman 会自动生成一个唯一的容器名称以及容器 ID。所有与容器交互的 Podman 命令都可以使用名称或
    ID：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When the `podman` `run` command completes, the container is running. Since
    this container is running in detached mode, Podman prints out the container ID
    and exits, but the container remains running:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `podman` `run` 命令完成后，容器正在运行。由于此容器以分离模式运行，Podman 打印出容器 ID 并退出，但容器仍然在运行：
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now that the container is running, you can launch a web browser to communicate
    with the web server inside of the container at localhost port `8080` (see figure
    2.1):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在容器正在运行，您可以通过启动一个网络浏览器来与容器内部的 Web 服务器进行通信，该服务器在 localhost 端口 `8080` 上运行（见图
    2.1）：
- en: '[PRE16]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '![](../../OEBPS/Images/02-01.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/02-01.png)'
- en: Figure 2.1 Web browser window connecting to the ubi8/httpd-24 container running
    in Podman
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 使用 Podman 运行的 ubi8/httpd-24 容器连接到 Web 浏览器窗口
- en: Congratulations! You have launched your first containerized application.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已成功启动了您的第一个容器化应用程序。
- en: 'Now imagine you want to start another container. You can execute a similar
    command with just a couple of changes:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设您想要启动另一个容器。您可以通过进行一些更改来执行类似的命令：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Notice you need to change the name of the container to `myapp1`; otherwise,
    the `podman` `run` command fails with the `myapp` name because the container previously
    existed. Also you need to change the `-p` option to use `8081` for the host port
    because the previous container, `myapp`, is currently running and is bound to
    port `8080`. The second container isn’t allowed to bind to port `8080` until the
    first container exits:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您需要将容器的名称更改为 `myapp1`；否则，由于容器之前已存在，使用 `myapp` 名称的 `podman` `run` 命令会失败。您还需要将
    `-p` 选项更改为使用 `8081` 作为主机端口，因为之前的容器 `myapp` 目前正在运行并绑定到端口 `8080`。第二个容器不允许绑定到端口 `8080`，直到第一个容器退出：
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `podman` `create` command is almost identical to the `podman` `run` command.
    The `create` command pulls the image if it is not in container storage and configures
    the container information to make it ready to run but never executes the container.
    It is often used together with the `podman` `start` command described in section
    2.1.4\. You might want to create a container and then later use a systemd unit
    file to start and stop the container.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`podman` 的 `create` 命令几乎与 `podman` 的 `run` 命令相同。如果镜像不在容器存储中，`create` 命令会拉取镜像并配置容器信息以便运行，但不会执行容器。它通常与第
    2.1.4 节中描述的 `podman` `start` 命令一起使用。您可能想要创建一个容器，然后稍后使用 systemd 单元文件来启动和停止容器。'
- en: 'Some notable `podman` `run` options include the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一些值得注意的 `podman` `run` 选项包括以下内容：
- en: --`user` `USERNAME`—This tells Podman to run the container as a specific user
    defined in the image. By default, Podman will run the container as root, unless
    the container image specifies a default user.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: --`user` `USERNAME`—这告诉 Podman 以在镜像中定义的特定用户运行容器。默认情况下，Podman 将以 root 用户身份运行容器，除非容器镜像指定了默认用户。
- en: '`--rm`—This automatically removes the container when it exits.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--rm` — 这会在容器退出时自动删除容器。'
- en: '`--tty` `-(t``)`—This allocates a pseudo `-tty` and attaches it to the standard
    input of the container.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--tty` `-(t)` — 这分配一个伪 `-tty` 并将其附加到容器的标准输入。'
- en: '`--interactive` `(-i``)`—This connects `stdin` to the primary process of the
    container. These options give you an interactive shell within the container.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--interactive` `(-i)` — 这将 `stdin` 连接到容器的首要进程。这些选项在容器内为你提供了一个交互式 shell。'
- en: Note There are dozens of `podman` `run` options available, allowing you to change
    security features, namespaces, volumes, and so on. Some of these I use and explain
    throughout the book. Refer to the `podman-run` man page for a description of all
    of the options. Most of the `podman` `create` options defined in table 2.1 are
    also available for `podman` `run`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：有数十个 `podman run` 选项可供使用，允许你更改安全功能、命名空间、卷等。我在本书中使用了其中一些并进行了解释。请参阅 `podman-run`
    的 man 页面以了解所有选项的描述。表 2.1 中定义的大多数 `podman create` 选项也适用于 `podman run`。
- en: Use the `man` `podman-run` command for information about all options. Now that
    the container is up and running, it is time to stop the container and go to the
    next step.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `man podman-run` 命令获取所有选项的信息。现在容器已经启动并运行，是时候停止容器并进入下一步了。
- en: 2.1.3 Stopping containers
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.3 停止容器
- en: 'You have two containers running and have tested them by running a web browser
    against them. To continue the development by actually adding some content to the
    web page, you can stop the containers using the `podman` `stop` command:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你有两个正在运行的容器，并且通过运行网页浏览器对它们进行了测试。为了通过实际向网页添加内容来继续开发，你可以使用 `podman stop` 命令停止容器：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `stop` command stops the container started with the previous `podman` `run`
    command.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`stop` 命令会停止之前使用 `podman run` 命令启动的容器。'
- en: When stopping a container, Podman examines the running container and sends a
    stop signal, usually `SIGTERM`, to the primary process (PID1) of the container,
    and then by default it waits 10 seconds for the container to stop. The stop signal
    tells the primary process within the container to exit gracefully. If the container
    doesn’t stop within 10 seconds, Podman sends the `SIGKILL` signal to the process,
    forcing the container to stop. The 10-second wait gives the processes in the container
    time to clean up and commit changes.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当停止容器时，Podman 会检查正在运行的容器，并向容器的首要进程（PID1）发送停止信号，通常是 `SIGTERM`，然后默认等待 10 秒以等待容器停止。停止信号告诉容器内的首要进程优雅地退出。如果容器在
    10 秒内没有停止，Podman 会向进程发送 `SIGKILL` 信号，强制容器停止。这 10 秒的等待时间给容器内的进程提供了清理和提交更改的时间。
- en: The default stop signal can be changed for a container using the `podman` `run`
    `--stop-signal` option. Sometimes the primary or init process of a container ignores
    `SIGTERM` (e.g., containers that use systemd as the primary process inside a container).
    systemd ignores `SIGTERM` and specifies that it shuts down using the `SIGRTMIN+3`
    `(signal` `#37)` signal. The stop signal can be embedded in container images,
    as I describe in section 2.3.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `podman run --stop-signal` 选项更改容器的默认停止信号。有时容器的首要或初始化进程会忽略 `SIGTERM`（例如，在容器内部使用
    systemd 作为首要进程的容器）。systemd 忽略 `SIGTERM` 并指定使用 `SIGRTMIN+3`（信号 `#37`）信号来关闭。停止信号可以嵌入到容器镜像中，正如我在第
    2.3 节中描述的那样。
- en: 'Some containers ignore the `SIGTERM` stop signal, which means you have to wait
    10 seconds for the container to exit. If you know the container ignores the default
    stop signal, and you don’t care about the container cleaning up, you can just
    add the `-t` `0` option to `podman` `stop` to send the `SIGKILL` signal right
    away:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一些容器会忽略 `SIGTERM` 停止信号，这意味着你必须等待 10 秒才能让容器退出。如果你知道容器忽略了默认的停止信号，并且你不在乎容器进行清理，你只需将
    `-t 0` 选项添加到 `podman stop` 中，就可以立即发送 `SIGKILL` 信号：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Podman has a similar command, `podman` `kill`, which sends the specified kill
    signal. The `podman` `kill` command can be useful when you want to send signals
    into the container without actually stopping the container.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 有一个类似的命令 `podman kill`，它发送指定的终止信号。当你想要向容器发送信号而不实际停止容器时，`podman kill`
    命令非常有用。
- en: 'Some notable Podman stop options include the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一些值得注意的 Podman 停止选项包括以下内容：
- en: '`--timeout` `(-t``)`—This sets the timeout; `-t` `0` sends the `SIGKILL` without
    waiting for the container to stop.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--timeout` `(-t)` — 这设置超时时间；`-t 0` 在等待容器停止之前发送 `SIGKILL` 信号。'
- en: '`--latest` `(-l``)`—This is a useful option to allow you to stop the last created
    container rather than having to use the container name or container ID. Most Podman
    commands that require you to specify a container name or ID also accept the `--latest`
    option. This is only available on Linux machines.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--latest` `(-l``)`—这是一个有用的选项，允许您停止最后一个创建的容器，而不是必须使用容器名称或容器 ID。大多数需要您指定容器名称或
    ID 的 Podman 命令也接受 `--latest` 选项。此选项仅在 Linux 机器上可用。'
- en: '`--all`—This tells Podman to stop all running containers. Similarly to `--latest`,
    Podman commands that require a container name or container ID parameter also take
    the `--all` option.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--all`—这告诉 Podman 停止所有正在运行的容器。类似于 `--latest`，需要容器名称或容器 ID 参数的 Podman 命令也接受
    `--all` 选项。'
- en: Use the `man` `podman-stop` command for information about all options.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `man` `podman-stop` 命令获取所有选项的信息。
- en: Eventually, your system will have lots of stopped containers, and sometimes
    you will need to restart them (e.g., if the system was rebooted). Another common
    use case is to first create a container and later start it. The next section explains
    how to start a container.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，您的系统将会有很多停止的容器，有时您需要重新启动它们（例如，如果系统重启）。另一个常见用例是首先创建一个容器，然后稍后启动它。下一节将解释如何启动容器。
- en: 2.1.4 Starting containers
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.4 启动容器
- en: The container you created has now been stopped. Next, you may want to start
    it back up again using the command in the following listing.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您创建的容器现在已经停止。接下来，您可能想要使用以下列表中的命令重新启动它。
- en: Listing 2.3 Example of starting a container
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.3 启动容器的示例
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ The start command prints the names of the containers that were started.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 启动命令打印已启动容器的名称。
- en: The `podman` `start` command starts one or more containers. This command will
    output the container ID, indicating that your container is up and running. You
    can now reconnect to it with a web browser. One common use case for `podman` `start`
    is starting a container after a reboot to start all of the containers that were
    stopped during shutdown.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`podman` `start` 命令启动一个或多个容器。此命令将输出容器 ID，表示您的容器正在运行。您现在可以使用网络浏览器重新连接到它。`podman`
    `start` 的一个常见用例是在重启后启动所有在关机期间停止的容器。'
- en: 'Some favorite Podman start options include these:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一些喜欢的 Podman 启动选项包括以下内容：
- en: '`--all`—This starts all of the stopped containers in container storage.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--all`—这会启动容器存储中所有停止的容器。'
- en: '`--attach`—This attaches your terminal to the output of the container.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--attach`—这会将您的终端连接到容器的输出。'
- en: '`--interactive` `(-i``)`—This attaches the terminal input to the container.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--interactive` `(-i``)`—这会将终端输入连接到容器。'
- en: Use the `man` `podman-start` command for information about all options.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `man` `podman-start` 命令获取所有选项的信息。
- en: After you’ve been using Podman for a while and have pulled down and run many
    different container images, you might want to figure out which containers are
    running or which containers you have in local storage. You will need to be able
    to list these containers.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在您使用 Podman 一段时间并拉取并运行了许多不同的容器镜像之后，您可能想要找出哪些容器正在运行或您在本地存储中有哪些容器。您将需要能够列出这些容器。
- en: 2.1.5 Listing containers
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.5 列出容器
- en: 'You can list the running containers and all of the containers that were previously
    created. Use the `podman` `ps` command to list containers:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以列出正在运行的容器和之前创建的所有容器。使用 `podman` `ps` 命令列出容器：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Notice the `podman` `ps` command by default lists the running containers. Use
    the `--all` option to see all of the containers:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，默认情况下 `podman` `ps` 命令列出正在运行的容器。使用 `--all` 选项查看所有容器：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Some notable `podman` `ps` options include the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一些值得注意的 `podman` `ps` 选项包括以下内容：
- en: '`--all`—This tells Podman to list all containers rather than just running containers.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--all`—这告诉 Podman 列出所有容器而不是仅列出正在运行的容器。'
- en: '`--quiet`—This tells Podman to only print the container IDs.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--quiet`—这告诉 Podman 只打印容器 ID。'
- en: '`--size`—This tells Podman to return the amount of disk space currently used
    for each container other than the images they are based on.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--size`—这告诉 Podman 返回每个容器（除了基于它们的镜像）当前使用的磁盘空间量。'
- en: Use the `man` `podman-ps` command for information about all options. Now that
    you know all of the containers you have on the system, you might want to inspect
    their internals.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `man` `podman-ps` 命令获取所有选项的信息。现在您已经知道了系统上所有的容器，您可能想要检查它们的内部结构。
- en: 2.1.6 Inspecting containers
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.6 检查容器
- en: To fully understand a container, sometimes you want to know which image a container
    was based on, which environment variables a container gets by default, or what
    the security settings used for a container are. The `podman` `ps` command gives
    us some data about the containers, but if you want to really examine information
    about the container, you can use the `podman` `inspect` command.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完全了解一个容器，有时您想知道容器基于哪个镜像，容器默认获取哪些环境变量，或者容器使用的安全设置是什么。`podman` `ps`命令为我们提供了一些关于容器的数据，但如果您想真正检查有关容器的信息，您可以使用`podman`
    `inspect`命令。
- en: 'The `podman` `inspect` command can also be used to inspect images, networks,
    volumes, and pods. The `podman` `container` `inspect` command is also available
    and specific to containers. But most users just type the shorter `podman` `inspect`
    command:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`podman` `inspect`命令也可以用来检查镜像、网络、卷和Pod。`podman` `container` `inspect`命令也是可用的，并且是针对容器的。但大多数用户只是输入较短的`podman`
    `inspect`命令：'
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, the `podman` `inspect` command outputs a large JSON file—307
    lines on my machine. All of this information is eventually handed down the OCI
    runtime to launch the container. When using the `inspect` command, it is often
    better to pipe its output to `less` or `grep` to find particular fields you are
    interested in. Alternatively, you can use the format option. If you want to examine
    the command executed when you start the container, execute the following.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`podman` `inspect`命令输出一个大的JSON文件——在我的机器上有307行。所有这些信息最终都会传递给OCI运行时以启动容器。当使用`inspect`命令时，通常最好将其输出通过`less`或`grep`管道，以找到您感兴趣的字段。或者，您可以使用格式选项。如果您想检查启动容器时执行的命令，请执行以下操作。
- en: Listing 2.4 Inspecting a specified command to execute the container
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.4 检查要执行的指定容器命令
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ❶ inspect is displaying data from the OCI image specification.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 检查正在显示来自OCI镜像规范的数据。
- en: Or if you want to see the stop signal, execute the following.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您想查看停止信号，请执行以下操作。
- en: Listing 2.5 Inspecting the stop signal to be used when stopping the container
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.5 检查停止容器时使用的停止信号
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ The default stop signal for all containers is 15 (SIGTERM).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 所有容器的默认停止信号为15（SIGTERM）。
- en: 'Some notable `podman` `inspect` options include the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一些显著的`podman` `inspect`选项包括以下内容：
- en: '`--latest` `(-l``)`—This is handy in that it allows you to quickly inspect
    the last created container rather than specifying the container name or container
    ID.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--latest` `(-l``)`—这很方便，因为它允许您快速检查最新创建的容器，而不是指定容器名称或容器ID。'
- en: '`--format`—This is useful, as shown previously, to extract particular fields
    out of the JSON.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--format`—正如之前所示，这很有用，可以从中提取JSON中的特定字段。'
- en: '`--size`—This adds the amount of disk space the container is using. Gathering
    this information takes a long time, so it is not done by default.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--size`—这会增加容器使用的磁盘空间量。收集这些信息需要很长时间，因此默认情况下不会执行。'
- en: Use the `man` `podman-inspect` command for information about all options. After
    you inspect a container, you might realize you no longer need that container taking
    up storage, so you need to remove it.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`man` `podman-inspect`命令获取有关所有选项的信息。在检查完容器后，您可能会意识到您不再需要占用存储空间的该容器，因此您需要删除它。
- en: 2.1.7 Removing containers
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.7 删除容器
- en: 'If you are done using a container, you may want to remove the container to
    free up disk space or reuse the container name. Remember when you started a second
    container called `myapp1`? You no longer need it, so you can remove it. Make sure
    to stop the container (section 2.1.3) before removing it. Then use the `podman`
    `rm` command to remove container:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经使用完一个容器，您可能想删除该容器以释放磁盘空间或重用容器名称。记得您启动了第二个名为`myapp1`的容器吗？您不再需要它，因此可以删除它。在删除之前，请确保停止容器（第2.1.3节）。然后使用`podman`
    `rm`命令删除容器：
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Some notable `podman` `rm` options include the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一些显著的`podman` `rm`选项包括以下内容：
- en: '`--all`—This option is useful if you want to remove all your containers.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--all`—如果您想删除所有容器，此选项很有用。'
- en: '`--force`—This option tells Podman to stop all the running containers when
    removing.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--force`—此选项告诉Podman在删除时停止所有正在运行的容器。'
- en: Use the `man` `podman-rm` command for information about all options. Now that
    you understand a few commands, it is time to start modifying the running container.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`man` `podman-rm`命令获取有关所有选项的信息。现在您已经了解了一些命令，是时候开始修改正在运行的容器了。
- en: 2.1.8 exec-ing into a container
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.8 在容器中执行
- en: Often, when a container is running, you might want to start another process
    within the container to debug or examine what is going on. In some cases, you
    may want to modify some of the content the container is using.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当容器正在运行时，你可能会想在容器内启动另一个进程以进行调试或检查正在发生的事情。在某些情况下，你可能想要修改容器使用的一些内容。
- en: Imagine you want to go into your container and modify the web page it is showing.
    You can `exec` into the container using the `podman` `exec` command. Use the `--interactive`
    (`-i`) option to allow you to execute commands within the container. You need
    to specify the name of the container `myapp` and execute the Bash script while
    in the container. If you stopped the `myapp` container, you need to restart it,
    since `podman` `exec` only works on running containers.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想进入你的容器并修改它显示的网页。你可以使用`podman` `exec`命令进入容器。使用`--interactive`（`-i`）选项允许你在容器内执行命令。你需要指定容器的名称`myapp`并在容器内执行Bash脚本。如果你停止了`myapp`容器，你需要重新启动它，因为`podman`
    `exec`只对正在运行的容器有效。
- en: 'In the following example, you will `exec` a `bash` process into the container
    to create the /var/www/html/index.xhtml file. You will write HTML content that
    causes the containerized website to display `Hello` `World`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，你将在容器中`exec`一个`bash`进程来创建`/var/www/html/index.xhtml`文件。你将写入HTML内容，使容器化的网站显示`Hello`
    `World`：
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`exec`-ing back into the container a second time, you can see that the file
    was successfully modified. This shows that modifications to a container via `exec`
    are permanent to the container and will remain even if you stopped and restarted
    the container. A key difference between `podman` `run` and `podman` `exec` is
    that `run` creates a new container off of an image with processes running inside,
    while `exec` starts processes inside of existing containers:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次`exec`回到容器中，你可以看到文件已被成功修改。这表明通过`exec`对容器的修改是永久性的，即使你停止并重新启动了容器，这些修改也会保留。`podman`
    `run`和`podman` `exec`之间的一个关键区别是`run`从一个带有内部运行进程的图像创建一个新的容器，而`exec`在现有容器内部启动进程：
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now let’s connect a web browser to the container to see if the content has
    changed (see figure 2.2):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将一个网络浏览器连接到容器以查看内容是否已更改（见图2.2）：
- en: '[PRE30]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '![](../../OEBPS/Images/02-02.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/02-02.png)'
- en: Figure 2.2 Web browser window connecting to the ubi8/httpd-24 container running
    in Podman with updated Hello World HTML
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 Web浏览器窗口连接到在Podman中运行的更新后的Hello World HTML的ubi8/httpd-24容器
- en: 'Some notable `podman` `exec` options include the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一些值得注意的`podman` `exec`选项包括以下内容：
- en: '`--tty`—This connects a `-tty` to the `exec` session.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--tty`—这会将一个`-tty`连接到`exec`会话。'
- en: '`--interactive`—The `-i` option tells Podman to run in interactive mode, meaning
    you can interact with an `exec`-ed program, like a shell.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--interactive`—`-i`选项告诉Podman以交互模式运行，这意味着你可以与一个`exec`执行的程序交互，比如一个shell。'
- en: Use the `man` `podman-exec` command for information about all options.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`man` `podman-exec`命令获取所有选项的信息。
- en: Now that you have created an application, you might want to share it with others.
    First, you need to commit the container to an image.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建了一个应用程序，你可能想要与他人分享它。首先，你需要将容器提交为一个图像。
- en: 2.1.9 Creating an image from a container
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.9 从容器创建图像
- en: Developers often run containers from a base image to create a new container
    environment. Once they are done, they pack this environment into a container image
    to be able to share it with other users. Those users can then use Podman to launch
    the containerized application. You can do this with Podman by committing the container
    to an OCI image.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者通常从基础镜像运行容器以创建一个新的容器环境。一旦完成，他们将这个环境打包成一个容器图像以便与其他用户分享。然后，这些用户可以使用Podman启动容器化应用程序。你可以通过将容器提交到OCI图像来实现这一点。
- en: 'First, stop or pause the container to make sure nothing gets modified while
    you are committing it:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，停止或暂停容器以确保在提交过程中没有任何内容被修改：
- en: '[PRE31]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now you can execute the `podman` `commit` command to take your application
    container, `myapp`, and commit it, creating a new image named `myimage`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以执行`podman` `commit`命令，将你的应用程序容器`myapp`提交，创建一个名为`myimage`的新图像：
- en: '[PRE32]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now you can continue running the existing `myapp` container by calling `podman`
    `start`, or you can create a new container based on `myimage`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以通过调用`podman` `start`继续运行现有的`myapp`容器，或者你可以基于`myimage`创建一个新的容器：
- en: '[PRE33]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note Using the `podman` `commit` command to create an image is not a common
    method. The entire process of building container images can be scripted and automated
    using `podman` `build`. See section 2.3 for more information on this process.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：使用 `podman` `commit` 命令来创建镜像不是一种常见的方法。构建容器镜像的整个过程可以使用 `podman` `build` 脚本化和自动化。有关此过程的更多信息，请参阅第
    2.3 节。
- en: 'Some notable `podman` `commit` options include the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 一些显著的 `podman` `commit` 选项包括以下内容：
- en: '`--pause`—This pauses a running container during the commit. Notice I stopped
    the container before doing the commit, while I could have simply paused it. The
    `podman` `pause` and `podman` `unpause` commands allow you to pause and unpause
    containers directly.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--pause`—在提交过程中暂停正在运行的容器。注意我在提交之前停止了容器，尽管我可以简单地暂停它。`podman` `pause` 和 `podman`
    `unpause` 命令允许您直接暂停和恢复容器。'
- en: '`--change`—This option allows you to commit instructions on using the image.
    The instructions are `CMD`, `ENTRYPOINT`, `ENV`, `EXPOSE`, `LABEL`, `ONBUILD`,
    `STOPSIGNAL`, `USER`, `VOLUME`, and `WORKDIR`. These instructions match up with
    the directives in the Containerfile or Dockerfile.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--change`—此选项允许您提交关于使用镜像的说明。说明包括 `CMD`、`ENTRYPOINT`、`ENV`、`EXPOSE`、`LABEL`、`ONBUILD`、`STOPSIGNAL`、`USER`、`VOLUME`
    和 `WORKDIR`。这些说明与 Containerfile 或 Dockerfile 中的指令相对应。'
- en: Use the `man` `podman-commit` command for information about all options. Table
    2.1 lists all the Podman container commands.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `man` `podman-commit` 命令获取所有选项的信息。表 2.1 列出了所有 Podman 容器命令。
- en: Now that you have committed your container to an image, it is time to show how
    Podman can work with images.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经将容器提交为镜像，是时候展示 Podman 如何与镜像一起工作了。
- en: Note You have examined a few of the Podman container commands, but there are
    many more. Use the `podman-container(1)` man pages to explore all of them as well
    as a full description of commands specified in this section.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您已经检查了一些 Podman 容器命令，但还有很多。使用 `podman-container(1)` 手册页来探索所有这些命令，以及本节中指定命令的完整描述。
- en: Table 2.1 Podman container commands
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.1 Podman 容器命令
- en: '| Command | Man page | Description |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| 命令 | 手册页 | 描述 |'
- en: '| `attach` | `podman-container-attach(1)` | Attach to a running container.
    |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `attach` | `podman-container-attach(1)` | 连接到正在运行的容器。|'
- en: '| `checkpoint` | `podman-container-checkpoint(1)` | Checkpoint a container.
    |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `checkpoint` | `podman-container-checkpoint(1)` | 创建容器的检查点。|'
- en: '| `cleanup` | `podman-container-cleanup(1)` | Clean up network and mount points
    of a container. |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `cleanup` | `podman-container-cleanup(1)` | 清理容器的网络和挂载点。|'
- en: '| `commit` | `podman-container-commit(1)` | Commit a container into an image.
    |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `commit` | `podman-container-commit(1)` | 将容器提交到镜像中。|'
- en: '| `cp` | `podman-container-cp(1)` | Copy files or folders into and out of containers.
    |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `cp` | `podman-container-cp(1)` | 将文件或文件夹复制到容器中或从容器中复制出来。|'
- en: '| `create` | `podman-container-create(1)` | Create a new container. |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `create` | `podman-container-create(1)` | 创建一个新的容器。|'
- en: '| `diff` | `podman-container-diff(1)` | Inspect changes in a container’s filesystem.
    |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `diff` | `podman-container-diff(1)` | 检查容器文件系统中的更改。|'
- en: '| `exec` | `podman-container-exec(1)` | Run a process in a container. |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `exec` | `podman-container-exec(1)` | 在容器中运行进程。|'
- en: '| `exists` | `podman-container-exists(1)` | Check if a container exists. |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `exists` | `podman-container-exists(1)` | 检查容器是否存在。|'
- en: '| `export` | `podman-container-export(1)` | Export a container''s filesystem
    as a TAR archive. |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `export` | `podman-container-export(1)` | 将容器的文件系统导出为 TAR 归档。|'
- en: '| `init` | `podman-container-init(1)` | Init a container. |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `init` | `podman-container-init(1)` | 初始化容器。|'
- en: '| `inspect` | `podman-container-inspect(1)` | Display detailed information
    on a container. |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `inspect` | `podman-container-inspect(1)` | 显示容器的详细信息。|'
- en: '| `kill` | `podman-container-kill(1)` | Send a signal to the primary process
    in the container. |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `kill` | `podman-container-kill(1)` | 向容器中的主进程发送信号。|'
- en: '| `List` `(ps``)` | `podman-container-list(1)` | List all of the containers.
    |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `List` `(ps``)` | `podman-container-list(1)` | 列出所有容器。|'
- en: '| `logs` | `podman-container-logs(1)` | Fetch logs for a container. |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `logs` | `podman-container-logs(1)` | 获取容器的日志。|'
- en: '| `mount` | `podman-container-mount(1)` | Mount a container''s root filesystem.
    |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `mount` | `podman-container-mount(1)` | 挂载容器的根文件系统。|'
- en: '| `pause` | `podman-container-pause(1)` | Pause container. |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `pause` | `podman-container-pause(1)` | 暂停容器。|'
- en: '| `port` | `podman-container-port(1)` | List port mappings for a container.
    |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `port` | `podman-container-port(1)` | 列出容器的端口映射。|'
- en: '| `prune` | `podman-container-prune(1)` | Remove all non-running containers.
    |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `prune` | `podman-container-prune(1)` | 删除所有非运行中的容器。|'
- en: '| `rename` | `podman-container-rename(1)` | Rename an existing container. |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `rename` | `podman-container-rename(1)` | 重命名现有的容器。|'
- en: '| `restart` | `podman-container-restart(1)` | Restart a container. |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `restart` | `podman-container-restart(1)` | 重新启动一个容器。 |'
- en: '| `restore` | `podman-container-restore(1)` | Restore a checkpointed container.
    |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `restore` | `podman-container-restore(1)` | 恢复已检查点的容器。 |'
- en: '| `rm` | `podman-container-rm(1)` | Remove a container. |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `rm` | `podman-container-rm(1)` | 删除一个容器。 |'
- en: '| `run` | `podman-container-run(1)` | Run a command in a new container. |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `run` | `podman-container-run(1)` | 在新容器中运行命令。 |'
- en: '| `runlabel` | `podman-container-runlabel(1)` | Execute the command described
    by an image label. |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `runlabel` | `podman-container-runlabel(1)` | 执行由镜像标签描述的命令。 |'
- en: '| `start` | `podman-container-start(1)` | Start a container. |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `start` | `podman-container-start(1)` | 启动一个容器。 |'
- en: '| `stats` | `podman-container-stats(1)` | Display statistics for a container.
    |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `stats` | `podman-container-stats(1)` | 显示容器的统计信息。 |'
- en: '| `stop` | `podman-container-stop(1)` | Stop a container. |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `stop` | `podman-container-stop(1)` | 停止一个容器。 |'
- en: '| `top` | `podman-container-top(1)` | Display running process in a container.
    |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `top` | `podman-container-top(1)` | 显示容器中的运行进程。 |'
- en: '| `unmount` | `podman-container-unmount(1)` | Unmount a container''s root filesystem.
    |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `unmount` | `podman-container-unmount(1)` | 卸载容器的根文件系统。 |'
- en: '| `unpause` | `podman-container-unpause(1)` | Unpause all the containers in
    a pod. |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `unpause` | `podman-container-unpause(1)` | 恢复 pod 中所有容器的暂停状态。 |'
- en: '| `wait` | `podman-container-wait(1)` | Wait for a container to exit. |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `wait` | `podman-container-wait(1)` | 等待容器退出。 |'
- en: 2.2 Working with container images
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 与容器镜像一起工作
- en: In the previous section, you tried basic operations with containers, including
    inspecting and committing to a container image. In this section, you will try
    working with container images, learn how they differ from containers, and learn
    how to share them through container registries.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你尝试了与容器的基本操作，包括检查和提交到容器镜像。在本节中，你将尝试与容器镜像一起工作，了解它们与容器之间的区别，以及如何通过容器注册库来共享它们。
- en: 2.2.1 Differences between a container and an image
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.1 容器和镜像之间的区别
- en: One of the problems with computer programming is that the same names are constantly
    used for different purposes. In the container world, there is no more overused
    term than *container*. Often *container* refers to the running processes launched
    by Podman. But *container* can also refer to container data as the non-running
    objects sitting in container storage. As you saw in the previous section, `podman`
    `ps` `--all` shows running and non-running containers.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机编程的一个问题是，相同的名称被不断地用于不同的目的。在容器世界中，没有比 *container* 更被过度使用的术语了。通常 *container*
    指的是 Podman 启动的运行进程。但 *container* 也可以指作为非运行对象坐在容器存储中的容器数据。正如你在上一节中看到的，`podman ps
    --all` 显示了运行和非运行的容器。
- en: Another example is the term *namespace*, which is used in many different ways.
    I often get confused when people talk about namespaces within Kubernetes. Some
    people hear the term and think of *virtual clusters*, but when I hear it I think
    of Linux namespaces used with Pods and Containers. Similarly, *image* can refer
    to a VM image, a container image, an OCI image, or a Docker image stored at a
    container registry.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是术语 *namespace*，它在许多不同的方式中被使用。当人们谈论 Kubernetes 中的命名空间时，我经常感到困惑。有些人听到这个术语就会想到
    *虚拟集群*，但当我听到它时，我会想到与 Pods 和容器一起使用的 Linux 命名空间。同样，*image* 可以指 VM 镜像、容器镜像、OCI 镜像或存储在容器注册库中的
    Docker 镜像。
- en: I think of containers as executing processes within an environment or something
    that is being prepared to run. In contrast, images are *committed* *containers*,
    which are prepared to be shared with others. Other users or systems can use these
    images to create new containers.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为容器是在环境中执行进程或在准备运行的东西。相比之下，镜像是被 *提交* 的 *容器*，准备与他人共享。其他用户或系统可以使用这些镜像来创建新的容器。
- en: Container images are just committed containers. The OCI defines the format of
    an image. Podman uses the container/image library ([https://github.com/containers/image](https://github.com/containers/image))
    for all of its interaction with images. Container images can be stored in different
    types of storage or transports, as *container/image* refers to them. These transports
    can be container registries, Docker archives, OCI archives, `docker-daemon`, as
    well as containers/storage. See section 2.2.4 for more information on transports.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像只是提交的容器。OCI 定义了镜像的格式。Podman 使用容器/镜像库 ([https://github.com/containers/image](https://github.com/containers/image))
    与镜像的所有交互。容器镜像可以存储在不同的存储或传输类型中，因为 *container/image* 就是指这些。这些传输可以是容器注册库、Docker 存档、OCI
    存档、`docker-daemon`，以及 containers/storage。有关传输的更多信息，请参阅 2.2.4 节。
- en: In the context of Podman, I usually refer to images as the content stored locally
    in a container storage or in container registries like docker.io and quay.io.
    Podman uses the GitHub container/storage library ([https://github.com/containers/storage](https://github.com/containers/storage))
    for handling locally stored images. Let’s take a closer look at it.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Podman 的上下文中，我通常将镜像称为存储在容器存储或容器注册库（如 docker.io 和 quay.io）中的本地内容。Podman 使用
    GitHub container/storage 库（[https://github.com/containers/storage](https://github.com/containers/storage)）来处理本地存储的镜像。让我们更详细地看看它。
- en: The container/storage library provides the concept of a storage container. Basically,
    storage containers are intermediate storage content that hasn’t been committed
    yet. Think of them as files on disk and some JSON describing the content. Podman
    has its own datastore of data related to a Podman container, and Podman needs
    to deal with multiple users of its containers at the same time. It relies on filesystem
    locking provided by containers/storage to make sure hundreds of Podman executables
    can reliably share the same datastore.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 容器/存储库提供了存储容器的概念。基本上，存储容器是尚未提交的中间存储内容。把它们想象成磁盘上的文件和一些描述内容的 JSON。Podman 有自己的与
    Podman 容器相关的数据存储库，Podman 需要同时处理其容器的多个用户。它依赖于 containers/storage 提供的文件系统锁定，以确保数百个
    Podman 可执行文件可以可靠地共享相同的数据存储库。
- en: When you commit a container to storage, Podman copies the container storage
    to the image storage. Images are stored in a series of layers, with every commit
    creating a new layer.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将容器提交到存储时，Podman 将容器存储复制到镜像存储。镜像存储在一系列层中，每次提交都会创建一个新的层。
- en: 'I like to think of an image like a wedding cake (figure 2.3). In our previous
    example, you used the ubi8/httpd-24 image, which is two layers: the base layer
    is ubi8, and then the image provided added the `httpd` package and a few others
    to create the ubi8/httpd-24\. Now when you commit your container in the previous
    section, Podman adds another layer on top of the ubi8/httpd-24 image called `myimage`.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢将镜像想象成一个婚礼蛋糕（图 2.3）。在我们之前的例子中，你使用了 ubi8/httpd-24 镜像，它由两层组成：基础层是 ubi8，然后镜像提供的添加了
    `httpd` 包和其他一些内容，创建了 ubi8/httpd-24。现在当你提交上一节中的容器时，Podman 在 ubi8/httpd-24 镜像之上添加了另一个层，称为
    `myimage`。
- en: '![](../../OEBPS/Images/02-03.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3](../../OEBPS/Images/02-03.png)'
- en: Figure 2.3 A wedding cake display showing the images making up our Hello World
    application.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 展示了构成我们的 Hello World 应用程序的镜像的婚礼蛋糕展示。
- en: 'One handy Podman command for showing the layers of an image is the `podman`
    `image` `tree` command:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 一个方便的 Podman 命令，用于显示镜像的层，是 `podman` `image` `tree` 命令：
- en: '[PRE34]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You can see that the image `myimage` consists of five layers.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，镜像 `myimage` 由五个层组成。
- en: 'Another useful Podman command, `podman` `image` `diff`, allows you to see the
    actual files and directories that have been changed (C), added (A), or deleted
    (D) compared to another image or the lower layer:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的 Podman 命令，`podman` `image` `diff`，允许你看到与另一个镜像或底层相比实际已更改（C）、已添加（A）或已删除（D）的文件和目录：
- en: '[PRE35]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Images are just TAR diffs of software applied on lower-level images, and container
    content is an uncommitted layer of software. Once a container is committed, you
    can create other containers on top of your image. You can also share the image
    with others, so they can create other containers on your image. Now let’s look
    at all the images in your container storage.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像只是应用于底层镜像的软件的 TAR 差分，容器内容是软件的一个未提交层。一旦容器被提交，你就可以在你的镜像之上创建其他容器。你还可以与他人共享镜像，这样他们就可以在你的镜像上创建其他容器。现在让我们看看你的容器存储中的所有镜像。
- en: 2.2.2 Listing images
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.2 列出镜像
- en: 'In the container section, you were working with images and used command `podman`
    `images` to list the images in local storage:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器部分，你正在处理镜像，并使用 `podman` `images` 命令列出本地存储中的镜像：
- en: '[PRE36]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Let’s look at the different fields in the default output. Table 2.2 describes
    the different fields and data available with the `podman` `images` command. You
    will use the `podman` `images` command throughout this section.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看默认输出中的不同字段。表 2.2 描述了 `podman` `images` 命令可用的不同字段和数据。你将在本节中使用 `podman` `images`
    命令。
- en: Table 2.2 Default fields listed by the `podman` `images` command
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.2 由 `podman` `images` 命令列出的默认字段
- en: '| Heading | Description |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| 标题 | 描述 |'
- en: '| `Repository` | Complete name of the image. |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| `Repository` | 镜像的完整名称。 |'
- en: '| `TAG` | Version (tag) of the image. Image tagging is covered in section 2.2.6.
    |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| `TAG` | 镜像的版本（标签）。镜像标记将在 2.2.6 节中介绍。 |'
- en: '| `IMAGE ID` | Unique identifier of the image. It is generated by Podman as
    a SHA256 hash of the image''s JSON configuration object. |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| `IMAGE ID` | 镜像的唯一标识符。它由 Podman 通过镜像的 JSON 配置对象的 SHA256 哈希生成。|'
- en: '| `CREATED` | Elapsed time since the image was created. Images are sorted by
    this field by default. |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| `CREATED` | 自镜像创建以来经过的时间。默认情况下，镜像按此字段排序。|'
- en: '| `SIZE` | The amount of storage being used by the image. |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| `SIZE` | 镜像使用的存储量。|'
- en: Note Over time, the amount of storage used by all the images you pull grows.
    It is relatively common for users to run out of disk space, so you should monitor
    the size of images and containers, removing them when you are no longer using
    them. Use the `man` `podman-system-prune` command for more information on cleaning
    up.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：随着时间的推移，你拉取的所有镜像使用的存储量会增加。用户耗尽磁盘空间相对常见，因此你应该监控镜像和容器的大小，在你不再使用它们时删除它们。使用 `man`
    `podman-system-prune` 命令获取更多关于清理的信息。
- en: 'One notable `podman` `image` option is the following:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 一个值得注意的 `podman` 镜像选项如下：
- en: '`--all`—This option is useful for listing all images. By default, `podman-images`
    lists only the images currently in use. When an image is replaced by a newer image
    with the same tag, the previous image is tagged as `<none><none>`; These images
    are called dangling images. I cover dangling images in section 2.3.1.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--all`——此选项对于列出所有镜像很有用。默认情况下，`podman-images` 只列出当前正在使用的镜像。当一个镜像被具有相同标签的新镜像替换时，之前的镜像会被标记为
    `<none><none>`；这些镜像被称为悬挂镜像。我在第 2.3.1 节中介绍了悬挂镜像。'
- en: Use the `man` `podman-images` command for information about all options. Similarly
    to containers, you will likely want to examine the configuration information associated
    with an image by inspecting it.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `man` `podman-images` 命令来获取所有选项的信息。类似于容器，你可能会想通过检查来查看与镜像关联的配置信息。
- en: 2.2.3 Inspecting images
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.3 检查镜像
- en: In the previous sections, I mentioned a couple of commands to examine images.
    I used the `podman` `image` `diff` to examine files and directories created or
    deleted between images. I also showed you a way to see the image hierarchy or
    wedding cake layers of images using the `podman` `image` `tree` command.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我提到了几个检查镜像的命令。我使用了 `podman` `image` `diff` 来检查镜像之间创建或删除的文件和目录。我还展示了使用
    `podman` `image` `tree` 命令查看镜像层次结构或婚礼蛋糕层的办法。
- en: 'Sometimes you may want to examine the configuration of an image; use the `podman`
    `image` `inspect` command for this. The `podman` `inspect` command can also be
    used to inspect images, but the names can conflict with containers, so I prefer
    to use the specific image command:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能想检查镜像的配置；使用 `podman` `image` `inspect` 命令来做这件事。`podman` `inspect` 命令也可以用来检查镜像，但名称可能与容器冲突，所以我更喜欢使用特定的镜像命令：
- en: '[PRE37]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As you can see, this command outputs a large JSON array—153 lines in the previous
    example—that includes the data used for the OCI Image Format specification. When
    you create a container from an image, this information is used as one of the inputs
    to create the container.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个命令输出了一个大的 JSON 数组——在先前的例子中有 153 行——它包括了用于 OCI 镜像格式规范的所需数据。当你从一个镜像创建容器时，这些信息被用作创建容器的输入之一。
- en: When using the `inspect` command, it is often better to pipe its output to `less`
    or `grep` to find particular fields you are interested in. Alternatively, you
    can use the `--format` option.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `inspect` 命令时，通常最好将其输出通过 `less` 或 `grep` 管道，以找到你感兴趣的特定字段。或者，你也可以使用 `--format`
    选项。
- en: 'If you want to to examine the default command to be executed from this image,
    execute the following:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要检查从这个镜像执行默认命令的情况，请执行以下操作：
- en: '[PRE38]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Or if you want to see the stop signal, execute
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你想查看停止信号，执行以下命令：
- en: '[PRE39]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As you can see, nothing is output, meaning the developer of the application
    did not specify a `STOPSIGNAL`. When you build a container off of this image,
    the `STOPSIGNAL` is the default, `15`, unless you override it via the command
    line.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，没有输出任何内容，这意味着应用程序的开发者没有指定 `STOPSIGNAL`。当你从这个镜像构建容器时，`STOPSIGNAL` 是默认的 `15`，除非你通过命令行覆盖它。
- en: 'One notable `podman` `image` `inspect` option is the following:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 一个值得注意的 `podman` `image` `inspect` 选项如下：
- en: '`--format`—This is useful as you see above to extract particular fields out
    of the json.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--format`——如上所示，这很有用，可以提取 json 中的特定字段。'
- en: Use the `man` `podman-image-inspect` command for information about the command.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `man` `podman-image-inspect` 命令来获取关于该命令的信息。
- en: Once you are happy with a container and commit it to an image, the next step
    is sharing it with others or perhaps running it on another system. You need to
    push the image out to other types of container storage, usually a container registry.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你对一个容器满意并将其提交为镜像，下一步就是与他人分享或者可能在另一个系统上运行它。你需要将镜像推送到其他类型的容器存储，通常是容器注册库。
- en: 2.2.4 Pushing images
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.4 推送镜像
- en: In Podman, you use the `podman` `push` command to copy an image and all of its
    layers out of container storage and push it to other forms of container image
    storage, like a container registry. Podman supports a few different types of container
    storage, which it calls transports.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Podman 中，你使用 `podman` 的 `push` 命令将镜像及其所有层从容器存储复制出来，并将其推送到其他形式的容器镜像存储，如容器注册库。Podman
    支持几种不同类型的容器存储，它称之为传输。
- en: Container transports
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 容器传输
- en: Podman uses the containers/image library ([https://github.com/containers/image](https://github.com/containers/image))
    for pulling and pushing images. I describe the containers/image project as a library
    for copying images between different types of container storage. One storage,
    as you have seen, is containers/storage.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 使用 containers/image 库（[https://github.com/containers/image](https://github.com/containers/image)）来拉取和推送镜像。我把
    containers/image 项目描述为在不同类型的容器存储之间复制镜像的库。正如你所看到的，其中一种存储是 containers/storage。
- en: When pushing an image, the `[destination]` is specified using `transport:ImageName`
    format. If no transport is specified, the `docker` (container registry) transport
    is used by default.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 当推送一个镜像时，使用 `transport:ImageName` 格式指定 `[destination]`。如果没有指定传输方式，默认使用 `docker`（容器注册库）传输方式。
- en: One of the novel things that Docker did, as I explained earlier, was invent
    the container registry concept—basically, a web server that contains container
    images. The docker.io, quay.io, and Artifactory web servers are all examples of
    container registries. The Docker engineering team defined a protocol for pulling
    and pushing these images from the container registries, which I refer to as the
    container registry or `docker` transport.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前解释的，Docker 做的一件新颖的事情是发明了容器注册库的概念——基本上是一个包含容器镜像的网页服务器。docker.io、quay.io 和
    Artifactory 网页服务器都是容器注册库的例子。Docker 工程团队定义了一个从容器注册库拉取和推送这些镜像的协议，我将其称为容器注册库或 `docker`
    传输。
- en: 'When I want to run a container of an image, I can fully specify the image name,
    including the transport like the following command:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当我想运行一个镜像的容器时，我可以完全指定镜像名称，包括传输方式，如下面的命令所示：
- en: '[PRE40]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'For Podman, `docker://` transport is the default; it can be skipped for convenience:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Podman，`docker://` 传输是默认的；为了方便可以省略：
- en: '[PRE41]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `myimage` image you created in the previous section was created locally,
    which means it doesn’t have a registry associated with it. By default, locally
    created images have the localhost registry associated with them. You can see the
    images in the containers/storage using the `podman` `images` command:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中创建的 `myimage` 镜像是本地创建的，这意味着它没有与之关联的注册库。默认情况下，本地创建的镜像与 localhost 注册库相关联。你可以使用
    `podman` 的 `images` 命令在 `containers/storage` 中查看镜像：
- en: '[PRE42]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If the image has a remote registry associated with it (e.g., registry.access.redhat.com/
    ubi8), it can be pushed without specifying the `[destination]` field. On the contrary,
    since localhost/myimage does not have a registry associated with it, remote registry
    needs to be specified (e.g., quay.io/rhatdan):'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果镜像与远程注册库相关联（例如，registry.access.redhat.com/ubi8），则可以不指定 `[destination]` 字段进行推送。相反，由于
    localhost/myimage 没有与之关联的注册库，需要指定远程注册库（例如，quay.io/rhatdan）：
- en: '[PRE43]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Note Before executing the `podman` `push` command, I logged into the quay.io/
    rhatdan account using p`odman` `login`, which is covered in the next section.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在执行 `podman` 的 `push` 命令之前，我使用 `podman` 的 `login` 登录到 quay.io/rhatdan 账户，这将在下一节中介绍。
- en: After the `push` command is finished, the image becomes available for pull for
    other users, given they have access to this container registry. Table 2.3 describes
    the supported transports for different types of container’s storage.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `push` 命令完成后，如果其他用户有权访问这个容器注册库，镜像将可供他们拉取。表 2.3 描述了支持不同类型容器存储的传输方式。
- en: Table 2.3 Podman-supported transports
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.3 Podman 支持的传输
- en: '| Transport | Description |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| 传输 | 描述 |'
- en: '| Container registry (Docker) | Default transport. This references a container
    image stored in a remote container image registry. Container registry is a place
    for storing and sharing container images (e.g., docker.io or quay.io). |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| 容器注册库（Docker） | 默认传输。它引用存储在远程容器图像注册库中的容器图像。容器注册库是存储和共享容器图像的地方（例如，docker.io
    或 quay.io）。|'
- en: '| `oci` | References a container image, compliant with the Open Container Image
    Layout Specification. The manifest and layer tarballs as individual files are
    located in the local directory. |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| `oci` | 指向符合 Open Container Image Layout 规范的容器图像。清单和层 tarball 作为单独的文件位于本地目录中。|'
- en: '| `dir` | References a container image, compliant with the Docker image layout.
    It is very similar to the `oci` transport but stores the files using the legacy
    Docker format. It is a nonstandardized format, primarily useful for debugging
    or noninvasive container inspection. |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| `dir` | 指向符合 Docker 图像布局的容器图像。它与 `oci` 传输非常相似，但使用传统的 Docker 格式存储文件。它是一种非标准化格式，主要用于调试或非侵入式容器检查。|'
- en: '| `docker-archive` | References a container image in Docker image layout, which
    is packed into a TAR archive. |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| `docker-archive` | 指向 Docker 图像布局中的容器图像，它被打包成一个 TAR 归档。|'
- en: '| `oci-archive` | References an image compliant with the Open Container Image
    Layout Specification, which is packed into a TAR archive. It is very similar to
    the `docker-archive` transport, but it stores an image in OCI format. |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| `oci-archive` | 指向符合 Open Container Image Layout 规范的图像，它被打包成一个 TAR 归档。它与
    `docker-archive` 传输非常相似，但它以 OCI 格式存储图像。|'
- en: '| `docker-daemon` | References an image stored in the Docker daemon’s internal
    storage. Since the Docker daemon requires root privileges, Podman has to be run
    by the root user. |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| `docker-daemon` | 指向存储在 Docker 守护进程内部存储中的图像。由于 Docker 守护进程需要 root 权限，Podman
    必须由 root 用户运行。|'
- en: '| `container-storage` | References an image located in a local container storage.
    It is not a transport but more of a mechanism for storing images. It can be used
    to convert other transports into `container-storage`. Podman defaults to using
    `container-storage` for local images. |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| `container-storage` | 指向位于本地容器存储中的图像。它不是一个传输，而更像是一种存储图像的机制。它可以用来将其他传输转换为
    `container-storage`。Podman 默认使用 `container-storage` 来存储本地图像。|'
- en: You want to push your image to a container registry, but if you try to push
    it, the container registry rejects your push, since you have not provided login
    authorization information. You need to execute `podman` `login` to create the
    authorization.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 您想将图像推送到容器注册库，但如果您尝试推送，容器注册库会拒绝您的推送，因为您没有提供登录授权信息。您需要执行 `podman` `login` 来创建授权。
- en: '2.2.5 podman login: Logging into a container registry'
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.5 podman login：登录到容器注册库
- en: 'In the previous section, I pushed the image to my container registry by executing
    the following:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我通过执行以下操作将图像推送到我的容器注册库：
- en: '[PRE44]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'However, I left out a key step: logging into a container registry using correct
    credentials. This is a necessary step for pushing a container image. It is also
    required for pulling a container image from a private registry.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我遗漏了一个关键步骤：使用正确的凭证登录到容器注册库。这是推送容器图像的必要步骤。它也是从私有注册库拉取容器图像所必需的。
- en: To follow along in this section, you need to set up an account at a container
    registry; there are several container registries available to choose from. The
    [https://quay.io](https://quay.io) and [https://docker.io](https://docker.io)
    registries both provide free accounts and storage. Your company might have a private
    registry, where you can also get an account.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 要在本节中跟随操作，您需要在容器注册库中设置一个账户；有多个容器注册库可供选择。[https://quay.io](https://quay.io) 和
    [https://docker.io](https://docker.io) 注册库都提供免费账户和存储。您的公司可能有一个私有注册库，在那里您也可以获得一个账户。
- en: 'For the examples, I will continue to use my rhatdan account at quay.io. Log
    in to get your credentials:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 对于示例，我将继续使用我在 quay.io 的 rhatdan 账户。登录以获取您的凭证：
- en: '[PRE45]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Notice the Podman command prompts you for your username and password at the
    registry. The `podman` `login` command has options to pass the username/password
    information on the command line to avoid the prompt, allowing you to automate
    the login process.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 Podman 命令会在注册库中提示您输入用户名和密码。`podman` `login` 命令有选项可以在命令行上传递用户名/密码信息，以避免提示，让您能够自动化登录过程。
- en: 'To store authentication information for the user, the `podman` `login` command
    creates an auth.json file. By default, this is stored in the /run/user/$UID/containers/auth.json
    file:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 要为用户存储认证信息，`podman login` 命令会创建一个 auth.json 文件。默认情况下，它存储在 /run/user/$UID/containers/auth.json
    文件中：
- en: '[PRE46]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The auth.json file contains your registry password in a Base64-encoded string;
    there is no cryptography involved. Therefore, the auth.json file needs to be protected.
    Podman defaults to storing the file in /run because it is a temporary filesystem
    and is destroyed when you log out or the system is rebooted. The /run/user/$UID/containers
    directory is not accessible by other users on the system.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: auth.json 文件包含你的注册表密码，以 Base64 编码的字符串形式；其中不涉及加密。因此，auth.json 文件需要受到保护。Podman
    默认将文件存储在 /run 中，因为它是一个临时文件系统，当你注销或系统重启时会被销毁。/run/user/$UID/containers 目录对系统上的其他用户不可访问。
- en: It is possible to override the location by specifying the `--auth-file` option.
    Alternatively, you can use the `REGISTRY_AUTH_FILE` environment variable to modify
    its location. If both are specified, the `--auth-file` option is used. All container
    tools use this file to access the container registry.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过指定 `--auth-file` 选项来覆盖位置。或者，你可以使用 `REGISTRY_AUTH_FILE` 环境变量来修改其位置。如果两者都指定了，则使用
    `--auth-file` 选项。所有容器工具都使用此文件来访问容器注册表。
- en: It is possible to run the `podman` `login` command multiple times to log in
    to multiple registries, storing the login information in the same authorization
    file with a different stanza.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 可以多次运行 `podman login` 命令以登录多个注册表，并将登录信息存储在同一个授权文件的不同部分中。
- en: Note Podman supports other mechanisms for storing the password information.
    These are called *credential helpers*.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 Podman 支持其他存储密码信息的机制。这些被称为 *凭证助手*。
- en: 'After you are done using the registry, you can log out by executing `podman`
    `logout`. This command deletes the cached credentials stored in the auth.json
    file:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 使用完注册表后，你可以通过执行 `podman logout` 来注销。此命令会删除存储在 auth.json 文件中的缓存凭证：
- en: '[PRE47]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Some notable `podman` `login` and `logout` options include the following:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 一些值得注意的 `podman login` 和 `logout` 选项包括以下内容：
- en: '`--username`, `(-u`—This provides the Podman username to use when logging into
    the registry.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--username`，`(-u)`—这提供了在登录注册表时使用的 Podman 用户名。'
- en: '`--authfile`—This tells Podman to store the authorization file in a different
    location. You can also use the `REGISTRY_AUTH_FILE` environment variable to change
    the location.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--authfile`—这告诉 Podman 将授权文件存储在不同的位置。你也可以使用 `REGISTRY_AUTH_FILE` 环境变量来更改位置。'
- en: '`--all`—This allows you to log out of all of the registries.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--all`—这允许你注销所有注册表。'
- en: Use the `man` `podman-login` and `man` `podman-logout` commands for information
    about all options.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `man podman-login` 和 `man podman-logout` 命令获取所有选项的信息。
- en: 'Notice when you pushed the image to a container registry, you renamed `myimage`
    to quay.io/rhatdan/myimage:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 注意当你将镜像推送到容器注册表时，你将 `myimage` 重命名为 quay.io/rhatdan/myimage：
- en: '[PRE48]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: It’d be nice to just have the local image named quay.io/rhatdan/myimage, in
    which case you could have just executed
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，如果只是有一个名为 quay.io/rhatdan/myimage 的本地镜像，那么你就可以直接执行
- en: '[PRE49]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In the next section, you will learn how to add names to images.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将学习如何为镜像添加名称。
- en: 2.2.6 Tagging images
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.6 镜像标记
- en: Earlier in this chapter, I pointed out that locally created images are created
    with a localhost registry. Images get created with the localhost registry when
    you commit a container to an image or if you use `podman` `build` to build an
    image. Podman has a mechanism to add additional names to images; it calls these
    names tags, and the command is `podman` `tag`.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面，我指出本地创建的镜像使用 localhost 注册表创建。当你将容器提交为镜像或使用 `podman build` 命令构建镜像时，镜像会使用
    localhost 注册表创建。Podman 有一个机制来为镜像添加额外的名称；它将这些名称称为标签，命令是 `podman tag`。
- en: 'Using the `podman` `images` command, list the image(s) in container/storage:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `podman images` 命令，在 container/storage 中列出镜像（们）：
- en: '[PRE50]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'You will want the final image you plan on shipping to be referred to as quay.io/rhatdan/
    myimage. To achieve this, add that name with the following `podman` `tag` command:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望最终计划发布的镜像被称为 quay.io/rhatdan/myimage。为了实现这一点，使用以下 `podman tag` 命令添加该名称：
- en: '[PRE51]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now run `podman` `images` again to examine the images. You will see that the
    name is now quay.io/rhatdan/myimage. Notice that the localhost/myimage and quay.io/
    rhatdan/myimage have the same image ID of `2c7e43d88038`:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次运行 `podman images` 来检查镜像。你会看到名称现在是 quay.io/rhatdan/myimage。注意 localhost/myimage
    和 quay.io/rhatdan/myimage 有相同的镜像 ID `2c7e43d88038`：
- en: '[PRE52]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Since the images have the same image ID, they are the same image with multiple
    names. Now you can interact directly with quay.io/rhatdan/myimage. First, you
    need to log back in to quay.io:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些图像具有相同的图像ID，它们是具有多个名称的同一图像。现在您可以直接与quay.io/rhatdan/myimage交互。首先，您需要重新登录到quay.io：
- en: '[PRE53]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now push without requiring the destination name:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在无需指定目标名称即可推送：
- en: '[PRE54]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: That was much simpler.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常简单。
- en: 'Let’s tag the previously used image with a version, 1.0:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给之前使用的镜像添加一个版本号，1.0：
- en: '[PRE55]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Once again, examine the images; notice that `myimage` now has three different
    names/tags. All three have the same image ID of `2c7e43d88038`:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 再次检查图像；注意`myimage`现在有三个不同的名称/标签。所有三个都具有相同的图像ID `2c7e43d88038`：
- en: '[PRE56]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now you can push the 1.0 version of the `myimage` (application) to the registry:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以将`myimage`（应用程序）的1.0版本推送到注册库：
- en: '[PRE57]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Users can pull either the latest image or the 1.0 version. Later, when you build
    version 2.0 of your application, you can store both images at the registry. You
    can run both version 1.0 and 2.0 of your application on the host at the same time.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以拉取最新版本或1.0版本。稍后，当您构建应用程序的2.0版本时，您可以在注册库中存储这两个镜像。您可以在主机上同时运行应用程序的1.0和2.0版本。
- en: 'Use a web browser (e.g., Firefox, Chrome, Safari, Internet Explorer, or Microsoft
    Edge) to look at the images at quay.io. You can see 1.0 and the latest image in
    figure 2.4:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 使用网络浏览器（例如，Firefox、Chrome、Safari、Internet Explorer或Microsoft Edge）查看quay.io上的镜像。您可以在图2.4中看到1.0和最新版本：
- en: '[PRE58]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '![](../../OEBPS/Images/02-04.png)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/02-04.png)'
- en: Figure 2.4 List of `myimage` tags on quay.io ([https://quay.io/repository/rhatdan/myimage/?tab=tags](https://quay.io/repository/rhatdan/myimage/?tab=tags))
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 quay.io上`myimage`标签列表（[https://quay.io/repository/rhatdan/myimage/?tab=tags](https://quay.io/repository/rhatdan/myimage/?tab=tags)）
- en: Now that you have pushed your image to a container registry, you may want to
    free up storage from your home directory by removing the images.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经将镜像推送到容器注册库，您可能想通过删除镜像来释放您主目录中的存储空间。
- en: Note Contrary to common sense, the tag `latest` does not refer to the most up-to-date
    image in the repository. It is just another tag with no magic involved. Even worse,
    because it is being used as a default tag for images pushed without tags, it could
    refer to any random version of an image. There could be newer images in the container
    registry than your local container’s storage with this tag. Thus, it is always
    better to refer to the specific version of the image you want to use, rather than
    relying on the `latest`.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：与常识相反，标签`latest`并不指向存储库中最新的镜像。它只是一个没有魔力的普通标签。更糟糕的是，因为它被用作未标记推送的镜像的默认标签，它可能指向任何随机的镜像版本。使用此标签，容器注册库中可能有比您本地容器存储空间中更新的镜像。因此，始终最好指定您想要使用的特定图像版本，而不是依赖`latest`。
- en: 2.2.7 Removing images
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.7 删除镜像
- en: 'Over time, images can take up a lot of disk space. Thus, it will be a good
    idea to remove images you no longer use. Let’s list local images first:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，镜像可能会占用大量的磁盘空间。因此，删除不再使用的镜像将是一个好主意。让我们首先列出本地镜像：
- en: '[PRE59]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Use the `podman` `rmi` command to remove local images:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`podman`的`rmi`命令删除本地镜像：
- en: '[PRE60]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Listing the local images again, you will see that the command didn’t actually
    remove the image but only the `localhost` tag from the image. Podman still has
    two references to the same image ID: the actual content of the image has not been
    removed. None of the disk space was freed up:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 再次列出本地镜像，您会看到命令实际上并没有删除图像，只是从图像中删除了`localhost`标签。Podman仍然有两个对同一图像ID的引用：图像的实际内容尚未删除。没有释放任何磁盘空间：
- en: '[PRE61]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'You can remove the other tags using a short name (see section 2.2.8). Podman
    uses the short name and finds the first name in local storage that matches the
    short name without a registry and removes it, which is why I need to remove it
    twice to get rid of both images. Tags other than `latest` need to be specified
    explicitly:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用简短名称删除其他标签（参见第2.2.8节）。Podman使用简短名称，并在本地存储中找到与简短名称匹配的第一个名称（无注册表），然后将其删除，这就是为什么我需要删除两次才能去除两个图像。除了`latest`之外的标签需要明确指定：
- en: '[PRE62]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'It is only when the last tag is removed that the actual disk space is reclaimed:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当最后一个标签被删除时，实际的磁盘空间才会被回收：
- en: '[PRE63]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Alternatively, you can try removing the images by specifying the image ID:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以通过指定图像ID来尝试删除图像：
- en: '[PRE64]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'But that fails because there are multiple tags for the same image. Adding the
    `--force` option removes the image and all of its tags:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 但这失败了，因为同一图像有多个标签。添加`--force`选项将删除图像及其所有标签：
- en: '[PRE65]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'As your image sizes and numbers grow and more containers are created, it becomes
    harder to figure out which images are no longer needed. Podman has another useful
    command—`podman` `image` `prune`—for removing all dangling images. *Dangling images*
    are images that no longer have a tag associated with them or a container using
    them. The `prune` command also has the `--all` option, which removes all images
    that are currently not in use by any containers, including dangling images:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你的镜像大小和数量增长以及创建更多容器，确定哪些镜像不再需要变得更加困难。Podman 有另一个有用的命令—`podman` `image` `prune`—用于移除所有悬挂镜像。*悬挂镜像*是指不再与任何标签相关联或被任何容器使用的镜像。`prune`
    命令也有 `--all` 选项，它移除所有当前未被任何容器使用的镜像，包括悬挂镜像：
- en: '[PRE66]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Note Having no containers running the `podman` `image` `prune` command removes
    all of the local images. This frees up all of the disk space in the home directory.
    You can use the `podman` `system` `df` command to show all of the storage in your
    home directory used by Podman.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：没有运行容器时，使用 `podman` `image` `prune` 命令会移除所有本地镜像。这会释放主目录中的所有磁盘空间。你可以使用 `podman`
    `system` `df` 命令来显示 Podman 在主目录中使用的所有存储。
- en: '[PRE67]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Some notable `podman` `image` `prune` options include the following:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 一些显著的 `podman` `image` `prune` 选项包括以下内容：
- en: '`--all`—This tells Podman to remove all images, freeing up all storage. Images
    that have containers running on them are not removed.'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--all`—这告诉 Podman 移除所有镜像，释放所有存储空间。运行在镜像上的容器不会被移除。'
- en: '`--force`—This tells Podman to stop and remove any containers that are running
    on them and remove any images dependent on the image you are attempting to remove.'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--force`—这告诉 Podman 停止并移除任何正在运行的容器，并移除任何依赖于你试图删除的镜像的镜像。'
- en: Use the `man` `podman-image-prune` command for information about all options.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `man` `podman-image-prune` 命令获取有关所有选项的信息。
- en: Images pushed to the registry could also be pulled for various reasons, including
    but not limited to sharing your applications with others, testing other versions,
    getting back removed local versions, and working on a new version of an image.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 推送到注册库的镜像也可能因各种原因而被拉取，包括但不限于与他人共享应用程序、测试其他版本、恢复已删除的本地版本以及开发镜像的新版本。
- en: 2.2.8 Pulling images
  id: totrans-355
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.8 拉取镜像
- en: 'Although you previously removed all local images, you can pull the previously
    pushed image at quay.io/rhatdan/myimage. Podman has the `podman` `pull` command
    to pull images from container registries (transports) into local container storage:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你之前已经移除了所有本地镜像，但你仍然可以拉取之前推送到 quay.io/rhatdan/myimage 的镜像。Podman 有 `podman`
    `pull` 命令，可以从容器注册库（传输）拉取镜像到本地容器存储：
- en: '[PRE68]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Does the output look familiar? You probably remember similar output from the
    `podman` `run` command from section 2.1.2:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来熟悉吗？你可能记得 2.1.2 节中 `podman` `run` 命令的类似输出：
- en: '[PRE69]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Many Podman commands implicitly execute the `podman` `pull` command if the required
    image is not present locally.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 Podman 命令在本地没有所需镜像时会隐式执行 `podman` `pull` 命令。
- en: 'So executing `podman` `images` shows the image back in container storage, ready
    to be used for containers:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `podman` `images` 命令会显示容器存储中的镜像，准备用于容器：
- en: '[PRE70]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Up until now, you have been typing the image with the full names as registry.access
    .redhat.com/ubi8/httpd-24 or quay.io/rhatdan/myimage, but if you are like me and
    not a great typist, this can be a pain. You really need a way to refer to the
    images via short names.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你一直使用完整的名称作为镜像，例如 registry.access.redhat.com/ubi8/httpd-24 或 quay.io/rhatdan/myimage，但如果你像我一样不是打字高手，这可能会很痛苦。你真的需要一个方法通过短名称来引用镜像。
- en: Short names and container registries
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 短名称和容器注册库
- en: When Docker first hit the scene, they defined an image reference as a combination
    of the container registry where the image was stored, repository, image name,
    and a tag or version of the image. In our examples, we have been using quay.io/rhatdan/myimage.
    In table 2.4, you can see this image name breakdown; note that the `latest` tag
    was used implicitly, as the image version wasn’t specified.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Docker 首次出现时，它们定义了一个镜像引用为存储镜像的容器注册库、仓库、镜像名称以及镜像的标签或版本的组合。在我们的示例中，我们一直在使用 quay.io/rhatdan/myimage。在表
    2.4 中，你可以看到这个镜像名称的分解；注意，`latest` 标签是隐式使用的，因为未指定镜像版本。
- en: Table 2.4 Container image name table
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.4 容器镜像名称表
- en: '| Registry | Repository | Name | Tag |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| 注册库 | 仓库 | 名称 | 标签 |'
- en: '| quay.io | rhatdan | myimage | `latest` |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| quay.io | rhatdan | myimage | `latest` |'
- en: The Docker command line has internally set the docker.io registry as the only
    registry, thus making every short image name refer to images at docker.io. There
    is also a special repository library, which is used for certified images.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: Docker命令行内部已将docker.io注册表设置为唯一注册表，因此使得每个短镜像名称都指向docker.io上的镜像。还有一个特殊的仓库库，用于存储认证镜像。
- en: So rather than typing
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，您不必输入
- en: '[PRE71]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: You can just execute
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 您只需执行
- en: '[PRE72]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Conversely, if you want to pull an image from a different registry, you need
    to specify the full name of the image:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果您想从不同的注册表拉取镜像，您需要指定镜像的完整名称：
- en: '[PRE73]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Table 2.5 shows the difference between the image name used in a short name versus
    the fully specified image name. Notice that when using the short name, the registry,
    repository, and tag were not specified.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.5显示了短名使用的镜像名称与完全指定的镜像名称之间的区别。请注意，当使用短名时，注册表、仓库和标签都没有指定。
- en: Table 2.5 Short name to container image name table
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.5 短名到容器镜像名称表
- en: '| Registry | Repository | Name | Tag |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '| 注册表 | 仓库 | 名称 | 标签 |'
- en: '|  |  | alpine |  |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '|  |  | alpine |  |'
- en: '| docker.io | library | alpine | `latest` |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '| docker.io | library | alpine | `latest` |'
- en: Since I am lazy and hate to type extra characters, I almost always use short
    names. With Podman, the developers did not want to hardcode one registry, docker.io,
    into the tool. Podman allows distributions, companies, and you to control which
    registries to use and to be able to configure multiple registries. At the same
    time, Podman provides support for the easier-to-use short names.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我懒惰且不喜欢输入额外的字符，我几乎总是使用短名。在Podman中，开发者不想将一个注册表，docker.io，硬编码到工具中。Podman允许发行版、公司和您控制要使用的注册表，并能够配置多个注册表。同时，Podman提供了对易于使用的短名的支持。
- en: 'Podman usually comes with multiple registries defined, controlled by the distribution
    that packaged Podman. You can use the `podman` `info` command to see what registries
    are defined for your Podman installation:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: Podman通常包含多个注册表定义，由打包Podman的发行版控制。您可以使用`podman` `info`命令查看为您的Podman安装定义了哪些注册表：
- en: '[PRE74]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The list of registries can be modified in the registries.conf file, which is
    described in section 5.2.1.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 注册表列表可以在`registries.conf`文件中修改，该文件在5.2.1节中有所描述。
- en: 'Let’s discuss the security side of things using these commands:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这些命令来讨论安全方面的问题：
- en: '[PRE75]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: From a security perspective, it is always better to specify the full image name
    when pulling it from a registry. That way, Podman guarantees that it pulls from
    the specified registry. Imagine you are attempting to pull rhatdan/myimage. Using
    the previous search order, there is a chance someone could set up an account on
    docker.io/rhatdan and trick you into mistakenly pulling docker.io/rhatdan/myimage.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 从安全角度考虑，在从注册表中拉取镜像时始终指定完整镜像名称总是更好的。这样，Podman可以保证它从指定的注册表拉取。想象一下，您正在尝试拉取rhatdan/myimage。使用之前的搜索顺序，有人可能在docker.io/rhatdan上设置了一个账户，并诱使您错误地拉取docker.io/rhatdan/myimage。
- en: 'To help protect against this, on the first pull of an image, Podman prompts
    you to select an exact image from the list of found images in configured registries:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助防止这种情况，在第一次拉取镜像时，Podman会提示您从配置的注册表中找到的镜像列表中选择一个确切的镜像：
- en: '[PRE76]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Once you have selected and pulled an image successfully, Podman records the
    short name mapping. In the future, when you run a container with this short name,
    Podman uses the short name mapping to pick the correct registry and does not prompt.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您成功选择并拉取了镜像，Podman会记录短名映射。在未来，当您使用此短名运行容器时，Podman会使用短名映射来选择正确的注册表，而不会提示。
- en: 'Linux distributions also ship mappings of the most commonly used short names,
    as they want you to pull from their supported registries. You can find these short
    name configuration files in the /etc/containers/registries.conf.d directory on
    the Linux host. Companies can also drop short name alias files in this directory:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: Linux发行版还提供了最常用短名的映射，因为它们希望您从它们支持的注册表中拉取。您可以在Linux主机上的`/etc/containers/registries.conf.d`目录中找到这些短名配置文件。公司也可以将短名别名文件放入此目录：
- en: '[PRE77]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Some notable `podman` `pull` options include the following:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 一些显著的`podman` `pull`选项包括以下内容：
- en: '`--arch`—This tells Podman to pull an image for a different architecture. For
    example, on my x86_64 machine, I can pull an arm64 image. By default, `podman`
    `pull` pulls images for the native architecture.'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--arch`——这告诉Podman为不同的架构拉取镜像。例如，在我的x86_64机器上，我可以拉取arm64镜像。默认情况下，`podman` `pull`命令会拉取本地架构的镜像。'
- en: '`--quiet` `(-q``)`—This tells Podman not to print out all the progress information.
    It just prints the image ID when it completes.'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--quiet` `(-q)` — 这告诉 Podman 完成时不要打印所有进度信息。它只打印镜像 ID。'
- en: Use the `man` `podman-pull` command for information about all options.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `man podman-pull` 命令获取所有选项的信息。
- en: I have mentioned a few images in this book, but there are thousands and thousands
    of images available. You need a mechanism to be able to search through these images
    for the perfect match.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这本书中提到了一些镜像，但可供选择的有成千上万。您需要一个机制来搜索这些镜像以找到完美的匹配。
- en: 2.2.9 Searching for images
  id: totrans-398
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.9 搜索镜像
- en: 'You might not know the name of a particular image you want to run or use as
    a base for your own image. Podman provides the command `podman` `search`, which
    allows you to search container registries for matching names:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能不知道要运行或用作自己镜像基础的特定镜像的名称。Podman 提供了 `podman search` 命令，允许您在容器注册库中搜索匹配的名称：
- en: '[PRE78]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: In this example, we are searching for images that include the string *httpd*
    in their name on the repository registry.access.redhat.com.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们正在搜索在 repository.registry.access.redhat.com 仓库中名称包含字符串 *httpd* 的镜像。
- en: 'Some notable `podman` `search` options include the following:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 一些显著的 `podman search` 选项包括以下内容：
- en: '`--no-trunc`—This tells Podman to show the full description of the image.'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--no-trunc` — 这告诉 Podman 显示镜像的完整描述。'
- en: '`--format`—This allows you to customize which fields are displayed by Podman.'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--format` — 这允许您自定义 Podman 显示的字段。'
- en: Use the `man` `podman-search` command for information about all options.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `man podman-search` 命令获取所有选项的信息。
- en: Up until now, you have seen several ways of managing and manipulating container
    images, including inspecting, pushing, pulling, and searching for them. But you
    have only been able to look at the contents of an image by running it as a container.
    One way to simplify the process is mounting a container image.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经看到了几种管理和操作容器镜像的方法，包括检查、推送、拉取和搜索它们。但您只能通过将其作为容器运行来查看镜像的内容。简化此过程的一种方法是将容器镜像挂载。
- en: 2.2.10 Mounting images
  id: totrans-407
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.10 挂载镜像
- en: Often you might want to examine the contents of a container image, and one way
    to do this is launching a shell inside a running container from the image. The
    problem with this is that the tools you use to examine the container image might
    not be available within the container. There is also a security risk that the
    application in the container is malicious, making use of this container undesirable.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您可能想要检查容器镜像的内容，一种方法是启动一个运行中的容器内的 shell。但问题是，您用于检查容器镜像的工具可能不在容器内可用。此外，还存在一个安全风险，即容器中的应用程序可能是恶意的，这使得使用此容器不受欢迎。
- en: To help with these problems, Podman provides the `podman` `image` `mount` command
    to mount an image’s root filesystem in a read-only mode without creating a container
    from it. The mounted image becomes immediately available on the host system, allowing
    you to examine its contents.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助解决这些问题，Podman 提供了 `podman image mount` 命令，可以在不创建容器的情况下以只读模式挂载镜像的根文件系统。挂载的镜像将立即在主机系统上可用，允许您检查其内容。
- en: 'Now try mounting the image you pulled previously:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试挂载您之前拉取的镜像：
- en: '[PRE79]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The reason for this error is that rootless mode does not allow mounting images.
    You need to enter a user namespace and separate mount namespace. Chapter 5 explains
    how most rootless Podman commands enter the user namespace and mount namespace
    when they execute. For now, it is enough to know that the `podman` `unshare` command
    enters the user and mount namespaces and will shut down when you execute the `exit`
    command of your shell.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 出现此错误的原因是，无根模式不允许挂载镜像。您需要进入用户命名空间和单独的挂载命名空间。第 5 章解释了大多数无根 Podman 命令在执行时如何进入用户命名空间和挂载命名空间。现在，只需知道
    `podman unshare` 命令进入用户和挂载命名空间，并在您执行 shell 的 `exit` 命令时关闭即可。
- en: Note The name `unshare` comes from the Linux syscall `unshare` (`man` `2` `unshare`).
    Linux also includes an unshare tool (`man` `1` `unshare`), which allows you to
    create namespaces by hand. Another low-level tool called `nsenter`, or namespace
    enter (`man` `1` `nsenter`), allows you to join processes to different namespaces.
    Podman `unshare` uses the same kernel features. It simplifies the process of creating
    and configuring namespaces and inserting processes into the namespaces.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：名称 `unshare` 来自 Linux 系统调用 `unshare` (`man` `2` `unshare`)。Linux 还包括一个名为
    `unshare` 的工具 (`man` `1` `unshare`)，它允许你手动创建命名空间。另一个名为 `nsenter` 的低级工具，或称为命名空间进入
    (`man` `1` `nsenter`)，允许你将进程加入到不同的命名空间中。Podman `unshare` 使用相同的内核功能。它简化了创建和配置命名空间以及将进程插入命名空间的过程。
- en: 'The `podman` `unshare` command leaves you at a `#` prompt, where you can actually
    mount an image:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '`podman` 的 `unshare` 命令将你置于一个 `#` 提示符，在那里你可以实际挂载一个镜像：'
- en: '[PRE80]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Mount the image, and save the location of the mounted filesystem in an environment
    variable:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 挂载镜像，并将挂载的文件系统位置保存在一个环境变量中：
- en: '[PRE81]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Now you can actually examine the content of the image. Let’s print the contents
    of a file on the terminal:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你实际上可以检查镜像的内容。让我们在终端上打印一个文件的目录：
- en: '[PRE82]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'When you are done, unmount the image, and exit the unshare session:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成时，卸载镜像，并退出 `unshare` 会话：
- en: '[PRE83]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Note You have examined about a half of the `podman` `image` subcommands, arguably
    the most used ones. Refer to the Podman man pages for a full explanation of these
    and other subcommands of the `podman` `image` command: `$` `man` `podman-image`.'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你已经检查了大约一半的 `podman` `image` 子命令，可以说是最常用的。请参考 Podman 的 man 页面以获取这些和其他 `podman`
    `image` 命令子命令的完整解释：`$` `man` `podman-image`。
- en: Now that you have a better understanding of containers and images, the next
    important step is updating your image. The main reasons for this are the need
    to update your application and the availability of new versions for the base image
    you use. You can build scripts to manually run the commands to build the image,
    but luckily, Podman optimized the experience.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对容器和镜像有了更好的理解，下一步重要的步骤是更新你的镜像。主要原因包括需要更新你的应用程序以及你使用的基镜像的新版本可用。你可以编写脚本来手动运行构建镜像的命令，但幸运的是，Podman
    优化了这一体验。
- en: 2.3 Building images
  id: totrans-424
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 构建镜像
- en: So far you have been working with images, which were already created and uploaded
    to a container registry. The process of creating a container image is called *building*.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你一直在处理已经创建并上传到容器注册库的镜像。创建容器镜像的过程称为 *构建*。
- en: When building container images, you manage not only your application but also
    the image content used by this application. In the days prior to containers, you
    shipped applications as an RPM or DEB package, and then it was up to the distribution
    to make sure the other parts of the OS were kept up to date and secure. But in
    the container world, the container image includes the application along with a
    subset of the OS. It is the developers’ responsibility to keep all of the image
    contents up to date and secure.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建容器镜像时，你不仅要管理你的应用程序，还要管理该应用程序使用的镜像内容。在容器出现之前，你将应用程序作为 RPM 或 DEB 软件包分发，然后由发行版负责确保操作系统的其他部分保持最新和安全。但在容器世界中，容器镜像包括了应用程序以及操作系统的子集。保持镜像内容最新和安全是开发者的责任。
- en: A coworker of mine, Scott McCarty (smccarty@redhat.com, @fatherlinux), has a
    saying, “Container images don’t age like wine but more like cheese. As the image
    gets older it gets stinky.”
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 我的同事 Scott McCarty（smccarty@redhat.com，@fatherlinux）有一句话，“容器镜像不像葡萄酒那样越陈越香，更像奶酪。随着镜像变老，它变得越来越臭。”
- en: This means that if the developer doesn’t keep up with the security updates,
    the number of vulnerabilities in the image will grow at an alarming rate. Luckily
    for developers, Podman has a special mechanism for helping you with image building
    for your applications. The `podman` `build` command uses the Buildah tool ([https://github.com/containers/buildah](https://github.com/containers/buildah))
    as a library to build container images; Buildah is covered in appendix A.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果开发者没有跟上安全更新，镜像中的漏洞数量将以惊人的速度增长。幸运的是，对于开发者来说，Podman 有一个特殊的机制来帮助你为应用程序构建镜像。`podman`
    的 `build` 命令使用 Buildah 工具 ([https://github.com/containers/buildah](https://github.com/containers/buildah))
    作为库来构建容器镜像；Buildah 的内容在附录 A 中介绍。
- en: The `podman` `build` uses a special text document called Containerfile or Dockerfile
    to automate the building of container images. This document lists commands used
    to build a container image.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '`podman` `build` 使用一种特殊的文本文档，称为 Containerfile 或 Dockerfile，来自动化容器镜像的构建。该文档列出了构建容器镜像所使用的命令。'
- en: 'Note The concept of a Dockerfile and its syntax was originally created for
    the Docker tool, developed by Docker, Inc. Podman defaults to using Containerfile
    for the name, which uses the exact same syntax. Dockerfile is supported as well
    for legacy purposes. The Docker build command does not support Containerfile by
    default but can use the Containerfile. You can specify the `-f` option: `#` `docker`
    `build` `-f` `Containerfile.`'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Dockerfile 及其语法的概念最初是为 Docker 工具创建的，该工具由 Docker, Inc. 开发。Podman 默认使用 Containerfile
    作为名称，它使用完全相同的语法。Dockerfile 也支持作为向后兼容。Docker 构建命令默认不支持 Containerfile，但可以使用 Containerfile。你可以指定
    `-f` 选项：`#` `docker` `build` `-f` `Containerfile.`
- en: 2.3.1 Format of a Containerfile or Dockerfile
  id: totrans-431
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.1 Containerfile 或 Dockerfile 的格式
- en: Containerfiles take many directives. I break these down into two categories,
    adding content to the container image and describing and documenting how to use
    the image.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: Containerfiles 包含许多指令。我将这些指令分为两类，一类是向容器镜像添加内容，另一类是描述和记录如何使用该镜像。
- en: Adding content to an image
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 向镜像添加内容
- en: Recall back in section 1.1.2 that I described a container image as a tdirectory
    on disk that looks like root on a Linux system. This directory is called a rootfs.
    Several of the directives in a container job are adding content to this rootfs.
    This rootfs eventually contains all of the content used to create your container
    image.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，在第 1.1.2 节中，我描述了容器镜像为一个类似于 Linux 系统上的根目录的磁盘上的目录。这个目录被称为 rootfs。容器作业中的许多指令都是向这个
    rootfs 添加内容。这个 rootfs 最终包含创建你的容器镜像所使用的所有内容。
- en: Every Containerfile must include a `FROM` line. The `FROM` line specifies the
    image that the new image is based off, often called a base image. The `podman`
    `build` command supports a special image named `scratch`, which means to start
    your image with no content. When Podman sees the `FROM` `scratch` directive, it
    just allocates space in containers/storage for an empty rootfs, then `COPY` can
    be used to populate the rootfs. More often, the `FROM` directive uses an existing
    image. For example, `FROM` `registry.access.redhat.com/ubi8` causes Podman to
    pull the ubi8 image from the registry.access.redhat.com container registry and
    copy it to container storage. `podman` `build` pulls the same image as the `podman`
    `pull` command you learned about in section 2.2.8\. When the image is pulled,
    Podman uses container storage to mount the image on the rootfs directory, using
    a copy on the write filesystem, like OverlayFS, where the other directives can
    start to add content. This image becomes the base layer of the rootfs.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Containerfile都必须包含一个`FROM`行。`FROM`行指定了新镜像基于的镜像，通常称为基础镜像。`podman` `build` 命令支持一个名为`scratch`的特殊镜像，这意味着以无内容的方式开始你的镜像。当
    Podman 看到指定的`FROM scratch`指令时，它只是在容器存储中为空根文件系统分配空间，然后可以使用`COPY`来填充根文件系统。更常见的是，`FROM`指令使用现有的镜像。例如，`FROM
    registry.access.redhat.com/ubi8`会导致 Podman 从 registry.access.redhat.com 容器注册库中拉取
    ubi8 镜像并将其复制到容器存储中。`podman` `build` 拉取与你在第 2.2.8 节中学习的`podman` `pull`命令相同的镜像。当镜像被拉取时，Podman
    使用容器存储在根文件系统目录上挂载镜像，使用类似于 OverlayFS 的写时复制文件系统，这样其他指令就可以开始添加内容。这个镜像成为根文件系统的底层。
- en: The `COPY` directive is often used to copy files, directories, or tarballs off
    of the local host into the newly created rootfs. The `RUN` directive is one of
    the most commonly used Containerfile directives. `RUN` tells Podman to actually
    run a container on the image. Package management tools, like DNF/YUM and `apt-get`,
    are run to install packages from distributions onto your new image. The `RUN`
    directive runs any command within the container image as a container. The `podman`
    `build` command runs the commands with the same security constraints as the `podman`
    `run` command.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '`COPY` 指令通常用于将文件、目录或 tarball 从本地主机复制到新创建的 rootfs 中。`RUN` 指令是 Containerfile
    中最常用的指令之一。`RUN` 指令告诉 Podman 在镜像上实际运行一个容器。像 DNF/YUM 和 `apt-get` 这样的包管理工具被用来将发行版的软件包安装到你的新镜像中。`RUN`
    指令在容器镜像中运行任何命令作为容器。`podman` `build` 命令使用与 `podman` `run` 命令相同的权限约束来运行命令。'
- en: 'As an example, imagine you want to add the `ps` command to a container image;
    you can create a directive like the following. The `RUN` command executes a container,
    which updates all of the packages from the base image, and then installs the `procps-ns`
    package, which includes the `ps` command. Finally the containerized command executes
    `yum` to clean up after itself, so cruft is removed from the container image:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您想向容器镜像添加`ps`命令；您可以创建如下所示的指令。`RUN`命令执行容器，更新基础镜像中的所有包，然后安装包含`ps`命令的`procps-ns`包。最后，容器化命令执行`yum`来自动清理，从而从容器镜像中移除冗余：
- en: '[PRE84]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Adding content to the container image is only half of what you need to do when
    creating a container image. You also need to describe and document how the image
    will be used when other users download and run your image.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建容器镜像时，向容器镜像添加内容只是您需要完成的一半工作。您还需要描述和记录其他用户下载并运行您的镜像时如何使用该镜像。
- en: Documenting how to use the image
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 记录如何使用镜像
- en: 'Recall that back in section 1.1.2, I also described the JSON file that included
    the image specification. This specification describes how the container image
    is to be run, the command, which user to run it with, and other requirements of
    the image. The Containerfile also supports many directives, which tells Podman
    how to run containers. These include the following:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，在1.1.2节中，我也描述了包含镜像规范的JSON文件。该规范描述了容器镜像的运行方式、命令、运行它的用户以及其他镜像要求。Containerfile也支持许多指令，这些指令告诉Podman如何运行容器。以下是一些指令：
- en: '*The* `ENTRYPOINT` *and* `CMD` *directives*—These instrument the image with
    the default command to be executed when users execute the image with Podman `run`.
    `CMD` is the actual command to run. `ENTRYPOINT` can cause the entire image to
    execute as a single command.'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*`ENTRYPOINT`* 和 *`CMD`* 指令——这些指令为用户使用Podman `run`执行镜像时默认要执行的命令配置了镜像。`CMD`是实际要运行的命令。`ENTRYPOINT`可以使整个镜像作为一个单独的命令执行。'
- en: '*The* `ENV` *directive*—This sets up the default environment variables to run
    when Podman runs a container on the image.'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*`ENV`* 指令——此指令设置Podman在镜像上运行容器时默认的环境变量。'
- en: '*The* `EXPOSE` *directive*—This records the network ports for Podman to expose
    in containers based on the image. If you execute `podman` `run` `--publish-all`
    `...`, Podman looks inside of the image for the `EXPOSE` network ports and connects
    them to the host.'
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*`EXPOSE`* 指令——此指令记录Podman在容器中基于镜像暴露的网络端口。如果您执行`podman run --publish-all ...`，Podman会在镜像内部查找`EXPOSE`网络端口并将它们连接到主机。'
- en: Table 2.6 explains the directives used in a Containerfile to add content to
    a container image.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.6解释了在Containerfile中用于向容器镜像添加内容的指令。
- en: Table 2.6 Containerfile directives that update the image
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.6更新镜像的Containerfile指令
- en: '| Directive examples | Explanation |'
  id: totrans-447
  prefs: []
  type: TYPE_TB
  zh: '| 指令示例 | 说明 |'
- en: '| `FROM` `quay.io/rhatdan/myimage` | Sets the base image for subsequent instructions.
    Containerfiles must have `FROM` as their first instruction. The `FROM` may appear
    multiple times within a single Containerfile to create multiple build stages.
    |'
  id: totrans-448
  prefs: []
  type: TYPE_TB
  zh: '| `FROM` `quay.io/rhatdan/myimage` | 设置后续指令的基础镜像。Containerfile必须以`FROM`作为其第一条指令。`FROM`可以在单个Containerfile中多次出现以创建多个构建阶段。|'
- en: '| `ADD` `start.sh` `/usr/bin/start.sh` | Copies new files, directories, or
    remote file URLs to the filesystem of the container at a specified path. |'
  id: totrans-449
  prefs: []
  type: TYPE_TB
  zh: '| `ADD` `start.sh` `/usr/bin/start.sh` | 将新文件、目录或远程文件URL复制到容器文件系统的指定路径。|'
- en: '| `COPY` `start.sh` `/usr/bin/start.sh` | Copies files to the filesystem of
    the container at a specified path. |'
  id: totrans-450
  prefs: []
  type: TYPE_TB
  zh: '| `COPY` `start.sh` `/usr/bin/start.sh` | 将文件复制到容器文件系统的指定路径。|'
- en: '| `RUN` `dnf` `-y` `update` | Executes commands in a new layer on top of the
    current image and commits the results. The committed image is used for the next
    step in the Containerfile. |'
  id: totrans-451
  prefs: []
  type: TYPE_TB
  zh: '| `RUN` `dnf` `-y` `update` | 在当前镜像之上执行新层的命令，并提交结果。提交的镜像用于Containerfile中的下一步。|'
- en: '| `VOLUME` `/var/lib/mydata` | Creates a mount point with the specified name
    and marks it as holding externally mounted volumes from the native host or from
    other containers. For more on volumes, see chapter 3. |'
  id: totrans-452
  prefs: []
  type: TYPE_TB
  zh: '| `VOLUME` `/var/lib/mydata` | 创建具有指定名称的挂载点，并将其标记为包含来自本地主机或其他容器的外部挂载卷。有关卷的更多信息，请参阅第3章。|'
- en: Table 2.7 explains the directives used in a Containerfile to populate the OCI
    Runtime Specifications with information that tells container engines like Podman
    information about the image and how to run the image. You can find much more information
    on Containerfiles in the `containerfile(5)` man page.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.7 解释了在 Containerfile 中使用的指令，这些指令用于将信息填充到 OCI 运行时规范中，以便容器引擎（如 Podman）了解镜像以及如何运行镜像。你可以在
    `containerfile(5)` 手册页中找到有关 Containerfile 的更多信息。
- en: Table 2.7 Containerfile directives that define the OCI Runtime Specification
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.7 定义 OCI 运行时规范的 Containerfile 指令
- en: '| Directive examples | Explanation |'
  id: totrans-455
  prefs: []
  type: TYPE_TB
  zh: '| 指令示例 | 说明 |'
- en: '| `CMD` `/usr/bin/start.sh` | Specifies the default command to run when launching
    a container off this image. If `CMD` is not specified, the parent image’s `CMD`
    is inherited. Note that `RUN` and `CMD` are very different. `RUN` runs the commands
    during the build process, while `CMD` is only used when a user launches the image
    without specifying a command. |'
  id: totrans-456
  prefs: []
  type: TYPE_TB
  zh: '| `CMD` `/usr/bin/start.sh` | 指定在从该镜像启动容器时运行的默认命令。如果没有指定 `CMD`，则继承父镜像的 `CMD`。请注意，`RUN`
    和 `CMD` 非常不同。`RUN` 在构建过程中运行命令，而 `CMD` 仅在用户启动镜像且未指定命令时使用。|'
- en: '| `ENTRYPOINT` `“/bin/sh -c”` | Allows you to configure a container to run
    as an executable. The `ENTRYPOINT` instruction is not overwritten when arguments
    are passed to `podman run`. This allows arguments to be passed to the entrypoint—for
    instance, `podman run <image> -d` passes the `-d` argument to the `ENTRYPOINT`.
    |'
  id: totrans-457
  prefs: []
  type: TYPE_TB
  zh: '| `ENTRYPOINT` `“/bin/sh -c”` | 允许你配置容器以可执行文件的方式运行。当向 `podman run` 传递参数时，`ENTRYPOINT`
    指令不会被覆盖。这允许将参数传递给入口点——例如，`podman run <image> -d` 将 `-d` 参数传递给 `ENTRYPOINT`。|'
- en: '| `ENV` `foo=”bar”` | Adds an environment variable to be used during both the
    image build and container execution. |'
  id: totrans-458
  prefs: []
  type: TYPE_TB
  zh: '| `ENV` `foo=”bar”` | 在镜像构建和容器执行期间添加一个环境变量。|'
- en: '| `EXPOSE` `8080` | Announces the port that containerized applications will
    be exposing. This does not actually map or open any ports. |'
  id: totrans-459
  prefs: []
  type: TYPE_TB
  zh: '| `EXPOSE` `8080` | 宣布容器化应用程序将要暴露的端口。这实际上不会映射或打开任何端口。|'
- en: '| `LABEL Description=”Web browser which displays Hello World”` | Adds metadata
    to an image. |'
  id: totrans-460
  prefs: []
  type: TYPE_TB
  zh: '| `LABEL Description=”Web browser which displays Hello World”` | 向镜像添加元数据。|'
- en: '| `MAINTAINER Daniel Walsh` | Sets the `Author` field for the generated images.
    |'
  id: totrans-461
  prefs: []
  type: TYPE_TB
  zh: '| `MAINTAINER Daniel Walsh` | 设置生成镜像的 `Author` 字段。|'
- en: '| `STOPSIGNAL SIGTERM` | Sets the default stop signal sent to the container
    to exit. The signal can be a valid unsigned number or a signal name in the format
    `SIGNAME`. |'
  id: totrans-462
  prefs: []
  type: TYPE_TB
  zh: '| `STOPSIGNAL SIGTERM` | 设置发送给容器以退出时的默认停止信号。信号可以是有效的无符号数字或格式为 `SIGNAME` 的信号名称。|'
- en: '| `USER apache` | Sets the user name (or UID) and group name (or GID) to use
    for any `RUN`, `CMD`, and `ENTRYPOINT` specified after it. |'
  id: totrans-463
  prefs: []
  type: TYPE_TB
  zh: '| `USER apache` | 设置用于任何 `RUN`、`CMD` 和 `ENTRYPOINT` 指定的用户名（或 UID）和组名（或 GID）。|'
- en: '| `ONBUILD` | Adds a trigger instruction to the image to be executed at a later
    time, when the image is used as the base for another build. |'
  id: totrans-464
  prefs: []
  type: TYPE_TB
  zh: '| `ONBUILD` | 向镜像添加一个触发指令，在稍后使用该镜像作为其他构建的基础时执行。|'
- en: '| `WORKDIR` /var/www/html | Sets the working directory for `RUN`, `CMD`, `ENTRYPOINT`,
    and `COPY` directives. A directory will be created if it doesn’t exist. |'
  id: totrans-465
  prefs: []
  type: TYPE_TB
  zh: '| `WORKDIR` /var/www/html | 设置 `RUN`、`CMD`、`ENTRYPOINT` 和 `COPY` 指令的工作目录。如果该目录不存在，将会创建它。|'
- en: Committing the image
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 提交镜像
- en: When `podman` `build` finishes processing the Containerfile, it commits the
    image, using the same code as `podman` `commit` you learned about in section 2.1.9\.
    Basically, Podman TARs up all of the differences between the new content in the
    rootfs and the base image, pulled down by the `FROM` directive. Podman also commits
    the JSON file and saves this as an image in container storage. Now you can take
    the steps used to build out containerized applications and automate them using
    a Containerfile and Podman build.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `podman` `build` 完成处理 Containerfile 后，它会提交镜像，使用与你在 2.1.9 节中学习的 `podman` `commit`
    相同的代码。基本上，Podman 将根文件系统中新内容与通过 `FROM` 指令拉取的基本镜像之间的所有差异打包成 TAR 文件。Podman 还会提交 JSON
    文件，并将其保存为容器存储中的镜像。现在你可以采取构建容器化应用程序的步骤，并使用 Containerfile 和 Podman 构建来自动化它们。
- en: Tip Use the `--tag` option to name the new image you are creating with `podman`
    `build`. This tells Podman to add the specified tag or name to the image in container
    storage in the same way as the `podman` `tag` command.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士 使用 `--tag` 选项通过 `podman` `build` 命令命名你正在创建的新镜像。这告诉 Podman 以与 `podman` `tag`
    命令相同的方式将指定的标签或名称添加到容器存储中的镜像。
- en: 2.3.2 Automating the building of our application
  id: totrans-469
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.2 自动化构建我们的应用程序
- en: 'First, create a directory to put your Containerfile and any other content for
    the container image in. The directory is called a context directory:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个目录来放置您的 Containerfile 以及任何其他用于容器镜像的内容。这个目录被称为上下文目录：
- en: '[PRE85]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Next, create the index.xhtml file you plan to use in the containerized application
    in the `myapp` directory:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 `myapp` 目录中创建您计划在容器化应用程序中使用的 index.xhtml 文件：
- en: '[PRE86]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Next, create a simple Containerfile to build your application in the `myapp`
    directory. The first line of the Containerfile is the `FROM` directive to pull
    the ubi8/httpd-24 image you are treating as your base image. Then add a `COPY`
    command to copy the index.xhtml file into the image. The `COPY` directive tells
    Podman to copy the index.xhtml file out of the context directory (./myapp) and
    copy it to the /var/www/html/index.xhtml file within the image:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 `myapp` 目录中创建一个简单的 Containerfile，用于构建您的应用程序。Containerfile 的第一行是 `FROM`
    指令，用于拉取您作为基础镜像的 ubi8/httpd-24 镜像。然后添加一个 `COPY` 命令，将 index.xhtml 文件复制到镜像中。`COPY`
    指令告诉 Podman 将 index.xhtml 文件从上下文目录（./myapp）复制出来，并将其复制到镜像内的 /var/www/html/index.xhtml
    文件中：
- en: '[PRE87]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Finally, use `podman` `build` to build your containerized application. Specify
    the `--tag` (`-t`) to name the image quay.io/rhatdan/myimage. You also need to
    specify the context directory ./myapp:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用 `podman` `build` 构建您的容器化应用程序。指定 `--tag` (`-t`) 来命名镜像为 quay.io/rhatdan/myimage。您还需要指定上下文目录
    ./myapp：
- en: '[PRE88]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: When the `podman` `build` command completes, it commits the image and tags (`-t`)
    it with the quay.io/rhatdan/myimage name. It is now ready to be pushed to the
    container registry using the `podman` `push` command.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `podman` `build` 命令完成后，它会提交镜像并使用 quay.io/rhatdan/myimage 名称对其进行标记。现在它已准备好使用
    `podman` `push` 命令将其推送到容器注册库。
- en: 'Now you can set up a CI/CD system or even a simple cron job to regularly build
    and replace `myapplication`:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以设置 CI/CD 系统，甚至一个简单的 cron 作业，以定期构建和替换 `myapplication`：
- en: '[PRE89]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Add some test scripts as well to make sure your application works the way it
    was designed before replacing the previous version. Let’s take a look at the images
    that were built:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一些测试脚本，以确保在替换上一个版本之前，您的应用程序按预期工作。让我们看看构建的镜像：
- en: '[PRE90]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Notice the old version of quay.io/rhatdan/myimage, image ID `2c7e43d88038`,
    still exists in container storage but now has a `REPOSITORY` and `TAG` of `<none>`
    `<none>`. Images like these are called dangling images. Since I have created a
    new version of quay.io/rhatdan/myimage with the `podman` `build` command, the
    previous image loses that name. You can still use the Podman commands with the
    image ID, or if the new image doesn’t work, simply use `podman` `tag` to rename
    the old image back to quay.io/ rhatdan/myimage. If the new image works correctly,
    you can remove the old image with `podman` `rmi`. These `<none><none>` images
    tend to build up over time, wasting space, but you can periodically use the `podman`
    `image` `prune` command to remove them.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，quay.io/rhatdan/myimage 的旧版本仍然存在于容器存储中，其镜像 ID 为 `2c7e43d88038`，但现在其 `REPOSITORY`
    和 `TAG` 都是 `<none>` `<none>`。这样的镜像被称为悬挂镜像。由于我已使用 `podman` `build` 命令创建了一个新的 quay.io/rhatdan/myimage
    版本，因此旧镜像失去了那个名称。您仍然可以使用带有镜像 ID 的 Podman 命令，或者如果新镜像不起作用，只需使用 `podman` `tag` 命令将旧镜像重命名为
    quay.io/ rhatdan/myimage。如果新镜像运行正确，您可以使用 `podman` `rmi` 命令删除旧镜像。这些 `<none><none>`
    镜像往往会随着时间的推移而积累，浪费空间，但您可以使用 `podman` `image` `prune` 命令定期删除它们。
- en: The `podman` `build` could really use a chapter or even a book to itself. People
    build images in thousands of different ways using the commands briefly described
    here.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '`podman` `build` 实际上需要一个章节，甚至一本书来专门介绍。人们使用这里简要描述的命令以数千种不同的方式构建镜像。'
- en: '`--tag` is a notable `podman` `build` option that specifies the image tag or
    name for the image. Remember that you can always add additional names after you
    create the image with the `podman` `tag` command you used in section 2.2.6\. Use
    the `man` `podman-build` command for information about all options (see table
    2.8).'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '`--tag` 是一个显著的 `podman` `build` 选项，用于指定镜像的标签或名称。请记住，您可以在使用 2.2.6 节中使用的 `podman`
    `tag` 命令创建镜像后添加额外的名称。使用 `man` `podman-build` 命令获取有关所有选项的信息（见表 2.8）。'
- en: Table 2.8 Podman image commands
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.8 Podman 镜像命令
- en: '| Command | Man page | Description |'
  id: totrans-487
  prefs: []
  type: TYPE_TB
  zh: '| 命令 | 手册页 | 描述 |'
- en: '| `build` | `podman-image-build(1)` | Builds an image using instructions from
    Containerfiles |'
  id: totrans-488
  prefs: []
  type: TYPE_TB
  zh: '| `build` | `podman-image-build(1)` | 使用容器文件中的指令构建镜像 |'
- en: '| `diff` | `podman-image-diff(1)` | Inspects changes in image’s filesystem
    |'
  id: totrans-489
  prefs: []
  type: TYPE_TB
  zh: '| `diff` | `podman-image-diff(1)` | 检查镜像文件系统的更改 |'
- en: '| `exists` | `podman-image-exists(1)` | Checks whether an image exists |'
  id: totrans-490
  prefs: []
  type: TYPE_TB
  zh: '| `exists` | `podman-image-exists(1)` | 检查镜像是否存在 |'
- en: '| `history` | `podman-image-history(1)` | Shows a history of a specified image
    |'
  id: totrans-491
  prefs: []
  type: TYPE_TB
  zh: '| `history` | `podman-image-history(1)` | 显示指定镜像的历史记录 |'
- en: '| `import` | `podman-image-import(1)` | Imports a tarball to create a filesystem
    image |'
  id: totrans-492
  prefs: []
  type: TYPE_TB
  zh: '| `import` | `podman-image-import(1)` | 从 tarball 导入以创建文件系统镜像 |'
- en: '| `inspect` | `podman-image-inspect(1)` | Displays the configuration of an
    image |'
  id: totrans-493
  prefs: []
  type: TYPE_TB
  zh: '| `inspect` | `podman-image-inspect(1)` | 显示镜像的配置 |'
- en: '| `list` | `podman-image-list(1)` | Lists all of the images |'
  id: totrans-494
  prefs: []
  type: TYPE_TB
  zh: '| `list` | `podman-image-list(1)` | 列出所有镜像 |'
- en: '| `load` | `podman-image-load(1)` | Loads image(s) from a tarball |'
  id: totrans-495
  prefs: []
  type: TYPE_TB
  zh: '| `load` | `podman-image-load(1)` | 从 tarball 加载镜像 |'
- en: '| `mount` | `podman-image-mount(1)` | Mounts an image’s root filesystem |'
  id: totrans-496
  prefs: []
  type: TYPE_TB
  zh: '| `mount` | `podman-image-mount(1)` | 挂载镜像的根文件系统 |'
- en: '| `prune` | `podman-image-prune(1)` | Removes unused images |'
  id: totrans-497
  prefs: []
  type: TYPE_TB
  zh: '| `prune` | `podman-image-prune(1)` | 删除未使用的镜像 |'
- en: '| `pull` | `podman-image-pull(1)` | Pulls an image from a registry |'
  id: totrans-498
  prefs: []
  type: TYPE_TB
  zh: '| `pull` | `podman-image-pull(1)` | 从仓库拉取镜像 |'
- en: '| `push` | `podman-image-push(1)` | Pushes an image to a registry |'
  id: totrans-499
  prefs: []
  type: TYPE_TB
  zh: '| `push` | `podman-image-push(1)` | 将镜像推送到仓库 |'
- en: '| `rm` | `podman-image-rm(1)` | Removes an image |'
  id: totrans-500
  prefs: []
  type: TYPE_TB
  zh: '| `rm` | `podman-image-rm(1)` | 删除镜像 |'
- en: '| `save` | `podman-image-save(1)` | Saves image(s) to an archive |'
  id: totrans-501
  prefs: []
  type: TYPE_TB
  zh: '| `save` | `podman-image-save(1)` | 将镜像保存到存档 |'
- en: '| `scp` | `podman-image-scp(1)` | Securely copies images to other containers/storage
    |'
  id: totrans-502
  prefs: []
  type: TYPE_TB
  zh: '| `scp` | `podman-image-scp(1)` | 安全地将镜像复制到其他容器/存储 |'
- en: '| `search` | `podman-image-search(1)` | Searches the registry for an image
    |'
  id: totrans-503
  prefs: []
  type: TYPE_TB
  zh: '| `search` | `podman-image-search(1)` | 在仓库中搜索镜像 |'
- en: '| `sign` | `podman-image-sign(1)` | Signs an image |'
  id: totrans-504
  prefs: []
  type: TYPE_TB
  zh: '| `sign` | `podman-image-sign(1)` | 签名镜像 |'
- en: '| `tag` | `podman-image-tag(1)` | Adds an additional name to a local image
    |'
  id: totrans-505
  prefs: []
  type: TYPE_TB
  zh: '| `tag` | `podman-image-tag(1)` | 向本地镜像添加额外的名称 |'
- en: '| `tree` | `podman-image-tree(1)` | Prints the layer hierarchy of an image
    in a tree format |'
  id: totrans-506
  prefs: []
  type: TYPE_TB
  zh: '| `tree` | `podman-image-tree(1)` | 以树形格式打印镜像的层层次结构 |'
- en: '| `trust` | `podman-image-trust(1)` | Manages container image trust policy
    |'
  id: totrans-507
  prefs: []
  type: TYPE_TB
  zh: '| `trust` | `podman-image-trust(1)` | 管理容器镜像信任策略 |'
- en: '| `unmount` | `podman-image-unmount(1)` | Unmounts an image’s root filesystem
    |'
  id: totrans-508
  prefs: []
  type: TYPE_TB
  zh: '| `unmount` | `podman-image-unmount(1)` | 卸载镜像的根文件系统 |'
- en: '| `untag` | `podman-image-untag(1)` | Removes a name from a local image |'
  id: totrans-509
  prefs: []
  type: TYPE_TB
  zh: '| `untag` | `podman-image-untag(1)` | 从本地镜像中移除一个名称 |'
- en: Summary
  id: totrans-510
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Podman’s simple command-line interface makes working with containers easy.
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Podman 简单的命令行界面使得与容器的工作变得容易。
- en: Podman `run`, `stop`, `start`, `ps`, `inspect`, `rm`, and `commit` are all commands
    for working with containers.
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Podman 的 `run`、`stop`、`start`、`ps`、`inspect`、`rm` 和 `commit` 都是用于处理容器的命令。
- en: Podman `pull`, `push`, `login`, and `rmi` are tools for working with images
    and sharing them via container registries.
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Podman 的 `pull`、`push`、`login` 和 `rmi` 是用于处理镜像并通过容器仓库共享它们的工具。
- en: Podman `build` is a great command for automating the build of container images.
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Podman 的 `build` 命令是自动化构建容器镜像的一个强大工具。
- en: Podman’s command line is based on the Docker CLI and supports it exactly, allowing
    us to tell people to just alias Docker = Podman.
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Podman 的命令行界面基于 Docker CLI，并完全支持它，这使得我们可以告诉人们只需将 Docker 别名为 Podman。
- en: Podman has additional commands and options to support more advanced concepts
    like `podman` `image` `mount`.
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Podman 有额外的命令和选项来支持更高级的概念，如 `podman` `image` `mount`。
