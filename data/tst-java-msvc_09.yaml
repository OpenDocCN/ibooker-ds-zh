- en: Chapter 10\. Continuous delivery in microservices
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第10章\. 微服务中的持续交付
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Using microservices in a continuous-delivery pipeline
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在持续交付管道中使用微服务
- en: Executing tests on the pipeline
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在管道上执行测试
- en: Understanding the coded pipeline
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解编码的管道
- en: Building the Jenkins pipeline
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建Jenkins管道
- en: Deploying services with certainty
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定性地部署服务
- en: We hope this book has broadened your insight and expanded your skill set for
    developing tests for a microservices architecture. The purpose of these tests
    is to enable changes to any service with the certainty that no regression has
    been introduced when you refactor, fix bugs, or add a new feature.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望这本书已经拓宽了您的视野，并扩展了您为开发微服务架构测试的技能集。这些测试的目的是确保在重构、修复错误或添加新功能时，不会引入任何回归。
- en: The questions now are when to execute the tests, where to execute them, and
    how the tests are related to the deployment of the production service. In this
    chapter, you’ll see how the traditional continuous delivery (CD) pipeline has
    evolved to serve a microservices architecture, and how to build a pipeline programmatically
    that focuses on test execution.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是何时执行测试，在哪里执行它们，以及测试如何与生产服务的部署相关。在本章中，您将了解传统的持续交付（CD）管道是如何演变为服务于微服务架构的，以及如何构建一个专注于测试执行的管道。
- en: We’ll assume that you have some experience with CD of your applications, and
    perhaps some basic use of Jenkins ([https://jenkins.io](https://jenkins.io)) as
    a CD server. There are several other good build-automation servers out there,
    such as Travis CI ([https://travis-ci.org](https://travis-ci.org)) and Bamboo
    ([www.atlassian.com/software/bamboo](http://www.atlassian.com/software/bamboo)),
    but we had to pick one to focus on, and we chose Jenkins. The principles described
    in this chapter more or less apply to whichever CD server you may end up choosing.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设您在应用程序的CD方面有一些经验，并且可能对Jenkins ([https://jenkins.io](https://jenkins.io))
    作为CD服务器有一些基本的使用。还有其他几个很好的构建自动化服务器，例如Travis CI ([https://travis-ci.org](https://travis-ci.org))
    和Bamboo ([www.atlassian.com/software/bamboo](http://www.atlassian.com/software/bamboo))，但我们不得不选择一个来集中关注，我们选择了Jenkins。本章中描述的原则大致适用于您最终可能选择的任何CD服务器。
- en: We’ll also assume that you’re using some kind of source control or source code
    management (SCM) server, such as Git ([https://git-scm.com](https://git-scm.com))
    or SVN ([https://subversion.apache.org](https://subversion.apache.org)), to manage
    your source code. If not, then you’re wicked, and your source code will die with
    your hard drive! Seriously, we wouldn’t wish that on anyone.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还假设您正在使用某种类型的源代码控制或源代码管理（SCM）服务器，例如Git ([https://git-scm.com](https://git-scm.com))
    或 SVN ([https://subversion.apache.org](https://subversion.apache.org))，来管理您的源代码。如果不是这样，那么您真的很糟糕，您的源代码将与您的硬盘一起死亡！说真的，我们不会希望这种情况发生在任何人身上。
- en: 10.1\. What is continuous delivery?
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1\. 什么是持续交付？
- en: '*Continuous delivery* is a methodology that revolves around releasing software
    faster and more frequently. This methodology helps reduce the cost, time, and
    risk of delivering changes that will potentially affect the user experience. Because
    delivery of the application is performed continuously and with incremental updates,
    it’s easier to capture feedback from the end user and react accordingly.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*持续交付* 是一种围绕更快、更频繁地发布软件的方法。这种方法有助于降低可能影响用户体验的更改交付的成本、时间和风险。由于应用程序的交付是持续进行的，并且带有增量更新，因此更容易从最终用户那里收集反馈并相应地做出反应。'
- en: The main concept in CD is the *deployment pipeline*. As the name suggests, it’s
    a set of steps or procedures through which the application must pass in order
    to be released for production. The deployment pipeline may be changed depending
    on the process you choose to follow when releasing the application. For example,
    some companies might have a manual testing/exploratory test phase before release.
    Others might go one step further and apply *continuous deployment* to the pipeline,
    releasing every change to production automatically on a successful build. *Continuous
    delivery*, on the other hand, is put in place only to ensure that every change
    is *potentially* releasable at any time (performing the actual release is a manual
    decision).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在持续集成（CD）中的主要概念是*部署管道*。正如其名所示，它是一系列步骤或程序，应用程序必须通过这些步骤或程序才能发布到生产环境。部署管道可能会根据您选择遵循的发布应用程序的过程而改变。例如，一些公司可能会在发布前进行手动测试/探索性测试阶段。其他公司可能会更进一步，将*持续部署*应用于管道，在构建成功后自动将每个更改发布到生产环境。另一方面，*持续交付*仅用于确保任何更改在任何时候*可能*发布（实际发布是手动决策）。
- en: 'The most common, generic deployment pipeline is shown in [figure 10.1](kindle_split_019_split_001.xhtml#ch10fig01).
    Typically, a deployment pipeline includes the following four primary phases:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见、通用的部署管道如图10.1所示。通常，部署管道包括以下四个主要阶段：
- en: '**1**.  *Commit stage*—The first part of the release process, triggered after
    a team member commits something to the SCM server. This stage is composed of the
    compilation process, unit (and significant other) test executions, code-quality
    analysis, and building the artifact deliverable. Ideally, the commit stage shouldn’t
    take more than 10 minutes.'
  id: totrans-15
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**.  *提交阶段*——发布过程的第一部分，在团队成员向源代码管理（SCM）服务器提交内容后触发。这个阶段包括编译过程、单元（和重要的其他）测试执行、代码质量分析和构建可交付成果。理想情况下，提交阶段不应超过10分钟。'
- en: '**2**.  *Automated acceptance tests*—Automated tests are executed that are
    deemed to be slow because they employ several parts of the system under test (for
    example, automated UI testing).'
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**.  *自动化验收测试*——执行被认为是慢速的自动化测试，因为这些测试使用了被测试系统中的多个部分（例如，自动化UI测试）。'
- en: '**3**.  *User acceptance tests*—Users test the application to make sure it
    meets their expectations. Some of these tests may be automatic (for example, capacity
    testing), but other manual tests, such as exploratory testing, can also be employed.
    Quality gates are commonly defined for code analysis, such as test coverage, metric
    collection, and measurement of technical debt; the umbrella term for this is *definition
    of done (DoD)*.'
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**.  *用户验收测试*——用户测试应用程序以确保其符合他们的期望。其中一些测试可能是自动的（例如，容量测试），但也可以采用其他手动测试，例如探索性测试。通常为代码分析定义质量门，如测试覆盖率、指标收集和技术债务的测量；这个总称是*完成定义（DoD）*。'
- en: '**4**.  *Release*—Based on all feedback from each stage, key users decide to
    release to production or drop the version. This is the final acceptance test or
    criteria.'
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**.  *发布*——基于每个阶段的全部反馈，关键用户决定将版本发布到生产环境或放弃该版本。这是最终的验收测试或标准。'
- en: Figure 10.1\. A typical deployment pipeline
  id: totrans-19
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.1\. 典型的部署管道
- en: '![](Images/10fig01_alt.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/10fig01_alt.jpg)'
- en: Now that you’re familiar with the basics of CD, let’s move on to how the microservices
    architecture fits in.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经熟悉了CD的基础知识，让我们继续探讨微服务架构如何与之结合。
- en: 10.2\. Continuous delivery and the microservices architecture
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2\. 持续交付与微服务架构
- en: 'Microservices should have the following characteristics when they’re deployed:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务在部署时应该具有以下特征：
- en: Each microservice should be a small, independent deployment unit. Deploying
    microservices together in the same process is not considered a best practice.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个微服务应该是一个小型、独立的部署单元。在相同的过程中一起部署微服务不被认为是最佳实践。
- en: Business features should be deployed independently. It’s important to note that
    this implies that each microservice should provide backward compatibility where
    changes have occurred in the public API, usually by versioning the API.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 商业功能应该独立部署。需要注意的是，这意味着每个微服务都应该提供向后兼容性，当公共API发生变化时，通常通过版本化API来实现。
- en: These characteristics affect the deployment pipeline. Because each microservice
    should be deployed independently, you need to create a new pipeline for each microservice.
    [Figure 10.2](kindle_split_019_split_002.xhtml#ch10fig02) shows an overview.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特性会影响部署管道。因为每个微服务都应该独立部署，所以你需要为每个微服务创建一个新的管道。[图10.2](kindle_split_019_split_002.xhtml#ch10fig02)展示了概述。
- en: Figure 10.2\. A microservices architecture deployment pipeline
  id: totrans-27
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.2. 微服务架构部署管道
- en: '![](Images/10fig02_alt.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/10fig02_alt.jpg)'
- en: 'The main advantages of using this approach for creating the deployment pipeline
    are as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法创建部署管道的主要优势如下：
- en: The pipeline is smaller and only contains steps for a single microservice.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道更小，只包含单个微服务的步骤。
- en: The pipeline is easier to set up, because there are fewer integrations with
    third-party systems.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于与第三方系统的集成较少，管道更容易设置。
- en: You receive feedback more quickly, because there are fewer tests to execute.
    You’re executing tests from a single microservice, not the entire application.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于测试数量较少，你能够更快地收到反馈。你正在执行单个微服务的测试，而不是整个应用程序的测试。
- en: 'But there are also some disadvantages that you need to be aware of:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 但也有一些缺点需要你注意：
- en: Each microservice might be developed using a different technology stack. This
    means each deployment pipeline might require different tools for each stage, making
    the code less reusable and more complex to maintain.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个微服务可能使用不同的技术栈进行开发。这意味着每个部署管道可能需要每个阶段不同的工具，使得代码的可重用性降低，维护更复杂。
- en: A microservice is the combination of the application, the server where it runs,
    the databases it needs, and any other required infrastructure. This means the
    process for deploying microservices may vary greatly from one microservice to
    another. For example, deploying a SQL database schema isn’t the same as deploying
    a NoSQL database schema.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务是应用程序、运行它的服务器、它需要的数据库以及任何其他所需基础设施的组合。这意味着部署微服务的流程可能因微服务而异。例如，部署SQL数据库模式与部署NoSQL数据库模式不同。
- en: Even if a microservice is well tested with unit tests, component tests, contract
    tests, service virtualization, and so forth, you still have the uncertainty of
    deploying a new piece of the system independently into an already running system.
    It’s normal to ask questions like, “Can old consumers communicate with new providers?”
    and “Will the new service be able to consume data from other providers (both old
    and new)?”
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使微服务经过单元测试、组件测试、契约测试、服务虚拟化等全面测试，你仍然会在将系统的新部分独立部署到已运行的系统中时面临不确定性。询问诸如“旧消费者能否与新的提供者通信？”和“新服务能否从其他提供者（包括新旧）那里消费数据？”这样的问题是正常的。
- en: 'To mitigate the risks of these drawbacks, you can follow these strategies:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减轻这些缺点的风险，你可以遵循以下策略：
- en: Define the pipeline in the same repository as the project’s source code. This
    ensures that the pipeline is created and maintained by the same team that’s developing
    the microservice.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在与项目源代码相同的存储库中定义管道。这确保了管道是由开发微服务的同一团队创建和维护的。
- en: Use a blue/green deployment approach. This means you create a complete cluster
    with each new release. Then run some automated tests or use an exploratory testing
    approach to validate that everything works as expected. After that, switch to
    the new cluster.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用蓝绿部署方法。这意味着你为每个新版本创建一个完整的集群。然后运行一些自动化测试或采用探索性测试方法来验证一切是否按预期工作。之后，切换到新集群。
- en: Use canary releases (to coin a term used by coal miners). With this approach,
    a new microservice is deployed to only a few nodes at a time. A few real users
    (preferably internal users) use the system against the new microservice for a
    defined period. During this time, you can monitor the results of the selected
    users’ interactions to ensure that the new service is behaving as expected.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用金丝雀发布（借用煤矿工人的术语）。采用这种方法，每次只部署少量节点的新微服务。一些真实用户（最好是内部用户）在定义的时间内使用系统对抗新微服务。在这段时间内，你可以监控所选用户交互的结果，以确保新服务按预期运行。
- en: Create a rollback strategy that’s easy and fast to apply to any given microservice,
    so in case of failure, you can roll back to the previous state as soon as possible.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个易于快速应用于任何给定微服务的回滚策略，以便在出现故障时，可以尽快回滚到之前的状态。
- en: Release often. Releasing often means releasing fewer features at once, which
    in turn means you’re changing the system one step at a time. This implies it’s
    more difficult to completely break the system. More important, it’s easier to
    detect where problems are.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经常发布。经常发布意味着一次发布较少的功能，这反过来意味着您一次只改变系统的一步。这意味着完全破坏系统更困难。更重要的是，更容易检测到问题所在。
- en: 'As you can see, release automation in a microservices architecture has the
    same requirements as any other application: being able to deploy with certainty
    and speed.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在微服务架构中的发布自动化与其他任何应用程序的要求相同：能够以确定性和速度进行部署。
- en: 10.3\. Orchestrating continuous delivery
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3. Orchestrating continuous delivery
- en: You’ve seen that a CD pipeline is composed of several stages, each of which
    may contain several steps. The code implementing each step is usually located
    with your build tool. For example, the *commit stage* is composed of the *compile*,
    *test*, *code quality*, and *package* steps, as shown in [figure 10.3](kindle_split_019_split_003.xhtml#ch10fig03).
    When you’re using the Gradle build tool, commands executed in the commit stage
    are, respectively, `gradle compileJava`, `gradle :test`, `gradle check`, and `gradle
    assemble`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到，持续交付（CD）管道由几个阶段组成，每个阶段可能包含几个步骤。实现每个步骤的代码通常位于您的构建工具中。例如，*提交阶段*由 *编译*、*测试*、*代码质量*
    和 *打包* 步骤组成，如图 [10.3](kindle_split_019_split_003.xhtml#ch10fig03) 所示。当您使用 Gradle
    构建工具时，提交阶段执行的命令分别是 `gradle compileJava`、`gradle :test`、`gradle check` 和 `gradle
    assemble`。
- en: Figure 10.3\. Commit stage example
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.3. 提交阶段示例
- en: '![](Images/10fig03_alt.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/10fig03_alt.jpg)'
- en: You wouldn’t want to call these commands manually every time you wanted to execute
    the commit stage, or any other stage, for that matter. You need a way to orchestrate
    the calls for all these commands and run them in the correct order to optimize
    the process. (The test and static-code-analysis steps can be performed in parallel.)
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您不希望每次想要执行提交阶段或任何其他阶段时都手动调用这些命令。您需要一个方法来编排所有这些命令的调用，并按正确的顺序运行它们以优化过程。（测试和静态代码分析步骤可以并行执行。）
- en: The *continuous integration* (CI) server coordinates all the steps that define
    the pipeline, manages the build process, and provides the magic for deploying
    the application. In addition to managing the release process, the CI server also
    offers a central place to retrieve all feedback from pipeline execution, such
    as test failures, artifact deployments for each environment, and hanging the build
    process for manual interaction.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*持续集成*（CI）服务器协调定义管道的所有步骤，管理构建过程，并为部署应用程序提供魔法。除了管理发布过程外，CI 服务器还提供了一个中心位置来检索管道执行的所有反馈，例如测试失败、每个环境的工件部署以及手动交互时挂起的构建过程。'
- en: 10.3.1\. Working with Jenkins
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3.1. 与 Jenkins 合作
- en: You need a CI server to manage the entire build. As we mentioned earlier, in
    our opinion, Jenkins is the most widely used server for managing the deployment
    pipeline that meets all the requirements for integrating with the full range of
    systems.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一个持续集成（CI）服务器来管理整个构建过程。正如我们之前提到的，我们认为 Jenkins 是最广泛使用的服务器，用于管理满足与全系列系统集成要求的部署管道。
- en: Jenkins is a cross-platform, CI/CD server. It provides various means to define
    your deployment pipeline, and it integrates well with a large number of testing
    and deployment technologies.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins 是一个跨平台、CI/CD 服务器。它提供了各种定义您的部署管道的方法，并且与大量的测试和部署技术集成良好。
- en: 'Here are just some of the many available integrations:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这里只是众多可用集成中的一些：
- en: '*Code and commit*—Git, GitHub, Mercurial, Visual Studio, Eclipse, and Nexus'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*代码和提交*—Git、GitHub、Mercurial、Visual Studio、Eclipse 和 Nexus'
- en: '*Build and config*—Maven, Gradle, Docker, Chef, Ant, Vagrant, Ansible, and
    AWS'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*构建和配置*—Maven、Gradle、Docker、Chef、Ant、Vagrant、Ansible 和 AWS'
- en: '*Scan and test*—Gerrit, Sauce Labs, Sonar, Gatling, JUnit, FitNesse, and Cucumber'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*扫描和测试*—Gerrit、Sauce Labs、Sonar、Gatling、JUnit、FitNesse 和 Cucumber'
- en: '*Release*—uDeploy, Serena, and MidVision'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*发布*—uDeploy、Serena 和 MidVision'
- en: '*Deployment*—AWS, Docker, OpenShift, Kubernetes, OpenStack, GCE, and Azure'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*部署*—AWS、Docker、OpenShift、Kubernetes、OpenStack、GCE 和 Azure'
- en: As you can see, Jenkins covers all the steps you might require for implementing
    any deployment pipeline. Let’s look at how to define a deployment pipeline with
    code using the Jenkins pipeline.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，Jenkins 覆盖了您可能需要实现任何部署管道的所有步骤。让我们看看如何使用 Jenkins 管道使用代码定义部署管道。
- en: 10.3.2\. The Jenkins pipeline
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3.2. Jenkins 管道
- en: The *Jenkins pipeline* is a group of plugins designed to help you implement
    continuous integration/delivery/deployment pipelines into Jenkins. Using the Jenkins
    pipeline, you can define your delivery pipeline *as code* in your project, rather
    than relying on the point-and-click UI of the past.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*Jenkins 管道* 是一组插件，旨在帮助您将持续集成/交付/部署管道实现到 Jenkins 中。使用 Jenkins 管道，您可以在项目中以代码的形式定义您的交付管道，而不是依赖于过去的点对点用户界面。'
- en: Normally, this definition lives in the same SCM repository as your service.
    This is perfect for a microservices architecture, because you’re keeping together
    everything related to the service.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这个定义与你的服务位于同一个源代码管理（SCM）仓库中。这对于微服务架构来说非常完美，因为你可以将所有与该服务相关的所有内容放在一起。
- en: 'A coded pipeline offers several benefits. Because it’s code and you can treat
    it as such, you can do the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 编码的管道提供了一些好处。因为它是代码，您可以将其视为代码，您可以执行以下操作：
- en: Automatically create pipelines for all branches and pull requests
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动为所有分支和拉取请求创建管道
- en: Perform code reviews and iterative improvement of the pipeline
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行代码审查和管道的迭代改进
- en: Keep an audit trail, because changes are also committed to the SCM
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持审计跟踪，因为更改也被提交到源代码管理（SCM）
- en: Enable collaboration, because everyone can see and edit the code
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用协作，因为每个人都可以查看和编辑代码
- en: The de facto filename for coding the pipeline in Jenkins is *Jenkinsfile*, and
    it’s usually checked into a service’s SCM repository in the root directory. Jenkinsfile
    is a text file that contains all the steps required to deliver a service/project
    via the *Pipeline* DSL.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Jenkins 中编写管道的默认文件名是 *Jenkinsfile*，它通常被检查到服务源代码管理（SCM）仓库的根目录中。Jenkinsfile
    是一个包含通过 *Pipeline* DSL 交付服务/项目的所有步骤的文本文件。
- en: 'As of version 2.5, the Jenkins pipeline supports two discrete syntaxes to define
    the pipeline: the *declarative pipeline* and the *scripted pipeline*. Under the
    covers, both are implemented as Groovy DSLs.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 2.5 版本，Jenkins 管道支持两种离散的语法来定义管道：*声明式管道* 和 *脚本式管道*。在底层，两者都作为 Groovy DSL 实现。
- en: The declarative pipeline
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 声明式管道
- en: The declarative pipeline presents a simplified, opinionated syntax for authoring
    the deployment pipeline. This simplification restricts flexibility and extensibility;
    but, on the other hand, it makes the deployment pipeline easy to write and read.
    In our experience, the declarative approach is sufficient for almost all cases.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式管道提供了一个简化的、有偏见的语法，用于编写部署管道。这种简化限制了灵活性和可扩展性；但另一方面，它使得部署管道易于编写和阅读。根据我们的经验，声明式方法对于几乎所有情况都足够了。
- en: All declarative pipelines must be enclosed in a `pipeline` block. Each block
    must only consist of *sections*, *directives*, and *assignment statements*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 所有声明式管道都必须包含在 `pipeline` 块中。每个块必须只包含 *部分*、*指令* 和 *赋值语句*。
- en: 'Here’s an example Jenkinsfile:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个 Jenkinsfile 的例子：
- en: '[PRE0]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '***1* Executes the pipeline in any available Jenkins agent (a Jenkins process)**'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在任何可用的 Jenkins 代理（一个 Jenkins 进程）上执行管道**'
- en: '***2* Stages are where all the work is done.**'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 阶段是所有工作完成的地方。**'
- en: '***3* Steps to execute within a stage**'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 阶段内执行的步骤**'
- en: '***4* Shell directive command**'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* Shell 指令命令**'
- en: '***5* The section executed after build (post-build steps)**'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 构建之后执行的章节（后构建步骤）**'
- en: '***6* Directive to archive the test results**'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 归档测试结果的指令**'
- en: The root element must be `pipeline`, which encloses all the stages for the current
    pipeline. The `agent` directive specifies where the entire pipeline or specific
    stage will be executed.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 根元素必须是 `pipeline`，它包围了当前管道的所有阶段。`agent` 指令指定整个管道或特定阶段将在哪里执行。
- en: The `any` option states that the pipeline should be executed on any available
    node. You can also specify nodes with a specific label or a specific Docker image.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`any` 选项表示管道应该在任何可用的节点上执行。您还可以指定具有特定标签或特定 Docker 镜像的节点。'
- en: Next, you define a list of stages. Each stage is related to the stages of your
    deployment pipeline, such as commit stage, acceptance-test stage, and so on. Each
    stage is composed of several steps that are responsible for performing the work.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您定义一系列阶段。每个阶段都与您的部署管道的阶段相关，例如提交阶段、验收测试阶段等。每个阶段由负责执行工作的几个步骤组成。
- en: At the end of the execution, the `post` directive is set to always register
    `junit` results. The `post` directive can be used in top-level `pipeline` blocks
    and in each `stage` block. Note that `post` supports conditional blocks such as
    `always`, `failure`, `success`, `changed`, and `unstable` that set whether `post`
    actions should be executed.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 执行结束时，`post` 指令被设置为始终注册 `junit` 结果。`post` 指令可以在顶层 `pipeline` 块和每个 `stage` 块中使用。请注意，`post`
    支持条件块，如 `always`、`failure`、`success`、`changed` 和 `unstable`，这些块设置是否执行 `post` 操作。
- en: 'Let’s look at some other minimalistic examples of declarative pipelines before
    we explain the scripted pipeline. The following Jenkinsfile allocates a new Docker
    container based on a Maven image. The workspace is added to the image, and then
    the steps are run inside it:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释脚本管道之前，让我们看看一些声明式管道的简单示例。以下 Jenkinsfile 基于Maven镜像分配一个新的Docker容器。将工作区添加到镜像中，然后在其内部运行步骤：
- en: '[PRE1]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '***1* Docker image on which the build is to be executed**'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 执行构建的 Docker 镜像**'
- en: '***2* Shell command executed within the container**'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在容器内执行的 Shell 命令**'
- en: 'You can also interact with users in a Jenkinsfile, as shown in this example:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在 Jenkinsfile 中与用户进行交互，如下例所示：
- en: '[PRE2]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***1* Sends an email in the event of a failure**'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在失败时发送电子邮件**'
- en: '***2* Waits for user input**'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 等待用户输入**'
- en: 'This Jenkinsfile has two stages: one for deploying the service and one for
    checking the state of the build. There’s also an error-handling routine. If an
    error occurs, an email is sent to the team, informing them of the failure. The
    second stage waits for approval from any user: the deployment pipeline is paused
    until a user clicks the Proceed button.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Jenkinsfile 有两个阶段：一个用于部署服务，一个用于检查构建状态。还有一个错误处理程序。如果发生错误，将向团队发送电子邮件，通知他们失败情况。第二个阶段等待任何用户的批准：部署管道将暂停，直到用户点击“继续”按钮。
- en: '|  |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**The script directive**'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**脚本指令**'
- en: 'The `script` step takes a block of scripted pipeline code and executes it in
    the declarative pipeline:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`script` 步骤接受一段脚本管道代码块，并在声明式管道中执行它：'
- en: '[PRE3]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`script` blocks of nontrivial size or greater complexity should be implemented
    as a shared library.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非平凡大小或更复杂性的 `script` 块，应将其实现为一个共享库。
- en: '|  |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The scripted pipeline
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 脚本管道
- en: So far, you’ve seen how to use the Jenkins declarative pipeline to define pipelines.
    Although this will probably cover most use cases, if you want more control or
    need to perform more-complex operations, then the *scripted pipeline* is the best
    approach. All the steps covered by the declarative pipeline are also valid for
    the scripted pipeline.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到了如何使用 Jenkins 声明式管道来定义管道。尽管这可能覆盖大多数用例，但如果你需要更多控制或需要执行更复杂的操作，那么 `scripted
    pipeline` 是最佳方法。声明式管道中涵盖的所有步骤在脚本管道中也是有效的。
- en: The scripted pipeline is effectively a general-purpose DSL built with Groovy.
    This means most of the features that are valid in the Groovy language are available
    in the scripted pipeline.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本管道实际上是一个用 Groovy 构建的通用 DSL。这意味着 Groovy 语言中有效的多数功能在脚本管道中也是可用的。
- en: Here’s a Jenkinsfile that shows an example of the scripted pipeline in use.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 Jenkinsfile，展示了脚本管道的使用示例。
- en: Listing 10.1\. Jenkinsfile
  id: totrans-104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.1\. Jenkinsfile
- en: '[PRE4]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***1* Selects the node to run**'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 选择运行节点**'
- en: '***2* Checks out the code from the SCM**'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 从源代码管理（SCM）检出代码**'
- en: '***3* Safe flow control with try/catch**'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用 try/catch 进行安全的流程控制**'
- en: '***4* Changes the build result**'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 改变构建结果**'
- en: You can see that this Jenkinsfile looks more like a Groovy script than a pure
    pipeline.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这个 Jenkinsfile 更像是一个 Groovy 脚本，而不是一个纯管道。
- en: In a scripted pipeline, you define stages and nodes. A *node* is the agent where
    the pipeline stage will be executed. You can begin coding the pipeline either
    using steps such as `sh`, `checkout`, and `mailto`, or using Groovy structures
    such as `try/catch` and `if/else`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本管道中，你定义阶段和节点。一个 *node* 是管道阶段将要执行的工作代理。你可以使用 `sh`、`checkout` 和 `mailto` 等步骤开始编写管道代码，或者使用
    `try/catch` 和 `if/else` 等Groovy结构。
- en: This is just a taste of how to code a deployment pipeline, to get you on the
    right track—covering the full Jenkins pipeline would require an entire book. To
    learn more, you can read the documentation at [https://jenkins.io/doc](https://jenkins.io/doc).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是展示如何编写部署管道代码的一个示例，以帮助你走上正确的道路——要全面了解 Jenkins 管道，需要整本书。要了解更多信息，你可以阅读[https://jenkins.io/doc](https://jenkins.io/doc)中的文档。
- en: 10.3.3\. Deploying with certainty
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3.3\. 确定性部署
- en: In [chapter 6](kindle_split_015_split_000.xhtml#ch06), you learned that *consumer-driven
    contracts* aren’t just a design process of your service’s API, but also a way
    to split the dependencies of a service so they’re tested in isolation. The contract
    is tested first against a consumer, and subsequently against the providers of
    that consumer.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](kindle_split_015_split_000.xhtml#ch06)中，你了解到*消费者驱动型契约*不仅仅是你的服务API的设计过程，也是分割服务依赖关系以便在隔离状态下进行测试的一种方式。契约首先针对消费者进行测试，然后针对该消费者的提供者进行测试。
- en: This is a big advantage over end-to-end tests in a microservices architecture,
    where trying to write end-to-end tests can be complicated due to the environmental
    preparation. Moreover, because of the complexity of the running environment (lots
    of interconnected services, networks, different databases, and so forth), these
    tests are candidates for being flaky or nondeterministic.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在微服务架构中相对于端到端测试的一个大优势，因为在微服务架构中，由于环境准备复杂，尝试编写端到端测试可能会很复杂。此外，由于运行环境的复杂性（众多相互连接的服务、网络、不同的数据库等），这些测试可能成为不可靠或非确定性的候选者。
- en: If you don’t use end-to-end tests, how can you deploy a new service independently
    and with the certainty that nothing is broken? The answer is to run contract tests
    during the deployment pipeline against a matrix of environments.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有使用端到端测试，如何独立部署新服务并确信没有出错？答案是，在部署管道中运行契约测试，针对环境矩阵进行测试。
- en: In [chapter 6](kindle_split_015_split_000.xhtml#ch06), you learned that the
    first step is to write a contract. Then, you test that contract against the *head*
    (current development) versions of the consumer and providers so you know they’re
    compatible with each other. As least, this is the methodology on a developer machine.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](kindle_split_015_split_000.xhtml#ch06)中，你了解到第一步是编写一个契约。然后，你测试该契约与消费者和提供者的*头部*（当前开发）版本，以便你知道它们是兼容的。至少，这是在开发机器上的方法。
- en: 'During the CD phase, where services are deployed independently of each other
    (and there may be both consumers and/or providers), this methodology isn’t enough.
    There’s no reliable way to answer the following questions:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在CD阶段，服务是相互独立部署的（可能既有消费者也有/或提供者），这种方法就不够了。没有可靠的方法来回答以下问题：
- en: Is the head version of a consumer compatible with the production version of
    the provider?
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费者的头部版本是否与提供者的生产版本兼容？
- en: Is the head version of a provider compatible with the production versions of
    its consumers?
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供者的头部版本是否与其消费者的生产版本兼容？
- en: You need to go one step further in contract testing and also verify the contracts
    against the production environments.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在契约测试中更进一步，并验证契约与生产环境。
- en: Deploying a new consumer
  id: totrans-122
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 部署新的消费者
- en: Before deploying a new consumer to production, it’s important to verify the
    contract generated by a consumer against the head version of its provider. This
    is also true of the production version of the provider. You need to ensure that
    when a new consumer hits production, the current providers already in production
    will still be able to receive input and produce output for that input.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在将新的消费者部署到生产环境之前，重要的是验证消费者生成的契约与其提供者的头部版本。这也适用于提供者的生产版本。你需要确保当新的消费者进入生产环境时，当前的生产提供者仍然能够接收输入并为该输入产生输出。
- en: '|  |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Contract tests are permitted to fail against the head version, but not against
    the production version. Although we suggest that you fix this scenario, it isn’t
    a blocker for deploying the consumer to production—at least, until the head version
    is promoted to production.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 契约测试可以针对头部版本失败，但不能针对生产版本失败。尽管我们建议你修复这种情况，但这并不是阻止消费者部署到生产的障碍——至少，直到头部版本升级到生产版本。
- en: '|  |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Deploying a new provider
  id: totrans-128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 部署新的提供者
- en: Before deploying a new provider to production, you need to verify that the head
    versions of contracts still work for consumers that the provider depends on. Again,
    this is true of the production contract versions. You need to ensure that when
    a new provider hits production, the consumers that are already deployed to production
    are still able to communicate with it.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在将新的提供者部署到生产环境之前，你需要验证契约的头部版本是否仍然适用于提供者所依赖的消费者。同样，这也适用于生产契约版本。你需要确保当新的提供者进入生产环境时，已经部署到生产环境中的消费者仍然能够与其通信。
- en: '|  |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Contract tests are permitted to fail against the head versions, but not those
    in production. Again, we suggest that you fix this, but it’s not a blocker for
    deploying the provider to production.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 合同测试允许对头版本失败，但不能对生产中的版本失败。再次建议您修复此问题，但这不会阻止将提供者部署到生产环境。
- en: '|  |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 10.4\. Jenkins
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4\. Jenkins
- en: Jenkins provides a huge variety of plugins to support all the stages of the
    CD process. Jenkins is distributed in several formats, including a WAR file, a
    platform-dependent installer, and a Docker container. We’re guessing that if you’ve
    made it this far, you’ve already installed Java. But in case you haven’t, let’s
    look at how to download, install, and perform an initial setup for Jenkins from
    a WAR file (a self-contained executable archive that only needs Java to run).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins 提供了大量的插件来支持 CD 流程的所有阶段。Jenkins 以多种格式分发，包括 WAR 文件、平台相关的安装程序和 Docker 容器。我们猜测，如果您已经走到这一步，您已经安装了
    Java。但以防万一您还没有，让我们看看如何从 WAR 文件（一个仅需要 Java 运行的自包含可执行归档）下载、安装和进行 Jenkins 的初始设置。
- en: '|  |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: At the time of writing, the latest version of Jenkins was 2.114\. Please check
    for and install the latest version of Jenkins—this project is released often.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Jenkins 的最新版本是 2.114。请检查并安装 Jenkins 的最新版本——该项目经常发布。
- en: '|  |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Generated password**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**生成的密码**'
- en: Before opening a browser to access the Jenkins console, pay special attention
    to the console output, similar to the following snippet.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在打开浏览器访问 Jenkins 控制台之前，请特别注意控制台输出，类似于以下片段。
- en: '![](Images/f0255-01_alt.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0255-01_alt.jpg)'
- en: Initial password
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 初始密码
- en: The first time Jenkins starts, a default password is generated. You need to
    copy or make a note of this password, because it’s required the first time you
    access the Jenkins web console, to create the initial admin account.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins 首次启动时，会生成一个默认密码。您需要复制或记下此密码，因为首次访问 Jenkins 网络控制台创建初始管理员账户时需要它。
- en: '|  |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Follow these steps:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: '**1**.  Download Jenkins from [https://jenkins.io/download](https://jenkins.io/download)
    (see [figure 10.4](kindle_split_019_split_004.xhtml#ch10fig04)). Select the generic
    Java package (.war) download link, and save the file locally.'
  id: totrans-148
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 从 [https://jenkins.io/download](https://jenkins.io/download) 下载 Jenkins（参见[图10.4](kindle_split_019_split_004.xhtml#ch10fig04)）。选择通用的
    Java 包 (.war) 下载链接，并将文件本地保存。'
- en: ''
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Figure 10.4\. Jenkins download site
  id: totrans-150
  prefs:
  - PREF_BQ
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.4\. Jenkins 下载网站
- en: ''
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](Images/10fig04_alt.jpg)'
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](Images/10fig04_alt.jpg)'
- en: '**2**.  Open a terminal, and move the downloaded jenkins.war file to a final
    destination where you’d like the service to run: for example, `mv ~/Downloads/jenkins.war
    /opt/jenkins`.'
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 打开终端，并将下载的 jenkins.war 文件移动到您希望服务运行的目标位置：例如，`mv ~/Downloads/jenkins.war
    /opt/jenkins`。'
- en: '**3**.  Start Jenkins by running `java -jar jenkins.war`. After a few seconds,
    Jenkins will be up and running.'
  id: totrans-154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. 通过运行 `java -jar jenkins.war` 启动 Jenkins。几秒钟后，Jenkins 将启动并运行。'
- en: '**4**.  Open a browser and access http://localhost:8080, where you’re prompted
    to provide your new default administrator password.'
  id: totrans-155
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**. 打开浏览器并访问 http://localhost:8080，系统会提示您提供新的默认管理员密码。'
- en: '**5**.  After you enter the new password, you’re presented with a screen where
    you can choose to install suggested plugins or manually select which plugins to
    install. For the sake of simplicity, and because it’s a pretty good start for
    most cases, click Install Suggested Plugins, as shown in [figure 10.5](kindle_split_019_split_004.xhtml#ch10fig05).
    Jenkins will download and install the most commonly used plugins in the Jenkins
    ecosystem, including the Jenkins Pipeline plugin. [Figure 10.6](kindle_split_019_split_004.xhtml#ch10fig06)
    shows the plugin installation window.'
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**5**. 输入新密码后，您将看到一个屏幕，您可以选择安装建议的插件或手动选择要安装的插件。为了简化操作，并且因为这对于大多数情况来说是一个很好的起点，请点击“安装建议插件”，如图[图10.5](kindle_split_019_split_004.xhtml#ch10fig05)所示。Jenkins
    将下载并安装 Jenkins 生态系统中最常用的插件，包括 Jenkins Pipeline 插件。[图10.6](kindle_split_019_split_004.xhtml#ch10fig06)显示了插件安装窗口。'
- en: ''
  id: totrans-157
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Figure 10.5\. Customizing Jenkins
  id: totrans-158
  prefs:
  - PREF_BQ
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.5\. 定制 Jenkins
- en: ''
  id: totrans-159
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](Images/10fig05_alt.jpg)'
  id: totrans-160
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](Images/10fig05_alt.jpg)'
- en: ''
  id: totrans-161
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Figure 10.6\. Plugin installation
  id: totrans-162
  prefs:
  - PREF_BQ
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.6\. 插件安装
- en: ''
  id: totrans-163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](Images/10fig06_alt.jpg)'
  id: totrans-164
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](Images/10fig06_alt.jpg)'
- en: '**6**.  When all plugins have been installed, you’re presented with a screen
    to create the first admin user, as shown in [figure 10.7](kindle_split_019_split_004.xhtml#ch10fig07).'
  id: totrans-165
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**6**. 所有插件安装完成后，您将看到一个屏幕来创建第一个管理员用户，如图[图10.7](kindle_split_019_split_004.xhtml#ch10fig07)所示。'
- en: Figure 10.7\. Creating the admin user
  id: totrans-166
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.7\. 创建管理员用户
- en: '![](Images/10fig07_alt.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/10fig07_alt.jpg)'
- en: The installation and setup are complete, and you can begin defining your first
    Jenkins pipeline job.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 安装和设置已完成，您现在可以开始定义您的第一个 Jenkins 管道作业。
- en: 10.4.1\. Defining a pipeline
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.4.1\. 定义管道
- en: 'To create a pipeline, follow these steps:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建管道，请按照以下步骤操作：
- en: '**1**.  Click the New Item link on the Jenkins main page, and add a name for
    the item (for example, game-service).'
  id: totrans-171
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**.  在 Jenkins 主页上点击新建项目链接，并为项目添加一个名称（例如，game-service）。'
- en: '**2**.  Select the Multibranch Pipeline type. This option creates a group of
    pipeline projects for each detected branch within the (yet to be specified) project
    (see [figure 10.8](kindle_split_019_split_004.xhtml#ch10fig08)).'
  id: totrans-172
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**.  选择多分支管道类型。此选项为（尚未指定的）项目中的每个检测到的分支创建一组管道项目（参见[图 10.8](kindle_split_019_split_004.xhtml#ch10fig08)）。'
- en: ''
  id: totrans-173
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Figure 10.8\. New multibranch pipeline item
  id: totrans-174
  prefs:
  - PREF_BQ
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.8\. 新的多分支管道项目
- en: ''
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](Images/10fig08_alt.jpg)'
  id: totrans-176
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](Images/10fig08_alt.jpg)'
- en: '**3**.  With the item created, you can configure the pipeline job. The most
    important part of the configuration is the Branch Sources section, where the project
    location is defined. Click Add Source, and then select the Git option. You’ll
    be presented with the block shown in [figure 10.9](kindle_split_019_split_004.xhtml#ch10fig09).'
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**.  创建项目后，您可以配置管道作业。配置最重要的部分是分支源部分，其中定义了项目位置。点击添加源，然后选择 Git 选项。您将看到[图 10.9](kindle_split_019_split_004.xhtml#ch10fig09)中所示的块。'
- en: ''
  id: totrans-178
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Figure 10.9\. Item configuration block
  id: totrans-179
  prefs:
  - PREF_BQ
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.9\. 项目配置块
- en: ''
  id: totrans-180
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](Images/10fig09_alt.jpg)'
  id: totrans-181
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](Images/10fig09_alt.jpg)'
- en: '**4**.  Add the full Git URL for the project to the Project Repository field,
    and click Save to complete the process of registering a new item.'
  id: totrans-182
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**.  将项目的完整 Git URL 添加到项目仓库字段，然后点击保存以完成注册新项目的流程。'
- en: At this point, Jenkins will detect all branches in the configured repository.
    If the branch contains a Jenkinsfile file, Jenkins will use that file to schedule
    a new build for the branch.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，Jenkins 将检测配置的存储库中的所有分支。如果分支包含 Jenkinsfile 文件，Jenkins 将使用该文件为该分支安排新的构建。
- en: '|  |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Blue Ocean**'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**Blue Ocean**'
- en: 'Blue Ocean is, at the time of writing, a plugin available for Jenkins that
    improves the Jenkins user experience by reducing the complexity and increasing
    the visual clarity of a pipeline. It isn’t installed by default, so you need to
    install it via the Jenkins Plugin Manager. Here are some notable features:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Blue Ocean 是一个可用于 Jenkins 的插件，通过减少复杂性并提高管道的可视清晰度来改善 Jenkins 用户体验。它默认未安装，因此您需要通过
    Jenkins 插件管理器进行安装。以下是一些显著功能：
- en: Visualization of CD pipelines for fast, easy checking of a pipeline’s status
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CD 管道的可视化，以便快速轻松地检查管道的状态
- en: A pipeline editor for creating pipelines using a visual process
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于创建管道的可视化流程编辑器
- en: Personalization to meet the role-based needs of the team
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 个性化以满足团队基于角色的需求
- en: Pinpoint precision, showing exactly the point in the pipeline that requires
    attention
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精确定位，显示需要关注的管道中的确切点
- en: Native integration for branch and pull requests
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分支和拉取请求的原生集成
- en: 'Creating a new job in Blue Ocean is simple: navigate to http://localhost:8080/blue,
    click New Pipeline, and fill in the required information.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Blue Ocean 中创建新作业很简单：导航到 http://localhost:8080/blue，点击新建管道，并填写所需信息。
- en: '![](Images/f0260-01_alt.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f0260-01_alt.jpg)'
- en: New pipeline
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 新的管道
- en: Under the covers, Jenkins detects available Jenkinsfiles and schedules builds
    accordingly.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，Jenkins 检测可用的 Jenkinsfiles 并相应地安排构建。
- en: '|  |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 10.4.2\. Example of a Jenkins pipeline
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.4.2\. Jenkins 管道的示例
- en: Section 10.2.3 discussed running contract tests so as not to break the environment
    when a new service is released. The idea is to run contract tests against the
    head and production versions, to ensure that all services will be able to communicate
    with each other after the new release.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 10.2.3 节讨论了运行合同测试，以防止在发布新服务时破坏环境。想法是对头版本和生产版本运行合同测试，以确保所有服务在新的发布后都能相互通信。
- en: 'Let’s see how to use Jenkins and the scripted pipeline to release a *consumer*
    with certainty. The following example skips the steps related to the compile and
    test phases, and focuses on the contract part of the *consumer* delivery pipeline:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 Jenkins 和脚本管道有信心地发布一个 *消费者*。以下示例跳过了与编译和测试阶段相关的步骤，并专注于 *消费者* 交付管道的合同部分：
- en: '[PRE5]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1* Sets the publishContracts environment variable to true**'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将 publishContracts 环境变量设置为 true**'
- en: '***2* Executes the contract tests**'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 执行合同测试**'
- en: 'The consumer contract tests (stored in the `contract` module) are run, and
    the resulting contracts are published to the contracts repository. This happens
    because the following arquillian.xml file evaluates the `publishContracts` environment
    variable to make the Arquillian Algeron extension ([http://arquillian.org/arquillian-algeron](http://arquillian.org/arquillian-algeron))
    publish the created contracts:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者合约测试（存储在 `contract` 模块中）正在运行，生成的合约被发布到合约仓库。这是因为以下 arquillian.xml 文件评估 `publishContracts`
    环境变量，以使 Arquillian Algeron 扩展 ([http://arquillian.org/arquillian-algeron](http://arquillian.org/arquillian-algeron))
    发布创建的合约：
- en: '[PRE6]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this stage, contract tests are running on the consumer side, validating that
    a new consumer version can communicate with latest contract versions.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，消费者端的合约测试正在运行，验证新的消费者版本能否与最新的合约版本进行通信。
- en: Before deploying this new consumer to production, you need to ensure that the
    providers of the specified consumer are compatible with this new contract. The
    following Jenkinsfile snippet depicts how to validate the latest contract against
    the head provider and against the current production provider.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在将这个新的消费者部署到生产之前，您需要确保指定的消费者提供者与这个新合约兼容。以下 Jenkinsfile 片段展示了如何验证最新合约与头提供者和当前生产提供者。
- en: Listing 10.2\. Validating the latest contract
  id: totrans-207
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.2\. 验证最新合约
- en: '[PRE7]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '***1* The head and production contract validations are run in parallel.**'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 头和生产的合约验证并行运行。**'
- en: '***2* Passes the production location as a parameter**'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将生产位置作为参数传递**'
- en: '***3* The build fails on a production provider failure.**'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 构建在生产提供者失败时失败。**'
- en: '***4* If production is OK, requests to deploy**'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 如果生产正常，请求部署**'
- en: This stage validates that the latest contract is also valid for the head and
    production versions of the provider, in this case, the comments service. Validation
    of both versions is performed in parallel. Because the provider’s validation contract
    resides in the provider project, the build needs to be triggered.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这个阶段验证最新合约对于提供者的头和生产版本也是有效的，在这个例子中，是评论服务。两个版本的验证是并行进行的。因为提供者的验证合约位于提供者项目中，所以需要触发构建。
- en: For the production run, the service location is defined as a build parameter.
    After the provider version is successfully validated against the latest contract,
    the user is prompted to deploy the new consumer to production.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 对于生产运行，服务位置被定义为构建参数。在提供者版本成功通过最新合约验证后，用户会被提示部署新的消费者到生产环境。
- en: '|  |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-216
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: Depending on your software release model, the pipeline script is likely to vary
    from project to project. For this reason, we encourage you to visit [https://jenkins.io/doc/book/pipeline](https://jenkins.io/doc/book/pipeline)
    and learn in depth how the Jenkins pipeline fits into various scenarios.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的软件发布模型，管道脚本可能会根据项目而有所不同。因此，我们鼓励您访问 [https://jenkins.io/doc/book/pipeline](https://jenkins.io/doc/book/pipeline)
    并深入了解 Jenkins 管道如何适应各种场景。
- en: '|  |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Summary
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Each service should be deployed independently.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个服务都应该独立部署。
- en: A coded pipeline simplifies deployment and encourages the delivery of a service
    to be treated as part of the service project.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码化管道简化了部署，并鼓励将服务的交付视为服务项目的一部分。
- en: Be sure to deploy to production with certainty, using contract tests against
    production versions.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保使用合约测试针对生产版本部署到生产环境。
- en: Jenkins covers all your needs for implementing continuous delivery in a microservices
    architecture.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins 涵盖了在微服务架构中实施持续交付的所有需求。
