- en: Level 0\. Encounter
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Level 0\. 遭遇
- en: '![](pg_001.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](pg_001.jpg)'
- en: '*Our mascot for this level is the magpie, one of the most intelligent nonhuman
    species on earth. They are capable of elaborate social rituals and usage of tools.*'
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*这个级别的吉祥物是乌鸦，地球上最聪明的非人类物种之一。它们能够进行复杂的社会仪式和工具使用。*'
- en: This first level of the book may be your first encounter with the programming
    language C. It provides you with a rough knowledge about C programs, their purpose,
    their structure, and how to use them. It is not meant to give you a complete overview,
    it can’t and it doesn’t even try. On the contrary, it is supposed to give you
    a general idea of what this is all about, open up questions, and promote ideas
    and concepts. These then will be explained in detail in the higher levels.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的第一级可能是你第一次接触编程语言C。它为你提供了关于C程序、它们的目的、结构和如何使用它们的大致知识。它并不旨在提供一个完整的概述，它不能，甚至不试图这样做。相反，它旨在给你一个大致的概念，提出问题，促进思想和概念。这些将在更高层次中详细解释。
- en: Chapter 1\. Getting started
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Chapter 1\. 开始
- en: This chapter covers
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Introduction to imperative programming
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令式编程简介
- en: Compiling and running code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译和运行代码
- en: In this chapter, I will introduce you to one simple program that has been chosen
    because it contains many of the constructs of the C language. If you already have
    programming experience, you may find that parts of it feel like needless repetition.
    If you lack such experience, you might feel overwhelmed by the stream of new terms
    and concepts.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将向您介绍一个简单的程序，我们选择它是因为它包含了C语言中的许多构造。如果您已经有了编程经验，您可能会发现其中的一些部分感觉像是无用的重复。如果您缺乏这样的经验，您可能会被一连串的新术语和概念所淹没。
- en: In either case, be patient. For those of you with programming experience, it’s
    very possible that there are subtle details you’re not aware of, or assumptions
    you have made about the language that are not valid, even if you have programmed
    C before. For those approaching programming for the first time, be assured that
    after approximately 10 pages your understanding will have increased a lot, and
    you should have a much clearer idea of what programming represents.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，都要有耐心。对于那些有编程经验的人来说，很可能存在一些您没有意识到的微妙细节，或者您对语言所做的假设可能并不正确，即使您以前已经编写过C程序。对于那些第一次接触编程的人来说，请放心，大约10页之后，您的理解将大大提高，您应该对编程代表什么有一个更清晰的认识。
- en: 'An important bit of wisdom for programming in general, and for this book in
    particular, is summarized in the following citation from the *Hitchhiker’s Guide
    to the Galaxy* by Douglas Adams [[1986](kindle_split_036.html#bib1)]:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一般编程，尤其是这本书来说，以下引用总结了道格拉斯·亚当斯的《银河系漫游指南》中的宝贵智慧[[1986](kindle_split_036.html#bib1)]：
- en: '|  |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway B
  id: totrans-12
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway B
- en: '*Don’t panic.*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*别慌张。*'
- en: '|  |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: It’s not worth it. There are many cross references, links, and bits of side
    information in the text, and there is an index at the end. Follow those if you
    have a question. Or just take a break.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这不值得。文本中有很多交叉引用、链接和旁支信息，并且在最后有一个索引。如果你有问题，就按照那些线索去找。或者，只是休息一下。
- en: 'Programming in C is about having the computer complete some specific tasks.
    A C program does that by giving orders, much as we would express such orders in
    the imperative tense in many human languages; thus the term *imperative programming*
    for this particular way of organizing computer programs. To get started and see
    what we are talking about, consider our first program in [listing 1.1](#ch01ex01):'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在C语言中编程是让计算机完成一些特定的任务。一个C程序通过下达命令来完成这些任务，就像我们在许多人类语言中使用祈使语气表达这样的命令一样；因此，这种组织计算机程序的方式被称为*命令式编程*。为了开始并了解我们在说什么，考虑我们的第一个程序[列表1.1](#ch01ex01)：
- en: Listing 1.1\. A first example of a C program
  id: totrans-17
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Listing 1.1\. C程序的一个初步示例
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 1.1\. Imperative programming
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1\. 命令式编程
- en: 'You probably see that this is a sort of language, containing some weird words
    like **main**, **`include`**, **`for`**, and so on, which are laid out and colored
    in a peculiar way and mixed with a lot of strange characters, numbers, and text
    (“*Doing some work*”) that looks like ordinary English. It is designed to provide
    a link between us, the human programmers, and a machine, the computer, to tell
    it what to do: to give it “orders.”'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能看到这是一种语言，包含一些奇怪的词，如**main**、**`include`**、**`for`**等等，它们以独特的方式排列和着色，并与大量奇怪的字符、数字和文本（“*做一些工作*”）混合在一起，看起来像普通的英语。它旨在在我们人类程序员和机器之间建立联系，告诉它该做什么：下达“命令”。
- en: '|  |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 1.1
  id: totrans-22
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 1.1
- en: '*C is an imperative programming language.*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*C是一种命令式编程语言*。'
- en: '|  |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In this book, we will not only encounter the C programming language, but also
    some vocabulary from an English dialect, C *jargon*, the language that helps us
    *to talk about C*. It will not be possible to immediately explain each term the
    first time it occurs. But I will explain each one in time, and all of them are
    indexed so you can easily cheat and *jump**^C* to more explanatory text, at your
    own risk.^([[1](#ch01fn01)])
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们不仅会遇到C编程语言，还会遇到一些来自英语方言的词汇，C *术语*，帮助我们*谈论C*的语言。第一次出现时，不可能立即解释每个术语。但我会及时解释每个术语，并且它们都有索引，你可以轻松地作弊并*跳转*^C*到更详细的文本，风险自负.^([[1](#ch01fn01)])
- en: ¹
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Such special terms from C jargon are marked with a *C*, as shown here.
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如此特殊的C术语用*C*标记，如下所示。
- en: 'As you can probably guess from this first example, such a C program has different
    components that form some intermixed layers. Let’s try to understand it from the
    inside out. The visible result of running this program is to output 5 lines of
    text on the command terminal of your computer. On my computer, using this program
    looks something like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能从第一个例子中猜到的，这样的C程序有不同的组件，它们形成了一些混合层。让我们从内部开始尝试理解它。运行此程序的可视结果是输出您计算机命令行上的5行文本。在我的计算机上，使用此程序看起来像这样：
- en: '`Terminal`'
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`终端`'
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can easily identify within our program the parts of the text that this program
    outputs (*prints**^C*, in C jargon): the part of line 17 between quotes. The real
    action happens between that line and line 20\. C calls this a *statement**^C*,
    which is a bit of a misnomer. Other languages would use the term *instruction*,
    which describes the purpose better. This particular statement is a *call**^C*
    to a *function**^C* named **printf**:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地在我们程序中识别出程序输出的文本部分（在C术语中称为*打印*^C*）：第17行之间的引号部分。真正的动作发生在这一行和第20行之间。C称这为*语句*^C*，这有点名不副实。其他语言会使用*指令*这个术语，它更好地描述了其目的。这个特定的语句是对名为**printf**的*函数*^C*的*调用*^C*：
- en: '`getting-started.c`'
  id: totrans-33
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`getting-started.c`'
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, the **printf** function receives four *arguments**^C*, enclosed in a
    pair of *parentheses**^C*, `( ... )`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，**printf**函数接收四个*参数*^C*，用一对*括号*^C*括起来，`( ... )`：
- en: 'The funny-looking text (between the quotes) is a so-called *string literal**^C*
    that serves as a *format**^C* for the output. Within the text are three markers
    (*format specifiers**^C*) that indicate the positions in the output where numbers
    are to be inserted. These markers start with a `%` character. This format also
    contains some special *escape characters**^C* that start with a backslash: `\`t
    and `\`n.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看起来奇怪的文本（在引号之间）是一种所谓的*字符串字面量*^C*，它作为输出的*格式*^C*。在文本中有三个标记（*格式说明符*^C*），它们指示输出中插入数字的位置。这些标记以一个`%`字符开始。此格式还包含一些特殊的*转义字符*^C*，它们以反斜杠开始：`\`t和`\`n。
- en: After a comma character, we find the word i. The thing i stands for will be
    printed in place of the first format specifier, %zu.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在逗号字符之后，我们找到了单词i。i所代表的内容将打印在第一个格式说明符%zu的位置上。
- en: Another comma separates the next argument A`[`i`]`. The thing this stands for
    will be printed in place of the second format specifier, the first `%`g.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个逗号将下一个参数A`[`i`]`分隔开来。这个参数所代表的内容将打印在第二个格式说明符，即第一个`%`g的位置上。
- en: Last, again separated by a comma, appears A`[`i`]*`A`[`i`]`, corresponding to
    the last `%`g.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，再次用逗号分隔，出现A`[`i`]*`A`[`i`]`，对应于最后一个`%`g。
- en: We will later explain what all of these arguments mean. Just remember that we
    identified the main purpose of the program (to print some lines on the terminal)
    and that it “orders” the **printf** function to fulfill that purpose. The rest
    is some *sugar**^C* to specify which numbers will be printed, and how many of
    them.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会解释所有这些参数的含义。只需记住，我们已经确定了程序的主要目的（在终端上打印一些行）并且它“指示”**printf**函数来实现这个目的。其余的部分是一些*糖分*，用于指定要打印哪些数字以及打印多少个。
- en: 1.2\. Compiling and running
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2\. 编译和运行
- en: 'As shown in the previous section, the program text expresses what we want our
    computer to do. As such, it is just another piece of text that we have written
    and stored somewhere on our hard disk, but the program text as such cannot be
    understood by your computer. There is a special program, called a *compiler*,
    that translates the C text into something that your machine can understand: the
    *binary code**^C* or *executable**^C*. What that translated program looks like
    and how this translation is done are much too complicated to explain at this stage.^([[2](#ch01fn02)])
    Even this entire book will not be able to explain most of it; that would be the
    subject of another whole book. However, for the moment, we don’t need to understand
    more deeply, as we have the tool that does all the work for us.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，程序文本表达了我们希望计算机执行的操作。因此，它只是我们写下来并存储在硬盘上的另一段文本，但程序文本本身不能被你的计算机理解。有一个特殊的程序，称为*编译器*，它将C文本翻译成你的机器可以理解的东西：*二进制代码**^C*或*可执行文件**^C*。这个翻译程序看起来是什么样子以及这种翻译是如何进行的，在这个阶段解释得太复杂了.^([[2](#ch01fn02)])
    即使整本书也无法解释大部分内容；那将是另一本书的主题。然而，目前我们不需要深入了解，因为我们有为我们做所有工作的工具。
- en: ²
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In fact, the *translation* itself is done in several steps that go from textual
    replacement, over proper compilation, to linking. Nevertheless, the tool that
    bundles all this is traditionally called a *compiler* and not a *translator*,
    which would be more accurate.
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 实际上，*翻译*本身是在几个步骤中完成的，从文本替换，经过适当的编译，到链接。尽管如此，将所有这些捆绑在一起的工具传统上被称为*编译器*，而不是*翻译器*，后者更准确。
- en: '|  |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 1.2
  id: totrans-47
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 收获1.2
- en: '*C is a compiled programming language.*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*C是一种编译型编程语言*。'
- en: '|  |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'The name of the compiler and its command-line arguments depend a lot on the
    *platform**^C* on which you will be running your program. There is a simple reason
    for this: the target binary code is *platform dependent**^C*: that is, its form
    and details depend on the computer on which you want to run it. A PC has different
    needs than a phone, and your refrigerator doesn’t speak the same “language” as
    your set-top box. In fact, that’s one of the reasons for C to exist: C provides
    a level of abstraction for all the different machine-specific languages (usually
    referred to as *assembler**^C*).'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器的名称及其命令行参数在很大程度上取决于你将在其上运行程序的*平台**^C*。这有一个简单的理由：目标二进制代码是*平台相关**^C*的：也就是说，其形式和细节取决于你想要在其上运行它的计算机。PC和手机有不同的需求，你的冰箱和机顶盒使用的“语言”也不相同。事实上，这就是C存在的一个原因：C为所有不同的机器特定语言提供了一种抽象级别（通常被称为*汇编器**^C*）。
- en: '|  |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 1.3
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 收获1.3
- en: '*A correct C program is portable between different platforms.*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*正确的C程序在不同平台上是可移植的*。'
- en: '|  |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: In this book, we will put a lot of effort into showing you how to write “correct”
    C programs that ensure portability. Unfortunately, there are some platforms that
    claim to be “C” but do not conform to the latest standards; and there are conforming
    platforms that accept incorrect programs or provide extensions to the C standard
    that are not widely portable. So, running and testing a program on a single platform
    will not always guarantee portability.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将投入大量精力向你展示如何编写“正确”的C程序，以确保其可移植性。不幸的是，有些平台声称自己是“C”平台，但实际上并不符合最新的标准；还有一些符合标准的平台接受不正确的程序，或者提供对C标准的扩展，这些扩展并不广泛可移植。因此，在一个平台上运行和测试程序并不总是能保证其可移植性。
- en: It is the job of the compiler to ensure that the little program shown earlier,
    once translated for the appropriate platform, will run correctly on your PC, your
    phone, your set-top box, and maybe even your refrigerator.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器的任务是确保前面展示的小程序，一旦为适当的平台翻译，将在你的PC、你的手机、你的机顶盒上正确运行，甚至可能在你冰箱上运行。
- en: 'That said, if you have a POSIX system (such as Linux or macOS), there is a
    good chance that a program named `c99` might be present and that it is in fact
    a C compiler. You could try to compile the example program using the following
    command:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，如果你有一个POSIX系统（如Linux或macOS），那么一个名为`c99`的程序可能存在，并且实际上它是一个C编译器。你可以尝试使用以下命令编译示例程序：
- en: '`Terminal`'
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`终端`'
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The compiler should do its job without complaining and output an executable
    file called `getting-started` in your current directory.^([[[Exs 1]](#ch01fn-ex01)])
    In the example line,
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器应该无怨无悔地完成其工作，并在你的当前目录下输出一个名为`getting-started`的可执行文件.^([[[Exs 1]](#ch01fn-ex01)])
    在示例行中，
- en: ^([Exs 1])
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 1])
- en: ''
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Try the compilation command in your terminal.
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在你的终端中尝试编译命令。
- en: '`c99` is the compiler program.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`c99` 是编译程序。'
- en: '`-Wall` tells it to warn us about anything that it finds unusual.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Wall` 告诉它警告我们它发现的任何不寻常之处。'
- en: '`-o getting-started` tells it to store the *compiler output**^C* in a file
    named `getting-started`.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-o getting-started` 告诉它将*编译器输出*存储在名为 `getting-started` 的文件中。'
- en: '`getting-started.c` names the *source file**^C*, the file that contains the
    C code we have written. Note that the `.c` extension at the end of the filename
    refers to the C programming language.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getting-started.c` 命名了*源文件*，包含我们编写的 C 代码的文件。请注意，文件名末尾的 `.c` 扩展名指的是 C 编程语言。'
- en: '`-lm` tells it to add some standard mathematical functions if necessary; we
    will need those later on.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-lm` 告诉它在必要时添加一些标准数学函数；我们稍后会需要这些。'
- en: Now we can *execute**^C* our newly created *executable**^C*. Type in
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以*执行*我们新创建的*可执行文件*。输入
- en: '`Terminal`'
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`终端`'
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'and you should see exactly the same output as I showed you earlier. That’s
    what *portable* means: wherever you run that program, its *behavior**^C* should
    be the same.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到与我之前展示的完全相同的输出。这就是*便携性*的含义：无论你在哪里运行那个程序，它的*行为*应该是相同的。
- en: 'If you are not lucky and the compilation command didn’t work, you will have
    to look up the name of your *compiler**^C* in your system documentation. You might
    even have to install a compiler if one is not available.^([[3](#ch01fn03)]) The
    names of compilers vary. Here are some common alternatives that might do the trick:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运气不好，编译命令没有工作，你将不得不在你的系统文档中查找你的*编译器*的名称。你可能甚至需要安装一个编译器。[3](#ch01fn03) 编译器的名称各不相同。以下是一些可能有效的常见替代方案：
- en: ³
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is necessary in particular if you have a system with a Microsoft operating
    system. Microsoft’s native compilers do not yet fully support even C99, and many
    features that we discuss in this book will not work. For a discussion of the alternatives,
    you might have a look at Chris Wellons’ blog entry “Four Ways to Compile C for
    Windows” ([https://nullprogram.com/blog/2016/06/13/](https://nullprogram.com/blog/2016/06/13/)).
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这在特定情况下是必要的，尤其是如果你有一个使用微软操作系统的系统。微软的本地编译器尚未完全支持 C99，而且我们在这本书中讨论的许多功能可能无法工作。关于替代方案的讨论，你可能想看看
    Chris Wellons 的博客条目“四种在 Windows 上编译 C 的方法”([https://nullprogram.com/blog/2016/06/13/](https://nullprogram.com/blog/2016/06/13/))。
- en: '`Terminal`'
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`终端`'
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Some of these, even if they are present on your computer, might not compile
    the program without complaining.^([[[Exs 2]](#ch01fn-ex02)])
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这些中的一些，即使它们存在于你的计算机上，也可能不会在没有抱怨的情况下编译程序。[[[Exs 2]](#ch01fn-ex02)]
- en: ^([Exs 2])
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 2])
- en: ''
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Start writing a text report about your tests with this book. Note down which
    command worked for you.
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用这本书开始编写关于你测试的文本报告。记下哪些命令对你有效。
- en: 'With the program in [listing 1.1](#ch01ex01), we presented an ideal world:
    a program that works and produces the same result on all platforms. Unfortunately,
    when programming yourself, very often you will have a program that works only
    partially and that may produce wrong or unreliable results. Therefore, let us
    look at the program in [listing 1.2](#ch01ex07). It looks quite similar to the
    previous one.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 1.1](#ch01ex01) 中的程序中，我们展示了一个理想的世界：一个在所有平台上都能正常工作并产生相同结果的程序。不幸的是，当你自己编程时，你经常会遇到一个只部分工作且可能产生错误或不可靠结果的程序。因此，让我们看看
    [列表 1.2](#ch01ex07) 中的程序。它看起来与上一个非常相似。
- en: Listing 1.2\. An example of a C program with flaws
  id: totrans-84
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 1.2\. 一个有缺陷的 C 程序示例
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you run your compiler on this program, it should give you some *diagnostic**^C*
    information similar to this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这个程序上运行你的编译器，它应该给你一些类似的*诊断信息*：
- en: '`Terminal`'
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`终端`'
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here we had a lot of long “warning” lines that are even too long to fit on a
    terminal screen. In the end, the compiler produced an executable. Unfortunately,
    the output when we run the program is different. This is a sign that we have to
    be careful and pay attention to details.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多很长的“警告”行，甚至长到无法适应终端屏幕。最后，编译器生成了一个可执行文件。不幸的是，当我们运行程序时的输出是不同的。这是一个我们必须小心并注意细节的信号。
- en: '`clang` is even more picky than `gcc` and gives us even longer diagnostic lines:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`clang` 比起 `gcc` 更加挑剔，并给出了更长的诊断行：'
- en: '`Terminal`'
  id: totrans-91
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`终端`'
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is a good thing! Its *diagnostic output**^C* is much more informative.
    In particular, it gave us two hints: it expected a different return type for **main**,
    and it expected us to have a line such as line 3 from [listing 1.1](#ch01ex01)
    to specify where the **printf** function comes from. Notice how `clang`, unlike
    `gcc`, did not produce an executable. It considers the problem on line 22 fatal.
    Consider this to be a feature.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一件好事！它的 *诊断输出**^C* 非常具有信息量。特别是，它给出了两个提示：它期望 **main** 函数有不同的返回类型，并且它期望我们有一个类似于
    [列表 1.1](#ch01ex01) 中的第 3 行的行来指定 **printf** 函数的来源。注意 `clang` 与 `gcc` 不同，没有生成可执行文件。它认为第
    22 行的问题具有致命性。把这看作是一个特性。
- en: Depending on your platform, you can force your compiler to reject programs that
    produce such diagnostics. For `gcc`, such a command-line option would be `-Werror`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的平台，你可以强制编译器拒绝产生此类诊断的程序。对于 `gcc`，这样的命令行选项将是 `-Werror`。
- en: So we have seen two of the points in which [listings 1.1](#ch01ex01) and [1.2](#ch01ex07)
    differed, and these two modifications turned a good, standards-conforming, portable
    program into a bad one. We also have seen that the compiler is there to help us.
    It nailed the problem down to the lines in the program that cause trouble, and
    with a bit of experience you will be able to understand what it is telling you.^([[[Exs
    3]](#ch01fn-ex03)]) ^([[[Exs 4]](#ch01fn-ex04)])
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经看到了 [列表 1.1](#ch01ex01) 和 [1.2](#ch01ex07) 之间的两个不同点，这两个修改将一个良好、符合标准、可移植的程序变成了一个不好的程序。我们还看到编译器在那里帮助我们。它将问题锁定在程序中引起麻烦的行上，并且凭借一些经验，你将能够理解它在告诉你什么.^([[[Exs
    3]](#ch01fn-ex03)]) ^([[[Exs 4]](#ch01fn-ex04)])
- en: ^([Exs 3])
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 3])
- en: ''
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Correct [listing 1.2](#ch01ex07) step by step. Start from the first diagnostic
    line, fix the code that is mentioned there, recompile, and so on, until you have
    a flawless program.
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 逐步纠正 [列表 1.2](#ch01ex07)。从第一条诊断行开始，修复那里提到的代码，重新编译，等等，直到你有一个无瑕疵的程序。
- en: ^([Exs 4])
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 4])
- en: ''
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: There is a third difference between the two programs that we didn’t mention
    yet. Find it.
  id: totrans-101
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这两个程序之间还有一个我们尚未提到的第三个区别。找到它。
- en: '|  |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 1.4
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取得成果 1.4
- en: '*A C program should compile cleanly without warnings.*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*一个 C 程序应该无警告地干净编译。*'
- en: '|  |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Summary
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: C is designed to give computers orders. Thereby it mediates between us (the
    programmers) and computers.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C 是为了给计算机下命令而设计的。因此，它在程序员（我们）和计算机之间进行调解。
- en: C must be compiled to be executed. The compiler provides the translation between
    the language that we understand (C) and the specific needs of the particular platform.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C 必须编译后才能执行。编译器提供了我们理解的语言（C）与特定平台特定需求之间的翻译。
- en: C gives a level of abstraction that provides portability. One C program can
    be used on many different computer architectures.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C 提供了一个抽象级别，提供了可移植性。一个 C 程序可以在许多不同的计算机架构上使用。
- en: The C compiler is there to help you. If it warns you about something in your
    program, listen to it.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C 编译器在那里帮助你。如果你在程序中警告你关于某事，要听从它。
- en: Chapter 2\. The principal structure of a program
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二章. 程序的主要结构
- en: This chapter covers
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: C grammar
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C 语法
- en: Declaring identifiers
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明标识符
- en: Defining objects
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义对象
- en: Instructing the compiler with statements
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用语句指导编译器
- en: Compared to our little examples in the previous chapter, real programs will
    be more complicated and contain additional constructs, but their structure will
    be very similar. [Listing 1.1](kindle_split_008.html#ch01ex01) already has most
    of the structural elements of a C program.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一章中的小例子相比，真正的程序将更加复杂，并包含额外的结构，但它们的结构将非常相似。[列表 1.1](kindle_split_008.html#ch01ex01)
    已经包含了 C 程序的大部分结构元素。
- en: 'There are two categories of aspects to consider in a C program: syntactical
    aspects (how do we specify the program so the compiler understands it?) and semantic
    aspects (what do we specify so that the program does what we want it to do?).
    In the following sections, we will introduce the syntactical aspects (grammar)
    and three different semantic aspects: declarative parts (what things are), definitions
    of objects (where things are), and statements (what things are supposed to do).'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 程序中，有两个方面的考虑：语法方面（我们如何指定程序以便编译器理解它？）和语义方面（我们指定什么以便程序执行我们想要它执行的操作？）。在接下来的几节中，我们将介绍语法方面（语法）和三个不同的语义方面：声明部分（是什么事物），对象定义（事物在哪里），和语句（事物应该做什么）。
- en: 2.1\. Grammar
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1. 语法
- en: 'Looking at its overall structure, we can see that a C program is composed of
    different types of text elements that are assembled in a kind of grammar. These
    elements are:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 从其整体结构来看，我们可以看到C程序由不同类型的文本元素组成，这些元素按照某种语法组合在一起。这些元素包括：
- en: '***Special words:*** In [listing 1.1](kindle_split_008.html#ch01ex01), we used
    the following special words:^([[1](#ch02fn01)]) **`#include`**, **`int`**, **`void`**,
    **`double`**, **`for`**, and **`return`**. In program text in this book, they
    will usually be printed in bold face. These special words represent concepts and
    features that the C language imposes and that cannot be changed.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***特殊词汇：*** 在[列表1.1](kindle_split_008.html#ch01ex01)中，我们使用了以下特殊词汇：**`#include`**、**`int`**、**`void`**、**`double`**、**`for`**和**`return`**。在这本书的程序文本中，它们通常会被加粗。这些特殊词汇代表C语言强加的概念和特性，这些特性不能更改。'
- en: ¹
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: In C jargon, these are *directives^C*, *keywords^C*, and *reserved^C* identifiers.
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在C术语中，这些是*指令^C*、*关键字^C*和*保留^C*标识符。
- en: '***Punctuation^C:*** C uses several types of punctuation to structure the program
    text.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***标点符号^C：*** C语言使用几种类型的标点符号来结构化程序文本。'
- en: 'There are five kinds of brackets: `{ ... }`, `( ... )`, `[ ... ]`, /* ... */,
    and `< ... >`. Brackets *group* certain parts of the program together and should
    always come in pairs. Fortunately, the `< ... >` brackets are rare in C and are
    only used as shown in our example, on the same logical line of text. The other
    four are not limited to a single line; their contents might span several lines,
    as they did when we used **printf** earlier.'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有五种括号类型：`{ ... }`、`( ... )`、`[ ... ]`、`/* ... */`和`< ... >`。括号用于将程序的某些部分组合在一起，并且应该始终成对出现。幸运的是，在C语言中`<
    ... >`括号很少见，并且仅在我们示例中所示，位于同一逻辑行文本上。其他四种括号不受单行限制；它们的内含可能跨越多行，就像我们之前使用**printf**时那样。
- en: 'There are two different separators or terminators: comma and semicolon. When
    we used **printf**, we saw that commas *separated* the four arguments of that
    function; and on line 12 we saw that a comma also can follow the last element
    of a list of elements.'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有两种不同的分隔符或终止符：逗号和分号。当我们使用**printf**时，我们看到逗号用于分隔该函数的四个参数；在第12行我们也看到逗号也可以跟在元素列表的最后一个元素后面。
- en: '`getting-started.c`'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`getting-started.c`'
- en: '[PRE9]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: One of the difficulties for newcomers in C is that the same punctuation characters
    are used to express different concepts. For example, the pairs `{}` and `[]` are
    each used for three different purposes in [listing 1.1](kindle_split_008.html#ch01ex01).^([[[Exs
    1]](#ch02fn-ex01)])
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: C语言新手的困难之一是相同的标点符号用于表达不同的概念。例如，成对出现的`{}`和`[]`在[列表1.1](kindle_split_008.html#ch01ex01)中各自用于三个不同的目的).^([[[Exs
    1]](#ch02fn-ex01)])
- en: ^([Exs 1])
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 1])
- en: ''
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: Find these different uses of these two sorts of brackets.
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 找出这些两种括号的不同用法。
- en: '|  |'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|'
- en: Takeaway 2.1
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 2.1
- en: '*Punctuation characters can be used with several different meanings.*'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*标点符号可以具有多种不同的含义*。'
- en: '|  |'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  |'
- en: '***Comments^C:*** The construct /* ... */ that we saw earlier tells the compiler
    that everything inside it is a *comment*; see, for example, line 5:'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***注释^C：*** 我们之前看到的`/* ... */`构造告诉编译器，它内部的所有内容都是*注释*；例如，查看第5行：'
- en: '`getting-started.c`'
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`getting-started.c`'
- en: '[PRE10]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Comments are ignored by the compiler. It is the perfect place to explain and
    document your code. Such in-place documentation can (and should) greatly improve
    the readability and comprehensibility of your code. Another form of comment is
    the so-called C++-style comment, as on line 15\. These are marked with //. C++-style
    comments extend from the // to the end of the line.
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注释被编译器忽略。这是解释和记录代码的完美地方。这种内联文档可以（并且应该）极大地提高代码的可读性和可理解性。另一种形式的注释是所谓的C++风格注释，如第15行所示。这些注释以`//`开始，延伸到行尾。
- en: '***Literals^C:*** Our program contains several items that refer to fixed values
    that are part of the program: `0`, `1`, `3`, `4`, `5`, `9.0`, `2.9`, `3.`E`+25`,
    `.00007`, and "element %zu is %g, \tits square is %g\n". These are called *literals**^C*.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***字面量^C：*** 我们程序包含几个引用固定值的项，这些值是程序的一部分：`0`、`1`、`3`、`4`、`5`、`9.0`、`2.9`、`3.E+25`、`.00007`和`"element
    %zu is %g, \tits square is %g\n"`。这些被称为*字面量^C*。'
- en: '***Identifiers^C:*** These are “names” that we (or the C standard) give to
    certain entities in the program. Here we have A, i, **main**, **printf**, **`size_t`**,
    and **`EXIT_SUCCESS`**. Identifiers can play different roles in a program. Among
    other things, they may refer to'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***标识符^C：*** 这些是我们（或C标准）给程序中某些实体赋予的“名称”。在这里我们有A、i、**main**、**printf**、**`size_t`**和**`EXIT_SUCCESS`**。标识符在程序中可以扮演不同的角色。在其他方面，它们可能指代'
- en: '*Data objects**^C* (such as A and i). These are also referred to as *variables**^C*.'
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据对象**^C*（如 A 和 i）。这些也被称为 **变量**^C*。'
- en: '*Type**^C* aliases, such as **`size_t`**, that specify the “sort” of a new
    object, here of i. Observe the trailing **`_t`** in the name. This naming convention
    is used by the C standard to remind you that the identifier refers to a type.'
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型**^C* 别名，如 **`size_t`**，指定了新对象“种类”，这里是指 i。注意名称末尾的 **`_t`**。这种命名约定是 C 标准用来提醒你该标识符指的是一个类型的。'
- en: Functions, such as **main** and **printf**.
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数，如 **main** 和 **printf**。
- en: Constants, such as **`EXIT_SUCCESS`**.
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常量，如 **`EXIT_SUCCESS`**。
- en: '***Functions^C:*** Two of the identifiers refer to functions: **main** and
    **printf**. As we have already seen, **printf** is *used* by the program to produce
    some output. The function **main** in turn is *defined**^C*: that is, its *declaration**^C*
    **`int`** **main**`(`**`void`**`)` is followed by a *block**^C* enclosed in `{
    ... }` that describes what that function is supposed to do. In our example, this
    function *definition**^C* goes from line 6 to 24\. **main** has a special role
    in C programs, as we will encounter: it must always be present, since it is the
    starting point of the program’s execution.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***函数^C：*** 两个标识符指的是函数：**main** 和 **printf**。正如我们之前所看到的，**printf** 是程序用来产生一些输出的。函数
    **main** 由此被 **定义**^C*：也就是说，它的 **声明**^C* **`int`** **main**`(`**`void`**`)` 后面跟着一个
    **块**^C*，用 `{ ... }` 包围，描述了这个函数应该做什么。在我们的例子中，这个函数 **定义**^C* 从第 6 行到第 24 行。**main**
    在 C 程序中有一个特殊的作用，我们将会遇到：它必须始终存在，因为它是程序执行的开始点。'
- en: '***Operators^C:*** Of the numerous C operators, our program only uses a few:'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***运算符^C：*** 在众多的 C 运算符中，我们的程序只使用了几个：'
- en: '`=` for *initialization**^C* and *assignment**^C*,'
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`=` 用于 **初始化**^C* 和 **赋值**^C*，'
- en: '`<` for comparison,'
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<` 用于比较，'
- en: '`++` to *increment* a variable (to increase its value by `1`), and'
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`++` 用于 **递增** 一个变量（将其值增加 `1`），以及'
- en: '`*` to multiply two values.'
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*` 用于乘以两个值。'
- en: 'Just as in natural languages, the lexical elements and the grammar of C programs
    that we have seen here have to be distinguished from the actual meaning these
    constructs convey. In contrast to natural languages, though, this meaning is rigidly
    specified and usually leaves no room for ambiguity. In the following sections,
    we will dig into the three main semantic categories that C distinguishes: declarations,
    definitions, and statements.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在自然语言中一样，我们在这里看到的 C 程序的词法元素和语法必须与这些构造的实际意义区分开来。然而，与自然语言不同的是，这种意义是严格指定的，通常没有歧义的空间。在接下来的几节中，我们将深入研究
    C 区分的三个主要语义类别：声明、定义和语句。
- en: 2.2\. Declarations
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2. 声明
- en: 'Before we may use a particular identifier in a program, we have to give the
    compiler a *declaration**^C* that specifies what that identifier is supposed to
    represent. This is where identifiers differ from keywords: keywords are predefined
    by the language and must not be declared or redefined.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以在程序中使用特定的标识符之前，我们必须向编译器提供一个 **声明**^C*，指定该标识符应该代表什么。这就是标识符与关键字的不同之处：关键字是由语言预定义的，不能声明或重新定义。
- en: '|  |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 2.2
  id: totrans-158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 2.2
- en: '*All identifiers in a program have to be declared.*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序中的所有标识符都必须声明**。'
- en: '|  |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Three of the identifiers we use are effectively declared in our program: **main**,
    A, and i. Later on, we will see where the other identifiers (**printf**, **`size_t`**,
    and **`EXIT_SUCCESS`**) come from. We already mentioned the declaration of the
    **main** function. All three declarations, in isolation as “declarations only,”
    look like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在程序中实际声明的三个标识符是：**main**、A 和 i。稍后，我们将看到其他标识符（**printf**、**`size_t`** 和 **`EXIT_SUCCESS`**）的来源。我们已经提到了
    **main** 函数的声明。这三个声明，单独作为“仅声明”，看起来是这样的：
- en: '[PRE11]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'These three follow a pattern. Each has an identifier (**main**, A, or i) and
    a specification of certain properties that are associated with that identifier:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个标识符遵循一个模式。每个都有一个标识符（**main**、A 或 i）以及与该标识符相关联的某些属性：
- en: i is of *type**^C* **`size_t`**.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: i 的 **类型**^C* 是 **`size_t`**。
- en: '**main** is additionally followed by parentheses, `( ... )`, and thus declares
    a function of type **`int`**.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**main** 还额外跟随着括号，`( ... )`，因此声明了一个 **`int`** 类型的函数。'
- en: A is followed by brackets, `[ ... ]`, and thus declares an *array**^C*. An array
    is an aggregate of several items of the same type; here it consists of `5` items
    of type **`double`**. These `5` items are ordered and can be referred to by numbers,
    called *indices**^C*, from `0` to `4`.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A 后跟方括号 `[ ... ]`，因此声明了一个 *数组**^C*。数组是相同类型几个项的聚合；这里由 `5` 个类型为 **`double`** 的项组成。这些
    `5` 个项是有序的，可以通过数字（称为 *索引**^C*）从 `0` 到 `4` 来引用。
- en: Each of these declarations starts with a *type**^C*, here **`int`**, **`double`**,
    and **`size_t`**. We will see later what that represents. For the moment, it is
    sufficient to know that this specifies that all three identifiers, when used in
    the context of a statement, will act as some sort of “numbers.”
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这些声明都以一个 *类型**^C* 开头，这里 **`int`**、**`double`** 和 **`size_t`**。我们稍后会看到这代表什么。目前，只需知道这指定了所有三个标识符在语句的上下文中将作为某种“数字”使用。
- en: 'The declarations of i and A declare *variables**^C*, which are named items
    that allow us to store *values**^C*. They are best visualized as a kind of box
    that may contain a “something” of a particular type:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: i 和 A 的声明声明了 *变量**^C*，它们是命名项，允许我们存储 *值**^C*。它们最好被想象成一种可能包含特定类型“某物”的盒子：
- en: '![](pg_014_alt.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](pg_014_alt.jpg)'
- en: Conceptually, it is important to distinguish the box itself (the *object*),
    the specification (its *type*), the box contents (its *value*), and the name or
    label that is written on the box (the *identifier*). In such diagrams, we put
    `??` if we don’t know the actual value of an item.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，区分盒子本身（*对象*）、规范（其 *类型*）、盒子内容（其 *值*）以及写在上面的名称或标签（*标识符*）是很重要的。在这些图中，如果我们不知道一个项的实际值，我们会放
    `??`。
- en: 'For the other three identifiers, **printf**, **`size_t`**, and **`EXIT_SUCCESS`**,
    we don’t see any declaration. In fact, they are predeclared identifiers, but as
    we saw when we tried to compile [listing 1.2](kindle_split_008.html#ch01ex07),
    the information about these identifiers doesn’t come out of nowhere. We have to
    tell the compiler where it can obtain information about them. This is done right
    at the start of the program, in lines 2 and 3: **printf** is provided by `stdio.h`,
    whereas **`size_t`** and **`EXIT_SUCCESS`** come from `stdlib.h`. The real declarations
    of these identifiers are specified in `.h` files with these names somewhere on
    your computer. They could be something like:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他三个标识符，**printf**、**`size_t`** 和 **`EXIT_SUCCESS`**，我们没有看到任何声明。实际上，它们是预声明的标识符，但正如我们在尝试编译[列表
    1.2](kindle_split_008.html#ch01ex07)时所看到的，这些标识符的信息并非凭空而来。我们必须告诉编译器它们可以从哪里获取这些信息。这是在程序的开始处，在第
    2 行和第 3 行完成的：**printf** 由 `stdio.h` 提供，而 **`size_t`** 和 **`EXIT_SUCCESS`** 来自
    `stdlib.h`。这些标识符的真实声明在计算机上的某个位置以这些名称指定的 `.h` 文件中指定。它们可能如下所示：
- en: '|  |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '`<stdio.h>`'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`<stdio.h>`'
- en: '`<stdlib.h>`'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`<stdlib.h>`'
- en: '|  |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[PRE12]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Because the specifics of these predeclared features are of minor importance,
    this information is normally hidden from you in these *include files**^C* or *header
    files**^C*. If you need to know their semantics, it is usually a bad idea to look
    them up in the corresponding files, as these tend to be barely readable. Instead,
    search in the documentation that comes with your platform. For the brave, I always
    recommend a look into the current C standard, as that is where they all come from.
    For the less courageous, the following commands may help:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些预声明特性的具体细节不太重要，这些信息通常在这些 *包含文件**^C* 或 *头文件**^C* 中对你隐藏。如果你需要了解它们的语义，通常在相应的文件中查找它们不是一个好主意，因为这些文件往往难以阅读。相反，你应该在你的平台提供的文档中进行搜索。对于勇敢的人，我总是推荐查看当前的
    C 标准，因为所有这些标准都来源于此。对于不那么勇敢的人，以下命令可能会有所帮助：
- en: '`Terminal`'
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`终端`'
- en: '[PRE13]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: A declaration only describes a feature but does not create it, so repeating
    a declaration does not do much harm but adds redundancy.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 声明仅描述一个特性，但不会创建它，因此重复声明并不会造成太大伤害，但会增加冗余。
- en: '|  |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 2.3
  id: totrans-182
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 收获 2.3
- en: '*Identifiers may have several consistent declarations.*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*标识符可能有多个一致的声明*。'
- en: '|  |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Clearly, it would become really confusing (for us or the compiler) if there
    were several contradicting declarations for the same identifier in the same part
    of the program, so generally this is not allowed. C is quite specific about what
    “the same part of the program” is supposed to mean: the *scope**^C* is a part
    of the program where an identifier is *visible**^C*.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，如果在程序的同一部分有多个针对同一标识符的矛盾声明，这将变得非常令人困惑（对我们或编译器来说），因此通常不允许这样做。C 对“程序的同一部分”的含义非常具体：*作用域**^C*
    是一个标识符可见的程序的某个部分。
- en: '|  |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 2.4
  id: totrans-187
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 收获 2.4
- en: '*Declarations are bound to the scope in which they appear.*'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*声明绑定到它们出现的作用域中*。'
- en: '|  |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'These scopes of identifiers are unambiguously described by the grammar. In
    [listing 1.1](kindle_split_008.html#ch01ex01), we have declarations in different
    scopes:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符的作用域由语法明确描述。在[列表1.1](kindle_split_008.html#ch01ex01)中，我们有不同作用域中的声明：
- en: A is visible inside the definition of **main**, starting at its declaration
    on line 8 and ending at the closing `}` on line 24 of the innermost `{ ... }`
    block that contains that declaration.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A在**main**函数的定义内部可见，从第8行的声明开始，到包含该声明的最内层`{ ... }`块的结束`}`，即第24行。
- en: i has more restricted visibility. It is bound to the **`for`** construct in
    which it is declared. Its visibility reaches from that declaration on line 16
    to the end of the `{ ... }` block that is associated with the **`for`** on line
    21.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: i的可见性更受限制。它绑定到它声明的**`for`**结构中。它的可见性从第16行的声明开始，延伸到与第21行的**`for`**关联的`{ ... }`块的末尾。
- en: '**main** is not enclosed in a `{ ... }` block, so it is visible from its declaration
    onward until the end of the file.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**main**函数没有被包含在`{ ... }`块中，因此从它的声明开始直到文件结束都是可见的。'
- en: In a slight abuse of terminology, the first two types of scope are called *block
    scope**^C*, because the scope is limited by a *block**^C* of matching `{ ... }`.
    The third type, as used for **main**, which is not inside a `{ ... }` pair, is
    called *file scope**^C*. Identifiers in file scope are often referred to as *globals*.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在术语的轻微滥用中，前两种作用域被称为*块作用域*，因为作用域受*块*的限制。第三种类型，用于**main**，它不在`{ ... }`对中，被称为*文件作用域*。文件作用域中的标识符通常被称为*全局变量*。
- en: 2.3\. Definitions
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3. 定义
- en: Generally, declarations only specify the kind of object an identifier refers
    to, not what the concrete value of an identifier is, nor where the object it refers
    to can be found. This important role is filled by a *definition**^C*.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，声明只指定一个标识符所引用的对象类型，而不是标识符的具体值，也不是它所引用的对象可以在哪里找到。这个重要的角色由一个*定义*来填补。
- en: '|  |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 2.5
  id: totrans-198
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取得成果2.5
- en: '*Declarations specify identifiers, whereas definitions specify objects.*'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '*声明指定标识符，而定义指定对象*。'
- en: '|  |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: We will later see that things are a little more complicated in real life, but
    for now we can make the simplification that we will always initialize our variables.
    An *initialization* is a grammatical construct that augments a declaration and
    provides an initial value for the object. For instance,
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后将会看到，在现实生活中事情要复杂一些，但到目前为止，我们可以简化为：我们总是初始化我们的变量。*初始化*是一种语法结构，它增强声明并提供对象的初始值。例如，
- en: '[PRE14]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: is a declaration of i such that the initial value is `0`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 是一个声明，其中i的初始值为`0`。
- en: 'In C, such a declaration with an initializer also *defines* the object with
    the corresponding name: that is, it instructs the compiler to provide storage
    in which the value of the variable can be stored.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在C语言中，这样的带有初始化器的声明也*定义*了具有相应名称的对象：也就是说，它指示编译器提供存储空间，以便变量的值可以存储在其中。
- en: '|  |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 2.6
  id: totrans-206
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取得成果2.6
- en: '*An object is defined at the same time it is initialized.*'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '*对象在初始化的同时被定义*。'
- en: '|  |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Our box visualization can now be completed with a value, `0` in this example:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以用一个值，在这个例子中是`0`，来完成我们的盒子可视化：
- en: '![](pg_016-01.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图片](pg_016-01.jpg)'
- en: 'A is a bit more complex because it has several components:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: A稍微复杂一些，因为它有几个组成部分：
- en: '`getting-started.c`'
  id: totrans-212
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`getting-started.c`'
- en: '[PRE15]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This initializes the `5` items in A to the values `9.0`, `2.9`, `0.0`, `0.00007`,
    and `3.`0`E+25`, in that order:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这将A中的`5`个元素初始化为`9.0`、`2.9`、`0.0`、`0.00007`和`3.`0`E+25`，顺序如下：
- en: '![](pg_016-02_alt.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![图片](pg_016-02_alt.jpg)'
- en: 'The form of an initializer that we see here is called *designated**^C*: a pair
    of brackets with an integer *designate* which item of the array is initialized
    with the corresponding value. For example, `[4] = 3.`E`+25` sets the last item
    of the array A to the value `3.`E`+25`. As a special rule, any position that is
    not listed in the initializer is set to `0`. In our example, the missing `[2]`
    is filled with `0.0`.^([[2](#ch02fn02)])'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到的初始化器的形式被称为*指定*：一对带有整数的方括号，该整数*指定*数组中的哪个元素用相应的值进行初始化。例如，`[4] = 3.`E`+25`将数组A的最后一个元素设置为`3.`E`+25`。作为一条特殊规则，初始化器中没有列出的任何位置都被设置为`0`。在我们的例子中，缺失的`[2]`被填充为`0.0`。^([[2](#ch02fn02)])
- en: ²
  id: totrans-217
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-218
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We will see later how these number literals with dots (`.`) and exponents (E`+25`)
    work.
  id: totrans-219
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们稍后将会看到这些带有小数点（`.`）和指数（E`+25`）的数字字面量是如何工作的。
- en: '|  |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 2.7
  id: totrans-221
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取得成果2.7
- en: '*Missing elements in initializers default to `0`.*'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '*初始化器中缺失的元素默认为 `0`。*'
- en: '|  |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: You might have noticed that array positions, *indices**^C*, do not start with
    `1` for the first element, but with `0`. Think of an array position as the distance
    of the corresponding array element from the start of the array.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，数组位置，*索引**^C*，对于第一个元素不是从 `1` 开始，而是从 `0` 开始。将数组位置想象成对应数组元素从数组开始处的距离。
- en: '|  |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 2.8
  id: totrans-226
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 2.8
- en: '*For an array with n elements, the first element has index 0, and the last
    has index n-1.*'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '*对于具有 n 个元素的数组，第一个元素的索引为 0，最后一个元素的索引为 n-1。*'
- en: '|  |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'For a function, we have a definition (as opposed to only a declaration) if
    its declaration is followed by braces `{ ... }` containing the code of the function:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个函数，如果其声明后面跟着包含函数代码的花括号 `{ ... }`，则我们有一个定义（而不是只有声明）：
- en: '[PRE16]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In our examples so far, we have seen names for two different features: *objects**^C*,
    i and A, and *functions**^C*, **main** and **printf**. In contrast to object or
    function declarations, where several are allowed for the same identifier, definitions
    of objects or functions must be unique. That is, for a C program to be operational,
    any object or function that is used must have a definition (otherwise the execution
    would not know where to look for them), and there must be no more than one definition
    (otherwise the execution could become inconsistent).'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的例子中，我们已经看到了两个不同特征的名称：*对象**^C*，i 和 A，以及 *函数**^C*，**main** 和 **printf**。与对象或函数声明不同，对于相同的标识符允许有多个，对象或函数的定义必须是唯一的。也就是说，为了让
    C 程序能够运行，任何使用到的对象或函数都必须有一个定义（否则执行将不知道在哪里查找它们），并且定义不能超过一个（否则执行可能会变得不一致）。
- en: '|  |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 2.9
  id: totrans-233
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 2.9
- en: '*Each object or function must have exactly one definition.*'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '*每个对象或函数必须有一个确切的定义。*'
- en: '|  |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 2.4\. Statements
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4\. 语句
- en: The second part of the **main** function consists primarily of *statements*.
    Statements are instructions that tell the compiler what to do with identifiers
    that have been declared so far. We have
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**main** 函数的第二部分主要由 *语句* 组成。语句是告诉编译器如何处理之前已声明的标识符的指令。我们有'
- en: '`getting-started.c`'
  id: totrans-238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`getting-started.c`'
- en: '[PRE17]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We have already discussed the lines that correspond to the call to **printf**.
    There are also other types of statements: **`for`** and **`return`** statements,
    and an increment operation, indicated by the *operator**^C* `++`. In the following
    section, we will go a bit into the details of three categories of statements:
    *iterations* (do something several times), *function calls* (delegate execution
    somewhere else), and *function returns* (resume execution from where a function
    was called).'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了与 **printf** 调用对应的行。还有其他类型的语句：**`for`** 和 **`return`** 语句，以及一个增量操作，由
    *运算符**^C* `++` 表示。在下一节中，我们将深入探讨三类语句的细节：*迭代*（多次执行某项操作）、*函数调用*（将执行委托到其他地方）和 *函数返回*（从函数被调用的位置恢复执行）。
- en: 2.4.1\. Iteration
  id: totrans-241
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.4.1\. 迭代
- en: The **`for`** statement tells the compiler that the program should execute the
    **printf** line a number of times. This is the simplest form of *domain iteration**^C*
    that C has to offer. It has four different parts.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**`for`** 语句告诉编译器程序应该执行 **printf** 行多次。这是 C 提供的最简单的 *域迭代**^C* 形式。它有四个不同的部分。'
- en: 'The code that is to be repeated is called the *loop body**^C*: it is the `{
    ... }` block that follows the **`for`** `( ... )`. The other three parts are those
    inside the `( ... )` part, divided by semicolons:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 要重复执行的代码称为 *循环体**^C*：它是跟随 **`for`** `( ... )` 的 `{ ... }` 块。其他三个部分是 `( ... )`
    部分内的内容，由分号分隔：
- en: The declaration, definition, and initialization of the *loop variable**^C* i,
    which we already discussed. This initialization is executed once before any of
    the rest of the entire **`for`** statement.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经讨论过的 *循环变量**^C* i 的声明、定义和初始化。这个初始化是在整个 **`for`** 语句的其余部分执行之前只执行一次。
- en: A *loop condition**^C*, i `< 5` specifies how long the **`for`** iteration should
    continue. This tells the compiler to continue iterating as long as i is strictly
    less than `5`. The loop condition is checked before each execution of the loop
    body.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*循环条件**^C*，i `< 5` 指定了 **`for`** 迭代应该持续多长时间。这告诉编译器只要 i 严格小于 `5` 就继续迭代。循环条件在每次执行循环体之前都会进行检查。'
- en: Another statement, `++`i, is executed after each iteration. In this case, it
    increases the value of i by `1` each time.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个语句，`++`i，在每次迭代后执行。在这种情况下，它每次将 i 的值增加 `1`。
- en: If we put all of these together, we ask the program to perform the part in the
    block five times, setting the value of i to `0`, `1`, `2`, `3`, and `4`, respectively,
    in each iteration. The fact that we can identify each iteration with a specific
    value for i makes this an iteration over the *domain**^C* `0`, . . ., `4`. There
    is more than one way to do this in C, but **`for`** is the easiest, cleanest,
    and best tool for the task.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将所有这些放在一起，我们要求程序在块中执行五次部分，分别将 i 的值设置为 `0`、`1`、`2`、`3` 和 `4`，在每次迭代中。我们可以将每个迭代与
    i 的特定值相对应的事实使得这是一个对 *域**^C* `0`、...、`4` 的迭代。在 C 中做这件事的方式不止一种，但 **`for`** 是完成这项任务最简单、最干净、最好的工具。
- en: '|  |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 2.10
  id: totrans-249
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 2.10
- en: '*Domain iterations should be coded with a* **`for`** *statement.*'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '*域迭代应该用* **`for`** *语句编码。*'
- en: '|  |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'A **`for`** statement can be written in several ways other than what we just
    saw. Often, people place the definition of the loop variable somewhere before
    the **`for`** or even reuse the same variable for several loops. Don’t do that:
    to help an occasional reader and the compiler understand your code, it is important
    to know that this variable has the special meaning of an iteration counter for
    that given **`for`** loop.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们刚才看到的方式之外，**`for`** 语句还可以用几种其他方式来编写。通常，人们会在 **`for`** 之前或甚至重用相同的变量为几个循环定义循环变量的定义。不要这样做：为了帮助偶尔的读者和编译器理解你的代码，了解这个变量对于给定的那个
    **`for`** 循环有迭代计数器的特殊意义是很重要的。
- en: '|  |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 2.11
  id: totrans-254
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 2.11
- en: '*The loop variable should be defined in the initial part of a* **`for`***.*'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '*循环变量应该在* **`for`*** 的初始部分定义。*'
- en: '|  |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 2.4.2\. Function calls
  id: totrans-257
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.4.2\. 函数调用
- en: '*Function calls* are special statements that suspend the execution of the current
    function (at the beginning, this is usually **main**) and then hand over control
    to the named function. In our example'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数调用* 是特殊的语句，它暂停当前函数（开始时通常是 **main**）的执行，然后将控制权交给命名的函数。在我们的例子中'
- en: '`getting-started.c`'
  id: totrans-259
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`getting-started.c`'
- en: '[PRE18]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'the called function is **printf**. A function call usually provides more than
    just the name of the function, but also *arguments*. Here, these are the long
    chain of characters, i, A`[`i`]`, and A`[`i`]*`A`[`i`]`. The *values* of these
    arguments are passed over to the function. In this case, these values are the
    information that is printed by **printf**. The emphasis here is on “value”: although
    i is an argument, **printf** will never be able to change i itself. Such a mechanism
    is called *call by value*. Other programming languages also have *call by reference*,
    a mechanism where the called function can change the value of a variable. C does
    not implement pass by reference, but it has another mechanism to pass the control
    of a variable to another function: by taking addresses and transmitting pointers.
    We will see these mechanism much later.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 被调用的函数是 **printf**。函数调用通常不仅提供函数的名称，还提供 *参数*。在这里，这些是长链字符，i、A`[`i`]` 和 A`[`i`]*`A`[`i`]`。这些参数的
    *值* 被传递给函数。在这种情况下，这些值是 **printf** 打印的信息。这里的重点是“值”：尽管 i 是一个参数，但 **printf** 永远不能改变
    i 本身。这种机制称为 *按值调用*。其他编程语言也有 *按引用调用*，这是一种调用函数可以改变变量值的机制。C 不实现按引用传递，但它有另一种机制将变量的控制权传递给另一个函数：通过取地址和传递指针。我们将在稍后看到这些机制。
- en: 2.4.3\. Function return
  id: totrans-262
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.4.3\. 函数返回
- en: The last statement in **main** is a **`return`**. It tells the **main** function
    to *return* to the statement that it was called from once it’s done. Here, since
    **main** has **`int`** in its declaration, a **`return`** *must* send back a value
    of type **`int`** to the calling statement. In this case, that value is **`EXIT_SUCCESS`**.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '**main** 中的最后一个语句是一个 **`return`**。它告诉 **main** 函数在完成后 *返回* 到它被调用的语句。在这里，由于
    **main** 的声明中有 **`int`**，一个 **`return`** *必须* 向调用语句发送一个 **`int`** 类型的值。在这种情况下，那个值是
    **`EXIT_SUCCESS`**。'
- en: Even though we can’t see its definition, the **printf** function must contain
    a similar **`return`** statement. At the point where we call the function on line
    17, execution of the statements in **main** is temporarily suspended. Execution
    continues in the **printf** function until a **`return`** is encountered. After
    the return from **printf**, execution of the statements in **main** continues
    from where it stopped.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们看不到它的定义，但 **printf** 函数必须包含一个类似的 **`return`** 语句。在我们在第 17 行调用函数的点，**main**
    中的语句执行暂时暂停。执行在 **printf** 函数中继续，直到遇到一个 **`return`**。从 **printf** 返回后，**main**
    中的语句从停止的地方继续执行。
- en: '[Figure 2.1](#ch02fig01) shows a schematic view of the execution of our little
    program: its *control flow*. First, a process-startup routine (on the left) that
    is provided by our platform calls the user-provided function **main** (middle).
    That, in turn, calls **printf**, a function that is part of the *C library**^C*,
    on the right. Once a **`return`** is encountered there, control returns back to
    **main**; and when we reach the **`return`** in **main**, it passes back to the
    startup routine. The latter transfer of control, from a programmer’s point of
    view, is the end of the program’s execution.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.1](#ch02fig01) 展示了我们小程序的执行示意图：其*控制流程*。首先，由我们的平台提供的进程启动例程（在左侧）调用用户提供的函数**main**（中间）。然后，**main**函数反过来调用**printf**函数，这是一个属于*C库*的函数（在右侧）。一旦遇到**`return`**，控制权返回到**main**；当我们到达**main**中的**`return`**时，它将控制权传递回启动例程。从程序员的角度来看，这种控制权的转移是程序执行的结束。'
- en: Figure 2.1\. Execution of a small program
  id: totrans-266
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.1. 小程序的执行
- en: '![](02fig01_alt.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1的替代文本](02fig01_alt.jpg)'
- en: Summary
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: C distinguishes the lexical structure (the punctuators, identifiers, and numbers),
    the grammatical structure (syntax), and the semantics (meaning) of programs.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C语言区分了程序的词汇结构（标点符号、标识符和数字）、语法结构（语法）和语义（意义）。
- en: All identifiers (names) must be declared such that we know the properties of
    the concept they represent.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有标识符（名称）都必须声明，以便我们知道它们所代表的概念的特性。
- en: All objects (things that we deal with) and functions (methods that we use to
    deal with things) must be defined; that is, we must specify how and where they
    come to be.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有对象（我们处理的事物）和函数（我们用来处理事物的方法）都必须定义；也就是说，我们必须指定它们是如何以及在哪里产生的。
- en: 'Statements indicate how things are going to be done: iterations (**`for`**)
    repeat variations of certain tasks, functions call (**printf**`(...)`) delegate
    a task to a function, and function returns (**`return`** something`;`) go back
    where we came from.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语句指示了事情将如何进行：迭代（**`for`**）重复执行某些任务的变体，函数调用（**printf**`(...)**）将任务委托给一个函数，函数返回（**`return`**
    something`;`）返回到我们来的地方。
