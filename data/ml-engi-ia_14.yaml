- en: 13 ML development hubris
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13 机器学习开发傲慢
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Applying refactoring to overengineered implementations to increase development
    velocity
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将重构应用于过度工程化的实现以提高开发速度
- en: Identifying code to target for refactoring
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定要重构的代码
- en: Establishing simplicity-driven development practices
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立以简单性为驱动的发展实践
- en: Adopting new technologies via sustainable means
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过可持续的方式采用新技术
- en: Comparing build, buy, and prior art in implementations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较实现中的构建、购买和先验艺术
- en: The preceding chapter focused on critical components used to measure a project’s
    overall health from a purely prediction-focused and solution efficacy perspective.
    ML projects that are built to support longevity through effective and detailed
    monitoring of their inputs and outputs are certainly guaranteed to have a far
    higher success rate than those that do not. However, this is only part of the
    story.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 前一章侧重于用于从纯粹预测和解决方案有效性角度衡量项目整体健康的临界组件。当然，旨在通过有效和详细监控其输入和输出以支持长期生存的机器学习项目肯定比那些没有这样做的项目有更高的成功率。然而，这仅仅是故事的一部分。
- en: Another major factor in successful projects has to do with the human side of
    the work. Specifically, we need to consider the humans involved in supporting,
    diagnosing issues with, improving, and maintaining the project’s code base over
    the lifespan of the solution.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 成功项目中的另一个主要因素与工作的这一人类方面有关。具体来说，我们需要考虑在解决方案的生命周期中支持、诊断项目代码库的问题、改进和维护项目代码库的人类。
- en: Note When a project is released to production, that is merely the beginning
    of its life. The real challenge of ML is to keep something running well over a
    long period of time.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 当项目发布到生产环境时，这仅仅是其生命周期的开始。机器学习的真正挑战是让某物在长时间内运行良好。
- en: 'This human element comes in the following form:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是人类元素的表现形式：
- en: '*How the code is crafted*—Can other people read it and understand it?'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*代码的构建方式*——其他人能否阅读并理解它？'
- en: '*How the code performs*—Is it deterministic? Does it have unintentional side
    effects?'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*代码的性能*——它是确定性的吗？它是否有无意之外的副作用？'
- en: '*How complex the code is*—Is it over- or under-engineered for the use case?'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*代码的复杂性*——它是否过度或不足工程化以适应用例？'
- en: '*How easy it is to improve*—ML code is in a constant state of refactoring.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*改进的容易程度*——机器学习代码处于不断的重构状态。'
- en: Throughout this chapter, we’ll look at signs to watch out for that define patterns
    making an ML code base a nightmare to maintain. From fancy code flexing (show-off
    developers) to empire-building framework creators, we’ll be able to identify these
    issues, see alternatives, and understand why the most effective design pattern
    for ML project code development is the same as for all of the other aspects of
    the project.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨需要注意的迹象，这些迹象定义了使机器学习代码库难以维护的模式。从炫耀的开发者的花哨代码（show-off developers）到构建帝国的框架创造者，我们将能够识别这些问题，看到替代方案，并理解为什么最有效的机器学习项目代码开发设计模式与其他项目的所有其他方面相同。
- en: TIP Build something only as complex as it needs to be to solve the problem at
    hand. People have to maintain this code, after all.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士 只构建解决问题所需的复杂度。毕竟，人们必须维护这段代码。
- en: Why “hubris,” though? That’s a bit insulting.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么是“傲慢”？这有点侮辱性。
- en: I chose the term *hubris* as a component of this chapter’s title after a long
    deliberation held between two temporally distinct versions of myself. On the one
    side was my current self, having felt the sting of crushing failure due to an
    overconfidence in my own skills, a builder of hopelessly confusing ego-driven
    solutions in the pursuit of prideful vanity, and a braggart-in-code who measured
    the success of a project in the cleverness of its implementation. The other side
    was a much younger version of myself, just getting started in the field and feeling
    as inadequate and as much an imposter as I could imagine a person to be.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在经过长时间深思熟虑后，我选择“傲慢”这个词作为本章标题的一个组成部分，这是在两个不同时间版本的我之间进行的。一方面是我的当前自我，由于对自己技能的过度自信而感到失败的痛苦，构建了令人困惑的、以自我为中心的解决方案，追求虚荣的虚荣，以及在代码中吹嘘的人，他衡量项目成功的方式是其实施的巧妙性。另一方面是我年轻得多、刚开始在这个领域工作的版本，感觉自己不称职，就像我能想象到的一个人一样，是一个冒牌货。
- en: I debated whether to use the term *arrogance* instead of *hubris*, but felt
    that would be disingenuous and inapplicable to what we’ll be talking about in
    this chapter (and what I wish I could have a long, hard chat with my younger self
    about). *Hubris* is much more applicable. By definition, it is the possession
    of excessive pride and self-confidence. Note that it isn’t about having pride
    (we all should be proud when we solve a complex problem in our profession), but
    rather the overabundance of it.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我在是否使用“傲慢”这个词而不是“自负”上犹豫不决，但觉得那样做是不诚实的，也不适用于我们将在本章中讨论的内容（以及我希望我能与年轻时的自己进行一场长谈的内容）。“自负”更为适用。根据定义，它是指拥有过度的骄傲和自信。请注意，这并不是关于拥有骄傲（当我们在我们职业中解决一个复杂问题时，我们都应该感到骄傲），而是过度地拥有它。
- en: 'When we, as data scientists, exhibit hubristic tendencies, we tend to build
    overly complex solutions to problems. Whether because of ego, vanity, or a simple
    desire to prove to peers that our skills are sufficiently high (typically due
    to imposter syndrome or having been burned by some hot garbage that we’ve written
    in the past), the end result is the same: regret. We end up building unmaintainable,
    confusing, overly complex, and unextendable solutions that have a high probability
    of derailing projects or frustrating our peers, and fearing the day that we have
    to troubleshoot a failure in the code.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们作为数据科学家表现出傲慢的倾向时，我们往往会构建过于复杂的解决方案来解决问题。无论是因为自负、虚荣，还是简单地想要向同伴证明我们的技能足够高（通常是由于冒充者综合症或过去被我们写过的某些垃圾代码所伤害），最终结果都是一样的：遗憾。我们最终构建了难以维护、令人困惑、过于复杂且无法扩展的解决方案，这些解决方案有很大概率会导致项目失败或让我们的同伴感到沮丧，并且害怕有一天我们必须调试代码中的故障。
- en: This chapter covers many of the dangerous ways that I’ve learned the lesson
    of pursuing simplicity in code, defining patterns of sustainable ML development
    that can, hopefully, save you from some painful mistakes I’ve made over the years.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了我在追求代码简洁性过程中学到的一些危险方法，定义了可持续的机器学习开发模式，希望这些模式能帮助你避免我多年来犯的一些痛苦错误。
- en: 13.1 Elegant complexity vs. overengineering
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.1 优雅的复杂性 vs. 过度设计
- en: 'Imagine for a moment that we’re starting a new project. It’s not too much of
    a departure from the last two chapters (spoiler alert: it has to do with dogs).
    We have some data about the dogs. We know their breed, age, weight, favorite food,
    and whether they’re generally of a favorable disposition. In addition, we have
    labeled data that measured whether each dog was exhibiting signs of hunger when
    they walked into our pet store franchise.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 暂时想象一下，我们正在启动一个新的项目。这并不太偏离前两章的内容（剧透：这与狗有关）。我们有一些关于狗的数据。我们知道它们的品种、年龄、体重、最喜欢的食物，以及它们是否通常具有讨人喜欢的性格。此外，我们还拥有标记数据，这些数据衡量了每只狗在走进我们的宠物店连锁店时是否表现出饥饿的迹象。
- en: Armed with this data, we’d like to build a model that predicts, based on the
    registered data of our canine consumers, whether we should offer them a treat
    when they pass through the checkout line.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这些数据，我们想要构建一个模型，根据我们犬类消费者的注册数据预测，当他们通过结账线时，我们是否应该给他们提供零食。
- en: NOTE Yes, I’m fully aware of how silly this is. It makes my wife chuckle, though,
    so the scenario is staying.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：是的，我完全清楚这有多愚蠢。不过，这会让我的妻子笑出声，所以这个场景还是保留着。
- en: 'As we begin working on investigating the data, we realize that we have a truly
    enormous amount of training data. Billions upon billions of rows of data. We’d
    like to utilize it all in the training of the model, though, so our platform decision
    leaves a simple choice for running this: Apache Spark.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始调查数据时，我们意识到我们拥有真正巨大的训练数据量。数以亿计的行数据。然而，我们希望利用所有这些数据来训练模型，因此我们的平台决策为我们留下了简单的选择：Apache
    Spark。
- en: 'Since we’ve been using Python so extensively throughout this book, let’s use
    this chapter to delve into another language used extensively for large-scale (in
    terms of training row count volume) ML projects: Scala. Since we’ll be using Spark’s
    ML library, in order to effectively build a feature vector from our columnar data,
    we’ll need to identify any noncontinuous data types and convert them to indexed
    integer values.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在这本书中广泛使用了Python，让我们利用本章深入探讨另一种广泛用于大规模（就训练行数量而言）机器学习项目的语言：Scala。由于我们将使用Spark的ML库，为了有效地从我们的列式数据中构建特征向量，我们需要识别任何非连续的数据类型并将它们转换为索引整数值。
- en: Before we get into code examples that show the differences between the topic
    of this section, let’s discuss the scales of ML coding practices. I like to think
    of development style (with regards to code complexity) as a delicate balancing
    act, illustrated in figure 13.1.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入展示本节主题差异的代码示例之前，让我们讨论一下机器学习编码实践的比例。我喜欢将开发风格（就代码复杂性而言）视为一种微妙的平衡行为，如图13.1所示。
- en: '![13-01](../Images/13-01.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![13-01](../Images/13-01.png)'
- en: Figure 13.1 Striking a balance between these two extremes of software development
    practices can lead to more effective and production-stable project work.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1 在软件开发实践这两种极端之间取得平衡可以导致更有效和更稳定的工程项目工作。
- en: On the right side of this scale, we have very lightweight code. It’s highly
    declarative (almost script-like), monotonous (statements copied and pasted many
    times over with slight changes to the arguments), and tightly coupled (changing
    one element means scouring through the code and updating all of the string-based
    configuration references).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个尺度的右侧，我们有非常轻量级的代码。它高度声明性（几乎像脚本一样），单调（语句被多次复制粘贴，参数略有变化），并且耦合紧密（更改一个元素意味着在代码中搜索并更新所有基于字符串的配置引用）。
- en: 'These lightweight code bases often can seem like they are written by groups
    of people all working for different companies. In many cases, they are, as entire
    functions and snippets of code are lifted in their entirety from popular developer
    Q&A forums. An additional feature that many of them share is a reliance on heavily
    popular frameworks and tooling that are well-documented (or, at least, are complex
    enough that a sufficient density of questions and answers has been provided on
    the aforementioned developer forums to liberally borrow from), regardless of how
    well suited the use case is. Here are some key identifiers of this behavior:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这些轻量级代码库往往看起来像是不同公司团队编写的。在许多情况下，确实如此，因为整个函数和代码片段被完整地从流行的开发者问答论坛中提取出来。它们共享的一个附加特性是对高度流行的框架和工具的依赖，这些框架和工具有很好的文档（或者至少足够复杂，以至于在上述开发者论坛上提供了足够的问题和答案，可以自由借用），无论用例是否合适。以下是这种行为的几个关键标识符：
- en: Using a framework intended for large-scale ML when the training dataset is in
    the thousands of rows and dozens of columns. (Instead of using SparkML, for example,
    stick to pandas and use Spark for training in broadcast mode.)
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当训练数据集有数千行和数十列时，使用为大规模机器学习设计的框架。（例如，而不是使用SparkML，坚持使用pandas，并在广播模式下使用Spark进行训练。）
- en: Building real-time serving atop large-scale serving architecture when the request
    volume will never hit more than a few requests per minute. (Instead of using Kubernetes
    with Seldon, build a simple Flask app in a Docker container.)
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当请求量永远不会超过每分钟几个请求时，在大型服务架构之上构建实时服务。（而不是使用带有Seldon的Kubernetes，请在Docker容器中构建一个简单的Flask应用。）
- en: Setting up a streaming ingestion service for large-scale microbatch predictions
    when there are a few hundred predictions to be made per hour and the SLA can be
    measured in minutes. (Instead of using Kafka, Spark Structured Streaming, or Scala
    user-defined functions, use the Flask app.)
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当每小时需要处理几百个预测，且服务等级协议（SLA）可以以分钟为单位衡量时，设置一个用于大规模微批预测的流式摄取服务。（而不是使用Kafka、Spark
    Structured Streaming或Scala用户定义函数，请使用Flask应用。）
- en: Building a time-series forecasting model using an LSTM running on GPU hardware
    with Horovod multi-GPU gang scheduling mode for a univariate time series that
    can be predicted with single-digit RMSE values with a simple ARIMA model. (Use
    an ARIMA model and choose the far cheaper CPU-based VMs instead).
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GPU硬件上运行的LSTM构建时间序列预测模型，使用Horovod多GPU群组调度模式，对于可以预测出单数RMSE值的多变量时间序列。 （使用ARIMA模型，并选择远更便宜的基于CPU的虚拟机。）
- en: On the left side of the scale, however, is the polar opposite. The code is dense,
    succinct, highly abstract, and typically complex. The left side can work in some
    groups and organizations, but by and large, it’s unnecessary, confusing, and limits
    the number of people who can contribute to the project by virtue of the experience
    required in understanding advanced language features. Some ML engineers will,
    after having dealt with a sufficiently large and complex project using the lightweight
    scripting style of ML development, pursue the left side’s heavy code approach
    on subsequent projects. The struggles that they had maintaining the scripted style
    and all of the extensive coupling that was present might lead to an explosion
    of abstracted operators that rapidly borders on building a generic framework.
    I can quite honestly say that I was that very person, reflected in my journey
    at the bottom of figure 13.1.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在刻度的一侧，是它的完全对立面。代码密集、简洁、高度抽象，通常复杂。左侧可以在某些团队和组织中工作，但总体来说，它是多余的、令人困惑的，并且由于理解高级语言特性所需的经验，限制了可以贡献项目的人数。一些机器学习工程师在处理足够大且复杂的机器学习开发轻量级脚本式风格的项目后，可能会在后续项目中追求左侧的重型代码方法。他们在维护脚本式风格和所有存在的广泛耦合方面遇到的挑战可能会导致抽象操作器的爆炸性增长，迅速接近构建通用框架。我可以相当诚实地说我就是那个人，这在图13.1的底部可以看到我的旅程。
- en: Sitting pleasantly in the middle of the figure is the balanced approach that
    has the greatest probability for long-term success of a team’s development style.
    Let’s take a look at examples of how our code might look when getting started
    with these two competing polar opposites.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在图表的中间，坐着一个平衡的方法，它为团队开发风格的长期成功提供了最大的可能性。让我们看看我们的代码在开始使用这两种竞争的极端对立面时可能的样子。
- en: 13.1.1 Lightweight scripted style (imperative)
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.1.1 轻量级脚本式风格（命令式）
- en: Before we get into the code of the minimalistic declarative style of writing
    our prototype ML model, let’s take a brief look at what our data looks like. Table
    13.1 shows a sample of the first five rows of the dataset.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨编写原型机器学习模型的简约声明式代码之前，让我们简要地看一下我们的数据是什么样的。表13.1显示了数据集的前五行样本。
- en: Table 13.1 Sample of data from our hungry dog dataset
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 表13.1 我们饥饿狗数据集的数据样本
- en: '| Age | Weight | Favorite food | Breed | Good boy or girl | Hungry |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 年龄 | 体重 | 最喜欢的食物 | 品种 | 好男孩或女孩 | 饥饿 |'
- en: '| 2 | 3.05 | Labneh | Pug | No | True |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 3.05 | Labneh | Pug | No | True |'
- en: '| 7 | 20.44 | Fajitas | Dalmatian | Sometimes | False |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 20.44 | Fajitas | Dalmatian | Sometimes | False |'
- en: '| 5 | 11.3 | Spaghetti | German Shepherd | No | True |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 11.3 | Spaghetti | German Shepherd | No | True |'
- en: '| 3 | 17.9 | Hummus | Estrela | Yes | False |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 17.9 | Hummus | Estrela | Yes | False |'
- en: '| 8 | 55.6 | Bolognese | Husky | Yes, when food is available | True |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 55.6 | Bolognese | Husky | 是的，当有食物时 | True |'
- en: We can clearly see that the majority of our data will need to be encoded, including
    our label (target) of `hungry`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以清楚地看到，我们的大部分数据都需要编码，包括我们的标签（目标）`hungry`。
- en: Let’s take a look at how we could handle these encodings by building a vector
    and running a simple `DecisionTreeClassifier` by using the Pipeline API from SparkML.
    The code for these operations is in the following listing. (See the “Why Scala?”
    sidebar for why I’m choosing to show these examples in Scala rather than Python.)
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何通过构建向量和运行简单的`DecisionTreeClassifier`来处理这些编码，使用SparkML的Pipeline API。这些操作的代码如下所示。（参见“为什么选择Scala？”侧边栏，了解为什么我选择用Scala而不是Python来展示这些示例。）
- en: Listing 13.1 Imperative model prototype
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13.1 命令式模型原型
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ dataLarger is a Spark DataFrame containing the full dataset from the sample
    in table 13.1.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ dataLarger 是一个包含表13.1中样本的完整数据集的 Spark DataFrame。
- en: ❷ Indexes the first String-typed column (breed) and creates a new 0th ordered
    descending-sort based on occurrence frequency
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 索引第一个字符串类型的列（品种）并创建一个基于发生频率的0th有序降序排序的新索引
- en: ❸ Builds the indexer for the next categorical (String) column (good thing that
    there are only four of them, right?)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 为下一个分类（字符串）列构建索引器（很高兴只有四个，对吧？）
- en: ❹ Builds the indexer for the target (label) column
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 为目标（标签）列构建索引器
- en: ❺ Creates the train and test splits
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 创建训练和测试分割
- en: ❻ Defines the fields (columns) that will be used for the feature vector
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 定义将用于特征向量的字段（列）
- en: ❼ Builds a decision-tree classifier model (hyperparameters hardcoded for brevity)
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 构建决策树分类器模型（为了简洁，超参数硬编码）
- en: ❽ Defines the order of operations to take and wrap in a pipeline (heavily modified
    during experimentation)
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 定义操作顺序并包装在管道中（在实验过程中进行了大量修改）
- en: ❾ Fits the pipeline against the training data (performs all stages of the pipeline,
    returning the processing steps along with the model as a single object of staged
    operations)
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 将管道拟合到训练数据上（执行管道的所有阶段，返回处理步骤以及作为单个操作对象返回的模型）
- en: ❿ Predicts against the test data for scoring purposes
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ 针对测试数据进行预测，以进行评分
- en: ⓫ Calculates the scoring metric (in this case, areaUnderROC) and returns the
    metric value
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ⓫ 计算评分指标（在这种情况下，为areaUnderROC）并返回指标值
- en: This code should look relatively familiar. It’s what we all see when we look
    at API documentation for a particular modeling framework. In this case, it’s Spark,
    but similar examples exist for any particular framework. It’s of an imperative
    style, meaning that we’re providing the execution steps directly in our code,
    preserving the manner in which we would do this step by step. While it makes the
    code incredibly easy to read (which is why examples in Getting Started guides
    use this format), it’s a nightmare to modify and extend as we work through different
    tests during experimentation and MVP development.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码看起来相对熟悉。这是我们查看特定建模框架的API文档时都会看到的。在这种情况下，是Spark，但任何特定框架都有类似的例子。它是一种命令式风格，这意味着我们在代码中直接提供执行步骤，保留了我们一步步执行此步骤的方式。虽然这使得代码非常易于阅读（这就是为什么入门指南中的示例使用这种格式），但在实验和MVP开发过程中，修改和扩展代码却是一个噩梦。
- en: Why Scala?
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么选择Scala？
- en: Well, we’re working with Scala predominantly because of Spark. Python is a first-party
    language, fully supported by Spark, but the backend of Spark (the low-level guts
    of how the sausage gets made) is written in Scala. The Python API is merely a
    wrapper (interface) to the Scala APIs, and as such, if anything lower level than
    the `DataFrame` API is required to be interfaced with, we must do so in either
    Scala or Java.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，我们主要使用Scala是因为Spark。Python是Spark的官方语言，Spark完全支持Python，但Spark的后端（即香肠是如何制成的底层细节）是用Scala编写的。Python
    API仅仅是Scala API的包装器（接口），因此，如果需要将比`DataFrame` API更底层的功能接口化，我们必须在Scala或Java中这样做。
- en: 'The choice of whether to use Python in Spark or Scala in Spark usually comes
    down to a short list of factors:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spark中使用Python还是Scala的选择通常取决于以下简短的因素列表：
- en: Prior familiarity with Java (or Scala) versus Python
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对Java（或Scala）的熟悉程度与Python相比
- en: The need to perform complex data manipulations not supported directly through
    the `DataFrame` API’s functions module—through the use of user-defined functions,
    resiliently distributed dataset (RDD) operations, or the development of custom
    estimators and transformers
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要执行复杂的数据操作，这些操作不能直接通过`DataFrame` API的函数模块支持——通过使用用户定义的函数、弹性分布式数据集（RDD）操作或开发自定义评估器和转换器
- en: The need to use custom distributed algorithms to solve a particular problem
    (for example, at the time of writing this book, XGBoost is available as a only
    a Scala/Java library)
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要使用自定义分布式算法来解决特定问题（例如，在撰写本书时，XGBoost仅作为Scala/Java库可用）
- en: “But why are you using Scala in this book?”
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: “但为什么在这本书中使用Scala？”
- en: That’s an excellent question. It’s mostly because there is a largely silent
    group of ML engineers in the industry who prefer it for their ML tasks, particularly
    when they’re dealing with extremely massive datasets. (Not a lot of questions
    can be found regarding use of Scala and Java on internet search results because
    of the higher barrier to entry for using the code than for a more forgiving language
    such as Python.) I’m including Scala in this chapter to showcase a slightly different
    approach to developing ML code than what most people are familiar with in an effort
    to pique curiosity and broaden your horizons. Although the language might seem
    foreign to you if you’re accustomed to only Python, let me assure you that learning
    it can be a rewarding endeavor and can help expand your technical repertoire as
    a professional ML engineer (giving you another set of tools to solve problems
    that might otherwise be incredibly arduous to solve in Python).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常好的问题。主要是因为在行业中存在一个庞大的沉默群体，他们是机器学习工程师，他们更倾向于使用Scala来处理他们的机器学习任务，尤其是在处理极其庞大的数据集时。（由于使用Scala的代码比Python等更宽容的语言的入门门槛更高，因此在互联网搜索结果中很难找到关于Scala和Java使用的问题。）我将Scala包括在本章中，是为了展示一种与大多数人熟悉的方法略有不同的机器学习代码开发方法，以期激发好奇心并拓宽你的视野。虽然如果你只习惯于Python，这种语言可能看起来很陌生，但请让我向你保证，学习它可以是一项有益的尝试，并且可以帮助你作为一个专业机器学习工程师的技术储备得到扩展（它为你提供了一套在Python中可能难以解决的工具，这些工具可能非常困难）。
- en: Numerous other, much more low-level and engineering-focused reasons exist for
    using Scala over Python in Spark. These reasons are related to topics—concurrency,
    thread management, and utilizing on-heap memory directly on the JVM—that are reserved
    for algorithm developers in the ML space. For the end user of Spark, performing
    ML-related work, Python is by far the widely accepted standard. However, that
    being said, it’s always good to know an additional language for the 5% of use
    cases where you have no other choice than to use Scala (plus, it’s an elegant
    and fun language for writing code!).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Scala而不是Python在Spark中进行机器学习存在许多其他、更底层和工程导向的原因。这些原因与以下主题相关——并发、线程管理和在JVM上直接利用堆内存——这些主题是为机器学习空间中的算法开发者保留的。对于Spark的最终用户，进行与机器学习相关的工作，Python无疑是广泛接受的标准。然而，话虽如此，了解另一种语言总是好的，因为在5%的情况下，你可能别无选择，只能使用Scala（此外，它是一种优雅且有趣的编程语言！）。
- en: I never realized how much of a struggle writing code in this imperative style
    would be when I first started working on ML projects. Much of my code looked like
    listing 13.1\. So why am I harping on this, if it’s something that I admit freely
    to having done for dozens of projects early in my career as a data scientist?
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当我开始从事机器学习项目工作时，我从未意识到以这种命令式风格编写代码会有多大的挑战。我的大部分代码看起来就像13.1列表中的那样。那么，如果我承认在作为数据科学家职业生涯早期几十个项目中都做过这样的事情，为什么我还要强调这一点呢？
- en: What happens if, during our experimentation and testing, we find that we have
    to add more features to this model? What if we go through extensive EDA and find
    that there are 47 additional features that we can include that might make the
    model perform better? What if they’re all categorical?
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在我们的实验和测试过程中，我们发现需要向这个模型添加更多特征怎么办？如果我们进行了广泛的探索性数据分析（EDA），并发现可以包含47个额外的特征，这可能会使模型的表现更好怎么办？如果它们都是分类的怎么办？
- en: Then our code, if built in the imperative design style shown in listing 13.1,
    will become an unmanageable wall of text. We’ll be using the Find functionality
    in our browser or IDE in order to know where to go in the code to update things.
    The `VectorAssembler` constructor alone will start to be a massive array of strings
    that will be hard to maintain.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果我们按照13.1列表中所示的使用命令式设计风格构建代码，它将变成一个难以管理的文本墙。我们将使用浏览器或IDE中的查找功能来了解代码中需要更新内容的位置。仅`VectorAssembler`构造函数本身就会开始成为一个庞大的字符串数组，这将很难维护。
- en: Writing complicated code bases in this fashion is error-prone, fragile, and
    headache inducing. While the reasons stated previously are bad enough during the
    experimentation and development phases of a project, think about what happens
    if the source data changes (a column gets renamed in a source system). How many
    places in the code base would we have to update? Could we get to them all in time
    while we’re on call? Would we find them all and be able to recover the job before
    we have a service disruption for the predictions?
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式编写复杂的代码库是容易出错的、脆弱的，并且会引起头痛。虽然之前提到的理由在项目的实验和开发阶段已经足够糟糕，但想想如果源数据发生变化（源系统中的列被重命名）会发生什么。我们有多少地方需要在代码库中更新？我们能否在值班时及时找到所有这些地方并恢复工作，以免预测服务中断？
- en: I’ve lived that life. My success rate for fixing things (adjusting the code
    base to support a fundamental change that happened upstream in the data) before
    the lack of new predictions became obvious and a problem was, at that time, just
    under 40%.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经经历过那种生活。在我意识到缺乏新的预测并成为问题之前，我修复东西（调整代码库以支持数据上游发生的根本性变化）的成功率，当时还不到40%。
- en: So, what I applied myself to, after suffering these frustrations, was to dance
    along that teetering plane of balance to the entire opposite side. I became my
    own (and my teams’) worst enemy by embracing extreme abstraction and object-oriented
    principles, and truly thought I was doing the right thing by producing incredibly
    complex code.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在经历了这些挫折之后，我致力于在那个摇摆不定的平衡平面上跳舞到完全相反的一侧。我通过拥抱极端抽象和面向对象原则，成为了自己（以及我的团队）的最坏敌人，并真正认为通过产生极其复杂的代码，我正在做正确的事情。
- en: 13.1.2 An overengineered mess
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.1.2 过度设计的混乱
- en: So, what did a younger Ben build? He built something like the following listing.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，年轻的本建造了什么呢？他建造了以下类似的结构。
- en: Listing 13.2 Overly complex model prototype
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13.2 过度复杂的模型原型
- en: '[PRE1]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Case class definition for currying data from the main method return signature
    (returns both the pipeline and the scoring metric)
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 为从主方法返回签名（返回管道和评分指标）中提取数据定义的案例类
- en: ❷ Class containing the model generation code. At an early phase in a project
    (as this level of complexity would be), this is unnecessary to generate. Refactoring
    dependencies within the methods will be far more complex than imperative scripting.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 包含模型生成代码的类。在项目的早期阶段（在这个复杂度级别），生成它是多余的。在方法内重构依赖关系将比命令式脚本更复杂。
- en: ❸ Externalizes the constants from the methods utilizing them (final production
    code would have these in their own module)
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将使用它们的常量外部化（最终的生产代码将把这些放在它们自己的模块中）
- en: ❹ Maps over the contents of the DataFrame’s schema and applies a StringIndexer
    to any field that is of String type and is not the label (target) field.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在DataFrame的模式内容上创建映射，并将StringIndexer应用于任何不是标签（目标）字段且为字符串类型的字段。
- en: ❺ Method for generating a String indexer if the label (target) is of String
    type. Note that other values are not handled here, so a full generic implementation
    has not been built.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 如果标签（目标）是字符串类型，则生成String索引器的函数。请注意，这里没有处理其他值，因此还没有构建完整的泛型实现。
- en: ❻ Label inverter that converts the label back into the original values. In this
    implementation, there are no checks for handling if the target value does not
    meet the criteria for indexing. In that case, this code will throw an exception.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 标签反转器，将标签转换回原始值。在这个实现中，没有检查处理如果目标值不符合索引标准的情况。在这种情况下，此代码将抛出异常。
- en: ❼ Dynamic means of generating a feature vector by manipulating the column listing
    and types to include. This doesn’t include other types of data aside from numeric
    and string types, which would not include those other column types into the feature
    vector.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 通过操作列列表和类型来生成特征向量的动态方法。这不包括除了数值和字符串类型之外的其他类型的数据，这些类型的数据不会被包含到特征向量中。
- en: ❽ The hyperparameters for this decision-tree classifier are hardcoded. While
    just a placeholder, the refactoring that will be needed in this coding style for
    tuning will be extensive. Since this is a private method, the main method signature
    will either need these values passed in as arguments, or the class constructor
    will need these values to be passed in at instantiation. This is a poor design.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 这个决策树分类器的超参数是硬编码的。虽然只是一个占位符，但在这个编码风格中，所需的重构将非常广泛。由于这是一个私有方法，主方法签名将需要将这些值作为参数传递，或者类构造函数需要在实例化时传递这些值。这是一个糟糕的设计。
- en: ❾ While this is a somewhat flexible design for building a pipeline based on
    the data passed in, it can be challenging for others to contribute to, involving
    paying close attention to the orders of operations that need to happen should
    additional stages be inserted into the pipeline constructor.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 虽然这是一种基于传入数据的构建管道的相对灵活的设计，但其他人要参与其中可能会很具挑战性，需要密切关注在管道构造函数中插入额外阶段时需要发生的操作顺序。
- en: ❿ Companion object to the class. This certainly should wait until the finalized
    API design is complete for the project.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ 类的伴随对象。这当然应该等到项目的最终 API 设计完成后再进行。
- en: This code might not look too absurd at first. It does, after all, greatly minimize
    verbosity when considering what would occur if we added additional features to
    the model’s feature vector. In point of fact, if we were to add even 1,000 additional
    features to the model, the code would stay the same. That might seem to be a distinct
    bonus to approaching writing ML code in this manner.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码一开始可能看起来并不荒谬。毕竟，如果我们考虑在模型的特征向量中添加更多功能，它将大大减少冗余。实际上，如果我们为模型添加甚至 1,000 个额外的特征，代码将保持不变。这似乎是采用这种方式编写机器学习代码的一个明显优势。
- en: What would happen if we needed different behavior for some fields than others
    for the `StringIndexer`? Suppose that some fields could support having the invalid
    keys (categorical values that were not present during training) appended to a
    catchall index value, while others could not. In that case, we’d have to modify
    this code extensively. We’d need to abstract the method `constructIndexers``()`
    and apply a case and match statement to generate indexers for different types
    of columns. We would then likely need to modify the passed-in signature argument
    to the wrapper methods to include a tuple (or a case class definition) of the
    field name and how to handle the validation of key existence.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要为某些字段而不是其他字段对 `StringIndexer` 进行不同的行为，会发生什么？假设某些字段可能支持将无效键（训练期间未出现的分类值）附加到通配索引值，而其他字段则不能。在这种情况下，我们不得不大量修改此代码。我们需要抽象方法
    `constructIndexers()` 并使用 case 和 match 语句为不同类型的列生成索引器。然后我们可能需要修改传递给包装方法的签名参数，以包括字段名称和如何处理键存在验证的元组（或案例类定义）。
- en: While this approach scales well, it’s a cumbersome act to undertake during experimentation
    phases. Instead of focusing on validating the performance of different experiments
    to run against a model type, we’re spending a great deal of time refactoring our
    class, adding new methods, abstracting complexity away, and potentially all in
    the pursuit of an idea that might not work out well at all.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种方法在扩展性方面表现良好，但在实验阶段进行时却显得相当繁琐。我们不是专注于验证针对不同模型类型运行的不同实验的性能，而是花费大量时间重构我们的类，添加新方法，抽象复杂性，并可能是在追求一个可能根本无法成功的想法。
- en: Approaching prototyping work in this manner (high abstraction and generalization)
    is a recipe for disaster when considering productivity. In the early phases of
    a project, it’s best to adopt a less complex style of coding that supports rapid
    iteration and modification. Moving toward the style exhibited in listing 13.2
    is much more applicable to the final pre-release phases of a project (code hardening),
    specifically when the components for producing the final project solution are
    known, defined, and can be identified as necessary for the code base. As an example
    of how I approach these phases of development work, see figure 13.2.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式（高抽象和泛化）进行原型设计工作，在考虑生产力时可能会带来灾难。在项目的早期阶段，最好采用一种更简单的编码风格，以支持快速迭代和修改。向 13.2
    列表中展示的风格更适用于项目的最终预发布阶段（代码加固），特别是在最终项目解决方案的组件已知、定义明确且可以识别为代码库中必要组件的情况下。作为一个如何处理这些开发阶段工作的例子，请参阅图
    13.2。
- en: '![13-02](../Images/13-02.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![13-02](../Images/13-02.png)'
- en: Figure 13.2 Avoiding refactoring hell by phased ML development
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2 通过分阶段机器学习开发避免重构地狱
- en: Because of the highly variable nature of prototyping (everything is quite fluid
    and elements need to change quickly), I typically stick to minimal imperative
    programming techniques. As the development successively moves toward a production
    build for the project, more and more of the complex logic is abstracted to maintainable
    and reusable parts in separate modules.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于原型设计的极端可变性（一切都很灵活，元素需要快速更改），我通常坚持使用最小化命令式编程技术。随着项目开发逐步转向生产构建，越来越多的复杂逻辑被抽象为可维护和可重用的部分，分别放在不同的模块中。
- en: Building an overengineered and overly complex code architecture early in the
    process will, as shown in listing 13.2, create walled-in scenarios that make refactoring
    for feature enhancements incredibly complex. Pursuing an overengineered development
    approach early in a project will only waste time, frustrate the team, and eventually
    lead to a far more complex and difficult-to-maintain code base.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期过程中构建过度工程化和过于复杂的代码架构，如列表 13.2 所示，将创建封闭的场景，使得为功能增强进行重构变得极其复杂。在项目早期追求过度工程化的开发方法只会浪费时间，让团队感到沮丧，并最终导致一个更加复杂且难以维护的代码库。
- en: Don’t do as I did. Fancy-looking code, particularly early in development, can
    only bring you problems. Choosing to pursue the simplest and most minimalistic
    implementation opens the door for extensibility when you need it, cohesive code
    structure for when you’re writing production code, and a far easier-to-troubleshoot
    code base that isn’t filled with technical debt (and dozens of `TODO` statements
    that will never get fixed).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 不要像我一样做。看起来很花哨的代码，尤其是在开发初期，只会给你带来问题。选择追求最简单和最简约的实现，当你需要扩展时，可以打开扩展的大门，当你编写生产代码时，可以拥有一个结构统一的代码结构，并且更容易调试的代码库，不会充满技术债务（以及数十个永远不会修复的
    `TODO` 语句）。
- en: '13.2 Unintentional obfuscation: Could you read this if you didn’t write it?'
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.2 非故意混淆：如果你没有编写它，你能读懂它吗？
- en: A rather unique form of ML hubris materializes in the form of code development
    practices. Sometimes malicious, many times driven by ego (and a desire to be revered),
    but mostly due to inexperience and fear, this particular destructive activity
    takes shape through the creation of unintelligibly complex code.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一种相当独特的形式的机器学习傲慢体现在代码开发实践中。有时是恶意的，许多时候是由自我（以及被尊敬的愿望）驱动的，但大多数情况下是由于缺乏经验和恐惧，这种特定的破坏性活动通过创建难以理解的复杂代码而形成。
- en: 'For our scenario, let’s take a look at a common and somewhat simplistic task:
    recasting data types to support feature-engineering tasks. In this journey of
    comparative examples, we’ll take a dataset whose features (and the target field)
    need to have their types modified to support the pipeline-enabled processing stages
    to build a model. This problem, at its most simplistic implementation, is shown
    in the next listing.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的场景，让我们看看一个常见且有些简化的任务：将数据类型重新转换为支持特征工程任务。在这个比较示例的旅程中，我们将查看一个需要修改其特征（以及目标字段）类型以支持管道启用处理阶段以构建模型的数据库。这个问题在其最简化的实现中，将在下一个列表中展示。
- en: Listing 13.3 Imperative casting
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.3 强制类型转换
- en: '[PRE2]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Encapsulates the modifications of the passed-in DataFrame by returning a DataFrame
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 通过返回 DataFrame 封装传入 DataFrame 的修改
- en: ❷ Converts the age column to Double from its original Integer type (for demonstration
    purposes only)
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将年龄列从原始的整数类型转换为 Double 类型（仅用于演示目的）
- en: ❸ Ensures that the weight column is of type Double
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 确保权重列的类型为 Double
- en: ❹ Casts the target column from Boolean to String for the encoders to work
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将目标列从布尔类型转换为字符串类型，以便编码器可以工作
- en: From this relatively simple and imperative-style implementation of casting fields
    in a `DataFrame`, we’ll look at examples of obfuscation and discuss the impacts
    that each might have for something as seemingly simple as this use case.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个相对简单且强制风格的 `DataFrame` 中字段转换的实现，我们将查看混淆的示例，并讨论每个可能对如此简单的情况产生的影响。
- en: NOTE In the next section, we’ll look at bad habits that some ML engineers have
    when writing code. Listing 13.3, it must be mentioned, is not intended to be disparaging
    in its approach and implementation. There is *nothing wrong with an imperative
    approach* when building ML code bases (provided the code base doesn’t have tight
    coupling requiring dozens of edits if one column changes). It becomes a problem
    only when the complexity of the solution makes modifying imperative code a burden.
    If the project is simple enough, stick with simpler code. You’ll thank yourself
    for the simplicity when you need to modify it and add new features.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在下一节中，我们将探讨一些机器学习工程师在编写代码时的一些坏习惯。必须指出的是，列表 13.3 的方法和实现并不是为了贬低。在构建机器学习代码库时（只要代码库没有紧密耦合，如果一列发生变化，则需要数十次编辑），强制方法没有任何问题。只有当解决方案的复杂性使得修改强制代码成为一种负担时，它才成为一个问题。如果项目足够简单，就坚持使用更简单的代码。当你需要修改并添加新功能时，你会感谢自己的简单性。
- en: 13.2.1 The flavors of obfuscation
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2.1 混淆的多种形式
- en: This section progresses through a sliding scale of complexity, with code examples
    that become progressively less intelligible, more complex, and increasingly harder
    to maintain. We’ll analyze bad habits of some developers to aid you in identifying
    these coding patterns and to call them out for what they are—crippling to productivity
    and absolutely requiring refactoring to be maintainable.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 本节通过一个滑动复杂度量表进行，代码示例变得越来越难以理解，越来越复杂，并且越来越难以维护。我们将分析一些开发者的不良习惯，以帮助您识别这些编码模式，并指出它们是什么——对生产力具有破坏性，并且绝对需要重构以保持可维护性。
- en: If you find yourself going down one of these rabbit holes, these examples can
    serve as a reminder to not follow these patterns. But before we get to the examples,
    let’s look at the personas that I’ve seen with respect to development habits,
    shown in figure 13.3.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发现自己陷入这些兔子洞之一，这些示例可以作为一个提醒，不要遵循这些模式。但在我们来看例子之前，让我们看看我在开发习惯方面看到的角色，如图 13.3
    所示。
- en: '![13-03](../Images/13-03.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![13-03](../Images/13-03.png)'
- en: Figure 13.3 The different personas in ML code development. Moving away from
    the central region has a high probability of creating a lot of problems for the
    team in the future.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.3 机器学习代码开发中的不同角色。远离中心区域在未来很可能给团队带来很多问题。
- en: These personas are not meant to identify a particular person, but rather to
    describe traits that a DS may go through during their journey of becoming a better
    developer. A nearly overwhelming number of people I’ve met (as well as myself)
    started off writing code as the Hacker. We’d find ourselves stuck on a problem
    that we’d never encountered before and instantly move to search online for a solution,
    copy someone’s code, and if it worked, move on. (I’m not saying that looking on
    the internet or in books for information is a bad thing; even the most experienced
    developers do this quite frequently.)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这些角色并不是为了识别特定的人，而是描述 DS 在成为更好的开发者过程中可能经历的特质。我遇到的大多数人（包括我自己）一开始都是作为黑客编写代码。我们会发现自己卡在一个以前从未遇到过的问题上，然后立刻在网上搜索解决方案，复制别人的代码，如果它有效，就继续前进。（我并不是说在网上或书中寻找信息是坏事；即使是经验最丰富的开发者也经常这样做。）
- en: As coding experience becomes deeper, some may lean toward one of the other three
    coding styles or, if they’re mentored properly, move directly to the center region.
    Some people have something to prove—usually only to themselves, as most people
    just want their peers to write the sort of code that comes from a Good Samaritan
    developer. Others may feel that the least number of lines of code is an effective
    development strategy, though they’re sacrificing legibility, extensibility, and
    testability in the process. Figure 13.4 shows the patterns that I’ve come across
    (and personally experienced).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 随着编码经验的加深，有些人可能会倾向于其他三种编码风格之一，或者如果他们得到了适当的指导，可以直接移动到中心区域。有些人有东西要证明——通常只是对自己，因为大多数人只是希望他们的同伴编写出来自善良的开发者的代码。其他人可能认为代码行数最少是一种有效的开发策略，尽管在这个过程中他们牺牲了可读性、可扩展性和可测试性。图
    13.4 展示了我遇到（以及个人经历）的这些模式。
- en: '![13-04](../Images/13-04.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![13-04](../Images/13-04.png)'
- en: Figure 13.4 The paths of becoming a better developer
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.4 成为更好的开发者的路径
- en: This circuitous path leads to increasingly complex and unnecessarily complicated
    implementations before landing on the pinnacle of wisdom-fueled experience. The
    best we can hope for while making this journey is to have the ability to recognize
    and learn the better path—specifically, that the simplest solution to a problem
    (that still meets the requirements of the task) is always the best way to solve
    it.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这条曲折的道路导致在达到智慧经验的顶峰之前，实现变得越来越复杂且不必要地复杂。在这次旅程中，我们所能期望的最好的事情是能够识别并学习更好的路径——特别是，对于一个问题（仍然满足任务要求）的最简单解决方案总是解决问题的最佳方式。
- en: My personal history of growth as a developer
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我作为开发者的个人成长历史
- en: My own growth path throughout my career has touched on nearly every aspect of
    the journey shown in figure 13.4\. Mostly driven by hubris, but also due to learning
    how to solve problems with code outside of a software engineering-focused company,
    it’s been a case of learning things the hard way by screwing up constantly along
    the journey. I have been a Hacker (not the cool kind shown so famously in the
    1995 movie *Hackers* with a “too cool for school” Jonny Lee Miller, a brief Mystic,
    a Show-off for too many years, a Mad Scientist on a few too many projects (much
    to the chagrin of my future self who had to fix code that I could no longer understand),
    and finally, a constant struggle to stay as a centrist Good Samaritan developer.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我在整个职业生涯中的成长路径几乎触及了图13.4中展示旅程的每一个方面。这主要是由自负驱动的，但也由于学会了如何在以软件工程为重点的公司之外用代码解决问题，因此在旅途中不断犯错，通过艰难的方式学习东西。我曾是一名黑客（不是像1995年电影《黑客》中那样著名、酷炫的那种，电影中有“太酷了以至于不上学”的乔尼·李·米勒，一个短暂的神秘主义者，多年的炫耀者，几个项目上的疯狂科学家（这让我未来的自己感到非常沮丧，因为我不得不修复我无法理解的代码），最终，我一直在努力保持一个中立的善良开发者。
- en: 'I mention this to illustrate that this journey is precisely as I said: a constant
    and Sisyphean struggle to strive for simple design and coherent code. It is, perhaps,
    one of the worthiest struggles to endure. The pursuit of writing cleaner and simpler
    code is not only to the benefit of your team and company, but also perhaps the
    most generous gift you can give to your future self who has to troubleshoot or
    improve the code base later. All of the clever tricks, concise one-liners, ego-placating
    flexing with complex design patterns, and impossibly convoluted implementations
    that, in the moment of writing them, seem like a good idea, are actually not.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到这一点是为了说明，这条旅程正是我所说的那样：一个不断且充满西西弗斯式挣扎的简单设计和连贯代码的追求。这可能是值得忍受的最崇高的斗争之一。追求编写更干净、更简单的代码不仅对你的团队和公司有益，而且可能是你能给予未来自己（他必须修复或改进代码库）的最慷慨的礼物。所有那些在写作时看似好主意，但实际上并非如此的高明技巧、简洁的一行代码、自我满足的复杂设计模式，以及难以置信的复杂实现。
- en: I’ve had to learn this the hard way. *Repeatedly*. My only advice is to learn
    from my examples and be able to recognize when you or others you work with are
    treading toward any of these caustic development patterns. Light the beacon to
    bring people back to simplicity, and your projects will be more successful.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我不得不通过艰难的方式反复学习这一点。我的唯一建议是，从我的例子中学习，并能够识别出你或你合作的他人是否正在走向这些有害的开发模式。点亮灯塔，让人们回归简单，你的项目将更加成功。
- en: In the following sections, we’ll look at versions of listing 13.3, wherein we
    are trying to recast some columns in a Spark `DataFrame` in order to prepare for
    feature-engineering transformations. It’s a seemingly simple task, but by the
    end of this section, hopefully you’ll be able to see just how “clever” someone
    can be by creating different types of confusing (and potentially very broken)
    implementations.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将查看列表13.3的版本，其中我们试图重新构建Spark `DataFrame`中的某些列，以便为特征工程转换做准备。这似乎是一个简单的任务，但到本节结束时，希望你能看到有人通过创建不同类型的令人困惑（并且可能非常糟糕）的实现方式，有多么“聪明”。
- en: The Hacker
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 黑客
- en: A *Hacker* mentality is, for the most part, simply born from inexperience and
    a feeling of being completely overwhelmed with the concepts of software development
    (ML or not). Many people in this mode of development feel nervous about asking
    for help in building solutions or in understanding how other team members’ solutions
    are built. Crippling feelings of inadequacy, known as *imposter syndrome*, may
    limit this person’s growth potential if they are not provided effective mentoring
    and acceptance by the larger team.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 黑客心态在很大程度上是源于缺乏经验和对软件开发概念（无论是机器学习还是其他）的完全不知所措。许多处于这种开发模式的人担心在构建解决方案或理解其他团队成员的解决方案是如何构建的时寻求帮助。被称为“冒名者综合症”的令人痛苦的不适感，如果他们没有得到有效的指导和团队的接受，可能会限制这个人的成长潜力。
- en: 'Many of their projects or contributions to projects may feel completely disjointed
    and tonally dissonant. It may seem like different people were involved in crafting
    the code within the pull request that they submitted. It’s likely true that there
    were: anonymous contributors to Stack Overflow.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 他们许多项目或对项目的贡献可能感觉完全脱节，在调性上也不和谐。这看起来像是不同的人参与了他们提交的拉取请求中的代码编写。很可能确实如此：Stack Overflow的匿名贡献者。
- en: Figure 13.5 summarizes many of the thoughts I had when I started writing full
    project code many years ago. I’ve asked other junior DS folks, after particularly
    rough peer reviews of their code, what motivated them to copy code from Stack
    Overflow, and their thought processes are paraphrased here as well.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.5总结了我多年前开始编写完整项目代码时的一些想法。我询问过其他初级数据科学家，在他们代码的特别粗糙的同行评审之后，是什么促使他们从Stack Overflow复制代码，他们的思考过程也在此处进行了概述。
- en: '![13-05](../Images/13-05.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![13-05](../Images/13-05.png)'
- en: Figure 13.5 The Hacker thought pattern, creating chaotic and unstable code bases,
    is where we all start in ML.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.5 黑客思维模式，创建混乱和不稳定的代码库，这是我们所有人开始机器学习的地方。
- en: A Hacker’s code looks like a patchwork quilt. The lack of coherent structure,
    inconsistent naming conventions, and varying degrees of code quality is likely
    to get flagged repeatedly in a code or peer review submission. A test of the code
    (if any unit tests are written) will likely show many points of fragility in the
    implementation.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 黑客的代码看起来像是一块拼布。缺乏连贯的结构、不一致的命名约定以及不同的代码质量程度可能会在代码或同行评审提交中反复被标记。如果编写了单元测试，对代码的测试可能会显示出实现中的许多脆弱点。
- en: Listing 13.4 shows an example of what the Hacker type of developer might come
    up with for a solution to the column-recasting problem. While not directly indicative
    of a cobbled-together state, it’s definitely full of antipatterns.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13.4展示了黑客类型开发者可能为解决列转换问题提出的解决方案示例。虽然这并不直接表明是一个拼凑的状态，但它确实充满了反模式。
- en: Listing 13.4 Hacker’s attempt at casting columns
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13.4 黑客尝试转换列
- en: '[PRE3]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ The function argument castChanges is strange. What does the list of tuples
    represent?
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 函数参数castChanges很奇怪。元组列表代表什么？
- en: ❷ Mutating objects is not considered a good practice in this instance. The DataFrame
    is immutable by nature, but declaring it as a var allows mutation to support this
    hacky method chaining in the foreach iterator.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在这种情况下，修改对象不被认为是良好的实践。DataFrame本质上是不可变的，但将其声明为var允许在foreach迭代器中支持这种黑客式的链式方法。
- en: ❸ Iterates over the List of tuples that are passed in
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 遍历传入的元组列表
- en: ❹ Positional notation for tuples is confusing, highly error prone, difficult
    to understand, and opens the door for frustration in API usage. (What happens
    if the data type and column names are switched?)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 元组的定位表示法令人困惑，极易出错，难以理解，并可能在API使用中引发挫败感。（如果数据类型和列名被交换会发生什么？）
- en: ❺ Returning the mutated DataFrame will still preserve encapsulation, but it’s
    a code sniff.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 返回修改后的DataFrame将仍然保持封装性，但这是一种代码嗅探。
- en: ❻ Example usage with the cumbersome definition of a List of tuples for the castChanges
    argument
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 使用繁琐的元组列表定义作为castChanges参数的示例用法
- en: 'In this code, we can see that the logic displayed is similar to the inherently
    mutable nature of Python. Instead of researching how to safely iterate over a
    collection to apply chained methods to an object, this developer implements a
    strong antipattern in Scala: mutating a shared state variable. In addition, because
    the function’s argument `castChanges` has no concept of what those `String` values
    should be (which one should be the column name and which the data type is being
    cast to), the user of this function would have to look at the source code to understand
    which one goes where.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们可以看到显示的逻辑与Python固有的可变性质相似。这位开发者没有研究如何安全地迭代集合以将链式方法应用于对象，而是在Scala中实现了一个强烈的反模式：修改共享状态变量。此外，由于函数的参数`castChanges`没有关于那些`String`值的概念（哪一个应该是列名，哪一个被转换成数据类型），使用这个函数的用户将不得不查看源代码来理解哪一个应该放在哪里。
- en: Recognizing these code smells in your peers’ work is critical. Whether those
    people are brand-new to the team (or the profession), or have a great deal of
    experience and are simply “phoning it in,” an effort should be made to help them.
    This is a perfect opportunity to work with a fellow member of the team, help them
    increase their skills, and in the process, build a stronger team full of engineers
    who are all creating more maintainable and production-stable code.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '在同事的工作中识别这些代码异味至关重要。无论这些人是否是团队（或职业）的新人，或者有丰富的经验但只是“应付差事”，都应该努力帮助他们。这是一个与团队成员一起工作的完美机会，帮助他们提高技能，在这个过程中，建立一个由工程师组成的更强大团队，他们都在创建更易于维护和更稳定的代码。 '
- en: The Mystic
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 神秘主义者
- en: As we progress in gaining skill and exposure to new concepts in ML software
    development, the next logical journey is to learn FP techniques. Unlike traditional
    software development, a great deal of DS coding work lends itself to functional
    composition. We ingest data structures (typically represented as array collections),
    perform operations on them, and return the modified state of the data in an encapsulated
    fashion. Many of our operations are based on applying algorithms to data, whether
    through direct calculation of values or through a transformation of structure.
    To a large degree, much of our code bases could be written in a stateless FP fashion.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们逐渐在 ML 软件开发中提高技能和接触新概念，下一个合乎逻辑的旅程是学习 FP 技术。与传统的软件开发不同，大量的 DS 编码工作适合于函数式组合。我们摄取数据结构（通常表示为数组集合），对它们进行操作，并以封装的方式返回修改后的数据状态。我们的许多操作都是基于对数据进行算法应用，无论是通过直接计算值还是通过结构转换。在很大程度上，我们的代码库的大部分内容都可以用无状态
    FP 风格编写。
- en: At its core, many tasks in ML are functional. There is definitely a strong case
    to apply functional programming techniques to many of the operations that we do.
    The *Mystic* developer persona is not someone who selectively chooses appropriate
    places to use FP paradigms, however. Instead, they dedicate their time and effort
    to making the entire code base functional. They pass around configuration monads
    to functions in a semblance of weak state, sacrificing composition in favor of
    an almost fanatical zeal for the adherence of FP standards. To illustrate, figure
    13.6 shows my thought processes when I discovered FP and all the wonders that
    it can bring to a code base.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，ML 中的许多任务都是函数式的。将函数式编程技术应用于我们执行的大多数操作确实有很强的理由。*神秘* 开发者角色并不是一个选择性选择合适位置使用
    FP 范式的人。相反，他们投入时间和精力使整个代码库函数化。他们以弱状态的形式将配置单子传递给函数，牺牲了组合，以近乎狂热的热情来遵守 FP 标准。为了说明，图
    13.6 展示了我发现 FP 以及它能为代码库带来的所有奇迹时的思维过程。
- en: '![13-06](../Images/13-06.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![13-06](../Images/13-06.png)'
- en: Figure 13.6 Inside the mind of an FP purist (the Mystic)
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.6 FP 纯粹主义者（神秘）的内心世界
- en: When I first began learning FP concepts, trying my hardest to convert all of
    my code into this standard, I found its conciseness liberating, efficient, and
    elegant. I enjoyed the simplicity of stateless coding and the purity of pure encapsulation.
    Gone were the side-effect problems of mutating state in my earlier hacky code,
    replaced with slick and stylistic `map`, `flatmap`, `reduce`, `scan`, and `fold`.
    I absolutely loved the idea of containerizing and defining generic types as a
    way to reduce the lines of code I had to write, maintain, and debug. Everything
    just seemed so much more elegant.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当我开始学习 FP 概念，尽力将所有代码转换为这种标准时，我发现它的简洁性令人解放，高效且优雅。我喜欢无状态编码的简单性和纯封装的纯粹性。在我早期的拙劣代码中，突变状态的副作用问题消失了，取而代之的是光滑且风格化的
    `map`、`flatmap`、`reduce`、`scan` 和 `fold`。我绝对喜欢将容器化和定义泛型类型作为减少我需要编写、维护和调试的代码行数的方式。一切似乎都更加优雅。
- en: In the process of refactoring code in this way, I managed to enrage the other
    people who were looking at each heavy-handed refactoring. They were right to call
    me out for increasing the complexity of the code base, decoupling functions in
    ways that didn’t need decoupling, and generally making the code harder to read.
    To get a good sense of what this implementation style would look like for our
    column casting, see the following listing.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在以这种方式重构代码的过程中，我成功地激怒了那些正在查看每个重手重构的其他人。他们正确地指出我增加了代码库的复杂性，以不需要解耦的方式解耦函数，并且通常使代码更难以阅读。要了解这种实现风格对我们列铸造的适用性，请参阅以下列表。
- en: Listing 13.5 A pure functional programming approach
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.5 纯函数式编程方法
- en: '[PRE4]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ The function signature’s castChanges argument is safer than the Hacker’s implementation.
    By requiring a DataType abstract class to be passed in, the chances of introducing
    unintentional bugs via this function are reduced.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 函数签名中的 castChanges 参数比黑客的实现更安全。通过要求传递一个 DataType 抽象类，通过此函数引入意外错误的可能性降低了。
- en: ❷ Using a foldLeft (mapping over the castChanges collection and applying an
    accumulator to the passed-in DataFrame df) allows for the mutated state of the
    DataFrame to be far more efficient than in the Hacker approach.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用 foldLeft（映射 castChanges 集合并对传入的 DataFrame df 应用累加器）可以使 DataFrame 的突变状态比黑客方法更高效。
- en: ❸ Case matching to define the structure of the passed-in argument castChanges
    allows for elimination of the complicated (and annoying) positional reference
    that was in the Hacker implementation. This code is far cleaner.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用案例匹配来定义传入参数`castChanges`的结构，允许消除黑客实现中存在的复杂（且令人烦恼）的位置引用。这段代码要干净得多。
- en: ❹ Using the function doesn’t save much on typing versus the Hacker implementation,
    but you can see how having these defined types for the casting conversion type
    makes the use of this function better.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用该函数与黑客实现相比在打字上节省不多，但你可以看出，为铸造转换类型定义这些类型如何使该函数的使用更加便捷。
- en: As you can see, this implementation has a distinct functional nature. Technically
    speaking, for this use case, this implementation is the best of all the examples
    in this section. The `DataFrame` object is mutated in a safe accumulator-friendly
    way (the mutation state of chaining operations on the `DataFrame` is encapsulated
    within `foldLeft`), the argument signature utilizes base types as part of the
    casting (minimizing errors at usage time), and the matching signature used prevents
    any confusing variable-naming conventions.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，这个实现具有明显的函数式特性。从技术角度讲，对于这个用例，这个实现是本节所有示例中最好的。`DataFrame`对象以安全累加器友好的方式被突变（链式操作在`DataFrame`上的突变状态被封装在`foldLeft`中），参数签名利用基类型作为铸造的一部分（最小化使用时的错误），并且使用的匹配签名防止了任何令人困惑的变量命名约定。
- en: The only way that I would make this a bit better would be to utilize a monad
    for the `castChanges` argument. Defining a case class constructor that could hold
    the mappings of column name to casting type would further prevent misuse or any
    confusing implementation details for others who wished to use this little utility
    function.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我会使其变得更好的一种方法就是利用单子来处理`castChanges`参数。定义一个可以包含列名到铸造类型的映射的案例类构造函数可以进一步防止误用或任何令人困惑的实现细节，对于希望使用这个小型实用函数的其他人来说。
- en: The issue in listing 13.5 isn’t the code; rather, it is in the philosophical
    approach of someone who writes code in this manner and enforces these patterns
    everywhere in the code base. If you detect these sorts of development patterns
    everywhere in a code base, replete with highly convoluted and confusing state
    currying that ships the entire stack around to each function, you should have
    a chat with this person. Show them the light. Let them know that this pursuit
    of “purity” is as much a fool’s errand as tilting at windmills. They’re not the
    only one who has to maintain this, after all.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13.5中的问题不在于代码；而在于编写这种代码的人的哲学方法，并在代码库的每个地方强制执行这些模式。如果你在代码库的每个地方都检测到这些开发模式，充满了高度复杂和令人困惑的状态累积，将整个堆栈传递到每个函数，你应该与这个人交谈。向他们展示光明。让他们知道，这种对“纯粹性”的追求就像与风车搏斗一样，是一种徒劳的行为。毕竟，他们不是唯一需要维护这个的人。
- en: A word on functional programming
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 关于函数式编程的一席话
- en: I know it might seem like I’m hating on FP. I’m not. You’ll see in this chapter
    and in any code base that I contribute to that I choose to do loads of FP things.
    It’s a wonderful programming style for what it is designed to do. In some languages,
    such as Python and Scala, it has performance benefits as well (using accumulators
    is far more efficient than using mutation).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道这可能会让人觉得我在讨厌函数式编程。我不是。你会在这一章以及我贡献的任何代码库中看到，我选择做很多函数式编程的事情。对于它设计要做的，它是一种非常好的编程风格。在某些语言中，例如Python和Scala，它还有性能优势（使用累加器比使用突变更有效）。
- en: However, what I am retroactively beating myself up for is the purist approach.
    In so many areas of ML development, using FP techniques simply doesn’t make sense.
    Attempting to shoehorn an FP design pattern into deterministic state-controlled
    hyperparameter tuning is a recipe for disaster, for instance.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我事后责备自己的是纯粹主义的方法。在ML开发的许多领域，使用FP技术根本就没有意义。例如，试图将FP设计模式强行塞入确定性状态控制的超参数调整中，是一场灾难。
- en: I do encourage all ML practitioners to learn FP concepts for places that make
    a great deal of sense. Do you need to iterate over a collection and apply a function
    to it? Don’t use a `for`loop; use a `map` function (list comprehension in Python).
    Do you need to update the state of an object based on a large collection of tasks?
    Use a map-reduce paradigm (folding in Scala, list comprehension, again, in Python).
    These language features are incredibly helpful, are frequently far more performant
    than alternative iterators (such as `for`loops and `while`loops), and make for
    much cleaner code.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我确实鼓励所有机器学习从业者学习函数式编程（FP）的概念，因为它们在许多地方都非常有意义。你需要遍历一个集合并对其应用一个函数吗？不要使用`for`循环；使用`map`函数（Python中的列表推导）。你需要根据大量任务更新对象的状态吗？使用map-reduce范式（Scala中的折叠，Python中的列表推导）。这些语言特性非常有帮助，通常比替代迭代器（如`for`循环和`while`循环）性能更好，并且代码更简洁。
- en: The only downside to using FP is if your team isn’t familiar with it. That can
    always be addressed through training, though. Take a little bit of time to introduce
    the topic to your team and you’ll find that iterations over collections will be
    easier to read, easier to write, and will run more cheaply.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数式编程的唯一缺点是如果你的团队不熟悉它。但这总是可以通过培训来解决。花点时间向你的团队介绍这个话题，你会发现遍历集合将更容易阅读、编写，并且运行成本更低。
- en: The Show-off
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 炫耀型
- en: The *Show-off* persona can come in several forms. It can be an incredibly advanced
    independent contributor who has a lengthy history of developing software with
    no ML components. They may look at an ML project and try to build a custom implementation
    of an algorithm that otherwise exists in a popular open source library. They could
    also be a person who has graduated from being a Hacker type of developer, and
    armed with a deeper understanding of the implementation language and software
    design patterns, chooses to show everyone on the team how good they are now.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*炫耀型*人格可以有多种形式。它可能是一个拥有长期独立开发软件历史、没有任何机器学习组件的极其高级的贡献者。他们可能会审视一个机器学习项目，并试图构建一个定制的算法实现，而这个算法在其他流行的开源库中已经存在。他们也可能是一个已经从黑客型开发者毕业的人，凭借对实现语言和软件设计模式的更深入理解，选择向团队中的每个人展示他们现在的优秀。'
- en: Regardless of why this sort of person builds complexity into their implementations,
    it will impact the team and the projects that the team must maintain in the same
    manner. The person who built it will end up owning it if the code isn’t refactored.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 无论这种类型的人为什么要在他们的实现中构建复杂性，它都会以相同的方式影响团队和团队必须维护的项目。如果代码没有被重构，构建它的人最终将拥有它。
- en: There’s absolutely nothing wrong with complexity in code if the use case and
    the problem being solved warrant that complexity. However, the Show-off type builds
    in complexity simply for the sake of overengineering the solution to appear skilled
    to others on the team. I imagine the mental state of people who fit the Show-off
    persona to look like figure 13.7.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码的复杂度是由用例和要解决的问题所证明的必要，那么在代码中存在复杂性绝对没有问题。然而，炫耀型的人仅仅为了过度设计解决方案以向团队中的其他人展示自己的技能，而人为地引入复杂性。我想象一下符合炫耀型人格的人的心理状态可能看起来像图13.7。
- en: '![13-07](../Images/13-07.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![13-07](../Images/13-07.png)'
- en: Figure 13.7 The unhelpful habits and thoughts of the Show-off
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.7 炫耀型的人的不良习惯和思维模式
- en: These habits and thinking patterns are significantly less than pleasant to endure
    when you’re this person’s coworker. The ideas that they’re conveying aren’t bad
    (except for the toxic one at the bottom right). Builder patterns, heavy abstraction,
    implicit typing, reflection, and well-crafted interfaces are all good things.
    However, they’re tools to be used when the need arises.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当你是这个人的同事时，这些习惯和思维模式会让你感到非常不愉快。他们传达的想法并不坏（除了右下角的那个有毒的想法）。构建者模式、重抽象、隐式类型、反射和精心设计的接口都是好事。然而，它们是在需要时使用的工具。
- en: The problem with the way this person thinks and writes code is that they’ll
    start off implementing a project from the initial commit on the first branch with
    skeleton stubs for a grand project architecture that is completely unneeded. This
    is the sort of ML engineer who is focused solely on the code sophistication of
    the project and has little to no regard for the actual project’s purpose. In this
    blindness, they typically strive toward writing very complex code that, to the
    rest of the team, seems intentionally obfuscated because of the overwhelming level
    of overengineering that they’ve done for the problem at hand.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这个人的思考和编写代码的方式的问题在于，他们将从第一个分支上的初始提交开始实施项目，为一个大型的、完全不必要的项目架构创建骨架占位符。这类机器学习工程师只关注项目的代码复杂性，几乎不考虑项目的实际目的。在这种盲目中，他们通常努力编写非常复杂的代码，对于其他团队成员来说，由于他们为当前问题所做的过度工程，这种代码看起来是故意混淆的。
- en: TIP If you want everyone to think you’re smart, sign up for *Jeopardy* and win
    some rounds. If you’re flexing through your code, all you’re doing is putting
    your team in jeopardy.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：如果你想让人人都认为你很聪明，就报名参加 *Jeopardy* 并赢得几轮。如果你在代码中炫耀，你只是在让你的团队处于危险之中。
- en: Let’s take a look at our casting scenario function, this time written in the
    Show-off development style.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们的类型转换场景函数，这次以展示者的开发风格编写。
- en: Listing 13.6 The Show-off’s casting implementation
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.6 展示者的类型转换实现
- en: '[PRE5]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Defining the matching numeric types is fine for this particular implementation.
    What happens if integers need to be handled differently? The refactoring required
    to stick with this design pattern would be substantial!
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 对于这个特定的实现，定义匹配的数值类型是合适的。如果整数需要以不同的方式处理，会发生什么？为了坚持这种设计模式，所需的重构将会相当大！
- en: ❷ The matching approach isn’t bad on the data type of the passed-in DataFrame.
    That’s the only good thing to say about this block of code.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在传入的 DataFrame 的数据类型上，匹配方法并不差。这是关于这段代码唯一值得说的好话。
- en: ❸ The mapping of the column name to the conversion type is odd. It’s consumed
    in the next statement.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将列名映射到转换类型的方式很奇怪。它在下一个语句中被消耗。
- en: ❹ Wildcard catch for all other conditions. What happens if the passed-in DataFrame
    contains a collection?
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 对于所有其他条件，使用通配符捕获。如果传入的 DataFrame 包含一个集合，会发生什么？
- en: ❺ Lazy passing of the map collection (x) from the first stage. Now position
    notation is required to access those values.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 从第一阶段懒传递映射集合（x）。现在需要使用位置表示法来访问这些值。
- en: ❻ Once again, the wildcard match. An ArrayType or ListType column would present
    serious issues here.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 再次，通配符匹配。如果是一个 ArrayType 或 ListType 列，这里会出现严重问题。
- en: ❼ At least the instantiation of this function is pretty simple.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 至少这个函数的实例化相当简单。
- en: This code works. It behaves exactly as the three preceding examples did. It’s
    just hard to read. By trying to show off skills and “advanced” language features,
    some pretty poor decisions were made.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是可行的。它的行为与前面的三个例子完全一样。只是很难阅读。试图展示技巧和“高级”语言特性，做出了一些相当糟糕的决定。
- en: First off, the initial mapping over the schema fields is completely unnecessary.
    Creating the Map type column that consists of a pseudo-enumeration of single character
    values to column name is not only useless, but also confusing. The collection
    generated from that first stage, which is then folded over in the accumulator
    action to the `DataFrame`, is instantly consumed, forcing the creation of a “temporary”
    `Map` object collection to apply the correct type casting. Finally, in the laziness
    of not wanting to fully write out all of the conditional matches that may occur,
    there’s a wildcard match case in the final section. What happens when someone
    needs to handle a different data type? What are the steps for updating this to
    support binary types, integers, or Boolean values? Extending this is not going
    to be particularly fun.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，对模式字段进行初始映射是完全不必要的。创建一个由单字符值到列名的伪枚举组成的 Map 类型列不仅无用，而且令人困惑。从第一阶段生成的集合，然后折叠到累加器操作中的
    `DataFrame`，立即被消耗，迫使创建一个“临时”的 `Map` 对象集合来应用正确的类型转换。最后，在懒惰地不想完全写出可能发生的所有条件匹配的情况下，在最后部分有一个通配符匹配案例。当有人需要处理不同的数据类型时会发生什么？更新以支持二进制类型、整数或布尔值的步骤是什么？扩展这一点不会特别有趣。
- en: Be wary of people who write code like this, particularly if they’re a senior
    person on your team. A conversation about how important it is for everyone on
    the team to be able to maintain the code and troubleshoot it is a good approach.
    It’s not likely that they’re intentionally trying to make the code complex for
    others. With a request for a simpler implementation, they’ll likely deliver and
    adjust their development strategy with this in mind for the future.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要警惕编写这种代码的人，尤其是如果他们是团队中的资深人员。关于为什么团队中的每个人都能够维护和调试代码的重要性进行一次对话是一个好的方法。他们不太可能有意使代码对其他人变得复杂。如果请求一个更简单的实现，他们很可能会根据这个想法调整他们的开发策略，以适应未来的需求。
- en: The Mad Scientist
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 疯狂科学家
- en: The *Mad Scientist* developer is well-intentioned. They’re also someone who
    has progressed on the path of knowledge of software development to a point far
    exceeding the fundamentals. With the amount of experience, number of projects,
    and sheer volume of code that they’ve written, they’ve begun to utilize advanced
    techniques within the languages (they typically are highly fluent in more than
    one) to reduce the amount of code that needs to be maintained.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*疯狂科学家*开发者是善意的。他们也是那些在软件开发知识道路上取得巨大进步的人。凭借他们的经验、项目数量以及他们所编写的代码的巨大数量，他们开始利用语言中的高级技术（他们通常精通一种以上的语言）来减少需要维护的代码量。'
- en: These people typically think of how to tackle problems based on efficiency of
    development rather than from a position of wanting to be recognized for the sophistication
    of their code. They’ve learned a great deal over the years and have had to maintain
    (and refactor) less-than-optimal code enough that they choose to compose their
    implementations in ways that make it easier to troubleshoot and maintain.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这些人通常基于开发效率来考虑如何解决问题，而不是基于希望因为代码的复杂性而获得认可。他们多年来学到了很多，并且不得不维护（和重构）不够理想的代码，以至于他们选择以使调试和维护更容易的方式进行实现。
- en: These are noble goals when the rest of the team is of a similar level of technological
    competency as they are. However, most teams comprise a myriad of humans of differing
    levels of development competency. Crafting complex but highly efficient code can
    be a hindrance to the effectiveness of more junior people on the team. To illustrate
    these thought processes, figure 13.8 shows a bit of the Mad Scientist’s mind.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当团队的其他成员与他们的技术能力相似时，这些目标是非常崇高的。然而，大多数团队由各种不同开发能力的人组成。编写复杂但高效的代码可能会阻碍团队中更初级人员的效果。为了说明这些思维过程，图
    13.8 展示了疯狂科学家的思维片段。
- en: '![13-08](../Images/13-08.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![13-08](../Images/13-08.png)'
- en: Figure 13.8 Without appropriate teaching and mentorship to the rest of the team,
    a more senior, highly advanced ML engineer may write code that’s highly obscure
    and complicated.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.8 如果没有对团队其他成员进行适当的指导和辅导，一个资历较深、高级的机器学习工程师可能会编写出非常晦涩和复杂的代码。
- en: Notice that the Mad Scientist’s points are not bad ones. They’re perfectly relevant
    and considered to be general best practices. However, the problem with this mentality
    arises when all the other humans working with the code aren’t aware of these standards.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，疯狂科学家的观点并不是不好的。它们非常相关，被认为是通用的最佳实践。然而，这种心态的问题在于，所有其他与代码一起工作的人并不了解这些标准。
- en: If code is written with these compositional rules in mind and just “thrown over
    the wall” by issuing a PR on a branch without the rest of the team being aware
    of why these standards are so important, the code design and implementation will
    be unintelligible to them. Let’s look at our continuation of casting examples
    for how this Mad Scientist developer would potentially write this code in listing
    13.7.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码是按照这些组合规则编写的，并且只是通过在分支上提交一个 PR 而没有让团队的其他成员意识到这些标准为什么如此重要，那么代码的设计和实现对他们来说将是难以理解的。让我们看看我们的铸造示例的延续，看看这位疯狂科学家开发者可能会在列表
    13.7 中如何编写这段代码。
- en: Listing 13.7 A slightly more sophisticated casting implementation
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.7 一个稍微复杂的铸造实现
- en: '[PRE6]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Similar to the preceding examples, except we’re iterating directly on the
    collection returned from the df.schema getter
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 与前面的例子类似，但我们是直接在 df.schema getter 返回的集合上进行迭代的。
- en: ❷ Moves away from the confusing name reference df as in previous examples. Although
    it would be encapsulated here (and safe), naming it df is confusing to read.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 放弃了前面例子中使用的 df 这样的令人困惑的名称引用。尽管在这里（并且是安全的）将其封装起来，但将其命名为 df 会让阅读变得困惑。
- en: ❸ Uses named entities from the return of the schema (variable s) to prevent
    unexpected bugs in the future
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用模式返回的命名实体（变量 s）来防止未来出现意外的错误
- en: ❹ By wrapping the decision logic within the casting statement, there are fewer
    lines of code. Matching directly to types from the metadata of the schema is going
    to be more future-proof as well.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 通过在转换语句中包装决策逻辑，代码行数更少。直接匹配到模式元数据中的类型将更有利于未来的兼容性。
- en: Now, there’s nothing wrong with this code. It’s concise, covers the use case
    needed rather well, and is designed to not spontaneously detonate if complex types
    (arrays and maps) are in a column in the dataset. The only caveat here is to ensure
    that design patterns like this are maintainable by your team. If they’re OK with
    maintaining and writing code in this manner, it’s a good solution. However, if
    the rest of the team is used to imperative-style programming, this code design
    can be as cryptic as if it were written in a different language.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这段代码没有问题。它简洁，很好地覆盖了所需的使用案例，并且设计得不会在数据集中的列中包含复杂类型（数组映射）时突然爆炸。这里唯一的注意事项是确保你的团队可以维护这种设计模式。如果他们可以接受以这种方式维护和编写代码，这是一个好的解决方案。然而，如果团队的其他成员习惯于命令式编程风格，这种代码设计可能和用另一种语言编写的一样晦涩难懂。
- en: If the team is facing overwhelming mountains of imperative calls, it would be
    best to introduce the team to coding styles exemplified in listing 13.7\. Taking
    the time to teach and mentor the rest of the team on more efficient development
    practices can accelerate project work and reduce the amount of maintenance involved
    in supporting projects. However, it is absolutely critical for more senior people
    to educate other team members as to *why* these standards are important. This
    does not mean throwing out a link to a language specification (someone linking
    the PEP-8 standard of Python to a PR is a pet peeve of mine), nor just firing
    off branches containing dense and efficient code at the team. Rather, it means
    crafting well-documented code, providing examples in the internal team documentation
    store, conducting training sessions, and sitting through pair programming with
    the less experienced members of the team.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果团队面临大量强制调用，最好向团队介绍列表 13.7 中展示的编码风格。花时间教授和指导团队其他成员更有效的开发实践可以加速项目工作并减少支持项目所需维护的工作量。然而，对于更资深的人来说，教育其他团队成员了解为什么这些标准很重要是绝对关键的。这并不意味着仅仅抛出一个语言规范的链接（有人将
    Python 的 PEP-8 标准链接到 PR 上是我的一个烦恼），也不是仅仅向团队发送包含密集和高效代码的分支。相反，这意味着编写良好的文档，在内部团队文档存储库中提供示例，进行培训课程，并与团队中经验较少的成员进行结对编程。
- en: If you happen to be one of these Mad Scientist types, writing elegant and well-constructed
    code that is misunderstood and opaque to the rest of your team members, the first
    thing that you should be thinking about is teaching. It is far more effective
    to help everyone understand why these paradigms of development are good than to
    write scathing PR review notes and reject merge requests. After all, if you’re
    writing good code and submitting it to a team that doesn’t have experience in
    the paradigms that you’re utilizing, it’s just as obfuscated as the mess of the
    Show-off code in listing 13.6.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你恰好是这类疯狂科学家类型的人，编写优雅且结构良好的代码，但被团队成员误解且难以理解，你应该首先考虑的是教学。帮助每个人理解为什么这些开发范式是好的，比写严厉的代码审查笔记和拒绝合并请求要有效得多。毕竟，如果你在编写好的代码并将其提交给没有你使用范式经验的团队，它和列表
    13.6 中展示的炫耀代码的混乱一样难以理解。
- en: A safer bet
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更安全的赌注
- en: Let’s look at a safer, more legible, and slightly more standard method of solving
    this problem. Here’s what a more maintainable implementation would look like.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一种更安全、更易读、稍微更标准的解决这个问题的方法。下面是一个更可维护的实现示例。
- en: Listing 13.8 A safer bet on invalid types casting
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.8 对无效类型转换的一个更安全的赌注
- en: '[PRE7]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Uses an object for encapsulation and more efficient garbage collection by
    the JVM
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用对象进行封装，并通过 JVM 进行更有效的垃圾回收
- en: ❷ Explicitly declares the data types that we want to convert to StringType
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 明确声明我们想要转换为 StringType 的数据类型
- en: ❸ Explicitly declares the data types that we want to convert to DoubleType
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 明确声明我们想要转换为 DoubleType 的数据类型
- en: ❹ Breaks out the schema reference purely to reduce the code complexity and make
    it more approachable to others reading it
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 仅为了减少代码复杂性和使其他阅读者更容易理解，将模式引用分离出来
- en: ❺ Converts the types that we declared to StringType if they’re in our configuration
    listing
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 如果它们在我们的配置列表中，将我们声明的类型转换为StringType
- en: ❻ Converts only the numeric types that match our listing to DoubleType
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 只转换与我们的列表匹配的数字类型到DoubleType
- en: ❼ Don’t touch anything else. Just leave it be.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 不要触碰任何其他东西。就让它保持原样。
- en: Notice the wrapping of the code in an object? This is to isolate references
    to those `Lists` that are defined. We don’t want variables like that defined globally
    in a code base, so encapsulating them in an object serves that purpose.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 注意代码被封装在对象中？这是为了隔离对已定义的`Lists`的引用。我们不希望在代码库中全局定义这样的变量，因此将它们封装在对象中达到这个目的。
- en: In addition, the encapsulation makes it far easier for the garbage collector
    to remove references to objects that are no longer needed. `SimpleRecasting`,
    once used and no longer referred to within the code, will be removed from the
    heap along with all other encapsulated objects within it. The seemingly more verbose
    naming convention (which helps a new reader follow along with what is being acted
    upon within the `foldLeft` operation), enables this code to be read more clearly
    than the briefer code of listing 13.7.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，封装使得垃圾收集器更容易移除对不再需要的对象的引用。一旦使用过并且代码中不再引用`SimpleRecasting`，它将和它内部的所有其他封装对象一起从堆中移除。看似更冗长的命名约定（有助于新读者跟随`foldLeft`操作中正在执行的操作），使得这段代码比列表13.7中的简短代码更易于阅读。
- en: A final note regarding this code is that the operations are entirely explicit.
    This is the largest hallmark of the difference in this code as compared to all
    previous examples, except for the original reference in listing 13.3 of the imperative
    casting. Here, as in that earlier example, we’re changing only the typing of column
    types that we’re explicitly commanding the system to change. We’re not defaulting
    behavior to “just cast everything else as `String`” or anything else that would
    create fragile, unpredictable behavior.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这段代码的最后一句话是，操作完全是显式的。这是与所有之前的例子相比，这段代码最大的特点，除了列表13.3中原始引用的命令式转换。在这里，就像那个早期的例子一样，我们只改变我们明确命令系统要改变的列类型。我们不是默认将“将所有其他内容转换为`String`”或其他任何会创建易碎、不可预测行为的操作。
- en: This approach to thinking about coding will save you a lot of frustrating hours,
    days, and months of your life troubleshooting seemingly innocuous code that blows
    up in production. We’ll revisit some of the ways that defaulting unknown state
    to a static value (or imputed values) can come back to bite us as ML engineers
    in the next chapter. For now, just realize that being explicit about actions is
    definitely a good design pattern for ML.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这种思考编码的方法将为你节省很多令人沮丧的小时、天数和月份，用于调试在生产中看似无害但实际上会导致崩溃的代码。我们将在下一章回顾一些将未知状态默认为静态值（或推断值）的方法，这些方法可能会在机器学习工程师的我们身上造成麻烦。现在，只需意识到明确动作绝对是一个好的设计模式。
- en: 13.2.2 Troublesome coding habits recap
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2.2 麻烦的编码习惯回顾
- en: In the preceding section, we focused on several, shall we say, unfriendly ways
    to write code. Each is bad in its own way and for a myriad of reasons, but the
    worst offending reasons are in table 13.2.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们关注了几种，让我们说，不友好的编写代码的方式。每种都有其自身的坏处和无数的原因，但最令人讨厌的原因在表13.2中。
- en: The most important aspect of writing code to keep in mind is that the code that
    you create is not purely for the benefit of the system executing it. If that were
    the case, the profession would likely never have moved away from low-level code
    frameworks for writing instructions (second-generation languages such as assembly
    languages or, for the truly masochistic, first-generation machine code).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码时需要牢记的最重要的一点是，你创建的代码并不仅仅是为了执行它的系统的利益。如果真是这样，那么这个职业可能永远不会从低级代码框架（如汇编语言或对真正受虐狂来说，第一代机器代码）转向编写指令的第二代语言。
- en: Table 13.2 Developer implementation sins
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 表13.2 开发者实现罪过
- en: '| Sinful persona | Why it’s so bad |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| 罪恶人格 | 为什么这么糟糕 |'
- en: '| Hacker | Fragile code is fragmented and stitched together, and breaks frequently.
    |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| 黑客 | 易碎的代码是碎片化的，并且经常断裂。|'
- en: '| Mystic | Complicated and dense code takes far too long to reverse engineer.
    Untestable nested code can silently introduce difficult-to-diagnose bugs. |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| 神秘 | 复杂且密集的代码需要花费很长时间才能逆向工程。不可测试的嵌套代码可能会静默地引入难以诊断的错误。|'
- en: '| Show-off | Intentionally complex code is intended to make others feel unworthy.
    Impossible to troubleshoot, repair, or expand upon. Nightmare code. |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| 展示 | 故意复杂的代码旨在让他人感到无足轻重。难以调试、修复或扩展。噩梦般的代码。|'
- en: '| Mad Scientist | Too clever of an implementation for peers to understand (because
    of a failure to teach). Too rigid to allow for lightweight testing or extensibility.
    |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| 疯狂科学家 | 实现过于复杂，以至于同行难以理解（因为缺乏教学）。过于僵化，不允许进行轻量级测试或扩展。|'
- en: Languages have advanced through higher-order generations not for the sake of
    computational efficiency for the processor and memory of the computers; rather,
    it has been for the sake of the humans writing, and more important, reading the
    code to figure out what it does. We write code, using high-level APIs when we
    can, and construct our code in ways to make it easy to read and maintain, solely
    for the benefit of our peers and future selves.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 语言的发展并非为了提高计算机处理器和内存的计算效率，而是为了编写代码的人类，更重要的是，为了阅读代码以了解其功能的人类。我们编写代码，尽可能使用高级API，并按照易于阅读和维护的方式构建代码，仅仅是为了我们同行和未来的自己。
- en: Avoid the habits listed in table 13.2 and move toward writing the code needed
    by you, your team, and the sort of technical talent that you’re targeting to hire
    in the future for roles in your group. Doing so will help make everyone productive
    and able to contribute to building and maintaining solutions, and will prevent
    inefficient refactoring of horribly complex code bases to fix crushing technical
    debt wrought by unthinking developers.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 避免表13.2中列出的习惯，并朝着编写你、你的团队以及你未来打算招聘的具有类似技术才能的人所需的代码方向发展。这样做将有助于使每个人都能够高效地贡献于构建和维护解决方案，并防止对复杂代码库进行低效的重构，以修复由无思考的开发者造成的沉重技术债务。
- en: 13.3 Premature generalization, premature optimization, and other bad ways to
    show how smart you are
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.3 过早的泛化、过早的优化以及其他展示你有多聪明的坏方法
- en: Let’s suppose that we’re starting a new project with a team of relatively advanced
    (from a software development perspective) ML engineers. At the start of the project,
    the architect decides that the best way to control the state of the code is to
    design and implement a framework for executing the modeling and inference tasks.
    The team is incredibly excited! Finally, the team members think, some interesting
    work!
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在与一支相对先进的（从软件开发角度来看）机器学习工程师团队开始一个新的项目。在项目开始时，架构师决定控制代码状态的最佳方式是设计和实现一个用于执行建模和推理任务的框架。团队非常兴奋！团队成员想，终于可以做些有趣的工作了！
- en: In their collective giddiness, none of them realize that, aside from illegible
    code, one of the worst forms of hubris is that of spending time where time does
    not need to be spent. They’re about to build useless framework code bases that
    serve no real purpose apart from being a justification for their own existence.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在他们的集体兴奋中，他们中没有一个人意识到，除了难以阅读的代码外，最糟糕的傲慢形式之一就是花费时间在不必要的地方。他们正准备构建无用的框架代码库，除了证明他们自己的存在之外，没有任何实际用途。
- en: '13.3.1 Generalization and frameworks: Avoid them until you can’t'
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.3.1 泛化和框架：在你无法避免之前避免使用它们
- en: 'The first thing that the team does is work on a product requirements document
    (PRD) that outlines what they want their unique framework to do. A general design,
    based on a builder pattern, is drafted. The architect wants the team to do the
    following:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 团队首先着手制作一个产品需求文档（PRD），概述他们希望他们独特的框架能做什么。基于构建者模式的一般设计被草拟。架构师希望团队执行以下操作：
- en: Ensure that custom default values are utilized throughout the project code (not
    relying on API defaults)
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在整个项目代码中利用自定义默认值（不依赖于API默认值）
- en: Enforce overriding of certain elements of the modeling process with respect
    to tuning hyperparameters
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 强制覆盖建模过程中某些元素以调整超参数
- en: Wrap the open source APIs with naming conventions and structural elements that
    are more in line with the code standards at the company
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用与公司代码标准更一致的命名约定和结构元素来包装开源API
- en: Before experimentation is done, a plan of features is developed, as shown in
    figure 13.9.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行实验之前，会制定一个功能计划，如图13.9所示。
- en: '![13-09](../Images/13-09.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![13-09](../Images/13-09.png)'
- en: 'Figure 13.9 The hopes and dreams of an architect trying to build a cohesive
    wrapper around disparate frameworks to support all ML needs of the company. Spoiler
    alert: it doesn’t end well.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.9 一个建筑师试图围绕不同的框架构建一个统一的包装器，以支持公司所有的机器学习需求。剧透一下：结果并不好。
- en: This plan for critical features is more than a little ambitious. Were this to
    proceed, the Reality aspects shown at the right side of the figure would likely
    play out (they’ve always happened whenever I’ve seen someone attempt to do this).
    Full of rework, refactoring, and redesign, this project would be doomed.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这个关键功能的计划过于雄心勃勃。如果继续进行，图右侧显示的现实方面很可能会发生（每次我看到有人尝试这样做时，这些事情总是会发生）。这个项目将充满重做、重构和重新设计，注定会失败。
- en: Instead of focusing on solving the problem by using existing frameworks (such
    as Spark, pandas, scikit-learn, NumPy, and R), the team would be supporting not
    only a project solution, but a custom implementation of a framework wrapper—and
    all of the pain that goes along with that. If you’re not staffed with dozens of
    software engineers to support a framework, it’s best to think carefully about
    planning to construct one.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 与其专注于使用现有框架（如Spark、pandas、scikit-learn、NumPy和R）解决问题，团队将不仅支持项目解决方案，还要支持一个定制的框架包装器实现——以及所有随之而来的痛苦。如果你没有几十名软件工程师来支持一个框架，最好仔细考虑计划构建一个框架。
- en: 'Adding to the immense workload of building and maintaining such a software
    stack is the simple fact that you’d be attempting to support a wrapper that is
    more generic than the framework that it is wrapping. Engaging in work like this
    never ends well for two primary reasons:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建和维护这样一个软件堆栈的巨大工作量之上，还有一个简单的事实，那就是你将尝试支持一个比它所包装的框架更通用的包装器。从事这类工作通常不会有好结果，主要有两个原因：
- en: '*You now own a framework*—This means updates, compatibility guarantees, and
    a truly massive amount of testing to write (you *are* writing tests, right?).
    Functionality assurances are now in lockstep with the packages that you’re using
    to build the framework.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*你现在拥有了一个框架*——这意味着更新、兼容性保证，以及需要编写的大量真正庞大的测试（你*确实*在编写测试，对吧？）。功能保证现在与构建框架所使用的包保持一致。'
- en: '*You now own a framework*—Unless you’re planning on making it truly generic,
    open sourcing it and having a community of committers involved in its growth,
    and committing to maintaining it, it’s pointless work to engage in.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*你现在拥有了一个框架*——除非你打算真正地使其通用，开源它，并让一个提交者社区参与其成长，并承诺维护它，否则这项工作是没有意义的。'
- en: Pursuing generalized approaches truly makes sense only if a direct need for
    that exists. Does a critical new functionality need to be developed to make another
    framework for ML work more efficiently? Perhaps think about contributing to that
    open source framework, then. Is there a need to stitch together disparate low-level
    APIs to solve a common problem? This is likely a good case for the creation of
    a framework.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在存在直接需求的情况下，追求通用方法才是真正有意义的。是否需要开发一个关键的新功能，以便使另一个机器学习框架工作得更有效率？也许你可以考虑为那个开源框架做出贡献。是否有必要将不同的低级API缝合在一起以解决一个共同的问题？这可能是一个创建框架的好案例。
- en: The *last thing* that you should be thinking about when starting a project,
    unlike our architect friend, is setting about building a custom framework to support
    that particular project. The premature generalization work involved (in time,
    distraction, and frustration) will detract heavily from the project’s pending
    work, will delay and disrupt productive work that should be focused on solving
    the problem, and will inevitably need to be reworked many times over throughout
    the evolution of the project. It’s simply not worth it.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始一个项目时，与我们的建筑师朋友不同，你最后应该考虑的是着手构建一个定制的框架来支持那个特定的项目。这种过早的泛化工作（在时间、分心和挫败感方面）将严重削弱项目的待办工作，将推迟和干扰应该专注于解决问题的生产性工作，并且不可避免地需要在项目演变过程中多次重做。这根本不值得。
- en: Should I ever build a generic framework?
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我是否应该构建一个通用的框架？
- en: Of course! Well . . . maybe.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 当然！嗯……也许吧。
- en: 'I’ll list some considerations to think about and then leave you to determine
    whether building a framework is something you actually want to pursue (provided
    it’s engaged in during designated time and not during a project delivery):'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我会列出一些需要考虑的事项，然后让你自己决定是否真的想追求构建框架（假设这是在指定时间内进行，而不是在项目交付期间）：
- en: How many people do you have on your team? If you can’t devote at least 16 human
    hours per week to maintaining the framework, adding features, and troubleshooting
    it, you should reconsider whether it’s worthwhile to start.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的团队有多少人？如果你每周无法至少投入16个人时来维护框架、添加功能和解决问题，你应该重新考虑是否值得开始。
- en: Are you planning on open sourcing it? How much of a community can you build
    around it? What are the company’s legal rules around maintaining open source software?
    How much time can you devote to supporting the software?
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你打算开源它吗？你能围绕它建立多大的社区？公司关于维护开源软件的法律规定是什么？你能投入多少时间来支持软件？
- en: Does it solve a novel problem, or are you building functionality that already
    exists in another tool?
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是否解决了新颖的问题，还是你正在构建另一个工具中已经存在的功能？
- en: Could you buy a tool or platform that does what you want your framework to do?
    If that’s the case, I guarantee that buying that tool or using existing open source
    solutions will be cheaper than devoting your time and energy to building your
    own.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你能购买一个工具或平台来执行你希望框架执行的任务吗？如果是这样，我保证购买该工具或使用现有的开源解决方案将比投入时间和精力构建自己的框架更便宜。
- en: How many dependencies will this framework have? For each additional package
    that you’re bringing on, you’re adding a factorial of headaches to its long-term
    maintenance. Software packages and dependencies change all the time with many
    deprecations that are little more than future threats that your framework is going
    to blow up in your face one day.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个框架将有多少依赖项？对于你引入的每个额外包，你都在为其长期维护增加了一个阶乘级的问题。软件包和依赖项不断变化，许多弃用实际上只是未来威胁，你的框架有一天会在你面前爆炸。
- en: What’s the additional value that this planned framework brings? If it isn’t
    accelerating your current and future project work by at least twice the amount
    of time you’re going to spend building and maintaining this framework, it’s a
    waste of time and energy.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个计划中的框架带来了哪些额外的价值？如果它不能通过至少是你将花费在构建和维护此框架上的时间的两倍来加速你当前和未来的项目工作，那么它就是浪费时间精力。
- en: Is the framework just a wrapper around another open source framework? The number
    of times I’ve seen people write a custom wrapper around pandas or Spark is truly
    shocking. Everything works well up until the next major release that has fundamental
    breaking changes (or the next minor critical feature addition that now requires
    implementing a wrapper for your custom APIs), forcing you to effectively rewrite
    your framework from scratch.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 框架只是另一个开源框架的包装器吗？我看到人们围绕pandas或Spark编写自定义包装器的次数真正令人震惊。一切工作都进行得很好，直到下一个重大版本发布，它有根本性的破坏性变化（或者下一个次要的关键功能添加，现在需要为你的自定义API实现包装器），迫使你实际上从零开始重写你的框架。
- en: Those are just a few of the questions that I ask people who tell me that they’re
    going to build a generic framework for ML work. I’m not trying to be dismissive
    of their lofty goals; it’s just that I’ve been there and know firsthand the pains
    of maintaining something of this nature.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是我向那些告诉我他们打算为机器学习工作构建通用框架的人提出的一些问题。我并不是试图贬低他们的宏伟目标；只是因为我亲身经历过，深知维护此类事物的痛苦。
- en: It makes perfect sense to build when you have hundreds of XGBoost models running
    in production to provide predictive insight into your business. But the business,
    and you, should understand the awfully large amount of work that you’re getting
    yourself into. Pursue this path only when it would be foolish not to build a framework;
    a high-level API for building, monitoring, and inferring from hundreds of XGBoost
    models would be a good reason to build one.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在生产中运行数百个XGBoost模型以提供业务预测洞察时，构建是完美的。但是，业务和你都应该理解你将使自己陷入多么巨大的工作量。只有在不构建框架就会愚蠢的情况下，才追求这条道路；为构建、监控和从数百个XGBoost模型中进行推断的高级API将是构建一个框架的好理由。
- en: 13.3.2 Optimizing too early
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.3.2 过早优化
- en: Let’s suppose we work for a different company—one without that architect from
    the previous section, preferably. This company, instead of an empire-building
    architect, has an advisor to the DS team who comes from a backend engineering
    background. Throughout this person’s career, they’ve focused on SLAs that can
    be measured in milliseconds, algorithms that traverse collections in the most
    efficient way possible, and vast amounts of time eking out every available CPU
    cycle. Their world is entirely focused on the performance of discreet portions
    of code.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们为一家不同的公司工作——一家没有上一节中那位架构师的公司，最好是。这家公司，而不是帝国建设的架构师，有一个来自后端工程背景的DS团队顾问。在整个职业生涯中，他们专注于可以以毫秒计量的SLA，以最有效的方式遍历集合的算法，以及大量时间榨取每个可用的CPU周期。他们的世界完全专注于代码离散部分的性能。
- en: On the first project, the advisor wants to contribute to the DS team’s work
    by helping to build out a load tester. Since the team is yet again dealing with
    determining whether dogs are hungry when entering the local pet supply store,
    the advisor guides the team on implementing a solution.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个项目中，顾问希望通过帮助构建负载测试器来为DS团队的工作做出贡献。由于团队再次面临确定狗在进入当地宠物用品店时是否饥饿的问题，顾问指导团队实施解决方案。
- en: Based on their experience and knowledge of Scala for backend systems, the team
    members end up focusing on something that is highly optimized for minimizing the
    memory pressure on the JVM. They want to eschew mutable buffer collections in
    favor of explicit collection building (using only the minimum amount of memory
    needed) with a fixed predetermined size of the collection. Because of prior experience,
    they spend a few days building the code in order to generate the data needed to
    test the throughput of the modeling solution for inference purposes.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 基于他们的经验和Scala后端系统的知识，团队成员最终专注于高度优化以最小化JVM上的内存压力的东西。他们希望避免使用可变缓冲区集合，而是使用显式集合构建（仅使用所需的最小内存量）和固定预定的集合大小。由于先前的经验，他们花了几天时间编写代码，以生成测试建模解决方案吞吐量的数据。
- en: To start, the advisor works on defining the data structure that is going to
    be used for testing. Listing 13.9 shows both the data structure and the defining
    static parameters to generate the data with.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，顾问致力于定义将要用于测试的数据结构。列表13.9显示了数据结构和用于生成数据的定义静态参数。
- en: NOTE The Scala formatting in listing 13.9 is condensed for printing purposes
    and is not representative of proper Scala syntax design.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 备注：列表13.9中的Scala格式是为了打印目的而压缩的，并不代表正确的Scala语法设计。
- en: Listing 13.9 Configuration and common structures for data generator
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13.9 数据生成器的配置和常见结构
- en: '[PRE8]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Defines the dataset schema (with typing) for testing
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义用于测试的数据集模式（带类型）
- en: ❷ Uses a case object to store static values for data generation (a pseudo-enumeration
    in Scala)
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用案例对象来存储用于数据生成的静态值（Scala中的伪枚举）
- en: ❸ Uses a trait for multiple inheritance to test different implementations and
    to keep the code cleaner
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用特质进行多重继承以测试不同的实现并使代码更简洁
- en: ❹ We’ll use a Spark session reference in the objects later, so having it available
    in the trait makes sense.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 我们将在对象中使用Spark会话引用，因此在特质中使其可用是有意义的。
- en: ❺ Uses a generic type to randomly fill in values (Strings or Booleans) into
    a fixed-size sequence
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 使用泛型类型随机填充值（字符串或布尔值）到固定大小的序列中
- en: ❻ Generates a random Gaussian distribution of Integer values based on the passed-in
    mean and sigma values
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 根据传入的均值和标准差值生成基于整数的随机高斯分布
- en: ❼ Generates a random Gaussian distribution of Double values based on the mean
    and sigma
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 根据均值和标准差生成基于Double值的随机高斯分布
- en: Now that the helper code has been developed to control the behavior and nature
    of the simulation data, the advisor tests the performance of the methods defined
    in the trait `DogUtility`. The performance scales well to hundreds of millions
    of elements after a few hours of tweaking and refactoring.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经开发出辅助代码来控制模拟数据的性质和行为，顾问测试了在特质`DogUtility`中定义的方法的性能。经过几小时的调整和重构后，性能在数亿个元素上表现良好。
- en: It should go without saying that this implementation is a bit of an overkill
    for the problem at hand. Since this is at the start of the project, not only are
    the features required for the end-result condition of the model not fully defined,
    but the statistical distribution of the features hasn’t been analyzed yet. The
    advisor decides that it’s now time to build the actual control execution code
    for generating the data as a Spark `DataFrame`, as shown in the next listing.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 应该不用说，这个实现对于当前的问题来说有点过度。由于这是项目的开始阶段，不仅模型最终结果所需的功能尚未完全定义，而且特征的概率分布还没有进行分析。导师决定现在是时候构建实际的控制执行代码，以生成作为
    Spark `DataFrame` 的数据，如下一列表所示。
- en: Listing 13.10 An overly complex and incorrectly optimized data generator
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.10 一个过于复杂且优化不当的数据生成器
- en: '[PRE9]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Uses the trait DogUtility defined earlier to have access to the methods and
    SparkContext defined there
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用之前定义的 DogUtility 特质来访问那里定义的方法和 SparkContext。
- en: ❷ Uses implicits from Spark to be able to cast a collection of case class objects
    directly through serialization to a DataFrame object (cuts down on a lot of nasty
    code)
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用 Spark 的隐式转换，能够直接通过序列化将案例类对象的集合转换为 DataFrame 对象（减少了大量糟糕的代码）。
- en: ❸ This is a mess. The Either type allows for a right-justified selection between
    two types and is challenging to extend properly. A generic type would have been
    better here.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 这是一团糟。Either 类型允许在两种类型之间进行右对齐选择，并且很难正确扩展。这里使用泛型类型会更好。
- en: ❹ The Option type is here because these values are not needed for some of the
    configured method calls for the data generators (one doesn’t need to define a
    sigma for a collection of Strings to be randomly sampled from).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 选项类型在这里是因为这些值对于数据生成器的一些配置方法调用不是必需的（不需要为从其中随机抽取的字符串集合定义一个 sigma）。
- en: ❺ The value type allows for optimized implementations of the generator below
    (for number of lines, not for ease of comprehension to the reader).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 值类型允许对以下生成器进行优化实现（针对行数，而不是对读者的理解容易程度）。
- en: ❻ Builds the control payload for defining how the data generators will be called
    (and in which order)
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 构建控制有效载荷，以定义数据生成器将被如何调用（以及顺序）。
- en: ❼ An overly fancy and optimized (for code length) implementation for calling
    the data generators based on the configuration specified in the method dogDataConstruct
    (this implementation is fragile)
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 这是一个针对根据方法 dogDataConstruct 中指定的配置调用数据生成器的过于花哨且优化（针对代码长度）的实现（这种实现很脆弱）
- en: ❽ OK, so this is horrible for accessing a value. Two .get operations? You’ve
    got to be kidding me.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 好吧，这对于访问一个值来说很糟糕。两个 .get 操作？你一定是在开玩笑吧。
- en: ❾ The root cause of the performance issues noticed below. This defaults to a
    Seq type but should be an IndexedSeq type to allow for O(1) access to individual
    values, instead of the current O(n).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 以下是性能问题的根本原因。这默认为 Seq 类型，但应该是 IndexedSeq 类型，以便允许对单个值进行 O(1) 访问，而不是当前的 O(n)。
- en: ❿ Wraps each collection of data in a Map object to make accessing the values
    by name easier than doing positional notation
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ 将每个数据集合包裹在一个 Map 对象中，以便通过名称访问值比使用位置表示法更容易。
- en: '⓫ Major problem #2 with this code—mapping over the index positions of each
    collection to build rows. This is O(kn) in complexity.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: ⓫ 这段代码的第二个主要问题——映射每个集合的索引位置以构建行。这在复杂度上是 O(kn)。
- en: ⓬ Converts to a Spark DataFrame
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: ⓬ 转换为 Spark DataFrame。
- en: After doing some testing on this code, the team members come to realize fairly
    quickly that the relationship between generated row size and runtime is far from
    linear. In fact, it’s much worse than linear, being more akin to O(*n*× log(*n*))
    in computational complexity. Generating 5,000 rows takes about 0.6 seconds, while
    a heavy load testing of 500,000 rows takes around 1 minute and 20 seconds. With
    the full load test of 50 million rows, the idea of waiting around for 2 hours
    and 54 minutes is a bit much.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在对这个代码进行了一些测试之后，团队成员很快意识到生成的行大小与运行时间之间的关系远非线性。事实上，它比线性更糟糕，计算复杂度更接近于 O(*n*× log(*n*))。生成
    5,000 行大约需要 0.6 秒，而 500,000 行的重负载测试大约需要 1 分钟 20 秒。对于 5000 万行的完全负载测试，等待 2 小时 54
    分钟的想法有点过分。
- en: What went wrong? They spent all of their time optimizing individual parts of
    the code so that, in isolation, each executed as quickly as possible. When the
    entire code was executed, it was a dismal mess. The implementation is just too
    clever in all of the wrong ways.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么问题？他们把所有的时间都花在优化代码的各个部分上，以至于在独立执行时，每个部分都尽可能地快。当整个代码执行时，却是一团糟。实现方式在所有错误的方向上都非常聪明。
- en: Why is it so slow, though? It’s the last part that is so crippling. Although
    the memory pressure is minimal for this implementation, the row count generation
    within the defined variable `collection` has to perform a non-indexed position
    lookup for each `Sequence` in the `Map` collection. At each iteration to build
    the `Dogs()` objects, the `Sequence` needs to be traversed to that point in order
    to retrieve the value.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为什么它这么慢呢？问题在于最后一部分，它非常致命。尽管对于这个实现，内存压力很小，但定义在变量 `collection` 中的行数生成必须在 `Map`
    集合中的每个 `Sequence` 上执行非索引位置查找。在构建 `Dogs()` 对象的每次迭代中，都需要遍历 `Sequence` 到那个位置以检索值。
- en: Now, this example is a bit hyperbolic. After all, if this backend developer
    was really adept at their optimizations, they likely would have utilized an indexed
    collection and cast the data object from a `Sequence` to an `IndexedSeq` (which
    would be able to drive directly to the position being requested and return the
    correct value in a fraction of the time). This implementation, even with that
    change, is still *sniffing about in the wrong place*.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个例子有点夸张。毕竟，如果这个后端开发者真的擅长优化，他们可能会利用一个索引集合，并将数据对象从 `Sequence` 强制转换为 `IndexedSeq`（这将能够直接到达请求的位置，并以极短的时间返回正确的值）。即使有这个改变，这种实现仍然是在错误的地方“嗅探”。
- en: The performance is terrible, but that’s only part of the story. What happens
    to the code in listing 13.10 if another data type needs to be added to be handled
    in the same manner as the `String` data? Is the developer going to wrap another
    `Either[]` statement around the first one? Is that then going to be wrapped in
    another `Option[]` type? How much of an unholy mess is this code going to become
    if a Spark `Vector` type needs to be generated? Because it was built in this manner,
    optimized excessively to an early state of a pre-MVP version of the solution,
    this code is either going to need to be modified heavily throughout the project
    to keep it synchronized with the DS team’s feature-engineering work or will need
    to be rewritten completely from scratch when it becomes cumbersome and unmaintainable.
    The likeliest path for this code is that it is destined for the infinite well
    of trash that is an `rm``-rf` command.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 性能非常糟糕，但这只是故事的一部分。如果需要添加另一种数据类型以与 `String` 数据相同的方式处理，列表 13.10 中的代码会发生什么？开发者会围绕第一个
    `Either[]` 语句包裹另一个吗？然后它会被包裹在另一个 `Option[]` 类型中吗？如果需要生成 Spark `Vector` 类型，这段代码会变成多么混乱的一团？因为这个代码是以这种方式构建的，过度优化到了解决方案预
    MVP 版本的早期状态，这段代码要么需要在整个项目中大量修改以保持与 DS 团队特征工程工作的同步，要么在变得笨拙且难以维护时需要从头开始完全重写。这段代码最有可能的路径是它注定要进入
    `rm -rf` 命令的无底深渊。
- en: The following listing shows a slightly different implementation that utilizes
    a far simpler approach. This code is focused on reducing the runtime by an order
    of magnitude.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了一种略微不同的实现方式，它利用了一种更简单的方法。这段代码专注于将运行时间减少一个数量级。
- en: Listing 13.11 A far more performant data generator
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.11 一个性能更好的数据生成器
- en: '[PRE10]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Identical to the implementation in listing 13.10
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 与列表 13.10 中的实现相同
- en: ❷ To eliminate one stage of the iteration over the collection, we can just append
    each generated sequence of values (the eventual row data) to a Buffer.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 为了消除集合迭代的一个阶段，我们只需将每个生成的值序列（最终的行数据）追加到一个 Buffer 中。
- en: ❸ Adds the first column’s data (the integers generated randomly for age) to
    the Buffer
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将第一列的数据（为年龄生成的随机整数）添加到 Buffer 中
- en: ❹ Iterates through a collection of all the String and Boolean columns’ data
    and passes their configured allowable values to the generator one by one
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 遍历所有 String 和 Boolean 列的数据集合，并将它们配置的可允许值逐个传递给生成器
- en: ❺ Calls the private method defined above to get the ArrayBuffer of randomly
    sampled data for testing
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 调用上面定义的私有方法来获取用于测试的随机采样数据的 ArrayBuffer
- en: ❻ Iterates over each row collection and generates the Dogs case class structure
    directly through position notation
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 遍历每一行数据集合，并通过位置表示法直接生成 Dogs 情况类结构
- en: ❼ Collapses the data to tuples that contain the row values together in the correct
    generated order
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 将数据折叠成元组，这些元组按照正确的生成顺序包含行值
- en: ❽ Might as well cast the Boolean field to a String type to save a processing
    step later
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 不如将布尔字段转换为字符串类型，以节省后续的处理步骤
- en: ❾ If you’ve ever known a husky, you’ll know that they’re always hungry.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 如果你曾经认识过狗熊，你会知道它们总是很饿。
- en: ❿ A husky will do anything for food. It will do nothing for an absence of food.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ 狗熊为了食物可以做任何事情。如果没有食物，它什么也不做。
- en: How did the code perform, once refactored? Well, it scales linearly now. The
    5,000 rows of data took less than a second; 50,000 rows took 1 second; and 5 million
    rows returned in just under 1 minute and 35 seconds. The 50 million target that
    was tested from the previous implementation, however, returns that row count in
    approximately 15 minutes. That’s quite a bit better than the more than 174 minutes
    from the earlier implementation.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 代码重构后表现如何？嗯，现在它是线性扩展的。5000行数据不到一秒；50000行数据用了1秒；500万行数据在不到1分钟35秒内返回。然而，之前实现中测试的5000万行目标，返回这个行数大约需要15分钟。这比早期实现中的174分钟要好得多。
- en: While this scenario is focused on a load-testing data generator and is esoteric
    for most DS practitioners, much can be said for other aspects of more ML-centric
    tasks. What would happen if someone were to focus on optimizing for performance
    one of the least important (computationally, that is) aspects of an ML pipeline?
    What if someone focused all of their energy on a project into, as we were looking
    at in the first section of this chapter, the performance of casting columns to
    specific types?
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个场景专注于负载测试数据生成器，对于大多数数据科学从业者来说很晦涩，但关于更多以ML为中心的任务的其他方面有很多可以说的。如果有人专注于优化ML管道中计算上最不重要的（即）方面，会发生什么？如果有人将所有精力集中在项目上，就像我们在本章第一部分所看到的那样，专注于将列转换为特定类型的性能，会发生什么？
- en: Figure 13.10 shows a general breakdown of most ML workflows for a training cycle.
    Note the Fermi-level estimations for each listed execution action for a generic
    ML project. Where would you spend your effort if you were trying to optimize this
    job? Where should you look first for problems and address them?
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.10显示了大多数ML工作流程训练周期的通用分解。注意每个列出的执行动作的费米能级估计，对于一个通用的ML项目。如果你试图优化这个工作，你会在哪里投入努力？你应该首先在哪里寻找问题并解决它们？
- en: '![13-10](../Images/13-10.png)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![13-10](../Images/13-10.png)'
- en: Figure 13.10 A generic breakdown of wall-clock runtime for tasks within an ML
    pipeline
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.10 ML管道内任务墙钟运行时间的通用分解
- en: As you can see, the vast majority of processing time for ML project code is
    primarily focused on data ingestion manipulations (loading data, joining data,
    calculating aggregations on data, and converting ordinal and categorical data
    to numeric representations) and hyperparameter tuning. If you notice that data
    ingestion is absolutely dominating the runtime of your project (provided that
    the platform you are utilizing can support massive parallel ingestion and the
    data storage format is optimal for rapid reading, as in Delta, Parquet, Avro,
    or a streaming source like Kafka), then look to either replatform your data to
    a more efficient storage paradigm or research more effective means of manipulating
    your data.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，ML项目代码的大部分处理时间主要专注于数据摄取操作（加载数据、合并数据、对数据进行聚合计算，以及将序数和分类数据转换为数值表示）和超参数调整。如果你注意到数据摄取绝对主导了你的项目运行时间（假设你所使用的平台可以支持大规模并行摄取，并且数据存储格式对快速读取是最优的，如Delta、Parquet、Avro或像Kafka这样的流源），那么考虑将数据重新部署到更高效的存储范式，或者研究更有效的数据处理方法。
- en: An incredibly small amount of time is spent on logging, model registration,
    and basic data manipulation tasks. Therefore, if these show a problem, the fix
    is likely going to be done relatively easily by reading the API documentation
    for the module that you’re utilizing and correcting the errors in your code.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在日志记录、模型注册和基本数据处理任务上花费的时间极其有限。因此，如果这些问题出现，修复这些问题很可能是通过阅读你所使用的模块的API文档，并纠正代码中的错误来相对容易地完成的。
- en: 'Knowing this, any optimization efforts should be primarily focused on reducing
    the total runtime and CPU pressure of these high temporal-bound stages of a job
    and not wasted on creating complex and clever code for insignificant portions
    of the solution. The key takeaway is that the process of optimizing ML code should
    focus on a few key critical aspects:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这一点，任何优化努力都应该主要集中于减少工作的高时间约束阶段的总运行时间和CPU压力，而不是浪费在为解决方案中不重要的部分创建复杂和巧妙的代码上。关键要点是，优化ML代码的过程应该关注几个关键的关键方面：
- en: '*Wait until the entire code base functions end to end before spending time
    optimizing code.* The sheer number and frequency of changes that happen during
    development will likely make rework of optimized code a frustrating experience.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*等待整个代码库的端到端功能全部运行正常后再花时间优化代码。* 在开发过程中发生的更改数量和频率可能会使对优化代码的重做变得令人沮丧。'
- en: '*Identify the longest-running portions of the code.* Attempt to get clever
    to make these more performant before tackling the portions that are already comparatively
    fast.'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*识别代码中运行时间最长的部分。* 在解决已经相对较快的部分之前，尝试变得巧妙，使这些部分更加高效。'
- en: '*Don’t reinvent the wheel.* If a language construct (or similar functionality
    in a completely different language, for that matter) will remarkably speed up
    or reduce memory pressure of what you’re trying to do, just use it. Implementing
    your own linked list abstract class or designing a new dictionary collection is
    the ultimate act of hubris. Just use what is out there and move on to solving
    a more worthwhile problem.'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*不要重新发明轮子。* 如果一个语言结构（或者类似功能在完全不同的语言中，无论如何）可以显著加快你正在尝试做的事情，或者减少内存压力，那么就使用它。实现你自己的链表抽象类或设计一个新的字典集合是极度自负的行为。只需使用现有的，然后继续解决更有价值的问题。'
- en: '*Explore different algorithms if the runtime is truly terrible.* Just because
    you really like gradient boosted trees doesn’t mean that they’re the ideal solution
    to every problem. Perhaps a linear model could get relatively close in performance
    at a fraction of the runtime. Is 0.1% accuracy worth a 50-times increase in budget
    to run the model?'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*如果运行时间确实非常糟糕，请探索不同的算法。* 只因为你非常喜欢梯度提升树，并不意味着它们是解决每个问题的理想方案。也许一个线性模型可以在运行时间的一小部分内相对接近性能。0.1%的准确度值得为了运行模型而增加50倍的预算吗？'
- en: Embodied within the collective DS-DNA of many teams that I see engage in premature
    optimization and generalization is the belief that the technical aspects of ML
    project work supersede the problems that they are trying to solve. They love the
    tools, the amazing new work being pushed out by large ML-focused organizations,
    and the rapid advancements being made continually in the ecosystem of ML. These
    groups care far more about the platforms, the toolkits, the frameworks, the algorithms,
    and the tech side of ML work than they do about making sure that their approach
    is going to help their business in the most efficient and maintainable way possible.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看到的多支参与过早优化和泛化的团队中，DS-DNA的集体信念是，ML项目工作的技术方面超越了他们试图解决的问题。他们热爱工具，热爱大型ML专注组织推出的令人惊叹的新工作，以及ML生态系统中不断取得的快速进步。这些团队对平台、工具包、框架、算法以及ML工作的技术方面的关心远超过他们确保他们的方法能够以最有效和最可维护的方式帮助他们的业务。
- en: 13.4 Do you really want to be the canary? Alpha testing and the dangers of the
    open source coal mine
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.4 你真的想成为那只金丝雀吗？alpha测试和开源矿井的危险
- en: Let’s pretend for a moment that you are incredibly new to the field of DS. So
    new, in fact, that it’s your first week on the job. In the office, you look around
    your desk. Not a single DS on the team has been employed in the profession for
    more than a month. The manager, an experienced software engineer, is busy with
    managing not only the DS team, but also the business intelligence team and the
    data warehousing group, and is busy interviewing additional candidates to fully
    round out the new DS team.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时假设你对DS领域非常陌生。实际上，你甚至是在工作的第一周。在办公室里，你环顾你的办公桌。团队中没有任何DS成员在职业中工作超过一个月。经理，一位经验丰富的软件工程师，不仅忙于管理DS团队，还忙于管理商业智能团队和数据仓库小组，并且忙于面试更多候选人，以使新的DS团队更加完整。
- en: As a first task, a low-hanging fruit modeling project is generated for the team
    to tackle. Being told that no, you can’t use your laptops to do the work as you
    did in school, the direction that the manager gives all of you is to select a
    framework for developing models.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一个任务，为团队生成一个低垂的果实建模项目来应对。被告知不能使用你在学校做工作时的笔记本电脑，经理给你们的方向是选择一个用于开发模型的框架。
- en: Within the first few days of research and investigations into platforms and
    solutions, one of the team members catches wind of a new framework being discussed
    in blogs. It seems to be forward-thinking, feature-rich, and easy to use. The
    general discussion around what is planned to be built for it over the coming months
    is incredibly powerful. There is talk about supporting not only CPU tasks in a
    distributed massively parallel processing (MPP) system written in C++ that has
    a slick-looking Python API as an interface, but also GPU clusters and future plans
    to support a quantum computing interface (quantum oracle optimization of superposition
    of all possible solutions to least squares problems)!
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在对平台和解决方案进行研究和调查的前几天，团队成员之一在博客中发现了正在讨论的一个新框架。它似乎具有前瞻性、功能丰富且易于使用。关于未来几个月计划为它构建的内容的讨论非常强大。有关于支持不仅是在用C++编写的具有光滑Python
    API作为接口的分布式大规模并行处理（MPP）系统中的CPU任务，还包括GPU集群以及未来计划支持量子计算接口（量子算子优化所有可能的解的叠加以解决最小二乘问题的讨论）！
- en: If you’ve ever read the source code for an ML framework (one that’s used by
    a majority of professionals in solving actual problems, that is), contributed
    to one, or built even a wrapper around the functionality exposed in one of the
    more popular open source ones out there, you’ll realize how silly this “new and
    hot” framework is. If that describes you, you’d be in the right-hand section of
    figure 13.11 (not bitter, but rather, wise).
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经阅读过机器学习框架的源代码（即大多数专业人士在解决实际问题时所使用的框架），为其中一个框架做出过贡献，或者甚至围绕其中一些更受欢迎的开源框架的功能构建了一个包装器，你就会意识到这个“新潮且热门”的框架是多么荒谬。如果你是这样的情况，那么你就在图13.11的右侧部分（不是苦涩，而是明智的）。
- en: Let’s agree that the team we’re on is entrenched within the middle column of
    figure 13.11\. The team members’ naivete blinds them to the dangers that they’re
    about to face in embracing this half-baked hubristic monstrosity that an overly
    ambitious developer is attempting to build. We try it out, we volunteer to be
    the canary, and our project pays with its life.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们同意，我们所在的团队深深扎根于图13.11的中间列。团队成员的天真使他们无法看到他们即将面对的危险，那就是拥抱这个半成品、傲慢的怪物，一个过于雄心勃勃的开发者正在尝试构建。我们尝试了它，我们自愿成为试验品，我们的项目以生命为代价。
- en: '![13-11](../Images/13-11.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![13-11](../Images/13-11.png)'
- en: Figure 13.11 The hype? It’s real. It also usually means that the object of that
    hype is really bad (or at least not what it claims to be).
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.11 炒作？这是真实的。这也通常意味着炒作的对象实际上真的很糟糕（或者至少不是它所声称的那样）。
- en: 'The end result of working in this new and heavily under-construction framework
    is inevitable: a complete and thorough failure. The failure of getting the project
    off the ground isn’t because of the API they’re using, nor is it in how they are
    tuning their solution. The real failure is in the hubris of the developer and
    the blog hype-o-sphere that surrounds bombastic claims of new functionality and
    frameworks.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新且高度在建的框架中工作的最终结果不可避免：彻底的失败。项目无法启动的失败并不是因为它们使用的API，也不是因为它们调整解决方案的方式。真正的失败在于开发者的傲慢和围绕新功能和新框架的夸大其词的博客炒作氛围。
- en: There is absolutely nothing wrong with trying things out. I frequently try out
    these newly announced packages to see if they’re worthwhile. I do my testing on
    open source datasets, run them in isolated environments that won’t contaminate
    my class path with flaky dependencies, and run them through their paces. I evaluate
    their claimed functionality, check for the ease of enhancing their functionality
    with custom implementations, and see how the system handles different modeling
    tasks. Is the memory utilization stable? Is the CPU usage on par (or, hopefully,
    better!) than comparable systems in widespread use? I ask all of these questions
    and more through my validations of their claims.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试新事物绝对没有错。我经常尝试这些新发布的软件包，看看它们是否值得。我在开源数据集上进行测试，在隔离环境中运行它们，以确保不会因为不稳定的依赖而污染我的类路径，并且让它们经历所有测试。我评估它们声称的功能，检查是否容易通过自定义实现来增强其功能，并观察系统如何处理不同的建模任务。内存利用率是否稳定？CPU使用率是否与广泛使用的类似系统相当（或者，希望更好！）？我通过验证它们的声明来询问所有这些问题以及更多。
- en: 'What I never do is attempt to build a project that a business depends on while
    using one of these packages in their early stages. There are several reasons for
    this:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我永远不会在早期阶段使用这些软件包之一来构建一个企业依赖的项目。这里有几个原因：
- en: '*The API’s are going to change*—*a lot.* The entire interface will likely be
    completely refactored by the time a stable 1.0 release happens. You’ll have to
    change your code to accommodate.'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*API将会改变*—*很多。* 到稳定版1.0发布时，整个接口很可能会被完全重构。你将不得不更改你的代码以适应。'
- en: '*Things will be broken.* Maybe a few things, but usually a lot of things at
    the beginning of a project’s alpha release phase. If you build something important
    on top of flaky code, you’ll be dealing with an unstable project code base.'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*事情可能会出错。* 可能会有一些事情，但通常在项目的alpha发布阶段初期会有很多事情出错。如果你在脆弱的代码上构建了重要的东西，你将不得不面对一个不稳定的代码库。'
- en: '*There’s no guarantee that the project isn’t going to become shelfware.* If
    a seriously strong community doesn’t exist around the project with hundreds or
    thousands of contributors and buy-in by a significant portion of the ML community,
    the code base is likely going to become extinct and abandoned. You really don’t
    want your project running on dead code.'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*没有保证项目不会变成积压品。* 如果项目周围没有强大的社区，没有数百或数千的贡献者，以及机器学习社区中相当一部分人的支持，代码库很可能会灭绝并被遗弃。你真的不希望你的项目运行在死代码上。'
- en: '*Even at the first announced release, tech debt is in there.* Corners were
    cut, shortcuts were traversed, and bugs will be present. It may work great for
    the demos and be flawless for the prepackaged examples, but it likely won’t work
    well for your highly specific custom logic that you need to implement to solve
    your predictive modeling task for your business. At least not until much later
    in its life cycle.'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*即使是在首次发布的版本中，技术债务也早已存在。* 有时候会走捷径，省略某些步骤，并且可能存在一些错误。它可能对演示效果很好，对预包装的示例也毫无瑕疵，但很可能不会很好地适用于你需要实现以解决业务预测建模任务的非常具体的自定义逻辑。至少在其生命周期后期之前不会。'
- en: '*Just because it’s new doesn’t mean it’s better.* Before deciding on something
    as critical as a framework or platform, you absolutely have to ignore the marketing
    hype from companies, blog posters, and the noisy buzz of advertisements. Test
    things out and perform a scientific study of your options. Select the solution
    that makes the most sense from a productivity, maintainability, stability, and
    cost perspective. The shiny new toy could be all of those things, but in my experience,
    it’s almost never the case (although sometimes these projects do grow into exactly
    that eventually, so keep an eye on them).'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*新不一定代表更好。* 在决定像框架或平台这样至关重要的东西之前，你绝对必须忽略来自公司、博客作者和广告嘈杂声中的营销炒作。尝试新事物，并对你的选项进行科学的研究。从生产力、可维护性、稳定性和成本的角度选择最合理的解决方案。这个闪亮的新玩具可能具有所有这些特性，但根据我的经验，这几乎从未发生过（尽管有时这些项目最终确实会变成那样，所以请密切关注它们）。'
- en: Embracing another person’s hubris is one of the most destructive tasks that
    can plague an ML team. By not doing proper testing and research of options about
    how and where to run your code, you run the risk of getting duped into a system
    that is fundamentally broken and will end up costing your team far more time and
    money in just keeping the lights on rather than innovating into new project solutions
    that you should be working on. Let your testing phase be your canary, not your
    ML projects.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 接受他人的傲慢是可能困扰机器学习团队的最具破坏性的任务之一。通过不做适当的测试和研究关于如何以及在哪里运行你的代码的选项，你可能会陷入一个本质上已经破裂的系统，这最终会导致你的团队在仅仅保持系统运行而不是创新到新的项目解决方案上花费更多的时间和金钱。让你的测试阶段成为你的金丝雀，而不是你的机器学习项目。
- en: 13.5 Technology-driven development vs. solution-driven development
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.5 技术驱动开发与解决方案驱动开发
- en: Let’s shift gears from the newbie-crew of DS members in section 13.4 and take
    a look at working in a group filled with highly experienced ML engineers. Let’s
    suppose that not a single person on the team has fewer than 20 years of software
    development experience, and each has grown bored and tired with building different
    flavors of deep learning models, gradient boosted trees, linear models, and univariate
    forecasts.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第13.4节的新手数据科学成员团队转移到充满经验丰富的机器学习工程师的团队。假设团队中没有一个人的软件开发经验少于20年，每个人都对构建不同类型的深度学习模型、梯度提升树、线性模型和单变量预测感到厌倦和疲惫。
- en: They all yearn to build something to automate away the tedium of the hundreds
    of predictive models that they are working on. What they want more than anything
    is a challenge.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 他们都渴望构建一些东西来自动化处理他们正在工作的数百个预测模型的枯燥工作。他们最想要的莫过于一个挑战。
- en: When faced with their next major project, an association-rules-based implementation
    (were they to use a tried-and-true approach), they decide to get clever. They
    feel as though they could write a more performant version of the FP-growth algorithm
    on Apache Spark and set to work deriving an equation for an improved version of
    an FP-tree that can be mined dynamically in such a way as to eliminate one of
    the core scans of the tree for item collection retrieval.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 当面对他们下一个主要项目时，一个基于关联规则的实现（如果他们使用一个经过验证的方法），他们决定要聪明一点。他们感觉可以编写一个在Apache Spark上运行性能更好的FP-growth算法版本，并开始推导出一个改进的FP-tree方程，这样就可以动态挖掘，从而消除树的核心扫描之一，用于项目收集检索。
- en: While well-intentioned, they end up spending three full months working on their
    algorithm, testing it, and proving that it retains nearly identical results to
    the reference FP-growth implementation but at a fraction of the time to build
    and scan the tree. They’ve created a novel algorithm implementation and set to
    work on using it to solve the business use case that they agreed to develop.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然他们的初衷是好的，但他们最终花了整整三个月的时间来完善他们的算法，测试它，并证明它几乎与参考FP-growth实现的结果相同，但构建和扫描树的时间却少了很多。他们创造了一种新的算法实现，并开始使用它来解决他们同意开发的业务用例。
- en: They crack some beers, slap some backs, and get to work on writing their blog
    post and whitepaper, and prepare for some conference speaking engagements. Oh
    boy, everyone is going to know just how clever they are now!
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 他们喝了一些啤酒，拍了拍彼此的背，开始撰写他们的博客文章和白皮书，并为一些会议演讲活动做准备。哦，天哪，现在每个人都知道他们有多么聪明了！
- en: They release the solution into production. Everything is working well, and the
    algorithm is, in their minds, paying for itself every day in cost savings of remarkably
    improved runtimes. That is, of course, until a major revision for the underlying
    framework is released. In this new runtime, significant changes are made to the
    way these trees are constructed in the open source framework, as well as a fundamental
    level of optimization in how antecedents are building the consequents.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 他们将解决方案投入生产。一切运行良好，在他们看来，这个算法每天都在通过显著提高运行时间的成本节约来为自己付费。当然，直到底层框架的重大修订发布。在这个新的运行时中，开源框架中对这些树的构建方式进行了重大更改，以及如何构建前因和后果的根本性优化。
- en: The team is demoralized at the prospect of adjusting the model to fit in with
    the underlying changes in the developer-level APIs that they used to build their
    solution. Figure 13.12 illustrates their plight and what they should have done
    instead.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 团队对调整模型以适应他们用来构建解决方案的开发者级API的底层变化感到士气低落。图13.12展示了他们的困境以及他们本应该做的事情。
- en: '![13-12](../Images/13-12.png)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![13-12](../Images/13-12.png)'
- en: Figure 13.12 An ML technical debt choose-your-own-adventure path
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.12 一个机器学习技术债务的“选择你的冒险”路径
- en: As you can see, the key decision that derailed the project was in not using
    preexisting standards that have been proven many times before. Not only did they
    have to build a solution to support the business use case, but they had to build
    an entirely new algorithm, integrate it to a framework’s low-level design paradigms,
    and fully own the implementation to ensure that they can continue to support the
    business use case that drove the creation of their unique algorithm.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，导致项目脱轨的关键决策在于没有使用之前多次被证明有效的现有标准。他们不仅需要构建一个支持业务用例的解决方案，还必须构建一个全新的算法，将其整合到框架的低级设计范式，并完全拥有实现权，以确保他们可以继续支持推动他们独特算法创建的业务用例。
- en: Because their algorithm leveraged so many of the internal structures of the
    framework to speed up development processes, the team is now left with a new quandary.
    Do they update their algorithm to work in the new framework version, hoping that
    it will continue to outperform the provided FP-growth algorithm? Or do they refactor
    their entire solution to work with the standard algorithm?
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 由于他们的算法利用了框架的许多内部结构来加速开发过程，团队现在面临一个新的困境。他们是更新他们的算法以在新框架版本中工作，希望它将继续优于提供的 FP-growth
    算法？还是重构整个解决方案以使用标准算法？
- en: There’s no good answer here. Their custom framework is destined to either become
    shelfware or incur a few quarters’ worth of conversion to make it work.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有好的答案。他们的自定义框架注定要么成为积压品，要么需要几个季度的转换才能使其工作。
- en: The principal problem with their attempt was building a custom implementation
    that they *weren’t prepared to support*. They were building a solution not to
    solve the business problem, but rather for notoriety. They wanted to be noticed
    and appreciated for their skills. The team failed to realize that, while there
    is nothing really wrong with building new algorithms and advancing the state of
    the profession, the motivation behind building it should be centered on the necessity
    to solve a problem.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 他们尝试的主要问题是构建了一个他们没有准备好支持的定制实现。他们构建解决方案不是为了解决业务问题，而是为了出名。他们想要被注意到并得到赞赏，因为他们的技能。团队没有意识到，虽然构建新算法和推进职业状态并没有什么真正的问题，但构建它的动机应该集中在解决问题的必要性上。
- en: Had the team members approached the problem with a solution-driven mindset,
    they never would have entertained the possibility of creating a custom solution.
    Perhaps they would have contacted the maintainers of the existing popular open
    source framework and volunteered to create a new version that could be supported
    by that framework’s community. If there was a distinct need to reduce runtime
    to meet an SLA and a novel algorithm needed to be built, that’s fine. If you encounter
    that need, go build it. Just know that you need to maintain that code for as long
    as that business use case need exists.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 如果团队成员以解决方案驱动的思维方式来处理问题，他们永远不会考虑创建自定义解决方案的可能性。也许他们会联系现有流行开源框架的维护者，并自愿创建一个可以由该框架社区支持的新版本。如果有明确的降低运行时间以满足服务级别协议的需要，并且需要构建一个新算法，那是可以的。如果你遇到这种需求，就去构建它。只是要知道，你需要维护那段代码，直到那个业务用例的需求存在。
- en: I find myself increasingly more and more allergic to this concept of TDD, as
    it just adds more stress to an already stressful profession. By pursuing the easier
    (and, arguably, more boring) solution to a problem, particularly if you already
    have an existing solution to a nearly identical problem in place, you’re leaving
    the business in better hands. You’ll have less maintenance work to do and more
    time to creatively use your talents at solving more interesting future problems.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现自己越来越反感这种 TDD（测试驱动开发）的概念，因为它只是给一个已经压力很大的职业增加了更多的压力。通过追求更容易（并且，可以说，更无聊）的解决方案来解决问题，尤其是如果你已经有一个现有的解决方案来解决几乎相同的问题，你是在让业务处于更好的手中。你将会有更少的维护工作要做，有更多的时间创造性地使用你的才能来解决更有趣的未来问题。
- en: Summary
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Pursuing simple implementations that don’t overreach the immediate needs of
    a project will save a great deal of refactoring later when the functionality needs
    to change. Less is more.
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 追求简单实现，不超出项目当前需求，将节省在功能需要改变时大量重构的时间。少即是多。
- en: While everyone is at a different stage of growth in software development skills,
    having a team focus on utilizing common design patterns that are easy to understand
    and read will ensure that everyone on a team can contribute to and maintain a
    code base.
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然每个人在软件开发技能的增长阶段都不同，但让团队专注于利用易于理解和阅读的通用设计模式，将确保团队中的每个人都能为代码库做出贡献并维护它。
- en: Building unnecessary functionality, complex interfaces, and clever unique implementations
    within an ML code base only means that you’re having to support and maintain more
    code, providing no value to the organization. Keeping a code base only as complex
    as it needs to be to solve a problem is always a wise choice.
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在机器学习代码库中构建不必要的功能、复杂的接口和巧妙的独特实现，仅仅意味着你将不得不支持和维护更多的代码，这对组织没有任何价值。保持代码库的复杂度仅限于解决问题的关键，始终是一个明智的选择。
- en: Thoroughly investigating the capabilities, utility, and most important, the
    needs of any new technology to determine whether it is useful for a project is
    essential before deciding to integrate any such tooling into a project.
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在决定将任何此类工具集成到项目中之前，彻底调查任何新技术的能力、实用性和最重要的是需求，以确定它是否对项目有用，这是至关重要的。
- en: Take care when working on a project for a business need to focus on implementing
    only what is needed to solve the problem. Anything apart from what is required
    for the project is vanity development and detracts from the maintainability of
    a solution.
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在为商业需求工作项目时，要注意只实现解决问题所需的功能。任何超出项目需求的东西都是虚荣的开发，会损害解决方案的可维护性。
