- en: 18 Future Java
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 18 未来 Java
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了
- en: Project Amber
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Project Amber
- en: Project Panama
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Project Panama
- en: Project Loom
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Project Loom
- en: Project Valhalla
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Project Valhalla
- en: Java 18
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 18
- en: This chapter covers developments in the Java language and platform since the
    release of Java 17, consisting of future updates that have not yet arrived. New
    directions in the Java language and platform are governed by JEPs, but those are
    descriptions of the implementations of specific features. At a higher level, there
    are several large, long-running projects within OpenJDK that are implementing
    the major changes that are currently in-flight and will be delivered over the
    coming years.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了自Java 17发布以来的Java语言和平台的发展，包括尚未到达的未来更新。Java语言和平台的新方向由JEPs管理，但那些是特定功能实现的描述。在更高层次上，OpenJDK中有几个大型、长期运行的项目正在实施目前正在进行的重大变化，并将在未来几年内交付。
- en: We’re going to meet each project in turn and then Java 18\. We’re going to start
    with *Project Amber*, where we will hear more of the story of pattern matching
    and why it is such an important feature.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将依次介绍每个项目，然后是Java 18。我们将从*Project Amber*开始，我们将听到更多关于模式匹配及其为何如此重要的故事。
- en: 18.1 Project Amber
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.1 Project Amber
- en: 'Of the current major projects in OpenJDK, Amber is the closest to completion.
    It also benefits from being relatively easy to understand in terms of a developer’s
    day-to-day work. From the project’s charter:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenJDK的当前主要项目中，Amber最接近完成。它还受益于在开发者日常工作中相对容易理解。从项目的章程中：
- en: The goal of Project Amber is to explore and incubate smaller, productivity-oriented
    Java language features ...
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Project Amber的目标是探索和孵化更小、面向生产力的Java语言特性 ...
- en: —Project Amber, [https://openjdk.java.net/projects/amber/](https://openjdk.java.net/projects/amber/)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: —Project Amber，[https://openjdk.java.net/projects/amber/](https://openjdk.java.net/projects/amber/)
- en: The main goals of the project are
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目的主要目标是
- en: Local Variable Type Inference (Delivered)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 局部变量类型推断（已交付）
- en: Switch Expressions (Delivered)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Switch 表达式（已交付）
- en: Records (Delivered)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录（已交付）
- en: Sealed Types (Delivered)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sealed Types（已交付）
- en: Pattern Matching
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式匹配
- en: As you can see, a lot of these features have been delivered as of Java 17—and
    very useful they are, too!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，许多这些功能已在Java 17中交付——而且非常实用！
- en: The last major piece of Amber that is still outstanding is Pattern Matching.
    As we saw in chapter 3, it is arriving in increments, the first of which is the
    use of a type pattern in `instanceof`. We also met the preview version of patterns
    in `switch`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Amber最后一个尚未解决的重大问题是模式匹配。正如我们在第3章中看到的，它正在逐步到来，首先是`instanceof`中的类型模式的使用。我们还遇到了`switch`中的模式预览版本。
- en: 'It is reasonable to expect that patterns in `switch` will move through the
    same lifecycle that other Project Amber features have: a first and then a second
    preview, and then delivery as a standard feature after that.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有理由预期`switch`中的模式将经历与其他Project Amber功能相同的生命周期：首先是一个预览，然后是第二个预览，之后作为标准功能交付。
- en: Looking to the future, more JEPs are planned. Finalizing the basic form of Pattern
    Matching is not the only game in town—there are additional forms of pattern to
    add. This tells us that, with the change in the release cadence to an “LTS every
    two years” model, anything initially previewed in Java 18 or 19 would have time
    to fully graduate for the next expected LTS, Java 21, in September 2023.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 展望未来，更多JEPs计划推出。确定模式匹配的基本形式并非唯一的目标——还有更多模式形式需要添加。这告诉我们，随着发布节奏的变化，每两年一个“LTS”模式，Java
    18或19中最初预览的内容将有机会在下一个预期的LTS，即2023年9月的Java 21中完全成熟。
- en: For example, we’ve already seen how Sealed Types can be used to great effect
    in the current, preview version of Pattern Matching. Without Sealed Types, even
    the form of Pattern Matching we have now would not be as useful. In a similar
    fashion, some of the most important use cases for Records in patterns have yet
    to be delivered. In particular, *deconstruction patterns* will allow a Record
    to be broken up in to its components as part of a pattern.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们已经看到了如何在当前的模式匹配预览版本中有效地使用Sealed Types。没有Sealed Types，即使我们现在拥有的模式匹配形式也不会那么有用。以类似的方式，记录在模式中的某些最重要的用例尚未交付。特别是，*解构模式*将允许将记录分解为其组件，作为模式的一部分。
- en: Note If you’ve programmed in Python or JS or other languages, you may be familiar
    with *destructuring*. The idea of deconstruction in Java is similar but is guided
    by Java’s nominal type system.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果您在Python、JS或其他语言中编程，您可能熟悉*解构*。Java中解构的想法类似，但受Java的名义类型系统指导。
- en: This is possible because Records are defined by their semantics—a Record is
    literally nothing more than the sum of its parts. So, if a Record can be constructed
    only by stitching together its components, then it follows that it can be rendered
    down into its components with no semantic consequences.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为记录是由其语义定义的——记录实际上 nothing more than the sum of its parts。因此，如果记录只能通过拼接其组件来构建，那么它就可以得出结论，它可以无语义后果地分解为其组件。
- en: 'At time of writing, this feature has not arrived into mainline JDK development,
    or even into the Amber-specific JDK repos. However, the syntax is expected to
    look like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，此功能尚未进入主线JDK开发，甚至尚未进入Amber特定的JDK仓库。然而，语法预计将类似于以下：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that this code contains explicit types for the Record components. It is
    also reasonable to expect that the types could also be inferred by the compiler.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此代码包含Record组件的显式类型。也可以合理地预期，编译器可以推断出这些类型。
- en: 'It should also be possible to deconstruct arrays as well because they also
    act as element containers that do not have additional semantics. The syntax for
    that may look like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 也应该能够解构数组，因为它们也充当没有额外语义的元素容器。该语法的样子可能如下所示：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that in both examples, we have not declared a binding for the element container,
    whether a Record or an array.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在两个示例中，我们都没有为元素容器声明绑定，无论是记录还是数组。
- en: A side point that should be mentioned here is how Java serialization affects
    this feature. In general, Java serialization is a problem, because it violates
    some basic rules of how encapsulation is supposed to work in Java.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 应该在这里提到的一个旁白是Java序列化如何影响这个特性。一般来说，Java序列化是一个问题，因为它违反了Java中封装应该如何工作的基本规则。
- en: Serialization constitutes an invisible but public constructor, and an invisible
    but public set of accessors for your internal state.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化构成了一个无形但公开的构造函数，以及一个无形但公开的访问器集合，用于您的内部状态。
- en: —Brian Goetz
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ——Brian Goetz
- en: 'Fortunately, both Records and arrays are very simple: they are just transparent
    carriers for their contents, so there is no need to invoke the weirdness in the
    detail of the serialization mechanism. Instead, we can always use the public API
    and canonical constructor to serialize and deserialize records. Building upon
    this foundation, there are even suggestions that could be very far-reaching, such
    as removing the serialization mechanism partially or completely and extending
    deconstruction to some (or even all) Java classes.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，记录和数组都非常简单：它们只是其内容的透明载体，因此不需要在序列化机制的细节中调用怪异之处。相反，我们始终可以使用公共API和规范构造函数来序列化和反序列化记录。在此基础上，甚至有建议可以非常深远，例如部分或完全移除序列化机制，并将解构扩展到某些（甚至所有）Java类。
- en: 'Overall, the message from Amber is: if you’re familiar with these features
    from other programming languages, then great. But, if not, then don’t worry—they
    are being designed to fit with the Java language you already know and be easy
    to start using in your code.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，Amber传达的信息是：如果你熟悉其他编程语言中的这些特性，那就太好了。但是，如果你不熟悉，也无需担心——它们被设计成与您已经熟悉的Java语言兼容，并且易于在代码中开始使用。
- en: Although some of the features are small and others larger, they can all have
    a positive impact on your code that is out of proportion with the size of the
    changes. Once you’ve started using them, you’ll likely find that they offer real
    benefit to your programs. Let’s now turn to the next of the major projects, codenamed
    Panama.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一些特性很小，而另一些则较大，但它们都可以对您的代码产生与更改规模不成比例的积极影响。一旦您开始使用它们，您可能会发现它们为您的程序提供了真正的益处。现在让我们转向下一个主要项目，代号为Panama。
- en: 18.2 Project Panama
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.2 项目 Panama
- en: Project Panama is, in the words of its project page, all about
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 根据项目页面上的说法，Project Panama的全部内容是
- en: improving and enriching the connections between the Java virtual machine and
    well-defined but “foreign” (non-Java) APIs, including many interfaces commonly
    used by C programmers.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 提高和丰富Java虚拟机与定义良好但“外国”（非Java）API之间的连接，包括许多C程序员常用的接口。
- en: —Project Panama, [https://openjdk.org/projects/panama/](https://openjdk.org/projects/panama/)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ——Project Panama, [https://openjdk.org/projects/panama/](https://openjdk.org/projects/panama/)
- en: 'The name “Panama” comes from the idea of an *isthmus*—a narrow string of land
    connecting two larger landmasses—which in this analogy are understood to be the
    JVM and native code. It comprises JEPs in two main areas:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: “巴拿马”这个名字来源于一个**地峡**的概念——一条狭窄的陆地连接两个更大的陆地，在这个类比中，这两个更大的陆地被认为是JVM和本地代码。它包括两个主要领域的JEP：
- en: Foreign Function and Memory API
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部函数和内存API
- en: Vector API
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量API
- en: Of these, we will discuss only the Foreign API in this section. The Vector API
    is not ready for a full treatment yet, for reasons that we will explain later
    in the chapter.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些中，我们将在本节中仅讨论外部API。向量API尚未准备好进行全面讨论，原因我们将在本章后面解释。
- en: 18.2.1 Foreign Function and Memory API
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.2.1 外部函数和内存API
- en: 'Java has had the Java Native Interface (JNI) for calling in to native code
    since Java 1.1, but it has long been recognized as having the following major
    problems:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 自Java 1.1以来，Java就拥有了Java Native Interface (JNI)来调用本地代码，但它长期以来一直被认为存在以下主要问题：
- en: The JNI has a lot of ceremony and extra artifacts.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JNI有很多仪式和额外组件。
- en: The JNI really only interoperates well with libraries written in C and C++.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JNI实际上仅与用C和C++编写的库良好互操作。
- en: The JNI does not do anything automatic to map the Java type system to the C
    type system.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JNI没有自动将Java类型系统映射到C类型系统的功能。
- en: 'The extra artifacts aspect is reasonably well understood by developers: as
    well as the Java API of `native` methods, JNI requires a C header (`.h`) file
    derived from the Java API and a C implementation file, which will call into the
    native library. Some of the other aspects are less well known, such as the fact
    that a native method cannot be used to invoke a function written in a language
    that uses a different calling convention than the one the JVM was built against.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者对额外组件方面有相当好的理解：除了`native`方法的Java API外，JNI还需要一个从Java API派生的C头文件（`.h`）和一个C实现文件，该文件将调用本地库。其他一些方面则不太为人所知，例如，本地方法不能用来调用使用与JVM构建时不同的调用约定编写的函数。
- en: In the intervening years since the JNI first arrived, a number of attempts have
    been made to provide a better alternative, such as JNA. However, other (non-JVM)
    languages have significantly better support for interoperating with native code.
    For example, Python’s reputation as a good language for machine learning largely
    depends on the ease of packaging native libraries and making them available in
    Python code.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 自JNI首次出现以来，已经尝试了多种提供更好替代方案的方法，例如JNA。然而，其他（非JVM）语言在与其他本地代码互操作方面有显著更好的支持。例如，Python作为机器学习良好语言的声誉很大程度上取决于打包本地库并将其在Python代码中提供的简便性。
- en: 'The Panama Foreign API is an attempt to close that gap, by allowing direct
    support in Java for the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 巴拿马外国API是一个尝试填补这一差距的尝试，它允许Java直接支持以下功能：
- en: Foreign memory allocation
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部内存分配
- en: Manipulation of structured foreign memory
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构化外部内存操作
- en: Lifecycle management of foreign resources
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部资源生命周期管理
- en: Calling foreign functions
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用外部函数
- en: The API lives in the `jdk.incubator.foreign` package in the `jdk.incubator.foreign`
    module. It builds upon MethodHandles and VarHandles, which we met in chapter 17.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: API位于`jdk.incubator.foreign`包中的`jdk.incubator.foreign`模块中。它建立在我们在第17章中遇到的MethodHandles和VarHandles之上。
- en: Note The Foreign API is contained in an incubator module in Java 17\. We discussed
    incubator modules and their significance way back in chapter 1\. To get the code
    examples in this section to run, you will need to explicitly add the incubator
    module to your modulepath.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：外部API包含在Java 17的孵化模块中。我们早在第1章就讨论了孵化模块及其重要性。要使本节中的代码示例运行，您需要明确将孵化模块添加到您的模块路径中。
- en: The first piece of the API relies on classes like `MemorySegment`, `MemoryAddress`,
    and `SegmentAllocator`. This provides access to allocation and handling of off-heap
    memory. The aim is to provide a better alternative to the use of both the ByteBuffer
    API and `Unsafe`. The Foreign API intends to avoid the limitations of `ByteBuffer`,
    such as performance, being limited to segments 2 GB in size and being not specifically
    designed for off-heap use. At the same time, it should be, well, safer than the
    use of `Unsafe`, which allows basically unrestricted memory access, making it
    very easy for bugs to crash the JVM.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: API 的第一部分依赖于 `MemorySegment`、`MemoryAddress` 和 `SegmentAllocator` 等类。这提供了对堆外内存的分配和处理访问。目标是提供一个更好的替代方案，以替代
    ByteBuffer API 和 `Unsafe` 的使用。Foreign API 旨在避免 `ByteBuffer` 的限制，例如性能受限，只能处理 2
    GB 大小的段，并且不是专门为堆外使用而设计的。同时，它应该比使用 `Unsafe` 更安全，`Unsafe` 允许基本上无限制的内存访问，这使得 JVM
    出现故障崩溃变得非常容易。
- en: Note For the rest of this section, we assume that you are familiar with C language
    concepts, as well as building C/C++ programs from source and understand the phases
    of C compilation, linking, and so on.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在本节的剩余部分，我们假设你已经熟悉 C 语言概念，以及从源代码构建 C/C++ 程序，并了解 C 编译、链接等阶段。
- en: Let’s see it in action. To get started, you will need to download an early-access
    build of Panama from [https://jdk.java.net/panama/](https://jdk.java.net/panama/).
    Although the incubator modules are present in JDK 17, the important `jextract`
    tool is not, and we’ll need it for our example.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它的实际效果。要开始，你需要从 [https://jdk.java.net/panama/](https://jdk.java.net/panama/)
    下载 Panama 的早期访问构建版本。尽管孵化器模块存在于 JDK 17 中，但重要的 `jextract` 工具并不包含在内，我们需要它来演示我们的例子。
- en: 'Once you have a Panama early-access install set up, test it with `jextract
    -h`. You should see output like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你设置了 Panama 的早期访问安装，可以使用 `jextract -h` 来测试它。你应该会看到如下输出：
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For our example, we’re going to use a simple PNG library that’s written in
    C: LibSPNG ([https://libspng.org/](https://libspng.org/)).'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，我们将使用一个用 C 语言编写的简单 PNG 库：LibSPNG ([https://libspng.org/](https://libspng.org/))。
- en: 'Example: LibSPNG'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：LibSPNG
- en: 'We’re going to start by using the `jextract` tool to get a set of base Java
    packages that we can use. The syntax looks like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先使用 `jextract` 工具获取一组基础 Java 包，我们可以使用这些包。语法看起来像这样：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'On a Mac, this ends up being something like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mac 上，这最终会变成如下所示：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This may give some warnings, depending on exactly the version of the header
    file we’re generating from, but providing it succeeds, it will create a directory
    structure in the current directory. This will contain a lot of Java classes in
    a package called `org.libspng`, which we’ll be able to use from within our Java
    program later.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会根据我们生成的头文件的版本产生一些警告，但只要成功，它将在当前目录中创建一个目录结构。这将包含一个名为 `org.libspng` 的包中的许多
    Java 类，我们可以在稍后的 Java 程序中使用它们。
- en: We also need to build a shared object to link against when we run our program.
    This is best accomplished following the project’s build instructions at [http://mng.bz/v6dJ](http://mng.bz/v6dJ).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要构建一个共享对象，以便在运行我们的程序时进行链接。这最好是通过遵循项目构建说明来完成，请参阅 [http://mng.bz/v6dJ](http://mng.bz/v6dJ)。
- en: The installation generates `libspng.dylib` locally within the project and installs
    it to a system-shared location. When running the project, you’ll want to ensure
    that the file is somewhere in the paths listed by the system property `java.library.path`,
    or directly set that property to include your location. An example default directory
    on a Mac is `~/Library/Java/Extensions/`. With the code generation completed and
    the library installed, we can get on with some Java programming.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 安装会在项目内部生成 `libspng.dylib`，并将其安装到系统共享位置。在运行项目时，你需要确保该文件位于系统属性 `java.library.path`
    列出的路径之一，或者直接设置该属性以包含你的位置。在 Mac 上，一个示例默认目录是 `~/Library/Java/Extensions/`。代码生成完成并且库安装后，我们可以继续进行一些
    Java 编程。
- en: The aim of Panama is to provide Java static methods that match the names (and
    Java versions of the parameter types) of the symbols in the C library that we
    want to link against. So, the symbols in the generated Java code will follow C
    naming conventions and won’t look much like Java names.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Panama 的目标是提供与我们要链接的 C 库中符号的名称（以及参数类型的 Java 版本）相匹配的 Java 静态方法。因此，生成的 Java 代码中的符号将遵循
    C 命名约定，并且看起来不太像 Java 名称。
- en: For the Java programmer, the overall impression is that we’re calling the C
    functions directly (as far as possible). In reality, there’s a certain amount
    of Panama magic that is happening under the hood, using techniques like method
    handles to hide the complexity. Under normal circumstances, most developers need
    not worry about the details of exactly how Panama works.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Java程序员来说，整体印象是我们直接调用C函数（尽可能直接）。实际上，底层发生了一些巴拿马魔法，使用方法句柄等技术来隐藏复杂性。在正常情况下，大多数开发者不需要担心巴拿马的确切工作细节。
- en: 'Let’s take a look at an example: a program that uses a C library to read some
    basic data from a PNG file. We’ll set up this code as a proper modular build.
    The module descriptor, `module-info.java`, looks like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子：一个使用C库从PNG文件读取一些基本数据的程序。我们将把这个代码设置为一个合适的模块化构建。模块描述符`module-info.java`看起来像这样：
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The code comprises the packages `org.libspng`, which we autogenerated from
    the C code, and the single exported package, `wgjd.png`. It contains a single
    file, which we’re showing in full as the imports and so on are important to understand
    what’s happening:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 代码包括`org.libspng`包，这是我们自动从C代码生成的，以及单个导出包`wgjd.png`。它包含一个文件，我们将完整展示，因为导入等对于理解正在发生的事情很重要：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Panama classes for working with C-style memory management
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用C风格内存管理的巴拿马课程
- en: ❷ The Java wrapper for a C function in spng.h
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ spng.h中C函数的Java包装器
- en: ❸ The Java wrapper for a C constant
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ C常量的Java包装器
- en: ❹ Reads data in 64 M chunks
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 以64 M块读取数据
- en: ❺ Copies contents of the Java string into a C string
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将Java字符串的内容复制到C字符串中
- en: ❻ The Java wrapper for a C standard library function
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ C标准库函数的Java包装器
- en: ❼ The Java wrapper for a C constant
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ C常量的Java包装器
- en: 'This is built with a Gradle build script, shown here:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过一个Gradle构建脚本构建的，如下所示：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And can be executed like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 可以像这样执行：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This should produce some output providing basic metadata about our image file.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会输出一些基本元数据，关于我们的图像文件。
- en: Handling native memory in Panama
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在巴拿马中处理原生内存
- en: One key aspect of handling memory is the question of the lifetime of native
    memory. C does not have a garbage collector, so all memory must be manually allocated
    and de-allocated. This is, of course, extremely error prone as well as being not
    at all natural for a Java programmer.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 处理内存的一个关键方面是原生内存的生命周期问题。C没有垃圾回收器，所以所有内存都必须手动分配和释放。这当然是极其容易出错的，并且对于Java程序员来说一点也不自然。
- en: 'To work around this problem, Panama provides several classes that are used
    as Java handles for C memory management operations. The key is the `ResourceScope`
    class, which can be used to provide deterministic cleanup. This is handled in
    the usual Java way, via `try`-with-resources. For example, the previous code used
    a lexically scoped lifetime for the native memory handling:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，巴拿马提供了几个类，这些类用作C内存管理操作的Java句柄。关键是`ResourceScope`类，它可以用来提供确定性清理。这通常通过Java的`try`-with-resources方式处理。例如，前面的代码使用了本地内存处理的词法作用域生命周期：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `allocator` object is an instance of an implementation of the `SegmentAllocator`
    interface. It is created from the scope via a factory method, and in turn we can
    create `MemorySegment` objects from the allocator.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`allocator`对象是`SegmentAllocator`接口实现的一个实例。它通过工厂方法从作用域创建，然后我们可以从分配器创建`MemorySegment`对象。'
- en: Objects that implement the `MemorySegment` interface represent contiguous blocks
    of memory. Typically, these will be backed by blocks of native memory, but it
    is also possible to back memory segments with on-heap arrays. This is similar
    to the case of `ByteBuffer` in the Java NIO API.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`MemorySegment`接口的对象代表连续的内存块。通常，这些将由原生内存块支持，但也可以使用堆上的数组来支持内存段。这与Java NIO API中的`ByteBuffer`的情况类似。
- en: Note The Panama API also contains `MemoryAddress`, which is effectively a Java
    wrapper over a C pointer (expressed as a `long` value).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：巴拿马API还包含`MemoryAddress`，它实际上是一个C指针的Java包装器（以`long`值表示）。
- en: When the scope is autoclosed, the allocator will be called back to deterministically
    deallocate and release any resources that it had been holding. This is how the
    *Resource Acquisition Is Initialization* (or RAII) pattern, which is implemented
    in Java using `try`-with-resources, is carried into native code. The scope and
    allocator objects hold references to native resources and automatically free them
    when the TWR block exits.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当作用域自动关闭时，分配器将被回调以确定性地释放和释放它所持有的任何资源。这就是*资源获取即初始化*（或RAII）模式在Java中使用`try`-with-resources实现，并将其带入原生代码的方式。作用域和分配器对象持有原生资源的引用，并在TWR块退出时自动释放它们。
- en: Alternatively, this can be handled implicitly, with the native memory being
    cleaned up when a `MemorySegment` object is garbage-collected. This, of course,
    means that the cleanup happens nondeterministically, whenever the GC runs. In
    general, it is advisable to use explicit scopes, especially if you are not familiar
    with the potential pitfalls of handling off-heap memory.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，这可以通过隐式处理，当`MemorySegment`对象被垃圾回收时，原生内存将被清理。当然，这意味着清理是非确定性的，无论GC何时运行。一般来说，建议使用显式作用域，特别是如果你不熟悉处理堆外内存的潜在陷阱。
- en: At time of writing, `jextract` understands only C header files. This means that,
    at present, to use it from other native languages (e.g., Rust), you have to generate
    a C header first. Ideally, there would be an automatic tool to generate these,
    which would work like the `rust-bindgen` tool but in reverse.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，`jextract`只理解C头文件。这意味着，目前，要从其他原生语言（例如，Rust）中使用它，你必须首先生成一个C头文件。理想情况下，将会有一个自动的工具来生成这些文件，它的工作方式类似于`rust-bindgen`工具，但方向相反。
- en: More broadly, over time, `jextract` may get more support for other languages
    generally. The tool is based on LLVM, which is already language independent, so,
    theoretically, it should be extensible to any language LLVM knows and which can
    handle C function call conventions.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 更广泛地说，随着时间的推移，`jextract`可能会为其他语言提供更多的支持。该工具基于LLVM，它已经是语言无关的，因此，从理论上讲，它应该可以扩展到LLVM所知的任何语言，并且可以处理C函数调用约定。
- en: The Foreign API is about to see its second release as an Incubating feature
    (see way back in chapter 1 for the description of Incubating and Preview features)
    as part of Java 18\. It is hoped that it will become a final, standardized feature
    as part of Java 19 in September 2022.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 外部API即将作为孵化功能发布第二个版本（参见第1章中对孵化功能和预览功能的描述），作为Java 18的一部分。希望它能在2022年9月的Java 19中成为最终的标准功能。
- en: The Vector API is not as advanced, primarily because the API designers have
    decided that they would prefer to wait until the capabilities of Project Valhalla
    (see later in this chapter) are available. This API therefore will not move out
    of Incubating status until Valhalla is available as a standard feature.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 向量API并不像其他API那样先进，主要是因为API设计者决定他们宁愿等待Project Valhalla（见本章后面的内容）的功能可用。因此，这个API将不会在Valhalla作为标准功能可用之前离开孵化状态。
- en: 18.3 Project Loom
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.3 Project Loom
- en: In its own words, OpenJDK’s *Project Loom* is about
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 用它自己的话说，OpenJDK的*Project Loom*是关于
- en: easy-to-use, high-throughput lightweight concurrency and new programming models
    on the Java platform.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java平台上，易于使用、高吞吐量、轻量级并发以及新的编程模型。
- en: —Project Loom, [https://wiki.openjdk.org/display/loom/Main](https://wiki.openjdk.org/display/loom/Main)
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: —Project Loom, [https://wiki.openjdk.org/display/loom/Main](https://wiki.openjdk.org/display/loom/Main)
- en: Why is this new approach to concurrency needed? Let’s consider Java from a more
    historical perspective.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么需要这种新的并发方法？让我们从更历史的角度来考虑Java。
- en: One interesting way of thinking about Java is that it is a late-1990s language
    and platform that made a number of opinionated, strategic bets about the direction
    of evolution of software. Those bets, from the perspective of 2022, have largely
    paid off (whether more by luck or by judgment is a matter for debate, of course).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑Java的一个有趣的方式是，它是一个20世纪90年代末的语言和平台，对软件演化的方向做出了许多有见地的、战略性的赌注。从2022年的角度来看，这些赌注在很大程度上已经得到了回报（当然，是靠运气还是靠判断，这当然是一个值得讨论的问题）。
- en: As an example, consider threading. Java was the first mainstream programming
    platform to bake threads into the core language. Before threads, the state of
    the art was to use multiple processes and various unsatisfactory mechanisms (Unix
    shared memory, anyone?) to communicate between them.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑线程。Java是第一个将线程内置于核心语言的流行编程平台。在引入线程之前，最先进的技术是使用多个进程和各种不令人满意的机制（比如Unix共享内存）来在它们之间进行通信。
- en: At an operating system level, threads are independently scheduled execution
    units that belong to a process. Each thread has an execution instruction counter
    and a call stack, but shares a heap with every other thread in the same process.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作系统级别，线程是独立调度的执行单元，属于一个进程。每个线程都有一个执行指令计数器和调用栈，但与同一进程中的每个其他线程共享堆。
- en: Not only that, but the Java heap is just a single contiguous subset of the process
    heap (at least in the HotSpot implementation—other JVMs may differ), so the memory
    model of threads at an OS level carries over naturally to the Java language domain.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅如此，Java堆只是进程堆的单个连续子集（至少在HotSpot实现中是这样——其他JVM可能不同），因此线程在操作系统级别的内存模型自然地延续到Java语言领域。
- en: The concept of threads naturally leads to a notion of a lightweight context
    switch. It is cheaper to switch between two threads in the same process than otherwise.
    This is primarily because the mapping tables that convert from virtual memory
    addresses to physical ones are mostly the same for threads in the same process.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 线程的概念自然地导致了一个轻量级上下文切换的概念。在同一进程中切换两个线程比其他方式更便宜。这主要是因为将虚拟内存地址转换为物理地址的映射表对于同一进程中的线程来说大部分是相同的。
- en: Note Creating a thread is also cheaper than creating a process. The exact extent
    to which this is true depends on the details of the operating system in question.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：创建线程也比创建进程便宜。这种说法的确切程度取决于所讨论的操作系统细节。
- en: In our case, the Java specification does not mandate any particular mapping
    between Java threads and operating system (OS) threads (assuming that the host
    OS even has a suitable thread concept, which has not always been the case). In
    fact, in very early Java versions, the JVM threads were multiplexed onto OS (aka
    *platform*) threads in what were referred to as *green threads* or *M:1 threads*
    (because the implementation actually used only a single platform thread).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，Java规范并没有强制要求Java线程和操作系统（OS）线程之间有任何特定的映射（假设宿主操作系统甚至有一个合适的线程概念，这并不总是如此）。事实上，在非常早期的Java版本中，JVM线程被多路复用到OS（也称为*平台*）线程上，这被称为*绿色线程*或*M:1线程*（因为实现实际上只使用了单个平台线程）。
- en: However, this practice died away around the Java 1.2/1.3 era (and slightly earlier
    on the Sun Solaris OS), and modern Java versions running on mainstream operating
    systems instead implement the rule that one Java thread == exactly one operating
    system thread. Calling `Thread.start()` calls the thread creation system call
    (e.g., `clone()` on Linux) and actually creates a new OS thread.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种做法在Java 1.2/1.3时代（以及在Sun Solaris OS上稍微早一些）就消失了，而主流操作系统上运行的现代Java版本则实现了规则：一个Java线程
    = 精确的一个操作系统线程。调用`Thread.start()`会调用线程创建系统调用（例如，Linux上的`clone()`）并实际上创建一个新的OS线程。
- en: OpenJDK’s Project Loom’s primary goal is to enable new `Thread` objects that
    can execute code but do not correspond to dedicated OS threads, or, to put it
    another way, to create an execution model where an object that represents an execution
    context is not necessarily a thing that needs to be scheduled by the operating
    system.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: OpenJDK的Project Loom的主要目标是启用新的`Thread`对象，这些对象可以执行代码，但并不对应于专用的OS线程，或者换句话说，创建一个执行模型，其中表示执行上下文的对象不一定是需要由操作系统调度的事物。
- en: So in some respects, Loom is a return to something similar to green threads.
    However, the world has changed a lot in the intervening years, and sometimes in
    computing, there are ideas that are ahead of their time.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在某种程度上，Loom是回归到类似于绿色线程的东西。然而，在这段时间里，世界发生了很大的变化，有时在计算中，有些想法是超越时代的。
- en: For example, one could regard Enterprise Java Beans (EJBs) as a form of virtualized/
    restricted environment that overambitiously tried to virtualize the environment
    away. Can they perhaps be thought of as a prototypical form of the ideas that
    would later find favor in modern PaaS systems—and to a lesser extent in Docker/K8s?
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，可以将企业JavaBeans（EJBs）视为一种虚拟化/受限的环境，它试图过度虚拟化环境。它们是否可以被视为后来在现代PaaS系统中（以及在一定程度上在Docker/K8s中）受到青睐的想法的原型形式？
- en: 'So, if Loom is a (partial) return to the idea of green threads, then one way
    of approaching it might be via the query: “what has changed in the environment
    that makes it interesting to return to an old idea that was not found to be useful
    in the past?”'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果Loom是（部分）回归到绿色线程的想法，那么一种接近它的方法可能是通过询问：“环境中的哪些变化使得回归到过去被认为没有用处的旧想法变得有趣？”
- en: 'To explore this question a little, let’s look at an example. Specifically,
    let’s try to crash the JVM by creating too many threads. You should not run the
    code in this example unless you are prepared for a possible crash:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了稍微探讨这个问题，让我们看看一个例子。具体来说，让我们尝试通过创建过多的线程来崩溃JVM。除非你准备好可能发生的崩溃，否则你不应该运行这个例子中的代码：
- en: '[PRE10]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The code starts up 20,000 threads and does a minimal amount of processing in
    each one—or tries to. In practice, it will often die or lock up the machine long
    before that steady state is reached.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 代码启动了20,000个线程，并在每个线程中执行最小量的处理——或者试图这样做。在实践中，它通常会在达到稳定状态之前就死亡或锁定机器。
- en: Note It is possible to get the example to run through to completion if the machine
    or OS are throttled and can’t create threads fast enough to induce the resource
    starvation.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果机器或操作系统被限制并且不能快速创建线程以引起资源饥饿，则可以将示例运行到完成。
- en: Although it is obviously not completely representative, this example is intended
    to signpost what will happen to, for example, a web serving environment with one
    thread per connection. It is entirely reasonable for a modern high-performance
    web server to be expected to handle 20,000 concurrent connections, and yet this
    example clearly demonstrates the failure of a thread-per-connection architecture
    for that case.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这显然并不完全具有代表性，但这个例子旨在表明，例如，对于每个连接一个线程的Web服务环境会发生什么。一个现代高性能Web服务器能够处理20,000个并发连接是完全合理的，而这个例子清楚地表明，对于这种情况，按连接分配线程的架构失败了。
- en: Note Another way to think about Loom is that a modern Java program may need
    to keep track of many more executable contexts than it can create threads for.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：另一种思考Loom的方式是，现代Java程序可能需要跟踪比它可以创建的线程更多的可执行上下文。
- en: An alternative takeaway could be that threads are potentially much more expensive
    than we think and represent a scaling bottleneck for modern JVM applications.
    Developers have been trying to solve this problem for years, either by taming
    the cost of threads or by using a representation of execution contexts that aren’t
    threads.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可能的启示可能是，线程可能比我们想象的要昂贵得多，并且代表了现代JVM应用程序的扩展瓶颈。开发者已经尝试了多年解决这个问题，要么通过降低线程的成本，要么通过使用不是线程的执行上下文的表示。
- en: One way of trying to achieve this was the SEDA approach (Staged Event Driven
    Architecture)—roughly speaking, a system in which a domain object is moved from
    A to Z along a multistage pipeline with various different transformations happening
    along the way. This can be implemented in a distributed system using a messaging
    system or in a single process, using blocking queues and a thread pool for each
    stage.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一目标的一种方法是通过SEDA方法（阶段事件驱动架构）——大致来说，这是一个将域对象从一个阶段移动到另一个阶段，并在途中发生各种不同转换的多阶段管道系统。这可以通过使用消息系统在分布式系统中实现，或者在一个进程中实现，使用阻塞队列和每个阶段的线程池。
- en: At each step, the processing of the domain object is described by a Java object
    that contains code to implement the step transformation. For this to work correctly,
    the code must be guaranteed to terminate—no infinite loops—and this cannot be
    enforced by the framework.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个步骤中，域对象的处理由一个包含实现步骤转换的代码的Java对象描述。为了正确工作，代码必须保证能够终止——没有无限循环——而这不能由框架强制执行。
- en: This approach has some notable shortcomings—not least the discipline required
    by programmers to use the architecture effectively. Let’s take a look at a better
    alternative.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有一些明显的缺点——首先是程序员为了有效地使用架构所必需的纪律。让我们看看一个更好的替代方案。
- en: 18.3.1 Virtual threads
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.3.1 虚拟线程
- en: 'Project Loom aims to deliver a better experience for today’s high-scale applications
    by adding the following new constructs to the JVM:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Project Loom旨在通过向JVM添加以下新结构来为今天的超大规模应用程序提供更好的体验：
- en: Virtual threads
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟线程
- en: Delimited continuations
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分界性延续
- en: Tail-call elimination
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尾调用消除
- en: The key aspect of this is *virtual threads*. These are designed to look to the
    programmer like “just threads.” However, they are managed by the Java runtime
    and are *not* thin, one-to-one wrappers over OS threads. Instead, they are implemented
    in user space by the Java runtime. The major advantages that virtual threads are
    intended to bring include
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个关键方面是*虚拟线程*。它们被设计成对程序员来说看起来就像“只是线程”。然而，它们是由Java运行时管理的，并且*不是*轻量级的、一对一的操作系统线程的包装器。相反，它们是由Java运行时在用户空间中实现的。虚拟线程旨在带来的主要优势包括
- en: Creating and blocking them is cheap.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和阻塞它们是廉价的。
- en: Standard Java execution schedulers (threadpools) can be used.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用标准的 Java 执行调度器（线程池）。
- en: No OS-level data structures are needed for the stack.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于栈不需要 OS 级别的数据结构。
- en: The removal of the involvement of the operating system in the lifecycle of a
    virtual thread is what removes the scalability bottleneck. Our JVM applications
    can cope with having millions or even billions of objects—so why are we restricted
    to just a few thousand OS-schedulable objects (which is one way to think about
    what a thread is)? Shattering this limitation and unlocking new concurrent programming
    styles is the main aim of Project Loom.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 移除操作系统在虚拟线程生命周期中的参与是消除可扩展性瓶颈的原因。我们的 JVM 应用程序可以处理数百万甚至数十亿个对象——那么为什么我们只限于几千个可由操作系统调度的对象（这是思考线程的一种方式）呢？打破这一限制并解锁新的并发编程风格是
    Project Loom 的主要目标。
- en: 'Let’s see virtual threads in action. Download a Loom beta ([https://jdk.java.net/loom/](https://jdk.java.net/loom/)),
    and spin up `jshell` (with Preview mode enabled to activate the Loom features)
    like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看虚拟线程的实际应用。下载 Loom 测试版([https://jdk.java.net/loom/](https://jdk.java.net/loom/))，并像这样启动
    `jshell`（启用预览模式以激活 Loom 功能）：
- en: '[PRE11]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We can straightaway see the virtual thread construct in the output. We are also
    using a new static method `startVirtualThread()` to start the lambda in a new
    execution context, which is a virtual thread. Simple!
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接在输出中看到虚拟线程结构。我们还在使用一个新的静态方法 `startVirtualThread()` 来在一个新的执行上下文中启动 lambda，这是一个虚拟线程。简单！
- en: The general rule has to be that existing codebases must continue to run in exactly
    the way that they did until the advent of Loom. Or, to put it another way, using
    virtual threads must be opt-in. We must make the conservative assumption that
    all existing Java code genuinely needs the lightweight wrapper over OS threads
    that has been, until now, the only game in town.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通用规则必须是，现有的代码库必须继续以它们在 Loom 之前的方式运行。或者，换句话说，使用虚拟线程必须是可选的。我们必须做出保守的假设，即所有现有的
    Java 代码真正需要的是，直到现在，城镇中唯一的游戏——在操作系统线程之上的轻量级包装器。
- en: 'The arrival of virtual threads opens up new horizons in other ways. Until now,
    the Java language has offered the following two primary ways of creating new threads:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟线程的出现以其他方式开辟了新的天地。到目前为止，Java 语言提供了以下两种创建新线程的主要方式：
- en: Subclass `java.lang.Thread`, and call the inherited `start()` method.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承 `java.lang.Thread` 并调用继承的 `start()` 方法。
- en: Create an instance of `Runnable`, and pass it to a `Thread` constructor, then
    start the resulting object.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 `Runnable` 实例，并将其传递给 `Thread` 构造函数，然后启动生成的对象。
- en: If the notion of what a thread *is* will be changing, then it makes sense to
    re-examine the methods we use to create threads as well. We have already met the
    new static factory method for *fire-and-forget* virtual threads, but the existing
    thread API needs to be improved in a few other ways as well.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果线程是什么的概念将会改变，那么重新审视我们用来创建线程的方法也是有意义的。我们已经遇到了为 *fire-and-forget* 虚拟线程提供的新静态工厂方法，但现有的线程
    API 还需要在其他几个方面进行改进。
- en: 18.3.2 Thread builders
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.3.2 线程构建器
- en: 'One important new notion is the `Thread.Builder` class, which has been added
    as an inner class of `Thread`. Two new factory methods have been added to `Thread`
    to give access to builders for platform and virtual threads, shown here:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的新概念是 `Thread.Builder` 类，它被添加为 `Thread` 的内部类。`Thread` 中添加了两个新的工厂方法，以提供对平台和虚拟线程构建器的访问，如下所示：
- en: '[PRE12]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let’s see the builder in action by replacing the `makeThread()` method in our
    example with this code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过替换我们示例中的 `makeThread()` 方法来查看构建器的实际应用：
- en: '[PRE13]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This calls the `ofVirtual()` method to explicitly create a virtual thread that
    will execute our `Runnable`. We could, of course, have used the `ofPlatform()`
    factory method instead, and we would have ended up with a traditional, OS-schedulable
    thread object. But where’s the fun in that?
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这调用 `ofVirtual()` 方法来显式创建一个将执行我们的 `Runnable` 的虚拟线程。当然，我们也可以使用 `ofPlatform()`
    工厂方法，我们最终会得到一个传统的、可由操作系统调度的线程对象。但那样有什么乐趣呢？
- en: If we substitute the virtual version of `makeThread()` and recompile our example
    with a version of Java that supports Loom, then we can execute the resulting code.
    This time, the program runs to completion without an issue. This is a good example
    of the Loom philosophy in action—localizing the change applications need to make
    to just the code locations that create threads.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用虚拟版本的 `makeThread()` 替换，并使用支持 Loom 的 Java 版本重新编译我们的示例，那么我们可以执行生成的代码。这次，程序运行完成且没有问题。这是一个
    Loom 哲学在行动中的好例子——将应用程序需要更改的代码位置局部化。
- en: One way in which the new thread library encourages developers to move on from
    older paradigms is that subclasses of `Thread` cannot be virtual. Therefore, code
    that subclasses `Thread` will continue to be created using traditional OS threads.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 新的线程库鼓励开发者从旧范式迁移的一种方式是，`Thread` 的子类不能是虚拟的。因此，子类化 `Thread` 的代码将继续使用传统的操作系统线程来创建。
- en: Note Over time, as virtual threads become more common and developers stop caring
    about the difference between virtual and OS threads, this should discourage the
    use of the subclassing mechanism because it will always create an OS-schedulable
    thread.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：随着时间的推移，随着虚拟线程变得更加普遍，开发者不再关心虚拟和操作系统线程之间的区别，这应该会阻止使用子类化机制，因为它总是会创建一个可由操作系统调度的线程。
- en: The intention is to protect existing code that uses subclasses of `Thread` and
    follow the principle of least surprise.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 目的是保护使用 `Thread` 子类的现有代码，并遵循最小惊讶原则。
- en: 'Various other parts of the thread library also need to be upgraded to better
    support Loom. For example `ThreadBuilder` can also build `ThreadFactory` instances
    that can be passed to various `Executors` like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 线程库的其他部分也需要升级，以更好地支持 Loom。例如，`ThreadBuilder` 也可以构建可以传递给各种 `Executors`（如这样）的
    `ThreadFactory` 实例：
- en: '[PRE14]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Virtual threads will need to be attached to an actual OS thread to execute.
    These OS threads upon which a virtual thread executes are called *carrier threads*.
    We have already seen carrier threads in some `jshell` output in one of our earlier
    examples. However, over its lifetime, a single virtual thread may run on several
    different carrier threads. This is somewhat reminiscent of the way that regular
    threads will execute on different physical CPU cores over time—both are examples
    of execution scheduling.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟线程需要附加到实际的操作系统线程才能执行。这些执行虚拟线程的操作系统线程被称为 *载体线程*。我们已经在之前的一些示例中看到过载体线程。然而，在其生命周期内，单个虚拟线程可能运行在几个不同的载体线程上。这有点类似于常规线程随着时间的推移在不同的物理
    CPU 核心上执行的方式——两者都是执行调度的例子。
- en: 18.3.3 Programming with virtual threads
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.3.3 使用虚拟线程进行编程
- en: The arrival of virtual threads brings with it a change of mindset. Programmers
    who have written concurrent applications in Java as it exists today are used to
    having to deal (consciously or unconsciously) with the inherent scaling limitations
    of threads.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟线程的出现带来了思维方式的转变。那些用今天存在的 Java 编写并发应用程序的程序员已经习惯了（有意识地或无意识地）处理线程固有的扩展限制。
- en: We are used to creating task objects, often based on `Runnable` or `Callable`
    and handing them off to executors, backed by thread pools, which exist to conserve
    our precious thread resources. What if all of that was suddenly different?
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们习惯于创建任务对象，通常基于 `Runnable` 或 `Callable`，并将它们传递给由线程池支持的执行器，以保存我们宝贵的线程资源。如果所有这些都突然变得不同会怎样？
- en: In essence, Project Loom tries to solve the scaling limitation of threads by
    introducing a new concept of a thread that is cheaper than existing notions and
    that doesn’t directly map to an OS thread. However, this new capability still
    looks and behaves like a thread as Java programmers already understand it.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，Project Loom 通过引入一个比现有概念更便宜且不直接映射到操作系统线程的新线程概念，试图解决线程的扩展限制。然而，这种新功能仍然看起来和表现像一个线程，就像
    Java 程序员已经理解的那样。
- en: Rather than requiring developers to learn a completely new programming style
    (such as continuation-passing style or the Promise/Future approach or callbacks),
    the Loom runtime keeps the same programming model we know from today’s threads
    for virtual threads; virtual threads are threads, at least as far as the programmer
    is concerned.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 与要求开发者学习全新的编程风格（如延续传递风格或 Promise/Future 方法或回调）相比，Loom 运行时保留了我们从今天线程中熟悉的相同编程模型，用于虚拟线程；对于程序员来说，虚拟线程就是线程。
- en: Virtual threads are *preemptive* because user code does not need to explicitly
    yield. Scheduling points are up to the virtual scheduler and the JDK. Users must
    make no assumptions on when they happen, because this is purely an implementation
    detail. However, it is worth understanding the basics of operating system theory
    that underlies scheduling to appreciate how virtual threads differ.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟线程是**抢占式**的，因为用户代码不需要显式地释放。调度点由虚拟调度器和JDK决定。用户无需假设它们何时发生，因为这完全是实现细节。然而，了解支撑调度的操作系统理论基础，有助于理解虚拟线程的不同之处。
- en: When the operating system schedules platform threads, it allocates a *timeslice*
    of CPU time to a thread. When the timeslice is up, a hardware interrupt is generated,
    and the kernel is able to resume control, remove the executing platform (user)
    thread, and replace it with another.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当操作系统调度平台线程时，它会为线程分配一个**时间片**的CPU时间。当时间片结束时，会生成一个硬件中断，内核能够恢复控制，移除正在执行的平台（用户）线程，并用另一个线程替换它。
- en: Note This mechanism is how Unix (and assorted other operating systems) has been
    able to implement time-sharing of the processor among different tasks—even decades
    ago in the era when computers had only one processing core.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：这种机制是Unix（以及其他操作系统）能够在不同任务之间实现处理器时间共享的原因——甚至在计算机只有一个处理核心的几十年前就已经如此。
- en: Virtual threads, however, are handled differently from platform threads. None
    of the existing schedulers for virtual threads uses timeslices to preempt virtual
    threads.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟线程与平台线程的处理方式不同。现有的虚拟线程调度器都不使用时间片来抢占虚拟线程。
- en: Note Using timeslices for preemption of virtual threads would be possible, and
    the VM is already capable of taking control of executing Java threads—it does
    so at JVM safepoints, for example.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：使用时间片来抢占虚拟线程是可能的，并且虚拟机已经能够控制执行Java线程——例如，在JVM安全点时。
- en: Instead, virtual threads automatically give up (or *yield*) their carrier thread
    when a blocking call (such as I/O) is made. This is handled by the library and
    runtime and is not under the explicit control of the programmer.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，当进行阻塞调用（如I/O）时，虚拟线程会自动放弃（或**释放**）其承载线程。这由库和运行时处理，并且不在程序员的显式控制之下。
- en: Thus, rather than forcing programmers to explicitly manage yielding, or relying
    upon the complexities of nonblocking or callback-based operations, Loom allows
    Java programmers to write code in traditional, thread-sequential style. This has
    additional benefits such as allowing debuggers and profilers to work in the usual
    way. Toolmakers and runtime engineers need to do a bit of extra work to support
    virtual threads, but that’s better than forcing an additional cognitive burden
    onto end user Java developers. In particular, this approach differs from the `async`/`await`
    approach adopted by some other programming languages.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Loom而不是强迫程序员显式管理释放，或者依赖于非阻塞或基于回调的操作的复杂性，允许Java程序员以传统的、线程顺序的方式编写代码。这带来了额外的优势，例如允许调试器和性能分析器以通常的方式工作。工具制造商和运行时工程师需要做一些额外的工作来支持虚拟线程，但这比强迫最终用户Java开发者承担额外的认知负担要好。特别是，这种方法与其他一些编程语言采用的`async`/`await`方法不同。
- en: The designers of Loom expect that, because virtual threads need never be pooled,
    they *should* never be pooled, and instead the model is the unconstrained creation
    of virtual threads. For this purpose, an *unbounded executor* has been added.
    It can be accessed via a new factory method, `Executors.newVirtualThreadPerTaskExecutor()`.
    The default scheduler for virtual threads is the work-stealing scheduler introduced
    in `ForkJoinPool`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Loom的设计者预期，由于虚拟线程无需池化，因此它们**不应该**池化，而是采用无约束的虚拟线程创建模式。为此，增加了一个**无界执行器**。可以通过新的工厂方法访问它，即`Executors.newVirtualThreadPerTaskExecutor()`。虚拟线程的默认调度器是`ForkJoinPool`中引入的工作窃取调度器。
- en: Note It is interesting how the work-stealing aspect of Fork/Join has become
    far more important than the recursive decomposition of tasks.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Fork/Join的工作窃取方面已经变得比任务的递归分解更为重要。
- en: The design of Loom as it is today is predicated on the developer understanding
    the computational overhead that will be present on the different threads in their
    application. Simply put, if a vast number of threads all need a lot of CPU time
    constantly, your application has a resource crunch that clever scheduling can’t
    help. On the other hand, if only a few threads are expected to become CPU-bound,
    these should be placed into a separate pool and provisioned with platform threads.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Loom的当前设计基于开发者理解他们应用程序中不同线程上存在的计算开销。简单来说，如果大量线程需要持续的大量CPU时间，那么你的应用程序将面临资源紧张，即使是巧妙的调度也无法帮助。另一方面，如果只有少数线程预期会变成CPU绑定，那么这些线程应该被放置在单独的池中，并分配平台线程。
- en: Virtual threads are also intended to work well in the case where there are many
    threads that are CPU-bound only occasionally. The intent is that the work-stealing
    scheduler will smooth out the CPU utilization and real-world code will eventually
    call an operation that passes a yield point (such as blocking I/O).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟线程也旨在在存在许多偶尔仅CPU绑定的线程的情况下表现良好。目标是工作窃取调度器将平滑CPU利用率，并且现实世界的代码最终会调用一个传递yield点的操作（例如阻塞I/O）。
- en: 18.3.4 When will Project Loom arrive?
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.3.4 Project Loom何时到来？
- en: Loom development is taking place in a separate repo, not on the JDK mainline.
    Early-access binaries are available, but these still have some rough edges—crashes
    still occur but are becoming less common. The basic API is taking shape, but it
    is almost certainly not completely finalized yet.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Loom的开发正在进行一个单独的仓库中，而不是在JDK主线中。早期访问的二进制文件是可用的，但这些仍然有一些粗糙的边缘——崩溃仍然发生，但变得越来越不常见。基本API正在成形，但几乎可以肯定还没有完全最终确定。
- en: JEP 425 ([https://openjdk.java.net/jeps/425](https://openjdk.java.net/jeps/425))
    has been filed to integrate virtual threads as a Preview feature, but at the time
    of writing, this JEP has not been targeted to any release yet. It is reasonable
    to suppose that if it is not included as Preview in Java 19, then a final version
    of the feature will not be available as part of Java 21 (which is likely to be
    the next LTS version of Java). There is still a lot of work to be done on the
    APIs that are being built on top of virtual threads, such as structured concurrency
    and other more advanced features.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: JEP 425 ([https://openjdk.java.net/jeps/425](https://openjdk.java.net/jeps/425))
    已被提交以将虚拟线程作为预览功能进行集成，但在撰写本文时，此JEP尚未针对任何版本进行目标定位。有理由假设，如果它不在Java 19中作为预览功能包含，那么该功能的最终版本可能不会作为Java
    21（可能是下一个Java LTS版本）的一部分提供。在虚拟线程之上构建的API还有很多工作要做，例如结构化并发和其他更高级的功能。
- en: One key question that developers always have is about performance, but this
    is always difficult to answer during the early stages of development of a new
    technology. For Loom, we are not yet at the point where meaningful comparisons
    can be made and the current performance is not thought to be really indicative
    of the final version.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者总是有一个关键问题，那就是性能，但在新技术开发的早期阶段，这总是很难回答。对于Loom，我们还没有达到可以进行有意义的比较的阶段，并且当前的性能并不被认为是最终版本的真实反映。
- en: 'As with other long-range projects within OpenJDK, the real answer is that it
    will be ready when it’s ready. For now, there is enough of a prototype to start
    experimenting with it and get a first taste of what future development in Java
    might look like. Let’s turn our attention to the last of the four major OpenJDK
    projects that we’re discussing: Valhalla.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 就像OpenJDK中的其他长期项目一样，真正的答案是它准备好了才会准备好。目前，已经有一个足够的原型可以开始实验它，并尝尝未来Java开发可能的样子。让我们把注意力转向我们正在讨论的四个主要OpenJDK项目中的最后一个：Valhalla。
- en: 18.4 Project Valhalla
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.4 Project Valhalla
- en: To align JVM memory layout behavior with the cost model of modern hardware.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使JVM内存布局行为与现代硬件的成本模型相一致。
- en: —Brian Goetz
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: —Brian Goetz
- en: To understand where the current Java model of memory layout reaches its limits
    and starts to break down, let’s start with an example. In figure 18.1, we can
    see an array of primitive ints. Because these values are primitive types and not
    objects, they are laid out at adjacent memory locations.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解当前Java内存布局模型达到极限并开始崩溃的地方，让我们从一个例子开始。在图18.1中，我们可以看到一个原始整型数组。因为这些值是原始类型而不是对象，所以它们被布局在相邻的内存位置。
- en: '![](../Images/CH18_F01_Evans2.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH18_F01_Evans2.png)'
- en: Figure 18.1 Array of primitive ints
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.1 原始整型数组
- en: To see the difference with object arrays, let’s contrast this with the boxed
    integer case. An array of `Integer` objects will be an array of references, as
    shown in figure 18.2.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到与对象数组的区别，让我们将其与装箱整数的情况进行对比。一个`Integer`对象数组将是一个引用数组，如图18.2所示。
- en: '![](../Images/CH18_F02_Evans2.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH18_F02_Evans2.png)'
- en: Figure 18.2 Array of `Integer` objects
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.2 `Integer`对象数组
- en: Because each `Integer` is an object, it is required to have an object header,
    as we explained in the previous chapter. We sometimes say that each object is
    required to pay the “header tax” that comes with being a Java object.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每个`Integer`都是一个对象，所以它需要有一个对象头，正如我们在上一章中解释的那样。我们有时说每个对象都需要支付作为Java对象带来的“头税”。
- en: 'For over 20 years, this memory layout pattern has been the way that the Java
    platform has functioned. It has the advantage of simplicity but has a performance
    trade-off: dealing with arrays of objects involves unavoidable pointer indirections
    and attendant cache misses.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 超过20年来，这种内存布局模式一直是Java平台运行的方式。它具有简单性的优势，但存在性能权衡：处理对象数组涉及不可避免的指针间接引用和相关的缓存未命中。
- en: 'As an example, consider a class that represents a point in three-dimensional
    space, a `Point3D` type. It really comprises only three spatial coordinates and,
    as of Java 17, can be represented as an object type with three fields (or an equivalent
    record) like this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个表示三维空间中点的类，一个`Point3D`类型。它实际上只包含三个空间坐标，并且从Java 17开始，可以表示为一个具有三个字段（或等效的记录）的对象类型，如下所示：
- en: '[PRE15]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In HotSpot, an array of these point objects is laid out in memory, as shown
    in Figure 18.3.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在HotSpot中，这些点对象的数组在内存中布局，如图18.3所示。
- en: '![](../Images/CH18_F03_Evans2.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH18_F03_Evans2.png)'
- en: Figure 18.3 An array of `Point3D`
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.3 `Point3D`数组
- en: When processing this array, each element is accessed via an additional indirection
    to get the coordinates of each point. This causes a cache miss for each point
    in the array, degrading performance for no good reason.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理这个数组时，每个元素都是通过额外的间接引用来访问的，以获取每个点的坐标。这导致数组中每个点都会发生缓存未命中，没有任何合理的理由而降低性能。
- en: For programmers who care a lot about performance, the ability to define types
    that can be laid out in memory more effectively would be very useful. We should
    also note that object identity has no real benefit for the programmer when working
    with `Point3D` values, because two points should be equal if and only if all their
    fields are equal.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非常关注性能的程序员来说，能够定义在内存中更有效地布局的类型将非常有用。我们还应该注意，当与`Point3D`值一起工作时，对象身份对程序员来说并没有真正的益处，因为两个点只有在所有字段都相等的情况下才应该相等。
- en: 'This example demonstrates the following two separate programming concepts that
    are both enabled by the removal of object identity:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例演示了以下两个独立的编程概念，这两个概念都通过移除对象身份而得以实现：
- en: '*Heap flattening*—The removal of pointer indirection for identity-less objects
    resulting in higher memory density'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*堆扁平化*—对于无身份对象移除指针间接引用，从而提高内存密度'
- en: '*Scalarization*—The ability to break up an identity-less object into fields
    and reconstitute it again elsewhere if needed'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*标量化*—将无身份对象分解为字段并在需要时重新构建的能力'
- en: These separate properties will turn out to have consequences for the user model
    for identity-less objects.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这些独立的属性将对无身份对象的用户模型产生后果。
- en: Note It turns out that scalarization—the ability of the VM to break up and reconstitute
    value objects as much as it likes—is surprisingly useful. The JVM contains a JIT
    technique called *escape analysis* that can greatly benefit from the freedom to
    split a value object into its individual fields and flow them through the code
    separately.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：标量化——JVM分解和重新构建值对象的能力，出人意料地有用。JVM包含一种称为*逃逸分析*的JIT技术，可以从将值对象拆分为其单个字段并将它们分别通过代码的自由中受益。
- en: 'Keeping these properties in mind, we can also approach Valhalla starting from
    the question: “can we avoid paying the header tax?” Broadly, the answer is yes,
    provided the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这些属性，我们也可以从以下问题开始接近Valhalla：“我们能否避免支付头税？”广泛地说，答案是肯定的，前提是以下条件成立：
- en: The objects don’t need a concept of identity.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象不需要身份的概念。
- en: The class is final, so all targets for method calls can be known at class loading
    time.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该类是最终的，因此所有方法调用的目标都可以在类加载时知道。
- en: Basically, the first property removes the need for the mark word of the header,
    and the second greatly reduces the need for the klass word (see chapters 4 and
    17 for more on the klass word).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，第一个属性消除了对头部标记词的需要，第二个大大减少了对于klass词的需求（参见第4章和第17章了解更多关于klass词的内容）。
- en: The klass word is still required while the object is on the heap, unless it
    has been flattened as an instance field in another object or flattened as an element
    of array because the object field layout might need to be described—for example,
    so that the GC can walk the object graph. However, when the objects have been
    scalarized, we can drop the header.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象在堆上时，klass词仍然是必需的，除非它已经被作为另一个对象的实例字段或作为数组元素扁平化，因为对象字段布局可能需要被描述——例如，以便GC可以遍历对象图。然而，当对象被标量化后，我们可以丢弃头部。
- en: From a developer’s perspective, therefore, one of the main outcomes of Valhalla
    is the arrival of a new form of values in the Java ecosystem, referred to as *value
    objects*, which are instances of *value classes*. These new types are understood
    to be (usually) small, immutable, identity-less types.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 从开发者的角度来看，因此，Valhalla的主要成果之一是Java生态系统中出现了一种新的值形式，被称为*值对象*，它们是*值类*的实例。这些新类型被认为是（通常是）小、不可变、无身份的类型。
- en: Note Value classes have been referred to by several different names during their
    development, including *primitive classes* and *inline types*. Naming things is
    hard, especially in a mature language that may well have used many of the common
    names for language concepts.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 音符值类在其发展过程中被赋予了多个不同的名称，包括*原始类*和*内联类型*。给事物命名是困难的，尤其是在一个成熟的语言中，它可能已经使用了许多语言概念的常见名称。
- en: Example use cases for value classes include
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 值类的示例用例包括
- en: New varieties of numerics, such as unsigned bytes, 128-bit integers, and half-precision
    floats
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的数值类型，如无符号字节、128位整数和半精度浮点数
- en: Complex numbers, colors, vectors, and other multidimensional numerical values
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复数、颜色、向量以及其他多维数值
- en: 'Numbers with units: sizes, temperatures, velocity, cashflow, and so on'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带单位的数字：大小、温度、速度、现金流等等
- en: Map entries, database rows, and types for multiple-return
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射条目、数据库行和多返回类型
- en: Immutable cursors, subarrays, intermediate streams, and other data structure
    view abstractions
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变游标、子数组、中间流以及其他数据结构视图抽象
- en: There is also the possibility that some existing types could be retrofitted
    and evolve to become represented as value classes. For example, `Optional` and
    much of `java.time` are obvious candidates that could become value classes in
    a future release if it proves to be feasible.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 还有可能一些现有的类型可以被改造并演变成表示为值类。例如，`Optional`和`java.time`中的许多类型显然是未来版本中可能成为值类的候选者，如果证明这是可行的。
- en: Note Records are not per se related to value classes, but it is highly likely
    that a number of Records will be aggregates that do not require identity, so the
    concept of a *value record* may be a very useful one.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 注意记录本身与值类没有直接关系，但高度可能有许多记录是聚合体，不需要身份，因此*值记录*的概念可能非常有用。
- en: If this new form of value can be implemented on the JVM, then for classes such
    as the spatial points we’ve been discussing, a flattened memory layout such as
    that shown in figure 18.4 would be far more efficient.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这种新的值形式可以在JVM上实现，那么对于像我们所讨论的空间点这样的类，一个如图18.4所示的扁平化内存布局将更加高效。
- en: '![](../Images/CH18_F04_Evans2.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH18_F04_Evans2.png)'
- en: Figure 18.4 Array of inline points
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.4 内联点数组
- en: This memory layout would be something close to what a C programmer would recognize
    as an array of `struct`, but without exposing the full dangers of low-level memory
    access. The flattened layout reduces not only memory footprint but also the load
    on garbage collectors.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这种内存布局将接近C程序员所认识到的`struct`数组，但不会暴露低级内存访问的全部危险。扁平化布局不仅减少了内存占用，还减轻了垃圾收集器的负担。
- en: 18.4.1 Changing the language model
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.4.1 改变语言模型
- en: 'The biggest change that needs to be made is to modify the concept of `java.lang
    .Object` as a universal superclass because it has methods on it such as `wait()`
    and `notify()` that are inherently linked to object identity. Without the object
    header, there is no mark word to store the object’s monitor and nothing to wait
    upon. The object does not really have a well-defined lifetime either because it
    can be freely copied and the resulting copies are indistinguishable. Instead,
    two new interfaces are defined in `java.lang`: `IdentityObject` and `ValueObject`.
    JEP 401 (see [https://openjdk.org/jeps/401](https://openjdk.org/jeps/401)) describes
    value objects in detail, but basically all value classes implicitly implement
    `ValueObject`.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 需要做的最大改变是修改`java.lang.Object`作为通用超类的概念，因为它上面有`wait()`和`notify()`这样的方法，这些方法本质上与对象身份相关联。没有对象头，就没有标记词来存储对象的监视器，也没有可以等待的东西。对象实际上也没有一个明确的生存期，因为它可以被自由复制，并且产生的副本是无法区分的。相反，在`java.lang`中定义了两个新的接口：`IdentityObject`和`ValueObject`。JEP
    401（见[https://openjdk.org/jeps/401](https://openjdk.org/jeps/401)）详细描述了值对象，但基本上所有值类都隐式实现了`ValueObject`。
- en: All identity classes will implicitly implement `IdentityObject`, and all preexisting
    concrete classes are opted-in as identity classes. Existing interfaces and (most)
    abstract classes do not extend either of the new interfaces. API designers may
    wish to update their interfaces to explicitly extend `IdentityObject` if their
    capabilities are not compatible with the new semantics.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 所有身份类都将隐式实现`IdentityObject`，所有现有的具体类都作为身份类选择加入。现有的接口和（大多数）抽象类不扩展这两个新接口。如果API设计者的功能与新语义不兼容，他们可能希望更新他们的接口以显式扩展`IdentityObject`。
- en: Value classes are `final` and may not be `abstract`. They may not implement
    (directly or indirectly) `IdentityObject`. An `instanceof` test can be used to
    check whether or not an object is a value object.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 值类是`final`的，不能是`abstract`的。它们不能实现（直接或间接地）`IdentityObject`。可以使用`instanceof`测试来检查一个对象是否是值对象。
- en: Note As well as not being able to `wait()` or `notify()` on value objects, it
    will not be possible to have synchronized methods or blocks because value objects
    do not have a monitor.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 除了不能在值对象上调用`wait()`或`notify()`之外，也不可能拥有同步方法或块，因为值对象没有监视器。
- en: The class `Object` itself will undergo some subtle repositioning because it
    will not implement either `IdentityObject` or `ValueObject` and will become more
    similar to an abstract class or interface. Code such as this
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 类`Object`本身将经历一些微妙的位置调整，因为它将不实现`IdentityObject`或`ValueObject`，并将更类似于抽象类或接口。如下代码所示
- en: '[PRE16]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: will also change meaning—it is anticipated that `o` will contain an instance
    of some anonymous subclass of `Object`, which for backward-compatibility reasons
    will be understood to be an identity class.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这也将改变意义——预计`o`将包含`Object`的某个匿名子类的实例，出于向后兼容性的原因，它将被理解为身份类。
- en: Although the initial aims of value classes seem clear, it turns out to have
    some far-reaching consequences. For the project to be successful, it is necessary
    to consider the logical conclusions of introducing a third form of value.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然值类的初始目标似乎很明确，但它实际上有一些深远的影响。为了使项目成功，有必要考虑引入第三种值形式的逻辑结论。
- en: 18.4.2 Consequences of value objects
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.4.2 值对象的影响
- en: 'Assignment of value objects has fairly obvious semantics: the bits are copied,
    just as they are for primitives (assignment of references also copies the bits,
    but in that case, we end up with two references to the same heap location). However,
    what happens if we need to construct a value object that is not completely identical
    to the original but is a modified copy?'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 值对象的赋值具有相当明显的语义：位被复制，就像原始类型（引用的赋值也复制位，但那种情况下，我们最终会得到两个指向同一堆位置的引用）。然而，如果我们需要构建一个与原始对象不完全相同但经过修改的副本的值对象会发生什么呢？
- en: 'Recall that value objects are immutable—they have only `final` fields. This
    means that their state cannot be changed by `putfield` operations. Instead, another
    mechanism is needed to produce a value object that has a different state than
    the original. To achieve this, some new bytecodes will be needed, shown next:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，值对象是不可变的——它们只有`final`字段。这意味着它们的州不能通过`putfield`操作来改变。相反，需要另一种机制来生成一个与原始对象状态不同的值对象。为了实现这一点，需要一些新的字节码，如下所示：
- en: '`aconst_init`'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aconst_init`'
- en: '`withfield`'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`withfield`'
- en: The new `withfield` instruction essentially acts as a bytecode-level equivalent
    to the use of wither methods (which we discussed in chapter 15).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`withfield`指令本质上相当于字节码级别的wither方法的使用（我们在第15章中讨论过）。
- en: The other new instruction, `aconst_init`, provides a default value for an instance
    of a value class. Let’s take a closer look at why this is needed.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个新的指令，`aconst_init`，为值类的一个实例提供一个默认值。让我们更深入地了解一下为什么需要这个。
- en: 'In Java to date, both primitives and object references are understood to have
    a default value that corresponds to “all bits zero,” with `null` being understood
    to be the meaning of zero bits for references. However, when we try to extend
    these semantics to handle value objects, we find that there are two related issues:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在Java中，原始类型和对象引用都被理解为具有与“所有位为零”相对应的默认值，而`null`被理解为引用的零位的意义。然而，当我们尝试将这些语义扩展到处理值对象时，我们发现存在两个相关的问题：
- en: Some value classes do not have a good choice for default value.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些值类没有好的默认值选择。
- en: The possibility of *value tearing*.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在着*值撕裂*的可能性。
- en: 'The no-good-default issue really comes down to wanting to be able to say that
    the value object isn’t really a value yet, but Java already has a way to do that:
    `null`. Furthermore, users are already used to dealing with `null` point exceptions
    (NPEs) when they have an uninitialized value.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 没有好的默认值的问题实际上归结于想要能够说值对象实际上还不是值，但Java已经有了一种方法来做这件事：`null`。此外，用户已经习惯了在值未初始化时处理`null`指针异常（NPEs）。
- en: The second problem, tearing, is really an old problem in a new guise. In older
    versions of Java, running on 32-bit hardware had some subtle potential problems
    when handling 64-bit values (such as longs). In particular, writes to longs were
    performed as two separate (32-bit) writes, and it was possible for a reading thread
    to observe a state where only one of the 32-bit writes had completed. This would
    allow the reading thread to observe a “torn” value for the long—one that was neither
    the before nor after state.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题，撕裂，实际上是一个老问题的新形式。在Java的旧版本中，在32位硬件上运行时，处理64位值（如longs）时有一些微妙的问题。特别是，对longs的写入作为两个独立的（32位）写入执行，并且读取线程可能会观察到只完成了一个32位写入的状态。这会使读取线程观察到long的“撕裂”值——既不是之前的状态也不是之后的状态。
- en: Value types have the possibility to reintroduce this issue. If values can be
    scalarized, then how can we guarantee the atomicity of writes?
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型有可能重新引入这个问题。如果值可以被标量化，那么我们如何保证写入的原子性？
- en: The solution is to recognize that value classes represent not one new form of
    data but *two*. If we want to avoid tearing, we need to use a reference. This
    is the well-established idea that using a layer of indirection allows us to update
    values without tearing them.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是认识到值类代表的不只是一种新的数据形式，而是*两种*。如果我们想避免撕裂，我们需要使用引用。这是一个已经确立的想法，即使用间接层允许我们更新值而不撕裂它们。
- en: Also, consider that some classes have no sensible default that could correspond
    to zero bits. For example, what would be the default of `LocalDate` after it has
    migrated to a value class? Some might argue that zero bits should be interpreted
    as zero offset from epoch (i.e., 1st Jan 1970), but this seems deeply error prone.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，考虑一些类可能没有合理的默认值，这些值可以对应于零位。例如，当`LocalDate`迁移到值类后，它的默认值会是什么？有些人可能会争论零位应该被解释为零偏移量（即，1970年1月1日），但这似乎很容易出错。
- en: This bring us to the concept of *identity-free references*—basically, objects
    we have removed identity from. At a low level, this still allows calling convention
    optimizations in the JIT (e.g., scalarized passing of values) and scalarization
    in JIT code but gives up the memory improvements on the heap. These objects are
    always handled by reference, just as identity objects are, and they have a straightforward
    default of `null`. Setting a nontrivial default value for the object is then handled
    by the constructors or factory methods, just as it should be.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了*无身份引用*的概念——基本上，我们移除了对象的身份。在底层，这仍然允许在JIT（例如，值的标量化传递）和JIT代码中进行标量化优化，但放弃了堆上的内存改进。这些对象总是通过引用来处理，就像身份对象一样，并且它们有一个简单的默认值`null`。然后，通过构造函数或工厂方法设置非平凡默认值，正如它应该的那样。
- en: In addition, for advanced use cases, there are also *primitive value types*.
    These act more like the built-in “true primitives” and allow flattening in the
    heap as well as the scalarization allowed with value objects. The additional benefits
    come with associated costs, though—the requirement of accepting zero bits as the
    default value as well as the possibility of tearing under updates that might have
    data races.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，对于高级用例，也存在*原始值类型*。这些类型更像是内置的“真正原始类型”，允许在堆中扁平化以及与值对象一起允许的标量化。然而，额外的利益伴随着相关的成本——需要接受零位作为默认值，以及在可能存在数据竞争的更新中可能会撕裂的可能性。
- en: Note The intent is that primitive value types are really only meant for small
    values (64–128 bits or less on today’s hardware) and will need additional care
    when programming with them.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：原始值类型实际上仅适用于小型值（在今天的硬件上为64-128位或更少），在用它们编程时需要额外的注意。
- en: Tearing does expose users to potential security problems, although it is tempting
    to say it is an issue only for “bad” programs that have data races. It is, in
    any case, a new form of possible concurrency bug and will require locking to properly
    defend against.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 撕裂确实使用户面临潜在的安全问题，尽管人们可能会倾向于认为这是一个只有“坏”程序（存在数据竞争）的问题。无论如何，它是一种新的可能的并发错误形式，需要锁定来正确防御。
- en: One other aspect of primitive value classes is that the runtime needs to know
    how to lay them out in memory. For this reason, it is not possible to create a
    field of a primitive value class that refers to (either directly or indirectly)
    the declaring class. In other words, instances of primitive value classes cannot
    contain a cyclic data structure of primitive value classes—they must have fixed-size
    layouts, so that they can be flattened in the heap. Overall, the expectation is
    that most users will want to use identity-free value objects and that the extended
    primitives will be used much more rarely.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 原始值类的另一个方面是，运行时需要知道如何在内存中布局它们。因此，不可能创建一个引用声明类的原始值类字段（无论是直接还是间接）。换句话说，原始值类的实例不能包含原始值类的循环数据结构——它们必须有固定大小的布局，这样它们才能在堆中扁平化。总的来说，预期是大多数用户将想要使用无身份的值对象，而扩展的原始类型将很少使用。
- en: To conclude this section, let’s look at one other aspect of how value classes
    are represented in bytecode. Recall that way back in chapter 4, we met the concept
    of a type descriptor. Identity reference types are denoted in bytecode via *L-type
    descriptors* such as `Ljava/lang/String;` for a string.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结本节，让我们看看值类在字节码中表示的另一个方面。回想一下，在第四章中，我们遇到了类型描述符的概念。通过*L类型描述符*表示身份引用类型，例如字符串的`Ljava/lang/String;`。
- en: To describe values of primitive classes, a new basic type is being added, the
    *Q-type descriptor*. A descriptor beginning with `Q` has the same structure as
    an L-descriptor (e.g., `QPoint3D;` for a primitive class `Point3D`). Both Q and
    L values are operated on by the same set of bytecodes, that is, those that start
    with `a`, such as `aload` or `astore`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 为了描述原始类的值，正在添加一个新的基本类型，即*Q类型描述符*。以`Q`开头的描述符与L描述符具有相同的结构（例如，对于原始类`Point3D`，`QPoint3D;`）。Q和L值都由同一组字节码操作，即以`a`开头的字节码，例如`aload`或`astore`。
- en: 'The values referred to via Q-descriptors (sometimes called “bare” objects)
    have the following major differences from references to value objects:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Q描述符（有时称为“裸”对象）引用的值与值对象的引用有以下主要区别：
- en: References to value objects, like all object references, can be `null`, whereas
    bare values cannot.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值对象的引用，如所有对象引用一样，可以是`null`，而裸值则不能。
- en: Loads and stores of references are atomic with respect to each other, whereas
    loads and stores of sufficiently large bare values may tear, as is the case for
    long and double on a 32-bit implementation.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用加载和存储是相对于彼此原子的，而足够大的裸值加载和存储可能会撕裂，就像在32位实现中的长和双精度浮点数一样。
- en: 'Object graphs may not be circular if linked via a path of Q-descriptors: a
    class `C` cannot reference `QC;` in its layout, either directly or indirectly.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果通过Q描述符的路径链接，对象图可能不是循环的：类`C`在其布局中不能直接或间接地引用`QC;`。
- en: For technical reasons, the JVM is required to load classes named in Q-descriptors
    much earlier than those named by L-descriptors.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于技术原因，JVM需要比由L描述符命名的类更早地加载Q描述符中命名的类。
- en: These properties are basically the bytecode-level encoding of some of the properties
    of value and primitive objects that we have already met.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性基本上是我们已经遇到的一些值和原始对象属性的字节码级编码。
- en: 'There is one final piece of the puzzle that we should briefly consider before
    moving on from Valhalla: a need to revisit the subject of generic types. This
    arises quite naturally as a consequence of the introduction of value and primitive
    objects.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在从 Valhalla 移动之前，我们应该简要考虑一个最终的问题：需要重新审视泛型类型的问题。这作为引入值和原始对象的自然结果而出现。
- en: 18.4.3 Generics revisited
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.4.3 泛型重访
- en: If Java is to include value classes, the question naturally arises as to whether
    value classes can be used in generic types, for instance, as the value for a type
    parameter. If not, this would seem to greatly limit the usefulness of the feature.
    Therefore, the high-level design has always included the assumption that value
    classes will eventually be valid as values of type parameters in an enhanced form
    of generics.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Java 要包含值类，自然会提出一个问题：值类是否可以在泛型类型中使用，例如，作为类型参数的值。如果不能，这似乎会极大地限制该特性的有用性。因此，高级设计始终包括假设值类最终将以增强泛型形式作为类型参数的值。
- en: Fortunately, the role of `Object` has subtly changed in Valhalla—it has been
    retrospectively altered to be the superclass of both value and identity objects.
    This allows us to include value objects within the realm of existing generics.
    However, the integration of primitive types into this model is also desirable.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在 Valhalla 中 `Object` 的角色发生了微妙的变化——它被追溯性地修改为值对象和身份对象的超类。这使我们能够将值对象纳入现有泛型的范畴。然而，将原始类型整合到这个模型中也是可取的。
- en: The long-term intent is to be able to extend generics—to allow abstraction over
    all types, including value classes and the existing primitives (and `void`). If
    this project is to be successful, we need to be able to compatibly evolve existing
    libraries—especially the JDK libraries—to fully take advantage of these features.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 长期目标是能够扩展泛型——允许对所有类型进行抽象，包括值类和现有的原始类型（以及 `void`）。如果这个项目要成功，我们需要能够兼容地演进现有的库——特别是
    JDK 库——以充分利用这些特性。
- en: Partially, this work would also involve updating the basic value types (`int`,
    `boolean`, etc.) to become primitive value classes, so that basic primitive values
    become primitive objects. This would also mean that the wrapper classes would
    be repurposed to fit into the primitive classes model.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在一定程度上，这项工作还涉及更新基本值类型（`int`、`boolean`等）以成为原始值类，从而使基本原始值成为原始对象。这也意味着包装类将被重新用于适应原始类模型。
- en: This extension to generics will produce a form of *generic specialization* for
    the primitives. This brings in aspects of a generic programming system similar
    to that found in other languages, such as templates in C++. At time of writing,
    the generics work is still at an early stage, and all JEPs pertaining to it are
    still in Draft state.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这种泛型扩展将为原始类型产生一种 *泛型特化* 形式。这引入了类似于在其他语言中找到的泛型编程系统的方面，例如 C++ 中的模板。在撰写本文时，泛型工作仍处于早期阶段，所有与之相关的
    JEPs 都仍处于草案状态。
- en: 18.5 Java 18
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.5 Java 18
- en: 'It is the nature of any text that attempts to be forward-looking that it will
    inevitably be out of date by the time it is read. At the time of writing, Java
    17 has been delivered, and Java 18 was delivered in March 2022\. The following
    JEPs were targeted at Java 18 and formed the content of the new release:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 任何试图具有前瞻性的文本的本质在于，它在被阅读时不可避免地会过时。在撰写本文时，Java 17 已经发布，Java 18 于 2022 年 3 月发布。以下
    JEPs 针对Java 18，并构成了新版本的内容：
- en: JEP 400 UTF-8 by Default
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JEP 400 默认使用 UTF-8
- en: JEP 408 Simple Web Server
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JEP 408 简单 Web 服务器
- en: JEP 413 Code Snippets in Java API Documentation
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JEP 413 Java API 文档中的代码片段
- en: JEP 416 Reimplement Core Reflection with Method Handles
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JEP 416 重新实现核心反射使用方法句柄
- en: JEP 417 Vector API (Third Incubator)
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JEP 417 向量 API（第三孵化器）
- en: JEP 418 Internet-Address Resolution SPI
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JEP 418 互联网地址解析 SPI
- en: JEP 419 Foreign Function and Memory API (Second Incubator)
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JEP 419 外部函数和内存 API（第二次孵化器）
- en: JEP 420 Pattern Matching for `switch` (Second Preview)
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JEP 420 `switch` 的模式匹配（第二次预览）
- en: JEP 421 Deprecate Finalization for Removal
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JEP 421 废弃最终化以进行移除
- en: Of these, the UTF-8 changes, the changes to Core Reflection, and the deprecation
    of finalization are internal changes that provide some tidying up and simplification
    of the internals that can be built on in future releases.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些中，UTF-8 的变化、核心反射（Core Reflection）的变化以及最终化（finalization）的弃用是一些内部变化，它们提供了一些整理和简化，可以在未来的版本中构建。
- en: The Vector and Foreign API updates are the next milestone on the journey toward
    Panama, and the next iteration of Pattern Matching is the next step for Amber.
    Java 18 does not contain any JEPs that deliver any part of Loom or Valhalla. Nothing
    has been confirmed at time of writing, but it is rumored that the first version
    of Loom will be delivered as a Preview feature in Java 19 (expected in September
    2022).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 向量（Vector）和外部（Foreign）API 的更新是通往巴拿马（Panama）之旅的下一个里程碑，而模式匹配（Pattern Matching）的下一版本是琥珀（Amber）的下一步。Java
    18 不包含任何 JEPs，它们提供 Loom 或 Valhalla 的任何部分。在撰写本文时，尚未有任何确认，但据传闻，Loom 的第一个版本将在 Java
    19（预计于 2022 年 9 月发布）中作为预览功能提供。
- en: Summary
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: One of Java’s original design principles was that the language should evolve
    carefully—that a language feature should not be implemented until the wider impact
    on the language as a whole was fully understood. Other languages can, and do,
    move faster than Java, which occasionally leads to complaints from developers
    that “Java needs to evolve faster.” However, the flip side of this is that other
    languages may “advance at speed and repent at leisure.” A flawed design, once
    integrated into the language, is essentially there forever.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: Java 的一个原始设计原则是，语言应该谨慎地进化——一个语言特性应该在完全理解其对整个语言的影响之前不应实现。其他语言可以，并且确实比 Java 进化得更快，这有时会导致开发者抱怨“Java
    需要更快地进化”。然而，这一面的反面是，其他语言可能会“快速前进，然后悠闲地反省”。一旦一个有缺陷的设计被整合到语言中，它基本上就永远存在了。
- en: Java’s approach, on the other hand, is to proceed conservatively—to make sure
    that a feature is understood, including all of its consequences, before committing
    to it. Let other languages break new ground (or, the cynic might say, be first
    “over the top”) and then see what conclusions can be drawn from their experimentation.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，Java 的做法是谨慎行事——在做出承诺之前，确保理解一个特性，包括其所有后果。让其他语言开辟新天地（或者，愤世嫉俗者可能会说，首先“冲在最前面”），然后看看可以从他们的实验中得出什么结论。
- en: In fact, this sort of influence—the back-and-forth borrowing of language concepts—is
    a common feature of language design. It also provides a great example of the idea
    sometimes expressed as “Great artists steal.” This quote is often attributed to
    Steve Jobs, but he did not invent it—he had merely borrowed (or stolen) it from
    other thinkers.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这种影响——语言概念的相互借鉴——是语言设计中的常见特征。它也提供了一个很好的例子，有时这种观点被表达为“伟大的艺术家偷窃”。这句话通常被归功于史蒂夫·乔布斯，但他并非发明者——他只是从其他思想家那里借鉴（或窃取）了它。
- en: 'In actuality, this idea seems to have been invented multiple times, but one
    of the original forms of it that can be definitively traced is this one:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这个想法似乎被发明了多次，但可以明确追踪的一种原始形式是这样的：
- en: One of the surest of tests is the way in which a poet borrows. Immature poets
    imitate; mature poets steal; bad poets deface what they take, and good poets make
    it into something better, or at least something different.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 最可靠的测试之一是诗人借鉴的方式。不成熟的诗人在模仿；成熟的诗人在窃取；糟糕的诗人在他们所取的东西上留下污点；而优秀的诗人在他们所取的东西上创造出更好的东西，或者至少是不同的东西。
- en: —T. S. Eliot
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: ——T. S. 埃利奥特
- en: Eliot’s point applies as readily to language designers as it does to poets.
    Truly great programming languages (and language designers) borrow (or steal) from
    each other freely. Good ideas that are first expressed in one language do not
    remain solely confined there—in fact, that is one of the ways that we know the
    idea was good in the first place.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 埃利奥特的观点同样适用于语言设计者，就像适用于诗人一样。真正伟大的编程语言（以及语言设计者）会自由地相互借鉴（或窃取）。首先在一个语言中表达的好想法并不会仅仅局限于那里——事实上，这正是我们知道这个想法最初就是好的原因之一。
- en: In this final chapter, we have met the four major ongoing projects within OpenJDK.
    Taken together, they aim to deliver a radically different version of future Java.
    Some of these projects are very ambitious, others more modest. They will all be
    delivered as part of the regular cadence of Java releases. The Java we write in
    a year, or three, from now may well look quite unlike what we would write today.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章的结尾，我们遇到了 OpenJDK 中的四个主要正在进行的项目。总的来说，它们的目的是提供未来 Java 的一个根本不同的版本。其中一些项目非常雄心勃勃，而另一些则更为谨慎。它们都将作为
    Java 正常发布节奏的一部分交付。我们一年或三年后编写的 Java 可能看起来与我们今天编写的大相径庭。
- en: The major aspects that we might guess will be reshaped include
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会猜测，以下主要方面将会发生改变：
- en: '*The merger of object and functional programming*—Amber introduces new language
    features that converge these models.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*面向对象和函数式编程的融合*——Amber 引入了新的语言特性，使这些模型趋于一致。'
- en: '*Threading*—Loom will introduce a new model for threads that engage in I/O.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*线程处理*——Loom 将引入一个新的线程模型，用于处理 I/O 操作。'
- en: '*Memory layout*—Valhalla solves several problems at once, improving memory
    density as well as extending generics.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*内存布局*——Valhalla 一次解决多个问题，提高内存密度并扩展泛型。'
- en: '*Better native interoperability*—Panama helps undo some of the design problems
    with JNI and other native technologies.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*更好的本地互操作性*——Panama 有助于解决 JNI 和其他本地技术中的一些设计问题。'
- en: '*Ongoing cleanup of internals*—A series of JEPs to slowly remove aspects of
    the platform that are no longer needed.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*持续清理内部结构*——一系列 JEPs 将逐步移除平台中不再需要的部分。'
- en: The ultimate shape of future Java is still to be determined—the future is unwritten
    as of now. What is sure, however, is that after more than 25 years, Java is still
    a force to be reckoned with. It has already survived several major transitions
    in the world of software—a track record to be proud of, and one that bodes well
    for the future.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 未来 Java 的最终形态尚未确定——到目前为止，未来仍是未写的。然而，可以肯定的是，经过超过 25 年的发展，Java 仍然是一个不容忽视的力量。它已经在软件世界中经历了多次重大转变——这是一份值得骄傲的记录，同时也预示着未来的光明。
