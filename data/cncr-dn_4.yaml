- en: B
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: B
- en: F# overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: F# 概述
- en: This appendix explores the basic syntax of F#, which is an established general-­purpose
    functional first language with object-oriented programming (OOP) support. In fact,
    F# embraces the .NET common language infrastructure (CLI) object model, which
    allows the declaration of interfaces, classes, and abstract classes. Furthermore,
    F# is a statically and strongly typed language, which means that the compiler
    can detect the data type of variables and functions at compile time. F#’s syntax
    is different from C-style languages, such as C#, because curly braces aren’t used
    to delimit blocks of code. Moreover, whitespace rather than commas and indentation
    is important to separate arguments and delimit the scope of a function body. In
    addition, F# is a cross-platform programming language that can run inside and
    outside the .NET ecosystem.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录探讨了 F# 的基本语法，F# 是一种已确立的通用目的函数式第一语言，同时支持面向对象编程（OOP）。实际上，F# 融入了 .NET 公共语言基础设施（CLI）对象模型，这允许声明接口、类和抽象类。此外，F#
    是一种静态和强类型语言，这意味着编译器可以在编译时检测变量和函数的数据类型。F# 的语法与 C 风格语言（如 C#）不同，因为代码块不是用花括号来界定的。此外，空格而不是逗号和缩进对于分隔参数和界定函数体的作用域非常重要。另外，F#
    是一种跨平台编程语言，可以在 .NET 生态系统内外运行。
- en: The let binding
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: let 绑定
- en: In F#, `let` is one of the most important keywords that binds an identifier
    to a value, which means giving a name to value (or, bind a value to a name). It’s
    defined as `let <identifier> = <value>.`
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 中，`let` 是最重要的关键字之一，它将一个标识符绑定到一个值，这意味着给值命名（或，将值绑定到名称）。它定义为 `let <identifier>
    = <value>。`
- en: 'The `let` bindings are immutable by default. Here are a few code examples:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '`let` 绑定默认是不可变的。以下是一些代码示例：'
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see from the last line, you can name a function by binding the identifier
    `myFunction` to the lambda expression `fun number -> number * number`.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从最后一行所见，您可以通过将标识符 `myFunction` 绑定到 lambda 表达式 `fun number -> number * number`
    来命名一个函数。
- en: The `fun` keyword is used to define a lambda expression (anonymous function)
    in the syntax as `fun args -> body`. Interestingly, you don’t need to define types
    in code because, due to its strong built-in type-inference system, the F# compiler
    can understand them natively. For example, in the previous code, the compiler
    inferred that the argument of the `myFunction function` is a number due to the
    multiplication (`*)` operator.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`fun` 关键字用于在语法中定义 lambda 表达式（匿名函数），形式为 `fun args -> body`。有趣的是，你不需要在代码中定义类型，因为由于它强大的内置类型推断系统，F#
    编译器可以原生地理解它们。例如，在上面的代码中，编译器推断出 `myFunction` 函数的参数是一个数字，因为乘法 (`*`) 操作符的存在。'
- en: Understanding function signatures in F#
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 F# 中的函数签名
- en: In F#, as in most of the functional languages, function signatures are defined
    with an arrow notation that reads from left to right. Functions are expressions
    that always have an output, so the last right arrow will always point to the return
    type. For example, when you see `typeA -> typeB`, you can interpret it as a function
    that takes an input value of `typeA` and produces a value of `typeB`. The same
    principle is applicable to functions that take more than two arguments. When the
    signature of a function is `typeA -> typeB -> typeC`, you read the arrows from
    left to right, which creates two functions. The first function is `typeA -> (typeB
    -> typeC)`, which takes an input of `typeA` and produces the function `typeB ->
    typeC`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 中，与大多数函数式语言一样，函数签名使用从左到右读取的箭头符号定义。函数是总是有输出的表达式，所以最右边的箭头总是指向返回类型。例如，当你看到
    `typeA -> typeB` 时，你可以将其解释为一个接受 `typeA` 类型的输入值并产生 `typeB` 类型的值的函数。相同的原理也适用于接受两个以上参数的函数。当函数的签名是
    `typeA -> typeB -> typeC` 时，你从左到右读取箭头，这创建了两个函数。第一个函数是 `typeA -> (typeB -> typeC)`，它接受
    `typeA` 类型的输入并产生 `typeB -> typeC` 类型的函数。
- en: 'Here’s the signature for the `add` function:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `add` 函数的签名：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This takes one argument `x:int` and returns as a result a function that takes
    `y:int` as input and returns an `int` as a result. The arrow notation is intrinsically
    connected to currying and anonymous functions.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这接受一个参数 `x:int` 并返回一个函数，该函数接受 `y:int` 作为输入并返回一个 `int` 类型的结果。箭头符号与柯里化和匿名函数内在相关。
- en: 'Creating mutable types: mutable and ref'
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建可变类型：mutable 和 ref
- en: 'One of the main concepts in FP is immutability. F# is a functional-first programming
    language; but explicitly using the `immutable` keywords lets you create mutable
    types that behave like variables, as in this example:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: FP（函数式编程）中的一个主要概念是不可变性。F#是一种以函数为主的编程语言；但显式使用`immutable`关键字可以让您创建类似变量的可变类型，如下例所示：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now it’s possible to change the value of `myNumber` with the goes-to (`<-``)`
    operator:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以使用goes-to (`<-``)`运算符来更改`myNumber`的值：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Another option when defining a mutable type is to use a *reference cell* that
    defines a storage location that lets you create mutable values with reference
    semantics. The `ref` operator declares a new reference cell that encapsulates
    a value, which can then be changed using the `:=` operator and accessed using
    the `!` (bang) operator:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 定义可变类型的另一种选择是使用定义存储位置的*引用单元格*，该存储位置允许您使用引用语义创建可变值。`ref`运算符声明一个新的引用单元格，它封装了一个值，然后可以使用`:=`运算符更改该值，并使用`!`（感叹号）运算符访问该值：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first line declares the reference cell `myRefVar` with the value 42, and
    the second line changes its value to 53\. In the last line of code, the underlying
    value is accessed and printed.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行声明了具有值42的引用单元格`myRefVar`，第二行将其值更改为53。在代码的最后一行，访问并打印了基础值。
- en: Mutable variables and reference cells can be used in almost the same situations;
    but the mutable types are preferred, unless the compiler doesn’t allow it and
    a reference cell can be used instead. In expressions that generate a closure where
    a mutable state is required, for example, the compiler will report that a mutable
    variable cannot be used. In this case, a reference cell overcomes the problem.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 可变变量和引用单元格可以在几乎相同的情况下使用；但首选可变类型，除非编译器不允许，并且可以使用引用单元格代替。例如，在生成需要可变状态的闭包的表达式中，编译器将报告不能使用可变变量。在这种情况下，引用单元格解决了这个问题。
- en: Functions as first-class types
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数作为一阶类型
- en: 'In F#, functions are first-order data types; they can be declared using the
    `let` keyword and used in exactly the same way as any other variable:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在F#中，函数是一阶数据类型；可以使用`let`关键字声明，并且可以像任何其他变量一样使用：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Functions always return a value, despite not having an explicit `return` keyword.
    The value of the last statement executed in the function is the return value.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 函数总是返回一个值，即使没有显式的`return`关键字。函数中执行的最后一个语句的值是返回值。
- en: 'Composition: pipe and composition operators'
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合：管道和组合运算符
- en: 'The pipe (`|>`) and the composition (`>>`) operators are used to chain functions
    and arguments to improve code readability. These operators let you establish *pipelines*
    of functions in a flexible manner. The definition of these operators is simple:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 管道（`|>`）和组合（`>>`）运算符用于链接函数和参数，以提高代码可读性。这些运算符以灵活的方式让您建立函数的*管道*。这些运算符的定义很简单：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following example shows how to take advantage of these operators to build
    a functional pipeline:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何利用这些运算符构建功能管道：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the last line of code, the composition (`>>`) operator lets you eliminate
    the explicit need for an input parameter definition. The F# compiler understands
    that the function `plusOneIsEven` is expecting an integer as input. The kind of
    function that doesn’t need parameter definitions is called a *point-free function*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的最后一行，组合（`>>`）运算符让您无需显式定义输入参数。F#编译器理解函数`plusOneIsEven`期望一个整数作为输入。不需要参数定义的函数称为*无参数函数*。
- en: The main differences between the pipe (`|>`) and composition (`>>`) operators
    are their signature and use. The pipeline operator takes functions and arguments,
    while composition combines functions.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 管道（`|>`）和组合（`>>`）运算符之间的主要区别在于它们的签名和使用。管道运算符接受函数和参数，而组合将函数组合在一起。
- en: Delegates
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 委托
- en: 'In .NET, a *delegate* is a pointer to a function; it’s a variable that holds
    the reference to a method that shares the same common signature. In F#, function
    values are used in place of delegates; but F# provides support for delegates to
    interop with the .NET APIs. This is the syntax in F# to define a delegate:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET中，*委托*是一个指向函数的指针；它是一个包含对具有相同公共签名的函数引用的变量。在F#中，使用函数值代替委托；但F#提供了与.NET API交互的委托支持。这是F#中定义委托的语法：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following code shows the syntax for creating a delegate with a signature
    that represents an addition operation:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了创建具有表示加法操作的签名的委托的语法：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the example, the F# function `add` is passed directly as arguments to the
    delegate constructor `MyDelegate`. Delegates can be attached to F# function values
    and to static or instance methods. The `Invoke` method on the delegate type `addDelegate`
    calls the underlying function `add`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，F# 函数 `add` 直接作为参数传递给委托构造函数 `MyDelegate`。委托可以附加到 F# 函数值、静态方法或实例方法。委托类型
    `addDelegate` 上的 `Invoke` 方法调用底层函数 `add`。
- en: Comments
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注释
- en: 'Three kinds of comments are used in F#: block comments are placed between the
    symbols `(* and *)`, line comments start with the symbols `//` and continue until
    the end of the line, and XML doc comments come after the symbols /// that let
    you use XML tags to generate code documentation based on the compiler-generated
    file. Here’s how these look:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: F# 中使用了三种注释类型：块注释位于 `(*` 和 `*)` 符号之间，行注释以 `//` 符号开始，并持续到行尾，XML 文档注释跟在 `///`
    符号之后，允许您使用 XML 标签根据编译器生成的文件生成代码文档。以下是这些注释的示例：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Open statements
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打开语句
- en: 'You use the `open` keyword to open a namespace or module, similar to statements
    in C#. This code opens the `System` namespace: `open` `System`.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `open` 关键字打开一个命名空间或模块，类似于 C# 中的语句。此代码打开 `System` 命名空间：`open` `System`。
- en: Basic data types
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本数据类型
- en: '[Table B.1](#tableB.1) shows the list of F# *primitive* *types.*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 B.1](#tableB.1) 展示了 F# 的 *原始* 类型列表。'
- en: '[Table B.1](#tableanchorB.1) Basic data types'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 B.1](#tableanchorB.1) 基本数据类型'
- en: '| **F# type** | **.NET type** | **Size in bytes** | **Range** | **Example**
    |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| **F# 类型** | **.NET 类型** | **字节大小** | **范围** | **示例** |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `sbyte` | `System.SByte` | 1 | -128 to 127 | 42y |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `sbyte` | `System.SByte` | 1 | -128 to 127 | 42y |'
- en: '| `byte` | `System.Byte` | 1 | 0 to 255 | 42uy |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `byte` | `System.Byte` | 1 | 0 to 255 | 42uy |'
- en: '| `int16` | `System.Int16` | 2 | -32,768 to 32,767 | 42s |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `int16` | `System.Int16` | 2 | -32,768 to 32,767 | 42s |'
- en: '| `uint16` | `System.UInt16` | 2 | 0 to 65,535 | 42us |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `uint16` | `System.UInt16` | 2 | 0 to 65,535 | 42us |'
- en: '| `int / int32` | `System.Int32` | 4 | -2,147,483,648 to 2,147,483,647 | 42
    |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `int / int32` | `System.Int32` | 4 | -2,147,483,648 to 2,147,483,647 | 42
    |'
- en: '| `uint32` | `System.UInt32` | 4 | 0 to 4,294,967,295 | 42u |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `uint32` | `System.UInt32` | 4 | 0 to 4,294,967,295 | 42u |'
- en: '| `int64` | `System.Int64` | 8 | -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807
    | 42L |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `int64` | `System.Int64` | 8 | -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807
    | 42L |'
- en: '| `uint64` | `System.UInt64` | 8 | 0 to 18,446,744,073,709,551,615 | 42UL |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `uint64` | `System.UInt64` | 8 | 0 to 18,446,744,073,709,551,615 | 42UL |'
- en: '| `float32` | `System.Single` | 4 | ±1.5e-45 to ±3.4e38 | 42.0F |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `float32` | `System.Single` | 4 | ±1.5e-45 to ±3.4e38 | 42.0F |'
- en: '| `float` | `System.Double` | 8 | ±5.0e-324 to ±1.7e308 | 42.0 |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `float` | `System.Double` | 8 | ±5.0e-324 to ±1.7e308 | 42.0 |'
- en: '| `decimal` | `System.Decimal` | 16 | ±1.0e-28 to ±7.9e28 | 42.0M |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `decimal` | `System.Decimal` | 16 | ±1.0e-28 to ±7.9e28 | 42.0M |'
- en: '| `char` | `System.Char` | 2 | U+0000 to U+ffff | ''x'' |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `char` | `System.Char` | 2 | U+0000 to U+ffff | ''x'' |'
- en: '| `string` | `System.String` | 20 + (2 * size of string) | 0 to about 2 billion
    characters | "Hello World" |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `string` | `System.String` | 20 + (2 * size of string) | 0 to about 2 billion
    characters | "Hello World" |'
- en: '| `bool` | `System.Boolean` | 1 | Only two possible values: true or false |
    true |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `bool` | `System.Boolean` | 1 | 只有两个可能的值：true 或 false | true |'
- en: Special string definition
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊字符串定义
- en: 'In F#, the string type is an alias for the `System.String` type; but in addition
    to the conventional .NET semantic, you have a special triple-quoted way to declare
    strings. This special string definition lets you declare a string without the
    need of escaping special characters as in the verbatim case. The following example
    defines the same string the standard way and the F# triple-quoted way to escape
    special characters:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 中，字符串类型是 `System.String` 类型的别名；但除了传统的 .NET 语义外，您还可以使用特殊的三个引号的方式来声明字符串。这种特殊的字符串定义允许您声明一个字符串，而无需像文本字面量那样转义特殊字符。以下示例以标准方式和
    F# 三个引号方式定义了相同的字符串，以转义特殊字符：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Tuple
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元组
- en: 'A *tuple* is a group of unnamed and ordered values, which can be of different
    types. Tuples are useful for creating ad hoc data structures and are a convenient
    way for a function to return multiple values. A tuple is defined as a comma-separated
    collection of values. Here’s how to construct tuples:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*元组* 是一组无名称且有序的值，可以是不同类型。元组对于创建临时数据结构很有用，并且是函数返回多个值的便捷方式。元组定义为值的逗号分隔集合。以下是构造元组的方法：'
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'A tuple can also be deconstructed. Here the tuple values `1` and `"Hello"`
    are bound, respectively, to the identifiers `a` and `b`, and the function `swap`
    switches the order of two values in a given tuple `(a, b)`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 元组也可以被解构。在这里，元组值 `1` 和 `"Hello"` 分别绑定到标识符 `a` 和 `b`，函数 `swap` 交换给定元组 `(a, b)`
    中两个值的顺序：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Tuples are normally objects, but they can also be defined as value type structs,
    as shown here:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 元组通常是对象，但也可以定义为值类型`结构体`，如下所示：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Note that the F# type inference can automatically generalize the function to
    have a generic type, which means that tuples work with any type. It’s possible
    to access and obtain the first and second elements of the tuple using the `fst`
    and `snd` functions:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，F#类型推断可以自动将函数泛化为一个泛型类型，这意味着元组可以与任何类型一起工作。可以使用`fst`和`snd`函数访问和获取元组的第一个和第二个元素：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Record types
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录类型
- en: A *record type* is similar to a tuple, except the fields are named and defined
    as a semi­colon-separated list. While tuples provide one method of storing potentially
    heterogeneous data in a single container, it can become difficult to interpret
    the purpose of the elements when more than a few exist. In this case, a record
    type helps to interpret the purpose of data by labeling their definition with
    a name. A record type is explicitly defined using the `type` keyword, and it’s
    compiled down to an immutable, public, and sealed .NET class. Furthermore, the
    compiler automatically generates the structural equality and comparison functionality,
    as well as providing a default constructor that populates all the fields contained
    in the record.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*记录类型*类似于元组，除了字段有名称，并定义为分号分隔的列表。虽然元组提供了一种在单个容器中存储可能异构数据的方法，但当存在多个元素时，解释元素的目的可能会变得困难。在这种情况下，记录类型通过使用名称标记其定义来帮助解释数据的目的。记录类型通过使用`type`关键字显式定义，并编译为不可变、公共和密封的
    .NET 类。此外，编译器自动生成结构相等性和比较功能，并提供一个默认构造函数，该构造函数填充记录中包含的所有字段。'
- en: 'This example shows how to define and instantiate a new record type:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例展示了如何定义和实例化一个新的记录类型：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Records can be extended with properties and methods:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 记录可以通过属性和方法进行扩展：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Records are immutable types, which means that instances of records cannot be
    modified. But you can conveniently clone records by using the `with` clone semantic:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 记录是不可变类型，这意味着记录的实例不能被修改。但你可以通过使用`with`克隆语义方便地克隆记录：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'A record type can also be represented as a structure using the `[<Struct>]`
    attribute. This is helpful in situations where performance is critical and overrides
    the flexibility of reference types:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 记录类型也可以使用`[<Struct>]`属性表示。这在性能至关重要的场景中很有帮助，并覆盖了引用类型的灵活性：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Discriminated unions
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 区分联合
- en: '*Discriminated unions* (DUs) are a type that represents a set of values that
    can be one of several well-defined cases, each possibly with different values
    and types. DUs can be thought of in the object-oriented paradigm as a set of classes
    that are inherited from the same base class. In general, DUs are the tool used
    for building complicated data structures, to model domains, and to represent recursive
    structures like a `Tree` data type.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*区分联合*（DUs）是一种类型，它表示一组值，这些值可以是几个定义良好的情况之一，每个情况可能具有不同的值和类型。在面向对象范式中，DUs 可以被视为从同一基类继承的一组类。通常，DUs
    是构建复杂数据结构、建模领域和表示递归结构（如`Tree`数据类型）的工具。'
- en: 'The following code shows the suit and the rank of a playing card:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了扑克牌的花色和点数：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As you can see, DUs can be extended with properties and methods. The list representing
    all the cards in the deck can be computed as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，DUs 可以通过属性和方法进行扩展。表示牌组中所有牌的列表可以按以下方式计算：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Additionally, DUs can also be represented as structures with the `[<Struct>]`
    attribute.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，DUs 也可以通过具有`[<Struct>]`属性的`结构体`来表示。
- en: Pattern matching
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式匹配
- en: '*Pattern* *matching* is a language construct that empowers the compiler to
    interpret the definition of a data type and apply a series of conditions against
    it. In this way, the compiler forces you to write pattern-matching constructs
    by covering all possible cases to match the given value. This is known as *exhaustive*
    pattern matching. Pattern-matching constructs are used for control flow. They’re
    conceptually similar to a series of `if/then` or `case/switch` statements but
    are much more powerful. They let you decompose data structures into their underlying
    components during each match and then perform certain computations on these values.
    In all programming languages, *control flow* refers to the decisions made in code
    that affect the order in which statements are executed in an application.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*模式* *匹配* 是一种语言结构，它使编译器能够解释数据类型的定义并对其应用一系列条件。通过这种方式，编译器强制你编写模式匹配结构，通过覆盖所有可能的案例来匹配给定的值。这被称为
    *穷举* 模式匹配。模式匹配结构用于控制流。它们在概念上类似于一系列 `if/then` 或 `case/switch` 语句，但功能更强大。它们允许你在每次匹配期间将数据结构分解为其底层组件，然后对这些值执行某些计算。在所有编程语言中，*控制流*
    指的是代码中做出的决策，这些决策影响应用程序中语句执行的顺序。'
- en: 'In general, most common patterns involve algebraic data types, such as discriminated
    unions, record types, and collections. The following code example has two implementations
    of the Fizz-Buzz ([https://en.wikipedia.org/wiki/Fizz_buzz](https://en.wikipedia.org/wiki/Fizz_buzz))
    game. The first pattern-matching construct has a set of conditions to test the
    evaluation of the function `divisibleBy.` If either condition is true or false,
    the second implementation uses the `when` clause, called *guard*, to specify and
    integrate additional tests that must succeed to match the pattern:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，最常见的模式涉及代数数据类型，例如区分联合、记录类型和集合。以下代码示例展示了Fizz-Buzz ([https://en.wikipedia.org/wiki/Fizz_buzz](https://en.wikipedia.org/wiki/Fizz_buzz))
    游戏的两个实现。第一个模式匹配结构包含一系列条件来测试函数 `divisibleBy` 的评估。如果任一条件为真或假，第二个实现使用 `when` 子句，称为
    *guard*，来指定和整合必须成功的附加测试以匹配模式：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When a pattern-matching construct is evaluated, the expression is passed into
    the `match <expression>`, which is tested against each pattern until the first
    positive match. Then the corresponding body is evaluated. The _ (underscore) character
    is known as a *wildcard*, which is one way to always have a positive match. Often,
    this pattern is used as final clause for a general catch to apply to a common
    behavior.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当模式匹配结构被评估时，表达式被传递到 `match <expression>`，然后与每个模式进行测试，直到找到第一个匹配。然后评估相应的主体。下划线字符（_）被称为
    *wildcard*，这是始终有正匹配的一种方式。通常，这个模式被用作通用捕获的最终子句，以应用于常见行为。
- en: Active patterns
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活跃模式
- en: '*Active* *patterns* are constructs that extend the capabilities of pattern
    matching, allowing for partition and deconstruction of a given data structure,
    thus guaranteeing the flexibility to transform and extract underlying values by
    making the code more readable and making the results of the decomposition available
    for further pattern matching.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*活跃* *模式* 是扩展模式匹配功能的结构，允许对给定的数据结构进行分区和分解，从而确保通过使代码更易于阅读并使分解的结果可用于进一步的模式匹配来转换和提取底层值。'
- en: Additionally, active patterns let you wrap arbitrary values in a DU data structure
    for easy pattern matching. It’s possible to wrap objects with an active pattern,
    so that you can use those objects in pattern matching as easily as any other union
    type.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，活跃模式允许你将任意值包裹在DU数据结构中，以便于模式匹配。可以使用活跃模式包裹对象，这样你就可以像使用任何其他联合类型一样轻松地在模式匹配中使用这些对象。
- en: 'Sometimes active patterns do not generate a value; in this case, they’re called
    *partial active patterns* and result in a type that is an option type. To define
    a partial active pattern, you use the underscore wildcard character (_) at the
    end of the list of patterns inside the banana clips `(| |)` created with the combination
    of parentheses and pipe characters. Here’s how a typical partial active pattern
    looks:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 有时活跃模式不会生成值；在这种情况下，它们被称为 *部分活跃模式*，并导致一个选项类型。要定义部分活跃模式，你需要在用括号和管道字符组合创建的香蕉剪辑
    `(| |)` 内部的模式列表末尾使用下划线通配符字符（_）。以下是一个典型的部分活跃模式的外观：
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In this partial active pattern, if the value `n` is divisible by the value
    `divideBy`, then the return type is `Some()`, which indicates that the active
    pattern succeeds. Otherwise, the `None` return type indicates that the pattern
    failed and moved to the next match expression. Partial active patterns are used
    to partition and match only part of the input space. The following code illustrates
    how to pattern match against a partial active pattern:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在此部分主动模式中，如果值 `n` 能被 `divideBy` 的值整除，则返回类型为 `Some()`，这表示主动模式成功。否则，`None` 返回类型表示模式失败并移动到下一个匹配表达式。部分主动模式用于分区和匹配输入空间的一部分。以下代码演示了如何对部分主动模式进行模式匹配：
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This function uses the partial active pattern `(|DivisibleBy|_|)` to test the
    input value `n`. If it’s divisible by a value 3 and 5, the first case succeeds.
    If it’s divisible by only 3, then the second cause succeeds, and so forth. Note
    that the `&` operator lets you run more than one pattern on the same argument.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数使用部分主动模式 `(|可被|_|)` 来测试输入值 `n`。如果它能被3和5整除，则第一个情况成功。如果它只能被3整除，则第二个情况成功，依此类推。请注意，`&`
    操作符允许你在同一个参数上运行多个模式。
- en: Another type of active pattern is the *parameterized active pattern*, which
    is similar to the partial active pattern, but takes one or more additional arguments
    as input.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种主动模式是 *参数化主动模式*，它与部分主动模式类似，但接受一个或多个额外的参数作为输入。
- en: 'More interesting is the *multicase active pattern*, which partitions the entire
    input space into different data structures in the shape of a DU. Here’s the `FizzBuzz`
    example, implemented using multicase active patterns:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 更有趣的是 *多情况主动模式*，它将整个输入空间划分为不同形状为 DU 的数据结构。以下是一个使用多情况主动模式的 `FizzBuzz` 示例：
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Because active patterns convert data from one type to another, they’re great
    for data transformation and validation. Active patterns come in four related varieties:
    single case, partial case, multicase, and partial parameterized. For more details
    about active patterns, see the MSDN documentation ([http://mng.bz/Itmw](http://mng.bz/Itmw))
    and Isaac Abraham’s *Get Programming with F#* (Manning, 2018).'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于主动模式可以将数据从一种类型转换为另一种类型，因此它们非常适合数据转换和验证。主动模式有四种相关的类型：单案例、部分案例、多案例和部分参数化。有关主动模式的更多详细信息，请参阅
    MSDN 文档 ([http://mng.bz/Itmw](http://mng.bz/Itmw)) 和 Isaac Abraham 的 *Get Programming
    with F#* (Manning, 2018)。
- en: Collections
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合
- en: 'F# supports the standard .NET collections like arrays and sequences (`IEnumerable`).
    In addition, it offers a set of immutable functional collections: lists, sets,
    and maps.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: F# 支持标准 .NET 集合，如数组序列 (`IEnumerable`)。此外，它还提供了一套不可变的函数式集合：列表、集合和映射。
- en: Arrays
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组
- en: 'Arrays are zero-based, mutable collections with a fixed-size number of elements
    of the same type. They support fast, random access of elements because they are
    compiled as a contiguous block of memory. Here are the different ways to create,
    filter, and project an array:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是零基、可变集合，具有固定大小的相同类型元素。由于它们被编译为连续的内存块，因此它们支持快速、随机的元素访问。以下是创建、过滤和投影数组的不同方法：
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The elements of an array can be accessed and updated by using the dot operator
    (`.`) and brackets `[ ]`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用点操作符 (`.`) 和方括号 `[ ]` 来访问和更新数组的元素：
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Arrays can also be created in various other syntaxes, using the functions from
    the `Array` module:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 数组也可以使用 `Array` 模块中的函数以各种其他语法创建：
- en: '[PRE28]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Sequences (seq)
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 序列（seq）
- en: '*Sequences* are a series of elements of the same type. Different from the `List`
    type, sequences are lazily evaluated, which means that elements can be computed
    on demand (only when they are needed). This provides better performance than a
    list in cases where not all the elements are needed. Here’s a different way to
    create, filter, and project a sequence:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*序列* 是同一类型元素的一系列。与 `List` 类型不同，序列是延迟评估的，这意味着元素可以在需要时计算（仅当需要时）。在不需要所有元素的情况下，这比列表提供了更好的性能。以下是创建、过滤和投影序列的另一种方法：'
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Sequences can use the `yield` keyword to lazily return a value that becomes
    part of the sequence.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 序列可以使用 `yield` 关键字来延迟返回成为序列一部分的值。
- en: Lists
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表
- en: 'In F#, the `List` collection is an immutable, singly linked list of elements
    of the same type. In general, lists are a good choice for enumeration, but aren’t
    recommended for random access and concatenation when performance is critical.
    Lists are defined using the `[ ... ]` syntax. Here are a few examples to create,
    filter, and map a list:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在F#中，`List`集合是一个不可变的、元素类型相同的单链表。一般来说，列表是枚举的好选择，但在性能关键时，不建议用于随机访问和连接。列表使用`[ ...
    ]`语法定义。以下是一些创建、过滤和映射列表的示例：
- en: '[PRE30]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Lists use brackets (`[ ]`) and the semicolon (`;`) delimiters to append multiple
    items to the list, the symbol `::` to append one item, and the at-sign operator
    (`@`) to concatenate two given lists.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 列表使用括号（`[ ]`）和分号（`;`）分隔符来向列表中添加多个项目，使用符号`::`来添加一个项目，并使用at符号运算符（`@`）来连接两个给定的列表。
- en: Sets
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合
- en: 'A *set* is a collection based on binary trees, where the elements are of the
    same type. With sets, the order of insertion is not preserved, and duplicates
    aren’t allowed. A set is immutable, and every operation to update its elements
    creates a new set. Here are a few different ways to create a set:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*集合*是基于二叉树的集合，其中元素类型相同。使用集合时，不保留插入顺序，也不允许重复。集合是不可变的，并且更新其元素的操作都会创建一个新的集合。以下是一些创建集合的不同方法：
- en: '[PRE31]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Maps
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射
- en: 'A *map* is an immutable, key-value pair of a collection of elements with the
    same type. This collection associates values with a key, and it behaves like the
    `Set` type, which doesn’t allow duplicates or respect the order of insertion.
    The following example shows how to instantiate a map in different ways:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*映射*是一个不可变的、具有相同类型的元素集合的键值对。这个集合将值与键关联起来，并且它的行为类似于不允许重复或不尊重插入顺序的`Set`类型。以下示例展示了如何以不同的方式实例化映射：
- en: '[PRE32]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Loops
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环
- en: 'F# supports loop constructs to iterate over enumerable collections like lists,
    arrays, sequences, maps, and so forth. The `while...do` expression performs iterative
    execution while a specified condition is true:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: F#支持循环结构来遍历如列表、数组、序列、映射等可枚举集合。`while...do`表达式在指定的条件为真时执行迭代：
- en: '[PRE33]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `for...to` expression iterates in a loop over a set of values of a loop
    variable:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`for...to`表达式在循环中遍历一个循环变量的值集合：'
- en: '[PRE34]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `for...in` expression iterates in a loop over each element in a collection
    of values:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`for...in`表达式在循环中遍历值集合中的每个元素：'
- en: '[PRE35]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Classes and inheritance
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类和继承
- en: 'As previously mentioned, F# supports OOP constructs like other .NET programming
    languages. In fact, it’s possible to define class objects to model real-world
    domains. The `type` keyword used in F# to declare a class can expose properties,
    methods, and fields. The following code shows the definition of the subclass `Student`
    that’s inherited from the class `Person`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，F#支持像其他.NET编程语言一样的OOP结构。实际上，可以定义类对象来模拟现实世界的领域。在F#中用于声明类的`type`关键字可以公开属性、方法和字段。以下代码展示了从`Person`类继承的子类`Student`的定义：
- en: '[PRE36]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The properties `FirstName`, `LastName`, and `Age` are exposed as fields; the
    method `UpdateAge` returns a new `Person` object with the modified `Age.` It’s
    possible to change the default behavior of methods inherited from the base class
    using the `override` keyword. In the example, the `ToString` base method is overridden
    to return the full name.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 属性`FirstName`、`LastName`和`Age`作为字段公开；方法`UpdateAge`返回一个新的`Person`对象，其`Age`已修改。可以使用`override`关键字更改从基类继承的方法的默认行为。在示例中，`ToString`基方法被重写以返回全名。
- en: The object `Student` is a subclass defined using the `inherit` keyword, and
    inherits its members from the base class `Person`, in addition to adding its own
    member `Grade`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 对象`Student`是通过`inherit`关键字定义的子类，它从基类`Person`继承其成员，并添加了自己的成员`Grade`。
- en: Abstract classes and inheritance
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象类和继承
- en: 'An *abstract class* is an object that provides a template to define classes.
    Usually it exposes one or more incomplete implementations of methods or properties
    and requires you to create subclasses to fill in these implementations. But it’s
    possible to define a default behavior, which can be overridden. In the following
    example, the abstract class `Shape` defines the `Rectangle` and `Circle` classes:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*抽象类*是一个提供定义类的模板的对象。通常它暴露一个或多个不完整的方法或属性实现，并要求你创建子类来填充这些实现。但是可以定义默认行为，这可以被覆盖。在下面的例子中，抽象类`Shape`定义了`Rectangle`和`Circle`类：
- en: '[PRE37]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `AbstractClass` attribute notifies the compiler that the class has abstract
    members. The `Rectangle` class uses the default implementation of the method `Area`,
    and the `Circle` class overrides it with a custom behavior.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`AbstractClass`属性通知编译器该类有抽象成员。`Rectangle`类使用`Area`方法的默认实现，而`Circle`类则使用自定义行为覆盖它。'
- en: Interfaces
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**接口**'
- en: 'An *interface* represents a contract for defining the implementation details
    of a class. But in an interface declaration, the members aren’t implemented. An
    interface provides an abstract way to refer to the public members and functions
    that it exposes. In F#, to define an interface, the members are declared using
    the `abstract` keyword, followed by their type signature:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*接口*代表了一个定义类实现细节的合约。但在接口声明中，成员没有被实现。接口提供了一种抽象的方式来引用它公开的公共成员和函数。在F#中，要定义一个接口，使用`abstract`关键字声明成员，后跟它们的类型签名：'
- en: '[PRE38]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The interface methods implemented by a class are accessed through the interface
    definition, rather than through the instance of the class. Thus, to call an interface
    method, a cast operation is applied against the class using the `:>` (upcast)
    operator:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 类实现的接口方法是通过接口定义而不是通过类的实例来访问的。因此，要调用接口方法，需要对类应用一个`:>`（向上转换）操作符：
- en: '[PRE39]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Object expressions
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**对象表达式**'
- en: 'Interfaces represent a useful implementation of code that can be shared between
    other parts of a program. But it might require cumbersome work to define an ad
    hoc interface implemented through the creation of new classes. A solution is to
    use an *object expression*, which lets you implement interfaces on the fly by
    using anonymous classes. Here’s an example to create a new object that implements
    the `IDisposable` interface to apply a color to the console and then revert to
    the original:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 接口代表了可以在程序的其他部分之间共享的有用代码实现。但可能需要繁琐的工作来定义通过创建新类实现的特定接口。一种解决方案是使用*对象表达式*，它允许您通过使用匿名类即时实现接口。以下是一个创建新对象以实现`IDisposable`接口并将颜色应用到控制台然后恢复原始状态的示例：
- en: '[PRE40]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Casting
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**类型转换**'
- en: The conversion of a primitive value into an object type is called *boxing*,
    which is applied using the function `box`. This function upcasts any type to the
    .NET `System.Object` type, which in F# is abbreviated by the name obj.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 将原始值转换为对象类型的过程称为*装箱*，它通过`box`函数应用。这个函数将任何类型向上转换为.NET的`System.Object`类型，在F#中用名称obj缩写。
- en: The *upcast* function applies an “up” conversion for classes and interface hierarchies,
    which goes from a class up to the inherited one. The syntax is `expr :> type`.
    The success of the conversion is checked at compile time.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*向上转换*函数应用于类和接口层次结构，它从类向上到继承的类。语法是`expr :> type`。转换的成功在编译时进行检查。'
- en: 'The *downcast* function is used to apply a conversion that goes “down” a class
    or interface hierarchy: for example, from an interface to an implemented class.
    The syntax is `expr :?> type`, where the question mark inside the operator suggests
    that the operation may fail with an `InvalidCastException`. It’s safe to compare
    and test the type before applying the downcast. This is possible using the type
    test operator `:?`, which is equivalent to the `is` operator in C#. The *match
    expression* returns true if the value matches a given type; otherwise, it returns
    false:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*向下转换*函数用于应用一个“向下”类或接口层次结构的转换：例如，从一个接口到一个实现类。语法是`expr :?> type`，其中操作符内的问号表示该操作可能因`InvalidCastException`而失败。在应用向下转换之前，安全地比较和测试类型。这可以通过类型测试操作符`:?`来实现，它在C#中相当于`is`操作符。*匹配表达式*如果值匹配给定的类型则返回true；否则返回false：'
- en: '[PRE41]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Units of measure
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**度量单位**'
- en: '*Units* *of measure* (UoM) are a unique feature of F#’s type system and provide
    the ability to define a context and to annotate statically typed unit metadata
    to numeric literals. This is a convenient way to manipulate numbers that represent
    a specific unit of measure, such as meters, seconds, pounds, and so forth. The
    F# type system checks that a UoM is used correctly in the first place, eliminating
    runtime errors. For example, the F# compiler will throw an error if a `float<m/sec>`
    is used where it expects a `float<mil>`. Furthermore, it’s possible to associate
    specific functions to a defined UoM that performs work on units rather than on
    numeric literals. Here, the code shows how to define the meter (m) and second
    (sec) UoM and then executes an operation to calculate speed:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*单位* *度量*（UoM）是F#类型系统的独特特性，它提供了定义上下文和为静态类型单位元数据注释的能力，并将其应用于数值字面量。这是一种方便的方式来操作表示特定度量单位（如米、秒、磅等）的数字。F#类型系统首先检查UoM是否正确使用，从而消除运行时错误。例如，如果F#编译器期望一个`float<mil>`，而使用了`float<m/sec>`，则会抛出错误。此外，可以将特定函数与定义的UoM关联起来，该函数在单位上执行工作而不是在数值字面量上。在此，代码展示了如何定义米（m）和秒（sec）UoM，然后执行一个计算速度的操作：'
- en: '[PRE42]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Event module API reference
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件模块API参考
- en: The *event module* provides functions for managing event streams. [Table B.1](#tableB.1)
    lists the API references from the online MSDN documentation ([http://mng.bz/a0hG](http://mng.bz/a0hG)).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*事件模块*提供了管理事件流的函数。[表B.1](#tableB.1)列出了来自在线MSDN文档的API参考([http://mng.bz/a0hG](http://mng.bz/a0hG))。'
- en: Table B.2 API references
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 表B.2 API参考
- en: '| **Function** | **Description** |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **描述** |'
- en: '| --- | --- |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| add :'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '| add :'
- en: '[PRE43]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '| Runs the function each time the event is triggered. |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 每次事件触发时运行函数。 |'
- en: '| choose :'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '| choose :'
- en: '[PRE44]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '| Returns a new event that fires on a selection of messages from the original
    event. The selection function takes an original message to an optional new message.
    |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| 返回一个新事件，该事件在原始事件的消息选择上触发。选择函数将原始消息转换为可选的新消息。 |'
- en: '| filter :'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '| filter :'
- en: '[PRE45]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '| Returns a new event that listens to the original event and triggers the resulting
    event only when the argument to the event passes the given function. |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 返回一个新事件，该事件监听原始事件，并且仅在事件传递给给定函数的参数通过时触发结果事件。 |'
- en: '| map :'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '| map :'
- en: '[PRE46]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '| Returns a new event that passes values transformed by the given function.
    |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| 返回一个新事件，该事件通过给定函数转换值。 |'
- en: '| merge :'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '| merge :'
- en: '[PRE47]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '| Fires the output event when either of the input events fire. |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| 当任一输入事件触发时，触发输出事件。 |'
- en: '| pairwise :`IEvent<''Del,''T> -> IEvent<''T * ''T>` | Returns a new event
    that triggers on the second and subsequent triggerings of the input event. The
    *N*th triggering of the input event passes the arguments from the *N* − 1th and
    *N*th triggerings as a pair. The argument passed to the *N* − 1th triggering is
    held in hidden internal state until the *N*th triggering occurs. |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| pairwise :`IEvent<''Del,''T> -> IEvent<''T * ''T>` | 返回一个新事件，该事件在输入事件的第二次和后续触发时触发。输入事件的第N次触发将传递来自第N-1次和第N次触发的参数作为一对。传递给第N-1次触发的参数在隐藏的内部状态中保持，直到第N次触发发生。
    |'
- en: '| partition :'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '| partition :'
- en: '[PRE48]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '| Returns a pair of events that listen to the original event. When the original
    event triggers, either the first or second event of the pair is triggered accordingly
    with the result of the predicate. |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| 返回一对事件，它们监听原始事件。当原始事件触发时，根据谓词的结果，触发这对中的第一个或第二个事件。 |'
- en: '| scan :'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '| scan :'
- en: '[PRE49]  | Returns a new event consisting of the results of applying the given
    accumulating function to successive values triggered on the input event. An item
    of internal state records the current value of the state parameter. The internal
    state is not locked during the execution of the accumulation function, so care
    should be taken that the input `IEvent` isn’t triggered by multiple threads simultaneously.
    |'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE49]  | 返回一个新事件，该事件由将给定累积函数应用于输入事件上连续触发的值的结果组成。内部状态项记录状态参数的当前值。在累积函数执行期间，内部状态不会被锁定，因此应小心，确保输入`IEvent`不会被多个线程同时触发。
    |'
- en: '| split :'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '| split :'
- en: '[PRE50]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '| Returns a new event that listens to the original event and triggers the first
    resulting event if the application of the function to the event arguments returned
    a `Choice1Of2`, and the second event if it returns a `Choice2Of2`. |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 返回一个新事件，该事件监听原始事件，并在将函数应用于事件参数返回`Choice1Of2`时触发第一个结果事件，如果返回`Choice2Of2`则触发第二个事件。
    |'
- en: '**Learn more**'
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**了解更多**'
- en: 'For more information about learning F#, I recommend Isaac Abraham’s *Get Programming
    with F#: A Guide for .NET Developers* (Manning, 2018, [www.manning.com/books/get-programming-with-f-sharp](http://www.manning.com/books/get-programming-with-f-sharp)).'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 关于学习 F# 的更多信息，我推荐 Isaac Abraham 的 *《用 F# 编程：.NET 开发者指南》*（Manning，2018，[www.manning.com/books/get-programming-with-f-sharp](http://www.manning.com/books/get-programming-with-f-sharp)）。
