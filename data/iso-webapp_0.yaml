- en: Part 1\. First steps
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第1部分。第一步
- en: Understanding what an isomorphic app is and why you’d want to build one is an
    important first step in learning about isomorphic architecture. The first part
    of this book explores the why and how of isomorphic apps with a bird’s-eye view,
    giving you the context you need in order to comprehend the specific implementation
    details presented in later sections.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 了解什么是同构应用以及为什么想要构建一个同构应用是了解同构架构的重要第一步。本书的第一部分从宏观角度探讨了同构应用的原因和方式，为你提供了理解后面章节中呈现的具体实现细节所需的环境。
- en: 'In [chapter 1](kindle_split_011_split_000.xhtml#ch01), you’ll learn all the
    reasons to build an isomorphic app. This chapter also gives you an overview of
    the All Things Westies app you’ll build later in the book. In [chapter 2](kindle_split_012_split_000.xhtml#ch02),
    you’ll work through building an example app with the technologies used in the
    book: React, Node.js, webpack, and Babel. Instead of covering all the small details,
    this chapter allows you to see how the pieces fit together.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](kindle_split_011_split_000.xhtml#ch01)中，你将了解构建同构应用的所有原因。本章还为你概述了本书后面将构建的All
    Things Westies应用。在[第2章](kindle_split_012_split_000.xhtml#ch02)中，你将使用本书中使用的技术（React、Node.js、webpack和Babel）构建一个示例应用。本章不是涵盖所有细节，而是让你看到这些部分是如何结合在一起的。
- en: Chapter 1\. Introduction to isomorphic web application architecture
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第1章。同构Web应用架构简介
- en: '*This chapter covers*'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Differentiating between isomorphic, server-side rendered, and single-page apps
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区分同构、服务器端渲染和单页应用
- en: Server rendering and the steps involved in transitioning from a server-rendered
    to a single-page app experience
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器端渲染以及从服务器端渲染到单页应用体验的转换步骤
- en: Understanding the advantages and challenges of isomorphic web apps
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解同构Web应用的优缺点
- en: Building isomorphic web apps with React’s virtual DOM
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用React的虚拟DOM构建同构Web应用
- en: Using Redux to handle the business logic and data flow
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Redux处理业务逻辑和数据流
- en: Bundling modules with dependencies via webpack
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过webpack将具有依赖关系的模块捆绑在一起
- en: This book is intended for web developers looking to expand their architectural
    toolset and better understand the options available for building web apps. If
    you’ve ever built a single-page or server-rendered web app (say, with Ruby on
    Rails), you’ll have an easier time following the content in this book. Ideally,
    you’re comfortable with JavaScript, HTML, and CSS. If you’re new to web development,
    this book isn’t for you.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本书旨在为寻求扩展其架构工具集并更好地了解构建Web应用的选项的Web开发者而编写。如果你曾经构建过单页或服务器端渲染的Web应用（比如，使用Ruby
    on Rails），你将更容易理解本书中的内容。理想情况下，你对JavaScript、HTML和CSS感到舒适。如果你是Web开发的初学者，这本书可能不适合你。
- en: 'Historically, web apps and websites have come in two forms: server-rendered
    and single-page apps (SPAs). *Server-rendered apps* handle each action the user
    takes by making a new request to the server. In contrast *SPAs* handle loading
    the content and responding to user interactions entirely in the browser. *Isomorphic
    web apps* are a combination of these two approaches.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，Web应用和网站有两种形式：服务器端渲染和单页应用（SPAs）。*服务器端渲染应用*通过向服务器发送新请求来处理用户采取的每个操作。相比之下，*SPAs*在浏览器中完全处理内容的加载和对用户交互的响应。*同构Web应用*是这两种方法的结合。
- en: 'This book aspires to take a complex application architecture and break it into
    repeatable and understandable bits. By the end of this book, you’ll be able to
    create a content site or an e-commerce web app with the following techniques:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本书旨在将复杂的应用程序架构分解成可重复和可理解的片段。到本书结束时，你将能够使用以下技术创建内容网站或电子商务Web应用：
- en: Render any page on the server by using React to achieve fast perceived performance
    and fully render pages for search engine optimization (SEO) crawlers (such as
    Googlebot).
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用React实现快速感知性能并在服务器上渲染任何页面，以实现搜索引擎优化（SEO）爬虫（如Googlebot）的完全渲染。
- en: Choose not to render certain features on the server. Understand how to use the
    React lifecycle to achieve this.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择不在服务器上渲染某些功能。了解如何使用React生命周期来实现这一点。
- en: Handle user sessions on both the server and the browser.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器和浏览器上处理用户会话。
- en: Implement single-direction data flow with Redux, making prefetching data on
    the server and rendering in the browser feasible.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Redux实现单向数据流，使在服务器上预取数据并在浏览器中渲染成为可能。
- en: Use webpack and Babel to enable a modern JavaScript workflow.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用webpack和Babel来启用现代JavaScript工作流程。
- en: 1.1\. Isomorphic web app overview
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1. 同构Web应用概述
- en: 'My team and I had a big problem: our SEO rendering system was brittle and eating
    up valuable time. Instead of building new features, we were troubleshooting why
    Googlebot was seeing a different version of our app from what our users were seeing.
    The system was complex, involved a third-party provider, and wasn’t scaling well
    for our needs, so we moved forward with a new type of app—an isomorphic one.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我的团队和我遇到了一个大问题：我们的SEO渲染系统非常脆弱，消耗了宝贵的时间。我们不是在构建新功能，而是在排查为什么谷歌机器人看到的我们应用版本与用户看到的版本不同。该系统复杂，涉及第三方提供商，并且没有很好地扩展以满足我们的需求，因此我们决定向前迈进，开发一种新的应用类型——同构应用。
- en: An *isomorphic app* is a web app that blends a server-rendered web app with
    a single-page application. On the one hand, we want to take advantage of fast
    perceived performance and SEO-friendly rendering from the server. On the other
    hand, we want to handle complex user actions in the browser (for example, opening
    a modal). We also want to take advantage of the browser push history and XMLHttpRequest
    (XHR). These technologies prevent us from making a server request on every interaction.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**同构应用**是一种将服务器渲染的网络应用与单页应用结合在一起的网络应用。一方面，我们希望利用服务器提供的快速感知性能和SEO友好的渲染。另一方面，我们希望在浏览器中处理复杂的用户操作（例如，打开模态窗口）。我们还想利用浏览器推送历史记录和XMLHttpRequest（XHR）。这些技术使我们能够在每次交互时避免向服务器发送请求。'
- en: To get started understanding all of this, you’re going to use an example web
    app called All Things Westies (you’ll build this app later in the book, starting
    in [chapter 4](kindle_split_015_split_000.xhtml#ch04)). On this site, you can
    find all kinds of products to buy for your Westie (West Highland white terrier—a
    small, white dog). You can purchase dog supplies and buy products featuring Westies
    (socks, mugs, shirts, and so forth). If you’re not a pet owner, you might find
    this example ridiculous. As a dog owner, even I thought it was over the top. But
    it turns out that dog products such as mugs are a huge thing. If you don’t believe
    me, search Google for “pug mugs.”
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始理解所有这些内容，你将使用一个名为“所有西高地白梗”（All Things Westies）的示例网络应用（你将在本书的[第4章](kindle_split_015_split_000.xhtml#ch04)中构建此应用）。在这个网站上，你可以找到各种为你的西高地白梗（一种小型白色犬）购买的产品。你可以购买狗用品和带有西高地白梗图案的产品（如袜子、杯子、T恤等）。如果你不是宠物主人，你可能会觉得这个例子很荒谬。即使是宠物主人，我也觉得它有些过分。但事实是，像杯子这样的狗用品已经成为一大热门。如果你不相信我，可以在谷歌上搜索“pug
    mugs”。
- en: Because this is an e-commerce app, we care about having good SEO. We also want
    our customers to have a great experience with performance in the app. This makes
    it an ideal use case for isomorphic architecture.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这是一个电子商务应用，我们非常重视良好的搜索引擎优化（SEO）。我们还希望我们的客户在使用应用时能获得极佳的体验。这使得同构架构成为理想的应用场景。
- en: 1.1.1\. Understanding how it works
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.1. 理解其工作原理
- en: Look at [figure 1.1](kindle_split_011_split_001.xhtml#ch01fig01), which is a
    wireframe for the All Things Westies app. There’s a standard header with some
    main site navigation on the right. Below the header, the main content areas promote
    products and the social media presence.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 请看[图1.1](kindle_split_011_split_001.xhtml#ch01fig01)，这是“所有西高地白梗”应用的线框图。它有一个标准的页眉，右侧有一些主要网站导航。在页眉下方，主要内容区域推广产品和社交媒体的存在。
- en: Figure 1.1\. A wireframe showing the homepage for All Things Westies, an isomorphic
    web app
  id: totrans-26
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.1. 展示“所有西高地白梗”应用主页的线框图，这是一个同构网络应用
- en: '![](Images/01fig01_alt.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片1.1](Images/01fig01_alt.jpg)'
- en: The first time you come to the site, the app content is rendered on the server
    using server-rendered techniques with Node.js. After being server-rendered, the
    content is sent to the browser and displayed to the user. As the user navigates
    around the pages, looking for a dog mug or supplies, each page is rendered by
    the JavaScript running in the browser and using SPA techniques.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次访问该网站时，应用内容使用Node.js的服务器渲染技术渲染在服务器上。在服务器渲染后，内容被发送到浏览器并显示给用户。当用户在页面间导航，寻找狗杯或用品时，每个页面都是由浏览器中运行的JavaScript和SPA技术渲染的。
- en: 'The All Things Westies app relies on reusing as much code as possible between
    the server and the browser. The app relies on JavaScript’s ability to run in multiple
    environments: JavaScript runs in browsers and on the server via Node.js. Although
    JavaScript can run in other environments as well (for example, on Internet of
    Things devices and on mobile devices via React Native), the focus here is on web
    apps that run in the browser.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: All Things Westies应用依赖于尽可能在服务器和浏览器之间重用代码。该应用依赖于JavaScript在多个环境中的运行能力：JavaScript在浏览器中运行，通过Node.js在服务器上运行。虽然JavaScript也可以在其他环境中运行（例如，在物联网设备和通过React
    Native在移动设备上），但这里的重点是运行在浏览器中的Web应用。
- en: Many of the concepts in this book could be applied without writing all the code
    in JavaScript. Historically, the complexity of running an isomorphic app without
    being able to reuse code has been prohibitive. Although it’s possible to server-render
    your site with Java or Ruby and then transition to a single-page app, it isn’t
    commonly done because it requires duplicating large portions of code in two languages.
    That requires more maintenance.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书中的许多概念可以在不编写所有JavaScript代码的情况下应用。历史上，在没有代码重用能力的情况下运行同构应用，其复杂性一直是阻碍因素。虽然使用Java或Ruby进行服务器端渲染并在之后过渡到单页应用是可能的，但这并不常见，因为它需要在两种语言中复制大量代码。这需要更多的维护。
- en: To see this flow in action, look at [figure 1.2](kindle_split_011_split_001.xhtml#ch01fig02).
    It shows how the code for All Things Westies gets deployed to the server and the
    browser. The server code is packaged and run on a Node.js web server, and the
    browser code is bundled into a file that’s later downloaded in the browser. Because
    we take advantage of JavaScript running in both environments, the same code that
    runs in the browser and talks to our API or data source also runs on the server
    to talk to our back end.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看这个流程的实际操作，请看[图1.2](kindle_split_011_split_001.xhtml#ch01fig02)。它展示了All Things
    Westies的代码是如何部署到服务器和浏览器的。服务器代码被打包并在Node.js网络服务器上运行，而浏览器代码则打包成一个文件，稍后在浏览器中下载。因为我们利用了JavaScript在两个环境中的运行，所以运行在浏览器并与我们的API或数据源通信的相同代码也在服务器上运行，以与后端通信。
- en: Figure 1.2\. Isomorphic apps build and deploy the same JavaScript code to both
    environments.
  id: totrans-32
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.2. 同构应用在两个环境中构建和部署相同的JavaScript代码。
- en: '![](Images/01fig02_alt.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/01fig02_alt.jpg)'
- en: 1.1.2\. Building our stack
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.2. 构建我们的堆栈
- en: Building an app such as All Things Westies requires putting together several
    well-known technologies. Many of the concepts in this book are executed with open
    source libraries. Although you could build an isomorphic app using few or no libraries,
    I highly recommend taking advantage of the JavaScript communities’ efforts in
    this area.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 构建像All Things Westies这样的应用需要组合几种知名技术。这本书中的许多概念都是通过开源库来实现的。虽然你可以使用很少或没有库来构建同构应用，但我强烈建议利用JavaScript社区在这个领域的努力。
- en: '|  |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-37
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Make sure any libraries you include in an isomorphic app support running in
    both the server and browser environments. Check out [chapter 10](kindle_split_022_split_000.xhtml#ch10)
    for what to watch for and how to handle differences in environments. If you intend
    to use a library only on the server, you don’t need to check for browser compatibility.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你包含在同构应用中的任何库都支持在服务器和浏览器环境中运行。查看[第10章](kindle_split_022_split_000.xhtml#ch10)了解需要注意的事项以及如何处理环境差异。如果你打算只在服务器上使用库，则不需要检查浏览器兼容性。
- en: '|  |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The HTML components that display the products (the view) will be built with
    React (in [chapter 12](kindle_split_025_split_000.xhtml#ch12), you’ll explore
    how to use other popular frameworks, including Angular 2 and Ember, to implement
    isomorphic architecture). You’ll use a single-direction data flow via Redux, the
    current community standard data management in React apps. You’ll use webpack to
    compile the code that runs in the browser and to enable running Node.js packages
    in the browser.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 显示产品（视图）的HTML组件将使用React构建（在第[12章](kindle_split_025_split_000.xhtml#ch12)中，你将探索如何使用其他流行的框架，包括Angular
    2和Ember，来实现同构架构）。你将通过Redux实现单向数据流，Redux是React应用中当前社区标准的数据管理方式。你将使用webpack来编译在浏览器中运行的代码，并启用在浏览器中运行Node.js包。
- en: On the server side, you’ll build a Node.js server using Express to handle routing.
    You’ll take advantage of React’s ability to render on the server and use it to
    build up a complete HTML response that can be served to the browser. [Table 1.1](kindle_split_011_split_001.xhtml#ch01table01)
    shows how all these pieces fit together.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，你将使用 Express 构建 Node.js 服务器来处理路由。你将利用 React 在服务器上渲染的能力，并使用它构建一个完整的 HTML
    响应，可以提供给浏览器。[表 1.1](kindle_split_011_split_001.xhtml#ch01table01) 显示了所有这些组件是如何组合在一起的。
- en: Table 1.1\. The technologies used in an isomorphic app and the environments
    they run in
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 1.1. 同构应用程序中使用的技术及其运行的环境
- en: '| Library (version) | Server | Browser | Build tool |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 库（版本） | 服务器 | 浏览器 | 构建工具 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Node.js (6.9.2) | ✓ |   |   |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| Node.js (6.9.2) | ✓ |   |   |'
- en: '| Express (4.15.3) | ✓ |   |   |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| Express (4.15.3) | ✓ |   |   |'
- en: '| React (15.6.1) | ✓ | ✓ |   |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| React (15.6.1) | ✓ | ✓ |   |'
- en: '| React Router (3.0.5) | ✓ | ✓ |   |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| React Router (3.0.5) | ✓ | ✓ |   |'
- en: '| Redux (3.7.2) | ✓ | ✓ |   |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| Redux (3.7.2) | ✓ | ✓ |   |'
- en: '| Babel (6.25.0) | ✓ | ✓ | ✓ |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| Babel (6.25.0) | ✓ | ✓ | ✓ |'
- en: '| webpack (3.4.1) |   | ✓ | ✓ |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| webpack (3.4.1) |   | ✓ | ✓ |'
- en: To make our application work everywhere, you’ll build in data prefetching for
    your routes using React Router. You’ll also handle differences in environments
    by building separate code entry points for the server and browser. If code can
    be run only in the browser, you’ll gate the code or take advantage of the React
    lifecycle to ensure that the code won’t run on the server. I introduce React in
    [chapter 3](kindle_split_014_split_000.xhtml#ch03) and the specifics of the server
    logic in [chapter 7](kindle_split_019_split_000.xhtml#ch07).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的应用程序在所有地方都能工作，你将使用 React Router 为你的路由构建数据预取。你还将通过为服务器和浏览器构建单独的代码入口点来处理环境差异。如果代码只能在浏览器中运行，你将控制代码或利用
    React 生命周期来确保代码不会在服务器上运行。我在[第 3 章](kindle_split_014_split_000.xhtml#ch03)介绍了 React，并在[第
    7 章](kindle_split_019_split_000.xhtml#ch07)中介绍了服务器逻辑的细节。
- en: 1.2\. Architecture overview
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2. 架构概述
- en: Earlier in this chapter, I told you that an isomorphic application is the result
    of combining a server-rendered application and a single-page application. To get
    a better understanding of how to connect the concepts of a server-rendered application
    and a single-page application, see [figure 1.3](kindle_split_011_split_002.xhtml#ch01fig03).
    This figure shows all the steps involved in getting an isomorphic app rendered
    and responding to user input, like a single-page application, starting when the
    user enters the web address.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期，我告诉你们同构应用程序是服务器端渲染的应用程序和单页应用程序结合的结果。为了更好地理解如何连接服务器端渲染应用程序和单页应用程序的概念，请参阅[图
    1.3](kindle_split_011_split_002.xhtml#ch01fig03)。此图显示了获取同构应用程序渲染并响应用户输入的所有步骤，如单页应用程序，从用户输入网页地址开始。
- en: Figure 1.3\. The isomorphic app flow from initial browser request to SPA cycle
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.3. 从初始浏览器请求到 SPA 循环的同构应用程序流程
- en: '![](Images/01fig03_alt.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/01fig03_alt.jpg)'
- en: 1.2.1\. Understanding the application flow
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.1. 理解应用程序流程
- en: 'Every web app session is initiated when a user navigates to the web app or
    types the URL into the browser window. For allthingswesties.com, when a user clicks
    a link to the app from an email or from searching on Google, the flow on the server
    goes through the following steps (the numbers match those in [figure 1.3](kindle_split_011_split_002.xhtml#ch01fig03)):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 每个网络应用程序会话都是在用户导航到网络应用程序或输入 URL 到浏览器窗口时启动的。对于 allthingswesties.com，当用户从电子邮件或从
    Google 搜索中点击应用程序链接时，服务器端的流程将经过以下步骤（数字与[图 1.3](kindle_split_011_split_002.xhtml#ch01fig03)中的数字相匹配）：
- en: '**1**.  The browser initiates the request.'
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**.  浏览器发起请求。'
- en: '**2**.  The server receives the request.'
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 服务器接收请求。'
- en: '**3**.  The server determines what needs to be rendered.'
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. 服务器确定需要渲染的内容。'
- en: '**4**.  The server gathers the data required for the part of our application
    being requested. If the request is for allthingswesties.com/product/mugs, the
    app requests the list of gift items for sale through the site. This list of mugs,
    along with all the information to be displayed (names, descriptions, price, images),
    is collected before moving on to the render step.'
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**. 服务器收集我们请求的应用程序部分所需的数据。如果请求是 allthingswesties.com/product/mugs，应用程序将请求通过网站销售的礼品项目列表。在进入渲染步骤之前，收集了所有要显示的信息（名称、描述、价格、图片）列表。'
- en: '**5**.  The server generates the HTML for our web page using the data collected
    for the mugs page.'
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**5**. 服务器使用为杯子页面收集的数据生成我们的网页的 HTML。'
- en: '**6**.  The server responds to the request for allthingswesties.com/product/mugs
    with the fully built HTML.'
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**6**.  服务器响应 allthingswesties.com/product/mugs 的请求，并返回完整的 HTML。'
- en: The next part of the application cycle is the initial load in the browser. We
    differentiate the first time the user loads the app from subsequent requests because
    several things that will happen only once per session happen during this first
    load.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序周期的下一部分是浏览器中的初始加载。我们区分用户首次加载应用程序与随后的请求，因为在此首次加载期间，只会发生一次会话中的几个事情。
- en: '|  |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Definition
  id: totrans-67
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义
- en: '*Initial load* is the first time the user interacts with your website. This
    means the first time the user clicks a link to your site in a Google search or
    from social media, or types it directly into the web address bar.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*初始加载* 是用户首次与您的网站互动的时刻。这意味着用户首次在谷歌搜索或社交媒体中点击您的网站链接，或者直接在网页地址栏中输入它。'
- en: '|  |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The first load on the browser begins as soon as the HTML response from the server
    is received and the DOM is able to be processed. At this point, single-page application
    flow takes over, and the app responds to user input, browser events, and timers.
    The user can add products to their cart, navigate around the site, and interact
    with forms.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器的首次加载开始于从服务器接收 HTML 响应并且 DOM 能够被处理的那一刻。在此点，单页应用程序流程接管，应用程序响应用户输入、浏览器事件和计时器。用户可以向购物车添加产品、在网站上导航，并与表单交互。
- en: '**7**.  The browser renders the markup received from the server.'
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**7**.  浏览器渲染从服务器接收到的标记。'
- en: '**8**.  The application is now able to respond to user input.'
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**8**.  应用程序现在能够响应用户输入。'
- en: '**9**.  When the user adds an item to their cart, the code responds and runs
    any business logic necessary.'
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**9**.  当用户将项目添加到购物车时，代码会响应并运行必要的业务逻辑。'
- en: '**10**.  If required, the browser talks to the back end to fetch data.'
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**10**.  如果需要，浏览器会与后端通信以获取数据。'
- en: '**11**.  React renders the components.'
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**11**.  React 渲染组件。'
- en: '**12**.  Updates are made, and any repaints are executed. For instance, the
    user’s cart icon updates to show that an item has been added.'
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**12**.  进行更新，并执行任何必要的重绘。例如，用户的购物车图标更新以显示已添加项目。'
- en: '**13**.  Each time the user interacts with the app, steps 9–12 repeat.'
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**13**.  每次用户与应用程序互动时，步骤 9–12 会重复。'
- en: 1.2.2\. Handling the server-side request
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.2\. 处理服务器端请求
- en: Now let’s take a closer look at what happens when the server receives the initial
    request to render the page. Look at what part of the site renders on the server.
    [Figure 1.4](kindle_split_011_split_002.xhtml#ch01fig04) is similar to [figure
    1.1](kindle_split_011_split_001.xhtml#ch01fig01), except that it doesn’t render
    the Twitter widget. The Twitter widget is designed to be loaded in the browser,
    so it doesn’t render on the server.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更详细地看看当服务器接收到渲染页面的初始请求时会发生什么。看看在服务器上渲染的网站部分。[图 1.4](kindle_split_011_split_002.xhtml#ch01fig04)
    与 [图 1.1](kindle_split_011_split_001.xhtml#ch01fig01) 类似，但它的 Twitter 小部件没有渲染。Twitter
    小部件设计为在浏览器中加载，因此它不会在服务器上渲染。
- en: Figure 1.4\. The server-rendered version of the All Things Westies homepage
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.4\. All Things Westies 首页的服务器渲染版本
- en: '![](Images/01fig04_alt.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/01fig04_alt.jpg)'
- en: The server does three important things. First, it fetches the data required
    for the view. Then it takes that data and uses it to render the DOM. Finally,
    it attaches that data to the DOM so the browser can read in the app state. [Figure
    1.5](kindle_split_011_split_002.xhtml#ch01fig05) shows the flow on the server.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器执行三项重要任务。首先，它获取视图所需的数据。然后，它使用这些数据来渲染 DOM。最后，它将数据附加到 DOM 上，以便浏览器可以读取应用程序状态。[图
    1.5](kindle_split_011_split_002.xhtml#ch01fig05) 展示了服务器上的流程。
- en: Figure 1.5\. App flow for the initial server render
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.5\. 初始服务器渲染的应用程序流程
- en: '![](Images/01fig05_alt.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/01fig05_alt.jpg)'
- en: 'Let’s step through the flow:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步分析流程：
- en: '**1**.  The server receives a request.'
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**.  服务器接收请求。'
- en: '**2**.  The server fetches the required data for that request. This can be
    from either a persistent data store such as a MySQL or NoSQL database or from
    an external API.'
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**.  服务器获取该请求所需的所需数据。这可以来自持久数据存储，如 MySQL 或 NoSQL 数据库，或来自外部 API。'
- en: '**3**.  After the data is received, the server can build the HTML. It generates
    the markup with React’s virtual DOM via React’s `renderToString` method.'
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**.  在接收到数据后，服务器可以构建 HTML。它通过 React 的 `renderToString` 方法使用 React 的虚拟 DOM
    生成标记。'
- en: '**4**.  The server injects the data from step 2 into your HTML so the browser
    can access it later.'
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**.  服务器将步骤 2 中的数据注入到您的 HTML 中，以便浏览器稍后可以访问它。'
- en: '**5**.  The server responds to the request with your fully built HTML.'
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**5**. 服务器以你完全构建的HTML响应请求。'
- en: 1.2.3\. Rendering in the browser
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.3\. 浏览器中的渲染
- en: 'Now let’s look more closely at what happens in the browser. [Figure 1.6](kindle_split_011_split_002.xhtml#ch01fig06)
    shows the flow in the browser, from the point the browser receives the HTML to
    the point it bootstraps the app:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们更详细地看看浏览器中发生了什么。[图1.6](kindle_split_011_split_002.xhtml#ch01fig06)显示了浏览器中的流程，从浏览器接收HTML到引导应用的过程：
- en: '**1**.  The browser starts to render the mugs page immediately because the
    HTML sent by the server is fully formed with all the content you generated on
    the server. This includes the header and the footer of your app along with the
    list of mugs for purchase. *The app won’t respond to user input yet. Things like
    adding a mug to the cart or viewing the detail page for a specific mug won’t work.*'
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 浏览器立即开始渲染茶杯页面，因为服务器发送的HTML已经完全形成，包含了你在服务器上生成的所有内容。这包括应用的页眉和页脚以及可购买的茶杯列表。*应用目前不会响应用户输入。像将茶杯添加到购物车或查看特定茶杯的详细页面这样的操作将无法工作。*'
- en: '**2**.  When the browser reaches the JavaScript entry for our application,
    the application bootstraps.'
  id: totrans-94
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 当浏览器达到我们应用的JavaScript入口时，应用开始引导。'
- en: '**3**.  The virtual DOM is re-created in React. Because the server sent down
    the app state, this virtual DOM is identical to the current DOM.'
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. React重新创建了虚拟DOM。因为服务器发送了应用状态，这个虚拟DOM与当前的DOM相同。'
- en: '**4**.  Nothing happens! React finds no differences between the DOM and the
    virtual DOM it built (the virtual DOM is explained in depth in [chapter 3](kindle_split_014_split_000.xhtml#ch03)).
    The user is already being shown the list of mugs in the browser. *The application
    can now respond to user input, such as adding a mug to the cart.*'
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**. 没有发生任何事！React没有在DOM和它构建的虚拟DOM之间找到差异（虚拟DOM在[第3章](kindle_split_014_split_000.xhtml#ch03)中有详细解释）。用户已经在浏览器中看到了茶杯列表。*现在应用可以响应用户输入，例如将茶杯添加到购物车。*'
- en: Figure 1.6\. Browser render and bootstrap—between steps 1 and 4, the app won’t
    respond to user input.
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.6\. 浏览器渲染和引导—在第1步和第4步之间，应用不会响应用户输入。
- en: '![](Images/01fig06_alt.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/01fig06_alt.jpg)'
- en: This is when the single-page application flow kicks in again. This is the most
    straightforward part. It handles user events, makes XHR calls, and updates the
    application as needed.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这时，单页应用流程再次启动。这是最直接的部分。它处理用户事件，进行XHR调用，并根据需要更新应用。
- en: 1.3\. Advantages of isomorphic app architecture
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3\. 同构应用架构的优势
- en: 'At this point, you may be thinking this sounds complicated. You may be wondering
    why this approach to building a web app would ever be worth it. There are several
    compelling reasons to go down this path:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可能觉得这听起来很复杂。你可能想知道为什么这种构建Web应用的方法会值得。有多个令人信服的理由选择这条路径：
- en: Simplified and improved SEO—bots and crawlers can read all the data on page
    load.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简化和改进的SEO—爬虫和爬虫可以在页面加载时读取所有数据。
- en: Performance gains in user-perceived performance.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户感知的性能提升。
- en: Maintenance gains.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护收益。
- en: Improved accessibility because the user can view the app without JavaScript.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高可访问性，因为用户可以在没有JavaScript的情况下查看应用。
- en: Isomorphic app architecture also has challenges and trade-offs. There’s increased
    complexity in managing and deploying code running in multiple environments. Debugging
    and testing are more complicated. Server-rendered HTML via Node.js and React can
    be slow for views that have many components. For example, a page that displays
    many items for sale might quickly end up with hundreds of React components. As
    this number increases, the speed at which React can build these components on
    the server declines. First, I’ll cover the benefits of building an isomorphic
    app. Let’s start by discussing SEO.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 同构应用架构也面临挑战和权衡。在管理和部署在多个环境中运行的代码时，复杂性增加。调试和测试更加复杂。通过Node.js和React服务器渲染的HTML对于具有许多组件的视图可能会很慢。例如，显示许多销售项目的页面可能会迅速变成数百个React组件。随着这个数字的增加，React在服务器上构建这些组件的速度会下降。首先，我将介绍构建同构应用的优点。让我们从讨论SEO开始。
- en: 1.3.1\. SEO benefits
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.1\. SEO优势
- en: Our example app, All Things Westies, is an e-commerce site, so to be successful
    it needs shoppers! And it needs good SEO to maximize the number of people who
    come to the app from search engines. Single-page applications are difficult for
    search-engine bots to crawl because they don’t load the data for the app until
    after the JavaScript has run in the browser. Isomorphic apps also need to bootstrap
    after JavaScript is run, but because their content is rendered by the server,
    neither users nor bots have to wait for the application to bootstrap in order
    to see the content of the site.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例应用“所有西施犬”，是一个电子商务网站，因此为了成功，它需要购物者！并且它需要良好的SEO来最大化从搜索引擎来到应用的人数。单页应用对搜索引擎爬虫来说很难爬取，因为它们在浏览器中的JavaScript运行之后才会加载数据。同构应用在JavaScript运行后也需要引导启动，但由于它们的内容是由服务器渲染的，用户和爬虫都不需要等待应用引导启动才能看到网站的内容。
- en: '|  |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Definition
  id: totrans-110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义
- en: '*Bootstrapping* an application means running the code required to get everything
    set up. This code is run only once on the initial load of the application and
    is run from the entry point of the browser application.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*引导启动*一个应用意味着运行设置好一切所需的代码。此代码仅在应用的初始加载时运行一次，并从浏览器应用的入口点运行。'
- en: '|  |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: On the All Things Westies app, you want to make sure all the SEO-relevant content
    is fetched on the server so you don’t rely on the SEO crawlers to try to render
    your page. Crawlers (both searchbots such as Google or Bing and sharebots such
    as Facebook) either can’t run all this code or don’t want to wait long enough
    for this code to run. For example, Google will try to run JavaScript but penalizes
    sites that take too long for the content to load. That can be seen in the warning
    shown in [figure 1.7](kindle_split_011_split_003.xhtml#ch01fig07). This warning
    shows up when you enter a URL for a single-page application into the Google PageSpeed
    Insights tool.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在All Things Westies应用上，您想要确保所有与SEO相关的内容都在服务器上获取，这样您就不依赖于SEO爬虫尝试渲染您的页面。爬虫（无论是谷歌或必应等搜索引擎爬虫还是Facebook等分享爬虫）要么无法运行所有这些代码，要么不愿意等待足够长的时间来运行这些代码。例如，谷歌会尝试运行JavaScript，但会惩罚加载内容过慢的网站。这可以在[图1.7](kindle_split_011_split_003.xhtml#ch01fig07)中显示的警告中看到。当您将单页应用的URL输入到Google
    PageSpeed Insights工具中时，就会出现这个警告。
- en: Figure 1.7\. Google PageSpeed Insights presents a warning for a single-page
    application. The application makes too many AJAX calls to fetch visible content
    after the initial load of the page.
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.7\. Google PageSpeed Insights为单页应用提供了一个警告。该应用在页面初始加载后进行了过多的AJAX调用以获取可见内容。
- en: '![](Images/01fig07_alt.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/01fig07_alt.jpg)'
- en: '|  |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Google PageSpeed Insights tool**'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**Google PageSpeed Insights工具**'
- en: Google’s PageSpeed Insights tool helps measure how your page is doing on a scale
    of 0 to 100\. You get a score for both speed-related issues (size of images, size
    of JavaScript, magnification, round trips made, and so forth) and UI (size of
    click areas, for example). Test it on your web app at [https://developers.google.com/speed/pagespeed/insights](https://developers.google.com/speed/pagespeed/insights).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Google的PageSpeed Insights工具帮助测量您的页面在0到100分的范围内表现如何。您会得到与速度相关的问题（如图片大小、JavaScript大小、放大、往返次数等）和UI（例如点击区域大小）的分数。在您的Web应用上测试它，请访问[https://developers.google.com/speed/pagespeed/insights](https://developers.google.com/speed/pagespeed/insights)。
- en: Google also has the Lighthouse tool (available as a Chrome extension or command-line
    tool), which will run an in-depth analysis of pages on your site. It makes recommendations
    on everything from performance, to using service workers to allow offline use,
    to improved accessibility for screen readers. You can learn more about Lighthouse
    at [https://developers.google.com/web/tools/lighthouse/](https://developers.google.com/web/tools/lighthouse/).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Google还有一个Lighthouse工具（作为Chrome扩展或命令行工具提供），它将对您网站上的页面进行深入分析。它对性能、使用服务工作者以允许离线使用、提高屏幕阅读器的可访问性等方面提出建议。您可以在[https://developers.google.com/web/tools/lighthouse/](https://developers.google.com/web/tools/lighthouse/)了解更多关于Lighthouse的信息。
- en: '|  |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: If you don’t deal with this warning, you may end up with a lower ranking and
    fewer customers. Also, there’s no guarantee that any page content that relies
    on API calls will be run by the crawler. Whole services have popped into existence
    to solve this problem for single-page apps. Dev teams pour time into developing
    systems to crawl and prerender their pages. They then redirect bots to these prerendered
    pages. These systems are complex and brittle to maintain.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有处理这个警告，你可能会得到较低的排名和更少的客户。此外，没有保证任何依赖于API调用的页面内容都会被爬虫运行。为了解决单页应用的问题，已经出现了专门的服务。开发团队投入时间开发系统来爬取和预渲染他们的页面。然后，他们将机器人重定向到这些预渲染的页面。这些系统复杂且脆弱，难以维护。
- en: Personally, I can’t wait for the day when crawlers and bots will be able to
    get to all our content regardless of when the data is fetched (on the server or
    in the browser). Until that day, server-rendering the initial content gives a
    big advantage over single-page application rendering. This is especially true
    for above-the-fold content and any other content that has SEO benefits.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 个人来说，我迫不及待地希望有一天爬虫和机器人能够获取到我们所有的内容，无论数据是在服务器上还是在浏览器中获取。直到那一天，服务器渲染初始内容在单页应用渲染方面具有很大的优势。这对于页眉以上的内容以及任何具有SEO优势的其他内容尤其如此。
- en: '|  |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Definition
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义
- en: '*Above-the-fold* is a term that comes from the newspaper business. It refers
    to all the content that shows on the front page when a newspaper is folded in
    half and sitting on a newsstand. For web apps, this term is used to refer to all
    the content that’s in the viewable area of a user’s screen when the app loads.
    To see below-the-fold content, the user must scroll.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*页眉以上* 是来自报纸行业的术语。它指的是当报纸折叠成一半并放在报摊上时，出现在首页上的所有内容。对于Web应用来说，这个术语用于指代当应用加载时，用户屏幕上可查看区域内的所有内容。要查看页眉以下的内容，用户必须滚动。'
- en: '|  |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In addition to SEO crawlers, many social sites and apps that allow inline website
    previews (for example, Facebook, Twitter, Slack, or WhatsApp), also use bots that
    don’t run JavaScript. These sites assume that all content that’s available to
    build a social card or inline preview will be available on the server-rendered
    page. Isomorphic apps are ideal for handling the social bot use case.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 除了SEO爬虫之外，许多允许内联网站预览的社会网站和应用（例如，Facebook、Twitter、Slack或WhatsApp）也使用不运行JavaScript的机器人。这些网站假设所有可用于构建社交卡片或内联预览的内容都将可在服务器渲染的页面上获得。同构应用非常适合处理社交机器人用例。
- en: At the beginning of this section, I mentioned that both bots and users don’t
    need to wait for the isomorphic application to bootstrap to see the dynamic content.
    Another way to say that is that the perceived performance of isomorphic web apps
    is fast. The next section describes this in detail.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的开始，我提到过，机器人和用户都不需要等待同构应用启动以查看动态内容。另一种说法是，同构Web应用的感知性能很快。下一节将详细描述这一点。
- en: 1.3.2\. Performance benefits
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.2\. 性能优势
- en: Users want to see the content of All Things Westies right away. Otherwise, they’ll
    get impatient and leave before seeing all the products and information being offered.
    Loading an SPA can be a slow experience for a user (especially on mobile phones).
    Even though the browser may connect quickly to your application, it takes time
    to run the startup code and fetch the content, which leaves the user waiting.
    In the best-case scenario, SPAs display loading indicators and messaging for the
    user. In the worst-case scenario, there’s no visual feedback, and the user is
    left wondering whether anything is happening.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 用户希望立即看到All Things Westies的内容。否则，他们会变得不耐烦，在看到所有产品和信息之前就离开。加载SPA对于用户来说可能是一个缓慢的过程（尤其是在手机上）。尽管浏览器可能快速连接到你的应用，但运行启动代码和获取内容需要时间，这会让用户等待。在最佳情况下，SPAs会显示加载指示器和用户消息。在最坏的情况下，没有视觉反馈，用户会感到困惑，不知道是否有什么事情发生。
- en: '[Figure 1.8](kindle_split_011_split_003.xhtml#ch01fig08) shows what All Things
    Westies would look like during the initial rendering if it were a single-page
    application. Instead of seeing all content immediately, you’d see loading spinners
    in all of the content areas.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1.8](kindle_split_011_split_003.xhtml#ch01fig08) 显示了如果All Things Westies是一个单页应用，在初始渲染时的样子。你不会立即看到所有内容，而是在所有内容区域都会看到加载旋转器。'
- en: Figure 1.8\. In a single-page app version of All Things Westies, spinners would
    be shown during the first load instead of the real content.
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.8\. 在All Things Westies的单页应用版本中，第一次加载时会显示旋转器，而不是真实内容。
- en: '![](Images/01fig08_alt.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图片1.8](Images/01fig08_alt.jpg)'
- en: A server-rendered page displays its content (all the HTML, images, CSS, and
    data for your site) to the user as soon as the browser receives and renders the
    HTML. This leads to content being seen by the user several seconds faster than
    in an SPA. Although the site still requires JavaScript to be loaded and executed
    before user interactions can take place, this fast load allows the user to start
    visually processing your content quickly. This is called *perceived performance*.
    The app content is presented to the user quickly. The user isn’t aware that JavaScript
    is being run in the background.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端渲染的页面在浏览器接收并渲染HTML后立即将内容（您网站的所有HTML、图像、CSS和数据）显示给用户。这导致用户比在SPA中看到内容快几秒钟。尽管网站仍然需要在用户交互之前加载和执行JavaScript，但这种快速加载使用户能够快速开始视觉处理您的内容。这被称为*感知性能*。应用内容快速呈现给用户。用户没有意识到后台正在运行JavaScript。
- en: When this process is executed well, the user will never know that the JavaScript
    loaded after the view rendered. For all practical purposes, your user has a great
    experience because they believe the app loaded fast. This greatly reduces the
    need for loading spinners or other waiting states on the first load of the app.
    This leads to happier users. [Figure 1.9](kindle_split_011_split_003.xhtml#ch01fig09)
    demonstrates the differences between SPA and isomorphic apps.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个过程执行得当，用户将永远不会知道在视图渲染之后加载的JavaScript。从所有实际目的来看，用户会有很好的体验，因为他们认为应用加载得很快。这大大减少了在应用首次加载时需要加载旋转器或其他等待状态的需求。这导致用户更加满意。[图1.9](kindle_split_011_split_003.xhtml#ch01fig09)展示了单页应用和同构应用之间的差异。
- en: Figure 1.9\. Comparison of when the user sees the content of a web app. An isomorphic
    app displays its content much sooner than a single-page app.
  id: totrans-136
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.9. 用户看到Web应用内容时的比较。同构应用比单页应用更早地显示其内容。
- en: '![](Images/01fig09_alt.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片1.9](Images/01fig09_alt.jpg)'
- en: Now I’ll walk you through the single-page app and isomorphic scenarios in detail.
    You can see these flows in [figure 1.9](kindle_split_011_split_003.xhtml#ch01fig09)
    as well.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我将详细向您介绍单页应用和同构场景。您也可以在[图1.9](kindle_split_011_split_003.xhtml#ch01fig09)中看到这些流程。
- en: First, look at example 1\. Imagine going to our example web app and being shown
    a blank screen for six seconds. What would you do? How likely are you to get frustrated
    and give up on using that web app? If you were looking to buy a pair of Westie
    socks, you’d be inclined to give up on All Things Westies and take your business
    elsewhere.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，看看示例1。想象一下，您访问我们的示例Web应用，屏幕上显示空白六秒钟。您会怎么做？您有多可能感到沮丧并放弃使用该Web应用？如果您想买一双威士忌袜子，您可能会放弃All
    Things Westies，并将业务转移到其他地方。
- en: Now imagine that the web app still took six seconds to load (as in example 2),
    but this time it showed you a basic structure (a loading spinner) to let you know
    that the web app is doing something but you can’t interact with it yet, just as
    in [figure 1.8](kindle_split_011_split_003.xhtml#ch01fig08) previously. Are you
    willing to wait for this site to load?
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，Web应用仍然需要六秒钟来加载（如示例2所示），但这次它显示了一个基本结构（一个加载旋转器），让您知道Web应用正在做某事，但您还不能与之交互，就像之前图1.8中所示的那样。您愿意等待这个网站加载吗？
- en: Finally, let’s imagine that when you come to All Things Westies, you see the
    content in under two seconds, as shown in example 3\. This flow matches that of
    [figure 1.1](kindle_split_011_split_001.xhtml#ch01fig01) at the beginning of the
    chapter. This time, your brain starts processing the information as soon as it’s
    displayed. You don’t feel like you had to wait. In the background, the app is
    still loading and working to get everything set up, but you don’t have to wait
    for this to finish before being able to see the content.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们想象一下，当您来到All Things Westies时，内容在两秒钟内显示出来，如图例3所示。这个流程与本章开头图1.1（kindle_split_011_split_001.xhtml#ch01fig01）中的流程相匹配。这次，您的头脑开始处理显示的信息。您感觉不到需要等待。在后台，应用仍在加载并工作以设置一切，但您不需要等待这一切完成才能看到内容。
- en: Notice that the app is able to show content much earlier in the page-load flow.
    Although the page-load time as measured by performance metrics will be the same
    in all three approaches, the user *perceives* the performance of an isomorphic
    app to be much faster.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，该应用能够在页面加载流程中更早地显示内容。尽管所有三种方法中页面加载时间按性能指标衡量将是相同的，但用户*感知*同构应用的性能要快得多。
- en: 1.3.3\. No JavaScript? No problem!
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.3. 没有JavaScript？没问题！
- en: Another user-facing benefit of isomorphic app architecture is that you can serve
    portions of your site without requiring JavaScript. Users who can’t or don’t want
    to run JavaScript can still benefit from using your site when it’s built isomorphically.
    Because you serve a complete page to the browser, users can at least see your
    content despite not being able to interact with the app.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 同构应用程序架构的另一个用户端好处是，你可以不要求JavaScript即可提供网站的部分内容。无法或不想运行JavaScript的用户仍然可以在网站以同构方式构建时从中受益。因为你向浏览器提供了一个完整的页面，用户至少可以看到你的内容，尽管他们无法与应用程序交互。
- en: This allows you to use progressive enhancement to better provide for users across
    a spectrum of browsers and devices. Although it may be unlikely to encounter a
    user with no JavaScript running, there are other good reasons for loading a full
    page from the server. For example, if you support older browsers or devices, isomorphic
    apps are good tools for providing the best experience possible across a multitude
    of browser/device/OS combinations.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这让你能够使用渐进增强来更好地为各种浏览器和设备上的用户提供服务。尽管遇到没有运行JavaScript的用户可能不太可能，但还有其他很好的理由从服务器加载整个页面。例如，如果你支持旧版浏览器或设备，同构应用程序是提供跨多种浏览器/设备/操作系统组合的最佳体验的好工具。
- en: We’ve covered the user-facing benefit of isomorphic apps. Next we’ll look at
    the developer benefits that come with this architecture.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了同构应用程序的用户端好处。接下来，我们将探讨这种架构带来的开发者好处。
- en: 1.3.4\. Maintenance and developer benefits
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.4. 维护和开发者好处
- en: When building an isomorphic app, most of the code can be run on both the server
    and the browser. If you want to render a view, you need to write your code only
    once. If you want to have helper functions for a common task in the app, you need
    to write this logic only once, and it’ll run in both places.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建同构应用程序时，大部分代码可以在服务器和浏览器上运行。如果你想渲染一个视图，你只需要编写一次代码。如果你想为应用程序中的常见任务编写辅助函数，你只需要编写一次这个逻辑，它将在两个地方运行。
- en: This is an advantage over apps that have server-side code written in one language
    and browser code written in JavaScript. Developers can keep their focus without
    having to switch between languages. Builds, environment management, and dependencies
    are all simplified, which makes your overall workflow cleaner.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这比那些服务器端代码用一种语言编写，浏览器端代码用JavaScript编写的应用程序具有优势。开发者可以保持专注，无需在语言之间切换。构建、环境管理和依赖项都得到了简化，这使得你的整体工作流程更加清晰。
- en: This isn’t to say that building isomorphic apps is easy. Writing everything
    in one language comes with its own set of problems.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是说构建同构应用程序很容易。用一种语言编写一切会带来它自己的一套问题。
- en: 1.3.5\. Challenges and trade-offs
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.5. 挑战和权衡
- en: 'Choosing to build an app with isomorphic web architecture isn’t without trade-offs.
    For one, it requires a new way of thinking, which takes time to adjust to. The
    good news is that’s what you’ll learn in this book. Some of the challenges include
    the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 选择使用同构Web架构构建应用程序并非没有权衡。首先，它需要一种新的思维方式，这需要时间来适应。好消息是，这正是本书要教你的内容。其中一些挑战包括以下内容：
- en: Handling the differences between Node.js and the browser
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理Node.js和浏览器之间的差异
- en: Debugging and testing complexity
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试和测试的复杂性
- en: Managing performance on the server
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器上管理性能
- en: Handling the differences between the server and the browser
  id: totrans-156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 处理服务器和浏览器之间的差异
- en: Node.js has no concept of a window or document. The browser doesn’t know about
    Node.js environment variables and has no idea what a request or response object
    is. Both environments know about cookies, but they handle them in different ways.
    In [chapter 10](kindle_split_022_split_000.xhtml#ch10), you’ll look at strategies
    for dealing with these environment tensions.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js没有窗口或文档的概念。浏览器不知道Node.js环境变量，也不知道请求或响应对象是什么。这两个环境都知道cookie，但它们处理它们的方式不同。在第10章中，你将了解处理这些环境紧张关系的策略。
- en: Debugging and testing complexity
  id: totrans-158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 调试和测试的复杂性
- en: 'All your code needs to be tested twice: loaded directly off the server and
    as part of the single-page flow. Debugging requires mastery of both browser and
    server debugging tools and knowing whether a bug is happening on the server, on
    the browser, or in both environments. Additionally, a thorough unit-testing strategy
    is needed, where tests are written and run in the appropriate environments. Server-only
    code should be tested in Node.js, but shared code should be tested in all the
    environments where it’ll eventually be run.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你的所有代码都需要测试两次：直接从服务器加载，以及作为单页流程的一部分。调试需要掌握浏览器和服务器调试工具，并知道错误是在服务器、浏览器还是在两个环境中发生的。此外，还需要一个彻底的单元测试策略，其中测试是在适当的环境中编写和运行的。仅服务器端代码应在Node.js中测试，但共享代码应在它最终运行的任何环境中进行测试。
- en: Managing performance on the server
  id: totrans-160
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 管理服务器端的性能
- en: Performance on the server also presents a challenge as the React-provided `renderToString`
    method is slow to execute on complex pages with many components. In [chapter 11](kindle_split_023_split_000.xhtml#ch11),
    I’ll show you how to optimize your code as much as possible without breaking React
    best practices. We’ll also discuss caching as a tool to minimize issues with server
    performance.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端的性能也提出了挑战，因为React提供的`renderToString`方法在具有许多组件的复杂页面上执行缓慢。在第11章（[kindle_split_023_split_000.xhtml#ch11](https://kindle_split_023_split_000.xhtml#ch11)）中，我将向你展示如何尽可能优化你的代码而不破坏React的最佳实践。我们还将讨论缓存作为减少服务器性能问题的工具。
- en: At this point, you understand the benefits and trade-offs that come with isomorphic
    app architecture. Next let’s take an in-depth look at how to execute an isomorphic
    app.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你已经理解了同构应用架构带来的好处和权衡。接下来，让我们深入探讨如何执行一个同构应用。
- en: 1.4\. Building the view with React
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4. 使用React构建视图
- en: React is one of the pieces that makes building an isomorphic web app possible.
    *React* is a library, open sourced by Facebook, for creating user interfaces (the
    view layer in your app). React makes it easy to express your views via HTML and
    JavaScript. It provides a simple API that’s easy to get up and running but that’s
    designed to be composable in order to facilitate building user interfaces quickly
    and efficiently. Like many other view libraries and implementations, React provides
    a template language (JSX) and hooks into commonly used parts of the DOM and JavaScript.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: React是构建同构Web应用可能性的组成部分之一。*React*是由Facebook开源的用于创建用户界面（应用中的视图层）的库。React通过HTML和JavaScript使表达视图变得容易。它提供了一个简单且易于启动的API，但设计成可组合的，以便快速高效地构建用户界面。像许多其他视图库和实现一样，React提供了一个模板语言（JSX）并钩入DOM和JavaScript的常用部分。
- en: React also takes advantage of functional concepts by adhering to single-direction
    data flows from the top-level component down to its children. What makes it appealing
    for isomorphic apps is how it uses a virtual DOM to manage changes and updates
    to the application.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: React还通过遵循从顶级组件到底层子组件的单向数据流来利用函数式概念。对于同构应用来说，使其吸引人的是它如何使用虚拟DOM来管理应用程序的变化和更新。
- en: React isn’t a framework like Angular or Ember. It only provides the code you
    use to write your view components. It can fit easily into a Model-View-Controller
    (MVC) style architecture as the view. But there’s a recommended way to build complex
    React apps, which is covered throughout the book.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: React不是一个像Angular或Ember那样的框架。它只提供你用来编写视图组件的代码。它可以很容易地适应模型-视图-控制器（MVC）风格的架构作为视图。但书中会介绍构建复杂React应用的推荐方法。
- en: The *virtual DOM* is a representation of the browser DOM written with JavaScript.
    At its core, React is composed of React elements. Since React introduced the virtual
    DOM to the web community, this idea has started to show up in many major libraries
    and frameworks. Some people are even writing their own virtual DOM implementations.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*虚拟DOM*是用JavaScript编写的浏览器DOM的表示。在核心上，React由React元素组成。自从React将虚拟DOM引入到Web社区以来，这个想法已经开始出现在许多主要的库和框架中。甚至有些人正在编写他们自己的虚拟DOM实现。'
- en: Like the browser DOM, the virtual DOM is a tree comprising a root node and its
    child nodes. After the virtual DOM is created, React compares the virtual tree
    to the current tree and calculates the updates it needs to make to the browser
    DOM. If nothing has changed, no update is made. If changes have occurred, React
    updates only the parts of the browser’s DOM that have changed. [Figure 1.10](kindle_split_011_split_004.xhtml#ch01fig10)
    shows what happens at this point. On the left, the virtual DOM has been updated
    to remove the right subtree with the `<div>` tag whose children are an `<img>`
    tag and an `<a>` tag. This results in these same children being removed from the
    browser DOM.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 就像浏览器DOM一样，虚拟DOM是一个由根节点及其子节点组成的树。虚拟DOM创建后，React将虚拟树与当前树进行比较，并计算出需要更新浏览器DOM的更新。如果没有变化，则不进行更新。如果发生了变化，React只更新浏览器DOM中发生变化的部分。[图1.10](kindle_split_011_split_004.xhtml#ch01fig10)展示了这一点。在左侧，虚拟DOM已更新以删除带有`<div>`标签的右子树，其子节点是一个`<img>`标签和一个`<a>`标签。这导致这些相同的子节点从浏览器DOM中删除。
- en: 'Figure 1.10\. Comparing the DOM trees: the virtual DOM changes are compared
    to the browser DOM. Then React intelligently updates the browser DOM tree based
    on the calculated diff.'
  id: totrans-169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.10. 比较DOM树：虚拟DOM的变化与浏览器DOM进行比较。然后React根据计算出的差异智能地更新浏览器DOM树。
- en: '![](Images/01fig10_alt.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图片 1.10](Images/01fig10_alt.jpg)'
- en: 'React uses JavaScript to represent DOM nodes. In JavaScript, this is written
    as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: React使用JavaScript来表示DOM节点。在JavaScript中，这被写成如下所示：
- en: '[PRE0]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When a React render occurs, each component returns a series of React elements.
    Together they form the virtual DOM, a JavaScript representation of the DOM tree.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当React渲染发生时，每个组件返回一系列React元素。它们一起形成虚拟DOM，这是DOM树的JavaScript表示。
- en: Because the virtual DOM is a JavaScript representation of the browser DOM and
    isn’t dependent on browser-provided objects such as the window and document (although
    certain code paths may depend on these items), it can be rendered on the server.
    But rendering a DOM on the server wouldn’t work. Instead, React provides a way
    to output the rendered DOM as a string (`ReactDOM.renderToString`). This string
    can be used to build a complete HTML page that’s served from your server to the
    user.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 由于虚拟DOM是浏览器DOM的JavaScript表示，并且不依赖于浏览器提供的对象（尽管某些代码路径可能依赖于这些项目），它可以在服务器上渲染。但是，在服务器上渲染DOM是不行的。相反，React提供了一种将渲染的DOM作为字符串输出（`ReactDOM.renderToString`）的方法。这个字符串可以用来构建一个完整的HTML页面，该页面从你的服务器发送到用户。
- en: '1.5\. Business logic and model: Redux'
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.5. 商业逻辑和模型：Redux
- en: In real-world web apps, you need a way to manage the data flow. Redux provides
    an application state implementation that works nicely with React. It’s important
    to note that you don’t have to use Redux with React, or vice versa, but their
    concepts mesh well because they both use functional programming ideas. Using Redux
    and React together is also a community best practice.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的Web应用中，你需要一种管理数据流的方法。Redux提供了一个与应用程序状态很好地配合React工作的实现。需要注意的是，你不必在React中使用Redux，反之亦然，但它们的理念相得益彰，因为它们都使用了函数式编程的思想。同时使用Redux和React也是社区的最佳实践。
- en: Like React, Redux follows a single-direction flow of data. Redux holds the state
    of your app in its store, providing a single source of truth for your application.
    To update this store, *actions* (JavaScript objects that represent a discrete
    change of app state) are dispatched from the views. These actions, in turn, trigger
    reducers. *Reducers* are pure functions (a function with no side effects) that
    take in a change and return a new store after responding to the change. [Figure
    1.11](kindle_split_011_split_005.xhtml#ch01fig11) shows this flow.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 与React一样，Redux遵循单方向的数据流。Redux在其存储中保存了应用程序的状态，为你的应用程序提供了一个单一的真实来源。为了更新这个存储，*动作*（代表应用程序状态离散变化的JavaScript对象）从视图中发出。这些动作反过来又触发*还原器*。*还原器*是纯函数（没有副作用的功能），它接受一个变化并返回在响应变化后的新存储。[图1.11](kindle_split_011_split_005.xhtml#ch01fig11)展示了这个流程。
- en: Figure 1.11\. The view (React) uses Redux to update the app state when the user
    takes an action. Redux then lets the view know when it should update based on
    the new app state.
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.11. 视图（React）使用Redux在用户采取动作时更新应用程序状态。Redux然后让视图知道何时根据新的应用程序状态进行更新。
- en: '![](Images/01fig11_alt.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图片 1.11](Images/01fig11_alt.jpg)'
- en: The key thing to remember about Redux is that only reducers can update the store.
    All other components can only read from the store. Additionally, the store is
    immutable. This is enforced via the reducers. I cover this again in [chapter 2](kindle_split_012_split_000.xhtml#ch02)
    and do a full Redux explanation in [chapter 6](kindle_split_017_split_000.xhtml#ch06).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Redux，需要记住的关键点是只有 reducers 可以更新存储。所有其他组件只能从存储中读取。此外，存储是不可变的。这是通过 reducers
    强制执行的。我在[第2章](kindle_split_012_split_000.xhtml#ch02)中再次提到了这一点，并在[第6章](kindle_split_017_split_000.xhtml#ch06)中进行了完整的
    Redux 解释。
- en: The ability to transfer state between server and browser is important in an
    isomorphic app. Redux’s store provides top-level state. By relying on a single
    root object to hold your application state, you can easily serialize your state
    on the server and send it down to the browser to be deserialized. [Chapter 7](kindle_split_019_split_000.xhtml#ch07)
    covers this topic in more detail. The final piece of the app is the build tool.
    The next section gives an overview of webpack.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在同构应用中，在服务器和浏览器之间传输状态的能力非常重要。Redux 的存储提供顶级状态。通过依赖于单个根对象来保存你的应用程序状态，你可以轻松地将状态序列化在服务器上，并将其发送到浏览器进行反序列化。[第7章](kindle_split_019_split_000.xhtml#ch07)更详细地介绍了这个主题。应用的最后一部分是构建工具。下一节将概述
    webpack。
- en: '1.6\. Building the app: webpack'
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.6\. 构建应用：webpack
- en: Webpack is a powerful build tool that makes packaging code into a single bundle
    easy. It has a plugin system in the form of loaders, allowing simple access to
    tools such as Babel for ES6 compiling or Less/Sass/PostCSS compiling. It also
    lets you package Node.js module code (npm packages) into the bundle that will
    be run in the browser.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack 是一个强大的构建工具，它使得将代码打包成一个单一捆绑包变得容易。它有一个以加载器形式存在的插件系统，允许简单地访问工具，如 Babel
    用于 ES6 编译或 Less/Sass/PostCSS 编译。它还允许你将 Node.js 模块代码（npm 包）打包成将在浏览器中运行的捆绑包。
- en: '|  |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Definition
  id: totrans-185
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义
- en: There are many names for current and future JavaScript versions (ES6, ES2015,
    ES2016, ES7, ES Next). To keep things consistent, I refer to modern JavaScript
    that’s not yet 100% adopted in browsers as *ES6*.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当前和未来的 JavaScript 版本（ES6、ES2015、ES2016、ES7、ES Next）有许多名称。为了保持一致性，我将尚未在浏览器中完全采用的现代
    JavaScript 称为 *ES6*。
- en: '|  |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: This is key for our isomorphic app. By using webpack, you can bundle all your
    dependencies together and take advantage of the ecosystem of libraries available
    via npm, the Node package manager. This allows you to share nearly all the code
    in your app with both environments—the browser and the server.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于我们的同构应用至关重要。通过使用 webpack，你可以将所有依赖项捆绑在一起，并利用 npm（Node 包管理器）提供的库生态系统。这允许你几乎在两个环境中共享应用程序中的所有代码——浏览器和服务器。
- en: '|  |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-190
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You won’t use webpack for our Node.js code. That’s unnecessary, as you can write
    most ES6 code on Node.js, and Node.js can already take advantage of environment
    variables and npm packages.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你不会为我们的 Node.js 代码使用 webpack。这是不必要的，因为你可以编写大多数 ES6 代码，Node.js 已经可以利用环境变量和 npm
    包。
- en: '|  |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Webpack also lets you use environment variables inside your bundled code. This
    is important for our isomorphic app. Although you want to share as much code between
    environments as possible, some code from the browser can’t run on the server,
    and vice versa. On a Node.js server, you can take advantage of an environment
    variable like this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack 还允许你在捆绑代码中使用环境变量。这对于我们的同构应用非常重要。尽管你希望尽可能在两个环境中共享代码，但浏览器中的一些代码在服务器上无法运行，反之亦然。在
    Node.js 服务器上，你可以利用这样的环境变量：
- en: '[PRE1]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: But this code won’t run in the browser because it has no concept of Node.js
    environment variables. You can use webpack to inject a `NODE_ENV` object into
    your webpacked code, so this code can run in both environments. [Chapter 5](kindle_split_016_split_000.xhtml#ch05)
    covers this concept in depth.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 但这段代码在浏览器中无法运行，因为它没有 Node.js 环境变量的概念。你可以使用 webpack 将一个 `NODE_ENV` 对象注入到你的 webpacked
    代码中，这样这段代码就可以在两种环境中运行。[第5章](kindle_split_016_split_000.xhtml#ch05)深入介绍了这个概念。
- en: Summary
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned that isomorphic web apps are the result of combining
    server-rendered HTML pages with single-page application architecture. Doing so
    has several advantages but does require learning a new way of thinking about web
    app architecture. The next chapter presents a high-level overview of an isomorphic
    application.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解到同构 Web 应用是服务器渲染的 HTML 页面与单页应用架构相结合的结果。这样做有几个优点，但确实需要学习一种新的关于 Web 应用架构的思考方式。下一章将提供一个同构应用的概述。
- en: Isomorphic web apps blend server-side architecture and single-page app architecture
    to provide a better overall experience for users. This leads to improved perceived
    performance, simplified SEO, and developer benefits.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同构 Web 应用将服务器端架构和单页应用架构结合起来，为用户提供更好的整体体验。这导致感知性能的提高、SEO 的简化以及开发者的好处。
- en: Being able to run JavaScript on the server (Node.js) and in the browser allows
    you to write code once and deploy it to both environments. React’s virtual DOM
    lets you render HTML on the server.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够在服务器（Node.js）和浏览器中运行 JavaScript 允许你编写一次代码，并将其部署到两个环境中。React 的虚拟 DOM 允许你在服务器上渲染
    HTML。
- en: Redux helps you manage application state and easily serialize this state to
    be sent from the server to the browser.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux 帮助你管理应用程序状态，并轻松地将此状态序列化以从服务器发送到浏览器。
- en: By building your app with webpack, you can use Node.js code in the browser and
    flag code to run only in the browser.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用 webpack 构建你的应用程序，你可以在浏览器中使用 Node.js 代码，并标记代码仅在浏览器中运行。
- en: Chapter 2\. A sample isomorphic app
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 2 章\. 一个同构应用的示例
- en: '*This chapter covers*'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Setting up your build to work on the server and the browser
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置你的构建以在服务器和浏览器上工作
- en: Rendering the views
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染视图
- en: Fetching data with Redux
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Redux 获取数据
- en: Handling the request on the server
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器上处理请求
- en: Serializing the data on the server
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器上序列化数据
- en: Deserializing the data on the browser
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在浏览器中反序列化数据
- en: In this chapter, I’m going to walk you through all the key parts of an isomorphic
    app built with React, Redux, Babel, and webpack. Think of this chapter as an opportunity
    to dip your feet in before taking the full plunge. You won’t need to understand
    all the details, but by the end you’ll have a sense of how all the pieces fit
    into the app, and that will provide you context for working through the rest of
    the book.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将带你了解使用 React、Redux、Babel 和 webpack 构建的同构应用程序的所有关键部分。将本章视为在全面投入之前试水的机会。你不需要理解所有细节，但到本章结束时，你将有一个关于所有组件如何融入应用程序的感觉，这将为你理解本书的其余部分提供背景。
- en: If you’re already proficient in building React apps, this chapter along with
    [chapters 7](kindle_split_019_split_000.xhtml#ch07) and [8](kindle_split_020_split_000.xhtml#ch08)
    will get you started. If you’re not already comfortable with React, I’ll take
    you through React and the other building blocks for the app in [chapters 3](kindle_split_014_split_000.xhtml#ch03)
    through [6](kindle_split_017_split_000.xhtml#ch06).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经精通构建 React 应用程序，那么本章以及[第 7 章](kindle_split_019_split_000.xhtml#ch07)和[第
    8 章](kindle_split_020_split_000.xhtml#ch08)将帮助你入门。如果你对 React 还不熟悉，我将在[第 3 章](kindle_split_014_split_000.xhtml#ch03)至[第
    6 章](kindle_split_017_split_000.xhtml#ch06)中带你了解 React 和应用程序的其他构建块。
- en: '2.1\. What you’ll build in this chapter: recipes example app'
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1\. 本章将构建的内容：食谱示例应用
- en: First, let’s look at the app you’ll build in this chapter. [Figure 2.1](kindle_split_012_split_001.xhtml#ch02fig01)
    shows the recipes app you’ll construct. In this chapter, you’ll build the homepage
    for the app, which will show a list of top recipes and a featured recipe. Getting
    all the pieces of your first isomorphic app together is an involved process, so
    for your first pass at building an isomorphic app, I’ll keep the end goal simple.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看你将在本章中构建的应用程序。[图 2.1](kindle_split_012_split_001.xhtml#ch02fig01)显示了你要构建的食谱应用程序。在本章中，你将构建应用程序的主页，它将显示顶级食谱和特色食谱。将你的第一个同构应用程序的所有组件组合在一起是一个复杂的过程，因此对于构建同构应用程序的第一次尝试，我将保持最终目标简单。
- en: Figure 2.1\. The home screen for the recipes app you’ll build in this chapter
  id: totrans-214
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.1\. 你将在本章中构建的食谱应用的主屏幕
- en: '![](Images/02fig01_alt.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig01_alt.jpg)'
- en: This app will have a single route and won’t handle any user interaction. Isomorphic
    architecture is overly complex for such a simple app, but the simplicity will
    allow me to present the core concepts. In later chapters (starting in [chapter
    4](kindle_split_015_split_000.xhtml#ch04)), I’ll teach you how to build a more
    complex app with routing and user interaction.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用将只有一个路由，不会处理任何用户交互。同构架构对于这样一个简单的应用来说过于复杂，但它的简单性将使我能够展示核心概念。在后面的章节（从[第 4
    章](kindle_split_015_split_000.xhtml#ch04)开始），我将教你如何构建一个更复杂的具有路由和用户交互的应用程序。
- en: 'In [chapter 1](kindle_split_011_split_000.xhtml#ch01), we went over the three
    main steps in an isomorphic app: server render, initial browser render, and single-page
    application behavior. In this chapter, you’ll learn how to create an application
    that can take advantage of this render flow. You’ll build the server, serialize
    the data, hydrate the data on the browser, and render the browser view. [Figure
    2.2](kindle_split_012_split_001.xhtml#ch02fig02) shows how the pieces that you’ll
    build in this chapter fit together.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](kindle_split_011_split_000.xhtml#ch01)中，我们讨论了同构应用中的三个主要步骤：服务器渲染、初始浏览器渲染和单页应用行为。在本章中，你将学习如何创建一个可以利用这种渲染流程的应用程序。你将构建服务器，序列化数据，在浏览器中加载数据，并渲染浏览器视图。[图2.2](kindle_split_012_split_001.xhtml#ch02fig02)展示了本章中你将构建的各个部分是如何组合在一起的。
- en: Figure 2.2\. The application flow you’ll build in this chapter—initial render
    from the server and browser hydration
  id: totrans-218
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.2\. 本章中你将构建的应用程序流程——从服务器和浏览器进行初始渲染
- en: '![](Images/02fig02_alt.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/02fig02_alt.jpg)'
- en: '|  |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Definition
  id: totrans-221
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义
- en: '*Serializing* occurs when you take JSON and turn it into a string. This string
    is easy to send between applications and can be sent to the browser as part of
    the server response. *Hydrating* (or *deserializing*) the data means taking the
    string and converting it back into a JSON object that can be used by the app in
    the browser.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '*序列化*发生在你将JSON转换为字符串时。这个字符串易于在应用程序之间发送，可以作为服务器响应的一部分发送到浏览器。*加载数据*（或*反序列化*）意味着将字符串转换回一个可以被浏览器中的应用程序使用的JSON对象。'
- en: '|  |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '2.1.1\. Building blocks: libraries and tools'
  id: totrans-224
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.1\. 构建块：库和工具
- en: 'To write the recipes app and make it run as an isomorphic app, you’ll use several
    JavaScript libraries:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写食谱应用程序并使其作为同构应用程序运行，你将使用几个JavaScript库：
- en: '***Babel and webpack*—** Compilation and build tools. Babel will compile the
    code into a version understood by the JavaScript compiler regardless of browser
    implementation. Webpack will allow you to bundle code for the browser, including
    libraries that are installed via npm (Node packet manager).'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Babel和webpack*—** 编译和构建工具。Babel将代码编译成JavaScript编译器可以理解的版本，无论浏览器实现如何。Webpack将允许你为浏览器捆绑代码，包括通过npm（Node包管理器）安装的库。'
- en: '***Express*—** Enables simple server-side routing for rendering the view.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Express*—** 使服务器端路由简单化，用于渲染视图。'
- en: '***React and Redux*—** The view and the business logic. You’ll write your React
    components using a template language called JSX, which is the standard for React.
    It looks a lot like HTML but allows you to insert logic and variables into your
    view code.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***React和Redux*—** 视图和业务逻辑。你将使用名为JSX的模板语言编写你的React组件，这是React的标准。它看起来很像HTML，但允许你在视图代码中插入逻辑和变量。'
- en: '***Semantic UI*—** Simplify the CSS by providing a standard set of classes.
    The focus of this book isn’t CSS, so this will make following along in the various
    examples easier.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Semantic UI*—** 通过提供一组标准的类来简化CSS。本书的重点不是CSS，这将使你在各种示例中更容易跟随。'
- en: '|  |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Semantic UI for layout and CSS**'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**Semantic UI用于布局和CSS**'
- en: Semantic UI is a CSS library that provides basic styling and predefined layouts,
    components, and grids. I’ve used Semantic UI’s CSS for the layout in the view
    for the recipes example app. Documentation on Semantic UI can be found at [http://semantic-ui.com](http://semantic-ui.com).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Semantic UI是一个CSS库，它提供了基本的样式和预定义的布局、组件和网格。我在食谱示例应用的视图布局中使用了Semantic UI的CSS。有关Semantic
    UI的文档可以在[http://semantic-ui.com](http://semantic-ui.com)找到。
- en: '|  |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Before you get started building and running the code, let’s look at what parts
    of the code run on the server, on the browser, and on both environments. [Figure
    2.3](kindle_split_012_split_001.xhtml#ch02fig03) maps the various parts of the
    app (React components, Redux actions and reducers, entry points for the server
    and browser) to the environments they run in. Some code (for example, React and
    Redux) will run in both environments. Other code is specific to either the server
    or browser (for example, Express for the server).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始构建和运行代码之前，让我们看看代码的哪些部分在服务器上运行，哪些部分在浏览器上运行，以及哪些部分在两个环境中都运行。[图2.3](kindle_split_012_split_001.xhtml#ch02fig03)将应用程序的各个部分（React组件、Redux动作和减少器、服务器和浏览器的入口点）映射到它们运行的相应环境中。一些代码（例如React和Redux）将在两个环境中运行。其他代码是针对服务器或浏览器的特定代码（例如，Express用于服务器）。
- en: Figure 2.3\. An overview of how the various libraries and build tools are used
    across the two environments the code runs in (server and browser). The files listed
    here can be found in the code example. See the next section for instructions on
    downloading the code.
  id: totrans-235
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.3\. 概述了各种库和构建工具如何在代码运行的两个环境中（服务器和浏览器）中使用。这里列出的文件可以在代码示例中找到。下一节将提供下载代码的说明。
- en: '![](Images/02fig03_alt.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig03_alt.jpg)'
- en: The diagram also demonstrates what build tools are used for which environments.
    Webpack will be used to build only the browser code. The server code will be built
    with npm scripts. Babel is used in both environments.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图表还演示了哪些构建工具用于哪些环境。Webpack将用于构建仅浏览器代码。服务器代码将使用npm脚本来构建。Babel在两个环境中都使用。
- en: 2.1.2\. Download the example code
  id: totrans-238
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.2\. 下载示例代码
- en: You can download the code for this example from GitHub at [https://github.com/isomorphic-dev-js/chapter2-a-sample-isomorphic-app.git](https://github.com/isomorphic-dev-js/chapter2-a-sample-isomorphic-app.git).
    I recommend you do so, as all the required packages and code are already set up
    for you, and you can easily follow along.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从GitHub下载此示例的代码：[https://github.com/isomorphic-dev-js/chapter2-a-sample-isomorphic-app.git](https://github.com/isomorphic-dev-js/chapter2-a-sample-isomorphic-app.git)。我建议您这样做，因为所有必需的包和代码都已经为您设置好了，您可以轻松地跟随操作。
- en: 'To check out the code from GitHub, run the following command inside the directory
    you want to clone the project into:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 要从GitHub检查代码，请在您想要克隆项目的目录中运行以下命令：
- en: '[PRE2]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '|  |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-243
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you need help getting started with Git, *Learn Git in a Month of Lunches*
    by Rick Umali (Manning, 2015) is a good resource.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要帮助开始使用Git，Rick Umali的《一个月午餐时间学习Git》（Manning, 2015）是一本很好的资源。
- en: '|  |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Look at the key folders and files in the app. [Figure 2.4](kindle_split_012_split_001.xhtml#ch02fig04)
    shows the core folder structure of the app (other files and folders are also in
    the repo, but the figure calls out what’s relevant for this chapter). You can
    map this to the environments shown in [figure 2.3](kindle_split_012_split_001.xhtml#ch02fig03).
    The entry points for the server (app.es6) and the browser (main.jsx) are of particular
    importance because all the code that’s environment specific will go in these files.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 查看应用中的关键文件夹和文件。[图2.4](kindle_split_012_split_001.xhtml#ch02fig04)显示了应用的核心文件夹结构（其他文件和文件夹也位于仓库中，但图表指出了本章相关的部分）。您可以将这些映射到[图2.3](kindle_split_012_split_001.xhtml#ch02fig03)中显示的环境。服务器（app.es6）和浏览器（main.jsx）的入口点尤为重要，因为所有特定于环境的代码都将放入这些文件中。
- en: Figure 2.4\. Folder organization and top-level build and configuration files.
    A subset view of the folder structure for the recipes app that shows what files
    pertain to build and tools, the server, and the browser.
  id: totrans-247
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.4\. 文件夹组织以及顶级构建和配置文件。食谱应用的文件夹结构子集视图，显示了哪些文件与构建和工具、服务器和浏览器相关。
- en: '![](Images/02fig04_alt.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig04_alt.jpg)'
- en: 2.2\. Tools
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2\. 工具
- en: After you’ve cloned the repo, it’s time to run the app. The code for this chapter
    includes a simple Node.js server that will render the recipes app homepage. The
    Node.js server will also serve up the data for the recipes. For this example,
    the recipes will be loaded from a JSON file. In the real world, you’d want to
    use a database or API to be able to persist the data.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在您克隆了仓库之后，就是时候运行应用了。本章的代码包括一个简单的Node.js服务器，该服务器将渲染食谱应用的首页。Node.js服务器还将提供食谱数据。在这个例子中，食谱将从JSON文件中加载。在现实世界中，您可能希望使用数据库或API来持久化数据。
- en: 'To get everything up and running for the recipes app, you’ll learn about the
    following:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让食谱应用正常运行，您将学习以下内容：
- en: Setting up the development environment and installing packages with npm
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用npm设置开发环境和安装包
- en: Compiling and running the server code with Babel
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Babel编译和运行服务器代码
- en: Building the browser code with webpack
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用webpack构建浏览器代码
- en: Handling multiple code entry points
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理多个代码入口点
- en: 2.2.1\. Setting up the environment and installing packages
  id: totrans-256
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.1\. 设置环境和安装包
- en: You’ll be using Node.js to run the web server. It’s suitable for many use cases
    but especially good for isomorphic apps, as it allows you to write the entire
    stack of the application in JavaScript.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用Node.js来运行Web服务器。它适用于许多用例，但特别适合同构应用，因为它允许您使用JavaScript编写整个应用栈。
- en: '|  |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Node.js download and docs**'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '**Node.js下载和文档**'
- en: This chapter assumes that you have basic familiarity with Node.js and have already
    installed it on your machine. To get the latest version of Node.js and stay up-to-date
    on the docs, visit [https://nodejs.org](https://nodejs.org). Node.js comes with
    npm.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设您对 Node.js 有基本的了解，并且已经将其安装到您的机器上。要获取 Node.js 的最新版本并保持文档更新，请访问 [https://nodejs.org](https://nodejs.org)。Node.js
    随 npm 一起提供。
- en: I’m running Node.js version 6.9.2\. If you run a major version lower than 6,
    you may need additional Babel packages that aren’t covered in this book. If you
    run a major version higher than 6, you may not need all the Babel packages included.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我正在运行 Node.js 版本 6.9.2。如果您运行的版本低于 6 的主要版本，您可能需要额外的 Babel 包，这些包在本书中没有涵盖。如果您运行的版本高于
    6 的主要版本，您可能不需要包含的所有 Babel 包。
- en: '|  |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Before you get started running the server, you need to install all the npm
    packages for this example. You’ll find a list of all npm packages as well as documentation
    for the packages listed in [tables 2.1](kindle_split_012_split_002.xhtml#ch02table01)
    and [2.2](kindle_split_012_split_002.xhtml#ch02table02) at [www.npmjs.com](http://www.npmjs.com).
    The packages needed for the recipes app are already provided in the package.json
    of the project. To install them, run the following command in your terminal:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在您开始运行服务器之前，您需要安装此示例的所有 npm 包。您可以在 [www.npmjs.com](http://www.npmjs.com) 找到所有
    npm 包的列表以及 [表 2.1](kindle_split_012_split_002.xhtml#ch02table01) 和 [2.2](kindle_split_012_split_002.xhtml#ch02table02)
    中列出的包的文档。食谱应用所需的包已在项目的 package.json 中提供。要安装它们，请在您的终端中运行以下命令：
- en: '[PRE3]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Two groups of packages get installed:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 安装两组包：
- en: devDependencies includes build tools such as Babel and webpack. Packages in
    the devDependencies section of package.json don’t get installed when the `NODE_ENV`
    variable is set to `production`. See [table 2.1](kindle_split_012_split_002.xhtml#ch02table01)
    for additional information.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: devDependencies 包含构建工具，如 Babel 和 webpack。当 `NODE_ENV` 变量设置为 `production` 时，package.json
    中的 devDependencies 部分的包不会安装。有关更多信息，请参阅 [表 2.1](kindle_split_012_split_002.xhtml#ch02table01)。
- en: dependencies include any libraries that are required to run the application.
    See [table 2.2](kindle_split_012_split_002.xhtml#ch02table02) for additional information.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: dependencies 包含运行应用程序所需的任何库。有关更多信息，请参阅 [表 2.2](kindle_split_012_split_002.xhtml#ch02table02)。
- en: Table 2.1\. List of devDependencies (for building and compiling the app)
  id: totrans-268
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 2.1\. devDependencies 列表（用于构建和编译应用程序）
- en: '| Package | Description |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| Package | 描述 |'
- en: '| --- | --- |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| babel-core | The main Babel compiler package. More information at [https://babeljs.io](https://babeljs.io).
    |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| babel-core | 主要的 Babel 编译器包。更多信息请访问 [https://babeljs.io](https://babeljs.io)。|'
- en: '| babel-cli | The Babel command-line tool. Used to compile the server code.
    |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| babel-cli | Babel 的命令行工具。用于编译服务器代码。|'
- en: '| babel-loader | Webpack loader for using Babel with webpack. |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| babel-loader | Webpack 用于使用 Babel 与 webpack 的加载器。|'
- en: '| babel-preset-es2015, babel-preset-react, babel-plugin-transform-es2015-destructuring,
    babel-plugin-transform-es2015-parameters, babel-plugin-transform-object-rest-spread
    | Babel has many preset options, so we include the ones relevant to this project.
    These packages include rules for React, ES6, and compiling JSX. |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| babel-preset-es2015, babel-preset-react, babel-plugin-transform-es2015-destructuring,
    babel-plugin-transform-es2015-parameters, babel-plugin-transform-object-rest-spread
    | Babel 有许多预设选项，因此我们包括与本项目相关的选项。这些包包括 React、ES6 和 JSX 编译的规则。|'
- en: '| css-loader | Webpack loader for using CSS inside webpacked files. |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| css-loader | Webpack 用于在 webpacked 文件中使用 CSS 的加载器。|'
- en: '| style-loader | Webpack loader for using CSS inside webpacked files. |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| style-loader | Webpack 用于在 webpacked 文件中使用 CSS 的加载器。|'
- en: '| webpack | A build tool for compiling JavaScript code. Enables the use of
    ES6 and JSX in the browser as well as the use of packages written for Node.js
    (as long as they’re isomorphic). More information at [https://webpack.js.org](https://webpack.js.org).
    |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| webpack | 用于编译 JavaScript 代码的构建工具。使 ES6 和 JSX 在浏览器中使用，以及使用 Node.js 编写的包（只要它们是同构的）。更多信息请访问
    [https://webpack.js.org](https://webpack.js.org)。|'
- en: Table 2.2\. Core dependencies for the recipes app
  id: totrans-278
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 2.2\. 食谱应用的核心依赖
- en: '| Package | Description |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| Package | 描述 |'
- en: '| --- | --- |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| express | A Node.js web framework that provides routing and route-handling
    tools via middleware. More information at [https://github.com/expressjs](https://github.com/expressjs).
    |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| express | 一个提供通过中间件进行路由和路由处理工具的 Node.js 网络框架。更多信息请访问 [https://github.com/expressjs](https://github.com/expressjs)。|'
- en: '| isomorphic-fetch | Enables the use of the fetch API in the browser and the
    server. |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| isomorphic-fetch | 启用在浏览器和服务器中使用 fetch API。|'
- en: '| react | The main React package. More information at [https://facebook.github.io/react/](https://facebook.github.io/react/).
    |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| react | 主要的 React 包。更多信息请访问 [https://facebook.github.io/react/](https://facebook.github.io/react/).
    |'
- en: '| react-dom | The browser- and server-specific DOM-rendering implementations.
    |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| react-dom | 浏览器和服务器特定的 DOM 渲染实现。 |'
- en: '| redux | Core Redux code. |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| redux | 核心Redux代码。 |'
- en: '| react-redux | Provides support to connect React and Redux. |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| react-redux | 为连接 React 和 Redux 提供支持。 |'
- en: '| redux-thunk | Redux middleware. |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| redux-thunk | Redux 中间件。 |'
- en: '| redux-promise-middleware | Redux middleware that supports promises. |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| redux-promise-middleware | 支持承诺的 Redux 中间件。 |'
- en: Open the code in your editor and find the package.json file. You’ll see all
    the libraries listed in the preceding tables. Now that you understand the dependencies
    of the example app, you can set up and run the server.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的编辑器中打开代码并找到 package.json 文件。您将看到前面表格中列出的所有库。现在您已经了解了示例应用的依赖关系，您可以设置并运行服务器。
- en: 2.2.2\. Running the server
  id: totrans-290
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.2\. 运行服务器
- en: 'To get the server running (so you can test the API, as shown in [figure 2.5](kindle_split_012_split_002.xhtml#ch02fig05)),
    you first need to build the server code using Babel. You’re probably wondering
    why you need to compile code for a language that’s interpreted at runtime. This
    step is required for two reasons:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 要使服务器运行（以便您可以测试 API，如图 2.5 所示），您首先需要使用 Babel 构建服务器代码。您可能想知道为什么需要为在运行时解释的语言编译代码。这一步骤需要两个原因：
- en: '***Writing the latest and greatest code with ES6 language features*—** JavaScript
    is also known as ECMAScript (ES). ES6 is a recent version that adds many language
    features, including classes, maps, and promises. Most of the ES6 spec already
    runs on Node.js 6.9.2 or later. But if you want to use upcoming features from
    ES7 (the next version of JavaScript) or use the `import` statement instead of
    `require` statements, a compile is still required. The examples in the book take
    advantage of `import` statements.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***使用 ES6 语言特性编写最新和最优秀的代码*—** JavaScript 也被称为 ECMAScript (ES)。ES6 是一个较新的版本，它添加了许多语言特性，包括类、映射和承诺。ES6
    的大部分规范已经在 Node.js 6.9.2 或更高版本上运行。但如果你想要使用来自 ES7（JavaScript 的下一个版本）的新功能或使用 `import`
    语句而不是 `require` 语句，仍然需要进行编译。本书中的示例利用了 `import` 语句。'
- en: '***Because the server will render components, you’ll need to run JSX on the
    server*—** JSX is the template language that React uses to declare the view. Node.js
    doesn’t understand how to run JSX, so you’ll need to compile the JSX into JavaScript
    before using it on the server. I discuss JSX later in the chapter.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***因为服务器将渲染组件，所以您需要在服务器上运行 JSX*—** JSX 是 React 用于声明视图的模板语言。Node.js 不理解如何运行
    JSX，因此您需要在使用服务器之前将 JSX 编译成 JavaScript。我将在本章后面讨论 JSX。'
- en: Figure 2.5\. Expected output from the recipes API endpoint after the server
    is running
  id: totrans-294
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.5\. 服务器运行后 recipes API 端点的预期输出
- en: '![](Images/02fig05_alt.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig05_alt.jpg)'
- en: '|  |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-297
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: I use two extensions for files in the project instead of .js. For files written
    with ES6, I use the extension .es6 to indicate the need to compile the file with
    Babel. For files that include React components, I use .jsx to indicate the presence
    of a JSX template. This lets us pass only the files we want to the Babel compiler
    and also makes it easy to distinguish between working and compiled files. The
    .jsx extension is also picked up by some editors and IDEs as a signal to use different
    syntax highlighting.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我在项目中使用两种文件扩展名而不是 .js。对于用 ES6 编写的文件，我使用 .es6 扩展名来表示需要使用 Babel 编译文件。对于包含 React
    组件的文件，我使用 .jsx 扩展名来表示存在 JSX 模板。这使得我们只需将想要传递给 Babel 编译器的文件传递过去，同时也使得区分工作文件和编译文件变得容易。.jsx
    扩展名也被一些编辑器和 IDE 识别为使用不同语法高亮的信号。
- en: '|  |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'To build and run the server, you use the Babel tools and configuration that
    are set up in the npm packages. Two additional pieces of code are required to
    make this all work. First, to use Babel, you need a Babel configuration. The best
    way to do that is to create a .babelrc configuration file. Inside .babelrc, I’ve
    called out two presets for the compiler to use: `es2015` and `react`. The following
    listing shows this code, which is already included in the repo.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建和运行服务器，您使用在 npm 包中设置的 Babel 工具和配置。还需要两段额外的代码来使这一切工作。首先，要使用 Babel，您需要一个 Babel
    配置。最好的方法是创建一个 .babelrc 配置文件。在 .babelrc 中，我已经为编译器指定了两个预设：`es2015` 和 `react`。以下列表显示了此代码，该代码已包含在仓库中。
- en: Listing 2.1\. Babel configuration—babelrc
  id: totrans-301
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.1\. Babel 配置—babelrc
- en: '[PRE4]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***1* Packages that contain groups of plugins, making configuration easier
    and quicker**'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 包含包含插件组的包，使配置更容易、更快**'
- en: '***2* Plugins are the base unit in Babel, and each plugin is responsible for
    one type of update.**'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 插件是 Babel 的基本单位，每个插件负责一种更新类型。**'
- en: '***3* Three plugins allow use of spread operator (...) so you can easily work
    with and update objects.**'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 三个插件允许使用扩展运算符 (...)，这样你可以轻松地处理和更新对象。**'
- en: The presets listed here map to the preset packages you installed earlier in
    the chapter. This will ensure that ES6 code and JSX template code are compiled
    properly.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出的预设与你在本章早期安装的预设包相对应。这将确保 ES6 代码和 JSX 模板代码被正确编译。
- en: '|  |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-308
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The babel-cli and related tools are powerful and flexible. Visit [https://babeljs.io](https://babeljs.io)
    to find out what else Babel can do. For example, Babel supports sourcemaps for
    compiled files. Also, if you prefer different build tools, you can use Babel with
    most of the popular JavaScript build tools.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: babel-cli 和相关工具功能强大且灵活。访问 [https://babeljs.io](https://babeljs.io) 了解 Babel
    还能做什么。例如，Babel 支持编译文件的 sourcemaps。此外，如果你更喜欢不同的构建工具，你可以使用 Babel 与大多数流行的 JavaScript
    构建工具一起使用。
- en: '|  |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: As for the other required piece of code, I’ve set up this project to use Babel
    inline in development mode on the server. You don’t have to precompile any of
    the code to have it run on the server. The server.js file is just two lines of
    code. The following listing shows the code, which is already included in the repo.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他所需的代码片段，我已经设置了这个项目在服务器上以开发模式使用 Babel 内联。你不需要预先编译任何代码就可以在服务器上运行它。server.js
    文件只有两行代码。以下列表显示了代码，它已经包含在仓库中。
- en: Listing 2.2\. Running the server with Babel—src/server.js
  id: totrans-312
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.2\. 使用 Babel 运行服务器——src/server.js
- en: '[PRE5]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1* Include Babel—it will parse all code that comes after it (not recommended
    for production use).**'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 包含 Babel——它将解析其后的所有代码（不推荐用于生产环境）。**'
- en: '***2* Include root application code for server.**'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 包含服务器根应用程序代码。**'
- en: 'With everything configured and set up, all you have to do to start the Node.js
    server is run the following:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在一切配置和设置完成后，你只需运行以下命令即可启动 Node.js 服务器：
- en: '[PRE6]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The Node.js server is now running on localhost at port 3000\. Load http://localhost:3000/recipes
    and you’ll see a JSON object with several recipes. Sample output will look like
    the JSON object in [figure 2.5](kindle_split_012_split_002.xhtml#ch02fig05). Remember,
    the server plays two roles in the recipes app: it renders the initial view and
    provides the data API.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 服务器现在正在本地主机 3000 端口上运行。加载 http://localhost:3000/recipes，你将看到一个包含多个菜谱的
    JSON 对象。示例输出将类似于 [图 2.5](kindle_split_012_split_002.xhtml#ch02fig05) 中的 JSON 对象。记住，服务器在菜谱应用中扮演两个角色：它渲染初始视图并提供数据
    API。
- en: Next, we’ll explore how webpack uses Babel to create the browser code.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨 webpack 如何使用 Babel 创建浏览器代码。
- en: 2.2.3\. Building the code for the browser with webpack
  id: totrans-320
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.3\. 使用 webpack 构建浏览器代码
- en: Every time I learn a new build tool, I spend hours being frustrated, wondering
    why I’m ramping up on yet another library that may or may not give me long-term
    workflow improvements. Although webpack has a steep learning curve, the time I
    invested to learn it has been well worth it. Each time I’ve run into something
    new that I need to do with build scripts, I’ve found that webpack can get the
    job done. Additionally, it has a strong community and has become one of the top
    choices for modern web apps.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我学习一个新的构建工具时，我都会花费数小时感到沮丧，想知道为什么我还在学习另一个可能或可能不会给我带来长期工作流程改进的库。尽管 webpack 有一个陡峭的学习曲线，但我投入学习它的时间是非常值得的。每次我遇到需要用构建脚本完成的新任务时，我都会发现
    webpack 可以完成这项工作。此外，它有一个强大的社区，并已成为现代网络应用的首选之一。
- en: 'Webpack is a build tool that you can run from the command line and configure
    via a JavaScript configuration file. It supports a wide range of features:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack 是一个可以从命令行运行并可通过 JavaScript 配置文件进行配置的构建工具。它支持广泛的功能：
- en: Using loaders to compile ES6 and JSX code and load static assets via loaders
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用加载器编译 ES6 和 JSX 代码，并通过加载器加载静态资源
- en: Code splitting for smart bundling of code into smaller packages
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 智能捆绑代码到更小包的代码拆分
- en: Ability to build code for the server or the browser
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够为服务器或浏览器构建代码
- en: Out-of-the-box sourcemaps
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开箱即用的 sourcemaps
- en: The webpack dev server
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Webpack 开发服务器
- en: Built-in watch option
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置的监视选项
- en: 'You’re going to use webpack to build the browser bundle. Unlike on Node.js,
    browser support for the latest version of JavaScript is inconsistent. To write
    code with ES6, I need to compile it into a format the browser can read (ES5).
    Also, as on the server, JSX must be compiled into a format that the JavaScript
    compiler can understand. To do that, you’ll take advantage of the webpack config
    and then run that config via the npm script you saw in the previous section. To
    run the webpack script, you also run this:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用 webpack 来构建浏览器包。与 Node.js 不同，浏览器对最新版 JavaScript 的支持不一致。为了编写 ES6 代码，我需要将其编译成浏览器可以读取的格式（ES5）。同样，在服务器上，JSX
    也必须编译成 JavaScript 编译器可以理解的格式。为此，你将利用 webpack 配置，然后通过上一节中看到的 npm 脚本运行该配置。要运行 webpack
    脚本，你还需要运行以下命令：
- en: '[PRE7]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The package.json includes a prestart script that runs the command for webpack.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: package.json 包含一个预启动脚本，该脚本运行 webpack 命令。
- en: '|  |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-333
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Although it’s possible to build your Node.js server with webpack, that will
    present challenges for building and testing later and require you to run two Node.js
    servers. It’s preferable to use webpack only for building the browser code.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以使用 webpack 构建你的 Node.js 服务器，但这将为构建和测试带来挑战，并需要你运行两个 Node.js 服务器。最好只使用 webpack
    来构建浏览器代码。
- en: '|  |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: As on the server, you’ll use Babel to compile the code. The webpack configuration
    file is located at the top level of the project and is a JavaScript module. The
    code is already included in the repo. The following listing explains how it works.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在服务器上一样，你将使用 Babel 来编译代码。webpack 配置文件位于项目的顶层，是一个 JavaScript 模块。代码已经包含在仓库中。以下列表解释了它是如何工作的。
- en: Listing 2.3\. Webpack configuration—webpack.config.js
  id: totrans-337
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.3\. Webpack 配置—webpack.config.js
- en: '[PRE8]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '***1* Defines input starting point or entry path—file runs only on browser**'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 定义输入起点或入口路径—文件仅在浏览器上运行**'
- en: '***2* Output folder—the dist directory where we build all other files**'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 输出文件夹—构建所有其他文件的 dist 目录**'
- en: '***3* Output filename**'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 输出文件名**'
- en: '***4* Regular expression that tells loader what files to apply loader to**'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 用于告诉加载器应用加载器到哪些文件的正则表达式**'
- en: '***5* Excludes node_modules because these files are already compiled and production
    ready**'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 排除 node_modules，因为这些文件已经编译并准备好用于生产**'
- en: '***6* Defines loader to apply to matched files, for Babel to compile ES6 and
    JSX**'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 定义应用于匹配文件的加载器，以便 Babel 编译 ES6 和 JSX**'
- en: '***7* Supported file extensions—empty file extension allows import statements
    with no extension (your src files have one extension but your compiled files have
    a different one)**'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 支持的文件扩展名—空文件扩展名允许没有扩展名的导入语句（你的源文件有一个扩展名，但编译后的文件有不同的扩展名）**'
- en: 'You can also load any CSS you need via files included in webpack. To do that,
    you need to define a loader that will handle any `require` statements that include
    a .css extension. Because our app is isomorphic and you aren’t using webpack for
    the server, it’s important to include CSS only in files that will be loaded in
    the browser. In this case, the CSS include will be in main.jsx:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过 webpack 包含的文件加载任何所需的 CSS。为此，你需要定义一个加载器来处理包含 .css 扩展名的任何 `require` 语句。因为我们的应用是同构的，而且你没有使用
    webpack 为服务器，所以只包含将在浏览器中加载的文件中的 CSS 很重要。在这种情况下，CSS 包含将在 main.jsx 中：
- en: '[PRE9]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: That’s all you need for now. For a full intro to webpack, make sure to read
    [chapter 5](kindle_split_016_split_000.xhtml#ch05).
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 目前你需要的就是这些。要全面了解 webpack，请确保阅读[第 5 章](kindle_split_016_split_000.xhtml#ch05)。
- en: 2.3\. The view
  id: totrans-349
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3\. 视图
- en: This section and the following pieces explore the specific technologies that
    will be used to wire the app together. [Figure 2.6](kindle_split_012_split_003.xhtml#ch02fig06)
    shows how each piece fits into the app lifecycle.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 本节和以下部分将探讨将应用连接在一起所使用的特定技术。[图 2.6](kindle_split_012_split_003.xhtml#ch02fig06)
    展示了每个部分如何适应应用生命周期。
- en: Figure 2.6\. How React and Redux fit into the application flow
  id: totrans-351
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.6\. React 和 Redux 如何适应应用流程
- en: '![](Images/02fig06_alt.jpg)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig06_alt.jpg)'
- en: The key takeaway here is that the app lifecycle is single directional. Anytime
    the app state is updated, the view receives an update and displays it to the user
    (step 4). When the view receives user input, it notifies the app state (Redux)
    to make an update (step 2). The view doesn’t worry about the implementation of
    the business logic, and app state doesn’t worry about how it’ll be displayed.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要收获是应用的生命周期是单向的。任何时间应用状态更新，视图都会收到更新并将其显示给用户（步骤 4）。当视图接收到用户输入时，它会通知应用状态（Redux）进行更新（步骤
    2）。视图不关心业务逻辑的实现，应用状态也不关心它将如何显示。
- en: 2.3.1\. React and components
  id: totrans-354
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.1\. React 和组件
- en: When building apps, the user interface is the most important piece. I enjoy
    building apps with great UIs. In these apps, users easily find what they’re looking
    for and can interact with the app without frustration. React makes this process
    easier. I find that its concepts map well to the way I think about piecing together
    good UIs.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建应用程序时，用户界面是最重要的部分。我喜欢用具有出色 UI 的应用程序。在这些应用程序中，用户可以轻松找到他们想要的东西，并且可以无挫折地与应用程序交互。React
    使这个过程变得更简单。我发现它的概念很好地映射到我对构建良好 UI 的思考方式。
- en: To build the view for the recipes app, I’ll show you how to take advantage of
    React to implement a declarative view that can be used to render both on the server
    and the browser. React offers a render cycle that allows you to easily separate
    which code will run on both the server and browser and which will run on only
    the browser. Additionally, React comes with built-in methods for constructing
    the DOM on both the server and the browser.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建食谱应用程序的视图，我将向你展示如何利用 React 实现一个声明性视图，该视图可以在服务器和浏览器上渲染。React 提供了一个渲染周期，它允许你轻松地分离哪些代码将在服务器和浏览器上运行，哪些代码只会在浏览器上运行。此外，React
    还提供了在服务器和浏览器上构建 DOM 的内置方法。
- en: First let’s talk about the idea of components. Look at the example app in [figure
    2.7](kindle_split_012_split_003.xhtml#ch02fig07). You could write this whole app
    as just one block of HTML, but it’s best practice to break this UX into small
    components. In the figure, you can see how you’d break up the recipes app into
    components. To keep it simple, I’ve created only three components. In a real app,
    one with many views, I’d create even smaller components to increase my ability
    to compose components together. This also reduces code duplication and speeds
    up development.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们谈谈组件的概念。看看[图 2.7](kindle_split_012_split_003.xhtml#ch02fig07)中的示例应用程序。你可以把这个整个应用程序写成一块
    HTML，但将这个 UX 分解成小的组件是最佳实践。在图中，你可以看到如何将食谱应用程序分解成组件。为了保持简单，我创建了仅三个组件。在一个真实的应用程序中，一个具有许多视图的应用程序，我会创建更小的组件来增加我组合组件的能力。这也减少了代码重复并加快了开发速度。
- en: Figure 2.7\. The recipes app is divided into three main components. By composing
    them together, the app is created.
  id: totrans-358
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.7\. 食谱应用程序被分解成三个主要组件。通过将它们组合在一起，应用程序被创建。
- en: '![](Images/02fig07_alt.jpg)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig07_alt.jpg)'
- en: The way you build components with React is by writing JavaScript modules and
    declaring your view in JSX. The next section provides an introduction to JSX.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用 React 构建组件的方式是通过编写 JavaScript 模块并在 JSX 中声明你的视图。下一节提供了 JSX 的介绍。
- en: 2.3.2\. Using JSX
  id: totrans-361
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.2\. 使用 JSX
- en: 'React uses a template language called JSX. For the most part, JSX looks and
    acts like normal HTML, which makes it easy to learn and use. JSX consists of HTML
    tags (which can also be additional React components) and sections of code that
    are JavaScript. The syntax is presented here:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: React 使用一种名为 JSX 的模板语言。大部分情况下，JSX 看起来和表现就像正常的 HTML，这使得它易于学习和使用。JSX 由 HTML 标签（也可以是额外的
    React 组件）和 JavaScript 代码段组成。语法在此处展示：
- en: '![](Images/0034fig01.jpg)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/0034fig01.jpg)'
- en: You can see that at the point where you reference JavaScript, you must wrap
    your code in `{}`. This indicates to the compiler that the code inside the brackets
    is executable. JSX is compiled by Babel into pure JavaScript. You could write
    your components with the base React functions, but that’s slower and less readable.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，在引用 JavaScript 的点上，你必须将你的代码包裹在 `{}` 中。这向编译器表明，括号内的代码是可执行的。JSX 由 Babel
    编译成纯 JavaScript。你可以使用基本的 React 函数编写你的组件，但这会更慢且可读性较差。
- en: Components can display data passed in via their properties, called *props*.
    Props are similar to HTML attributes and can be written in the opening tag of
    any JSX element. You’ll find more information in [chapter 3](kindle_split_014_split_000.xhtml#ch03),
    which covers JSX and React properties and state.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 组件可以显示通过它们的属性传递进来的数据，这些属性称为 *props*。Props 类似于 HTML 属性，并且可以写在任何 JSX 元素的开始标签中。你可以在[第
    3 章](kindle_split_014_split_000.xhtml#ch03)中找到更多信息，该章节涵盖了 JSX 和 React 的属性和状态。
- en: 'The recipe app has four React components: the component that renders the HTML
    wrapper (used only on the server), the app wrapper component (the root of the
    React tree), and two view components called Featured and Recipes.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 食谱应用程序有四个 React 组件：渲染 HTML 包装器的组件（仅在服务器上使用），应用程序包装组件（React 树的根），以及两个名为 Featured
    和 Recipes 的视图组件。
- en: 2.3.3\. App wrapper component
  id: totrans-367
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.3\. 应用程序包装组件
- en: First, we’ll look at main.jsx and app.jsx to get the root of the app setup.
    If you want to follow along in this section, you can switch branches to the react-components
    branch (`git checkout react-components`). The starting branch for a section provides
    a skeleton sample that you’ll add the code listings into. If you’d like to see
    the complete code for this section, you can switch to the react-components-complete
    branch (`git checkout react-components-complete`).
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将查看main.jsx和app.jsx以获取应用程序设置的根。如果您想在本节中跟随，可以将分支切换到react-components分支（`git
    checkout react-components`）。章节的起始分支提供了一个骨架示例，您将添加代码列表。如果您想查看本节的完整代码，可以将分支切换到react-components-complete分支（`git
    checkout react-components-complete`）。
- en: To render the components in the browser, you need to set up React in main.jsx
    code. The following listing shows you what to add to make the components render
    in the browser. Add the code to src/main.jsx.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 要在浏览器中渲染组件，您需要在main.jsx代码中设置React。以下列表显示了您需要添加的内容以使组件在浏览器中渲染。将代码添加到src/main.jsx中。
- en: Listing 2.4\. Browser entry point—src/main.jsx
  id: totrans-370
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.4\. 浏览器入口点—src/main.jsx
- en: '[PRE10]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '***1* Imports React dependencies**'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入React依赖项**'
- en: '***2* Includes root App component**'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 包含根App组件**'
- en: '***3* Includes styles**'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 包含样式**'
- en: '***4* Renders the App component into the DOM—second parameter indicates the
    DOM element React should be rendered into**'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将App组件渲染到DOM中—第二个参数指示React应渲染到的DOM元素**'
- en: App is a container component. It knows about the business rules and data required
    by its children. More importantly, it’s aware of the application state. In this
    case, that means it will be connected to Redux later in the chapter. The following
    listing shows the App component. Replace the placeholder code in the repo (in
    src/components/app.jsx) with the code from the listing.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: App是一个容器组件。它了解其子组件所需的企业规则和数据。更重要的是，它了解应用程序的状态。在这种情况下，这意味着它将在本章的后面连接到Redux。以下列表显示了App组件。将代码库中的占位符代码（在src/components/app.jsx中）替换为列表中的代码。
- en: Listing 2.5\. App (top-level component)—src/components/app.jsx
  id: totrans-377
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.5\. App（顶级组件）—src/components/app.jsx
- en: '[PRE11]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '***1* To declare a React component that uses state, create a class that extends
    the base component class.**'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 要声明一个使用状态的React组件，创建一个扩展基本组件类的类。**'
- en: '***2* Every component that has a render function, must return either null or
    valid JSX.**'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 每个具有渲染函数的组件必须返回null或有效的JSX。**'
- en: '***3* A component defines the layout of its children.**'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 组件定义其子组件的布局。**'
- en: The App component renders the header and footer but also has two additional
    React components that it includes as children. Recipes displays the list of recipes
    returned from the /recipes endpoint. Featured displays just the featured recipe
    you get back from the server via /featured. These child components require information
    from the parent, which is passed down in the form of properties.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: App组件渲染页眉和页脚，但它还包括两个额外的React组件，它将它们作为子组件包含。Recipes显示从/recipes端点返回的食谱列表。Featured仅显示从服务器通过/featured返回的特色食谱。这些子组件需要从父组件获取信息，这些信息以属性的形式传递下来。
- en: The data being passed down is from the API and is fetched by Redux and stored
    in the app state. Run `npm start` after adding the app.jsx code and you’ll see
    the header, footer, and some placeholder strings for Recipes and Featured at http://localhost:3000/index.html.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 正在传递的数据来自API，并由Redux获取并存储在应用程序状态中。在添加app.jsx代码后运行`npm start`，您将在http://localhost:3000/index.html看到页眉、页脚以及一些用于食谱和特色的占位符字符串。
- en: 2.3.4\. Building child components
  id: totrans-384
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.4\. 构建子组件
- en: The two child components display the properties that are passed into them. They
    don’t have any awareness of other parts of the application such as Redux. This
    makes them reusable and loosely coupled to the business logic in the app. The
    following listing shows the Featured recipe component. Add this code to src/components/featured.jsx,
    replacing the placeholder code.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 两个子组件显示它们接收到的属性。它们对应用程序的其他部分，如Redux，没有任何意识。这使得它们可重用，并且与应用程序中的业务逻辑松散耦合。以下列表显示了特色食谱组件。将此代码添加到src/components/featured.jsx中，替换占位符代码。
- en: Listing 2.6\. Featured component—src/components/featured.jsx
  id: totrans-386
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.6\. 特色组件—src/components/featured.jsx
- en: '[PRE12]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***1* Function converts an array of ingredients into an array of list items;
    this is called from the render function.**'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 函数将配料数组转换为列表项数组；这从渲染函数中调用。**'
- en: '***2* Function takes in the steps array and converts it to a list item, called
    from render function.**'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 函数接收步骤数组并将其转换为列表项，从渲染函数中调用。**'
- en: '***3* Featured component is a container that renders information about the
    featured recipe; it renders a recipe passed in via props.**'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* Featured 组件是一个容器，用于渲染关于特色食谱的信息；它通过 props 渲染传入的食谱。**'
- en: '***4* Function converts an array of ingredients into an array of list items;
    this is called from the render function.**'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 函数将配料数组转换为列表项数组；这从渲染函数中调用。**'
- en: '***5* Function takes in the steps array and converts it to a list item, called
    from render function.**'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 函数接受步骤数组并将其转换为列表项，从渲染函数中调用。**'
- en: '***6* Set properties that are arrays to defaults so if there’s no data, the
    component can still render.**'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 将属性设置为默认值，以便在没有数据的情况下，组件仍然可以渲染。**'
- en: 'After adding this code, you’ll see the featured recipe displayed but without
    data (you haven’t hooked it up to any data yet). There’s one more step to show
    the complete homepage: adding the Recipes component code.'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 添加此代码后，您将看到显示的特色食谱，但没有数据（您还没有将其连接到任何数据）。要显示完整的首页，还需要进行一个步骤：添加 Recipes 组件代码。
- en: The next Recipes component handles more complex data than Featured. It’s similar
    in that it only displays recipes data and has no awareness of the rest of the
    application. The following listing shows the Recipes list component. You’ll add
    this code to src/components/recipes.jsx, replacing the placeholder code.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个 Recipes 组件处理比 Featured 更复杂的数据。它在这一点上与 Featured 类似，因为它只显示食谱数据，并且没有意识到应用程序的其他部分。以下列表显示了
    Recipes 列表组件。您需要将此代码添加到 src/components/recipes.jsx 中，以替换占位符代码。
- en: Listing 2.7\. Recipes component—src/components/recipes.jsx
  id: totrans-396
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.7\. Recipes 组件——src/components/recipes.jsx
- en: '[PRE13]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '***1* Function called from JSX in return statement**'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从 JSX 返回语句中调用的函数**'
- en: '***2* Because you can’t write loops directly in JSX, build an array of items
    that can be rendered by JSX.**'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 因为不能直接在 JSX 中编写循环，所以构建一个可以由 JSX 渲染的项目数组。**'
- en: '***3* Each recipes item is rendered here; data for recipes is passed down via
    props.**'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 每个食谱项在这里渲染；食谱数据通过 props 传递下来。**'
- en: '***4* The render function is a wrapper for the recipes list and has no state,
    like featured component.**'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 渲染函数是食谱列表的包装器，没有状态，就像 featured 组件一样。**'
- en: In both components, the properties are passed in from the parent component.
    These components are updated only if their parent component receives an update.
    That ties into the single-direction flow discussed at the beginning of this section.
    As top-level components receive updates from the app state, they can then pass
    these changes down to their children. Because there’s no data in the app, you
    won’t see a visual change at this point—there are no recipes to render!
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个组件中，属性是从父组件传入的。这些组件只有在它们的父组件收到更新时才会更新。这与本节开头讨论的单向流有关。顶级组件从应用程序状态接收更新后，可以将这些更改传递给它们的子组件。因为应用程序中没有数据，所以您在这个阶段不会看到视觉上的变化——没有要渲染的食谱！
- en: 2.3.5\. HTML container
  id: totrans-403
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.5\. HTML 容器
- en: The final React component is the one that the server uses to render the full
    HTML markup. It’s mostly standard HTML tags but has a couple of spots to insert
    the rendered markup and the data. The following listing shows the full HTML component.
    Add this code to src/components/html.jsx so you have a container to render into
    on the server.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的 React 组件是服务器用来渲染完整 HTML 标记的组件。它主要是标准的 HTML 标签，但有几个地方可以插入渲染的标记和数据。以下列表显示了完整的
    HTML 组件。将此代码添加到 src/components/html.jsx 中，以便在服务器上有一个渲染的容器。
- en: Listing 2.8\. HTML template component (server only)—src/components/html.jsx
  id: totrans-405
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.8\. 服务器端仅使用的 HTML 模板组件——src/components/html.jsx
- en: '[PRE14]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '***1* Component creates a valid HTML page—html, head, body tags included.**'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 组件创建一个有效的 HTML 页面——包括 html、head、body 标签。**'
- en: '***2* CSS referenced from head tag.**'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 从 head 标签引用的 CSS。**'
- en: '***3* Component receives rendered HTML as prop.**'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 组件接收作为 prop 的渲染 HTML。**'
- en: '***4* Prop being passed in here is data, a stringified JSON object representing
    the current state of the app on the server—otherwise the handoff from server to
    browser can’t happen.**'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 这里传入的 prop 是数据，一个表示服务器上应用程序当前状态的字符串化 JSON 对象——否则服务器到浏览器的传递就无法发生。**'
- en: '`dangerouslySetInnerHTML` is used because it’s a prerendered string. Normally,
    you can’t put HTML in a React component. This special property allows you to bypass
    this restriction. It’s named that way as a reminder to be cautious and intentional
    with HTML in components.'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '`dangerouslySetInnerHTML` 被使用，因为它是一个预渲染的字符串。通常，你无法在 React 组件中放置 HTML。这个特殊属性允许你绕过这个限制。它被这样命名是为了提醒在使用组件中的
    HTML 时要谨慎且有意。 '
- en: Now that all the React components for the app have been created, you’ll set
    up the business logic for the recipes app.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用的所有React组件都已创建，你将设置食谱应用的业务逻辑。
- en: '2.4\. App state: Redux'
  id: totrans-413
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4. 应用状态：Redux
- en: In this section, I’ll show you how to use Redux to build the business logic
    for the recipes app. The recipes app doesn’t have much user interaction because
    it’s so simple. But Redux will still be responsible for fetching the data for
    the app. [Chapter 6](kindle_split_017_split_000.xhtml#ch06) presents a complete
    look at Redux, including handling user interactions.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将向你展示如何使用Redux为食谱应用构建业务逻辑。由于食谱应用非常简单，所以它没有太多的用户交互。但Redux仍然负责获取应用的数据。[第6章](kindle_split_017_split_000.xhtml#ch06)全面介绍了Redux，包括处理用户交互。
- en: 2.4.1\. Understanding Redux
  id: totrans-415
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.4.1. 理解Redux
- en: The flow of Redux loosely follows the flow originally defined by Facebook’s
    Flux architecture. All updates to the app state are single directional. When a
    change is requested, it’s processed by the business logic (actions), updated in
    the app state (reducers), and finally returned to the view as part of a brand-new
    copy of the app state. [Figure 2.8](kindle_split_012_split_004.xhtml#ch02fig08)
    shows how this works.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: Redux的流程大致遵循Facebook最初定义的Flux架构流程。所有对应用状态的所有更新都是单向的。当请求更改时，它由业务逻辑（动作）处理，更新到应用状态（reducer），最后作为应用状态的新副本的一部分返回到视图。[图2.8](kindle_split_012_split_004.xhtml#ch02fig08)展示了这是如何工作的。
- en: 'Figure 2.8\. Redux overview: flow of user interaction to store update to view
    update'
  id: totrans-417
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.8. Redux概述：用户交互到商店更新到视图更新的流程
- en: '![](Images/02fig08_alt.jpg)'
  id: totrans-418
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/02fig08_alt.jpg)'
- en: The store
  id: totrans-419
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 商店
- en: Redux is based on the idea of a single root state object for the entire application,
    commonly referred to as the *store*. This state can be a combination of multiple
    deeply nested objects. The recipes app is simple, so it will have just a single
    root object called *recipes*.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: Redux基于整个应用的单个根状态对象的概念，通常称为*商店*。这个状态可以是多个深度嵌套对象的组合。由于食谱应用很简单，所以它将只有一个名为*recipes*的根对象。
- en: The store is immutable, meaning changes to the state object always return a
    new state rather than modifying the existing state. I like to think of this as
    the model of the application, where the data is stored.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 商店是不可变的，这意味着对状态对象的更改总是返回一个新的状态，而不是修改现有的状态。我喜欢把它看作是应用的模式，数据存储在这里。
- en: '|  |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Definition
  id: totrans-423
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义
- en: '*Immutable objects* are read-only. To update an immutable object, you need
    to clone it. In JavaScript, when you change an object, it affects all references
    to that object. Mutable changes can have unintended side effects. By enforcing
    immutability in your store, you prevent this from happening in your app.'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '*不可变对象*是只读的。要更新不可变对象，你需要克隆它。在JavaScript中，当你改变一个对象时，它会影响到对该对象的全部引用。可变更改可能会有意外的副作用。通过在商店中强制执行不可变性，你可以在应用中防止这种情况发生。'
- en: '|  |'
  id: totrans-425
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Actions
  id: totrans-426
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 动作
- en: To make updates to state, you dispatch actions. *Actions* are where most of
    our business logic takes place. I like to think of actions as the controllers
    of the app.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新状态，你需要派发动作。*动作*是大多数业务逻辑发生的地方。我喜欢把动作看作是应用的控制器。
- en: An action can be anything in your app. Actions can be used to fetch data (such
    as `getRecipes` or `getFeatured`). They can also be used to update the app state—for
    example, keeping track of items added to a shopping cart. Think of these actions
    as discrete messages that describe a single state update. Actions are synchronous
    by default, but we can include middleware in Redux that allows asynchronous actions.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 动作可以是应用中的任何东西。动作可以用来获取数据（例如`getRecipes`或`getFeatured`）。它们也可以用来更新应用状态——例如，跟踪添加到购物车的项目。将这些动作视为描述单个状态更新的离散消息。动作默认是同步的，但我们可以向Redux中包含中间件，以允许异步动作。
- en: Actions (which are JavaScript objects) are usually wrapped in action *creators*,
    which are JavaScript functions that return or dispatch an action. They’re helper
    methods that give your code more reusability by centralizing the creation of action
    objects.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 动作（通常是JavaScript对象）通常被封装在动作*创建者*中，这些是返回或派发动作的JavaScript函数。它们是辅助方法，通过集中创建动作对象，使代码更具可重用性。
- en: Reducers
  id: totrans-430
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Reducers
- en: Actions are handled by reducers. A *reducer* takes the input from the action,
    including any data fetched asynchronously from the server or an API, and inserts
    it into the proper place in the store. Reducers are responsible for enforcing
    the immutable requirement of the state object. By using reducers, the actions
    and the store are decoupled, which gives greater flexibility to the app.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 动作由减少器处理。一个 *减少器* 接收来自动作的输入，包括从服务器或 API 异步获取的任何数据，并将其插入到存储库的正确位置。减少器负责强制执行状态对象的不可变要求。通过使用减少器，动作和存储库解耦，这为应用程序提供了更大的灵活性。
- en: I’ll walk you through setting up Redux and adding actions, reducers, and the
    code that makes Redux and React work together.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 我将带您了解如何设置 Redux 以及添加动作、减少器和使 Redux 和 React 一起工作的代码。
- en: '2.4.2\. Actions: fetching the recipes data'
  id: totrans-433
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.4.2\. 动作：获取食谱数据
- en: First, we’ll look at the recipes data that you need to fetch to populate the
    view. For this one-page app, you’ll need only asynchronous actions. To learn more
    about actions and action creators, see [chapter 6](kindle_split_017_split_000.xhtml#ch06)
    for a full explanation. If you’d like to check out the code for this section,
    change to the redux branch (`git checkout redux`). To see all the code for this
    section in final working form, check out redux-complete (`git checkout redux-complete`).
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将查看您需要获取以填充视图的食谱数据。对于这个单页应用，您只需要异步动作。要了解更多关于动作和动作创建者的信息，请参阅第 6 章（kindle_split_017_split_000.xhtml#ch06）以获取完整解释。如果您想查看本节的代码，请切换到
    redux 分支（`git checkout redux`）。要查看本节所有代码的最终工作形式，请查看 redux-complete（`git checkout
    redux-complete`）。
- en: In the action-creators file in the recipes app, you’ll add two action creators.
    One will fetch the list of all the recipes, and the other will fetch the featured
    recipe. [Listing 2.9](kindle_split_012_split_004.xhtml#ch02ex09) shows the implementation
    for the actions. Add the code in this listing to the src/action-creators.es6 file.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在食谱应用的 action-creators 文件中，您将添加两个动作创建者。一个将获取所有食谱的列表，另一个将获取特色食谱。[列表 2.9](kindle_split_012_split_004.xhtml#ch02ex09)
    显示了动作的实现。将此列表中的代码添加到 src/action-creators.es6 文件中。
- en: '|  |'
  id: totrans-436
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-437
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: I’ve included a library called isomorphic-fetch to help make XHR calls. It provides
    an implementation of the fetch API for both Node.js and in the browser. You can
    find more information and the documentation at [https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)
    and [https://github.com/matthew-andrews/isomorphic-fetch](https://github.com/matthew-andrews/isomorphic-fetch).
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 我包括了一个名为 isomorphic-fetch 的库，以帮助进行 XHR 调用。它为 Node.js 和浏览器提供了 fetch API 的实现。您可以在
    [https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)
    和 [https://github.com/matthew-andrews/isomorphic-fetch](https://github.com/matthew-andrews/isomorphic-fetch)
    找到更多信息和相关文档。
- en: '|  |'
  id: totrans-439
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Listing 2.9\. Action creators for recipes and featured data—src/action-creators.es6
  id: totrans-440
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.9\. 食谱和特色数据的动作创建者—src/action-creators.es6
- en: '[PRE15]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '***1* Best practice is to create constants for all your actions so action creators
    (functions listed here) and reducers can use them. Then you won’t have discrepancies
    between strings.**'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 最佳实践是为所有动作创建常量，以便动作创建者（此处列出的函数）和减少器可以使用它们。这样，您就不会在字符串之间出现差异。**'
- en: '***2* fetchRecipes, the first action creator, handles logic for making a request
    to the server for recipes data.**'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* fetchRecipes，第一个动作创建者，处理向服务器请求食谱数据的逻辑。**'
- en: '***3* Implements fetch API for making GET request to appropriate endpoint.**'
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 实现用于向适当端点发起 GET 请求的 fetch API。**'
- en: '***4* On a successful response, get JSON from the response—using a promise
    to get JSON response is standard with the fetch API.**'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 在成功响应中，从响应中获取 JSON 数据—使用 promise 获取 JSON 响应是 fetch API 的标准做法。**'
- en: '***5* Dispatch action.**'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 分发动作。**'
- en: '***6* Type is the only required property of every action, set it using string
    constants declared at the top of the module.**'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 类型是每个动作的唯一必需属性，使用模块顶部声明的字符串常量设置它。**'
- en: '***7* Attach JSON data to action payload on a property called data.**'
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 在名为 data 的属性上附加 JSON 数据到动作负载。**'
- en: '***8* The second action creator handles the logic for requesting the featured
    recipe from the server.**'
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 第二个动作创建者处理从服务器请求特色食谱的逻辑。**'
- en: '***9* Dispatch action.**'
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9* 分发动作。**'
- en: '***10* Attach JSON data to action payload on a property called data.**'
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***10* 在名为 data 的属性上附加 JSON 数据到动作负载。**'
- en: '***11* This action creator composes the other two action creators—making it
    easier for view and server to request related data.**'
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***11* 此动作创建者组合了其他两个动作创建者—使视图和服务器请求相关数据更容易。**'
- en: By themselves, these actions won’t do anything. All they’re responsible for
    is determining what will be updated in the app state. They then send the action
    to the reducers. The reducers take in the objects from the action creators in
    `fetchRecipes` and `fetchFeaturedRecipe`. They return a new copy of the store
    (maintaining state as an immutable object), with the updated data. [Figure 2.9](kindle_split_012_split_004.xhtml#ch02fig09)
    shows this flow.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 这些动作本身不会做任何事情。它们只负责确定应用状态中将要更新什么。然后它们将动作发送给减数。减数接收来自`fetchRecipes`和`fetchFeaturedRecipe`的动作创建者中的对象。它们返回一个新的存储副本（将状态作为不可变对象维护），并带有更新后的数据。[图2.9](kindle_split_012_split_004.xhtml#ch02fig09)展示了这个流程。
- en: Figure 2.9\. Dispatching an action triggers a lookup in the reducer followed
    by an update to the store.
  id: totrans-454
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.9\. 分发动作触发在减数中的查找，然后更新存储。
- en: '![](Images/02fig09_alt.jpg)'
  id: totrans-455
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig09_alt.jpg)'
- en: The following listing shows the recipes reducers in the app. It also demonstrates
    how to keep the app state immutable. Add this code to src/recipe-reducer.es6.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了应用中的食谱减数。它还演示了如何保持应用状态不可变。将此代码添加到src/recipe-reducer.es6中。
- en: Listing 2.10\. Reducers—src/recipe-reducer.es6
  id: totrans-457
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.10\. 减数—src/recipe-reducer.es6
- en: '[PRE16]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '***1* Include the constants from action creators.**'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 包含来自动作创建者的常量。**'
- en: '***2* A reducer is a JavaScript function that takes in the current state and
    an action.**'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 减数（reducer）是一个JavaScript函数，它接收当前状态和一个动作。**'
- en: '***3* Using a switch statement is recommended because many reducers end up
    with > 4 cases to handle—this switch uses a type property to determine how to
    handle each action.**'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 建议使用switch语句，因为许多减数最终会有超过4个case来处理——这个switch使用一个type属性来确定如何处理每个动作。**'
- en: '***4* Using the spread operator to clone the state object maintains an immutable
    store.**'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 使用扩展运算符克隆状态对象以保持存储不可变。**'
- en: '***5* Use data from the action to override the current state so the new app
    state is the old app state with the modified data.**'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 使用动作中的数据覆盖当前状态，以便新的应用状态是带有修改后数据的旧应用状态。**'
- en: '***6* If a reducer is triggered but no case matches, return the current store
    state—no changes required, no need to create new object.**'
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 如果减数被触发但没有匹配的case，则返回当前存储状态——不需要更改，不需要创建新对象。**'
- en: Now that you have action creators and reducers, you need to initialize and configure
    Redux. Because both the browser and the server will be initializing Redux, you’ll
    abstract the code into a module called init-redux. You add the code from the following
    listing to src/init-redux.es6.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了动作创建者和减数，你需要初始化和配置Redux。因为浏览器和服务器都将初始化Redux，所以你将代码抽象到一个名为init-redux的模块中。你将以下列表中的代码添加到src/init-redux.es6中。
- en: Listing 2.11\. Using `initialState` to start Redux—src/init-redux.es6
  id: totrans-466
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.11\. 使用`initialState`启动Redux—src/init-redux.es6
- en: '[PRE17]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '***1* Include the Redux functions used to create the Redux store.**'
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 包含用于创建Redux存储的Redux函数。**'
- en: '***2* Include the recipes reducer you created earlier.**'
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 包含你之前创建的食谱减数。**'
- en: '***3* Include Thunk middleware. It lets you write action creators that can
    dispatch additional actions and use promises.**'
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 包含Thunk中间件。它允许你编写可以分发额外动作并使用promise的动作创建者。**'
- en: '***4* Use the combineReducers function to create one root reducer (in bigger
    apps, you’ll have many reducers).**'
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 使用`combineReducers`函数创建一个根减数（在更大的应用中，你将有许多减数）。**'
- en: '***5* Use the functions imported from Redux to initialize the store and pass
    in middleware options—compose takes functions and combines them from right to
    left.**'
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 使用从Redux导入的函数初始化存储并传入中间件选项——`compose`从右到左组合函数。**'
- en: Redux is completely wired up, but the view still doesn’t have access to the
    data. The next section covers connecting React and Redux.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: Redux已经完全配置好了，但视图仍然无法访问数据。下一节将介绍如何连接React和Redux。
- en: 2.4.3\. React and Redux
  id: totrans-474
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.4.3\. React和Redux
- en: You still have a couple of steps before you can get React and Redux working
    together properly and have the browser code ready to go. You’ll use an npm package
    called react-redux to hook up your React components to Redux. This package provides
    a React component called Provider that you use to wrap all your other React components.
    These wrapped components can then optionally subscribe to updates from the Redux
    store using another component that the library has, called *connect*. The following
    listing shows how to include the Provider in the browser entry point file. Update
    src/main.jsx with the code in bold.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 在你能够正确地将 React 和 Redux 结合起来并准备好浏览器代码之前，你还需要进行几个步骤。你将使用一个名为 react-redux 的 npm
    包来将你的 React 组件连接到 Redux。这个包提供了一个名为 Provider 的 React 组件，你用它来包裹你所有的其他 React 组件。这些被包裹的组件可以使用库中的另一个组件，称为
    *connect*，来选择性地订阅 Redux 存储的更新。以下列表显示了如何在浏览器入口点文件中包含 Provider。使用加粗的代码更新 src/main.jsx。
- en: Listing 2.12\. Redux and React setup—src/main.jsx
  id: totrans-476
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.12\. Redux 和 React 设置—src/main.jsx
- en: '[PRE18]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '***1* Include the Provider component that sets up a Redux store in the app
    so you can use the connect wrapper in your components.**'
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在应用中包含设置 Redux 存储的 Provider 组件，以便你可以在组件中使用 connect 包装器。**'
- en: '***2* Include the module you just added that initializes Redux in application.**'
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 包含你刚刚添加的初始化 Redux 的模块。**'
- en: '***3* Call initRedux to set up the Redux store.**'
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 调用 initRedux 以设置 Redux 存储。**'
- en: '***4* Wrap root app component with the react-redux Provider component and pass
    in the newly created store to the Provider component.**'
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 使用 react-redux Provider 组件包裹根应用组件，并将新创建的存储传递给 Provider 组件。**'
- en: The Provider component acts as the stateful top-level component. It knows when
    the store updates and passes that change down to its children. Individual components
    can also subscribe to the store as needed. The following listing shows the code
    to add to the root component (src/components/app.jsx) so that it becomes a Redux
    connected component.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: Provider 组件充当有状态的顶级组件。它知道存储何时更新，并将这些更改传递给其子组件。单个组件也可以根据需要订阅存储。以下列表显示了添加到根组件（src/components/app.jsx）的代码，以便它成为一个连接到
    Redux 的组件。
- en: Listing 2.13\. Connecting the app component to Redux—src/components/app.jsx
  id: totrans-483
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.13\. 将应用组件连接到 Redux—src/components/app.jsx
- en: '[PRE19]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '***1* Import the Redux dependencies and action creators you added previously.**'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入你之前添加的 Redux 依赖和动作创建者。**'
- en: '***2* With the component configured to use Redux, you can dispatch actions
    from the view.**'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将组件配置为使用 Redux 后，你可以从视图中分发动作。**'
- en: '***3* Function lets you convert app state to properties on your component.**'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 函数让你将应用状态转换为组件上的属性。**'
- en: '***4* This component requires data fetched from server, so you need to get
    recipes and featuredRecipe objects out of the current app state.**'
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 此组件需要从服务器获取数据，因此你需要从当前应用状态中获取 recipes 和 featuredRecipe 对象。**'
- en: '***5* Return values you want to access directly on this.props in your component.**'
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 返回你希望在组件的 this.props 中直接访问的值。**'
- en: '***6* Function lets you make actions simpler to call from the component—instead
    of calling dispatch(action) each time, the view can call the action without knowing
    about dispatch.**'
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 函数让你使动作更简单易从组件中调用——而不是每次都调用 dispatch(action)，视图可以调用动作而不必了解 dispatch。**'
- en: '***7* Instead of exporting App component, export connect component, which takes
    in two helper functions and App component as parameters.**'
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 而不是导出 App 组件，导出 connect 组件，它接受两个辅助函数和 App 组件作为参数。**'
- en: Connect allows you to tap into the app state from components that need to know
    about how to display the data and where to get it from. Now the App component
    has access to all the properties needed to make the view work. At this point,
    if you restart the app, the view will be populated with data! Next, we’ll walk
    through the server code.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: Connect 允许你从需要了解如何显示数据和从哪里获取数据的组件中提取应用状态。现在 App 组件可以访问所有需要的属性来使视图工作。在这个时候，如果你重新启动应用，视图将填充数据！接下来，我们将介绍服务器代码。
- en: 2.5\. Server rendering
  id: totrans-493
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5\. 服务器渲染
- en: Now that you have your views and business logic set up, it’s time to look at
    server-rendering the homepage. You’re going to add a single route for the homepage.
    This isn’t very “real-world”—[chapter 7](kindle_split_019_split_000.xhtml#ch07)
    introduces a more robust way of handling the server, including using React Router
    on the server.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经设置了视图和业务逻辑，是时候查看如何服务器端渲染主页了。你将为主页添加一个单独的路由。这并不非常“现实世界”——[第7章](kindle_split_019_split_000.xhtml#ch07)介绍了一种更健壮的处理服务器的方法，包括在服务器上使用
    React Router。
- en: If you’re following along and want to check out the code so far, you can switch
    to the server-browser-rendering branch (`git checkout server-browser-rendering`).
    Note that in this section, you’ll no longer be loading index.html. Instead, load
    the app at http://localhost:3000.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在跟随并想查看到目前为止的代码，你可以切换到 server-browser-rendering 分支 (`git checkout server-browser-rendering`)。注意，在本节中，你将不再加载
    index.html。相反，加载 http://localhost:3000 的 app。
- en: 2.5.1\. Setting up a basic route on the server with middleware
  id: totrans-496
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.5.1\. 在服务器上设置基本路由并使用中间件
- en: This route will use Express middleware to handle and render the request. The
    middleware will also fetch the necessary data.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 此路由将使用 Express 中间件来处理和渲染请求。中间件还将获取必要的数据。
- en: '|  |'
  id: totrans-498
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Definition
  id: totrans-499
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义
- en: '*Express middleware* is made up of chainable functions that each do a single
    job. Middleware can terminate the request by sending a response or can transform
    requests and do other business logic, including error handling.'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '*Express 中间件* 由链式函数组成，每个函数执行单一任务。中间件可以通过发送响应来终止请求，也可以转换请求并执行其他业务逻辑，包括错误处理。'
- en: '|  |'
  id: totrans-501
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The line of code in the [Listing 2.14](kindle_split_012_split_005.xhtml#ch02ex14)
    needs to be added to src/app.es6\. This code adds a handler for the root route.
    Make sure you add it so that server rendering will work. (I added the other code
    for you so the data endpoints would work in all the other examples.)
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2.14](kindle_split_012_split_005.xhtml#ch02ex14) 中的代码行需要添加到 src/app.es6
    中。此代码添加了对根路由的处理程序。确保你添加它，以便服务器渲染能够工作。（我已经为你添加了其他代码，以便在所有其他示例中数据端点都能工作。）'
- en: Listing 2.14\. Set up the root route—src/app.es6
  id: totrans-503
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.14\. 设置根路由—src/app.es6
- en: '[PRE20]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '***1* Add an Express route to get the homepage using renderViewMiddleware.**'
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 添加 Express 路由以使用 renderViewMiddleware 获取主页。**'
- en: 2.5.2\. Fetching the data
  id: totrans-506
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.5.2\. 获取数据
- en: Next, let’s look at `renderViewMiddleware` and see how it fetches the data and
    renders the view. Remember, you have only one route in the recipes app, so you’re
    able to assume what Redux action needs to be dispatched. The following listing
    shows how the middleware to render the view works. Replace the code in src/middleware/renderView.jsx
    with this code.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看 `renderViewMiddleware` 并了解它是如何获取数据和渲染视图的。记住，在 recipes 应用中你只有一个路由，所以你可以假设需要分发哪个
    Redux 动作。以下列表显示了渲染视图的中间件是如何工作的。将 src/middleware/renderView.jsx 中的代码替换为以下代码。
- en: Listing 2.15\. Isomorphic view middleware data fetching—src/middleware/renderView.jsx
  id: totrans-508
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.15\. 同构视图中间件数据获取—src/middleware/renderView.jsx
- en: '[PRE21]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '***1* Middleware function definition—express middleware receives a request
    object, a response object, and the next callback for passing control to next middleware
    in the chain.**'
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 中间件函数定义—express 中间件接收一个请求对象、一个响应对象以及用于将控制传递给链中下一个中间件的回调函数。**'
- en: '***2* Set up Redux reducers and compose store—on the server, it starts with
    an empty store.**'
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 设置 Redux 减法器和组合存储—在服务器上，它从一个空存储开始。**'
- en: '***3* Dispatch required action and wait for it to resolve before moving on
    to render.**'
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 分发所需动作并在继续渲染之前等待其解析。**'
- en: 'At this point, if you run `npm start` and load the app at http://localhost:3000,
    you’ll get a message: “It worked!!!”. In the terminal output, you should see the
    current state, including an array of recipes and the featured recipe. You’ve set
    up the data fetching, but you still need to render the view. The next section
    covers adding the React server rendering code to renderView.jsx.'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，如果你运行 `npm start` 并在 http://localhost:3000 加载应用，你会得到一条消息：“成功了！！！”。在终端输出中，你应该看到当前状态，包括食谱数组和特色食谱。你已经设置了数据获取，但仍然需要渲染视图。下一节将介绍如何将
    React 服务器渲染代码添加到 renderView.jsx 中。
- en: 2.5.3\. Rendering the view and serializing/injecting the data
  id: totrans-514
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.5.3\. 渲染视图和序列化/注入数据
- en: For this single route, the rendering logic is simple. The one weird bit is that
    you end up doing two React renders on the server. When I first started building
    isomorphic apps, we used a different server-side templating language to build
    the index HTML. But this had a lot of downsides, including additional knowledge
    that each developer on the team had to have before understanding the full render
    flow. Then we switched to rendering the components for the route into a React
    component that represented the full-page markup. One less skill to master!
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个单一路由，渲染逻辑很简单。奇怪的一点是，你最终在服务器上执行了两次 React 渲染。当我最初开始构建同构应用时，我们使用不同的服务器端模板语言来构建
    index HTML。但这有很多缺点，包括每个团队成员在理解完整的渲染流程之前都需要掌握额外的知识。然后我们转向将路由的组件渲染到一个代表完整页面标记的 React
    组件中。少了一个需要掌握的技能！
- en: This is to remove the need to have another view template language in use on
    the server. The following listing shows how to implement the render logic. Add
    the bold code to the `renderView` middleware.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了消除在服务器上使用另一个视图模板语言的需求。以下列表展示了如何实现渲染逻辑。将粗体代码添加到 `renderView` 中间件。
- en: Listing 2.16\. Isomorphic view middleware view render—src/middleware/renderView.jsx
  id: totrans-517
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.16\. 同构视图中间件视图渲染—src/middleware/renderView.jsx
- en: '[PRE22]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '***1* Serialize the data so you can pass the state down to the browser.**'
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 序列化数据，以便你可以将状态传递到浏览器。**'
- en: '***2* Render components by rendering app.jsx and injecting the data you fetched
    in the previous step.**'
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 通过渲染 app.jsx 并注入你在上一步中获取的数据来渲染组件。**'
- en: '***3* Render the full HTML page by rendering html.jsx with the previously rendered
    components and serialized data.**'
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 通过渲染 html.jsx 并使用之前渲染的组件和序列化数据来渲染完整的 HTML 页面。**'
- en: The other key piece of logic that must happen during your view render is getting
    the app state attached to the DOM response. You can see this in the code in the
    listing—it’s necessary so the browser can do its initial render with the exact
    same app state as was used on the server.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图渲染过程中必须发生的另一个关键逻辑是获取与应用状态附加到 DOM 响应。你可以在列表中的代码中看到这一点——这是必要的，以便浏览器可以使用与服务器上相同的精确应用状态进行初始渲染。
- en: 2.6\. Browser rendering
  id: totrans-523
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.6\. 浏览器渲染
- en: The code for browser rendering is one of the most straightforward parts of the
    whole isomorphic app flow, but it’s also one of the most important pieces to get
    right. If you don’t render the app in the same state as on the server, you’ll
    break the isomorphic render and ruin all the performance gains you’ve earned.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器渲染的代码是整个同构应用流程中最直接的部分之一，但同时也是最重要的部分之一，需要正确实现。如果你不在与服务器相同的状态下渲染应用，你会破坏同构渲染并毁掉你获得的所有性能提升。
- en: 2.6.1\. Deserializing the data and hydrating the DOM
  id: totrans-525
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.6.1\. 反序列化数据并使 DOM 充水
- en: The server did all that hard work to get the data to the browser. To grab that
    data, all the browser needs to do is point at the window object the server set
    up via a script tag. You do that in main.jsx. Add the code in the next listing
    to main.jsx.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器已经完成了所有艰苦的工作，将数据传输到浏览器。为了获取这些数据，浏览器只需要指向服务器通过脚本标签设置的窗口对象。你可以在 main.jsx 中这样做。将下一列表中的代码添加到
    main.jsx 中。
- en: Listing 2.17\. Add code for main.jsx—src/main.jsx
  id: totrans-527
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.17\. 为 main.jsx 添加代码—src/main.jsx
- en: '[PRE23]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '***1* Include the Provider component, which will become the root component,
    as on the server.**'
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 包含 Provider 组件，它将成为根组件，就像在服务器上一样。**'
- en: '***2* Include Redux initialization module.**'
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 包含 Redux 初始化模块。**'
- en: '***3* Grab server serialized state off the window object.**'
  id: totrans-531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 从窗口对象中获取服务器序列化的状态。**'
- en: '***4* Instead of starting Redux with an empty initial state on the server,
    pass server data into the Redux setup.**'
  id: totrans-532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 在服务器上启动 Redux 时，不要使用空的初始状态，而是将服务器数据传递到 Redux 设置中。**'
- en: Then, inside the `initRedux` function, the data from the server gets used. [Listing
    2.18](kindle_split_012_split_006.xhtml#ch02ex18) shows the configuration of Redux
    and how `initialStore` can be passed into it. You need to add the following code
    to the init-redux file.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `initRedux` 函数内部，使用从服务器获取的数据。[列表 2.18](kindle_split_012_split_006.xhtml#ch02ex18)
    展示了 Redux 的配置以及如何将 `initialStore` 传递给它。你需要在 init-redux 文件中添加以下代码。
- en: Listing 2.18\. Using `initialState` to start redux—src/init-redux.es6
  id: totrans-534
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.18\. 使用 `initialState` 启动 Redux—src/init-redux.es6
- en: '[PRE24]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '***1* initialStore has the value that was passed in from main.jsx (defaults
    to empty object when none is passed in).**'
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* `initialStore` 具有从 main.jsx 传递的值（如果没有传递，则默认为空对象）。**'
- en: '***2* initialStore value is passed into the Redux createStore function—the
    store is now hydrated with data from server.**'
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* `initialStore` 值被传递到 Redux createStore 函数中——现在存储已通过服务器数据充水。**'
- en: Now the app is ready to listen for user interaction and to continually update
    without talking to the server (the SPA flow). For the recipes app, if you wanted
    to expand the functionality and add detail pages for recipes, the server wouldn’t
    be involved in loading the detail page when the user clicks it from the homepage.
    In the GitHub repo, you can see the complete app on the server-browser-rendering-complete
    or master branches.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，应用已经准备好监听用户交互，并且可以在不与服务器通信的情况下持续更新（SPA 流）。对于食谱应用，如果你想要扩展功能并添加食谱的详细页面，当用户从主页点击详细页面时，服务器不会参与加载详细页面。在
    GitHub 仓库中，你可以在 server-browser-rendering-complete 或 master 分支中看到完整的应用。
- en: Summary
  id: totrans-539
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, you learned to build a complete isomorphic app. Congrats—you
    covered a lot of ground by building this example! The next few chapters take a
    deeper dive into the various parts of isomorphic apps. You learned the following
    in this chapter:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何构建一个完整的同构应用。恭喜你——通过构建这个示例，你已经覆盖了大量的内容！接下来的几章将更深入地探讨同构应用的各个部分。在本章中，你学习了以下内容：
- en: Babel and webpack enable JavaScript code to be compiled. Webpack allows npm
    packages to be used with browser code.
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Babel 和 webpack 允许将 JavaScript 代码编译。Webpack 允许在浏览器代码中使用 npm 包。
- en: React components make up the view portion of the application. JSX is used to
    declare the components.
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 组件构成了应用的可视部分。使用 JSX 来声明组件。
- en: Redux acts as the controller and the model of the isomorphic app.
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux 在同构应用中充当控制器和模型的角色。
- en: The Node.js server uses Express middleware to respond to requests. Custom middleware
    for rendering React is needed for isomorphic apps. This middleware also sends
    down the initial serialized state of the application.
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 服务器使用 Express 中间件来响应请求。对于同构应用，需要自定义中间件来渲染 React。此中间件还会发送应用程序的初始序列化状态。
- en: The browser uses a separate entry point to load in the initial state and start
    the app.
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器使用一个单独的入口点来加载初始状态并启动应用。
