- en: 4 Working with Spring Data JPA
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 使用 Spring Data JPA 进行工作
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了
- en: Introducing Spring Data and its modules
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Spring Data 及其模块
- en: Examining the main concepts of Spring Data JPA
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查 Spring Data JPA 的主要概念
- en: Investigating the query builder mechanisms
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调查查询构建器机制
- en: Examining projections, and modifying and deleting queries
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查投影、修改和删除查询
- en: Examining Query by Example
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查基于示例的查询
- en: Spring Data is an umbrella project containing many projects specific to various
    databases. These projects are developed in partnership with the companies creating
    the database technologies themselves. Spring Data’s goal is to provide an abstraction
    for data access while retaining the underlying specifics of the various data stores.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data 是一个包含许多针对各种数据库的特定项目的伞形项目。这些项目是与创建数据库技术的公司合作开发的。Spring Data 的目标是提供数据访问的抽象，同时保留各种数据存储的底层细节。
- en: 'We’ll discuss the following general features provided by Spring Data:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论 Spring Data 提供的以下一般功能：
- en: Integration with Spring via JavaConfig and XML configuration
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 JavaConfig 和 XML 配置与 Spring 集成
- en: Repository and custom object-mapping abstractions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储库和自定义对象映射抽象
- en: Integration with custom repository code
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过自定义存储库代码进行集成
- en: Dynamic query creation based on repository method names
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据存储库方法名称动态创建查询
- en: Integration with other Spring projects, such as Spring Boot
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其他 Spring 项目（如 Spring Boot）集成
- en: We enumerated the main Spring Data modules in chapter 2\. We’ll focus on Spring
    Data JPA here, which is largely used as an alternative for accessing databases
    from Java programs. It provides a layer of abstraction on top of a JPA provider
    (such as Hibernate), in the spirit of the Spring framework, taking control of
    the configuration and transactions management. We’ll use it to interact with the
    databases in many of our examples in the following chapters, so this chapter will
    analyze its capabilities in depth. We will still define and manage our entities
    using JPA and Hibernate, but we’ll provide Spring Data JPA as an alternative for
    interacting with them.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第 2 章中列出了主要的 Spring Data 模块。在这里，我们将重点关注 Spring Data JPA，它主要用作从 Java 程序访问数据库的替代方案。它在一个
    JPA 提供商（如 Hibernate）之上提供了一层抽象，遵循 Spring 框架的精神，控制配置和事务管理。我们将在接下来的章节中的许多示例中使用它来与数据库交互，因此本章将深入分析其功能。我们仍然将使用
    JPA 和 Hibernate 定义和管理我们的实体，但我们将提供 Spring Data JPA 作为与之交互的替代方案。
- en: 4.1 Introducing Spring Data JPA
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 介绍 Spring Data JPA
- en: Spring Data JPA provides support for interacting with JPA repositories. As you
    can see in figure 4.1, it is built on top of the functionality offered by the
    Spring Data Commons project and the JPA provider (Hibernate in our case). To review
    the main Spring Data modules, refer to chapter 2.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data JPA 提供了与 JPA 存储库交互的支持。如图 4.1 所示，它建立在 Spring Data Commons 项目和 JPA
    提供商（在我们的例子中是 Hibernate）的功能之上。要回顾主要的 Spring Data 模块，请参阅第 2 章。
- en: '![](../../OEBPS/Images/CH04_F01_Tudose2.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH04_F01_Tudose2.png)'
- en: Figure 4.1 Spring Data JPA is built on top of Spring Data Commons and the JPA
    provider.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 Spring Data JPA 是建立在 Spring Data Commons 和 JPA 提供商之上的。
- en: Throughout the book, we’ll generally interact with databases using both Hibernate
    JPA and Spring Data as alternatives. This chapter, along with the background provided
    in chapters 1–3, will help you start using the most important capabilities of
    Spring Data JPA. We’ll examine further Spring Data JPA features when they are
    needed, and we’ll look at other Spring Data projects in their dedicated chapters.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们将使用 Hibernate JPA 和 Spring Data 作为替代方案来与数据库交互。本章以及第 1-3 章提供的背景信息将帮助您开始使用
    Spring Data JPA 最重要的功能。当需要时，我们将进一步检查 Spring Data JPA 的功能，并在各自的章节中查看其他 Spring Data
    项目。
- en: 'As you saw in section 2.6 when we created the “Hello World” application, Spring
    Data JPA can do several things to facilitate interaction with a database:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在 2.6 节中创建“Hello World”应用程序时所见，Spring Data JPA 可以做几件事情来简化与数据库的交互：
- en: Configure the data source bean
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置数据源 Bean
- en: Configure the entity manager factory bean
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置实体管理器工厂 Bean
- en: Configure the transaction manager bean
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置事务管理器 Bean
- en: Manage transactions through annotations
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过注解管理事务
- en: 4.2 Starting a new Spring Data JPA project
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 开始一个新的 Spring Data JPA 项目
- en: We’ll use the CaveatEmptor example application that we introduced in chapter
    3 to demonstrate and analyze the capabilities of Spring Data JPA. We’ll use Spring
    Data JPA as a persistence framework to manage and persist the CaveatEmptor users,
    with Hibernate JPA as the underlying JPA provider. Spring Data JPA can execute
    CRUD operations and queries against a database, and it can be backed by different
    JPA implementations. It provides another layer of abstraction to interact with
    the databases.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用在第 3 章中介绍的 CaveatEmptor 示例应用程序来演示和分析 Spring Data JPA 的功能。我们将使用 Spring Data
    JPA 作为持久化框架来管理和持久化 CaveatEmptor 用户，Hibernate JPA 作为底层的 JPA 提供者。Spring Data JPA
    可以对数据库执行 CRUD 操作和查询，并且它可以由不同的 JPA 实现支持。它提供了另一层抽象来与数据库交互。
- en: Note To be able to execute the examples from the source code, you’ll first need
    to run the Ch04.sql script. The source code is in the `springdatajpa` folder.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：要能够执行源代码中的示例，您首先需要运行 Ch04.sql 脚本。源代码位于 `springdatajpa` 文件夹中。
- en: 'We’ll create a Spring Boot application to use Spring Data JPA. To do this,
    we’ll use the Spring Initializr website at [https://start.spring.io/](https://start.spring.io/)
    to create a new Spring Boot project (see figure 4.2) with the following characteristics:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个 Spring Boot 应用程序来使用 Spring Data JPA。为此，我们将使用 [https://start.spring.io/](https://start.spring.io/)
    网站的 Spring Initializr 创建一个具有以下特性的新 Spring Boot 项目（见图 4.2）：
- en: 'Group: com.manning.javapersistence'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组：com.manning.javapersistence
- en: 'Artifact: springdatajpa'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工件：springdatajpa
- en: 'Description: Spring Data with Spring Boot'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述：Spring Data 与 Spring Boot
- en: '![](../../OEBPS/Images/CH04_F02_Tudose2.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH04_F02_Tudose2.png)'
- en: Figure 4.2 Creating a new Spring Boot project using Spring Data JPA and MySQL
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 使用 Spring Data JPA 和 MySQL 创建新的 Spring Boot 项目
- en: 'We’ll also add the following dependencies:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将添加以下依赖项：
- en: Spring Data JPA (this will add `spring-boot-starter-data-jpa` in the Maven pom.xml
    file)
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Data JPA（这将在 Maven pom.xml 文件中添加 `spring-boot-starter-data-jpa`）
- en: MySQL Driver (this will add `mysql-connector-java` in the Maven pom.xml file)
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL 驱动程序（这将在 Maven pom.xml 文件中添加 `mysql-connector-java`）
- en: After you click the Generate button (shown in figure 4.2), the Spring Initializr
    website will provide an archive to be downloaded. This archive contains a Spring
    Boot project that uses Spring Data JPA and MySQL. Figure 4.3 shows this project
    opened in the IntelliJ IDEA IDE.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在您点击生成按钮（如图 4.2 所示）后，Spring Initializr 网站将提供一个要下载的存档。此存档包含一个使用 Spring Data JPA
    和 MySQL 的 Spring Boot 项目。图 4.3 显示了在 IntelliJ IDEA IDE 中打开的此项目。
- en: '![](../../OEBPS/Images/CH04_F03_Tudose2.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH04_F03_Tudose2.png)'
- en: Figure 4.3 Opening the Spring Boot project that uses Spring Data JPA and MySQL
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 打开使用 Spring Data JPA 和 MySQL 的 Spring Boot 项目
- en: 'The skeleton of the project contains four files:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 项目的骨架包含四个文件：
- en: '`SpringDataJpaApplication` includes a skeleton `main` method.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SpringDataJpaApplication` 包含一个骨架 `main` 方法。'
- en: '`SpringDataJpaApplicationTests` includes a skeleton test method.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SpringDataJpaApplicationTests` 包含一个骨架测试方法。'
- en: '`application.properties` is empty at the beginning.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`application.properties` 在开始时为空。'
- en: '`pom.xml` includes the management information needed by Maven.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pom.xml` 包含 Maven 需要的管理信息。'
- en: As the first three files in the preceding list are standard ones, we’ll take
    a closer look now at the pom.xml file generated by Spring Initializr.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于前三个文件是标准文件，我们现在将更详细地查看 Spring Initializr 生成的 pom.xml 文件。
- en: Listing 4.1 The pom.xml Maven file
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.1 Maven 文件 pom.xml
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Ⓐ The parent POM is `spring-boot-starter-parent`. This parent provides default
    configuration, dependency, and plugin management for the Maven applications. It
    also inherits dependency management from its parent, `spring-boot-dependencies`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 父 POM 是 `spring-boot-starter-parent`。此父项目为 Maven 应用程序提供默认配置、依赖项和插件管理。它还从其父项目
    `spring-boot-dependencies` 继承依赖项管理。
- en: Ⓑ Indicates the `groupId`, `artifactId`, `version`, `name`, and `description`
    of the project, plus the Java version.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 表示项目的 `groupId`、`artifactId`、`version`、`name` 和 `description`，以及 Java 版本。
- en: Ⓒ `spring-boot-starter-data-jpa` is the starter dependency used by Spring Boot
    to connect to a relational database through Spring Data JPA with Hibernate. It
    uses Hibernate as a transitive dependency.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ `spring-boot-starter-data-jpa` 是 Spring Boot 用于通过 Spring Data JPA 连接到关系数据库的启动依赖项。它使用
    Hibernate 作为传递依赖项。
- en: Ⓓ `mysql-connector-java` is the JDBC driver for MySQL. It is a runtime dependency,
    indicating that it is not needed in the classpath for compiling, but only at runtime.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ `mysql-connector-java` 是 MySQL 的 JDBC 驱动程序。它是一个运行时依赖项，表示在编译时不需在类路径中，但仅在运行时需要。
- en: Ⓔ `spring-boot-starter-test` is the Spring Boot starter dependency for testing.
    This dependency is needed only for the test compilation and execution phases.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓔ `spring-boot-starter-test` 是用于测试的 Spring Boot 启动依赖项。这个依赖项仅在测试编译和执行阶段需要。
- en: Ⓕ `spring-boot-maven-plugin` is a utility plugin for building and running a
    Spring Boot project.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓕ `spring-boot-maven-plugin` 是用于构建和运行 Spring Boot 项目的实用插件。
- en: 4.3 First steps for configuring a Spring Data JPA project
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 配置 Spring Data JPA 项目的第一步
- en: We’ll now write the class that will describe a `User` entity. The CaveatEmptor
    application has to keep track of the users interacting with it, so it is natural
    to start with the implementation of this class.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将编写描述 `User` 实体的类。CaveatEmptor 应用程序必须跟踪与之交互的用户，因此自然地要从实现这个类开始。
- en: Listing 4.2 The `User` entity
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.2 `User` 实体
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Ⓐ Create the `User` entity and annotate it with the `@Entity` and `@Table` annotations.
    We specify `USERS` as the name of the corresponding table, because the default
    `USER` name is reserved in most database systems.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 创建 `User` 实体并使用 `@Entity` 和 `@Table` 注解进行标注。我们指定 `USERS` 作为对应表的名称，因为大多数数据库系统中默认的
    `USER` 名称已被保留。
- en: Ⓑ Specify the `id` field as the primary key and include a getter for it. The
    `@GeneratedValue` annotation enables the automatic generation of `id`s. We’ll
    look at this more in chapter 5.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 将 `id` 字段指定为主键，并包含一个获取器。`@GeneratedValue` 注解可以启用 `id` 的自动生成。我们将在第 5 章中更详细地介绍这一点。
- en: Ⓒ Declare the `username` and `registrationDate` fields, together with getters
    and setters.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 声明 `username` 和 `registrationDate` 字段，以及相应的获取器和设置器。
- en: Ⓓ Declare three constructors, including a no-arguments one. Recall that JPA
    requires a constructor with no arguments for every persistent class. JPA uses
    the Java Reflection API on such a no-argument constructor to create instances.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 声明三个构造函数，包括一个无参构造函数。回想一下，JPA 要求每个持久化类都必须有一个无参构造函数。JPA 使用 Java 反射 API 在这样的无参构造函数上创建实例。
- en: Ⓔ Create the `toString` method to nicely display the instances of the `User`
    class.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓔ 创建 `toString` 方法以优雅地显示 `User` 类的实例。
- en: Ⓕ `spring-boot-starter-test` is the Spring Boot starter dependency for testing.
    This dependency is needed only for the test compilation and execution phases.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓕ `spring-boot-starter-test` 是用于测试的 Spring Boot 启动依赖项。这个依赖项仅在测试编译和执行阶段需要。
- en: Ⓖ `spring-boot-maven-plugin` is a utility plugin for building and running a
    Spring Boot project.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓖ `spring-boot-maven-plugin` 是用于构建和运行 Spring Boot 项目的实用插件。
- en: We’ll also create the `UserRepository` interface.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将创建 `UserRepository` 接口。
- en: Listing 4.3 The `UserRepository` interface
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.3 `UserRepository` 接口
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `UserRepository` interface extends `CrudRepository<User,` `Long>`. This
    means that it is a repository of `User` entities, which have a `Long` identifier.
    Remember, the `User` class has an `id` field of type `Long` annotated as `@Id`.
    We can directly call methods such as `save`, `findAll`, and `findById`, inherited
    from `CrudRepository`, and we can use them without any additional information
    to execute the usual operations against the database. Spring Data JPA will create
    a proxy class implementing the `UserRepository` interface and implement its methods.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserRepository` 接口扩展了 `CrudRepository<User, Long>`。这意味着它是一个 `User` 实体仓库，这些实体具有
    `Long` 类型的标识符。记住，`User` 类有一个类型为 `Long` 并被 `@Id` 注解的 `id` 字段。我们可以直接调用从 `CrudRepository`
    继承的方法，如 `save`、`findAll` 和 `findById`，并且我们可以不提供任何额外信息来执行对数据库的常规操作。Spring Data
    JPA 将创建一个实现 `UserRepository` 接口的代理类并实现其方法。'
- en: It is worth mentioning that `CrudRepository` is a generic technology-agnostic
    persistence interface that we can use not only for JPA/relational databases but
    also for NoSQL databases. For example, we can easily change the database from
    MySQL to MongoDB without touching the implementation by changing the dependency
    from the original `spring-boot-starter-data-jpa` to `spring-boot-starter-data-mongodb`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`CrudRepository` 是一种通用的技术无关的持久化接口，我们不仅可以用于 JPA/关系数据库，还可以用于 NoSQL 数据库。例如，我们可以通过更改依赖项从原始的
    `spring-boot-starter-data-jpa` 到 `spring-boot-starter-data-mongodb`，轻松地将数据库从 MySQL
    更改为 MongoDB，而无需触及实现。
- en: The next step will be to fill in the Spring Boot application.properties file.
    Spring Boot will automatically find and load the application.properties file from
    the classpath; the src/main/resources folder is added by Maven to the classpath.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步将是填写 Spring Boot 的 `application.properties` 文件。Spring Boot 会自动从类路径中查找并加载
    `application.properties` 文件；Maven 会将 `src/main/resources` 文件夹添加到类路径中。
- en: Listing 4.4 The application.properties file
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.4 `application.properties` 文件
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Ⓐ The application.properties file will indicate the URL of the database.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ `application.properties`文件将指示数据库的URL。
- en: Ⓑ The username, and no password for access.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 用户名，没有密码用于访问。
- en: Ⓒ The Hibernate dialect is MySQL8, as the database we’ll interact with is MySQL
    Release 8.0.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ Hibernate方言是MySQL8，因为我们将要交互的数据库是MySQL Release 8.0。
- en: Ⓓ While executing, the SQL code is shown.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 在执行过程中，会显示SQL代码。
- en: Ⓔ Every time the program is executed, the database will be created from scratch.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓔ 每次程序执行时，数据库都会从头创建。
- en: We’ll now write code that saves two users to the database and then tries to
    find them.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写代码将两个用户保存到数据库中，然后尝试查找它们。
- en: Listing 4.5 Persisting and finding `User` entities
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.5 持久化和查找`User`实体
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Ⓐ The `@SpringBootApplication` annotation, added by Spring Boot to the class
    containing the `main` method, will enable the Spring Boot autoconfiguration mechanism
    and the scan on the package where the application is located, and it will allow
    the registration of extra beans in the context.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 由Spring Boot添加到包含`main`方法的类上的`@SpringBootApplication`注解将启用Spring Boot自动配置机制，并扫描应用程序所在的包，同时允许在上下文中注册额外的bean。
- en: Ⓑ `SpringApplication.run` will load the standalone Spring application from the
    `main` method. It will create an appropriate `ApplicationContext` instance and
    load beans.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ `SpringApplication.run`将从`main`方法中加载独立的Spring应用程序。它将创建一个适当的`ApplicationContext`实例并加载bean。
- en: Ⓒ Spring Boot will run the `@Bean` annotated method, returning an `ApplicationRunner`
    just before `SpringApplication.run()` finishes.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ Spring Boot将在`SpringApplication.run()`完成之前运行被`@Bean`注解的方法，返回一个`ApplicationRunner`。
- en: Ⓓ Create two users.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 创建两个用户。
- en: Ⓔ Save them to the database.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓔ 将它们保存到数据库中。
- en: Ⓕ Retrieve them and display the information about them.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓕ 检索它们并显示它们的信息。
- en: 'When we run this application, we’ll get the following output (determined by
    the way the `toString()` method of the `User` class works):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行此应用程序时，我们会得到以下输出（由`User`类的`toString()`方法的工作方式决定）：
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 4.4 Defining query methods with Spring Data JPA
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 使用Spring Data JPA定义查询方法
- en: We’ll extend the `User` class by adding the fields `email`, `level`, and `active`.
    A user may have different levels, which will allow them to execute particular
    actions (such as bidding above some amount). A user may be active or may be retired
    (previously active in the CaveatEmptor auction system, but not anymore). This
    is important information that the CaveatEmptor application needs to keep about
    its users.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过添加字段`email`、`level`和`active`来扩展`User`类。用户可能有不同的级别，这将允许他们执行特定的操作（例如，在某个金额以上出价）。用户可能是活跃的，也可能是退休的（以前在CaveatEmptor拍卖系统中是活跃的，但不再是）。这是CaveatEmptor应用程序需要保留关于其用户的重要信息。
- en: Note The source code we’ll discuss in the rest of this chapter can be found
    in the `springdatajpa2` folder.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本章余下部分讨论的源代码可以在`springdatajpa2`文件夹中找到。
- en: Listing 4.6 The modified `User` class
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.6 修改后的`User`类
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We’ll now start to add new methods to the `UserRepository` interface and use
    them inside newly created tests. We’ll change the `UserRepository` interface to
    extend `JpaRepository` instead of `CrudRepository`. `JpaRepository` extends `PagingAndSortingRepository,`
    which, in turn, extends `CrudRepository`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将开始向`UserRepository`接口添加新方法，并在新创建的测试中使用它们。我们将把`UserRepository`接口改为扩展`JpaRepository`而不是`CrudRepository`。`JpaRepository`扩展了`PagingAndSortingRepository`，而`PagingAndSortingRepository`又扩展了`CrudRepository`。
- en: '`CrudRepository` provides basic CRUD functionality, whereas `PagingAndSortingRepository`
    offers convenient methods that sort and paginate the records (which we’ll address
    later in the chapter). `JpaRepository` offers JPA-related methods, such as flushing
    the persistence context and deleting records in a batch. Additionally, `JpaRepository`
    overwrites a few methods from `CrudRepository`, such as `findAll`, `findAllById``,`
    and `saveAll` to return `List` instead of `Iterable`.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`CrudRepository`提供了基本的CRUD功能，而`PagingAndSortingRepository`提供了方便的方法来排序和分页记录（我们将在本章后面讨论）。`JpaRepository`提供了与JPA相关的功能，例如刷新持久化上下文和批量删除记录。此外，`JpaRepository`覆盖了`CrudRepository`的一些方法，例如`findAll`、`findAllById`和`saveAll`，以返回`List`而不是`Iterable`。'
- en: We’ll also add a series of query methods to the `UserRepository` interface,
    as shown in the following listing
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将向`UserRepository`接口添加一系列查询方法，如下所示
- en: Listing 4.7 The `UserRepository` interface with new methods
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.7 带有新方法的`UserRepository`接口
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The purpose of these query methods is to retrieve information from the database.
    Spring Data JPA provides a query builder mechanism that will create behavior for
    the repository methods based on their names. Later we’ll look at modifying queries,
    which modify the data they find; for now, we’ll focus on queries whose purpose
    is to find information. This query mechanism removes prefixes and suffixes such
    as `find...By`, `get...By`, `query...By`, `read...By`, and `count...By` from the
    name of the method and parses the remainder of it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这些查询方法的目的是从数据库中检索信息。Spring Data JPA 提供了一个查询构建器机制，它将根据方法名称创建仓库方法的操作。稍后我们将探讨修改查询，这些查询会修改它们找到的数据；现在，我们将专注于那些旨在查找信息的查询。此查询机制从方法名称中移除了
    `find...By`、`get...By`、`query...By`、`read...By` 和 `count...By` 等前缀和后缀，并解析剩余的部分。
- en: You can declare methods containing expressions as `Distinct` to set a distinct
    clause; declare operators as `LessThan`, `GreaterThan`, `Between`, or `Like`;
    or declare compound conditions with `And` or `Or`. You can apply static ordering
    with the `OrderBy` clause in the name of the query method, referencing a property
    and providing a sorting direction (`Asc` or `Desc`). You can use `IgnoreCase`
    for properties that support such a clause. For deleting rows, you’d have to replace
    `find` with `delete` in the names of the methods. Also, Spring Data JPA will look
    at the return type of the method. If you want to find a `User` and return it in
    an `Optional` container, the method return type will be `Optional<User>`. A full
    list of possible return types, together with detailed explanations, can be found
    in appendix D of the Spring Data JPA reference documentation ([http://mng.bz/o51y](http://mng.bz/o51y)).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将包含表达式的函数声明为 `Distinct` 以设置一个唯一子句；将运算符声明为 `LessThan`、`GreaterThan`、`Between`
    或 `Like`；或者使用 `And` 或 `Or` 声明复合条件。你可以在查询方法的名称中使用 `OrderBy` 子句进行静态排序，引用一个属性并提供排序方向（`Asc`
    或 `Desc`）。对于支持此类子句的属性，你可以使用 `IgnoreCase`。对于删除行，你必须在方法名称中将 `find` 替换为 `delete`。此外，Spring
    Data JPA 将检查方法的返回类型。如果你想找到一个 `User` 并将其返回在 `Optional` 容器中，方法返回类型将是 `Optional<User>`。可能的返回类型完整列表及其详细说明可以在
    Spring Data JPA 参考文档的附录 D 中找到（[http://mng.bz/o51y](http://mng.bz/o51y)）。
- en: The names of the methods need to follow the rules. If the method naming is wrong
    (for example, the entity property does not match in the query method), you will
    get an error when the application context is loaded. Table 4.1 describes the essential
    keywords that Spring Data JPA supports and how each method name is transposed
    in JPQL. For a more comprehensive list, see appendix B at the end of this book.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 方法名称需要遵循规则。如果方法命名错误（例如，查询方法中的实体属性不匹配），则在加载应用程序上下文时将会出现错误。表 4.1 描述了 Spring Data
    JPA 支持的基本关键字以及每个方法名称如何在 JPQL 中转换。对于更完整的列表，请参阅本书末尾的附录 B。
- en: Table 4.1 Essential Spring Data JPA keywords and the generated JPQL
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.1 Spring Data JPA 关键字及其生成的 JPQL
- en: '| Keyword | Example | Generated JPQL |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 关键字 | 示例 | 生成的 JPQL |'
- en: '| `Is,` `Equals` | `findByUsername``findByUsernameIs``findByUsernameEquals`
    | ` . . .` `wheree.username` `=` `?1` |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `Is,` `Equals` | `findByUsername` | `findByUsernameIs` | `findByUsernameEquals`
    | ` . . .` `where e.username = ?1` |'
- en: '| `And` | `findByUsernameAndRegistrationDate` | ` . . .` `wheree.username`
    `=` `?1` `and` `e.registrationdate` `= ?2` |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `And` | `findByUsernameAndRegistrationDate` | ` . . .` `where e.username
    = ?1 and e.registrationdate = ?2` |'
- en: '| `Or` | `findByUsernameOrRegistrationDate` | ` . . .  where e.username = ?1
    or e.registrationdate = ?2` |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `Or` | `findByUsernameOrRegistrationDate` | ` . . .` `where e.username =
    ?1 or e.registrationdate = ?2` |'
- en: '| `LessThan` | `findByRegistrationDateLessThan` | ` . . .  where e.registrationdate
    < ?1` |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `LessThan` | `findByRegistrationDateLessThan` | ` . . .` `where e.registrationdate
    < ?1` |'
- en: '| `LessThanEqual` | `findByRegistrationDateLessThanEqual` | ` . . .  where
    e.registrationdate <= ?1` |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `LessThanEqual` | `findByRegistrationDateLessThanEqual` | ` . . .` `where
    e.registrationdate <= ?1` |'
- en: '| `GreaterThan` | `findByRegistrationDateGreaterThan` | ` . . .  where e.registrationdate
    > ?1` |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `GreaterThan` | `findByRegistrationDateGreaterThan` | ` . . .` `where e.registrationdate
    > ?1` |'
- en: '| `GreaterThanEqual` | `findByRegistrationDateGreaterThanEqual` | ` . . . 
    where e.registrationdate >= ?1` |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `GreaterThanEqual` | `findByRegistrationDateGreaterThanEqual` | ` . . .`
    `where e.registrationdate >= ?1` |'
- en: '| `Between` | `findByRegistrationDateBetween` | ` . . .  where e.registrationdate
    between ?1 and ?2` |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `Between` | `findByRegistrationDateBetween` | ` . . .` `where e.registrationdate
    between ?1 and ?2` |'
- en: '| `OrderBy` | `findByRegistrationDateOrderByUsernameDesc` | ` . . .  where
    e.registrationdate = ?1 order by e.username desc` |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `OrderBy` | `findByRegistrationDateOrderByUsernameDesc` | ` . . .` `where
    e.registrationdate = ?1 order by e.username desc` |'
- en: '| `Like` | `findByUsernameLike` | ` . . .  where e.username like ?1` |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `Like` | `findByUsernameLike` | ` . . .  where e.username like ?1` |'
- en: '| `NotLike` | `findByUsernameNotLike` | ` . . .  where e.username not like
    ?1` |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `NotLike` | `findByUsernameNotLike` | ` . . .  where e.username not like
    ?1` |'
- en: '| `Before` | `findByRegistrationDateBefore` | ` . . .  where e.registrationdate
    < ?1` |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `Before` | `findByRegistrationDateBefore` | ` . . .  where e.registrationdate
    < ?1` |'
- en: '| `After` | `findByRegistrationDateAfter` | ` . . .  where e.registrationdate
    > ?1` |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `After` | `findByRegistrationDateAfter` | ` . . .  where e.registrationdate
    > ?1` |'
- en: '| `Null,` `IsNull` | `findByRegistrationDate(Is)Null` | ` . . .  where e.registrationdate
    is null` |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `Null,` `IsNull` | `findByRegistrationDate(Is)Null` | ` . . .  where e.registrationdate
    is null` |'
- en: '| `NotNull,` `IsNotNull` | `findByRegistrationDate(Is)NotNull` | ` . . .  where
    e.registrationdate is not null` |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `NotNull,` `IsNotNull` | `findByRegistrationDate(Is)NotNull` | ` . . .  where
    e.registrationdate is not null` |'
- en: '| `Not` | `findByUsernameNot` | ` . . .  where e.username <> ?1` |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `Not` | `findByUsernameNot` | ` . . .  where e.username <> ?1` |'
- en: As a base class for future tests, we’ll write a `SpringDataJpaApplicationTests`
    abstract class.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 作为未来测试的基础类，我们将编写一个`SpringDataJpaApplicationTests`抽象类。
- en: Listing 4.8 The `SpringDataJpaApplicationTests` abstract class
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.8 `SpringDataJpaApplicationTests`抽象类
- en: '[PRE8]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Ⓐ The `@SpringBootTest` annotation, added by Spring Boot to the initially created
    class, tells Spring Boot to search the main configuration class (the `@SpringBootApplication`
    annotated class, for instance) and create the `ApplicationContext` to be used
    in the tests. Recall that the `@SpringBootApplication` annotation added by Spring
    Boot to the class containing the `main` method will enable the Spring Boot autoconfiguration
    mechanism, enable the scan on the package where the application is located, and
    allow the registration of extra beans in the context.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ Spring Boot通过添加到最初创建的类的`@SpringBootTest`注解，告诉Spring Boot搜索主配置类（例如，`@SpringBootApplication`注解的类）并创建用于测试的`ApplicationContext`。回想一下，Spring
    Boot添加到包含`main`方法的类的`@SpringBootApplication`注解将启用Spring Boot自动配置机制，启用对应用程序所在包的扫描，并允许在上下文中注册额外的bean。
- en: Ⓑ Using the `@TestInstance(TestInstance.Lifecycle.PER_CLASS)` annotation, we
    ask JUnit 5 to create a single instance of the test class and reuse it for all
    test methods. This will allow us to make the `@BeforeAll` and `@AfterAll` annotated
    methods non-static and to directly use the autowired `UserRepository` instance
    field inside them.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 使用`@TestInstance(TestInstance.Lifecycle.PER_CLASS)`注解，我们请求JUnit 5创建一个测试类的单个实例，并为其所有测试方法重用它。这将允许我们将`@BeforeAll`和`@AfterAll`注解的方法设置为非静态，并直接在它们内部使用自动装配的`UserRepository`实例字段。
- en: Ⓒ Autowire a `UserRepository` instance. This autowiring is possible due to the
    `@SpringBootApplication` annotation, which enables the scan on the package where
    the application is located and registers the beans in the context.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 自动装配一个`UserRepository`实例。这种自动装配是由于`@SpringBootApplication`注解，它启用了对应用程序所在包的扫描并在上下文中注册了bean。
- en: Ⓓ The `@BeforeAll` annotated method will be executed once before executing all
    tests from a class that extends `SpringDataJpaApplicationTests`. This method will
    not be static (see Ⓑ above).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ `@BeforeAll`注解的方法将在执行扩展`SpringDataJpaApplicationTests`的类的所有测试之前执行一次。此方法将不是静态的（见Ⓑ以上）。
- en: Ⓔ The `@AfterAll` annotated method will be executed once, after executing all
    tests from a class that extends `SpringDataJpaApplicationTests`. This method will
    not be static (see Ⓑ above).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓔ `@AfterAll`注解的方法将在执行扩展`SpringDataJpaApplicationTests`的类的所有测试之后执行一次。此方法将不是静态的（见Ⓑ以上）。
- en: 'The next tests will extend this class and use the already populated database.
    To test the methods that now belong to `UserRepository`, we’ll create the `FindUsersUsingQueriesTest`
    class and follow the same recipe for writing tests: call the repository method
    and verify its results.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个测试将扩展此类并使用已填充的数据库。为了测试现在属于`UserRepository`的方法，我们将创建`FindUsersUsingQueriesTest`类，并遵循相同的测试编写方法：调用仓库方法并验证其结果。
- en: Listing 4.9 The `FindUsersUsingQueriesTest` class
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.9 `FindUsersUsingQueriesTest`类
- en: '[PRE9]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 4.5 Limiting query results, sorting, and paging
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5 限制查询结果、排序和分页
- en: The `first` and `top` keywords (used equivalently) can limit the results of
    query methods. The `top` and `first` keywords may be followed by an optional numeric
    value to indicate the maximum result size to be returned. If this numeric value
    is missing, the result size will be 1.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`first`和`top`关键字（等效使用）可以限制查询方法的结果。`top`和`first`关键字后面可以跟一个可选的数值，表示要返回的最大结果大小。如果此数值缺失，则结果大小为1。'
- en: '`Pageable` is an interface for pagination information, but in practice we use
    the `PageRequest` class that implements it. This one can specify the page number,
    the page size, and the sorting criterion.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pageable` 是一个分页信息的接口，但在实践中我们使用实现它的 `PageRequest` 类。这个类可以指定页码、页面大小和排序标准。'
- en: We’ll add the methods shown in listing 4.10 to the `UserRepository` interface.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把列表4.10中显示的方法添加到 `UserRepository` 接口。
- en: Listing 4.10 Limiting query results, sorting, and paging
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.10 限制查询结果、排序和分页
- en: '[PRE10]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Next we’ll write the following tests to verify how these newly added methods
    work.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将编写以下测试来验证这些新添加的方法的工作情况。
- en: Listing 4.11 Testing limiting query results, sorting, and paging
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.11 测试限制查询结果、排序和分页
- en: '[PRE11]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Ⓐ The first test will find the first user by ascending order of the username
    and the second user by descending order of the registration date.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 第一个测试将按用户名的升序查找第一个用户，按注册日期的降序查找第二个用户。
- en: Ⓑ Find all users, split them into pages, and return page number 1 of size 3
    (the page numbering starts with 0).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 查找所有用户，将它们分成页面，并返回第1页，大小为3（页码从0开始）。
- en: Ⓒ Find the first two users with level 2, ordered by registration date.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 查找前两个2级用户，并按注册日期排序。
- en: Ⓓ The second test will define a sorting criterion on the `User` class. `Sort.TypedSort`
    extends `Sort` and can use method handles to define the properties to sort by.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 第二个测试将在 `User` 类上定义一个排序标准。`Sort.TypedSort` 扩展 `Sort` 并可以使用方法句柄来定义排序的属性。
- en: Ⓔ Find users of level 3 and sort by registration date, descending.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓔ 查找3级用户并按注册日期降序排序。
- en: Ⓕ The third test will find the active users sorted by registration date, split
    them into pages, and return page number 1 of size 4 (the page numbering starts
    with 0).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓕ 第三个测试将按注册日期查找活跃用户，将它们分成页面，并返回第1页，大小为4（页码从0开始）。
- en: 4.6 Streaming results
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.6 流式传输结果
- en: Query methods returning more than one result can use standard Java interfaces
    such as `Iterable`, `List`, `Set`. Additionally, Spring Data supports `Streamable`,
    which can be used as an alternative to `Iterable` or any collection type. You
    can concatenate `Streamable`s and directly filter and map over the elements.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 返回多个结果的查询方法可以使用标准的 Java 接口，如 `Iterable`、`List`、`Set`。此外，Spring Data 支持 `Streamable`，它可以作为
    `Iterable` 或任何集合类型的替代品。您可以连接 `Streamable`s 并直接过滤和映射元素。
- en: We’ll add the following methods to the `UserRepository` interface.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把以下方法添加到 `UserRepository` 接口。
- en: Listing 4.12 Adding methods that return `Streamable` in the `UserRepository`
    interface
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.12 在 `UserRepository` 接口中添加返回 `Streamable` 的方法
- en: '[PRE12]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We’ll write the following tests to verify that these newly added methods work.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写以下测试来验证这些新添加的方法是否工作。
- en: Listing 4.13 Testing methods that return `Streamable`
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.13 测试返回 `Streamable` 的方法
- en: '[PRE13]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Ⓐ The test will call the `findByEmailContaining` method, searching for emails
    containing “someother.”
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 测试将调用 `findByEmailContaining` 方法，搜索包含“someother”的电子邮件。
- en: Ⓑ The test will concatenate the resulting `Streamable` with the `Streamable`
    providing the users of level 2.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 测试将把生成的 `Streamable` 与提供2级用户的 `Streamable` 连接起来。
- en: Ⓒ It will transform this into a stream and will keep the distinct users. The
    stream is given as a resource of the `try` block, so it will automatically be
    closed. An alternative is to explicitly call the `close()` method. Otherwise,
    the stream would keep the underlying connection to the database.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 它将把这个转换成一个流，并保留不同的用户。这个流作为 `try` 块的资源，所以它将被自动关闭。另一种选择是显式调用 `close()` 方法。否则，流将保持与数据库的底层连接。
- en: Ⓓ Check that the resulting stream contains six users.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 确保生成的流包含六个用户。
- en: 4.7 The @Query annotation
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.7 @Query 注解
- en: With the `@Query` annotation, you can create a method and then write a custom
    query on it. When you use the `@Query` annotation, the method name does not need
    to follow any naming convention. The custom query can be parameterized, identifying
    the parameters by position or by name, and binding these names in the query with
    the `@Param` annotation. The `@Query` annotation can generate native queries with
    the `nativeQuery` flag set to `true`. You should be aware, however, that native
    queries can affect the portability of the application. To sort the results, you
    can use a `Sort` object. The properties you order by must resolve to a query property
    or a query alias.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `@Query` 注解，您可以在方法上创建一个查询，然后在该查询上编写自定义查询。当您使用 `@Query` 注解时，方法名称不需要遵循任何命名约定。自定义查询可以是参数化的，可以通过位置或名称标识参数，并在查询中使用
    `@Param` 注解绑定这些名称。`@Query` 注解可以生成带有 `nativeQuery` 标志设置为 `true` 的本地查询。然而，您应该意识到，本地查询可能会影响应用程序的可移植性。为了排序结果，您可以使用
    `Sort` 对象。您排序的属性必须解析为查询属性或查询别名。
- en: Spring Data JPA supports Spring Expression Language (SpEL) expressions in queries
    defined using the `@Query` annotation, and Spring Data JPA supports the `entityName`
    variable. In a query such as `select` `e` `from` `#{#entityName}` `e`, `entityName`
    is resolved based on the `@Entity` annotation. In our case, in `UserRepository
    extends JpaRepository<User,` `Long>`, `entityName` will resolve to `User`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 'Spring Data JPA 支持在 `@Query` 注解定义的查询中使用 Spring 表达式语言 (SpEL) 表达式，并且 Spring Data
    JPA 支持使用 `entityName` 变量。在一个如 `select e from #{#entityName} e` 的查询中，`entityName`
    的解析基于 `@Entity` 注解。在我们的情况下，在 `UserRepository extends JpaRepository<User, Long>`
    中，`entityName` 将解析为 `User`。'
- en: We’ll add the following methods to the `UserRepository` interface.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 `UserRepository` 接口中添加以下方法。
- en: Listing 4.14 Limiting query results, sorting, and paging
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.14 限制查询结果、排序和分页
- en: '[PRE14]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Ⓐ The `findNumberOfUsersByActivity` method will return the number of active
    users.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ `findNumberOfUsersByActivity` 方法将返回活跃用户数量。
- en: Ⓑ The `findByLevelAndActive` method will return the users with the `level` and
    `active` status given as named parameters. The `@Param` annotation will match
    the `:level` parameter of the query with the `level` argument of the method and
    the `:active` parameter of the query with the `active` argument of the method.
    This is especially useful when you change the order of the parameters from the
    signature of the method and the query is not updated.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ `findByLevelAndActive` 方法将返回具有指定 `level` 和 `active` 状态的用户。`@Param` 注解将查询中的
    `:level` 参数与方法的 `level` 参数匹配，将查询中的 `:active` 参数与方法的 `active` 参数匹配。这在您更改参数顺序时特别有用，因为此时查询尚未更新。
- en: Ⓒ The `findNumberOfUsersByActivityNative` method will return the number of users
    with a given `active` status. Setting the `nativeQuery` flag to `true` indicates
    that, unlike the previous queries, which are written with JPQL, this query is
    written using a native SQL that’s specific to the database.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ `findNumberOfUsersByActivityNative` 方法将返回具有给定 `active` 状态的用户数量。将 `nativeQuery`
    标志设置为 `true` 表示，与之前使用 JPQL 编写的查询不同，此查询使用的是针对特定数据库的本地 SQL。
- en: Ⓓ The `findByAsArrayAndSort` method will return a list of arrays, with each
    array containing the `username` and the length of the `email`, after filtering
    based on the `username`. The second `Sort` parameter will allow you to order the
    result of the query based on different criteria.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ `findByAsArrayAndSort` 方法将返回一个数组列表，每个数组包含 `username` 和 `email` 的长度，在根据 `username`
    过滤后。第二个 `Sort` 参数将允许您根据不同的标准对查询结果进行排序。
- en: We’ll write the tests for these query methods, which are pretty straightforward.
    We’ll discuss only the test written for the fourth query method, which allows
    a few variations of the sorting criterion.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为这些查询方法编写测试，这些测试相当直接。我们只讨论为第四个查询方法编写的测试，该测试允许对排序标准进行一些变化。
- en: Listing 4.15 Testing the query methods
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.15 测试查询方法
- en: '[PRE15]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Ⓐ The `findByAsArrayAndSort` method will return the users whose `username` is
    like `%ar%`, and it will order them by `username`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ `findByAsArrayAndSort` 方法将返回用户名中包含 `%ar%` 的用户，并将它们按 `username` 排序。
- en: Ⓑ The `findByAsArrayAndSort` method will return the users whose `username` is
    like `%ar%`, and it will order them by `email_length`, descending. Note that the
    `email_ length` alias needed to be specified inside the query to be used for ordering.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ `findByAsArrayAndSort` 方法将返回用户名中包含 `%ar%` 的用户，并将它们按 `email_length` 降序排序。请注意，需要将
    `email_length` 别名指定在查询内部，以便用于排序。
- en: Ⓒ The `findByAsArrayAndSort` method will return the users whose `username` is
    like `%ar%`, and it will order them by `LENGTH(u.email)`. `JpaSort` is a class
    that extends `Sort,` and it can use something other than property references and
    aliases for sorting. The `unsafe` property handling means that the provided String
    is not necessarily a property or an alias but can be an arbitrary expression inside
    the query.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ `findByAsArrayAndSort`方法将返回`username`字段类似于`%ar%`的用户，并将它们按`LENGTH(u.email)`排序。`JpaSort`是一个扩展了`Sort`的类，它可以用于排序，除了属性引用和别名之外，还可以使用其他内容。`unsafe`属性处理意味着提供的字符串不一定是属性或别名，但可以是查询中的任意表达式。
- en: If the method naming is wrong for any of the previous methods that follow the
    Spring Data JPA naming conventions (for example, the entity property does not
    match in the query method), you will get an error when the application context
    is loaded. If you are using the `@Query` annotation and the query you wrote is
    wrong, you will get an error at runtime when executing that method. Thus, the
    `@Query` annotated methods are more flexible, but they also provide less safety.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何遵循Spring Data JPA命名约定（例如，查询方法中的实体属性不匹配）的前置方法命名错误，则在加载应用程序上下文时将得到错误。如果你使用`@Query`注解，并且你编写的查询错误，则在执行该方法时将在运行时得到错误。因此，`@Query`注解的方法更加灵活，但它们也提供了更少的安全性。
- en: 4.8 Projections
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.8 投影
- en: Not all attributes of an entity are always needed, so we may sometimes access
    only some of them. For example, the frontend may reduce I/O and display only the
    information that will be of interest to the end user. Consequently, instead of
    returning instances of the root entity managed by the repository, you may want
    to create projections based on certain attributes of those entities. Spring Data
    JPA can shape return types to selectively return attributes of entities.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 实体的不是所有属性都是始终需要的，所以我们有时可能只访问其中的一些。例如，前端可能会减少I/O，只显示对最终用户感兴趣的信息。因此，你可能会想基于那些实体的某些属性创建投影，而不是返回由存储库管理的根实体实例。Spring
    Data JPA可以调整返回类型，以选择性地返回实体的属性。
- en: An interface-based projection requires the creation of an interface that declares
    getter methods for the properties to be included in the projection. Such an interface
    can also compute specific values using the `@Value` annotation and SpEL expressions.
    By executing queries at runtime, the execution engine creates proxy instances
    of the interface for each returned element and forwards the calls to the exposed
    methods to the target object.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 基于接口的投影需要创建一个接口，该接口声明了要包含在投影中的属性的getter方法。这样的接口也可以使用`@Value`注解和SpEL表达式计算特定值。通过在运行时执行查询，执行引擎为每个返回的元素创建接口的代理实例，并将对公开方法的调用转发到目标对象。
- en: We’ll create a `Projection` class and add `UserSummary` as a nested interface.
    We’ll group the projections, as they are logically connected.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个`Projection`类，并将`UserSummary`作为一个嵌套接口添加。我们将对投影进行分组，因为它们在逻辑上是相互关联的。
- en: Listing 4.16 Interface-based projection
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.16 基于接口的投影
- en: '[PRE16]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Ⓐ The `getUsername` method will return the `username` field.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ `getUsername`方法将返回`username`字段。
- en: Ⓑ The `getInfo` method is annotated with the `@Value` annotation and will return
    the concatenation of the `username` field, a space, and the `email` field.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ `getInfo`方法被`@Value`注解标记，并将返回`username`字段、一个空格和`email`字段的连接。
- en: How should we approach projections in practice? If we include only methods such
    asa Ⓐ in listing 4.16, we’ll create a closed projection—this is an interface whose
    getters all correspond to properties of the target entity. When you’re working
    with a closed projection, the query execution can be optimized by Spring Data
    JPA because all the properties needed by the projection proxy are known from the
    beginning.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中我们应该如何处理投影？如果我们只包含像Ⓐ在列表4.16中的方法，我们将创建一个封闭投影——这是一个所有getter都对应目标实体属性的接口。当你使用封闭投影时，Spring
    Data JPA可以通过在开始时就了解投影代理所需的所有属性来优化查询执行。
- en: If we include methods such as Ⓑ, we create an open projection, which is more
    flexible. However, Spring Data JPA will not be able to optimize the query execution,
    because the SpEL expression is evaluated at runtime and may include any properties
    or combination of properties of the entity root.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们包含像Ⓑ这样的方法，我们将创建一个开放投影，这更加灵活。然而，Spring Data JPA将无法优化查询执行，因为SpEL表达式在运行时评估，可能包括实体根的任何属性或属性组合。
- en: In general, you should use projections when you need to provide limited information
    and not expose the full entity. For performance reasons, you should prefer closed
    projections whenever you know from the beginning which information you want to
    return. If you have a query that returns the full object, and you have a similar
    query that only returns a projection, you can use alternate naming conventions,
    such as naming one method `find...By` and the other method `get...By``.`
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，当你需要提供有限的信息而不暴露完整实体时，你应该使用投影。出于性能考虑，如果你一开始就知道你想要返回哪些信息，你应该优先选择封闭投影。如果你有一个返回完整对象的查询，而你有一个类似的查询只返回投影，你可以使用不同的命名约定，例如将一个方法命名为`find...By`，另一个方法命名为`get...By`。
- en: A class-based projection requires the creation of a data transfer object (DTO)
    class that declares the properties to be included in the projection and the getter
    methods. Using a class-based projection is similar to using interface-based projections.
    However, Spring Data JPA doesn’t need to create proxy classes for managing projections.
    Spring Data JPA will instantiate the class that declares the projection, and the
    properties to be included are determined by the parameter names of the constructor
    of the class.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 基于类的投影需要创建一个数据传输对象（DTO）类，该类声明了要包含在投影中的属性和getter方法。使用基于类的投影类似于使用基于接口的投影。然而，Spring
    Data JPA不需要为管理投影创建代理类。Spring Data JPA将实例化声明投影的类，要包含的属性由类的构造函数的参数名称确定。
- en: The following listing adds `UsernameOnly` as a nested class of the `Projection`
    class.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表将`UsernameOnly`作为`Projection`类的嵌套类添加。
- en: Listing 4.17 Class-based projection
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.17 基于类的投影
- en: '[PRE17]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Ⓐ The `UsernameOnly` class
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ `UsernameOnly`类
- en: Ⓑ The `username` field
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ `username`字段
- en: Ⓒ The declared constructor
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 声明的构造函数
- en: Ⓓ The `username` field exposed through a getter
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 通过getter暴露的`username`字段
- en: 'The methods that we’ll add to the `UserRepository` interface will look like
    these:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加到`UserRepository`接口中的方法将看起来像这些：
- en: '[PRE18]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'These repository methods use the same naming conventions we applied in the
    previous examples in this section, and they know their return types from compile
    time as collections of projection types. However, we can generify the return types
    of repository methods, which will make them dynamic. We’ll add a new method to
    the `UserRepository` interface:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这些仓库方法使用了我们在本节之前示例中应用的相同命名约定，并且它们从编译时就知道它们的返回类型是投影类型的集合。然而，我们可以泛化仓库方法的返回类型，这将使它们变得动态。我们将在`UserRepository`接口中添加一个新方法：
- en: '[PRE19]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We’ll write the tests for these query methods using projections.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用投影编写这些查询方法的测试。
- en: Listing 4.18 Testing query methods using projections
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.18 使用投影测试查询方法
- en: '[PRE20]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Ⓐ The `findByEmail` method will return a list of `Projection.UsernameOnly` instances.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ `findByEmail`方法将返回一个`Projection.UsernameOnly`实例的列表。
- en: Ⓑ Verify the assertions.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 验证断言。
- en: Ⓒ The `findByRegistrationDateAfter` method will return a list of `Projection
    .UserSummary` instances.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ `findByRegistrationDateAfter`方法将返回一个`Projection.UserSummary`实例的列表。
- en: Ⓓ Verify the assertions.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 验证断言。
- en: Ⓔ This `findByEmail` method provides a dynamic projection. It will return a
    list of `Projection.UsernameOnly` instances.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓔ 这个`findByEmail`方法提供了一个动态投影。它将返回一个`Projection.UsernameOnly`实例的列表。
- en: Ⓕ This `findByEmail` method may also return a list of `User` instances, depending
    on the class that it is generified by.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓕ 这个`findByEmail`方法也可能返回一个`User`实例的列表，具体取决于它被泛化的类。
- en: Ⓖ Verify the assertions.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓖ 验证断言。
- en: 4.9 Modifying queries
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.9 修改查询
- en: You can define modifying methods with the `@Modifying` annotation. For example,
    `INSERT`, `UPDATE`, and `DELETE` queries, or DDL statements, modify the content
    of the database. The `@Query` annotation will have the modifying query as an argument,
    and it may need binding parameters. Such a method must also be annotated with
    `@Transactional` or be run from a programmatically managed transaction. Modifying
    queries have the advantage of clearly emphasizing which column they address, and
    they may include conditions, so they can make the code clearer, compared to persisting
    or deleting the whole object. Also, changing a limited number of columns in the
    database will execute more quickly.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `@Modifying` 注解定义修改方法。例如，`INSERT`、`UPDATE` 和 `DELETE` 查询，或 DDL 语句，修改数据库的内容。`@Query`
    注解将修改查询作为参数，可能需要绑定参数。这样的方法还必须注解 `@Transactional` 或从程序管理的事务中运行。修改查询的优点是清楚地强调它们针对的是哪一列，并且可以包含条件，与持久化或删除整个对象相比，可以使代码更清晰。此外，更改数据库中有限数量的列将执行得更快。
- en: Spring Data JPA can also generate delete queries based on method names. The
    mechanism works much like the examples in table 4.1, but replacing the `find`
    keyword with `delete`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data JPA 也可以根据方法名生成删除查询。该机制与表 4.1 中的示例类似，但将 `find` 关键字替换为 `delete`。
- en: We’ll add the following methods to the `UserRepository` interface.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 `UserRepository` 接口中添加以下方法。
- en: Listing 4.19 Adding modifying methods to the `UserRepository` interface
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.19 将修改方法添加到 `UserRepository` 接口
- en: '[PRE21]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Ⓐ The `updateLevel` method will change `level` for users with the `oldLevel`
    parameter and set it to `newLevel`, as the argument of the `@Query` annotation
    indicates. The method is also annotated with `@Modifying` and `@Transactional`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ `updateLevel` 方法将根据 `@Query` 注解的参数更改 `oldLevel` 参数用户的 `level` 并将其设置为 `newLevel`。该方法还注解了
    `@Modifying` 和 `@Transactional`。
- en: Ⓑ The `deleteByLevel` method will generate a query based on the method name;
    it will remove all users with the `level` given as a parameter. The method is
    annotated with `@Transactional`. `@Modifying` isn’t necessary in this case, since
    the query is generated by the framework.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ `deleteByLevel` 方法将根据方法名生成查询；它将移除所有具有指定 `level` 的用户。该方法注解了 `@Transactional`。在这种情况下，不需要
    `@Modifying`，因为查询是由框架生成的。
- en: Ⓒ The `deleteBulkByLevel` method will remove all users with the `level` given
    as a parameter, as the argument of the `@Query` annotation indicates. The method
    is also annotated with `@Modifying` and `@Transactional`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ `deleteBulkByLevel` 方法将根据 `@Query` 注解的参数移除所有具有指定 `level` 的用户。该方法还注解了 `@Modifying`
    和 `@Transactional`。
- en: What is the difference between the `deleteByLevel` and `deleteBulkByLevel` methods?
    The first one runs a query, and it will then remove the returned instances one
    by one. If there are callback methods that control the lifecycle of each instance
    (for example, a method to be run when a user is removed), they will be executed.
    The second method will remove the users in bulk, executing a single JPQL query.
    No `User` instance (not even the ones that are already loaded in memory) will
    execute lifecycle callback methods.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`deleteByLevel` 和 `deleteBulkByLevel` 方法之间的区别是什么？第一个方法运行查询，然后逐个删除返回的实例。如果有控制每个实例生命周期的回调方法（例如，在用户被删除时运行的某个方法），它们将被执行。第二个方法将批量删除用户，执行单个
    JPQL 查询。没有任何 `User` 实例（甚至已经加载到内存中的实例）将执行生命周期回调方法。'
- en: We can now write tests for the modifying methods.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以编写修改方法的测试。
- en: Listing 4.20 Testing modifying methods
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.20 测试修改方法
- en: '[PRE22]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We’ll also write tests for the deleting methods.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将为删除方法编写测试。
- en: Listing 4.21 Testing deleting methods
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.21 测试删除方法
- en: '[PRE23]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 4.10 Query by Example
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.10 查询示例
- en: 'Query by Example (QBE) is a querying technique that does not require you to
    write classical queries to include entities and properties. It allows dynamic
    query creation and consists of three pieces: a probe, an `ExampleMatcher,` and
    an `Example`.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 查询示例（QBE）是一种不需要编写经典查询来包含实体和属性的查询技术。它允许动态创建查询，并包含三个部分：探针、`ExampleMatcher` 和 `Example`。
- en: The probe is a domain object with already-set properties. The `ExampleMatcher`
    provides the rules for matching particular properties. An `Example` puts the probe
    and the `ExampleMatcher` together and generates the query. Multiple `Example`s
    may reuse a single `ExampleMatcher`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 探针是一个具有已设置属性的域对象。`ExampleMatcher` 提供了匹配特定属性的规则。一个 `Example` 将探针和 `ExampleMatcher`
    结合起来并生成查询。多个 `Example` 可以复用单个 `ExampleMatcher`。
- en: 'These are the most appropriate use cases for QBE:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是QBE最合适的用例：
- en: When you are decoupling the code from the underlying data store API.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你将代码从底层数据存储API解耦时。
- en: When there are frequent changes to the internal structure of the domain objects,
    and they aren’t propagated to the existing queries.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当域对象的内部结构频繁变化，并且这些变化没有传播到现有查询时。
- en: When you are building a set of static or dynamic constraints to query the repository.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你构建一组静态或动态约束以查询存储库时。
- en: 'QBE has a couple of limitations:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: QBE有一些限制：
- en: It only supports starting/ending/containing regex matching for String properties,
    and exact matching for other types.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它仅支持字符串属性的开始/结束/包含正则表达式匹配，以及其他类型的精确匹配。
- en: It does not support nested or grouped property constraints, such as `username
    = ?0 or (username = ?1 and email = ?2)`.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不支持嵌套或分组属性约束，例如`username = ?0 or (username = ?1 and email = ?2)`。
- en: We won’t add any more methods to the `UserRepository` interface. We’ll only
    write tests to build the probe, the `ExampleMatcher`s, and the `Example`s.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会向`UserRepository`接口添加更多方法。我们只会编写测试来构建探针、`ExampleMatcher`和`Example`。
- en: Listing 4.22 Query By Example tests
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.22 查询示例测试
- en: '[PRE24]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Ⓐ Initialize a `User` instance and set up an `email` for it. This will represent
    the probe.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 初始化一个`User`实例并为它设置一个`email`。这将代表探针。
- en: Ⓑ Create the `ExampleMatcher` with the help of the builder pattern. Any `null`
    reference property will be ignored by the matcher. However, we need to explicitly
    ignore the `level` and `active` properties, which are primitives. If they were
    not ignored, they would be included in the matcher with their default values (0
    for `level` and `false` for `active`) and would change the generated query. We’ll
    configure the matcher condition so that the `email` property will end with a given
    string.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 使用构建器模式创建`ExampleMatcher`。任何`null`引用属性都将被匹配器忽略。然而，我们需要显式忽略`level`和`active`属性，它们是原始数据类型。如果不忽略，它们将以默认值（`level`为0和`active`为`false`）包含在匹配器中，并会改变生成的查询。我们将配置匹配器条件，以便`email`属性将以给定的字符串结尾。
- en: Ⓒ Create an `Example` that puts the probe and `ExampleMatcher` together and
    generates the query. The query will search for users that have an `email` property
    ending with the string defining the `email` of the probe.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 创建一个`Example`实例，将探针和`ExampleMatcher`结合在一起并生成查询。该查询将搜索具有以探针定义的`email`字符串结尾的`email`属性的用
    户。
- en: Ⓓ Execute the query to find all users matching the probe.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 执行查询以找到所有与探针匹配的用户。
- en: Ⓔ Verify that there are four users of this kind.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓔ 验证是否存在四种此类用户。
- en: Ⓕ Initialize a `User` instance and set up a `name` for it. This will represent
    the second probe.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓕ 初始化一个`User`实例并为它设置一个`name`。这将代表第二个探针。
- en: Ⓖ Create the `ExampleMatcher` with the help of the builder pattern. Any `null`
    reference property will be ignored by the matcher. Again, we need to explicitly
    ignore the `level` and `active` properties, which are primitives. We configure
    the matcher condition so that the match will be made on starting strings for the
    configured properties (the `username` property from the probe, in our case).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓖ 使用构建器模式创建`ExampleMatcher`。任何`null`引用属性都将被匹配器忽略。再次，我们需要显式忽略`level`和`active`属性，它们是原始数据类型。我们配置匹配器条件，以便对配置属性的开头字符串进行匹配（在我们的例子中是探针的`username`属性）。
- en: Ⓗ Create an `Example` that puts the probe and the `ExampleMatcher` together
    and generates the query. The query will search for users having a `username` property
    that starts with the string defining the `username` of the probe.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓗ 创建一个`Example`实例，将探针和`ExampleMatcher`结合在一起并生成查询。该查询将搜索具有以探针定义的`username`字符串开头的`username`属性的用
    户。
- en: Ⓘ Execute the query to find all users matching the probe.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓘ 执行查询以找到所有与探针匹配的用户。
- en: Ⓙ Verify that there are six users of this kind.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓙ 验证是否存在六种此类用户。
- en: 'To emphasize the importance of ignoring the default primitive properties, we’ll
    compare the generated queries with and without the calls to the `withIgnorePaths
    ("level",` `"active")` methods. For the first test, this is the query generated
    with the call to the `withIgnorePaths("level",` `"active")` method:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 为了强调忽略默认原始属性的重要性，我们将比较带有和不带有对`withIgnorePaths("level", "active")`方法的调用生成的查询。对于第一个测试，这是调用`withIgnorePaths("level",
    "active")`方法生成的查询：
- en: '[PRE25]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This is the query generated without the call to the `withIgnorePaths("level",
    "active")` method:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这是调用`withIgnorePaths("level", "active")`方法之前生成的查询：
- en: '[PRE26]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'For the second test, this is the query generated with the call to the `withIgnorePaths("level",`
    `"active")` method:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二次测试，这是调用`withIgnorePaths("level", "active")`方法生成的查询：
- en: '[PRE27]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This is the query generated without the call to the `withIgnorePaths("level",
    "active")` method:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这是未调用`withIgnorePaths("level", "active")`方法的查询生成的：
- en: '[PRE28]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Note the conditions added on primitive properties when the `withIgnorePaths("level",`
    `"active")` method was removed:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在移除`withIgnorePaths("level", "active")`方法时添加到原始属性上的条件：
- en: '[PRE29]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This will change the query result.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这将改变查询结果。
- en: Summary
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: You can create and configure a Spring Data JPA project using Spring Boot.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用Spring Boot创建和配置一个Spring Data JPA项目。
- en: You can define and use a series of query methods to access repositories by using
    the Spring Data JPA query builder mechanisms.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用Spring Data JPA查询构建器机制定义并使用一系列查询方法来通过仓库访问。
- en: Spring Data JPA provides capabilities for limiting query results, sorting, paging,
    and streaming the results.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Data JPA提供了限制查询结果、排序、分页和流式传输结果的能力。
- en: You can use the `@Query` annotation to define both non-native and native custom
    queries.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用`@Query`注解来定义非原生和原生的自定义查询。
- en: You can implement projections to shape the return types and selectively return
    attributes of entities, and you can create and use modifying queries to update
    and delete entities.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以实现投影来塑造返回类型，并选择性地返回实体的属性，您还可以创建和使用修改查询来更新和删除实体。
- en: 'The Query by Example (QBE) querying technique allows for dynamic query creation
    and consists of three pieces: a probe, an `ExampleMatcher`, and an `Example`.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询示例（QBE）查询技术允许动态创建查询，并包括三个部分：一个探测器、一个`ExampleMatcher`和一个`Example`。
