- en: Chapter 14\. Exceptions
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第14章\. 异常
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Understanding exceptions
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解异常
- en: Handling exceptions in Python
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python中处理异常
- en: Using the `with` keyword
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `with` 关键字
- en: This chapter discusses exceptions, which are language features specifically
    aimed at handling unusual circumstances during the execution of a program. The
    most common use for exceptions is to handle errors that arise during the execution
    of a program, but they can also be used effectively for many other purposes. Python
    provides a comprehensive set of exceptions, and new ones can be defined by users
    for their own purposes.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了异常，这是专门针对在程序执行期间处理异常情况的语言特性。异常最常见的使用是处理程序执行期间出现的错误，但它们也可以有效地用于许多其他目的。Python提供了一套全面的异常，用户可以定义新的异常以供自己使用。
- en: The concept of exceptions as an error-handling mechanism has been around for
    some time. C and Perl, the most commonly used systems and scripting languages,
    don’t provide any exception capabilities, and even programmers who use languages
    such as C++, which does include exceptions, are often unfamiliar with them. This
    chapter doesn’t assume familiarity with exceptions on your part but instead provides
    detailed explanations.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 异常作为错误处理机制的概念已经存在了一段时间。C和Perl，最常用的系统和脚本语言，都不提供任何异常功能，甚至使用像C++这样的语言（它确实包括异常）的程序员通常也不熟悉它们。本章不假设你对异常有了解，而是提供详细的解释。
- en: 14.1\. Introduction to exceptions
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1\. 异常简介
- en: The following sections provide an introduction to exceptions and how they’re
    used. If you’re already familiar with exceptions, you can skip directly to “[Exceptions
    in Python](#ch14lev1sec2)” ([section 14.2](#ch14lev1sec2)).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分提供了异常的介绍以及它们是如何被使用的。如果你已经熟悉异常，可以直接跳转到“[Python中的异常](#ch14lev1sec2)”（[第14.2节](#ch14lev1sec2)）。
- en: 14.1.1\. General philosophy of errors and exception handling
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.1.1\. 错误和异常处理的通用哲学
- en: Any program may encounter errors during its execution. For the purposes of illustrating
    exceptions, I look at the case of a word processor that writes files to disk and
    that therefore may run out of disk space before all of its data is written. There
    are various ways of coming to grips with this problem.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 任何程序在执行过程中都可能遇到错误。为了说明异常，我考虑了一个字处理器将文件写入磁盘的情况，因此可能在所有数据都写入之前就耗尽了磁盘空间。有各种方法来处理这个问题。
- en: 'Solution 1: Don’t handle the problem'
  id: totrans-11
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案1：不处理问题
- en: The simplest way to handle this disk-space problem is to assume that there’ll
    always be adequate disk space for whatever files you write and that you needn’t
    worry about it. Unfortunately, this option seems to be the most commonly used.
    It’s usually tolerable for small programs dealing with small amounts of data,
    but it’s completely unsatisfactory for more mission-critical programs.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这种磁盘空间问题的最简单方法是假设你写的任何文件都会有足够的磁盘空间，你不需要担心这个问题。不幸的是，这似乎是最常用的选项。对于处理少量数据的小程序来说，这通常是可容忍的，但对于更关键的程序来说，这完全不能令人满意。
- en: 'Solution 2: All functions return success/failure status'
  id: totrans-13
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案2：所有函数返回成功/失败状态
- en: The next level of sophistication in error handling is realizing that errors
    will occur and defining a methodology using standard language mechanisms for detecting
    and handling them. There are numerous ways to do this, but a typical method is
    to have each function or procedure return a status value that indicates whether
    that function or procedure call executed successfully. Normal results can be passed
    back in a call-by-reference parameter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理的下一个高级层次是意识到错误会发生，并定义一种使用标准语言机制来检测和处理错误的方法。有无数种方法可以做到这一点，但典型的方法是让每个函数或过程返回一个状态值，表示该函数或过程调用是否成功执行。正常结果可以通过引用参数传递回调用。
- en: Consider how this solution might work with a hypothetical word-processing program.
    Assume that the program invokes a single high-level function, `save_to_file`,
    to save the current document to file. This function calls subfunctions to save
    different parts of the entire document to the file, such as `save_text_to_file`
    to save the actual document text, `save_prefs_to_file` to save user preferences
    for that document, `save_formats_to_file` to save user-defined formats for the
    document, and so forth. Any of these subfunctions may in turn call its own subfunctions,
    which save smaller pieces to the file. At the bottom are built-in system functions,
    which write primitive data to the file and report on the success or failure of
    the file-writing operations.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下这个解决方案如何与一个假设的文字处理程序一起工作。假设程序调用一个高级函数`save_to_file`来将当前文档保存到文件。这个函数调用子函数将整个文档的不同部分保存到文件中，例如`save_text_to_file`用于保存实际文档文本，`save_prefs_to_file`用于保存该文档的用户偏好设置，`save_formats_to_file`用于保存用户定义的文档格式，等等。这些子函数中的任何一个都可能进一步调用自己的子函数，将更小的部分保存到文件中。在底层是内置的系统函数，它们将原始数据写入文件，并报告文件写入操作的成功或失败。
- en: 'You could put error-handling code into every function that might get a disk-space
    error, but that practice makes little sense. The only thing the error handler
    will be able to do is put up a dialog box telling the user that there’s no more
    disk space and asking the user to remove some files and save again. It wouldn’t
    make sense to duplicate this code everywhere you do a disk write. Instead, put
    one piece of error-handling code into the main disk-writing function: `save_to_file`.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在可能遇到磁盘空间错误的每个函数中放入错误处理代码，但这种做法几乎没有意义。错误处理器唯一能做的就是弹出一个对话框告诉用户没有更多磁盘空间，并要求用户删除一些文件再次保存。在每次磁盘写入操作中重复此代码是没有意义的。相反，将一段错误处理代码放入主要的磁盘写入函数中：`save_to_file`。
- en: 'Unfortunately, for `save_to_file` to be able to determine when to call this
    error-handling code, every function it calls that writes to disk must itself check
    for disk space errors and return a status value indicating the success or failure
    of the disk write. In addition, the `save_to_file` function must explicitly check
    every call to a function that writes to disk, even though it doesn’t care about
    which function fails. The code, using C-like syntax, looks something like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，为了让`save_to_file`能够确定何时调用此错误处理代码，它调用的每个写入磁盘的函数都必须自己检查磁盘空间错误，并返回一个表示磁盘写入成功或失败的状态值。此外，`save_to_file`函数必须显式检查每个调用写入磁盘的函数，即使它不关心哪个函数失败。使用类似C语言的语法，代码看起来可能像这样：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The same applies to `save_prefs_to_file`, `save_formats_to_file`, and all other
    functions that either write to `filename` directly or (in any way) call functions
    that write to `filename`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 同样适用于`save_prefs_to_file`、`save_formats_to_file`以及所有直接写入`filename`或以任何方式调用写入`filename`的函数的其他函数。
- en: Under this methodology, code to detect and handle errors can become a significant
    portion of the entire program, because every function and procedure containing
    calls that might result in an error needs to contain code to check for an error.
    Often, programmers don’t have the time or the energy to put in this type of complete
    error checking, and programs end up being unreliable and crash-prone.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法论下，用于检测和处理错误的代码可能成为整个程序的一个重要部分，因为每个可能引发错误的函数和过程都需要包含检查错误的代码。通常，程序员没有时间或精力进行这种完整的错误检查，结果程序变得不可靠且容易崩溃。
- en: 'Solution 3: The exception mechanism'
  id: totrans-21
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案3：异常机制
- en: 'It’s obvious that most of the error-checking code in the previous type of program
    is largely repetitive: The code checks for errors on each attempted file write
    and passes an error status message back up to the calling procedure if an error
    is detected. The disk-space error is handled in only one place: the top-level
    `save_to_file`. In other words, most of the error-handling code is plumbing code
    that connects the place where an error is generated with the place where it’s
    handled. What you really want to do is get rid of this plumbing and write code
    that looks something like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在前面类型程序中的大部分错误检查代码都是重复的：代码在每次尝试文件写入时检查错误，并在检测到错误时将错误状态信息传递回调用过程。磁盘空间错误仅在顶级`save_to_file`中处理。换句话说，大部分错误处理代码是管道代码，它将错误发生的地方与错误处理的地方连接起来。你真正想要做的是消除这种管道，编写看起来像这样的代码：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The error-handling code is completely removed from the lower-level functions;
    an error (if it occurs) is generated by the built-in file writing routines and
    propagates directly to the `save_to_file` routine, where your error-handling code
    will (presumably) take care of it. Although you can’t write this code in C, languages
    that offer exceptions permit exactly this sort of behavior—and of course, Python
    is one such language. Exceptions let you write clearer code and handle error conditions
    better.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理代码完全从底层函数中移除；错误（如果发生）由内置的文件写入例程生成，并直接传播到`save_to_file`例程，在那里你的错误处理代码（可能）会处理它。虽然你不能在C语言中编写此代码，但提供异常的语言允许这种类型的行为——当然，Python就是这样一种语言。异常让你能够编写更清晰的代码并更好地处理错误条件。
- en: 14.1.2\. A more formal definition of exceptions
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.1.2\. 异常的更正式定义
- en: The act of generating an exception is called *raising* or *throwing* an exception.
    In the previous example, all exceptions are raised by the disk-writing functions,
    but exceptions can also be raised by any other functions or can be explicitly
    raised by your own code. In the previous example, the low-level disk-writing functions
    (not seen in the code) would throw an exception if the disk were to run out of
    space.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 生成异常的行为被称为*抛出*或*引发*异常。在先前的例子中，所有异常都是由磁盘写入函数抛出的，但异常也可以由任何其他函数抛出，或者可以由你自己的代码显式抛出。在先前的例子中，如果磁盘空间不足，低级别的磁盘写入函数（在代码中未显示）会抛出异常。
- en: The act of responding to an exception is called *catching* an exception, and
    the code that handles an exception is called *exception-handling code* or just
    an *exception handler*. In the example, the `except that...` line catches the
    disk-write exception, and the code that would be in place of the `...handle the
    error...` line would be an exception handler for disk-write (out of space) exceptions.
    There may be other exception handlers for other types of exceptions or even other
    exception handlers for the same type of exception but at another place in your
    code.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对异常做出响应的行为被称为*捕获*异常，处理异常的代码被称为*异常处理代码*或简称为*异常处理器*。在例子中，`except that...`行捕获了磁盘写入异常，而`...handle
    the error...`行所在的位置的代码将是一个磁盘写入（空间不足）异常的异常处理器。可能还有其他类型的异常处理器，甚至可能是同一类型的异常处理器，但位于你的代码的另一个位置。
- en: 14.1.3\. Handling different types of exceptions
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.1.3\. 处理不同类型的异常
- en: Depending on exactly what event causes an exception, a program may need to take
    different actions. An exception raised when disk space is exhausted needs to be
    handled quite differently from an exception that’s raised if you run out of memory,
    and both of these exceptions are completely different from an exception that arises
    when a divide-by-zero error occurs. One way to handle these different types of
    exceptions is to globally record an error message indicating the cause of the
    exception, and have all exception handlers examine this error message and take
    appropriate action. In practice, a different method has proved to be much more
    flexible.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 根据确切导致异常的事件，程序可能需要采取不同的行动。当磁盘空间耗尽时抛出的异常需要与如果你内存不足时抛出的异常完全不同的处理方式，而且这两种异常与当发生除以零错误时出现的异常也完全不同。处理这些不同类型的异常的一种方法是在全局记录一个指示异常原因的错误消息，并让所有异常处理程序检查这个错误消息并采取适当的行动。在实践中，一种不同的方法已被证明要灵活得多。
- en: Rather than defining a single kind of exception, Python, like most modern languages
    that implement exceptions, defines different types of exceptions corresponding
    to various problems that may occur. Depending on the underlying event, different
    types of exceptions may be raised. In addition, the code that catches exceptions
    may be told to catch only certain types. This feature is used in the pseudocode
    in solution 3 earlier in this chapter that said `except that, if the disk runs
    out of space . . ., do this`; this pseudocode specifies that this particular exception-handling
    code is interested only in disk-space exceptions. Another type of exception wouldn’t
    be caught by that exception-handling code. That exception would be caught by an
    exception handler that was looking for numeric exceptions, or (if no such exception
    handler existed) it would cause the program to exit prematurely with an error.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是定义一种单一的异常类型，Python，就像大多数实现异常的现代语言一样，定义了与可能发生的各种问题相对应的不同类型的异常。根据底层事件，可能会引发不同类型的异常。此外，捕获异常的代码可能被指示只捕获某些类型。这一特性在本书前面解决方案3中的伪代码中得到了应用，该伪代码表示“如果磁盘空间不足，则执行此操作”；这个伪代码指定了这段特定的异常处理代码只对磁盘空间异常感兴趣。其他类型的异常不会被该异常处理代码捕获。这种异常会被寻找数值异常的异常处理器捕获，或者（如果不存在这样的异常处理器）会导致程序因错误而提前退出。
- en: 14.2\. Exceptions in Python
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2. Python中的异常
- en: The remaining sections of this chapter talk specifically about the exception
    mechanisms built into Python. The entire Python exception mechanism is built around
    an object-oriented paradigm, which makes it both flexible and expandable. If you
    aren’t familiar with object-oriented programming (OOP), you don’t need to learn
    object-oriented techniques to use exceptions.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的剩余部分将专门讨论Python中内置的异常机制。整个Python异常机制都是围绕面向对象范式构建的，这使得它既灵活又可扩展。如果你不熟悉面向对象编程（OOP），你不需要学习面向对象技术来使用异常。
- en: An exception is an object generated automatically by Python functions with a
    `raise` statement. After the object is generated, the `raise` statement, which
    raises an exception, causes execution of the Python program to proceed in a manner
    different from what would normally occur. Instead of proceeding with the next
    statement after the `raise` or whatever generated the exception, the current call
    chain is searched for a handler that can handle the generated exception. If such
    a handler is found, it’s invoked and may access the exception object for more
    information. If no suitable exception handler is found, the program aborts with
    an error message.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 异常是由Python函数使用`raise`语句自动生成的对象。在对象生成后，引发异常的`raise`语句会导致Python程序的执行方式与通常情况不同。在执行`raise`或引发异常的代码之后的下一个语句之前，会搜索一个可以处理生成的异常的处理程序。如果找到了这样的处理程序，它就会被调用，并且可以访问异常对象以获取更多信息。如果没有找到合适的异常处理程序，程序会因错误而终止。
- en: '|  |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Easier to ask forgiveness than permission**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**求其宽恕，不如求其许可**'
- en: The way that Python thinks about handling error situations in general is different
    from that common in languages such as Java, for example. Those languages rely
    on checking for possible errors as much as possible before they occur, since handling
    exceptions after they occur tends to be costly in various ways. This style is
    described in the first section of this chapter and is sometimes described as a
    look before you leap (LBYL) approach.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Python处理错误情况的方式与Java等语言中常见的处理方式不同。这些语言在发生之前尽可能多地检查可能出现的错误，因为异常发生后的处理往往在各方面都代价高昂。这种风格在本章的第一节中进行了描述，有时被称为“三思而后行”（LBYL）方法。
- en: Python, on the other hand, is more likely to rely on exceptions to deal with
    errors after they occur. Although this reliance may seem to be risky, if exceptions
    are used well, the code is less cumbersome and easier to read, and errors are
    dealt with only as they occur. This Pythonic approach to handling errors is often
    described by the phrase “easier to ask forgiveness than permission” (EAFP).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，Python更有可能依赖异常来处理已发生的错误。尽管这种依赖可能看起来有些风险，但如果异常使用得当，代码会更简洁、更容易阅读，并且错误只会在发生时处理。这种Python处理错误的方法通常用短语“求其宽恕，不如求其许可”（EAFP）来描述。
- en: '|  |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 14.2.1\. Types of Python exceptions
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.2.1. Python异常的类型
- en: 'It’s possible to generate different types of exceptions to reflect the actual
    cause of the error or exceptional circumstance being reported. Python 3.6 provides
    several exception types:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能生成不同类型的异常来反映报告的错误或异常情况的真实原因。Python 3.6提供了几种异常类型：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The Python exception set is hierarchically structured, as reflected by the indentation
    in this list of exceptions. As you saw in a previous chapter, you can obtain an
    alphabetized list from the `__builtins__` module.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Python的异常集是按层次结构组织的，如本异常列表中的缩进所示。正如你在前一章中看到的，你可以从`__builtins__`模块中获取一个按字母顺序排列的列表。
- en: Each type of exception is a Python class, which inherits from its parent exception
    type. But if you’re not into OOP yet, don’t worry about that. An `IndexError`,
    for example, is also a `LookupError` and (by inheritance) an `Exception` and also
    a `BaseException`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 每种异常类型都是一个Python类，它继承自其父异常类型。但如果你还没有接触面向对象编程，不必担心。例如，`IndexError`也是一个`LookupError`，通过继承也是`Exception`和`BaseException`。
- en: 'This hierarchy is deliberate: Most exceptions inherit from `Exception`, and
    it’s strongly recommended that any user-defined exceptions also subclass `Exception`,
    not `BaseException`. The reason is that if you have code set up like this'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这种层次结构是有意为之的：大多数异常都继承自`Exception`，强烈建议任何用户定义的异常也继承自`Exception`，而不是`BaseException`。原因是如果你这样设置代码
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: you could still interrupt the code in the `try` block with Ctrl-C without triggering
    the exception-handling code, because the `KeyboardInterrupt` exception is *not*
    a subclass of `Exception`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你仍然可以在`try`块中通过Ctrl-C中断代码，而不会触发异常处理代码，因为`KeyboardInterrupt`异常不是`Exception`的子类。
- en: You can find an explanation of the meaning of each type of exception in the
    documentation, but you’ll rapidly become acquainted with the most common types
    as you program!
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在文档中找到每种异常含义的解释，但随着编程的深入，你将迅速熟悉最常见的异常类型！
- en: 14.2.2\. Raising exceptions
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.2.2. 抛出异常
- en: 'Exceptions are raised by many of the Python built-in functions:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Python内置函数都会引发异常：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Error-checking code built into Python detects that the second input line requests
    an element at a list index that doesn’t exist and raises an `IndexError` exception.
    This exception propagates all the way back to the top level (the interactive Python
    interpreter), which handles it by printing out a message stating that the exception
    has occurred.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Python内置的错误检查代码检测到第二行输入请求的列表索引不存在，并引发一个`IndexError`异常。这个异常会一直传播到顶级（交互式Python解释器），它通过打印出一条消息来处理这个异常，说明异常已经发生。
- en: Exceptions may also be raised explicitly in your own code through the use of
    the `raise` statement. The most basic form of this statement is
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过使用`raise`语句在你的代码中显式地引发异常。这个语句的最基本形式是
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `exception(args)` part of the code creates an exception. The arguments to
    the new exception are typically values that aid you in determining what happened—something
    that I discuss next. After the exception has been created, `raise` throws it upward
    along the stack of Python functions that were invoked in getting to the line containing
    the `raise` statement. The new exception is thrown up to the nearest (on the stack)
    exception catcher looking for that type of exception. If no catcher is found on
    the way to the top level of the program, the program terminates with an error
    or (in an interactive session) causes an error message to be printed to the console.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中的`exception(args)`部分创建了一个异常。新异常的参数通常是帮助你确定发生了什么的值——这一点我将在下一节讨论。异常创建后，`raise`语句会将它向上抛出到调用`raise`语句的Python函数堆栈中。新的异常会抛到最近的（在堆栈上的）异常捕获器，寻找该类型的异常。如果在程序的最高级别找不到捕获器，程序将因错误而终止（在交互式会话中）或在控制台打印出错误信息。
- en: 'Try the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试以下操作：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The use of `raise` here generates what at first glance looks similar to all
    the Python list-index error messages you’ve seen so far. Closer inspection reveals
    this isn’t the case. The actual error reported isn’t as serious as those other
    ones.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里使用`raise`生成的错误消息乍一看与迄今为止看到的所有Python列表索引错误消息相似。但仔细检查会发现并非如此。实际报告的错误并不像那些其他错误那样严重。
- en: The use of a string argument when creating exceptions is common. Most of the
    built-in Python exceptions, if given a first argument, assume that the argument
    is a message to be shown to you as an explanation of what happened. This isn’t
    always the case, though, because each exception type is its own class, and the
    arguments expected when a new exception of that class is created are determined
    entirely by the class definition. Also, programmer-defined exceptions, created
    by you or by other programmers, are often used for reasons other than error handling;
    as such, they may not take a text message.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建异常时使用字符串参数是常见的。大多数内置的Python异常，如果提供了第一个参数，假设该参数是一个消息，用于向您显示作为发生事件的解释。但这并不总是如此，因为每个异常类型都是其自己的类，当创建该类的新异常时预期的参数完全由类定义决定。此外，程序员定义的异常，无论是您创建的还是其他程序员创建的，通常用于除错误处理之外的原因；因此，它们可能不包含文本消息。
- en: 14.2.3\. Catching and handling exceptions
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.2.3. 捕获和处理异常
- en: The important thing about exceptions isn’t that they cause a program to halt
    with an error message. Achieving that function in a program is never much of a
    problem. What’s special about exceptions is that they don’t have to cause the
    program to halt. By defining appropriate exception handlers, you can ensure that
    commonly encountered exceptional circumstances don’t cause the program to fail;
    perhaps they display an error message to the user or do something else, perhaps
    even fix the problem, but they don’t crash the program.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 关于异常的重要之处不在于它们会导致程序因错误消息而停止。在程序中实现这种功能从来不是什么大问题。异常的特殊之处在于它们不必导致程序停止。通过定义适当的异常处理程序，您可以确保常见的异常情况不会导致程序失败；也许它们会向用户显示错误消息或执行其他操作，甚至可能是修复问题，但它们不会使程序崩溃。
- en: 'The basic Python syntax for exception catching and handling is as follows,
    using the `try`, `except`, and sometimes `else` keywords:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Python用于捕获和处理异常的基本语法如下，使用`try`、`except`和有时`else`关键字：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'A `try` statement is executed by first executing the code in the `body` part
    of the statement. If this execution is successful (that is, no exceptions are
    thrown to be caught by the `try` statement), the `else_body` is executed, and
    the `try` statement is finished. Because there is a `finally` statement, `finally_body`
    is executed. If an exception is thrown to the `try`, the `except` clauses are
    searched sequentially for one whose associated exception type matches that which
    was thrown. If a matching `except` clause is found, the thrown exception is assigned
    to the variable named after the associated exception type, and the exception code
    body associated with the matching exception is executed. If the line `except exception_type`
    as `var`: matches some thrown exception `exc`, the variable `var` is created,
    and `exc` is assigned as the value of `var` before the exception-handling code
    of the `except` statement is executed. You don’t need to put in `var`; you can
    say something like `except exception_type:`, which still catches exceptions of
    the given type but doesn’t assign them to any variable.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`try`语句通过首先执行语句的`body`部分来执行。如果此执行成功（即没有抛出要由`try`语句捕获的异常），则执行`else_body`，然后`try`语句完成。由于存在`finally`语句，因此会执行`finally_body`。如果向`try`抛出异常，则会按顺序搜索`except`子句，寻找与抛出的异常类型匹配的一个。如果找到匹配的`except`子句，则抛出的异常被分配给与关联异常类型命名的变量，并执行与匹配异常关联的异常代码体。如果`except
    exception_type as var:`行与某些抛出的异常`exc`匹配，则创建变量`var`，在执行`except`语句的异常处理代码之前，将`exc`分配给`var`的值。您不需要放入`var`；您可以说类似`except
    exception_type:`的内容，这仍然可以捕获给定类型的异常，但不会将它们分配给任何变量。'
- en: If no matching `except` clause is found, the thrown exception can’t be handled
    by that `try` statement, and the exception is thrown farther up the call chain
    in hope that some enclosing `try` will be able to handle it.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有找到匹配的`except`子句，则抛出的异常无法由该`try`语句处理，异常将被抛到调用链的更高处，希望某个封装的`try`能够处理它。
- en: 'The last `except` clause of a `try` statement can optionally refer to no exception
    types at all, in which case it handles all types of exceptions. This technique
    can be convenient for some debugging and extremely rapid prototyping but generally
    isn’t a good idea: all errors are hidden by the `except` clause, which can lead
    to some confusing behavior on the part of your program.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`try` 语句的最后一条 `except` 子句可以可选地不引用任何异常类型，在这种情况下，它将处理所有类型的异常。这种技术对于某些调试和极快的原型设计可能很方便，但通常不是一个好主意：所有错误都被
    `except` 子句隐藏，这可能导致你的程序出现一些令人困惑的行为。'
- en: The `else` clause of a `try` statement is optional and rarely used. This clause
    is executed if and only if the `body` of the `try` statement executes without
    throwing any errors.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`try` 语句的 `else` 子句是可选的，很少使用。这个子句仅在 `try` 语句的主体执行而没有抛出任何错误时执行。'
- en: The `finally` clause of a `try` statement is also optional and executes after
    the `try`, `except`, and `else` sections have executed. If an exception is raised
    in the `try` block and isn’t handled by any of the `except` blocks, that exception
    is raised again after the `finally` block executes. Because the `finally` block
    always executes, it gives you a chance to include code to clean up after any exception
    handling by closing files, resetting variables, and so on.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`try` 语句的 `finally` 子句也是可选的，并在 `try`、`except` 和 `else` 部分执行后执行。如果在 `try` 块中引发异常，并且没有被任何
    `except` 块处理，那么在 `finally` 块执行后，该异常将被再次引发。因为 `finally` 块总是会执行，这给你一个机会来包含代码，以便在关闭文件、重置变量等操作后清理任何异常处理。'
- en: '|  |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Try this: Catching exceptions'
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这样做：捕获异常
- en: Write code that gets two numbers from the user and divides the first number
    by the second. Check for and catch the exception that occurs if the second number
    is zero (`ZeroDivisionError`).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 编写代码，从用户那里获取两个数字并将第一个数字除以第二个数字。检查并捕获如果第二个数字为零时发生的异常（`ZeroDivisionError`）。
- en: '|  |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 14.2.4\. Defining new exceptions
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.2.4. 定义新异常
- en: 'You can easily define your own exception. The following two lines do this for
    you:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以轻松地定义自己的异常。以下两行为你做了这件事：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This code creates a class that inherits everything from the base `Exception`
    class. But you don’t have to worry about that if you don’t want to.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个从基类 `Exception` 继承所有内容的类。但如果你不想这么做，你不必担心。
- en: 'You can raise, catch, and handle this exception like any other exception. If
    you give it a single argument (and you don’t catch and handle it), it’s printed
    at the end of the traceback:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像处理任何其他异常一样引发、捕获和处理这个异常。如果你给它一个单一参数（并且你没有捕获和处理它），它将在跟踪信息结束时打印出来：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This argument, of course, is available to a handler you write as well:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个参数也适用于你编写的处理程序：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The result is
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you raise your exception with multiple arguments, these arguments are delivered
    to your handler as a tuple, which you can access through the `args` variable of
    the error:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你用多个参数引发你的异常，这些参数作为元组传递给你的处理程序，你可以通过错误的 `args` 变量访问它：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The result is
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Because an exception type is a regular class in Python and happens to inherit
    from the root `Exception` class, it’s a simple matter to create your own subhierarchy
    of exception types for use by your own code. You don’t have to worry about this
    process on a first read of this book. You can always come back to it after you’ve
    read [chapter 15](kindle_split_027.html#ch15). Exactly how you create your own
    exceptions depends on your particular needs. If you’re writing a small program
    that may generate only a few unique errors or exceptions, subclass the main `Exception`
    class as you’ve done here. If you’re writing a large, multifile code library with
    a special goal in mind—say, weather forecasting—you may decide to define a unique
    class called `WeatherLibraryException` and then define all the unique exceptions
    of the library as subclasses of `WeatherLibraryException`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 因为异常类型在 Python 中是一个常规类，并且恰好继承自根 `Exception` 类，所以创建自己的异常子层次结构以供自己的代码使用是一件简单的事情。你不必在阅读这本书的第一遍时担心这个过程。你可以在阅读完[第15章](kindle_split_027.html#ch15)后再回来。你如何创建自己的异常取决于你的特定需求。如果你正在编写一个可能只生成几个独特错误或异常的小程序，就像这里所做的那样，你可以将主
    `Exception` 类作为子类。如果你正在编写一个具有特殊目标的大型多文件代码库——比如说，天气预报——你可能会决定定义一个名为 `WeatherLibraryException`
    的独特类，然后定义库的所有独特异常作为 `WeatherLibraryException` 的子类。
- en: '|  |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Quick Check: Exceptions as classes'
  id: totrans-88
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：异常作为类
- en: If `MyError` inherits from `Exception`, what is the difference between `except
    Exception as e` and `except MyError as e`?
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `MyError` 继承自 `Exception`，那么 `except Exception as e` 和 `except MyError as
    e` 之间有什么区别？
- en: '|  |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 14.2.5\. Debugging programs with the assert statement
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.2.5\. 使用断言语句调试程序
- en: 'The `assert` statement is a specialized form of the `raise` statement:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`assert` 语句是 `raise` 语句的专用形式：'
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `AssertionError` exception with the optional `argument` is raised if the
    `expression` evaluates to `False` and the system variable `__debug__` is `True`.
    The `__debug__` variable defaults to `True` and is turned off by starting the
    Python interpreter with the `-O` or `-OO` option or by setting the system variable
    `PYTHONOPTIMIZE` to `True`. The optional argument can be used to include an explanation
    of the assertion.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `expression` 评估为 `False` 并且系统变量 `__debug__` 是 `True`，则会引发带有可选 `argument`
    的 `AssertionError` 异常。`__debug__` 变量默认为 `True`，可以通过使用 `-O` 或 `-OO` 选项启动 Python
    解释器或通过将系统变量 `PYTHONOPTIMIZE` 设置为 `True` 来关闭它。可选参数可以用来包含对断言的解释。
- en: 'The code generator creates no code for assertion statements if `__debug__`
    is `False`. You can use `assert` statements to instrument your code with debug
    statements during development and leave them in the code for possible future use
    with no runtime cost during regular use:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `__debug__` 是 `False`，代码生成器不会为断言语句生成代码。您可以在开发期间使用 `assert` 语句将调试语句插入到代码中，并在代码中保留它们以供将来可能的用途，而不会在常规使用期间产生运行时成本：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '|  |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Try this: The assert statement'
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：断言语句
- en: Write a simple program that gets a number from the user and then uses the `assert`
    statement to raise an exception if the number is zero. Test to make sure that
    the `assert` statement fires; then turn it off, using one of the methods mentioned
    in this section.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个简单的程序，从用户那里获取一个数字，然后使用 `assert` 语句在数字为零时引发异常。测试以确保 `assert` 语句被触发；然后关闭它，使用本节中提到的任何一种方法。
- en: '|  |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 14.2.6\. The exception inheritance hierarchy
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.2.6\. 异常继承层次结构
- en: In this section, I expand on an earlier notion that Python exceptions are hierarchically
    structured and on what that structure means in terms of how `except` clauses catch
    exceptions.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我扩展了之前关于 Python 异常是层次结构化的概念，以及这个结构在 `except` 子句捕获异常方面的含义。
- en: The following code
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'catches two types of exceptions: `IndexError` and `LookupError`. It just so
    happens that `IndexError` is a subclass of `LookupError`. If `body` throws an
    `IndexError`, that error is first examined by the `except LookupError as error:`
    line, and because an `IndexError` is a `LookupError` by inheritance, the first
    `except` succeeds. The second `except` clause is never used because it’s subsumed
    by the first `except` clause.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获两种类型的异常：`IndexError` 和 `LookupError`。碰巧的是 `IndexError` 是 `LookupError` 的子类。如果
    `body` 抛出 `IndexError`，则该错误首先由 `except LookupError as error:` 行检查，因为 `IndexError`
    通过继承是 `LookupError`，第一个 `except` 子句成功。第二个 `except` 子句永远不会使用，因为它被第一个 `except` 子句包含。
- en: Conversely, flipping the order of the two `except` clauses could potentially
    be useful; then the first clause would handle `IndexError` exceptions, and the
    second clause would handle any `LookupError` exceptions that aren’t `IndexError`
    errors.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，交换两个 `except` 子句的顺序可能是有用的；那么第一个子句将处理 `IndexError` 异常，第二个子句将处理任何不是 `IndexError`
    错误的 `LookupError` 异常。
- en: '14.2.7\. Example: a disk-writing program in Python'
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.2.7\. 示例：Python中的磁盘写入程序
- en: 'In this section, I revisit the example of a word-processing program that needs
    to check for disk out-of-space conditions as it writes a document to disk:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我重新审视了需要检查磁盘空间不足条件的字处理程序示例：
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice how unobtrusive the error-handling code is; it’s wrapped around the main
    sequence of disk-writing calls in the `save_to_file` function. None of the subsidiary
    disk-writing functions needs any error-handling code. It would be easy to develop
    the program first and add error-handling code later. That’s often what programmers
    do, although this practice isn’t the optimal ordering of events.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意错误处理代码是如何不引人注目的；它在 `save_to_file` 函数中的主要磁盘写入调用序列周围包装。没有任何辅助磁盘写入函数需要任何错误处理代码。首先开发程序然后添加错误处理代码很容易。程序员通常就是这样做的，尽管这种事件顺序并不是最优的。
- en: As another note of interest, this code doesn’t respond specifically to disk-full
    errors; rather, it responds to `IOError` exceptions, which Python’s built-in functions
    raise automatically whenever they can’t complete an I/O request, for whatever
    reason. That’s probably satisfactory for your needs, but if you need to identify
    disk-full conditions, you can do a couple of things. The `except` body can check
    to see how much room is available on disk. If the disk is out of space, clearly,
    the problem is a disk-full problem and should be handled in this `except` body;
    otherwise, the code in the `except` body can throw the `IOError` farther up the
    call chain to be handled by some other `except`. If that solution isn’t sufficient,
    you can do something more extreme, such as going into the C source for the Python
    disk-writing functions and raising your own `DiskFull` exceptions as necessary.
    I don’t recommend the latter option, but it’s nice to know that this possibility
    exists if you need to use it.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的点是，此代码不会专门响应磁盘满的错误；相反，它响应 `IOError` 异常，Python 的内置函数在无法完成 I/O 请求时自动引发该异常，无论原因如何。这可能满足您的需求，但如果您需要识别磁盘满的情况，您可以做一些事情。`except`
    块可以检查磁盘上还有多少空间。如果磁盘空间不足，显然问题是磁盘满的问题，应该在 `except` 块中处理；否则，`except` 块中的代码可以将 `IOError`
    抛向调用链的更高层，由其他 `except` 处理。如果这个解决方案不够充分，您可以采取更极端的措施，例如进入 Python 磁盘写入函数的 C 源代码，并在需要时引发自己的
    `DiskFull` 异常。我不推荐后者，但如果你需要使用它，了解这种可能性是好的。
- en: '14.2.8\. Example: exceptions in normal evaluation'
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.2.8\. 示例：正常评估中的异常
- en: Exceptions are most often used in error handling but can also be remarkably
    useful in certain situations involving what you’d think of as normal evaluation.
    Consider the problems in implementing something that works like a spreadsheet.
    Like most spreadsheets, it would have to permit arithmetic operations involving
    cells, and it would also permit cells to contain values other than numbers. In
    such an application, blank cells used in a numerical calculation might be considered
    to contain the value `0`, and cells containing any other nonnumeric string might
    be considered invalid and represented as the Python value `None`. Any calculation
    involving an invalid value should return an invalid value.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 异常通常用于错误处理，但在某些涉及正常评估的情况中也非常有用。考虑实现类似电子表格的功能时的问题。像大多数电子表格一样，它必须允许涉及单元格的算术运算，并且它还允许单元格包含除数字以外的值。在这种情况下，在数值计算中使用的空白单元格可能被认为是包含值
    `0`，而包含任何其他非数字字符串的单元格可能被认为是无效的，并以 Python 值 `None` 表示。涉及无效值的任何计算都应该返回无效值。
- en: 'The first step is to write a function that evaluates a string from a cell of
    the spreadsheet and returns an appropriate value:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是编写一个函数，该函数评估电子表格单元格中的字符串并返回适当的值：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Python’s exception-handling ability makes this function a simple one to write.
    The code tries to convert the string from the cell to a number and return it in
    a `try` block using the `float` built-in function. `float` raises the `ValueError`
    exception if it can’t convert its string argument to a number, so the code catches
    that exception and returns either `0` or `None`, depending on whether the argument
    string is empty or nonempty.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的异常处理能力使得编写这个函数变得简单。代码尝试将单元格中的字符串转换为数字，并使用内置的 `float` 函数在 `try` 块中返回它。如果
    `float` 无法将其字符串参数转换为数字，则会引发 `ValueError` 异常，因此代码会捕获该异常，并根据参数字符串是否为空返回 `0` 或 `None`。
- en: 'The next step is handling the fact that some of the arithmetic might have to
    deal with a value of `None`. In a language without exceptions, the normal way
    to do this is to define a custom set of arithmetic functions, which check their
    arguments for `None`, and then use those functions rather than the built-in arithmetic
    functions to perform all of the spreadsheet arithmetic. This process is time-consuming
    and error-prone, however, and it leads to slow execution because you’re effectively
    building an interpreter in your spreadsheet. This project takes a different approach.
    All the spreadsheet formulas can actually be Python functions that take as arguments
    the x and y coordinates of the cell being evaluated and the spreadsheet itself,
    and calculate the result for the given cell by using standard Python arithmetic
    operators, using `cell_value` to extract the necessary values from the spreadsheet.
    You can define a function called `safe_apply` that applies one of these formulas
    to the appropriate arguments in a `try` block and returns either the formula’s
    result or `None`, depending on whether the formula evaluated successfully:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是处理可能需要处理`None`值的情况。在没有异常的语言中，通常的做法是定义一组自定义的算术函数，这些函数会检查它们的参数是否为`None`，然后使用这些函数而不是内置的算术函数来执行所有的电子表格算术。然而，这个过程既耗时又容易出错，并且会导致执行缓慢，因为你实际上在你的电子表格中构建了一个解释器。这个项目采取了一种不同的方法。所有的电子表格公式实际上可以是Python函数，这些函数接受正在评估的单元格的x和y坐标以及电子表格本身作为参数，并使用标准的Python算术运算符通过`cell_value`从电子表格中提取必要值来计算给定单元格的结果。你可以定义一个名为`safe_apply`的函数，该函数在一个`try`块中将其中一个公式应用于适当的参数，并根据公式是否成功评估返回公式结果或`None`：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: These two changes are enough to integrate the idea of an empty (`None`) value
    into the semantics of the spreadsheet. Trying to develop this ability without
    the use of exceptions is a highly educational exercise.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个更改足以将空（`None`）值的理念整合到电子表格的语义中。试图在不使用异常的情况下开发这种能力是一个高度教育性的练习。
- en: 14.2.9\. Where to use exceptions
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.2.9. 应该在哪里使用异常
- en: Exceptions are natural choices for handling almost any error condition. It’s
    an unfortunate fact that error handling is often added when the rest of the program
    is largely complete, but exceptions are particularly good at intelligibly managing
    this sort of after-the-fact error-handling code (or, more optimistically, when
    you’re adding more error handling after the fact).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 异常几乎可以处理任何错误条件。不幸的是，错误处理通常是在程序的大部分内容基本完成时添加的，但异常特别擅长以可理解的方式管理这种事后错误处理代码（或者更乐观地说，当你事后添加更多错误处理时）。
- en: Exceptions are also highly useful in circumstances where a large amount of processing
    may need to be discarded after it becomes obvious that a computational branch
    in your program has become untenable. The spreadsheet example is one such case;
    others are branch-and-bound algorithms and parsing algorithms.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 异常在需要丢弃大量处理的情况中也非常有用，当程序中的计算分支变得不可行时，这种情况就变得明显。电子表格示例就是这样一种情况；其他情况包括分支和界限算法和解析算法。
- en: '|  |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Quick Check: Exceptions'
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：异常
- en: Do Python exceptions force a program to halt?
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Python异常会强制程序停止吗？
- en: Suppose that you want accessing a dictionary `x` to always return `None` if
    a key doesn’t exist in the dictionary (that is, if a `KeyError` exception is raised).
    What code would you use?
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要访问字典`x`时，如果键不存在于字典中（即如果引发`KeyError`异常），总是返回`None`。你会使用什么代码？
- en: '|  |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Try this: Exceptions'
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：异常
- en: What code would you use to create a custom `ValueTooLarge` exception and raise
    that exception if the variable `x` is over 1000?
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你会用什么代码来创建一个自定义的`ValueTooLarge`异常，并在变量`x`超过1000时引发这个异常？
- en: '|  |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 14.3\. Context managers using the with keyword
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3. 使用with关键字进行上下文管理
- en: 'Some situations, such as reading files, follow a predictable pattern with a
    set beginning and end. In the case of reading from a file, quite often the file
    needs to be open only one time: while data is being read. Then the file can be
    closed. In terms of exceptions, you can code this kind of file access like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一些情况，如读取文件，遵循一个可预测的模式，有一个明确的开始和结束。在读取文件的情况下，通常只需要打开一次文件：当数据正在读取时。然后可以关闭文件。在异常的术语中，你可以这样编码这种类型的文件访问：
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Python 3 offers a more generic way of handling situations like this: context
    managers. *Context managers* wrap a block and manage requirements on *entry* and
    *departure* from the block and are marked by the `with` keyword. File objects
    are context managers, and you can use that capability to read files:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3 提供了一种更通用的方式来处理这种情况：上下文管理器。*上下文管理器*封装一个块，并管理块进入和离开时的需求，并由 `with` 关键字标记。文件对象是上下文管理器，你可以使用这种能力来读取文件：
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: These two lines of code are equivalent to the five previous lines. In both cases,
    you know that the file will be closed immediately after the last read, whether
    or not the operation was successful. In the second case, closure of the file is
    also assured because it’s part of the file object’s context management, so you
    don’t need to write the code. In other words, by using `with` combined with a
    context management (in this case a file object), you don’t need to worry about
    the routine cleanup.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这两行代码与之前的五行代码等价。在两种情况下，你都知道文件将在最后一次读取后立即关闭，无论操作是否成功。在第二种情况下，文件的关闭也得到了保证，因为它属于文件对象的上下文管理的一部分，因此你不需要编写代码。换句话说，通过使用
    `with` 与上下文管理（在这种情况下是文件对象）结合，你不需要担心常规的清理工作。
- en: As you might expect, it’s also possible to create your own context managers
    if you need them. You can learn a bit more about how to create context managers
    and the various ways they can be manipulated by checking out the documentation
    for the `contextlib` module of the standard library.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所料，如果你需要，也可以创建自己的上下文管理器。你可以通过查看标准库中 `contextlib` 模块的文档来了解更多关于如何创建上下文管理器以及它们可以以哪些方式被操作的信息。
- en: Context managers are great for things like locking and unlocking resources,
    closing files, committing database transactions, and so on. Since their introduction,
    context managers have become standard best practice for such use cases.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文管理器非常适合诸如锁定和解锁资源、关闭文件、提交数据库事务等情况。自从它们被引入以来，上下文管理器已经成为此类用例的标准最佳实践。
- en: '|  |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Quick Check: Context managers'
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：上下文管理器
- en: Assume that you’re using a context manager in a script that reads and/or writes
    several files. Which of the following approaches do you think would be best?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你在一个脚本中使用上下文管理器来读取和/或写入多个文件。你认为以下哪种方法最好？
- en: Put the entire script in a block managed by a `with` statement.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将整个脚本放在由 `with` 语句管理的块中。
- en: Use one `with` statement for all file reads and another for all file writes.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于所有文件读取使用一个 `with` 语句，对于所有文件写入使用另一个 `with` 语句。
- en: Use a `with` statement each time you read a file or write a file (for each line,
    for example).
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次读取或写入文件时（例如，对于每一行），都使用一个 `with` 语句。
- en: Use a `with` statement for each file that you read or write.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于你读取或写入的每个文件，使用一个 `with` 语句。
- en: '|  |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Lab 14: Custom exceptions'
  id: totrans-149
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实验 14：自定义异常
- en: Think about the module you wrote in [chapter 9](kindle_split_020.html#ch09)
    to count word frequencies. What errors might reasonably occur in those functions?
    Refactor those functions to handle those exception conditions appropriately.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 想想你在第 9 章[第 9 章](kindle_split_020.html#ch09)中编写的用于计算词频的模块。这些函数中可能合理地出现哪些错误？将这些函数重构以适当地处理这些异常条件。
- en: '|  |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Summary
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Python’s exception-handling mechanism and exception classes provide a rich system
    to handle runtime errors in your code.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 的异常处理机制和异常类提供了一套丰富的系统来处理代码中的运行时错误。
- en: By using `try`, `except`, `else`, and `finally` blocks, and by selecting and
    even creating the types of exceptions caught, you can have very fine-grained control
    over how exceptions are handled and ignored.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用 `try`、`except`、`else` 和 `finally` 块，并选择甚至创建捕获的异常类型，你可以非常精细地控制异常的处理和忽略方式。
- en: Python’s philosophy is that errors shouldn’t pass silently unless they’re explicitly
    silenced.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 的哲学是，除非它们被明确地静默处理，否则错误不应该无声地通过。
- en: Python exception types are organized in a hierarchy because exceptions, like
    all objects in Python, are based on classes.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 的异常类型是按层次结构组织的，因为异常，像 Python 中的所有对象一样，都是基于类的。
