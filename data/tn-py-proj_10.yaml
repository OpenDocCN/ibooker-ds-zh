- en: '9 Dial-a-Curse: Generating random insults from lists of words'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9. 生成随机侮辱语的“拨号诅咒”
- en: “He or she is a slimy-sided, frog-mouthed, silt-eating slug with the brains
    of a turtle.”
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: “他或她是一个滑溜的、青蛙嘴的、吃淤泥的鼻涕虫，有着乌龟的头脑。”
- en: --Dial-A-Curse
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: --Dial-A-Curse
- en: '| Random events are at the heart of interesting games and puzzles. Humans quickly
    grow bored of things that are always the same. I think one reason people may choose
    to have pets and children is to inject some randomness into their lives. Let’s
    learn how to make our programs more interesting by having them behave differently
    each time they are run. | ![](../Images/9-unnumb-1.png)  |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '| 随机事件是有趣的游戏和谜题的核心。人类很快就会对总是相同的事情感到厌倦。我认为人们可能选择养宠物和孩子的原因之一是向他们的生活中注入一些随机性。让我们学习如何通过让程序在每次运行时表现不同来使我们的程序更有趣。|
    ![图片](../Images/9-unnumb-1.png) |'
- en: This exercise will show you how to randomly select one or more elements from
    lists of options. To explore randomness, we’ll create a program called abuse.py
    that will insult the user by randomly selecting adjectives and nouns to create
    slanderous epithets.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习将向你展示如何从选项列表中随机选择一个或多个元素。为了探索随机性，我们将创建一个名为 abuse.py 的程序，该程序将通过随机选择形容词和名词来侮辱用户，创建诽谤性的绰号。
- en: In order to test randomness, though, we need to control it. It turns out that
    “random” events on computers are rarely truly random but only *pseudo-random*,
    which means we can control them by using a “seed.”[1](#pgfId-1011890) Each time
    you use the same seed, you will get the same “random” choices!
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了测试随机性，我们需要控制它。结果证明，计算机上的“随机”事件很少是真正的随机，而只是*伪随机*，这意味着我们可以通过使用“种子”来控制它们。每次使用相同的种子时，你都会得到相同的“随机”选择！
- en: 'Shakespeare had some of the best insults, so we’ll draw from the vocabulary
    of his works. Here is the list of adjectives you should use:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 莎士比亚有一些最好的侮辱语，所以我们将从他的作品中汲取词汇。以下是您应该使用的形容词列表：
- en: bankrupt base caterwauling corrupt cullionly detestable dishonest false filthsome
    filthy foolish foul gross heedless indistinguishable infected insatiate irksome
    lascivious lecherous loathsome lubbery old peevish rascaly rotten ruinous scurilous
    scurvy slanderous sodden-witted thin-faced toad-spotted unmannered vile wall-eyed
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 破产、基础、嚎叫、腐败、卑鄙、可憎、虚假、污秽、污秽、愚蠢、肮脏、粗心大意、无法区分的、感染的、贪得无厌的、令人烦恼的、放荡的、好色的、令人厌恶的、油腻的、老的、易怒的、恶心的、丑陋的、无礼的、卑鄙的、腐烂的、破坏性的、污秽的、恶心的、诽谤的、湿脑的、薄脸的、癞蛤蟆斑点的
- en: 'And these are the nouns:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是名词：
- en: Judas Satan ape ass barbermonger beggar block boy braggart butt carbuncle coward
    coxcomb cur dandy degenerate fiend fishmonger fool gull harpy jack jolthead knave
    liar lunatic maw milksop minion ratcatcher recreant rogue scold slave swine traitor
    varlet villain worm
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 犹大、撒旦、猿猴、屁股、理发师、乞丐、石头、吹牛者、屁股、痈疽、懦夫、傻瓜、乌鸦、女巫、杰克、笨蛋、骗子、说谎者、疯子、嘴巴、奶头、寄生虫、捕鼠人、叛徒、流氓、泼妇、奴隶、猪、叛徒、恶棍、虫子
- en: 'For instance, it might produce the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，它可能会产生以下结果：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this exercise, you will learn to
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将学习如何
- en: Use `parser.error()` from `argparse` to throw errors
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `parser.error()` 从 `argparse` 抛出错误
- en: Control randomness with random seeds
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用随机种子来控制随机性
- en: Take random choices and samples from Python lists
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 Python 列表中获取随机选择和样本
- en: Iterate an algorithm a specified number of times with a `for` loop
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `for` 循环迭代算法指定次数
- en: Format output strings
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格式化输出字符串
- en: 9.2 Writing abuse.py
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2 编写 abuse.py
- en: 'You should go into the 09_abuse directory to create your new program. Let’s
    start by looking at the usage statement it should produce:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该进入 09_abuse 目录来创建你的新程序。让我们先看看它应该生成的用法说明：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: All parameters are options that have default values, so our program will be
    able to run with no arguments at all.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 所有参数都是具有默认值的选项，因此我们的程序可以在没有任何参数的情况下运行。
- en: 'For instance, the `-n` or `--number` option will have a default of `3` and
    will control the number of insults:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`-n` 或 `--number` 选项将默认为 `3`，并将控制侮辱语的数量：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `-a` or `--adjectives` option should default to `2` and will determine
    how many adjectives are used in each insult:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`-a` 或 `--adjectives` 选项应该默认为 `2`，并将确定每个侮辱语中使用的形容词数量：'
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Lastly, the `-s` or `--seed` option will control the random choices in the program
    by setting an initial value. The default should be the special `None` value, which
    is like an undefined value.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`-s` 或 `--seed` 选项将通过设置一个初始值来控制程序中的随机选择。默认值应该是特殊的 `None` 值，它类似于一个未定义的值。
- en: 'Because the program will use a random seed, the following output should be
    exactly reproducible by any user on any machine at any time:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因为程序将使用随机种子，所以以下输出应该在任何时间、任何机器上的任何用户那里都是完全可重现的：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '| When run with no arguments, the program should generate insults using the
    defaults:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '| 当不带参数运行时，程序应该使用默认值生成侮辱：'
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '| ![](../Images/9-unnumb-2.png)  |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| ![图片](../Images/9-unnumb-2.png) |'
- en: I recommend you start by copying the template/template.py file to abuse/abuse.py
    or by using new.py to create the abuse.py program in the 09_abuse directory of
    your repository.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你首先将 `template/template.py` 文件复制到 `abuse/abuse.py`，或者使用 `new.py` 在你的仓库的 `09_abuse`
    目录中创建 `abuse.py` 程序。
- en: Figure 9.1 is a string diagram that illustrates the parameters for the program.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 是一个字符串图，展示了程序的参数。
- en: '![](../Images/9-1.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/9-1.png)'
- en: Figure 9.1 The abuse.py program will accept options for the number of insults
    to create, the number of adjectives per insult, and a random seed value.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 `abuse.py` 程序将接受创建侮辱的数量、每个侮辱的形容词数量以及随机种子值等选项。
- en: 9.1.1 Validating arguments
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.1 验证参数
- en: 'The options for the number of insults and adjectives and the random seed should
    all be `int` values. If you define each using `type=int` (remember, there are
    no quotes around the `int`), `argparse` will handle the validation and conversion
    of the arguments to `int` values for you. That is, just by defining `type=int`,
    the following error will be generated for you if a string is entered:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 侮辱数量、形容词数量和随机种子的选项都应该都是 `int` 类型的值。如果你使用 `type=int`（记住，`int` 周围没有引号），`argparse`
    将为你处理验证和将参数转换为 `int` 类型的值。也就是说，只需定义 `type=int`，如果输入了一个字符串，就会为你生成以下错误：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Not only must the value be a number, but it must be an *integer* which means
    it must be a whole number, so `argparse` will complain if you give it something
    that looks like a `float`. Note that you can use `type=float` when you actually
    want a floating-point value:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅值必须是数字，而且它必须是一个 *整数*，这意味着它必须是一个整数，所以 `argparse` 如果你给它一个看起来像 `float` 的东西会抱怨。注意，当你实际上想要浮点值时，你可以使用
    `type=float`：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Additionally, if either `--number` or `--adjectives` is less than 1, your program
    should exit with an error code and message:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果 `--number` 或 `--adjectives` 中的任何一个小于 `1`，你的程序应该使用错误代码和信息退出：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you start to write your own programs and tests, I recommend you steal from
    the tests I’ve written.[2](#pgfId-1012841) Let’s take a look at one of the tests
    in test.py to see how the program is tested:[3](#pgfId-1024217)
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始编写自己的程序和测试时，我建议你借鉴我写的测试。[2](#pgfId-1012841) 让我们看看 `test.py` 中的一个测试，看看程序是如何被测试的：[3](#pgfId-1024217)
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ① The name of the function must start with “test_” in order for Pytest to find
    and run it.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ① 函数的名称必须以 “test_” 开头，这样 Pytest 才能找到并运行它。
- en: ② Use the random.choice() function to randomly select a value from the range()
    of numbers from -10 to 0\. We will use this same function in our program, so note
    here how it is called.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `random.choice()` 函数从 `-10` 到 `0` 的数字范围内随机选择一个值。我们将在程序中使用这个相同的函数，所以请注意它的调用方式。
- en: ③ Run the program using getstatusoutput() from the subprocess3 module using
    a bad -a value. This function returns the exit value (which I put into rv for
    “return value”) and standard out (out).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 使用 `subprocess3` 模块的 `getstatusoutput()` 函数运行程序，并使用一个错误的 `-a` 值。这个函数返回退出值（我将它放入
    `rv` 以表示“返回值”）和标准输出（`out`）。
- en: ④ Assert that the return value (rv) is not 0, where “0” would indicate success
    (or “zero errors”).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 断言返回值（`rv`）不是 `0`，其中 `0` 表示成功（或“零错误”）。
- en: ⑤ Assert that the output somewhere contains the statement that the --adjectives
    argument must be greater than 0.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 断言输出中包含声明 `--adjectives` 参数必须大于 `0` 的语句。
- en: 'There’s no simple way to tell `argparse` that the numbers for adjectives and
    insults must be greater than zero, so we’ll have to check those values ourselves.
    We’ll use the verification ideas from section A.4.7 in the appendix. There I introduce
    the `parser.error()` function, which you can call inside the `get_args()` function
    to do the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 没有一种简单的方法可以告诉 `argparse` 形容词和侮辱的数字必须大于零，所以我们将不得不自己检查这些值。我们将使用附录中 A.4.7 节的验证想法。在那里，我介绍了
    `parser.error()` 函数，你可以在 `get_args()` 函数内部调用它来完成以下操作：
- en: Print the short usage statement
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印简短的用法说明
- en: Print an error message to the user
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向用户打印错误信息
- en: Stop execution of the program
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止程序的执行
- en: Exit with a nonzero exit value to indicate an error
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用非零退出值来指示错误
- en: 'That is, `get_args()` normally finishes with this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 即，`get_args()` 通常以这种方式结束：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Instead, we’ll put the `args` into a variable and check the `args.adjectives`
    value to see if it’s less than 1\. If it is, we’ll call `parser.error()` with
    an error message to report to the user:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将 `args` 放入一个变量中，并检查 `args.adjectives` 的值是否小于 1。如果是，我们将使用错误信息调用 `parser.error()`
    来向用户报告错误：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We’ll also do this for `args.number`. If they are both fine, you can `return`
    the arguments to the calling function:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也会对 `args.number` 做同样的事情。如果它们都很好，你可以将参数 `return` 给调用函数：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 9.1.2 Importing and seeding the random module
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.2 导入和初始化随机模块
- en: Once you have defined and validated all the program’s arguments, you are ready
    to heap scorn upon the user. First, we need to add `import` `random` to our program
    so we can use functions from that module to select adjectives and nouns. It’s
    best practice to list all the `import` statements, one module at a time, at the
    top of a program.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你定义并验证了所有程序的参数，你就可以开始对用户进行侮辱了。首先，我们需要在我们的程序中添加 `import random`，这样我们就可以使用该模块中的函数来选择形容词和名词。在程序顶部逐个列出所有
    `import` 语句是最佳实践。
- en: 'In `main()`, the first thing we need to do is call `get_args()` to get our
    arguments. The next step is to pass the `args.seed` value to the `random.seed()`
    function:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main()` 函数中，我们首先需要做的是调用 `get_args()` 来获取我们的参数。下一步是将 `args.seed` 的值传递给 `random.seed()`
    函数：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ① We call the random.seed() function to set the initial value of the random
    module’s state. There is no return value from random.seed()--the only change is
    internal to the random module.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们调用 `random.seed()` 函数来设置随机模块状态的初始值。`random.seed()` 没有返回值——唯一的改变是随机模块内部的。
- en: 'You can read about the `random.seed()` function in the REPL:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 REPL 中阅读关于 `random.seed()` 函数的信息：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There you’ll learn that the function will “initialize internal state [of the
    `random` module] from hashable object.” That is, we set an initial value from
    some *hashable* Python type. Both the `int` and `str` types are hashable, but
    the tests are written with the expectation that you will define the `seed` argument
    as an `int`. (Remember that the character `'1'` is different from the *integer
    value* `1`!)
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在那里，你会了解到该函数将“从可哈希对象初始化 `random` 模块的内部状态”。也就是说，我们从某种可哈希的 Python 类型设置一个初始值。`int`
    和 `str` 类型都是可哈希的，但测试是按照你将 `seed` 参数定义为 `int` 的预期来编写的。（记住，字符 `'1'` 与整数值 `1` 是不同的！）
- en: The default value for `args.seed` should be `None`. If the user has not indicated
    any seed, then setting `random.seed(None)` is the same as not setting it at all.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`args.seed` 的默认值应该是 `None`。如果用户没有指定任何种子，那么设置 `random.seed(None)` 与不设置它是一样的。'
- en: 'If you look at the test.py program, you will notice that all the tests that
    expect a particular output will pass an `-s` or `--seed` argument. Here is the
    first test for output:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 `test.py` 程序，你会注意到所有期望特定输出的测试都会传递一个 `-s` 或 `--seed` 参数。以下是输出测试的第一个测试：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ① Run the program using getoutput() from the subprocess module using a seed
    value of 1 and requesting 1 insult. This function returns only the output from
    the program.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ① 使用 subprocess 模块的 getoutput() 函数运行程序，使用种子值 1 并请求 1 个侮辱。此函数仅返回程序的输出。
- en: ② Verify that the entire output is the one expected insult.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ② 验证整个输出是否是预期的侮辱。
- en: 'This means test.py will run your program and capture the output into the `out`
    variable:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 `test.py` 将运行你的程序并将输出捕获到 `out` 变量中：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It will then verify that the program did in fact produce the expected number
    of insults with the expected selection of words.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它将验证程序是否确实产生了预期数量的侮辱，并且使用了预期的单词选择。
- en: 9.1.3 Defining the adjectives and nouns
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.3 定义形容词和名词
- en: 'Earlier in the chapter, I gave you a long list of adjectives and nouns that
    you should use in your program. You could create a `list` by individually quoting
    each word:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期，我给了你一个你应该在程序中使用的长形容词和名词列表。你可以通过逐个引用每个单词来创建一个 `list`：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Or you could save yourself a good bit of typing by using the `str.split()`
    method to create a new `list` from a `str` by splitting on spaces:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以通过使用 `str.split()` 方法来创建一个新的 `list`，从 `str` 中通过空格分割，从而节省大量的输入：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you try to make one giant string of all the adjectives, it will be very
    long and so will wrap around in your code editor and look ugly. I recommend you
    use triple quotes (either single or double quotes), which will allow you to include
    newlines:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试将所有的形容词组合成一个巨大的字符串，它将会非常长，并在你的代码编辑器中换行，看起来会很丑。我建议你使用三引号（单引号或双引号），这将允许你包含换行符：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Once you have variables for `adjectives` and `nouns`, you should check that
    you have the right number of each:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了`adjectives`和`nouns`的变量，你应该检查你是否有正确数量的每个：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note In order to pass the tests, your adjectives and nouns must be in alphabetical
    order as they were provided.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，为了通过测试，你的形容词和名词必须按照提供的顺序排列。
- en: 9.1.4 Taking random samples and choices
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.4 随机抽样和选择
- en: '| In addition to the `random.seed()` function, we will also use the `random.choice()`
    and `random.sample()` functions. In the `test_bad_adjective_num` function in section
    9.1.1, you saw one example of using `random .choice()`. We can use it similarly
    to select a noun from the `list` of `no`uns.Notice that this function returns
    a single item, so, given a `list` of `str` values, it will return a single `str`:
    | ![](../Images/9-unnumb-3.png) |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 除了`random.seed()`函数，我们还将使用`random.choice()`和`random.sample()`函数。在9.1.1节中的`test_bad_adjective_num`函数中，你看到了使用`random.choice()`的一个例子。我们可以用类似的方式从`no`uns的`list`中选择一个名词。注意，这个函数返回一个单独的项目，所以，给定一个`str`值的`list`，它将返回一个单独的`str`：|
    ![图片](../Images/9-unnumb-3.png) |'
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'For the `adjectives`, you should use `random.sample()`. If you read the `help(random
    .sample)` output, you will see that this function takes some `list` of items and
    a `k` parameter for how many items to return:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`adjectives`，你应该使用`random.sample()`。如果你阅读了`help(random.sample)`的输出，你会看到这个函数接受一些项目的`list`和一个`k`参数，用于指定返回多少个项目：
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Note that this function returns a new `list`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个函数返回一个新的`list`：
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: There is also a `random.choices()` function that works similarly but which might
    select the same items twice because it samples “with replacement.” We will not
    use that.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个`random.choices()`函数，它的工作方式类似，但它可能会选择相同的项两次，因为它“有放回”地抽样。我们不会使用它。
- en: 9.1.5 Formatting the output
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.5 格式化输出
- en: 'The output of the program is a `--number` of insults, which you could generate
    using a `for` loop and the `range()` function. It doesn’t matter here that `range()`
    starts at zero. What’s important is that it generates three values:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出是一个`--number`数量的侮辱词，你可以使用`for`循环和`range()`函数来生成。这里`range()`从零开始并不重要。重要的是它生成了三个值：
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You can loop the `--number` of times needed, select your sample of adjectives
    and your noun, and then format the output. Each insult should start with the string
    “`You`”, then have the adjectives joined on a comma and a space, then the noun,
    and finish with an exclamation point (figure 9.2). You could use either an f-string
    or the `str.format()` function to `print()` the output to `STDOUT`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以循环`--number`次，选择你的形容词样本和名词，然后格式化输出。每个侮辱词应该以字符串“`You`”开头，然后是形容词（用逗号和空格连接），然后是名词，最后以感叹号结束（图9.2）。你可以使用f-string或`str.format()`函数将输出`print()`到`STDOUT`。
- en: '![](../Images/9-2.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/9-2.png)'
- en: Figure 9.2 Each insult will combine the chosen adjectives joined on commas with
    the selected noun and some static bits of text.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 每个侮辱词将把选定的形容词（用逗号连接）与选定的名词和一些静态文本片段组合起来。
- en: 'Here are a few hints:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些提示：
- en: Perform the check for positive values for `--adjectives` and `--number` *inside*
    the `get_args()` function, and use `parser.error()` to throw the error while printing
    a message and the usage.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`get_args()`函数内部执行对`--adjectives`和`--number`的正值检查，并使用`parser.error()`在打印消息和使用说明时抛出错误。
- en: If you set the default of `args.seed` to `None` and use `type=int`, you can
    directly pass the value to `random.seed()`. When the value is `None`, it will
    be like not setting the value at all.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你将`args.seed`的默认值设置为`None`并使用`type=int`，你可以直接将值传递给`random.seed()`。当值为`None`时，它将像没有设置值一样。
- en: Use a `for` loop with the `range()` function to create a loop that will execute
    the `--number` of times to generate each insult.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`range()`函数和`for`循环创建一个循环，该循环将执行`--number`次以生成每个侮辱词。
- en: Look at the `random.sample()` and `random.choice()` functions for help in selecting
    some adjectives and a noun.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看`random.sample()`和`random.choice()`函数以获取选择一些形容词和一个名词的帮助。
- en: You can use three single quotes (`'''`) or double quotes (`"""`) to create a
    multiline string and then use `str.split()` to get a list of strings. This is
    easier than individually quoting a long list of shorter strings (such as the list
    of adjectives and nouns).
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用三个单引号(`'''`)或双引号(`"""`)来创建一个多行字符串，然后使用`str.split()`来获取字符串的列表。这比逐个引用一个长列表中的短字符串（如形容词和名词列表）要简单。
- en: To construct an insult to print, you can use the `+` operator to concatenate
    strings, use the `str.join()` method, or use format strings.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要构造一个要打印的侮辱词，你可以使用`+`运算符来连接字符串，使用`str.join()`方法，或者使用格式化字符串。
- en: Now give this your best shot before reading ahead to the solution, you snotty-faced
    heap of parrot droppings!
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读解决方案之前，尽力尝试一下，你这满嘴脏话的鹦鹉粪堆！
- en: 9.2 Solution
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2 解决方案
- en: This is the first solution where I use `parser.error()` to augment the validation
    of the arguments. I also incorporate triple-quoted strings and introduce the `random`
    module, which is quite fun unless you’re a vacuous, coffee-nosed, malodorous git.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一个使用 `parser.error()` 来增强参数验证的解决方案。我还结合了三个引号字符串，并引入了 `random` 模块，这很有趣，除非你是个空虚的、咖啡味的、恶臭的混蛋。
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ① Bring in the random module so we can call functions.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 带入 `random` 模块，以便我们可以调用函数。
- en: ② Define the parameter for the number of adjectives, setting type=int and the
    default value.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ② 定义形容词数量的参数，设置类型为 `int` 和默认值。
- en: ③ Similarly define the parameter for the number of insults as an integer with
    a default.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 同样定义侮辱数量的参数，将其作为具有默认值的整数。
- en: ④ The random seed default should be None.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 随机种子默认值应该是 `None`。
- en: ⑤ Get the result of parsing the command-line arguments. The argparse module
    will handle errors such as non-integer values.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 获取解析命令行参数的结果。`argparse` 模块将处理诸如非整数值之类的错误。
- en: ⑥ Check that args.adjectives is greater than 0\. If there is a problem, call
    parser.error() with the error message.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 检查 `args.adjectives` 是否大于 0。如果有问题，使用错误信息调用 `parser.error()`。
- en: ⑦ Similarly check args.number.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 同样检查 `args.number`。
- en: ⑧ At this point, all the user’s arguments have been validated, so return the
    arguments to the caller.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 在这一点上，所有用户的参数都已验证，因此将参数返回给调用者。
- en: ⑨ This is where the program actually begins as it is the first action inside
    main(). I always start off by getting the arguments.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这里程序实际上开始了，因为它在 `main()` 函数内部是第一个动作。我总是从获取参数开始。
- en: ⑩ Set random.seed() using whatever value was passed by the user. Any integer
    value is valid, and I know that argparse has handled the validation and conversion
    of the argument to an integer.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ 使用用户传递的任何值设置 `random.seed()`。任何整数值都是有效的，我知道 `argparse` 已经处理了参数的验证和转换为整数。
- en: ⑪ Create a list of adjectives by splitting the very long string contained in
    the triple quotes.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ⑪ 通过分割包含在三个引号中的非常长的字符串来创建一个形容词列表。
- en: ⑫ Do the same for the list of nouns.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ⑫ 对名词列表做同样的处理。
- en: ⑬ Use a for loop over the range() of the args.number. Since I don’t actually
    need the value from range(), I can use the _ to disregard it.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个 for 循环遍历 `args.number` 的范围。由于我实际上不需要 `range()` 的值，我可以使用 `_` 来忽略它。
- en: ⑭ Use the random.sample() function to select the correct number of adjectives
    and join them on the comma-space string.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `random.sample()` 函数选择正确数量的形容词，并将它们连接在逗号空格字符串上。
- en: ⑮ Use an f-string to format the output to print().
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ⑮ 使用 f-string 格式化输出以打印。
- en: 9.3 Discussion
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3 讨论
- en: I trust you did not peek at the solution before you passed all the tests or
    else you are a rascaly, filthsome swine.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你在通过所有测试之前没有偷看解决方案，否则你就是个肮脏的、恶心的猪。
- en: 9.3.1 Defining the arguments
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.1 定义参数
- en: 'More than half of my solution is defining the program’s arguments to `argparse`.
    The effort is well worth the result. Because I set `type=int`, `argparse` will
    ensure that each argument is a valid integer value. Notice that there are no quotes
    around the `int`--it’s not the string `''int''` but a reference to the class in
    Python:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我解决方案的一半以上是定义程序参数给 `argparse`。这种努力是值得的，因为设置了 `type=int`，`argparse` 将确保每个参数都是有效的整数值。注意，`int`
    周围没有引号——它不是字符串 `'int'`，而是对 Python 中类的引用：
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ① The short flag
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ① 短标志
- en: ② The long flag
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ② 长标志
- en: ③ The help message
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 帮助信息
- en: ④ A description of the parameter
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 参数的描述
- en: ⑤ The actual Python type for converting the input; note that this is the bare
    word int for the integer class
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 实际用于转换输入的 Python 类型；注意，这是整数类的裸词 `int`
- en: ⑥ The default value for the number of adjectives per insult
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 每个侮辱的形容词数量的默认值
- en: I set reasonable defaults for all the program’s options so that no input is
    required from the user. The `--seed` option should default to `None` so that the
    default behavior is to generate pseudo-random insults. This value is only important
    for testing purposes.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我为程序的所有选项设置了合理的默认值，这样就不需要用户输入。`--seed` 选项应该默认为 `None`，这样默认行为就是生成伪随机侮辱。这个值仅在测试目的上很重要。
- en: 9.3.2 Using parser.error()
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.2 使用 `parser.error()`
- en: 'I really love the `argparse` module for all the work it saves me. In particular,
    I often use `parser.error()` when I find there is a problem with an argument.
    This function will do four things:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我真的很喜欢`argparse`模块，因为它为我节省了大量的工作。特别是，当我发现某个参数有问题时，我经常使用`parser.error()`。这个函数将做四件事：
- en: Print the short usage of the program to the user
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将程序的简短用法打印给用户
- en: Print a specific message about the problem
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印关于问题的特定信息
- en: Halt execution of the program
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止程序执行
- en: Return an error code to the operating system
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向操作系统返回错误代码
- en: I’m using `parser.error()` here because, while I can ask `argparse` to verify
    that a given value is an `int`, I can’t as easily say that it must be a *positive*
    value. I can, however, inspect the value myself and halt the program if there
    is a problem. I do all this inside `get_args()` so that, by the time I get the
    `args` in my `main()` function, I know they have been validated.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里使用`parser.error()`是因为，虽然我可以要求`argparse`验证给定的值是否为`int`，但我不能轻易地说它必须是一个*正数*。然而，我可以自己检查这个值，并在有问题时停止程序。我所有的这些操作都在`get_args()`内部完成，这样，当我在`main()`函数中得到`args`时，我知道它们已经被验证了。
- en: I highly recommend you tuck this tip into your back pocket. It can prove quite
    handy, saving you loads of time validating user input and generating useful error
    messages. (And it’s quite likely that the future user of your program will be
    *you*, so you will really appreciate your efforts.)
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议你把这个技巧记在心里。它可以证明非常有用，可以节省你大量验证用户输入和生成有用错误信息的时间。（而且，你程序的未来用户很可能就是你，所以你真的会感激你的努力。）
- en: 9.3.3 Program exit values and STDERR
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.3 程序退出值和STDERR
- en: I would like to highlight the exit value of the program. Under normal circumstances,
    programs should exit with a value of `0`. In computer science, we often think
    of `0` as a `False` value, but here it’s quite positive. In this instance we should
    think of it as “zero errors.”
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我想强调程序的退出值。在正常情况下，程序应该以值`0`退出。在计算机科学中，我们通常认为`0`是一个`False`值，但在这里它是非常积极的。在这种情况下，我们应该将其视为“零错误”。
- en: 'If you use `sys.exit()` in your code to exit a program prematurely, the default
    exit value is `0`. If you want to indicate to the operating system or some calling
    program that your program exited with an error, you should return *any value other
    than* `0`. You can also call the function with a string, which will be printed
    as an error message, and Python will exit with the value `1`. If you run this
    in the REPL, you will be returned to the command line:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`sys.exit()`在你的代码中提前退出程序，默认的退出值是`0`。如果你想向操作系统或某些调用程序指示你的程序以错误状态退出，你应该返回*任何非*
    `0`的值。你也可以用字符串调用该函数，它将被打印为错误信息，Python将以值`1`退出。如果你在REPL中运行此代码，你将返回到命令行：
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Additionally, it’s common for all error messages to be printed not to `STDOUT`
    (standard out) but to `STDERR` (standard error). Many command shells (like Bash)
    can segregate these two output channels using `1` for `STDOUT` and `2` for `STDERR`.
    When using the Bash shell, note how I can use `2>` to redirect `STDERR` to the
    file called err so that nothing appears on `STDOUT`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，通常所有错误信息都会打印到`STDERR`（标准错误），而不是`STDOUT`（标准输出）。许多命令行（如Bash）可以使用`1`表示`STDOUT`，`2`表示`STDERR`来隔离这两个输出通道。当使用Bash
    shell时，请注意我如何使用`2>`将`STDERR`重定向到名为err的文件，这样就不会在`STDOUT`上显示任何内容：
- en: '[PRE28]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'I can verify that the expected error messages are in the err file:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以验证预期的错误信息都包含在err文件中：
- en: '[PRE29]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If you were to handle all of this yourself, you would need to write something
    like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要自己处理所有这些，你需要写点像这样的东西：
- en: '[PRE30]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ① Print the short usage. You can also use parser.print_help() to print the more
    verbose output for -h.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ① 打印简短用法。你也可以使用parser.print_help()来打印-h的更详细输出。
- en: ② Print the error message to the sys.stderr file handle. This is similar to
    the sys.stdout file handle we used in chapter 5.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ② 将错误信息打印到sys.stderr文件句柄。这与我们在第5章中使用的sys.stdout文件句柄类似。
- en: ③ Exit the program with a value that is not 0 to indicate an error.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 以非0的值退出程序以指示错误。
- en: Writing pipelines
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 编写管道
- en: As you write more and more programs, you may eventually start chaining them
    together. We often call these *pipelines*, as the output of one program is “piped”
    to become the input for the next program. If there is an error in any part of
    the pipeline, you’ll generally want the entire operation to stop so that the problems
    can be fixed. A nonzero return value from any program is a warning flag to halt
    operations.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你编写越来越多的程序，你最终可能会开始将它们串联起来。我们通常将这些称为 *pipelines*，因为一个程序的输出被“管道”传输成为下一个程序的输入。如果在管道的任何部分出现错误，你通常会希望整个操作停止，以便可以修复问题。任何程序的零返回值都是一个警告标志，表示停止操作。
- en: '![](../Images/9-unnumb-4.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/9-unnumb-4.png)'
- en: 9.3.4 Controlling randomness with random.seed()
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.4 使用 random.seed() 控制随机性
- en: The pseudo-random events in the `random` module follow from a given starting
    point. That is, each time you start from a given state, the events will happen
    in the same way. We can use the `random.seed()` function to set that starting
    point.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`random` 模块中的伪随机事件遵循一个给定的起始点。也就是说，每次从给定状态开始时，事件将以相同的方式发生。我们可以使用 `random.seed()`
    函数来设置这个起始点。'
- en: The seed value must be *hashable*. According to the Python documentation ([https://
    docs.python.org/3.1/glossary.html](https://docs.python.org/3.1/glossary.html)),
    “all of Python’s immutable built-in objects are hashable, while no mutable containers
    (such as lists or dictionaries) are.” In this program, we have to use an integer
    value because the tests were written using integer seeds. When you write you own
    programs, you may choose to use a string or other hashable type.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 种子值必须是 *可哈希的*。根据 Python 文档（[https://docs.python.org/3.1/glossary.html](https://docs.python.org/3.1/glossary.html)），“Python
    的所有不可变内置对象都是可哈希的，而所有可变容器（如列表或字典）都不是。”在这个程序中，我们必须使用整数值，因为测试是用整数种子编写的。当你编写自己的程序时，你可以选择使用字符串或其他可哈希类型。
- en: 'The default for our seed is the special `None` value, which is a bit like an
    undefined state. Calling `random.seed(None)` is essentially the same as not setting
    the seed at all, so it makes it safe to write this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们种子的默认值是特殊的 `None` 值，这有点像未定义的状态。调用 `random.seed(None)` 实质上等同于没有设置种子，因此这使得编写如下代码变得安全：
- en: '[PRE31]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 9.3.5 Iterating with range() and using throwaway variables
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.5 使用 range() 迭代并使用废弃变量
- en: 'To generate some `--number` of insults, we can use the `range()` function.
    Because we don’t need the numbers returned by `range()`, we use the underscore
    (`_`) as the variable name to indicate this is throwaway value:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成一些 `--number` 个侮辱性言论，我们可以使用 `range()` 函数。因为我们不需要 `range()` 返回的数字，所以我们使用下划线
    (`_`) 作为变量名来表示这是一个废弃值：
- en: '[PRE32]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The underscore is a valid variable name in Python. You can assign to it and
    use it:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，下划线是一个有效的变量名。你可以将其赋值并使用：
- en: '[PRE33]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The use of the underscore as a variable name is a convention to indicate that
    we don’t intend to use the value. That is, if we had said `for` num in `range(...)`,
    some tools like Pylint will see that the `num` variable is not used and will report
    this as a possible error (and well it could be). The `_` indicates that you’re
    throwing this value away, which is good information for your future self, some
    other user, or external tools to know.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 将下划线用作变量名是一种约定，表示我们不打算使用该值。也就是说，如果我们说过 `for` num in `range(...)`，一些工具如 Pylint
    会看到 `num` 变量没有被使用，并将此报告为可能的错误（确实如此）。`_` 表示你正在丢弃这个值，这对于你未来的自己、其他用户或外部工具来说是一个有用的信息。
- en: 'Note that you can use multiple `_` variables in the same statement. For instance,
    I can unpack a 3-tuple so as to get the middle value:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你可以在同一个语句中使用多个 `_` 变量。例如，我可以解包一个 3 元组以获取中间值：
- en: '[PRE34]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 9.3.6 Constructing the insults
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.6 构建侮辱性言论
- en: 'To create my list of adjectives, I used the `str.split()` method on a long,
    multiline string enclosed in triple quotes. I think this is probably the easiest
    way to get all these strings into my program. The triple quotes allow us to enter
    line breaks, which single quotes would not allow:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建我的形容词列表，我使用了 `str.split()` 方法在一个用三引号包裹的长多行字符串上。我认为这可能是将所有这些字符串放入程序中最简单的方法。三引号允许我们输入换行符，这是单引号所不允许的：
- en: '[PRE35]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Because we need one or more adjectives, the `random.sample()` function is a
    good choice. It will return a `list` of items randomly selected from a given `list`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们需要一个或多个形容词，所以 `random.sample()` 函数是一个很好的选择。它将返回一个从给定列表中随机选择的 `list`：
- en: '[PRE36]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '| The `random.choice()` function is appropriate for selecting just one item
    from a list, such as the noun for our invective:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '| `random.choice()` 函数适用于从列表中选择一个项目，例如我们侮辱中的名词：'
- en: '[PRE37]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '| ![](../Images/9-unnumb-5.png) |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| ![](../Images/9-unnumb-5.png) |'
- en: 'Next we need to concatenate the epithets using `'',` `''` (a comma and a space)
    similar to what we did in chapter 3 for our picnic items. The `str.join()` function
    is perfect for this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要使用 `', '`(一个逗号和一个空格) 连接绰号，就像我们在第3章为野餐物品所做的那样。`str.join()` 函数非常适合这个任务：
- en: '[PRE38]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To create the insult, we can combine the adjectives and nouns inside our template
    using an f-string:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建侮辱，我们可以使用 f-string 在模板内部组合形容词和名词：
- en: '[PRE39]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: And now I have a handy way to make enemies and influence people.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我有了一种方便的方法来制造敌人并影响人们。
- en: 9.4 Going further
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.4 进一步探索
- en: Read your adjectives and nouns from files that are passed as arguments.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从作为参数传递的文件中读取你的形容词和名词。
- en: Add tests to verify that the files are processed correctly and new insults are
    still stinging.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加测试以验证文件是否正确处理，并且新的侮辱仍然具有攻击性。
- en: Summary
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Use the `parser.error()` function to print a short usage statement, report the
    problem, and exit the program with an error value.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `parser.error()` 函数打印简短的用法说明，报告问题，并以错误值退出程序。
- en: Triple-quoted strings may contain line breaks, unlike regular single- or double-quoted
    strings.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三重引号字符串可以包含换行符，与常规的单引号或双引号字符串不同。
- en: The `str.split()` method is a useful way to create a `list` of string values
    from a long string.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`str.split()` 方法是从长字符串创建字符串值列表的有用方式。'
- en: The `random.seed()` function can be used to make reproducible pseudo-random
    selections each time a program is run.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`random.seed()` 函数可以在每次程序运行时生成可重复的伪随机选择。'
- en: The `random.choice()` and `random.sample()` functions are useful for randomly
    selecting one or several items from a list of choices, respectively.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`random.choice()` 和 `random.sample()` 函数分别用于从选择列表中随机选择一个或多个项目。'
- en: '* * *'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 1 “The generation of random numbers is too important to be left to chance.”--Robert
    R. Coveyou
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 1 “随机数的生成太重要了，不能留给偶然。”--罗伯特·R·科维尤
- en: 2 “Good composers borrow. Great ones steal.” -- Igor Stravinsky
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 2 “好作曲家借鉴，伟大的作曲家窃取。” -- 伊戈尔·斯特拉文斯基
- en: 3 The `subprocess` module allows you to run a command from inside your program.
    The `subprocess .getoutput()` function will capture the output from the command,
    while the `subprocess.getstatusoutput()` will capture both the exit value and
    the output from the command.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 3 `subprocess` 模块允许你在程序内部运行命令。`subprocess.getoutput()` 函数将捕获命令的输出，而 `subprocess.getstatusoutput()`
    将捕获退出值和命令的输出。
