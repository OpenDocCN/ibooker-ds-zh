- en: Appendix A. A guide to Python’s documentation
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附录 A. Python 文档指南
- en: The best and most current reference for Python is the documentation that comes
    with Python itself. With that in mind, it’s more useful to explore the ways you
    can access that documentation than to print pages of edited documentation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Python 来说，最好的也是最全面的参考资料是 Python 自带的文档。考虑到这一点，探索如何访问这些文档的方式比打印编辑过的文档页面更有用。
- en: The standard bundle of documentation has several sections, including instructions
    on documenting, distributing, installing, and extending Python on various platforms,
    and is the logical starting point when you’re looking for answers to questions
    about Python. The two main areas of the Python documentation that are likely to
    be the most useful are the *Library Reference* and the *Language Reference*. The
    *Library Reference* is absolutely essential because it has explanations of both
    the built-in data types and every module included with Python. The *Language Reference*
    is the explanation of how the core of Python works, and it contains the official
    word on the core of the language, explaining the workings of data types, statements,
    and so on. The “What’s New” section is also worth reading, particularly when a
    new version of Python is released, because it summarizes all of the changes in
    the new version.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 标准文档包包含几个部分，包括在各个平台上记录、分发、安装和扩展 Python 的说明，当您寻找有关 Python 的问题答案时，它是逻辑上的起点。Python
    文档中最可能最有用的两个区域是 *库参考* 和 *语言参考*。*库参考* 是绝对必要的，因为它包含了内置数据类型和 Python 所包含的每个模块的解释。*语言参考*
    是对 Python 核心工作方式的解释，它包含了语言核心的官方说明，解释了数据类型、语句等的工作原理。“新增功能”部分也值得阅读，尤其是在 Python 新版本发布时，因为它总结了新版本中的所有变化。
- en: A.1\. Accessing Python documentation on the web
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.1\. 在网络上访问 Python 文档
- en: For many people, the most convenient way to access the Python documentation
    is to go to [www.python.org](http://www.python.org) and browse the documentation
    collection there. Although doing so requires a connection to the web, it has the
    advantage that the content is always the most current. Given that for many projects,
    it’s often useful to search the web for other documentation and information, having
    a browser tab permanently open and pointing to the online Python documentation
    is an easy way to have a Python reference at your fingertips.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多人来说，访问 Python 文档最方便的方式是访问 [www.python.org](http://www.python.org) 并浏览那里的文档集合。尽管这样做需要连接到网络，但它有一个优点，即内容总是最新的。鉴于对于许多项目来说，经常在网络上搜索其他文档和信息是有用的，因此始终打开一个浏览器标签并指向在线
    Python 文档，是一种方便地将 Python 参考手册放在手边的简单方法。
- en: A.1.1\. Browsing Python documentation on your computer
  id: totrans-5
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.1.1\. 在您的计算机上浏览 Python 文档
- en: Many distributions of Python include the full documentation by default. In some
    Linux distributions, the documentation is a separate package that you need to
    install separately. In most cases, however, full documentation is already on your
    computer and easily accessible.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 Python 发行版默认包含完整的文档。在某些 Linux 发行版中，文档是一个需要单独安装的单独包。然而，在大多数情况下，完整的文档已经存在于您的计算机上，并且易于访问。
- en: Accessing help in the interactive shell or at a command line
  id: totrans-7
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在交互式外壳或命令行中访问帮助
- en: 'In [chapter 2](kindle_split_012.html#ch02), you saw how to use the `help` command
    in the interactive interpreter to access online help for any Python module or
    object:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 2 章](kindle_split_012.html#ch02)中，您学习了如何在交互式解释器中使用 `help` 命令来访问任何 Python
    模块或对象的在线帮助：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: What’s happening is that the interpreter is calling the `pydoc` module to generate
    the documentation. You can also use the `pydoc` module to search the Python documentation
    from a command line. On a Linux or macOS system, to get the same output in a terminal
    window, you need only type `pydoc int` at the prompt; to exit, type `q`. In a
    Windows command window, unless you’ve set your search path to include the Python
    Lib directory, you need to type the entire path—probably something like `C:\Users
    \<user>\AppData\Local\Programs\Python\Python36\Lib\pydoc.py int`, where `<user>`
    is your Windows username.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 发生的情况是，解释器正在调用 `pydoc` 模块来生成文档。您也可以使用 `pydoc` 模块从命令行搜索 Python 文档。在 Linux 或 macOS
    系统上，要在终端窗口中获得相同的输出，您只需在提示符下输入 `pydoc int`；要退出，请输入 `q`。在 Windows 命令窗口中，除非您已将搜索路径设置为包含
    Python Lib 目录，否则您需要输入完整的路径——可能类似于 `C:\Users\<user>\AppData\Local\Programs\Python\Python36\Lib\pydoc.py
    int`，其中 `<user>` 是您的 Windows 用户名。
- en: Generating HTML help pages with pydoc
  id: totrans-11
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 pydoc 生成 HTML 帮助页面
- en: If you want a sleeker look to the documentation that `pydoc` generates for a
    Python object or module, you can have the output written to an HTML file, which
    you can view in any browser. To do this, add the `–w` option to the `pydoc` command,
    which on Windows would then be `C:\Users\<user>\AppData\Local\Programs\Python
    \Python36\Lib\pydoc.py –w int`. In this case, in which you’re looking up documentation
    on the `int` object, `pydoc` creates a file named int.html in the current directory,
    and you can open and view it in a browser from there. Figure A.1 shows what int.html
    looks like in a browser.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要 `pydoc` 为 Python 对象或模块生成的文档看起来更简洁，你可以将输出写入一个 HTML 文件，你可以在任何浏览器中查看它。为此，将
    `–w` 选项添加到 `pydoc` 命令中，在 Windows 上将是 `C:\Users\<user>\AppData\Local\Programs\Python
    \Python36\Lib\pydoc.py –w int`。在这种情况下，你正在查找 `int` 对象的文档，`pydoc` 在当前目录中创建一个名为 int.html
    的文件，你可以在那里打开并在浏览器中查看它。图 A.1 展示了在浏览器中 int.html 的样子。
- en: If for some reason you want only a limited number pages of documentation available,
    this method works well. But in most cases, it’s probably better to use `pydoc`
    to serve more complete documentation, as discussed in the next section.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出于某种原因你只想有有限页数的文档可用，这种方法很有效。但在大多数情况下，可能最好使用 `pydoc` 提供更完整的文档，如下一节所述。
- en: Figure A.1\. int.html as generated by `pydoc`
  id: totrans-14
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '![图 A.1](images/afig01_alt.jpg)'
- en: '![](images/afig01_alt.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](images/afig01_alt.jpg)'
- en: Using pydoc as a documentation server
  id: totrans-16
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 pydoc 作为文档服务器
- en: In addition to being able to generate text and HTML documentation on any Python
    object, the `pydoc` module can be used as a server to serve web-based docs. You
    can run `pydoc` with `–p` and a port number to open a server on that port. Then
    you can enter the `"b"` command to open a browser and access the documentation
    of all the modules available, as shown in figure A.2.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 除了能够在任何 Python 对象上生成文本和 HTML 文档之外，`pydoc` 模块还可以用作服务器来提供基于 Web 的文档。你可以使用 `–p`
    和端口号运行 `pydoc`，在指定端口上打开服务器。然后你可以输入 `"b"` 命令来打开浏览器并访问所有模块的文档，如图 A.2 所示。
- en: Figure A.2\. A partial view of the module documentation served by `pydoc`
  id: totrans-18
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 A.2\. `pydoc` 提供的模块文档的部分视图
- en: '![](images/afig02_alt.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](images/afig02_alt.jpg)'
- en: Figure A.3\. If you’re comfortable with using Window Help files, this file may
    be all the documentation you’ll ever need.
  id: totrans-20
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '![图 A.3](images/afig03_alt.jpg)'
- en: '![](images/afig03_alt.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图 A.3](images/afig03_alt.jpg)'
- en: A bonus in using `pydoc` to serve documentation is that it also scans the current
    directory and extracts documentation from the docstrings of any modules it finds,
    even if they aren’t part of the standard library. This makes it useful for accessing
    the documentation of any Python modules. There’s one caveat, however. To extract
    the documentation from a module, `pydoc` must import it, which means that it will
    execute any code at the module’s top level. Thus, scripts that aren’t written
    to be imported without side effects (as discussed in [chapter 11](kindle_split_022.html#ch11))
    will be run, so use this feature with care.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `pydoc` 提供文档的一个好处是，它还会扫描当前目录，并从它找到的任何模块的 docstrings 中提取文档，即使它们不是标准库的一部分。这使得它可以用于访问任何
    Python 模块的文档。然而，有一个注意事项。要从模块中提取文档，`pydoc` 必须导入它，这意味着它将执行模块顶层中的任何代码。因此，那些没有编写为导入时不会产生副作用（如第
    11 章所述）的脚本将被运行，所以请谨慎使用此功能。
- en: Using the Windows Help file
  id: totrans-23
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 Windows 帮助文件
- en: On Windows systems, the standard Python 3 package includes complete Python documentation
    as Windows Help files. You can find these files in the Doc folder inside the folder
    where Python was installed; usually, they’re in the Python 3 program group on
    the program menu. When you open the main manuals file, it looks something like
    figure A.3.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 系统上，标准的 Python 3 软件包包括完整的 Python 文档作为 Windows 帮助文件。你可以在 Python 安装文件夹中的
    Doc 文件夹中找到这些文件；通常，它们在程序菜单上的 Python 3 程序组中。当你打开主手册文件时，它看起来就像图 A.3 所示的那样。
- en: A.1.2\. Downloading documentation
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.1.2\. 下载文档
- en: If you want the Python documentation on a computer but don’t necessarily want
    or need to be running Python, you can also download the complete documentation
    from [www.python.org](http://www.python.org) in PDF, HTML, or text format, which
    is convenient if you want to be able to access the docs from an e-book reader
    or similar device.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要计算机上的 Python 文档，但并不一定需要运行 Python，你也可以从 [www.python.org](http://www.python.org)
    下载完整的文档，格式为 PDF、HTML 或文本，如果你想要能够从电子书阅读器或类似设备访问文档，这很方便。
- en: 'A.2\. Best practices: How to become a Pythonista'
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.2\. 最佳实践：如何成为一名 Pythonista
- en: Every programming language develops its own traditions and culture, and Python
    is a strong example. Most experienced Python programmers (*Pythonistas*, as they’re
    sometimes called) care a great deal about writing Python in a way that matches
    the style and best practices of Python. This type of code is commonly called *Pythonic*
    code and is valued highly, as opposed to Python code that looks like Java, C,
    or JavaScript.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 每种编程语言都会发展出自己的传统和文化，Python 是一个很好的例子。大多数经验丰富的 Python 程序员（有时被称为 *Pythonistas*）非常关心以符合
    Python 风格和最佳实践的方式编写 Python。这种类型的代码通常被称为 *Pythonic* 代码，并且非常受重视，与看起来像 Java、C 或 JavaScript
    的 Python 代码形成对比。
- en: The question that coders new to Python face is how they learn to write Pythonic
    code. Although getting a feel for the language and its style takes a little time
    and effort, the rest of this appendix gives you some suggestions on how to start.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于刚开始接触 Python 的程序员来说，他们面临的问题是如何学习编写 Python 风格的代码。尽管感受语言及其风格需要一点时间和努力，但本附录的其余部分为你提供了一些如何开始的建议。
- en: A.2.1\. Ten tips for becoming a Pythonista
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.2.1. 成为 Pythonista 的十个技巧
- en: 'The tips in this section are ones that I share with intermediate Python classes
    and are my suggestions for leveling up your Python skills. I’m not saying that
    everyone absolutely agrees with me, but from what I’ve seen over the years, these
    tips will put you soundly on the path to being a true Pythonista:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的技巧是我与中级 Python 班级分享的，也是我对提升 Python 技能的建议。我并不是说每个人都绝对同意我的观点，但从我多年来看到的来看，这些技巧将使你稳稳地走上成为真正的
    Pythonista 的道路：
- en: '*Consider the Zen of Python.* The Zen of Python, or PEP 20, sums up the design
    philosophy underlying Python as a language and is commonly invoked in discussions
    of what makes scripts more Pythonic. In particular, “Beautiful is better than
    ugly” and “Simple is better than complex” should guide your coding. I’ve included
    the Zen of Python at the end of this appendix; you can always find it by typing
    `import this` at a Python shell prompt.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*考虑 Python 的禅意.* Python 的禅意，或称为 PEP 20，总结了作为语言基础的 Python 设计哲学，并在讨论什么使脚本更具 Python
    风格的讨论中经常被引用。特别是，“优美胜于丑陋”和“简单胜于复杂”应该指导你的编码。我在本附录的末尾包含了 Python 的禅意；你可以在 Python 命令行提示符中输入
    `import this` 来始终找到它。'
- en: '*Follow PEP 8.* PEP 8 is the official Python style guide, which is also included
    later in this appendix. PEP 8 offers good advice on everything from code formatting
    and variable naming to the use of the language. If you want to write Pythonic
    code, become familiar with PEP 8.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*遵循 PEP 8.* PEP 8 是官方的 Python 风格指南，也包含在本附录的后面。PEP 8 提供了关于代码格式化、变量命名到语言使用的良好建议。如果你想编写
    Python 风格的代码，熟悉 PEP 8 是很有必要的。'
- en: '*Be familiar with the docs.* Python has a rich, well-maintained collection
    of documentation, and you should refer to it often. The most useful documents
    probably are the standard library documentation, but the tutorials and how-to
    files are also rich veins of information on using the language effectively.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*熟悉文档.* Python 拥有一个丰富、维护良好的文档集合，你应该经常参考它。最有用的文档可能是标准库文档，但教程和如何使用文件也是关于有效使用语言的信息宝库。'
- en: '*Write as little code as you can as much as you can.* Although this advice
    might apply to many languages, it fits Python particularly well. What I mean is
    that you should strive to make your programs as short and as simple as possible
    (but no shorter and no simpler) and that you should practice that style of coding
    as much as you can.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*尽可能少地编写尽可能多的代码.* 虽然这些建议可能适用于许多语言，但它们非常适合 Python。我的意思是，你应该努力使你的程序尽可能短和简单（但不要更短或更简单），并且你应该尽可能多地练习这种编码风格。'
- en: '*Read as much code as you can.* From the beginning, the Python community has
    been aware that reading code is more important than writing code. Read as much
    Python code as you can, and if possible, discuss the code that you read with others.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*尽可能多地阅读代码.* 从一开始，Python 社区就意识到阅读代码比编写代码更重要。尽可能多地阅读 Python 代码，并在可能的情况下，与他人讨论你阅读的代码。'
- en: '*Use the built-in data structures over all else.* You should turn first to
    Python’s built-in structures before writing your own classes to hold data. Python’s
    various data types can be combined with nearly unlimited flexibility and have
    the advantage of years of debugging and optimization. Take advantage of them.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*优先使用内置数据结构.* 在编写自己的类来存储数据之前，你应该首先转向 Python 的内置结构。Python 的各种数据类型可以几乎无限灵活地组合，并且具有多年调试和优化的优势。利用它们。'
- en: '*Dwell on generators and comprehensions.* Coders who are new to Python almost
    always fail to appreciate how much list and dictionary comprehensions and generator
    expressions are part of Pythonic coding. Look at examples in the Python code that
    you read, and practice them. You won’t be a Pythonista until you can write a list
    comprehension almost without thinking.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*关注生成器和推导式。* 对于 Python 新手来说，几乎总是无法欣赏到列表和字典推导式以及生成器表达式在 Python 编程中的重要性。查看你阅读的
    Python 代码中的示例，并练习它们。除非你能几乎不假思索地编写列表推导式，否则你不会成为 Python 程序员。'
- en: '*Use the standard library.* When the built-ins fail you, look next to the standard
    library. The elements in the standard library are the famed “batteries included”
    of Python. They’ve stood the test of time and have been optimized and documented
    better than almost any other Python code. Use them if you can.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用标准库。* 当内置函数无法满足你的需求时，请查看标准库。标准库中的元素是 Python 著名的“内置电池”。它们经受了时间的考验，并且比几乎任何其他
    Python 代码都经过了更好的优化和文档化。如果可能，请使用它们。'
- en: '*Write as few classes as you can.* Write your own classes only if you must.
    Experienced Pythonistas tend to be very economical with classes, knowing that
    designing good classes isn’t trivial and that any classes they create are also
    classes that they have to test and debug.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*尽可能少写类。* 只有在必须的时候才编写自己的类。经验丰富的 Python 程序员通常非常节省类，因为他们知道设计好的类并不简单，而且他们创建的任何类都是他们必须测试和调试的类。'
- en: '*Be wary of frameworks.* Frameworks can be attractive, particularly to coders
    new to the language, because they offer so many powerful shortcuts. You should
    use frameworks when they’re helpful, of course, but be aware of their downsides.
    You may spend more time learning the quirks of an un-Pythonic framework than learning
    Python itself, or you may find yourself adapting what you do to the framework
    rather than the other way around.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*对框架保持警惕。* 框架可能很有吸引力，尤其是对于 Python 新手来说，因为它们提供了许多强大的快捷方式。当然，当框架有帮助时，你应该使用它们，但也要意识到它们的缺点。你可能会花更多的时间学习一个非
    Python 风格框架的怪癖，而不是学习 Python 本身，或者你可能发现自己是在适应框架，而不是反过来。'
- en: A.3\. PEP 8—Style guide for Python code
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.3. PEP 8—Python 代码风格指南
- en: This section contains a slightly edited excerpt from PEP (Python Enhancement
    Proposal) 8\. Written by Guido van Rossum and Barry Warsaw, PEP 8 is the closest
    thing Python has to a style manual. Some more-specific sections have been omitted,
    but the main points are covered. You should make your code conform to PEP 8 as
    much as possible; your Python style will be the better for it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包含了对 PEP (Python Enhancement Proposal) 8 的略微编辑的摘录。由 Guido van Rossum 和 Barry
    Warsaw 撰写，PEP 8 是 Python 最接近风格手册的东西。一些更具体的部分已被省略，但主要观点都得到了涵盖。你应该尽可能使你的代码符合 PEP
    8；你的 Python 风格会因此变得更好。
- en: You can access the full text of PEP 8 and all of the other PEPs issued in the
    history of Python by going to the documentation section of [www.python.org](http://www.python.org)
    and looking for the PEP index. The PEPs are excellent sources for the history
    and lore of Python as well as explanations of current issues and future plans.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过访问 [www.python.org](http://www.python.org) 的文档部分并查找 PEP 索引来获取 PEP 8 的完整文本以及
    Python 历史中发布的所有其他 PEP。PEP 是了解 Python 的历史和传说以及解释当前问题和未来计划的绝佳来源。
- en: A.3.1\. Introduction
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.3.1. 简介
- en: This document gives coding conventions for the Python code comprising the standard
    library in the main Python distribution. Please see the companion informational
    PEP describing style guidelines for the C code in the C implementation of Python.^([[1](#app02fn1)])
    This document was adapted from Guido’s original Python Style Guide essay, with
    some additions from Barry’s style guide.^([[2](#app02fn2)]) Where there’s conflict,
    Guido’s style rules for the purposes of this PEP. This PEP may still be incomplete
    (in fact, it may never be finished <wink>).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 本文档提供了 Python 主分布标准库中 Python 代码的编码约定。请参阅描述 C 实现中 C 代码风格指南的配套信息性 PEP。[^1](#app02fn1)
    本文档是从 Guido 的原始 Python 风格指南文章改编的，其中包含了一些来自 Barry 的风格指南的补充。[^2](#app02fn2) 如果存在冲突，本
    PEP 的目的是采用 Guido 的风格规则。本 PEP 可能仍然不完整（实际上，它可能永远无法完成 <wink>）。
- en: ¹
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: PEP 7, Style Guide for C Code, van Rossum, [https://www.python.org/dev/peps/pep-0007/](https://www.python.org/dev/peps/pep-0007/).
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: PEP 7，C 代码风格指南，van Rossum，[https://www.python.org/dev/peps/pep-0007/](https://www.python.org/dev/peps/pep-0007/)。
- en: ²
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Barry’s GNU Mailman style guide, [http://barry.warsaw.us/software/STYLEGUIDE.txt](http://barry.warsaw.us/software/STYLEGUIDE.txt).
    The URL is empty although it is presented in the PEP 8 style guide.
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 巴里的GNU Mailman风格指南，[http://barry.warsaw.us/software/STYLEGUIDE.txt](http://barry.warsaw.us/software/STYLEGUIDE.txt)。尽管它以PEP
    8风格指南的形式呈现，但URL是空的。
- en: A foolish consistency is the hobgoblin of little minds
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 愚蠢的一致性是小思想的怪物
- en: One of Guido’s key insights is that code is read much more often than it’s written.
    The guidelines provided here are intended to improve the readability of code and
    make it consistent across the wide spectrum of Python code. As PEP 20^([[3](#app02fn3)])
    says, “Readability counts.”
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 吉多（Guido）的关键洞察之一是代码的阅读次数远多于其编写次数。这里提供的指南旨在提高代码的可读性，并使其在广泛的Python代码中保持一致性。正如PEP
    20^([[3](#app02fn3)])所说，“可读性很重要。”
- en: ³
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: PEP 20, The Zen of Python, [www.python.org/dev/peps/pep-0020/](http://www.python.org/dev/peps/pep-0020/).
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: PEP 20，Python的禅，[www.python.org/dev/peps/pep-0020/](http://www.python.org/dev/peps/pep-0020/)。
- en: A style guide is about consistency. Consistency with this style guide is important.
    Consistency within a project is more important. Consistency within one module
    or function is most important.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 风格指南关乎一致性。与这个风格指南的一致性很重要。项目内的一致性更重要。一个模块或函数内的一致性最为重要。
- en: But most important, know when to be inconsistent—sometimes the style guide just
    doesn’t apply. When in doubt, use your best judgment. Look at other examples and
    decide what looks best. And don’t hesitate to ask!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 但最重要的是，要知道何时可以不一致——有时候风格指南并不适用。如果有疑问，请使用你的最佳判断。参考其他示例并决定哪种看起来最好。并且不要犹豫去询问！
- en: 'Here are two good reasons to break a particular rule:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个很好的理由来打破特定的规则：
- en: When applying the rule would make the code less readable, even for someone who
    is used to reading code that follows the rules
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果应用规则会使代码的可读性降低，即使对于习惯于阅读遵循规则代码的人来说也是如此
- en: To be consistent with surrounding code that also breaks it (maybe for historic
    reasons), although this is also an opportunity to clean up someone else’s mess
    (in true XP style)
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了与周围也打破规则的代码保持一致（可能是出于历史原因），尽管这也是清理别人混乱的机会（在真正的XP风格中）
- en: A.3.2\. Code layout
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.3.2\. 代码布局
- en: Indentation
  id: totrans-64
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 缩进
- en: Use four spaces per indentation level.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 每个缩进级别使用四个空格。
- en: For really old code that you don’t want to mess up, you can continue to use
    eight-space tabs.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你不想弄乱的老代码，你可以继续使用八个空格的制表符。
- en: Tabs or spaces?
  id: totrans-67
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 制表符或空格？
- en: Never mix tabs and spaces.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要混合使用制表符和空格。
- en: The most popular way of indenting Python is with spaces only. The second most
    popular way is with tabs only. Code indented with a mixture of tabs and spaces
    should be converted to using spaces exclusively. When you invoke the Python command-line
    interpreter with the `-t` option, it issues warnings about code that illegally
    mixes tabs and spaces. When you use `-tt`, these warnings become errors. These
    options are highly recommended!
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Python中最受欢迎的缩进方式是只使用空格。第二种最受欢迎的方式是只使用制表符。混合使用制表符和空格的缩进代码应转换为仅使用空格。当你使用带有`-t`选项的Python命令行解释器时，它会发出有关非法混合制表符和空格的代码的警告。当你使用`-tt`时，这些警告变为错误。这些选项强烈推荐！
- en: For new projects, spaces only are strongly recommended over tabs. Most editors
    have features that make this easy to do.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对于新项目，强烈推荐只使用空格，而不是制表符。大多数编辑器都有使这变得容易的功能。
- en: Maximum line length
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 最大行长度
- en: Limit all lines to a maximum of 79 characters.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有行限制在最多79个字符。
- en: Many devices are still around that are limited to 80-character lines; plus,
    limiting windows to 80 characters makes it possible to have several windows side
    by side. The default wrapping on such devices disrupts the visual structure of
    the code, making it more difficult to understand. Therefore, please limit all
    lines to a maximum of 79 characters. For flowing long blocks of text (docstrings
    or comments), limiting the length to 72 characters is recommended.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 许多设备仍然存在，它们的行限制在80个字符以内；此外，将窗口限制在80个字符内使得可以并排打开几个窗口。在这些设备上的默认换行会破坏代码的视觉结构，使其更难以理解。因此，请将所有行限制在最多79个字符。对于流动的长文本块（如文档字符串或注释），建议限制长度为72个字符。
- en: 'The preferred way of wrapping long lines is by using Python’s implied line
    continuation inside parentheses, brackets, and braces. If necessary, you can add
    an extra pair of parentheses around an expression, but sometimes using a backslash
    looks better. Make sure to indent the continued line appropriately. The preferred
    place to break around a binary operator is *after* the operator, not before it.
    Here are some examples:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 捆绑长行的首选方法是使用Python在括号、方括号和大括号中的隐式行续行。如果需要，可以在表达式周围添加额外的括号对，但有时使用反斜杠看起来更好。确保适当地缩进续行。在二元运算符周围断行的首选位置是在运算符*之后*，而不是之前。以下是一些示例：
- en: '[PRE1]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Blank lines
  id: totrans-76
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 空白行
- en: Separate top-level function and class definitions with two blank lines.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用两个空白行分隔顶层函数和类定义。
- en: Method definitions inside a class are separated by a single blank line.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 类内部的函数定义之间用单个空白行分隔。
- en: Extra blank lines may be used (sparingly) to separate groups of related functions.
    Blank lines may be omitted between a bunch of related one-liners (for example,
    a set of dummy implementations).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用额外的空白行（适当地）来分隔相关函数组。在相关的一行代码之间（例如，一组占位符实现）可以省略空白行。
- en: Use blank lines in functions, sparingly, to indicate logical sections.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数中，适当地使用空白行来表示逻辑部分。
- en: Python accepts the Control-L (^L) form feed character as whitespace. Many tools
    treat these characters as page separators, so you may use them to separate pages
    of related sections of your file.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Python接受控制-L (^L) 形式进纸字符作为空白。许多工具将这些字符视为页面分隔符，因此您可以使用它们来分隔文件中相关部分的页面。
- en: Imports
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 导入
- en: 'Imports should usually be on separate lines, for example:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 导入通常应单独一行，例如：
- en: '[PRE2]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Don’t put them together like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 不要像这样放在一起：
- en: '[PRE3]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It’s okay to say this, though:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这样说可以，但：
- en: '[PRE4]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Imports are always put at the top of the file, just after any module comments
    and docstrings and before module globals and constants.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 导入始终放在文件顶部，紧接在模块注释和文档字符串之后，在模块全局变量和常量之前。
- en: 'Imports should be grouped in the following order:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 导入应按以下顺序分组：
- en: Standard library imports
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标准库导入
- en: Related third-party imports
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 相关第三方导入
- en: Local application/library–specific imports
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本地应用程序/库特定导入
- en: Put a blank line between each group of imports.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在每组导入之间放置一个空白行。
- en: Put any relevant `__all__` specification after the imports.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入之后放置任何相关的`__all__`规范。
- en: Relative imports for intra-package imports are highly discouraged. Always use
    the absolute package path for all imports. Even now that PEP 328^([[4](#app02fn4)])
    is fully implemented in Python 2.5, its style of explicit relative imports is
    actively discouraged; absolute imports are more portable and usually more readable.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对于包内导入，相对导入被高度不建议。始终使用绝对包路径进行所有导入。即使现在PEP 328^([[4](#app02fn4)]) 已在Python 2.5中完全实现，其显式相对导入的风格也受到积极反对；绝对导入更便携且通常更易读。
- en: ⁴
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴
- en: ''
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'PEP 328, Imports: Multi-Line and Absolute/Relative, [www.python.org/dev/peps/pep-0328/](http://www.python.org/dev/peps/pep-0328/).'
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: PEP 328，导入：多行和绝对/相对，[www.python.org/dev/peps/pep-0328/](http://www.python.org/dev/peps/pep-0328/).
- en: When importing a class from a class-containing module, it’s usually okay to
    spell them
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 从包含类的模块中导入类时，通常可以这样拼写
- en: '[PRE5]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If this spelling causes local name clashes, then spell them
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这种拼写导致局部名称冲突，那么请这样拼写
- en: '[PRE6]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Whitespace in expressions and statements
  id: totrans-104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表达式和语句中的空白
- en: 'Pet peeves—avoid extraneous whitespace in the following situations:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 容忍的烦恼——避免在以下情况下出现多余的空白：
- en: 'Immediately inside parentheses, brackets, or braces Yes:'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在括号、方括号或大括号内部立即使用 Yes:'
- en: '[PRE7]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'No:'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'No:'
- en: '[PRE8]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Immediately before a comma, semicolon, or colon Yes:'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在逗号、分号或冒号之前立即使用 Yes:'
- en: '[PRE9]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'No:'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'No:'
- en: '[PRE10]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Immediately before the open parenthesis that starts the argument list of a
    function call Yes:'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在开始函数调用参数列表的左括号之前立即使用 Yes:'
- en: '[PRE11]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'No:'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'No:'
- en: '[PRE12]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Immediately before the open parenthesis that starts an indexing or slicing
    Yes:'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在开始索引或切片的左括号之前立即使用 Yes:'
- en: '[PRE13]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'No:'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'No:'
- en: '[PRE14]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'More than one space around an assignment (or other) operator to align it with
    another Yes:'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在赋值（或其他）运算符周围留有多个空格以对齐另一个 Yes:'
- en: '[PRE15]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'No:'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'No:'
- en: '[PRE16]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Other recommendations
  id: totrans-126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 其他建议
- en: 'Always surround these binary operators with a single space on either side:
    assignment (`=`), augmented assignment (`+=, -=,` and so on), comparisons `(==,
    <, >, !=, <>, <=, >=, in, not in, is, is not`), and Booleans (`and, or, not`).'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 总是使用单侧空格包围这些二元运算符：赋值（`=`）、增量赋值（`+=, -=,` 等等）、比较（`==, <, >, !=, <>, <=, >=, in,
    not in, is, is not`）和布尔运算符（`and, or, not`）。
- en: Use spaces around arithmetic operators.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在算术运算符周围使用空格。
- en: 'Yes:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 'Yes:'
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'No:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 'No:'
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Don’t use spaces around the `=` sign when used to indicate a keyword argument
    or a default parameter value.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当用`=`表示关键字参数或默认参数值时，不要在`=`周围使用空格。
- en: 'Yes:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 是的：
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'No:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 不：
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Compound statements (multiple statements on the same line) are generally discouraged.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 复合语句（同一行上的多个语句）通常是不被鼓励的。
- en: 'Yes:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 是的：
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Rather not:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 不太愿意：
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: While sometimes it’s okay to put an `if/for/while` with a small body on the
    same line, never do this for multiclause statements. Also avoid folding such long
    lines!
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有时可以在同一行上放置具有小体量的`if/for/while`，但绝不要为多子句语句这样做。还避免折叠这样长的行！
- en: 'Rather not:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 不太愿意：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Definitely not:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 绝对不是：
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: A.4\. Comments
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.4. 注释
- en: Comments that contradict the code are worse than no comments. Always make a
    priority of keeping the comments up to date when the code changes!
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 与代码相矛盾的注释比没有注释更糟。当代码更改时，始终将保持注释更新作为优先事项！
- en: Comments should be complete sentences. If a comment is a phrase or sentence,
    its first word should be capitalized, unless it’s an identifier that begins with
    a lowercase letter (never alter the case of identifiers!).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 注释应该是完整的句子。如果注释是一个短语或句子，其第一个单词应大写，除非它是一个以小写字母开头的标识符（永远不要改变标识符的大小写！）。
- en: If a comment is short, the period at the end can be omitted. Block comments
    generally consist of one or more paragraphs built out of complete sentences, and
    each sentence should end in a period.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果注释很短，可以省略结尾的句号。块注释通常由一个或多个由完整句子组成的段落组成，每个句子应以句号结束。
- en: You should use two spaces after a sentence-ending period.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 句号后应使用两个空格。
- en: When writing English, Strunk and White apply.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当用英语写作时，应遵循Strunk和White的原则。
- en: 'Python coders from non-English-speaking countries: please write your comments
    in English, unless you are 120% sure that the code will never be read by people
    who don’t speak your language.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 来自非英语国家的Python程序员：请用英语编写注释，除非你120%确信代码永远不会被不会说你的语言的人阅读。
- en: Block comments
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 块注释
- en: 'Block comments generally apply to some (or all) code that follows them and
    are indented to the same level as that code. Each line of a block comment starts
    with a # and a single space (unless it is indented text inside the comment).'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 块注释通常适用于它们后面的某些（或所有）代码，并且缩进与该代码相同级别。块注释的每一行都以#和一个空格开始（除非它是注释内的缩进文本）。
- en: Paragraphs inside a block comment are separated by a line containing a single
    `#`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 块注释内的段落由包含单个`#`的行分隔。
- en: Inline Comments
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 内联注释
- en: Use inline comments sparingly.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 适度地使用内联注释。
- en: 'An inline comment is a comment on the same line as a statement. Inline comments
    should be separated by at least two spaces from the statement. They should start
    with a # and a single space.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 内联注释是与语句在同一行的注释。内联注释应至少与语句隔开两个空格。它们应以#和一个空格开始。
- en: 'Inline comments are unnecessary and in fact distracting if they state the obvious.
    Don’t do this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果内联注释只是陈述显而易见的事情，则是不必要的，甚至可能会分散注意力。不要这样做：
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'But sometimes, this is useful:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 但有时，这很有用：
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Documentation strings
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 文档字符串
- en: Conventions for writing good documentation strings (aka docstrings) are immortalized
    in PEP 257.^([[5](#app02fn5)])
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 良好文档字符串（即docstrings）的约定被永久记录在PEP 257中.^([[5](#app02fn5)])
- en: ⁵
  id: totrans-167
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁵
- en: ''
  id: totrans-168
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: PEP 257, Docstring Conventions, Goodger, van Rossum, [www.python.org/dev/peps/pep-0257/](http://www.python.org/dev/peps/pep-0257/).
  id: totrans-169
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: PEP 257，文档字符串约定，Goodger，van Rossum，[www.python.org/dev/peps/pep-0257/](http://www.python.org/dev/peps/pep-0257/).
- en: Write docstrings for all public modules, functions, classes, and methods. Docstrings
    are not necessary for nonpublic methods, but you should have a comment that describes
    what the method does. This comment should appear after the `def` line.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为所有公共模块、函数、类和方法编写文档字符串。对于非公共方法，文档字符串不是必需的，但你应该有一个描述方法做什么的注释。这个注释应出现在`def`行之后。
- en: 'PEP 257 describes good docstring conventions. Note that, most importantly,
    the `"""` that ends a multiline docstring should be on a line by itself and preferably
    preceded by a blank line, for example:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: PEP 257描述了良好的文档字符串约定。请注意，最重要的是，结束多行文档字符串的`"""`应单独一行，并且最好前面有一个空行，例如：
- en: '[PRE27]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: For one-liner docstrings, it’s okay to keep the closing `"""` on the same line.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单行文档字符串，可以保留结尾的`"""`在同一行上。
- en: Version bookkeeping
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 版本簿记
- en: 'If you have to have Subversion, CVS, or RCS crud in your source file, do it
    as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须在源文件中包含Subversion、CVS或RCS的垃圾，请按以下方式操作：
- en: '[PRE28]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: These lines should be included after the module’s docstring, before any other
    code, separated by a blank line above and below.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行应在模块的文档字符串之后、任何其他代码之前包含，上方和下方各有一个空白行。
- en: A.4.1\. Naming conventions
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.4.1\. 命名约定
- en: The naming conventions of Python’s library are a bit of a mess, so we’ll never
    get this completely consistent. Nevertheless, here are the currently recommended
    naming standards. New modules and packages (including third-party frameworks)
    should be written to these standards, but where an existing library has a different
    style, internal consistency is preferred.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Python库的命名约定有些混乱，所以我们永远无法完全一致。尽管如此，以下是目前推荐的标准命名规范。新的模块和包（包括第三方框架）应按照这些标准编写，但如果现有的库有不同的风格，则内部一致性更受青睐。
- en: 'Descriptive: naming styles'
  id: totrans-180
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 描述性：命名风格
- en: There are many different naming styles. It helps to be able to recognize what
    naming style is being used, independent of what it’s used for.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 存在许多不同的命名风格。能够识别正在使用的命名风格，而不管它用于什么目的，这很有帮助。
- en: 'The following naming styles are commonly distinguished:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命名风格通常被区分：
- en: b (single lowercase letter)
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: b（单个小写字母）
- en: B (single uppercase letter)
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: B（单个大写字母）
- en: lowercase
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小写
- en: lower_case_with_underscores
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: lower_case_with_underscores
- en: UPPERCASE
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全大写
- en: UPPER_CASE_WITH_UNDERSCORES
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UPPER_CASE_WITH_UNDERSCORES
- en: CapitalizedWords (or CapWords, or CamelCase—so named because of the bumpy look
    of its letters^([[6](#app02fn6)])). This is also sometimes known as StudlyCaps.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CapitalizedWords（或CapWords，或CamelCase——之所以这样命名是因为其字母的凹凸外观^([[6](#app02fn6)]))。这也被称为StudlyCaps。
- en: ⁶
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁶
- en: ''
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: For a complete description, see [www.wikipedia.com/wiki/CamelCase](http://www.wikipedia.com/wiki/CamelCase).
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于完整的描述，请参阅[www.wikipedia.com/wiki/CamelCase](http://www.wikipedia.com/wiki/CamelCase)。
- en: 'Note: When using abbreviations in CapWords, capitalize all the letters of the
    abbreviation. Thus `HTTPServerError` is better than `HttpServerError`.'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意：当在CapWords中使用缩写时，应将缩写中的所有字母都大写。因此`HTTPServerError`比`HttpServerError`更好。
- en: mixedCase (differs from CapitalizedWords by initial lowercase character!)
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: mixedCase（与CapitalizedWords不同，以小写字母开头！）
- en: Capitalized_Words_With_Underscores (ugly!)
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Capitalized_Words_With_Underscores（丑陋！）
- en: There’s also the style of using a short unique prefix to group related names
    together. This is seldom used in Python, but I mention it for completeness. For
    example, the `os.stat()` function returns a tuple whose items traditionally have
    names like `st_mode`, `st_size`, `st_mtime`, and so on. (This is done to emphasize
    the correspondence with the fields of the POSIX system call struct, which helps
    programmers familiar with that.)
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 还有使用短唯一前缀来分组相关名称的风格。这在Python中很少使用，但我提一下以示完整。例如，`os.stat()`函数返回一个元组，其元素传统上具有`st_mode`、`st_size`、`st_mtime`等名称（这样做是为了强调与POSIX系统调用struct字段的对应关系，这有助于熟悉该结构的程序员）。
- en: The X11 library uses a leading X for all its public functions. In Python, this
    style is generally deemed unnecessary because attribute and method names are prefixed
    with an object, and function names are prefixed with a module name.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: X11库为其所有公共函数使用前缀X。在Python中，这种风格通常被认为是不必要的，因为属性和方法名称前都有一个对象前缀，而函数名称前有一个模块名称前缀。
- en: 'In addition, the following special forms using leading or trailing underscores
    are recognized (these can generally be combined with any case convention):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，以下使用前导或尾随下划线的特殊形式也被识别（这些通常可以与任何大小写约定结合使用）：
- en: _single_leading_underscore Weak “internal use” indicator. For example, `from
    M import *` does not import objects whose name starts with an underscore.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: _single_leading_underscore 弱“内部使用”指示符。例如，`from M import *`不会导入以下划线开头的对象。
- en: single_trailing_underscore_ Used by convention to avoid conflicts with Python
    keyword. For example, `tkinter.Toplevel(master, class_='ClassName')`.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: single_trailing_underscore_ 习惯上用于避免与Python关键字冲突。例如，`tkinter.Toplevel(master,
    class_='ClassName')`。
- en: __double_leading_underscore When naming a class attribute, it invokes name mangling
    (inside class `FooBar`, `__boo` becomes `_FooBar__boo`; see below).
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: __double_leading_underscore_ 当命名类属性时，它将触发名称混淆（在类`FooBar`内部，`__boo`变为`_FooBar__boo`；见下文）。
- en: __double_leading_and_trailing_underscore__ “Magic” objects or attributes that
    live in user-controlled namespaces. For example, `__init__`, `__import__` or `__file__`.
    Never invent such names; use them only as documented.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: __double_leading_and_trailing_underscore__ “魔法”对象或属性，它们存在于用户控制的命名空间中。例如，`__init__`、`__import__`或`__file__`。永远不要发明这样的名称；仅按文档使用它们。
- en: 'Prescriptive: naming conventions'
  id: totrans-203
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 规范性：命名约定
- en: Names to avoid Never use the characters *l* (lowercase letter el), *O* (uppercase
    letter oh), or *I* (uppercase letter eye) as single-character variable names.
    In some fonts, these characters are indistinguishable from the numerals 1 (one)
    and 0 (zero). When tempted to use *l*, use *L* instead.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免使用的名称 永远不要使用字符 *l*（小写字母 el）、*O*（大写字母 oh）或 *I*（大写字母 eye）作为单个字符的变量名。在某些字体中，这些字符与数字
    1（一个）和 0（零）难以区分。当想要使用 *l* 时，使用 *L* 代替。
- en: Package and module names Modules should have short, all-lowercase names. Underscores
    can be used in a module name if it improves readability. Python packages should
    also have short, all-lowercase names, although the use of underscores is discouraged.
    Since module names are mapped to filenames, and some file systems are case-insensitive
    and truncate long names, it’s important that module names be fairly short—this
    won’t be a problem on UNIX, but it may be a problem when the code is transported
    to older Mac or Windows versions or DOS. When an extension module written in C
    or C++ has an accompanying Python module that provides a higher-level (for example,
    more object-oriented) interface, the C/C++ module has a leading underscore (for
    example, `_socket`).
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包和模块名称 模块应该有简短的全小写名称。如果它提高了可读性，可以在模块名称中使用下划线。Python 包也应该有简短的全小写名称，尽管不鼓励使用下划线。由于模块名称映射到文件名，并且某些文件系统不区分大小写并且截断长名称，因此模块名称应该相对较短——在
    UNIX 上这不会是问题，但在代码被传输到较老的 Mac 或 Windows 版本或 DOS 时可能会成为问题。当一个用 C 或 C++ 编写的扩展模块有一个伴随的
    Python 模块，该模块提供了一个更高级的（例如，更面向对象的）接口时，C/C++ 模块有一个前导下划线（例如，`_socket`）。
- en: Class names Almost without exception, class names use the CapWords convention.
    Classes for internal use have a leading underscore in addition.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类名 几乎没有例外，类名使用 CapWords 规范。用于内部使用的类名前面有一个下划线。
- en: Exception names Because exceptions should be classes, the class-naming convention
    applies here. However, you should use the suffix `Error` on your exception names
    (if the exception actually is an error).
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常名 因为异常应该是类，所以类命名规范也适用于这里。然而，你应该在你的异常名称中使用后缀 `Error`（如果异常实际上是一个错误）。
- en: Global variable names (Let’s hope that these variables are meant for use inside
    one module only.) The conventions are about the same as those for functions. Modules
    that are designed for use via `from M import *` should use the `__all__` mechanism
    to prevent exporting globals or use the older convention of prefixing such globals
    with an underscore (which you might want to do to indicate these globals are module
    nonpublic).
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局变量名称（让我们希望这些变量仅用于一个模块内。）这些规范与函数的规范大致相同。设计为通过 `from M import *` 使用的模块应该使用 `__all__`
    机制来防止导出全局变量，或者使用较旧的约定，即使用下划线作为这样的全局变量的前缀（你可能想这样做来表示这些全局变量是模块非公开的）。
- en: Function names Function names should be lowercase, with words separated by underscores
    as necessary to improve readability. mixedCase is allowed only in contexts where
    that’s already the prevailing style (for example, threading.py), to retain backward
    compatibility.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数名 函数名应该是小写的，必要时使用下划线分隔单词以提高可读性。在已经普遍使用 mixedCase 的上下文中，允许使用 mixedCase（例如，threading.py），以保持向后兼容性。
- en: Function and method arguments Always use `self` for the first argument to instance
    methods. Always use `cls` for the first argument to class methods. If a function
    argument’s name clashes with a reserved keyword, it’s generally better to append
    a single trailing underscore than to use an abbreviation or spelling corruption.
    Thus, `print_` is better than `prnt`. (Perhaps better is to avoid such clashes
    by using a synonym.)
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数和方法参数 总是使用 `self` 作为实例方法的第一个参数。总是使用 `cls` 作为类方法的第一个参数。如果一个函数参数的名称与保留关键字冲突，通常最好在后面添加一个单下划线，而不是使用缩写或拼写错误。因此，`print_`
    比较于 `prnt` 更好。（也许更好的做法是使用同义词来避免这种冲突。）
- en: 'Method names and instance variables Use the function-naming rules: lowercase
    with words separated by underscores as necessary to improve readability. Use one
    leading underscore only for nonpublic methods and instance variables. To avoid
    name clashes with subclasses, use two leading underscores to invoke Python’s name-mangling
    rules. Python mangles these names with the class name: if class `Foo` has an attribute
    named `__a`, it cannot be accessed by `Foo.__a`. (An insistent user could still
    gain access by calling `Foo._Foo__a`.) Generally, double leading underscores should
    be used only to avoid name conflicts with attributes in classes designed to be
    subclassed. Note: there is some controversy about the use of __names (see below).'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法名称和实例变量：使用函数命名规则：小写字母，必要时用下划线分隔单词以提高可读性。仅对非公开方法和实例变量使用一个前导下划线。为了避免与子类发生名称冲突，使用两个前导下划线来调用Python的名称混淆规则。Python通过类名混淆这些名称：如果类
    `Foo` 有一个名为 `__a` 的属性，则不能通过 `Foo.__a` 访问它。（一个固执的用户仍然可以通过调用 `Foo._Foo__a` 来获得访问权限。）通常，双前导下划线仅用于避免与设计为可继承的类中的属性发生名称冲突。注意：关于__names的使用存在一些争议（见下文）。
- en: Constants Constants are usually declared on a module level and written in all
    capital letters with underscores separating words. Examples include `MAX_OVERFLOW`
    and `TOTAL`.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常量：常量通常在模块级别声明，并使用全部大写字母，单词之间用下划线分隔。例如包括 `MAX_OVERFLOW` 和 `TOTAL`。
- en: Designing for inheritance Always decide whether a class’s methods and instance
    variables (collectively called attributes) should be public or nonpublic. If in
    doubt, choose nonpublic; it’s easier to make it public later than to make a public
    attribute nonpublic. Public attributes are those that you expect unrelated clients
    of your class to use, with your commitment to avoid backward-incompatible changes.
    Nonpublic attributes are those that are not intended to be used by third parties;
    you make no guarantees that nonpublic attributes won’t change or even be removed.
    We don’t use the term *private* here, since no attribute is really private in
    Python (without a generally unnecessary amount of work). Another category of attributes
    includes those that are part of the subclass API (often called *protected* in
    other languages). Some classes are designed to be inherited from, either to extend
    or modify aspects of the class’s behavior. When designing such a class, take care
    to make explicit decisions about which attributes are public, which are part of
    the subclass API, and which are truly only to be used by your base class.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计继承：始终决定一个类的公共方法、实例变量（统称为属性）应该是公开的还是非公开的。如果有疑问，请选择非公开；将其公开比将其公开属性非公开更容易。公共属性是你期望与你的类无关的客户使用，你承诺避免向后不兼容的更改。非公共属性是不打算由第三方使用的；你不对非公共属性不会更改或甚至被删除做出保证。在这里我们不使用术语“私有”，因为在Python中（没有大量不必要的额外工作），没有任何属性真正是私有的。属性的另一类包括那些是子类API的一部分（在其他语言中通常称为“受保护的”）。一些类被设计为可以继承，无论是为了扩展还是修改类的行为方面。在设计这样的类时，请务必明确决定哪些属性是公开的，哪些是子类API的一部分，以及哪些真正只应由基类使用。
- en: 'With this in mind, here are the Pythonic guidelines:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，以下是一些Python风格的指南：
- en: Public attributes should have no leading underscores.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共属性不应以下划线开头。
- en: 'If your public attribute name collides with a reserved keyword, append a single
    trailing underscore to your attribute name. This is preferable to an abbreviation
    or corrupted spelling. (However, notwithstanding this rule, `cls` is the preferred
    spelling for any variable or argument that’s known to be a class, especially the
    first argument to a class method.) Note 1: See the argument name recommendation
    above for class methods.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的公共属性名称与保留关键字冲突，请在你属性名称的末尾添加一个单独的后缀下划线。这比缩写或拼写错误更可取。（然而，尽管有此规则，对于任何已知是类的变量或参数，`cls`
    是首选的拼写，特别是类方法的第一个参数。）注意1：请参考上述关于类方法参数名称的建议。
- en: 'For simple public data attributes, it’s best to expose just the attribute name,
    without complicated accessor/mutator methods. Keep in mind that Python provides
    an easy path to future enhancement, should you find that a simple data attribute
    needs to grow functional behavior. In that case, use properties to hide functional
    implementation behind simple data attribute access syntax. Note 1: Properties
    work only on new-style classes. Note 2: Try to keep the functional behavior side-effect
    free, although side effects such as caching are generally fine. Note 3: Avoid
    using properties for computationally expensive operations; the attribute notation
    makes the caller believe that access is (relatively) cheap.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于简单的公共数据属性，最好只公开属性名称，而不使用复杂的访问器/修改器方法。记住，如果发现简单的数据属性需要增长功能行为，Python 提供了一条简单的路径。在这种情况下，使用属性来隐藏简单数据属性访问语法背后的功能实现。注意
    1：属性仅在新的类上工作。注意 2：尽量保持功能行为无副作用，尽管如缓存这样的副作用通常是可以接受的。注意 3：避免使用属性进行计算密集型操作；属性符号使调用者相信访问（相对）是廉价的。
- en: 'If your class is intended to be subclassed, and you have attributes that you
    don’t want subclasses to use, consider naming them with double leading underscores
    and no trailing underscores. This invokes Python’s name-mangling algorithm, where
    the name of the class is mangled into the attribute name. This helps avoid attribute
    name collisions should subclasses inadvertently contain attributes with the same
    name. Note 1: Only the simple class name is used in the mangled name, so if a
    subclass chooses both the same class name and attribute name, you can still get
    name collisions. Note 2: Name mangling can make certain uses, such as debugging
    and `__getattr__()`, less convenient. However the name-mangling algorithm is well
    documented and easy to perform manually. Note 3: Not everyone likes name mangling.
    Try to balance the need to avoid accidental name clashes with potential use by
    advanced callers.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的类打算被继承，并且你有不想让子类使用的属性，考虑使用双前导下划线和无尾随下划线来命名它们。这会调用 Python 的名称混淆算法，其中类的名称被混淆到属性名称中。这有助于避免子类意外包含具有相同名称的属性。注意
    1：仅使用简单的类名在混淆名称中，所以如果子类选择了相同的类名和属性名，你仍然可能会得到名称冲突。注意 2：名称混淆可能会使某些用途（如调试和 `__getattr__()`）不太方便。然而，名称混淆算法有很好的文档记录，并且易于手动执行。注意
    3：并非每个人都喜欢名称混淆。尝试在避免意外名称冲突的需求与高级调用者的潜在使用之间取得平衡。
- en: A.4.2\. Programming recommendations
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.4.2\. 编程建议
- en: You should write code in a way that does not disadvantage other implementations
    of Python (PyPy, Jython, IronPython, Pyrex, Psyco, and such).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 应该以不损害其他 Python（PyPy、Jython、IronPython、Pyrex、Psyco 等）实现的方式编写代码。
- en: For example, don’t rely on CPython’s efficient implementation of in-place string
    concatenation for statements in the form `a+=b` or `a=a+b`. Those statements run
    more slowly in Jython. In performance-sensitive parts of the library, you should
    use the `''.join()` form instead. This will ensure that concatenation occurs in
    linear time across various implementations.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，不要依赖于 CPython 对原地字符串连接的高效实现，用于形式为 `a+=b` 或 `a=a+b` 的语句。这些语句在 Jython 中运行得更慢。在库的性能敏感部分，你应该使用
    `''.join()` 形式。这将确保连接在各种实现中按线性时间发生。
- en: Comparisons to singletons like `None` should always be done with `is` or `is
    not`, never the equality operators.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `None` 这样的单例的比较应该始终使用 `is` 或 `is not`，而不是相等运算符。
- en: Also, beware of writing `if x` when you really mean `if x is not None`, for
    example, when testing whether a variable or argument that defaults to `None` was
    set to some other value. The other value might have a type (such as a container)
    that could be false in a Boolean context!
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，当你真正想表达的是 `if x is not None` 时，不要写成 `if x`，例如，当测试一个默认值为 `None` 的变量或参数是否被设置为其他值时。其他值可能具有（如容器）在布尔上下文中可能为假的数据类型！
- en: Use class-based exceptions.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于类的异常。
- en: String exceptions in new code are forbidden, because this language feature has
    been removed in Python 2.6.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在新代码中禁止使用字符串异常，因为这种语言特性已在 Python 2.6 中被移除。
- en: 'Modules or packages should define their own domain-specific base exception
    class, which should be subclassed from the built-in `Exception` class. Always
    include a class docstring, for example:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 模块或包应定义自己的领域特定基异常类，该类应从内置的 `Exception` 类继承。始终包含类文档字符串，例如：
- en: '[PRE29]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Class-naming conventions apply here, although you should add the suffix `Error`
    to your exception classes if the exception is an error. Non-error exceptions need
    no special suffix.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 类命名约定适用于此处，尽管你应该在异常类中添加后缀 `Error`，如果异常是错误。非错误异常不需要特殊后缀。
- en: When raising an exception, use `raise ValueError('message')` instead of the
    older form `raise ValueError, 'message'`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当抛出异常时，使用 `raise ValueError('message')` 而不是较旧的格式 `raise ValueError, 'message'`。
- en: The paren-using form is preferred because when the exception arguments are long
    or include string formatting, you don’t need to use line continuation characters
    thanks to the containing parentheses. The older form has been removed in Python
    3.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 使用括号的形式是首选的，因为当异常参数很长或包含字符串格式化时，由于包含括号，你不需要使用行续行字符。较旧的形式已在 Python 3 中被移除。
- en: When catching exceptions, mention specific exceptions whenever possible instead
    of using a bare `except:` clause. For example, use
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在捕获异常时，尽可能提及具体的异常，而不是使用裸的 `except:` 子句。例如，使用
- en: '[PRE30]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: A bare `except:` clause will catch `SystemExit` and `KeyboardInterrupt` exceptions,
    making it harder to interrupt a program with Control-C, and can disguise other
    problems. If you want to catch all exceptions that signal program errors, use
    `except Exception:`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 裸的 `except:` 子句将捕获 `SystemExit` 和 `KeyboardInterrupt` 异常，这使得使用 Control-C 中断程序变得更加困难，并且可能掩盖其他问题。如果你想捕获所有表示程序错误的异常，请使用
    `except Exception:`。
- en: 'A good rule of thumb is to limit use of bare `except` clauses to two cases:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的经验法则是将裸的 `except` 子句的使用限制在两种情况：
- en: If the exception handler will be printing out or logging the traceback; at least
    the user will be aware that an error has occurred.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果异常处理程序将打印或记录跟踪信息；至少用户会知道已发生错误。
- en: If the code needs to do some cleanup work but then lets the exception propagate
    upward with `raise`, then `try...finally` is a better way to handle this case.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果代码需要做一些清理工作，但随后又使用 `raise` 让异常向上传播，那么 `try...finally` 是处理这种情况的更好方式。
- en: In addition, for all `try/except` clauses, limit the `try` clause to the absolute
    minimum amount of code necessary. Again, this avoids masking bugs.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，对于所有 `try/except` 子句，将 `try` 子句限制在绝对必要的最小代码量。再次强调，这可以避免掩盖错误。
- en: 'Yes:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 'Yes:'
- en: '[PRE31]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'No:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 'No:'
- en: '[PRE32]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '***1* Will also catch KeyError raised by handle_value()**'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 也会捕获由 handle_value() 触发的 KeyError**'
- en: Use string methods instead of the string module.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字符串方法而不是字符串模块。
- en: String methods are always much faster and share the same API with Unicode strings.
    Override this rule if backward compatibility with Python versions older than 2.0
    is required.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串方法总是更快，并且与 Unicode 字符串共享相同的 API。如果需要与 Python 2.0 之前的版本保持向后兼容性，则可以覆盖此规则。
- en: Use `''.startswith()` and `''.endswith()` instead of string slicing to check
    for prefixes or suffixes.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `''.startswith()` 和 `''.endswith()` 而不是字符串切片来检查前缀或后缀。
- en: '`startswith()` and `endswith()` are cleaner and less error prone.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`startswith()` 和 `endswith()` 更简洁且错误更少。'
- en: 'Yes:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 'Yes:'
- en: '[PRE33]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'No:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 'No:'
- en: '[PRE34]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The exception is if your code must work with Python 1.5.2 (but let’s hope not!).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 例外情况是如果你的代码必须与 Python 1.5.2 兼容（但让我们希望不是这样！）。
- en: Object type comparisons should always use `isinstance()` instead of comparing
    types directly.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 对象类型比较应始终使用 `isinstance()` 而不是直接比较类型。
- en: 'Yes:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 'Yes:'
- en: '[PRE35]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'No:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 'No:'
- en: '[PRE36]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'When checking to see if an object is a string, keep in mind that it might be
    a Unicode string too! In Python 2.3, `str` and `unicode` have a common base class,
    `basestring`, so you can do the following:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 当检查一个对象是否为字符串时，请记住它可能也是一个 Unicode 字符串！在 Python 2.3 中，`str` 和 `unicode` 有一个共同的基类
    `basestring`，因此你可以这样做：
- en: '[PRE37]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In Python 2.2, the `types` module has the `StringTypes` type defined for that
    purpose, for example:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 2.2 中，`types` 模块定义了 `StringTypes` 类型用于此目的，例如：
- en: '[PRE38]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In Python 2.0 and 2.1, you should do the following:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 2.0 和 2.1 中，你应该这样做：
- en: '[PRE39]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: For sequences (strings, lists, tuples), use the fact that empty sequences are
    false.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 对于序列（字符串、列表、元组），使用空序列为假的事实。
- en: 'Yes:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 'Yes:'
- en: '[PRE40]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'No:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 'No:'
- en: '[PRE41]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Don’t write string literals that rely on significant trailing whitespace. Such
    trailing whitespace is visually indistinguishable, and some editors (or more recently,
    reindent.py) will trim them.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 不要编写依赖于大量尾随空白的字符串字面量。这种尾随空白在视觉上无法区分，并且一些编辑器（或更近期的 reindent.py）会将其删除。
- en: Don’t compare Boolean values to `True` or `False` using `==`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用 `==` 将布尔值与 `True` 或 `False` 进行比较。
- en: 'Yes:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 'Yes:'
- en: '[PRE42]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'No:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 'No:'
- en: '[PRE43]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Worse:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 更糟的是：
- en: '[PRE44]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Copyright—this document has been placed in the public domain.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 版权——本文件已被置于公有领域。
- en: A.4.3\. Other guides for Python style
  id: totrans-277
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.4.3\. 其他 Python 风格指南
- en: Although PEP 8 remains the most influential style guide for Python, you have
    other options. In general, these guides don’t contradict PEP 8, but they offer
    wider examples and fuller reasoning about how to make your code Pythonic. One
    good choice is *The Elements of Python Style*, freely available at [https://github.com/amontalenti/elements-of-python-style/blob/master/README.md](https://github.com/amontalenti/elements-of-python-style/blob/master/README.md).
    Another useful guide is The Hitchhiker’s Guide to Python, by Kenneth Reitz and
    Tanya Schlusser, also freely available at [http://docs.python-guide.org/en/latest/](http://docs.python-guide.org/en/latest/).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 PEP 8 仍然是 Python 最有影响力的风格指南，但你还有其他选择。通常，这些指南并不与 PEP 8 冲突，但它们提供了更广泛的示例和更充分的理由，说明如何使你的代码更符合
    Python 风格。一个不错的选择是 *《Python 风格要素》*，可在 [https://github.com/amontalenti/elements-of-python-style/blob/master/README.md](https://github.com/amontalenti/elements-of-python-style/blob/master/README.md)
    免费获取。另一个有用的指南是 Kenneth Reitz 和 Tanya Schlusser 编著的《Python 漫游指南》，同样可在 [http://docs.python-guide.org/en/latest/](http://docs.python-guide.org/en/latest/)
    免费获取。
- en: As the language and programmers’ skills continue to evolve, there will certainly
    be other guides, and I encourage you to take advantage of new guides as they’re
    produced, but only after starting with PEP 8.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 随着语言和程序员技能的不断演变，肯定会有其他指南，我鼓励你在新指南发布后充分利用它们，但前提是先从 PEP 8 开始。
- en: A.5\. The Zen of Python
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.5\. Python 的禅意
- en: The following document is PEP 20, also referred to as “The Zen of Python,” a
    slightly tongue-in-cheek statement of the philosophy of Python. In addition to
    being included in the Python documentation, the Zen of Python is an Easter egg
    in the Python interpreter. Type `import this` at the interactive prompt to see
    it.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 以下文档是 PEP 20，也被称为“Python 的禅意”，这是一句带点幽默的话，阐述了 Python 的哲学。除了包含在 Python 文档中，Python
    的禅意也是 Python 解释器中的一个彩蛋。在交互式提示符中输入 `import this` 即可查看。
- en: Longtime Pythoneer Tim Peters succinctly channels the BDFL’s (Benevolent Dictator
    for Life) guiding principles for Python’s design into 20 aphorisms, only 19 of
    which have been written down.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 长期从事 Python 开发的 Tim Peters 简明扼要地将 BDFL（终身仁慈独裁者）为 Python 设计的指导原则融入了 20 条格言，其中只有
    19 条被记录下来。
- en: '**The Zen of Python**'
  id: totrans-283
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Python 的禅意**'
- en: ''
  id: totrans-284
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Beautiful is better than ugly.*'
  id: totrans-285
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*美丽优于丑陋*。'
- en: ''
  id: totrans-286
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Explicit is better than implicit.*'
  id: totrans-287
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*明确优于隐晦*。'
- en: ''
  id: totrans-288
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Simple is better than complex.*'
  id: totrans-289
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*简单优于复杂*。'
- en: ''
  id: totrans-290
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Complex is better than complicated.*'
  id: totrans-291
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*复杂优于复杂*。'
- en: ''
  id: totrans-292
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Flat is better than nested.*'
  id: totrans-293
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*扁平结构优于嵌套结构*。'
- en: ''
  id: totrans-294
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Sparse is better than dense.*'
  id: totrans-295
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*稀疏优于密集*。'
- en: ''
  id: totrans-296
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Readability counts.*'
  id: totrans-297
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*可读性很重要*。'
- en: ''
  id: totrans-298
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Special cases aren’t special enough to break the rules.*'
  id: totrans-299
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*特殊情况并不足以打破规则*。'
- en: ''
  id: totrans-300
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Although practicality beats purity.*'
  id: totrans-301
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*尽管实用性胜过纯粹性*。'
- en: ''
  id: totrans-302
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Errors should never pass silently.*'
  id: totrans-303
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*错误不应该默默无闻地通过*。'
- en: ''
  id: totrans-304
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Unless explicitly silenced.*'
  id: totrans-305
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*除非明确禁止*。'
- en: ''
  id: totrans-306
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*In the face of ambiguity, refuse the temptation to guess.*'
  id: totrans-307
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*面对歧义，拒绝猜测的诱惑*。'
- en: ''
  id: totrans-308
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*There should be one—and preferably only one—obvious way to do it.*'
  id: totrans-309
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*应该只有一个——最好是唯一一个——明显的做法*。'
- en: ''
  id: totrans-310
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Although that way may not be obvious at first unless you’re Dutch.*'
  id: totrans-311
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*尽管一开始可能不明显，除非你是荷兰人*。'
- en: ''
  id: totrans-312
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Now is better than never.*'
  id: totrans-313
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*现在比从未好*。'
- en: ''
  id: totrans-314
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Although never is often better than *right* now.*'
  id: totrans-315
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*尽管永远比现在好*。'
- en: ''
  id: totrans-316
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*If the implementation is hard to explain, it’s a bad idea.*'
  id: totrans-317
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*如果实现起来难以解释，那是个坏主意*。'
- en: ''
  id: totrans-318
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*If the implementation is easy to explain, it may be a good idea.*'
  id: totrans-319
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*如果实现起来容易解释，那可能是个好主意*。'
- en: ''
  id: totrans-320
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Namespaces are one honking great idea—let’s do more of those!*'
  id: totrans-321
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*命名空间是一个非常好的想法——让我们多做些这样的工作！*。'
- en: Copyright—This document has been placed in the public domain.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 版权——本文件已进入公有领域。
