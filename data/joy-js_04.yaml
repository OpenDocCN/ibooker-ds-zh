- en: 3 Linked, compositional object models
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 链接，组合对象模型
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Understanding the Objects Linked to Other Objects (OLOO) pattern of behavior
    delegation with linked objects
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解与其他对象链接的对象（OLOO）的行为委托模式
- en: Combining classes with mixins for concatenative dynamic extension
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过组合类和混入（mixins）来实现动态扩展
- en: Using `Object.assign` and the spread operator to build new objects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Object.assign`和扩展运算符来构建新对象
- en: '*Class inheritance is very rarely (perhaps never) the best approach in JavaScript.*'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*类继承在JavaScript中很少（可能永远）是最好的方法。*'
- en: —Eric Elliot
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: —埃里克·埃利奥特
- en: In chapter 2, we looked at some of the scaffolding needed to create prototype
    chains to model inheritance and how classes streamline this process. Remember
    that the goal of using inheritance is to improve reusability. Now we’ll continue
    the topic of assembling your objects to achieve the same level of code reuse,
    but in a way that doesn’t require you to think in terms of inheritance.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二章中，我们探讨了创建原型链以模拟继承所需的一些基本结构，以及类如何简化这一过程。记住，使用继承的目的是为了提高复用性。现在我们将继续讨论组装你的对象，以实现相同级别的代码复用，但这种方式不需要你从继承的角度去思考。
- en: The first technique, discovered by Kyle Simpson, is called Objects Linked to
    Other Objects (OLOO) and relies on `Object.create` to create associations among
    the objects that constitute your domain model. This technique has the simplicity
    of classes of stripping away the complicated prototype jargon while setting up
    the prototype chain properly. This pattern is interesting because it allows you
    to look at your domain model as a collection of peer objects that delegate to
    one another to carry out their work.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种技术，由凯尔·辛普森发现，被称为与其他对象链接的对象（OLOO），它依赖于`Object.create`来创建构成你的领域模型的对象之间的关联。这种技术具有类的基本简洁性，同时正确地设置了原型链。这个模式很有趣，因为它允许你将领域模型视为一组对等对象，它们相互委托以完成工作。
- en: The second approach is based on composing objects that capture a small set of
    behavior known as mixins to create a much richer model, as you can see on full
    display in the works of Eric Elliot, Douglas Crockford, and other JavaScript experts.
    In this case, instead of acquiring properties from a long prototype chain, mixins
    allow you to integrate various independent pieces of behavior and/or data into
    a single object. A good example of this technique outside JavaScript is a CSS
    preprocessor such as Sass. You can use `@mixin`s to group repetitive stylesheet
    information and apply it to many rule sets. In many cases, this technique is preferred
    to `@extends`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法基于组合捕获一小组行为（称为混入）以创建一个更丰富的模型，正如埃里克·埃利奥特、道格拉斯·克罗克福德和其他JavaScript专家的作品中所充分展示的那样。在这种情况下，而不是从长原型链中获取属性，混入允许你将各种独立的行为和/或数据集成到一个单一的对象中。在JavaScript之外，这种技术的良好例子是一个CSS预处理器，如Sass。你可以使用`@mixin`来分组重复的样式表信息并将其应用于许多规则集。在许多情况下，这种技术比`@extends`更受欢迎。
- en: In this chapter, we’ll be talking about links between objects as being explicit
    (set directly in code) or implicit (wired via JavaScript’s runtime). These types
    of links are important to understand before jumping into the patterns mentioned
    in this section.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论对象之间的链接是显式（直接在代码中设置）还是隐式（通过JavaScript的运行时连接）。在深入研究本节中提到的模式之前，理解这些类型的链接非常重要。
- en: 3.1 Types of object links
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 对象链接类型
- en: 'In JavaScript, you can associate objects in two ways: implicitly and explicitly.
    Both types of association allow one object to send messages to another (aka delegation),
    but they behave a bit differently. Figure 3.1 illustrates the difference.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，你可以以两种方式关联对象：隐式和显式。这两种类型的关联都允许一个对象向另一个对象发送消息（即委托），但它们的行为略有不同。图3.1展示了这种差异。
- en: '![](../Images/3-1.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3-1.png)'
- en: Figure 3.1 Explicit delegation occurs through a property known directly by name.
    Implicit delegation occurs through JavaScript’s prototype lookup process, chained
    by the internal `__proto__` property.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 显式委托通过直接按名称知道的一个属性发生。隐式委托通过JavaScript的内部`__proto__`属性链式查找过程发生。
- en: Let’s start with implicit (implied) links.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从隐式（暗示）链接开始。
- en: 3.1.1  Implicit
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.1  隐式
- en: An implicit link is known only internally—in other words, is not visible in
    the code. In JavaScript, links to objects that delegate behavior by using the
    [[Prototype]] internal reference can be considered implicit because the runtime
    uses it to send messages to other objects (up the chain, in the case of inheritance)
    on your behalf as part of property resolution, as shown in the next listing.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式链接只在内部已知——换句话说，在代码中不可见。在 JavaScript 中，通过使用 [[Prototype]] 内部引用来委托行为的对象链接可以被认为是隐式的，因为运行时会代表你使用它将消息发送到其他对象（在继承的情况下，向上链），作为属性解析的一部分，如下一个列表所示。
- en: Listing 3.1 Implicit reference between `Foo` and `UpperCaseFormatter`
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.1 `Foo` 和 `UpperCaseFormatter` 之间的隐式引用
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ format is resolved through the prototype chain.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 格式通过原型链解析。
- en: The association formed is one in which object A delegates to B by an “is a”
    relationship, and the same object context (`this`) is used to access the full
    set of behavior. In this example, we say that `Foo` “is a” `UpperCaseFormatter`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 形成的关联是一种对象 A 通过“是”关系委托给 B 的关联，并且使用相同的对象上下文（`this`）来访问完整的行为集。在这个例子中，我们说 `Foo`
    “是” `UpperCaseFormatter`。
- en: Implicit linking or delegation is the fundamental method of accessing properties
    and behavior in prototype-based languages. This method is used by all the object
    construction patterns we’ve discussed so far (classes and constructor functions)
    and is also used by OLOO and mixins, which we’ll discuss in sections 3.2 and 3.5,
    respectively.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式链接或委托是原型语言中访问属性和行为的基本方法。这种方法被我们迄今为止讨论的所有对象构造模式（类和构造函数）所使用，也被 OLOO 和混入（我们将在
    3.2 和 3.5 节中分别讨论）所使用。
- en: 3.1.2 Explicit
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.2 显式
- en: On the other hand, objects are linked explicitly when the link is well-known
    and visibly set in code, perhaps through a public or private property. I don’t
    cover this technique in the book, but it’s important to look at a simple example
    for comparison, shown in the next listing.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当链接已知且在代码中明显设置时，对象会通过显式链接，可能通过公共或私有属性来实现。我在书中没有涵盖这种技术，但查看一个简单的示例进行比较是很重要的，如下一个列表所示。
- en: Listing 3.2 Explicit link between `Foo` and `UpperCaseFormatter`
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.2 `Foo` 和 `UpperCaseFormatter` 之间的显式链接
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Explicitly passes an object to another
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 显式地将一个对象传递给另一个
- en: Again, if we were to label these relationships, when the relation is explicit,
    we say that some object A delegates to B with a “uses” label, also known as object
    composition. In this case, `Foo` uses `UpperCaseFormatter` to carry out its work,
    and both objects have different life cycles. In this configuration, it’s sensible
    to check whether `this.formatter` `!==` `null`. Visually, you can see the explicit
    relationship because `UpperCaseFormatter`’s properties are accessed by delegating
    through a known reference (`formatter`), explicitly typed in the code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，如果我们对这些关系进行标记，当关系是显式的，我们说某个对象 A 通过“使用”标签委托给 B，也称为对象组合。在这种情况下，`Foo` 使用 `UpperCaseFormatter`
    来执行其工作，并且这两个对象有不同的生命周期。在这个配置中，检查 `this.formatter` `!==` `null` 是合理的。从视觉上看，你可以看到显式的关系，因为
    `UpperCaseFormatter` 的属性是通过通过已知引用（`formatter`）代理访问的，这在代码中是显式类型化的。
- en: In the case of an implicit link, the life cycles of both objects are intertwined,
    in that `UpperCaseFormatter`’s properties would be accessed via `this`; it’s understood
    that the runtime is resolving these properties via `__proto__`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在隐式链接的情况下，两个对象的生命周期交织在一起，因为 `UpperCaseFormatter` 的属性将通过 `this` 访问；运行时通过 `__proto__`
    解析这些属性是理解的。
- en: Now that you understand this fundamental difference, let’s begin with a pattern
    that uses implicit links to achieve behavior delegation.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了这种基本差异，让我们从使用隐式链接来实现行为委托的模式开始。
- en: 3.2 OLOO
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 OLOO
- en: The OLOO pattern was presented by Kyle Simpson in his book series You Don’t
    Know JS (mentioned in chapter 2) as well as his entertaining and thorough video
    series “Deep JavaScript Foundations” ([https://frontendmasters.com/courses/javascript-foundations](https://frontendmasters.com/courses/javascript-foundations/)).
    This pattern is interesting to study because it changes our mindset when it comes
    to visualizing parent-child relationships among objects. OLOO’s view of differential
    inheritance is different from the mental model of classes in that it doesn’t consider
    child objects to derive from a base object. Rather, it considers objects peers
    that link together and delegate functionality by passing messages to each other.
    All that inheritance-related terminology disappears, and we no longer say that
    an object inherits from another; we say that it links to another, which is a much
    simpler model to understand.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: OLOO 模式由凯尔·辛普森在他的书籍系列《你不知道的 JavaScript》（在第 2 章中提及）以及他有趣且详尽的视频系列“深入 JavaScript
    基础”中提出（[https://frontendmasters.com/courses/javascript-foundations](https://frontendmasters.com/courses/javascript-foundations/)）。这个模式值得研究，因为它改变了我们看待对象之间父子关系可视化的思维方式。OLOO
    对差分继承的看法与类的心智模型不同，因为它不认为子对象是从基对象派生出来的。相反，它认为对象是相互链接的同伴，通过传递消息来委托功能。所有与继承相关的术语都消失了，我们不再说一个对象继承自另一个对象；我们说它链接到另一个对象，这是一个更简单的模型，更容易理解。
- en: Furthermore, OLOO keeps the good parts of the language while throwing away the
    deceiving class-based design and the complex prototype configuration of the constructor
    function pattern. OLOO still uses the [[Prototype]], but that mechanism is cleverly
    hidden behind `Object.create` and provides a much simpler userland model for designing
    objects. If you were to look under the hood of `Object.create` ([http://mng.bz/
    zxnB](http://mng.bz/zxnB)), you’ll see the minimal implementation of the constructor
    functions pattern, shown in the next listing.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，OLOO 保留了语言的良好部分，同时摒弃了欺骗性的基于类的设计和构造函数模式的复杂原型配置。OLOO 仍然使用 [[Prototype]]，但这个机制被巧妙地隐藏在
    `Object.create` 之后，为设计对象提供了一个更简单的用户模型。如果你要查看 `Object.create` 的内部机制（[http://mng.bz/zxnB](http://mng.bz/zxnB)），你会看到构造函数模式的最小实现，如下一列表所示。
- en: Listing 3.3 Under the hood of `Object.create`
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.3 `Object.create` 的内部机制
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Creates a new superfluous constructor function, F
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个新的多余的构造函数，F
- en: ❷ Sets the prototype of the constructor function
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 设置构造函数的原型
- en: ❸ Returns the new object invoking the new keyword
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 返回调用 new 关键字的新对象
- en: 'Now that we know that `Object.create` takes care of the boilerplate code for
    us, let’s take proper advantage of it and use it to wire up the chain connecting
    all our objects. I’ll start showing you this pattern with a simple example that
    introduces some of the components of this pattern. In this snippet of code, we’ll
    begin to play with the concept of the blockchain data structure. A `Blockchain`
    is an object that stores consecutive elements, called blocks:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道 `Object.create` 为我们处理了样板代码，那么让我们充分利用它，并使用它来连接所有对象的链。我将从展示这个模式的一些组件的简单示例开始。在这个代码片段中，我们将开始玩转区块链数据结构的概念。区块链是一个存储连续元素的对象，称为块：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this example, we first link the objects `MyStore` and `Blockchain`; then
    we link the object `chain` (which we consider to be the actual instance object
    with all the functionality) with `Blockchain`. In the definition of `MyStore`,
    the `init` initializer method is in charge of typical object constructor logic
    that sets the properties of the new instance. As you can see from the preceding
    code snippet, `chain` properly delegates to properties of its peers: `init`, `push`,
    and `length`.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先将对象 `MyStore` 和 `Blockchain` 链接起来；然后我们将对象 `chain`（我们认为它是具有所有功能的实际实例对象）与
    `Blockchain` 链接起来。在 `MyStore` 的定义中，`init` 初始化方法负责典型的对象构造器逻辑，设置新实例的属性。正如你从前面的代码片段中看到的，`chain`
    正确地将其同伴的属性 `init`、`push` 和 `length` 委托出去。
- en: 'Another interesting aspect of OLOO is that after `Object.create(Blockchain``)`
    is called, all the links get created in memory. `Blockchain` knows about `init`
    and `push` because of the prototype chain, but the objects have not been initialized
    because `init` has not been called. At this point, the shape of the object is
    in memory and instantiated, but actual initialization of the data happens when
    `init` is called, which sets everything in motion, populates the first block in
    the chain, and returns a ready-to-use object to its caller. As you can see, the
    objects are linked properly:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: OLOO（对象链接和对象初始化）的另一个有趣方面是，在调用`Object.create(Blockchain)`之后，所有的链接都在内存中创建。`Blockchain`通过原型链知道`init`和`push`，但对象尚未初始化，因为`init`尚未被调用。此时，对象的形状已经在内存中实例化，但实际的数据初始化发生在调用`init`时，这启动了整个过程，填充了链中的第一个区块，并将一个可用的对象返回给调用者。正如你所见，对象被正确地链接：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can think of `init` as having some of the responsibilities of a class constructor.
    But unlike a class constructor, which performs construction and initialization
    at the same time, OLOO separates the two actions as different steps. Separating
    declaration from use allows you to define and lazily pass around the actual object
    representation (a template, perhaps) as a first-class object, similar to passing
    a class definition around. Then you can initialize this lazily built, minimal
    object with its full set of data only when needed.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将`init`视为具有类构造函数的一些职责。但与同时执行构建和初始化的类构造函数不同，OLOO将这两个动作作为不同的步骤分开。将声明与使用分离，允许你定义并懒加载实际的物体表示（例如模板）作为一个一等对象，类似于传递类定义。然后，你可以在需要时仅用其完整的数据集初始化这个懒加载的最小对象。
- en: This pattern resembles the Builder pattern ([https://en.wikipedia.org/wiki/Builder
    _pattern](https://en.wikipedia.org/wiki/Builder_pattern)), which is used a lot
    in object-oriented design.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式类似于建造者模式（[https://en.wikipedia.org/wiki/Builder_pattern](https://en.wikipedia.org/wiki/Builder_pattern)），在面向对象设计中使用得很多。
- en: 'But if you’d like to call both steps fluently inline, you can do so easily
    by returning `this` from the `init` method:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你希望流畅地内联调用这两个步骤，你可以通过从`init`方法返回`this`来实现：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'A noticeable difference with OLOO compared with constructor functions and classes
    is that the reliance in the prototypal inheritance is much more controlled and
    less exposed. When `MyStore.isPrototypeOf(Blockchain)` is `true`, you can’t inadvertently
    change the shape of all initialized objects, protecting you from prototype pollution.
    In fact, `MyStore` and `Blockchain` are not constructor functions at all, so they
    do not have a `prototype` property to do this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 与构造函数和类相比，OLOO在原型继承上的依赖性更加可控和隐蔽。当`MyStore.isPrototypeOf(Blockchain)`为`true`时，你无法意外地改变所有初始化对象的形状，从而保护你免受原型污染。实际上，`MyStore`和`Blockchain`根本不是构造函数，因此它们没有`prototype`属性来做这件事：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now that you’ve seen the pattern in a simple scenario, let’s use this same idea
    to refactor `Transaction`. The next listing shows a simple OLOO implementation;
    listing 3.5 shows the full implementation.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经在一个简单场景中看到了这个模式，让我们用这个同样的想法重构`Transaction`。接下来的列表显示了一个简单的OLOO实现；列表3.5显示了完整的实现。
- en: Listing 3.4 `HashTransaction` with simple object linking
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.4 `HashTransaction`的简单对象链接
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ The init method is the exact equivalent of a class constructor (merely a convention;
    you can use any method name you like).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `init`方法与类构造函数完全等价（仅是一种约定；你可以使用任何你喜欢的名称）。
- en: ❷ Because the object is returned directly, results in the properties of this
    object contained inside the specialized object
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 由于对象是直接返回的，导致此对象的属性包含在专用对象内部
- en: ❸ Uses Object.create to build new objects and nicely separate prototype linkage
    from object initialization
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用`Object.create`构建新对象，并将原型链接与对象初始化很好地分离
- en: ❹ This method is invoked through the prototype chain.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 此方法通过原型链调用。
- en: Everything should look straightforward so far. The only thing we’ve added compared
    to the `MyStore` example is a bit more functionality to each object. Figure 3.2
    shows the structure of the objects and the links among them.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切看起来都很直接。与我们添加的`MyStore`示例相比，我们只是为每个对象添加了更多一点的功能。图3.2显示了对象的结构以及它们之间的链接。
- en: '![](../Images/3-2.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3-2.png)'
- en: Figure 3.2 Surface view of how the three object peers are linked
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 三种对象对之间的链接表面视图
- en: Figure 3.2 shows that you can establish implicit links among objects and at
    the same time remove the prototypal boilerplate code that you would have otherwise
    needed to write with classes and (to greater extent) constructor functions. The
    following listing builds out the full-fledged `Transaction` object in all its
    glory.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 显示，你可以建立对象之间的隐式链接，同时移除使用类和（在更大程度上）构造函数时可能需要编写的原型样板代码。下面的列表展示了完整的 `Transaction`
    对象及其所有功能。
- en: Listing 3.5 Modeling `Transaction` with behavior delegation (OLOO)
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.5 使用行为委托（OLOO）建模 `Transaction`
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ The entire chain is based on simple objects, with Transaction at the base
    of the hierarchy.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 整个链基于简单对象，`Transaction` 位于层次结构的底部。
- en: ❷ The init functions are analogous to a class’s constructor. Also, the use of
    the function keyword is deliberate to establish the proper behavior of this.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 初始化函数类似于类构造函数。此外，使用函数关键字是故意的，以确立 this 的正确行为。
- en: ❸ Private properties are nicely encapsulated in the object’s closure, allowing
    only privileged methods to access them.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 私有属性被很好地封装在对象的闭包中，只允许特权方法访问它们。
- en: ❹ Because I’m using a plain function as constructor, there is no implied this,
    so we need to return it ourselves.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 因为我是使用普通函数作为构造函数，所以没有隐含的 this，因此我们需要自己返回它。
- en: ❺ Using JavaScript’s Object.create properly creates the implicit delegation
    linkage using [[Prototype]].
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 正确使用 JavaScript 的 Object.create 可以创建使用 [[Prototype]] 的隐式委托链接。
- en: ❻ The init functions are analogous to a class’s constructor. Also, the use of
    the function keyword is deliberate to establish the proper behavior of this.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 初始化函数类似于类构造函数。此外，使用函数关键字是故意的，以确立 this 的正确行为。
- en: ❼ Equivalent to the use of super within a child class’s constructor
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 等同于在子类构造函数中使用 super。
- en: This code is the same as in listing 3.4 but adds more initialization logic to
    `HashTransaction` to clearly separate initialization from instantiation. Figure
    3.3 shows a more complete diagram.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与列表 3.4 中的代码相同，但为 `HashTransaction` 添加了更多的初始化逻辑，以清楚地将初始化与实例化分开。图 3.3 显示了一个更完整的图。
- en: '![](../Images/3-3.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/3-3.png)'
- en: Figure 3.3 A full-fledged implementation of the OLOO pattern to implement `HashTransaction`,
    linking to `Transaction` to delegate basic functionality
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 实现了 OLOO 模式的完整实现，以实现 `HashTransaction`，链接到 `Transaction` 以委托基本功能
- en: As figure 3.3 shows, the `init` function nicely encapsulates any private state
    inside its lexical scope (à la the Module pattern) and exposes only what’s needed
    through `this`. You could take the opportunity to define any private functions
    that are needed as part of object construction, and nothing would leak out to
    the caller. Also, you see a very visible management of the object context (`this`)
    being passed from one `init` block to the next upstream until reaching the parent
    object. This is not done to create the prototype linkage (as `Object.create` does
    that for you), but to initialize the entire chain up to the base object.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如图 3.3 所示，`init` 函数很好地封装了其词法作用域内的任何私有状态（类似于模块模式），并通过 `this` 仅暴露所需的内容。你可以利用这个机会定义任何作为对象构建一部分所需的私有函数，并且不会有任何内容泄露给调用者。此外，你还可以看到对象上下文（`this`）从上一个
    `init` 块到下一个上游直到父对象的可视化管理。这不是为了创建原型链接（因为 `Object.create` 会为你做这个），而是为了初始化整个链直到基对象。
- en: Up to now, you’ve learned about object modeling techniques that share the idea
    of using the prototype resolution mechanism with implicit links to delegate to
    other objects, whether that delegation is up the chain or along the chain. But
    all these techniques lack the ability to share behavior from more than one object,
    because prototypes establish a single, unidirectional path in which properties
    are dynamically resolved. These situations do not occur frequently in software,
    but when they do, the prototype chain is insufficient to model them correctly.
    Take a simple example extracted from nature. Amphibians are animals with both
    aquatic and terrestrial characteristics. If you were to map out the objects `Amphibian`,
    `Aquatic`, and `Terrestrial`, how could you model this relationship in a prototypal
    manner so that `Amphibian` links to both `AquaticAnimal` and `TerrestrialAnimal`?
    Multiple inheritance, perhaps?
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经学习了关于对象建模的技术，这些技术共享使用原型解析机制和隐式链接到其他对象的观念，无论这种委托是向上还是沿着链。但是所有这些技术都缺乏从多个对象共享行为的能力，因为原型建立了一个单一、单向的路径，其中属性是动态解析的。这些情况在软件中并不常见，但一旦发生，原型链就不足以正确地模拟它们。以一个从自然界中提取的简单例子来说明。两栖动物是具有水生和陆生特性的动物。如果你要绘制出`Amphibian`、`Aquatic`和`Terrestrial`对象，你如何以原型方式建模这种关系，使得`Amphibian`链接到`AquaticAnimal`和`TerrestrialAnimal`？可能是多重继承？
- en: You don’t need to use inheritance at all. Let’s explore another software construction
    pattern that relies on object composition. It’s important to add that when I mention
    composition of objects, I’m not referring to the well-known object-oriented pattern
    that goes by that name. This pattern is much simpler. Here, I’m referring to the
    ability to assemble a rich object by gluing together small individual pieces or
    traits—composition in the structural sense. JavaScript’s object model is one of
    a kind that lets us perform this task, and the API to use is `Object.assign`.
    Section 3.3 discusses this API first and then shows you how it’s used to compose
    objects. You’ll use the API to implement mixins in section 3.4.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你根本不需要使用继承。让我们探索另一种依赖对象组合的软件构建模式。重要的是要说明，当我提到对象的组合时，我并不是指那个同名已知的面向对象模式。这个模式要简单得多。在这里，我指的是通过粘合小的单个部分或特性来组装一个丰富的对象的能力——在结构意义上的组合。JavaScript的对象模型是独一无二的，它让我们能够执行这个任务，而要使用的API是`Object.assign`。第3.3节首先讨论了这个API，然后展示了如何使用它来组合对象。你将在第3.4节中使用这个API来实现混入。
- en: 3.3 Understanding Object.assign
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 理解 Object.assign
- en: Software evolves quickly, and requirements change drastically. The problem with
    prototypal object models is that they tend to become too rigid and brittle over
    time, making it difficult to introduce big changes to your model with the guarantee
    that those changes won’t break something else up or along the chain of delegation.
    Mishandling base objects higher up in the hierarchy may cause rippling downstream
    effects throughout your model—an issue known as the fragile base class problem.
    You can use patterns to minimize this problem by physically copying properties
    down to derived objects.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 软件发展迅速，需求变化剧烈。原型对象模型的问题在于，随着时间的推移，它们往往会变得过于僵化和脆弱，这使得在保证不会破坏其他东西的情况下，很难对模型进行大的改动。在层次结构中不当处理基类可能会导致在整个模型中产生连锁反应——这个问题被称为脆弱基类问题。你可以使用模式通过物理复制属性到派生对象来最小化这个问题。
- en: State copying over state sharing isn’t a new concept. Instead of assembling
    rigid hierarchies of objects, why don’t you build objects by handing them copies
    of all the properties they need? With JavaScript, in which objects are dynamic
    bags of properties, this process is simple. JavaScript allows you to glue together
    various pieces (bags) of properties (call them partial objects, if you will) to
    create a whole, feature-rich object, like pouring the contents of several bags
    into a larger one. This process is done not by linking to a prototype, but by
    integrating or merging copies of simpler, individual objects.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 状态复制而非状态共享并不是一个新概念。为什么不通过传递它们所需的所有属性的副本来构建对象呢？在JavaScript中，对象是属性的动态集合，这个过程很简单。JavaScript允许你粘合各种属性（称为部分对象）的各个部分，以创建一个完整的、功能丰富的对象，就像将几个袋子的内容倒入一个更大的袋子中一样。这个过程不是通过链接到原型来完成的，而是通过整合或合并更简单、单个对象的副本。
- en: Aside from instantiation, from the perspective of the user, using objects built
    this way feels no different from the approaches listed earlier; the shape of the
    object on the surface is the same. From a code-reasoning point of view, however,
    the process is radically different. In the following sections, we explore the
    JavaScript APIs that support this process and some behind-the-scenes features
    that make it possible.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 除了实例化之外，从用户的角度来看，使用这种方式构建的对象与前面列出的方法感觉没有区别；表面上对象的形状是相同的。然而，从代码推理的角度来看，这个过程却是根本不同的。在接下来的几节中，我们将探讨支持此过程的
    JavaScript API 以及一些幕后特性，这些特性使得这一切成为可能。
- en: 3.3.1 Object.assign uncovered
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.1 暴露 `Object.assign`
- en: You can use `Object.assign` to merge the properties of various objects. In this
    section, we’ll discuss in depth how to use this API. `Object.assign` is a nice
    little Swiss army knife to have in your tool belt. It comes in handy in several
    use cases. Suppose that you’re developing a mashup of several API responses and
    would like to deliver the response body as a single JSON. Another common task
    is to perform a shallow clone by assigning the properties of an object to a new,
    empty object `{}`. Many libraries that accept configuration objects as arguments
    use `Object.assign` to provide defaults. In the next listing, the function `doSomething`
    takes a `config` object that allows the user to specify settings for the hypothetical
    logic carried out by this function.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `Object.assign` 来合并各种对象的属性。在本节中，我们将深入讨论如何使用此 API。`Object.assign` 是您工具箱中的一个很好的瑞士军刀，它在几个用例中都很有用。假设您正在开发几个
    API 响应的混合体，并希望将响应体作为单个 JSON 提供出来。另一个常见任务是通过对一个对象的新空对象 `{}` 分配属性来执行浅克隆。许多接受配置对象作为参数的库使用
    `Object.assign` 来提供默认值。在下面的列表中，函数 `doSomething` 接收一个 `config` 对象，允许用户为此函数执行的假设逻辑指定设置。
- en: Listing 3.6 Using `Object.assign` to implement options with defaults
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.6 使用 `Object.assign` 实现具有默认值的选项
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Configuration defaults
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 配置默认值
- en: By merging the user-provided object with defaults, it’s easy to obtain the desired
    `config.` `Object.assign` copies the enumerable properties that one or more objects
    owns (as defined by `Object#hasOwnProperty`) into a target object, returning the
    target object. The following listing shows a simple example.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 通过合并用户提供的对象和默认值，很容易获得所需的 `config.` `Object.assign` 将一个或多个对象拥有的可枚举属性（由 `Object#hasOwnProperty`
    定义）复制到目标对象中，并返回目标对象。下面的列表展示了简单示例。
- en: Listing 3.7 Using `Object.assign` to merge two objects into a new object
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.7 使用 `Object.assign` 将两个对象合并到新对象中
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ These properties are enumerable and owned by the object, so they get copied.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这些属性是可枚举的，并且属于对象，因此它们会被复制。
- en: In this case, all the objects in question have their properties as `enumerable:`
    `true`, which means that `Object.assign` will scan and copy them.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，所有相关的对象都具有 `enumerable:` `true` 的属性，这意味着 `Object.assign` 将扫描并复制它们。
- en: 'Now consider a non-enumerable property, which will be skipped:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑一个不可枚举的属性，它将被跳过：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can find enumerable properties by iterating over an object, using a construct
    such as `for...in` for properties that have `enumerable:` `true``.` You can control
    this meta-attribute as well as three others (`writable`, `configurable`, and `value`)
    at the point of definition. Recall from chapter 2 that the meta-object containing
    these four attributes is known as a property or data descriptor.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过迭代对象，使用 `for...in` 这样的结构来找到可枚举属性，这些属性具有 `enumerable:` `true`。您可以在定义点控制这个元属性以及另外三个（`writable`、`configurable`
    和 `value`）。回想第2章，包含这四个属性的元对象被称为属性或数据描述符。
- en: 'Following `Object#hasOwnProperty`, owned properties refer to properties found
    directly in the source objects, not properties accessible via their prototype.
    In the following code snippet, the inherited property `parent` is never assigned
    to the target object:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 `Object#hasOwnProperty`，自有属性指的是直接在源对象中找到的属性，而不是通过其原型可访问的属性。在下面的代码片段中，继承属性
    `parent` 从未分配给目标对象：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now consider a property with the same name, with the objects being merged.
    In this case, the rule is that the object to the right overrides the set of properties
    of the object to the left in the list. Here’s a simple use case:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑一个具有相同名称的属性，对象正在合并。在这种情况下，规则是列表中右侧的对象覆盖左侧对象的属性集。这里有一个简单的用例：
- en: '| `const a = {``a: ''a''``};``const b = {``b: ''b''``};``Object.assign({},
    a, b);``//{ a: ''a'', b: ''b'' }` | `const c = {``a: ''ca'',``c: ''c''``};``Object.assign({},
    a, b, c);``//{ a: ''ca'', b: ''b'', c: ''c'' }` |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `const a = {a: ''a''};const b = {b: ''b''};Object.assign({}, a, b);` | `const
    c = {a: ''ca'', c: ''c''};Object.assign({}, a, b, c);` |'
- en: This rule is important, and I’ll circle back to it in section 3.4.2.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这条规则很重要，我将在3.4.2节中再次提到它。
- en: At this point, you may be thinking that `Object.assign` simply copies properties
    right to left. Well, not always. There’s a subtle difference between definition
    and assignment.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可能认为`Object.assign`只是从右到左直接复制属性。嗯，并不总是这样。定义和赋值之间有一个微妙的不同。
- en: 3.3.2 Assignment vs definition
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.2 赋值与定义的区别
- en: Assigning a value to an existing property doesn’t define how a property behaves,
    the way that `Object.defineProperty` does. Assignment falls back to defining a
    property only if an assignment is made for a property that doesn’t exist. Hence,
    for new properties, JavaScript uses the [[DefineOwnProperty]] internal process
    as outlined in the specification, and for existing properties, it uses [[Set]],
    which won’t alter the property’s meta-attributes, as happened in our first example
    with `doSomething` (see the following listing).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 将值赋给现有属性并不定义属性的行为方式，就像`Object.defineProperty`所做的那样。赋值只有在为不存在的属性进行赋值时才会回退到定义属性。因此，对于新属性，JavaScript使用规范中概述的[[DefineOwnProperty]]内部过程，而对于现有属性，它使用[[Set]]，这不会改变属性的元属性，就像我们第一个例子中的`doSomething`（见以下列表）所发生的那样。
- en: Listing 3.8 Using `Object.assign` to assign values to new and existing properties
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.8 使用`Object.assign`为新和现有属性赋值
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ foo gets set to 'hello', and bar and baz are newly defined during Object.assign.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将`foo`设置为`'hello'`，而`bar`和`baz`是在`Object.assign`过程中新定义的。
- en: 'Most of the time, this distinction makes no difference, but sometimes it does.
    Let’s explore the difference with another example:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，这种区别没有影响，但有时会有。让我们通过另一个例子来探索这种区别：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding call works as expected, and `sender` is set to `'luke@tjoj.com'`.
    But what if `sender` wasn’t a string property, but a setter method? According
    to the specification, `Object.assign` invokes the [[Set]] meta-operation for an
    existing property key. Consider the scenario in the next listing.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的调用按预期工作，`sender`被设置为`'luke@tjoj.com'`。但如果`sender`不是一个字符串属性，而是一个setter方法呢？根据规范，`Object.assign`会对现有属性键调用[[Set]]元操作。考虑下一个列表中的场景。
- en: Listing 3.9 `Object.assign` invokes [[Set]] when encountering the same property
    name
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.9 `Object.assign`在遇到相同属性名时调用[[Set]]
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ A regular expression that matches valid email addresses
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 匹配有效电子邮件地址的正则表达式
- en: ❷ Sending input with invalid email address
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用无效电子邮件地址发送输入
- en: Here, `sender` is considered to be an existing property and gets processed through
    JavaScript’s internal [[Set]] property, causing the setter logic to execute and
    fail when the email address is badly formatted.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`sender`被视为一个现有属性，并通过JavaScript的内部[[Set]]属性进行处理，当电子邮件地址格式错误时，setter逻辑会执行并失败。
- en: 'Now that you understand the basic workings of this built-in API, let’s use
    it to support our last object construction pattern: mixins.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了这个内置API的基本工作原理，让我们用它来支持我们最后的对象构造模式：混入。
- en: 3.4 Assembling objects using mixin composition
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 使用混入组合组装对象
- en: The idea behind composing or assembling objects is a bit different from the
    approaches you’ve seen so far. With prototypes, you link to a single object to
    share its state and behavior, but with mixins, you copy fine-grained pieces of
    multiple independent slices of objects that together represent the entirety of
    the object’s API. This section teaches you how to use `Object.assign` to achieve
    a technique called concatenative object extension with mixins.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 组合或组装对象的思路与之前看到的方法略有不同。使用原型，你链接到一个单一的对象以共享其状态和行为，但使用混入，你复制了多个独立切片对象的精细粒度部分，这些切片共同代表了对象的全部API。本节教你如何使用`Object.assign`来实现一种称为混入的连接对象扩展技术。
- en: 'Think of mixins as adding flavors to your ice cream or toppings to your sandwich;
    every new addition adds a twist to the overall flavor but doesn’t overpower it.
    Before we dive into our final version of `Transaction`, let’s study a simple use
    case. Consider these trivial object literals:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 将混入（mixins）想象成给你的冰淇淋添加风味或给你的三明治加配料；每一次新的添加都会给整体风味带来变化，但不会压倒它。在我们深入到`Transaction`的最终版本之前，让我们研究一个简单的用例。考虑以下这些简单的对象字面量：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Our `Sandwich` object can be created by joining any or all of these parts:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Sandwich` 对象可以通过连接以下任何部分或全部来创建：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'More succinctly, you can take advantage of the spread operator:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 更简洁地说，您可以利用扩展运算符：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: A mixin object like `HasBread` doesn’t provide much value on its own, but it
    can be used to enhance some target object—`Sandwich`, in this case. Going back
    briefly to the OLOO pattern, you may have caught a glimpse of it as the properties
    (methods and data) of a parent object were added during the execution of the derived
    object’s constructor. This process repeats at every level of the linked object
    graph. In fact, to ease the transition of using `Object.assign` as a means to
    define object relationships, consider a slight twist on the OLOO example that
    combines the object-linking step (`const` `HashTransaction` `=` `Object.create(Transaction)`)
    and defines new properties on this new object, as shown next.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 `HasBread` 的混入对象本身并不提供太多价值，但它可以用来增强某些目标对象——在这个例子中是 `Sandwich`。简要回顾一下 OLOO
    模式，你可能在派生对象构造函数执行期间添加父对象的属性（方法和数据）时瞥见了它。这个过程在链接对象图的每一层都会重复。实际上，为了简化使用 `Object.assign`
    作为定义对象关系手段的过渡，可以考虑对 OLOO 示例进行轻微的调整，将对象链接步骤（`const HashTransaction = Object.create(Transaction)`）和在此新对象上定义新属性结合起来，如下所示。
- en: Listing 3.10 OLOO implemented with `Object.assign`
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.10 使用 `Object.assign` 实现的 OLOO
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Defines the properties of HashTransaction through assignment using Object.assign
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 通过使用 Object.assign 分配定义 HashTransaction 的属性
- en: A mixin is an object with simple behavior, typically made from one or two methods.
    In this case, there’s one method, `calculateHash`, which we’ll refactor into its
    own object in section 3.5.1\. The simpler mixins are, the easier they are to compose
    and reuse in many parts of your code. Mixins should have a narrow focus, much
    smaller than a class. They could capture a single responsibility or perhaps even
    a slice of a responsibility. It’s acceptable for a mixin to look incomplete as
    long as it’s self-sustaining and has everything needed to carry out its task.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 混入是一个具有简单行为的对象，通常由一个或两个方法组成。在这种情况下，有一个方法，`calculateHash`，我们将在 3.5.1 节中将其重构为其自己的对象。混入越简单，就越容易在代码的许多部分中组合和重用。混入应该具有狭窄的焦点，远小于类。它们可以捕获单一责任或甚至是一部分责任。只要混入是自维持的并且拥有执行其任务所需的一切，看起来不完整是可以接受的。
- en: NOTE This book discusses mixins only superficially. For more information on
    the mixin pattern, check out Composing Software, by Eric Elliot ([https:// leanpub.com/composingsoftware](https://leanpub.com/composingsoftware)).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本书仅对混入模式进行了表面讨论。有关混入模式的更多信息，请参阅埃里克·埃利奥特（Eric Elliot）的《Composing Software》（[https://leanpub.com/composingsoftware](https://leanpub.com/composingsoftware)）。
- en: Object composition promotes creating HAS-A or USES-A rather than IS-A relationships
    among objects. So instead of implicitly delegating to an object’s parent, you
    circumvent inheritance and copy all the properties you need directly to the target
    object. You can imagine this process as being analogous to squashing an inheritance
    hierarchy two or three levels deep into a single object literal. Because you’re
    adding new properties to an object after it’s been defined, this process is called
    dynamic or concatenative object extension.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对象组合促进创建对象之间的 HAS-A 或 USES-A 而不是 IS-A 关系。因此，您不是隐式地将对象委派给其父对象，而是绕过继承，直接将所有需要的属性复制到目标对象。您可以想象这个过程类似于将继承层次结构压缩成单个对象字面量。由于您是在对象定义之后添加新属性，这个过程被称为动态或连接性对象扩展。
- en: Mixins might sound a little complicated, but the pattern has been widely used
    for some time. I mentioned its use in CSS preprocessors, but there are others
    uses in JavaScript itself. In browsers, the behavior instilled by the global `window`
    object is in part implemented by the `WindowOrWorkerGlobalScope` mixin. Similarly,
    browser events are handled by the `WindowEventHandlers` mixin. These mixins are
    used to group a common set of properties between the global objects used in browsers
    (`window`) as well as the Web Worker API (`self`). The browsers premix this code
    for you, of course, so that you don’t have to, but consider a more obvious example.
    If you’ve ever used the popular Mocha and Chai unit testing libraries, you probably
    know that you can extend their functionality by injecting new behavior dynamically,
    using
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 混入可能听起来有些复杂，但这种模式已经被广泛使用了一段时间。我提到了它在CSS预处理器中的使用，但JavaScript本身也有其他用途。在浏览器中，由全局`window`对象灌输的行为部分是通过`WindowOrWorkerGlobalScope`混入实现的。同样，浏览器事件是通过`WindowEventHandlers`混入处理的。这些混入用于在浏览器中使用的全局对象（`window`）以及Web
    Worker API（`self`）之间分组一组常见的属性。当然，浏览器为您预先混合了这些代码，因此您不必这样做，但考虑一个更明显的例子。如果您曾经使用过流行的Mocha和Chai单元测试库，您可能知道您可以通过动态注入新行为来扩展它们的功能，使用
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The method name (`use`) is appropriate. Many other third-party libraries already
    take advantage of this feature. To streamline testing with promises, for example,
    you can extend Chai with the chai-as-promised ([https://www.npmjs.com/package/chai-as
    -promised](https://www.npmjs.com/package/chai-as-promised)) library:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 方法名（`use`）是合适的。许多其他第三方库已经利用了这一特性。例如，为了简化使用承诺的测试，你可以通过chai-as-promised ([https://www.npmjs.com/package/chai-as-promised](https://www.npmjs.com/package/chai-as-promised))库扩展Chai：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Dynamic concatenation embodies the principle of composition well: combine simple
    objects to build a complex one, which we’re achieving here.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 动态连接体现了组合原则：将简单的对象组合成复杂的对象，这正是我们在这里所实现的。
- en: Circling back to `Transaction`, we’ll use the class definition we started in
    chapter 2 as its core structure, with mixins to borrow shared modules of code.
    The first thing you’ll notice is that the definition of `calculateHash` is not
    part of the class declaration anymore; it was moved to an object called `HasHash`.
    Separating `calculateHash` into own module will make it easier to add hashing
    behavior to other classes of our domain, such as `Block` and `Blockchain`. As
    listing 3.11 shows, instead of a simple object, a function allows us to configure
    the hashing behavior as needed with arguments, such as specifying the fields of
    the object used as part of the hashing process.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`Transaction`，我们将使用第2章开始定义的类作为其核心结构，并通过混入来借用共享的代码模块。你首先会注意到`calculateHash`的定义不再属于类声明的一部分；它被移动到了一个名为`HasHash`的对象中。将`calculateHash`分离成独立的模块将使得为我们的领域中的其他类（如`Block`和`Blockchain`）添加哈希行为变得更加容易。正如列表3.11所示，通过一个函数，我们可以根据需要使用参数来配置哈希行为，例如指定作为哈希过程一部分的对象字段。
- en: NOTE For these mixins, because we’re returning a new object, we’re going to
    use arrow functions to save some typing. A regular function declaration would
    work equally well.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：对于这些混入（mixins），因为我们返回一个新的对象，我们将使用箭头函数来节省一些打字。常规函数声明同样可以很好地工作。
- en: Listing 3.11 Defining the `HasHash` mixin
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.11 定义`HasHash`混入
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ Creates a string from the values of the specified property keys
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从指定的属性键值创建一个字符串
- en: '`HasHash` is a mixin wrapped by a function expression, so the mixin part is
    this object literal:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`HasHash`是一个由函数表达式包裹的混入，因此混入部分是这个对象字面量：'
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: For completeness, if we replace this body of code in the OLOO example (listing
    3.10), we obtain the result in the next listing.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整性，如果我们替换OLOO示例（列表3.10）中的这段代码，我们将在下一个列表中看到结果。
- en: Listing 3.12 OLOO pattern for `Transaction` using the `HasHash` mixin
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.12 使用`HasHash`混入的`Transaction`的OLOO模式
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ Copies the properties of the mixin returned by calling HasHash. By using a
    function, it’s simple to specify which properties of the object’s state the mixin
    has access to as part of calculating the object’s hash value.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 复制由调用`HasHash`返回的混入的属性。通过使用函数，可以简单地指定混入可以访问的对象状态中的哪些属性作为计算对象哈希值的一部分。
- en: Listing 3.13 shows the final version of `Transaction` (class + mixins). This
    code integrates all the mixins into the class prototype reference so that the
    same hashing functionality is available to all instances of `Transaction`. The
    `Object.assign` call with all mixins happens at the end.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.13 显示了 `Transaction` 的最终版本（类 + 混合）。此代码将所有混合集成到类原型引用中，以便 `Transaction` 的所有实例都可以使用相同的哈希功能。所有混合的
    `Object.assign` 调用都在最后进行。
- en: Listing 3.13 `Transaction` object using mixin concatenation
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.13 使用混合连接的 `Transaction` 对象
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ❶ The transactionId is set in the constructor by calling calculateHash, dynamically
    assigned to this instance’s prototype and available to all instances.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 通过调用 calculateHash 在构造函数中设置 transactionId，动态分配给此实例的原型，并可供所有实例使用。
- en: ❷ Using Object.assign to glue together (or include) the objects that make up
    a Transaction
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用 Object.assign 将构成事务的对象粘合在一起（或包含）
- en: ❸ The HasSignature mixin handles signature generation and verification.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ HasSignature 混合处理签名生成和验证。
- en: ❹ HasValidation groups common validation tasks for any object (to be discussed
    in chapter 5).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ HasValidation 为任何对象（将在第 5 章讨论）分组常见的验证任务。
- en: NOTE Using a class (such as `Transaction`) as the target object for dynamic
    mixin extension is the scenario you’ll most likely encounter in your own coding
    due to the popularity of classes. But you can use mixins with any of the construction
    patterns discussed so far.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：使用类（如 `Transaction`）作为动态混合扩展的目标对象是在你的编码中最可能遇到的情况，因为类的流行。但你可以使用混合与之前讨论的任何构造模式一起使用。
- en: You may find this pattern, also known as traits, in programming languages such
    as PHP ([https://www.php.net/manual/en/language.oop5.traits.php](https://www.php.net/manual/en/language.oop5.traits.php)).
    When you use classes, all the properties are added to the class’s prototype reference.
    For this reason, we use `Object.assign` to extend the class’s prototype dynamically
    and avoid having to repeat the logic of assigning mixins every time we need a
    new transaction.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会在像 PHP 这样的编程语言中找到这种模式，也称为特性（[https://www.php.net/manual/en/language.oop5.traits.php](https://www.php.net/manual/en/language.oop5.traits.php)）。当你使用类时，所有属性都添加到类的原型引用中。因此，我们使用
    `Object.assign` 动态扩展类的原型，以避免每次需要新的交易时都要重复分配混合的逻辑。
- en: 'Also, from a memory-efficient point of view, augmenting the prototype object
    causes all transaction objects to have the same set of properties. Instantiating
    a new `Transaction` looks the same as in chapter 2:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，从内存效率的角度来看，增强原型对象导致所有事务对象都具有相同的属性集。实例化新的 `Transaction` 看起来与第 2 章相同：
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The important thing to notice is that although this version of `Transaction`
    is different from the previous ones, it retains the best parts by
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，尽管这个版本的 `Transaction` 与之前的版本不同，但它通过以下方式保留了最佳部分：
- en: Using the convenient syntax of classes to nicely group and encapsulate all the
    pertinent transactional details.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类方便的语法来优雅地分组和封装所有相关的交易细节。
- en: Integrating reusable pieces from other mixins for maximum code reuse.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从其他混合中集成可重用部分以实现最大程度的代码重用。
- en: Separating the object definition (such as `Transaction` class) and mixin configuration
    from instantiation, akin to OLOO.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将对象定义（如 `Transaction` 类）和混合配置从实例化中分离，类似于 OLOO。
- en: Integrating only the direct, public interface of a mixin object by skipping
    nonenumerable and not-owned properties (because it uses `Object.assign``)`.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过跳过不可枚举和非所有者属性（因为它使用 `Object.assign`）仅集成混合对象的直接、公共接口。
- en: 'Allowing mixins to encapsulate hidden properties and methods of their own that
    only its public API can use, but that do not become part of the overall object
    and are not reachable from the class. The reverse is also true: mixins don’t have
    access to any private (`#`) properties declared inside the class. Only their public
    interfaces communicate, which prevents a tighter form of coupling. I’ll come back
    to this topic in section 3.5.1.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许混合封装它们自己的隐藏属性和方法，这些属性和方法只能通过其公共 API 使用，但不成为整体对象的一部分，并且无法从类中访问。反之亦然：混合没有访问类内部声明的任何私有（`#`）属性。只有它们的公共接口进行通信，这防止了更紧密的耦合形式。我将在
    3.5.1 节中回到这个话题。
- en: Avoiding deep and cumbersome prototype configurations, making objects flatter
    and therefore simpler to use and combine with other parts of the code.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免深层和繁琐的原型配置，使对象更扁平，因此更易于使用和与其他代码部分结合。
- en: Now that you know how the mixins integrate into the bigger object, let’s evaluate
    the structure of a mixin.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了混合如何集成到更大的对象中，让我们评估混合的结构。
- en: 3.4.1 Anatomy of a mixin
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.1 混合体的解剖结构
- en: 'In this section, we’re going to discuss the shape of the mixins used in our
    blockchain application. `Transaction` uses two important extensions that implement
    the two main cryptographic concepts underpinning blockchain technology: hashing
    (`HasHash`) and digital signatures (`HasSignature`). Our current version of `HasHash`
    still does not produce cryptographically secure hashes. We need to improve that
    algorithm, but we’ll save the nitty-gritty of the logic for chapter 4 and focus
    only on its shape for now. When we have the public interface and calls wired up,
    swapping algorithms in and out is simple.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论在我们区块链应用中使用的混合体的形状。`Transaction`使用了两个重要的扩展，实现了支撑区块链技术的两个主要加密概念：哈希（`HasHash`）和数字签名（`HasSignature`）。我们当前的`HasHash`版本仍然不产生加密安全的哈希。我们需要改进这个算法，但我们将逻辑的细节留到第4章，现在只关注其形状。当我们有了公共接口和连接的调用，替换算法就变得简单了。
- en: Listings 3.14 and 3.15 show the updated structures of `HasHash` and `HasSignature`,
    respectively.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.14和3.15显示了`HasHash`和`HasSignature`的更新结构。
- en: Listing 3.14 `HasHash` mixin
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.14 `HasHash`混合体
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ❶ Default options passed to configure the hashing process. Here, we’re using
    the SHA256 algorithm with hexadecimal encoding.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 传递给配置哈希过程的默认选项。在这里，我们使用SHA256算法和十六进制编码。
- en: 'Because `HasHash` accepts a list of keys representing the properties involved
    in computing the hash, it could work with with any target object. Here’s an example:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`HasHash`接受一个表示参与计算哈希的属性的键列表，它可以与任何目标对象一起工作。以下是一个例子：
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Coming back to encapsulation, assuming that the mixins are their own modules
    (chapter 6), any data outside the scope of the mixin function (such as `DEFAULT_ALGO_SHA256`)
    is virtually private and self-contained, as it is part of the mixin function’s
    closure.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 回到封装，假设混合体是其自己的模块（第6章），任何在混合体函数作用域之外的数据（如`DEFAULT_ALGO_SHA256`）实际上是私有的和自包含的，因为它是混合体函数闭包的一部分。
- en: With a similar structure, the next listing contains the skeleton for `HasSignature`.
    This mixin packs a bit more behavior.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 与此类似的结构，下一个列表包含了`HasSignature`的骨架。这个混合体包含更多的行为。
- en: Listing 3.15 `HasSignature` mixin
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.15 `HasSignature`混合体
- en: '[PRE29]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The body of these methods deals with using Node.js’s `crypto` modules to sign
    the contents of an object, as well as read and verify public/private key pairs,
    which we don’t cover in this book. Feel free to visit the code repo for the internals.
    Keep in mind, though, that in the real world of open, distributed ledgers, the
    public key is what identifies a user’s wallet to rest of the world. From the caller’s
    point of view, the next listing shows how you would use `HasSignature`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法的主体处理使用Node.js的`crypto`模块对对象的内含内容进行签名，以及读取和验证公私钥对，这些内容我们在这本书中不涉及。你可以自由地访问代码库以了解内部细节。不过，请记住，在现实世界的开放分布式账本中，公钥是识别用户钱包对其他世界的方式。从调用者的角度来看，下一个列表显示了如何使用`HasSignature`。
- en: Listing 3.16 Using `HasSignature` to sign the contents of an object
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.16 使用`HasSignature`对对象的内含内容进行签名
- en: '[PRE30]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ❶ Signs the object’s data, using the private key
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用私钥对对象的数据进行签名
- en: ❷ You can verify that the signature is correct by using the corresponding public
    key.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 你可以使用相应的公钥来验证签名的正确性。
- en: You’ve seen examples of `HasHash` and `HasSignature`. I cover `HasValidation`
    (another mixin) and its internal logic in chapter 5\. Note that I named these
    mixins with the full intention of showing that composition is happening, clearly
    establishing HAS-A relationships with the target objects, as shown in figure 3.4.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了`HasHash`和`HasSignature`的例子。我在第5章中介绍了`HasValidation`（另一个混合体）及其内部逻辑。请注意，我命名这些混合体的目的是清楚地表明正在发生组合，明确地建立了与目标对象的HAS-A关系，如图3.4所示。
- en: '![](../Images/3-4.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3-4.png)'
- en: 'Figure 3.4 When using composition, the mechanism by which an object is built
    consists of gluing together other independent objects: `HasHash`, `HasSignature`,
    and `HasValidation`. The properties of each one get mashed up into a single source,
    forming a single object from the user’s point of view.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 当使用组合时，构建对象的方式是通过粘合其他独立对象：`HasHash`、`HasSignature`和`HasValidation`。每个对象的属性被混合成一个单一来源，从用户的角度来看，形成一个单一对象。
- en: Figure 3.4 shows a theoretical or conceptual view of object composition. Practically
    speaking, after the target object is formed, the `Transaction` class looks like
    figure 3.5 to the caller.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4展示了对象组合的理论或概念视图。实际上讲，在目标对象形成后，`Transaction`类对调用者看起来就像图3.5。
- en: '![](../Images/3-5.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图3.5](../Images/3-5.png)'
- en: Figure 3.5 Shape of `Transaction` after object assignment
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 对象赋值后的`Transaction`形状
- en: It might seem that with the composition of mixins, we can obtain something similar
    to multiple inheritance—a controversial software topic. If you’ve done some research
    on this topic, you’ve come across the “diamond of death” problem. The problem
    refers to the ambiguity present when a class extends multiple classes, each declaring
    the same method. Languages with sophisticated support for this feature, such as
    Scala, overcome the problem by using a technique known as linearization. In section
    3.4.2, we’ll see how JavaScript solves this problem.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 可能看起来，通过混入的组合，我们可以获得类似于多重继承的东西——这是一个有争议的软件话题。如果你对这个话题做过一些研究，你可能会遇到“死亡钻石”问题。这个问题指的是当一个类扩展多个类，每个类都声明了相同的方法时存在的歧义。像Scala这样的语言，通过使用称为线性化的技术来克服这个问题。在3.4.2节中，我们将看到JavaScript是如何解决这个问题。
- en: 3.4.2 Multiple inheritance and linearization
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.2 多重继承与线性化
- en: 'Generally speaking, mixins have two main benefits over traditional inheritance
    schemes:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，与传统的继承方案相比，混入（mixins）有两个主要优点：
- en: Mixins reduce some limitations of single inheritance by enabling a developer
    to reuse sets of methods freely from several independent objects rather than one.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混入通过允许开发者从几个独立的对象中自由地重用方法集，而不是从一个对象中，从而减少了单继承的一些限制。
- en: The algorithm that `Object.assign` uses removes the ambiguity caused by multiple
    inheritance and makes this process predictable.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.assign`使用的算法消除了多重继承引起的歧义，并使这个过程变得可预测。'
- en: The first point is a direct result of the prototype chain mechanism, as there’s
    a 1-1 correspondence between an object and its prototype. Concatenation overcomes
    this limitation because you are free to mash together as many objects as needed
    into a single one.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 第一点是直接由原型链机制产生的结果，因为一个对象与其原型之间是一对一对应的关系。连接（concatenation）克服了这种限制，因为你可以自由地将所需数量的对象组合成一个单一的对象。
- en: 'The second point is more puzzling. How can mixins fix the infamous diamond
    problem? The premise of the problem is easy to understand: a child class C extends
    from two parent classes, B1 and B2, and each of these classes in turn extends
    from a base class A. This problem is more common in class-oriented languages,
    which label relationships to parent classes as IS-A. From that standpoint, how
    can a class be a template for two different things? Consider the animal taxonomies
    example again (figure 3.6). At the base, you may have a class `Animal`, with child
    classes `TerrestrialAnimal` and `AquaticAnimal`.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 第二点更为复杂。混入如何解决臭名昭著的钻石问题？这个问题的前提是容易理解的：一个子类C从两个父类B1和B2扩展，而这两个类又依次从基类A扩展。这个问题在面向类的语言中更为常见，这些语言将父类的关系标记为IS-A。从这个角度来看，一个类如何成为两种不同事物的模板？再次考虑动物分类学示例（图3.6）。在底层，你可能有一个类`Animal`，以及子类`TerrestrialAnimal`和`AquaticAnimal`。
- en: '![](../Images/3-6.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图3.6](../Images/3-6.png)'
- en: Figure 3.6 The classic diamond problem of multiple inheritance. Assuming that
    a class may extend form multiple other classes with a conflicting method signature,
    which method is dispatched at runtime?
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 多重继承的经典钻石问题。假设一个类可能从多个其他类扩展，而这些类具有冲突的方法签名，那么在运行时将调用哪个方法？
- en: 'First, a little biology lesson: amphibians such as frogs, toads, and salamanders
    start as larvae, with gills to breathe underwater, and later mature to adults
    with lungs to breathe air. Some amphibians even rely on their skins as a secondary
    respiratory alternative. It makes perfect sense for a class `Amphibian` to extend
    from both of these classes. But when `frog.breathe` is called, which implementation
    will it pick? With software, we can’t leave the answer to Mother Nature.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们来点生物学知识：两栖动物，如青蛙、蟾蜍和蝾螈，最初是幼虫，有鳃来在水下呼吸，后来成熟为成体，拥有肺来呼吸空气。有些两栖动物甚至依赖它们的皮肤作为次要的呼吸方式。一个类`Amphibian`从这两个类中扩展出来是很有道理的。但当调用`frog.breathe`时，它将选择哪个实现？在软件中，我们不能把答案留给大自然。
- en: 'As you might expect, we can use mixins to model this type of object:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所预期，我们可以使用混入来模拟这种类型的对象：
- en: '[PRE31]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To return to the original question, if `frog` calls `breathe`, which implementation
    does it use? Seemingly, we have entered a diamond situation. But the rules of
    `Object.assign` remove this ambiguity because it’s predictable: always favor the
    properties of the object that gets added last. You can picture this situation
    by collapsing the diamond of death to a straight line (hence, linearizing) in
    an orderly sequence. Linearizing the diamond problem would look like figure 3.7.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 回到原始问题，如果青蛙调用`breathe`，它使用的是哪种实现？看起来我们进入了一个菱形情况。但是`Object.assign`的规则消除了这种歧义，因为它是可预测的：总是优先选择最后添加的对象的属性。你可以通过将死亡菱形折叠成一条直线（因此，线性化）来想象这种情况，按照有序的顺序。线性化菱形问题看起来就像图3.7。
- en: '![](../Images/3-7.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/3-7.png)'
- en: Figure 3.7 Applying linearization to a multiple inheritance situation
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 将线性化应用于多重继承情况
- en: The way in which `Object.assign` is implemented allows the same behavior to
    occur. Behind the scenes, the implementation works like figure 3.8.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.assign`的实现方式允许发生相同的行为。在幕后，实现方式就像图3.8。'
- en: '![](../Images/3-8.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/3-8.png)'
- en: Figure 3.8 Multiple inheritance is possible with `Object.assign`’s mechanism
    that takes care of establishing a predictable order in which source objects are
    assigned to the target.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 使用`Object.assign`的机制，该机制负责建立源对象分配给目标对象的可预测顺序，可以实现多重继承。
- en: 'Now if you call `breathe` on the `frog` object, you always get the expected
    result, choosing `TerrestrialAnimal` as the implementation:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果你在`frog`对象上调用`breathe`，你总是得到预期的结果，选择`TerrestrialAnimal`作为实现：
- en: '[PRE32]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 3.4.3 Composing objects using Object.assign and the spread operator
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.3 使用Object.assign和扩展运算符组合对象
- en: Merging objects this way is so common that since ECMAScript 2018, we can streamline
    this technique even more. Instead of using the `Object.assign` API directly, we
    have language support to accomplish something similar, using the spread operator
    over objects. This operator gives you a compact, idiomatic syntax to copy the
    state of an object in an immutable way.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方式合并对象如此常见，以至于自ECMAScript 2018以来，我们可以进一步简化这项技术。我们不必直接使用`Object.assign` API，我们有语言支持来完成类似的事情，使用扩展运算符对对象进行操作。这个运算符提供了一个紧凑、惯用的语法，以不可变的方式复制对象的状态。
- en: 'In section 3.3, I briefly mention some examples in which `Object.assign` is
    useful. The spread operator works equally well for each of those cases. Consider
    the example of performing shallow clones of some object `obj`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在3.3节中，我简要提到了一些`Object.assign`有用的例子。扩展运算符在这些情况下也同等有效。考虑对某个对象`obj`执行浅克隆的例子：
- en: '[PRE33]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This example is analogous to
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子与
- en: '[PRE34]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can use the spread operator to create object templates:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用扩展运算符来创建对象模板：
- en: '[PRE35]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In a single line, we copied all owned properties from `frog` and overrode the
    name property to yield a new object called `toad`. From a practical point of view,
    `Object .assign` and the spread operator have similar uses, the exception being
    that the spread operator yields a new object instead of assigning to an existing
    object. In most cases, this exception doesn’t matter, but if we were to use the
    spread operator with the `Transaction` class where we opted to augment `prototype`
    directly, the code would fail with an error. So
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在一行中，我们复制了`frog`的所有自有属性，并覆盖了名称属性，从而得到一个新的对象，称为`toad`。从实际的角度来看，`Object.assign`和扩展运算符有类似的使用，唯一的例外是扩展运算符产生一个新的对象，而不是分配给现有的对象。在大多数情况下，这个例外并不重要，但如果我们选择使用扩展运算符与`Transaction`类一起直接增强`prototype`，代码会因错误而失败。所以
- en: '[PRE36]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'would throw an error in strict mode:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在严格模式下会抛出错误：
- en: '[PRE37]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Although both patterns allow you to create objects by combining others, that
    subtle difference is enough for us to continue using `Object.assign` in our application.
    In section 3.5, we use this pattern to complete the main classes of our domain
    model.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这两种模式都允许你通过组合其他对象来创建对象，但这种细微的差别足以让我们在我们的应用程序中继续使用`Object.assign`。在3.5节中，我们使用这种模式来完成我们的领域模型的主要类。
- en: 3.5 Applying shared mixins to multiple objects
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5 将共享混合应用到多个对象
- en: Now that you have a good understanding of dynamic object concatenation, to see
    the benefits of code reuse, we’ll apply it to other parts of our application.
    In this section, you’ll see how the mixins we’ve created so far apply to more
    than `Transaction`. To keep things a bit consistent in the domain layer, and because
    you’re more likely to run into classes in the wild, I’ll use classes to model
    the concepts of `Blockchain`, `Block`, and `Wallet`. In listing 3.12, I showed
    how to use mixins with OLOO. Both patterns use implicit linking, so you should
    be able to port this code to OLOO style without much effort.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经很好地理解了动态对象连接，为了看到代码重用的好处，我们将将其应用于应用程序的其他部分。在本节中，你将看到我们迄今为止创建的混合如何应用于不仅仅是`Transaction`。为了在领域层保持一致性，并且因为你更有可能遇到类，我将使用类来建模`Blockchain`、`Block`和`Wallet`的概念。在列表3.12中，我展示了如何使用混合与OLOO。这两种模式都使用隐式链接，所以你应该能够不费吹灰之力将此代码移植到OLOO风格。
- en: First, let’s define the `Blockchain` class in the next listing with a similar
    structure.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在下一个列表中定义具有相似结构的`Blockchain`类。
- en: Listing 3.17 `Blockchain` definition with mixins
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.17 使用混合的`Blockchain`定义
- en: '[PRE38]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: ❶ As with Transaction, extends blockchain with validation functionality. (Full
    implementation of validation logic is covered in chapter 5.)
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 与`Transaction`一样，扩展了区块链的验证功能。（验证逻辑的完整实现将在第5章中介绍。）
- en: A blockchain stores blocks, which in turn store transactions. Listing 3.17 shows
    a basic class declaration of `Block`, which we’ll fill in as we go along. The
    most important job of this class is to manage a collection of transactions and
    the hashing calculation by using its previous hash. What makes tampering detectable
    in a blockchain is that every block’s hash depends on the hashes of all the previous
    blocks, starting with the genesis. So if a block is tampered with, all you need
    to do is recompute its hash and compare it with the original to detect the malfeasance.
    The next listing shows how `Block` also mixes `HasHash`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链存储区块，而区块又存储交易。列表3.17显示了`Block`的基本类声明，我们将随着进展逐步填充它。这个类最重要的任务是使用其前一个哈希来管理交易集合和哈希计算。使区块链篡改可检测的是，每个区块的哈希都依赖于所有前一个区块的哈希，从创世区块开始。所以如果区块被篡改，你只需要重新计算其哈希，并与原始哈希比较以检测不当行为。下一个列表显示了`Block`如何也混合了`HasHash`。
- en: Listing 3.18 `Block` definition
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.18 `Block`定义
- en: '[PRE39]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: ❶ A block’s data field can contain a collection of pending transactions found
    in the blockchain at the moment a new block is mined or mined transactions found
    after the block is mined into the chain.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 一个区块的数据字段可以包含在挖掘新区块或挖掘后添加到链中的交易。
- en: ❷ Every block always contains the hash of the block that preceded it (which
    establishes the chain).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 每个区块总是包含其前一个区块的哈希（这建立了链）。
- en: ❸ HasHash augments Block with hashing functionality.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ `HasHash`扩展了`Block`的哈希功能。
- en: As of now, we’ve built the skeleton of most of the domain layer of our application.
    As you read on, you will learn more about JavaScript and programming a blockchain
    as we continue to add the finer details to this code. For additional reference,
    figure 3.9 shows the objects and the shared mixins we’ve created so far.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经构建了应用程序领域层的大部分骨架。随着你继续阅读，你将了解更多关于JavaScript和编写区块链编程的知识，我们将继续添加此代码的更详细细节。作为额外参考，图3.9显示了迄今为止我们创建的对象和共享的混合。
- en: '![](../Images/3-9.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图3-9](../Images/3-9.png)'
- en: Figure 3.9 The main objects at play, with their respective mixins. As you can
    see, mixins are designed to be shared structures.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9展示了主要对象及其各自的混合。如您所见，混合结构旨在共享。
- en: Furthermore, to make teaching blockchain simpler, I tried to avoid some of the
    cryptography topics by using email addresses to identify a transaction’s sender
    and recipient. In the real world, emails are way too personal for a public ledger,
    in which user information always needs to be secure. A transaction stores `sender`
    and `receiver` addresses in the form of cryptographically secure public keys.
    When you visit the blockchain application’s source code in GitHub, you’ll see
    keys being used instead of emails. This information identifies each user’s digital
    `Wallet`, as shown in the following listing. Think of a `Wallet` as being your
    personal banking mobile app.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了使区块链教学更简单，我尝试通过使用电子邮件地址来识别交易的发送者和接收者，从而避免了一些密码学主题。在现实世界中，电子邮件对于公共账本来说过于个人化，在公共账本中，用户信息始终需要保持安全。交易以密码学安全的公钥形式存储`sender`和`receiver`地址。当您访问GitHub上的区块链应用程序源代码时，您会看到使用密钥而不是电子邮件。此信息标识了每个用户的数字`钱包`，如下所示。将`钱包`想象成您的个人银行移动应用程序。
- en: Listing 3.19 `Wallet` object
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.19 `Wallet`对象
- en: '[PRE40]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: ❶ Details deferred to chapter 4
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 详细内容推迟到第四章
- en: Figure 3.10 shows the basic interactions among blocks, transactions, wallets,
    and blockchain.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10显示了区块、交易、钱包和区块链之间基本交互。
- en: '![](../Images/3-10.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3-10.png)'
- en: Figure 3.10 The main objects at play in our simple blockchain application. I
    have not shown `Money`, a value object that describes an amount and currency.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10展示了我们简单区块链应用程序中起主要作用的对象。我没有显示`Money`，这是一个描述金额和货币的价值对象。
- en: 'In this chapter, we explored two more object construction patterns: OLOO (also
    known as simple object linking) and concatenative object extension (also known
    as mixins). Parting from the techniques you reviewed in chapter 2, these alternatives
    give you more flexibility in modeling your objects.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了两种更多的对象构造模式：OLOO（也称为简单对象链接）和连接性对象扩展（也称为混入）。与第二章中回顾的技术不同，这些替代方案为您在建模对象时提供了更多的灵活性。
- en: There’s always a downside, however. JavaScript engines highly optimize processes
    that take advantage of the [[Prototype]] mechanism. When deviating a bit by using
    mixins instead of object hierarchies, which prefer more state copying and are
    more resilient to fragile base objects or prototype pollution, we create a slightly
    bigger combined memory footprint because we have a lot more objects in memory.
    We mitigated this situation by extending a class’s prototype instead of mixin
    into new instances directly, as the next listing shows.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，总有缺点。JavaScript引擎高度优化利用[[Prototype]]机制的过程。当我们通过使用混入而不是对象层次结构（这更喜欢更多的状态复制，并且对脆弱的基本对象或原型污染更具弹性）进行轻微偏离时，我们创建了一个稍微更大的组合内存占用，因为我们有更多的对象在内存中。我们通过将类原型扩展到新实例而不是直接将混入扩展到新实例来缓解这种情况，如下一个列表所示。
- en: Listing 3.20 Assigning mixins to a single instance of `Transaction`
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.20 将混入分配给`Transaction`的单个实例
- en: '[PRE41]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: ❶ Creates a new object each time with a copy of all methods
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 每次都创建一个新的对象，并复制所有方法
- en: With this code, you would have to repeat this complex construction call every
    time you need a new transaction. In most or all of your cases, having to copy
    state is negligible, considering that most performance bottlenecks in applications
    occur with I/O bound calls (database, network, file system, and others). Nevertheless,
    it’s important to pay attention to this situation in those rare cases in which
    you’d need hundreds of these objects.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此代码，每次需要新的交易时，您都必须重复此复杂构造函数调用。在大多数或所有情况下，考虑到大多数应用程序的性能瓶颈发生在I/O受限的调用（数据库、网络、文件系统等），复制状态是可以忽略不计的。然而，在那些您可能需要数百个此类对象的罕见情况下，关注这种情况是很重要的。
- en: Another issue to pay attention to is the implicit assumption that a mixin makes
    about the target object in which it’s embedded. You might have seen this assumption
    when we discussed the code inside `HasHash` in section 3.5\. The next listing
    shows that code again.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的问题是混入对其嵌入的目标对象的隐式假设。您可能在我们讨论3.5节中的`HasHash`内部代码时看到了这个假设。下一个列表再次显示了这段代码。
- en: Listing 3.21 `HasHash` mixin
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.21 `HasHash`混入
- en: '[PRE42]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: ❶ Creates an implicit dependency between the mixin and the whole object
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在混入和整个对象之间创建了一个隐式依赖
- en: As you can see, `this` is the glue between the whole object and its mixins.
    Mixins bind really tightly to the public interface of its target object and can
    become fragile when target objects are further extended and mixin code starts
    to change. Also, from an optics perspective, it’s hard to see the shape of the
    objects being coupled here. You’d have to navigate to all objects that mix this
    behavior to understand whether the code will work for all of them.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`this` 是整个对象及其混入之间的粘合剂。混入与目标对象的公共接口绑定得非常紧密，当目标对象进一步扩展且混入代码开始变化时，可能会变得脆弱。从光学角度来看，很难看到被耦合对象的形状。您需要导航到所有混入这种行为的对象，才能理解代码是否适用于所有这些对象。
- en: There’s no hard-and-fast rule about whether to use linking-based models versus
    inheritance-based models. As with all software, the answer depends on the types
    of problems you’re solving, the team’s expertise, and how complex your domain
    model is. Unlike other languages, however, JavaScript gives you options.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 关于是否使用基于链接的模型与基于继承的模型，并没有一条硬性规则。与所有软件一样，答案取决于您要解决的问题类型、团队的专长以及您的领域模型有多复杂。然而，与其他语言不同的是，JavaScript
    给您提供了选择。
- en: Now that we’ve examined JavaScript’s object model in great depth, it’s time
    to start talking about functions. One interesting fact about JavaScript is that
    functions are also objects in the language (aka first-class functions). In chapter
    4, you’ll learn how to exploit the benefits of first-class functions and see how
    they enable functional programming.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经深入探讨了 JavaScript 的对象模型，是时候开始讨论函数了。关于 JavaScript 的一个有趣的事实是，函数在该语言中也是对象（即一等函数）。在第
    4 章中，您将学习如何利用一等函数的优势，并了解它们如何使函数式编程成为可能。
- en: Summary
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: JavaScript offers behavior delegation via implicit links and mixins for building
    objects in a compositional manner.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 通过隐式链接和混入提供行为委托，以组合方式构建对象。
- en: Behavior delegation is the natural way to model objects in JavaScript. It uses
    the implicit delegation mechanism present in JavaScript’s lookup process and the
    prototype chain.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为委托是 JavaScript 中建模对象的自然方式。它使用 JavaScript 查找过程中存在的隐式委托机制和原型链。
- en: Object concatenation offers a simple approach based on structural object composition,
    which allows you to build objects by attaching (embedding) behavior from other
    independent objects.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象连接提供了一种基于结构化对象组合的简单方法，允许您通过附加（嵌入）来自其他独立对象的行为来构建对象。
- en: You can use mixins to extend objects (or classes) dynamically and favor structural
    composition over inheritance.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用混入动态地扩展对象（或类），并倾向于结构化组合而非继承。
- en: Mixins address the issue of multiple inheritance through a mechanism known as
    mixin linearization.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混入通过混入线性化机制解决了多重继承的问题。
- en: JavaScript offers a shortcut for `Object.assign` by using the spread operator,
    although `Object.assign` and the spread operator are not interchangeable.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 通过使用扩展运算符为 `Object.assign` 提供了快捷方式，尽管 `Object.assign` 和扩展运算符不可互换。
