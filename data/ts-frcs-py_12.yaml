- en: 10 Forecasting multiple time series
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 多个时间序列的预测
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Examining the VAR model
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查VAR模型
- en: Exploring Granger causality to validate the use of the VAR model
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索格兰杰因果检验以验证VAR模型的使用
- en: Forecasting multiple time series using the VAR model
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用VAR模型进行多个时间序列的预测
- en: 'In the last chapter, you saw how the SARIMAX model can be used to include the
    impact of exogenous variables on a time series. With the SARIMAX model, the relationship
    is unidirectional: we assume that the exogenous variable has an impact on the
    target only.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你看到了如何使用SARIMAX模型来包括外生变量对时间序列的影响。在SARIMAX模型中，关系是单向的：我们假设外生变量只对目标变量有影响。
- en: However, it is possible that two time series have a bidirectional relationship,
    meaning that time series t1 is a predictor of time series t2, and time series
    t2 is also a predictor for time series t1. In such a case, it would be useful
    to have a model that can take this bidirectional relationship into account and
    output predictions for *both*time series simultaneously.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，可能存在两个时间序列之间存在双向关系的情况，这意味着时间序列 t1 是时间序列 t2 的预测因子，同时时间序列 t2 也是时间序列 t1 的预测因子。在这种情况下，拥有一个能够考虑这种双向关系并同时对两个时间序列进行预测的模型将非常有用。
- en: This brings us to the *vector autoregression* (VAR) model. This particular model
    allows us to capture the relationship between multiple time series as they change
    over time. That, in turn, allows us to produce forecasts for many time series
    simultaneously, therefore performing multivariate forecasting.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这将我们引向向量自回归（VAR）模型。这个特定的模型允许我们捕捉多个时间序列随时间变化之间的关系。反过来，这使我们能够同时对多个时间序列进行预测，从而执行多元预测。
- en: Throughout this chapter, we will use the same US macroeconomics dataset as in
    chapter 9\. This time we’ll explore the relationship between real disposable income
    and real consumption, as shown in figure 10.1.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用与第9章相同的美国宏观经济数据集。这次我们将探索实际可支配收入与实际消费之间的关系，如图10.1所示。
- en: '![](../../OEBPS/Images/10-01.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/10-01.png)'
- en: Figure 10.1 Real disposable income (`realdpi`) and real consumption (`realcons`)
    in the United States from 1959 to 2009\. The data is collected quarterly and is
    expressed in thousands of US dollars. Both series have a similar shape and trend
    over time.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 1959年至2009年美国实际可支配收入（`realdpi`）和实际消费（`realcons`）。数据按季度收集，并以千美元为单位表示。这两个序列在时间上的形状和趋势相似。
- en: Real consumption expresses how much money people spend, while real disposable
    income represents how much money is available to spend. Therefore, it is a reasonable
    hypothesis that a higher amount of disposable income could signal higher consumption.
    The opposite can also be true, with higher consumption meaning that more income
    is available for spending. This bidirectional relationship can be captured by
    a VAR model.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 实际消费表示人们花费的金额，而实际可支配收入则代表可用于支出的金额。因此，一个更高的可支配收入可能预示着更高的消费。反之亦然，更高的消费意味着有更多的收入可用于支出。这种双向关系可以通过向量自回归（VAR）模型来捕捉。
- en: In this chapter, we’ll first explore the VAR model in detail. Then, we’ll introduce
    the Granger-causality test, which will help us validate the hypothesis that two
    time series have an impact on one another. Finally, we’ll apply the VAR model
    to produce forecasts for both real consumption and real disposable income.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先详细探讨向量自回归（VAR）模型。然后，我们将介绍格兰杰因果检验，这有助于我们验证两个时间序列相互影响的假设。最后，我们将应用VAR模型对实际消费和实际可支配收入进行预测。
- en: 10.1 Examining the VAR model
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1 检查VAR模型
- en: The vector autoregression (VAR) model captures the relationship between multiple
    series as they change over time. In this model, each series has an impact on the
    other, unlike the SARIMAX model where the exogenous variable had an impact on
    the target, but not the other way around. Recall in chapter 9 that we used the
    variables `realcons`, `realinv`, `realgovt`, `realdpi`, `cpi`, `m1`, and `tbilrate`
    as predictors for `realgdp`, but we did not consider how `realgdp` can affect
    any of those variables. That is why we used the SARIMAX model in that case.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 向量自回归（VAR）模型捕捉了多个时间序列随时间变化之间的关系。在这个模型中，每个时间序列都会对其他时间序列产生影响，这与SARIMAX模型不同，在SARIMAX模型中，外生变量对目标变量有影响，但反之则不然。回想第9章，我们使用了变量
    `realcons`、`realinv`、`realgovt`、`realdpi`、`cpi`、`m1` 和 `tbilrate` 作为 `realgdp`
    的预测因子，但我们没有考虑 `realgdp` 如何影响这些变量。这就是为什么我们在那种情况下使用了SARIMAX模型。
- en: You might have noticed the return of *autoregression*, which brings us back
    to the AR(*p*) model of chapter 5\. This is a good intuition, as the VAR model
    can be seen as a generalization of the AR(*p*) model to allow for the forecast
    of multiple time series. Therefore, we can also denote the VAR model as VAR(*p*),
    where *p* is the order and has the same meaning as in the AR(*p*) model.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了 *自回归* 的回归，这让我们回到了第 5 章的 AR(*p*) 模型。这是一个很好的直觉，因为 VAR 模型可以看作是 AR(*p*)
    模型的一种推广，允许预测多个时间序列。因此，我们也可以将 VAR 模型表示为 VAR(*p*)，其中 *p* 是阶数，其含义与 AR(*p*) 模型相同。
- en: Recall that AR(*p*) expressed the value of a time series as a linear combination
    of a constant C, the present error term *ϵ[*t*]*, which is also white noise, and
    the past values of the series *y*[*t*–*p*]. The magnitude of the influence of
    the past values on the present value is denoted as ϕ[p], which represents the
    coefficients of the AR(*p*) model, as shown in equation 10.1.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，AR(*p*) 将时间序列的值表示为常数 C、当前误差项 *ϵ[*t*]*（它也是白噪声）以及时间序列的过去值 *y*[*t*–*p*] 的线性组合。过去值对当前值的影响程度用
    ϕ[p] 表示，它代表 AR(*p*) 模型的系数，如方程式 10.1 所示。
- en: '*y[t]* = C + ϕ[1]*y*[*t*–1] + ϕ[2]*y*[*t*–2] +⋅⋅⋅+ ϕ*[p]y*[*t*–*p*] + *ϵ[*t*]*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*y[t]* = C + ϕ[1]*y*[*t*–1] + ϕ[2]*y*[*t*–2] +⋅⋅⋅+ ϕ*[p]y*[*t*–*p*] + *ϵ[*t*]*'
- en: Equation 10.1
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 方程式 10.1
- en: We can simply extend equation 10.1 to allow for multiple time series to be modeled,
    where each has an impact on the others.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将方程式 10.1 扩展以允许模拟多个时间序列，其中每个时间序列都会影响其他时间序列。
- en: For simplicity, let’s consider a system with two time series, denoted as *y*[1
    ,*t*] and *y*[2 ,*t*], and an order of 1, meaning that *p* = 1\. Then, using matrix
    notation, the VAR(1) model can be expressed as equation 10.2.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，让我们考虑一个由两个时间序列组成的时间序列系统，分别表示为 *y*[1 ,*t*] 和 *y*[2 ,*t*]，并且阶数为 1，这意味着 *p*
    = 1。然后，使用矩阵表示法，VAR(1) 模型可以表示为方程式 10.2。
- en: '![](../../OEBPS/Images/10-01-Equation-10-2.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![方程式 10-2](../../OEBPS/Images/10-01-Equation-10-2.png)'
- en: Equation 10.2
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 方程式 10.2
- en: Carrying out the matrix multiplication, the mathematical expression for *y*[1
    ,*t*] is shown in equation 10.3, and that for *y*[2 ,*t*] is shown in equation
    10.4.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 进行矩阵乘法后，*y*[1 ,*t*] 的数学表达式显示在方程式 10.3 中，而 *y*[2 ,*t*] 的表达式显示在方程式 10.4 中。
- en: '*y*[1 ,*t*] = C[1] + ϕ[1,1]*y*[1,][*t*–1] + ϕ[1,2]*y*[2,][*t*–1] + ϵ[1 ,*t*]'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*y*[1 ,*t*] = C[1] + ϕ[1,1]*y*[1,][*t*–1] + ϕ[1,2]*y*[2,][*t*–1] + ϵ[1 ,*t*]'
- en: Equation 10.3
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 方程式 10.3
- en: '*y*[2 ,*t*] = C[2] + ϕ[2,1]*y*[1,][*t*–1] + ϕ[2,2]*y*[2,][*t*–1] + ϵ[2 ,*t*]'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*y*[2 ,*t*] = C[2] + ϕ[2,1]*y*[1,][*t*–1] + ϕ[2,2]*y*[2,][*t*–1] + ϵ[2 ,*t*]'
- en: Equation 10.4
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 方程式 10.4
- en: In equation 10.3 you’ll notice that the expression for *y*[1 ,*t*] includes
    the past value of *y*[2 ,*t*]. Similarly, in equation 10.4, the expression for
    *y*[2 ,*t*] includes the past value of *y*[1 ,*t*]. Hence, you can see how the
    VAR model captures the impact of each series on the other.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在方程式 10.3 中，你会注意到 *y*[1 ,*t*] 的表达式包括了 *y*[2 ,*t*] 的过去值。同样，在方程式 10.4 中，*y*[2
    ,*t*] 的表达式包括了 *y*[1 ,*t*] 的过去值。因此，你可以看到 VAR 模型如何捕捉每个序列对其他序列的影响。
- en: We can extend equation 10.3 to express a general VAR(*p*) model that considers
    *p* lagged values, resulting in equation 10.5\. Note that the superscript does
    not represent an exponent but is used for indexing. For simplicity, we’ll again
    consider only two time series.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将方程式 10.3 扩展以表达一个考虑 *p* 个滞后值的通用向量自回归（VAR）模型，从而得到方程式 10.5。请注意，上标不代表指数，而是用于索引。为了简化，我们再次只考虑两个时间序列。
- en: '![](../../OEBPS/Images/10-01-Equation-10-5.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![方程式 10-5](../../OEBPS/Images/10-01-Equation-10-5.png)'
- en: Equation 10.5
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 方程式 10.5
- en: Just like with the AR(*p*) model, the VAR(*p*) model requires each time series
    to be stationary.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 与 AR(*p*) 模型一样，VAR(*p*) 模型要求每个时间序列都是平稳的。
- en: Vector autoregression model
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 向量自回归模型
- en: The vector autoregression model VAR(*p*) models the relationship of two or more
    time series. In this model, each time series has an impact on the others. This
    means that past values of one time series affect the other time series, and vice
    versa.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 向量自回归模型 VAR(*p*) 模拟两个或更多时间序列之间的关系。在这个模型中，每个时间序列都会影响其他时间序列。这意味着一个时间序列的过去值会影响另一个时间序列，反之亦然。
- en: The VAR(*p*) model can be seen as a generalization of the AR(*p*) model that
    allows for multiple time series. Just like in the AR(*p*) model, the order *p*
    of the VAR(*p*) model determines how many lagged values impact the present value
    of a series. In this model, however, we also include lagged values of other time
    series.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: VAR(*p*) 模型可以看作是 AR(*p*) 模型的一种推广，允许模拟多个时间序列。就像在 AR(*p*) 模型中一样，VAR(*p*) 模型的阶数
    *p* 决定了多少个滞后值会影响一个时间序列的当前值。然而，在这个模型中，我们还包含了其他时间序列的滞后值。
- en: 'For two time series, the general equation for the VAR(*p*) model is a linear
    combination of a vector of constants, past values of both time series, and a vector
    of error terms:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于两个时间序列，VAR(*p*)模型的一般方程是常数向量、两个时间序列的过去值和误差项向量的线性组合：
- en: '![](../../OEBPS/Images/10-01-Equation-10-5.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/10-01-Equation-10-5.png)'
- en: Note that the time series must be stationary to apply the VAR model.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，时间序列必须是平稳的才能应用VAR模型。
- en: You have seen how the VAR(p) model is expressed mathematically, with their lagged
    values included in each expression, as shown in equations 10.3 and 10.4\. This
    should give you a sense of how each series has an impact on the others. The VAR(*p*)
    model is only valid if both series are useful in predicting one another. Looking
    at the general shape of the series over time is not sufficient to support that
    hypothesis. Instead, we must apply the *Granger causality* test, which is a statistical
    hypothesis test to determine whether one time series is predictive of another.
    Only upon the success of this test can we apply the VAR model to make predictions.
    This is an important step in our modeling procedure when using a VAR model.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到了VAR(p)模型是如何用数学表达式表示的，每个表达式中都包含了滞后值，如方程10.3和10.4所示。这应该让您对每个序列如何影响其他序列有一个概念。VAR(*p*)模型只有在两个序列都对预测对方有用时才是有效的。仅仅观察序列随时间的变化形状是不够支持该假设的。相反，我们必须应用*格兰杰因果*检验，这是一种统计假设检验，用于确定一个时间序列是否可以预测另一个。只有在这个检验成功之后，我们才能将VAR模型应用于预测。这是使用VAR模型时建模过程中的一个重要步骤。
- en: 10.2 Designing a modeling procedure for the VAR(p) model
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2 设计VAR(p)模型的建模过程
- en: The VAR(*p*) model requires a slightly modified version of the modeling procedure
    we have been using. The most notable modification is the addition of the Granger
    causality test, since the VAR model assumes that past values of both time series
    are significantly predictive of the other time series.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: VAR(*p*)模型需要我们对之前使用的建模过程进行略微修改。最显著的修改是增加了格兰杰因果检验，因为VAR模型假设两个时间序列的过去值对另一个时间序列具有显著的预测性。
- en: The complete modeling procedure for the VAR(*p*) model is shown in figure 10.2\.
    As you can see, the modeling procedure for the VAR(*p*) model is very similar
    to the modeling procedures we have been using since the introduction of the ARMA(*p*,*q*)
    model.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: VAR(*p*)模型的完整建模过程如图10.2所示。如您所见，VAR(*p*)模型的建模过程与我们自ARMA(*p*,*q*)模型引入以来一直使用的建模过程非常相似。
- en: '![](../../OEBPS/Images/10-02.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/10-02.png)'
- en: Figure 10.2 Modeling procedure for the VAR(*p*) model. It is very similar to
    the modeling procedures we have been using since the introduction of the ARMA(*p*,
    *q*) model, but this time we are fitting different VAR(*p*) models and selecting
    the one with the lowest AIC. Then we run the Granger causality test. If it fails,
    the VAR(*p*) model is invalid, and we will not go forward with the procedure.
    On the other hand, if the test passes, we perform residual analysis. If the residuals
    are similar to white noise, the VAR(*p*) model can be used for forecasting.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 VAR(*p*)模型的建模过程。它与我们自ARMA(*p*, *q*)模型引入以来一直使用的建模过程非常相似，但这次我们正在拟合不同的VAR(*p*)模型，并选择具有最低AIC的模型。然后我们运行格兰杰因果检验。如果检验失败，VAR(*p*)模型无效，我们将不会继续该过程。另一方面，如果检验通过，我们进行残差分析。如果残差类似于白噪声，则VAR(*p*)模型可用于预测。
- en: The main difference here is that we list values only for the order *p*, since
    we are fitting different VAR(*p*) models on the data. Then, once the model with
    the lowest AIC has been selected, we perform the Granger causality test. This
    test determines whether past values of a time series are statistically significant
    in forecasting another time series. It is important to test for this relationship
    because the VAR(*p*) model uses past values of one time series to forecast another.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要区别在于我们只为阶数*p*列出值，因为我们正在对数据拟合不同的VAR(*p*)模型。然后，一旦选择了具有最低AIC的模型，我们就进行格兰杰因果检验。这个检验确定一个时间序列的过去值在预测另一个时间序列时是否具有统计显著性。测试这种关系很重要，因为VAR(*p*)模型使用一个时间序列的过去值来预测另一个。
- en: If the Granger causality test fails, we cannot say that past values of one time
    series are predictive of the other time series. In that case, the VAR(*p*) model
    becomes invalid, and we must revert to using a variation of the SARIMAX model
    to forecast the time series. On the other hand, if the Granger causality test
    passes, we can resume the procedure with residual analysis. As before, if the
    residuals are close to white noise, we can use the selected VAR(*p*) model to
    make forecasts.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果格兰杰因果检验失败，我们不能说一个时间序列的过去值可以预测另一个时间序列。在这种情况下，VAR(*p*)模型变得无效，我们必须转而使用SARIMAX模型的变体来预测时间序列。另一方面，如果格兰杰因果检验通过，我们可以继续进行残差分析。正如之前所述，如果残差接近白噪声，我们可以使用选定的VAR(*p*)模型进行预测。
- en: Before we move on to applying this modeling procedure, it is worth spending
    some time exploring the Granger causality test in more detail.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续应用这种建模程序之前，花些时间更详细地探讨格兰杰因果检验是值得的。
- en: 10.2.1 Exploring the Granger causality test
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.1 探索格兰杰因果检验
- en: As shown in the previous section, the VAR(*p*) model assumes that each time
    series has an impact on another. Therefore, it is important to test if this relationship
    actually exists. Otherwise, we would be assuming a relationship that does not
    exist, which would introduce mistakes in the model and make our predictions invalid
    and unreliable.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如前节所示，VAR(*p*)模型假设每个时间序列都会影响另一个。因此，测试这种关系是否存在非常重要。否则，我们就会假设一个不存在的关系，这会在模型中引入错误，并使我们的预测无效且不可靠。
- en: Hence, we use the Granger causality test. This is a statistical test that helps
    us determine if past values of a time series *y*[2,*t*] can help forecast time
    series *y*[1,*t*]. If that is the case, then we say that *y*[2,*t*] *Granger-causes*
    *y*[1,*t*].
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们使用格兰杰因果检验。这是一种统计检验，帮助我们确定时间序列*y*[2,*t*]的过去值是否可以帮助预测时间序列*y*[1,*t*]。如果是这样，那么我们说*y*[2,*t*]
    *格兰杰-引起* *y*[1,*t*]。
- en: Note that the Granger causality test is restricted to predictive causality,
    as we are only determining whether past values of a time series are statistically
    significant in predicting another time series. Furthermore, the test requires
    both time series to be stationary in order for the results to be valid. Also,
    the Granger causality test tests causality only in one direction; we must repeat
    the test to verify that *y*[1 ,*t*] also Granger-causes *y*[2 ,*t*] in order for
    the VAR model to be valid. Otherwise, we must resort to the SARIMAX model and
    predict each time series separately.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，格兰杰因果检验仅限于预测因果性，因为我们只确定一个时间序列的过去值在预测另一个时间序列时是否具有统计显著性。此外，该测试要求两个时间序列都是平稳的，以便结果有效。另外，格兰杰因果检验只测试单向因果关系；我们必须重复测试以验证*y*[1,*t*]也格兰杰-引起*y*[2,*t*]，以便VAR模型有效。否则，我们必须求助于SARIMAX模型并分别预测每个时间序列。
- en: The null hypothesis for this test states that *y*[2 ,*t*] does not Granger-cause
    *y*[1 ,*t*]. Again, we will use the p-value with a critical value of 0.05 to determine
    whether we will reject the null hypothesis or not. In the case where the returned
    p-value of the Granger causality test is less than 0.05, we can reject the null
    hypothesis and say that *y*[2,*t*] Granger-causes *y*[1,*t*].
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 该检验的零假设是*y*[2,*t*]不格兰杰-引起*y*[1,*t*]。同样，我们将使用p值和临界值0.05来确定是否拒绝零假设。在格兰杰因果检验返回的p值小于0.05的情况下，我们可以拒绝零假设，并说*y*[2,*t*]格兰杰-引起*y*[1,*t*]。
- en: You saw that the Granger causality test is performed after the VAR(*p*) model
    is selected. This is because the test requires us to specify the number of lags
    to include in the test, which is equivalent to the order of the model. For example,
    if the selected VAR(*p*) model is of order 3, the Granger causality test will
    determine if the past three values of a time series are statistically significant
    in forecasting the other time series.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到，在选择了VAR(*p*)模型之后，才进行格兰杰因果检验。这是因为测试需要我们指定要包含在测试中的滞后数，这相当于模型的阶数。例如，如果选定的VAR(*p*)模型是3阶的，格兰杰因果检验将确定一个时间序列的过去三个值在预测另一个时间序列时是否具有统计显著性。
- en: The `statsmodels` library conveniently includes the Granger causality test,
    which we will apply in the next section when we forecast both real consumption
    and real disposable income.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`statsmodels`库方便地包含了格兰杰因果检验，我们将在下一节中应用它，当我们预测实际消费和实际可支配收入时。'
- en: 10.3 Forecasting real disposable income and real consumption
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3 预测实际可支配收入和实际消费
- en: Having examined the VAR(*p*) model and designed a modeling procedure for it,
    we are now ready to apply it to forecasting both the real disposable income and
    real consumption in the United States. We will use the same dataset as in the
    previous chapter, which contains the macroeconomics data between 1959 and 2009.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查了VAR(*p*)模型并为其设计了建模程序后，我们现在准备将其应用于预测美国实际可支配收入和实际消费。我们将使用与上一章相同的数据库，其中包含1959年至2009年的宏观经济数据。
- en: 'Note The source code for this chapter is available on GitHub: [https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH10](https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH10).'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本章的源代码可在GitHub上找到：[https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH10](https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH10)。
- en: '[PRE0]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We can now plot our two variables of interest, which are real disposable income,
    denoted as `realdpi` in the dataset, and real consumption, denoted as `realcons`.
    The result is shown in figure 10.3.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以绘制我们感兴趣的两个变量，即实际可支配收入，在数据集中表示为`realdpi`，和实际消费，表示为`realcons`。结果如图10.3所示。
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In figure 10.3 you can see that both curves have a very similar shape through
    time, which intuitively makes them good candidates for a VAR(*p*) model. It is
    reasonable to think that with a higher disposable income, consumption is likely
    to be high, just as higher consumption can be a sign of higher disposable income.
    Of course, this hypothesis will have to be tested using the Granger causality
    test later in the modeling procedure.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在图10.3中，你可以看到两条曲线在时间上具有非常相似的形状，这直观地使它们成为VAR(*p*)模型的良好候选者。认为随着可支配收入的增加，消费很可能会增加，就像高消费可能是高可支配收入的一个标志一样，这是合理的。当然，这个假设将在建模过程的后期通过Granger因果检验来测试。
- en: We have gathered the data, so now we must determine if the time series are stationary.
    In figure 10.3 both of them exhibit a positive trend through time, meaning that
    they are non-stationary. Nevertheless, we’ll apply the augmented Dickey-Fuller
    (ADF) test to make sure.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经收集了数据，所以现在我们必须确定时间序列是否平稳。在图10.3中，它们都表现出随时间推移的正向趋势，这意味着它们是非平稳的。尽管如此，我们将应用增强迪基-富勒(ADF)检验以确保。
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ ADF test for realdpi
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 对`realdpi`进行ADF检验
- en: ❷ ADF test for realcons. Note that both time series must be stationary before
    they are used in the VAR(p) model.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 对`realcons`进行ADF检验。请注意，在它们被用于VAR(p)模型之前，这两个时间序列都必须是平稳的。
- en: '![](../../OEBPS/Images/10-03.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/10-03.png)'
- en: Figure 10.3 Real disposable income and real consumption in the United States,
    between 1959 and 2009\. The data was collected quarterly and is expressed in thousands
    of US dollars. You can see that both curves have a similar shape through time.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3展示了1959年至2009年美国实际可支配收入和实际消费。数据按季度收集，并以千美元为单位表示。你可以看到，两条曲线在时间上具有相似的形状。
- en: For both variables, the ADF test outputs a p-value of 1.0\. Therefore, we cannot
    reject the null hypothesis, and we conclude that both time series are not stationary,
    as expected.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这两个变量，ADF检验输出一个p值为1.0。因此，我们不能拒绝零假设，我们得出结论，正如预期的那样，两个时间序列都不是平稳的。
- en: We’ll apply a transformation to make them stationary. Specifically, we’ll difference
    both series and test for stationarity again.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将应用转换使它们平稳。具体来说，我们将对两个序列进行差分，并再次进行平稳性检验。
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ First-order differencing for realdpi
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 对`realdpi`进行一阶差分
- en: ❷ First-order differencing for realcons
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 对`realcons`进行一阶差分
- en: The ADF test for `realdpi` returns a p-value of 1.45 × 10^(–14), while the ADF
    test for `realcons` returns a p-value of 0.0006\. In both cases, the p-value is
    smaller than 0.05\. Therefore, we reject the null hypothesis and conclude that
    both time series are stationary. As mentioned before, the VAR(*p*) model requires
    the time series to be stationary. We can thus use the transformed series for modeling,
    and we will need to integrate the forecasts to bring them back to their original
    scales.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对`realdpi`进行的ADF检验返回一个p值为1.45 × 10^(–14)，而对`realcons`进行的ADF检验返回一个p值为0.0006。在这两种情况下，p值都小于0.05。因此，我们拒绝零假设，并得出结论，两个时间序列都是平稳的。如前所述，VAR(*p*)模型要求时间序列是平稳的。因此，我们可以使用转换后的序列进行建模，并且我们需要对预测进行积分，以将它们恢复到原始尺度。
- en: We are now at the step of fitting many VAR(*p*) models to select the one with
    the smallest Akaike information criterion (AIC). We’ll write a function, `optimize_VAR`,
    to fit many VAR(*p*) models while varying the order *p*. This function will return
    an ordered `DataFrame` in ascending order of AIC. This function is shown in the
    following listing.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在处于拟合多个 VAR(*p*) 模型以选择具有最小赤池信息准则 (AIC) 的模型的步骤。我们将编写一个名为 `optimize_VAR` 的函数，用于在阶数
    *p* 变化的同时拟合多个 VAR(*p*) 模型。此函数将返回一个按 AIC 升序排列的有序 `DataFrame`。此函数如下所示。
- en: Listing 10.1 Function to fit many VAR(*p*) models and select the one with the
    lowest AIC
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.1 函数用于拟合多个 VAR(*p*) 模型并选择具有最低 AIC 的模型
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Vary the order p from 0 to 14.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将阶数 p 从 0 变化到 14。
- en: We can now use this function to select the order *p* that minimizes the AIC.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用此函数来选择使 AIC 最小的阶数 *p*。
- en: First, though, we must define the train and test sets. In this case, we’ll use
    80% of the data for training and 20% for testing. This means that the last 40
    data points will be used for testing, and the rest is used for training. Remember
    that the VAR(*p*) model requires both series to be stationary. Therefore, we’ll
    split on the differenced dataset and feed the differenced training set to the
    `optimize_VAR` function.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须定义训练集和测试集。在这种情况下，我们将使用 80% 的数据进行训练，20% 的数据进行测试。这意味着最后 40 个数据点将用于测试，其余的用于训练。记住，VAR(*p*)
    模型要求两个序列都必须是平稳的。因此，我们将基于差分数据集进行分割，并将差分训练集输入到 `optimize_VAR` 函数中。
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Select only realdpi and realcons, as they are the only two variables of interest
    in this case.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 仅选择 realdpi 和 realcons，因为它们是此情况下唯一两个感兴趣的变量。
- en: ❷ Difference both series, as the ADF test shows that a first-order differencing
    makes them stationary.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 由于 ADF 测试表明一阶差分使它们平稳，因此对两个序列进行差分。
- en: ❸ The first 162 data points go for training. This is roughly 80% of the dataset.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 前面的 162 个数据点用于训练。这大约是数据集的 80%。
- en: ❹ The last 40 data points go for the test set. This is roughly 20% of the dataset.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 最后 40 个数据点用于测试集。这大约是数据集的 20%。
- en: ❺ Run the optimize_VAR function using the differenced data stored in train.
    This is required for the VAR(p) model.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 使用存储在 train 中的差分数据运行 `optimize_VAR` 函数。这是 VAR(p) 模型所必需的。
- en: Running the function returns a `DataFrame` in which we see that *p* = 3 has
    the lowest AIC value of all. Therefore, the selected model is a VAR(3) model,
    meaning that the past three values of each time series are used to forecast the
    other time series.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 运行该函数返回一个 `DataFrame`，我们可以看到 *p* = 3 具有所有中最小的 AIC 值。因此，所选模型是 VAR(3) 模型，这意味着每个时间序列的过去三个值用于预测其他时间序列。
- en: Following the modeling procedure, we must now use the Granger causality test
    Recall that the VAR model assumes that past values of `realcons` are useful in
    predicting `realdpi` and that past values of `realdpi` are useful in predicting
    `realcons`. This relationship must be tested. If the Granger causality test returns
    a p-value greater than 0.05, we cannot reject the null hypothesis, meaning that
    the variables do not Granger-cause each other, and the model is invalid. On the
    other hand, a p-value smaller than 0.05 will allow us to reject the null hypothesis,
    thus validating the VAR(3) model, meaning that we can move on with the modeling
    procedure.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在建模过程之后，我们现在必须使用格兰杰因果检验。记住，VAR 模型假设 `realcons` 的过去值对预测 `realdpi` 有用，而 `realdpi`
    的过去值对预测 `realcons` 也有用。这种关系必须经过检验。如果格兰杰因果检验返回的 p 值大于 0.05，我们不能拒绝零假设，这意味着变量之间没有格兰杰因果关系，模型无效。另一方面，如果
    p 值小于 0.05，我们将能够拒绝零假设，从而验证 VAR(3) 模型，这意味着我们可以继续建模过程。
- en: We’ll run the Granger causality test for both variables, using the `grangercausalitytests`
    function from the `statsmodels` library. Remember that the series must be stationary
    for the Granger causality test, which is why they are differenced when passed
    in to the function. Also, we specify the number of lags for the test, which in
    this case is 3, since the model selection step returned *p* = 3.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `statsmodels` 库中的 `grangercausalitytests` 函数对两个变量都进行格兰杰因果检验。记住，对于格兰杰因果检验，序列必须是平稳的，这就是为什么它们在传递给函数时进行了差分。此外，我们指定了测试的滞后数，在此情况下为
    3，因为模型选择步骤返回 *p* = 3。
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ The function tests if the second variable Granger-causes the first one. Here
    we thus test if realcons Granger-causes realdpi. We then pass the number of lags
    in a list, which in our case is 3\. Note that the series are differenced to make
    them stationary.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 函数测试第二个变量是否是第一个变量的格兰杰原因。因此，我们测试`realcons`是否是`realdpi`的格兰杰原因。然后我们传递一个包含滞后数的列表，在我们的例子中是3。请注意，这些序列被差分以使它们平稳。
- en: ❷ Here we test if realdpi Granger-causes realcons.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 这里我们测试`realdpi`是否是`realcons`的格兰杰原因。
- en: Running the Granger causality test for both variables returns a p-value smaller
    than 0.05 in both cases. Therefore, we can reject the null hypothesis and conclude
    that `realdpi` Granger-causes `realcons`, and `realcons` Granger-causes `realdpi`.
    Our VAR(3) model is thus valid. In the event that one variable does not Granger-cause
    the other, the VAR(*p*) model becomes invalid, and it cannot be used. In that
    case, we must use the SARIMAX model and predict each time series individually.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对两个变量进行格兰杰因果检验，两种情况下都返回了小于0.05的p值。因此，我们可以拒绝零假设，并得出结论，`realdpi`是`realcons`的格兰杰原因，`realcons`也是`realdpi`的格兰杰原因。因此，我们的VAR(3)模型是有效的。如果其中一个变量不是另一个变量的格兰杰原因，VAR(*p*)模型就变得无效，不能使用。在这种情况下，我们必须使用SARIMAX模型并分别预测每个时间序列。
- en: We can now move on to residual analysis. For this step, we first fit the VAR(3)
    model on our train set.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以继续进行残差分析。为此，我们首先在我们的训练集上拟合VAR(3)模型。
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Then we can use the `plot_diagnostics` function to plot a histogram of the residuals,
    the Q-Q plot, and the correlogram. However, we must study the residuals of two
    variables here, since we are modeling both `realdpi` and `realcons`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用`plot_diagnostics`函数来绘制残差的直方图、Q-Q图和自相关图。然而，在这里我们必须研究两个变量的残差，因为我们正在对`realdpi`和`realcons`进行建模。
- en: Let’s focus on the residuals for `realdpi` first.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们关注`realdpi`的残差。
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Passing variable=0 specifies that we want plots for the residuals of realdpi,
    since it is the first variable that was passed to the VAR model.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 通过传递变量=0指定我们想要`realdpi`残差的图，因为它是被传递给VAR模型的第一变量。
- en: The output in figure 10.4 shows that the residuals are close to white noise.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4的输出显示，残差接近白噪声。
- en: Now we can move on to analyzing the residuals of `realcons`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以继续分析`realcons`的残差。
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Passing variable=1 specifies that we want the plots of the residuals for realcons,
    since it was the second variable passed in the model.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 通过传递变量=1指定我们想要`realcons`残差的图，因为它是在模型中传递的第二变量。
- en: '![](../../OEBPS/Images/10-04.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/10-04.png)'
- en: Figure 10.4 Residuals analysis of `realdpi`. The standardized residuals seem
    to have no trend and constant variance, which is in line with white noise. The
    histogram also closely resembles the shape of a normal distribution. This is further
    supported by the Q-Q plot, which shows a fairly straight line that lies on *y*
    = *x*, although we can see some curvature at the extremities. Finally, the correlogram
    shows no significant coefficients except at lag 5\. However, this is likely due
    to chance, since there are no preceding significant coefficients. Thus, we can
    conclude that the residuals are close to white noise.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 `realdpi`的残差分析。标准化残差似乎没有趋势且方差恒定，这与白噪声相符。直方图也紧密地类似于正态分布的形状。这一点进一步得到了Q-Q图的支持，该图显示了一条相当直的线，位于*y*
    = *x*上，尽管在两端我们可以看到一些弯曲。最后，自相关图显示除了滞后5之外没有显著的系数。然而，这很可能是由于偶然，因为没有先前的显著系数。因此，我们可以得出结论，残差接近白噪声。
- en: The output in figure 10.5 shows that the residuals of `realcons` closely resemble
    white noise.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5的输出显示，`realcons`的残差非常接近白噪声。
- en: '![](../../OEBPS/Images/10-05.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/10-05.png)'
- en: Figure 10.5 Residuals analysis of `realcons`. The top-left plot shows the residuals
    over time, and you can see that there is no trend and constant variance, which
    is in line with the behavior of white noise. At the top right, the distribution
    is very close to a normal distribution. This is further supported by the Q-Q plot
    at the bottom left, which displays a fairly straight line that lies on *y* = *x*.
    Finally, the correlogram at the bottom right shows that there are no significant
    autocorrelation coefficients after lag 0\. Therefore, the residuals are close
    to white noise.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 `realcons`的残差分析。左上角的图显示了随时间变化的残差，你可以看到没有趋势且方差恒定，这与白噪声的行为相符。右上角的分布非常接近正态分布。这一点进一步得到了左下角的Q-Q图的支持，该图显示了一条相当直的线，位于*y*
    = *x*上。最后，右下角的自相关图显示在滞后0之后没有显著的自相关系数。因此，残差接近白噪声。
- en: Once the qualitative analysis is done, we can move on to the quantitative analysis
    using the Ljung-Box test. Recall that the null hypothesis of the Ljung-Box test
    states that the residuals are independent and uncorrelated. Therefore, for the
    residuals to behave like white noise, the test must return p-values that are larger
    than 0.05, in which case we do not reject the null hypothesis.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成定性分析，我们就可以继续使用Ljung-Box测试进行定量分析。回想一下，Ljung-Box测试的零假设是残差是独立且不相关的。因此，为了使残差表现得像白噪声，测试必须返回大于0.05的p值，在这种情况下，我们不拒绝零假设。
- en: 'The test must be applied on both `realdpi` and `realcons`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 测试必须应用于`realdpi`和`realcons`：
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Running the Ljung-Box test on the residuals of `realdpi` returns p-values that
    are all larger than 0.05\. Thus, we do not reject the null hypothesis, meaning
    that the residuals are uncorrelated and independent, just like white noise.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对`realdpi`的残差进行Ljung-Box测试返回的p值都大于0.05。因此，我们不拒绝零假设，这意味着残差是不相关且独立的，就像白噪声一样。
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Next, we’ll run the test on the residuals of `realcons`. This test returns p-values
    that are all greater than 0.05\. Again, we do not reject the null hypothesis,
    meaning that the residuals are not correlated and independent, just like white
    noise.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将对`realcons`的残差进行测试。这个测试返回的p值都大于0.05。同样，我们不拒绝零假设，这意味着残差是不相关且独立的，就像白噪声一样。
- en: Since the model passed both the qualitative and quantitative aspects of residual
    analysis, we can move on to forecasting `realcons` and `realdpi` using a VAR(3)
    model. We will compare the VAR(3) model to a baseline that simply predicts the
    last observed value. We’ll forecast four steps into the future, which is equivalent
    to forecasting one full year as the data is sampled quarterly. We’ll thus perform
    a rolling forecast four steps into the future over the entire length of the test
    set.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于模型通过了残差分析的定性和定量两个方面，我们可以继续使用VAR(3)模型预测`realcons`和`realdpi`。我们将比较VAR(3)模型与一个简单地预测最后一个观测值的基线。我们将预测四个步骤到未来，这相当于预测一个完整的年份，因为数据是按季度采样的。因此，我们将在整个测试集的长度上执行四个步骤的滚动预测。
- en: To do so, we’ll use the `rolling_forecast` function that we have defined many
    times over the last several chapters. This time, we’ll apply some slight modifications
    to accommodate the VAR(3) model. It will need to output predictions for both `realdpi`
    and `realcons`, so we must return two lists containing forecasts. The following
    listing shows the code for the `rolling_forecast` function.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将使用我们在过去几章中多次定义的`rolling_forecast`函数。这次，我们将对VAR(3)模型进行一些轻微的修改。它需要输出`realdpi`和`realcons`的预测结果，因此我们必须返回包含预测的两个列表。下面的列表显示了`rolling_forecast`函数的代码。
- en: Listing 10.2  Function for rolling forecasts over a test set
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.2  测试集上的滚动预测函数
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Initialize two empty lists to hold the predictions for realdpi and realcons.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 初始化两个空列表来保存`realdpi`和`realcons`的预测结果。
- en: ❷ Extract the predictions for realdpi.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 提取`realdpi`的预测结果。
- en: ❸ Extract the predictions for realcons.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 提取`realcons`的预测结果。
- en: ❹ Extend the lists with the new predictions for each variable.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将新预测结果扩展到每个变量的列表中。
- en: ❺ Return both lists of predictions for realdpi and realcons.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 返回包含`realdpi`和`realcons`预测的两个列表。
- en: ❻ For the baseline, we’ll also use two lists to hold the predictions for each
    variable and return them at the end.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 对于基线，我们也将使用两个列表来保存每个变量的预测结果，并在最后返回它们。
- en: We can now use this function to produce the forecasts for `realdpi` and `realcons`
    using the VAR(3) model.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用这个函数来使用VAR(3)模型生成`realdpi`和`realcons`的预测结果。
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ The window is 4, since we want to forecast four time steps into the future
    at a time, which is equivalent to 1 year.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 窗口大小为4，因为我们想一次预测四个时间步，这相当于1年。
- en: Recall that the VAR(3) model requires the series to be stationary, meaning that
    we have transformed forecasts. We must then integrate them using the cumulative
    sum to bring them back to the original scale of the data.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，VAR(3)模型要求序列是平稳的，这意味着我们已经对预测进行了转换。然后我们必须使用累积和来整合它们，以便将它们恢复到数据的原始尺度。
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ Integrate the forecasts using the cumulative sum.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用累积和整合预测结果。
- en: ❷ Display the test DataFrame.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 显示测试DataFrame。
- en: At this point, `test` contains the actual values of the test set and the predictions
    from the VAR(3) model. We can now add the forecasts from our baseline method,
    which simply predicts the last known value for the next four timesteps.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，`test`包含了测试集的实际值和VAR(3)模型的预测值。我们现在可以添加基线方法的预测，该方法简单地预测下一个四个时间步长的最后一个已知值。
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ Use rolling_forecast to obtain the baseline predictions using the last known
    value method.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用rolling_forecast获取使用最后一个已知值方法得到的基线预测。
- en: ❷ Display the test DataFrame.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 显示测试DataFrame。
- en: Now `test` holds the actual values of the test set, the predictions from the
    VAR(3) model, and the predictions from the baseline method. Everything is set
    for us to visualize the forecasts and evaluate the forecasting methods using the
    mean absolute percentage error (MAPE). The forecasts are shown in figure 10.6.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`test`包含了测试集的实际值、VAR(3)模型的预测值和基线方法的预测值。一切都已经为我们设置好，以便可视化预测并使用平均绝对百分比误差（MAPE）评估预测方法。预测结果如图10.6所示。
- en: '![](../../OEBPS/Images/10-06.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/10-06.png)'
- en: Figure 10.6 Forecasts of `realdpi` and `realcons`. You can see that the predictions
    from the VAR(3) model, shown as a dashed line, closely follow the actual values
    of the test set. You’ll also notice that the dotted curve from the baseline method
    shows little steps, which makes sense since we are forecasting a constant value
    over four timesteps.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 `realdpi`和`realcons`的预测。你可以看到，VAR(3)模型的预测值（以虚线表示）紧密跟随测试集的实际值。你还会注意到基线方法的点线曲线显示了小的步骤，这在预测四个时间步长内的常数值时是有意义的。
- en: In figure 10.6 the dashed line represents the forecasts from the VAR(3) model,
    and the dotted line shows the predictions from the last known value method. You
    can see that both lines are very close to the actual values of the test set, making
    it hard for us to visually determine which method is better.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在图10.6中，虚线表示VAR(3)模型的预测值，而点线显示了从最后一个已知值方法的预测。你可以看到这两条线都非常接近测试集的实际值，这使得我们很难从视觉上判断哪种方法更好。
- en: We will now calculate the MAPE. The result is shown in figure 10.7.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将计算MAPE。结果如图10.7所示。
- en: '[PRE16]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '![](../../OEBPS/Images/10-07.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/10-07.png)'
- en: Figure 10.7 The MAPE of the forecast for `realdpi` and `realcons`. You can see
    that the VAR(3) model performs worse than the baseline in the case of `realdpi`.
    However, the VAR(3) model performs better than the baseline for `realcons`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7 预测`realdpi`和`realcons`的MAPE。你可以看到，在`realdpi`的情况下，VAR(3)模型的表现不如基线，但对于`realcons`来说，VAR(3)模型的表现优于基线。
- en: In figure 10.7 you can see that the VAR(3) model performs worse than the baseline
    in the case of `realdpi` but better than the baseline for `realcons`. This is
    an ambiguous situation. There is no clear result, since the model does not outperform
    the baseline in both situations.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在图10.7中，你可以看到，在`realdpi`的情况下，VAR(3)模型的表现不如基线，但对于`realcons`来说，VAR(3)模型的表现优于基线。这是一个模糊的情况。由于模型在两种情况下都没有优于基线，因此没有明确的结果。
- en: We can hypothesize that in the case of `realdpi`, `realcons` is not predictive
    enough to make more accurate forecasts than the baseline, even though the Granger
    causality test passed. Therefore, we should resort to using a variation of the
    SARIMAX model to predict `realdpi`. Thus, I would conclude that the VAR(3) model
    is not sufficient to accurately forecast `realdpi` and `realcons`. I would suggest
    using two separate models, which could include `realdpi` and `realcons` as exogenous
    variables, while also potentially including moving average terms.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以假设，在`realdpi`的情况下，尽管格兰杰因果检验通过了，但`realcons`的预测能力不足以比基线做出更准确的预测。因此，我们应该求助于使用SARIMAX模型的变化来预测`realdpi`。因此，我会得出结论，VAR(3)模型不足以准确预测`realdpi`和`realcons`。我建议使用两个独立的模型，这些模型可能包括`realdpi`和`realcons`作为外生变量，同时可能还包括移动平均项。
- en: 10.4 Next steps
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.4 下一步
- en: In this chapter, we covered the VAR(*p*) model, which allows us to forecast
    multiple time series at once.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了VAR(*p*)模型，该模型允许我们同时预测多个时间序列。
- en: The VAR(*p*) model stands for vector autoregression, and it assumes that the
    past values of some time series are predictive of the future values of other time
    series. This bidirectional relationship is tested using the Granger causality
    test. If the test fails, meaning that the returned p-values are larger than 0.05,
    the VAR(*p*) model is invalid, and it cannot be used.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: VAR(*p*) 模型代表向量自回归，它假设某些时间序列的过去值可以预测其他时间序列的未来值。这种双向关系通过格兰杰因果检验来测试。如果测试失败，即返回的
    p 值大于 0.05，则 VAR(*p*) 模型无效，不能使用。
- en: Congratulations on making it this far—we have covered a wide array of statistical
    methods for forecasting time series! These statistical methods are great for smaller
    datasets with low dimensionality. However, when datasets start getting large,
    starting at 10,000 data points or more, and they have many features, deep learning
    can be a great tool for obtaining accurate forecasts and leveraging all the available
    data.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你走到这一步——我们已经涵盖了广泛的时间序列预测统计方法！这些统计方法非常适合小数据集和低维数据。然而，当数据集开始变得很大，从 10,000 个数据点或更多，并且具有许多特征时，深度学习可以成为一个获取准确预测和利用所有可用数据的强大工具。
- en: In the next chapter, we’ll go through a capstone project to consolidate our
    knowledge of statistical methods. Then we’ll start a new section and apply deep
    learning forecasting models on large datasets.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过一个综合项目来巩固我们对统计方法的知识。然后我们将开始一个新的部分，并在大型数据集上应用深度学习预测模型。
- en: 10.5 Exercises
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.5 练习
- en: 'Go above and beyond the VAR(*p*) model with these exercises. The full solutions
    are available on GitHub: [https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH10](https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH10).'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些练习超越 VAR(*p*) 模型。完整的解决方案可在 GitHub 上找到：[https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH10](https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH10)。
- en: 10.5.1 Use a VARMA model to predict realdpi and realcons
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.5.1 使用 VARMA 模型预测 realdpi 和 realcons
- en: In this chapter, we used a VAR(*p*) model. However, we used the `VARMAX` function
    from `statsmodels` to do so, meaning that we can easily extend the VAR(*p*) model
    to a VARMA(*p*,*q*) model. In this exercise, use a VARMA(*p*,*q*) model to forecast
    `realdpi` and `realcons`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用了 VAR(*p*) 模型。然而，我们使用了 `statsmodels` 中的 `VARMAX` 函数来实现这一点，这意味着我们可以轻松地将
    VAR(*p*) 模型扩展到 VARMA(*p*,*q*) 模型。在这个练习中，使用 VARMA(*p*,*q*) 模型来预测 `realdpi` 和 `realcons`。
- en: Use the same train and test sets as in this chapter.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用本章中相同的训练集和测试集。
- en: Generate a list of unique (*p*,*q*) combinations.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成一个独特的 (*p*,*q*) 组合列表。
- en: Rename the `optimize_VAR` function to `optimize_VARMA`, and adapt it to loop
    over all unique (*p*,*q*) combinations.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `optimize_VAR` 函数重命名为 `optimize_VARMA`，并修改它以遍历所有独特的 (*p*,*q*) 组合。
- en: Select the model with the lowest AIC, and perform the Granger causality test.
    Pass in the largest order among (*p*,*q*). Is the VARMA(*p*,*q*) model valid?
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 AIC 最低的模型，并执行格兰杰因果检验。传入 (*p*,*q*) 中的最大阶数。VARMA(*p*,*q*) 模型有效吗？
- en: Perform residual analysis.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行残差分析。
- en: Make forecasts on a four-step window over the test set. Use the last known value
    method as a baseline.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试集上对四步窗口进行预测。使用最后已知值方法作为基线。
- en: Calculate the MAPE. Is it lower or higher than that of our VAR(3) model?
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算平均绝对百分比误差（MAPE）。它是低于还是高于我们的 VAR(3) 模型？
- en: 10.5.2 Use a VARMAX model to predict realdpi and realcons
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.5.2 使用 VARMAX 模型预测 realdpi 和 realcons
- en: Again, since we used the `VARMAX` function from `statsmodels`, we know that
    we can also add exogenous variables to the model, just like in SARIMAX. In this
    exercise, use the VARMAX model to forecast `realdpi` and `realcons`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用了 `statsmodels` 中的 `VARMAX` 函数，我们知道我们也可以向模型添加外生变量，就像在 SARIMAX 中一样。在这个练习中，使用
    VARMAX 模型来预测 `realdpi` 和 `realcons`。
- en: Use the same train and test sets as in this chapter.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用本章中相同的训练集和测试集。
- en: Generate a list of unique (*p*,*q*) combinations.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成一个独特的 (*p*,*q*) 组合列表。
- en: Rename the `optimize_VAR` function to `optimize_VARMAX`, and adapt it to loop
    over all the unique (*p*,*q*) combinations and exogenous variables.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `optimize_VAR` 函数重命名为 `optimize_VARMAX`，并修改它以遍历所有独特的 (*p*,*q*) 组合和外生变量。
- en: Select the model with the lowest AIC, and perform the Granger causality test.
    Pass in the largest order among (*p*,*q*). Is the VARMAX(*p*,*q*) model valid?
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 AIC 最低的模型，并执行格兰杰因果检验。传入 (*p*,*q*) 中的最大阶数。VARMAX(*p*,*q*) 模型有效吗？
- en: Perform residual analysis.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行残差分析。
- en: Make forecasts on a one-step window over the test set. Use the last known value
    method as a baseline.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试集上对单步窗口进行预测。使用最后已知值方法作为基线。
- en: Calculate the MAPE. Did the model perform better than the baseline?
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算MAPE。模型的表现是否优于基线？
- en: Summary
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: The vector autoregression model, VAR(*p*), captures the relationship between
    multiple series as they change over time. In this model, each series has an impact
    on the others.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量自回归模型（VAR(*p*)）捕捉了多个序列随时间变化之间的关系。在这个模型中，每个序列都会对其他序列产生影响。
- en: A VAR(*p*) model is valid only if each time series Granger-causes the others.
    This is determined using the Granger causality test.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个VAR(*p*)模型只有在每个时间序列格兰杰-引起其他序列时才是有效的。这通过格兰杰因果检验来确定。
- en: The null hypothesis of the Granger causality test states that one time series
    does not Granger-cause the other. If the p-value is less than 0.05, we reject
    the null hypothesis and conclude that the first time series Granger-causes the
    other.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格兰杰因果检验的零假设是，一个时间序列不会格兰杰-引起另一个时间序列。如果p值小于0.05，我们拒绝零假设，并得出结论，第一个时间序列格兰杰-引起了另一个时间序列。
