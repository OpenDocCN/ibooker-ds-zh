- en: Chapter 6\. Concurrency
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第6章\. 并发
- en: '*In this chapter*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章内容*'
- en: Running code with goroutines
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用goroutines运行代码
- en: Detecting and fixing race conditions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测和修复竞态条件
- en: Sharing data with channels
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用通道共享数据
- en: Often a program can be written as one linear path of code that performs a single
    task and finishes. When this is possible, always choose this option, because this
    type of program is usually simple to write and maintain. But there are times when
    executing multiple tasks concurrently has greater benefit. One example is with
    a web service that can receive multiple requests for data on individual sockets
    at the same time. Each socket request is unique and can be independently processed
    from any other. Having the ability to execute requests concurrently can dramatically
    improve the performance of this type of system. With this in mind, support for
    concurrency has been built directly into Go’s language and runtime.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个程序可以编写为一条执行单一任务并完成的线性代码路径。当这是可能的时候，总是选择这个选项，因为这种类型的程序通常更容易编写和维护。但是，有时同时执行多个任务会带来更大的好处。一个例子是具有能够同时接收多个数据请求的Web服务，这些请求可以在同一时间针对不同的套接字。每个套接字请求都是唯一的，并且可以独立于其他任何请求进行处理。能够并发执行请求的能力可以显著提高这类系统的性能。考虑到这一点，并发支持已经被直接构建到Go的语言和运行时中。
- en: Concurrency in Go is the ability for functions to run independent of each other.
    When a function is created as a goroutine, it’s treated as an independent unit
    of work that gets scheduled and then executed on an available logical processor.
    The Go runtime scheduler is a sophisticated piece of software that manages all
    the goroutines that are created and need processor time. The scheduler sits on
    top of the operating system, binding operating system’s threads to logical processors
    which, in turn, execute goroutines. The scheduler controls everything related
    to which goroutines are running on which logical processors at any given time.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Go中的并发是函数能够独立运行的能力。当一个函数被创建为goroutine时，它被视为一个独立的作业单元，该单元会被调度并在可用的逻辑处理器上执行。Go运行时调度器是一块复杂的软件，它管理所有创建并需要处理器时间的goroutines。调度器位于操作系统之上，将操作系统的线程绑定到逻辑处理器上，这些处理器反过来执行goroutines。调度器控制着在任何给定时间哪些goroutines在哪些逻辑处理器上运行的所有相关事宜。
- en: Concurrency synchronization comes from a paradigm called *communicating sequential
    processes* or *CSP*. CSP is a message-passing model that works by communicating
    data between goroutines instead of locking data to synchronize access. The key
    data type for synchronizing and passing messages between goroutines is called
    a *channel*. For many developers who have never experienced writing concurrent
    programs using channels, they invoke an air of awe and excitement, which you hopefully
    will experience as well. Using channels makes it easier to write concurrent programs
    and makes them less prone to errors.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 并发同步来自一个称为**通信顺序进程**或**CSP**的范式。CSP是一个通过在goroutines之间传递数据而不是锁定数据来同步访问的消息传递模型。用于在goroutines之间同步和传递消息的关键数据类型称为**通道**。对于许多从未使用通道编写并发程序的开发者来说，他们可能会感受到一种敬畏和兴奋的氛围，你也许也会体验到这种感觉。使用通道使得编写并发程序变得更加容易，并使它们更不容易出错。
- en: 6.1\. Concurrency versus parallelism
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1\. 并发与并行
- en: Let’s start by learning at a high level what operating system *processes* and
    *threads* are. This will help you understand later on how the Go runtime scheduler
    works with the operating system to run goroutines concurrently. When you run an
    application, such as an IDE or editor, the operating system starts a process for
    the application. You can think of a process like a container that holds all the
    resources an application uses and maintains as it runs.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们从高层次了解操作系统中的**进程**和**线程**是什么。这将帮助你理解稍后如何Go运行时调度器与操作系统协同工作以并发运行goroutines。当你运行一个应用程序，例如IDE或编辑器时，操作系统会为该应用程序启动一个进程。你可以将进程想象成一个容器，它持有应用程序使用并维护的所有资源。
- en: '[Figure 6.1](#ch06fig01) shows a process that contains common resources that
    may be allocated by any process. These resources include but are not limited to
    a memory address space, handles to files, devices, and threads. A *thread* is
    a path of execution that’s scheduled by the operating system to run the code that
    you write in your functions. Each process contains at least one thread, and the
    initial thread for each process is called the *main thread*. When the main thread
    terminates, the application terminates, because this path of the execution is
    the origin for the application. The operating system schedules threads to run
    against processors regardless of the process they belong to. The algorithms that
    different operating systems use to schedule threads are always changing and abstracted
    from the programmer.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6.1](#ch06fig01) 展示了一个包含任何进程可能分配的常见资源的进程。这些资源包括但不限于内存地址空间、文件、设备和线程的句柄。*线程*是操作系统调度以运行你在函数中编写的代码的执行路径。每个进程至少包含一个线程，每个进程的初始线程称为*主线程*。当主线程终止时，应用程序也会终止，因为这条执行路径是应用程序的起源。操作系统调度线程在处理器上运行，无论它们属于哪个进程。不同操作系统用于调度线程的算法始终在变化，并且对程序员来说是抽象的。'
- en: Figure 6.1\. A simple view of a process and its threads for a running application
  id: totrans-11
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.1\. 运行应用程序的进程及其线程的简单视图
- en: '![](06fig01_alt.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![06fig01_alt.jpg](06fig01_alt.jpg)'
- en: The operating system schedules threads to run against physical processors and
    the Go runtime schedules goroutines to run against logical processors. Each logical
    processor is individually bound to a single operating system thread. As of version
    1.5, the default is to allocate a logical processor for every physical processor
    that’s available. Prior to version 1.5, the default was to allocate only a single
    logical processor. These logical processors are used to execute all the goroutines
    that are created. Even with a single logical processor, hundreds of thousands
    of goroutines can be scheduled to run concurrently with amazing efficiency and
    performance.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统调度线程在物理处理器上运行，而Go运行时调度goroutines在逻辑处理器上运行。每个逻辑处理器单独绑定到单个操作系统线程。截至版本1.5，默认为为每个可用的物理处理器分配一个逻辑处理器。在版本1.5之前，默认只分配一个逻辑处理器。这些逻辑处理器用于执行创建的所有goroutines。即使只有一个逻辑处理器，也可以调度数十万个goroutines并发运行，效率惊人，性能卓越。
- en: In [figure 6.2](#ch06fig02), you can see the relationship between an operating
    system thread, a logical processor, and the local run queue. As goroutines are
    created and ready to run, they’re placed in the scheduler’s global run queue.
    Soon after, they’re assigned to a logical processor and placed into a local run
    queue for that logical processor. From there, a goroutine waits its turn to be
    given the logical processor for execution.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图6.2](#ch06fig02)中，你可以看到操作系统线程、逻辑处理器和本地运行队列之间的关系。随着goroutines的创建和准备运行，它们被放置在调度器的全局运行队列中。不久之后，它们被分配给一个逻辑处理器，并放置在该逻辑处理器的本地运行队列中。从那里，goroutine等待轮到它被分配逻辑处理器进行执行。
- en: Figure 6.2\. How the Go scheduler manages goroutines
  id: totrans-15
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.2\. Go调度器如何管理goroutines
- en: '![](06fig02_alt.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![06fig02_alt.jpg](06fig02_alt.jpg)'
- en: Sometimes a running goroutine may need to perform a blocking syscall, such as
    opening a file. When this happens, the thread and goroutine are detached from
    the logical processor and the thread continues to block waiting for the syscall
    to return. In the meantime, there’s a logical processor without a thread. So the
    scheduler creates a new thread and attaches it to the logical processor. Then
    the scheduler will choose another goroutine from the local run queue for execution.
    Once the syscall returns, the goroutine is placed back into a local run queue,
    and the thread is put aside for future use.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有时正在运行的goroutine可能需要执行阻塞系统调用，例如打开文件。当这种情况发生时，线程和goroutine会从逻辑处理器上分离，线程继续阻塞等待系统调用返回。与此同时，存在一个没有线程的逻辑处理器。因此，调度器创建一个新的线程并将其附加到逻辑处理器上。然后调度器将选择本地运行队列中的另一个goroutine进行执行。一旦系统调用返回，goroutine将被放回本地运行队列，线程将被放在一边以备将来使用。
- en: If a goroutine needs to make a network I/O call, the process is a bit different.
    In this case, the goroutine is detached from the logical processor and moved to
    the runtime integrated network poller. Once the poller indicates a read or write
    operation is ready, the goroutine is assigned back to a logical processor to handle
    the operation. There’s no restriction built into the scheduler for the number
    of logical processors that can be created. But the runtime limits each program
    to a maximum of 10,000 threads by default. This value can be changed by calling
    the `SetMaxThreads` function from the `runtime/debug` package. If any program
    attempts to use more threads, the program crashes.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果goroutine需要执行网络I/O调用，过程略有不同。在这种情况下，goroutine将从逻辑处理器分离出来，并移动到运行时集成的网络轮询器。一旦轮询器指示读取或写入操作已准备好，goroutine将被分配回逻辑处理器以处理操作。调度器中并没有内置对可以创建的逻辑处理器数量的限制。但是，运行时默认将每个程序限制在最多10,000个线程。这个值可以通过从`runtime/debug`包调用`SetMaxThreads`函数来更改。如果任何程序尝试使用更多线程，程序将崩溃。
- en: Concurrency is not parallelism. Parallelism can only be achieved when multiple
    pieces of code are executing simultaneously against different physical processors.
    Parallelism is about doing a lot of things at once. Concurrency is about managing
    a lot of things at once. In many cases, concurrency can outperform parallelism,
    because the strain on the operating system and hardware is much less, which allows
    the system to do more. This less-is-more philosophy is a mantra of the language.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 并发不是并行。只有在多个代码块同时针对不同的物理处理器执行时才能实现并行。并行是关于同时做很多事情。并发是关于同时管理很多事情。在许多情况下，并发可以超越并行，因为对操作系统和硬件的压力要小得多，这使得系统可以做更多的事情。这种少即是多的哲学是语言的座右铭。
- en: If you want to run goroutines in parallel, you must use more than one logical
    processor. When there are multiple logical processors, the scheduler will evenly
    distribute goroutines between the logical processors. This will result in goroutines
    running on different threads. But to have true parallelism, you still need to
    run your program on a machine with multiple physical processors. If not, then
    the goroutines will be running concurrently against a single physical processor,
    even though the Go runtime is using multiple threads.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要并行运行goroutines，你必须使用多个逻辑处理器。当有多个逻辑处理器时，调度器将在逻辑处理器之间平均分配goroutines。这将导致goroutines在不同的线程上运行。但要实现真正的并行，你仍然需要在具有多个物理处理器的机器上运行你的程序。如果不是这样，那么goroutines将并行运行在单个物理处理器上，尽管Go运行时正在使用多个线程。
- en: '[Figure 6.3](#ch06fig03) shows the difference between running goroutines concurrently
    against a single logical processor and concurrently in parallel against two logical
    processors. It’s not recommended to blindly change the runtime default for a logical
    processor. The scheduler contains intelligent algorithms that are updated and
    improved with every release of Go. If you’re seeing performance issues that you
    believe could be resolved by changing the number of logical processors, you have
    the ability to do so. You’ll learn more about this soon.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6.3](#ch06fig03) 展示了在单个逻辑处理器上并发运行goroutines与在两个逻辑处理器上并行运行的差异。不建议盲目更改逻辑处理器的运行时默认值。调度器包含智能算法，这些算法会随着Go的每个版本更新和改进。如果你看到性能问题，你认为可以通过更改逻辑处理器的数量来解决，你有能力这样做。你很快就会了解更多关于这方面的信息。'
- en: Figure 6.3\. Difference between concurrency and parallelism
  id: totrans-22
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.3\. 并发与并行之间的差异
- en: '![](06fig03_alt.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig03_alt.jpg)'
- en: 6.2\. Goroutines
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2\. Goroutines
- en: Let’s uncover more about the behavior of the scheduler and how to create goroutines
    and manage their lifespan. We’ll start with samples that run using a single logical
    processor before discussing how to run goroutines in parallel. Here’s a program
    that creates two goroutines that display the English alphabet with lower and uppercase
    letters in a concurrent fashion.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解调度器的行为以及如何创建goroutines并管理它们的生命周期。我们将从使用单个逻辑处理器运行的示例开始，然后再讨论如何并行运行goroutines。以下是一个创建两个goroutines的程序，这两个goroutines以并发方式显示英文字母的大小写。
- en: Listing 6.1\. listing01.go
  id: totrans-26
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.1\. listing01.go
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In [listing 6.1](#ch06ex01) on line 14, you see a call to the `GOMAXPROCS` function
    from the `runtime` package. This is the function that allows the program to change
    the number of logical processors to be used by the scheduler. There’s also an
    environmental variable that can be set with the same name if we don’t want to
    make this call specifically in our code. By passing the value of `1`, we tell
    the scheduler to use a single logical processor for this program.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 6.1](#ch06ex01) 的第 14 行，你可以看到对 `runtime` 包中的 `GOMAXPROCS` 函数的调用。这是允许程序更改调度器使用的逻辑处理器数量的函数。还有一个可以设置相同名称的环境变量，如果我们不想在代码中特别调用这个函数。通过传递值
    `1`，我们告诉调度器为这个程序使用单个逻辑处理器。
- en: On lines 24 and 37, we declare two anonymous functions that display the English
    alphabet. The function on line 24 displays the alphabet with lowercase letters
    and the function on line 37 displays the alphabet with uppercase letters. Both
    of these functions are created as goroutines by using the keyword `go`. You can
    see by the output in [listing 6.2](#ch06ex02) that the code inside each goroutine
    is running concurrently within a single logical processor.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 24 行和 37 行，我们声明了两个显示英语字母的匿名函数。第 24 行的函数显示小写字母的字母表，而第 37 行的函数显示大写字母的字母表。这两个函数都是通过使用关键字
    `go` 创建为 goroutines 的。你可以通过 [列表 6.2](#ch06ex02) 中的输出看到，每个 goroutine 中的代码都在单个逻辑处理器内并发运行。
- en: Listing 6.2\. Output for listing01.go
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.2\. 列表 01.go 的输出
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The amount of time it takes the first goroutine to finish displaying the alphabet
    is so small that it can complete its work before the scheduler swaps it out for
    the second goroutine. This is why you see the entire alphabet in capital letters
    first and then in lowercase letters second. The two goroutines we created ran
    concurrently, one after the other, performing their individual task of displaying
    the alphabet.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 goroutine 完成显示字母表所需的时间非常短，以至于它可以在调度器将其与第二个 goroutine 交换之前完成其工作。这就是为什么你首先看到大写字母的整个字母表，然后是小写字母的字母表。我们创建的两个
    goroutines 是并发运行的，一个接一个，执行它们各自的显示字母表的任务。
- en: Once the two anonymous functions are created as goroutines, the code in `main`
    keeps running. This means that the `main` function can return before the goroutines
    complete their work. If this happens, the program will terminate before the goroutines
    have a chance to run. On line 51, the `main` function therefore waits for both
    goroutines to complete their work by using a `WaitGroup`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了两个匿名函数作为 goroutines，`main` 中的代码将继续运行。这意味着 `main` 函数可以在 goroutines 完成其工作之前返回。如果发生这种情况，程序将在
    goroutines 有机会运行之前终止。因此，在第 51 行，`main` 函数使用 `WaitGroup` 等待两个 goroutines 完成其工作。
- en: 'Listing 6.3\. listing01.go: lines 17–19, 23–26, 49–51'
  id: totrans-34
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 6.3\. listing01.go: 行 17–19，23–26，49–51'
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A `WaitGroup` is a counting semaphore that can be used to maintain a record
    of running goroutines. When the value of a `WaitGroup` is greater than zero, the
    `Wait` method will block. On line 18 a variable of type `WaitGroup` is created,
    and then on line 19 we set the value of the `WaitGroup` to `2`, noting two running
    goroutines. To decrement the value of the `WaitGroup` and eventually release the
    `main` function, calls to the `Done` method on lines 26 and 39 are made within
    the scope of a `defer` statement.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`WaitGroup` 是一个计数信号量，可以用来记录正在运行的 goroutines。当 `WaitGroup` 的值大于零时，`Wait` 方法将会阻塞。在第
    18 行创建了一个 `WaitGroup` 类型的变量，然后在第 19 行我们将 `WaitGroup` 的值设置为 `2`，表示有两个正在运行的 goroutines。为了减少
    `WaitGroup` 的值并最终释放 `main` 函数，我们在第 26 行和 39 行的 `defer` 语句范围内调用了 `Done` 方法。'
- en: The keyword `defer` is used to schedule other functions from inside the executing
    function to be called when the function returns. In the case of our sample program,
    we use the keyword `defer` to guarantee that the method call to `Done` is made
    once each goroutine is finished with its work.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字 `defer` 用于在执行函数内部调度其他函数，以便在函数返回时调用。在我们的示例程序中，我们使用关键字 `defer` 来保证每个 goroutine
    完成其工作后都调用一次 `Done` 方法。
- en: Based on the internal algorithms of the scheduler, a running goroutine can be
    stopped and rescheduled to run again before it finishes its work. The scheduler
    does this to prevent any single goroutine from holding the logical processor hostage.
    It will stop the currently running goroutine and give another runnable goroutine
    a chance to run.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 根据调度器的内部算法，一个正在运行的 goroutine 可以在完成工作之前被停止并重新调度以再次运行。调度器这样做是为了防止任何单个 goroutine
    限制逻辑处理器。它将停止当前正在运行的 goroutine，并给另一个可运行的 goroutine 一个运行的机会。
- en: '[Figure 6.4](#ch06fig04) shows this scenario from a logical processor point
    of view. In step 1 the scheduler begins to execute goroutine A while goroutine
    B waits for its turn in the run queue. Then, suddenly in step 2, the scheduler
    swaps out goroutine A for goroutine B. Since goroutine A doesn’t finish, it’s
    placed back into the run queue. Then, in step 3 goroutine B completes its work
    and it’s gone. This allows goroutine A to get back to work.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6.4](#ch06fig04) 从逻辑处理器的角度展示了这一场景。在第1步中，调度器开始执行goroutine A，而goroutine B则在运行队列中等待轮到它。然后，在第2步中，调度器突然将goroutine
    A与goroutine B交换。由于goroutine A没有完成，它被放回运行队列。接着，在第3步中，goroutine B完成其工作并消失。这允许goroutine
    A重新开始工作。'
- en: Figure 6.4\. Goroutines being swapped on and off the logical processor’s thread
  id: totrans-40
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.4\. 逻辑处理器线程上的goroutines交换
- en: '![](06fig04_alt.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig04_alt.jpg)'
- en: You can see this behavior by creating a goroutine that requires a longer amount
    of time to complete its work.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过创建一个需要较长时间来完成其工作的goroutine来看到这种行为。
- en: Listing 6.4\. listing04.go
  id: totrans-43
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.4\. listing04.go
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The program in [listing 6.4](#ch06ex04) creates two goroutines that print any
    prime numbers between 1 and 5,000 that can be found. Finding and displaying the
    prime numbers take a bit of time and will cause the scheduler to time-slice the
    first running goroutine before it finishes finding all the prime numbers it’s
    looking for.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表6.4](#ch06ex04)中的程序创建了两个goroutine，它们打印出1到5,000之间可以找到的所有质数。找到并显示质数需要一些时间，这会导致调度器在找到所有要查找的质数之前对第一个正在运行的goroutine进行时间切片。'
- en: When the program starts, it declares a `WaitGroup` variable on line 12 and then
    sets the value of the `WaitGroup` to 2 on line 20\. Two goroutines are created
    on lines 24 and 25 by specifying the name of the function `printPrime` after the
    keyword `go`. The first goroutine is given the prefix A and the second goroutine
    is given the prefix B. Like any calling function, parameters can be passed into
    the function being created as a goroutine. Return parameters aren’t available
    when the goroutine terminates. When you look at the output in [listing 6.5](#ch06ex05),
    you can see the swapping of the first goroutine by the scheduler.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序启动时，它在第12行声明了一个`WaitGroup`变量，然后在第20行将`WaitGroup`的值设置为2。在第24和第25行创建了两个goroutine，通过在`go`关键字后指定函数`printPrime`的名称。第一个goroutine被赋予前缀A，第二个goroutine被赋予前缀B。像任何调用函数一样，可以将参数传递给创建为goroutine的函数。当goroutine终止时，没有返回参数。当你查看[列表6.5](#ch06ex05)中的输出时，你可以看到调度器对第一个goroutine的交换。
- en: Listing 6.5\. Output for listing04.go
  id: totrans-47
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.5\. listing04.go的输出
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Goroutine B begins to display prime numbers first. Once goroutine B prints prime
    number 4591, the scheduler swaps out the goroutine for goroutine A. Goroutine
    A is then given some time on the thread and swapped out for the B goroutine once
    again. The B goroutine is allowed to finish all its work. Once goroutine B returns,
    you see that goroutine A is given back the thread to finish its work. Every time
    you run this program, the scheduler will slightly change the point where the time
    slice occurs.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Goroutine B开始首先显示质数。一旦goroutine B打印出质数4591，调度器将交换goroutine，将goroutine A放入线程中，并再次将线程交换给goroutine
    B。允许goroutine B完成所有工作。一旦goroutine B返回，你会看到goroutine A再次获得线程以完成其工作。每次运行此程序时，调度器都会稍微改变时间切片发生的位置。
- en: Both example programs in [listings 6.1](#ch06ex01) and [6.4](#ch06ex04) have
    shown how the scheduler runs goroutines concurrently within a single logical processor.
    As stated earlier, the Go standard library has a function called `GOMAXPROCS`
    in the `runtime` package that allows you to specify the number of logical processors
    to be used by the scheduler. This is how you can change the runtime to allocate
    a logical processor for every available physical processor. The next listing will
    have our goroutines running in parallel.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表6.1](#ch06ex01)和[6.4](#ch06ex04)中的两个示例程序都展示了调度器如何在单个逻辑处理器内并发运行goroutines。如前所述，Go标准库在`runtime`包中有一个名为`GOMAXPROCS`的函数，允许你指定调度器使用的逻辑处理器数量。这就是如何将运行时更改为为每个可用的物理处理器分配一个逻辑处理器。下一个列表将展示我们的goroutines并行运行。'
- en: Listing 6.6\. How to change the number of logical processors
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.6\. 如何更改逻辑处理器的数量
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `runtime` package provides support for changing Go runtime configuration
    parameters. In [listing 6.6](#ch06ex06), we use two `runtime` functions to change
    the number of logical processors for the scheduler to use. The `NumCPU` function
    returns the number of physical processors that are available; therefore, the function
    call to `GOMAXPROCS` creates a logical processor for each available physical processor.
    It’s important to note that using more than one logical processor doesn’t necessarily
    mean better performance. Benchmarking is required to understand how your program
    performs when changing any `runtime` configuration parameters.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`runtime` 包提供了更改 Go 运行时配置参数的支持。在 [代码清单 6.6](#ch06ex06) 中，我们使用两个 `runtime` 函数来更改调度器使用的逻辑处理器数量。`NumCPU`
    函数返回可用的物理处理器数量；因此，对 `GOMAXPROCS` 的函数调用为每个可用的物理处理器创建一个逻辑处理器。需要注意的是，使用多个逻辑处理器并不一定意味着更好的性能。需要进行基准测试才能了解在更改任何
    `runtime` 配置参数时程序的性能。'
- en: If we give the scheduler more than one logical processor to use, we’ll see different
    behavior in the output of our example programs. Let’s change the number of logical
    processors to 2 and rerun the first example that printed the English alphabet.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们给调度器提供多个逻辑处理器来使用，我们将在示例程序的输出中看到不同的行为。让我们将逻辑处理器的数量更改为 2 并重新运行第一个打印英语字母的示例。
- en: Listing 6.7\. listing07.go
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 代码清单 6.7\. listing07.go
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The example in [listing 6.7](#ch06ex07) creates two logical processors with
    the call to the `GOMAXPROCS` function on line 14\. This will allow the goroutines
    to be run in parallel.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[代码清单 6.7](#ch06ex07) 中的示例通过在 14 行调用 `GOMAXPROCS` 函数创建了两个逻辑处理器。这将允许 goroutines
    并行运行。'
- en: Listing 6.8\. Output for listing07.go
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 代码清单 6.8\. listing07.go 的输出
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you look closely at the output in [listing 6.8](#ch06ex08), you’ll see that
    the goroutines are running in parallel. Almost immediately, both goroutines start
    running, and the letters in the display are mixed. The output is based on running
    the program on an eight-core machine, so each goroutine is running on its own
    core. Remember that goroutines can only run in parallel if there’s more than one
    logical processor and there’s a physical processor available to run each goroutine
    simultaneously.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察 [代码清单 6.8](#ch06ex08) 的输出，你会看到 goroutines 正在并行运行。几乎立即，两个 goroutines
    都开始运行，显示器的字母混合在一起。输出是基于在八核机器上运行程序的结果，因此每个 goroutine 都在自己的核心上运行。记住，goroutines 只有在存在多个逻辑处理器并且有物理处理器可以同时运行每个
    goroutine 时才能并行运行。
- en: You now know how to create goroutines and understand what’s happening under
    the hood. Next you need to understand the potential dangers and the things to
    look out for when writing concurrent programs.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在知道了如何创建 goroutines 并理解底层发生了什么。接下来，你需要了解在编写并发程序时可能存在的危险和需要注意的事项。
- en: 6.3\. Race conditions
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3\. 竞态条件
- en: When two or more goroutines have unsynchronized access to a shared resource
    and attempt to read and write to that resource at the same time, you have what’s
    called a *race condition*. Race conditions are the reason concurrent programming
    is complicated and has a greater potential for bugs. Read and write operations
    against a shared resource must always be atomic, or in other words, done by only
    one goroutine at a time.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个或更多 goroutines 对共享资源进行非同步访问并尝试同时读取和写入该资源时，你就有了一个所谓的 *竞态条件*。竞态条件是并发编程复杂且具有更大潜在错误可能性的原因。对共享资源的读取和写入操作必须是原子的，换句话说，一次只能由一个
    goroutine 完成。
- en: Here’s an example program that contains a race condition.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个包含竞态条件的示例程序。
- en: Listing 6.9\. listing09.go
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 代码清单 6.9\. listing09.go
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Listing 6.10\. Output for listing09.go
  id: totrans-67
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 代码清单 6.10\. listing09.go 的输出
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `counter` variable is read and written to four times, twice by each goroutine,
    but the value of the `counter` variable when the program terminates is `2`. [Figure
    6.5](#ch06fig05) provides a clue as to why this is happening.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`counter` 变量被读取和写入四次，每个 goroutine 两次，但程序结束时 `counter` 变量的值是 `2`。[图 6.5](#ch06fig05)
    提供了为什么会出现这种情况的线索。'
- en: Figure 6.5\. Visual of the race condition in action
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.5\. 竞态条件作用的可视化
- en: '![](06fig05.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig05.jpg)'
- en: Each goroutine overwrites the work of the other. This happens when the goroutine
    swap is taking place. Each goroutine makes its own copy of the `counter` variable
    and then is swapped out for the other goroutine. When the goroutine is given time
    to execute again, the value of the `counter` variable has changed, but the goroutine
    doesn’t update its copy. Instead it continues to increment the copy it has and
    set the value back to the `counter` variable, replacing the work the other goroutine
    performed.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 每个goroutine都会覆盖其他goroutine的工作。这发生在goroutine交换过程中。每个goroutine都会创建`counter`变量的副本，然后被交换出去以供其他goroutine使用。当goroutine再次被赋予执行时间时，`counter`变量的值已经改变，但goroutine没有更新其副本。相反，它继续增加其副本，并将值重新设置为`counter`变量，从而替换了其他goroutine执行的工作。
- en: Let’s walk through the code to understand what it’s doing. Two goroutines are
    created from the function `incCounter`, which can be seen on lines 25 and 26\.
    The `incCounter` function on line 34 reads and writes to the package variable
    `counter`, which is our shared resource in this example. Both goroutines start
    reading and storing a copy of the `counter` variable into a local variable called
    `value` on line 40\. Then, on line 46 they increment their copy of `value` by
    one and finally assign the new value back into the `counter` variable on line
    49\. The function contains a call to the `Gosched` function from the `runtime`
    package on line 43 to yield the thread and give the other goroutine a chance to
    run. This is being done in the middle of the operation to force the scheduler
    to swap between the two goroutines to exaggerate the effects of the race condition.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步分析代码，以了解它在做什么。从第25行和第26行可以看到，从`incCounter`函数创建了两个goroutine。第34行的`incCounter`函数读取并写入包变量`counter`，这是我们在这个示例中的共享资源。两个goroutine从第40行开始读取并将`counter`变量的副本存储到名为`value`的局部变量中。然后，在第46行，它们将`value`的副本增加1，并在第49行将新值赋回`counter`变量。该函数在第43行包含对`runtime`包中的`Gosched`函数的调用，以释放线程并给其他goroutine运行的机会。这是在操作过程中执行的，以强制调度器在两个goroutine之间进行交换，以夸大竞争条件的影响。
- en: Go has a special tool that can detect race conditions in your code. It’s extremely
    useful to find these types of bugs, especially when they’re not as obvious as
    our example. Let’s run the race detector against our example code.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Go有一个特殊的工具可以检测代码中的竞争条件。这对于发现这些类型的错误非常有用，尤其是当它们不像我们的示例那样明显时。让我们运行竞争检测器来检测我们的示例代码。
- en: Listing 6.11\. Building and running listing09 with the race detector
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.11\. 使用竞争检测器构建和运行listing09
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The race detector in [listing 6.11](#ch06ex11) has pointed out the following
    four lines of code from our example.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表6.11](#ch06ex11)中的竞争检测器已经指出我们示例中的以下四行代码。'
- en: Listing 6.12\. Lines of code called out by the race detector
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.12\. 被竞争检测器标记的代码行
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[Listing 6.12](#ch06ex12) shows that the race detector has told us which goroutine
    is causing the data race and which two lines of code are in conflict. It’s not
    surprising that the code that’s pointed out is reading from and writing to the
    `counter` variable.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表6.12](#ch06ex12)显示，竞争检测器告诉我们哪个goroutine导致了数据竞争，以及哪两行代码存在冲突。指出的是从`counter`变量读取和写入的代码并不令人惊讶。'
- en: One way we can fix our example and eliminate the race condition is by using
    the support Go has for synchronizing goroutines by locking down shared resources.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用Go对同步goroutines的支持，通过锁定共享资源来修复我们的示例并消除竞争条件。
- en: 6.4\. Locking shared resources
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4\. 锁定共享资源
- en: Go provides traditional support to synchronize goroutines by locking access
    to shared resources. If you need to serialize access to an integer variable or
    a block of code, then the functions in the `atomic` and `sync` packages may be
    a good solution. We’ll look at a few of the `atomic` package functions and the
    `mutex` type from the `sync` package.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Go通过锁定对共享资源的访问来提供传统的goroutine同步支持。如果你需要序列化对整数变量或代码块的访问，那么`atomic`和`sync`包中的函数可能是一个好的解决方案。我们将查看`atomic`包的一些函数和`sync`包中的`mutex`类型。
- en: 6.4.1\. Atomic functions
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.4.1\. 原子函数
- en: Atomic functions provide low-level locking mechanisms for synchronizing access
    to integers and pointers. We can use atomic functions to fix the race condition
    we created in [listing 6.9](#ch06ex09).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 原子函数提供了对整数和指针访问的低级锁定机制，用于同步。我们可以使用原子函数来修复我们在[列表6.9](#ch06ex09)中创建的竞争条件。
- en: Listing 6.13\. listing13.go
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.13\. listing13.go
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Listing 6.14\. Output for listing13.go
  id: totrans-88
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.14\. listing13.go的输出
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: On line 43 the program is now using the `AddInt64` function from the `atomic`
    package. This function synchronizes the adding of integer values by enforcing
    that only one goroutine can perform and complete this add operation at a time.
    When goroutines attempt to call any atomic function, they’re automatically synchronized
    against the variable that’s referenced. Now we get the correct value of `4`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在第43行，程序现在使用`atomic`包中的`AddInt64`函数。此函数通过强制一次只有一个goroutine可以执行并完成此加法操作来同步整数值的添加。当goroutine尝试调用任何原子函数时，它们会自动与引用的变量同步。现在我们得到正确的值`4`。
- en: Two other useful `atomic` functions are `LoadInt64` and `StoreInt64`. These
    functions provide a safe way to read and write to an integer value. Here’s an
    example using `LoadInt64` and `StoreInt64` to create a synchronous flag that can
    alert multiple goroutines of a special condition in a program.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个有用的`原子`函数是`LoadInt64`和`StoreInt64`。这些函数提供了一种安全的方式来读取和写入整数值。以下是一个使用`LoadInt64`和`StoreInt64`创建同步标志的示例，该标志可以通知多个goroutine程序中的特殊条件。
- en: Listing 6.15\. listing15.go
  id: totrans-92
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.15. listing15.go
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this example two goroutines are launched and begin to perform some work.
    After every iteration of their respective loop, the goroutines check the value
    of the `shutdown` variable by using the `LoadInt64` function on line 52\. This
    function returns a safe copy of the `shutdown` variable. If the value equals `1`,
    the goroutine breaks out of the loop and terminates.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，启动了两个goroutine并开始执行一些工作。在它们各自的循环的每次迭代之后，goroutine通过在第52行使用`LoadInt64`函数来检查`shutdown`变量的值。此函数返回`shutdown`变量的安全副本。如果值等于`1`，则goroutine会退出循环并终止。
- en: The `main` function uses the `StoreInt64` function on line 35 to safely change
    the value of the `shutdown` variable. If any of the `doWork` goroutines attempt
    to call the `LoadInt64` function at the same time as the `main` function calls
    `StoreInt64`, the atomic functions will synchronize the calls and keep all the
    operations safe and race condition–free.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数在第35行使用`StoreInt64`函数安全地更改`shutdown`变量的值。如果任何`doWork` goroutine试图在`main`函数调用`StoreInt64`的同时调用`LoadInt64`函数，原子函数将同步调用并保持所有操作安全且无竞争条件。'
- en: 6.4.2\. Mutexes
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.4.2. 互斥锁
- en: Another way to synchronize access to a shared resource is by using a `mutex`.
    A mutex is named after the concept of mutual exclusion. A mutex is used to create
    a critical section around code that ensures only one goroutine at a time can execute
    that code section. We can also use a mutex to fix the race condition we created
    in [listing 6.9](#ch06ex09).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种同步访问共享资源的方法是使用`互斥锁`。互斥锁是以互斥排他概念命名的。互斥锁用于在代码周围创建临界区，确保一次只有一个goroutine可以执行该代码段。我们还可以使用互斥锁来解决我们在[列表
    6.9](#ch06ex09)中创建的竞争条件。
- en: Listing 6.16\. listing16.go
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.16. listing16.go
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The operations against the `counter` variable are now protected within a critical
    section defined by the calls to `Lock()` and `Unlock()` on lines 46 and 60\. The
    use of the curly brackets is just to make the critical section easier to see;
    they’re not necessary. Only one goroutine can enter the critical section at a
    time. Not until the call to the `Unlock()` function is made can another goroutine
    enter the critical section. When the thread is yielded on line 52, the scheduler
    assigns the same goroutine to continue running. After the program completes, we
    get the correct value of `4` and the race condition no longer exists.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在对`counter`变量的操作被包含在由第46行和第60行的`Lock()`和`Unlock()`调用定义的临界区中。使用花括号只是为了使临界区更容易看到；它们不是必需的。一次只能有一个goroutine进入临界区。只有在调用`Unlock()`函数之后，另一个goroutine才能进入临界区。当线程在第52行释放时，调度器将分配相同的goroutine继续运行。程序完成后，我们得到正确的值`4`，竞争条件不再存在。
- en: 6.5\. Channels
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5. 通道
- en: Atomic functions and mutexes work, but they don’t make writing concurrent programs
    easier, less error-prone, or fun. In Go you don’t have only atomic functions and
    mutexes to keep shared resources safe and eliminate race conditions. You also
    have `channels` that synchronize goroutines as they send and receive the resources
    they need to share between each other.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 原子函数和互斥锁可以工作，但它们并不使编写并发程序变得更容易、更不容易出错或更有趣。在Go中，你不仅只有原子函数和互斥锁来保持共享资源的安全并消除竞争条件。你还有`通道`，它通过同步goroutine在它们发送和接收彼此之间需要共享的资源时来同步goroutine。
- en: When a resource needs to be shared between goroutines, channels act as a conduit
    between the goroutines and provide a mechanism that guarantees a synchronous exchange.
    When declaring a channel, the type of data that will be shared needs to be specified.
    Values and pointers of built-in, named, struct, and reference types can be shared
    through a channel.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要在 goroutine 之间共享资源时，通道作为 goroutine 之间的导管，并提供了一种保证同步交换的机制。在声明通道时，需要指定将要共享的数据类型。内置类型、命名类型、结构体和引用类型的值和指针可以通过通道共享。
- en: Creating a channel in Go requires the use of the built-in function `make`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中创建一个通道需要使用内置函数 `make`。
- en: Listing 6.17\. Using `make` to create a channel
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.17\. 使用 `make` 创建一个通道
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In [listing 6.17](#ch06ex17) you see the use of the built-in function `make`
    to create both an unbuffered and buffered channel. The first argument to `make`
    requires the keyword `chan` and then the type of data the channel will allow to
    be exchanged. If you’re creating a buffered channel, then you specify the size
    of the channel’s buffer as the second argument.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 6.17](#ch06ex17) 中，您可以看到使用内置函数 `make` 创建无缓冲和缓冲通道的用法。`make` 的第一个参数需要关键字
    `chan`，然后是通道允许交换的数据类型。如果您正在创建一个缓冲通道，那么您需要指定通道缓冲区的大小作为第二个参数。
- en: Sending a value or pointer into a channel requires the use of the `<-` operator.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个值或指针发送到通道中需要使用 `<-` 操作符。
- en: Listing 6.18\. Sending values into a channel
  id: totrans-109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.18\. 向通道发送值
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In [listing 6.18](#ch06ex18) we create a buffered channel of type `string` that
    contains a buffer of 10 values. Then we send the `string` “Gopher” through the
    channel. For another goroutine to receive that string from the channel, we use
    the same `<-` operator, but this time as a unary operator.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 6.18](#ch06ex18) 中，我们创建了一个包含 10 个值缓冲区的 `string` 类型的缓冲通道。然后我们通过通道发送了 `string`
    “Gopher”。为了使另一个 goroutine 能够从通道接收该字符串，我们使用相同的 `<-` 操作符，但这次作为一元操作符。
- en: Listing 6.19\. Receiving values from a channel
  id: totrans-112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.19\. 从通道接收值
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When receiving a value or pointer from a channel, the `<-` operator is attached
    to the left side of the channel variable, as seen in [listing 6.19](#ch06ex19).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当从通道接收一个值或指针时，`<-` 操作符连接到通道变量的左侧，如 [列表 6.19](#ch06ex19) 所示。
- en: Unbuffered and buffered channels behave a bit differently. Understanding the
    differences will help you determine when to prefer one over the other, so let’s
    look at each type separately.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 无缓冲通道和缓冲通道的行为略有不同。理解这些差异将帮助您确定何时更倾向于使用其中一种，因此让我们分别查看每种类型。
- en: 6.5.1\. Unbuffered channels
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.5.1\. 无缓冲通道
- en: An *unbuffered channel* is a channel with no capacity to hold any value before
    it’s received. These types of channels require both a sending and receiving goroutine
    to be ready at the same instant before any send or receive operation can complete.
    If the two goroutines aren’t ready at the same instant, the channel makes the
    goroutine that performs its respective send or receive operation first wait. Synchronization
    is inherent in the interaction between the send and receive on the channel. One
    can’t happen without the other.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *无缓冲通道* 是一个在接收之前没有能力存储任何值的通道。这类通道要求发送和接收的 goroutine 在任何发送或接收操作完成之前同时准备好。如果两个
    goroutine 没有同时准备好，通道将使执行相应发送或接收操作的 goroutine 首先等待。同步是通道发送和接收交互中的固有特性。一个操作不能在没有另一个操作的情况下发生。
- en: In [figure 6.6](#ch06fig06), you see an example of two goroutines sharing a
    value using an unbuffered channel. In step 1 the two goroutines approach the channel,
    but neither have issued a send or receive yet. In step 2 the goroutine on the
    left sticks its hand into the channel, which simulates a send on the channel.
    At this point, that goroutine is locked in the channel until the exchange is complete.
    In step 3 the goroutine on the right places its hand into the channel, which simulates
    a receive on the channel. That goroutine is now locked in the channel until the
    exchange is complete. In steps 4 and 5 the exchange is made and finally, in step
    6, both goroutines are free to remove their hands, which simulates the release
    of the locks. They both can now go on their merry way.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 6.6](#ch06fig06) 中，你可以看到一个示例，其中两个 goroutine 使用无缓冲通道共享一个值。在第 1 步中，两个 goroutine
    接近通道，但还没有发出发送或接收操作。在第 2 步中，左侧的 goroutine 将手伸入通道，这模拟了在通道上的发送操作。此时，该 goroutine 被锁定在通道中，直到交换完成。在第
    3 步中，右侧的 goroutine 将手伸入通道，这模拟了在通道上的接收操作。现在，该 goroutine 被锁定在通道中，直到交换完成。在第 4 和第
    5 步中完成了交换，最后在第 6 步中，两个 goroutine 都可以自由地移开手，这模拟了锁的释放。他们现在都可以继续他们的愉快旅程。
- en: Figure 6.6\. Synchronization between goroutines using an unbuffered channel
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.6\. 使用无缓冲通道的 goroutine 同步
- en: '![](06fig06_alt.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig06_alt.jpg)'
- en: To make this more clear, let’s look at two complete examples that use an unbuffered
    channel to synchronize the exchange of data between two goroutines.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清楚地说明，让我们看看两个使用无缓冲通道同步两个 goroutine 之间数据交换的完整示例。
- en: 'In the game of tennis, two players hit a ball back and forth to each other.
    The players are always in one of two states: either waiting to receive the ball,
    or sending the ball back to the opposing player. You can simulate a game of tennis
    using two goroutines and an unbuffered channel to simulate the exchange of the
    ball.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在网球游戏中，两名球员互相击球。球员总是处于两种状态之一：要么等待接收球，要么将球发送回对方球员。你可以使用两个 goroutine 和一个无缓冲通道来模拟球的交换，以模拟网球游戏。
- en: Listing 6.20\. listing20.go
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.20\. listing20.go
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When you run the program, you get the following output.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行程序时，你会得到以下输出。
- en: Listing 6.21\. Output for listing20.go
  id: totrans-126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.21\. listing20.go 的输出
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the `main` function on line 22, an unbuffered channel of type `int` is created
    to synchronize the exchange of the ball being hit by both goroutines. Then the
    two goroutines that will be playing the game are created on lines 28 and 29\.
    At this point both goroutines are locked waiting to receive the ball. On line
    32 a ball is sent into the channel, and the game is played until one of the goroutines
    lose.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 22 行的 `main` 函数中，创建了一个类型为 `int` 的无缓冲通道来同步两个 goroutine 打击的球之间的交换。然后在第 28 和
    29 行创建了将玩游戏的两个 goroutine。此时，两个 goroutine 都被锁定，等待接收球。在第 32 行将一个球发送到通道中，游戏一直进行，直到其中一个
    goroutine 失败。
- en: Inside the `player` function, you find an endless `for` loop on line 43\. Within
    the loop, the game is played. On line 45 the goroutine performs a receive on the
    channel, waiting to receive the ball. This locks the goroutine until a send is
    performed on the channel. Once the receive on the channel returns, the `ok` flag
    is checked on line 46 for `false`. A value of `false` indicates the channel was
    closed and the game is over. On lines 53 through 60 a random number is generated
    to determine if the goroutine hits or misses the ball. If the ball is hit, then
    on line 64 the value of the ball is incremented by one and the ball is sent back
    to the other player on line 67\. At this point both goroutines are locked until
    the exchange is made. Eventually a goroutine misses the ball and the channel is
    closed on line 58\. Then both goroutines return, the call to `Done` via the `defer`
    statement is performed, and the program terminates.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `player` 函数内部，你会在第 43 行找到一个无限循环的 `for`。在循环内部，进行游戏。在第 45 行，goroutine 在通道上执行接收操作，等待接收球。这会锁定
    goroutine，直到通道上执行发送操作。一旦通道上的接收操作返回，第 46 行会检查 `ok` 标志是否为 `false`。`false` 的值表示通道已关闭，游戏结束。在第
    53 到 60 行生成一个随机数，以确定 goroutine 是否击中或错过球。如果击中球，则在第 64 行将球的价值增加一，并在第 67 行将球发送回另一个玩家。此时，两个
    goroutine 都被锁定，直到交换完成。最终，一个 goroutine 错过球，在第 58 行关闭通道。然后两个 goroutine 返回，通过 `defer`
    语句调用 `Done`，程序终止。
- en: Another example that uses a different pattern to synchronize goroutines with
    an unbuffered channel is simulating a relay race. In a relay race, four runners
    take turns running around the track. The second, third, and fourth runners can’t
    start running until they receive the baton from the previous runner. The exchange
    of the baton is a critical part of the race and requires synchronization to not
    miss a step. For this synchronization to take place, both runners who are involved
    in the exchange need to be ready at exactly the same time.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个使用不同模式通过无缓冲通道同步协程的例子是模拟接力赛。在接力赛中，四名运动员轮流在赛道上跑步。第二、第三和第四名运动员必须在接收到前一名运动员的接力棒后才能开始跑步。接力棒的传递是比赛的关键部分，需要同步以避免错过任何一步。为了实现这种同步，参与交换的两名运动员必须同时准备好。
- en: Listing 6.22\. listing22.go
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.22\. listing22.go
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When you run the program, you get the following output.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行程序时，你会得到以下输出。
- en: Listing 6.23\. Output for listing22.go
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.23\. 列表 22.go 的输出
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the `main` function on line 17, an unbuffered channel of type `int` is created
    to synchronize the exchange of the baton. On line 20 we add a count of 1 to the
    `WaitGroup` so the `main` function can wait until the last runner is finished.
    The first runner takes to the track on line 23 with the creation of a goroutine,
    and then on line 26 the baton is given to the runner and the race begins. Finally,
    on line 29 the `main` function waits on the `WaitGroup` for the last runner to
    finish.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 函数的第 17 行，创建了一个类型为 `int` 的无缓冲通道来同步接力棒的交换。在第 20 行，我们将 1 添加到 `WaitGroup`
    中，以便 `main` 函数可以等待最后一名运动员完成。第 23 行，第一名运动员通过创建协程进入赛道，然后在第 26 行将接力棒交给运动员，比赛开始。最后，在第
    29 行，`main` 函数等待 `WaitGroup` 直到最后一名运动员完成。
- en: Inside the `Runner` goroutine, you can see how the baton is exchanged from runner
    to runner. On line 37 the goroutine waits to receive the baton with the receive
    call on the channel. Once the baton is received, the next runner takes his mark
    on line 46 unless the goroutine represents the fourth runner. On line 50 the runner
    runs around the track for 100 milliseconds. On line 55 if the fourth runner just
    finished running, the `WaitGroup` is decremented by the call to `Done` and the
    goroutine returns. If this isn’t the fourth runner, then on line 64 the baton
    is passed to the next runner who is already waiting. At this point both goroutines
    are locked until the exchange is made.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Runner` 协程内部，你可以看到接力棒是如何从一名运动员传递到另一名运动员的。在第 37 行，协程通过通道上的接收调用等待接收接力棒。一旦接收到接力棒，下一名运动员在第
    46 行做好准备，除非协程代表第四名运动员。在第 50 行，运动员在赛道上跑 100 毫秒。在第 55 行，如果第四名运动员刚刚完成跑步，通过 `Done`
    调用减少 `WaitGroup` 的计数，并且协程返回。如果不是第四名运动员，那么在第 64 行，接力棒传递给已经等待的下一名运动员。此时，两个协程都锁定，直到交换完成。
- en: In both examples we used an unbuffered channel to synchronize goroutines to
    simulate a tennis game and a relay race. The flow of the code was inline with
    the way these events and activities take place in the real world. This makes the
    code readable and self-documenting. Now that you know how unbuffered channels
    work, next you can learn how buffered channels work.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个例子中，我们使用无缓冲通道来同步协程，模拟网球比赛和接力赛。代码的流程与这些事件和活动在现实世界中的发生方式一致。这使得代码易于阅读且具有自文档性。现在，既然你已经了解了无缓冲通道的工作原理，接下来你可以学习缓冲通道的工作原理。
- en: 6.5.2\. Buffered channels
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.5.2\. 缓冲通道
- en: 'A *buffered channel* is a channel with capacity to hold one or more values
    before they’re received. These types of channels don’t force goroutines to be
    ready at the same instant to perform sends and receives. There are also different
    conditions for when a send or receive does block. A receive will block only if
    there’s no value in the channel to receive. A send will block only if there’s
    no available buffer to place the value being sent. This leads to the one big difference
    between unbuffered and buffered channels: An unbuffered channel provides a guarantee
    that an exchange between two goroutines is performed at the instant the send and
    receive take place. A buffered channel has no such guarantee.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*缓冲通道* 是一种在接收之前可以持有一个或多个值的通道。这类通道不会强制协程在同一时刻准备好进行发送和接收。发送或接收阻塞的条件也有所不同。接收只有在通道中没有值可以接收时才会阻塞。发送只有在没有可用缓冲区来放置要发送的值时才会阻塞。这导致了无缓冲通道和缓冲通道之间的一大区别：无缓冲通道提供了一种保证，即两个协程之间的交换是在发送和接收发生的瞬间完成的。而缓冲通道没有这样的保证。'
- en: In [figure 6.7](#ch06fig07) you see an example of two goroutines adding and
    removing items from a buffered channel independently. In step 1 the goroutine
    on the right is in the process of receiving a value from the channel. In step
    2 that same goroutine is able to complete the receive independent of the goroutine
    on the left sending a new value into the channel. In step 3 the goroutine on the
    left is sending a new value into the channel while the goroutine on the right
    is receiving a different value. Neither of these two operations in step 3 are
    in sync with each other or blocking. Finally, in step 4 all the sends and receives
    are complete and we have a channel with several values and room for more.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 6.7](#ch06fig07) 中，你可以看到一个示例，两个 goroutine 独立地从缓冲通道中添加和移除项目。在第 1 步中，右侧的
    goroutine 正在从通道接收一个值。在第 2 步中，相同的 goroutine 能够独立于左侧的 goroutine 向通道发送新值而完成接收。在第
    3 步中，左侧的 goroutine 正在向通道发送新值，而右侧的 goroutine 正在接收不同的值。在第 3 步中的这两个操作都没有同步，也没有阻塞。最后，在第
    4 步中，所有的发送和接收都已完成，我们有一个包含多个值并有更多空间的通道。
- en: Figure 6.7\. Synchronization between goroutines using a buffered channel
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.7\. 使用缓冲通道在 goroutine 之间进行同步
- en: '![](06fig07_alt.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig07_alt.jpg)'
- en: Let’s look at an example using a buffered channel to manage a set of goroutines
    to receive and process work. Buffered channels provide a clean and intuitive way
    to implement this code.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个使用缓冲通道来管理一组 goroutine 接收和处理工作的示例。缓冲通道提供了一个干净直观的方式来实现此代码。
- en: Listing 6.24\. listing24.go
  id: totrans-145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.24\. listing24.go
- en: '[PRE23]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: When you run the program, you get the following output.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行程序时，你会得到以下输出。
- en: Listing 6.25\. Output for listing24.go
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.25\. listing24.go 的输出
- en: '[PRE24]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Because of the random nature of the program and the Go scheduler, the output
    for this program will be different every time you run it. But the use of all four
    goroutines to process work from the buffered channel won’t change. You can see
    from the output how each goroutine is receiving work distributed from the channel.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 由于程序和 Go 调度器的随机性，每次运行此程序的输出都会不同。但使用所有四个 goroutine 处理缓冲通道中的工作不会改变。你可以从输出中看到每个
    goroutine 如何接收从通道分配的工作。
- en: In the `main` function on line 31, a buffered channel of type `string` is created
    with a capacity of 10\. On line 34 the `WaitGroup` is given the count of 4, one
    for each goroutine that’s going to be created. Then on lines 35 through 37, four
    goroutines are created and passed the channel they will be receiving the work
    on. On lines 40 through 42, 10 strings are sent into the channel to simulate work
    for the goroutines. Once the last string is sent into the channel, the channel
    is closed on line 46 and the `main` function waits for all the work to be completed
    on line 49.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 31 行的 `main` 函数中，创建了一个容量为 10 的 `string` 类型的缓冲通道。在第 34 行，`WaitGroup` 被赋予计数
    4，代表将要创建的每个 goroutine。然后在第 35 到 37 行，创建了四个 goroutine，并将它们将要接收工作的通道传递给它们。在第 40
    到 42 行，向通道发送了 10 个字符串来模拟为 goroutine 的工作。一旦最后一个字符串被发送到通道，通道在第 46 行被关闭，`main` 函数在第
    49 行等待所有工作完成。
- en: Closing the channel on line 46 is an important piece of code. When a channel
    is closed, goroutines can still perform receives on the channel but can no longer
    send on the channel. Being able to receive on a closed channel is important because
    it allows the channel to be emptied of all its values with future receives, so
    nothing in the channel is ever lost. A receive on a closed and empty channel always
    returns immediately and provides the zero value for the type the channel is declared
    with. If you also request the optional flag on the channel receive, you can get
    information about the state of the channel.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 46 行关闭通道是一段重要的代码。当一个通道被关闭时，goroutine 仍然可以在通道上执行接收操作，但不能再向通道发送。能够在关闭的通道上接收是很重要的，因为它允许通道通过未来的接收清空所有值，所以通道中永远不会丢失任何东西。在关闭且为空的通道上的接收总是立即返回，并提供通道声明类型的零值。如果你还请求通道接收的可选标志，你可以获取有关通道状态的信息。
- en: Inside the `worker` function you find an endless `for` loop on line 58\. Within
    the loop, all of the received work is processed. Each goroutine blocks on line
    60 waiting to receive work from the channel. Once the receive returns, the `ok`
    flag is checked to see if the channel is both empty and closed. If the value of
    `ok` is `false`, the goroutine terminates, which causes the `defer` statement
    on line 56 to call `Done` and report back to `main`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在`worker`函数中，你会在第58行找到一个无休止的`for`循环。在循环中，所有接收到的任务都会被处理。每个goroutine在第60行阻塞，等待从通道接收任务。一旦接收返回，就会检查`ok`标志以确定通道是否既为空又已关闭。如果`ok`的值为`false`，则goroutine终止，这会导致第56行的`defer`语句调用`Done`并返回给`main`。
- en: If the `ok` flag is `true`, then the value received is valid. Lines 71 and 72
    simulate work being processed. Once the work is done, the goroutine blocks again
    in the receive of the channel on line 60\. Once the channel is closed, the receive
    on the channel returns immediately and the goroutine terminates itself.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`ok`标志为`true`，则接收到的值是有效的。第71行和第72行模拟了正在处理的工作。一旦工作完成，goroutine再次在第60行的通道接收处阻塞。一旦通道关闭，通道的接收立即返回，并且goroutine自行终止。
- en: The examples for the unbuffered and buffered channels provided a good sampling
    of the kind of code you can write with channels. In the next chapter we’ll look
    at real-world concurrency patterns that you could use in your own projects.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的无缓冲和缓冲通道的示例提供了使用通道可以编写的代码类型的好样本。在下一章中，我们将探讨您可以在自己的项目中使用的真实世界的并发模式。
- en: 6.6\. Summary
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.6. 概述
- en: Concurrency is the independent execution of goroutines.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发是goroutines的独立执行。
- en: Functions are created as goroutines with the keyword `go`.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数通过使用`go`关键字创建为goroutines。
- en: Goroutines are executed within the scope of a logical processor that owns a
    single operating system thread and run queue.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Goroutines在拥有单个操作系统线程和运行队列的逻辑处理器的作用域内执行。
- en: A race condition is when two or more goroutines attempt to access the same resource.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 竞态条件是指两个或更多goroutines尝试访问同一资源。
- en: Atomic functions and mutexes provide a way to protect against race conditions.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原子函数和互斥锁提供了一种防止竞态条件的方法。
- en: Channels provide an intrinsic way to safely share data between two goroutines.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Channels提供了一种在两个goroutines之间安全共享数据的方法。
- en: Unbuffered channels provide a guarantee between an exchange of data. Buffered
    channels do not.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无缓冲通道提供数据交换的保证，而缓冲通道则不提供。
