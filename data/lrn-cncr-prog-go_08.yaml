- en: Part 2\. Message passing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分\. 消息传递
- en: In the first part of the book, we talked about how to use memory sharing to
    enable communication between threads of execution. In this second part, we’ll
    explore message passing, which is a different way for executions to communicate.
    In message passing, threads of executions pass copies of messages to each other
    whenever they need to communicate. Since these executions are not sharing memory,
    we eliminate the risks of many types of race conditions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的第一部分，我们讨论了如何使用内存共享来启用执行线程之间的通信。在本书的第二部分，我们将探讨消息传递，这是执行之间通信的另一种方式。在消息传递中，执行线程在需要通信时相互传递消息的副本。由于这些执行没有共享内存，我们消除了许多类型竞态条件的风险。
- en: Go takes inspiration from a concurrency model called communicating sequential
    processes (CSP), which is a formal language for describing interactions of concurrent
    programs. In this model, processes connect to each other by communicating via
    synchronous message passing. In the same fashion, Go provides us with the concept
    of the channel, which enables goroutines to connect, synchronize, and share messages
    with one another.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Go 从一种称为通信顺序进程（CSP）的并发模型中汲取灵感，这是一种描述并发程序交互的正式语言。在这个模型中，进程通过同步消息传递相互连接。同样地，Go
    为我们提供了通道的概念，它使 goroutines 能够相互连接、同步和共享消息。
- en: In this part of the book, we’ll explore message passing and the various tools
    and programming patterns we can use to manage this form of communication.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的这一部分，我们将探讨消息传递以及我们可以使用的各种工具和编程模式来管理这种通信形式。
