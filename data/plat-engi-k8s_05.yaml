- en: 5 Multi-cloud (app) infrastructure
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 多云（应用程序）基础设施
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Defining and managing the infrastructure for your cloud-native applications
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义和管理云原生应用程序的基础设施
- en: Identifying the challenges of managing infrastructure components
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别管理基础设施组件的挑战
- en: Learning how Crossplane is the Kubernetes way to deal with infrastructure
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用Crossplane以Kubernetes的方式处理基础设施
- en: 'In previous chapters, we installed a walking skeleton, and we learned how to
    build each separate component using service pipelines and then how to deploy them
    into different environments using environment pipelines. We now face a big challenge:
    dealing with our application infrastructure, meaning running and maintaining not
    only our application services but also the components that our services need to
    run. These services expect other components to work correctly, such as databases,
    message brokers, identity management solutions, email servers, etc. While several
    tools exist to automate the installation (for on-premises setups) or provisioning
    of these components in different cloud providers, this chapter will focus on just
    one that does it in a Kubernetes way. This chapter has three main sections:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们安装了一个行走骨架，并学习了如何使用服务管道构建每个单独的组件，然后如何使用环境管道将它们部署到不同的环境中。我们现在面临一个重大挑战：处理我们的应用程序基础设施，这意味着不仅要运行和维护我们的应用程序服务，还要运行和维护我们的服务所需的组件。这些服务期望其他组件能够正确工作，例如数据库、消息代理、身份管理解决方案、电子邮件服务器等。虽然存在一些工具可以自动化这些组件的安装（对于本地设置）或在不同云提供商中的配置，但本章将专注于仅以Kubernetes方式完成这一点的工具。本章有三个主要部分：
- en: The challenges of dealing with infrastructure
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理基础设施的挑战
- en: How to deal with infrastructure using Kubernetes constructs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Kubernetes结构处理基础设施
- en: How to provision infrastructure for our walking skeleton using Crossplane
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Crossplane为我们的行走骨架配置基础设施
- en: Let’s get started. Why is it so difficult to manage our application infrastructure?
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。为什么管理我们的应用程序基础设施如此困难？
- en: 5.1 The challenges of managing infrastructure in Kubernetes
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 Kubernetes中管理基础设施的挑战
- en: When you design applications like the walking skeleton introduced in chapter
    1, you face specific challenges that are not core to achieving your business goals.
    Installing, configuring, and maintaining *application infrastructure* components
    that support our application’s services is a big task that needs to be planned
    carefully by the right teams with the right expertise.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当你设计像第1章中介绍的那种行走骨架的应用程序时，你会面临一些并非实现业务目标核心的特定挑战。安装、配置和维护支持我们应用程序服务的*应用程序基础设施*组件是一项需要由具备正确专业知识的团队精心计划的大任务。
- en: These components are classified as application infrastructure, which usually
    involves third-party components not developed in-house, such as databases, message
    brokers, identity management solutions, etc. A big reason behind the success of
    modern cloud providers is that they are great at providing and maintaining these
    components and allow your development teams to focus on building the core features
    of applications, which brings value to the business.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件被归类为应用程序基础设施，通常涉及第三方组件，这些组件不是内部开发的，例如数据库、消息代理、身份管理解决方案等。现代云服务提供商成功的一个重要原因是他们擅长提供和维护这些组件，并允许你的开发团队专注于构建应用程序的核心功能，这为业务带来了价值。
- en: It is essential to distinguish between application infrastructure and hardware
    infrastructure, because this book is not concerned with hardware provisioning,
    the reminder of content focus on the application space. I assume that for public
    cloud offerings, the provider solves all hardware-related topics. For on-prem
    scenarios, you likely have a specialized team taking care of the hardware (removing,
    adding, and maintaining hardware as needed).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 区分应用程序基础设施和硬件基础设施至关重要，因为本书不涉及硬件配置，其余内容主要关注应用程序空间。我假设对于公共云服务，提供商解决了所有与硬件相关的问题。对于本地场景，你可能有一个专门的团队负责硬件（根据需要移除、添加和维护硬件）。
- en: It is common to rely on cloud provider services to provision application infrastructure.
    There are a lot of advantages to doing so, such as pay-as-you-use services, easy
    provisioning at scale, and automated maintenance. But at that point, you heavily
    rely on provider-specific ways of doing things and their tools. The moment you
    create a database or a message broker in a cloud provider, you are jumping outside
    the realms of Kubernetes. Now you depend on their tools and automation mechanisms,
    and you are creating a strong dependency between your business and the cloud provider.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖云服务提供商来配置应用程序基础设施是很常见的。这样做有很多优点，例如按需付费服务、易于大规模配置和自动化维护。但到了那个阶段，你将严重依赖提供商特定的操作方式和他们的工具。一旦你在云服务提供商中创建数据库或消息代理，你就已经跳出了Kubernetes的领域。现在你依赖于他们的工具和自动化机制，并且正在在业务和云服务提供商之间建立强烈的依赖关系。
- en: 'Let’s look at the challenges associated with provisioning and maintaining application
    infrastructure, so your teams can plan and choose the right tool for the job:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看配置和维护应用程序基础设施所面临的挑战，以便您的团队能够规划和选择合适的工具：
- en: '*Configuring components to scale:* Each component requires different expertise
    to be configured (database administrators for databases, message broker experts,
    machine learning experts, etc.) and a deep understanding of how our application’s
    services will use it, as well as the hardware available. These configurations
    need to be versioned and monitored closely, so new environments can be created
    quickly to reproduce problems or test new versions of our application.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*配置组件以进行扩展:* 每个组件都需要不同的专业知识来配置（数据库管理员对数据库，消息代理专家，机器学习专家等），以及深入了解我们的应用程序服务将如何使用它，以及可用的硬件。这些配置需要版本控制和密切监控，以便可以快速创建新环境来重现问题或测试我们应用程序的新版本。'
- en: '*Maintaining components in the long run:* Databases and message brokers are
    constantly released and patched to improve performance and security. This constant
    change pushes the operations teams to ensure they can upgrade to newer versions
    and keep all the data safe without bringing down the entire application. All this
    complexity requires a lot of coordination and impact analysis between the teams
    providing and consuming these components.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*长期维护组件:* 数据库和消息代理不断发布和修补以改进性能和安全。这种持续的变化迫使运维团队确保他们可以升级到新版本并保持所有数据的安全，而不会使整个应用程序崩溃。所有这些复杂性都需要在提供和消费这些组件的团队之间进行大量的协调和影响分析。'
- en: '*Cloud provider services affect our multi-cloud strategy:* If we rely on cloud-specific
    application infrastructure and tools, we need to find a way to enable developers
    to create and provision their components for developing and testing their services.
    We need a way to abstract how infrastructure is provisioned to enable applications
    to define what infrastructure they need without relying directly on cloud-specific
    tools.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*云服务提供商服务影响我们的多云策略:* 如果我们依赖于特定于云的应用程序基础设施和工具，我们需要找到一种方法来使开发者能够为他们开发和服务创建和配置组件。我们需要一种方法来抽象基础设施的配置，以便应用程序可以定义它们需要的基础设施，而无需直接依赖于特定于云的工具。'
- en: Interestingly, we had these challenges even before having distributed applications,
    and configuration and provisioning architectural components have always been hard
    and usually far away from developers. Cloud providers are doing a fantastic job
    by bringing these topics closer to developers so they can be more autonomous and
    iterate faster. Unfortunately, when working with Kubernetes, we have more options
    that we need to consider carefully to ensure we understand the tradeoffs. The
    following section covers how we can manage our application infrastructure inside
    Kubernetes. While this is usually not recommended, it can be practical and cheaper
    for some scenarios.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，我们在拥有分布式应用程序之前就已经面临这些挑战，配置和配置架构组件一直很困难，通常远离开发者。云服务提供商通过将这些主题带到开发者身边，做得非常出色，使他们能够更加自主和快速迭代。不幸的是，当与Kubernetes一起工作时，我们有更多的选项需要仔细考虑，以确保我们理解权衡。下一节将介绍我们如何在Kubernetes内部管理我们的应用程序基础设施。虽然这通常不推荐，但对于某些场景来说，它可能是实际且成本更低的。
- en: 5.1.1 Managing your application infrastructure
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.1 管理您的应用程序基础设施
- en: Application infrastructure has become an exciting arena. With the rise of containers,
    every developer can bootstrap a database or message broker with a couple of commands,
    which is usually enough for development purposes. In the Kubernetes world, this
    translates to Helm Charts, which uses containers to configure and provision databases
    (relational and NoSQL), message brokers, identity management solutions, etc. As
    we saw in chapter 2, you installed the walking skeleton application containing
    four services, two databases (Redis and PostgreSQL), and a message broker (Kafka)
    with a single command.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 应用基础设施已经成为一个令人兴奋的领域。随着容器技术的兴起，每个开发者都可以通过几条命令启动数据库或消息代理，这对于开发目的通常已经足够。在 Kubernetes
    世界中，这转化为 Helm 图表，它使用容器来配置和提供数据库（关系型和非关系型）、消息代理、身份管理解决方案等。正如我们在第 2 章中看到的，您只需一条命令就可以安装包含四个服务、两个数据库（Redis
    和 PostgreSQL）和一个消息代理（Kafka）的行走骨架应用程序。
- en: For our walking skeleton, we are provisioning an instance of a Redis NoSQL database
    for the Agenda service, an instance of a PostgreSQL database for the Call for
    Proposals (C4P) service, and an instance of a Kafka cluster, all using Helm Charts.
    The number of Helm charts available today is impressive, and it is pretty easy
    to think that installing a Helm Chart will be the way to go. The Helm charts used
    in the example application can all be found in the Bitnami Helm Chart repositories
    at [https://bitnami.com/stacks/helm](https://bitnami.com/stacks/helm).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的行走骨架，我们正在为议程服务提供 Redis NoSQL 数据库的一个实例，为提案征集（C4P）服务提供一个 PostgreSQL 数据库的实例，以及一个
    Kafka 集群的实例，所有这些都使用 Helm 图表。目前可用的 Helm 图表数量令人印象深刻，很容易想到安装 Helm 图表将成为一种趋势。示例应用程序中使用的
    Helm 图表都可以在 Bitnami Helm 图表存储库[https://bitnami.com/stacks/helm](https://bitnami.com/stacks/helm)中找到。
- en: As discussed in chapter 2, if we want to scale our services that keep state,
    we must provision specialized components such as databases. Application developers
    will define which kind of database will suit them best depending on the data they
    need to store and how that data will be structured. Figure 5.1 shows the dependency
    of the application services on some of the application infrastructure components
    that we have identified for our walking skeleton.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如第 2 章所述，如果我们想扩展保持状态的服务，我们必须提供专门的组件，如数据库。应用程序开发者将根据需要存储的数据及其结构来定义最适合他们的数据库类型。图
    5.1 展示了应用程序服务对我们为行走骨架确定的某些应用程序基础设施组件的依赖关系。
- en: '![](../../OEBPS/Images/05-01.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/05-01.png)'
- en: Figure 5.1 Services and their dependencies on application infrastructure components
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 服务及其对应用程序基础设施组件的依赖关系
- en: 'The process of setting up these (PostgreSQL, Redis, and Kafka) components inside
    your Kubernetes cluster involves the following steps:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的 Kubernetes 集群内部署这些（PostgreSQL、Redis 和 Kafka）组件的过程涉及以下步骤：
- en: Finding or creating a suitable Helm Chart for the component you want to bootstrap.
    For the walking skeleton, PostgreSQL ([https://bitnami.com/stack/postgresql/helm](https://bitnami.com/stack/postgresql/helm)),
    Redis ([https://bitnami.com/stack/redis/helm](https://bitnami.com/stack/redis/helm)),
    and Kafka ([https://bitnami.com/stack/kafka/helm](https://bitnami.com/stack/kafka/helm))
    can be found in the Bitnami Helm Chart repository. If you cannot find a Helm Chart
    but have a Docker container for the component you want to provision, you can create
    your chart after you define the basic Kubernetes constructs needed for the deployment.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找或创建适合您要启动的组件的 Helm 图表。对于行走骨架，PostgreSQL ([https://bitnami.com/stack/postgresql/helm](https://bitnami.com/stack/postgresql/helm))、Redis
    ([https://bitnami.com/stack/redis/helm](https://bitnami.com/stack/redis/helm))
    和 Kafka ([https://bitnami.com/stack/kafka/helm](https://bitnami.com/stack/kafka/helm))
    都可以在 Bitnami Helm 图表存储库中找到。如果您找不到 Helm 图表，但有一个您要提供的组件的 Docker 容器，您可以在定义部署所需的基本
    Kubernetes 构造之后创建您的图表。
- en: Research the chart configurations and parameters you must set up to accommodate
    your requirements. Each chart exposes a set of parameters that you can tune for
    different use cases. Check the chart website to understand what is available.
    Include your operations teams and DBAs to check the optimal database configurations
    for your use case; this is not something that a developer can do. This analysis
    also requires Kubernetes expertise to ensure the components can work in HA (high
    availability) mode inside Kubernetes.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 研究图表配置和参数，您必须设置以适应您的需求。每个图表都提供了一组参数，您可以根据不同的用例进行调整。检查图表网站以了解可用的选项。包括您的运维团队和数据库管理员（DBAs）来检查针对您的用例的最佳数据库配置；这不是开发者可以完成的事情。这项分析还需要
    Kubernetes 专业知识，以确保组件可以在 Kubernetes 内部以高可用性（HA）模式工作。
- en: Install the chart into your Kubernetes cluster using `helm install`. By running
    `helm install`, you are downloading a set of Kubernetes manifest (YAML files)
    that describe how these components need to be deployed. Helm will then proceed
    to apply these YAML files to your cluster. For our Conference application Helm
    Chart that we installed in chapter 2 (section 2.1.3), all the application infrastructure
    components are added as a dependency to the chart.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `helm install` 将图表安装到您的 Kubernetes 集群中。通过运行 `helm install`，您将下载一组 Kubernetes
    清单（YAML 文件），这些文件描述了这些组件需要如何部署。然后 Helm 将继续将这些 YAML 文件应用到您的集群中。对于我们在第 2 章中安装的 Conference
    应用 Helm 图表（第 2.1.3 节），所有应用程序基础设施组件都被添加为图表的依赖项。
- en: Configure your service to connect to the newly provisioned components. You can
    achieve this by giving the service the new provisioned instance URL and credentials
    to connect. For a database, it will be the database URL serving requests and possibly
    a username and password. An interesting detail to notice here is that your application
    will need some kind of driver to connect to the target database. More on this
    in chapter 8.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置您的服务以连接到新配置的组件。您可以通过提供新配置的实例 URL 和连接凭据来实现这一点。对于数据库，将是处理请求的数据库 URL，可能还包括用户名和密码。一个有趣的细节是，您的应用程序需要某种类型的驱动程序才能连接到目标数据库。更多内容将在第
    8 章中介绍。
- en: Maintain these components in the long run, doing backups and ensuring the fail-over
    mechanisms work as expected.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在长期维护这些组件，进行备份并确保故障转移机制按预期工作。
- en: Figure 5.2 shows the steps involved in installing and wiring up these application
    infrastructure components to our application’s services.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 展示了将应用程序基础设施组件安装和连接到我们的应用程序服务的步骤。
- en: '![](../../OEBPS/Images/05-02.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/05-02.png)'
- en: 'Figure 5.2 Provisioning a new PostgreSQL instance using the PostgreSQL Helm
    Chart. #1 Install a helm chart into a Namespace inside a Kubernetes Cluster; #2
    The chart creates Kubernetes resources such as StatefulSets and Deployments to
    provision a PostgreSQL instance; #3 A Service needs to connect to the newly created
    instance, this can be done manually or by referencing a Kubernetes Secret that
    contains the credentials and details on how to connect.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 使用 PostgreSQL Helm 图表配置新的 PostgreSQL 实例。#1 在 Kubernetes 集群内的命名空间中安装 helm
    图表；#2 图表创建 Kubernetes 资源，如 StatefulSets 和 Deployments，以配置 PostgreSQL 实例；#3 需要一个服务连接到新创建的实例，这可以通过手动操作或通过引用包含凭据和连接详情的
    Kubernetes 密钥来实现。
- en: 'If you are working with Helm Charts, there are a couple of caveats and tricks
    that you need to be aware of:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用 Helm 图表，有一些注意事项和技巧您需要了解：
- en: If the chart doesn’t allow you to configure a parameter that you are interested
    in changing, you can always use `helm template`, then modify the output to add
    or change the parameters that you need to finally install the components using
    `kubectl apply -f`. Alternatively, you can submit a pull request to the chart
    repository. It is a common practice not to expose all possible parameters and
    wait for community members to suggest more parameters to be exposed by the chart.
    Don’t be shy and contact the maintainers if that is the case. Whatever modification
    you do, the chart content must be maintained and documented. By using `helm template`,
    you lose the Helm release management features, allowing you to upgrade a chart
    when a new version is available.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果图表不允许您配置您想要更改的参数，您始终可以使用 `helm template`，然后修改输出以添加或更改您需要最终使用 `kubectl apply
    -f` 安装组件的参数。或者，您可以向图表存储库提交一个拉取请求。不公开所有可能的参数并等待社区成员建议更多要公开的参数是常见的做法。如果这种情况发生，不要害羞，联系维护者。无论您进行何种修改，都必须维护和记录图表内容。使用
    `helm template` 会失去 Helm 发布管理功能，允许您在新版本可用时升级图表。
- en: Most charts have a default configuration designed to scale, meaning that the
    default deployment will target high-availability scenarios. This results in charts
    that, when installed, consume a lot of resources (CPU and memory) that might not
    be available if you use Kubernetes KinD or Minikube on your laptop. Once again,
    chart documentation usually includes special configurations for development and
    resource-constrained environments.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数图表都有一个默认配置，旨在进行扩展，这意味着默认部署将针对高可用性场景。这导致安装时消耗大量资源（CPU 和内存）的图表，这些资源在使用笔记本电脑上的
    Kubernetes KinD 或 Minikube 时可能不可用。再次强调，图表文档通常包括针对开发和资源受限环境的特殊配置。
- en: If you are installing a database inside your Kubernetes cluster, each database
    container (pod) must have access to storage from the underlying Kubernetes node.
    For databases, you might need a special kind of storage to enable the database
    to scale elastically, which might require advanced configurations outside of Kubernetes.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您在 Kubernetes 集群内安装数据库，每个数据库容器（Pod）必须能够访问底层 Kubernetes 节点的存储。对于数据库，您可能需要一种特殊的存储类型，以使数据库能够弹性扩展，这可能需要在
    Kubernetes 之外进行高级配置。
- en: For our walking skeleton, for example, we set up the Redis chart to use the
    `architecture` parameter to `standalone`, (as you can see in the environment pipeline
    configurations and in the Agenda service Helm Chart values.yaml file) to make
    it easier to run on environments where you might have limited resources, such
    as your laptop/workstation. This affects Redis’s availability to tolerate failure,
    because it will only run a single replica in contrast with the default setup where
    a master and two slaves are created.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于我们的“行走骨架”，我们设置了 Redis 图表使用 `architecture` 参数为 `standalone`，（如环境管道配置和 Agenda
    服务 Helm Chart values.yaml 文件所示），以便在您可能拥有有限资源的环境中更容易运行，例如您的笔记本电脑/工作站。这会影响 Redis
    的可用性以容忍故障，因为它将只运行一个副本，而与默认设置中创建一个主节点和两个从节点的情况相比。
- en: 5.1.2 Connecting our services to the newly provisioned infrastructure
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.2 将我们的服务连接到新配置的基础设施
- en: Installing the charts will not make our application services automatically connect
    to the Redis, PostgreSQL, or Kafka instances. We need to provide the services
    the configurations need to connect while also being conscious of the time needed
    by these components, such as databases, to start.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 安装图表不会使我们的应用程序服务自动连接到 Redis、PostgreSQL 或 Kafka 实例。我们需要提供服务所需的配置以连接，同时也要意识到这些组件（如数据库）启动所需的时间。
- en: Figure 5.3 shows how the wiring usually happens, as most charts automatically
    create a Kubernetes secret hosting all the details that application’s services
    need to connect.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 展示了通常的连接方式，因为大多数图表会自动创建一个 Kubernetes 机密，托管所有应用程序服务需要连接的详细信息。
- en: '![](../../OEBPS/Images/05-03.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/05-03.png)'
- en: 'Figure 5.3 Connecting a service to a provisioned resource using secrets. #1
    A Kubernetes deployment is created to run one of your services, and the pod template
    contains the environment variables to configure the pods that this deployment
    will create; #2 The pod is created using the template specified in the deployment
    resource, which points to a secret that contains the details to connect to the
    db instance; #3 The container, which is running inside the pod needs to be prepared
    to consume the environment variables to connect to the db instance.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 使用 secrets 连接服务到已配置的资源。#1 创建了一个 Kubernetes 部署来运行你的一个服务，并且 pod 模板包含配置 pod
    的环境变量，这些 pod 将由该部署创建；#2 使用部署资源中指定的模板创建了 pod，该模板指向包含连接到 db 实例详细信息的 secret；#3 运行在
    pod 内部的容器需要准备就绪，以便消费环境变量以连接到 db 实例。
- en: A common practice is to use Kubernetes secrets to store the credentials for
    these application infrastructure components. The Helm Chart for Redis and PostgreSQL
    that we are using for our walking skeleton creates a new Kubernetes secret containing
    the details required to connect. These Helm Charts also create a Kubernetes service
    to be used as the location (URL) where the instance will run.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的做法是使用 Kubernetes secrets 来存储这些应用基础设施组件的凭证。我们用于构建行走框架的 Redis 和 PostgreSQL
    Helm Chart 会创建一个新的 Kubernetes secret，其中包含连接所需的详细信息。这些 Helm Charts 还创建了一个 Kubernetes
    服务，用作实例运行的地点（URL）。
- en: To connect the Call for Proposals (C4P) service to the PostgreSQL instance,
    you need to make sure that the Kubernetes Deployment for the C4P service (`conference-c4p-service-deployment`)
    has the right environment variables (listing 5.1).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要将提案征集服务（Call for Proposals，C4P）连接到 PostgreSQL 实例，你需要确保 C4P 服务的 Kubernetes Deployment
    (`conference-c4p-service-deployment`) 具有正确的环境变量（见 5.1 列表）。
- en: Listing 5.1 Environment variables to connect to application infrastructure (PostgreSQL)
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.1 连接到应用基础设施（PostgreSQL）的环境变量
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The bold highlights how we can consume the dynamically generated password when
    we install the chart and the DB endpoint URL, which is the PostgreSQL Kubernetes
    service, also created by the chart. The DB endpoint will be different if you used
    a different chart release name.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 粗体部分突出显示了我们在安装图表时如何消费动态生成的密码以及 DB 端点 URL，该 URL 是由图表创建的 PostgreSQL Kubernetes
    服务。如果你使用了不同的图表发布名称，DB 端点将会有所不同。
- en: A similar configuration applies to the Agenda service (`conference-agenda-service-deployment`)
    and Redis (listing 5.2).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的配置也适用于议程服务（`conference-agenda-service-deployment`）和 Redis（见 5.2 列表）。
- en: Listing 5.2 Environment variables to connect to application infrastructure (Redis)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.2 连接到应用基础设施（Redis）的环境变量
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As before, we extract the password from a Kubernetes secret that will be generated
    when installing the Redis Helm Chart. The secret name will be derived from the
    name of the Helm Chart release that we use. The `REDIS_HOST` is obtained from
    the name of the Kubernetes service that is created by the chart, which depends
    on the `helm release` name that you used. For all the services of the application
    we will need to set up the `KAFKA_URL` environment variable so that the services
    can connect to Kafka. Configuring different instances for the application infrastructure
    components opens the door for us to delegate the provisioning and maintenance
    to other teams and even cloud providers.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们从安装 Redis Helm Chart 时生成的 Kubernetes secret 中提取密码。secret 的名称将派生自我们使用的
    Helm Chart 发布名称。`REDIS_HOST` 从图表创建的 Kubernetes 服务的名称中获取，这取决于你使用的 `helm release`
    名称。对于应用的所有服务，我们都需要设置 `KAFKA_URL` 环境变量，以便服务可以连接到 Kafka。为应用基础设施组件配置不同的实例为我们打开了将供应和维护委托给其他团队甚至云提供商的大门。
- en: 5.1.3 I’ve heard about Kubernetes operators. Should I use them?
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.3 我听说过 Kubernetes operators。我应该使用它们吗？
- en: Now you have four application services, two databases, and a message broker
    inside your Kubernetes cluster. Believe it or not, now you are in charge of seven
    components to maintain and scale depending on the application’s needs. The team
    that built the services will know exactly how to maintain and upgrade each service,
    but they are not experts in maintaining and scaling databases or message brokers.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的 Kubernetes 集群内部有四个应用服务、两个数据库和一个消息代理。信不信由你，你现在需要负责七个组件的维护和扩展，这些组件根据应用的需求而定。构建服务的团队将确切知道如何维护和升级每个服务，但他们不是维护和扩展数据库或消息代理的专家。
- en: You might need help with these databases and message brokers depending on how
    demanding the services are. Imagine you have too many requests on the Agenda service,
    so you decide to scale up the number of replicas of the agenda deployment to 200\.
    At that point, Redis must have enough resources to deal with 200 pods connecting
    to the Redis cluster. The advantage of using Redis for this scenario, where we
    might get a lot of reads while the conference is ongoing, is that the Redis cluster
    allows us to read data from the replicas so the load can be distributed.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 根据服务需求的不同，您可能需要帮助来处理这些数据库和消息代理。想象一下，您在Agenda服务上收到了太多的请求，因此您决定将议程部署的副本数量扩展到200个。在那个时刻，Redis必须拥有足够的资源来处理连接到Redis集群的200个Pod。在这个场景中使用Redis的优势在于，在会议进行期间我们可能会遇到大量的读取操作，Redis集群允许我们从副本中读取数据，从而实现负载的分散。
- en: Figure 5.4 shows a typical case of high demand, where we are tempted to increase
    the number of replicas of our application’s services, without checking or changing
    the configuration of our PostgreSQL instance. In these scenarios, even if the
    application’s services can scale, the PostgreSQL instance will be the bottleneck
    if not configured accordingly (to support 200+ concurrent connections).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4展示了高需求的一个典型情况，我们可能会被诱惑增加应用服务的副本数量，而不会检查或更改我们的PostgreSQL实例的配置。在这些场景中，即使应用服务可以扩展，如果未相应配置（以支持200+并发连接），PostgreSQL实例将成为瓶颈。
- en: '![](../../OEBPS/Images/05-04.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/05-04.png)'
- en: 'Figure 5.4 Application infrastructure needs to be configured according to how
    our services will be scaled. #1 If you noticed a surge in demand for one of your
    services, you might be tempted to increase the number of replicas, and the deployment
    using the ReplicaSet will not complain about it. If the cluster has enough resources,
    the replicas will be created; #2 If the application infrastructure is not correctly
    configured, you might encounter a lot of issues, such as exhausting the database
    connection pool or overloading the database pods, as they are not scaled when
    you scale up your deployments.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4显示，应用基础设施的配置需要根据我们的服务扩展方式来设置。#1 如果您注意到某个服务的需求激增，您可能会想增加副本数量，使用ReplicaSet的部署不会对此提出异议。如果集群有足够的资源，副本将被创建；#2
    如果应用基础设施配置不正确，您可能会遇到许多问题，例如耗尽数据库连接池或数据库Pod过载，因为当您扩展部署时，它们并没有进行扩展。
- en: 'If you are installing your application infrastructure with Helm, notice that
    Helm will not check for the health of these components—it is just doing the installation.
    It is quite common nowadays to find another alternative to install components
    in a Kubernetes cluster called Operators. Usually associated with application
    infrastructure, you can find more active components that will install and monitor
    the installed components. One example of these operators is the Zalando PostgreSQL
    Operator, which you can find at [https://github.com/zalando/postgres-operator](https://github.com/zalando/postgres-operator).
    While these operators are focused on allowing you to provision new instances of
    PostgreSQL databases, they also implement other features focused on maintenance,
    for example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用Helm安装应用基础设施，请注意，Helm不会检查这些组件的健康状况——它只是在进行安装。如今，找到另一种在Kubernetes集群中安装组件的方法非常普遍，这种方法被称为Operators。通常与应用基础设施相关联，您会发现更多活跃的组件，这些组件将安装并监控已安装的组件。这些operator的一个例子是Zalando
    PostgreSQL Operator，您可以在[https://github.com/zalando/postgres-operator](https://github.com/zalando/postgres-operator)找到它。虽然这些operator专注于允许您为PostgreSQL数据库提供新实例，但它们还实现了其他专注于维护的功能，例如：
- en: Rolling updates on Postgres cluster changes, including quick minor version updates
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Postgres集群更改上进行滚动更新，包括快速的小版本更新
- en: Live volume resize without pod restarts (AWS EBS, PVC)
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不重启Pod的情况下实时调整卷大小（AWS EBS，PVC）
- en: Database connection pooling with PGBouncer
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PGBouncer进行数据库连接池
- en: Supporting fast, in-place major version upgrades
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持快速就地主要版本升级
- en: In general, Kubernetes operators try to encapsulate the operational tasks associated
    with a specific component, in this case, PostgreSQL. While using operators might
    add more features on top of installing a given component, you still need to maintain
    the component and the operator itself now. Each operator comes with a very opinionated
    flow that your teams will need to research and learn to manage. Take this into
    consideration when researching and deciding which operator to use.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Kubernetes 运营商试图封装与特定组件相关的操作任务，在本例中是 PostgreSQL。虽然使用运营商可能为安装的组件添加更多功能，但您现在仍然需要维护该组件和运营商本身。每个运营商都附带一个非常具有意见的流程，您的团队将需要研究和学习以进行管理。在研究和决定使用哪个运营商时，请考虑这一点。
- en: Regarding the application infrastructure you and your teams decide to use if
    you plan to run these components inside your cluster, plan accordingly to have
    the right in-house expertise to manage, maintain, and scale these extra components.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您计划在集群内部运行这些组件，您和您的团队决定使用哪些应用程序基础设施，请相应地规划，以便拥有管理、维护和扩展这些额外组件所需的内部专业知识。
- en: In the following section, we will look at how we can tackle these challenges
    by looking at an open-source project that aims to simplify the provisioning of
    cloud and on-prem resources for application infrastructure components using a
    declarative approach.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何通过查看一个开源项目来解决这些挑战，该项目旨在通过声明性方法简化应用程序基础设施组件的云和本地资源的配置。
- en: 5.2 Declarative infrastructure using Crossplane
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 使用 Crossplane 实现声明性基础设施
- en: Using Helm to install application infrastructure components inside Kubernetes
    is far from ideal for large applications and user-facing environments, because
    maintaining these components and their requirements, such as advanced storage
    configurations, might become too complex to handle for your teams.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Helm 在 Kubernetes 内部安装应用程序基础设施组件远非理想，尤其是在大型应用程序和面向用户的场景中，因为维护这些组件及其要求，如高级存储配置，可能变得过于复杂，难以处理。
- en: Cloud providers do a fantastic job at allowing us to provision infrastructure,
    but they all rely on cloud provider-specific tools that are outside of the realm
    of Kubernetes.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 云提供商在允许我们配置基础设施方面做得非常出色，但它们都依赖于云提供商特定的工具，这些工具超出了 Kubernetes 的范畴。
- en: In this section, we will look at an alternative tool—a CNCF project called Crossplane
    ([https://crossplane.io](https://crossplane.io)), which uses the Kubernetes APIs
    and extension points to enable users to provision real infrastructure in a declarative
    way, using the Kubernetes APIs. Crossplane relies on the Kubernetes APIs to support
    multiple cloud providers; this also means that it integrates nicely with all the
    existing Kubernetes tooling.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨一个替代工具——一个名为 Crossplane 的 CNCF 项目([https://crossplane.io](https://crossplane.io))，它使用
    Kubernetes API 和扩展点以声明性方式允许用户使用 Kubernetes API 部署真实基础设施。Crossplane 依赖于 Kubernetes
    API 来支持多个云提供商；这也意味着它与所有现有的 Kubernetes 工具很好地集成。
- en: By understanding how Crossplane works and how it can be extended, you can build
    a multi-cloud approach and run your cloud-native applications and their dependencies
    with different providers without worrying about getting locked in on a single
    vendor. Because Crossplane uses the same declarative approach as Kubernetes, you
    can create high-level abstractions about the applications you are trying to deploy
    and maintain.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通过了解 Crossplane 的工作原理以及如何扩展它，您可以构建多云方法，并使用不同的提供商运行您的云原生应用程序及其依赖项，而无需担心被锁定在单个供应商上。因为
    Crossplane 使用与 Kubernetes 相同的声明性方法，您可以创建关于您试图部署和维护的应用程序的高级抽象。
- en: To use Crossplane, you must first install its control plane in a Kubernetes
    cluster. You can follow the official documentation ([https://docs.crossplane.io/](https://docs.crossplane.io/))
    or the step-by-step tutorial introduced in section 5.3.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Crossplane，您必须首先在 Kubernetes 集群中安装其控制平面。您可以遵循官方文档([https://docs.crossplane.io/](https://docs.crossplane.io/))或第
    5.3 节中介绍的逐步教程。
- en: The core Crossplane components alone will not do much for you. Depending on
    your cloud provider(s), you will install and configure one or more *Crossplane
    providers*. Let’s take a look at what Crossplane providers have to offer us.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 仅靠 Crossplane 的核心组件对您来说帮助不大。根据您的云提供商，您将安装和配置一个或多个 *Crossplane 提供商*。让我们看看 Crossplane
    提供商能为我们提供什么。
- en: 5.2.1 Crossplane providers
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.1 Crossplane 提供商
- en: Crossplane extends Kubernetes by installing a set of components called Crossplane
    providers ([https://docs.crossplane.io/v1.12/concepts/providers/](https://docs.crossplane.io/v1.12/concepts/providers/))
    in charge of understanding and interacting with cloud provider-specific services
    to provision cloud resources on our behalf. Figure 5.5 shows how by installing
    the GCP provider and the AWS provider, our Crossplane installation can provision
    resources on both clouds.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Crossplane 通过安装一组称为 Crossplane 提供商的组件来扩展 Kubernetes，这些组件负责理解和与云提供商特定的服务交互，代表我们配置云资源。图
    5.5 展示了通过安装 GCP 提供商和 AWS 提供商，我们的 Crossplane 安装可以在两个云上配置资源。
- en: '![](../../OEBPS/Images/05-05.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/05-05.png)'
- en: Figure 5.5 Crossplane installed with GCP and AWS providers
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 配置了 GCP 和 AWS 提供商的 Crossplane
- en: 'By installing Crossplane providers, you are extending the Kubernetes API’s
    functionality to provision external resources such as databases, message brokers,
    buckets, and other cloud resources that will live outside your Kubernetes cluster
    but inside the cloud provider realm. There are several Crossplane providers that
    cover the major cloud providers such as GCP, AWS, and Azure. You can find these
    Crossplane providers in the Crossplane GitHub’s organization: [https://docs.crossplane.io/latest/concepts/providers/](https://docs.crossplane.io/latest/concepts/providers/).'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 通过安装 Crossplane 提供商，您正在扩展 Kubernetes API 的功能，以配置外部资源，如数据库、消息代理、桶以及其他将存在于您的 Kubernetes
    集群之外但位于云提供商领域内的云资源。有几个 Crossplane 提供商涵盖了主要的云提供商，如 GCP、AWS 和 Azure。您可以在 Crossplane
    GitHub 组织中找到这些 Crossplane 提供商：[https://docs.crossplane.io/latest/concepts/providers/](https://docs.crossplane.io/latest/concepts/providers/)。
- en: Once a Crossplane Provider is installed, you can create provider-specific resources
    in a declarative way, which means that you can create a Kubernetes Resource, apply
    it with `kubectl apply -f`, package these definitions in Helm Charts or use environment
    pipelines storing these resources in a Git repository.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了 Crossplane 提供商，您就可以以声明性方式创建特定于提供商的资源，这意味着您可以创建一个 Kubernetes 资源，使用 `kubectl
    apply -f` 应用它，将这些定义打包在 Helm 图表中，或者使用环境管道将这些资源存储在 Git 仓库中。
- en: For example, creating a bucket in Google Cloud using the Crossplane GCP provider
    looks like listing 5.4.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用 Crossplane GCP 提供商在 Google Cloud 中创建一个桶看起来像列表 5.4。
- en: Listing 5.4 Google Cloud Platform bucket resource definition
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.4 Google Cloud Platform 桶资源定义
- en: '[PRE2]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ① Both apiVersion and kind are defined by the Crossplane GCP provider. You can
    find all the supported types of resources in the Crossplane provider documentation.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ① apiVersion 和 kind 都由 Crossplane GCP 提供商定义。您可以在 Crossplane 提供商文档中找到所有支持的资源类型。
- en: ② By creating a bucket resource in our Kubernetes cluster where Crossplane is
    installed, you are creating a request for Crossplane to provision and monitor
    this resource on your behalf.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在我们的 Kubernetes 集群中创建一个桶资源，其中安装了 Crossplane，您正在创建一个请求，让 Crossplane 代表您配置和监控此资源。
- en: ③ For each resource type, you have a set of parameters to configure the resource.
    In this case, we want the bucket to be in the US. Different resources will expose
    different configuratio
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 对于每种资源类型，您都有一组参数来配置资源。在这种情况下，我们希望桶位于美国。不同的资源将公开不同的配置
- en: Provisioning cloud-specific resources relying on the Kubernetes APIs is a big
    step forward, but Crossplane doesn’t stop there. If you look at what it takes
    to provision a database in any major cloud provider, you will realize that provisioning
    the component is just one of the tasks involved in getting the component ready
    to be used. You need extra network and security configurations, user credentials,
    and other cloud provider-specific configurations to connect to these provisioned
    resources. Welcome Crossplane compositions!
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖于 Kubernetes API 配置云特定资源是一个很大的进步，但 Crossplane 并没有停止在这里。如果您看看在任何一个主要云提供商中配置数据库需要什么，您将意识到配置组件只是使组件准备好使用的任务之一。您需要额外的网络和安全配置、用户凭证以及其他云提供商特定的配置来连接到这些已配置的资源。欢迎
    Crossplane 组合！
- en: 5.2.2 Crossplane compositions
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.2 Crossplane 组合
- en: 'Crossplane aims to serve two different personas: *platform teams* and *application
    teams*. While *platform* teams are cloud provider experts who understand how to
    provision cloud provider-specific components, *application* teams know the application
    requirements and understand what is required from the application infrastructure
    perspective. The interesting thing about this approach is that when using Crossplane,
    platform teams can define these complex configurations for a specific cloud provider
    and expose simplified interfaces for application teams.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Crossplane旨在服务于两个不同的角色：*平台团队*和*应用团队*。虽然*平台*团队是云服务提供商的专家，了解如何配置特定云服务提供商的组件，但*应用*团队了解应用程序的需求，并从应用程序基础设施的角度理解需要什么。这个方法有趣的地方在于，当使用Crossplane时，平台团队可以为特定云服务提供商定义这些复杂的配置，并为应用团队提供简化的接口。
- en: In real-life scenarios, it is rare to create a single component. For example,
    if we want to provision a database instance, application teams will also require
    the correct network and security configurations to be able to access the newly
    created instance. Being able to compose and wire together several components is
    a very convenient feature, and to achieve these abstractions and simplified interfaces,
    Crossplane introduced two concepts, *Composite Resource Definitions (XRDs)* and
    *Composite Resources (XRs)*.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实场景中，创建单个组件的情况很少见。例如，如果我们想要配置一个数据库实例，应用团队还需要正确的网络和安全配置，以便能够访问新创建的实例。能够组合和连接多个组件是一个非常方便的功能，为了实现这些抽象和简化接口，Crossplane引入了两个概念，*组合资源定义（XRDs）*和*组合资源（XRs）*。
- en: Figure 5.6 shows how you can use Crossplane XRD to define abstractions for different
    cloud providers. The platform team might be very knowledgeable in Google Cloud
    or Azure, so they will be in charge of defining which Resources they want to wire
    up together for a specific application. The application team has a simple resource
    interface to request the resource they are interested in. But as usual, abstractions
    are complicated and good to show who is responsible for what, but let’s look at
    a concrete example to understand the power of Crossplane compositions.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6展示了如何使用Crossplane XRD为不同的云服务提供商定义抽象。平台团队可能非常了解Google Cloud或Azure，因此他们将负责定义针对特定应用程序需要连接在一起的具体资源。应用团队有一个简单的资源接口来请求他们感兴趣的资源。但正如通常情况一样，抽象是复杂的，有助于展示谁负责什么，但让我们通过一个具体例子来了解Crossplane组合的强大功能。
- en: '![](../../OEBPS/Images/05-06.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/05-06.png)'
- en: Figure 5.6 Resource composition abstractions by Crossplane composite resources
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6 通过Crossplane组合资源进行资源组合抽象
- en: Figure 5.7 shows how the application team can create a simple PostgreSQL resource
    to a provision in Google Cloud a CloudSQLInstance plus a network configuration
    and a bucket. The application team is interested in something other than what
    resources are created or even in which cloud provider they were created. They
    are only interested in having a PostgreSQL instance to connect their applications
    to.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7展示了应用团队如何创建一个简单的PostgreSQL资源，并在Google Cloud中配置一个CloudSQL实例，同时还需要网络配置和一个存储桶。应用团队对创建的资源类型或它们在哪个云服务提供商下创建并不感兴趣。他们只关心拥有一个PostgreSQL实例，以便将应用程序连接到它。
- en: '![](../../OEBPS/Images/05-07.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/05-07.png)'
- en: Figure 5.7 Provisioning a PostgreSQL instance in Google Cloud with Crossplane
    compositions
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7 使用Crossplane组合在Google Cloud中配置PostgreSQL实例
- en: This takes us to the `Secret` box in the figure, representing a Kubernetes secret
    that Crossplane will create for our application/services pods to connect to the
    provisioned resources. Crossplane creates this Kubernetes secret with all the
    details our applications require to connect to the newly created resources (or
    just with the one relevant to the application). This secret typically contains
    URLs, usernames, passwords, certificates, or anything required for your applications
    to connect. Platform teams define what will be included in the secret when defining
    the CompositeResources. In the following sections, when we add real infrastructure
    to our Conference application, we will explore how these `CompositeResourceDefinitions`
    look and how they can be applied to create all the components our applications
    need.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这将带我们到图中的 `Secret` 框，代表 Crossplane 将为我们应用程序/服务 pod 连接到已部署的资源而创建的 Kubernetes
    机密。Crossplane 使用所有应用程序连接到新创建的资源所需的所有详细信息创建此 Kubernetes 机密（或仅包含与应用程序相关的信息）。此机密通常包含
    URL、用户名、密码、证书或任何应用程序连接所需的内容。平台团队在定义复合资源时定义了机密中应包含的内容。在以下章节中，当我们向我们的会议应用程序添加真实的基础设施时，我们将探讨这些
    `CompositeResourceDefinitions` 的外观以及它们如何应用于创建我们应用程序所需的所有组件。
- en: 5.2.3 Crossplane components and requirements
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.3 Crossplane 组件和需求
- en: To work with Crossplane providers and `CompositeResourceDefinitions` we need
    to understand how Crossplane components will work together to provision and manage
    these components inside different cloud providers.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要与 Crossplane 提供程序和 `CompositeResourceDefinitions` 一起工作，我们需要了解 Crossplane 组件将如何协同工作以在不同的云提供商内部提供和管理这些组件。
- en: This section covers what Crossplane needs to work and how Crossplane components
    will manage our `CompositeResources`. First, it is important to understand that
    you must install Crossplane in a Kubernetes cluster. This can be the cluster where
    your applications run or a separate cluster where Crossplane will run. This cluster
    will have some Crossplane components that will understand our `CompositeResourceDefinitions`
    and have enough permissions on the cloud platform to provision resources on our
    behalf.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了 Crossplane 需要运行的方式以及 Crossplane 组件将如何管理我们的 `CompositeResources`。首先，重要的是要理解您必须在
    Kubernetes 集群中安装 Crossplane。这可以是运行您应用程序的集群，也可以是 Crossplane 将运行的单独集群。此集群将包含一些 Crossplane
    组件，它们将理解我们的 `CompositeResourceDefinitions` 并在云平台上拥有足够的权限代表我们提供资源。
- en: '![](../../OEBPS/Images/05-08.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/05-08.png)'
- en: Figure 5.8 Crossplane in Google Cloud Platform
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8 Google Cloud Platform 中的 Crossplane
- en: Figure 5.8 shows Crossplane installed inside a Kubernetes cluster, with the
    Crossplane GCP provider installed and configured to use a Google Cloud Platform
    account with enough rights to provision PostgreSQL and Redis instances. This means
    having, in some cases, admin access to create resources on the cloud provider.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8 展示了 Crossplane 在 Kubernetes 集群内部安装的情况，其中已安装并配置了 Crossplane GCP 提供程序，以使用具有足够权限来部署
    PostgreSQL 和 Redis 实例的 Google Cloud Platform 账户。这意味着在某些情况下，您将拥有在云提供商上创建资源的管理员访问权限。
- en: 'For figure 5.8 to work in GCP, you need the following configurations on the
    cloud provider:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使图 5.8 在 GCP 中正常工作，您需要在云提供商上进行以下配置：
- en: For creating a Redis instance in GCP.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 GCP 中创建 Redis 实例。
- en: Your GCP project needs to have the `redis.googleapis.com` APIs enabled.
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的 GCP 项目需要启用 `redis.googleapis.com` API。
- en: You also need to have admin rights on the Redis resources `roles/redis.admin`.
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您还需要对 Redis 资源拥有管理员权限 `roles/redis.admin`。
- en: 'For creating a PostgreSQL instance in GCP:'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 GCP 中创建 PostgreSQL 实例：
- en: Your GCP project needs to have the `sqladmin.googleapis.com` APIs enabled.
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的 GCP 项目需要启用 `sqladmin.googleapis.com` API。
- en: You also need to have admin rights on the SQL resources `roles/cloudsql.admin`.
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您还需要对 SQL 资源 `roles/cloudsql.admin` 拥有管理员权限。
- en: 'Each Crossplane provider available requires a specific security configuration
    to work and an account inside the cloud provider where we want to create resources.
    Once a Crossplane provider is installed and configured (in this case, the GCP
    provider) we can start creating resources managed by this provider. You can find
    the resources offered by each provider on the following documentation site: [https://doc.crds.dev/github.com/crossplane/provider-gcp](https://doc.crds.dev/github.com/crossplane/provider-gcp)
    (figure 5.9).'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 每个可用的 Crossplane 提供程序都需要特定的安全配置才能工作，并在我们想要创建资源的云提供商内部有一个账户。一旦安装并配置了 Crossplane
    提供程序（在本例中为 GCP 提供程序），我们就可以开始创建由该提供程序管理的资源。您可以在以下文档网站上找到每个提供程序提供的资源：[https://doc.crds.dev/github.com/crossplane/provider-gcp](https://doc.crds.dev/github.com/crossplane/provider-gcp)（图
    5.9）。
- en: '![](../../OEBPS/Images/05-09.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/05-09.png)'
- en: Figure 5.9 Crossplane GCP–supported resources
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9 Crossplane 支持的 GCP 资源
- en: As you can see in the previous figure, the GCP provider version 0.22.0 supports
    29 different CRDs (Custom Resource Definitions) for creating resources in the
    Google Cloud Platform. Crossplane defines each of these resources as managed resources.
    Each of these managed resources will need to be enabled for the Crossplane provider
    to have access to the list, create, and modify these resources.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，GCP 提供者版本 0.22.0 支持 29 个不同的 CRD（自定义资源定义），用于在 Google Cloud Platform 中创建资源。Crossplane
    将这些资源定义为托管资源。每个托管资源都需要启用，以便 Crossplane 提供者能够访问列表、创建和修改这些资源。
- en: In section 5.3, we will look at how to provision cloud or local resources for
    our applications using different Crossplane providers and Crossplane compositions.
    Before jumping into the technical aspects, let’s look at Crossplane core behaviors
    that you should look for when working with tools in the Kubernetes space.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 5.3 节中，我们将探讨如何使用不同的 Crossplane 提供者和 Crossplane 组合为我们的应用程序配置云或本地资源。在深入技术细节之前，让我们看看在使用
    Kubernetes 空间中的工具时应寻找的 Crossplane 核心行为。
- en: 5.2.4 Crossplane behaviors
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.4 Crossplane 行为
- en: 'In contrast to installing Helm components in our Kubernetes clusters, we use
    Crossplane to interact with the cloud provider-specific APIs to provision resources
    inside the cloud infrastructure. This should simplify the maintenance tasks and
    costs related to these resources. Another important difference is that the Crossplane
    provider (GCP provider in this case) will observe the created managed resources
    for us. These managed resources offer some advantages compared with just installed
    resources using Helm. Managed resources have very well-defined behaviors. Here
    is a summary of what to expect from a Crossplane managed resource:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 与在我们的 Kubernetes 集群中安装 Helm 组件相比，我们使用 Crossplane 与云提供者特定的 API 交互，以在云基础设施内部配置资源。这应该简化与这些资源相关的维护任务和成本。另一个重要的区别是，Crossplane
    提供者（在本例中为 GCP 提供者）将为我们观察创建的托管资源。与仅使用 Helm 安装的资源相比，这些托管资源提供了一些优势。托管资源具有非常明确的行为。以下是您可以从
    Crossplane 托管资源中期待的内容摘要：
- en: '*Visible as any other Kubernetes resource:* Crossplane managed resources are
    just Kubernetes resources. This means that we can use any Kubernetes tool to monitor
    and query the state of these resources.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*与其他 Kubernetes 资源一样可见:* Crossplane 托管资源只是 Kubernetes 资源。这意味着我们可以使用任何 Kubernetes
    工具来监控和查询这些资源的状态。'
- en: '*Continuous reconciliation:* When a managed resource is created, the provider
    will continuously monitor the resource to ensure it exists and is working and
    report back the status to the Kubernetes resource. The parameters defined inside
    the managed resource are considered the desired state (source of truth) and Crossplane
    providers will work to apply these configurations to the cloud provider resources.
    Once again, we can use standard Kubernetes tools to monitor changes in state and
    trigger remediation flows.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*持续同步*: 当创建一个托管资源时，提供者将不断监控该资源以确保其存在且正在运行，并将状态报告给 Kubernetes 资源。托管资源内部定义的参数被认为是期望状态（真实来源）并且
    Crossplane 提供者将努力将这些配置应用到云提供者资源上。再次强调，我们可以使用标准的 Kubernetes 工具来监控状态变化并触发修复流程。'
- en: '*Immutable properties*Providers are in charge of reporting back if a user manually
    changes properties in the cloud provider. The idea here is to avoid configuration
    drifts from what was defined to what is running in the cloud provider. If so,
    the state is reported back to the managed resource. Crossplane will not delete
    the cloud provider resource but will notify back so actions can be taken. Other
    tools like Terraform ([https://www.terraform.io](https://www.terraform.io)) will
    automatically delete the remote resources to recreate them.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*不可变属性* 提供者负责报告用户是否手动更改了云提供者的属性。这里的想法是避免配置漂移，即从定义的状态到云提供者中运行的实际状态。如果是这样，状态将被报告回托管资源。Crossplane
    不会删除云提供者资源，而是会通知以便采取行动。其他工具如 Terraform ([https://www.terraform.io](https://www.terraform.io))
    将自动删除远程资源以重新创建它们。'
- en: '*Late initialization:* Some properties in the managed resources can be optional,
    meaning each provider will select the default values for these properties. When
    this happens, Crossplane creates the resource with the default values and then
    sets the selected values into the managed resource. This simplifies the configuration
    needed to create resources and reuse the sensible defaults defined by cloud providers,
    usually in their user interfaces.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*延迟初始化:* 托管资源中的一些属性可能是可选的，这意味着每个提供程序将为这些属性选择默认值。当这种情况发生时，Crossplane 将使用默认值创建资源，然后将选定的值设置到托管资源中。这简化了创建资源所需的配置，并可以重用云提供商定义的合理默认值，通常在他们的用户界面中。'
- en: '*Deletion:* When deleting a managed resource, the cloud provider immediately
    triggers the action. However, the managed resource is kept until the resource
    is fully removed from the cloud provider. Errors that might happen during deletion
    on the cloud provider will be added to the managed resource status field.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*删除:* 当删除托管资源时，云提供商将立即触发操作。然而，托管资源将保留，直到资源完全从云提供商中移除。在云提供商上删除过程中可能发生的错误将被添加到托管资源状态字段中。'
- en: '*Importing existing resources:* Crossplane doesn’t necessarily need to create
    the resources to manage them. You can create managed resources that start monitoring
    components created before Crossplane was installed. You can achieve this using
    a specific Crossplane annotation on the managed resource: `crossplane.io/external-name`.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*导入现有资源:* Crossplane 不一定需要创建资源来管理它们。您可以为之前安装 Crossplane 之前创建的组件创建托管资源，并开始监控它们。您可以使用托管资源上的特定
    Crossplane 注释来实现这一点：`crossplane.io/external-name`。'
- en: To summarize the interactions between Crossplane, the Crossplane GCP provider,
    and our managed resources, let’s look at figure 5.10.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结 Crossplane、Crossplane GCP 提供程序和我们的托管资源之间的交互，让我们看看图 5.10。
- en: '![](../../OEBPS/Images/05-10.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/05-10.png)'
- en: Figure 5.10 Lifecycle of managed resources with Crossplane
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10 使用 Crossplane 的托管资源生命周期
- en: 'The following points indicate the sequence observed in figure 5.10:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的点表明了图 5.10 中观察到的顺序：
- en: First, we need to create a resource. We can use any tool to create Kubernetes
    resources; `kubectl` here is just an example.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个资源。我们可以使用任何工具来创建 Kubernetes 资源；这里的 `kubectl` 只是一个例子。
- en: If the created resource is a Crossplane managed resource, let’s imagine a CloudSQLInstance
    resource the GCP Crossplane provider will pick up and manage.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果创建的资源是 Crossplane 托管资源，让我们想象一个 GCP Crossplane 提供程序将选择并管理的 CloudSQLInstance
    资源。
- en: The first step to execute when managing a resource will be checking if it exists
    in the infrastructure (that is, in the configured GCP account). If it doesn’t
    exist, the provider will request that the resource be created in the infrastructure.
    The appropriate SQL database will be provisioned depending on the properties set
    on the resource, such as which kind of SQL database is required. Imagine that
    we have chosen a PostgreSQL database for the sake of the example.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 管理资源的第一步将是检查它是否存在于基础设施中（即在配置的 GCP 账户中）。如果不存在，提供程序将请求在基础设施中创建该资源。将根据资源上设置的属性（例如所需的
    SQL 数据库类型）提供适当的 SQL 数据库。假设我们为了示例的目的选择了 PostgreSQL 数据库。
- en: The cloud provider, after receiving the request, if the resources are enabled,
    will create a new PostgreSQL instance with the configured parameters in the managed
    resource.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 云提供商在收到请求后，如果资源已启用，将在托管资源中配置的参数下创建一个新的 PostgreSQL 实例。
- en: The status of the PostgreSQL will be reported back to the managed resource,
    which means that we can use `kubectl` or any other tool to monitor the status
    of the provisioned resources. Crossplane providers will keep these in sync.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PostgreSQL 的状态将被报告回托管资源，这意味着我们可以使用 `kubectl` 或其他任何工具来监控已配置资源的状态。Crossplane 提供程序将保持这些状态同步。
- en: When the database is up and running, the Crossplane provider will create a secret
    to store the credentials and properties that our applications will need to connect
    to the newly created instance.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当数据库运行起来后，Crossplane 提供程序将创建一个密钥来存储我们的应用程序连接到新创建的实例所需的凭据和属性。
- en: Crossplane will regularly check the status of the PostgreSQL instance and update
    the managed resource.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Crossplane 将定期检查 PostgreSQL 实例的状态，并更新托管资源。
- en: By following Kubernetes design patterns, Crossplane uses the reconciliation
    cycle implemented by controllers to keep track of external resources. Let’s see
    this in action! The following section will examine how we can use Crossplane with
    our walking skeleton application.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循Kubernetes设计模式，Crossplane使用控制器实现的reconciliation周期来跟踪外部资源。让我们看看这是如何付诸实践的！以下部分将探讨我们如何使用Crossplane与我们的行走骨架应用一起工作。
- en: 5.3 Infrastructure for our walking skeleton
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3 我们行走骨架的基础设施
- en: In this section, we will use Crossplane to abstract away how we provision infrastructure
    for our Conference application. Because you might not have access to a cloud provider
    like GCP, AWS, or Azure, we will work with a special provider called the Crossplane
    Helm provider. This Crossplane Helm provider allows us to manage Helm Charts as
    cloud resources. The idea here is to show how using Crossplane—more specifically,
    using Crossplane compositions—we can enable users to request resources using a
    simplified Kubernetes resource to provision local or different cloud resources
    (hosted in different cloud providers).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用Crossplane来抽象化我们为会议应用提供基础设施的方式。由于您可能无法访问像GCP、AWS或Azure这样的云提供商，我们将与一个名为Crossplane
    Helm provider的特殊提供商一起工作。这个Crossplane Helm provider允许我们将Helm图表作为云资源进行管理。这里的想法是展示如何使用Crossplane——更具体地说，使用Crossplane组合——来使用户能够使用简化的Kubernetes资源请求资源，以提供本地或不同云提供商托管的不同云资源。
- en: For our Conference application, we need Redis, PostgreSQL, and Kafka instances.
    From the application perspective, as soon as these three components are available,
    we can connect to them, and we are good to go. How these components are configured
    is the responsibility of the operations teams.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了我们的会议申请，我们需要Redis、PostgreSQL和Kafka实例。从应用的角度来看，一旦这三个组件可用，我们就可以连接到它们，然后就可以开始了。这些组件如何配置是运维团队的责任。
- en: 'The conference application helm chart that we installed in chapter 2 included
    the installation of Redis, PostgreSQL, and Kafka as Helm dependencies using a
    conditional value that can be set at installation time. Let’s take a quick look
    at how this was wired up for our Helm Chart: [https://github.com/salaboy/platforms-on-k8s/blob/main/conference-application/helm/conference-app/Chart.yaml#L13](https://github.com/salaboy/platforms-on-k8s/blob/main/conference-application/helm/conference-app/Chart.yaml#L13).'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第2章中安装的会议应用Helm图表包括了使用安装时可以设置的条件值将Redis、PostgreSQL和Kafka作为Helm依赖项安装。让我们快速看一下这是如何为我们的Helm图表配置的：[https://github.com/salaboy/platforms-on-k8s/blob/main/conference-application/helm/conference-app/Chart.yaml#L13](https://github.com/salaboy/platforms-on-k8s/blob/main/conference-application/helm/conference-app/Chart.yaml#L13)。
- en: The Conference Helm Chart includes the Redis, PostgreSQL, and Kafka charts dependencies,
    as shown in listing 5.5.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 会议Helm图表包括了Redis、PostgreSQL和Kafka图表依赖项，如列表5.5所示。
- en: Listing 5.5 Conference application with Helm Chart dependencies
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.5 使用Helm图表依赖项的会议应用
- en: '[PRE3]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ① You can include any number of dependencies to your Helm Charts. This allows
    complex compositions.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ① 您可以为您的Helm图表包含任意数量的依赖项。这允许复杂的组合。
- en: ② Each dependency requires the chart name, the repository where it is hosted
    (notice that you can use oci:// references here too), and the version of the chart
    that you want to install.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ② 每个依赖项都需要图表名称、它所在的存储库（注意，您也可以在这里使用oci://引用），以及您想要安装的图表版本。
- en: ③ Custom conditions can be defined to decide if this dependency is injected
    when we install the chart.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 可以定义自定义条件来决定在安装图表时是否注入此依赖项。
- en: For this example, all the application infrastructure dependencies are defined
    at the application level (dependencies section in the Chart.yaml file), but there
    is nothing stopping you from having one Helm Chart per service, which internally
    defines its own dependencies.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，所有应用基础设施依赖项都在应用级别定义（在Chart.yaml文件的依赖项部分），但这并不妨碍你为每个服务创建一个Helm图表，该图表内部定义了自己的依赖项。
- en: This kind of chart dependency works for development teams that want to install
    the entire application with all the components needed with a single command. Still,
    we want to decouple all the application infrastructural concerns from application
    services for larger scenarios. Luckily, the Conference application Helm Chart
    allows us to turn off these component dependencies, allowing us to plug in Redis,
    PostgreSQL, and Kafka instances hosted and managed by different teams (figure
    5.11).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这种图表依赖关系适用于希望使用单个命令安装整个应用程序及其所需所有组件的开发团队。然而，我们希望将所有应用程序基础设施的关注点与应用程序服务解耦，以适应更大的场景。幸运的是，Conference应用程序Helm图表允许我们关闭这些组件依赖关系，从而允许我们将由不同团队托管和管理的Redis、PostgreSQL和Kafka实例插入（如图5.11）。
- en: '![](../../OEBPS/Images/05-11.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/05-11.png)'
- en: Figure 5.11 Using Helm Chart dependencies for application infrastructure
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.11 使用Helm图表依赖关系进行应用程序基础设施
- en: 'By separating who requests and who provisions the application’s infrastructure
    components, we enable different teams to control and manage when these components
    are updated, backed up, or how they need to be restored in case of failure. By
    using Crossplane, we can enable teams to request these databases on demand, which
    then can be connected to our application’s services. One important aspect of the
    mechanisms we will use in the next sections is that the components we request
    can be provisioned locally (using the Crossplane Helm provider) or remotely using
    Crossplane cloud providers. Let’s see what this would look like. You can follow
    a step-by-step tutorial to install, configure, and create your Crossplane compositions:
    [https://github.com/salaboy/platforms-on-k8s/tree/main/chapter-5](https://github.com/salaboy/platforms-on-k8s/tree/main/chapter-5).'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 通过分离谁请求和谁提供应用程序基础设施组件，我们使不同的团队能够控制和管理这些组件何时更新、备份，或者在发生故障时如何恢复。通过使用Crossplane，我们可以使团队能够按需请求这些数据库，然后可以将它们连接到我们的应用程序服务。我们将在下一节中使用的机制的一个重要方面是，我们请求的组件可以在本地（使用Crossplane
    Helm提供程序）或远程（使用Crossplane云提供程序）进行配置。让我们看看这会是什么样子。您可以遵循一个逐步教程来安装、配置和创建您的Crossplane组合：[https://github.com/salaboy/platforms-on-k8s/tree/main/chapter-5](https://github.com/salaboy/platforms-on-k8s/tree/main/chapter-5)。
- en: In this example, we will create a KinD cluster and configure Crossplane to allow
    teams to request application infrastructure on demand using the Crossplane Helm
    provider for development purposes. In production the same requests will be satisfied
    via scalable cloud resources. More specifically, we enable teams to request Redis,
    PostgreSQL, and Kafka instances this way using a simplified interface.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将创建一个KinD集群并配置Crossplane，以便团队可以使用Crossplane Helm提供程序按需请求开发目的的应用程序基础设施。在生产环境中，相同的请求将通过可扩展的云资源得到满足。更具体地说，我们通过这种方式使团队能够使用简化的接口请求Redis、PostgreSQL和Kafka实例。
- en: 'For our Conference application example, the platform team decided to create
    two different concepts:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的Conference应用程序示例，平台团队决定创建两个不同的概念：
- en: '*Databases:* NoSQL and SQL databases such as Redis and PostgreSQL.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数据库:* 如Redis和PostgreSQL之类的NoSQL和SQL数据库。'
- en: '*Message brokers:* For managed and unmanaged message brokers such as Kafka.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*消息代理:* 用于管理和未管理的消息代理，如Kafka。'
- en: 'After having Crossplane and the Crossplane Helm provider installed, the platform
    team needs to define two Kubernetes resources:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装了Crossplane和Crossplane Helm提供程序之后，平台团队需要定义两个Kubernetes资源：
- en: '*Crossplane Composite Resource Definitions (XRDs):* Defines the resources we
    want to expose to our teams—in this example, Database and MessageBroker. These
    Composite Resource Definitions define an interface that multiple Compositions
    can implement.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*交叉平面复合资源定义（XRDs）:* 定义了我们希望向团队公开的资源——在这个例子中，是数据库和消息代理。这些复合资源定义定义了一个接口，多个组合可以实现。'
- en: '*Crossplane composition:* The Crossplane composition allows us to define a
    set of resource manifests. We can link a composition to a Composite Resource Definition
    and implement that XRD. By doing so, when the user requests new resources from
    the XRD–defined resource, all the composed resource manifests in the composition
    will be created in the cluster. We can provide multiple compositions (for example
    for different cloud providers), all implementing the same XRD, and then use labels
    in our resources to choose which composition should kick in.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Crossplane 组合*：Crossplane 组合允许我们定义一组资源清单。我们可以将一个组合链接到组合资源定义并实现该 XRD。通过这样做，当用户从
    XRD 定义的资源请求新资源时，组合中的所有组合资源清单将在集群中创建。我们可以提供多个组合（例如，针对不同的云提供商），所有这些组合都实现了相同的 XRD，然后使用资源中的标签来选择哪个组合应该启动。'
- en: I know this might sound confusing at first, so let’s see these concepts in action.
    Let’s look at the database Crossplane Composite Resource Definition ([https://github.com/salaboy/platforms-on-k8s/blob/main/chapter-5/resources/app-database-resource.yaml](https://github.com/salaboy/platforms-on-k8s/blob/main/chapter-5/resources/app-database-resource.yaml))
    in listing 5.6.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道一开始这可能会听起来有些令人困惑，所以让我们看看这些概念在实际中的应用。让我们看看列表 5.6 中的数据库 Crossplane 组合资源定义（[https://github.com/salaboy/platforms-on-k8s/blob/main/chapter-5/resources/app-database-resource.yaml](https://github.com/salaboy/platforms-on-k8s/blob/main/chapter-5/resources/app-database-resource.yaml)）。
- en: Listing 5.6 Database Composite Resource Definition
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.6 数据库组合资源定义
- en: '[PRE4]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ① As with every Kubernetes resource, the CompositeResourceDefinition needs a
    unique name.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ① 就像每个 Kubernetes 资源一样，CompositeResourceDefinition 需要一个唯一的名称。
- en: ② This CompositeResourceDefinition defines a new type of resource that needs
    to have a group and a kind.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ② 本 CompositeResourceDefinition 定义了一种新的资源类型，该类型需要有一个组和一种类型。
- en: ③ Our new resource type that users can request is Database, because we want
    to enable them to request new databases.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们为用户可以请求的新资源定义了一个新的资源类型，即数据库，因为我们希望让他们能够请求新的数据库。
- en: '④ The new resource we are defining can also define custom parameters. For this
    example, and only for demonstration purposes, we are defining only two: size and
    mockData.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 我们正在定义的新资源也可以定义自定义参数。在这个例子中，仅用于演示目的，我们只定义了两个：size 和 mockData。
- en: ⑤ Because the Kubernetes API server can validate all resources, we can define
    which parameters are required and their types and other validations. The Kubernetes
    API server will reject our resource request if these parameters are not provided
    or invalid.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 因为 Kubernetes API 服务器可以验证所有资源，所以我们可以定义哪些参数是必需的，它们的类型以及其他验证。如果这些参数未提供或无效，Kubernetes
    API 服务器将拒绝我们的资源请求。
- en: We have defined a new type of resource called a Database, which contains two
    parameters that we can set, `size` and `mockData`. Users can define how many resources
    are allocated for that instance by setting up the `size` parameter. Instead of
    worrying about how much storage they will need or how many replicas they need
    for the database instances, they can simply specify a size from a list of possible
    values (small, medium, or large). Using the `mockData` parameters, you can implement
    a mechanism to inject data into the instance when needed. This is just an example
    of what can be done, but it is up to you to define these interfaces and what parameters
    make sense to your teams.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一种名为数据库的新资源类型，其中包含两个我们可以设置的参数，`size` 和 `mockData`。用户可以通过设置 `size` 参数来定义为该实例分配多少资源。他们不必担心需要多少存储空间或需要多少副本来为数据库实例提供服务，他们只需从可能值列表（小、中或大）中指定一个大小即可。使用
    `mockData` 参数，您可以在需要时实现向实例注入数据的机制。这只是一个可以做到的例子，但定义这些接口和哪些参数对您的团队有意义取决于您。
- en: Let’s see what the Crossplane composition looks like that will implement this
    XRD, in listing 5.7.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实现此 XRD 的 Crossplane 组合在列表 5.7 中的样子。
- en: Listing 5.7 Key/value Database Crossplane composition
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.7 关键/值数据库 Crossplane 组合
- en: '[PRE5]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ① The composition resource also needs a unique name.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ① 组合资源还需要一个唯一的名称。
- en: ② For each composition, we can also define labels. We will then use these to
    match compositions with the requested Database resources.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ② 对于每个组合，我们还可以定义标签。然后我们将使用这些标签来匹配请求的数据库资源。
- en: ③ Using the compositeTypeRef property, we are linking Database CompositeResourceDefinition
    to this composition.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 通过使用 compositeTypeRef 属性，我们将数据库组合资源定义链接到这个组合。
- en: ④ Inside the resources array, we can define all the resources this composition
    will provision. It is quite common to have more than one resource here. For this
    example, we are configuring a single resource of type Release defined in the Crossplane
    Helm provider.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 在资源数组内部，我们可以定义这个组合将配置的所有资源。在这里有多个资源是很常见的。在这个例子中，我们正在配置Crossplane Helm提供者中定义的单一类型的Release资源。
- en: ⑤ We need to provide the values defined for the Release resource, in this case,
    the Helm Chart details that we want to install using the Crossplane Helm provider.
    As you can see, we are pointing to the Redis Helm Chart hosted by Bitnami.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 我们需要提供为Release资源定义的值，在这种情况下，是我们想使用Crossplane Helm提供者安装的Helm图表的详细信息。正如你所见，我们指向由Bitnami托管的Redis
    Helm图表。
- en: ⑥ Using the providerConfigRef, we can target different Crossplane Helm provider
    configurations. This means we can have different Helm providers pointing to different
    target clusters, and this composition can select which one to use. For the sake
    of simplicity, this composition uses the default configuration for the local Helm
    provider installation.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用providerConfigRef，我们可以针对不同的Crossplane Helm提供者配置进行定位。这意味着我们可以拥有指向不同目标集群的不同Helm提供者，并且这种组合可以选出使用哪一个。为了简化，这个组合使用了本地Helm提供者安装的默认配置。
- en: ⑦ Because we are wiring multiple resources, we can patch resources to configure
    them to work together or to apply the parameters of the requested resource. Check
    the Crossplane documentation for more details on what can be achieved with these
    mechanisms.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们在连接多个资源，我们可以修补资源以配置它们协同工作或应用请求资源的参数。请查阅Crossplane文档以获取更多关于这些机制可以实现的内容的详细信息。
- en: ⑧ For each composition, we can define a condition to flag the resource status.
    For this example, we will mark the composition as ready when the Helm Release
    resource status .atProvider.state property is set to deployed. If you are provisioning
    multiple resources, you, as the person defining the composition, will need to
    define what this condition is.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 对于每个组合，我们可以定义一个条件来标记资源状态。在这个例子中，我们将组合标记为就绪状态，当Helm Release资源状态.atProvider.state属性设置为已部署时。如果你正在配置多个资源，作为定义组合的人，你需要定义这个条件是什么。
- en: With this composition, we link our `Database` claim with a set of resources,
    in this case, installing the Redis Helm Chart using the default Helm provider
    we installed with Crossplane in our Kubernetes cluster. Figure 5.12 shows two
    user requests for the same database type.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个组合，我们将我们的`Database`声明与一组资源相连接，在这种情况下，是使用我们在Kubernetes集群中与Crossplane一起安装的默认Helm提供者安装Redis
    Helm图表。图5.12显示了针对相同数据库类型的两个用户请求。
- en: '![](../../OEBPS/Images/05-12.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/05-12.png)'
- en: Figure 5.12 Crossplane composition and Composite Resource Definition working
    together
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.12 Crossplane组合和组合资源定义协同工作
- en: It is important to note that this Helm Chart will be installed in the same Kubernetes
    cluster where Crossplane is installed. Still, nothing stops us from configuring
    the Helm provider to have the right credentials to install charts to a completely
    different cluster.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，这个Helm图表将安装在安装Crossplane的同一Kubernetes集群中。尽管如此，我们仍然可以配置Helm提供者，使其拥有正确的凭证来安装图表到完全不同的集群。
- en: In the step-by-step tutorial ([https://github.com/salaboy/platforms-on-k8s/tree/main/chapter-5](https://github.com/salaboy/platforms-on-k8s/tree/main/chapter-5)),
    you will install the three Composite Resource Definitions and three compositions.
    Once these are installed, as shown in figure 5.12, you can request new databases
    and message brokers, and for every request, all the resources defined in the composition
    will be provisioned. For the sake of simplicity, the key-value database composition
    just installs Redis, but there are no limits on how many resources you can create
    (except for the available hardware or quotas you have).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在逐步教程([https://github.com/salaboy/platforms-on-k8s/tree/main/chapter-5](https://github.com/salaboy/platforms-on-k8s/tree/main/chapter-5))中，你将安装三个组合资源定义和三个组合。一旦安装完成，如图5.12所示，你可以请求新的数据库和消息代理，并且对于每个请求，组合中定义的所有资源都将被配置。为了简化，键值数据库组合仅安装Redis，但你可以创建的资源数量没有限制（除了可用的硬件或配额）。
- en: A `Database` resource is just another Kubernetes resource that now our cluster
    understands, and it looks like listing 5.8.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`Database`资源只是另一个Kubernetes资源，现在我们的集群理解它，看起来像列表5.8。'
- en: Listing 5.8 Teams create database resources to request new database instances
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.8 团队创建数据库资源以请求新的数据库实例
- en: '[PRE6]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ① The unique name for the resource
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ① 资源的唯一名称
- en: ② We use matchLabels to select the appropriate composition.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们使用 matchLabels 来选择合适的组成。
- en: ③ We need to set the parameters that are required by our Database resource claim.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们需要设置我们的数据库资源声明所需的参数。
- en: The schema for this Database resource is defined inside the Crossplane `CompositeResourceDefinition`.
    Notice that the `spec.compositionSelector.matchLabels` matches with the labels
    used for the composition. We can use this mechanism to select a different composition
    for the same Database definition.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数据库资源的模式定义在 Crossplane 的 `CompositeResourceDefinition` 内部。注意 `spec.compositionSelector.matchLabels`
    与用于组成的标签相匹配。我们可以使用这个机制为相同的数据库定义选择不同的组成。
- en: If you are following the step-by-step tutorial, try to create multiple resources
    and look at the Crossplane official documentation to understand how to implement
    parameters like `small` or `mockData` because these values are not being used
    yet and only serve for demonstration purposes.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在按照逐步教程进行，尝试创建多个资源，并查看 Crossplane 官方文档以了解如何实现 `small` 或 `mockData` 等参数，因为这些值目前尚未使用，仅用于演示目的。
- en: The real power of these mechanisms comes when you have different compositions
    (implementations) for the same interface (Composite Resource Definition). For
    example, we can now create another composition to provision PostgreSQL instances
    for the Call for Proposals service, as shown in listing 5.9\. The PostgreSQL composition
    will look similar to the one for Redis, but it will install the PostgreSQL helm
    chart instead.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这些机制的真正力量在于当你为相同的接口（复合资源定义）有不同的组成（实现）时。例如，我们现在可以创建另一个组成来为提案请求服务提供 PostgreSQL
    实例，如列表 5.9 所示。PostgreSQL 的组成将类似于 Redis 的，但它将安装 PostgreSQL Helm 图表。
- en: Listing 5.9 SQL Database Crossplane Composition
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.9 SQL 数据库 Crossplane 组成
- en: '[PRE7]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ① We need a unique name for our composition, so we can differentiate it from
    the keyvalue composition that we used for Redis.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们需要一个唯一的名称来区分我们的组成与之前用于 Redis 的 keyvalue 组成。
- en: ② We use a different label to describe this composition, notice that the provider
    is the same as before.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们使用不同的标签来描述这个组成，注意提供者与之前相同。
- en: ③ We want to install the PostgreSQL Helm Chart hosted by Bitnami.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们想要安装由 Bitnami 托管的 PostgreSQL Helm 图表。
- en: Let’s look at how to create a PostgreSQL instance using this composition. Creating
    a PostgreSQL instance will look pretty similar to what we did before for Redis,
    as shown in listing 5.10\.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用这个组成创建一个 PostgreSQL 实例。创建 PostgreSQL 实例的过程将非常类似于我们之前为 Redis 所做的，如列表
    5.10 所示。
- en: 'Listing 5.10 Database resource with kind: `sql` label to select implementation'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5.10 使用 kind: `sql` 标签选择实现的数据库资源'
- en: '[PRE8]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ① The unique name used for the PostgreSQL database.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ① 用于 PostgreSQL 数据库的唯一名称。
- en: ② We use the “sql” label to match the previously defined composition.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们使用“sql”标签来匹配之前定义的组成。
- en: We are just using labels to select which composition will be triggered for our
    Database resource. Figure 5.13 shows these concepts in action. Notice how labels
    select the right composition based on the `kind` label value.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是使用标签来选择哪个组成将触发我们的数据库资源。图 5.13 展示了这些概念在实际中的应用。注意标签是如何根据 `kind` 标签值选择正确的组成的。
- en: '![](../../OEBPS/Images/05-13.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/05-13.png)'
- en: Figure 5.13 Selecting compositions using labels
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.13 使用标签选择组成
- en: Hooray! We can create databases! But of course, this doesn’t stop here. If you
    have access to a cloud provider, you can provide compositions that create database
    instances inside the cloud provider, and this is where Crossplane shines.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 哈喽！我们可以创建数据库了！但当然，这并没有结束。如果你可以访问云提供商，你可以在云提供商内部提供创建数据库实例的组成，这正是 Crossplane 发挥其优势的地方。
- en: 'If we use the Google Cloud Platform (GCP) as an example, for compositions that
    use cloud resources from GCP, you will need to install the Crossplane GCP provider
    and configure it accordingly, as explained in the official Crossplane documentation:
    [https://docs.crossplane.io/latest/getting-started/provider-gcp/](https://docs.crossplane.io/latest/getting-started/provider-gcp/).'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们以 Google Cloud Platform (GCP) 为例，对于使用 GCP 云资源的组成，你需要安装 Crossplane GCP 提供者并相应地配置它，如官方
    Crossplane 文档中所述：[https://docs.crossplane.io/latest/getting-started/provider-gcp/](https://docs.crossplane.io/latest/getting-started/provider-gcp/)。
- en: '![](../../OEBPS/Images/05-14.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/05-14.png)'
- en: Figure 5.14 Selecting compositions using different providers, still using labels
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.14 使用不同提供者选择组成，仍然使用标签
- en: We can still select different providers by matching labels with our desired
    composition. By changing a label in figure 5.14, we can use the local Helm Provider
    or the GCP provider to instantiate a Redis Instance.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然可以通过匹配标签与我们的期望组合来选择不同的提供商。通过更改图 5.14 中的标签，我们可以使用本地 Helm 提供商或 GCP 提供商来实例化
    Redis 实例。
- en: Note Check the community–contributed AWS compositions for this example using
    the Crossplane AWS Provider at [https://github.com/salaboy/platforms-on-k8s/tree/main/chapter-5/aws](https://github.com/salaboy/platforms-on-k8s/tree/main/chapter-5/aws).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：检查使用 Crossplane AWS 提供商的社区贡献 AWS 组合，请参阅[https://github.com/salaboy/platforms-on-k8s/tree/main/chapter-5/aws](https://github.com/salaboy/platforms-on-k8s/tree/main/chapter-5/aws)。
- en: Then, creating new database resources that will be provisioned in the Google
    Cloud Platform will look like listing 5.11.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建将在 Google Cloud Platform 中部署的新数据库资源将类似于列表 5.11。
- en: Listing 5.11 Requesting a new SQL database
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.11 请求新的 SQL 数据库
- en: '[PRE9]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ① The unique name for our resource needs to be different from all the ones used
    before.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们资源的唯一名称需要与之前使用的所有名称都不同。
- en: '② The provider label selects the composition labeled with provider: gcp. In
    other words, with this label, we select where the database will be provisioned.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '② 提供者标签选择带有 provider: gcp 标签的组合。换句话说，使用这个标签，我们选择数据库将在哪里部署。'
- en: ③ The kind label allows us to select which kind of database we want to provision.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 类型标签允许我们选择我们想要部署哪种类型的数据库。
- en: No matter where our databases or other application infrastructure components
    are provisioned, we can connect our application’s services by following some conventions.
    We can use the resource name (for example, `my-db-cloud-sql`) to know which Kubernetes
    service will be used for service discovery. We can also use the created secret
    to obtain the credentials that we will need to connect.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们的数据库或其他应用程序基础设施组件在哪里部署，我们都可以通过遵循一些约定来连接我们的应用程序服务。我们可以使用资源名称（例如，`my-db-cloud-sql`）来了解将用于服务发现的
    Kubernetes 服务。我们还可以使用创建的密钥来获取我们需要的凭证。
- en: The step-by-step tutorial also provides a `CompositeResourceDefinition` for
    message brokers and a composition that installs the Kafka Helm chart that you
    can find at [https://github.com/salaboy/platforms-on-k8s/blob/main/chapter-5/resources/app-messagebroker-kafka.yaml](https://github.com/salaboy/platforms-on-k8s/blob/main/chapter-5/resources/app-messagebroker-kafka.yaml).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤分解教程还提供了一个用于消息代理的 `CompositeResourceDefinition`，以及一个安装 Kafka Helm 图表的组合，您可以在[https://github.com/salaboy/platforms-on-k8s/blob/main/chapter-5/resources/app-messagebroker-kafka.yaml](https://github.com/salaboy/platforms-on-k8s/blob/main/chapter-5/resources/app-messagebroker-kafka.yaml)找到它。
- en: One really important thing to consider for this example is that Google Cloud
    Platform doesn’t provide a managed Kafka service. This pushes your team to decide
    to replace Kafka when the application is going to be deployed on Google Cloud
    Platform, install and manage Kafka on Google Cloud compute or hire a third-party
    service. In the AWS example, we have a Kafka–managed service that we can use,
    so there is no need to change our application code. But still, wouldn’t it be
    nice to abstract away how we connect to these infrastructure services? More on
    this in chapter 7.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，一个非常重要的事情要考虑的是，Google Cloud Platform 不提供托管 Kafka 服务。这促使您的团队在应用程序部署到 Google
    Cloud Platform 时决定替换 Kafka，在 Google Cloud 计算上安装和管理 Kafka，或者雇佣第三方服务。在 AWS 的例子中，我们有一个可以使用的
    Kafka 管理服务，因此不需要更改我们的应用程序代码。但仍然，抽象出我们如何连接这些基础设施服务不是很好吗？关于这一点，请参阅第 7 章。
- en: Figure 5.15 shows how easy it is to provide a Composite Resource Definition
    for key/value databases that can be provisioned locally using Helm or managed
    by a cloud provider. But in the case of Kafka, it gets a bit trickier because
    you might need to integrate with a third-party service or take the lead in having
    a team to manage the Kafka instance(s).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.15 展示了为键值数据库提供复合资源定义的简便性，这些数据库可以使用 Helm 本地部署或由云服务提供商管理。但在 Kafka 的情况下，事情会变得稍微复杂一些，因为您可能需要集成第三方服务或领导一个团队来管理
    Kafka 实例。
- en: '![](../../OEBPS/Images/05-15.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/05-15.png)'
- en: Figure 5.15 Compositions push teams to define which Cloud services are available
    for our applications to use.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.15 组合推动团队定义哪些云服务可供我们的应用程序使用。
- en: Besides Kafka and Google Cloud Platform, your teams will need a strategy to
    deal with infrastructure across cloud providers, or at least make conscious choices
    about how to deal with situations like this. From the application’s services perspective,
    would you maintain two copies of the same service if you decide to swap Kafka
    and use Google PubSub instead? One includes the Kafka dependencies, and the other
    includes the Google GCP SDKs to connect to Google PubSub. If you only use Google
    PubSub, you lose the ability to run the application outside Google Cloud.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Kafka 和 Google Cloud Platform 之外，您的团队还需要一个策略来处理跨云提供商的基础设施，或者至少对如何处理这种情况做出有意识的选择。从应用程序服务的角度来看，如果您决定用
    Google PubSub 代替 Kafka，您会维护两个相同服务的副本吗？一个包含 Kafka 依赖项，另一个包含连接到 Google PubSub 的
    Google GCP SDK。如果您只使用 Google PubSub，您将失去在 Google Cloud 外运行应用程序的能力。
- en: 5.3.1 Connecting our services with the new provisioned infrastructure
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.1 将我们的服务与新的配置基础设施连接
- en: When we create new database or message broker resources, Crossplane will monitor
    the status of these Kubernetes resources against the status of the provisioned
    components inside the specific cloud provider, keeping them in sync and ensuring
    that the desired configurations are applied. This means that Crossplane will make
    sure that our databases and message brokers are up and running. If for some reason
    that changes, Crossplane will try to reapply the configurations that we requested
    until what we requested is up and running.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建新的数据库或消息代理资源时，Crossplane 将监控这些 Kubernetes 资源与特定云提供商内配置的组件的状态，保持它们同步，并确保应用了所需的配置。这意味着
    Crossplane 将确保我们的数据库和消息代理正在运行。如果由于某种原因发生变化，Crossplane 将尝试重新应用我们请求的配置，直到请求的内容运行起来。
- en: 'If we don’t have the application deployed in our KinD cluster, we can deploy
    it without installing PostgreSQL, Redis, and Kafka. As we have seen in chapter
    2, this can be disabled by setting one flag: `install.infrastructure=false`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有在我们的 KinD 集群中部署应用程序，我们可以不安装 PostgreSQL、Redis 和 Kafka 就部署它。正如我们在第 2 章中看到的，这可以通过设置一个标志来禁用：`install.infrastructure=false`：
- en: '[PRE10]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: I strongly recommend you check out the step-by-step tutorial that you can find
    at [https://github.com/salaboy/platforms-on-k8s/tree/main/chapter-5](https://github.com/salaboy/platforms-on-k8s/tree/main/chapter-5)
    to get your hands dirty with Crossplane and the Conference application. The best
    way to learn is by doing!
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议您查看位于 [https://github.com/salaboy/platforms-on-k8s/tree/main/chapter-5](https://github.com/salaboy/platforms-on-k8s/tree/main/chapter-5)
    的分步教程，以亲身体验 Crossplane 和 Conference 应用程序。最好的学习方式就是动手实践！
- en: If we just run this command, no components (Redis, PostgreSQL, or Kafka) will
    be provisioned by Helm. Still, the application’s services will not know where
    to connect to the Redis, PostgreSQL, and Kafka instances we created using our
    Crossplane compositions. We need to add more parameters to the application chart,
    so the services know where to connect. First, check which databases you have available
    in your cluster as in listing 5.12.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只运行这个命令，Helm 不会通过部署任何组件（Redis、PostgreSQL 或 Kafka）。然而，应用程序的服务将不知道如何连接到我们使用
    Crossplane 组合创建的 Redis、PostgreSQL 和 Kafka 实例。我们需要向应用程序图表中添加更多参数，以便服务知道连接的位置。首先，检查您的集群中可用的数据库，如列表
    5.12 所示。
- en: Listing 5.12 Listing all database resources
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.12 列出所有数据库资源
- en: '[PRE11]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The tutorial also guides you to create a MessageBroker and checks that you have
    one instance of that too, as in listing 5.13.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程还指导您创建一个消息代理，并检查您是否也拥有一个实例，如列表 5.13 所示。
- en: Listing 5.13 Listing all MessageBroker resources
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.13 列出所有消息代理资源
- en: '[PRE12]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Listing 5.14 shows the Kubernetes pods for our database instances and our message
    broker.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.14 显示了我们的数据库实例和消息代理的 Kubernetes Pod。
- en: Listing 5.14 Pods for our application infrastructure
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.14 我们的应用基础设施的 Pod
- en: '[PRE13]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Along with the pods, four Kubernetes secrets were created: two to store the
    Helm releases used by our Crossplane compositions and two containing our new databases
    passwords that our applications will need to use to connect (see listing 5.15).'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Pod 之外，还创建了四个 Kubernetes 机密：两个用于存储我们的 Crossplane 组合使用的 Helm 发布，另外两个包含我们新的数据库密码，我们的应用程序将需要使用这些密码来连接（请参阅列表
    5.15）。
- en: Listing 5.15 Kubernetes secrets containing credentials to connect to our Databases
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.15 包含连接到我们数据库的凭证的 Kubernetes 机密
- en: '[PRE14]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Take a look at the services available in the default namespace after we provisioned
    our databases, see Listing 5.16:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们配置了数据库之后，查看默认命名空间中可用的服务，请参阅列表 5.16：
- en: Listing 5.16 Custom values.yaml file to connect with new infrastructure
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.16 用于连接新基础设施的自定义 values.yaml 文件
- en: '[PRE15]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'With the database and message broker service names and secrets, we can configure
    our conference application chart to not only not deploy Redis, PostgreSQL, and
    Kafka but also to connect to the right instances by running the following command:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数据库和消息代理服务名称和机密，我们可以配置我们的会议应用程序图表，不仅不部署 Redis、PostgreSQL 和 Kafka，而且通过运行以下命令连接到正确的实例：
- en: '[PRE16]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Instead of setting all the parameters in the command, we are using a file for
    the values to be applied to the chart. For this example, the app-values.yaml file
    looks like listing 5.17.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是在命令中设置所有参数，而是使用一个文件来应用图表的值。在这个例子中，app-values.yaml 文件看起来像列表 5.17。
- en: Listing 5.17 Helm Chart customized values.yaml file
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.17 定制的 Helm 图表 values.yaml 文件
- en: '[PRE17]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ① We disable the Redis, PostgreSQL, and Kafka Helm dependencies. These components
    will not be installed when we install the application.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们禁用了 Redis、PostgreSQL 和 Kafka 的 Helm 依赖项。当我们安装应用程序时，这些组件将不会安装。
- en: ② We use the Kubernetes service created for our Kafka cluster to connect all
    the application services to the created instance. The same approach is used for
    Redis and PostgreSQL.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们使用为我们的 Kafka 集群创建的 Kubernetes 服务将所有应用程序服务连接到创建的实例。对于 Redis 和 PostgreSQL
    也采用相同的方法。
- en: ③ For both Redis and PostgreSQL, a Kubernetes secret is created by the composite
    resource. Our Helm Chart understands how to get the credentials from the secret,
    so we only need to specify the secret name.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 对于 Redis 和 PostgreSQL，通过组合资源创建 Kubernetes 机密。我们的 Helm 图表理解如何从机密中获取凭证，因此我们只需要指定机密名称。
- en: In this app-values.yaml file, we are not only turning off the Helm dependencies
    for PostgreSQL, Redis, and Kafka, but we are also configuring the variables needed
    for the services to connect to our newly provisioned databases. Notice that if
    the databases were created in a different namespace or with a different name,
    the `kafka.url`, `postgresql.host` and `redis.host` should contain the appropriate
    namespace in the fully qualified name of the service, for example, `my-db-sql-postgresql.default.svc.cluster.local`
    (where `default` is the namespace).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 app-values.yaml 文件中，我们不仅关闭了 PostgreSQL、Redis 和 Kafka 的 Helm 依赖项，而且还配置了服务连接到我们新配置的数据库所需的变量。请注意，如果数据库是在不同的命名空间或不同的名称下创建的，`kafka.url`、`postgresql.host`
    和 `redis.host` 应该包含服务完全限定名称中的适当命名空间，例如，`my-db-sql-postgresql.default.svc.cluster.local`（其中
    `default` 是命名空间）。
- en: Figure 5.16 shows the Conference application services connecting to the application
    infrastructure that was created with Crossplane. The boundaries between the developer
    realm and the platform team become more defined now, as developers interested
    in getting the infrastructure that they need have a set of options that are carefully
    selected by the platform team and exposed to developers using simpler interfaces.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.16 显示了会议应用程序服务连接到使用 Crossplane 创建的应用程序基础设施。现在，开发者和平台团队之间的界限变得更加明确，因为对获取所需基础设施感兴趣的开发者有一组由平台团队精心选择并暴露给开发者的选项，这些选项使用更简单的接口。
- en: '![](../../OEBPS/Images/05-16.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/05-16.png)'
- en: Figure 5.16 Enabling different teams to work together and focus on their tasks
    at hand
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.16 启用不同团队协作并专注于手头任务
- en: All this effort enables us to split the responsibility of defining, configuring,
    and running all the application infrastructure to another team not responsible
    for working on the application’s services. Services can be released independently
    without worrying about which databases are being used or when they need to be
    upgraded. Developers shouldn’t be worrying about cloud provider accounts or if
    they have access to create different resources. Hence, another team with a completely
    different set of skills can take care of creating Crossplane compositions and
    configuring Crossplane providers.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些努力使我们能够将定义、配置和运行所有应用程序基础设施的责任分配给另一个团队，该团队不负责处理应用程序的服务。服务可以独立发布，无需担心使用的是哪个数据库或何时需要升级。开发者不应担心云服务提供商账户或他们是否有权创建不同资源。因此，另一个具有完全不同技能组合的团队可以负责创建
    Crossplane 组合和配置 Crossplane 提供商。
- en: We have also enabled teams to request application infrastructure components
    by using Kubernetes resources. This enables them to create their setups for experimentation
    and testing or to set up new instances of the application quickly. This is a major
    shift in how we (as developers) were used to doing things, because before this,
    cloud providers and most companies must have access to a database and a ticketing
    system to request another team to provision that resource for you, which can take
    weeks!
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使团队能够通过使用 Kubernetes 资源来请求应用程序基础设施组件。这使得他们能够快速创建用于实验和测试的设置，或者快速设置应用程序的新实例。这对于我们（作为开发者）习惯的做法是一个重大转变，因为在之前，云服务提供商和大多数公司必须能够访问数据库和票务系统，以便请求另一团队为你提供该资源，这可能需要几周时间！
- en: 'To summarize what we have achieved so far, we can say that:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结我们迄今为止所取得的成就，我们可以这样说：
- en: We abstracted how to provision local- and cloud-specific components such as
    PostgreSQL and Redis databases and message brokers such as Kafka and all the configurations
    needed to access these new instances.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们抽象了如何提供本地和云特定的组件，例如 PostgreSQL 和 Redis 数据库以及 Kafka 等消息代理，以及访问这些新实例所需的所有配置。
- en: We exposed a simplified interface for the application teams that is cloud-provider
    independent because it relies on the Kubernetes API.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为应用团队提供了一个简化的界面，该界面不依赖于云服务提供商，因为它依赖于 Kubernetes API。
- en: Finally, we connected our application service to the newly provisioned instances
    by relying on Kubernetes Secrets created by Crossplane, containing all the details
    required to connect to the newly created instances.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们通过依赖由 Crossplane 创建的 Kubernetes Secrets 将我们的应用程序服务连接到新提供的实例，这些 Secrets
    包含连接到新创建的实例所需的所有详细信息。
- en: If you use mechanisms like Crossplane compositions to create higher-level abstractions,
    you will create domain-specific concepts that your teams can consume using a self-service
    approach. We have created our database and message broker concept by creating
    a Crossplane Composite Resource that uses Crossplane compositions that knows which
    resources to provision (and in which cloud provider).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用像 Crossplane 组合这样的机制来创建高级抽象，你将创建特定领域的概念，你的团队可以通过自助服务的方式使用这些概念。我们通过创建一个使用
    Crossplane 组合的 Crossplane 组合资源来创建我们的数据库和消息代理概念，该组合资源知道需要提供哪些资源（以及在哪里提供云服务提供商）。
- en: Note You can follow a step-by-step tutorial that covers all the steps described
    in this section at [https://github.com/salaboy/platforms-on-k8s/tree/main/chapter-5](https://github.com/salaboy/platforms-on-k8s/tree/main/chapter-5).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您可以在[https://github.com/salaboy/platforms-on-k8s/tree/main/chapter-5](https://github.com/salaboy/platforms-on-k8s/tree/main/chapter-5)找到涵盖本节中所有步骤的逐步教程。
- en: 5.4 Linking back to platform engineering
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.4 回到平台工程
- en: We need to be cautious. We cannot expect every developer to understand or be
    willing to use tools like the ones we have discussed (Crossplane, ArgoCD, Tekton,
    etc.). We need a way to reduce the complexity these tools introduce. Platforms
    are meant to reduce the cognitive load of their users, as described in chapter
    1 when we looked at Google Cloud Platform and how it enables teams to create a
    Kubernetes cluster with a few clicks. For GCP and other platforms, the users interacting
    with the platform don’t need to understand what is going on under the covers,
    what tools are being used, or the design of the entire platform to use it.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要谨慎行事。我们不能期望每个开发者都理解或愿意使用我们讨论过的工具（如 Crossplane、ArgoCD、Tekton 等）。我们需要一种方法来减少这些工具引入的复杂性。平台旨在减少其用户的认知负荷，正如我们在第
    1 章中查看 Google Cloud Platform 以及它如何通过几点击就能创建 Kubernetes 集群时所描述的那样。对于 GCP 和其他平台，与平台交互的用户不需要了解底层发生了什么，使用了哪些工具，或者整个平台的设计，就可以使用它。
- en: Crossplane was created to serve both platform teams and development teams (or
    consumers), which have different priorities, interests, and skills. By creating
    the right abstractions (XRDs) the platform team can expose simple resources that
    development teams can configure according to their needs, while behind the covers,
    a complex composition is being set up to create and wire together a group of cloud
    resources. We have also seen how by using labels and selectors, we can choose
    between different compositions, enabling the creation of infrastructure in different
    cloud providers but keeping the same user experience for the teams creating the
    requests. Crossplane, by extending the Kubernetes APIs, unifies how we manage
    our workloads and how we can manage application infrastructure across cloud providers.
    In other words, if we install Crossplane into a Kubernetes cluster, we cannot
    only deploy and run our clusters but also provision and manage cloud resources
    by using the same tooling that we use for our workloads.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: Crossplane 是为了服务于平台团队和开发团队（或消费者），他们有不同的优先级、兴趣和技能。通过创建正确的抽象（XRDs），平台团队可以暴露出简单的资源，开发团队可以根据他们的需求进行配置，而在幕后，一个复杂的组合正在建立，以创建和连接一组云资源。我们也看到了如何通过使用标签和选择器，我们可以在不同的组合之间进行选择，使得在不同的云提供商中创建基础设施成为可能，同时为创建请求的团队保持相同的用户体验。通过扩展
    Kubernetes API，Crossplane 统一了我们管理工作负载的方式以及我们如何管理跨云提供商的应用程序基础设施。换句话说，如果我们将 Crossplane
    安装到 Kubernetes 集群中，我们不仅能够部署和运行我们的集群，还可以通过使用我们用于工作负载的工具来配置和管理云资源。
- en: With all the goodies that Crossplane brings, you must also be ready for some
    drawbacks and challenges. Platform teams looking into Crossplane have other more
    popular options available to provision cloud resources, such as Hashicorp’s Terraform
    and Pulumi. Crossplane is much more recent than Terraform, and because Crossplane
    is focused on Kubernetes, it requires platform teams to be fully invested in Kubernetes.
    Teams not used to managing Kubernetes clusters will find tools like Crossplane
    challenging at first, so you need to level up your Kubernetes skills to run and
    maintain a tool like Crossplane.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Crossplane 带来了许多好处，但你必须准备好面对一些缺点和挑战。正在考虑使用 Crossplane 的平台团队有其他更受欢迎的选项来配置云资源，例如
    Hashicorp 的 Terraform 和 Pulumi。Crossplane 比 Terraform 更新，而且因为 Crossplane 专注于 Kubernetes，它要求平台团队完全投入
    Kubernetes。不习惯管理 Kubernetes 集群的团队可能会发现像 Crossplane 这样的工具一开始很有挑战性，因此你需要提升你的 Kubernetes
    技能来运行和维护像 Crossplane 这样的工具。
- en: Platform teams will be forced to make a decision about using Crossplane or tools
    like Terraform, and my recommendation is to think about how much you want to align
    the tools that you are using with the Kubernetes APIs. Being able to manage infrastructure
    (cloud resources) in the same way that we manage our applications makes a lot
    of sense in theory. Still, it also needs to make sense to the teams managing and
    maintaining these components up and running. In the last couple of years, there
    has been a huge increase in maturity around observability, security, and operations
    in the cloud-native space. More and more teams are feeling comfortable with managing
    and operating Kubernetes at scale. For those teams, Crossplane can be a great
    addition, because it is going to work with all their existing Kubernetes observability
    stacks, policy enforcers, and dashboards.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 平台团队将不得不在是否使用 Crossplane 或 Terraform 等工具之间做出决定，我的建议是考虑你希望将使用的工具与 Kubernetes
    API 对齐的程度。理论上，能够以管理应用程序相同的方式管理基础设施（云资源）是非常有意义的。然而，这也需要管理并维护这些组件的团队觉得这样做是有意义的。在过去的几年里，云原生领域在可观察性、安全和运维方面的成熟度有了巨大的提升。越来越多的团队开始感到舒适地管理和运营大规模的
    Kubernetes。对于这些团队来说，Crossplane 可以是一个很好的补充，因为它将与他们现有的所有 Kubernetes 可观察性堆栈、策略执行器和仪表板协同工作。
- en: When having tools as flexible as Crossplane, you open the door to new possibilities
    that can span across cloud providers. Platform teams now have more options available,
    and that can be counterproductive, but one thing is clear. If you use the right
    abstractions, the platform can be flexible, as consumer interfaces will not change.
    At the same time, the platform team can iterate on their previous decisions and
    provide new implementations behind the covers.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 当拥有像 Crossplane 这样灵活的工具时，你打开了通往新可能性的大门，这些可能性可以跨越云提供商。平台团队现在有更多的选择可用，这可能会适得其反，但有一点是明确的。如果你使用正确的抽象，平台可以更加灵活，因为消费者界面不会改变。同时，平台团队可以迭代他们的先前决策，并在幕后提供新的实现。
- en: Figure 5.17 shows how by using Crossplane, we can provide self-service abstractions
    for development teams to consume. They can request databases, message brokers,
    identity services, and any other internal or external services they might need
    for their applications. But what do they need from an application perspective?
    Think about the Kafka example provided before. What needs to change in your applications
    if you move from Kafka to Google PubSub?
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.17 展示了通过使用 Crossplane，我们可以为开发团队提供自助抽象，以便他们可以请求数据库、消息代理、身份服务以及他们可能需要用于其应用程序的任何其他内部或外部服务。但他们从应用程序的角度需要什么？想想之前提供的
    Kafka 示例。如果你从 Kafka 迁移到 Google PubSub，你的应用程序需要做出哪些改变？
- en: '![](../../OEBPS/Images/05-17.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![图片 5.17](../../OEBPS/Images/05-17.png)'
- en: Figure 5.17 What do developers need to consume all these Platform services?
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.17 开发者需要消费所有这些平台服务吗？
- en: We have covered a lot of ground so far, from installing a simple application
    into a cluster to building services and deploying them using a GitOps approach
    and now provisioning application infrastructure declaratively. Figure 5.18 shows
    how using a GitOps approach we can define not only which services/applications
    should be running inside an environment, but also which cloud resources need to
    be provisioned and wired to our application services.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经覆盖了很多内容，从将简单应用程序安装到集群中，到构建服务并使用 GitOps 方法部署它们，现在是以声明式方式配置应用程序基础设施。图 5.18
    展示了通过使用 GitOps 方法，我们不仅可以定义哪些服务/应用程序应该在环境中运行，还可以定义哪些云资源需要配置并连接到我们的应用程序服务。
- en: '![](../../OEBPS/Images/05-18.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![图片 5.18](../../OEBPS/Images/05-18.png)'
- en: Figure 5.18 Provisioning application infrastructure using a declarative GitOps
    approach
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.18 使用声明式 GitOps 方法配置应用程序基础设施
- en: 'It is time to put everything together into a platform, because it doesn’t make
    too much sense to have our applications running in the same cluster where our
    pipelines and other tools are running. What would a platform on top of Kubernetes
    look like? What are the main challenges that your teams will face when trying
    to build one? There is only one way to find out: Let’s build a platform on top
    of Kubernetes!'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候将所有内容整合到一个平台中，因为让我们的应用程序在运行我们的管道和其他工具的同一集群中运行并没有太多意义。在 Kubernetes 之上的平台会是什么样子？当你的团队试图构建一个平台时，他们会面临哪些主要挑战？只有一个方法可以找到答案：让我们在
    Kubernetes 之上构建一个平台！
- en: Summary
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Cloud-native applications depend on application infrastructure to run, as each
    service might require different persistent storages, a message broker to send
    messages, and other components to work.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云原生应用程序依赖于应用程序基础设施来运行，因为每个服务可能需要不同的持久存储、消息代理来发送消息以及其他组件来工作。
- en: Creating application infrastructure inside cloud providers is easy and can save
    us a lot of time, but then we rely on their tools and ecosystem.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在云提供商内部创建应用程序基础设施很容易，并且可以节省我们大量时间，但那时我们依赖于他们的工具和生态系统。
- en: Provisioning infrastructure in a cloud-agnostic way can be achieved by relying
    on the Kubernetes API and tools like Crossplane, which abstracts the underlying
    cloud provider and lets us define which resources must be provisioned using Crossplane
    compositions.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过依赖 Kubernetes API 和像 Crossplane 这样的工具，以云无关的方式配置基础设施可以实现，这些工具抽象了底层云提供商，并允许我们定义必须使用
    Crossplane 组合来配置哪些资源。
- en: Crossplane provides support for major cloud providers. It can be extended for
    other service providers, including third-party tools that might not be running
    on cloud providers (for example, legacy systems we want to manage using the Kubernetes
    APIs).
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Crossplane 为主要云提供商提供支持。它可以扩展到其他服务提供商，包括可能不在云提供商上运行（例如，我们希望使用 Kubernetes API
    管理的旧系统）的第三方工具。
- en: By using Crossplane Composite Resource Definitions, we create an interface that
    application teams can use to request cloud resources using a self-service approach.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用 Crossplane 组合资源定义，我们创建了一个接口，应用程序团队可以使用它以自助方式请求云资源。
- en: If you followed the step-by-step tutorial, you got hands-on experience on how
    to provision application infrastructure using a multi-cloud approach using Crossplane.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你遵循了逐步教程，你将获得使用 Crossplane 通过多云方法配置应用程序基础设施的实践经验。
