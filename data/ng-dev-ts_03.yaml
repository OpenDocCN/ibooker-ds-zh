- en: Chapter 4\. Router advanced
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第4章\. 路由高级
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Guarding routes
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 守卫路由
- en: Creating components that have multiple router outlets
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建具有多个路由出口的组件
- en: Lazy-loading modules
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 懒加载模块
- en: This chapter covers some advanced router features. You’ll learn how to use router
    guards that allow you to restrict access to certain routes, warn the user about
    unsaved changes, and ensure that important data is retrieved before allowing the
    user to navigate to a route.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了一些高级路由功能。您将学习如何使用路由守卫，这些守卫允许您限制对某些路由的访问，警告用户关于未保存的更改，并在允许用户导航到路由之前确保检索重要数据。
- en: We’ll then show you how to create components that have more than one router
    outlet. Finally, you’ll see how to load modules *lazily*—meaning only when the
    user decides to navigate to certain routes.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将向您展示如何创建具有多个路由出口的组件。最后，您将了解如何懒加载模块——意味着只有当用户决定导航到某些路由时才会加载。
- en: This chapter doesn’t include the hands-on section for ngAuction. If you’re eager
    to switch from dealing with routing to learning other Angular features, you can
    skip this chapter and come back to it at a later time.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不包括 ngAuction 的动手实践部分。如果您急于从处理路由切换到学习其他 Angular 功能，您可以跳过本章，稍后再回来。
- en: 4.1\. Guarding routes
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1\. 守卫路由
- en: Angular offers several *guard interfaces* that give you a way to mediate navigation
    to and from a route. Let’s say you have a route that only authenticated users
    can visit. In other words, you want to guard (protect) the route. [Figure 4.1](#ch04fig01)
    shows a workflow illustrating how a login guard can protect a route that can be
    visited only by authenticated users. If the user isn’t logged in, the app will
    render a login view.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 提供了几个 *守卫接口*，这些接口为您提供了一种中介导航到和从路由的方法。假设您有一个只有经过身份验证的用户才能访问的路由。换句话说，您想要守卫（保护）该路由。[图4.1](#ch04fig01)
    展示了一个工作流程，说明了登录守卫如何保护只有经过身份验证的用户才能访问的路由。如果用户未登录，应用程序将渲染登录视图。
- en: Figure 4.1\. A sample login workflow with a guard
  id: totrans-10
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.1\. 带有守卫的示例登录工作流程
- en: '![](Images/04fig01_alt.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/04fig01_alt.jpg)'
- en: 'Here are some other scenarios where guards can help:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些其他场景，在这些场景中守卫可以提供帮助：
- en: Open the route only if the user is authenticated and authorized to do so.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有当用户经过身份验证并有权这样做时才打开路由。
- en: Display a multipart form that consists of several components, and the user is
    allowed to navigate to the next section of the form only if the data entered in
    the current section is valid.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示由多个组件组成的多部分表单，并且只有当当前部分输入的数据有效时，用户才被允许导航到表单的下一部分。
- en: Remind the user about unsaved changes if they try to navigate from the route.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户尝试从路由导航离开，提醒用户关于未保存的更改。
- en: Allow navigation to the route only after a certain data structure is populated.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有在填充了某些数据结构之后才允许导航到路由。
- en: 'These are the guard interfaces:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是守卫接口：
- en: '`CanActivate` allows or disallows navigation to a route.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CanActivate` 允许或禁止导航到路由。'
- en: '`CanActivateChild` mediates navigation to a child route.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CanActivateChild` 中介导航到子路由。'
- en: '`CanDeactivate` allows or disallows navigating away from the current route.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CanDeactivate` 允许或禁止从当前路由导航离开。'
- en: '`Resolve` ensures that the required data is retrieved before navigating to
    a route.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Resolve` 确保在导航到路由之前检索所需的数据。'
- en: '`CanLoad` allows or disallows lazy-loading modules.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CanLoad` 允许或禁止懒加载模块。'
- en: '[Section 3.3](kindle_split_012.xhtml#ch03lev1sec3) of [chapter 3](kindle_split_012.xhtml#ch03)
    mentions that the `Routes` type is an array of items that conforms to the `Route`
    interface. So far, you’ve used such properties as `path` and `component` in configuring
    routes. Now, you’ll see how to mediate navigation to or from a route and ensure
    that certain data is retrieved before navigating to the route. Let’s start with
    adding a guard that’ll work when the user wants to navigate to a route.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[第3.3节](kindle_split_012.xhtml#ch03lev1sec3) 和 [第3章](kindle_split_012.xhtml#ch03)
    提到，`Routes` 类型是一个符合 `Route` 接口的项的数组。到目前为止，您已经使用了如 `path` 和 `component` 这样的属性来配置路由。现在，您将了解如何中介导航到或从路由，并确保在导航到路由之前检索某些数据。让我们从添加一个当用户想要导航到路由时将工作的守卫开始。'
- en: 4.1.1\. Implementing the CanActivate guard
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.1\. 实现 CanActivate 守卫
- en: Imagine a component with a link that only logged-in users can navigate to. To
    guard this route, you need to create a new class (for example, `LoginGuard`) that
    implements the `CanActivate` interface, which declares one method, `canActivate()`.
    In this method, you implement the validating logic that will return either `true`
    or `false`. If `canActivate()` of the guard returns `true`, the user can navigate
    to the route. You need to assign this guard to the property `canActivate`, as
    in the following listing.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个带有链接的组件，只有已登录的用户才能导航到。为了保护此路由，您需要创建一个新的类（例如，`LoginGuard`），该类实现`CanActivate`接口，该接口声明一个方法，`canActivate()`。在此方法中，您实现验证逻辑，该逻辑将返回`true`或`false`。如果守卫的`canActivate()`返回`true`，则用户可以导航到该路由。您需要将此守卫分配给`canActivate`属性，如下所示。
- en: Listing 4.1\. Configuring a route with a `canActivate` guard
  id: totrans-26
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.1\. 使用`canActivate`守卫配置路由
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '***1* The LoginGuard will mediate navigation to the ProductDetailComponent.**'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* LoginGuard将调解对ProductDetailComponent的导航。**'
- en: Because `canActivate` properties of `Route` accept an array as a value, you
    can assign multiple guards if you need to check more than one condition to allow
    or forbid the navigation.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`Route`的`canActivate`属性接受一个数组作为值，所以如果您需要检查多个条件以允许或禁止导航，您可以分配多个守卫。
- en: Let’s create a simple app to illustrate how you can protect the `product` route
    from users who aren’t logged in. To keep the example simple, you won’t use an
    authentication service but will generate the login status randomly. The following
    class implements the `CanActivate` interface. The `canActivate()` function will
    contain code that returns `true` or `false`. If the function returns `false` (the
    user isn’t logged in), the application won’t navigate to the route, will show
    a warning, and will navigate the user to the login view.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的应用程序来展示您如何保护`product`路由，防止未登录的用户访问。为了使示例简单，您不会使用身份验证服务，而是会随机生成登录状态。以下类实现了`CanActivate`接口。`canActivate()`函数将包含返回`true`或`false`的代码。如果函数返回`false`（用户未登录），则应用程序不会导航到该路由，将显示警告，并将用户导航到登录视图。
- en: Listing 4.2\. login.guard.ts
  id: totrans-31
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.2\. login.guard.ts
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '***1* Injects the Router object**'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 注入Router对象**'
- en: '***2* Randomly generates the login status**'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 随机生成登录状态**'
- en: '***3* Conditionally displays a “not logged in” message**'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 条件显示“未登录”消息**'
- en: '***4* Redirects to the login page**'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 重定向到登录页面**'
- en: This implementation of the `canActivate()` function will randomly return `true`
    or `false`, emulating the user’s logged-in status.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此`canActivate()`函数的实现将随机返回`true`或`false`，模拟用户的登录状态。
- en: The next step is to use this guard in the router configuration. The following
    listing shows how the routes could be configured for an app that has home and
    product-detail routes. The latter is protected by `LoginGuard`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将此守卫用于路由配置。以下列表显示了如何为具有主页和产品详情路由的应用程序配置路由。后者受`LoginGuard`保护。
- en: Listing 4.3\. Configure one of the routes with a guard
  id: totrans-39
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.3\. 使用守卫配置一个路由
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***1* Adding a guard to the product route**'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将守卫添加到产品路由**'
- en: Your `LoginComponent` will be pretty simple—it will show the text “Please login
    here,” as shown in the following listing.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您的`LoginComponent`将非常简单——它将显示文本“请在此处登录”，如下所示。
- en: Listing 4.4\. login.component.ts
  id: totrans-43
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.4\. login.component.ts
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Angular will instantiate the `LoginGuard` class using its DI mechanism, but
    you have to mention this class in the list of providers that are needed for injection
    to work. Add the name `LoginGuard` to the list of providers in `@NgModule()`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Angular将使用其DI机制实例化`LoginGuard`类，但您必须在此类需要注入的提供者列表中提及此类。将`LoginGuard`名称添加到`@NgModule()`中的提供者列表。
- en: Listing 4.5\. Adding the guard to the module’s providers
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.5\. 将守卫添加到模块的提供者
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***1* Adds the guard class to the provider’s list so Angular can instantiate
    and inject it**'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将守卫类添加到提供者列表，以便Angular可以实例化和注入它**'
- en: The template of your root component will look like the following listing.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您的根组件模板将如下所示。
- en: Listing 4.6\. The `AppComponent`’s template
  id: totrans-50
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.6\. `AppComponent`的模板
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1* The login page**'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 登录页面**'
- en: 'To see this app in action, run the following command:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此应用程序的实际运行情况，请运行以下命令：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[Figure 4.2](#ch04fig02) shows what happens after the user clicks the Product
    Detail link, but the `LoginGuard` decides the user isn’t logged in.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4.2](#ch04fig02)显示了用户点击产品详情链接后发生的情况，但`LoginGuard`决定用户未登录。'
- en: Figure 4.2\. Clicking the Product Detail link is guarded
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.2\. 点击产品详情链接是受保护的
- en: '![](Images/04fig02_alt.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/04fig02_alt.jpg)'
- en: 'Clicking OK closes the pop-up window with the warning and navigates to the
    /login route. In [figure 4.2](#ch04fig02), you implement the `canActivate()` method
    without providing any arguments to it. But this method can be used with optional
    parameters:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“确定”将关闭带有警告的弹出窗口，并导航到 /login 路由。在 [图 4.2](#ch04fig02) 中，你实现了 `canActivate()`
    方法，但没有向其提供任何参数。但此方法可以与可选参数一起使用：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The values of `ActivatedRouteSnapshot` and `RouterStateSnapshot` will be injected
    by Angular automatically, and this may be quite handy if you want to analyze the
    current state of the router. For example, if you’d like to know the name of the
    route the user tried to navigate to, this is how you can do it:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`ActivatedRouteSnapshot` 和 `RouterStateSnapshot` 的值将由 Angular 自动注入，如果您想分析当前路由的状态，这可能非常有用。例如，如果您想了解用户尝试导航到的路由名称，您可以这样做：'
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `CanActivate` guard controls who gets in, but how you can control whether
    a user should be allowed to navigate *from* the route? Why do you even need this?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`CanActivate` 守卫控制谁可以进入，但你如何控制用户是否应该被允许从路由中导航？你为什么需要这个？'
- en: 4.1.2\. Implementing the CanDeactivate guard
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.2\. 实现 CanDeactivate 守卫
- en: The `CanDeactivate` interface mediates the process of navigating from a route.
    This guard is quite handy in cases when you want to warn the user that there are
    some unsaved changes in the view. To illustrate this, you’ll update the app from
    the previous section and add an input field to the `ProductDetailComponent`. If
    the user enters something in this field and then tries to navigate from this route,
    your `CanDeactivate` guard will show the “Do you want to save changes” warning,
    as shown in the following listing.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`CanDeactivate` 接口调解从路由导航的过程。当您想警告用户视图中有一些未保存的更改时，此守卫非常有用。为了说明这一点，您将更新上一节的应用程序并添加一个输入字段到
    `ProductDetailComponent`。如果用户在此字段中输入某些内容，然后尝试从该路由导航，您的 `CanDeactivate` 守卫将显示“您想要保存更改”的警告，如下所示。'
- en: Listing 4.7\. The `ProductDetailComponent` with an input field
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.7\. 带有输入字段的 `ProductDetailComponent`
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '***1* Binding the variable name to a directive from Forms API**'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1* 将变量 name 绑定到来自表单API的指令**'
- en: '***2* Creating an instance of FormControl from Forms API**'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2* 从表单API创建 FormControl 实例**'
- en: '[Listing 4.7](#ch04ex07) uses the Forms API, which is covered in [chapters
    10](kindle_split_019.xhtml#ch10) and [11](kindle_split_020.xhtml#ch11). At this
    point, it suffices to know that you create an instance of the `FormControl` class
    and bind it to the `<input>` element. In your guard, you’ll use the `FormControl.dirty`
    property to know if the user entered anything in the input field. The following
    listing creates a `UnsavedChangesGuard` class that implements the `CanDeactivate`
    interface.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 4.7](#ch04ex07) 使用表单API，这在第 10 章（[kindle_split_019.xhtml#ch10](https://example.org/kindle_split_019.xhtml#ch10)）和第
    11 章（[kindle_split_020.xhtml#ch11](https://example.org/kindle_split_020.xhtml#ch11)）中有介绍。到目前为止，您只需要知道您创建
    `FormControl` 类的实例并将其绑定到 `<input>` 元素。在您的守卫中，您将使用 `FormControl.dirty` 属性来了解用户是否在输入字段中输入了任何内容。以下列表创建了一个
    `UnsavedChangesGuard` 类，该类实现了 `CanDeactivate` 接口。'
- en: Listing 4.8\. `UnsavedChangesGuard` implements `CanDeactivate`
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.8\. `UnsavedChangesGuard` 实现 `CanDeactivate`
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '***1* Implementing the CanDeactivate guard for the ProductDetailComponent**'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1* 为 ProductDetailComponent 实现 CanDeactivate 守卫**'
- en: '***2* Implementing canDeactivate() required by the CanDeactivate guard**'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2* 实现 CanDeactivate 守卫所需的 canDeactivate() 方法**'
- en: '***3* Checking whether the content of the input control has been changed**'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3* 检查输入控件的内容是否已更改**'
- en: 'The `CanDeactivate` interface uses a parameterized type, which you specified
    using TypeScript generics syntax: `<ProductDetailComponent>`. The method `canDeactivate()`
    can be used with several arguments (see [https://angular.io/api/router/CanDeactivate](https://angular.io/api/router/CanDeactivate)),
    but you’ll just use one: the component to guard.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`CanDeactivate` 接口使用参数化类型，你使用 TypeScript 泛型语法指定：`<ProductDetailComponent>`。`canDeactivate()`
    方法可以与多个参数一起使用（见 [https://angular.io/api/router/CanDeactivate](https://angular.io/api/router/CanDeactivate)），但你将只使用一个：要保护的组件。'
- en: If the user entered any value in the input field—`if (component.name.dirty)`—you’ll
    show a pop-up window with a warning. You need to make a couple more additions
    to the app from the previous section. First, add the `CanDeactivate` guard to
    the routes configuration.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户在输入字段中输入了任何值—`if (component.name.dirty)`—你将显示一个带有警告的弹出窗口。你需要从上一节的应用程序中添加一些额外的功能。首先，将
    `CanDeactivate` 守卫添加到路由配置中。
- en: Listing 4.9\. Adding `CanDeactivate` and `CanDeactivate` guards to a route
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.9\. 向路由添加 `CanDeactivate` 和 `CanDeactivate` 守卫
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '***1* Adding the LoginGuard to the product route**'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1* 将 LoginGuard 添加到产品路由**'
- en: '***2* Adding the UnsavedChangesGuard to the product route**'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将 UnsavedChangesGuard 添加到产品路由**'
- en: The next listing includes the new guard in the providers list in the module.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表中包括了模块中提供者列表中的新保护器。
- en: Listing 4.10\. Specifying providers for guards
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.10\. 指定保护器的提供者
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***1* Adding the LoginGuard provider**'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 添加 LoginGuard 提供者**'
- en: '***2* Adding the UnsavedChangesGuard provider**'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 添加 UnsavedChangesGuard 提供者**'
- en: Run this app (`ng serve --app guards -o`), visit the /product route, and enter
    something in the input field. Then, try to click another link in the app or the
    browser’s back button. You’ll see the message shown in [figure 4.3](#ch04fig03).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此应用程序 (`ng serve --app guards -o`)，访问 /product 路由，并在输入字段中输入一些内容。然后，尝试点击应用程序中的另一个链接或浏览器的后退按钮。你将看到
    [图 4.3](#ch04fig03) 中显示的消息。
- en: Figure 4.3\. Unsaved changes guard in action
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.3\. 未保存更改保护器正在工作
- en: '![](Images/04fig03_alt.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/04fig03_alt.jpg)'
- en: Now you know how to control the navigation to and from a route. The next thing
    is to ensure that the user doesn’t navigate to a route too soon, when the data
    required by the route isn’t ready yet.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何控制路由的导航。接下来要确保的是，当路由所需的数据尚未准备好时，用户不会过早地导航到该路由。
- en: 4.1.3\. Implementing the Resolve guard
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.3\. 实现解析保护器
- en: Let’s say you navigate to a product-detail component that makes an HTTP request
    to retrieve data. The connection is slow, and it takes two seconds to retrieve
    the data. This means that the user will look at the empty component for two seconds,
    and then the data will be displayed. That’s not a good user experience. What if
    the server request returns an error? The user will look at the empty component
    to see the error message after that. That’s why it may be a good idea to not even
    render the component until the required data arrives.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你导航到一个产品详情组件，该组件会发起一个 HTTP 请求以检索数据。连接速度慢，需要两秒钟来检索数据。这意味着用户将看到空组件两秒钟，然后数据才会显示。这不是一个好的用户体验。如果服务器请求返回错误呢？用户将在看到错误消息后查看空组件。这就是为什么在所需数据到达之前甚至不渲染组件可能是一个好主意。
- en: If you want to make sure that by the time the user navigates to a route some
    data structures are populated, create a `Resolve` guard that allows getting the
    data *before* the route is activated. A *resolver* is a class that implements
    the `Resolve` interface. The code in its `resolve()` method loads the required
    data, and only after the data arrives does the router navigate to the route.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要确保在用户导航到某个路由之前，某些数据结构已经被填充，创建一个允许在路由激活之前获取数据的 `Resolve` 保护器。一个 *resolver*
    是一个实现了 `Resolve` 接口的类。其 `resolve()` 方法中的代码加载所需的数据，并且只有在数据到达后，路由器才会导航到该路由。
- en: 'Let’s review an app that will have two links: Home and Data. When the user
    clicks the Data link, it has to render the `DataComponent`, which requires a large
    chunk of data to be loaded before the user sees this view. To preload the data
    (a 48 MB JSON file), you’ll create a `DataResolver` class that implements the
    `Resolve` interface. The routes are configured in the following listing.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一个将有两个链接的应用程序：主页和数据。当用户点击数据链接时，它必须渲染 `DataComponent`，这需要在用户看到这个视图之前加载大量数据。为了预加载数据（一个
    48 MB 的 JSON 文件），你将创建一个实现 `Resolve` 接口的 `DataResolver` 类。路由配置如下所示。
- en: Listing 4.11\. Routes with the resolver
  id: totrans-94
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.11\. 带有解析器的路由
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '***1* Configures the resolve guard for the mydata route**'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 配置 mydata 路由的解析保护器**'
- en: '***2* Specifies the class that will preload the data**'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 指定预加载数据的类**'
- en: 'Note that the `HomeComponent` has no guards. You’ve configured the `DataResolver`
    only for the route that renders `DataComponent`. Angular will invoke its `resolve()`
    method every time the user navigates to the `mydata` route. Because you named
    the property of the resolve object `loadedJsonData`, you’ll be able to access
    preloaded data in the `DataComponent` using the `ActivatedRoute` object, as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`HomeComponent` 没有保护器。你只为渲染 `DataComponent` 的路由配置了 `DataResolver`。Angular
    将在用户每次导航到 `mydata` 路由时调用其 `resolve()` 方法。因为你将解析对象属性的名称命名为 `loadedJsonData`，你将能够在
    `DataComponent` 中使用 `ActivatedRoute` 对象访问预加载数据，如下所示：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The code of your resolver is shown next. In this code, you use some of the syntax
    elements that haven’t been covered yet, such as `@Injectable()` (explained in
    [chapter 5](kindle_split_014.xhtml#ch05)), `HttpClient` ([chapter 12](kindle_split_021.xhtml#ch12)),
    and `Observable` ([appendix D](kindle_split_028.xhtml#app04) and [chapter 6](kindle_split_015.xhtml#ch06)),
    but we still want to review this code sample because it’s about the router.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码显示了您的解析器代码。在此代码中，您使用了尚未介绍的一些语法元素，例如 `@Injectable()`（在第 5 章中解释），`HttpClient`（在第
    12 章中介绍），以及 `Observable`（在第 4 章附录 D 和第 6 章中介绍），但我们仍然想回顾这个代码示例，因为它与路由器有关。
- en: Listing 4.12\. data.resolver.ts
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.12\. data.resolver.ts
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '***1* Marks this service as injectable**'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将此服务标记为可注入**'
- en: '***2* Injects the HttpClient service to read the data**'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 注入 HttpClient 服务以读取数据**'
- en: '***3* Implements the resolve() method**'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 实现了 resolve() 方法**'
- en: '***4* Reads the data from the file**'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 从文件中读取数据**'
- en: Your resolver class is an injectable service that implements the `Resolve` interface,
    which requires implementing a single `resolve()` method that can return an `Observable`,
    a `Promise`, or any arbitrary object.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您的解析器类是一个可注入的服务，它实现了 `Resolve` 接口，该接口要求实现一个 `resolve()` 方法，该方法可以返回一个 `Observable`、一个
    `Promise` 或任何任意对象。
- en: '|  |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: Because a resolver is a service, you need to declare its *provider* (covered
    in [section 5.2](kindle_split_014.xhtml#ch05lev1sec2) of [chapter 5](kindle_split_014.xhtml#ch05))
    in the `@NgModule()` decorator.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 因为解析器是一个服务，所以您需要在 `@NgModule()` 装饰器中声明其 *provider*（在第 5 章的 [5.2 节](kindle_split_014.xhtml#ch05lev1sec2)
    中介绍）。
- en: '|  |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Here, you use the `HttpClient` service to read the file that contains an array
    of 360,000 records of random data. The `HttpClient.get()` method returns an `Observable`,
    and so does your `resolve()` method. Angular generates the code for resolvers
    that autosubscribes to the observable and stores the emitted data in the `ActivatedRoute`
    object.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您使用 `HttpClient` 服务读取包含 360,000 条随机数据记录的文件。`HttpClient.get()` 方法返回一个 `Observable`，您的
    `resolve()` 方法也是如此。Angular 为解析器生成代码，该代码自动订阅到可观察对象并将发出的数据存储在 `ActivatedRoute` 对象中。
- en: In the constructor of the `DataComponent`, you extract the data loaded by the
    resolver and store it in the variable. In this case, you don’t display or process
    the data, because your goal is to show that the resolver loads the data before
    `DataComponent` is rendered. [Figure 4.4](#ch04fig04) shows the debugger at the
    breakpoint in the constructor. Note that the data was loaded and is available
    in the constructor of the `DataComponent`. The UI will be rendered after the code
    in your constructor completes.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `DataComponent` 的构造函数中，您提取解析器加载的数据并将其存储在变量中。在这种情况下，您不显示或处理数据，因为您的目标是展示解析器在
    `DataComponent` 渲染之前加载了数据。[图 4.4](#ch04fig04) 显示了构造函数中的断点处的调试器。请注意，数据已在 `DataComponent`
    的构造函数中加载并可用。UI 将在您的构造函数中的代码完成后渲染。
- en: Figure 4.4\. The data is loaded.
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.4\. 数据已加载。
- en: '![](Images/04fig04_alt.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/04fig04_alt.jpg)'
- en: The source code of this app is located in the directory resolver, and you can
    see it in action by running `ng serve --app resolver -o`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用的源代码位于 `resolver` 目录中，您可以通过运行 `ng serve --app resolver -o` 来查看其运行情况。
- en: Every time you navigate to the `mydata` route, the file will be reloaded and
    the user will see a progress bar (`mat-progress-bar`) from the Angular Material
    library of UI components. You’ll be introduced to this library in [section 5.6](kindle_split_014.xhtml#ch05lev1sec6)
    of [chapter 5](kindle_split_014.xhtml#ch05).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 每次您导航到 `mydata` 路由时，文件将被重新加载，并且用户将看到来自 Angular Material UI 组件库的进度条 (`mat-progress-bar`)。您将在第
    5 章的 [5.6 节](kindle_split_014.xhtml#ch05lev1sec6) 中介绍这个库。[第 5 章](kindle_split_014.xhtml#ch05)。
- en: The progress bar is used in the template of the `AppComponent`, but how does
    `AppComponent` know when to start showing the progress bar and when to remove
    it from the UI? The router triggers events during navigation, such as `NavigationStart`,
    `NavigationEnd`, and some others. Your `AppComponent` subscribes to these events,
    and when `NavigationStart` is triggered, the progress bar is displayed, and on
    `NavigationEnd` it’s removed, as shown in the following listing.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 进度条用于 `AppComponent` 的模板中，但 `AppComponent` 如何知道何时开始显示进度条以及何时从 UI 中移除它？路由器在导航期间触发事件，例如
    `NavigationStart`、`NavigationEnd` 以及其他一些事件。您的 `AppComponent` 订阅到这些事件，当 `NavigationStart`
    被触发时，进度条显示，在 `NavigationEnd` 时移除，如下面的列表所示。
- en: Listing 4.13\. app.component.ts
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.13\. app.component.ts
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '***1* Conditionally shows/hides the progress bar based on the isNavigating
    flag**'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 根据isNavigating标志条件性地显示/隐藏进度条**'
- en: '***2* Initially the flag isNavigating is false.**'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 初始时isNavigating标志为false。**'
- en: '***3* Injects the Router object**'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 注入路由对象**'
- en: '***4* Subscribes to Router events**'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 订阅路由事件**'
- en: '***5* Sets the flag to true if NavigationStart is triggered**'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 如果触发NavigationStart，则将标志设置为true**'
- en: '***6* Sets the flag to false if NavigationEnd is triggered**'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 如果触发NavigationEnd，则将标志设置为false**'
- en: '|  |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: To avoid reading such a large file over and over again, you can cache the data
    in memory after the first read. If you’re interested in seeing how to do this,
    review the code of another version of the resolver located in the data.resolver2.ts
    file. That resolver uses an injectable service from data.service.ts, so on subsequent
    clicks, instead of the file being read, the data is retrieved from the memory
    cache. Since the data service is a singleton, it’ll survive creations and destructions
    of the `DataComponent` and cached data remains available.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免反复读取如此大的文件，你可以在第一次读取后将其数据缓存到内存中。如果你对如何做到这一点感兴趣，请查看位于data.resolver2.ts文件中的另一个版本的解析器的代码。该解析器使用来自data.service.ts的可注入服务，因此在下一次点击时，不是读取文件，而是从内存缓存中检索数据。由于数据服务是单例的，它将存活于`DataComponent`的创建和销毁之间，缓存的数据仍然可用。
- en: '|  |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Reloading the active route**'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**重新加载活动路由**'
- en: You can reload the route that’s already active and rerun its guards and resolvers
    using the configuration `runGuardsAndResolvers` and `onSameUrlNavigation` options.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`runGuardsAndResolvers`和`onSameUrlNavigation`选项配置并重新运行已激活的路由的守卫和解析器。
- en: 'Say the user visits the `mydata` route and after some time wants to reload
    the data *in the same route* by clicking the Data link again. The `routes` configuration
    in the following listing does this by reapplying the guards and resolvers:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 假设用户访问了`mydata`路由，并在一段时间后想要通过再次点击数据链接来重新加载同一路由中的数据。以下列表中的`routes`配置通过重新应用守卫和解析器来实现这一点：
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '***1* Runs guards and resolvers always**'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 总是运行守卫和解析器**'
- en: '***2* Reloads the component when the user navigates to the same route**'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 当用户导航到同一路由时重新加载组件**'
- en: '|  |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: You can read about the other guards in the product documentation at [https://angular.io/guide/router#milestone-5-route-guards](https://angular.io/guide/router#milestone-5-route-guards).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在产品文档中了解有关其他守卫的信息，请参阅[https://angular.io/guide/router#milestone-5-route-guards](https://angular.io/guide/router#milestone-5-route-guards)。
- en: 'Now, we’ll move on to covering another subject: how to create a view that has
    more than one `<router-outlet>`.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将继续介绍另一个主题：如何创建一个包含多个 `<router-outlet>` 的视图。
- en: 4.2\. Developing an SPA with multiple router outlets
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2\. 开发具有多个路由出口的单页应用（SPA）
- en: The directory ngAuction contains the code of ngAuction that implements the functionality
    described in [chapter 3](kindle_split_012.xhtml#ch03)’s hands-on section.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ngAuction目录包含实现第3章（kindle_split_012.xhtml#ch03）动手实践部分功能的ngAuction代码。
- en: 'So far, in all routing code samples you’ve used components that have a single
    tag, `<router-outlet>`, where Angular renders views based on the configured routes.
    Now, you’ll see how to configure and render views in sibling routes located in
    the same component. Let’s consider a couple of use cases for multi-outlet views:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在所有路由代码示例中，你使用的组件都有一个单一的标签`<router-outlet>`，Angular根据配置的路由渲染视图。现在，你将看到如何配置和渲染位于同一组件中的同级路由中的视图。让我们考虑一些多出口视图的用例：
- en: Imagine a dashboard-like SPA that has several dedicated areas (outlets), and
    each area can render more than one component (one at a time). Outlet A can display
    your stock portfolio, either as a table or as a chart, while outlet B shows either
    the latest news or an advertisement.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想象一个类似仪表板的SPA，它有几个专用区域（出口），每个区域可以渲染多个组件（一次一个）。出口A可以显示你的股票组合，无论是以表格还是图表的形式，而出口B则显示最新的新闻或广告。
- en: Say you want to add a chat area to an SPA so the user can communicate with a
    customer service representative while keeping the current route active as well.
    You want to add an independent chat route allowing the user to use both routes
    at the same time and be able to switch from one route to another.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设你想要向SPA添加一个聊天区域，以便用户在保持当前路由激活的同时与客户服务代表进行交流。你想要添加一个独立的聊天路由，允许用户同时使用这两个路由，并能够从一个路由切换到另一个路由。
- en: In Angular, you can implement either of those scenarios by having not only a
    *primary* outlet, but also named *secondary* outlets, which are displayed at the
    same time as the primary one.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 中，你可以通过不仅有一个 *主* 出口，还有一个命名的 *次级* 出口来实现这两种场景，这些出口与主出口同时显示。
- en: 'To separate the rendering of components for primary and secondary outlets,
    you’ll need to add yet another `<router-outlet>` tag, but this outlet must have
    a name. For example, the following code snippet defines primary and chat outlets:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了区分主出口和次级出口的组件渲染，你需要添加另一个 `<router-outlet>` 标签，但这个出口必须有一个名称。例如，以下代码片段定义了主出口和聊天出口：
- en: '[PRE18]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '***1* The primary outlet**'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 主出口**'
- en: '***2* The secondary (named) outlet**'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 次级（命名）出口**'
- en: '[Figure 4.5](#ch04fig05) shows an app with two routes opened at the same time
    after the user clicks the Home link and then the Open Chat link. The left side
    shows the rendering of `HomeComponent` in the primary outlet, and the right side
    shows `ChatComponent` rendered in a named outlet. Clicking the Close Chat link
    will remove the content of the named outlet (you add an HTML `<input>` field to
    `HomeComponent` and a `<textarea>` to `ChatComponent` so it’s easier to see which
    component has focus when the user switches between the home and chat routes).'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4.5](#ch04fig05) 展示了用户点击“主页”链接然后点击“打开聊天”链接后同时打开两个路由的应用程序。左侧显示了主出口中 `HomeComponent`
    的渲染，右侧显示了在命名出口中渲染的 `ChatComponent`。点击“关闭聊天”链接将移除命名出口的内容（你向 `HomeComponent` 添加了一个
    HTML `<input>` 字段，向 `ChatComponent` 添加了一个 `<textarea>`，这样在用户在主页和聊天路由之间切换时更容易看到哪个组件具有焦点）。'
- en: Figure 4.5\. Rendering a chat view with a secondary route
  id: totrans-152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.5\. 使用次级路由渲染聊天视图
- en: '![](Images/04fig05_alt.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/04fig05_alt.jpg)'
- en: Note the parentheses in the URL of the auxiliary route, http://localhost:4200/#home(aux:chat).
    Whereas a child route is separated from the parent using the forward slash, an
    auxiliary route is represented as a URL segment in parentheses. This URL tells
    you that home and chat are sibling routes.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 注意辅助路由 URL 中的括号，http://localhost:4200/#home(aux:chat)。与使用正斜杠从父路由中分离子路由不同，辅助路由表示为括号中的
    URL 段。此 URL 告诉你 home 和 chat 是兄弟路由。
- en: The configuration for the chat route specifies the name of the outlet where
    the `ChatComponent` has to be rendered, shown in the following listing.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天路由的配置指定了 `ChatComponent` 必须渲染的出口名称，如下面的列表所示。
- en: Listing 4.14\. Configuring routes for two outlets
  id: totrans-156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.14\. 为两个出口配置路由
- en: '[PRE19]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '***1* Redirects an empty path to the home route**'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将空路径重定向到主页路由**'
- en: '***2* If the URL includes home, renders the HomeComponent in the primary outlet**'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 如果 URL 包含主页，则在主出口中渲染 HomeComponent**'
- en: '***3* If the URL includes chat, renders the ChatComponent in the outlet named
    aux**'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 如果 URL 包含聊天，则在名为 aux 的出口中渲染 ChatComponent**'
- en: 'In this configuration, we wanted to introduce you to the `redirectTo` property.
    The `HomeComponent` will be rendered in two cases: either by default at the base
    URL, or if the URL has only the /home segment, as in http://localhost:4200/home.
    The `pathMatch: ''full''` means that the client’s portion URL must be exactly
    /, so if you entered the URL http://localhost:4200/product/home, it wouldn’t redirect
    to `home`.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '在此配置中，我们想向您介绍 `redirectTo` 属性。`HomeComponent` 将在两种情况下渲染：要么默认在基本 URL 上，要么如果
    URL 只包含 /home 段，如 http://localhost:4200/home。`pathMatch: ''full''` 表示客户端部分的 URL
    必须正好是 /，所以如果你输入了 URL http://localhost:4200/product/home，它不会重定向到 `home`。'
- en: The template of the app component can look like the following listing.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序组件的模板可能看起来如下所示。
- en: Listing 4.15\. A template of a component that has two outlets
  id: totrans-163
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.15\. 具有两个出口的组件模板
- en: '[PRE20]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '***1* A link to navigate to a default route in the primary outlet**'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 一个链接用于导航到主出口的默认路由**'
- en: '***2* A link to navigate to the chat route in the outlet named aux**'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 一个链接用于导航到名为 aux 的出口中的聊天路由**'
- en: '***3* A link to remove the outlet named aux from the UI**'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 一个链接用于从 UI 中移除名为 aux 的出口**'
- en: '***4* This area is allocated for the primary outlet.**'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 此区域分配给主出口。**'
- en: '***5* This area is allocated for the secondary outlet named aux.**'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 此区域分配给名为 aux 的次级出口。**'
- en: 'Note that you have two outlets here: one primary (unnamed) and one secondary
    (named). When the user clicks the Open Chat link, you instruct Angular to render
    the component configured for `chat` in the outlet named `aux`. To close a secondary
    outlet, assign `null` instead of a route name.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里有两个出口：一个主出口（未命名）和一个次级出口（命名）。当用户点击“打开聊天”链接时，你指示 Angular 在名为 `aux` 的出口中渲染配置为
    `chat` 的组件。要关闭次级出口，请将 `null` 而不是路由名称分配给它。
- en: 'If you want to navigate to (or close) the named outlets programmatically, use
    the `Router.navigate()` method:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想以编程方式导航到（或关闭）命名出口，请使用 `Router.navigate()` 方法：
- en: '[PRE21]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To see this app with two router outlets in action, run the following command
    in the router-samples project:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此应用在两个路由出口处的实际效果，请在路由-samples 项目中运行以下命令：
- en: '[PRE22]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: There’s one more problem the router can help you with. To make the app more
    responsive, you want to minimize the amount of code that the browser loads to
    display the landing page of your app. Do you really need to load all the code
    for each route on application startup?
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器还可以帮助你解决另一个问题。为了使应用更具响应性，你想要最小化浏览器加载以显示应用着陆页的代码量。你真的需要在应用启动时加载每个路由的所有代码吗？
- en: 4.2.1\. Lazy-loading modules
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.1\. 懒加载模块
- en: Some time ago, one of your authors was working on a website for a European car
    manufacturer. There was a menu item called “European Delivery” for US citizens,
    who could fly to the car factory in Europe, pick up their new car there, and spend
    two weeks driving their own car and enjoying everything that Europe has to offer.
    After that, the car would be shipped to the United States. Such a trip would cost
    several thousand dollars, and as you can imagine, not many website visitors would
    be interested in exploring this option. Then why include the code supporting the
    menu European Delivery into the landing page of this site, increasing the initial
    page size?
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，我们的一位作者正在为一个欧洲汽车制造商的网站工作。有一个名为“欧洲交付”的菜单项，供美国公民使用，他们可以飞往欧洲的汽车工厂，在那里取走他们的新车，然后花两周时间驾驶自己的车，享受欧洲的一切。之后，汽车将被运往美国。这样的旅行可能需要花费数千美元，正如你可以想象的那样，不会有很多网站访客对探索这个选项感兴趣。那么，为什么要把支持“欧洲交付”菜单的代码包含在这个网站的着陆页中，从而增加初始页面大小？
- en: A better solution would be to create a separate European Delivery module that
    would be downloaded only if the user clicked the menu item, right? In general,
    the landing page of a web app should include only the minimal core functionality
    that must be present when a user visits the site.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的解决方案是创建一个单独的欧洲交付模块，只有当用户点击菜单项时才会下载，对吧？一般来说，Web 应用的着陆页应该只包含用户访问网站时必须存在的最小核心功能。
- en: Any mid-size or large app should be split into several modules, where each module
    implements certain functionality (billing, shipping, and so on) and is *lazy-loaded*
    on demand. In [chapter 2](kindle_split_011.xhtml#ch02), [section 2.5.1](kindle_split_011.xhtml#ch02lev2sec1),
    you saw an app split into two modules, but both modules were loaded on application
    startup. In this section, we’ll show you how a module can be lazy loaded.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 任何中型或大型应用都应该分成几个模块，其中每个模块实现某些功能（计费、运输等），并且按需*懒加载*。在[第 2 章](kindle_split_011.xhtml#ch02)中，[第
    2.5.1 节](kindle_split_011.xhtml#ch02lev2sec1)，你看到了一个分成两个模块的应用，但两个模块都在应用启动时加载。在本节中，我们将向你展示如何懒加载一个模块。
- en: 'Let’s create an app with three links: Home, Product Details, and Luxury Items.
    Imagine that luxury items have to be processed differently than regular products,
    and you want to separate this functionality into a feature module called `LuxuryModule`,
    which will have one component named `LuxuryComponent`. Most users of the app have
    modest incomes and will rarely click the Luxury Items link, so there’s no reason
    to load the code of the luxury module on application startup. You’ll load it *lazily*—only
    if the user clicks the Luxury Items link. This way of doing things is especially
    important for mobile apps when they’re used in a poor connection area—the code
    of the root module has to contain only the core functionality. The code of `LuxuryModule`
    is shown in the following listing.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个包含三个链接的应用：主页、产品详情和豪华商品。想象一下，豪华商品需要与普通产品不同地处理，你希望将此功能分离到一个名为 `LuxuryModule`
    的功能模块中，该模块将有一个名为 `LuxuryComponent` 的组件。大多数应用用户收入有限，很少会点击豪华商品链接，因此没有必要在应用启动时加载豪华模块的代码。你将*懒加载*它——只有当用户点击豪华商品链接时才会加载。这种方式对于在较差的连接区域使用的移动应用尤为重要——根模块的代码必须只包含核心功能。`LuxuryModule`
    的代码如下所示。
- en: Listing 4.16\. luxury.module.ts
  id: totrans-181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.16\. luxury.module.ts
- en: '[PRE23]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '***1* Imports CommonModule as required for feature modules**'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入 CommonModule 作为功能模块所需的模块**'
- en: '***2* Configures the default route for this feature module using the forChild()
    method**'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用 forChild() 方法配置此功能模块的默认路由**'
- en: '***3* By default, renders its only component, LuxuryComponent**'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 默认情况下，渲染其唯一组件，LuxuryComponent**'
- en: In the next listing, the code of `LuxuryComponent` just displays the text “Luxury
    Component” on a yellow (suggesting gold) background.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个列表中，`LuxuryComponent` 的代码仅显示在黄色（暗示金色）背景上的文本“高级组件”。
- en: Listing 4.17\. luxury.component.ts
  id: totrans-187
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.17\. luxury.component.ts
- en: '[PRE24]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '***1* Applying the CSS selector gold**'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 应用 CSS 选择器 gold**'
- en: '***2* Declaring the CSS selector gold**'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 声明 CSS 选择器 gold**'
- en: The code of the root module is shown in the following listing.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列出的是根模块的代码。
- en: Listing 4.18\. app.module.ts
  id: totrans-192
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.18\. app.module.ts
- en: '[PRE25]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '***1* Configures routes for the root module**'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 为根模块配置路由**'
- en: '***2* Instead of the property component, uses the loadChildren component for
    lazy loading**'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用 loadChildren 组件进行懒加载，而不是使用 component 属性**'
- en: Note that the `imports` section only includes `BrowserModule` and `RouterModule`.
    The feature module `LuxuryModule` isn’t listed here. Also, the root module doesn’t
    mention `LuxuryComponent` in its `declarations` section, because this component
    isn’t a part of the root module. When the router parses the routes configuration
    from both root and feature modules, it’ll properly map the `luxury` path to the
    `LuxuryComponent` that’s declared in the `LuxuryModule`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`imports` 部分只包括 `BrowserModule` 和 `RouterModule`。功能模块 `LuxuryModule` 没有列在这里。此外，根模块在其
    `declarations` 部分没有提到 `LuxuryComponent`，因为该组件不是根模块的一部分。当路由器从根和功能模块解析路由配置时，它将正确地将
    `luxury` 路径映射到在 `LuxuryModule` 中声明的 `LuxuryComponent`。
- en: Instead of mapping the `path` to a component, you use the `loadChildren` property,
    providing the path and the name of the module to be loaded. Note that the value
    of `loadChildren` isn’t a typed module name, but a string. The root module doesn’t
    know about the `LuxuryModule` type; but when the user clicks the Luxury Items
    link, the loader module will parse this string and load `LuxuryModule` from the
    luxury .module.ts file shown earlier.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你不是将 `path` 映射到组件，而是使用 `loadChildren` 属性，提供要加载的模块的路径和名称。请注意，`loadChildren` 的值不是一个类型化的模块名称，而是一个字符串。根模块不了解
    `LuxuryModule` 类型；但是当用户点击“高级项目”链接时，加载模块将解析这个字符串，并从前面显示的 luxury .module.ts 文件中加载
    `LuxuryModule`。
- en: 'To ensure that the code supporting `LuxuryModule` isn’t loaded on app startup,
    Angular CLI places its code in a separate bundle. In your project router-samples,
    this app is configured under the name `lazy` in .angular-cli.json. You can build
    the bundles by running the following command:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保支持 `LuxuryModule` 的代码在应用启动时不会被加载，Angular CLI 将其代码放置在单独的包中。在你的项目 router-samples
    中，这个应用在 .angular-cli.json 中配置为名为 `lazy`。你可以通过运行以下命令来构建包：
- en: '[PRE26]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The Terminal window will print the information about the bundles, as shown in
    the following listing.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 终端窗口将打印有关包的信息，如下所示。
- en: Listing 4.19\. The bundles built by ng serve
  id: totrans-201
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.19\. 由 ng serve 构建的包
- en: '[PRE27]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '***1* A separate bundle was built for a lazy-loaded bundle.**'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 为懒加载的包构建了单独的包。**'
- en: The second line shows that your luxury module was placed in a separate bundle
    named luxury.module.chunk.js.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行显示，你的高级模块被放置在一个名为 luxury.module.chunk.js 的单独包中。
- en: '|  |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-206
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: When you run `ng build --prod`, the names of the bundles for lazy modules are
    numbers, not names. In the code sample, the default name of the bundle for the
    luxury module would be zero followed by a generated hash code, something like
    0.0797fe80dbf6edcb363f.chunk.js. If your app had two lazy modules, they would
    be placed in the bundles with the names starting with 0 and 1, respectively.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行 `ng build --prod` 时，懒加载模块的包名称是数字，而不是名称。在代码示例中，高级模块的默认包名称将是零后跟一个生成的哈希码，例如
    0.0797fe80dbf6edcb363f.chunk.js。如果你的应用有两个懒加载模块，它们将被放置在以 0 和 1 分别开始的包中。
- en: '|  |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: If you open the browser at localhost:4200 and check the network tab in dev tools,
    you won’t see this module there. See [figure 4.6](#ch04fig06).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开浏览器到 localhost:4200 并检查开发者工具中的网络标签，你将不会在那里看到这个模块。参见 [图 4.6](#ch04fig06)。
- en: Figure 4.6\. Luxury module is not loaded
  id: totrans-210
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.6\. 高级模块未加载
- en: '![](Images/04fig06_alt.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/04fig06_alt.jpg)'
- en: Click the Luxury Items link, and you’ll see that the browser made an additional
    request and downloaded the code of the `LuxuryModule`, as seen at the bottom of
    [figure 4.7](#ch04fig07). The luxury module has been loaded, and the `LuxuryComponent`
    has been rendered in the router outlet.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“高级项目”链接，你会看到浏览器进行了额外的请求并下载了 `LuxuryModule` 的代码，如 [图 4.7](#ch04fig07) 底部所示。高级模块已被加载，并且
    `LuxuryComponent` 已在路由出口中渲染。
- en: Figure 4.7\. Luxury module is loaded after the button click
  id: totrans-213
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.7\. 点击按钮后加载了高级模块
- en: '![](Images/04fig07_alt.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/04fig07_alt.jpg)'
- en: This simple example didn’t substantially reduce the size of the initial download.
    But architecting large applications using lazy-loading techniques can lower the
    initial size of the downloadable code by hundreds of kilobytes or more, improving
    the perceived performance of your application. *Perceived performance* is what
    the user *thinks* of the performance of your application, and improving it is
    important, especially when the app is being loaded from a mobile device on a slow
    network.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的示例并没有显著减少初始下载的大小。但使用懒加载技术构建大型应用程序可以减少可下载代码的初始大小数百千字节或更多，从而提高应用程序的感知性能。*感知性能*
    是用户对应用程序性能的看法，提高它很重要，尤其是在从移动设备上通过慢速网络加载应用程序时。
- en: 'On one of our past projects, the manager stated that the landing page of the
    newly developed web app had to load blazingly fast. We asked, “How fast?” He sent
    us a link to some app: “As fast as this one.” We followed the link and found a
    nicely styled web page with a menu presented as four large squares. This page
    did load blazingly fast. After clicking any of the squares, it took more than
    10 seconds for the selected module to be lazy loaded. This is perceived performance
    in action.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们过去的一个项目中，经理表示新开发的网页应用的首页必须加载得非常快。我们问：“有多快？”他给我们发了一个链接到某个应用：“和这个一样快。”我们点击链接，发现一个风格很好的网页，菜单以四个大方块的形式呈现。这个页面确实加载得非常快。点击任何一个方块后，选定的模块需要超过
    10 秒才能进行懒加载。这就是感知性能的实际应用。
- en: '|  |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-218
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: Make the root module of your app as small as possible. Split the rest of your
    app into lazy-loaded modules, and users will praise the performance of your app.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能使您的应用程序的根模块尽可能小。将应用程序的其余部分拆分为懒加载模块，用户将称赞您应用程序的性能。
- en: '|  |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 4.2.2\. Preloaders
  id: totrans-221
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.2\. 预加载器
- en: 'Let’s say that after implementing lazy loading, you saved one second on the
    initial app startup. But when the user clicks the Luxury Items link, they still
    need to wait this second for the browser to load your luxury module. It would
    be nice if the user didn’t need to wait for that second. With Angular *preloaders*,
    you can kill two birds with one stone: reduce the initial download time *and*
    get immediate response while working with lazy-loaded routes.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您在实现懒加载后，在初始应用启动时节省了一秒钟。但当用户点击奢侈品链接时，他们仍然需要等待这一秒钟，以便浏览器加载您的奢侈品模块。如果用户不需要等待这一秒钟，那就太好了。使用
    Angular 预加载器，您可以一石二鸟：减少初始下载时间 *并且* 在处理懒加载路由时获得即时响应。
- en: 'With Angular preloaders, you can do the following:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Angular 预加载器，您可以执行以下操作：
- en: Preload all lazy modules in the background while the user is interacting with
    your app
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在用户与您的应用交互时，在后台预加载所有懒加载模块
- en: Specify the preloading strategy in the routes configuration
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在路由配置中指定预加载策略
- en: Implement a custom preloading strategy by creating a class that implements the
    `PreloadingStrategy` interface
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过创建一个实现 `PreloadingStrategy` 接口的类来实现自定义预加载策略
- en: Angular offers a preloading strategy called `PreloadAllModules`, which means
    that right after your app is loaded, Angular loads all bundles with lazy modules
    in the background. This doesn’t block the application, and the user can continue
    working with the app without any delays. Adding this preloading strategy as a
    second argument of `forRoot()` is all it takes, as shown in the following listing.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 提供了一个名为 `PreloadAllModules` 的预加载策略，这意味着在您的应用程序加载后，Angular 会立即在后台加载所有包含懒加载模块的包。这不会阻塞应用程序，用户可以继续使用应用程序而不会出现任何延迟。只需将此预加载策略作为
    `forRoot()` 的第二个参数添加即可，如下所示。
- en: Listing 4.20\. Adding a preloading strategy
  id: totrans-228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.20\. 添加预加载策略
- en: '[PRE28]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '***1* Adding the PreloadAllModules preloading strategy**'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 添加 PreloadAllModules 预加载策略**'
- en: After this code change, the network tab will show that luxury.module.chunk.js
    was also loaded. Large apps may consist of dozens of lazy modules, and you may
    want to come up with some custom strategy defining which lazy modules should be
    preloaded and which shouldn’t.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码更改之后，网络标签将显示 luxury.module.chunk.js 也已被加载。大型应用程序可能包含数十个懒加载模块，您可能需要制定一些自定义策略，以确定哪些懒加载模块应该预加载，哪些不应该。
- en: 'Say you have two lazy modules, `LuxuryModule` and `SuperLuxuryModule`, and
    you want to preload only the first. You can add some Boolean variable (for example,
    `preloadme: true`) to the configuration of the `luxury` path:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '假设您有两个懒加载模块，`LuxuryModule` 和 `SuperLuxuryModule`，并且您只想预加载第一个。您可以在 `luxury`
    路径的配置中添加一些布尔变量（例如，`preloadme: true`）：'
- en: '[PRE29]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Your custom preloader may look like the following listing.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 您的自定义预加载器可能看起来像以下列表。
- en: Listing 4.21\. A sample custom preloader class
  id: totrans-235
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.21\. 一个示例自定义预加载类
- en: '[PRE30]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '***1* Creates a class implementing the PreloadingStrategy interface**'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建一个实现PreloadingStrategy接口的类**'
- en: '***2* Passes to the preload() method a callback function that returns an Observable**'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将返回一个Observable的回调函数传递给preload()方法**'
- en: '***3* Checks the value of the preloadme property on the data object for each
    route configuration. If it exists and its value is preloadme: true, then invokes
    the load() callback.**'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 检查每个路由配置的数据对象上的preloadme属性值。如果存在且其值为preloadme: true，则调用load()回调函数。**'
- en: '***4* No need to preload—returns an empty Observable**'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 无需预加载—返回一个空的Observable**'
- en: Because `CustomPreloadingStrategy` is an injectable service, you need to add
    it to the `providers` property of the root module in the `@NgModule` decorator.
    Don’t forget to specify the name of your custom preloader as an argument in the
    `forRoot()` method.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`CustomPreloadingStrategy`是一个可注入的服务，您需要将其添加到根模块的`@NgModule`装饰器中的`providers`属性。不要忘记在`forRoot()`方法中将您自定义预加载器的名称作为参数指定。
- en: Summary
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Mediate client-side navigation using guards.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用守卫来介导客户端导航。
- en: Create more than one `<router-outlet>` tag in the same component if need be.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要，可以在同一组件中创建多个`<router-outlet>`标签。
- en: Minimize the initial size of your app by implementing lazy-loading techniques.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过实现懒加载技术来最小化您应用的初始大小。
