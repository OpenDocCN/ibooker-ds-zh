- en: 3 Managing component state with the useReducer hook
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 使用 `useReducer` 钩子管理组件状态
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Asking React to manage multiple, related state values by calling `useReducer`
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调用 `useReducer` 请求 React 管理多个相关状态值
- en: Putting component state management logic in a single location
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将组件状态管理逻辑放在一个位置
- en: Updating state and triggering re-renders by dispatching actions to a reducer
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过向 reducer 发送动作来更新状态和触发重新渲染
- en: Initializing state with initialization arguments and initialization functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用初始化参数和初始化函数初始化状态
- en: 'As your applications grow, it’s natural for some components to handle more
    state, especially if they supply different parts of that state to multiple children.
    When you find you always need to update multiple state values together or your
    state update logic is so spread out that it’s hard to follow, it might be time
    to define a function to manage state updates for you: a *reducer* function.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你的应用程序的增长，某些组件处理更多状态是很自然的，尤其是如果它们向多个子组件提供该状态的不同部分。当你发现你总是需要一起更新多个状态值，或者你的状态更新逻辑分布得太广，难以追踪时，可能就是时候定义一个函数来为你管理状态更新了：一个
    *reducer* 函数。
- en: 'A simple, common example is for loading data. Say a component needs to load
    posts for a blog on things to do when stuck at home during a pandemic. You want
    to display loading UI when new posts are requested, error UI if a problem arises,
    and the posts themselves when they arrive. The component’s state includes values
    for the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单、常见的例子是加载数据。比如说，一个组件需要加载在疫情期间被困在家时可以做的事情的博客帖子。你希望在请求新帖子时显示加载用户界面，如果出现问题则显示错误用户界面，当帖子到达时显示帖子本身。组件的状态包括以下值：
- en: '*The loading state*—Are you in the process of loading new posts?'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*加载状态*——你正在加载新的帖子吗？'
- en: '*Any errors*—Has an error been returned from the server, or is the network
    down?'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*任何错误*——服务器返回了错误，或者网络是否已断开？'
- en: '*The posts*—A list of the posts retrieved.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*帖子*——检索到的帖子列表。'
- en: 'When the component requests posts, you might set the loading state to `true`,
    the error state to `null`, and the posts to an empty array. One event causes changes
    to three pieces of state. When the posts are returned, you might set the loading
    state to `false` and the posts to those returned. One event causes changes to
    two pieces of state. You can definitely manage these state values with calls to
    the `useState` hook but, when you always respond to an event with calls to multiple
    updater functions (`setIsLoading`, `setError`, and `setPosts`, for example), React
    provides a cleaner alternative: the `useReducer` hook.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件请求帖子时，你可能将加载状态设置为 `true`，错误状态设置为 `null`，并将帖子设置为空数组。一个事件导致三个状态值的变化。当帖子返回时，你可能将加载状态设置为
    `false` 并将帖子设置为返回的帖子。一个事件导致两个状态值的变化。你当然可以通过调用 `useState` 钩子来管理这些状态值，但是，当你总是用对多个更新函数的调用（例如
    `setIsLoading`、`setError` 和 `setPosts`）来响应事件时，React 提供了一个更干净的替代方案：`useReducer`
    钩子。
- en: 'In this chapter, we start by addressing a problem with the `BookablesList`
    component in the bookings app: something is amiss with our state management. We
    then introduce reducers and the `useReducer` hook as a way of managing our state.
    Section 3.3 shows how to use a function to initialize the state for a reducer
    as we start work on a new component, the `WeekPicker`. We finish the chapter with
    a review of how the `useReducer` hook fits in with our understanding of function
    components.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先解决预订应用程序中 `BookablesList` 组件的问题：我们的状态管理有些问题。然后，我们介绍 reducer 和 `useReducer`
    钩子作为管理我们状态的一种方式。3.3 节展示了如何使用函数初始化 reducer 的状态，当我们开始一个新的组件 `WeekPicker` 的工作时。我们以回顾
    `useReducer` 钩子如何与我们对函数组件的理解相匹配来结束本章。
- en: Can you smell that? There’s a definite whiff in the air. Something’s been left
    out that should’ve been tidied up. Something stale. Let’s purge that distracting
    pong!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你能闻到那味道吗？空气中有一股明显的异味。有些东西被遗漏了，应该被整理一下。有些陈旧的。让我们清除那些分散注意力的声音！
- en: 3.1 Updating multiple state values in response to a single event
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 对单个事件响应更新多个状态值
- en: You’re free to call `useState` as many times as you want, once for each piece
    of state you need React to manage. But a single component may need to hold many
    values in state, and often those pieces of state are related; you may want to
    update multiple pieces of state in response to a single user action. You don’t
    want to leave some pieces of state unattended to when they should really be tidied
    up.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以随意多次调用`useState`，每次为React需要管理的每个状态片段调用一次。但一个组件可能需要持有许多状态值，而且通常这些状态片段是相关的；你可能希望对单个用户操作响应时更新多个状态片段。你不希望当它们应该被整理时，有些状态片段被忽视。
- en: Our `BookablesList` component currently has a problem when users switch from
    one group to another. It’s not a big problem, but in this section we discuss what
    the problem is, why it’s a problem, and how we can solve it by using the `useState`
    hook. That sets us up for the `useReducer` hook in section 3.2.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户从一个组切换到另一个组时，我们的`BookablesList`组件目前存在一个问题。这不是一个大问题，但在这个部分中，我们将讨论这个问题是什么，为什么它是问题，以及我们如何通过使用`useState`钩子来解决它。这为我们设置了3.2节中的`useReducer`钩子。
- en: 3.1.1 Taking users out of the movie with unpredictable state changes
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.1 使用不可预测的状态变化将用户从电影中拉出来
- en: We don’t want clunky, unpredictable interfaces preventing users from getting
    on with tasks. If the UI keeps pulling their attention away from their desired
    focus or makes them wait with no feedback or sends them off down dead ends, their
    thought process is interrupted, their work becomes more difficult, and their day
    is ruined.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望出现笨拙、不可预测的界面，阻碍用户完成任务。如果用户界面不断将他们的注意力从他们想要的焦点上拉走，或者让他们在没有反馈的情况下等待，或者将他们引向死胡同，他们的思维过程就会被打断，他们的工作会变得更加困难，他们的这一天就会被毁了。
- en: It’s like when you’re watching a movie, and a strange camera movement, or frenzied
    editing, or blatant product placement, or Ed Sheeran pulls you out of the story.
    Your train of thought is gone. You become overly aware that it’s a movie, and
    something’s not quite right. Or when you’re reading a book on programming, and
    a tortured simile, a strained attempt at humor, perplexing asides, or meta jokes
    pull you out of the explanation. You become overly aware that you’re reading a
    desperate author, and something’s not quite right.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像你在看电影时，突然的摄像机运动，或者疯狂的剪辑，或者明显的产品植入，或者艾德·希兰将你从故事中拉出来。你的思维链断了。你过度意识到这是一部电影，有些地方不太对劲。或者当你阅读一本编程书时，一个痛苦的比喻，勉强的幽默尝试，令人困惑的旁白，或者元幽默将你从解释中拉出来。你过度意识到你正在读一个绝望的作者，有些地方不太对劲。
- en: 'Okay, sorry. Back in the room. Let’s see an example. At the end of section
    2.3 in the preceding chapter, we diagnosed a mild case of jank in our `BookablesList`
    component’s UI. Users are able to choose a group and then select a bookable from
    that group. The bookable’s details are then displayed. But some combinations of
    bookable and group selection lead to UI updates that are a little bit off. If
    you follow these three steps, you should see the UI updates shown in figure 3.1:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，抱歉。回到房间。让我们看看一个例子。在前一章的2.3节末尾，我们诊断了我们的`BookablesList`组件UI中轻微的卡顿。用户可以选择一个组，然后从该组中选择一个可预订书籍。然后显示该可预订书籍的详细信息。但是，一些可预订书籍和组选择组合会导致UI更新有些不正常。如果你遵循这三个步骤，你应该会看到图3.1中显示的UI更新：
- en: Select the Games Room; its details are then displayed.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择游戏室；然后显示其详细信息。
- en: Switch the group to Kit. The list of Kit bookables is displayed with no bookable
    selected, and the details disappear.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将组切换到Kit。Kit可预订书籍列表显示时没有选择任何可预订书籍，并且详细信息消失。
- en: Click the Next button. The second item of Kit, Wireless Mics, is selected, and
    its details appear.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击下一步按钮。Kit的第二个项目，无线麦克风，被选中，并显示其详细信息。
- en: '![](../Images/3-1.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图3-1](../Images/3-1.png)'
- en: Figure 3.1 Selecting a bookable, switching groups, and then clicking the Next
    button can lead to unpredictable state changes.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 选择一个可预订书籍，切换组，然后点击下一步按钮可能导致不可预测的状态变化。
- en: Switching from the Rooms group to the Kit group, the component seems to lose
    track of which bookable is selected. Clicking the Next button then selects the
    *second* item, skipping the first. It’s not a huge problem—users can still select
    bookables—but it may be enough to jar the user out of their focused flow. What’s
    going on?
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 从房间组切换到Kit组，组件似乎失去了跟踪哪个可预订书籍被选中。点击下一步按钮然后选择第二个项目，跳过了第一个。这不是一个大问题——用户仍然可以选择可预订书籍——但这可能足以让用户从他们的专注流程中跳出来。发生了什么？
- en: It turns out that the selected bookable and the selected group aren’t completely
    independent values in our state. When a user selects the Games Room, the `bookableIndex`
    state value is set to 2; it’s the third item in the list. If they then switch
    to the Kit group, which has only two items, with indexes 0 and 1, the `bookableIndex`
    value no longer matches up with a bookable. The UI ends up with no bookable selected
    and no details displayed. We need to carefully consider the state we want the
    UI to be in after a user chooses a group. So, how do we fix our stale index problem
    and smooth the path for our users?
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，在我们状态中，所选的可预订项和所选的组并不是完全独立的值。当用户选择游戏室时，`bookableIndex`状态值被设置为2；它是列表中的第三项。如果他们然后切换到只有两个项目（索引为0和1）的套件组，`bookableIndex`值就不再与一个可预订项匹配。UI最终没有选择任何可预订项，也没有显示任何详细信息。我们需要仔细考虑用户选择一个组后我们希望UI处于的状态。那么，我们如何修复我们的陈旧索引问题并平滑用户的路径？
- en: 3.1.2 Keeping users in the movie with predictable state changes
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.2 保持用户在电影中，通过可预测的状态变化
- en: 'Building a bookings app for our colleagues, we want to make its use as frictionless
    as possible. Say a colleague, Akiko, has clients visiting next week. She’s organizing
    her schedule for the visit and needs to book the Meeting Room in the afternoon
    and then the Games Room after work. Akiko’s focus is on her task: getting the
    schedule sorted and preparing for a great client visit. The bookings app should
    let her continue to focus on her task. She should be thinking, “I’ll get those
    rooms booked and then order the catering,” not “Um, hang on, which button? Did
    I click it? Has it frozen? Argh, *I hate computers*!”'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为我们的同事构建预订应用，我们希望尽可能使其使用无摩擦。比如说，同事Akiko下周有客户来访。她正在为访问安排日程，需要在下午预订会议室，然后下班后预订游戏室。Akiko的关注点在于她的任务：整理日程并为一次伟大的客户访问做准备。预订应用应该让她继续专注于她的任务。她应该想着，“我会预订那些房间，然后订购餐饮，”而不是“嗯，等等，哪个按钮？我点击了吗？它冻结了吗？啊，*我讨厌电脑*！”
- en: It's like when you’re watching a movie and you’re completely invested in a character’s
    plight. You don’t notice the camera moves and the editing because they help to
    smoothly draw you into the story. You’re no longer in the movie theater; you’re
    in the world of the film. The artifice melts away, and the story is everything.
    Or when you’re reading a book, and its quirky but relatable characters and propulsive
    plot pull you into the narrative. It’s almost as if the book disappears, and you
    inhabit the characters’ thoughts, feelings, locations, and actions. Eventually,
    you notice yourself, and realize you’ve read 100 pages and it’s almost dark. .
    . .
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像你在看电影时完全投入到一个角色的困境中。你不会注意到摄像机的移动和剪辑，因为它们有助于平滑地将你带入故事。你已经不再在电影院；你进入了电影的世界。技巧消失了，故事就是一切。或者当你读书时，它奇特但引人入胜的角色和推动性的情节把你带入叙事。几乎就像书消失了，你占据了角色的思想、感受、地点和行动。最终，你注意到自己，意识到你已经读了100页，天都快黑了……
- en: Okay, sorry. Back in the room. Let’s get back to the example. After the user
    selects a group, we want the UI to be in a predictable state. We don’t want sudden
    deselections and skipped bookables. A simple and sensible approach is to always
    select the first bookable in the list when a user chooses a new group, as shown
    in figure 3.2.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，抱歉。回到房间。让我们回到例子。在用户选择一个组之后，我们希望UI处于一个可预测的状态。我们不希望突然取消选择和跳过的可预订项。一个简单且合理的方法是在用户选择新组时始终选择列表中的第一个可预订项，如图3.2所示。
- en: '![](../Images/3-2.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3-2.png)'
- en: Figure 3.2 Selecting a bookable, switching groups, and then clicking the Next
    button leads to predictable state changes.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 选择可预订项，切换组，然后点击下一步按钮会导致可预测的状态变化。
- en: The `group` and `bookableIndex` state values are connected; when we change the
    group, we change the index as well. In step 2 of figure 3.2, notice that the first
    item in the list, Projector, is automatically selected when the group is switched.
    The following listing shows the `changeGroup` function setting `bookableIndex`
    to zero whenever a new group is set.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`group`和`bookableIndex`状态值是相互关联的；当我们更改组时，我们也更改索引。在图3.2的第2步中，注意当切换组时，列表中的第一项（投影仪）会自动选中。下面的列表显示了`changeGroup`函数在设置新组时将`bookableIndex`设置为0。'
- en: 'Branch: 0301-related-state, File: /src/components/Bookables/BookablesList.js'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0301-related-state，文件：/src/components/Bookables/BookablesList.js
- en: Listing 3.1 Automatically selecting a bookable when the group is changed
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.1 在更改组时自动选择可预订项
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Create a handler function to respond to group selection.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个处理函数来响应组选择。
- en: ❷ Update the group.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 更新组。
- en: ❸ Select the first bookable in the new group.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在新组中选择第一个可预订项。
- en: ❹ Specify the new function as the onChange handler.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将新函数指定为onChange处理程序。
- en: 'Whenever the group is changed, we set the bookable index to zero; when we call
    `setGroup`, we always follow it with a call to `setBookableIndex`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 每当组发生变化时，我们将可预订索引设置为零；当我们调用`setGroup`时，我们总是随后调用`setBookableIndex`：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is a simple example of related state. When components start to get more
    complicated with multiple events causing multiple state changes, tracking those
    changes and making sure all related state values are updated together become more
    and more difficult.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相关状态的简单例子。当组件开始变得复杂，由多个事件引起多个状态变化时，跟踪这些变化并确保所有相关状态值一起更新变得越来越困难。
- en: When state values are related in such a way, either affecting each other or
    often being changed together, it can help to move the state update logic into
    a single place, rather than spreading the code that performs changes across event
    handler functions, whether inline or separately defined. React gives us the `useReducer`
    hook to help us manage this collocation of state update logic, and we look at
    that hook next.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当状态值以这种方式相互关联时，要么相互影响，要么经常一起改变，将状态更新逻辑移动到单个位置可能会有所帮助，而不是将执行更改的代码分散在事件处理函数中，无论是内联定义还是单独定义。React通过`useReducer`钩子为我们提供了帮助，以管理这种状态更新逻辑的组合，我们将在下一节中查看该钩子。
- en: 3.2 Managing more complicated state with useReducer
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 使用useReducer管理更复杂的状态
- en: 'As it stands, the `BookablesList` component example is simple enough that you
    could continue to use `useState` and just call the respective updater functions
    for each piece of state within the `changeGroup` event handler. But when you have
    multiple pieces of interrelated state, using a *reducer* can make it easier to
    make and understand state changes. In this section, we introduce the following
    topics:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 就目前而言，`BookablesList`组件示例足够简单，你可以继续使用`useState`，并在`changeGroup`事件处理程序中调用每个状态片段的相应更新函数。但是，当你有多个相互关联的状态时，使用*reducer*可以使状态变化更容易理解和实现。在本节中，我们介绍了以下主题：
- en: A reducer helps you to manage state changes in a centralized, well-defined way
    with clear actions that act on the state.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Reducer帮助你以集中化、定义良好的方式管理状态变化，具有对状态执行操作的清晰动作。
- en: A reducer uses actions to generate a new state from the previous state, making
    it easier to specify more complicated updates that may involve multiple pieces
    of interrelated state.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Reducer通过使用动作从上一个状态生成一个新的状态，这使得指定更复杂的更新变得更容易，这些更新可能涉及多个相互关联的状态。
- en: React provides the `useReducer` hook to let your component specify initial state,
    access the current state, and dispatch actions to update the state and trigger
    a re-render.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React提供了`useReducer`钩子，允许你的组件指定初始状态，访问当前状态，并派发动作以更新状态并触发重新渲染。
- en: Dispatching well-defined actions makes it easier to follow state changes and
    to understand how your component interacts with the state in response to different
    events.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 派发定义良好的动作使跟踪状态变化和了解组件如何对不同事件响应的状态交互变得更加容易。
- en: We start, in section 3.2.1, with a description of a reducer and a simple example
    of a reducer that manages incrementing and decrementing a counter. In section
    3.2.2, we build a reducer for the `BookablesList` component that performs the
    necessary state changes like switching groups, selecting bookables, and toggling
    bookable details. Finally, in section 3.2.3, we incorporate our freshly minted
    reducer into the `BookablesList` component by using React’s `useReducer` hook.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从3.2.1节开始，描述了一个reducer和一个简单的reducer示例，该reducer管理计数器的增加和减少。在3.2.2节中，我们为`BookablesList`组件构建了一个reducer，执行切换组、选择可预订项和切换可预订详情等必要的状态变化。最后，在3.2.3节中，我们通过使用React的`useReducer`钩子将我们新铸造的reducer集成到`BookablesList`组件中。
- en: 3.2.1 Updating state using a reducer with a predefined set of actions
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.1 使用预定义动作集的reducer更新状态
- en: A *reducer* is a function that accepts a state value and an action value. It
    generates a new state value based on the two values passed in. It then returns
    the new state value, as shown in figure 3.3.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*reducer*是一个函数，它接受一个状态值和一个动作值。它根据传入的两个值生成一个新的状态值。然后，它返回新的状态值，如图3.3所示。'
- en: '![](../Images/3-3.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图3-3](../Images/3-3.png)'
- en: Figure 3.3 A reducer takes a state and an action and returns a new state.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 一个reducer接受一个状态和一个动作，并返回一个新的状态。
- en: The state and action can be simple, primitive values like numbers or strings,
    or more complicated objects. With a reducer, you keep all of the ways of updating
    the state in one place, which makes it easier to manage state changes, particularly
    when a single action affects multiple pieces of state.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 状态和动作可以是简单的、原始的值，如数字或字符串，或者更复杂的对象。使用还原器，你将所有更新状态的方式集中在一个地方，这使得管理状态变化变得更容易，尤其是在单个动作影响多个状态时。
- en: 'We get back to the `BookablesList` component shortly, after a super-simple
    example. Say your state’s just a counter and there are only two actions you can
    take: increment the counter or decrement the counter. The following listing shows
    a reducer that manages such a counter. The value of the `count` variable starts
    at 0 and changes to 1, to 2, and then back to 1.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个超级简单的例子之后，我们将回到`BookablesList`组件。比如说，你的状态只是一个计数器，你只能执行两种动作：增加计数器或减少计数器。下面的列表显示了一个管理此类计数器的还原器。`count`变量的值从0开始，变为1，然后变为2，然后又回到1。
- en: 'Code on JS Bin: [https://jsbin.com/capogug/edit?js,console](https://jsbin.com/capogug/edit?js,console)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 代码在JS Bin上：[https://jsbin.com/capogug/edit?js,console](https://jsbin.com/capogug/edit?js,console)
- en: Listing 3.2 A simple reducer for a counter
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.2 一个简单的计数器还原器
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Create a reducer function that accepts the existing state and an action.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个接受现有状态和动作的还原器函数。
- en: ❷ Check which action is specified and update state accordingly.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 检查指定的动作，并相应地更新状态。
- en: ❸ Handle missing or unrecognized actions.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 处理缺失或不识别的动作。
- en: ❹ Use the reducer to increment the counter.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用还原器来增加计数器。
- en: ❺ Use the reducer to decrement the counter.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 使用还原器来减少计数器。
- en: The reducer handles the incrementing and decrementing actions and just returns
    the count unaltered for any other action specified. (Rather than silently ignoring
    unrecognized actions, you could throw an error, depending on the needs of your
    application and the role the reducer is playing.)
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 还原器处理增量和减量动作，并且对于任何其他指定的动作，只返回未更改的计数。（而不是默默地忽略未识别的动作，你可以根据应用程序的需求和还原器所扮演的角色抛出一个错误。）
- en: 'That seems like a bit of overkill for our two little actions, but having a
    reducer makes it easy to extend. Let’s add three more actions, for adding and
    subtracting arbitrary numbers to and from the counter and for setting the counter
    to a specified value. To be able to specify extra values with our action, we need
    to beef it up a bit—let’s make it an object with a type and a payload. Say we
    want to add 3 to the counter; our action looks like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们这两个小小的动作来说，这似乎有点过度，但有了还原器，扩展它就变得容易了。让我们再添加三个动作，用于将任意数字加到计数器上或从计数器上减去，以及将计数器设置为指定的值。为了能够用我们的动作指定额外值，我们需要稍微增强它——让我们将其制作成一个具有类型和有效载荷的对象。比如说，我们想将3加到计数器上；我们的动作看起来像这样：
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The following listing shows the new reducer with its extra powers and calls
    to the reducer passing our beefed-up actions. The value of the `count` variable
    starts at 0 and changes to 3, to -7, to 41, and finally to 42.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了具有额外功能和传递给还原器的动作的新还原器。`count`变量的值从0开始，变为3，然后变为-7，接着变为41，最后变为42。
- en: 'Code on JS Bin: [https://jsbin.com/kokumux/edit?js,console](https://jsbin.com/kokumux/edit?js,console)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 代码在JS Bin上：[https://jsbin.com/kokumux/edit?js,console](https://jsbin.com/kokumux/edit?js,console)
- en: Listing 3.3 Adding more actions and specifying extra values
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.3 添加更多动作并指定额外值
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Now check the action type for the two original actions.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 现在检查两个原始动作的动作类型。
- en: ❷ Use the action payload to perform the new actions.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用动作有效载荷来执行新的动作。
- en: ❸ Pass an object to specify each action.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 通过传递一个对象来指定每个动作。
- en: The last call to the reducer right at the end of listing 3.3 specifies the increment
    action. The increment action doesn’t need any extra information. It always adds
    1 to `count`, so the action doesn’t include a payload property.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.3的最后一个还原器调用指定了增量动作。增量动作不需要任何额外信息。它总是将1加到`count`上，因此动作不包括有效载荷属性。
- en: Let’s put these ideas of state and actions with a type and payload into practice
    in the bookings app by building a reducer for our `BookablesList` component. Then
    we can see how to enlist React’s help to use that reducer to manage the component’s
    state.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在构建`BookablesList`组件的还原器时将这些关于状态和动作类型及有效载荷的想法付诸实践。然后我们可以看到如何利用React的帮助来使用该还原器来管理组件的状态。
- en: 3.2.2 Building a reducer for the BookablesList component
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.2 为BookablesList组件构建还原器
- en: 'The `BookablesList` component has four pieces of state: `group`, `bookableIndex`,
    `hasDetails`, and `bookables` (imported from static.json). The component also
    has four actions to perform on that state: set the group, set the index, toggle
    `hasDetails`, and move to the next bookable. To manage four pieces of state, we
    can use an object with four properties. It’s common to represent both the state
    and the action as objects, as shown in figure 3.4.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`BookablesList` 组件有四项状态：`group`、`bookableIndex`、`hasDetails` 和 `bookables`（从
    `static.json` 导入）。该组件还有四个动作来执行该状态：设置组、设置索引、切换 `hasDetails` 和移动到下一个可预订项。为了管理四项状态，我们可以使用具有四个属性的对象。如图
    3.4 所示，通常将状态和动作都表示为对象。'
- en: '![](../Images/3-4.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/3-4.png)'
- en: Figure 3.4 Pass the reducer a state object and an action object. The reducer
    updates the state based on the action type and payload. The reducer returns the
    new, updated state.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 将状态对象和动作对象传递给 reducer。reducer 根据动作类型和有效负载更新状态。reducer 返回新的、更新后的状态。
- en: The `BookablesList` component imports the bookables data from the static.json
    file. That data won’t change while the `BookablesList` component is mounted, and
    we include it in the initial state for the reducer, using it to find the number
    of bookables in each group.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`BookablesList` 组件从静态的 `static.json` 文件中导入可预订项数据。当 `BookablesList` 组件挂载时，这些数据不会改变，并且我们将其包含在初始状态中，用于在
    reducer 中查找每个组中的可预订项数量。'
- en: The following listing shows a reducer for the `BookablesList` component using
    objects for both the state and the actions. We export it from its own file, reducer.js,
    in the /src/components/Bookables folder.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了使用对象作为状态和动作的 `BookablesList` 组件的 reducer。我们将其从其自己的文件 `reducer.js` 导出，位于
    `/src/components/Bookables` 文件夹中。
- en: 'Branch: 0302-reducer, File: /src/components/Bookables/reducer.js'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0302-reducer，文件：/src/components/Bookables/reducer.js
- en: Listing 3.4 A reducer for the `BookablesList` component
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.4 `BookablesList` 组件的 reducer
- en: '[PRE5]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Use a switch statement to organize the code for each action type.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 switch 语句组织每个动作类型的代码。
- en: ❷ Specify the action type as the comparison for each case.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将动作类型指定为每个 case 的比较。
- en: ❸ Create a case block for each action type.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 为每个动作类型创建一个 case 块。
- en: ❹ Update the group and set the bookableIndex to 0.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 更新组并将可预订项索引设置为 0。
- en: ❺ Use the spread operator to copy existing state properties.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 使用扩展运算符复制现有的状态属性。
- en: ❻ Override existing state properties with any changes.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 使用任何更改覆盖现有的状态属性。
- en: ❼ Count the bookables in the current group.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 计算当前组中的可预订项数量。
- en: ❽ Use the count to wrap from the last index to the first.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 使用计数从最后一个索引到第一个索引进行包装。
- en: ❾ Always include a default case.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 总是包含一个默认情况。
- en: 'Each `case` block returns a new JavaScript object; the previous state is not
    mutated. The object spread operator is used to copy across properties from the
    old state to the new. You then set the property values that need updating on the
    object, overriding those from the previous state, like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `case` 块返回一个新的 JavaScript 对象；前一个状态不会被修改。使用对象扩展运算符来复制旧状态中的属性到新状态。然后，在对象上设置需要更新的属性值，覆盖前一个状态中的值，如下所示：
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Spread the properties of the old state object into the new one.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将旧状态对象的属性扩展到新对象中。
- en: ❷ Override any properties that need updating.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 覆盖任何需要更新的属性。
- en: 'With only four properties in total in our state, we could have set them all
    explicitly:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的状态中总共只有四个属性，我们可以明确地设置它们：
- en: '[PRE7]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Copy across previous values for unchanged properties.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 复制未更改属性的先前值。
- en: Using the spread operator protects the code as it evolves; the state may gain
    new properties in the future, and they all need to be copied across.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用扩展运算符可以保护代码在演变过程中的安全性；状态可能会在未来获得新的属性，并且它们都需要被复制过来。
- en: Notice that the `SET_GROUP` action updates two properties. In addition to updating
    the group to be displayed, it sets the selected bookable index to `0`. When switching
    to a new group, the action automatically selects the first bookable and, as long
    as the group has at least one bookable, the component shows the details for the
    first bookable if the Show Details toggle is checked.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `SET_GROUP` 动作更新了两个属性。除了更新要显示的组外，它还将选定的可预订项索引设置为 `0`。当切换到新组时，动作会自动选择第一个可预订项，并且只要组中至少有一个可预订项，如果已检查显示详情切换，组件将显示第一个可预订项的详情。
- en: 'The reducer also handles a `NEXT_BOOKABLE` action, removing from the `Bookables`
    component the onus for calculating indexes when moving from one bookable to the
    next. This is why including the bookables data in the reducer’s state is helpful;
    we use the count of bookables in a group to wrap from the last bookable to the
    first when incrementing `bookableIndex`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Reducer还处理一个`NEXT_BOOKABLE`动作，从`Bookables`组件中移除了在从一个可预订项移动到下一个时计算索引的责任。这就是为什么在reducer的状态中包含可预订数据是有帮助的；我们使用组中可预订的数量来在增加`bookableIndex`时从最后一个可预订项包裹到第一个：
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Use the bookables data to count the bookables in the current group.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用可预订数据来计算当前组中的可预订数量。
- en: ❷ Use the modulus operator to wrap from the last index to the first.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用取模运算符从最后一个索引包裹到第一个。
- en: We have a reducer set up, but how do we fold it into our component? How do we
    access the state object and call the reducer with our actions? We need the `useReducer`
    hook.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经设置了一个reducer，但如何将其整合到我们的组件中？我们如何访问状态对象并使用我们的动作调用reducer？我们需要`useReducer`钩子。
- en: 3.2.3 Accessing component state and dispatching actions with useReducer
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.3 使用useReducer访问组件状态和发送动作
- en: The `useState` hook lets us ask React to manage single values for our component.
    With the `useReducer` hook, we can give React a bit more help in managing values
    by passing it a reducer and the component’s initial state. When events occur in
    our application, instead of giving React new values to set, we *dispatch* an *action*,
    and React uses the corresponding code in the reducer to generate a new state before
    calling the component for the latest UI.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`useState`钩子让我们请求React管理我们组件的单个值。使用`useReducer`钩子，我们可以通过传递reducer和组件的初始状态来给React提供更多帮助来管理值。当我们的应用程序中发生事件时，我们不是给React提供新值来设置，而是*发送*一个*动作*，React使用reducer中相应的代码来生成一个新的状态，在调用组件以获取最新的UI之前。'
- en: When calling the `useReducer` hook, we pass it the reducer and an initial state.
    The hook returns the current state and a function for dispatching actions, as
    two elements in an array, as shown in figure 3.5.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`useReducer`钩子时，我们传递给它reducer和一个初始状态。钩子返回当前状态和一个用于发送动作的函数，如图3.5所示的两个数组元素。
- en: '![](../Images/3-5.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3-5.png)'
- en: Figure 3.5 Call `useReducer` with a reducer and an initial state. It returns
    the current state and a dispatch function. Use the dispatch function to dispatch
    actions to the reducer.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 使用reducer调用`useReducer`。它返回当前状态和dispatch函数。使用dispatch函数向reducer发送动作。
- en: 'As we did with `useState`, here with `useReducer` we use array destructuring
    to assign the two elements of the returned array to two variables with names of
    our choosing. The first element, the current state, we assign to a variable we
    call `state`, and the second element, the dispatch function, we assign to a variable
    we call `dispatch`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们使用`useState`一样，在这里使用`useReducer`时，我们使用数组解构将返回数组的两个元素分配给两个我们选择的变量名。第一个元素，当前状态，我们分配给一个我们称为`state`的变量，第二个元素，dispatch函数，我们分配给一个我们称为`dispatch`的变量：
- en: '[PRE9]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: React pays attention to only the arguments passed to `useReducer` (in our case,
    `reducer` and `initialState`) the first time React invokes the component. On subsequent
    invocations, it ignores the arguments but still returns the current state and
    the dispatch function for the reducer.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: React只关注第一次调用组件时传递给`useReducer`（在我们的情况下，`reducer`和`initialState`）的参数。在随后的调用中，它忽略这些参数，但仍然返回当前状态和reducer的dispatch函数。
- en: Let’s get the `useReducer` hook up and running in the `BookablesList` component
    and start dispatching some actions! The following listing shows the changes.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`BookablesList`组件中使用`useReducer`钩子并开始发送一些动作！以下列表显示了更改。
- en: 'Branch: 0302-reducer, File: /src/components/Bookables/BookablesList.js'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0302-reducer，文件：/src/components/Bookables/BookablesList.js
- en: Listing 3.5 The `BookablesList` component using a reducer
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.5 使用reducer的`BookablesList`组件
- en: '[PRE10]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Import the useReducer hook.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入useReducer钩子。
- en: ❷ Import the reducer from listing 3.4.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从列表3.4中导入reducer。
- en: ❸ Specify an initial state.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 指定一个初始状态。
- en: ❹ Call useReducer, passing the reducer and the initial state.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 调用useReducer，传递reducer和初始状态。
- en: ❺ Assign state values to local variables.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将状态值分配给局部变量。
- en: ❻ Dispatch an action with a type and a payload.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 发送一个带有类型和负载的动作。
- en: ❼ Dispatch an action that doesn’t need a payload.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 发送一个不需要负载的动作。
- en: ❽ Call the new changeBookable function.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 调用新的changeBookable函数。
- en: ❾ Call the new toggleDetails function.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 调用新的toggleDetails函数。
- en: 'Listing 3.5 imports the reducer we created in listing 3.4, sets up an initial
    state object, and then, in the component code itself, passes the reducer and initial
    state to `useReducer`. Next, `useReducer` returns the current state and the dispatch
    function, and we assign them to variables, `state` and `dispatch`, using array
    destructuring. The listing uses an intermediate `state` variable and then destructures
    the state object into individual variables—`group`, `bookableIndex`, `bookables`,
    and `hasDetails`—but you could do the object destructuring directly inside the
    array destructuring:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.5导入了我们在列表3.4中创建的reducer，设置了一个初始状态对象，然后在组件代码中，将reducer和初始状态传递给`useReducer`。接下来，`useReducer`返回当前状态和`dispatch`函数，我们使用数组解构将它们分配给变量`state`和`dispatch`。该列表使用一个中间的`state`变量，然后将状态对象解构为单个变量——`group`、`bookableIndex`、`bookables`和`hasDetails`——但你也可以直接在数组解构中执行对象解构：
- en: '[PRE11]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the event handlers, the `BookablesList` component now dispatches actions
    rather than updating individual state values via `useState`. We use separate event
    handler functions (`changeGroup`, `changeBookable`, `nextBookable`, `toggleDetails`),
    but you could easily dispatch actions inline within the UI. For example, you could
    set up the Show Details check box like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件处理程序中，`BookablesList`组件现在发送动作而不是通过`useState`更新单个状态值。我们使用单独的事件处理函数（`changeGroup`、`changeBookable`、`nextBookable`、`toggleDetails`），但你也可以在UI内轻松地内联发送动作。例如，你可以设置显示详情复选框如下：
- en: '[PRE12]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Either approach is fine, as long as you (and your team) find the code easy to
    read and understand.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 任何一种方法都可以，只要你觉得代码易于阅读和理解。
- en: Although the example is simple, you should appreciate how a reducer can help
    structure your code, your state mutations, and your understanding, particularly
    as the component state becomes more complex. If your state is complex and/or the
    initial state is expensive to set up or is generated by a function you’d like
    to reuse or import, the `useReducer` hook has a third argument you can use. Let’s
    check it out.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然示例很简单，但你应该欣赏reducer如何帮助你结构化代码、状态变更以及理解，尤其是当组件状态变得更加复杂时。如果你的状态复杂，或者初始状态设置成本很高，或者是由你希望重用或导入的函数生成的，`useReducer`钩子有一个第三个参数你可以使用。让我们来看看。
- en: 3.3 Generating the initial state with a function
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 使用函数生成初始状态
- en: You saw in chapter 2 that we can generate the initial state for `useState` by
    passing a function to the hook. Similarly, with `useReducer`, as well as passing
    an initialization argument as the second argument, we can pass an initialization
    function as the third argument. The initialization function uses the initialization
    argument to generate the initial state, as shown in figure 3.6.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你在第二章中看到，我们可以通过将函数传递给钩子来生成`useState`的初始状态。同样，对于`useReducer`，除了将初始化参数作为第二个参数外，我们还可以将初始化函数作为第三个参数。初始化函数使用初始化参数来生成初始状态，如图3.6所示。
- en: '![](../Images/3-6.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/3-6.png)'
- en: Figure 3.6 The initialization function for `useReducer` uses the initialization
    argument to generate the reducer’s initial state.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 `useReducer`的初始化函数使用初始化参数来生成reducer的初始状态。
- en: 'As usual, `useReducer` returns an array with two elements: the state and a
    dispatch function. On the first call, the state is the return value of the initialization
    function. On subsequent calls, it is the state at the time of the call:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 与往常一样，`useReducer`返回一个包含两个元素的数组：状态和`dispatch`函数。在第一次调用时，状态是初始化函数的返回值。在后续调用中，它是调用时的状态：
- en: '[PRE13]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Use the dispatch function to dispatch actions to the reducer. For a particular
    call to `useReducer`, React will always return the same dispatch function. (Having
    an unchanging function is important when re-renders may depend on changing props
    or dependencies, as you’ll see in later chapters.)
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`dispatch`函数向reducer发送动作。对于`useReducer`的特定调用，React将始终返回相同的`dispatch`函数。（当重新渲染可能依赖于变化的props或依赖项时，拥有一个不变的函数很重要，你将在后面的章节中看到。）
- en: 'In this section, we put `useReducer`’s initialization function argument to
    use as we start work on a second component for the bookings app, the `WeekPicker`
    component. We split the work into five subsections:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们开始为预订应用开发第二个组件，即`WeekPicker`组件，我们将工作分为五个小节：
- en: Introducing the `WeekPicker` component
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍`WeekPicker`组件
- en: Creating utility functions to work with dates and weeks
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建用于处理日期和周的工作函数
- en: Building the reducer to manage dates for the component
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建reducer来管理组件的日期
- en: Creating `WeekPicker`, passing an initialization function to the `useReducer`
    hook
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 `WeekPicker`，将初始化函数传递给 `useReducer` 钩子
- en: Updating `BookingsPage` to use `WeekPicker`
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `BookingsPage` 更新为使用 `WeekPicker`
- en: 3.3.1 Introducing the WeekPicker component
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.1 介绍 `WeekPicker` 组件
- en: So far in the bookings app, we’ve been concentrating on the `BookablesList`
    component, displaying a list of bookables. To set the groundwork for actually
    booking a resource, we need to start thinking about calendars; in the finished
    app, our users will pick a date and session from a bookings grid calendar, as
    shown in figure 3.7.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在预订应用中，我们一直专注于 `BookablesList` 组件，显示可预订项目的列表。为了为实际预订资源打下基础，我们需要开始考虑日历；在完成的应用中，我们的用户将从一个预订网格日历中选择日期和时段，如图3.7所示。
- en: '![](../Images/3-7.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3-7.png)'
- en: Figure 3.7 The bookings page will include a list of bookables, a bookings grid,
    and a week picker.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 预订页面将包括可预订项目的列表、预订网格和周选择器。
- en: 'Let’s start small and just consider the interface for switching between one
    week and the next. Figure 3.8 shows a possible interface for picking the week
    to show in the bookings grid. It includes the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单开始，只考虑在一周和下一周之间切换的界面。图3.8显示了在预订网格中显示周的选择可能界面。它包括以下内容：
- en: The start and end dates for the selected week
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择周的开始和结束日期
- en: Buttons to move to the next and previous weeks
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于移动到下一周和上一周的按钮
- en: A button to show the week containing today’s date
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个按钮用于显示包含今天日期的那一周
- en: '![](../Images/3-8.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3-8.png)'
- en: Figure 3.8 The `WeekPicker` component shows the start and end dates for the
    chosen week and has buttons to navigate between weeks.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 `WeekPicker` 组件显示了所选周的起始和结束日期，并具有在周之间导航的按钮。
- en: Later in the book, we’ll add an input for jumping straight to a specific date.
    For now, we’ll stick with our three buttons and week date text. To get the start
    and end dates for a specified week, we need a couple of utility functions to wrangle
    JavaScript’s date object. Let’s conjure those first.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的后面部分，我们将添加一个直接跳转到特定日期的输入。现在，我们将坚持使用我们的三个按钮和周日期文本。为了获取指定周的起始和结束日期，我们需要几个实用函数来处理JavaScript的日期对象。让我们首先创建这些函数。
- en: 3.3.2 Creating utility functions to work with dates and weeks
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.2 创建用于处理日期和周的实用函数
- en: 'Our bookings grid will show one week at a time, running from Sunday to Saturday.
    On any particular date, we show the week that contains that date. Let’s create
    objects that represent a week, with a particular date in the week and the dates
    for the start and end of the week:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的预订网格将一次显示一周，从周日到周六。在特定日期，我们显示包含该日期的那一周。让我们创建代表一周的对象，包括一周中的特定日期以及一周的开始和结束日期：
- en: '[PRE14]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ JavaScript Date object for a particular date
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 指定日期的JavaScript Date对象
- en: ❷ Date object for the start of the week containing date
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 包含特定日期的一周开始日期的日期对象
- en: ❸ Date object for the end of the week
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 一周结束日期的日期对象
- en: 'For example, take Wednesday, April 1, 2020\. The start of the week was Sunday,
    March 29, 2020, and the end of the week was Saturday, April 4, 2020:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑2020年4月1日星期三。一周的开始是2020年3月29日星期日，一周的结束是2020年4月4日星期六：
- en: '[PRE15]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ Assign each property a JavaScript Date object for the specified date.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 为指定的日期分配一个JavaScript Date对象。
- en: 'The following listing shows a couple of utility functions: one to create a
    new date from an old date, offset by a number of days, and the second to generate
    the week objects. The file is called date-wrangler.js and is in a new /src/utils
    folder.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了几个实用函数：一个用于从旧日期创建新日期，偏移指定天数，另一个用于生成周对象。该文件名为date-wrangler.js，位于新的/src/utils文件夹中。
- en: 'Branch: 0303-week-picker, File: /src/utils/date-wrangler.js'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0303-week-picker，文件：/src/utils/date-wrangler.js
- en: Listing 3.6 Date-wrangling utility functions
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.6 日期处理实用函数
- en: '[PRE16]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ Shift the date by the number of days specified.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将日期按指定天数移动。
- en: ❷ Immediately shift the date.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 立即移动日期。
- en: ❸ Get the day index for the new date, for example, Tuesday = 2.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 获取新日期的天数索引，例如，星期二=2。
- en: ❹ For example, if it’s Tuesday, shift back by 2 days.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 例如，如果今天是星期二，则后退2天。
- en: ❺ For example, if it’s Tuesday, shift forward by 4 days.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 例如，如果今天是星期二，则向前推进4天。
- en: 'The `getWeek` function uses the `getDay` method of JavaScript’s `Date` object
    to get the day-of-the-week index of the specified date: Sunday is 0, Monday is
    1, . . . , Saturday is 6\. To get to the start of the week, the function subtracts
    the same number of days as the day index: for Sunday, it subtracts 0 days; for
    Monday, it subtracts 1 day; . . . ; for Saturday, it subtracts 6 days. The end
    of the week is 6 days after the start of the week, so to get the end of the week,
    the function performs the same subtraction as for the start of the week but also
    adds 6\. We can use the `getWeek` function to generate a week object for a given
    date:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`getWeek`函数使用JavaScript的`Date`对象的`getDay`方法来获取指定日期的星期索引：星期天是0，星期一是1，...，星期六是6。为了到达一周的开始，函数减去与日索引相同的日期数：对于星期天，它减去0天；对于星期一，它减去1天；...；对于星期六，它减去6天。一周的结束是一周开始后的6天，因此为了得到一周的结束，函数执行与一周开始相同的减法，但也要加上6。我们可以使用`getWeek`函数为给定日期生成一个周对象：'
- en: '[PRE17]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ Get the week object for the week containing today’s date.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 获取包含今天日期的周的周对象。
- en: 'We can also specify an offset number of days as the second argument if we want
    the week object for a date relative to the date in the first argument:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想获取相对于第一个参数中日期的日期的周对象，我们可以将偏移天数作为第二个参数指定：
- en: '[PRE18]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Get the week object for the week containing the date a week from today.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 获取包含今天日期一周的周对象。
- en: The `getWeek` function lets us generate week objects as we navigate from week
    to week in the bookings app. Let’s use it to do just that in a reducer.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`getWeek`函数让我们在预订应用中从一周导航到另一周时生成周对象。让我们在reducer中用它来做这件事。'
- en: 3.3.3 Building the reducer to manage dates for the component
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.3 为组件构建reducer以管理日期
- en: 'A reducer helps us to centralize the state management logic for our `WeekPicker`
    component. In a single place, we can see all of the possible actions and how they
    update the state:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Reducer帮助我们集中管理`WeekPicker`组件的状态逻辑。在一个地方，我们可以看到所有可能的操作以及它们如何更新状态：
- en: Move to the next week by adding seven days to the current date.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将当前日期加上七天来移动到下个星期。
- en: Move to the previous week by subtracting seven days from the current date.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过从当前日期减去七天来移动到上一个星期。
- en: Move to today by setting the current date to today’s date.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将当前日期设置为今天的日期来移动到今天。
- en: Move to a specified date by setting the current date to the action’s payload.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将当前日期设置为操作的负载来移动到指定的日期。
- en: For each action, the reducer returns a week object as described in the previous
    section. Although we really need to track only a single date, we would need to
    generate the week object at some point, and abstracting the week object generation
    along with the reducer seems sensible to me. You can see how the possible state
    changes translate to a reducer in the following listing. We put the weekReducer.js
    file in the Bookings folder.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个操作，reducer返回一个与上一节中描述的周对象。虽然我们实际上只需要跟踪一个日期，但我们可能需要在某个时候生成周对象，并且将周对象生成与reducer一起抽象化对我来说似乎是合理的。您可以在以下列表中看到可能的状态变化如何转换为reducer。我们将weekReducer.js文件放在Bookings文件夹中。
- en: 'Branch: 0303-week-picker, File: /src/components/Bookings/weekReducer.js'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0303-week-picker，文件：/src/components/Bookings/weekReducer.js
- en: Listing 3.7 The reducer for `WeekPicker`
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.7 `WeekPicker`的reducer
- en: '[PRE19]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Import the getWeek function.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入`getWeek`函数。
- en: ❷ Return a week object for 7 days ahead.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 返回7天后的周对象。
- en: ❸ Return a week object for 7 days before.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 返回7天前的周对象。
- en: ❹ Return a week object for today.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 返回今天的周对象。
- en: ❺ Return a week object for a specified date.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 返回指定日期的周对象。
- en: The reducer imports the `getWeek` function to generate the week object for each
    state change. Having the `getWeek` function available to import means we can also
    use it as an initialization function when we call the `useReducer` hook in the
    `WeekPicker` component.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Reducer导入`getWeek`函数以生成每个状态变化时的周对象。有`getWeek`函数可供导入意味着我们也可以在调用`WeekPicker`组件中的`useReducer`钩子时将其用作初始化函数。
- en: 3.3.4 Passing an initialization function to the useReducer hook
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.4 将初始化函数传递给`useReducer`钩子
- en: The `WeekPicker` component lets users navigate from week to week to book resources
    in the company. We set up the reducer in the preceding section; now it’s time
    to use it. The reducer needs an initial state, a week object. The following listing
    shows how we can use the `getWeek` function to generate the initial week object
    from a date we pass to `WeekPicker` as a prop. The WeekPicker.js file is also
    in the Bookings folder.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`WeekPicker` 组件允许用户从周切换到周，在公司预订资源。我们在前面的部分设置了 reducer；现在是时候使用它了。reducer 需要一个初始状态，一个周对象。下面的列表展示了我们如何使用
    `getWeek` 函数从传递给 `WeekPicker` 作为属性的日期生成初始周对象。WeekPicker.js 文件也在 Bookings 文件夹中。'
- en: 'Branch: 0303-week-picker, File: /src/components/Bookings/WeekPicker.js'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0303-week-picker，文件：/src/components/Bookings/WeekPicker.js
- en: Listing 3.8 The `WeekPicker` component
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.8 `WeekPicker` 组件
- en: '[PRE20]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ Import the getWeek date-wrangler function.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入 getWeek 日期处理函数。
- en: ❷ Receive the initial date as a prop.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 接收初始日期作为属性。
- en: ❸ Generate the initial state, passing date to getWeek.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 生成初始状态，将日期传递给 getWeek。
- en: ❹ Dispatch actions to the reducer to switch weeks.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 向 reducer 发送动作以切换周。
- en: ❺ Use the current state to display the date info.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 使用当前状态来显示日期信息。
- en: 'Our call to `useReducer` passes the specified date to the `getWeek` function.
    The `getWeek` function returns a week object that is set as the initial state.
    We assign the state that `useReducer` returns to a variable called `week`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用 `useReducer` 时，将指定的日期传递给 `getWeek` 函数。`getWeek` 函数返回一个设置为初始状态的周对象。我们将 `useReducer`
    返回的状态分配给一个名为 `week` 的变量：
- en: '[PRE21]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In addition to letting us reuse the `getWeek` function to generate state (in
    the reducer and the `WeekPicker` component), the initialization function (`useReducer`’s
    third argument) also allows us to run expensive state generation functions once
    only, on the initial call to `useReducer`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 除了让我们能够重用 `getWeek` 函数来生成状态（在 reducer 和 `WeekPicker` 组件中），初始化函数（`useReducer`
    的第三个参数）还允许我们在 `useReducer` 的初始调用中仅运行一次昂贵的状态生成函数。
- en: At last, a new component! Let’s hook it up to `BookingsPage`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一个新的组件！让我们将其连接到 `BookingsPage`。
- en: 3.3.5 Updating BookingsPage to use WeekPicker
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.5 将 BookingsPage 更新为使用 WeekPicker
- en: The following listing shows an updated `BookingsPage` component that imports
    and renders the `WeekPicker` component. The resulting page is shown in figure
    3.9.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表展示了更新后的 `BookingsPage` 组件，它导入并渲染了 `WeekPicker` 组件。结果页面如图 3.9 所示。
- en: 'Branch: 0303-week-picker, File: /src/components/Bookings/BookingsPage.js'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0303-week-picker，文件：/src/components/Bookings/BookingsPage.js
- en: Listing 3.9 The `BookingsPage` component using `WeekPicker`
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.9 使用 `WeekPicker` 的 `BookingsPage` 组件
- en: '[PRE22]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ Import the WeekPicker component.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入 WeekPicker 组件。
- en: ❷ Include the WeekPicker in the UI, passing it the current date.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在 UI 中包含 WeekPicker，并传递当前日期。
- en: '![](../Images/3-9.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3-9.png)'
- en: Figure 3.9 The `BookingsPage` component with the `WeekPicker` component in place
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9 带有 `WeekPicker` 组件的 `BookingsPage` 组件
- en: '`BookingsPage` passes the `WeekPicker` component the current date. The week
    picker first appears showing the start and end dates of the current week, from
    Sunday to Saturday. Have a go navigating from week to week and then click the
    Today button to jump back to the present week. It’s a simple component but helps
    drive the bookings grid in chapters to come. And it provides an example of `useReducer`’s
    initialization function argument.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`BookingsPage` 将当前日期传递给 `WeekPicker` 组件。周选择器首先显示当前周的起始和结束日期，从周日到周六。尝试从周切换到周，然后点击
    Today 按钮回到当前周。这是一个简单的组件，但有助于推动后续章节中的预订网格。它还提供了一个 `useReducer` 初始化函数参数的例子。'
- en: Before this chapter’s formal Summary section, let’s briefly recap some of the
    key concepts we’ve encountered, building your understanding of function components
    and hooks.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章正式的总结部分之前，让我们简要回顾一下我们遇到的一些关键概念，以加深你对函数组件和钩子的理解。
- en: 3.4 Reviewing some useReducer concepts
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 回顾一些 useReducer 概念
- en: A bit more jargon has crept into this discussion, so just in case all the actions,
    reducers, and dispatch functions are causing some dizziness, table 3.1 describes
    the terms with examples. Take a breather!
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论中混入了一些术语，所以如果所有的动作、reducer 和 dispatch 函数让你感到头晕，表 3.1 用例子描述了这些术语。喘口气吧！
- en: Table 3.1 Some of the key terms we’ve met
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.1 我们遇到的一些关键术语
- en: '| Icon | Term | Description | Example |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| 图标 | 术语 | 描述 | 示例 |'
- en: '| ![](../Images/3-unnumb-1.png) | Initial state | The values of variables and
    properties when the component first runs | `{``group: "Rooms",``bookableIndex:
    0,``hasDetails: false``}` |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| ![图片](../Images/3-unnumb-1.png) | 初始状态 | 组件首次运行时变量和属性的值 | `{``group: "Rooms",``bookableIndex:
    0,``hasDetails: false``}` |'
- en: '| ![](../Images/3-unnumb-2.png) | Action | Information that the reducer uses
    to update the state | `{``type: "SET_BOOKABLE",``payload: 1``}` |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| ![图片](../Images/3-unnumb-2.png) | 动作 | Reducer使用的用于更新状态的信息 | `{``type: "SET_BOOKABLE",``payload:
    1``}` |'
- en: '| ![](../Images/3-unnumb-3.png) | Reducer | A function React passes the current
    state and an action. It creates a new state from the current state, depending
    on the action. | `(state, action) => {``// check action``// update state based``//
    on action type and``// action payload``// return new state``};` |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| ![图片](../Images/3-unnumb-3.png) | Reducer | React传递当前状态和动作的函数。根据动作创建新的状态。
    | `(state, action) => {``// 检查动作``// 根据动作类型和``// 动作负载更新状态``// 返回新状态``};` |'
- en: '| ![](../Images/3-unnumb-4.png) | State | The values of variables and`properties
    at a particular point``in execution` | `{``group: "Rooms",``bookableIndex: 1,``hasDetails:
    false``}` |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| ![图片](../Images/3-unnumb-4.png) | 状态 | 执行特定点的变量和属性的值 | `{``group: "Rooms",``bookableIndex:
    1,``hasDetails: false``}` |'
- en: '| ![](../Images/3-unnumb-5.png) | Dispatch`function` | A function for dispatching
    actions to the reducer. Use it to tell the reducer what action to take. | `dispatch({``type:
    "SET_BOOKABLE",``payload: 1``});` |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| ![图片](../Images/3-unnumb-5.png) | 分发函数 | 用于向reducer分发动作的函数。用它来告诉reducer要采取什么动作。
    | `dispatch({``type: "SET_BOOKABLE",``payload: 1``});` |'
- en: Once we pass the reducer and initial state to React via our call to `useReducer`,
    it manages the state for us. We just have to dispatch actions, and React will
    use the reducer to update the state depending on which action it receives. Remember,
    our component code returns a description of its UI. Having updated the state,
    React knows it may need to update the UI, so it will call our component code again,
    passing it the latest state and the dispatcher function when the component calls
    `useReducer`. To reinforce the functional nature of our components, figure 3.10
    illustrates each step when React first calls the `BookablesList` component and
    a user then fires an event by selecting a group, choosing a bookable, or toggling
    the Show Details check box.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们通过调用`useReducer`将reducer和初始状态传递给React，它就会为我们管理状态。我们只需分发动作，React将根据接收到的动作使用reducer来更新状态。记住，我们的组件代码返回其UI的描述。更新了状态后，React知道它可能需要更新UI，因此它将再次调用我们的组件代码，当组件调用`useReducer`时，传递给它最新的状态和分发函数。为了强调组件的函数性，图3.10展示了React首次调用`BookablesList`组件时，用户通过选择组、选择可预订项或切换显示详细信息复选框来触发事件时的每个步骤。
- en: Table 3.2 lists the steps from figure 3.10, describing what is happening and
    including short discussions of each one.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.2列出了图3.10中的步骤，描述了正在发生的事情，并对每个步骤进行了简要讨论。
- en: '![](../Images/3-10.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/3-10.png)'
- en: Figure 3.10 Stepping through the key moments when using `useReducer`
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10 使用`useReducer`时的关键时刻步骤
- en: Each time it needs the UI, React invokes the component code. The component function
    runs to completion, and local variables are created during execution, and destroyed
    or referenced in closures when the function ends. The function returns a description
    of the UI for the component. The component uses hooks, like `useState` and `useReducer`,
    to persist state across invocations and to receive updater and dispatch functions.
    Event handlers call the updater functions or dispatch actions in response to user
    actions, and React can update the state and call the component code again, restarting
    the cycle.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 每次需要UI时，React都会调用组件代码。组件函数运行至完成，并在执行过程中创建局部变量，当函数结束时，这些变量会被销毁或在闭包中被引用。函数返回组件的UI描述。组件使用钩子，如`useState`和`useReducer`，来在调用之间保持状态，并接收更新器和分发函数。事件处理程序在用户操作时调用更新器函数或分发动作，React可以更新状态并再次调用组件代码，重新开始循环。
- en: Table 3.2 Some key steps when using useReducer
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.2 使用`useReducer`时的关键步骤
- en: '| Step | What happens? | Discussion |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| 步骤 | 发生了什么？ | 讨论 |'
- en: '| 1 | React calls the component. | To generate the UI for the page, React traverses
    the tree of components, calling each one. React will pass each component any props
    set as attributes in the JSX. |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| 1 | React调用组件。 | 为了生成页面的UI，React遍历组件树，调用每个组件。React将传递给每个组件任何在JSX中设置的属性作为props。
    |'
- en: '| 2 | The component calls `useReducer` for the first time. | The component
    passes the initial state and the reducer to the `useReducer` function. React sets
    the current state for the reducer as the initial state. |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 组件第一次调用 `useReducer`。 | 组件将初始状态和 reducer 传递给 `useReducer` 函数。React 将
    reducer 的当前状态设置为初始状态。|'
- en: '| 3 | React returns the current state and the dispatch function as an array.
    | The component code assigns the state and dispatch function to variables for
    later use. The variables are often called `state` and `dispatch`, or we might
    destructure the state into further variables. |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| 3 | React 返回当前状态和 dispatch 函数作为一个数组。 | 组件代码将状态和 dispatch 函数分配给变量以供后续使用。这些变量通常被称为
    `state` 和 `dispatch`，或者我们可能将状态进一步解构为其他变量。|'
- en: '| 4 | The component sets up an event handler. | The event handler may listen
    for user clicks, timers firing, or resources loading, for example. The handler
    will dispatch an action to change the state. |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 组件设置一个事件处理器。 | 事件处理器可能监听用户点击、计时器触发或资源加载等。处理器将派发一个动作来改变状态。|'
- en: '| 5 | The component returns its UI. | The component uses the current state
    to generate its user interface and returns it, finishing its work. React compares
    the new UI to the old and updates the DOM. |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 组件返回其 UI。 | 组件使用当前状态来生成其用户界面并返回它，完成其工作。React 将新 UI 与旧 UI 进行比较并更新 DOM。|'
- en: '| 6 | The event handler dispatches an action. | An event fires, and the handler
    runs. The handler uses the dispatch function to dispatch an action. |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 事件处理器派发一个动作。 | 发生了一个事件，处理器运行。处理器使用 dispatch 函数来派发一个动作。|'
- en: '| 7 | React calls the reducer. | React passes the current state and the dispatched
    action to the reducer. |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| 7 | React 调用 reducer。 | React 将当前状态和已派发的动作传递给 reducer。|'
- en: '| 8 | The reducer returns the new state. | The reducer uses the action to update
    the state and returns the new version. |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| 8 | reducer 返回新的状态。 | reducer 使用动作来更新状态并返回新版本。|'
- en: '| 9 | React calls the component. | React knows the state has changed and so
    must recalculate the UI. |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| 9 | React 调用组件。 | React 知道状态已更改，因此必须重新计算 UI。|'
- en: '| 10 | The component calls `useReducer` for the second time. | This time, React
    will ignore the arguments. |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 组件第二次调用 `useReducer`。 | 这次，React 将忽略这些参数。|'
- en: '| 11 | React returns the current state and the dispatch function. | The state
    has been updated by the reducer, and the component needs the latest values. The
    dispatch function is the exact same function as React returned for the previous
    call to `useReducer`. |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| 11 | React 返回当前状态和 dispatch 函数。 | 状态已被 reducer 更新，组件需要最新的值。dispatch 函数与 React
    在前一次 `useReducer` 调用返回的函数完全相同。|'
- en: '| 12 | The component sets up an event handler. | This is a new version of the
    handler and may use some of the newly updated state values. |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| 12 | 组件设置一个事件处理器。 | 这是一个新版本的事件处理器，可能使用一些新更新的状态值。|'
- en: '| 13 | The component returns its UI. | The component uses the current state
    to generate its user interface and returns it, finishing its work. React compares
    the new UI to the old and updates the DOM. |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| 13 | 组件返回其 UI。 | 组件使用当前状态来生成其用户界面并返回它，完成其工作。React 将新 UI 与旧 UI 进行比较并更新 DOM。|'
- en: Summary
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'If you have multiple pieces of interrelated state, consider using a reducer
    to clearly define the actions that can change the state. A reducer is a function
    to which you pass the current state and an action. It uses the action to generate
    a new state. It returns the new state:'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你有多块相互关联的状态，考虑使用 reducer 来清晰地定义可以改变状态的动作。reducer 是一个函数，你向它传递当前状态和动作。它使用动作来生成新状态。它返回新状态：
- en: '[PRE23]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Call the `useReducer` hook when you want React to manage the state and reducer
    for a component. Pass it the reducer and an initial state. It returns an array
    with two elements, the state and a dispatch function:'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你想要 React 为组件管理状态和 reducer 时，调用 `useReducer` 钩子。传递给它 reducer 和初始状态。它返回一个包含两个元素的数组，即状态和
    dispatch 函数：
- en: '[PRE24]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Call the `useReducer` hook with an initialization argument and an initialization
    function to generate the initial state when the hook is first called. The hook
    automatically passes the initialization argument to the initialization function.
    The initialization function returns the initial state for the reducer. This is
    useful when initialization is expensive or when you want to use an existing function
    to initialize the state:'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用带有初始化参数和初始化函数的`useReducer`钩子来生成初始状态，当钩子首次被调用时。钩子会自动将初始化参数传递给初始化函数。初始化函数返回reducer的初始状态。这在初始化成本高昂或您想使用现有函数初始化状态时很有用：
- en: '[PRE25]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Use the `dispatch` function to dispatch an action. React will pass the current
    state and the action to the reducer. It will replace the state with the new state
    generated by the reducer. It will re-render if the state has changed:'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`dispatch`函数派发一个动作。React会将当前状态和动作传递给reducer。如果状态已更改，它将用reducer生成的新状态替换状态，并重新渲染：
- en: '[PRE26]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'For anything more than the most basic actions, consider following common practice
    and specify the action as a JavaScript object with `type` and `payload` properties:'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于比最基本动作更复杂的情况，考虑遵循常见做法，并将动作指定为具有`type`和`payload`属性的JavaScript对象：
- en: '[PRE27]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: React always returns the same `dispatch` function for a particular call to `useReducer`
    within a component. (If the `dispatch` function changed between calls, it could
    cause unnecessary re-renders when passed as a prop or included as a dependency
    for other hooks.)
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React总是为组件中特定调用`useReducer`返回相同的`dispatch`函数。（如果`dispatch`函数在调用之间发生变化，当作为prop传递或作为其他钩子的依赖项包含时，可能会引起不必要的重新渲染。）
- en: 'In the reducer, use `if` or `switch` statements to check for the type of action
    dispatched:'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在reducer中，使用`if`或`switch`语句检查派发的动作类型：
- en: '[PRE28]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the `default` case, either return the unchanged state (if the reducer will
    be combined with other reducers, for example) or throw an error (if the reducer
    should never receive an unknown action type).
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`默认`情况下，要么返回未更改的状态（如果reducer将与其他reducer组合，例如）或者抛出错误（如果reducer不应该接收未知动作类型）。
