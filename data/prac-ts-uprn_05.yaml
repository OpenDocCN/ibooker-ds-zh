- en: Chapter 5\. Storing Temporal Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章。存储时间数据
- en: Often, the value of time series data comes in its retrospective, rather than
    live streaming, scenarios. For this reason, storage of time series data is necessary
    for most time series analysis.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列数据的价值通常体现在回顾性而非实时流式场景中。因此，对于大多数时间序列分析来说，存储时间序列数据是必要的。
- en: A good storage solution is one that enables ease of access and reliability of
    data without requiring a major investment of computing resources. In this chapter,
    we will discuss what aspects of a data set you should consider when designing
    for time series data storage. We will also discuss the advantages of SQL databases,
    NoSQL databases, and a variety of flat file formats.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一个良好的存储解决方案应该能够在不需要大量计算资源投入的情况下，实现数据的轻松访问和可靠性。在本章中，我们将讨论设计时间序列数据存储时应考虑的数据集的各个方面。我们还将讨论SQL数据库、NoSQL数据库以及各种平面文件格式的优势。
- en: Designing a general time series storage solution is a challenge because there
    are so many different kinds of time series data, each with different storage,
    read/write, and analysis patterns. Some data will be stored and examined repeatedly,
    whereas other data is useful only for a short period of time, after which it can
    be deleted altogether.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 设计通用的时间序列存储解决方案是一项挑战，因为有许多不同种类的时间序列数据，每种数据都具有不同的存储、读写和分析模式。一些数据将被反复存储和检查，而其他数据只在短时间内有用，之后可以完全删除。
- en: 'Here are a few use cases for time series storage that have different read,
    write, and query patterns:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个时间序列存储的使用案例，它们具有不同的读、写和查询模式：
- en: You are collecting performance metrics on a production system. You need to store
    these performance metrics for years at a time, but the older the data gets, the
    less detailed it needs to be. Hence you need a form of storage that will automatically
    downsample and cull data as information ages.
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您正在收集生产系统的性能指标。您需要将这些性能指标存储多年，但数据变老越久，它的详细程度就越低。因此，您需要一种存储形式，能够随着信息老化自动进行降采样和剪辑。
- en: You have access to a remote open source time series data repository, but you
    need to keep a local copy on your computer to cut down on network traffic. The
    remote repository stores each time series in a folder of files available for download
    on a web server, but you’d like to collapse all these files into a single database
    for simplicity. The data should be immutable and able to be stored indefinitely,
    as it is intended to be a reliable copy of the remote repository.
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以访问远程开源时间序列数据存储库，但需要在您的计算机上保留本地副本以减少网络流量。远程存储库将每个时间序列存储在一个可通过Web服务器下载的文件夹中，但您希望将所有这些文件合并到一个单一的数据库中，以简化操作。数据应该是不可变的，并且能够无限期地存储，因为它旨在是远程存储库的可靠副本。
- en: You created your own time series data by integrating a variety of data sources
    at different timescales and with different preprocessing and formatting. The data
    collection and processing was laborious and time-consuming. You’d like to store
    the data in its final form rather than running a preprocessing step on it repeatedly,
    but you’d also like to keep the raw data in case you later investigate preprocessing
    alternatives. You expect to revisit the processed and raw data often as you develop
    new machine learning models, refitting new models on the same data and also adding
    to your data over time as new, more recent raw data becomes available. You will
    never downsample or cull data in storage even if you do so for your analyses.
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您通过在不同时间尺度上整合各种数据源，并进行不同的预处理和格式化，创建了自己的时间序列数据。数据的收集和处理是费力且耗时的。您希望将数据以最终形式存储，而不是反复运行预处理步骤，但您也希望保留原始数据，以备稍后探索预处理替代方案。随着您开发新的机器学习模型并随时间添加新的、更新的原始数据，您预计会经常回顾处理和原始数据。即使您为了分析而对数据进行降采样或剪辑，您也永远不会在存储中降低数据质量。
- en: 'These use cases are quite varied in what their major demands on a system will
    be:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这些使用案例在其对系统的主要需求方面相当多样化：
- en: Importance of how performance scales with size
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 性能随大小变化的重要性
- en: In the first use case, we would look for a solution that could incorporate automated
    scripting to delete old data. We would not be concerned with how the system scaled
    for large data sets because we would plan to keep the data set small. By contrast,
    in the second and third use cases we would expect to have a stable, large collection
    of data (use case 2), or a large and growing collection of data (use case 3).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个用例中，我们将寻找一个能够集成自动化脚本以删除旧数据的解决方案。我们不会担心系统如何为大数据集进行扩展，因为我们计划保持数据集较小。相比之下，在第二和第三个用例中，我们预期会有稳定的大型数据集（用例
    2）或大型且增长中的数据集（用例 3）。
- en: Importance of random versus sequential access of data points
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 随机访问数据点与顺序访问数据点的重要性
- en: In use case 2, we would expect all of the data to be accessed in equal amounts,
    as this time series data would all be the same “age” on insertion and would all
    reference interesting data sets. In contrast, in use cases 1 and 3 (and especially
    1, given the preceding description) we would expect the most recent data to be
    accessed more often.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在用例 2 中，我们预计所有数据都将以相等的方式访问，因为这些时间序列数据在插入时都是相同的“年龄”，并且都引用了有趣的数据集。相比之下，在用例 1 和
    3 中（尤其是在用例 1 中，根据前述描述），我们预计最近的数据会更频繁地被访问。
- en: Importance of automation scripts
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化脚本的重要性
- en: Use case 1 seems as though it might be automated, whereas use case 2 would not
    require automation (since that data would be immutable). Use case 3 suggests little
    automation but a great deal of data fetching and processing of all portions of
    the data, not just the most recent. In use case 1, we would want a storage solution
    that could be integrated with scripting or stored procedures, whereas in use case
    3, we would want a solution that permitted a great deal of easy customization
    of data processing.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 用例 1 看起来可能会自动化，而用例 2 不需要自动化（因为数据是不可变的）。用例 3 表明几乎没有自动化，但需要获取和处理所有数据部分，而不仅仅是最近的数据。在用例
    1 中，我们希望找到一个能够与脚本或存储过程集成的存储解决方案，而在用例 3 中，我们希望找到一个允许轻松定制数据处理的解决方案。
- en: Just three examples already offer a good idea of the many use cases an all-purpose
    time series solution needs to meet.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅三个例子就已经很好地展示了一种通用时间序列解决方案需要满足的众多用例。
- en: 'In real-world use cases, you will be able to tailor your storage solution and
    not worry about finding a tool that fits all use cases. That said, you will always
    be choosing from a similar range of available technologies, which tend to boil
    down to:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际用例中，您将能够定制您的存储解决方案，而不必担心找不到适合所有用例的工具。话虽如此，您始终会在类似的可用技术范围内进行选择，这些技术往往归结为以下几种：
- en: SQL databases
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL数据库
- en: NoSQL databases
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NoSQL数据库
- en: Flat file formats
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平面文件格式
- en: In this chapter, we cover all three options and discuss the advantages and disadvantages
    of each. Of course, the specifics will depend on the use case at hand, but this
    chapter will equip you with the foundation you’ll need when you begin your search
    for a time series storage option that works for your use case.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了所有三种选项，并讨论了每种选项的优缺点。当然，具体情况取决于具体用例，但本章将为您提供在寻找适合您用例的时间序列存储选项时所需的基础。
- en: We first discuss what questions you should ask at the outset when picking a
    storage solution. Then we look at the great SQL versus NoSQL debate and examine
    some of the most popular time series storage solutions. Finally, we consider setting
    up policies to let old time series data expire and be deleted.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先讨论在选择存储解决方案时应该问什么问题。然后我们看一下SQL与NoSQL的大辩论，并检查一些最流行的时间序列存储解决方案。最后，我们考虑设置政策来让旧的时间序列数据过期并被删除。
- en: Defining Requirements
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义需求
- en: 'When you are thinking about storage for time series data, you need to ask yourself
    a number of questions:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当您考虑存储时间序列数据时，您需要问自己一些问题：
- en: '*How much time series data will you be storing? How quickly will that data
    grow?* You want to choose a storage solution appropriate to the growth rate of
    the data you expect. Database administrators moving into time series work from
    transaction-oriented data sets are often surprised at just how quickly time series
    data sets can grow.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*你将存储多少时间序列数据？这些数据会以多快的速度增长？* 你需要选择一个适合你预期数据增长速度的存储解决方案。从事时间序列工作的数据库管理员通常会对时间序列数据集的增长速度感到惊讶，尤其是那些从事事务性数据集工作的管理员。'
- en: '*Do your measurements tend toward endless channels of updates (e.g., a constant
    stream of web traffic updates) or distinct events (e.g., an hourly air traffic
    time series for every major US holiday in the last 10 years)?* If your data is
    like an endless channel, you will mostly look at recent data. On the other hand,
    if your data is a collection of distinct time series split into separate events,
    then events more distant in time may still be fairly interesting. In the latter
    case, random access is a more likely pattern.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*你的测量是否趋向于无尽的更新通道（例如，持续不断的网页流量更新），还是独立的事件（例如，过去10年每个主要美国假期的每小时空中交通时间序列）？* 如果你的数据像一个无尽的通道，你大多数情况下会查看最近的数据。另一方面，如果你的数据是一个由独立时间序列分割成单独事件的集合，那么时间上更远的事件可能仍然相当有趣。在后一种情况下，随机访问是更可能的模式。'
- en: '*Will your data be regularly or irregularly spaced?* If your data is regularly
    spaced, you can calculate more accurately in advance how much data you expect
    to collect and how often that data will be inputted. If your data is irregularly
    spaced, you must prepare for a less predictable style of data access that can
    efficiently allow for both dead periods and periods of write activity.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*你的数据是定期还是不定期分布的？* 如果你的数据是定期分布的，你可以提前更准确地计算你预期收集的数据量以及数据的输入频率。如果你的数据是不定期分布的，你必须准备一个不太可预测的数据访问方式，能有效地处理静止期和写入活动期。'
- en: '*Will you continuously collect data or is there a well-defined end to your
    project?* If you have a well-defined end to the data collection, this makes it
    easier to know how large a data set you need to accommodate. However, many organizations
    find that once they start collecting a particular kind of time series, they don’t
    want to stop!'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*你是否将持续收集数据，还是你的项目有一个明确定义的结束？* 如果你的数据收集有一个明确定义的结束，这将更容易知道你需要适应多大的数据集。然而，许多组织发现一旦开始收集某种类型的时间序列，就不想停止！'
- en: '*What will you be doing with your time series? Do you need real-time visualizations?
    Preprocessed data for a neural network to iterate over thousands of times? Sharded
    data highly available to a large mobile user base?* Your primary use case will
    indicate whether you are more likely to need sequential or random access to your
    data and how important a factor latency should be to your storage format selection.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*你将如何处理你的时间序列？你需要实时可视化吗？为神经网络预处理数据以进行数千次迭代？高度可用于大型移动用户群体的分片数据？* 你的主要用例将表明你更可能需要顺序访问还是随机访问你的数据，以及延迟在你选择存储格式时应扮演的重要角色。'
- en: '*How will you cull or downsample data? How will you prevent infinite growth?
    What should be the lifecycle of an individual data point in a time series?* It
    is impossible to store all events for all time. It is better to make decisions
    about data deletion policies systematically and in advance rather than on an ad
    hoc basis. The more you can commit to up front, the better a choice you can make
    regarding storage formats. More on this in the next section.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*你将如何剔除或降低数据采样率？你将如何防止无限增长？一个时间序列中个别数据点的生命周期应该是什么样子？* 不可能永久存储所有事件。最好是系统地和提前做出关于数据删除策略的决定，而不是临时决定。你越是能在前期做出承诺，你在存储格式选择上就能做出更好的选择。关于这点，我们将在下一节详细讨论。'
- en: The answers to these questions will indicate whether you should store raw or
    processed data, whether the data should be located in memory according to time
    or according to some other axis, and whether you need to store your data in a
    form that makes it easy to both read and write. Use cases will vary, so you should
    do a fresh inventory with every new data set.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题的答案将表明你是否应该存储原始数据还是处理后的数据，数据是否应该根据时间或其他轴来定位在内存中，以及是否需要以便于读写的形式存储你的数据。用例会有所不同，所以你应该在每一个新数据集上做一次全新的盘点。
- en: Tip
  id: totrans-31
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: '**提示**'
- en: '*Sharded* data is data that is part of a large data system but spread into
    smaller, more manageable chunks, often across several servers on a network.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*分片* 数据是一个大数据系统中的一部分，但分散到更小、更可管理的块中，通常分布在网络上的多个服务器上。'
- en: Live Data Versus Stored Data
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**实时数据与存储数据**'
- en: When thinking about what storage options are desirable for your data, it’s key
    to understand your data’s lifecycle. The more realistic you can be about your
    actual use cases for data, the less data you will need to save and the less time
    you will need to worry about finding the optimal storage system because you won’t
    quickly size up to an intractable amount of data. Often organizations over-record
    events of interest and are afraid to lose their data stores, but having more data
    stored in an intractable form is far less useful than having aggregated data stored
    at meaningful timescales.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑数据的存储选项时，理解数据的生命周期至关重要。对于数据的实际使用案例能越实际，你需要保存的数据就越少，你需要担心找到最佳存储系统的时间也就越少，因为你不会迅速积累到无法处理的数据量。通常，组织会过度记录感兴趣的事件，并害怕丢失它们的数据存储，但是将更多数据存储在无法处理的形式中远不如在有意义的时间尺度上存储聚合数据有用。
- en: For short-lived data, such as performance data that will be looked at only to
    ensure nothing is going wrong, it’s possible you may never need to store the data
    in the form in which it’s collected, at least not for very long. This is most
    important for event-driven data, where no single event is important and instead
    aggregate statistics are the values of interest.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于短暂的数据，比如仅用于确保一切正常的性能数据，可能永远不需要将数据存储在收集的形式中，至少不需要很长时间。这对于事件驱动数据尤为重要，其中没有单个事件重要，而是感兴趣的是聚合统计数据。
- en: Suppose you are running a web server that records and reports to you the amount
    of time it took every single mobile device to fully load a given web page. The
    resulting irregularly spaced time series might look something like [Table 5-1](#example-server-reports-table).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你运行一个Web服务器，记录并向你报告每个移动设备加载特定网页所需的时间。结果是不规则的时间序列，可能看起来像表5-1所示。
- en: Table 5-1\. Web server time series
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 表5-1\. Web服务器时间序列
- en: '| Timestamp | Time to load page |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 时间戳 | 加载页面时间 |'
- en: '| --- | --- |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| April 5, 2018 10:22:24 pm | 23s |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 2018年4月5日晚上10:22:24 | 23秒 |'
- en: '| April 5, 2018 10:22:28 pm | 15s |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 2018年4月5日晚上10:22:28 | 15秒 |'
- en: '| April 5, 2018 10:22:41 pm | 14s |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 2018年4月5日晚上10:22:41 | 14秒 |'
- en: '| April 5, 2018 10:23:02 pm | 11s |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 2018年4月5日晚上10:23:02 | 11秒 |'
- en: For many reasons, you would not be interested in any individual measurement
    of the time to load a page. You would want to aggregate the data (say, time to
    load averaged per minute), and even the aggregate statistics would only be interesting
    for a short while. Suppose you were on call overnight for that server. You’d want
    to make sure you could show performance was good while you were in charge. You
    could simplify this to a data point for your 12 hours of being on call, and you
    would have most of the information you could ever want, as shown in [Table 5-2](#example-load-time-table).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于多种原因，你可能对页面加载时间的任何单独测量都不感兴趣。你希望聚合数据（例如，每分钟平均加载时间），即使聚合统计数据也只有短暂的兴趣。假设你在那台服务器上通宵值班。你希望确保在你负责期间性能良好。你可以简化为你值班12小时的数据点，这将包含你可能需要的大部分信息，如[Table 5-2](#example-load-time-table)所示。
- en: Table 5-2\. A simplified data point for on-call hours
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 表5-2\. 值班时段简化数据点
- en: '| Time period | Most popular hour of access | Num loads | Mean time to load
    | Max time to load |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 时间段 | 最流行的访问小时 | 加载次数 | 平均加载时间 | 最大加载时间 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| April 5, 2018 8pm–8 am | 11 pm | 3,470 | 21s | 45s |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 2018年4月5日晚上8点至次日早上8点 | 23时 | 3,470 | 21秒 | 45秒 |'
- en: In such a case, you should not plan to indefinitely store the individual events.
    Rather, you should build a storage solution that provides for staging of the individual
    events only as temporary storage until the data goes into its ultimate form. You
    will save yourself and your colleagues a lot of grief by preventing runaway data
    growth before it can even get started. Instead of having 3,470 individual events,
    none of which interests anyone, you will have readily accessible and compact figures
    of interest. You should simplify data storage via aggregation and deduplication
    whenever possible.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你不应计划无限期地存储单个事件。相反，你应该建立一个存储解决方案，仅提供临时存储的个体事件，直到数据进入其最终形式。通过防止数据暴增开始之前的操作，你将为自己和同事节省很多麻烦。与无人感兴趣的3,470个单独事件相比，你将拥有易于访问和紧凑的感兴趣数据。在可能的情况下，你应该通过聚合和去重简化数据存储。
- en: Next we consider a few opportunities for reducing data without losing information.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们考虑几种减少数据量而不丢失信息的机会。
- en: Slowly changing variables
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓慢变化的变量
- en: If you are storing a state variable, consider recording only those data points
    where the value has changed. For example, if you are recording temperature at
    five-minute increments, your temperature curve might look like a step function,
    particularly if you only care about a value such as the nearest degree. In such
    a case, it’s not necessary to store repetitive values, and you will save storage
    space by not doing so.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在存储一个状态变量，请考虑只记录数值发生变化的数据点。例如，如果你每隔五分钟记录一次温度，你的温度曲线可能看起来像一个阶梯函数，特别是如果你只关心最接近度数的值。在这种情况下，存储重复数值是不必要的，通过不这样做你可以节省存储空间。
- en: Noisy, high-frequency data
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 嘈杂的高频数据
- en: If your data is noisy, there are reasons for not caring very much about any
    particular data point. You might consider aggregating data points before recording
    them since the high level of noise makes any individual measurement less valuable.
    This will, of course, be quite domain specific and you will need to ensure that
    downstream users are still able to assess the noise in the measurements for their
    purposes.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的数据很嘈杂，有理由不太关心任何特定的数据点。考虑在记录数据点之前对它们进行聚合，因为高噪声水平使得任何单个测量值的价值降低。当然，这将是相当特定于领域，并且你需要确保下游用户仍然能够评估其目的中测量数据中的噪声。
- en: Stale data
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 过时数据
- en: 'The older data is, the less likely your organization is going to use it, except
    in a very general way. Whenever you are beginning to record a new time series
    data set, you should think preemptively about when the time series data is likely
    to become irrelevant:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 数据越老，你的组织使用它的可能性就越小，除非以非常一般的方式。每当你开始记录一个新的时间序列数据集时，你应该预先考虑时间序列数据何时可能变得不相关：
- en: Is there a natural expiration date?
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否有自然的过期日期？
- en: If not, can you look through past research from your analytics department and
    see how far back they realistically go? When did any script in a Git repository
    actually access the oldest data in your data set?
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果不能，你能查看一下你的分析部门过去的研究，看看它们到底可以追溯到多远吗？你的数据集中最老的数据上次真正被 Git 仓库中的任何脚本访问是什么时候？
- en: If you can automate data deletion in a way that will not impede data analysis
    efforts, you will improve your data storage options by reducing the importance
    of scalability or the drag of slow queries on bloated data sets.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能自动化地删除数据，而不会妨碍数据分析工作，你将通过减少可扩展性的重要性或者减少庞大数据集上慢查询的负担，来改善你的数据存储选项。
- en: 'So far, we have discussed the general range of use cases for time series storage.
    We have also reviewed a general set of queries related to how a time series data
    set will be produced and analyzed so that these queries can inform our selection
    of a storage format. We now review two common options for storing time series:
    databases and files.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了时间序列存储的一般使用情况范围。我们还回顾了一组关于如何生成和分析时间序列数据集的查询，以便这些查询可以指导我们选择存储格式。我们现在回顾两种常见的时间序列存储选项：数据库和文件。
- en: Database Solutions
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库解决方案
- en: 'For almost any data analyst or data engineer, a database is an intuitive and
    familiar solution to the question of how to store data. As with relational data,
    a database will often be a good storage choice for time series data. This is particularly
    true if you want an out-of-the-box solution with any of these classic database
    characteristics:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于几乎所有的数据分析师或数据工程师来说，数据库是如何存储数据的直观而熟悉的解决方案。与关系型数据一样，数据库通常是处理时间序列数据的良好选择。特别是当你需要一个开箱即用的解决方案时，其中具有经典数据库特性之一：
- en: A storage system that can scale up to multiple servers
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展到多个服务器的存储系统
- en: A low-latency read/write system
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 低延迟读/写系统
- en: Functions already in place for computing commonly used metrics (such as computing
    the mean in a group-by query, where the group-by can apply to time metrics)
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已经可以计算常用指标的函数（例如在分组查询中计算平均值，其中分组可以应用于时间指标）
- en: Troubleshooting and monitoring tools that can be used to tune system performance
    and analyze bottlenecks
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用于调整系统性能和分析瓶颈的故障排除和监控工具
- en: These are good reasons [among many](https://perma.cc/K994-RXE9) to opt for a
    database rather than a filesystem, and you should always consider a database solution
    for data storage, particularly when working with a new data set. A database, particularly
    a NoSQL database, can help you preserve flexibility. Also, a database will get
    your project up and running sooner than if you are going to work with individual
    files because much of the boilerplate you will need is already in place. Even
    if you ultimately decide on a file storage solution (and most people won’t), working
    with a database first can help you determine how to structure your own files when
    your new data processes mature.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是选择数据库而不是文件系统的充分理由，[其中之一](https://perma.cc/K994-RXE9)，特别是在处理新数据集时，你应该始终考虑数据库解决方案。数据库，特别是NoSQL数据库，可以帮助你保持灵活性。此外，与单独处理文件相比，数据库将使您的项目更快地启动，因为您将需要的大部分样板代码已经就位。即使最终决定采用文件存储解决方案（大多数人不会这样做），首先使用数据库可以帮助您确定在新的数据处理成熟时如何组织自己的文件结构。
- en: In the remainder of this section, we will cover the respective advantages of
    SQL and NoSQL databases for time series and then discuss currently popular database
    options for time series applications.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的其余部分，我们将介绍SQL和NoSQL数据库在时间序列中的各自优势，然后讨论目前流行的时间序列应用数据库选项。
- en: The good news is that time series graphs appear to be the [fastest growth category
    of database](https://perma.cc/RQ79-5AX7) at this time, so you can expect to see
    more and even better options for time series database solutions in the future.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，时间序列图表似乎是目前数据库领域中增长最快的类别，因此您可以期待在未来看到更多甚至更好的时间序列数据库解决方案选择。
- en: SQL Versus NoSQL
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL与NoSQL的比较
- en: SQL versus NoSQL is just as lively a debate in the time series database community
    as it is more widely. Many expert database administrators insist that SQL is the
    only way to go and that there is no data in any shape that cannot be well described
    by a good set of relational tables. Nonetheless, in practice there is often a
    drop in performance when organizations try to scale SQL solutions to accommodate
    large amounts of time series data, and for this reason it’s always worth considering
    a NoSQL solution as well, particularly if you are seeking an open-ended solution
    that can scale to accommodate cases where time series data collection begins with
    no finite time horizon in sight.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: SQL与NoSQL在时间序列数据库社区中的辩论与更广泛的领域一样活跃。许多专家数据库管理员坚持认为SQL是唯一的选择，并且没有任何形式的数据不能通过一组良好的关系表格进行很好地描述。尽管如此，在实践中，当组织试图扩展SQL解决方案以适应大量时间序列数据时，通常会出现性能下降的情况，因此始终值得考虑NoSQL解决方案，特别是如果您正在寻找一个开放的解决方案，可以扩展以适应时间序列数据收集开始时看不到有限时间范围的情况。
- en: While both SQL and NoSQL solutions can be good for time series data, we first
    motivate our discussion of the difficulties of applying database logic to time
    series data by exploring how time series data differs from the kind of data for
    which SQL databases were developed.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管SQL和NoSQL解决方案都可以适用于时间序列数据，但我们首先通过探索时间序列数据与SQL数据库开发的数据类型之间的不同，来激励我们讨论将数据库逻辑应用于时间序列数据的困难。
- en: Characteristics of the data that originally inspired SQL databases
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最初启发SQL数据库的数据特征
- en: We can best understand the mismatch between SQL-like thinking and time series
    data by reviewing the history of SQL solutions. SQL solutions were based on transactional
    data, which is whatever data is needed to completely describe a discrete event.
    A transaction is composed of attributes that reflect many primary keys, such as
    product, participants, time, and value of a transaction. Notice that time can
    be present as a primary key but only as one among many, not as a privileged axis
    of information.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回顾SQL解决方案的历史，我们可以最好地理解SQL式思维与时间序列数据之间的不匹配。SQL解决方案基于事务数据，这是完全描述离散事件所需的任何数据。事务由反映许多主键的属性组成，例如产品、参与者、时间和交易的价值。请注意，时间可以作为一个主键存在，但只能作为众多主键之一，而不是作为信息的主要轴。
- en: 'There are two important features of transactional data that are quite different
    from time series needs:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 事务数据有两个重要特征，与时间序列需求大不相同：
- en: Existing data points are often updated.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现有数据点经常会更新。
- en: The data is accessed somewhat randomly as there is no underlying ordering required.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据访问有些随机，因为不需要底层排序。
- en: Characteristics of time series data
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 时间序列数据的特征
- en: Time series data elaborates the entire history of something, whereas a transaction
    recording tells us only the final state. Hence, time series data does not usually
    require updating, meaning that random access for write operations is a low priority.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列数据详细记录了某物的整个历史，而事务记录仅告诉我们最终状态。因此，时间序列数据通常不需要更新，这意味着随机访问的写操作不是首要考虑的。
- en: 'This means that the performance objectives that have been key to decades of
    SQL database design are not very important for time series databases. In fact,
    when we consider objectives in designing a database for time series, we have quite
    different priorities because of how we will use our time series data. The primary
    features of our time series data use case are:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在设计数据库用于时间序列时，性能目标对几十年来 SQL 数据库设计的关键性并不重要。事实上，考虑到在设计时间序列数据库时的目标，我们有着非常不同的优先级，因为我们将如何使用时间序列数据。我们时间序列数据使用案例的主要特征包括：
- en: Write operations predominate over read operations.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写操作优先于读操作。
- en: Data is neither written nor read nor updated in random order, but rather in
    the order related to temporal sequencing.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据的写入、读取和更新并非随机顺序，而是按照时间顺序相关的顺序进行。
- en: Concurrent reads are far more likely than they are for transaction data.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发读取远比事务数据更可能发生。
- en: There are few, if any, primary keys other than time itself.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了时间本身，几乎没有其他主键。
- en: Bulk deletes are far more common than individual data point deletion.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大量删除比单个数据点删除更常见。
- en: These features support the use of a NoSQL database, because many general-application
    NoSQL databases offer much of what we want for time series databases, particularly
    the emphasis on write operations over read operations. Conceptually, NoSQL databases
    map well to time series data in that they natively reflect aspects of time series
    data collection, such as not all fields being collected for all data points. The
    flexible schemas of NoSQL are natural with time series data. Much of the data
    that motivated the current popularity of NoSQL databases is time series data.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特性支持使用 NoSQL 数据库，因为许多通用应用的 NoSQL 数据库提供了时间序列数据库所需的大部分功能，尤其是对写操作的强调优于读操作。从概念上讲，NoSQL
    数据库与时间序列数据非常匹配，因为它们本身就反映了时间序列数据收集的各个方面，例如并非所有数据点都会收集所有字段。NoSQL 的灵活模式与时间序列数据天然契合。当前推动
    NoSQL 数据库流行的很大一部分数据就是时间序列数据。
- en: For this reason, out-of-the-box NoSQL databases tend to perform better than
    SQL databases for write operations. [Figure 5-1](#fig-0501) plots performance
    of a commonly used SQL database versus a commonly used NoSQL database for the
    case of time series data point insertions (write operations).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，开箱即用的 NoSQL 数据库在写操作方面往往比 SQL 数据库表现更好。[图 5-1](#fig-0501) 展示了用于时间序列数据点插入（写操作）的常用
    SQL 数据库与常用 NoSQL 数据库的性能比较。
- en: '![](assets/ptsa_0501.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ptsa_0501.png)'
- en: Figure 5-1\. One common feature of a database designed for time series use is
    that the data insertion rate is constant with respect to the database size. This
    is a striking advantage in comparison to a traditional SQL storage solution.
  id: totrans-89
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-1\. 为了时间序列使用而设计的数据库的一个共同特征是，数据插入速率与数据库大小成正比。与传统的 SQL 存储解决方案相比，这是一个显著的优势。
- en: How to choose between SQL and NoSQL
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何在 SQL 和 NoSQL 之间做出选择
- en: 'It may seem that I am attempting to push you toward the NoSQL use case, but
    there are also many good use cases for SQL databases. When thinking about your
    own data, keep in mind the principle that always applies to data storage, be it
    in a SQL database, a NoSQL database, or a plain old text file: *data that tends
    to be requested at the same time should be stored in the same location*. That’s
    the most important factor regardless of your use case.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 或许会让人觉得我在推动你使用 NoSQL，但 SQL 数据库也有许多良好的使用场景。在考虑自己的数据时，请记住这一适用于数据存储的原则，无论是在 SQL
    数据库、NoSQL 数据库还是纯文本文件中：*那些通常在同一时间被请求的数据应该存储在相同的位置*。这是无论你的使用场景如何都是最重要的因素。
- en: Many conference presentations and blog posts herald NoSQL solutions as precisely
    catering to the situation of a high-write low-update scenario where data is not
    ordered randomly. Nonetheless, SQL databases are a viable and regularly used time
    series storage option. In particular, with some architectural changes in emphasis
    to traditional SQL databases and their internal memory structure, these challenges
    can be met while keeping some of the [advantages of SQL](https://perma.cc/3ZUQ-B5WC).
    For example, something as simple and seemingly obvious as structuring SQL tables’
    internal memory representation to account for time can make a substantial performance
    difference.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 许多会议演示和博客文章把NoSQL解决方案宣扬为精确迎合高写入低更新情景的解决方案，其中数据不会随机排序。尽管如此，SQL数据库仍然是一种可行且经常使用的时间序列存储选项。特别是，在一些对传统SQL数据库及其内存结构的重点进行架构变更后，这些挑战可以得到应对，同时保留SQL的一些[优势](https://perma.cc/3ZUQ-B5WC)。例如，如何简单且看似显而易见地构建SQL表的内存表示以考虑时间，可以显著提升性能。
- en: 'Ultimately, the distinctions between NoSQL and SQL are highly implementation-dependent
    and not as systematic or important as they are made out to be. Let your data drive
    your selection of a specific implementation of one of these technologies. As you
    consider the attributes of your time series data and access use patterns, you
    can keep some general limitations in mind:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，NoSQL和SQL之间的区别高度依赖于实现，并不像它们被宣传的那样系统化或重要。让你的数据决定你选择这些技术中的某一个具体实现。当你考虑你的时间序列数据的属性和访问使用模式时，你可以记住一些一般的限制：
- en: '*Pluses of SQL for time series*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*SQL在时间序列中的优点*'
- en: If your time series is stored in a SQL database, you can easily relate it to
    relevant cross-sectional data also stored in that database.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的时间序列存储在SQL数据库中，你可以轻松地将其与存储在该数据库中的相关横截面数据关联起来。
- en: Hierarchical time series data is a natural fit with relational tables. An appropriate
    set of SQL schema will help you group related time series and clearly delineate
    the hierarchy, whereas these could be easily scattered less systematically in
    a NoSQL solution.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分层时间序列数据与关系表是自然匹配的。适当的SQL模式集将帮助你组织相关的时间序列，并清晰地划分层次结构，而这些在NoSQL解决方案中可能会比较零散地分布。
- en: If you are crafting a time series based on transactional data, where the data
    is best stored in a SQL database, it will be advantageous to also store your time
    series in the same database for ease of verification, cross-referencing, and so
    on.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你正在创建基于交易数据的时间序列，在这种情况下最好将数据存储在SQL数据库中，这样可以轻松进行验证、交叉引用等操作。
- en: '*Pluses of NoSQL for time series*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*NoSQL在时间序列中的优点*'
- en: Writes are fast.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入速度快。
- en: They’re good if you don’t know enough about future data to design and intelligent
    and robust schema.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你对未来数据不了解，设计一个智能和健壮的模式将是很困难的，它们是不错的选择。
- en: For the inexpert user, these databases are often the more performant out-of-the-box
    solution because you are less likely to design an awkward schema or to be locked
    into a mediocre schema design.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于不熟悉的用户来说，这些数据库通常是开箱即用的更高性能解决方案，因为你不太可能设计一个笨拙的模式或者被锁定在一个平庸的模式设计中。
- en: Popular Time Series Database and File Solutions
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流行的时间序列数据库和文件解决方案
- en: Now we’ll discuss some popular database solutions for time series data. These
    give you a sense of what is available in addition to traditional SQL solutions.
    Note that the technologies discussed here occupy a crowded and fragmented technology
    landscape. What is commonly used this year may not be so popular next year. Thus,
    this discussion should not be viewed as a specific technology recommendation so
    much as a set of samples helping to illustrate the current state of the market.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将讨论一些流行的时间序列数据的数据库解决方案。这些给你一种可用性的感觉，除了传统的SQL解决方案之外。请注意，这里讨论的技术占据了一个拥挤和碎片化的技术景观。今年常用的技术明年可能不那么流行。因此，这个讨论不应被视为具体的技术推荐，而更像是一组样本，帮助说明市场的当前状态。
- en: Time series–specific databases and related monitoring tools
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 时间序列专用数据库及相关监控工具
- en: First we discuss tools that are built specifically for the purpose of storing
    and monitoring time series data. In particular, we take a look at a time series
    database (InfluxDB) and another product that is a performance monitoring tool,
    which can double as a time series storage solution (Prometheus). The advantages
    of each tool necessarily reflect its distinct emphasis and use patterns.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们讨论专门用于存储和监控时间序列数据的工具。特别是，我们看一下时间序列数据库（InfluxDB）和另一款性能监控工具，它也可以作为时间序列存储解决方案（Prometheus）。每个工具的优势必然反映了其独特的重点和使用模式。
- en: InfluxDB
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: InfluxDB
- en: 'InfluxDB is a time series–specific database, per [its own description](https://oreil.ly/6qmVH)
    on the GitHub project’s web page:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: InfluxDB 是一个专门针对时间序列的数据库，根据其在 GitHub 项目网页上的[描述](https://oreil.ly/6qmVH)：
- en: InfluxDB is an open source time series database...useful for recording metrics,
    events, and performing analytics.
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: InfluxDB 是一个开源时间序列数据库，用于记录度量、事件并进行分析。
- en: 'In InfluxDB, data is organized by time series. A data point in InfluxDB consists
    of:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在 InfluxDB 中，数据按时间序列组织。InfluxDB 中的数据点包括：
- en: A timestamp
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个时间戳
- en: A label indicating what the measurement consists of
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指示测量内容的标签
- en: One or more key/value fields (such as `temperature=25.3`)
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个或多个键/值字段（例如 `temperature=25.3`）
- en: Key/value pairs containing metadata tags
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含元数据标签的键/值对
- en: 'InfluxDB, as a time-aware database, automatically timestamps any data point
    that comes in without a timestamp. Also, InfluxDB uses SQL-like querying, such
    as:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个时序感知的数据库，InfluxDB 会自动为任何未带时间戳的数据点添加时间戳。此外，InfluxDB 使用类似于 SQL 的查询语言，例如：
- en: '[PRE0]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Other advantages of InfluxDB include:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: InfluxDB 的其他优势包括：
- en: Data retention options that allow you to easily automate the designation and
    deletion of stale data
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据保留选项，允许您轻松自动指定和删除陈旧数据
- en: High data ingestion speed and aggressive data compression
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高数据摄取速度和激进的数据压缩
- en: Ability to tag individual time series to allow for fast indexing of time series
    that match a specific criterion
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许为个别时间序列添加标签，以便快速索引与特定条件匹配的时间序列
- en: Membership in the mature [TICK stack](https://oreil.ly/KLjGo), which is a platform
    for capturing, storing, monitoring, and displaying time series data
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成为成熟的[TICK堆栈](https://oreil.ly/KLjGo)的一部分，这是一个用于捕获、存储、监控和显示时间序列数据的平台
- en: There are many other time series–specific databases; right now InfluxDB happens
    to be the most popular, so it is the one you are most likely to encounter. The
    options it offers are those commonly offered by time series–specialized databases,
    as these options reflect the most commonly desired attributes for storage of time
    series data.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他的时间序列专用数据库；目前 InfluxDB 是最流行的，因此您最有可能遇到它。它提供的选项是时间序列数据存储中常见的期望属性。
- en: As a database, InfluxDB is a *push-based* system, meaning that when you use
    it you push data into the database for ingestion. This is different from the next
    option we’ll discuss, Prometheus.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个数据库，InfluxDB 是一个*推送式*系统，这意味着在使用它时，您将数据推送到数据库进行摄取。这与我们将讨论的下一个选项 Prometheus
    不同。
- en: Given these specifications, a solution such as InfluxDB provides all general
    functionality right out of the box in a time-aware manner. This means you can
    use your existing SQL skills while also benefiting from advantages related to
    the need to capture but control the growth of time series data. Finally, you have
    the fast write so often necessary when capturing time series data as it is produced.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于这些规格，像 InfluxDB 这样的解决方案从一开始就以时序感知的方式提供所有一般功能。这意味着您可以利用现有的 SQL 技能，同时还能从捕获但控制时序数据增长的需求中获益。最后，在捕获时序数据时，您还可以获得所需的快速写入。
- en: Prometheus
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Prometheus
- en: 'Prometheus [describes itself](https://github.com/prometheus/prometheus) as
    a “monitoring system and time series database” that works via HTTP. This description
    indicates its general emphasis: monitoring first and storage second. The great
    advantage of Prometheus is that it is a *pull-based* system, which means that
    the logic for how data is pulled for creating a time series and how often it is
    centralized can be easily adjusted and inspected.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus [描述自己](https://github.com/prometheus/prometheus) 为一个“监控系统和时间序列数据库”，通过HTTP工作。这个描述表明它的一般重点：首先是监控，其次是存储。Prometheus
    的一个巨大优势在于它是一个*拉取式*系统，这意味着用于拉取数据以创建时间序列的逻辑以及拉取的频率可以轻松调整和检查。
- en: Prometheus is a great resource to have during emergencies because it is atomic
    and self-reliant. However, it is also not guaranteed to be entirely up-to-date
    or accurate, due to its pull-based architecture. While it should be the go-to
    technology for quick-and-dirty performance monitoring, it is not appropriate for
    applications where data has to be 100% accurate.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus在紧急情况下是一个很好的资源，因为它是原子性和自我依赖的。然而，由于其拉取式架构，不能保证完全实时或准确。虽然它应该是快速和粗糙性能监控的首选技术，但不适用于数据必须是100%准确的应用程序。
- en: 'Prometheus uses a functional expression language called PromQL for its querying:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus使用称为PromQL的功能表达语言进行查询：
- en: '[PRE1]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Prometheus also offers, via PromQL, an API for many common time series tasks,
    even including sophisticated functions such as making a prediction (`predict_linear()`)
    and calculating the per-unit-of-time rate of increase for a time series (`rate()`).
    Aggregation over periods of time is also offered with a simple interface. Prometheus
    tends to emphasize monitoring and analysis over maintenance, so compared to InfluxDB
    there are fewer automated data-curating functionalities.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus还通过PromQL提供了一个API，用于许多常见的时间序列任务，甚至包括如何做出预测(`predict_linear()`)和计算时间序列的每单位时间增长率(`rate()`)等复杂功能。通过简单的接口也提供了时间段内的聚合。相比于InfluxDB，Prometheus更强调监控和分析，因此自动化数据整理功能较少。
- en: Prometheus is a helpful time series storage solution particularly for live streaming
    applications and when data availability is paramount. It has a steeper learning
    curve due to its custom scripting language and the less database-like architecture
    and API, but it is nonetheless widely used and enjoyed by many developers.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus是一个有用的时间序列存储解决方案，特别适用于实时流应用和数据可用性至关重要的场景。由于其自定义脚本语言和较少类似数据库的架构与API，它具有较陡的学习曲线，但仍被许多开发人员广泛使用和喜爱。
- en: General NoSQL databases
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通用NoSQL数据库
- en: While time series–specific databases offer many advantages, you can also consider
    the case of more general-use NoSQL databases. These sorts of databases are based
    on a *document* structure rather than a *table* structure, and they do not usually
    have many explicit functions specifically for time series.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然时间序列特定的数据库提供了许多优势，但您也可以考虑更通用的NoSQL数据库的情况。这些数据库基于*文档*结构而不是*表*结构，并且通常不具备专门用于时间序列的显式功能。
- en: Nonetheless, the flexible schemas of NoSQL databases remain useful for time
    series data, particularly for new projects where the rhythm of data collection
    and the number of input channels may change through the course of a data set’s
    lifetime. For example, a time series may initially start out as only one channel
    of data but gradually grow to include more kinds of data all timestamped together.
    Later, it may be decided that some of the input channels are not particularly
    useful, and they may be discontinued.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管NoSQL数据库的灵活模式对于时间序列数据仍然很有用，特别是对于数据集的生命周期中数据收集的节奏和输入通道数量可能会发生变化的新项目。例如，时间序列可能最初只包含一个数据通道，但逐渐增加到包含更多种类的数据，所有数据都有时间戳。后来，可能会决定一些输入通道并不特别有用，它们可能会被停用。
- en: In such a case, storing the data in a SQL table would be difficult for several
    reasons, and would result in a great many NaNs where data was not available. A
    NoSQL database would simply leave the channels absent when they were not available
    rather than marking up a rectangular data store with a bunch of NaNs.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，将数据存储在SQL表中将会因几个原因而困难，并导致大量NaN，即数据不可用时的标记。相比之下，NoSQL数据库在数据不可用时会简单地保留这些通道的缺失，而不是在矩形数据存储中标记大量NaN。
- en: 'One popular and performant NoSQL time series database is MongoDB. Mongo is
    particularly aware of its value as a time series database and has a strong push
    to develop IoT-friendly architecture and instructions. It offers high-level aggregation
    features that can be applied to aggregation operations by time and time-related
    groupings, and it also offers many automated processes to divide time into human-relevant
    markings, such as day of the week or day of the month:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一种受欢迎且性能出色的NoSQL时间序列数据库是MongoDB。Mongo特别关注其作为时间序列数据库的价值，并积极推动开发适合物联网的架构和指导。它提供了高级聚合特性，可用于按时间和与时间相关的分组的聚合操作，并提供了许多自动化流程来将时间分割为人类相关的标记，例如星期几或每月的日期：
- en: '`$dayOfWeek`'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$dayOfWeek`'
- en: '`$dayOfMonth`'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$dayOfMonth`'
- en: '`$hour`'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$hour`'
- en: Also, Mongo has devoted extensive documentation efforts to demonstrating how
    time series can be handled.^([1](ch05.html#idm45576039147144)) A ready set of
    documentation and institutional focus on time series data explicitly mean that
    users can expect this database to continue developing even more time-friendly
    features.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Mongo 专注于展示如何处理时间序列的广泛文档工作。^([1](ch05.html#idm45576039147144)) 一套准备好的文档和机构专注于时间序列数据明确意味着用户可以期待这个数据库会继续开发更多面向时间的功能。
- en: More useful than all this functionality, however, is Mongo’s flexibility in
    evolving schema over time. This schema flexibility will save you a lot of grief
    if you work on a rapidly evolving time series data set with ever-changing data
    collection practices.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，比所有这些功能更有用的是 Mongo 在随时间演变的架构上的灵活性。如果你在处理不断变化的数据收集实践的快速演变的时间序列数据集上工作，这种架构的灵活性将为你节省大量麻烦。
- en: 'For example, imagine a sequence of time series data collection practices such
    as what might occur in a healthcare startup:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一下一家医疗创业公司可能发生的时间序列数据收集实践：
- en: Your startup launches as a blood pressure app and collects only two metrics,
    systolic and diastolic blood pressure, which you encourage users to measure several
    times daily…
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的创业公司推出了一款血压应用，并只收集两个指标，收缩压和舒张压，鼓励用户每天多次测量…
- en: But your users want enhanced lifestyle advice and they are happy to give you
    more data. Users provide everything from their birth dates to monthly weight recordings
    to hourly step counts and calorie counts. Obviously, these different kinds of
    data are collected at drastically different rhythms…
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 但是你的用户希望得到增强的生活方式建议，并且他们乐意为你提供更多的数据。用户提供从他们的生日到每月体重记录再到每小时步数和卡路里计数等一切。显然，这些不同类型的数据以截然不同的节奏进行收集…
- en: But later you realize some of this data is not very useful so you stop collecting
    it...
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 但后来你意识到一些数据并不是很有用，所以你停止了收集它…
- en: But your users miss your display of the data even if you don’t use it, so you
    restart collection of the most popular data…
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 但是即使你不再使用，你的用户也会想念你的数据显示，所以你重新开始收集最受欢迎的数据…
- en: And then the government of one of your largest markets passes a law regarding
    the storage of health data and you need to purge that data or encrypt it, so you
    need a new encrypted field…
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你最大市场之一的政府通过了关于健康数据存储的法律，你需要清除那些数据或加密它，因此你需要一个新的加密字段…
- en: And the changes continue.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并且变化还在继续。
- en: When you need the querying and schema flexibility described in an application
    like this, you would be well served by a general NoSQL database that offers a
    reasonable balance between time-specific and more general flexibility.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要像这样的应用程序中描述的查询和架构灵活性时，你可以选择一个提供了合理平衡的通用 NoSQL 数据库，既具有时间特定性又具有更一般灵活性。
- en: Another advantage of a general-purpose NoSQL database rather than a time series–specific
    database is you can more easily integrate non-time series data into the same database
    for ease of cross-referencing the related data sets. Sometimes a general-purpose
    NoSQL database is just the right mix of performance considerations and SQL-like
    functionality without the cleverness needed to optimize a SQL database schema
    for time series functionality.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 与时序特定数据库相比，通用 NoSQL 数据库的另一个优势是你可以更轻松地将非时序数据集成到同一数据库中，以便跨数据集引用相关数据。有时候，通用 NoSQL
    数据库恰好是性能考量和类似 SQL 功能的完美结合，而无需为时序功能优化 SQL 数据库架构的聪明办法。
- en: 'In this section, we have examined NoSQL database solutions^([2](ch05.html#idm45576039133192))
    and surveyed some options now in popular use. While we can expect the particular
    technologies that dominate the market to evolve over time, the general principles
    on which these technologies operate and the advantages they offer will remain
    the same. As a quick recap, some of the advantages we find in different varieties
    of databases are:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经研究了 NoSQL 数据库解决方案^([2](ch05.html#idm45576039133192))，并调查了一些当前流行的选项。虽然我们可以预期主导市场的特定技术随着时间的推移而演变，但这些技术操作的一般原则和它们提供的优势将保持不变。作为一个快速回顾，我们在不同类型的数据库中发现的一些优势包括：
- en: High read or write capacities (or both)
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高读取或写入容量（或两者兼有）
- en: Flexible data structures
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 灵活的数据结构
- en: Push or pull data ingestion
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推送或拉取数据摄取
- en: Automated data culling processes
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化数据修剪流程
- en: A time series–specific database will offer the most out-of-the-box automation
    for your time series–specific tasks, but it will offer less schema flexibility
    and fewer opportunities to integrate related cross-sectional data than a more
    general, all-purpose NoSQL database.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 时序数据库专用于时序特定任务，可以提供最多的开箱即用自动化功能，但其模式灵活性较低，整合相关的横截面数据的机会也较少，相比之下，通用的 NoSQL 数据库更具有这些特点。
- en: Generally speaking, databases will offer more flexibility than flat file storage
    formats, but this flexibility means that databases are less streamlined and less
    I/O performant than simple flat files, which we discuss next.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，数据库比平面文件存储格式提供更大的灵活性，但这种灵活性意味着数据库不如简单的平面文件存储格式流畅，并且在 I/O 性能上也较差，接下来我们将讨论这一点。
- en: File Solutions
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件解决方案
- en: At the end of the day, a database is a piece of software that integrates both
    scripting and data storage. It is essentially a flat file wrapped in a special
    piece of software responsible for making that file as safe and easy to use as
    possible.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 总而言之，数据库是一种集成了脚本和数据存储功能的软件。它本质上是一个包装在特殊软件中的平面文件，负责使该文件尽可能安全且易于使用。
- en: Sometimes it makes sense to take away this outer layer and take on the full
    responsibility of the data storage ourselves. While this is not very common in
    business applications, it is frequently done in scientific research and in the
    rare industrial application (such as high-frequency trading) in which speed is
    paramount. In such cases, it is the analyst who will design a much more intricate
    data pipeline that involves allocating storage space, opening files, reading files,
    closing files, protecting files, and so on, rather than simply writing some database
    queries.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，摆脱这个外部层并全面承担数据存储的责任是有意义的。虽然这在商业应用中并不常见，但在科学研究中经常这样做，在极少数的工业应用（如高频交易）中，速度至关重要。在这种情况下，分析师将设计一个更复杂的数据管道，涉及分配存储空间、打开文件、读取文件、关闭文件、保护文件等，而不仅仅是编写一些数据库查询。
- en: 'A flat file solution is a good option if any of these conditions apply:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果符合以下任何条件，平面文件解决方案是一个不错的选择：
- en: Your data format is mature so that you can commit to a specification for a reasonably
    long period of time.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的数据格式已经成熟，因此可以承诺在相当长的时间内使用特定规范。
- en: Your data processing is I/O bound, so it makes sense to spend development time
    speeding it up.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的数据处理受 I/O 限制，因此在加速开发时间上投入是有意义的。
- en: You don’t need random access, but can instead read data sequentially.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不需要随机访问，而可以顺序读取数据。
- en: In this section, we briefly survey some common flat file solutions. You should
    also remember that you can always [create your own file storage format](https://perma.cc/DU98-FWW9),
    although this is fairly complex and is usually worth doing only if you are working
    in a highly performant language, such as C++ or Java.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们简要概述了一些常见的平面文件解决方案。你还应该记住，你始终可以[创建自己的文件存储格式](https://perma.cc/DU98-FWW9)，尽管这相当复杂，并且通常只有在你使用高性能语言（如C++或Java）时才值得这样做。
- en: 'If your system is mature and performance-sensitive enough to suit a flat file
    system, there are several advantages to implementing one, even if it may mean
    the chore of migrating your data out of a database. These advantages include:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的系统已经成熟且对性能要求敏感到足以支持平面文件系统，那么即使可能需要将数据迁出数据库，实施平面文件系统也有几个优点。这些优点包括：
- en: A flat file format is system agnostic. If you need to share data, you simply
    make files available in a known shareable format. There is no need to ask a collaborator
    to remotely access your database or set up their own mirrored database.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平面文件格式与系统无关。如果需要共享数据，只需以已知的可共享格式提供文件即可。无需请求合作者远程访问你的数据库或设置他们自己的镜像数据库。
- en: A flat file format’s I/O overhead is necessarily less than that for a database,
    because this amounts to a simple read operation for a flat file rather than a
    retrieval and a read with a database.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平面文件格式的I/O开销必然比数据库少，因为这只涉及对平面文件的简单读取操作，而不是对数据库的检索和读取操作。
- en: A flat file format encodes the order in which data should be read, whereas not
    all databases will do so. This enforces serial reading of the data, which can
    be desirable, such as for deep learning training regimes.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平面文件格式编码了数据应该读取的顺序，而并非所有数据库都会这样做。这强制执行了数据的串行读取，这在某些情况下是可取的，比如用于深度学习训练体制。
- en: Your data will occupy a much smaller amount of memory than it would on a database
    because you can maximize compression opportunities. Relatedly, you can tune the
    degree of data compression to explicitly balance your desire to minimize both
    the data storage footprint and I/O time in your application. More compression
    will mean a smaller data footprint but longer I/O waits.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与数据库相比，您的数据将占用比较小的内存空间，因为您可以最大程度地利用压缩机会。相关地，您可以调整数据压缩程度，以明确平衡在应用程序中最小化数据存储占用和
    I/O 时间的愿望。更多的压缩将意味着更小的数据占用，但更长的 I/O 等待时间。
- en: NumPy
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NumPy
- en: If your data is purely numeric, one widely used option for holding that data
    is a Python NumPy array. NumPy arrays can easily be saved in a variety of formats,
    and there are many benchmarking publications comparing their relative performance.
    For example, the [`array_storage_benchmark` GitHub repo](https://perma.cc/ZBS7-PR56)
    is designed to test the efficiency and speed of various NumPy file formats.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的数据纯粹是数字，一种广泛使用的选择是 Python NumPy 数组。NumPy 数组可以轻松保存为各种格式，并且有许多基准出版物比较它们的相对性能。例如，[`array_storage_benchmark`
    GitHub 仓库](https://perma.cc/ZBS7-PR56) 专为测试各种 NumPy 文件格式的效率和速度而设计。
- en: A downside of NumPy arrays is that they have a single data type, which means
    you cannot store heterogeneous time series data automatically, but must instead
    think about whether having just one data type can work for your data in raw or
    processed form (although there are ways around this restriction). Another downside
    of NumPy arrays is that it is not natural to add labels to rows or columns, so
    there is no straightforward way to timestamp each row of an array, for example.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 数组的缺点是它们只有一个数据类型，这意味着您不能自动存储异构时间序列数据，而必须考虑是否可以将单一数据类型用于原始或处理后的数据（尽管有办法绕过此限制）。另一个缺点是，NumPy
    数组不自然地为行或列添加标签，因此没有直接的方法为数组的每一行添加时间戳，例如。
- en: The advantage of using a NumPy array is that there are many options for saving
    one, including a compressed binary format that takes up less space and has faster
    I/O than you will see with a database solution. It is also as out-of-the-box as
    it gets in terms of a performant data structure for analysis as well as storage.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 NumPy 数组的优点是可以使用多种选项保存，包括占用空间更小并且比数据库解决方案具有更快 I/O 的压缩二进制格式。从分析和存储的角度来看，它也是一种开箱即用的性能良好的数据结构。
- en: Pandas
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pandas
- en: If you want easy labeling of data or easy storage of heterogenous time series
    data (or both), consider the less streamlined but more flexible Pandas data frame.
    It can be particularly useful when you have a time series that consists of many
    distinct kinds of data, perhaps including event counts (ints), state measurements
    (floats), and labels (strings or one-hot encodings). In such cases, you will likely
    want to stick to Pandas data frames (also remember that the name “pandas” actually
    comes from an elision of “panel data,” so this is a natural format for many use
    cases).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望轻松标记数据或轻松存储异构时间序列数据（或两者兼有），请考虑不那么流畅但更灵活的 Pandas 数据框架。当您有一个时间序列，其中包含许多不同类型的数据（例如事件计数（整数）、状态测量（浮点数）和标签（字符串或独热编码））时，Pandas
    数据框架特别有用。在这种情况下，您可能希望坚持使用 Pandas 数据框架（还要记住，“pandas”这个名字实际上来自于“面板数据”的省略，因此对许多用例来说，这是一种自然的格式）。
- en: Pandas data frames are widely used, and there are several resources online to
    [compare the various formats](https://perma.cc/BNJ5-EDGM) used to store this data.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas 数据框架被广泛使用，有多个在线资源可用于比较用于存储此类数据的[各种格式](https://perma.cc/BNJ5-EDGM)。
- en: Standard R Equivalents
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准 R 等效物
- en: The native formats for storing R objects are `.Rds` and `.Rdata` objects. These
    are binary file formats, so they will necessarily be more efficient both for compression
    and I/O than text-based formats, and in this way are akin to Pandas data frames
    in Python. Relatedly, the [`feather` format](https://perma.cc/4C3J-TBK8) can be
    used in both R and Python to save data frames in a language-agnostic file format.
    For R users, the native binary formats will (of course) be the most performant.
    [Table 5-3](#file-format-table) compares the file format options.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 存储 R 对象的本地格式是 `.Rds` 和 `.Rdata` 对象。这些都是二进制文件格式，因此它们在压缩和 I/O 方面必然比基于文本的格式更有效率，从这个角度来看，它们类似于
    Python 中的 Pandas 数据框架。相关地，[`feather` 格式](https://perma.cc/4C3J-TBK8) 可用于在 R 和
    Python 中以语言无关的文件格式保存数据框架。对于 R 用户来说，本地二进制格式（当然）是性能最佳的。[表格 5-3](#file-format-table)
    比较了文件格式选项。
- en: Table 5-3\. Size and performance comparison of file format options
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 5-3\. 文件格式选项的大小和性能比较
- en: '| Format name | Relative size | Relative time to load |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| 格式名称 | 相对大小 | 相对加载时间 |'
- en: '| --- | --- | --- |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| .RDS | 1x | 1x |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| .RDS | 1倍 | 1倍 |'
- en: '| feather | 2x | 1x |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| feather | 2倍 | 1倍 |'
- en: '| csv | 3x | 20x |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| csv | 3倍 | 20倍 |'
- en: As we can see, the native format is a clear winner to minimize both storage
    space and I/O, and those who use a text-based file format rather than binary will
    pay a heavy price both in storage and I/O slowdowns.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，本地格式明显是减少存储空间和I/O的优胜者，而那些使用文本文件格式而不是二进制文件的人在存储和I/O减速方面会付出沉重代价。
- en: Xarray
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Xarray
- en: 'When your time series data reaches many dimensions wide, it may be time to
    think about a more industrial data solution—namely [Xarray](http://xarray.pydata.org/en/stable),
    which is useful for a number of reasons:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的时间序列数据扩展到许多维度时，可能是时候考虑更工业化的数据解决方案了，即[Xarray](http://xarray.pydata.org/en/stable)，这有多个理由是有用的：
- en: Named dimensions
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名维度
- en: Vectorized mathematical operations, like NumPy
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像NumPy这样的向量化数学操作
- en: Group-by operations, like Pandas
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似Pandas的分组操作
- en: Database-like functionality that permits indexing based on a time range
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许根据时间范围进行索引的类似数据库的功能
- en: A variety of file storage options
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多种文件存储选项
- en: Xarray is a data structure that supports many time series–specific operations,
    such as indexing and resampling on time, interpolating data, and accessing individual
    components of a date time. Xarray was built as a high-performance scientific computing
    instrument, and it is woefully underutilized and underappreciated for time series
    analysis applications.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Xarray是一种支持许多时间序列特定操作的数据结构，例如在时间上索引和重采样、插值数据以及访问日期时间的各个组成部分。Xarray作为一个高性能科学计算工具构建，对于时间序列分析应用来说被严重低估和轻视。
- en: Xarray is a data structure in Python, and it comes with a choice of storage
    options. It implements both pickling and another binary file format called `netCDF`,
    a universal scientific data format supported across many platforms and languages.
    If you are looking to up your time series game in Python, Xarray is a good place
    to start.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Xarray是Python中的一种数据结构，它提供了多种存储选项。它实现了pickle和另一种称为`netCDF`的二进制文件格式，这是一种跨平台和多语言支持的通用科学数据格式。如果你希望在Python中提升你的时间序列应用能力，Xarray是一个不错的起点。
- en: 'As you’ve seen, there are many options for flat file storage of time series
    data, some with associated functionality (Xarray) and some with very streamlined,
    purely numeric formats (NumPy). When migrating a data set from a database-oriented
    pipeline to a file-oriented pipeline, there will be some growing pains related
    to simplifying data and rewriting scripts to move logic out of the database and
    into the explicit ETL (extract-transform-load) scripts. In cases where performance
    is paramount, moving your data into files is likely the most important step to
    reduce latency. Common cases where this is desirable include:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，有许多选项用于时间序列数据的平面文件存储，一些选项带有相关功能（如Xarray），一些选项则具有非常简化的纯数字格式（如NumPy）。当将数据集从面向数据库的流水线迁移到面向文件的流水线时，将会有一些与简化数据和重写脚本以将逻辑从数据库移出并放入显式ETL（提取-转换-加载）脚本相关的成长阵痛。在性能至关重要的情况下，将数据移到文件中很可能是减少延迟的最重要一步。常见的希望采取此方法的情况包括：
- en: Latency-sensitive forecasting, such as for user-facing software
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对延迟敏感的预测，比如用于用户界面的软件
- en: I/O-intensive repetitive data access situations, such as training deep learning
    models
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高I/O密集型重复数据访问情况，例如训练深度学习模型
- en: On the other hand, for many applications, the convenience, scalability, and
    flexibility of a database is well worth the higher latency. Your optimal storage
    situation will depend very much on the nature of the data you are storing and
    what you want to do with it.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，对于许多应用程序而言，数据库的便利性、可扩展性和灵活性远远超过了较高的延迟。你的最佳存储方案将在很大程度上取决于你存储的数据的性质以及你想要做什么。
- en: More Resources
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多资源
- en: 'On time series database technologies:'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于时间序列数据库技术：
- en: Jason Moiron, [“Thoughts on Time-Series Databases,”](https://perma.cc/8GDC-6CTX)
    jmoiron blog, June 30, 2015, https://perma.cc/8GDC-6CTX.
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Jason Moiron，《关于时间序列数据库的思考》，jmoiron博客，2015年6月30日，https://perma.cc/8GDC-6CTX。
- en: This classic blog post from 2015 provides a glimpse into an earlier time period
    with time series databases and the cult of recording everything. This high-level
    overview of options for storing time series databases and typical use cases is
    highly informative for beginners to database administration and engineering.
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这篇2015年的经典博文提供了一个早期时间段与时间序列数据库以及记录一切的崇拜之间的一瞥。这篇关于存储时间序列数据库选项和典型用例的高层次概述对于数据库管理和工程初学者非常有益。
- en: Preetam Jinka, [“List of Time Series Databases,”](https://perma.cc/9SCQ-9G57)
    Misframe blog, April 9, 2016, https://perma.cc/9SCQ-9G57.
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Preetam Jinka, [“时间序列数据库列表,”](https://perma.cc/9SCQ-9G57) Misframe 博客，2016年4月9日，https://perma.cc/9SCQ-9G57.
- en: This lengthy list of time series databases is frequently updated to show databases
    currently on the market. Each database entry comes with highlights as to how a
    particular database relates to its competitors and predecessors.
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这份时间序列数据库的长列表经常更新，展示目前市场上的数据库。每个数据库条目都有重点介绍，说明特定数据库与竞争对手和前辈的关系。
- en: 'Peter Zaitsev, [“Percona Blog Poll: What Database Engine Are You Using to Store
    Time Series Data?”](https://perma.cc/5PXF-BF7L) Percona blog, February 10, 2017,
    https://perma.cc/5PXF-BF7L.'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Peter Zaitsev, [“Percona 博客调查：您使用哪种数据库引擎存储时间序列数据？”](https://perma.cc/5PXF-BF7L)
    Percona 博客，2017年2月10日，https://perma.cc/5PXF-BF7L.
- en: This 2017 poll of database engineers indicated that relational databases (SQL
    databases) continued to dominate as a group, with 35% of respondents indicating
    they use these databases to store time series data. ElasticSearch, InfluxDB, MongoDB,
    and Prometheus were also favorites.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这项2017年的数据库工程师调查显示，关系数据库（SQL数据库）继续作为一个群体占据主导地位，35% 的受访者表示他们使用这些数据库来存储时间序列数据。ElasticSearch、InfluxDB、MongoDB
    和 Prometheus 也是受欢迎的选择。
- en: Rachel Stephens, [“The State of the Time Series Database Market,”](https://perma.cc/WLA7-ABRU)
    RedMonk, April 3, 2018, https://perma.cc/WLA7-ABRU.
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Rachel Stephens, [“时间序列数据库市场现状,”](https://perma.cc/WLA7-ABRU) RedMonk，2018年4月3日，https://perma.cc/WLA7-ABRU.
- en: This recent data-driven write-up by a tech analyst describes the most popular
    solutions to time series database storage via an empirical investigation of GitHub
    and Stack Overflow activity. The report also indicates a high degree of fragmentation
    in the time series storage domain due to a wide variety of use cases for time
    series data as well as a larger trend toward segmentation in databases.
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一位技术分析师最近的数据驱动撰写描述了通过对GitHub和Stack Overflow活动的实证调查，时间序列数据库存储的最流行解决方案。报告还显示由于时间序列数据的广泛用例以及数据库分段化的趋势，时间序列存储领域存在较高的分散度。
- en: 'Prometheus.io, [“Prometheus Documentation: Comparison to Alternatives,”](https://perma.cc/M83E-NBHQ)
    n.d., https://perma.cc/M83E-NBHQ.'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Prometheus.io, [“Prometheus 文档：与其他备选方案的比较,”](https://perma.cc/M83E-NBHQ) 无日期，https://perma.cc/M83E-NBHQ.
- en: This extremely detailed and comprehensive list compares Prometheus to a number
    of other popular time series storage solutions. You can use this model as a quick
    reference for the dominant data structures and storage structures used by the
    alternatives to Prometheus. This is a good place to get an overview of what’s
    on offer and what the trade-offs are between various databases designed for temporal
    data.
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这份极其详细和全面的列表将Prometheus与其他流行的时间序列存储解决方案进行比较。您可以将此模型用作快速参考，了解与Prometheus替代方案相关的主导数据结构和存储结构。这是一个了解当前提供的选择以及各种为时序数据设计的数据库之间权衡的好地方。
- en: 'On adapting general database technologies:'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于调整通用数据库技术：
- en: Gregory Trubetskoy, [“Storing Time Series in PostreSQL Efficiently,”](https://perma.cc/QP2D-YBTS)
    Notes to Self blog, September 23, 2015, https://perma.cc/QP2D-YBTS.
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Gregory Trubetskoy, [“高效在PostgreSQL中存储时间序列,”](https://perma.cc/QP2D-YBTS) Notes
    to Self 博客，2015年9月23日，https://perma.cc/QP2D-YBTS.
- en: This older but still relevant blog post explains how to store time series in
    Postgres in a performance-focused way. Trubetskoy explains the difficulties of
    the “naive” approach of a column of values and a column of timestamps, and gives
    practical advice for approaches based on Postgres arrays.
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这篇较老但仍然相关的博文解释了如何以性能为重点在Postgres中存储时间序列。Trubetskoy解释了“朴素”方法（数值列和时间戳列）的困难，并给出了基于Postgres数组的实用建议。
- en: Josiah Carlson, [“Using Redis as a Time Series Database,”](https://perma.cc/RDZ2-YM22)
    InfoQ, January 2, 2016, https://perma.cc/RDZ2-YM22.
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Josiah Carlson, [“使用Redis作为时间序列数据库,”](https://perma.cc/RDZ2-YM22) InfoQ，2016年1月2日，https://perma.cc/RDZ2-YM22.
- en: This article provides detailed advice and examples related to using Redis as
    a time series database. While Redis has been used for time series data since its
    creation, there are several gotchas the author points out as well as advantageous
    data structures that can be applied in many time series use case scenarios. This
    article is useful for learning more about how to use Redis with time series data,
    but also as an example of how more general tools can be repurposed for time series–specific
    uses.
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本文提供了有关如何使用Redis作为时间序列数据库的详细建议和示例。虽然Redis自创建以来一直被用于时间序列数据，但作者指出了几个需要注意的地方，以及可以在许多时间序列使用案例场景中应用的优势数据结构。这篇文章不仅对于学习如何使用Redis处理时间序列数据很有帮助，而且作为如何将更一般的工具重新用于时间序列特定用途的示例也非常有用。
- en: 'Mike Freedman, [“Time Series Data: Why (and How) to Use a Relational Database
    Instead of NoSQL,”](https://perma.cc/A6CU-6XTZ) Timescale blog, April 20, 2017,
    https://perma.cc/A6CU-6XTZ.'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 迈克·弗里德曼，[“时间序列数据：为什么（以及如何）使用关系数据库而不是NoSQL”](https://perma.cc/A6CU-6XTZ)，Timescale博客，2017年4月20日，https://perma.cc/A6CU-6XTZ。
- en: This blog post by TimescaleDB’s founder describes the ways in which his team
    built a time series database as a relational database with memory layout modifications
    specific to temporal data. TimescaleDB’s contention is that the main problem with
    traditional SQL databases for time series data is that such databases do not scale,
    resulting in slow performance as data is shifted into and out of memory to perform
    time-related queries. TimescaleDB proposes laying out memory and memory mappings
    to reflect the temporal nature of data and reduce swapping disparate data into
    and out of memory.
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: TimescaleDB的创始人在这篇博客文章中描述了他的团队如何构建一个具有特定于时间数据的内存布局修改的时间序列数据库作为关系数据库。TimescaleDB认为传统SQL数据库在处理时间序列数据时的主要问题是不可扩展性，导致数据在内存中进出进行时间相关查询时性能缓慢。TimescaleDB建议布置内存和内存映射以反映数据的时间性质，并减少将不同数据交换到内存中和从内存中交换出去的次数。
- en: Hilmar Buchta, [“Combining Multiple Tables with Valid from/to Date Ranges into
    a Single Dimension,”](https://perma.cc/B8CT-BCEK) Oraylis blog, November 17, 2014,
    https://perma.cc/B8CT-BCEK.
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 希尔马尔·布赫塔，[“将多个表与有效时间范围合并为单个维度”](https://perma.cc/B8CT-BCEK)，Oraylis博客，2014年11月17日，https://perma.cc/B8CT-BCEK。
- en: While the title is not very appealing, this is an extremely useful blog post
    for those of us who are not SQL database experts. It illustrates a good way to
    deal with the hairy problem of data that is marked as being valid only for a certain
    range of time and how to combine this data and join with it across multiple tables.
    This is a surprisingly common and a surprisingly difficult task. The example covered
    involves a few human resources charts, including an employee’s valid dates of
    employment, valid dates for a given department, valid dates for a specific office
    location, and valid dates for a company car. A very likely task would be to determine
    an employee’s status on a particular day—was that person employed, and if so,
    in what department and in what location, and did the employee have a company car?
    This sounds intuitive, but the SQL to answer this question is difficult and well
    covered in this post.
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 虽然标题不太吸引人，但对于我们这些不是SQL数据库专家的人来说，这篇博客文章非常有用。它展示了一种处理标记为仅在特定时间范围内有效的数据及如何跨多个表进行联合的良好方式。这是一个令人惊讶地常见且难以解决的问题。所涉及的示例包括几个人力资源图表，包括雇员的雇佣有效日期、给定部门的有效日期、特定办公室位置的有效日期以及公司汽车的有效日期。一个非常可能的任务是确定某一天雇员的状态—该人是否受雇，并且在哪个部门、在哪个位置，并且是否有公司汽车？这听起来很直观，但要回答这个问题所需的SQL查询却很困难，在这篇文章中有详细的覆盖。
- en: '^([1](ch05.html#idm45576039147144-marker)) See, for example, [“Schema Design
    for Time Series Data in MongoDB”](https://perma.cc/E8XL-R3SY), [“Time Series Data
    and MongoDB: Part 1 – An Introduction”](https://perma.cc/A2D5-HDFB), and [“Time
    Series Data and MongoDB: Part 2 – Schema Design Best Practices”](https://perma.cc/2LU7-YDHX).
    For a contrary view, see [“How to store time-series data in MongoDB, and why that’s
    a bad idea”](https://perma.cc/T4KM-Z2B4).'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch05.html#idm45576039147144-marker)) 例如，参见[“MongoDB中的时间序列数据模式设计”](https://perma.cc/E8XL-R3SY)，[“时间序列数据与MongoDB：第1部分
    – 简介”](https://perma.cc/A2D5-HDFB)，以及[“时间序列数据与MongoDB：第2部分 – 模式设计最佳实践”](https://perma.cc/2LU7-YDHX)。相反的观点请参考[“如何在MongoDB中存储时间序列数据，以及为什么这是个坏主意”](https://perma.cc/T4KM-Z2B4)。
- en: ^([2](ch05.html#idm45576039133192-marker)) The optimization of SQL databases
    for time series data is beyond the scope of this book and tends to be very specific
    to use case. Some resources at the end of the chapter address this question.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch05.html#idm45576039133192-marker)) SQL 数据库针对时间序列数据的优化超出了本书的范围，并且往往非常具体于使用情况。本章末尾的一些资源解答了这个问题。
