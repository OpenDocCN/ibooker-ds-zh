- en: 11 Simulating force fields
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11 模拟力场
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Modeling forces like gravity using scalar and vector fields
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标量和矢量场建模像重力这样的力
- en: Calculating force vectors using the gradient
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用梯度计算力矢量
- en: Taking the gradient of a function in Python
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python中计算函数的梯度
- en: Adding gravitational force to the asteroid game
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为小行星游戏添加引力
- en: Calculating gradients and working with vector fields in higher dimensions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在高维空间中计算梯度场和操作矢量场
- en: 'There has just been a catastrophic event in the universe of our asteroid game:
    a black hole has appeared in the center of the screen! As a result of this new
    object in our game, shown in figure 11.1, the spaceship and all of the asteroids
    will feel a “gravitational pull” toward the middle of the screen. This makes the
    game even more challenging, and it gives us a new mathematical challenge as well−understanding
    *force fields*.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的小行星游戏宇宙中刚刚发生了一场灾难性事件：屏幕中央出现了一个黑洞！由于这个新物体（如图11.1所示）的出现，飞船和所有的小行星都将感受到“引力吸引”向屏幕中央。这使得游戏更具挑战性，同时也给我们带来了一个新的数学挑战−理解
    *力场*。
- en: '![](../Images/CH11_F01_Orland.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH11_F01_Orland.png)'
- en: Figure 11.1 Oh no, a black hole!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 哎呀，黑洞！
- en: Gravity is a familiar example of a force that acts at a distance, meaning that
    you don’t have to be touching an object to feel its gravitational pull. For instance,
    when you’re flying on an airplane, you can still walk around normally because,
    even at
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 重力是距离作用力的熟悉例子，这意味着你不需要接触一个物体就能感受到它的引力。例如，当你乘坐飞机时，你仍然可以正常行走，因为即使在
- en: 30,000 feet, the Earth is pulling you downward. Magnetism and static electricity
    are other familiar forces that act at a distance. In physics, we picture sources
    of these kinds of forces, like magnets or statically charged balloons, as generating
    an invisible force field around themselves. Anywhere in the Earth’s gravitational
    force field, called its gravitational field, an object will feel a pull toward
    the Earth.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 30,000英尺的高度，地球正在向下拉着你。磁力和静电是其他熟悉的距离作用力。在物理学中，我们想象这些力的来源，如磁铁或静电充气的气球，在它们周围产生一个看不见的力场。在任何地球引力场（称为引力场）中的任何地方，一个物体都会感受到向地球的拉力。
- en: Our central coding challenge for this chapter is adding a gravitational field
    to the asteroid game, and once we’re done with that, we’ll cover the math in more
    generality. Namely, force fields are modeled with mathematical functions called
    vector fields. Vector fields often arise as outputs from a calculus operation
    called the *gradient*, which is a key tool in the machine learning examples we
    cover in part 3.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的核心编码挑战是为小行星游戏添加引力场，一旦完成这个任务，我们将更普遍地介绍数学。具体来说，力场是用称为矢量场的数学函数建模的。矢量场通常作为微积分运算（称为
    *梯度*）的输出，而梯度是我们在第3部分中涵盖的机器学习示例中的关键工具。
- en: The math and code in this chapter aren’t particularly hard, but there are a
    lot of new concepts to get familiar with. For that reason, I want to show you
    the story arc for the chapter before we dig in in earnest.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的数学和代码并不特别难，但有很多新的概念需要熟悉。因此，在深入探讨之前，我想先展示本章的故事线。
- en: 11.1 Modeling gravity with a vector field
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1 使用矢量场建模重力
- en: A *vector field* is an assignment of a vector at every point in space. A *gravitational
    field* is a vector field telling us how strongly gravity pulls and in what direction
    from any given point. You can visualize a vector field by picking a bunch of points
    and drawing the vector assigned to each point as an arrow starting from that point.
    For instance, the gravitational field caused by the black hole in our asteroid
    game might look like figure 11.2.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *矢量场* 是在空间中的每一个点分配一个矢量。一个 *引力场* 是一个矢量场，它告诉我们从任何给定点引力有多强以及引力方向是什么。你可以通过选择一些点并从每个点开始绘制分配给该点的矢量作为箭头来可视化矢量场。例如，我们小行星游戏中由黑洞产生的引力场可能看起来像图11.2。
- en: '![](../Images/CH11_F02_Orland.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH11_F02_Orland.png)'
- en: Figure 11.2 Picturing the gravitational field created by the black hole in our
    asteroid game
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 在我们的小行星游戏中描绘由黑洞产生的引力场
- en: Figure 11.2 agrees with our intuition about gravity; all the arrows around the
    black hole point toward it, so that any object placed in this region feels pulled
    toward the black hole. Closer to the black hole, it’s gravitational pull is stronger,
    so the arrows are longer.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2与我们关于引力的直觉一致；围绕黑洞的所有箭头都指向黑洞，因此任何放置在这个区域的物体都会感受到被黑洞吸引。靠近黑洞的地方，它的引力更强，因此箭头更长。
- en: The first thing we do in this chapter is to model gravitational fields as functions,
    taking a point in space to tell us the magnitude and direction of the force an
    object would feel at that point. In Python, a 2D vector field is a function that
    takes a 2D vector representing a point and returns a 2D vector that is the force
    at that point.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的第一件事是将引力场建模为函数，通过空间中的一个点来告诉我们物体在该点会感受到的力的强度和方向。在Python中，一个二维矢量场是一个函数，它接受一个表示点的二维矢量，并返回一个在该点的二维矢量，即该点的力。
- en: Once we build that function, we use it to add a gravitational field to our asteroid
    game. It will tell us what gravitational forces are felt by the spaceship and
    the asteroids, depending on their locations and, therefore, what their rate and
    direction of acceleration should be. Once we implement the acceleration, we’ll
    see the objects in the asteroid game accelerate toward the black hole.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们构建了这个函数，我们就用它来为我们的小行星游戏添加引力场。它将告诉我们宇宙飞船和小行星在它们的位置上感受到的引力，因此，它们的加速度速率和方向应该是什么。一旦我们实现了加速度，我们将在小行星游戏中看到物体向黑洞加速。
- en: 11.1.1 Modeling gravity with a potential energy function
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.1 使用势能函数建模引力
- en: After modeling the gravitational field, we’ll look at a second, equivalent mental
    model for force at a distance, called *potential energy*. You can think of potential
    energy as stored energy, ready to be converted into motion. For instance, a bow
    and arrow have no potential energy to begin with, but when you stretch the bow
    it gains potential energy. When the bow is released, this energy is converted
    into motion (figure 11.3).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在建模引力场之后，我们将探讨第二个等效的心理模型，即称为*势能*的远程力。你可以将势能视为储存的能量，准备转换为运动。例如，一开始弓箭没有势能，但是当你拉弓时，它就获得了势能。当弓被释放时，这种能量就转换为运动（图11.3）。
- en: '![](../Images/CH11_F03_Orland.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH11_F03_Orland.png)'
- en: Figure 11.3 On the left, the bow has no potential energy. On the right, it has
    a lot of potential energy, ready to be spent to put the arrow in motion.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3 左边，弓没有势能。右边，它具有大量的势能，准备用来使箭运动。
- en: You can picture pulling a spaceship away from the black hole as pulling back
    an imaginary bow and arrow. The further you pull the spaceship from the black
    hole, the more potential energy it has, and the faster it ends up going after
    it is released. We’ll model potential energy as another Python function, taking
    the 2D position vector of an object in the game world and returning a number measuring
    its potential energy at that point. An assignment of a number (instead of a vector)
    to every point in space is called a *scalar field*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以想象将宇宙飞船从黑洞拉远就像拉回一个想象中的弓箭。你将宇宙飞船拉得越远，它就具有越多的势能，释放后它最终的速度就越快。我们将势能建模为另一个Python函数，它接受游戏世界中物体的二维位置矢量，并返回该点势能的数值。将数值（而不是矢量）分配给空间中的每个点称为*标量场*。
- en: With a potential energy function, we’ll use several Matplotlib visualizations
    to see what it looks like. One important example is called a *heatmap*, which
    uses darker and brighter colors to show how the value of a scalar field changes
    over a 2D space (figure 11.4).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用势能函数，我们将使用几个Matplotlib可视化来查看其外观。一个重要的例子是称为*热图*，它使用深浅不同的颜色来显示标量场在二维空间中的值如何变化（图11.4）。
- en: '![](../Images/CH11_F04_Orland.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH11_F04_Orland.png)'
- en: Figure 11.4 A heatmap of potential energy, using brighter colors to represent
    higher potential energy values
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4 使用较亮的颜色表示较高势能值的热图
- en: As figure 11.4 shows, the further away from the black hole you get on this heatmap,
    the brighter the colors get, meaning the potential energy is greater. The scalar
    field representing potential energy is a different mathematical model than the
    vector field representing gravitational force, but they represent the same physics.
    They are also mathematically connected by an operation called the *gradient*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如图11.4所示，在这个热力图上，你离黑洞越远，颜色越亮，这意味着势能越大。表示势能的标量场与表示引力场的矢量场是不同的数学模型，但它们代表相同的物理现象。它们还通过称为“梯度”的运算在数学上相互关联。
- en: The gradient of a scalar field is a vector field, which tells us the direction
    and magnitude of steepest increase in the scalar field. In our example, potential
    energy increases as you move away from the black hole, so the gradient of potential
    energy is a vector field pointing outward at every point. Superimposing the gradient
    vector field on the potential energy heatmap, figure 11.5 shows us that arrows
    point in the direction that the potential energy increases.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 标量场的梯度是一个矢量场，它告诉我们标量场中最大增加的方向和大小。在我们的例子中，势能随着你远离黑洞而增加，因此势能的梯度是一个在每个点上指向外部的矢量场。将梯度矢量场叠加在势能热力图上，图11.5显示箭头指向势能增加的方向。
- en: '![](../Images/CH11_F05_Orland.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH11_F05_Orland.png)'
- en: Figure 11.5 Potential energy function plotted as a heatmap with its gradient,
    a vector field, superimposed. The gradient points in the direction of increasing
    potential energy.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5展示了势能函数作为热力图绘制，其梯度，一个矢量场，叠加在上面。梯度指向势能增加的方向。
- en: The gradient vector field in figure 11.5 looks similar to the gravitational
    field of the black hole, except the arrows are pointing in the opposite directions
    and the magnitudes are reversed. To get a gravitational field from a potential
    energy function, we need to take the gradient and then reverse the directions
    of the force field vectors by adding a minus sign. At the end of this chapter,
    I’ll show you how to calculate the gradient of a scalar field using derivatives,
    which allow us to switch from the potential energy model of gravity to the force
    field model of gravity.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5中的梯度矢量场看起来类似于黑洞的引力场，但箭头指向相反的方向，大小相反。要从势能函数中获得引力场，我们需要取梯度，然后通过添加负号来反转力场矢量的方向。在本章结束时，我将向您展示如何使用导数来计算标量场的梯度，这使我们能够从重力的势能模型切换到力场模型。
- en: Now that you have a sense of where we’re going in this chapter, we’re ready
    to dig in. The first thing we’ll do is look closer at vector fields and see how
    to turn them into Python functions.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你对本章的内容有了大致的了解，我们就准备深入研究了。我们将首先更仔细地研究矢量场，并看看如何将它们转换为Python函数。
- en: 11.2 Modeling gravitational fields
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.2 建模引力场
- en: A vector field is an assignment of a vector to every point in a space−for instance,
    a gravitational force vector for every location in our asteroid game. We’ll look
    exclusively at 2D vector fields that assign 2D vectors to every point in a 2D
    space. The first thing we’ll
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 矢量场是对空间中每个点分配一个矢量，例如，在我们的小行星游戏中，每个位置的引力力矢量。我们将专门研究二维矢量场，它将二维矢量分配给二维空间中的每个点。我们将首先
- en: do is build concrete representations of vector fields as Python functions taking
    2D vectors as inputs and returning 2D vectors as outputs. I’ve given you a function,
    `plot_vector _field`, in the source code that takes such a function as an argument
    and draws a picture of it by drawing the output vectors at a large number of input
    points in 2D.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的是构建矢量场的具体表示，作为Python函数，它接受二维矢量作为输入，并返回二维矢量作为输出。我在源代码中提供了一个函数`plot_vector_field`，它接受这样的函数作为参数，并通过在二维的大量输入点上绘制输出矢量来绘制它的图像。
- en: Then, we’ll write code to add a black hole to our asteroid game. For our purposes,
    a black hole just means a black circle that exerts an attractive force on all
    objects around it as shown in figure 11.6.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将编写代码将黑洞添加到我们的小行星游戏中。对我们来说，黑洞只是一个黑色圆圈，它对周围的物体施加吸引力，如图11.6所示。
- en: '![](../Images/CH11_F06_Orland.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH11_F06_Orland.png)'
- en: Figure 11.6 The black hole in our asteroid game is a black circle with every
    object in the game feeling the pull of a force toward it.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6显示，在我们的小行星游戏中，黑洞是一个黑色圆圈，游戏中的每个物体都感受到向它施加的引力。
- en: To make this work, we implement a `BlackHole` class, define its corresponding
    gravitational field as a function and then update our game loop so that the spaceship
    and asteroids respond to the forces according to Newton’s laws.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这起作用，我们实现一个 `BlackHole` 类，定义其相应的引力场为一个函数，然后更新我们的游戏循环，使太空船和小行星根据牛顿定律对力做出反应。
- en: 11.2.1 Defining a vector field
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.1 定义向量场
- en: Let’s cover a bit of basic notation for vector fields. A vector field in the
    2D plane is a function **F**(*x*, *y*) that takes a vector represented by its
    two coordinates, *x* and *y*. It returns another 2D vector that is the value of
    the vector field at the point (*x*, *y*). The bold **F** signifies that its return
    values are vectors and that we can say that **F** is a vector-valued function.
    When we’re talking about vector fields, we usually interpret the inputs as points
    in the plane and the outputs as arrows. Figure 11.7 shows a schematic for the
    vector field **F**(*x*, *y*) = (−2*y*, *x*).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要介绍一些向量场的基本符号。二维平面上的向量场是一个函数 **F**(*x*, *y*)，它接受由其两个坐标 *x* 和 *y* 表示的向量。它返回另一个二维向量，这是向量场在点
    (*x*, *y*) 处的值。粗体 **F** 表示其返回值是向量，我们可以说 **F** 是一个向量值函数。当我们谈论向量场时，我们通常将输入解释为平面上的点，将输出解释为箭头。图
    11.7 显示了向量场 **F**(*x*, *y*) = (−2*y*, *x*) 的示意图。
- en: '![](../Images/CH11_F07_Orland.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH11_F07_Orland.png)'
- en: Figure 11.7 The vector field F(*x, y*) = (−2y, x) takes the point (3, 1) as
    input and produces the arrow (−2, 3) as output.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.7 向量场 F(*x, y*) = (−2y, x) 以点 (3, 1) 为输入，并产生输出箭头 (−2, 3)。
- en: It’s usual to draw the output vector as an arrow starting from the point in
    the plane that was the input vector, so that the output vector is “attached” to
    the input point (figure 11.8).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们将输出向量绘制为从平面上的输入向量点开始的箭头，这样输出向量就“附加”到输入点上（图 11.8）。
- en: '![](../Images/CH11_F08_Orland.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH11_F08_Orland.png)'
- en: Figure 11.8 Attaching the vector (−2, 3) to the point (3, 1)
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.8 将向量 (−2, 3) 附加到点 (3, 1)
- en: If you calculate several values of **F**, you can start to picture the vector
    field by drawing a number of arrows attached to points at once. Figure 11.9 shows
    three more points, (−2, 2), (−1, −2), and (−1, −2) with arrows attached to them
    representing the values of **F** at the points. The results are (−4, −2), (4,
    −1), and (4, 3), respectively.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计算 **F** 的几个值，你可以通过同时绘制多个附加到点的箭头来开始想象向量场。图 11.9 显示了三个额外的点 (−2, 2)，(−1, −2)，和
    (−1, −2)，它们各自附加了表示 **F** 在这些点上的值的箭头。结果分别是 (−4, −2)，(4, −1)，和 (4, 3)。
- en: '![](../Images/CH11_F09_Orland.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH11_F09_Orland.png)'
- en: Figure 11.9 Arrows attached to points, representing more values of the vector
    field F(*x, y*) = (−2y, x)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.9 将箭头附加到点，表示向量场 F(*x, y*) = (−2y, x) 的更多值
- en: '![](../Images/CH11_F10_Orland.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH11_F10_Orland.png)'
- en: Figure 11.10 A plot of F(*x, y*) as vectors emanating from (*x, y*) points that
    are generated by Matplotlib
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.10 以向量形式绘制 F(*x, y*)，这些向量从由 Matplotlib 生成的 (*x, y*) 点发散出来
- en: 'If we draw a lot more arrows, they start to overlap and the diagram becomes
    illegible. To avoid this, we typically scale down the lengths of vectors by a
    constant factor. I’ve included a wrapper function called `plot_vector_field` on
    top of Matplotlib, and you can use it as follows to generate a visualization of
    a vector field. You can see that the vector field **F**(*x*, *y*) circulates in
    a counterclockwise direction around the origin (figure 11.10):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们画很多箭头，它们开始重叠，图变得难以辨认。为了避免这种情况，我们通常通过一个常数因子缩小向量的长度。我在 Matplotlib 上包含了一个名为
    `plot_vector_field` 的包装函数，你可以按照以下方式使用它来生成向量场的可视化。你可以看到向量场 **F**(*x*, *y*) 以逆时针方向围绕原点循环（图
    11.10）：
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ The first argument is the vector field; the next arguments are the *x* bounds
    followed by the y bounds for the plot.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 第一个参数是向量场；下一个参数是绘图的范围 *x* 界限，然后是 y 界限。
- en: One of the big ideas of physics is how some kinds of forces are modeled by vector
    fields. The example we focus on next is a simplified model of gravity.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 物理学的一个重大思想是某些类型的力如何通过向量场建模。我们接下来要关注的例子是重力的一种简化模型。
- en: 11.2.2 Defining a simple force field
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.2 定义简单的力场
- en: 'As you might expect, gravitational forces get stronger as you get closer to
    their sources. Even though the sun has stronger gravity than the Earth, you are
    much closer to the Earth, so you only feel the Earth’s gravity. For simplicity,
    we won’t use a realistic gravitational field. Instead, we’ll use the vector field
    **F**(**r**) = −**r**, which is **F**(*x*, *y*) = (−*x*, − *y*) in the plane.
    Here’s what it looks like in code, and figure 11.11 shows what it looks like on
    a plot:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所预期，随着您靠近它们的来源，引力会变得更强。尽管太阳的引力比地球强，但您离地球更近，所以您只感觉到地球的引力。为了简化，我们不会使用真实的引力场。相反，我们将使用向量场
    **F**(**r**) = −**r**，在平面上的表示为 **F**(*x*, *y*) = (−*x*, − *y*)。以下是它在代码中的样子，图11.11显示了它在图上的样子：
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![](../Images/CH11_F11_Orland.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH11_F11_Orland.png)'
- en: Figure 11.11 A visualization of the vector field F(*x, y*) = (−x, -y)
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.11 向量场 F(*x, y*) = (−x, -y) 的可视化
- en: This vector field is like a gravitational field in that it points toward the
    origin everywhere, but it has the advantage that the field gets stronger as you
    go further away. That guarantees that we can’t have a simulated object reach escape
    velocity and completely disappear from view; every wayward object eventually gets
    to a point where the force field is big enough to slow it down and pull it back
    toward the origin. Let’s confirm this by implementing this gravitational field
    for a black hole in our asteroid game.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个向量场就像一个引力场，它在任何地方都指向原点，但它有一个优点，即随着距离的增加，场变得更强。这保证了模拟物体无法达到逃逸速度并完全消失在视野中；任何偏离的物体最终都会到达一个力场足够强大以减慢其速度并将其拉回原点的点。让我们通过在我们的小行星游戏中实现这个引力场来验证这一点。
- en: 11.3 Adding gravity to the asteroid game
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.3 在小行星游戏中添加引力
- en: 'The black hole in our game is a `PolygonModel` object with 20 vertices at equal
    distances, so it will be approximately circular. We specify the strength of the
    gravitational pull of the black hole by one number, which we’ll call its gravity.
    This number is passed to the constructor for the black hole:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏中的黑洞是一个具有20个等距顶点的 `PolygonModel` 对象，因此它将大致呈圆形。我们通过一个数字指定黑洞的引力强度，我们将称之为其引力。这个数字传递给了黑洞的构造函数：
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Defines the vertices of the BlackHole as a PolygonModel
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义BlackHole的顶点为PolygonModel
- en: Note that the 20 vertices in our `BlackHole` are all 0.5 units from the origin
    at equally spaced angles, so the black hole appears approximately circular. Adding
    this line
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的 `BlackHole` 中的20个顶点都位于原点0.5个单位距离处，角度均匀分布，因此黑洞看起来大致呈圆形。添加以下行
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: creates a `BlackHole` object with `gravity` valued at `0.1`, which is positioned
    at the origin by default. To make the black hole appear onscreen (figure 11.12),
    we need to draw it with
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了一个 `BlackHole` 对象，其 `gravity` 值为 `0.1`，默认情况下位于原点。为了使黑洞出现在屏幕上（图11.12），我们需要用以下方式绘制它：
- en: '![](../Images/CH11_F12_Orland.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH11_F12_Orland.png)'
- en: Figure 11.12 Making the black hole show up in the center of our game screen
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.12 使黑洞出现在我们的游戏屏幕中心
- en: 'each iteration of the game loop. In the following, I add a `fill` keyword argument
    to the `draw_poly` function to fill in the black hole and make it (appropriately)
    black:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏循环的每次迭代。在下面的内容中，我向 `draw_poly` 函数添加了一个 `fill` 关键字参数来填充黑洞，使其（适当地）变黑：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The gravitational field created by our black hole is inspired by the vector
    field **F**(*x*, *y*) = (−*x*, − *y*), which points to the origin. If the black
    hole is centered at (*x[bh]*, *y[bh]*), the vector field **g**(*x*, *y*) = (*x[bh]*
    − *x*, *y[bh]* − *y*) points in the direction from (*x*, *y*) to (*x[bh]*, *y[bh]*).
    That means that as an arrow attached to the point (*x*, *y*), it points toward
    the center of the black hole. To make the strength of the force field scale with
    the gravity of the black hole, we can multiply the vectors of the vector field
    by the gravity value:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的黑洞产生的引力场灵感来源于向量场 **F**(*x*, *y*) = (−*x*, − *y*)，它指向原点。如果黑洞位于 (*x[bh]*, *y[bh]*)，则向量场
    **g**(*x*, *y*) = (*x[bh]* − *x*, *y[bh]* − *y*) 指向从 (*x*, *y*) 到 (*x[bh]*, *y[bh]*)
    的方向。这意味着，如果将箭头附着在点 (*x*, *y*) 上，它将指向黑洞的中心。为了使力场的强度与黑洞的引力成正比，我们可以将向量场的向量乘以引力值：
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In this function, `source` is a `BlackHole` object, and its `x` and `y` properties
    indicate its center as a `PolygonModel`, while its `gravity` property is the value
    passed to it in its constructor. The equivalent force field in mathematical notation
    would be written like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，`source` 是一个 `BlackHole` 对象，其 `x` 和 `y` 属性表示其中心作为一个 `PolygonModel`，而其
    `gravity` 属性是在其构造函数中传递给它的值。用数学符号表示的等效力场可以写成这样：
- en: '***g***(*x*, *y*) = *G[bh]* ·(*x* − *x[bh]*, *y* − *y[bh]*)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '***g***(*x*, *y*) = *G[bh]* ·(*x* − *x[bh]*, *y* − *y[bh]*)'
- en: Here, *Gbh* represents the made-up `gravity` property of the black hole, and
    (*x[bh]*, *y[bh]*), once again, represents its position. The next step is to use
    this gravitational field to decide how objects should move.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*Gbh* 代表黑洞的虚构 `gravity` 属性，而 (*x[bh]*, *y[bh]*)，再次，代表其位置。下一步是使用这个重力场来决定物体应该如何移动。
- en: 11.3.1 Making game objects feel gravity
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.1 使游戏对象感受到重力
- en: 'If this vector field works like a gravitational field, it tells us the force
    per unit mass on an object at position (*x*, *y*). In other words, the force on
    an object of mass *m* will be **F**(*x*, *y*) = *m* · **g**(*x*, *y*). If this
    is the only force our object feels, we can figure out its acceleration using Newton’s
    second law of motion:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个矢量场像重力场一样工作，它告诉我们位于 (*x*, *y*) 位置的单位质量物体上的力。换句话说，质量为 *m* 的物体上的力将是 **F**(*x*,
    *y*) = *m* · **g**(*x*, *y*)。如果这是物体感受到的唯一力，我们可以使用牛顿第二定律来计算其加速度：
- en: '![](../Images/CH11_F12_Orland_EQ02.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH11_F12_Orland_EQ02.png)'
- en: This last expression for acceleration has the mass *m* in both the numerator
    and denominator, so they cancel out. It turns out that the gravitational field
    vector is equal to the acceleration vector caused by gravity−it has nothing to
    do with the object’s mass. This calculation works for real gravitational fields
    as well, and it is why objects of different masses all fall at the same rate of
    about 9.81 meters per second near the Earth’s surface. In one iteration of the
    game loop taking an elapsed time Δ*t*, the change in velocity of a spaceship or
    asteroid is determined by its (*x*, *y*) position as
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个加速度的最后一个表达式在分子和分母中都有质量 *m*，所以它们相互抵消。结果发现，重力场矢量等于由重力引起的加速度矢量——它与物体的质量无关。这个计算对于真实重力场同样适用，这就是为什么在地球表面附近，不同质量的物体都以大约每秒9.81米的相同速率下落。在游戏循环的一次迭代中，考虑经过的时间
    Δ*t*，宇宙飞船或小行星的速度变化由其 (*x*, *y*) 位置决定：
- en: Δ*v* = *a* · Δ*t* = *g*(*x*, *y*) · Δt
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Δ*v* = *a* · Δ*t* = *g*(*x*, *y*) · Δt
- en: 'We need to add some code to update the velocity of the spaceship as well as
    each asteroid in each iteration of the game loop. There are a few choices as to
    how to organize our code, and the one I’ll choose is to encapsulate all of the
    physics into the `move` method of `PolygonModel` objects. You might also remember
    that instead of having objects fly off the screen, we teleported them to the other
    side. Another small change I’ve made here is to add a global `bounce` flag that
    says whether objects teleport or simply bounce off the sides of the screen. I’ve
    done this because if objects teleport, they instantly feel a different gravitational
    field; if they bounce instead, we get more intuitive physics. Here’s the new `move`
    method:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在游戏循环的每次迭代中添加一些代码来更新宇宙飞船以及每个小行星的速度。关于如何组织我们的代码，有几个选择，而我将选择将所有物理封装到 `PolygonModel`
    对象的 `move` 方法中。你可能也记得，我们不是让物体飞离屏幕，而是将它们传送到另一边。我在这里做的另一个小改动是添加一个全局 `bounce` 标志，表示物体是传送还是简单地从屏幕边缘弹回。我这样做是因为如果物体传送，它们会立即感受到不同的重力场；如果它们弹回，我们得到更直观的物理现象。下面是新的
    `move` 方法：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Passes in the thrust vector, which can be (0,0), and the gravity source (black
    hole) as parameters to the move method
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将推力矢量（可以是 (0,0)）和重力源（黑洞）作为参数传递给移动方法
- en: ❷ Here the net force is the sum of the thrust vector and gravitational force
    vector. Assume the mass = 1 and the acceleration is the sum of the thrust and
    gravitational field.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 这里，合力是推力矢量和重力矢量的和。假设质量 = 1，加速度是推力和重力场的和。
- en: ❸ Updates the velocity as before, using Δv = a*Δt
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如前所述更新速度，使用 Δv = a*Δt
- en: ❹ Updates the position vector as before, using Δs = v*Δt
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 如前所述更新位置矢量，使用 Δs = v*Δt
- en: ❺ If the global bounce flag is true, flips the *x* component of velocity when
    the object is about to leave the screen on the left or right, or flips the y component
    of velocity when the object is about to leave the screen through the top or bottom
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 如果全局反弹标志为真，则在物体即将离开屏幕的左侧或右侧时翻转速度的 *x* 分量，或者在物体即将通过顶部或底部离开屏幕时翻转速度的 *y* 分量
- en: ❻ Otherwise, uses the same teleportation effect as before when the object is
    about to leave the screen
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 否则，当物体即将离开屏幕时，使用之前相同的传送效果
- en: 'The remaining work is to call this `move` method for the spaceship as well
    as each asteroid in the game loop:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的工作是在游戏循环中调用太空船的 `move` 方法以及每个小行星：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ For each asteroid, calls its move method with a thrust vector of 0
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 对于每个小行星，使用推力向量为 0 调用其 move 方法
- en: ❷ The ship’s thrust vector is also (0,0) by default.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 船的推力矢量默认也是 (0,0)。
- en: ❸ If the up or down arrow is pressed, calculates the thrust_vector using the
    direction of the spaceship and the fixed thrust scalar value
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果按下上箭头或下箭头，则使用太空船的方向和固定的推力标量值计算 thrust_vector
- en: ❹ Calls the move method for the spaceship to cause it to move
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 调用太空船的 move 方法使其移动
- en: Running the game now, you’ll see that objects start to be attracted by the black
    hole, and starting with zero velocity, the spaceship falls straight into it! Figure
    11.13 shows a time-lapse photo of the ship’s acceleration.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏后，你会看到物体开始被黑洞吸引，并且从零速度开始，太空船直接掉入其中！图 11.13 显示了飞船加速的延时照片。
- en: '![](../Images/CH11_F13_Orland.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH11_F13_Orland.png)'
- en: Figure 11.13 With no initial velocity, the spaceship falls into the black hole.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.13 在没有初始速度的情况下，太空船掉入黑洞。
- en: With any other starting velocity and no thrust, the ship begins to orbit the
    black hole, tracing out the shape of an ellipse, or stretched out circle (figure
    11.14).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何其他起始速度和没有推力的情况下，太空船开始围绕黑洞轨道运动，描绘出椭圆或拉长的圆形状（图 11.14）。
- en: '![](../Images/CH11_F14_Orland.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH11_F14_Orland.png)'
- en: Figure 11.14 With some initial velocity perpendicular to the black hole, the
    spaceship begins an elliptical orbit.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.14 在与黑洞垂直的初始速度下，太空船开始椭圆轨道运动。
- en: '![](../Images/CH11_F15_Orland.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH11_F15_Orland.png)'
- en: Figure 11.15 An asteroid in another elliptical orbit around our black hole
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.15 在我们的黑洞周围另一个椭圆轨道上的小行星
- en: It turns out that any object feeling no forces other than the gravity of the
    black hole either fall right in or enter into an elliptical orbit. Figure 11.15
    shows a randomly initialized asteroid along with the spaceship. You can see that
    its trajectory is a different ellipse.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，任何只感受到黑洞引力的物体要么直接掉入黑洞，要么进入椭圆轨道。图 11.15 显示了一个随机初始化的小行星和太空船。你可以看到它的轨迹是一个不同的椭圆。
- en: You can try adding all of the asteroids back in. You’ll see that with 11 simultaneously
    accelerating objects, the game has become much more interesting!
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试将所有的小行星重新添加进来。你会发现，随着 11 个同时加速的物体，游戏变得更有趣了！
- en: 11.3.2 Exercises
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.2 练习
- en: '| **Exercise 11.1**: Where do all of the vectors in the vector field (−2 −
    *x*, 4 − *y*) point? Plot the vector field to confirm your answer.**Solution**:
    This vector field is the same as the displacement vector (−2, 4) − (*x*, *y*),
    which is a vector pointing from a point (*x*, *y*) to (−2, 4). Therefore, we expect
    every vector in this vector field to point toward (−2, 4). Drawing this vector
    field confirms this.![](../Images/CH11_F15_Orland_UN01.png) |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| **练习 11.1**: 向量场 (−2 − *x*, 4 − *y*) 中的所有向量都指向哪里？绘制向量场以确认你的答案。**解答**: 这个向量场与位移向量
    (−2, 4) − (*x*, *y*) 相同，这是一个从点 (*x*, *y*) 指向 (−2, 4) 的向量。因此，我们预计这个向量场中的每个向量都指向
    (−2, 4)。绘制这个向量场可以确认这一点。![](../Images/CH11_F15_Orland_UN01.png) |'
- en: '| **Exercise 11.2-Mini Project**: Suppose we have *two* black holes, both having
    gravity 0.1, and positioned at (−3, 4) and (2, 1), respectively. The gravitational
    fields are **g** 1(*x*, *y*) = 0.1 · (−3 − *x*, 4 − *y*) and **g** 2(*x*, *y*)
    = 0.1 · (2 − *x*, 1 − *y*). Calculate a formula for the total gravitational field
    **g**(*x*, *y*) due to both black holes. Is it equivalent to a single black hole?
    If so, why?**Solution**: At every position (*x*, *y*), an object with mass *m*
    feels two gravitational forces: *m* · **g** 1(*x*, *y*) and *m* · **g** 2(*x*,
    *y*). The vector sum of these forces is *m*(**g** 1(*x*, *y*) + **g** 2(*x*, *y*)).
    Per unit of mass, the force felt will be **g** 1(*x*, *y*) + **g** 2(*x*, *y*),
    which confirms that the total gravitational field vector is the sum of the gravitational
    field vectors due to each of the black holes. This total gravitational field is*g*(*x*,
    *y*) = *g*[1](*x*, *y*) + *g*[2](*x*, *y*)            = 0.1 · (−3 − *x*, 4 − *y*)
    + 0.1 · (2 − *x*, 1 − *y*)We can divide out a factor of 2 and rewrite as*g*(*x*,
    *y*) = 0.1 · 2 · (0.5 − *x*, 2.5 − *y*)            = 0.2 · (0.5 − *x*, 2.5 − *y*)This
    is the same as a single black hole with gravity 0.2, positioned at (0.5, 2.5).
    |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| **练习11.2-迷你项目**：假设我们有两个黑洞，它们的引力均为0.1，分别位于（-3，4）和（2，1）。引力场分别为**g**1(*x*, *y*)
    = 0.1 · (−3 − *x*, 4 − *y*)和**g**2(*x*, *y*) = 0.1 · (2 − *x*, 1 − *y*)。计算由这两个黑洞产生的总引力场**g**(*x*,
    *y*)的公式。它是否等同于一个黑洞？如果是，为什么？**解答**：在每一个位置(*x*, *y*)，一个质量为*m*的物体感受到两个引力：*m* · **g**1(*x*,
    *y*)和*m* · **g**2(*x*, *y*)。这些力的矢量之和是*m*(**g**1(*x*, *y*) + **g**2(*x*, *y*))。按单位质量计算，感受到的力将是**g**1(*x*,
    *y*) + **g**2(*x*, *y*)，这证实了总引力场矢量是每个黑洞产生的引力场矢量的和。这个总引力场是*g*(*x*, *y*) = *g*[1](*x*,
    *y*) + *g*[2](*x*, *y*)            = 0.1 · (−3 − *x*, 4 − *y*) + 0.1 · (2 − *x*,
    1 − *y*)我们可以除以一个因子2，并重写为*g*(*x*, *y*) = 0.1 · 2 · (0.5 − *x*, 2.5 − *y*)      
         = 0.2 · (0.5 − *x*, 2.5 − *y*)这与一个位于(0.5, 2.5)且引力为0.2的单个黑洞相同。|'
- en: '| **Exercise 11.3-Mini Project**: In the asteroid game, add two black holes
    and allow these to feel each other’s gravity. Then move while these both also
    exert gravity on the asteroids and the spaceship.**Solution**: For a full implementation,
    see the source code. The key addition calls the `move` method for each black hole
    in each iteration of the game loop, passing it the list of all other black holes
    as sources of gravity:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习11.3-迷你项目**：在彗星游戏中，添加两个黑洞，并允许它们感受到彼此的引力。然后移动，同时这两个黑洞也对彗星和宇宙飞船施加引力。**解答**：为了完整实现，请参阅源代码。关键的增加是在游戏循环的每次迭代中调用每个黑洞的`move`方法，并传递给它所有其他黑洞作为引力源的黑名单：'
- en: '[PRE8]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '|'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 11.4 Introducing potential energy
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.4 引入势能
- en: Now that we’ve seen the behavior of the spaceship and asteroids in our gravitational
    field, we can build our second model of how they behave using *potential energy*.
    We already have black holes working in the asteroid game, so the purpose of the
    rest of the chapter is to broaden your perspective on the underlying math. Vector
    fields, including gravitational fields, often arise as results of the calculus
    operation called the gradient, which is a critical tool in the remaining chapters
    of the book.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了宇宙飞船和彗星在我们引力场中的行为，我们可以使用*势能*来构建它们行为的第二个模型。我们已经在彗星游戏中使用了黑洞，所以本章剩余部分的目的在于拓宽你对底层数学的视野。矢量场，包括引力场，通常作为微积分运算梯度（在本书的剩余章节中是一个关键工具）的结果出现。
- en: 'The basic idea is as follows: instead of picturing gravity as a force vector
    at every point, pulling objects toward a source, we can think of objects in a
    gravitational field like marbles rolling around in a bowl. The marbles may roll
    back and forth, but they are always “pulled” back toward the bottom of the bowl
    as they roll away. A potential energy function essentially defines the shape of
    this bowl. You can see a preview of what the bowl looks like in the center image
    of figure 11.16.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 基本思想如下：我们不是将重力想象成在每个点上的力矢量，将物体拉向源头，而是可以将处于引力场中的物体想象成在碗边滚动的弹珠。弹珠可能会来回滚动，但它们在滚动远离碗边时，总是会“被拉回”碗底。势能函数本质上定义了这个碗的形状。你可以在图11.16的中心图像中预览这个碗的形状。
- en: 'We’ll write potential energy as a function, taking a point (*x*, *y*) and returning
    a single number, representing the gravitational potential energy at the point
    (*x*, *y*). In terms of the bowl analogy, this is something like the height of
    the bowl at a given point. Once we implement a potential energy function in Python,
    we can visualize it in three ways: as a heatmap, which you saw at the beginning
    of this chapter; as a 3D graph; and as a contour map as shown in figure 11.16.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将势能写成函数的形式，它接受一个点(*x*, *y*)并返回一个单一的数值，代表该点的重力势能。从碗的类比来说，这就像是在某个特定点的碗的高度。一旦我们在Python中实现了势能函数，我们可以用三种方式来可视化它：作为热图，这是你在本章开头看到的；作为3D图表；以及如图11.16所示的等高线图。
- en: '![](../Images/CH11_F16_Orland.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH11_F16_Orland.png)'
- en: 'Figure 11.16 Three pictures of a scalar field: a heatmap, a graph, and a contour
    map'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.16 标量场的三个图像：热图、图表和等高线图
- en: These visualizations will help us picture potential energy functions in the
    final section of this chapter and in the remaining chapters of the book.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可视化将帮助我们想象本章最后部分以及本书剩余章节中的势能函数。
- en: 11.4.1 Defining a potential energy scalar field
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4.1 定义势能标量场
- en: Like a field, we can think of a scalar field as a function that takes (*x*,
    *y*) points as inputs. Instead of vectors, however, the outputs of this function
    are scalars. For instance, let’s work with the function *U*(*x*, *y*) = ½(*x*²
    + *y*²), which defines a scalar field. Figure 11.17 shows that you can plug in
    a 2D vector, and the output is some scalar determined by the formula for *U*(*x*,
    *y*).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 就像场一样，我们可以将标量场视为一个函数，它接受(*x*, *y*)点作为输入。然而，这个函数的输出是标量，而不是向量。例如，让我们考虑函数*U*(*x*,
    *y*) = ½(*x*² + *y*²)，它定义了一个标量场。图11.17显示，你可以插入一个二维向量，输出是由*U*(*x*, *y*)的公式确定的某个标量。
- en: '![](../Images/CH11_F17_Orland.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH11_F17_Orland.png)'
- en: Figure 11.17 As a function, a scalar field takes a point in the plane and produces
    a corresponding number. In this case, where (*x, y*) = (3, 1), the value of *U*(*x,
    y*) is ½ · (32 + 12) = 5.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.17 作为函数，标量场将平面上的一个点映射为一个相应的数值。在这种情况下，(*x, y*) = (3, 1)，*U*(*x, y*)的值为½ ·
    (32 + 12) = 5。
- en: The function *U*(*x*, *y*) turns out to be the potential energy function corresponding
    to the vector field **F**(*x*, *y*) = (−*x*, − *y*). I’ll need to do some more
    work to explain this mathematically, but we can confirm it qualitatively by picturing
    the scalar field *U*(*x*, *y*).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 函数*U*(*x*, *y*)实际上是与矢量场**F**(*x*, *y*) = (−*x*, − *y*)相对应的势能函数。我需要做一些额外的工作来从数学上解释这一点，但我们可以通过想象标量场*U*(*x*,
    *y*)来从定性上确认它。
- en: One way to picture *U*(*x*, *y*) is to draw a 3D plot like figure 11.18, where
    *U*(*x*, *y*) is a surface of (*x*, *y*, *z*) points and where *z* = *U*(*x*,
    *y*). For instance, *U*(3, 1) = 5, so we would plot a first point above the point
    (3, 1) in the x,y plane at a *z*-coordinate of 5.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 想象*U*(*x*, *y*)的一种方法是通过绘制一个类似于图11.18的3D图表，其中*U*(*x*, *y*)是(*x*, *y*, *z*)点的表面，其中*z*
    = *U*(*x*, *y*)。例如，*U*(3, 1) = 5，因此我们会在x,y平面上点(3, 1)的上方绘制一个z坐标为5的点。
- en: '![](../Images/CH11_F18_Orland.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH11_F18_Orland.png)'
- en: Figure 11.18 To plot one point of *U*(*x, y*) = ½(x2 + y2), use (*x, y*) = (3,
    1), then use *U*(3, 1) = 5 as the z-coordinate.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.18 要绘制*U*(*x, y*) = ½(x² + y²)的一个点，使用(*x, y*) = (3, 1)，然后使用*U*(3, 1) = 5作为z坐标。
- en: 'Plotting a point in 3D for every single value of (*x*, *y*) gives us a whole
    surface representing the scalar field *U*(*x*, *y*) and how it varies over the
    plane. In the source code, you’ll find a function, `plot_scalar_field`, that takes
    a function defining a scalar field, as well as *x* and *y* bounds, and draws the
    surface of 3D points representing the field:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个(*x*, *y*)的值绘制一个3D点，我们可以得到一个表示标量场*U*(*x*, *y*)及其在平面上变化的整个表面。在源代码中，你会找到一个名为`plot_scalar_field`的函数，它接受定义标量场的函数以及*x*和*y*的界限，并绘制代表该场的3D点表面：
- en: '[PRE9]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: While there are several ways to visualize a scalar field, I’ll refer to the
    graph of the function *U*(*x*, *y*) as shown in figure 11.19.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有几种方法可以可视化标量场，但我将参考图11.19中所示的*U*(*x*, *y*)函数的图表。
- en: '![](../Images/CH11_F19_Orland.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH11_F19_Orland.png)'
- en: Figure 11.19 A graph of the potential energy scalar field *U*(*x, y*) = ½(x2
    + y2)
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.19 势能标量场*U*(*x*, *y*) = ½(x² + y²)的图表
- en: This is the “bowl” from the previous analogy. It turns out this potential energy
    function gives the same model of gravity as the vector field **F**(*x*, *y*)=
    (−*x*, − *y*). We’ll see exactly why this is in section 11.5, but for now, we
    can confirm that the potential energy increases as the distance from the origin
    (0, 0) increases. In all radial directions, the height of the graph increases,
    meaning the value of *U* increases.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是之前类比中的“碗”。结果证明，这个势能函数给出的重力模型与矢量场 **F**(*x*, *y*)= (−*x*, − *y*) 相同。我们将在第11.5节中详细解释为什么是这样，但到目前为止，我们可以确认势能随着从原点（0,
    0）的距离增加而增加。在所有径向方向上，图形的高度增加，意味着 *U* 的值增加。
- en: 11.4.2 Plotting a scalar field as a heatmap
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4.2 将标量场绘制为热图
- en: Another way a scalar function is to draw a heatmap. Instead of using a *z*-coordinate
    to visualize the value of *U*(*x*, *y*), we can use a color scheme. This allows
    us to plot the scalar field without leaving 2D. By including a color legend on
    the side (as in figure 11.20), we can see the approximate scalar value at (*x*,
    *y*) from the color at that point on the plot.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种表示标量函数的方法是绘制热图。我们不是使用 *z* 坐标来可视化 *U*(*x*, *y*) 的值，而是可以使用颜色方案。这允许我们在二维空间内绘制标量场。通过在旁边包含一个颜色图例（如图11.20所示），我们可以从图上该点的颜色中看到
    (*x*, *y*) 处的大致标量值。
- en: '![](../Images/CH11_F20_Orland.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH11_F20_Orland.png)'
- en: Figure 11.20 A heatmap of the function *U*(*x, y*)
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.20 函数 *U*(*x, y*) 的热图
- en: In the center of the plot in figure 11.20, near (0, 0), the color is darker,
    meaning the values of *U*(*x*, *y*) are lower. Toward the edges, the color is
    lighter, meaning the values of *U*(*x*, *y*) are higher. You can plot the potential
    energy function using the `scalar_field_heatmap` function you’ll find in the source
    code.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在图11.20的中心，靠近 (0, 0) 的地方，颜色较暗，意味着 *U*(*x*, *y*) 的值较低。向边缘移动时，颜色较浅，意味着 *U*(*x*,
    *y*) 的值较高。你可以使用源代码中找到的 `scalar_field_heatmap` 函数来绘制势能函数。
- en: 11.4.3 Plotting a scalar field as a contour map
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4.3 将标量场绘制为等高线图
- en: Similar to a heatmap is a *contour map*. You may have seen a contour map before
    as the format of a topographical map, a map which shows the elevation of terrain
    over a geographical area. This kind of map consists of paths where the elevation
    is constant, so if you’re walking along the path shown in the map, you’re neither
    walking uphill nor downhill. Figure 11.21 shows the analogous contour map for
    *U*(*x*, *y*), showing paths in the *x*,*y* plane where *U*(*x*, *y*) is equal
    to 10, 20, 30, 40, 50, and 60.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 与热图类似的是 *等高线图*。你可能之前见过等高线图，它是地形图的格式，一种显示地理区域内地形高程的地图。这类地图由高程恒定的路径组成，所以如果你沿着地图上显示的路径行走，你既不上坡也不下坡。图11.21显示了
    *U*(*x*, *y*) 的类似等高线图，显示了 *x*,*y* 平面上的路径，其中 *U*(*x*, *y*) 等于10, 20, 30, 40, 50和60。
- en: '![](../Images/CH11_F21_Orland.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH11_F21_Orland.png)'
- en: Figure 11.21 A contour map of *U*(*x, y*), showing curves where the value of
    *U*(*x, y*) is constant
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.21 *U*(*x, y*) 的等高线图，显示了 *U*(*x, y*) 值恒定的曲线
- en: You can see that the curves are all circular and that they get closer together
    as they go outward. We can interpret this to mean that *U*(*x*, *y*) gets steeper
    as we get further from the origin. For instance, *U*(*x*, *y*) increases from
    30 to 40 over a shorter distance than it takes to increase from 10 to 20\. You
    can plot the scalar field *U* as a contour map using the `scalar_field_contour`
    function from the source code.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到曲线都是圆形的，并且随着向外延伸而彼此靠得更近。我们可以解释这一点意味着 *U*(*x*, *y*) 随着我们离原点越来越远而变得更加陡峭。例如，*U*(*x*,
    *y*) 在较短的距离上从30增加到40，而增加从10到20的距离更长。你可以使用源代码中的 `scalar_field_contour` 函数将标量场 *U*
    绘制为等高线图。
- en: 11.5 Connecting energy and forces with the gradient
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.5 使用梯度将能量和力联系起来
- en: This notion of *steepness* is important−the steepness of a potential energy
    function tells us how much energy an object has to exert to move in that direction.
    As you might expect, the exertion required to move in a given direction is a measure
    of the force *in the opposite direction*. In the remainder of this section, we’ll
    get to a precise and quantitative version of this statement.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个关于 *陡峭度* 的概念很重要——势能函数的陡峭度告诉我们物体在某个方向上移动需要施加多少能量。正如你所期望的，在给定方向上移动所需的努力是 *相反方向*
    力的量度。在本节的剩余部分，我们将得到这个陈述的精确和定量版本。
- en: As I mentioned in the introduction to this chapter, the gradient is an operation
    that takes a scalar field like potential energy and produces a vector field like
    a gravitational field. At every location (*x*, *y*) in the plane, the gradient
    vector field at that location points in the direction of fastest increase in the
    scalar field. In this section, I will show you how to take the gradient of a scalar
    field *U*(*x*, *y*), which requires taking a derivative of *U* with respect to
    *x* and, separately, taking a derivative with respect to *y*. We’ll be able to
    show that the gradient of the potential energy function *U*(*x*, *y*) we’ve been
    working with is -**F**(*x*, *y*), where **F**(*x*, *y*) is the gravitational field
    we implemented in our asteroid game. We’ll make extensive use of the gradient
    in the remaining chapters of this book.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在本章引言中提到的，梯度是一个操作，它将标量场（如势能）转换为向量场（如引力场）。在平面上每个位置(*x*, *y*)，该位置的梯度向量场指向标量场最快增加的方向。在本节中，我将向您展示如何取标量场*U*(x,
    *y*)的梯度，这需要分别对*U*关于*x*和*y*求导。我们将能够证明我们一直在使用的势能函数*U*(x, *y*)的梯度是-**F**(*x*, *y*)，其中**F**(*x*,
    *y*)是我们在我们的小行星游戏中实现的引力场。我们将在本书的剩余章节中广泛使用梯度。
- en: 11.5.1 Measuring steepness with cross sections
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.5.1 使用横截面测量陡度
- en: 'There’s one more way of visualizing the function *U*(*x*, *y*) that makes it
    easy to see how steep it is at various points. Let’s focus on a specific point:
    (*x*, *y*) = (−5, 2). On a contour map like that shown in figure 11.22, this point
    is between the *U* = 10 and *U* = 20 curves, and in fact, *U*(−5, 2) = 14.5\.
    If we move in the +*x* direction, we hit the *U* = 10 curve, meaning that *U*
    decreases in the +*x* direction. If we instead move in the +*y* direction, we
    hit the *U* = 20 curve, meaning that *U* increases in this direction.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种可视化函数*U*(x, *y*)的方法，可以让我们很容易地看到它在各个点的陡度。让我们关注一个特定的点：（*x*, *y*) = (-5, 2)。在一个像图11.22中显示的等高线图上，这个点位于*U*
    = 10和*U* = 20曲线之间，实际上，*U*(-5, 2) = 14.5。如果我们沿+*x*方向移动，我们会碰到*U* = 10曲线，这意味着*U*在+*x*方向上减小。如果我们相反地沿+*y*方向移动，我们会碰到*U*
    = 20曲线，这意味着*U*在这个方向上增加。
- en: '![](../Images/CH11_F22_Orland.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH11_F22_Orland.png)'
- en: Figure 11.22 Exploring the value of *U*(*x, y*) in the +x and +y directions
    from (−5, 2)
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.22 从（-5，2）在+x和+y方向上探索*U*(x, y)的值
- en: Figure 11.22 shows that the steepness of *U*(*x*, *y*) depends on the direction.
    We can picture this by plotting the cross sections of *U*(*x*, *y*), where *x*
    = −5 and *y* = 2\. *Cross sections* are slices of the graph of *U*(*x*, *y*) at
    fixed values of *x* or *y*. For example, figure 11.23 shows that the cross section
    of *U*(*x*, *y*) at *x* = −5 is a slice of *U*(*x*, *y*) in the plane *x* = −5.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.22显示，*U*(x, *y*)的陡度取决于方向。我们可以通过绘制*U*(x, *y*)的横截面来想象这一点，其中*x* = -5和*y* =
    2。*横截面*是*U*(x, *y*)在固定的*x*或*y*值处的图形切片。例如，图11.23显示，在*x* = -5时，*U*(x, *y*)的横截面是*x*
    = -5平面上*U*(x, *y*)的切片。
- en: '![](../Images/CH11_F23_Orland.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH11_F23_Orland.png)'
- en: Figure 11.23 The cross section of *U*(*x, y*) at *x* = −5
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.23 *U*(x, y)在*x* = -5处的横截面
- en: Using the functional programming terminology from chapter 4, we can partially
    apply *U* with *x* = −5 to get a function that accepts a single number *y* and
    returns the value of *U*. There’s also a cross section in the *y* direction at
    (5, 2). This is the cross section of *U*(*x*, *y*), where *y* = 2\. Figure 11.24
    shows its shape as a graph of *U*(*x*, *y*) after partially applying with *y*
    = 2.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用第4章中的函数式编程术语，我们可以将*x* = -5的*U*部分应用到一个函数上，该函数接受一个单独的数字*y*并返回*U*的值。在(5, 2)处也有一个*y*方向的横截面。这是*y*
    = 2的*U*(x, *y*)横截面。图11.24显示了使用*y* = 2部分应用后的*U*(x, *y*)的形状作为图形。
- en: '![](../Images/CH11_F24_Orland.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH11_F24_Orland.png)'
- en: Figure 11.24 The cross section of *U*(*x, y*) at y = 2
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.24 *U*(x, y)在y = 2处的横截面
- en: Together, these cross sections tell us how *U* is changing at (−5, 2) in both
    the *x* and *y* directions. The slope of *U*(*x*, 2) at *x* = −5 is negative,
    telling us that moving in the +*x* direction from (−5, 2) causes *U* to decrease.
    Likewise, the slope of *U*(−5, *y*) at *y* = 2 is positive, telling us that moving
    in the +*y* direction from (−5, 2) causes *U* to increase (figure 11.25).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这些横截面一起告诉我们，在（-5，2）处，*U*在*x*和*y*方向上的变化情况。在*x* = -5时，*U*(x, 2)的斜率为负，这告诉我们从（-5，2）沿+*x*方向移动会使*U*减小。同样，在*y*
    = 2时，*U*(−5, *y*)的斜率为正，这告诉我们从（-5，2）沿+*y*方向移动会使*U*增加（图11.25）。
- en: '![](../Images/CH11_F25_Orland.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH11_F25_Orland.png)'
- en: Figure 11.25 Cross sections show us that *U*(*x, y*) is increasing in the +y
    direction and decreasing in the +x direction.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.25横截面显示，*U*(*x, y*)在+y方向上增加，在+x方向上减少。
- en: We haven’t found the slope of the scalar field *U*(*x*, *y*) at this point,
    but we have found what we could call the slope in the *x* direction and the slope
    in the *y* direction. These values are called *partial derivatives* of *U*.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有找到标量场*U*(*x*, *y*)在这个点的斜率，但我们已经找到了可以称为*x*方向和*y*方向的斜率。这些值被称为*U*的*偏导数*。
- en: 11.5.2 Calculating partial derivatives
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.5.2 计算偏导数
- en: You already know everything you need to know to find the previous slopes. Both
    *U*(−5, *y*) and *U*(*x*, 2) are functions of one variable, so you could approximate
    their derivatives by calculating the slope of small secant lines.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道找到之前斜率所需的一切。*U*(−5, *y*)和*U*(*x*, 2)都是单变量函数，因此你可以通过计算小割线的斜率来近似它们的导数。
- en: 'For instance, if we want to find the partial derivative of *U*(*x*, *y*) with
    respect to *x* at the point (−5, 2), we’re asking for the slope of *U*(*x*, 2)
    at *x* = −5\. That is, we want to know how fast *U*(*x*, *y*) is changing in the
    *x* direction at the point (*x*, *y*) = (−5, 2). We could approximate this by
    plugging in a small value of Δ*x* into the following slope calculation:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想在点(−5, 2)处找到*U*(*x*, *y*)关于*x*的偏导数，我们是在询问*U*(*x*, 2)在*x* = −5处的斜率。也就是说，我们想知道*U*(*x*,
    *y*)在点(*x*, *y*) = (−5, 2)处*x*方向的改变速度。我们可以通过将一个小的Δ*x*值代入以下斜率计算来近似这个值：
- en: '![](../Images/CH11_F25_Orland_EQ06.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH11_F25_Orland_EQ06.png)'
- en: We can also calculate the derivative exactly by writing the formula for *U*(*x*,
    2). Because *U*(*x*, *y*) = ½(*x*² + *y*²), we have *U*(*x*, 2) = ½(*x*² + 2²)
    = ½(*x*² + 4) = 2 + (*x*²/2). Using the power rule for derivatives, the derivative
    of *U*(*x*, 2) with respect to *x* is 0 + 2*x*/2 = *x*. At *x* = −5, the derivative
    is −5.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过写出*U*(*x*, 2)的公式来精确计算导数。因为*U*(*x*, *y*) = ½(*x*² + *y*²)，所以*U*(*x*, 2)
    = ½(*x*² + 2²) = ½(*x*² + 4) = 2 + (*x*²/2)。使用导数的幂规则，*U*(*x*, 2)关于*x*的导数是0 + 2*x*/2
    = *x*。在*x* = −5时，导数是−5。
- en: Notice that in both the slope approximation and the symbolic derivative process,
    the variable *y* doesn’t appear. Instead, we’re working with the constant value
    2\. This is to be expected because when we’re thinking about a partial derivative
    in the *x* direction, *y* isn’t changing. The general way to calculate partial
    derivatives symbolically is to take the derivative as if only one symbol (like
    *x*) is a variable, while all the other symbols (like *y*) are constants.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在斜率近似和符号导数过程中，变量*y*都没有出现。相反，我们正在处理常数2。这是可以预料的，因为当我们考虑*x*方向的偏导数时，*y*并没有变化。计算偏导数的通用方法是，将导数视为只有一个符号（如*x*）是变量，而所有其他符号（如*y*）都是常数。
- en: 'Using this method, the partial derivative of *U*(*x*, *y*) with respect to
    *x* is ½(2*x* + 0) = *x*, and the partial derivative with respect to *y* is ½(0
    + 2*y*) = *y*. By the way, the notation *f*''(*x*) we previously preferred for
    the derivative of a function *f*(*x*) is insufficient to extend to partial derivatives.
    When taking partial derivatives, you can take the derivative with respect to different
    variables, and you need to specify which one you’re working with. There’s another
    equivalent notation for the derivative of *f*''(*x*):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，*U*(*x*, *y*)关于*x*的偏导数是½(2*x* + 0) = *x*，关于*y*的偏导数是½(0 + 2*y*) = *y*。顺便说一下，我们之前用于函数*f*(*x*)导数的记号*f*'(*x*)对于扩展到偏导数是不够的。在求偏导数时，你可以对不同的变量求导，并且需要指定你正在处理的是哪一个。对于*f*'(*x*)的导数，还有一个等效的记号：
- en: '![](../Images/CH11_F25_Orland_EQ07.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH11_F25_Orland_EQ07.png)'
- en: '(I use the ≡ sign to indicate that these notations are equivalent; they represent
    the same concept.) This is reminiscent of the slope formula Δ*f* /Δ*x*, but in
    this notation, *df* and *dx* instead represent *infinitesimal* changes in the
    value of *f* and *x*. The notation *df*/*dx* means the same thing as *f*''(*x*),
    but it makes it clearer that the derivative is taken with respect to *x*. For
    a partial derivative of a function like *U*(*x*, *y*), we can take the derivative
    with respect to either *x* or *y*. It’s traditional to use different shaped *d*
    ’s to indicate that we’re not taking an ordinary derivative (called a *total*
    derivative). The partial derivatives of *U* with respect to *x* and *y* are (respectivel*y*)
    written as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: （我使用≡符号来表示这些符号是等价的；它们代表相同的概念。）这让人联想到斜率公式Δf/Δx，但在这个符号中，df和dx代表的是f和x值的**无穷小**变化。df/dx表示的含义与f'(x)相同，但它使得导数是相对于x取的这一点更加清晰。对于一个像U(x,
    y)这样的函数的偏导数，我们可以相对于x或y取导数。传统上，使用不同形状的d来表示我们不是取一个普通导数（称为全导数）。U相对于x和y的偏导数（分别相对于y）可以写成以下形式：
- en: '![](../Images/CH11_F25_Orland_EQ08.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../Images/CH11_F25_Orland_EQ08.png)'
- en: 'Here’s another example with a function *q*(*x*, *y*) = *x* sin(*xy*) + *y*.
    If we treat *y* as a constant and take the derivative with respect to *x*, we
    need to use the product rule and the chain rule. The result is the partial derivative
    with respect to *x* :'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个函数q(x, y) = x sin(xy) + y的例子。如果我们把y看作常数并对x求导，我们需要使用乘积规则和链式规则。结果是相对于x的偏导数：
- en: '![](../Images/CH11_F25_Orland_EQ09.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../Images/CH11_F25_Orland_EQ09.png)'
- en: 'To take the partial derivative with respect to *y*, we treat *x* as a constant,
    and we need to use the chain rule and the sum rule:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要对y求偏导数，我们把x看作常数，并需要使用链式规则和加法规则：
- en: '![](../Images/CH11_F25_Orland_EQ10.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../Images/CH11_F25_Orland_EQ10.png)'
- en: It’s true that each of the partial derivatives only tells part of the story
    of how a function like *U*(*x*, *y*) changes at any point. Next, we combine them
    to gain a full understanding, analogous to the total derivative for a function
    of one variable.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，每个偏导数只讲述了函数像U(x, y)在任意一点如何变化的其中一部分故事。接下来，我们将它们结合起来，以获得全面的理解，类似于单变量函数的全导数。
- en: 11.5.3 Finding the steepness of a graph with the gradient
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.5.3 使用梯度找到图形的陡度
- en: Let’s zoom in on the point (−5, 2) on the graph of *U*(*x*, *y*) (figure 11.26).
    Just as any smooth function *f*(*x*) looks like a straight line on a sufficiently
    small range of *x* values, it turns out the graph of a smooth scalar field looks
    like a plane in a small enough vicinity of the x,y plane.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们放大U(x, y)图形上的点(−5, 2)（图11.26）。正如任何光滑函数f(x)在足够小的x值范围内看起来像一条直线一样，结果是一个光滑标量场的图形在x,y平面的足够小的邻域内看起来像是一个平面。
- en: '![](../Images/CH11_F26_Orland.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../Images/CH11_F26_Orland.png)'
- en: Figure 11.26 Up close, the region of the graph of *U*(*x, y*) near (*x, y*)
    = (−5, 2) looks like a plane.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.26 从近距离看，U(x, y)在(x, y) = (−5, 2)附近的图形区域看起来像一个平面。
- en: Just as the derivative *df*/*dx* tells us about the slope of the line that approximates
    *f*(*x*) at a given point, the partial derivatives *∂**U*/*∂**x* and *∂**U*/*∂**y*
    tell us about a plane that approximates *U*(*x*, *y*) at a given point. The dotted
    lines in figure 11.26 show the *x* and *y* cross sections of *U*(*x*, *y*) at
    this point. In this window, they are approximately straight lines, and their slopes
    in the *x*,*z* and *y*,*z* planes are close to the partial derivatives *∂**U*/*∂**x*
    and *∂**U*/*∂**y*.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 正如导数df/dx告诉我们关于在给定点近似f(x)的线的斜率一样，偏导数∂U/∂x和∂U/∂y告诉我们关于在给定点近似U(x, y)的平面的信息。图11.26中的虚线显示了U(x,
    y)在此点的x和y截面。在这个窗口中，它们近似为直线，它们在x,z和y,z平面上的斜率接近偏导数∂U/∂x和∂U/∂y。
- en: I haven’t proven it, but suppose there *is* a plane that best approximates *U*(*x*,
    *y*) near (−5, 2), and because we can’t distinguish it, we can pretend the graph
    in figure 11.26 is that plane for a moment. The partial derivatives tell us how
    much it is slanted in the *x* and *y* directions. On a plane, there are actually
    two better directions to think about. First of all, there’s a direction on the
    plane you could walk without gaining or losing elevation. In other words, this
    is the line in the plane that is parallel to the *x*,*y* plane. For the plane
    that approximates *U*(*x*, *y*) at (−5, 2), that turns out to be in the direction
    (2, 5) as shown by figure 11.27.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我还没有证明它，但假设存在一个最佳逼近于 *U*(*x*, *y*) 的平面，且该平面在 (−5, 2) 附近，因为我们无法区分它，我们可以暂时假设图
    11.26 中的图形就是那个平面。偏导数告诉我们它在 *x* 和 *y* 方向上的倾斜程度。在一个平面上，实际上有两个更好的方向可以考虑。首先，有一个方向在平面上你可以行走而不会升高或降低高度。换句话说，这就是平面上与
    *x*,*y* 平面平行的线。对于在 (−5, 2) 处逼近 *U*(*x*, *y*) 的平面，结果是在方向 (2, 5) 上，如图 11.27 所示。
- en: '![](../Images/CH11_F27_Orland.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH11_F27_Orland.png)'
- en: Figure 11.27 Walking along the graph of *U*(*x, y*) from (*x, y*) = (−5,2) in
    the direction of (2,5), you won’t gain or lose elevation.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.27 从 (*x, y*) = (−5,2) 沿着 *U*(*x, y*) 的图形在方向 (2,5) 上行走，你不会升高或降低高度。
- en: The walker in figure 11.27 is having an easy time because they’re not climbing
    or descending the plane when walking in this direction. If, however, the walker
    turns 90° to the left, they would be walking uphill in the steepest direction
    possible. That is the direction (−5, 2), which is perpendicular to (2, 5).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.27 中的行进者行走起来很轻松，因为他们在这个方向上行走时不会爬升或下降平面。然而，如果行进者向左转 90°，他们就会在可能的最陡方向上上山。这就是方向
    (−5, 2)，它与 (2, 5) 垂直。
- en: 'This direction of steepest ascent happens to be a vector whose components are
    the partial derivatives of *U* at a given point. I gave one illustration of this
    instead of proving it, but this fact is true in general. For a function *U*(*x*,
    *y*), the vector of its partial derivatives is called its *gradient* and written
    ∇*U*. It gives the magnitude and direction of steepest ascent of *U* at a given
    point:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最陡上升的方向恰好是一个向量，其分量是 *U* 在给定点的偏导数。我给出了一幅示意图而不是证明，但这个事实在一般情况下是正确的。对于函数 *U*(*x*,
    *y*)，其偏导数的向量被称为其 *梯度*，表示为 ∇*U*。它给出了 *U* 在给定点的最陡上升的幅度和方向：
- en: '![](../Images/CH11_F27_Orland_EQ11.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH11_F27_Orland_EQ11.png)'
- en: Because we have formulas for the partial derivatives, we can tell, for instance,
    that ∇*U*(*x*, *y*) = (*x*, *y*) for our function. The function ∇*U*, which is
    the gradient of *U*, is an assignment of a vector to every point in the plane,
    so it is indeed a vector field! The plot of ∇*U* shows us at every point (*x*,
    *y*) which direction is uphill on the graph of *U*(*x*, *y*), as well as how steep
    it is (figure 11.28).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有偏导数的公式，我们可以知道，例如，对于我们的函数，∇*U*(*x*, *y*) = (*x*, *y*)。函数 ∇*U*，即 *U* 的梯度，是将一个向量分配给平面上每一个点，因此它确实是一个向量场！∇*U*
    的图示告诉我们，在每一个点 (*x*, *y*) 上，*U*(*x*, *y*) 的图形上哪个方向是上坡，以及它有多陡（图 11.28）。
- en: '![](../Images/CH11_F28_Orland.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH11_F28_Orland.png)'
- en: Figure 11.28 The gradient ∇U is a vector field telling us the magnitude and
    direction of steepest ascent on the graph of U at any point (*x, y*).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.28 梯度 ∇U 是一个向量场，它告诉我们 U 在任何点 (*x, y*) 的图形上最陡上升的幅度和方向。
- en: The gradient is a way of connecting a scalar field with a vector field. It turns
    out that this gives the connection between potential energy and force.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 梯度是连接标量场和向量场的一种方式。结果，这给出了势能与力之间的联系。
- en: 11.5.4 Calculating force fields from potential energy with the gradient
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.5.4 使用梯度从势能计算力场
- en: The gradient is the best analogy of the ordinary derivative for scalar fields.
    It has all the information needed to find the direction of steepest ascent of
    the scalar field, the slope along the *x* or *y* directions, or the plane of best
    approximation. But from the perspective of physics, the direction of steepest
    ascent is not what we’re looking for. After all, there’s no object in nature that
    spontaneously moves uphill.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 梯度是标量场的普通导数的最佳类比。它包含了找到标量场最陡上升方向、沿 *x* 或 *y* 方向的斜率，或最佳逼近平面的所有必要信息。但从物理学的角度来看，最陡上升的方向并不是我们寻找的。毕竟，自然界中没有物体会自发向上移动。
- en: Neither the spaceship in the asteroid game nor the ball rolling around in the
    bowl would feel forces that impel them toward regions of higher potential energy.
    As we’ve discussed, they would need to apply a force or sacrifice some kinetic
    energy to gain more potential energy. For that reason, the right description of
    the force an object feels is the *negative* gradient of potential energy, which
    points in the direction of steepest *descent* rather than steepest *ascent*. If
    *U*(*x*, *y*) represents the scalar field of potential energy, then the associated
    force field **F**(*x*, *y*) can be calculated by
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在小行星游戏中的太空船和在碗边滚动的球都不会感受到推动它们向势能更高的区域移动的力。正如我们之前讨论的，它们需要施加力或牺牲一些动能来获得更多的势能。因此，描述物体感受到的力的正确方式是势能的*负梯度*，它指向最陡的*下降*方向，而不是最陡的*上升*方向。如果
    *U*(*x*, *y*) 代表势能的标量场，那么相关的力场 **F**(*x*, *y*) 可以通过以下方式计算：
- en: '***F***(*x, y*) = −∇*U*(*x, y*)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '***F***(*x, y*) = −∇*U*(*x, y*)'
- en: Let’s try a fresh example. What kind of force field would be produced by the
    following potential energy function?
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一个新例子。以下势能函数会产生什么样的力场？
- en: '*V*(*x, y*) = 1 + *y*² − 2*x*² + *x*⁶'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '*V*(*x, y*) = 1 + *y*² − 2*x*² + *x*⁶'
- en: We can get a sense for how this function behaves by plotting it.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 通过绘制这个函数，我们可以对其行为有一个大致的了解。
- en: '![](../Images/CH11_F29_Orland.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH11_F29_Orland.png)'
- en: Figure 11.29 The potential energy function V(*x, y*) shown in 3D
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.29 3D 显示的势能函数 V(*x, y*)
- en: 'Figure 11.29 illustrates that this potential energy function has a double bowl
    shape with two minimum points and a hump between them. What does the force field
    associated with this potential energy function look like? To find out, we need
    to take the negative gradient of *V* :'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.29 说明这个势能函数具有双碗形状，有两个最小值点，它们之间有一个驼峰。与这个势能函数相关的力场看起来是什么样子？为了找出答案，我们需要计算
    *V* 的负梯度：
- en: '![](../Images/CH11_F29_Orland_EQ14.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH11_F29_Orland_EQ14.png)'
- en: We can get the partial derivative of *V* with respect to *x* by treating *y*
    like a constant, so the terms 1 and *y*² don’t contribute. The result is just
    the derivative of −2*x*² + *x*⁶ with respect to *x*, which is −4*x* + 6*x*⁵.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将 *y* 视为一个常数来得到 *V* 对 *x* 的偏导数，因此项 1 和 *y*² 不贡献于结果。结果是 -2*x*² + *x*⁶ 对
    *x* 的导数，即 -4*x* + 6*x*⁵。
- en: For the partial derivative of *V* with respect to *y*, we treat *x* like a constant,
    so the only term that contributes to the result is *y*² having a derivative 2*y*.
    The negative gradient of *V*(*x*, *y*) is therefore
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 *V* 对 *y* 的偏导数，我们将 *x* 视为一个常数，因此只有 *y*² 有导数 2*y* 贡献于结果。因此，*V*(*x*, *y*) 的负梯度是
- en: '*F*(*x, y*) = −∇*V*(*x, y*) = (4*x* − 6*x*⁵, −2*y*)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '*F*(*x, y*) = −∇*V*(*x, y*) = (4*x* − 6*x*⁵, −2*y*)'
- en: Plotting this vector field, figure 11.30 shows that the force field points toward
    the points of lowest potential energy. An object feeling this force field would
    experience these two points as exerting an attractive force.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 通过绘制这个矢量场，图 11.30 显示力场指向势能最低的点。感受到这个力场的物体会将这些点视为施加吸引力的点。
- en: '![](../Images/CH11_F30_Orland.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH11_F30_Orland.png)'
- en: Figure 11.30 A plot of the vector field -∇V(*x, y*), the force field associated
    with the potential energy function V(*x, y*). This is an attractive force toward
    the two points shown.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.30 是矢量场 -∇V(*x, y*) 的图，这是与势能函数 V(*x, y*) 相关的力场。这是一种指向图中所示两点的吸引力的力。
- en: The negative gradient of potential energy is the direction nature prefers; it
    is the direction to release stored energy. Objects are naturally pushed toward
    states where their potential energy is minimized. The gradient is an important
    tool for finding optimum values of scalar fields, as we’ll see in the next chapters.
    Specifically, in the last part of this book, I’ll show you how following the negative
    gradient in search of an optimal value mimics the process of “learning” in certain
    machine learning algorithms.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 势能的负梯度是自然界偏好的方向；它是释放储存能量的方向。物体自然地被推向使它们的势能最小化的状态。梯度是寻找标量场最优值的重要工具，我们将在下一章中看到。具体来说，在这本书的最后一部分，我将向你展示如何通过跟随负梯度寻找最优值来模拟某些机器学习算法中的“学习”过程。
- en: 11.5.5 Exercises
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.5.5 练习题
- en: '| **Exercise 11.4**: Plot the cross section of *h*(*x*, *y*) = *ey* sin(*x*),
    where *y* = 1\. Then plot the cross section of *h*(*x*, *y*), where *x* = *π*/6.**Solution**:
    The cross section of *h*(*x*, *y*) where *y* = 1 is a function of only *x* : *h*(*x*,
    1) = *e*¹ sin(*x*) = *e* · sin(*x*) as shown here:![](../Images/CH11_F30_Orland_UN02.png)Where
    *x* = *π*/6, the value of *h*(*x*, *y*) depends only on *y*. That is, *h*(*π*/6,
    *y*) = *ey* sin(*π*/6) = *ey*/2\. The graph is![](../Images/CH11_F30_Orland_UN03.png)
    |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| **练习 11.4**: 绘制函数 *h*(*x*, *y*) = *ey* sin(*x*) 在 *y* = 1 时的横截面。然后绘制 *h*(*x*,
    *y*) 在 *x* = *π*/6 时的横截面。**解答**：当 *y* = 1 时，*h*(*x*, *y*) 的横截面仅是 *x* 的函数：*h*(*x*,
    1) = *e*¹ sin(*x*) = *e* · sin(*x*)，如图所示：![](../Images/CH11_F30_Orland_UN02.png)。当
    *x* = *π*/6 时，*h*(*x*, *y*) 的值仅取决于 *y*。也就是说，*h*(*π*/6, *y*) = *ey* sin(*π*/6)
    = *ey*/2。图形如下所示：![](../Images/CH11_F30_Orland_UN03.png) |'
- en: '| **Exercise 11.5**: What are the partial derivatives of the function *h*(*x*,
    *y*) from the first exercise? What is the gradient? What is the value of the gradient
    at (*x*, *y*) = (*π*/6, 1)?**Solution**: The partial derivative of *ey* sin(*x*)
    with respect to *x* is obtained by treating *y* as a constant. *ey* is therefore
    treated as a constant as well. The result is![](../Images/CH11_F30_Orland_UN03_EQ16.png)Likewise,
    we get the partial derivative with respect to *y* by treating *x* and, therefore,
    sin(*x*) as constants:![](../Images/CH11_F30_Orland_UN03_EQ17.png)The gradient
    ∇*h*(*x*, *y*) is the vector field whose components are the partial derivatives:![](../Images/CH11_F30_Orland_UN03_EQ18.png)At
    (*x*, *y*) = (*π*/6, 1), this vector field evaluates as follows:![](../Images/CH11_F30_Orland_UN03_EQ19.png)
    |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| **练习 11.5**: 第一个练习中的函数 *h*(*x*, *y*) 的偏导数是什么？梯度是什么？梯度在 (*x*, *y*) = (*π*/6,
    1) 处的值是多少？**解答**：求 *ey* sin(*x*) 关于 *x* 的偏导数时，将 *y* 视为常数。因此，*ey* 也被视为常数。结果是！[](../Images/CH11_F30_Orland_UN03_EQ16.png)。同样，通过将
    *x* 和 sin(*x*) 视为常数，我们得到关于 *y* 的偏导数：![](../Images/CH11_F30_Orland_UN03_EQ17.png)。梯度
    ∇*h*(*x*, *y*) 是一个向量场，其分量是偏导数：![](../Images/CH11_F30_Orland_UN03_EQ18.png)。在 (*x*,
    *y*) = (*π*/6, 1) 处，这个向量场评估如下：![](../Images/CH11_F30_Orland_UN03_EQ19.png)。 |'
- en: '| **Exercise 11.6**: Prove (−5, 2) is perpendicular to (2, 5).**Solution**:
    This is a review from chapter 2\. These two vectors are perpendicular because
    their dot product is zero: (−5, 2) · (2, 5) = −10 + 10 = 0. |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| **练习 11.6**: 证明点 (−5, 2) 与点 (2, 5) 垂直。**解答**：这是对第 2 章内容的复习。这两个向量是垂直的，因为它们的点积为零：(−5,
    2) · (2, 5) = −10 + 10 = 0。 |'
- en: '| **Exercise 11.7-Mini Project**: Let *z* = *p*(*x*, *y*) be the equation of
    the plane that best approximates *U*(*x*, *y*) at (−5, 2). Figure out (from scratch!)
    an equation for *p*(*x*, *y*) and the line contained in *p* and passing through
    (−5, 2), which is parallel to the *x*, *y* plane. This line should be parallel
    to the vector (2, 5, 0) as I claimed in the previous exercise.**Solution**: Remember
    that the formula for *U*(*x*, *y*) is ½(*x*² + *y*²). The value of *U*(−5, 2)
    is 14.5, so the point (*x*, *y*, *z*) = (−5, 2, 14.5) is on the graph of *U*(*x*,
    *y*) in 3D.Before we think about the formula for the plane of best approximation
    for *U*(*x*, *y*), let’s review how we got the line of best approximation for
    a function *f*(*x*). The line that best approximates a function *f*(*x*) at a
    point *x*[0] is the line that passes through the point (*x*[0], *f*(*x*[0])) and
    has a slope *f*''(*x*[0]). Those two facts ensure that both the value and the
    derivative of *f*(*x*) agree with the line that approximates it.Following this
    model, let’s look for the plane *p*(*x*, *y*), whose value and *both* partial
    derivatives match at (*x*, *y*) = (−5, 2). That means we must have *p*(−5, 2)
    = 14.5, while *∂**p*/*∂**x* = −5 and *∂**p*/*∂**y* = 2\. As a plane, *p*(*x*,
    *y*) has the form *p*(*x*, *y*) = *ax* + *by* + *c* for some numbers *a* and *b*(do
    you remember why?). The partial derivatives are![](../Images/CH11_F30_Orland_UN03_EQ20.png)To
    make them match, the formula must be *p*(*x*, *y*) = −5*x* + 2*y* + *c*, and to
    satisfy *p*(−5, 2) = 14.5, it must be that *c* = −14.5\. Therefore, the formula
    for the plane of best approximation is *p*(*x*, *y*) = −5*x* + 2*y* − 14.5.Now,
    let’s look for the line in the plane *p*(*x*, *y*) passing through (−5, 2), which
    is parallel to the *x*,*y* plane. This is the set of points (*x*, *y*) such that
    *p*(*x*, *y*) = *p*(−5, 2), meaning that there is no elevation change between
    (−5, 2) and (*x*, *y*).If *p*(*x*, *y*) = *p*(−5, 2), then −5*x* + 2*y* − 14.5
    = −5 · −5 + 2 · 2 − 14.5\. That simplifies to the equation of a line: −5*x* +
    2*y* = 29\. This line is equivalent to the set of vectors (−5, 2, 14.5) + *r*
    · (2, 5, 0), where *r* is a real number, so it is indeed parallel to (2, 5, 0).
    |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| **练习11.7-迷你项目**：设 *z* = *p*(*x*, *y*) 为在 (−5, 2) 处最佳逼近 *U*(*x*, *y*) 的平面方程。从零开始！找出
    *p*(*x*, *y*) 的一个方程以及包含在 *p* 中并通过 (−5, 2) 的直线，该直线平行于 *x*, *y* 平面。这条直线应该与我在上一个练习中提到的向量
    (2, 5, 0) 平行。**解答**：记住 *U*(*x*, *y*) 的公式是 ½(*x*² + *y*²)。*U*(−5, 2) 的值是 14.5，所以点
    (*x*, *y*, *z*) = (−5, 2, 14.5) 在 3D 中 *U*(*x*, *y*) 的图像上。在我们考虑 *U*(*x*, *y*)
    的最佳逼近平面方程之前，让我们回顾一下我们是如何得到函数 *f*(*x*) 的最佳逼近线的。在点 *x*[0] 处最佳逼近函数 *f*(*x*) 的线是通过点
    (*x*[0], *f*(*x*[0])) 并具有斜率 *f*''(*x*[0]) 的线。这两个事实确保了 *f*(*x*) 的值和导数与逼近它的线相一致。遵循这个模型，让我们寻找平面
    *p*(*x*, *y*)，其值和 *x*, *y* 在 (*x*, *y*) = (−5, 2) 处的偏导数都匹配。这意味着我们必须有 *p*(−5, 2)
    = 14.5，同时 *∂**p**/*∂**x* = −5 和 *∂**p**/*∂**y* = 2。作为一个平面，*p*(*x*, *y*) 的形式是 *p*(*x*,
    *y*) = *ax* + *by* + *c*，其中 *a* 和 *b* 是一些数字（你记得为什么吗？）。偏导数是![图片](../Images/CH11_F30_Orland_UN03_EQ20.png)。为了使它们匹配，公式必须是
    *p*(*x*, *y*) = −5*x* + 2*y* + *c*，为了满足 *p*(−5, 2) = 14.5，必须满足 *c* = −14.5。因此，最佳逼近平面的公式是
    *p*(*x*, *y*) = −5*x* + 2*y* − 14.5。现在，让我们寻找平面 *p*(*x*, *y*) 中通过 (−5, 2) 且平行于
    *x*, *y* 平面的直线。这是满足 *p*(*x*, *y*) = *p*(−5, 2) 的点集 (*x*, *y*)，这意味着在 (−5, 2) 和
    (*x*, *y*) 之间没有高度变化。如果 *p*(*x*, *y*) = *p*(−5, 2)，那么 −5*x* + 2*y* − 14.5 = −5
    · −5 + 2 · 2 − 14.5。这简化为一条直线的方程：−5*x* + 2*y* = 29。这条直线等价于向量集 (−5, 2, 14.5) + *r*
    · (2, 5, 0)，其中 *r* 是一个实数，因此它确实平行于 (2, 5, 0)。|'
- en: Summary
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: A vector field is a function that takes a vector both as input and output. Specifically,
    we picture it as an assignment of an arrow vector to every point in a space.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量场是一个函数，它既接受向量作为输入，也接受向量作为输出。具体来说，我们将其想象为将箭头向量分配到空间中的每一个点。
- en: Gravitational force can be modeled by a vector field. The value of the vector
    field at any point in space tells you how strong and in what direction an object
    is pulled by the force of gravity.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重力可以通过向量场来模拟。向量场在空间中任何一点的值告诉你物体受到重力作用的大小和方向。
- en: To simulate the motion of an object in a vector field, you need to use its position
    to calculate the strength and direction of the force field where it is. In turn,
    the value of the force field tells you the force on the object, and Newton’s second
    law tells you the resulting acceleration.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要模拟物体在向量场中的运动，你需要使用它的位置来计算它所在位置的力场的强度和方向。反过来，力场的值告诉你物体受到的力，而牛顿第二定律告诉你由此产生的加速度。
- en: '*Potential energy* is stored energy that has the potential to create motion.
    The potential energy for an object in a force field is determined by where the
    object is.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*势能*是储存的能量，具有产生运动的可能性。一个物体在力场中的势能取决于物体的位置。'
- en: 'Potential energy can be modeled as a scalar field: an assignment of a number
    to every point in space, which is the amount of potential energy an object would
    have at that point.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 势能可以被建模为一个标量场：为空间中的每一个点分配一个数值，这个数值代表物体在该点的势能。
- en: 'There are several ways to picture a scalar field in 2D: as a 3D surface, a
    heatmap, a contour map, or a pair of cross-section graphs.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有几种方式可以在二维中想象标量场：作为一个三维表面，一个热图，一个等高线图，或者一对横截面图。
- en: The partial derivatives of a scalar field give the rate of change in the value
    of the field with respect to the coordinates. For instance, if *U*(*x*, *y*) is
    a scalar field in 2D, there are partial derivatives with respect to *x* and *y*.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标量场的偏导数给出了场值相对于坐标的变化率。例如，如果 *U*(*x*, *y*) 是二维中的标量场，那么存在关于 *x* 和 *y* 的偏导数。
- en: Partial derivatives are the same as the derivatives of a cross section of the
    scalar field. You can calculate the partial derivative with respect to one variable
    by treating the other variables as constants.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 偏导数与标量场的横截面导数相同。你可以通过将其他变量视为常数来计算关于一个变量的偏导数。
- en: The gradient of a scalar field *U* is a vector whose components are partial
    derivatives of *U* with respect to each of the coordinates. The gradient points
    in the direction of steepest ascent for *U* or the direction in which *U* increases
    most rapidly.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标量场 *U* 的梯度是一个矢量，其分量是 *U* 对每个坐标的偏导数。梯度指向 *U* 最陡上升的方向，或者 *U* 增加最快的方向。
- en: The negative gradient of a potential energy function corresponding to a force
    field tells us the vector value of the force field at that point. This means that
    objects are pushed towards regions of lower potential energy.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与力场对应的势能函数的负梯度告诉我们该点的力场矢量值。这意味着物体会被推向势能较低的区域。
