- en: Chapter 1\. An introduction to microservices
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第1章。微服务简介
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Why move toward a new microservice architecture?
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么要转向新的微服务架构？
- en: What microservices are today, and where the future may lead
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 今天微服务是什么，以及未来可能的发展方向
- en: The basic component makeup of a microservice
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务的基本组件构成
- en: Testing strategies
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试策略
- en: Traditional monolithic applications are deployed as a single package, usually
    as a web or enterprise-archive file (WAR or EAR). They contain all the business
    logic required to complete multiple tasks, often alongside the components required
    to render the *user interface* (UI, or GUI for *graphical user interface*). When
    scaling, this usually means taking a complete copy of that entire application
    archive onto a new server node (basically, deploying it to another server node
    in a cluster). It doesn’t matter where the load or bottleneck is occurring; even
    if it’s only in a small cross section of the application, scaling this way is
    an all-or-nothing approach. Microservices are specifically designed to target
    and change this all-or-nothing aspect by allowing you to break your business logic
    into smaller, more manageable elements that can be employed in multiple ways.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的单体应用程序通常作为一个单一包部署，通常是一个Web或企业存档文件（WAR或EAR）。它们包含完成多个任务所需的所有业务逻辑，通常还包含渲染*用户界面*（UI，或GUI，即*图形用户界面*）所需的组件。在扩展时，这通常意味着将整个应用程序存档的完整副本复制到新的服务器节点上（基本上，将其部署到集群中的另一个服务器节点）。无论负载或瓶颈发生在哪里；即使它只出现在应用程序的一个小部分，这种扩展方式都是一种全有或全无的方法。微服务专门设计用来针对和改变这种全有或全无的方面，通过允许您将业务逻辑分解成更小、更易于管理的元素，这些元素可以用多种方式使用。
- en: This book isn’t intended to be a tutorial on the varied microservice architectures
    that are available today; we’ll assume you have some understanding of the subject.
    Rather, we’re going to help you overcome the challenges involved in *testing*
    the common features that all microservice applications share. In order to do that,
    in this chapter we’ll establish some common ground about what a microservice is,
    so that you can relate to where we’re coming from when we discuss these topics
    in later chapters.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的目的不是介绍今天可用的各种微服务架构；我们假设您对这一主题有一些了解。相反，我们将帮助您克服测试所有微服务应用程序共享的常见功能所涉及到的挑战。为了做到这一点，在本章中，我们将确立一些关于微服务是什么的共识，这样您就可以在后面的章节中讨论这些话题时，了解我们的出发点。
- en: Shifting toward the ever-more-popular microservice architecture means you need
    to adopt new strategies in development, testing, and restructuring/refactoring
    and move away from some of the purely monolithic-application practices.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 转向越来越受欢迎的微服务架构意味着您需要在开发、测试、重构/重构和重构方面采用新的策略，并远离一些纯粹的单体应用程序实践。
- en: Microservices offer you the advantage of being able to scale individual services,
    and the ability to develop and maintain multiple services in parallel using several
    teams, but they still require a robust approach when it comes to testing.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务为您提供能够扩展单个服务的优势，以及能够使用多个团队并行开发和维护多个服务的能力，但它们在测试方面仍然需要一种稳健的方法。
- en: In this book, we’ll discuss various approaches for using this new, more focused
    way of delivering tightly packaged “micro” services and how to resolve the complex
    testing scenarios that are required to maintain stability across multiple teams.
    Later chapters will introduce an example application and how to develop testing
    strategies for it; this will help you better understand how to create your own
    test environments.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将讨论使用这种新的、更专注的方式来交付紧密打包的“微”服务的各种方法，以及如何解决维护多个团队稳定性的复杂测试场景。后面的章节将介绍一个示例应用程序及其测试策略的开发；这将帮助您更好地理解如何创建自己的测试环境。
- en: You’ll see and use many features of the Arquillian test framework, which was
    specifically designed to tackle many of the common testing challenges you’ll face.
    An array of mature extensions have been developed over the years, and although
    other tools are available, Arquillian is our tool of choice—so expect some bias.
    That said, Arquillian also provides close integration with many testing tools
    you may already be familiar with.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到并使用Arquillian测试框架的许多功能，该框架专门设计用来解决您将面临的大多数常见测试挑战。多年来已经开发了一系列成熟的扩展，尽管其他工具也可用，但Arquillian是我们的首选工具——因此请期待一些偏见。话虽如此，Arquillian还提供了与您可能已经熟悉的许多测试工具的紧密集成。
- en: '|  |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**A note about software versions**'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于软件版本的一个注意事项**'
- en: This book uses many different software packages and tools, all of which change
    periodically. We tried throughout the book to present examples and techniques
    that wouldn’t be greatly affected by these changes. All examples require Java
    8, although when we finished the book, Java 10 had been released. We haven’t updated
    the examples because in terms of testing microservices, the release doesn’t add
    anything new. Something similar is true for JUnit 5\. All of the examples are
    written using JUnit 4.12, because when we started writing the book, JUnit 5 wasn’t
    yet in development. At the time we finished the book, not all of the frameworks
    explained here have official support for JUnit 5, so we decided to skip updating
    the JUnit version. Other libraries, such as Spring Boot and Docker (Compose),
    have evolved as well during the development of the book, but none of these changes
    have a significant impact on how to write tests.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本书使用了许多不同的软件包和工具，这些工具都会定期更新。我们试图在整本书中展示不会因这些变化而受到很大影响的示例和技术。所有示例都需要 Java 8，尽管当我们完成这本书时，Java
    10 已经发布。我们没有更新示例，因为在测试微服务方面，这个版本并没有增加任何新功能。对于 JUnit 5 也是如此。所有示例都是使用 JUnit 4.12
    编写的，因为当我们开始写这本书时，JUnit 5 还没有开发出来。在我们完成这本书的时候，这里解释的所有框架还没有官方支持 JUnit 5，所以我们决定跳过更新
    JUnit 版本。其他库，如 Spring Boot 和 Docker (Compose)，在本书的开发过程中也发生了演变，但这些变化对编写测试的方式没有重大影响。
- en: '|  |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 1.1\. What are microservices, and why use them?
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1\. 什么是微服务，为什么使用它们？
- en: 'In this section, we present what we believe is a reasonably good interpretation
    of the currently available answers to these questions. What you learn will provide
    a solid basis for understanding the microservice architecture, but expect innovation
    over time. We won’t make any predictions: as stated, our principle focus for the
    book is testing microservices, which is unlikely to change in any significant
    way.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们展示了我们认为目前对这些问题的现有答案的合理解释。你所学的知识将为理解微服务架构提供一个坚实的基础，但请期待随着时间的推移会有创新。我们不会做出任何预测：正如所述，本书的主要关注点是测试微服务，这不太可能发生任何重大变化。
- en: It isn’t important that you fully understand the microservice architecture at
    this point. But if, after reading this chapter, the term *microservice* is still
    a dark void for you, we encourage you to gather more information from your own
    sources.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你完全理解微服务架构并不重要。但如果阅读完这一章后，“微服务”这个术语对你来说仍然是一个模糊的概念，我们鼓励你从自己的渠道获取更多信息。
- en: '|  |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-20
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: You may find it useful to join the open discussions at MicroProfile ([http://microprofile.io](http://microprofile.io)).
    This is an initiative by the likes of IBM, London Java Community (LJC), RedHat,
    Tomitribe, Payara, and Hazelcast to develop a shared definition of Enterprise
    Java for microservices, with the goal of standardization.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会发现加入 MicroProfile（[http://microprofile.io](http://microprofile.io)）的公开讨论很有用。这是由
    IBM、伦敦 Java 社区（LJC）、RedHat、Tomitribe、Payara 和 Hazelcast 等公司发起的一项倡议，旨在为微服务开发一个共享的企业
    Java 定义，目标是标准化。
- en: '|  |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 1.1.1\. Why use microservices?
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.1\. 为什么使用微服务？
- en: Before we delve into the nature of microservices, let’s answer the “why” question.
    Until recently, it’s been commonplace to develop monolithic applications, and
    that’s still perfectly acceptable for any application that doesn’t require scaling.
    The problem with scaling any kind of monolithic application is straightforward,
    as shown in [figure 1.1](kindle_split_010_split_001.xhtml#ch01fig01). Microservices
    aren’t here to tell you that everything else is bad; rather, they offer an architecture
    that is far more resilient than a monolith to changes in the future.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨微服务的本质之前，让我们先回答“为什么”这个问题。直到最近，开发单体应用是很常见的，对于不需要扩展的应用来说，这仍然完全可接受。扩展任何类型单体应用的问题很简单，如图
    1.1[所示](kindle_split_010_split_001.xhtml#ch01fig01)。微服务并不是要告诉你其他一切都是不好的；相反，它们提供了一个比单体更具有未来变化适应性的架构。
- en: Figure 1.1\. Scaling a monolithic application
  id: totrans-25
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.1\. 扩展单体应用
- en: '![](Images/01fig01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片 01fig01](Images/01fig01.jpg)'
- en: Microservices enable you to isolate and scale smaller pieces of your application,
    rather than the *entire* application. Imagine that you’ve extracted some core
    business logic in your application to services A and B. Let’s say service A provides
    access to an inventory of items, and B provides simple statistics. You notice
    that on average, service A is called one million times per hour and service B
    is called only once per day. Scaling a monolithic application would mean adding
    a new node with the application that includes both services A and B.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务使你能够隔离和扩展应用的小部分，而不是整个应用。想象一下，你将应用中的一些核心业务逻辑提取到了服务A和B中。假设服务A提供对商品库存的访问，而B提供简单的统计数据。你会发现，平均每小时服务A被调用一百万次，而服务B每天只被调用一次。扩展单体应用意味着添加一个包含服务A和B的应用的新节点。
- en: 'Wouldn’t it be better if you only needed to scale service A? This is where
    the potential of microservices becomes apparent: in the new architecture, shown
    in [figure 1.2](kindle_split_010_split_001.xhtml#ch01fig02), services A and B
    become microservices A and B. You can still scale the application, but this additional
    flexibility is the point: you can now choose to scale where the load is greatest.
    Even better, you can dedicate one team of developers to maintaining microservice
    A and another to microservice B. You don’t need to touch the application to add
    features or fix bugs in either A or B, and they can also be rolled out completely
    independently of each other.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只需要扩展服务A，岂不是更好？这就是微服务的潜力显现的地方：在新架构中，如[图1.2](kindle_split_010_split_001.xhtml#ch01fig02)所示，服务A和B变成了微服务A和B。你仍然可以扩展应用，但这种额外的灵活性是关键：你现在可以选择在负载最大的地方进行扩展。更好的是，你可以指派一个开发团队来维护微服务A，另一个团队来维护微服务B。你不需要触及应用来添加功能或修复A或B中的错误，它们也可以完全独立地相互推出。
- en: Figure 1.2\. Scaling a microservice independently of the main application
  id: totrans-29
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.2. 独立于主应用扩展微服务
- en: '![](Images/01fig02.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/01fig02.jpg)'
- en: Companies like Netflix, Google, Amazon, and eBay have based much of their platforms
    on a microservice architecture, and they’ve all been kind enough to share much
    of this information freely. But although considerable focus is placed on web applications,
    you can apply a microservice architecture to any application. We hope this whets
    your appetite!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Netflix、Google、Amazon和eBay等公司已经将它们的大部分平台建立在微服务架构之上，并且他们都足够慷慨，愿意免费分享这些信息的大部分内容。尽管对Web应用的关注很多，但你也可以将微服务架构应用于任何应用。我们希望这能激发你的兴趣！
- en: 1.1.2\. What are microservices?
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.2. 什么是微服务？
- en: At first glance, the term *micro* may conjure up images of a tiny application
    with a small footprint. But regarding application size, there are no rules, other
    than a rule of thumb. A microservice may consist of several, several hundred,
    or even several thousand lines of code, depending on your specific business requirements;
    the rule of thumb is to keep the logic small enough for a single team to manage.
    Ideally, you should focus on a single endpoint (which may in turn provide multiple
    resources); but again, there’s no hard-and-fast rule. It’s your party.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 初看，术语“微”可能会让人联想到一个体积小、占用空间小的应用。但就应用大小而言，没有固定的规则，除了一个经验法则。一个微服务可能由几个、几百个，甚至几千行代码组成，这取决于你具体的业务需求；经验法则是保持逻辑足够小，以便单个团队管理。理想情况下，你应该专注于单个端点（这可能会提供多个资源）；但同样，也没有硬性规定。这是你的派对。
- en: The most common concept is that a single application should be the uppermost
    limit of a microservice. In the context of a typical application server running
    multiple applications, this means splitting applications so they’re running on
    a single application server. In theory, think of your first microservice as a
    single piece of a jigsaw puzzle, and try to imagine how it will fit together with
    the next piece.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的概念是，单个应用应该是微服务的上限。在典型应用服务器运行多个应用的背景下，这意味着将应用拆分，以便它们在单个应用服务器上运行。理论上，将你的第一个微服务视为拼图的一块，并尝试想象它如何与下一块拼合在一起。
- en: You can break a monolithic application into its logical pieces, as shown in
    [figure 1.3](kindle_split_010_split_001.xhtml#ch01fig03). There should be just
    enough information within each piece of the puzzle to enable you to build the
    greater picture. In a microservice architecture, these pieces are much more loosely
    coupled; see [figure 1.4](kindle_split_010_split_001.xhtml#ch01fig04).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将单体应用程序分解为其逻辑部分，如图1.3所示[figure 1.3](kindle_split_010_split_001.xhtml#ch01fig03)。每个拼图块中应该包含足够的信息，以便你能够构建更大的图景。在微服务架构中，这些部分耦合得更加松散；参见[figure
    1.4](kindle_split_010_split_001.xhtml#ch01fig04)。
- en: Figure 1.3\. Each service is part of the big picture.
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.3\. 每个服务都是大图景的一部分。
- en: '![](Images/01fig03_alt.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/01fig03_alt.jpg)'
- en: Figure 1.4\. Each microservice is still part of the picture but is isolated
    within a separate environment.
  id: totrans-38
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.4\. 每个微服务仍然是图景的一部分，但被隔离在单独的环境中。
- en: '![](Images/01fig04_alt.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/01fig04_alt.jpg)'
- en: 1.1.3\. Continuous integration, deployment, and Docker
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.3\. 持续集成、部署和Docker
- en: The *decoupling* of application elements into scalable microservices means you’ll
    have to start thinking about the *continuous integration (CI)* and *continuous
    delivery (CD)* pipelines from an early stage. Instead of one build script and
    one deployment, you’ll need multiple independent builds that must be sewn together
    for integration testing and deployment to different hosts.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序元素*解耦*到可扩展的微服务意味着你将不得不从早期阶段开始考虑*持续集成(CI)*和*持续交付(CD)*管道。你将需要多个独立的构建，这些构建必须被缝合在一起进行集成测试和部署到不同的主机。
- en: You’ll find that far less work is involved than you may think. This is largely
    due to the fact that a microservice is, for all intents and purposes, an application
    like any other. The only difference is that a microservice packages the application
    together with its runtime environment. The easiest and most recognized way to
    do this today is to create and deploy a microservice as a Docker image ([www.docker.com](http://www.docker.com)).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现所需的工作远比你想象的要少。这主要归因于这样一个事实，即微服务在本质上就像任何其他应用程序一样。唯一的区别是微服务将应用程序与其运行环境打包在一起。今天最简单、最公认的方法是将微服务作为Docker镜像([www.docker.com](http://www.docker.com))创建和部署。
- en: '|  |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Docker is the world’s leading software-containerization platform. If you’re
    not sure what Docker is, then at some point please visit [www.docker.com](http://www.docker.com)
    and follow the “What is Docker?” tutorial. Don’t worry, though—we’ll guide you
    through this pipeline when we put all the microservice elements together toward
    the end of the book.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Docker是世界上领先的软件容器化平台。如果你不确定Docker是什么，那么在某个时候请访问[www.docker.com](http://www.docker.com)并遵循“什么是Docker？”教程。不过，不用担心——当我们把所有微服务元素组合在一起，在本书的结尾部分，我们将引导你通过这个管道。
- en: '|  |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The heavyweight CI/CD contenders are Travis ([https://travis-ci.org](https://travis-ci.org)),
    Bamboo ([https://de.atlassian.com/software/bamboo](https://de.atlassian.com/software/bamboo)),
    and Jenkins ([https://jenkins.io](https://jenkins.io)). They all provide great
    support for microservices and deployment pipelines for Docker images; but in this
    book, we’ll use Jenkins, because it’s open source and has a huge community. It’s
    not necessarily the easiest to use, but it offers by far the most features via
    plugins. In [chapter 8](kindle_split_017_split_000.xhtml#ch08), we’ll highlight
    all the involved technologies in detail and guide you through the development
    of a viable CI/CD pipeline.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 重型CI/CD竞争者包括Travis([https://travis-ci.org](https://travis-ci.org))、Bamboo([https://de.atlassian.com/software/bamboo](https://de.atlassian.com/software/bamboo))和Jenkins([https://jenkins.io](https://jenkins.io))。它们都为微服务和Docker镜像的部署管道提供了很好的支持；但在这本书中，我们将使用Jenkins，因为它开源并且拥有庞大的社区。它可能不是最容易使用的，但它通过插件提供了最丰富的功能。在第8章[kindle_split_017_split_000.xhtml#ch08]中，我们将详细介绍所有涉及的技术，并指导你开发一个可行的CI/CD管道。
- en: 1.2\. Microservice networks and features
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2\. 微服务网络和特性
- en: Microservices are *loosely coupled*, which leads to new questions. How are microservices
    coupled, and what features does this architecture offer? In the following sections,
    we’ll look at some answers. But for all intents and purposes, each microservice
    is isolated by a network boundary.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是*松散耦合*的，这引发了一些新问题。微服务是如何耦合的，这种架构提供了哪些特性？在接下来的章节中，我们将探讨一些答案。但无论如何，每个微服务都是由网络边界隔离的。
- en: 1.2.1\. Microservice networks
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.1\. 微服务网络
- en: Microservices are most commonly integrated over a RESTful (Representational
    State Transfer) API using HTTP or HTTPS, but they can be connected by anything
    that’s considered a protocol to access an endpoint to a resource or function.
    This is a broad topic, so we’re only going to discuss and demonstrate Java REST
    using JAX-RS.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务通常通过 RESTful (表示状态转移) API 使用 HTTP 或 HTTPS 进行集成，但它们可以通过任何被认为是一种协议来连接，以访问资源或函数的端点。这是一个广泛的话题，所以我们只将讨论和演示使用
    JAX-RS 的 Java REST。
- en: '|  |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you’re unfamiliar with RESTful web services using JAX-RS ([https://jax-rs-spec.java.net](https://jax-rs-spec.java.net)),
    now would be a good time to read up on these topics.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还不熟悉使用 JAX-RS 的 RESTful 网络服务([https://jax-rs-spec.java.net](https://jax-rs-spec.java.net))，现在正是学习这些主题的好时机。
- en: '|  |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: With this information, your initial ideas for microservices should be starting
    to take form. Let’s continue with our earlier example. Microservice A, the inventory
    service, is isolated by a network layer from the UI and from microservice B, the
    statistics service. B communicates with A to collect statistics using the defined
    request-and-response protocols. They each have their own domain and external resources
    and are otherwise completely separate from each other. The UI service is able
    to call both A and B to present information in a human-readable form, a website,
    or a heavy client, as shown in [figure 1.5](kindle_split_010_split_002.xhtml#ch01fig05).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在获得这些信息后，你对微服务的初步想法应该开始成形。让我们继续之前的例子。微服务 A，库存服务，通过网络层与 UI 和微服务 B，统计服务隔离。B 通过定义的请求-响应协议与
    A 通信以收集统计数据。它们各自拥有自己的领域和外部资源，并且在其他方面完全独立。UI 服务能够调用 A 和 B，以人类可读的形式、一个网站或一个重型客户端展示信息，如图
    1.5[figure 1.5](kindle_split_010_split_002.xhtml#ch01fig05)所示。
- en: Figure 1.5\. Each service communicates by defined protocols.
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.5\. 每个服务通过定义的协议进行通信。
- en: '![](Images/01fig05.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/01fig05.jpg)'
- en: '|  |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Hypermedia**'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**超媒体**'
- en: 'Services should be developed with *hypermedia* in mind. This is the latest
    buzzword; it implies that services should be self-documenting in their architecture,
    by providing links to related resources in any response. Currently there’s no
    winner in this category, and it would be unfair to start placing bets now, but
    you can take a look at the front runners and make an educated guess: JSON-LD ([http://json-ld.org](http://json-ld.org)),
    JSON Hypertext Application Language (HAL, [https://tools.ietf.org/html/draft-kelly-json-hal-08](https://tools.ietf.org/html/draft-kelly-json-hal-08)),
    Collection+JSON ([https://github.com/collection-json/spec](https://github.com/collection-json/spec)),
    and Siren ([https://github.com/kevinswiber/siren](https://github.com/kevinswiber/siren)).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 应该考虑使用 *超媒体* 来开发服务。这是最新的热门词汇；它意味着服务在其架构中应该是自文档化的，通过在任何响应中提供相关资源的链接。目前在这个类别中还没有赢家，现在开始下注是不公平的，但你可以看看领跑者并做出明智的猜测：JSON-LD
    ([http://json-ld.org](http://json-ld.org))、JSON Hypertext Application Language
    (HAL, [https://tools.ietf.org/html/draft-kelly-json-hal-08](https://tools.ietf.org/html/draft-kelly-json-hal-08))、Collection+JSON
    ([https://github.com/collection-json/spec](https://github.com/collection-json/spec))
    和 Siren ([https://github.com/kevinswiber/siren](https://github.com/kevinswiber/siren))。
- en: '|  |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tests must be designed to cover comprehensively any and all interaction with
    external services. It’s important to get this right, because network interaction
    will always present its own set of challenges. We’ll cover this extensively in
    [chapter 5](kindle_split_014_split_000.xhtml#ch05).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 测试必须设计得能够全面覆盖与外部服务的任何交互。这一点非常重要，因为网络交互总会带来它自己的一套挑战。我们将在第 5 章[chapter 5](kindle_split_014_split_000.xhtml#ch05)中对此进行详细讨论。
- en: By now it should be clear that a microservice can be large in terms of application
    size, and that “micro” refers to the public-facing surface area of the application.
    Cloud space is cheap today, so the physical size of a microservice is less relevant
    than in the past.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，应该很清楚，微服务在应用大小方面可以很大，而“微”指的是应用的公共接口面积。如今云空间便宜，所以微服务的物理大小不如过去那么重要。
- en: Another concern that we often hear mentioned is, “What about network speed?”
    Microservices are generally hosted in the same local network, which is typically
    Gigabit Ethernet or better. So, from a client perspective, and given the ease
    of scaling microservices, response times are likely to be much better than expected.
    Again, don’t take our word for it; think of Netflix, Google, Amazon/AWS, and eBay.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常听到的另一个担忧是，“关于网络速度怎么办？”微服务通常托管在同一本地网络中，这通常是千兆以太网或更好。因此，从客户端的角度来看，考虑到微服务的易于扩展，响应时间可能会比预期的要好得多。再次强调，不要只听我们的话；想想Netflix、Google、Amazon/AWS和eBay。
- en: 1.2.2\. Microservice features
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.2\. 微服务特性
- en: 'In our example, both microservices A and B can be developed independently and
    deployed by two entirely different teams. Each team only needs to understand the
    resource-component layer of the microservice on which they’re working, rather
    than the entire business-domain component. This is the first big win: development
    can be much faster and easier to understand in the given context.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，微服务A和B都可以独立开发并由两个完全不同的团队部署。每个团队只需要了解他们正在工作的微服务的资源组件层，而不是整个业务域组件。这是第一个重大胜利：在给定上下文中，开发可以更快且更容易理解。
- en: 'JavaScript Object Notation (JSON, [www.json.org](http://www.json.org)) and
    Extensible Markup Language (XML, [www.w3.org/XML](http://www.w3.org/XML)) are
    the common resource languages, so it’s easy to write clients for such services.
    Some cases may dictate a different approach, but the basic scenarios remain essentially
    the same: the endpoints are accessible from a multitude of devices and clients
    using defined protocols.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript对象表示法（JSON，[www.json.org](http://www.json.org)）和可扩展标记语言（XML，[www.w3.org/XML](http://www.w3.org/XML)）是常见的资源语言，因此编写此类服务的客户端很容易。在某些情况下，可能需要不同的方法，但基本场景基本上是相同的：端点可以通过定义的协议从多种设备和客户端访问。
- en: Multiple microservices form a network of connected applications, where each
    individual microservice can be scaled independently. Elastic deployment on the
    cloud is now commonplace, and this enables an individual service to scale *automatically*
    up or down—for example, based on load.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 多个微服务形成一个连接的应用程序网络，其中每个单独的微服务都可以独立扩展。云上的弹性部署现在很常见，这使得单个服务可以根据负载自动扩展或缩减。
- en: Some other interesting benefits of microservices are improved fault isolation
    and memory management. In a monolithic application, a fault in a single component
    can bring down an entire server. With resilient microservices, the larger part
    of the picture will continue to function until the misbehaving service issue is
    resolved. In [figure 1.6](kindle_split_010_split_002.xhtml#ch01fig06), is the
    statistics service really necessary for the application to function as a whole,
    or can you live without it for a while?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务的其他一些有趣的好处是提高了故障隔离和内存管理。在单体应用中，单个组件的故障可能会使整个服务器崩溃。具有弹性的微服务，大部分功能将继续运行，直到出现问题的服务问题得到解决。在[图1.6](kindle_split_010_split_002.xhtml#ch01fig06)中，统计服务对于整个应用的功能是否真的必要，或者你可以在一段时间内没有它？
- en: Figure 1.6\. Resilient design using circuit breakers
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.6\. 使用断路器的弹性设计
- en: '![](Images/01fig06.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/01fig06.jpg)'
- en: Of course, as is the nature of all good things, microservices have drawbacks.
    Developers need to learn and understand the complexities of developing a distributed
    application, including how best to use IDEs, which are often orientated toward
    monolithic development. Developing use cases spanning multiple services that aren’t
    included in distributed transactions requires more thought and planning than for
    a monolith. And testing is generally more difficult, at least for the connected
    elements, which is why we wrote this book.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，正如所有美好事物的本质一样，微服务也有其缺点。开发者需要学习和理解开发分布式应用的复杂性，包括如何最好地使用IDE，这些IDE通常面向单体开发。开发跨越多个服务且不包含在分布式事务中的用例需要比单体应用更多的思考和规划。而且测试通常更困难，至少对于连接的元素来说是这样，这也是我们编写这本书的原因。
- en: 1.3\. Microservice architecture
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3\. 微服务架构
- en: The anatomy of a microservice can be varied, as shown in [figure 1.7](kindle_split_010_split_003.xhtml#ch01fig07),
    but design similarities are bound to occur. These elements can be grouped together
    to form the application-component layers. It’s important to provide test coverage
    at each layer, and you’ll likely be presented with new challenges along the way;
    we’ll address these challenges and offer solutions throughout the book.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务的结构可能多种多样，如图1.7所示，但设计上的相似性是必然的。这些元素可以组合在一起形成应用程序组件层。在每个层提供测试覆盖率很重要，你可能会在过程中遇到新的挑战；我们将在整本书中解决这些挑战并提供解决方案。
- en: Figure 1.7\. The basic microservice components
  id: totrans-76
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.7\. 基本微服务组件
- en: '![](Images/01fig07.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/01fig07.jpg)'
- en: Let’s look at these microservice component layers from the top down.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从上到下看看这些微服务组件层。
- en: '|  |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: A microservice should encapsulate and expose a well-defined area of logic as
    a service. That doesn’t mean that you can’t allow interaction from other systems
    by other means. For example, your service may expose specific documents that are
    stored in Elasticsearch (ES). In such a case, it’s perfectly legitimate for other
    applications to talk natively to ES in order to seed the documents.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务应该封装并暴露一个定义良好的逻辑区域作为服务。这并不意味着你不能通过其他方式允许其他系统进行交互。例如，你的服务可能公开了存储在Elasticsearch（ES）中的特定文档。在这种情况下，其他应用程序直接与ES通信以初始化文档是完全合法的。
- en: '|  |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 1.3.1\. Resource component
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.1\. 资源组件
- en: Resources are responsible for exposing the service interaction via a chosen
    protocol. This interaction occurs using mapped objects, usually serialized using
    JSON or XML. These mapped objects represent the input and/or output of the business
    domain. Sanitization of the incoming objects and construction of the protocol-specific
    response usually occur at this layer; see [figure 1.8](kindle_split_010_split_003.xhtml#ch01fig08).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 资源负责通过选定的协议公开服务交互。这种交互使用映射对象进行，通常使用JSON或XML进行序列化。这些映射对象代表业务域的输入和/或输出。对传入对象的净化和协议特定响应的构建通常发生在这一层；参见[图1.8](kindle_split_010_split_003.xhtml#ch01fig08)。
- en: Figure 1.8\. The resource component publicly exposes the service.
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.8\. 资源组件公开暴露服务。
- en: '![](Images/01fig08.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/01fig08.jpg)'
- en: '|  |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-88
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Now that we’re here, it’s worth mentioning that the resource-component layer
    is the layer that puts the *micro* in *microservice*.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在这里，值得提一下，资源组件层是使“微”服务成为“微服务”的层。
- en: '|  |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'For the rest of this book, and for the sake of simplicity, we’ll focus on the
    most common form of resource providers today: *RESTful endpoints*.^([[1](kindle_split_010_split_003.xhtml#ch01fn01)])
    If you aren’t familiar with RESTful web services, please take the time to research
    and understand this important topic.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的其余部分，为了简单起见，我们将关注今天最常见的资源提供者形式：*RESTful端点*^([[1](kindle_split_010_split_003.xhtml#ch01fn01)])。如果你不熟悉RESTful
    Web服务，请花时间研究和理解这个重要主题。
- en: ¹
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See “What Are RESTful Web Services?” in the Java EE 6 tutorial, [http://mng.bz/fIa2](http://mng.bz/fIa2).
  id: totrans-94
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 请参阅Java EE 6教程中的“什么是RESTful Web服务？”，[http://mng.bz/fIa2](http://mng.bz/fIa2)。
- en: 1.3.2\. Business-domain component
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.2\. 业务域组件
- en: The business-domain component is the core focus of your service application
    and is highly specific to the logical task for which the service is being developed.
    The domain may have to communicate with various other services (including other
    microservices) in order to calculate a response or process requests to and from
    the resource component; see [figure 1.9](kindle_split_010_split_003.xhtml#ch01fig09).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 业务域组件是您服务应用程序的核心焦点，并且对于服务正在开发的具体逻辑任务非常具体。域可能需要与各种其他服务（包括其他微服务）进行通信，以便计算响应或处理来自资源组件的请求和响应；参见[图1.9](kindle_split_010_split_003.xhtml#ch01fig09)。
- en: Figure 1.9\. The business-domain component is your service’s business logic.
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.9. 业务域组件是您服务业务逻辑。
- en: '![](Images/01fig09.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/01fig09.jpg)'
- en: A bridge is likely to be required between the domain component and the resource
    component, and possibly the remote component. Most microservices need to communicate
    with other microservices at some point.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在域组件和资源组件之间，以及可能还有远程组件之间，可能需要一个桥梁。大多数微服务都需要在某个时候与其他微服务进行通信。
- en: 1.3.3\. Remote resources component
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.3\. 远程资源组件
- en: This component layer is where your piece of the jigsaw puzzle may need to connect
    to the next piece, or pieces, of the picture. It consists of a client that understands
    how to send and receive resource objects to and from other microservice endpoints,
    which it then translates for use in the business component layer; see [figure
    1.10](kindle_split_010_split_003.xhtml#ch01fig10).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件层是您的拼图碎片可能需要连接到图片的下一部分或几部分的地方。它由一个客户端组成，该客户端了解如何向其他微服务端点发送和接收资源对象，并将其转换为业务组件层中的使用；参见
    [图 1.10](kindle_split_010_split_003.xhtml#ch01fig10)。
- en: Figure 1.10\. The remote resources component is the gateway to other services.
  id: totrans-102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.10\. 远程资源组件是通往其他服务的入口。
- en: '![](Images/01fig10.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/01fig10.jpg)'
- en: 'Due to the nature of remote resources, you must pay special attention to creating
    a resilient design. A resilient framework is designed to provide features such
    as circuit breakers and timeout fallbacks in the event of a failure. Don’t try
    to reinvent the wheel: several resilient frameworks are available to choose from,
    including our top pick, Hystrix ([https://github.com/Netflix/Hystrix/wiki](https://github.com/Netflix/Hystrix/wiki)),
    which is open source and contributed by Netflix.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 由于远程资源的特点，你必须特别注意创建一个具有弹性的设计。一个弹性的框架旨在在发生故障时提供诸如断路器和超时回退等特性。不要试图重新发明轮子：有多个弹性的框架可供选择，包括我们的首选，Hystrix
    ([https://github.com/Netflix/Hystrix/wiki](https://github.com/Netflix/Hystrix/wiki))，这是一个开源项目，由Netflix贡献。
- en: A gateway service should act as a bridge between the domain component and the
    client component. It’s responsible for translating request-and-response calls
    to and from any remote resource via the client. This is the best place to provide
    a graceful failure if the resource can’t be reached.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 网关服务应充当领域组件和客户端组件之间的桥梁。它负责通过客户端将请求和响应调用翻译为任何远程资源。如果资源无法访问，这是提供优雅失败的最佳位置。
- en: The client is responsible for speaking the language of your chosen protocol.
    Nine times out of ten, this will be JAX-RS ([https://jax-rs-spec.java.net](https://jax-rs-spec.java.net))
    over HTTP/S for RESTful web services.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端负责使用您选择的协议进行通信。十有八九，这将是通过 HTTP/S 的 JAX-RS ([https://jax-rs-spec.java.net](https://jax-rs-spec.java.net))
    用于 RESTful 网络服务。
- en: We highly recommend the open source services framework Apache CXF ([http://cxf.apache.org](http://cxf.apache.org))
    for this layer, because it’s fully compliant with JAX-WS, JAX-RS, and others,
    and it won’t tie you down to a specific platform.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强烈推荐开源服务框架 Apache CXF ([http://cxf.apache.org](http://cxf.apache.org)) 用于此层，因为它完全符合
    JAX-WS、JAX-RS 等标准，并且不会将您绑定到特定平台。
- en: 1.3.4\. Persistence component
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.4\. 持久性组件
- en: More often than not, an application requires some type of persistence or data
    retrieval (see [figure 1.11](kindle_split_010_split_003.xhtml#ch01fig11)). This
    usually comes in the form of an object-relational mapping (ORM)^([[2](kindle_split_010_split_003.xhtml#ch01fn02)])
    mechanism, such as the Java Persistence API (JPA),^([[3](kindle_split_010_split_003.xhtml#ch01fn03)])
    but could be something as simple as an embedded database or properties file.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 更多时候，应用程序需要某种类型的持久性或数据检索（参见 [图 1.11](kindle_split_010_split_003.xhtml#ch01fig11)）。这通常以对象关系映射（ORM）机制的形式出现，例如
    Java 持久性 API（JPA），^([[2](kindle_split_010_split_003.xhtml#ch01fn02)])，但也可能是像嵌入式数据库或属性文件这样简单的东西。
- en: ²
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'See “Hibernate ORM: What Is Object/Relational Mapping?” [http://hibernate.org/orm/what-is-an-orm](http://hibernate.org/orm/what-is-an-orm).'
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 请参阅“Hibernate ORM：什么是对象/关系映射？” [http://hibernate.org/orm/what-is-an-orm](http://hibernate.org/orm/what-is-an-orm)。
- en: ³
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See “Introduction to the Java Persistence API” in the Java EE 6 tutorial, [http://mng.bz/Cy69](http://mng.bz/Cy69).
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 请参阅 Java EE 6 教程中的“Java 持久性 API 简介”，[http://mng.bz/Cy69](http://mng.bz/Cy69)。
- en: Figure 1.11\. The persistence component is for data storage.
  id: totrans-116
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.11\. 持久性组件用于数据存储。
- en: '![](Images/01fig11.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/01fig11.jpg)'
- en: 1.4\. Microservice unit testing
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4\. 微服务单元测试
- en: '[Chapter 3](kindle_split_012_split_000.xhtml#ch03) will take a deep dive into
    real unit-testing scenarios. The next few paragraphs are an introduction to the
    terminology we’ll use and what to expect as you develop your testing strategies.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 3 章](kindle_split_012_split_000.xhtml#ch03) 将深入探讨实际的单元测试场景。接下来的几段将介绍我们将使用的术语以及您在开发测试策略时可以期待的内容。'
- en: 'A typical unit test is designed to be as small as possible and to test a trivial
    item: a *unit of work*. In the microservice context, this unit of work may be
    more difficult to represent, due to the fact that there’s often much more underlying
    complexity to the service than is apparent at first glance.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的单元测试旨在尽可能小，并测试一个微不足道的项目：*工作单元*。在微服务环境中，这个工作单元可能更难表示，因为服务通常比乍看之下有更多的底层复杂性。
- en: Unit testing can often lead to the conclusion that you need to refactor your
    code in order to reduce the complexity of the component under test. This also
    makes testing useful as a design tool, especially when you’re using test-driven
    development (TDD). A beneficial side effect of unit testing is that it lets you
    continue developing an application while detecting regressions at the same time.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试往往会导致您需要重构代码以降低被测试组件的复杂性。这也使得测试作为一个设计工具变得有用，尤其是在您使用测试驱动开发（TDD）时。单元测试的一个有益副作用是，它让您在检测回归的同时继续开发应用程序。
- en: 'Although you’re likely to encounter more-detailed scenarios along the way,
    there are basically two styles of unit testing: *sociable* and *solitary*. These
    styles are loosely based on whether the unit test is isolated from its underlying
    collaborators. Both styles are nonexclusive, and they complement each other nicely.
    You should count on using both, depending on the nature of the testing challenge.
    We’ll expand on these concepts throughout the book.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可能会在过程中遇到更详细的场景，但基本上有两种单元测试风格：*社交*和*独立*。这些风格松散地基于单元测试是否与其底层协作者隔离。两种风格都不是排他的，并且它们很好地互补。您应该根据测试挑战的性质使用两者。我们将在整本书中扩展这些概念。
- en: 1.4.1\. Solitary unit tests
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.4.1\. 独立单元测试
- en: Solitary unit testing should focus on the interaction around a single object
    class. The test should encompass only the class’s own dependents or dependencies
    on the class. You’ll usually test resource, persistence, and remote components
    using solitary tests, because those components rarely need to collaborate with
    each other; see [figure 1.12](kindle_split_010_split_004.xhtml#ch01fig12).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 独立单元测试应专注于单个对象类的交互。测试应仅涵盖该类自己的依赖项或对该类的依赖项。您通常会使用独立测试来测试资源、持久性和远程组件，因为这些组件很少需要相互协作；参见[图
    1.12](kindle_split_010_split_004.xhtml#ch01fig12)。
- en: Figure 1.12\. Predominantly solitary unit-test components
  id: totrans-125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.12\. 主要为独立单元测试组件
- en: '![](Images/01fig12.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/01fig12.jpg)'
- en: You need to isolate individual classes for testing by stubbing or mocking all
    collaborators within that class. You should test all the methods of the class,
    but not cross any boundaries to other concrete classes. Basically, this means
    all injected fields should receive either a mock or stubbed implementation that
    only returns canned responses. The primary aim is for the code coverage of the
    class under test to be as high as possible.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要通过模拟或存根化该类中所有协作者来隔离单个类进行测试。您应该测试该类的所有方法，但不要跨越到其他具体类的边界。基本上，这意味着所有注入的字段都应该接收一个模拟或存根化的实现，该实现只返回预定义的响应。主要目标是使被测试类的代码覆盖率尽可能高。
- en: 1.4.2\. Sociable unit tests
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.4.2\. 社交单元测试
- en: Sociable unit testing focuses on testing the behavior of modules by observing
    changes in their state. This approach treats the unit under test as a black box
    tested entirely through its interface. The domain component is nearly always a
    candidate for sociable testing, because it needs to collaborate in order to process
    a request and return a response; see [figure 1.13](kindle_split_010_split_004.xhtml#ch01fig13).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 社交单元测试侧重于通过观察其状态的变化来测试模块的行为。这种方法将单元测试视为一个完全通过其接口测试的黑盒。领域组件几乎总是社交测试的候选者，因为它需要协作以处理请求并返回响应；参见[图
    1.13](kindle_split_010_split_004.xhtml#ch01fig13)。
- en: Figure 1.13\. Predominantly sociable unit-test component
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.13\. 主要为社交单元测试组件
- en: '![](Images/01fig13.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/01fig13.jpg)'
- en: You may still need to stub or mock some complex collaborators of the class under
    test, but this should be as far along as possible within the hierarchy of collaborating
    objects. You shouldn’t only be testing that a specific class sends and receives
    correct payloads, but also that the class collaborators are operating as expected
    *within* the class. The test coverage should ideally include all models, variables
    and fields as well as the class collaborators. It’s also important to test that
    the class can correctly handle any response, including invalid responses (negative
    testing).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能仍然需要模拟或伪造测试中类的一些复杂协作者，但这应该在协作对象层次结构中尽可能远。你不应该只测试特定类是否发送和接收正确的有效载荷，还应该测试类协作者在**类内部**是否按预期操作。测试覆盖率应理想地包括所有模型、变量和字段以及类协作者。测试该类能够正确处理任何响应，包括无效响应（负面测试）也很重要。
- en: Summary
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: A microservice is a part of a monolithic application that has been dissected
    into a smaller logical element.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务是单体应用的一部分，已经被分解成更小的逻辑元素。
- en: Microservices benefit your application by allowing targeted scaling and focused
    development.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务通过允许有针对性的扩展和专注的开发，使你的应用程序受益。
- en: Microservices offer a logical way to meet scalability requirements by providing
    the ability to scale not only *where* performance is required, but also *when*.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务通过提供能力来扩展性能所需的**位置**和**时间**，提供了一种逻辑上满足可扩展性要求的方法。
- en: You can break monolithic applications into smaller elements that can be used
    as microservices.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以将单体应用拆分成更小的元素，这些元素可以用作微服务。
- en: Microservices allow several teams to focus on individual, nonconflicting tasks
    that make up the bigger picture.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务允许几个团队专注于构成更大图景的个别、非冲突任务。
- en: Solitary unit tests are used for components that don’t store state or don’t
    need to collaborate in order to be tested.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单独的单元测试用于那些不需要存储状态或不需要协作以进行测试的组件。
- en: Sociable unit tests are used for components that must collaborate or store state
    in order to be tested.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 社交单元测试用于那些必须协作或存储状态以进行测试的组件。
