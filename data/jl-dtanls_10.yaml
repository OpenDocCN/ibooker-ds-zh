- en: 8 First steps with data frames
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数据框的8个基本步骤
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Working with compressed files
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理压缩文件
- en: Reading and writing CSV files, Apache Arrow data, and SQLite databases
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取和写入CSV文件、Apache Arrow数据和SQLite数据库
- en: Getting columns from a data frame
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从数据框中获取列
- en: Computing summary statistics of data frame contents
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算数据框内容的摘要统计量
- en: Visualizing data distribution by using histograms
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用直方图可视化数据分布
- en: In this chapter, you will learn the basic principles of working with data frames
    in Julia provided by the DataFrames.jl package. *Data frame objects* are flexible
    data structures that allow you to work with tabular data. As I explained in chapter
    1, tabular data in general, and a data frame in particular, is a two-dimensional
    structure consisting of cells. Each row has the same number of cells and provides
    information about one observation of the data. Each column has the same number
    of cells, stores information about the same feature across observations, and also
    has a name.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习使用DataFrames.jl包在Julia中处理数据框的基本原理。"数据框对象"是灵活的数据结构，允许你处理表格数据。正如我在第1章中解释的，表格数据通常，尤其是数据框，是一个由单元格组成的二维结构。每一行都有相同数量的单元格，提供关于数据的一个观测值的信息。每一列都有相同数量的单元格，存储关于观测值之间相同特征的信息，并且有一个名称。
- en: 'After reading part 1, you have acquired essential skills for working with Julia
    to analyze data. Starting with this chapter, you will learn how to efficiently
    perform data analysis tasks in Julia. We start with explaining how to work with
    tabular data, as most statistical data sets have this form. Therefore, essentially
    every ecosystem used for doing data science provides a data frame type. For example:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读第1部分后，你已经掌握了使用Julia分析数据的基本技能。从本章开始，你将学习如何在Julia中高效地执行数据分析任务。我们首先解释如何处理表格数据，因为大多数统计数据集都采用这种形式。因此，几乎所有用于数据科学的生态系统都提供了数据框类型。例如：
- en: Every relational database organizes data in one or more tables.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个关系型数据库都通过一个或多个表来组织数据。
- en: In R, the data.frame object is a central concept built into the language. Over
    the years, alternative implementations of this concept were proposed in this ecosystem;
    two of the most popular are tibble and data.table.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在R中，data.frame对象是语言中内置的一个核心概念。多年来，这个概念在这个生态系统中提出了多种替代实现；其中最受欢迎的是tibble和data.table。
- en: In Python, the pandas package is highly popular, and the DataFrame type is its
    pivotal component.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python中，pandas包非常流行，其核心组件是DataFrame类型。
- en: The goal of this chapter is to introduce you to working with data frames. We
    will achieve this goal by performing a simple data analysis task.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是介绍你如何使用数据框。我们将通过执行一个简单的数据分析任务来实现这一目标。
- en: Many people like playing games. During the COVID-19 pandemic, playing chess
    online has become increasingly popular. Netflix additionally fueled this interest
    with its 2020 miniseries *The Queen’s Gambit*. If you would like to read more
    about the recent growing interest in chess, you might want to check out the Chess.com
    blog post at [http://mng.bz/O6Gj](http://mng.bz/O6Gj).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人喜欢玩游戏。在COVID-19大流行期间，在线下棋变得越来越受欢迎。Netflix还通过其2020年的迷你剧集《王后棋局》进一步激发了这种兴趣。如果你想了解更多关于近期对棋类游戏日益增长的兴趣，你可能想查看Chess.com博客文章[http://mng.bz/O6Gj](http://mng.bz/O6Gj)。
- en: 'Many people practice playing chess by solving chess puzzles. Therefore, a natural
    question to ask is this: What makes a good chess puzzle? We will try to gain insight
    into this topic through the analysis we will perform in this chapter. Specifically,
    we will examine how the popularity of a puzzle is related to its difficulty. Maybe
    people like easy puzzles the most. Or maybe the opposite is true, and very hard
    puzzles that require finding ingenious moves are most attractive. My objective
    for this chapter and for chapter 9 is to show you how to find the answers to these
    questions.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人通过解决棋盘谜题来练习下棋。因此，一个自然的问题就是：什么使一个棋盘谜题变得出色？我们将通过本章将要进行的分析来探讨这个话题。具体来说，我们将研究谜题的流行程度与其难度之间的关系。也许人们最喜欢简单的谜题。或者也许相反，非常难的谜题，需要找到巧妙的走法，才是最有吸引力的。本章和第9章的目标是向你展示如何找到这些问题的答案。
- en: As in any data science project, to gain insight into a problem, we need data
    that we can analyze. Fortunately, data on puzzles is freely available on the web.
    Lichess ([https://lichess.org](https://lichess.org/)) is a free and open source
    chess server. One of its features is an option allowing its users to solve chess
    puzzles.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何数据科学项目一样，为了对问题有深入了解，我们需要可以分析的数据。幸运的是，有关谜题的数据在网络上免费提供。Lichess ([https://lichess.org](https://lichess.org/))
    是一个免费的开源国际象棋服务器。其功能之一是允许用户解决国际象棋谜题。
- en: You can download the database of available puzzles from [https://database.lichess.org](https://database.lichess.org/).
    The data is distributed under the Creative Commons CC0 license. The file containing
    the puzzles is available as a bzip2 archive ([http://mng.bz/YKgj](http://mng.bz/YKgj)).
    It contains information about more than two million puzzles, including the number
    of times a given puzzle was played, how hard the puzzle is, how much Lichess users
    like the puzzle, and what chess themes the puzzle features.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从 [https://database.lichess.org](https://database.lichess.org/) 下载可用的谜题数据库。数据在Creative
    Commons CC0许可下分发。包含谜题的文件作为一个bzip2存档 ([http://mng.bz/YKgj](http://mng.bz/YKgj))
    提供。它包含关于超过两百万个谜题的信息，包括给定谜题被玩了多少次，谜题有多难，Lichess用户有多喜欢这个谜题，以及谜题具有哪些国际象棋主题。
- en: 'Our goal is to examine the relationship between the puzzle’s degree of difficulty
    and whether users like it. We will perform this analysis in chapter 9\. However,
    before we can get insights from data, we need to get it, load it, and perform
    its preliminary analysis. These preparatory steps are the objective of this chapter.
    Specifically, we will perform the following steps:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是检查谜题难度与用户是否喜欢它之间的关系。我们将在第9章进行这项分析。然而，在我们能够从数据中获得见解之前，我们需要获取它、加载它，并对其进行初步分析。这些准备工作是本章的目标。具体来说，我们将执行以下步骤：
- en: Download the compressed puzzle archive from the web.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从网络上下载压缩的谜题存档。
- en: Uncompress it.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解压缩它。
- en: Read its contents into a data frame.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其内容读入一个数据框。
- en: Use histograms to analyze the distributions of selected features stored in this
    data set.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用直方图来分析存储在此数据集中所选特征的分布。
- en: 'All these tasks need to be performed in virtually every data science project.
    Therefore, learning how to perform them efficiently is useful. To accomplish these
    objectives, I organized this chapter as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些任务几乎需要在每个数据科学项目中执行。因此，学习如何高效地执行这些任务是有用的。为了实现这些目标，我按照以下方式组织了本章：
- en: In section 8.1, you will learn how to work with bzip2 compressed data in Julia.
    Knowing how to programmatically handle compressed archives is often needed in
    practice, as data in many sources is typically compressed for storage.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第8.1节中，你将学习如何在Julia中处理bzip2压缩数据。在实际应用中，知道如何编程处理压缩归档通常是必需的，因为许多来源中的数据通常为了存储而进行压缩。
- en: In section 8.2, I’ll show you how to read a CSV file into a DataFrame object
    and quickly inspect its contents.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第8.2节中，我将向您展示如何将CSV文件读入DataFrame对象并快速检查其内容。
- en: 'Section 8.3 introduces you to the most basic way of getting data out of a data
    frame: by selecting a single column out of it.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第8.3节介绍了从数据框中获取数据的最基本方法：通过从中选择一个列。
- en: The source data we work with in this chapter is in CSV format. To show you how
    to read and write data stored using different standards, in section 8.4 you will
    learn how to work with the Apache Arrow format and SQLite databases.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们处理的数据源是CSV格式。为了向您展示如何读取和写入使用不同标准存储的数据，在第8.4节中，你将学习如何处理Apache Arrow格式和SQLite数据库。
- en: 8.1 Fetching, unpacking, and inspecting the data
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1 获取、解包和检查数据
- en: To work with the database of puzzles available on Lichess, we first need to
    download it from the web. Next, we will uncompress it so that later we can read
    it into a DataFrame.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理Lichess上可用的谜题数据库，我们首先需要从网络上下载它。接下来，我们将解压缩它，以便稍后可以将其读入DataFrame。
- en: I will show you how to unpack data stored in the bzip2 archive. However, the
    same approach can be used to uncompress archives created in other formats. Data
    compression is often used, as it reduces storage size or transfer time, so knowing
    how to handle compressed data is useful in practice.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我将向您展示如何解包存储在bzip2存档中的数据。然而，同样的方法也可以用于解压缩其他格式创建的存档。数据压缩通常被使用，因为它可以减少存储大小或传输时间，因此了解如何处理压缩数据在实践中是有用的。
- en: note In the GitHub repository containing the source code for this book, I have
    included the puzzles.csv.bz2 file that we use in this section to ensure reproducibility
    of the results presented in this chapter and chapter 9\. The Lichess puzzle database
    is constantly updated, so if you choose to use its latest version instead of the
    one available on GitHub, you can expect slightly different results, and the code
    could require minor changes. For this reason, in the first step of the example
    code, we save the file as new_puzzles.csv.bz2 so that it does not overwrite the
    puzzles.csv.bz2 file that we use next in the analysis.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在包含本书源代码的 GitHub 仓库中，我已经包含了本节中使用的 puzzles.csv.bz2 文件，以确保本章和第 9 章中展示的结果的可重复性。Lichess
    棋盘数据库不断更新，因此如果你选择使用其最新版本而不是 GitHub 上的版本，你可能会得到略微不同的结果，代码可能需要一些小的修改。因此，在示例代码的第一步中，我们将文件保存为
    new_puzzles.csv.bz2，这样它就不会覆盖我们在分析中使用的 puzzles.csv.bz2 文件。
- en: 8.1.1 Downloading the file from the web
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.1 从网络上下载文件
- en: 'Since the downloaded file is large, we add a step that checks whether the file
    already exists locally to avoid fetching it again if this is not necessary:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于下载的文件很大，我们添加了一个步骤来检查文件是否已经本地存在，以避免在不需要的情况下再次获取：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Checks whether the file is already present
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 检查文件是否已经存在
- en: ❷ If yes, prints the information confirming it
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果是，则打印确认信息
- en: ❸ If not, informs the user that the data needs to be fetched from the web
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果不是，则通知用户需要从网络上获取数据
- en: We use the @info macro to print an appropriate status message. In the preceding
    printout, I showed that puzzles.csv.bz2 is already present in the working directory.
    In this case, the isfile("new_puzzles.csv.bz2") check produces true.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 @info 宏来打印适当的状态消息。在上面的打印输出中，我展示了 puzzles.csv.bz2 已经存在于工作目录中。在这种情况下，isfile("new_puzzles.csv.bz2")
    检查产生 true。
- en: Creating logs of events in Julia
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Julia 中创建事件日志
- en: 'Julia is shipped with the Logging module, which allows you to log the progress
    of a computation as a log of events. The @info macro is part of this module and
    is used for logging informational messages. Other common event severity levels
    are supported via macros: @debug, @warn, and @error.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 随带日志模块，该模块允许你将计算进度记录为事件日志。@info 宏是这个模块的一部分，用于记录信息性消息。其他常见的事件严重程度级别通过宏支持：@debug、@warn
    和 @error。
- en: The Logging module allows you to flexibly decide which events get recorded and
    how. For example, you could decide you want to only log error messages and write
    them to a file. If you would like to learn more about how to configure logging
    in your Julia programs, refer to the “Logging” section of the Julia Manual ([https://docs.julialang.org/en/v1/stdlib/Logging/](https://docs.julialang.org/en/v1/stdlib/Logging/))
    for details.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 日志模块允许你灵活地决定哪些事件被记录以及如何记录。例如，你可以决定只记录错误消息并将它们写入文件。如果你想了解更多关于如何在 Julia 程序中配置日志的信息，请参阅
    Julia 手册中的“日志”部分 ([https://docs.julialang.org/en/v1/stdlib/Logging/](https://docs.julialang.org/en/v1/stdlib/Logging/))
    以获取详细信息。
- en: 8.1.2 Working with bzip2 archives
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.2 使用 bzip2 归档
- en: 'The puzzles.csv.bz2 file that is stored in the GitHub repository and used in
    this chapter is compressed using the bzip2 algorithm ([www.sourceware.org/bzip2/](https://www.sourceware.org/bzip2/)),
    which is indicated by the bz2 file extension. We will use the CodecBzip2.jl package
    to uncompress it. We first read the contents of the file as a vector of UInt8
    values (a single UInt8 value is 1 byte), and then uncompress it to a vector of
    bytes by using the transcode function:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在 GitHub 仓库中并用于本章的 puzzles.csv.bz2 文件是使用 bzip2 算法压缩的 ([www.sourceware.org/bzip2/](https://www.sourceware.org/bzip2/))，这由
    .bz2 文件扩展名指示。我们将使用 CodecBzip2.jl 包来解压缩它。我们首先将文件内容读取为 UInt8 值的向量（单个 UInt8 值是 1
    字节），然后使用转码函数将其解压缩为一个字节数组向量：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Reads compressed data into a vector of bytes
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将压缩数据读入一个字节数组向量
- en: ❷ Uncompresses the data using the Bzip2Decompressor codec
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用 Bzip2Decompressor 编解码器解压缩数据
- en: 'The compressed data has 94,032,447 bytes, which after uncompression becomes
    366,020,640 bytes. Thus, the compression ratio for this data set is around 4:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩数据有 94,032,447 字节，解压缩后变为 366,020,640 字节。因此，该数据集的压缩比大约为 4：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Understanding the transcode function
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 理解转码函数
- en: 'In our example, we use the transcode function to uncompress a vector of bytes.
    In Julia, this function is used in two contexts: changing string encoding and
    transcoding data streams.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们使用转码函数来解压缩一个字节数组。在 Julia 中，这个函数用于两个上下文：更改字符串编码和转码数据流。
- en: The first use case is converting data between Unicode encodings. As you learned
    in chapter 6, strings in Julia are UTF-8 encoded. If you happen to have a source
    data stream encoded in UTF-16 or UTF-32, you can use the transcode function to
    convert it to UTF-8\. Similarly, you can convert UTF-8-encoded data to UTF-16
    or UTF-32.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个用例是在 Unicode 编码之间转换数据。正如你在第 6 章中学到的，Julia 中的字符串是 UTF-8 编码的。如果你有一个以 UTF-16
    或 UTF-32 编码的源数据流，你可以使用 transcode 函数将其转换为 UTF-8。同样，你也可以将 UTF-8 编码的数据转换为 UTF-16
    或 UTF-32。
- en: 'The second situation for using the transcode function is to transcode data
    streams. In this scenario, you should provide as an input a codec you want to
    apply to this data and a vector of bytes. A *codec* is a program that changes
    encoding of data from its source format to another target. The most common usages
    of transcoding are data compression, uncompression, and changing data format.
    Here is a list of selected available codecs along with the packages that provide
    them:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 transcode 函数的第二个情况是将数据流进行转码。在这种情况下，您应该提供一个要应用于此数据的编解码器和一个字节数组。*编解码器*是一个程序，它将数据从源格式转换为另一种目标格式。转码的最常见用途是数据压缩、解压缩和更改数据格式。以下是一个选定的可用编解码器列表，以及提供它们的包：
- en: 'gzip, zlib, and deflate format compression and uncompression: CodecZlib.jl'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gzip、zlib 和 deflate 格式压缩和解压缩：CodecZlib.jl
- en: 'bzip2 format compression and uncompression: CodecBzip2.jl'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: bzip2 格式压缩和解压缩：CodecBzip2.jl
- en: 'xz format compression and uncompression: CodecXz.jl'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: xz 格式压缩和解压缩：CodecXz.jl
- en: 'zsdf format compression and uncompression: CodecZstd.jl'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: zsdf 格式压缩和解压缩：CodecZstd.jl
- en: 'base16, base32, and base64 decoding and encoding: CodecBase.jl'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: base16、base32 和 base64 解码和编码：CodecBase.jl
- en: I leave out the details of all these formats and functionalities, as we will
    not need them in this book. If you would like to learn more about how to use the
    transcode function, refer to the documentation of the respective packages.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我省略了所有这些格式和功能细节，因为我们在这本书中不需要它们。如果您想了解更多关于如何使用 transcode 函数的信息，请参阅相应包的文档。
- en: We most likely will want to get back to our uncompressed data several times.
    Let’s write it to a puzzles.csv file.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很可能需要多次回到我们的未压缩数据。让我们将其写入 puzzles.csv 文件。
- en: 'In the code that saves the puzzles.csv file, we use the pattern involving the
    open function with the do-end block you have already seen in chapter 6\. What
    is new is the use of the write function. It is used to write a binary representation
    of data to a file. In our case, since plain is Vector{UInt8}, we write its raw
    contents to the file. Before writing the uncompressed data stored in the plain
    vector, we write a string to this file by using the println function. This is
    needed because, as you will soon learn, the original CSV data does not have a
    header with column names. I have used column names given on the Lichess website
    ([https://database.lichess.org/#puzzles](https://database.lichess.org/#puzzles)):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在保存 puzzles.csv 文件的代码中，我们使用了你在第 6 章中已经看到的 open 函数和 do-end 块的模式。新的东西是 write 函数的使用。它用于将数据的二进制表示写入文件。在我们的情况下，因为
    plain 是 Vector{UInt8}，所以我们将其原始内容写入文件。在将存储在 plain 向量中的未压缩数据写入文件之前，我们使用 println
    函数向该文件写入一个字符串。这是因为，正如你很快就会学到的，原始 CSV 数据没有包含列名的标题。我使用了 Lichess 网站上给出的列名（[https://database.lichess.org/#puzzles](https://database.lichess.org/#puzzles)）：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Writes to io the text representation of the second passed argument followed
    by a newline
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将第二个传入参数的文本表示写入 io，后跟一个换行符
- en: ❷ Writes to io the binary representation of the second passed argument
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将第二个传入参数的二进制表示写入 io
- en: 8.1.3 Inspecting the CSV file
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.3 检查 CSV 文件
- en: 'Let’s quickly inspect the contents of the puzzles.csv file:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速检查 puzzles.csv 文件的内容：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Running this command gives the following output in a terminal:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令在终端中给出以下输出：
- en: '![CH08_UN01_Kaminski2](../Images/CH08_UN01_Kaminski2.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_UN01_Kaminski2](../Images/CH08_UN01_Kaminski2.png)'
- en: 'Indeed, the file looks like a properly formatted CSV file. This file format,
    which is a popular way to store tabular data, is specified as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 的确，这个文件看起来是一个格式正确的 CSV 文件。这种格式是存储表格数据的流行方式，其指定如下：
- en: The first line of the file contains column names separated by commas (,).
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件的第一行包含由逗号（,）分隔的列名。
- en: Each of the following lines contains information about a single observation
    (record) of our data. In a single line, commas separate cells that refer to consecutive
    columns of our table. The number of columns in each row must be equal to the number
    of column names defined in the first row of data.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下每一行都包含关于我们数据单个观测值（记录）的信息。在一行中，逗号分隔了引用表格连续列的单元格。每行中的列数必须等于数据第一行中定义的列名数量。
- en: 8.2 Loading the data to a data frame
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2 将数据加载到数据框中
- en: Now that we have uncompressed the data, let’s load it into a data frame. Our
    Lichess data is stored in the CSV format, and I have chosen this example intentionally
    because CSV is one of the most popular human-readable data formats used in practice.
    It can be easily read and written by spreadsheet editors. Therefore, knowing how
    to work with CSV files in Julia is worthwhile.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经解压缩了数据，让我们将其加载到数据框中。我们的 Lichess 数据存储在 CSV 格式，我故意选择这个例子，因为 CSV 是实践中使用最广泛的人类可读数据格式之一。它可以很容易地由电子表格编辑器读取和写入。因此，了解如何在
    Julia 中处理 CSV 文件是值得的。
- en: 8.2.1 Reading a CSV file into a data frame
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.1 将 CSV 文件读取到数据框中
- en: 'The DataFrame type defined in the DataFrames.jl library is one of the most
    popular options that you can use to store tabular data in memory in Julia. To
    read in the puzzles.csv file from disk to a DataFrame, use the CSV.read function
    from the CSV.jl package:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在 DataFrames.jl 库中定义的 DataFrame 类型是您在 Julia 中内存中存储表格数据最受欢迎的选项之一。要将磁盘上的 puzzles.csv
    文件读取到 DataFrame 中，请使用 CSV.jl 包中的 CSV.read 函数：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the last expression, I use the semicolon (;) to suppress printing the data
    frame contents to screen.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个表达式中，我使用分号 (;) 来抑制将数据框内容打印到屏幕。
- en: 'The CSV.read function can not only read data from a file whose name is passed
    as a string, but can also be directly passed a source that provides a sequence
    of bytes containing the data that should be read in. In our case, we have such
    a source, as it is a binary vector bound to the plain variable. Therefore, we
    could alternatively have created our data frame by writing this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: CSV.read 函数不仅可以读取传递为字符串的文件名中的数据，还可以直接传递一个提供包含要读取数据的字节序列的源的源。在我们的例子中，我们有一个这样的源，因为它是一个绑定到普通变量的二进制向量。因此，我们也可以通过编写以下内容来创建我们的数据框：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Reads the data from the vector of bytes while passing column names using the
    header keyword argument
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在传递列名时使用 header 关键字参数从字节数组中读取数据
- en: ❷ Checks that puzzles and puzzles2 data frames are identical
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 检查 puzzles 和 puzzles2 数据框是否相同
- en: Note that in this case, we pass the header keyword argument to the CSV.read
    function, as our original data does not have column names. Next, we compare the
    two data frames by using the == operator to make sure they are identical.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这种情况下，我们将 header 关键字参数传递给 CSV.read 函数，因为我们的原始数据没有列名。接下来，我们使用 == 操作符比较两个数据框，以确保它们相同。
- en: Choosing how CSV.read reads the data from the source
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 CSV.read 如何从源读取数据
- en: 'In our example, we have seen that the CSV.read function allows passing the
    header keyword argument to supply column names to a created table. In the CSV.jl
    documentation ([https://csv.juliadata.org/stable/reading.html](https://csv.juliadata.org/stable/reading.html)),
    you can find a list of all options supported by the reader. I’ll summarize several
    of the most often used keyword arguments and their functions:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们看到了 CSV.read 函数允许传递 header 关键字参数来为创建的表提供列名。在 CSV.jl 文档（[https://csv.juliadata.org/stable/reading.html](https://csv.juliadata.org/stable/reading.html)）中，您可以找到读者支持的所有选项列表。我将总结几个最常用的关键字参数及其功能：
- en: header—Controls how column names are treated when processing files. By default,
    it is assumed that the column names are the first row/line of the input.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: header—控制处理文件时如何处理列名。默认情况下，假设列名是输入的第一行/行。
- en: limit—Specifies the number of rows that should be read from the data. By default,
    all data is read.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: limit—指定应从数据中读取的行数。默认情况下，读取所有数据。
- en: misssingstring—Controls how missing values are handled while parsing input data.
    By default, an empty string is considered to represent a missing value.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: misssingstring—控制解析输入数据时如何处理缺失值。默认情况下，空字符串被视为表示缺失值。
- en: delim—Argument that parsing looks for in the data input that separates distinct
    columns on each row. If no argument is provided (the default), parsing will try
    to detect the most consistent delimiter on the first 10 rows of the input, falling
    back to a single comma (,) if no other delimiter can be detected consistently.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: delim—解析在数据输入中查找的参数，用于分隔每行上的不同列。如果没有提供参数（默认），解析将尝试检测输入前 10 行上最一致的分隔符，如果无法检测到其他一致的分隔符，则回退到单个逗号（,）。
- en: ignorerepeated—Used if parsing should ignore consecutive delimiters between
    columns. This option can be used to parse fixed-width data inputs. By default,
    it is set to false.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ignorerepeated—如果解析应该忽略列之间的连续分隔符，则使用此选项。此选项可用于解析固定宽度数据输入。默认情况下，它设置为 false。
- en: dateformat—Controls how parsing detects date and time values in the data input.
    If no argument is provided (the default), parsing will try to detect time, date,
    and date and time columns.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: dateformat—控制解析在数据输入中检测日期和时间值的方式。如果没有提供参数（默认），解析将尝试检测时间、日期和日期时间列。
- en: decimal—Used when parsing float values to indicate where the fractional portion
    of the float value begins. By default, a dot (.) is used.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: decimal—在解析浮点值时使用，以指示浮点值的分数部分开始的位置。默认情况下，使用点（.）。
- en: stringtype—Controls the type of string columns. By default, the InlineString.jl
    package, discussed in chapter 6, is used for columns storing narrow strings, and
    the String type is used for wide columns holding strings.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: stringtype—控制字符串列的类型。默认情况下，使用第 6 章中讨论的 InlineString.jl 包，用于存储窄字符串的列，而 String
    类型用于存储宽字符串的列。
- en: pool—Controls which columns will be returned as PooledArray. We discussed this
    type in chapter 6\. By default, a column is pooled if it stores strings, the number
    of unique values stored is less than 20% of its length, and the number of unique
    values is less than 500.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pool—控制哪些列将以 PooledArray 的形式返回。我们已在第 6 章中讨论了这种类型。默认情况下，如果列存储字符串，且存储的唯一值数量小于其长度的
    20%，并且唯一值的数量小于 500，则该列会被合并。
- en: 'Further, we will not need the values bound to the compressed and plain variables.
    Therefore, to allow Julia to free up memory allocated to these objects, we bind
    nothing to both variables:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们不需要绑定到压缩和普通变量的值。因此，为了允许 Julia 释放这些对象分配的内存，我们将这两个变量都绑定为无：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Freeing memory allocated to large objects
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 释放大型对象分配的内存
- en: It is important to remember that if a large object is bound to a variable name
    that is reachable in the Julia program, the memory allocated to them will not
    be freed by Julia. To allow Julia to reclaim this memory, you must make sure that
    the object is not reachable.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的是，如果一个大型对象绑定到一个在 Julia 程序中可访问的变量名，Julia 不会释放这些对象分配的内存。为了允许 Julia 重新回收此内存，你必须确保该对象不可访问。
- en: In one common case, global variables are often created in interactive sessions.
    Since in Julia you cannot delete a variable name after it has been bound to a
    value (see [http://mng.bz/G1GA](http://mng.bz/G1GA)), the solution is to change
    the binding of the variable name from pointing to a large object to nothing.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个常见情况下，全局变量通常在交互会话中创建。由于在 Julia 中，你不能在变量绑定到值之后删除变量名（见 [http://mng.bz/G1GA](http://mng.bz/G1GA)），解决方案是将变量名的绑定从指向一个大对象更改为无。
- en: 8.2.2 Inspecting the contents of a data frame
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.2 检查数据框的内容
- en: Let’s have a peek at the puzzles data frame in the following listing.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下列表中的 puzzles 数据框。
- en: Listing 8.1 Printing a sample data frame to the screen
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.1 将样本数据框打印到屏幕上
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output of listing 8.1 is cropped, as you can see here:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.1 的输出被裁剪了，正如你在这里可以看到的：
- en: '![CH08_UN02_Kaminski2](../Images/CH08_UN02_Kaminski2.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_UN02_Kaminski2](../Images/CH08_UN02_Kaminski2.png)'
- en: Cropping is indicated by triple dots and the message at the bottom right of
    the printout, where we learn that seven more columns and 2,123,983 rows were not
    fully printed. The exact output you get when you run this command on your computer
    depends on the window size where it is displayed.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 裁剪由三个点表示，并在打印输出的右下角的消息中指示，我们从中了解到还有七个列和 2,123,983 行没有被完全打印出来。你在计算机上运行此命令时得到的精确输出取决于显示它的窗口大小。
- en: When the puzzles data frame is printed, the header contains information about
    the names of the columns displayed and their element types. Each row in our data
    frame is a single puzzle description. Observe that the PuzzleId column uses five
    characters to encode the puzzle identifier. The CSV.read function automatically
    detects this fact and reads in this column by using the String7 type to store
    the strings. On the other hand, the FEN and Moves columns are wider, and therefore
    the String type is used.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当打印 puzzles 数据框时，标题包含有关显示的列名称及其元素类型的信息。我们数据框中的每一行都是一个单独的谜题描述。请注意，PuzzleId 列使用五个字符来编码谜题标识符。CSV.read
    函数自动检测这一事实，并使用 String7 类型来存储字符串。另一方面，FEN 和 Moves 列更宽，因此使用 String 类型。
- en: After reading in the data, it is a good practice to check whether the process
    produced the expected results in all columns. To get a quick view of the summary
    statistics for a data frame, use the describe function, as shown in the next listing.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在读取数据后，检查所有列是否产生了预期的结果是一个好习惯。要快速查看数据框的摘要统计信息，请使用 describe 函数，如以下列表所示。
- en: Listing 8.2 Getting summary statistics of the data frame columns
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.2 获取数据框列的摘要统计信息
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can see the result here:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里看到结果：
- en: '![CH08_UN03_Kaminski2](../Images/CH08_UN03_Kaminski2.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_UN03_Kaminski2](../Images/CH08_UN03_Kaminski2.png)'
- en: I wanted to show you the entire default result of the describe function. Therefore,
    this example also uses the show function to customize the data frame display.
    The truncate keyword argument allows you to specify a column’s maximum display
    width for output before being truncated (you can learn about other keyword arguments
    that the show function supports by executing ?show to check its documentation
    string).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我想向您展示 describe 函数的完整默认结果。因此，此示例还使用了 show 函数来自定义数据框显示。truncate 关键字参数允许您指定在截断之前输出列的最大显示宽度（您可以通过执行
    ?show 来了解 show 函数支持的其他关键字参数，以检查其文档字符串）。
- en: 'The describe function returns a new data frame in which each row contains information
    about a single column of the original data frame. By default, describe produces
    the following statistics for each source column:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: describe 函数返回一个新的数据框，其中每一行包含有关原始数据框中单个列的信息。默认情况下，describe 为每个源列生成以下统计信息：
- en: variable—Name stored as a Symbol
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: variable—存储为符号的名称
- en: mean—Average of values if the column contains numeric data
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: mean—如果列包含数值数据，则值的平均值
- en: min—Minimum value if the column contains data that can have a defined order
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: min—如果列包含可以定义顺序的数据，则列的最小值
- en: median—Median of values if the column contains numeric data
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: median—如果列包含数值数据，则值的中间值
- en: max—Maximum value if the column contains data that can have a defined order
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: max—如果列包含可以定义顺序的数据，则列的最大值
- en: nmissing—Number of missing values
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: nmissing—缺失值的数量
- en: eltype—Type of values stored
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: eltype—存储的值的类型
- en: The describe function allows you to additionally specify the statistics you
    want to compute (the ones listed here are the default) and select for which columns
    the summary statistics should be computed. Refer to the documentation ([http://mng.bz/09wE](http://mng.bz/09wE))
    if you would like to learn the details.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: describe 函数允许您进一步指定要计算的统计信息（这里列出的是默认值）并选择哪些列应计算摘要统计信息。如果您想了解详细信息，请参阅文档 ([http://mng.bz/09wE](http://mng.bz/09wE))。
- en: 'Given the information presented in the summary statistics in listing 8.2, we
    are ready to give an interpretation of the columns stored in the puzzles data
    frame:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 根据列表 8.2 中提供的摘要统计信息，我们准备对存储在 puzzles 数据框中的列进行解释：
- en: PuzzleId—A unique identifier of the puzzle
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PuzzleId—谜题的唯一标识符
- en: FEN—An encoding of a starting position of the puzzle
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FEN—对谜题起始位置的编码
- en: Moves—Moves that are a solution to the puzzle
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Moves—解决谜题的移动
- en: Rating—Difficulty of the puzzle
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rating—谜题的难度
- en: RatingDeviation—Accuracy of assessment of difficulty of the puzzle
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RatingDeviation—对谜题难度评估的准确性
- en: Popularity—How much the puzzle is liked by users (the higher, the better)
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Popularity—用户对谜题的喜爱程度（越高越好）
- en: NbPlays—Number of times a given puzzle was played
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NbPlays—给定谜题被玩过的次数
- en: Themes—Description of chess themes featured by the puzzle
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Themes—描述谜题中包含的棋类主题
- en: GameUrl—URL to the source game from which the puzzle was taken
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GameUrl—从其中获取谜题的源游戏的 URL
- en: 'Before we move forward, let’s discuss three functions that are commonly used
    when working with data frames: the ncol, nrow, and names functions.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续前进之前，让我们讨论在处理数据框时常用到的三个函数：ncol、nrow和names函数。
- en: 'The ncol function returns the number of columns in a data frame:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 'The ncol function returns the number of columns in a data frame:'
- en: '[PRE10]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The nrow function returns the number of rows in a data frame:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: nrow函数返回数据框中的行数：
- en: '[PRE11]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, the names function returns a vector of column names in our data frame
    (this function has more features that we will discuss in chapter 9):'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，names函数返回我们数据框中的列名向量（此函数具有更多功能，我们将在第9章中讨论）：
- en: '[PRE12]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 8.2.3 Saving a data frame to a CSV file
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.3 将数据框保存到CSV文件
- en: 'Before we wrap up this section, let’s see how to save a data frame back to
    a CSV file. You use the CSV.write function, where the first argument is the target
    filename, and the second argument is the table you want to save:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束本节之前，让我们看看如何将数据框保存回CSV文件。您使用CSV.write函数，其中第一个参数是目标文件名，第二个参数是要保存的表格：
- en: '[PRE13]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this code, we save the puzzles data frame to the puzzles2.csv file.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们将谜题数据框保存到puzzles2.csv文件中。
- en: 'It would be interesting to check whether the original puzzles.csv and puzzles2.csv
    files are identical. To perform this test, we will use the read function, which
    when passed a file as a single argument, returns a Vector{UInt8} that contains
    bytes read from the file. Here is an example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 检查原始puzzles.csv和puzzles2.csv文件是否相同将很有趣。为了执行此测试，我们将使用read函数，当传递一个文件作为单个参数时，它返回一个包含从文件中读取的字节的Vector{UInt8}。以下是一个示例：
- en: '[PRE14]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Therefore, we can check whether the files puzzles.csv and puzzles2.csv are
    identical by comparing the result of the read function applied to them:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以通过比较应用于它们的read函数的结果来检查文件puzzles.csv和puzzles2.csv是否相同：
- en: '[PRE15]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Indeed, both files contain identical data.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这两个文件包含相同的数据。
- en: Choosing how CSV.write writes the data
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 选择CSV.write如何写入数据
- en: 'Like the CSV.read function, the CSV.write function allows passing multiple
    keyword arguments to control the way the CSV data should be written. You can find
    all the options in the CSV.jl package documentation ([https://csv.juliadata.org/stable/writing.html](https://csv.juliadata.org/stable/writing.html)).
    Here are the most important ones:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 与CSV.read函数类似，CSV.write函数允许传递多个关键字参数来控制CSV数据应如何写入。您可以在CSV.jl包的文档中找到所有选项（[https://csv.juliadata.org/stable/writing.html](https://csv.juliadata.org/stable/writing.html)）。以下是最重要的几个：
- en: delim—A character or string to print out as the field delimiter. The default
    is a comma (,).
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: delim—用作字段分隔符的字符或字符串。默认为逗号（,）。
- en: missingstring—A string to print for missing values. By default, an empty string
    is used.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: missingstring—用于打印缺失值的字符串。默认情况下，使用空字符串。
- en: dateformat—The date format string to use. The default is a format specified
    by the Dates module.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: dateformat—要使用的日期格式字符串。默认为由Dates模块指定的格式。
- en: append—Whether to append writing to an existing file. If true, it will not write
    column names; the default is false.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: append—是否将写入追加到现有文件中。如果为true，则不会写入列名；默认为false。
- en: compress—Controls whether the written output should be compressed using standard
    gzip compression. By default, false is used.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: compress—控制是否使用标准gzip压缩来压缩写入的输出。默认情况下，使用false。
- en: decimal—Character to use as the decimal point when writing floating-point numbers.
    The default is a dot (.).
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: decimal—在写入浮点数时用作小数点的字符。默认为点（.）。
- en: 8.3 Getting a column out of a data frame
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3 从数据框中获取列
- en: To be able to perform our analysis, we need to learn how to get data out of
    a data frame. The most common operation of this kind is extracting a single column.
    DataFrames.jl provides several options for how to do this. Let’s investigate them
    one by one.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够执行我们的分析，我们需要学习如何从数据框中获取数据。这类操作中最常见的是提取单个列。DataFrames.jl提供了几种进行此操作的方法。让我们逐一调查它们。
- en: To keep the focus on a task of analysis of the Lichess puzzles data, we will
    specifically want to create histograms of the Rating, RatingDeviation, Popularity,
    and NbPlays columns from the puzzles data frame, as they will be used in our further
    analysis.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了专注于分析Lichess谜题数据的任务，我们将特别想要从谜题数据框中创建Rating、RatingDeviation、Popularity和NbPlays列的直方图，因为它们将在我们的进一步分析中使用。
- en: 8.3.1 Understanding the data frame’s storage model
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.1 理解数据框的存储模型
- en: Internally, a DataFrame object stores data as a collection of vectors. Each
    vector represents one column of a data frame and is assigned a name and a number.
    Let’s visualize this in table 8.1.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，DataFrame对象将数据存储为向量的集合。每个向量代表数据框的一列，并分配一个名称和一个编号。让我们在表8.1中可视化这一点。
- en: Table 8.1 Structure of the puzzles data frame
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.1 拼图数据框的结构
- en: '| Column # | Column name | Column vector |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 列编号 | 列名称 | 列向量 |'
- en: '| 1 | PuzzleId | ["00008", "0000D", "0009B", "000aY", ...] |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 1 | PuzzleId | ["00008", "0000D", "0009B", "000aY", ...] |'
- en: '| 2 | FEN | ["r6k/pp2r2p/ ... /7K b - - 0 24", ...] |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 2 | FEN | ["r6k/pp2r2p/ ... /7K b - - 0 24", ...] |'
- en: '| 3 | Moves | ["f2g3 e6e7 b2b1 b3c1 b1c1 h6c1", ...] |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 3 | Moves | ["f2g3 e6e7 b2b1 b3c1 b1c1 h6c1", ...] |'
- en: '| 4 | Rating | [1765, 1525, 1102, 1320, 1560, 1039, ...] |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| 4 | Rating | [1765, 1525, 1102, 1320, 1560, 1039, ...] |'
- en: '| 5 | RatingDeviation | [74, 74, 75, 74, 76, 80, 75, ...] |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 5 | RatingDeviation | [74, 74, 75, 74, 76, 80, 75, ...] |'
- en: '| 6 | Popularity | [93, 97, 85, 92, 88, 85, 80, ...] |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 6 | Popularity | [93, 97, 85, 92, 88, 85, 80, ...] |'
- en: '| 7 | NbPlays | [493, 9211, 503, 395, 441, 54, ...] |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 7 | NbPlays | [493, 9211, 503, 395, 441, 54, ...] |'
- en: '| 8 | Themes | ["crushing ... middlegame", ...] |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 8 | Themes | ["crushing ... middlegame", ...] |'
- en: '| 9 | GameUrl | ["https://lichess.org/.../black#48", ...] |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 9 | GameUrl | ["https://lichess.org/.../black#48", ...] |'
- en: 'For example, internally, column number 4 has the name Rating and stores a vector
    of integers that represents the puzzle’s difficulties: [1765, 1525, 1102, 1320,
    1560, ...].'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在内部，编号为4的列名为Rating，存储了一个表示拼图难度的整数向量：[1765, 1525, 1102, 1320, 1560, ...]。
- en: 'The storage layout of a data frame was chosen to ensure that operations that
    are performed on columns of a data frame are very fast. We will discuss multiple
    such operations in this book. Let’s start with the simplest one: extracting a
    column from a data frame.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 数据框的存储布局被选择以确保对数据框列执行的操作非常快。本书将讨论多个此类操作。让我们从最简单的一个开始：从数据框中提取列。
- en: 8.3.2 Treating a data frame column as a property
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.2 将数据框列视为属性
- en: In chapter 4, you learned about the NamedTuple type and about composite types
    that are created using the struct keyword argument. We discussed the fact that
    you can access fields of NamedTuple or a composite type by using a dot (.) followed
    by a field name. The same syntax allows accessing columns of a data frame.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4章中，你学习了关于NamedTuple类型以及使用struct关键字参数创建的复合类型。我们讨论了你可以通过使用点号（.）后跟字段名称来访问NamedTuple或复合类型的字段。相同的语法允许访问数据框的列。
- en: 'If you consider the puzzles data frame and want to extract out the Rating column
    from it, write this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你考虑拼图数据框并想从中提取Rating列，请编写以下内容：
- en: '[PRE16]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Earlier, in chapter 5, I said that the dot (.) allows the user to access the
    fields of a struct. How is it then possible that the DataFrame type allows the
    user to access its columns by using this syntax?
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，在第5章中，我说过点号（.）允许用户访问结构体的字段。那么，DataFrame类型是如何允许用户使用这种语法来访问其列的呢？
- en: The reason is that Julia makes a distinction between *fields* of a struct object
    and its *properties*. When you use the dot (.) syntax, you get access to properties
    of an object. By default, properties of the object are the same as its fields,
    but it is possible to override this behavior (technically, you need to add appropriate
    methods to the getproperty function; see [http://mng.bz/K0Bg](http://mng.bz/K0Bg)
    for more information). This is exactly what is done for the DataFrame type. Instead
    of exposing its fields, it allows users to access its columns by using the dot
    (.) syntax since this is much more useful in practice.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是Julia在结构体对象的字段和其属性之间做出了区分。当你使用点号（.）语法时，你可以访问对象的属性。默认情况下，对象的属性与其字段相同，但可以覆盖这种行为（技术上，你需要向getproperty函数添加适当的方法；更多信息请参见[http://mng.bz/K0Bg](http://mng.bz/K0Bg)）。这正是DataFrame类型所做的事情。它不是暴露其字段，而是允许用户使用点号（.）语法来访问其列，因为在实践中这要更有用。
- en: Note that field names are part of a type definition, so every value having this
    type has the same fields. Conversely, if a type overrides the definition of properties,
    they can be different across values having the same type. For instance, all values
    having the DataFrame type have the same fields, but their properties depend on
    the column names that a given data frame stores.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，字段名称是类型定义的一部分，因此具有此类型的每个值都有相同的字段。相反，如果类型覆盖了属性的定义，那么具有相同类型的值之间的属性可以不同。例如，所有具有DataFrame类型的值都有相同的字段，但它们的属性取决于给定数据框存储的列名称。
- en: You can get the list of fields of the DataFrame type by using the fieldnames
    function. If you called fieldnames(DataFrame), you would get the tuple (:columns,
    :colindex) if you work with DataFrames.jl 1.3\. (Which fields the DataFrame object
    stores is an implementation detail, and they may change with versions of DataFrames.jl.)
    The internal fields store the vectors constituting the DataFrame columns, as well
    as a mapping of column names and their numbers. If you wanted to extract the fields
    from a df variable of the DataFrame type, you could use the getfield function.
    For example, getfield(df, :columns) returns a vector of vectors stored in a data
    frame.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 fieldnames 函数来获取 DataFrame 类型的字段列表。如果你使用 DataFrames.jl 1.3 版本工作，调用 fieldnames(DataFrame)
    将会得到一个包含 (:columns, :colindex) 的元组。（DataFrame 对象存储哪些字段是实现细节，并且它们可能会随着 DataFrames.jl
    的版本而变化。）内部字段存储构成 DataFrame 列的向量，以及列名称和它们的数字映射。如果你想要从 DataFrame 类型的 df 变量中提取字段，你可以使用
    getfield 函数。例如，getfield(df, :columns) 返回一个存储在数据帧中的向量。
- en: Figure 8.1 shows how the fields and properties of two sample data frames are
    related.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 展示了两个样本数据帧的字段和属性之间的关系。
- en: '![CH08_F01_Kaminski2](../Images/CH08_F01_Kaminski2.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F01_Kaminski2](../Images/CH08_F01_Kaminski2.png)'
- en: Figure 8.1 Because both data frames have the same type, they have the same field
    names. These field names are part of the definition of the DataFrame type. Conversely,
    since both data frames have different columns, their property names are different.
    DataFrame type properties are defined to correspond to column names of a given
    instance.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 由于两个数据帧具有相同的类型，它们具有相同的字段名称。这些字段名称是 DataFrame 类型的定义的一部分。相反，由于两个数据帧具有不同的列，它们的属性名称也不同。DataFrame
    类型的属性定义为与给定实例的列名称相对应。
- en: Although it is technically possible, you should never directly extract the fields
    from a data frame. The internal layout of the DataFrame type is considered private
    and might change in the future. I cover this topic only to make sure that you
    understand the distinction between fields and properties of objects in Julia.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在技术上可能，但你永远不应该直接从数据帧中提取字段。DataFrame 类型的内部布局被认为是私有的，并且可能会在未来发生变化。我仅介绍这个主题是为了确保你理解
    Julia 中对象字段和属性之间的区别。
- en: 'Let’s go back to the topic of this section and check how fast the operation
    of getting a column from a data frame is, using the @btime macro (recall from
    chapter 3 that we need to prefix the global variable puzzles with $ to get proper
    benchmark results):'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到本节的主题，并检查使用 @btime 宏获取数据帧列的操作速度有多快（回想第 3 章中提到的，我们需要在全局变量 puzzles 前面加上 $
    以获得正确的基准测试结果）：
- en: '[PRE17]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The operation is very fast. It takes only a few nanoseconds because accessing
    a data frame’s column this way is performed without copying the data. By writing
    puzzles.Rating, you get the same data that is referenced by the puzzles variable.
    The only operations that Julia needs to perform to get the column from a data
    frame are to retrieve from the :colindex private field the information that Rating
    has column number 4 and then extract it out from the :columns private field.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 操作非常快。它只需要几纳秒，因为以这种方式访问数据帧的列不需要复制数据。通过编写 puzzles.Rating，你可以得到由 puzzles 变量引用的相同数据。Julia
    需要执行的唯一操作是从 :colindex 私有字段中检索信息，即 Rating 有列号 4，然后从 :columns 私有字段中提取它。
- en: This behavior has a clear performance benefit. However, you might ask what to
    do if you want to get a copy of the vector. This is not a mundane question. In
    practice, you might later want to modify it without altering the original vector’s
    data.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为有明显的性能优势。然而，你可能会问，如果你想要获取向量的副本，该怎么办。这不仅仅是一个普通的问题。在实践中，你可能稍后想要修改它，而不改变原始向量的数据。
- en: 'An established way to copy an object in Julia is to call the copy function
    on it, so by writing copy(puzzles.Rating), you get a copy of the vector stored
    in the puzzles data frame. However, when you compare the puzzles.Rating and copy
    (puzzles.Rating), you learn that they are equal:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Julia 中复制对象的一种既定方法是调用它的 copy 函数，所以通过编写 copy(puzzles.Rating)，你可以得到 puzzles
    数据帧中存储的向量的副本。然而，当你比较 puzzles.Rating 和 copy(puzzles.Rating) 时，你会了解到它们是相等的：
- en: '[PRE18]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This shows us that using == to test two vectors for equality compares their
    contents, not their memory location. Is it possible to compare vectors in a way
    that would check if they were the same objects (in the sense that no Julia program
    could distinguish between them)? Indeed, there is. You can achieve this by using
    the === comparison discussed in chapter 7:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明使用 `==` 来测试两个向量是否相等是比较它们的内容，而不是它们的内存位置。是否有可能以某种方式比较向量，从而检查它们是否是相同的对象（在这个意义上，没有任何
    Julia 程序能够区分它们）？确实有。你可以通过使用第 7 章中讨论的 `===` 比较来实现这一点：
- en: '[PRE19]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We see that these two objects are not the same (although they have the same
    contents).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到这两个对象不是同一个（尽管它们有相同的内容）。
- en: 'If we compare puzzles.Rating to puzzles.Rating by using ===, we get true, as
    this time it is indeed the same object:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 `===` 来比较 puzzles.Rating 和 puzzles.Rating，我们会得到 true，因为这次它们确实是同一个对象：
- en: '[PRE20]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'On the other hand, two copies are different, as expected:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，两个副本是不同的，正如预期的那样：
- en: '[PRE21]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You can also use a string literal after the dot (.) when getting the column
    from a data frame:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在点（.）之后使用字符串字面量来获取数据框的列：
- en: '[PRE22]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The effect of this operation is the same as writing puzzles.Rating. You might
    ask, then, why puzzles."Rating" is useful. This syntax facilitates handling any
    special characters in a data frame’s column name (for example, spaces). Then the
    double quotes (") make the column name’s beginning and ending unambiguous. A small
    downside of writing puzzles."Rating" instead of puzzles.Rating is that it is a
    bit slower, as internally Julia needs to convert the string to a Symbol before
    getting the data from a data frame. However, this operation is still fast (nanoseconds).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作的效果与写入 puzzles.Rating 相同。那么，你可能会问，为什么 puzzles."Rating" 有用。这种语法简化了处理数据框列名中的任何特殊字符（例如，空格）。然后双引号（"）使得列名的开始和结束变得明确。将
    puzzles."Rating" 而不是 puzzles.Rating 写入的一个小缺点是，它稍微慢一些，因为 Julia 需要在从数据框获取数据之前将字符串转换为
    Symbol。然而，这个操作仍然很快（纳秒级）。
- en: Exercise 8.1 Using the BenchmarkTools.jl package, measure the performance of
    getting a column from a data frame by using the puzzles ."Rating" syntax.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 8.1 使用 BenchmarkTools.jl 包，通过使用 puzzles ."Rating" 语法来测量从数据框获取列的性能。
- en: 8.3.3 Getting a column by using data frame indexing
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.3 通过数据框索引获取列
- en: Using the property access, like puzzles.Rating, to get a data frame’s column
    is easy to type but has one drawback. What if the column name is stored in a variable
    like this?
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用属性访问，如 puzzles.Rating，来获取数据框的列容易输入，但有一个缺点。如果列名存储在一个变量中，会怎样呢？
- en: '[PRE23]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How can you get a column of the puzzles data frame that is referenced to by
    the col variable? And how do you get a column by its number, not by its name,
    from a data frame? Both questions are answered by using the indexing syntax.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何获取由 col 变量引用的 puzzles 数据框的列？以及你如何从数据框中通过编号而不是名称来获取列？这两个问题都通过使用索引语法得到解答。
- en: 'The general form of indexing into a data frame is as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 数据框索引的一般形式如下：
- en: '[PRE24]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, this is similar to matrices discussed in chapter 4\. In this
    chapter, we will discuss various options for the accepted values of selected_rows
    and selected_ columns, but in this section, we focus on what you should use to
    get a single column from a data frame.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这与第 4 章中讨论的矩阵类似。在本章中，我们将讨论各种选项的接受值，包括 selected_rows 和 selected_columns，但在这个部分，我们专注于你应该如何从数据框中获取单个列。
- en: 'To get a column from a data frame via copying, use a colon (:) as the row selector,
    and use a string, Symbol, or number as the column selector. Here are four equivalent
    ways of using copying to get the Rating column from the puzzles data frame:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过复制从数据框中获取列，使用冒号（:）作为行选择器，并使用字符串、Symbol 或数字作为列选择器。这里有四种等效的方法来使用复制从 puzzles
    数据框中获取 Rating 列：
- en: '[PRE25]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ❶ Column selector passed using a string
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用字符串传递列选择器
- en: ❷ Column selector passed using a symbol
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用符号传递列选择器
- en: ❸ Column selector passed using an integer
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用整数传递列选择器
- en: ❹ Column selector passed using a variable (storing a string, in this case)
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用变量（在这种情况下存储字符串）传递列选择器
- en: It is important to highlight that when referring to the column of a data frame,
    you can always use either a string or a Symbol. For user convenience, the data
    frame will accept both and treat them in the same way. Choose the style that is
    more convenient for you. If you are concerned about performance, using Symbol
    is a bit faster, but the time increase of using a string is negligible.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 突出强调，在引用数据框的列时，您始终可以使用字符串或符号。为了方便用户，数据框将接受两者并将它们以相同的方式处理。选择对您更方便的样式。如果您担心性能，使用符号会稍微快一点，但使用字符串的时间增加是可以忽略不计的。
- en: Note that in the last selector, puzzles[:, col], we use the col variable bound
    to the "Rating" string. Allowing for this selection is the benefit of using indexing
    over property access.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在最后一个选择器 puzzles[:, col] 中，我们使用绑定到 "Rating" 字符串的 col 变量。允许这种选择是使用索引而不是属性访问的好处。
- en: 'Finally, you might ask how I have established that Rating is the fourth column
    in our data frame. This is easy to check using the columnindex function:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可能会问我是如何确定 Rating 是我们数据框中的第四列的。这很容易使用 columnindex 函数来检查：
- en: '[PRE26]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If a certain column name is not found in the data frame, the columnindex function
    returns 0, as in this example:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据框中没有找到特定的列名，columnindex 函数将返回 0，就像这个例子一样：
- en: '[PRE27]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In DataFrames.jl, columns are numbered starting with 1 (just as in standard
    arrays), so if you get a 0 value from the columnindex function, you know that
    such a column name is not present in the data frame.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在 DataFrames.jl 中，列是从 1 开始编号的（就像在标准数组中一样），因此如果您从 columnindex 函数中获得 0 值，您知道这样的列名不存在于数据框中。
- en: 'You can also test whether a data frame contains a certain column name by using
    the hasproperty function:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用 hasproperty 函数来测试数据框是否包含特定的列名：
- en: '[PRE28]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note that in both columnindex and hasproperty, we could have used a Symbol instead
    of a string to pass a column name if we preferred.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 columnindex 和 hasproperty 中，如果我们愿意，可以使用符号而不是字符串来传递列名。
- en: 'Getting a column from a data frame by copying is more expensive than a noncopying
    operation:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 通过复制从数据框中获取列比非复制操作更昂贵：
- en: '[PRE29]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this case, the time has grown from nanoseconds for the puzzles.Rating selector
    to milliseconds for puzzles[:, :Rating]. Also, much more memory is used.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，时间从 puzzles.Rating 选择器的纳秒增长到 puzzles[:, :Rating] 的毫秒。此外，使用的内存也更多。
- en: 'To get a column from a data frame without copying, use an exclamation mark
    (!) as the row selector, and use a string, Symbol, or number as the column selector.
    Here are four equivalent ways of getting the Rating column from the puzzles data
    frame without copying by using indexing:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 要从数据框中获取列而不进行复制，请使用感叹号（!）作为行选择器，并使用字符串、符号或数字作为列选择器。以下是四种获取 puzzles 数据框中 Rating
    列而不进行复制的等价方法，使用索引：
- en: '[PRE30]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Note that writing puzzles[!, "Rating"] is equivalent to writing puzzles.Rating.
    Recall that if you used : instead of ! (like this: puzzles[:, "Rating"]), you
    would get a copy of the Rating column.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，编写 puzzles[!, "Rating"] 与编写 puzzles.Rating 等效。回想一下，如果您使用冒号（:）而不是感叹号（!）（例如：puzzles[:,
    "Rating"]），您将得到 Rating 列的副本。
- en: Be cautious with noncopying access to the data frame’s columns
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在访问数据框的列时请谨慎使用非复制访问
- en: In many applications, users are tempted to use the noncopying access to columns
    of a data frame, by, for example, writing puzzles.Rating or puzzles[!, "Rating"].
    This approach has merit, as access is faster. However, noncopying access has a
    serious drawback if you mutate the obtained vector. The experience of DataFrames.jl
    users shows that this type of access can occasionally lead to hard-to-catch bugs.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多应用中，用户可能会被诱惑使用数据框列的非复制访问，例如编写 puzzles.Rating 或 puzzles[!, "Rating"]。这种方法有其优点，因为访问更快。然而，如果您对获得的向量进行修改，非复制访问有一个严重的缺点。DataFrames.jl
    用户的经验表明，这种类型的访问有时会导致难以捕捉的故障。
- en: Therefore, as a rule of thumb, always access columns of a data frame with copying—that
    is, like puzzles[:, "Rating"]—unless you are 100% sure you are not going to mutate
    the column, or your operation needs to be performed very fast (for example, it
    is inside a loop that is executed millions of times).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，作为一个经验法则，始终以复制的方式访问数据框的列——即像 puzzles[:, "Rating"] 一样——除非您 100% 确定您不会修改列，或者您的操作需要非常快（例如，它在一个执行数百万次的循环中）。
- en: 8.3.4 Visualizing data stored in columns of a data frame
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.4 在数据框的列中可视化存储的数据
- en: 'Now that you have learned how to get a column from a data frame, we are ready
    to create the desired plots. The following code uses the histogram function from
    the Plots.jl package to produce four histograms of the columns Rating, RatingDeviation,
    Popularity, and NbPlays:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何从一个数据框中获取列，我们就可以创建所需的图表了。以下代码使用Plots.jl包中的直方图函数生成Rating、RatingDeviation、Popularity和NbPlays列的四个直方图：
- en: '[PRE31]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You can see the result in figure 8.2\. All these variables are significantly
    skewed. We discuss how to handle this issue and analyze the relationship between
    puzzle rating and popularity in chapter 9.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在图8.2中看到结果。所有这些变量都显著偏斜。我们将在第9章讨论如何处理这个问题，并分析拼图评分与流行度之间的关系。
- en: '![CH08_F02_kaminski2](../Images/CH08_F02_kaminski2.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F02_kaminski2](../Images/CH08_F02_kaminski2.png)'
- en: Figure 8.2 In these histograms of the columns Rating, RatingDeviation, Popularity,
    and NbPlays from the puzzles data frame, all the analyzed variables are skewed.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 在这些来自拼图数据框的Rating、RatingDeviation、Popularity和NbPlays列的直方图中，所有分析的变量都是偏斜的。
- en: 'However, before moving to the next chapter, let’s write the code generating
    the plot in an alternative way as an exercise:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在进入下一章之前，让我们作为一个练习，用另一种方式编写生成图表的代码：
- en: '[PRE32]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The three dots (...) at the end of the code are the splatting operation that
    you learned about in chapter 4\. We need it because the plot function expects
    that the histograms we create are passed as consecutive positional arguments.
    This code shows how you can leverage the fact that you can pass a variable instead
    of an explicit column name when indexing a data frame. Note that in this case,
    I used noncopying access to the data (by applying ! as a row selector) because
    I am sure that I will not modify or store the extracted column (the values are
    used only to produce a plot).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 代码末尾的三个点(...)是你在第4章中学到的散列操作。我们需要它，因为绘图函数期望我们将创建的直方图作为连续的位置参数传递。此代码展示了你如何利用在索引数据框时可以使用变量而不是显式的列名这一事实。请注意，在这种情况下，我使用了非复制访问数据（通过应用!作为行选择器），因为我确信我不会修改或存储提取的列（这些值仅用于生成图表）。
- en: 8.4 Reading and writing data frames using different formats
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.4 使用不同格式读取和写入数据框
- en: In this chapter, you have learned how to read and write CSV files with Julia.
    However, many other data storage formats are used in data science projects. You
    will often want to use these formats when working with data frames in Julia.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经学会了如何使用Julia读取和写入CSV文件。然而，在数据科学项目中，还使用了许多其他数据存储格式。当你在Julia中处理数据框时，你通常会想使用这些格式。
- en: 'Here are some in alphabetical order (in the parentheses, I give names of Julia
    packages that support them): Apache Arrow (Arrow.jl), Apache Avro (Avro.jl), Apache
    Parquet (Parquet.jl), Microsoft Excel (XLSX.jl), JSON (JSON3.jl), MySQL (MySQL.jl),
    PostgreSQL (LibPQ.jl), and SQLite (SQLite.jl). In this section, I’ll show you
    the Arrow.jl and SQLite.jl packages.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些按字母顺序排列的（在括号中，我给出了支持它们的Julia包的名称）：Apache Arrow (Arrow.jl)、Apache Avro (Avro.jl)、Apache
    Parquet (Parquet.jl)、Microsoft Excel (XLSX.jl)、JSON (JSON3.jl)、MySQL (MySQL.jl)、PostgreSQL
    (LibPQ.jl)和SQLite (SQLite.jl)。在本节中，我将向你展示Arrow.jl和SQLite.jl包。
- en: Apache Arrow format is a language-independent columnar memory format, organized
    for efficient analytic operations. This format is gaining popularity because it
    allows data to be transferred between different systems at little or no cost,
    regardless of the programming language used. Apart from these advantages, I picked
    this format to show how Julia allows you to handle data stored in a non-native
    memory format in a transparent manner. You can learn more about this standard
    at [https://arrow.apache.org/](https://arrow.apache.org/).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Arrow格式是一种与语言无关的列式内存格式，旨在进行高效的分析操作。这种格式越来越受欢迎，因为它允许以几乎或没有成本在不同系统之间传输数据，无论使用哪种编程语言。除了这些优点之外，我选择这个格式来展示Julia如何以透明的方式处理存储在非原生内存格式中的数据。你可以在[https://arrow.apache.org/](https://arrow.apache.org/)了解更多关于这个标准的信息。
- en: As a second example, we will use a SQLite database. It is, in my opinion, one
    of the easiest databases to set up and use. It is also, therefore, one of the
    most popular databases used in practice; it is reported that more than one trillion
    (1012) SQLite databases are in active use ([www.sqlite.org/mostdeployed.html](https://www.sqlite.org/mostdeployed.html)).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第二个例子，我们将使用SQLite数据库。在我看来，这是最容易设置和使用的数据库之一。因此，它也是实践中使用最广泛的数据库之一；据报道，有超过一千兆（10^12）个SQLite数据库正在使用中([www.sqlite.org/mostdeployed.html](https://www.sqlite.org/mostdeployed.html))。
- en: For both data formats, I will give you a minimal introduction to how to save
    and load back the puzzles data frame that we worked with in this chapter.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这两种数据格式，我将为您提供一个关于如何保存和加载我们在本章中使用的puzzles数据帧的最小介绍。
- en: 8.4.1 Apache Arrow
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4.1 Apache Arrow
- en: 'We start with saving a data frame in Apache Arrow format. As discussed in chapter
    1, it is supported by such popular frameworks as Apache Parquet, PySpark, and
    Dask. The task is relatively easy; just use the Arrow.write function, passing
    it the filename and data frame you want to save:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从以Apache Arrow格式保存数据帧开始。如第1章所述，它由Apache Parquet、PySpark和Dask等流行框架支持。这项任务相对简单；只需使用Arrow.write函数，传递要保存的文件名和数据帧：
- en: '[PRE33]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'A more interesting process is related to reading the data stored in the Apache
    Arrow format. You first need to create an Arrow.Table object that is then passed
    to the DataFrame constructor. In the code, we check that the object we read back
    is the same as the original puzzles data frame:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更有趣的过程与读取存储在Apache Arrow格式中的数据有关。您首先需要创建一个Arrow.Table对象，然后将它传递给DataFrame构造函数。在代码中，我们检查我们读取回的对象是否与原始puzzles数据帧相同：
- en: '[PRE34]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: ❶ Creates the Arrow.Table object that holds a reference to the source data on
    disk
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个包含对磁盘上源数据引用的Arrow.Table对象
- en: ❷ Constructs a DataFrame from Arrow.Table
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从Arrow.Table构建DataFrame
- en: ❸ Checks that the data frame we’ve created has the same contents as the source
    data frame we used
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 检查我们创建的数据帧与使用的源数据帧具有相同的内容
- en: A distinguishing aspect of the Arrow.Table object is that the columns it stores
    use Apache Arrow format. Also, importantly, the columns in an Arrow.Table are
    views into the original arrow memory.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: Arrow.Table对象的显著特点是它存储的列使用Apache Arrow格式。同样重要的是，Arrow.Table中的列是原始arrow内存的视图。
- en: This has a significant advantage. When creating an Arrow.Table object, the operating
    system does not actually load the entire file contents into RAM at the same time.
    Instead, the file is partially swapped into RAM as different regions of the file
    are requested. This allows for support for working with Apache Arrow data that
    is larger than available RAM. Also, if you need to process only a portion of the
    source table, the process of reading it is much faster, as you fetch only the
    data required.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这有一个显著的优势。当创建Arrow.Table对象时，操作系统不会同时将整个文件内容加载到RAM中。相反，当请求文件的不同区域时，文件的部分内容会被部分交换到RAM中。这允许支持处理大于可用RAM的Apache
    Arrow数据。此外，如果您只需要处理源表的一部分，读取过程会更快，因为您只需获取所需的数据。
- en: 'This design has one downside, however, since this implies that the columns
    having Apache Arrow data format are read-only. Here is an example:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种设计有一个缺点，因为这意味着具有Apache Arrow数据格式的列是只读的。以下是一个例子：
- en: '[PRE35]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note that the puzzles_arrow.PuzzleId column has a nonstandard Arrow.List type,
    and not, for example, a Vector type. This nonstandard vector type is read-only.
    We check this by trying to change an element of such a vector, and we get an error.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，puzzles_arrow.PuzzleId列具有非标准的Arrow.List类型，而不是例如Vector类型。这种非标准向量类型是只读的。我们通过尝试更改此类向量的一个元素来检查这一点，并得到一个错误。
- en: In many applications, having columns of a source data frame that are read-only
    is not a problem, since we might only want to read data from them. However, sometimes
    you might want to mutate vectors stored in a data frame created from an Apache
    Arrow source.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多应用程序中，如果源数据帧的列是只读的，通常没有问题，因为我们可能只想从它们中读取数据。然而，有时您可能希望修改从Apache Arrow源创建的数据帧中存储的向量。
- en: 'In such a case, just copy the data frame. By doing this, you will materialize
    the Apache Arrow columns in RAM and change their types to standard Julia types
    that are mutable. Here is an example:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，只需复制数据帧。通过这样做，您将在RAM中实现Apache Arrow列，并将它们的类型更改为可变的标准Julia类型。以下是一个例子：
- en: '[PRE36]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: After performing a copy operation of a data frame, the :PuzzleId column now
    has a standard Vector type.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行数据帧的复制操作后，:PuzzleId列现在具有标准的Vector类型。
- en: 8.4.2 SQLite
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4.2 SQLite
- en: For Apache Arrow data, we will first create an SQLite database on disk. Next,
    we will store the puzzles data frame in it. Finally, we will read it back using
    the SQL SELECT query.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Apache Arrow数据，我们首先将在磁盘上创建一个SQLite数据库。接下来，我们将存储puzzles数据帧到其中。最后，我们将使用SQL SELECT查询读取它。
- en: 'First, we create an SQLite database that is backed up by a file on disk. Use
    the SQLite.DB function, passing it a filename as an argument:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个由磁盘上的文件支持的SQLite数据库。使用SQLite.DB函数，传递一个文件名作为参数：
- en: '[PRE37]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Next, we store the puzzles data frame in it by using the SQLite.load! function.
    We pass the table we want to store in the database, the connection to a database
    where we want to store it, and the table name in the target database as three
    positional arguments:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用SQLite.load!函数将谜题数据框存储在其中。我们传递三个位置参数：要存储在数据库中的表、我们想要存储数据库的连接以及目标数据库中的表名：
- en: '[PRE38]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let’s check to see if we have successfully created a table in our database.
    We first use the SQLite.tables function to list all tables stored in the database,
    followed by the SQLite.columns function to get more detailed information on columns
    stored in a given table:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下是否已成功在我们的数据库中创建了一个表。我们首先使用SQLite.tables函数列出数据库中存储的所有表，然后使用SQLite.columns函数获取有关给定表中存储的列的更详细信息：
- en: '[PRE39]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We see that there is now one puzzles table in our database. The metadata about
    columns of this table matches the structure of the source puzzles data frame.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到现在数据库中有一个谜题表。关于此表列的元数据与源谜题数据框的结构相匹配。
- en: Finally, we read back the puzzles table into a data frame. As an important first
    step, we need to create a query. We use the DBInterface.execute function, to which
    we pass a connection to a database and a string containing the SQL query we want
    to run. Importantly, this operation is lazy and does not materialize the query.
    The data is fetched only when we need it. In our example, we perform this materialization
    by creating a data frame using the results of the query.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将谜题表读回到一个数据框中。作为一个重要的第一步，我们需要创建一个查询。我们使用DBInterface.execute函数，向其传递一个数据库连接和一个包含我们想要运行的SQL查询的字符串。重要的是，这个操作是惰性的，不会实际化查询。数据只在需要时才被检索。在我们的例子中，我们通过使用查询的结果创建一个数据框来实现这种实际化。
- en: 'Also, note that we are using a generic execute function that is not SQLite
    specific. It is defined in the interface package DBInterface.jl that is automatically
    loaded by SQLite.jl. If we used another database backend, we would also use the
    DBInterface .execute to run SQL queries against it in the same way. After creating
    the data frame, we check that the obtained result is the same as the original
    puzzles data frame:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意我们使用的是一个通用的执行函数，它不是SQLite特有的。该函数定义在由SQLite.jl自动加载的接口包DBInterface.jl中。如果我们使用另一个数据库后端，我们也会使用DBInterface.execute来以相同的方式运行SQL查询。在创建数据框之后，我们检查获得的结果与原始谜题数据框相同：
- en: '[PRE40]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This time, unlike with the Apache Arrow case, the columns of a data frame are
    standard Julia vectors. Let’s check it for the :PuzzleId column:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，与Apache Arrow的情况不同，数据框的列是标准的Julia向量。让我们检查一下:PuzzleId列：
- en: '[PRE41]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'After we are done using the SQLite database, we close it:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 使用完SQLite数据库后，我们需要关闭它：
- en: '[PRE42]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: To learn more about how to work with the Arrow.jl and SQLite.jl packages discussed
    in this section, visit their respective repositories at [https://github.com/apache/arrow-julia](https://github.com/apache/arrow-julia)
    and [https://github.com/JuliaDatabases/SQLite.jl](https://github.com/JuliaDatabases/SQLite.jl).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何使用本节中讨论的Arrow.jl和SQLite.jl包，请访问它们的相应存储库：[https://github.com/apache/arrow-julia](https://github.com/apache/arrow-julia)
    和 [https://github.com/JuliaDatabases/SQLite.jl](https://github.com/JuliaDatabases/SQLite.jl)。
- en: Summary
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: DataFrames.jl is a package that allows you to work with tabular data in Julia.
    The most important type it defines is DataFrame, whose rows typically represent
    observations and whose columns typically represent features of those observations.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DataFrames.jl是一个允许你在Julia中处理表格数据的包。它定义的最重要类型是DataFrame，其行通常表示观测值，而列通常表示这些观测值的特征。
- en: You can use the CodecBzip2.jl package to uncompress bzip2 archives. Similar
    functionality is available in Julia as well as for other compression formats,
    because in real-life applications, you will often need to work with compressed
    data.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用CodecBzip2.jl包解压bzip2存档。在Julia中以及对于其他压缩格式，也有类似的功能，因为在实际应用中，您通常会需要处理压缩数据。
- en: The CSV.read function from the CSV.jl package can be used to read data stored
    in CSV files into a DataFrame. Similarly, the CSV.write function can be used to
    save tabular data to a CSV file. The CSV format is one of the most popular human-readable
    ones, and you can expect to use it often when doing data analysis.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSV.jl包中的CSV.read函数可以用来将存储在CSV文件中的数据读入DataFrame。同样，CSV.write函数可以用来将表格数据保存到CSV文件。CSV格式是最受欢迎的人可读格式之一，您在数据分析时可能会经常使用它。
- en: You can use the describe function to get summary information about a data frame.
    In this way, you can quickly inspect whether the data stored in a data frame follows
    your expectations.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用`describe`函数来获取数据框的摘要信息。通过这种方式，您可以快速检查数据框中存储的数据是否符合您的预期。
- en: The nrow and ncol functions give you information about the number of rows and
    columns of a data frame. Since these functions return a value, they are often
    used when writing code that operates on data frame objects.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nrow`和`ncol`函数为您提供有关数据框行数和列数的信息。由于这些函数返回一个值，因此它们在编写操作数据框对象的代码时经常被使用。'
- en: The names function can be used to get a list of column names in a data frame;
    it additionally accepts a column selector argument that allows you to pass conditions
    specifying the column names you want to get. This feature is especially useful
    when you work with very wide data frames with thousands of columns.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`names`函数可以用来获取数据框中列名的列表；它还接受一个列选择器参数，允许您传递指定要获取的列名的条件。当您处理具有数千列的非常宽的数据框时，此功能特别有用。'
- en: Internally, DataFrame objects store data in columns. Every column of a data
    frame is a vector. This ensures that extracting columns from a data frame is very
    fast.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在内部，`DataFrame`对象按列存储数据。数据框的每一列都是一个向量。这确保了从数据框中提取列非常快速。
- en: You can get a column from a data frame by using the property access syntax (for
    example, puzzles.Rating returns the Rating column). This is one of the most performed
    operations, as it is convenient to type and read.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过使用属性访问语法（例如，`puzzles.Rating`返回`Rating`列）从数据框中获取列。这是最常执行的操作之一，因为它便于输入和阅读。
- en: When referring to columns of a data frame, you can use either strings or symbols;
    therefore, both puzzles."Rating" and puzzles.Rating are valid. Using strings is
    especially useful if your column name contains characters not allowed in identifiers
    in Julia (for example, spaces).
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当引用数据框的列时，您可以使用字符串或符号；因此，`puzzles."Rating"`和`puzzles.Rating`都是有效的。如果您的列名包含Julia中标识符不允许的字符（例如，空格），使用字符串特别有用。
- en: You can use the histogram function from the Plots.jl package to plot histograms
    of your data. This is a useful way to inspect the distribution of your data.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用`Plots.jl`包中的`histogram`函数来绘制数据的直方图。这是一种检查数据分布的有用方法。
- en: The Arrow.jl package allows you to work with data stored in the Apache Arrow
    format. This is often useful when you want to interchange data between different
    data analysis ecosystems or want to work with data that is too large to fit into
    RAM.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Arrow.jl`包允许您使用Apache Arrow格式存储的数据。当您想要在不同数据分析生态系统之间交换数据或处理太大而无法放入RAM的数据时，这通常很有用。'
- en: The SQLite.jl package provides an interface to the SQLite database engine. The
    SQLite database is one of the most popular formats for storing, sharing, and archiving
    your data.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SQLite.jl`包提供了一个到SQLite数据库引擎的接口。SQLite数据库是存储、共享和归档您数据最受欢迎的格式之一。'
