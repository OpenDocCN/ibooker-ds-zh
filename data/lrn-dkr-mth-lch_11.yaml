- en: 10 Running multiple environments with Docker Compose
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 使用 Docker Compose 运行多个环境
- en: We looked at Docker Compose in chapter 7, and you gained a good understanding
    of how to use YAML to describe a multi-container application and manage it with
    the Compose command line. Since then we’ve enhanced our Docker applications to
    get them ready for production with health checks and monitoring. Now it’s time
    to return to Compose, because we don’t need all those production features in every
    environment. Portability is one of Docker’s major benefits. When you package your
    application to run in containers, it works the same way wherever you deploy it,
    and that’s important because it eliminates drift between environments.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第 7 章中探讨了 Docker Compose，并且你对如何使用 YAML 描述多容器应用程序以及如何使用 Compose 命令行来管理它有了很好的理解。从那时起，我们已经增强了我们的
    Docker 应用程序，通过健康检查和监控使它们为生产做好准备。现在，是时候回到 Compose 了，因为我们不需要在每个环境中都使用所有那些生产功能。可移植性是
    Docker 的主要优势之一。当你将应用程序打包到容器中运行时，它在任何部署的地方都以相同的方式工作，这是很重要的，因为它消除了环境之间的 Drift。
- en: Drift is what always happens when manual processes are used to deploy software.
    Some updates get missed or some new dependencies are forgotten, so the production
    environment is different from the user test environment, which is different again
    from the system test environment. When deployments fail, it’s often because of
    drift, and it takes a huge amount of time and effort to track down the missing
    pieces and put them right. Moving to Docker fixes that problem because every application
    is already packaged with its dependencies, but you still need the flexibility
    to support different behavior for different environments. Docker Compose provides
    that with the more advanced features we’ll cover in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Drift 是在手动过程用于部署软件时总会发生的事情。一些更新被遗漏了，或者一些新的依赖项被忘记了，因此生产环境与用户测试环境不同，而系统测试环境又与用户测试环境不同。当部署失败时，通常是因为
    Drift，追踪缺失的部分并纠正它们需要花费大量的时间和精力。转向 Docker 解决了这个问题，因为每个应用程序都已经打包了其依赖项，但你仍然需要灵活性来支持不同环境的不同行为。Docker
    Compose 通过本章将要介绍的高级功能提供了这种灵活性。
- en: 10.1 Deploying many applications with Docker Compose
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1 使用 Docker Compose 部署多个应用程序
- en: Docker Compose is a tool for running multi-container applications on a single
    Docker Engine. It’s great for developers, and it’s also heavily used for non-production
    environments. Organizations often run multiple versions of an app in different
    environments--maybe version 1.5 is running in production, version 1.5.1 is being
    tested in a hotfix environment, version 1.6 is finishing up user testing, and
    version 1.7 is in system test. Those non-production environments don’t need the
    scale and performance of production, so it’s a great use case for Docker Compose
    to run those environments and get maximum utilization from your hardware.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose 是一个在单个 Docker 引擎上运行多容器应用程序的工具。它非常适合开发者，并且在非生产环境中也被广泛使用。组织通常在不同的环境中运行应用程序的多个版本——比如版本
    1.5 在生产环境中运行，版本 1.5.1 在热修复环境中进行测试，版本 1.6 正在完成用户测试，而版本 1.7 正在进行系统测试。这些非生产环境不需要生产环境的规模和性能，因此
    Docker Compose 运行这些环境并从硬件中获得最大利用率是一个很好的用例。
- en: For that to work, there need to be some differences between environments. You
    can’t have several containers trying to listen for traffic on port 80, or writing
    data to the same files on the server. You can design your Docker Compose files
    to support that, but first you need to understand how Compose identifies which
    Docker resources are part of the same application. It does that with naming conventions
    and labels, and if you want to run several copies of the same application, you
    need to work around the defaults.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其工作，环境之间需要有一些差异。不能有多个容器试图监听端口 80 的流量，或者向服务器上的同一文件写入数据。你可以设计你的 Docker Compose
    文件来支持这一点，但首先你需要了解 Compose 如何识别哪些 Docker 资源属于同一应用程序的一部分。它是通过命名约定和标签来做到这一点的，如果你想要运行相同应用程序的多个副本，你需要绕过默认设置。
- en: 'Try it now Open a terminal and browse to the exercises for this chapter. Run
    two of the apps we’ve already worked with, and then try running another instance
    of the to-do list application:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 打开终端并浏览到本章的练习。运行我们已经使用过的两个应用程序，然后尝试运行待办事项应用程序的另一个实例：
- en: '` cd ./ch10/exercises`  ` # run the random number app from chapter 8:` ` docker-compose
    -f ./numbers/docker-compose.yml up -d`  ` # run the to-do list app from chapter
    6:` ` docker-compose -f ./todo-list/docker-compose.yml up -d`  ` # and try another
    copy of the to-do list:` ` docker-compose -f ./todo-list/docker-compose.yml up
    -d`'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '` cd ./ch10/exercises`  ` # 运行第8章中的随机数应用：` ` docker-compose -f ./numbers/docker-compose.yml
    up -d`  ` # 运行第6章中的待办事项列表应用：` ` docker-compose -f ./todo-list/docker-compose.yml
    up -d`  ` # 并尝试另一个待办事项列表的副本：` ` docker-compose -f ./todo-list/docker-compose.yml
    up -d`'
- en: Your output will be the same as mine in figure 10.1\. You can start multiple
    applications from Compose files in different folders, but you can’t start a second
    instance of an application by running `up` from the same folder. Docker Compose
    thinks you’re asking it to run an application that is already running, so it doesn’t
    start any new containers.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你的输出将与我的图10.1中的输出相同。你可以从不同文件夹中的Compose文件启动多个应用，但你不能通过从同一文件夹运行`up`来启动应用的第二个实例。Docker
    Compose认为你要求它运行一个已经运行的应用，因此它不会启动任何新的容器。
- en: '![](../Images/10-1.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1](../Images/10-1.jpg)'
- en: Figure 10.1 Repeating a Docker Compose command to start an app doesn’t run a
    second copy of the app.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 重复执行Docker Compose命令以启动应用不会运行应用的第二个副本。
- en: Docker Compose uses the concept of a project to identify that various resources
    are part of the same application, and it uses the name of the directory that contains
    the Compose file as the default project name. Compose prefixes the project name
    when it creates resources, and for containers it also adds a numeric counter as
    a suffix. So if your Compose file is in a folder called `app1` , and it defines
    one service called `web` and one volume called `disk` , Compose will deploy it
    by creating a volume called `app1_disk` and a container called `app1_web_1` .
    The counter at the end of the container name supports scale, so if you scale that
    up to two instances of the web service, the new container will be called `app1_web_2`
    . Figure 10.2 shows how the container name is built for the to-do list application.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose使用项目概念来识别各种资源是同一应用的一部分，并且它使用包含Compose文件的目录名称作为默认项目名称。当创建资源时，Compose会在项目名称前加前缀，对于容器，它还会添加一个数字计数器作为后缀。所以如果你的Compose文件在一个名为`app1`的文件夹中，并且定义了一个名为`web`的服务和一个名为`disk`的卷，Compose将通过创建一个名为`app1_disk`的卷和一个名为`app1_web_1`的容器来部署它。容器名称末尾的计数器支持扩展，所以如果你将web服务的实例扩展到两个，新的容器将被命名为`app1_web_2`。图10.2显示了待办事项应用容器名称的构建方式。
- en: '![](../Images/10-2.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2](../Images/10-2.jpg)'
- en: Figure 10.2 Docker Compose builds names for the resources it manages by including
    the project name.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 Docker Compose通过包含项目名称为它管理的资源构建名称。
- en: You can override the default project name Compose uses, and that’s how you can
    run many copies of the same application in different sets of containers on a single
    Docker Engine.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以覆盖Docker Compose使用的默认项目名称，这就是你如何在单个Docker Engine上以不同的容器集运行同一应用多个副本的方法。
- en: 'try it now You already have one instance of the to-do app running; you can
    start another by specifying a different project name. The website uses random
    ports, so you’ll need to find the assigned port if you want to actually try the
    apps:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 你已经有一个待办事项应用的实例正在运行；你可以通过指定不同的项目名称来启动另一个。网站使用随机端口，所以如果你想实际尝试这些应用，你需要找到分配的端口：
- en: '` docker-compose -f ./todo-list/docker-compose.yml -p todo-test up -d`  ` docker
    container ls`  ` docker container port todo-test_todo-web_1 80`'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '` docker-compose -f ./todo-list/docker-compose.yml -p todo-test up -d`  ` docker
    container ls`  ` docker container port todo-test_todo-web_1 80`'
- en: My output is in figure 10.3\. Specifying a project name means this is a different
    application as far as Compose is concerned, and there are no resources that match
    this project name, so Compose creates a new container. The naming pattern is predictable,
    so I know the new container will be called `todo-test_todo-web_1` . The Docker
    CLI has the `container` `port` command to find the published port for a container,
    and I can use that with the generated container name to find the application port.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我的输出在图10.3中。指定项目名称意味着在Compose看来这是一个不同的应用，没有资源与这个项目名称匹配，所以Compose创建了一个新的容器。命名模式是可预测的，所以我知道新的容器将被命名为`todo-test_todo-web_1`。Docker
    CLI有`container` `port`命令来查找容器的已发布端口，我可以使用生成的容器名称来查找应用端口。
- en: '![](../Images/10-3.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3](../Images/10-3.jpg)'
- en: Figure 10.3 Specifying a project name lets you run multiple copies of the same
    app with one Compose file.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 指定项目名称允许你使用一个Compose文件运行同一应用的多个副本。
- en: This approach lets you run many copies of many different applications. I could
    deploy another instance of my random number application too, using the same Compose
    file but specifying a different project name. That’s useful, but for most situations
    you’ll want a bit more control--having to find out which random port to use for
    each release isn’t a great workflow for operations or test teams. To support different
    setups in different environments, you could create duplicate Compose files and
    edit the properties that need to change, but Compose has a better way of managing
    that with overrides.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法允许你运行许多不同应用程序的多个副本。我也可以使用相同的 Compose 文件部署我的随机数应用程序的另一个实例，只需指定不同的项目名称即可。这很有用，但对于大多数情况，你可能需要更多的控制——对于运维或测试团队来说，找出每个版本要使用的随机端口并不是一个很好的工作流程。为了支持不同环境中的不同设置，你可以创建重复的
    Compose 文件并编辑需要更改的属性，但 Compose 提供了一种更好的方法来管理覆盖。
- en: 10.2 Using Docker Compose override files
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2 使用 Docker Compose 覆盖文件
- en: Teams hit the problem of trying to run different app configurations with Docker
    Compose and often end up with many Compose files--one for each environment. That
    works, but it’s not maintainable, because those Compose files are often 90% duplicated
    content, which means they’ll get out of sync and you’re back to a drift situation.
    Override files are a much neater approach. Docker Compose lets you merge multiple
    files together, with properties from later files overriding those from earlier
    in the merge.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 团队面临在 Docker Compose 中尝试运行不同的应用程序配置的问题，通常最终会有许多 Compose 文件——每个环境一个。这可以工作，但不可维护，因为这些
    Compose 文件通常是 90% 的重复内容，这意味着它们会失去同步，你又会回到漂移状态。覆盖文件是一种更整洁的方法。Docker Compose 允许你合并多个文件，其中较后文件中的属性会覆盖合并中较早的属性。
- en: Figure 10.4 shows how you can use overrides to structure an easily maintainable
    set of Compose files. You start with a core `docker-compose.yml` file that contains
    the basic structure of the app, with the services defined and configured with
    properties that are common for all environments. Then each environment has its
    own override file that adds specific settings, but it doesn’t duplicate any of
    the configuration from the core file.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4 展示了如何使用覆盖来构建一组易于维护的 Compose 文件。你从一个包含应用基本结构的核心 `docker-compose.yml` 文件开始，其中定义并配置了适用于所有环境的通用服务属性。然后每个环境都有自己的覆盖文件，它添加了特定的设置，但不会复制核心文件中的任何配置。
- en: '![](../Images/10-4.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/10-4.jpg)'
- en: Figure 10.4 Removing duplication with override files that add environment-specific
    settings
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4 使用添加环境特定设置的覆盖文件消除重复
- en: This approach is maintainable. If you need to make a change that applies to
    all environments--like changing an image tag to use the latest version--you do
    that once in the core file, and it filters through to every environment. If you
    just need to change one environment, you only change that single file. The override
    files you have for each environment also serve as clear documentation of the differences
    between environments.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法是可维护的。如果你需要做出适用于所有环境的更改——比如更改镜像标签以使用最新版本——你只需在核心文件中做一次更改，它就会过滤到每个环境。如果你只需要更改一个环境，你只需更改那个单一文件。每个环境拥有的覆盖文件也充当了环境之间差异的清晰文档。
- en: Listing 10.1 shows a very simple example where the core Compose file specifies
    most of the application properties, and the override changes the image tag so
    this deployment will use v2 of the to-do app.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.1 展示了一个非常简单的示例，其中核心 Compose 文件指定了大多数应用程序属性，而覆盖则更改了镜像标签，因此这次部署将使用待办事项应用程序的
    v2 版本。
- en: Listing 10.1 A Docker Compose override file that updates a single property
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.1 一个更新单个属性的 Docker Compose 覆盖文件
- en: '` # from docker-compose.yml - the core app specification:` ` services:` `   todo-web:`
    `       image: diamol/ch06-todo-list` `       ports:` `           - 80` `       environment:`
    `           - Database:Provider=Sqlite` `       networks:` `           - app-net` 
    ` # and from docker-compose-v2.yml - the version override file:` ` services:`
    `   todo-web:` `         image: diamol/ch06-todo-list:v2`'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '` # 来自 docker-compose.yml - 核心应用程序规范:` ` services:` `   todo-web:` `       image:
    diamol/ch06-todo-list` `       ports:` `           - 80` `       environment:`
    `           - Database:Provider=Sqlite` `       networks:` `           - app-net` 
    ` # 来自 docker-compose-v2.yml - 版本覆盖文件:` ` services:` `   todo-web:` `         image:
    diamol/ch06-todo-list:v2`'
- en: In the override file you just specify the properties you care about, but you
    need to preserve the structure of the main Compose file so that Docker Compose
    can link the definitions together. The override file in this example only changes
    the value of the `image` property, but that needs to be specified in the `todo-web`
    block under the `services` block, so Compose can match that to the full service
    definition in the core file.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在覆盖文件中，你只需指定你关心的属性，但需要保留主Compose文件的结构，以便Docker Compose可以将定义链接在一起。本例中的覆盖文件仅更改`image`属性的值，但需要在`services`块下的`todo-web`块中指定，以便Compose可以将其与核心文件中的完整服务定义相匹配。
- en: Docker Compose merges files together when you specify multiple file paths in
    `docker-compose` commands. The `config` command is very useful here--it validates
    the contents of the input files, and if the input is valid, it writes out the
    final output. You can use that to see what will happen when you apply an override
    file.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在`docker-compose`命令中指定多个文件路径时，Docker Compose会合并文件。`config`命令在这里非常有用--它验证输入文件的内容，如果输入有效，则输出最终结果。你可以使用它来查看应用覆盖文件时会发生什么。
- en: 'try it now In the exercises folder for this chapter, use Docker Compose to
    merge together the files from listing 10.1 and print the output:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看 在本章的练习文件夹中，使用Docker Compose合并列表10.1中的文件并打印输出：
- en: '` docker-compose -f ./todo-list/docker-compose.yml -f ./todo-list/docker-compose-v2.yml
    config`'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose -f ./todo-list/docker-compose.yml -f ./todo-list/docker-compose-v2.yml
    config`'
- en: The `config` command doesn’t actually deploy the app; it just validates the
    configuration. You’ll see in the output that the two files have been merged. All
    the properties come from the core Docker Compose file, except the `image` tag
    where the value has been overridden from the second file--you can see that in
    figure 10.5.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`config` 命令实际上并不部署应用程序；它只是验证配置。你会在输出中看到两个文件已经被合并。所有属性都来自核心Docker Compose文件，除了`image`标签，其值已被第二个文件覆盖--你可以在图10.5中看到这一点。'
- en: '![](../Images/10-5.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/10-5.jpg)'
- en: Figure 10.5 Merging a Compose file with an override file and displaying the
    output
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 合并Compose文件与覆盖文件并显示输出
- en: Docker Compose applies overrides in the order that the files are listed in the
    command, with files to the right overriding files to the left. That’s important,
    because if you get the order wrong, you’ll get unexpected results--the `config`
    command is useful here because it shows you a dry run of the complete Compose
    file. The output sorts everything by alphabetical order, so you’ll see networks,
    then services, then the Compose version number, which is unsettling at first,
    but useful. You could automate that command as part of your deployment process
    and commit the merged files to source control--then the alphabetical order makes
    it easy to compare releases.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose按照命令中文件列表的顺序应用覆盖，右侧的文件覆盖左侧的文件。这很重要，因为如果你顺序错误，你会得到意外的结果--`config`命令在这里很有用，因为它显示了完整的Compose文件的预览。输出按字母顺序排序，所以你会看到网络、然后是服务、然后是Compose版本号，一开始可能会感到不安，但很有用。你可以将此命令作为部署过程的一部分进行自动化，并将合并后的文件提交到源代码控制中--这样按字母顺序比较版本就变得容易了。
- en: 'Using overrides for an image tag is just a quick example. There’s a more realistic
    set of compose files for the random number application in the `numbers` folder:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用覆盖来更改图像标签只是一个快速示例。在`numbers`文件夹中有一个更现实的随机数应用程序的Compose文件集：
- en: '`docker-compose.yml` --The core application definition. It specifies the web
    and API services without any ports or network definitions.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker-compose.yml` -- 核心应用程序定义。它指定了Web和API服务，但没有指定任何端口或网络定义。'
- en: '`docker-compose-dev.yml` --For running the app in development. It specifies
    a Docker network and for the services it adds the ports to publish and disables
    the health and dependency checks. This is so developers can be up and running
    quickly.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker-compose-dev.yml` -- 用于在开发中运行应用程序。它指定了一个Docker网络，并为服务添加了发布端口，并禁用了健康和依赖性检查。这样开发者可以快速启动和运行。'
- en: '`docker-compose-test.yml` --For running in a test environment. This specifies
    a network, adds health check parameters, and publishes a port for the web app,
    but it keeps the API service internal by not publishing any ports.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker-compose-test.yml` -- 用于在测试环境中运行。它指定了一个网络，添加了健康检查参数，并为Web应用程序发布了一个端口，但通过不发布任何端口，保持了API服务的内部性。'
- en: '`docker-compose-uat.yml` --For the User Acceptance Test environment. This specifies
    a network, publishes standard port 80 for the website, sets the services to always
    restart, and specifies more stringent health check parameters.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker-compose-uat.yml` -- 用于用户验收测试环境。它指定了一个网络，发布标准端口 80 用于网站，设置服务始终重启，并指定更严格的健康检查参数。'
- en: Listing 10.2 shows the contents of the dev override file--it’s very clear that
    it isn’t a full app specification because no images are specified. The values
    in here will be merged into the core Compose file, adding new properties or overriding
    existing properties if there are matching keys in the core file.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.2 显示了开发覆盖文件的内容——很明显，它不是一个完整的应用程序规范，因为没有指定镜像。这里的值将被合并到核心 Compose 文件中，如果核心文件中有匹配的键，则会添加新的属性或覆盖现有的属性。
- en: Listing 10.2 An override file only specifies changes from the main Compose file
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.2 一个覆盖文件仅指定了与主 Compose 文件的不同之处
- en: '` services:` `   numbers-api:` `       ports:` `           - "8087:80"` `       healthcheck:`
    `           disable: true`  `   numbers-web:` `       entrypoint:` `           -
    dotnet` `           - Numbers.Web.dll` `       ports:` `           - "8088:80"` 
    ` networks:` `   app-net:` `         name: numbers-dev`'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '` services:` `   numbers-api:` `       ports:` `           - "8087:80"` `       healthcheck:`
    `           disable: true`  `   numbers-web:` `       entrypoint:` `           -
    dotnet` `           - Numbers.Web.dll` `       ports:` `           - "8088:80"` 
    ` networks:` `   app-net:` `         name: numbers-dev`'
- en: The other override files follow the same pattern. Each environment uses different
    ports for the web application and the API so you can run them all on a single
    machine.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 其他覆盖文件遵循相同的模式。每个环境使用不同的端口来运行 Web 应用和 API，因此可以在单个机器上运行所有这些应用。
- en: 'try it now Start by removing all your existing containers, and then run the
    random number app in multiple environments. Each environment needs a project name
    and the correct set of Compose files:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下：首先删除所有现有的容器，然后在多个环境中运行随机数应用。每个环境需要一个项目名称和正确的 Compose 文件集：
- en: '` # remove any existing containers` ` docker container rm -f $(docker container
    ls -aq)`  ` # run the app in dev configuration:` ` docker-compose -f ./numbers/docker-compose.yml
    -f ./numbers/docker-compose-dev.yml -p numbers-dev up -d`  ` # and the test setup:`
    ` docker-compose -f ./numbers/docker-compose.yml -f ./numbers/docker-compose-test.yml
    -p numbers-test up -d`  ` # and UAT:` ` docker-compose -f ./numbers/docker-compose.yml
    -f ./numbers/docker-compose-uat.yml -p numbers-uat up -d`'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '` # 删除任何现有容器` ` docker container rm -f $(docker container ls -aq)`  ` # 在开发配置下运行应用：`
    ` docker-compose -f ./numbers/docker-compose.yml -f ./numbers/docker-compose-dev.yml
    -p numbers-dev up -d`  ` # 以及测试设置：` ` docker-compose -f ./numbers/docker-compose.yml
    -f ./numbers/docker-compose-test.yml -p numbers-test up -d`  ` # 以及 UAT：` ` docker-compose
    -f ./numbers/docker-compose.yml -f ./numbers/docker-compose-uat.yml -p numbers-uat
    up -d`'
- en: Now you have three copies of the application running, which are all isolated
    from each other because each deployment is using its own Docker network. In an
    organization, these would be running on one server, and teams would use the environment
    they want by browsing to the correct port. For example, you could use port 80
    for UAT, port 8080 for system test, and port 8088 for the development team’s integration
    environment. Figure 10.6 shows my output with networks and containers being created.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你有三个应用程序副本正在运行，它们彼此之间都是隔离的，因为每个部署都在使用自己的 Docker 网络。在一个组织中，这些应用将运行在一台服务器上，团队可以通过浏览到正确的端口来使用他们想要的任何环境。例如，你可以使用端口
    80 进行 UAT，端口 8080 进行系统测试，端口 8088 用于开发团队的集成环境。图 10.6 显示了我的输出，其中包含了创建的网络和容器。
- en: '![](../Images/10-6.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.6](../Images/10-6.jpg)'
- en: Figure 10.6 Running multiple isolated application environments in containers
    on a single machine
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6 在单个机器上运行多个隔离的应用程序环境
- en: 'Now you have three deployments that function as separate environments: http:
    */ /* localhost is UAT, http: */ /* localhost:8080 is system test, and *http://localhost:8088*
    is the dev environment. Browse to any of those, and you’ll see the same application,
    but each web container can only see the API container in its own network. This
    keeps the apps separate, so if you keep fetching random numbers in the dev environment,
    the API will break, but the system test and UAT environments are still working.
    The containers in each environment use DNS names to communicate, but Docker restricts
    traffic within the container network. Figure 10.7 shows how network isolation
    keeps all your environments separate.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '现在你有三个部署，它们作为独立的环境运行：http: */ /* localhost是UAT，http: */ /* localhost:8080是系统测试，而*http://localhost:8088*是开发环境。浏览到任何一个，你都会看到相同的应用，但每个Web容器只能看到其网络中的API容器。这保持了应用的分离，所以如果你在开发环境中持续获取随机数字，API将会崩溃，但系统测试和UAT环境仍然在运行。每个环境中的容器使用DNS名称进行通信，但Docker限制了容器网络内的流量。图10.7展示了网络隔离如何保持所有环境分离。'
- en: '![](../Images/10-7.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10-7.jpg)'
- en: Figure 10.7 Running multiple environments on one Docker Engine, using networks
    for isolation
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7 在一个Docker Engine上运行多个环境，使用网络进行隔离
- en: It’s time to remind you that Docker Compose is a client-side tool, and you need
    access to all your Compose files to manage your apps. You also need to remember
    the project names you used. If you want to clear down the test environment, removing
    containers and the network, you would normally just run `docker-compose` `down`
    , but that won’t work for these environments because Compose needs all the same
    file and project information you used in the `up` command to match the resources.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候提醒你了，Docker Compose是一个客户端工具，你需要访问所有你的Compose文件来管理你的应用。你还需要记住你使用的项目名称。如果你想清除测试环境，移除容器和网络，你通常会只运行`docker-compose
    down`，但这对这些环境不起作用，因为Compose需要你在`up`命令中使用的所有相同文件和项目信息来匹配资源。
- en: 'try it now Let’s remove that test environment. You can try different variations
    on the `down` command, but the only one that will work is the one that has the
    same file list and project name as the original `up` command:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 让我们移除那个测试环境。你可以尝试不同的`down`命令变体，但唯一能工作的是具有与原始`up`命令相同文件列表和项目名称的那个：
- en: '` # this would work if we''d used the default docker-compose.yml file:` ` docker-compose
    down`  ` # this would work if we''d used override files without a project name:`
    ` docker-compose -f ./numbers/docker-compose.yml -f ./numbers/docker-compose-test.yml
    down`  ` # but we specified a project name, so we need to include that too:` ` docker-compose
    -f ./numbers/docker-compose.yml -f ./numbers/docker-compose-test.yml -p numbers-test
    down`'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '` # 如果我们使用了默认的docker-compose.yml文件，这将有效：` ` docker-compose down`  ` # 如果我们使用了没有项目名称的覆盖文件，这将有效：`
    ` docker-compose -f ./numbers/docker-compose.yml -f ./numbers/docker-compose-test.yml
    down`  ` # 但我们指定了项目名称，所以我们也需要包含它：` ` docker-compose -f ./numbers/docker-compose.yml
    -f ./numbers/docker-compose-test.yml -p numbers-test down`'
- en: You can see my output in figure 10.8\. You might have guessed that Compose can’t
    identify the running resources for the application unless you provide the matching
    file and project name, so in the first command it doesn’t remove anything. In
    the second command, Compose does try to delete the container network, even though
    there are application containers connected to that network.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在图10.8中看到我的输出。你可能已经猜到，除非你提供匹配的文件和项目名称，否则Compose无法识别应用的运行资源，所以在第一个命令中它不会删除任何内容。在第二个命令中，Compose确实尝试删除连接到该网络的容器网络。
- en: '![](../Images/10-8.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10-8.jpg)'
- en: Figure 10.8 You need to use the same files and project name to manage an application
    with Compose.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8 你需要使用相同的文件和项目名称来使用Compose管理应用。
- en: Those errors happened because the networks were explicitly named in the Compose
    override files. I didn’t specify a project name in the second `down` command,
    so it used the default, which is the folder name `numbers` . Compose looked for
    containers called `numbers_numbers-web_1` and `numbers_numbers-api_1` , but didn’t
    find them because they were actually created with the project prefix `numbers-test`
    . Compose thought those containers were already gone and it only needed to clean
    up the network, which it did find because the explicit network name in the Compose
    file is used without a project prefix. Compose tried to remove that network, but
    fortunately Docker won’t let you remove networks that still have containers attached.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 那些错误发生是因为在 Compose 覆盖文件中明确命名了网络。我在第二个 `down` 命令中没有指定项目名称，所以它使用了默认值，即文件夹名称 `numbers`。Compose
    寻找名为 `numbers_numbers-web_1` 和 `numbers_numbers-api_1` 的容器，但找不到它们，因为它们实际上是使用项目前缀
    `numbers-test` 创建的。Compose 认为那些容器已经不存在了，它只需要清理网络，而它确实找到了，因为 Compose 文件中的显式网络名称没有使用项目前缀。Compose
    尝试删除那个网络，但幸运的是，Docker 不允许你删除仍有容器附加的网络。
- en: This is a long way of showing you that you need to take care with Docker Compose.
    It’s an excellent tool for non-production environments, where it gets you maximum
    value from your compute resources by deploying tens or hundreds of applications
    on single machines. Override files let you reuse application definitions and identify
    the differences between environments, but you need to be aware of the management
    overhead. You should look at scripting and automation for your deployments and
    teardowns.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种长篇大论的方式来告诉你，你需要小心使用 Docker Compose。它是一个非生产环境中的优秀工具，通过在单台机器上部署成百上千的应用程序，使你从计算资源中获得最大价值。覆盖文件让你可以重用应用程序定义并识别不同环境之间的差异，但你需要注意管理开销。你应该考虑为你的部署和拆卸编写脚本和自动化。
- en: 10.3 Injecting configuration with environment variables and secrets
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3 使用环境变量和密钥注入配置
- en: You can isolate applications using Docker networks and capture the differences
    between environments with Compose overrides, but you’ll also need to change the
    application configuration between environments. Most applications can read configuration
    settings from environment variables or files, and Compose has good support for
    both those approaches.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 Docker 网络隔离应用程序，并使用 Compose 覆盖来捕捉环境之间的差异，但你还需要在不同环境之间更改应用程序配置。大多数应用程序可以从环境变量或文件中读取配置设置，而
    Compose 对这两种方法都有良好的支持。
- en: I’ll cover all the options in this section, so we’ll dig a bit deeper into Compose
    than we have so far. This will help you understand the choices you have for applying
    configuration settings, and you’ll be able to select what works for you.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在本节中涵盖所有选项，所以我们将比之前更深入地研究 Compose。这将帮助你了解你可以选择的配置设置应用选项，你将能够选择适合你的选项。
- en: 'It’s back to the to-do app for these exercises. The Docker image for the app
    is built to read environment variables and files for configuration settings. There
    are three items that need to vary between environments:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这些练习又回到了待办事项应用。该应用的 Docker 镜像被构建为读取环境变量和配置设置所需的文件。有三个项目需要在不同环境之间进行变化：
- en: Logging --How detailed the logging level should be. This will start off being
    very verbose in the dev environment and become less so in test and production.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录--日志详细程度应该有多详细。这将在开发环境中非常详细，在测试和生产环境中则不那么详细。
- en: Database provider --Whether to use a simple data file inside the application
    container, or a separate database (which may or may not be running in a container).
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库提供者--是否在应用程序容器内部使用简单的数据文件，或者使用单独的数据库（该数据库可能或可能不在容器中运行）。
- en: Database connection string --The details for connecting to the database, if
    the app isn’t using a local data file.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库连接字符串--如果应用程序不使用本地数据文件，连接到数据库的详细信息。
- en: I’m using override files to inject configuration for different environments,
    and I’m using different approaches for each item, so I can show you the options
    Docker Compose has. Listing 10.3 shows the core Compose file; this just has the
    basic information for the web application with a configuration file set up as
    a secret.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用覆盖文件为不同的环境注入配置，并且为每个项目使用不同的方法，这样我可以向你展示 Docker Compose 提供的选项。列表 10.3 展示了核心的
    Compose 文件；这只是一个设置了作为密钥的配置文件的 Web 应用程序的基本信息。
- en: Listing 10.3 The Compose file specifies the web service with a secret
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.3 Compose 文件指定了带有密钥的 Web 服务
- en: '` services:` `   todo-web:` `       image: diamol/ch06-todo-list` `       secrets:`
    `           - source: todo-db-connection` `                 target: /app/config/secrets.json`'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`services:` `   todo-web:` `       image: diamol/ch06-todo-list` `       secrets:`
    `           - source: todo-db-connection` `                 target: /app/config/secrets.json`'
- en: Secrets are a useful way of injecting configuration--they have support in Docker
    Compose, Docker Swarm, and Kubernetes. In the Compose file you specify the source
    and target for the secret. The source is the place where the secret is loaded
    from the container runtime, and the target is the file path where the secret is
    surfaced inside the container.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥是一种有用的注入配置的方式——它们在 Docker Compose、Docker Swarm 和 Kubernetes 中都有支持。在 Compose
    文件中，你指定密钥的源和目标。源是从容器运行时加载密钥的地方，而目标是密钥在容器内部暴露的文件路径。
- en: This secret is specified as coming from the source `todo-db-connection` , which
    means there needs to be a secret with that name defined in the Compose file. The
    contents of the secret will be loaded into the container at the target path `/app/config/
    secrets.json` , which is one of the locations the application searches for configuration
    settings.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此密钥指定为来自源 `todo-db-connection`，这意味着在 Compose 文件中需要定义具有该名称的密钥。密钥的内容将被加载到目标路径
    `/app/config/secrets.json`，这是应用程序搜索配置设置的位置之一。
- en: The preceding Compose file on its own isn’t valid because there is no secrets
    section, and the `todo-db-connection` secret is required because it’s used in
    the service definition. Listing 10.4 shows the override file for development,
    which sets up some more configuration for the service and specifies the secret.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 上述 Compose 文件本身是无效的，因为没有密钥部分，而 `todo-db-connection` 密钥在服务定义中是必需的。列表 10.4 展示了开发覆盖文件，它为服务设置了一些更多的配置并指定了密钥。
- en: Listing 10.4 The development override adds config settings and the secret setup
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.4 开发覆盖文件添加了配置设置和密钥设置
- en: '` services:` `   todo-web:` `       ports:` `           - 8089:80` `       environment:`
    `           - Database:Provider=Sqlite` `       env_file:` `           - ./config/logging.debug.env` 
    ` secrets:` `   todo-db-connection:` `         file: ./config/empty.json`'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '` services:` `   todo-web:` `       ports:` `           - 8089:80` `       environment:`
    `           - Database:Provider=Sqlite` `       env_file:` `           - ./config/logging.debug.env` 
    ` secrets:` `   todo-db-connection:` `         file: ./config/empty.json`'
- en: 'There are three properties in this override file that inject application configuration
    and change the behavior of the app in the container. You can use any combination
    of them, but each approach has benefits:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在此覆盖文件中有三个属性，用于注入应用程序配置并改变容器中应用程序的行为。你可以使用它们的任何组合，但每种方法都有其优点：
- en: '`environment` adds an environment variable inside the container. This setting
    configures the app to use the SQLite database, which is a simple data file. This
    is the easiest way to set configuration values, and it’s clear from the Compose
    file what’s being configured.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`environment` 在容器内添加一个环境变量。此设置配置应用程序使用 SQLite 数据库，这是一个简单的数据文件。这是设置配置值的最简单方式，从
    Compose 文件中可以清楚地看到正在配置的内容。'
- en: '`env_file` contains the path to a text file, and the contents of the text file
    will be loaded into the container as environment variables. Each line in the text
    file is read as an environment variable, with the name and value separated by
    an equals sign. The contents of this file set the logging configuration. Using
    an environment variable file is a simple way to share settings between multiple
    components, because each component references the file rather than duplicates
    a list of environment variables.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`env_file` 包含一个文本文件的路径，文本文件的内容将被加载到容器中作为环境变量。文本文件中的每一行都被读取为一个环境变量，名称和值由等号分隔。此文件的内容设置了日志配置。使用环境变量文件是共享多个组件设置的一种简单方式，因为每个组件都引用该文件而不是复制环境变量列表。'
- en: '`secrets` is a top-level resource in the Compose YAML file, like `services`
    and `networks` . It contains the actual source of `todo-db-connection` , which
    is a file on the local filesystem. In this case, there’s no separate database
    for the app to connect to, so it uses an empty JSON file for the secret. The app
    will read the file, but there are no configuration settings to apply.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`secrets` 是 Compose YAML 文件中的顶级资源，类似于 `services` 和 `networks`。它包含 `todo-db-connection`
    的实际源，这是一个本地文件系统上的文件。在这种情况下，应用程序没有单独的数据库要连接，因此它使用一个空的 JSON 文件作为密钥。应用程序将读取该文件，但没有配置设置要应用。'
- en: 'try it now You can run the app in development configuration using the Compose
    file and the override in the `todo-list-configured` directory. Send a request
    into the web app with curl and check that the container is logging lots of detail:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看。你可以使用 Compose 文件和 `todo-list-configured` 目录中的覆盖配置来以开发配置运行应用。使用 curl 向
    Web 应用发送请求并检查容器是否正在记录大量详细信息：
- en: '` # remove existing containers:` ` docker container rm -f $(docker container
    ls -aq)`  ` # bring up the app with config overrides - for Linux containers:`
    ` docker-compose -f ./todo-list-configured/docker-compose.yml -f ./todo-list-configured/docker-compose-dev.yml
    -p todo-dev up -d`  ` # OR for Windows container, which use different file paths
    for secrets:` ` docker-compose -f ./todo-list-configured/docker-compose.yml -f
    ./todo-list-configured/docker-compose-dev.yml -f ./todo-list-configured/docker-compose-dev-windows.yml
    -p todo-dev up -d`  ` # send some traffic into the app:` ` curl http://localhost:8089/list` 
    ` # check the logs:` ` docker container logs --tail 4 todo-dev_todo-web_1`'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '` # 移除现有容器:` ` docker container rm -f $(docker container ls -aq)` ` # 使用配置覆盖启动应用
    - 对于 Linux 容器:` ` docker-compose -f ./todo-list-configured/docker-compose.yml
    -f ./todo-list-configured/docker-compose-dev.yml -p todo-dev up -d` ` # 或者对于 Windows
    容器，使用不同的文件路径存储密钥:` ` docker-compose -f ./todo-list-configured/docker-compose.yml
    -f ./todo-list-configured/docker-compose-dev.yml -f ./todo-list-configured/docker-compose-dev-windows.yml
    -p todo-dev up -d` ` # 向应用发送一些流量:` ` curl http://localhost:8089/list` ` # 检查日志:`
    ` docker container logs --tail 4 todo-dev_todo-web_1`'
- en: You can see my output in figure 10.9\. Docker Compose always uses a network
    for each application, so it creates a default network and connects containers
    to it even if there’s no network specified in the Compose files. In my case, the
    latest log lines show the SQL database command the app uses. Yours might show
    something different, but if you check through the whole logs, you should see the
    SQL statements in there. That shows the enhanced logging configuration is in place.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在图 10.9 中看到我的输出。Docker Compose 总是为每个应用程序使用一个网络，因此它会创建一个默认网络并将容器连接到它，即使 Compose
    文件中没有指定网络。在我的情况下，最新的日志行显示了应用程序使用的 SQL 数据库命令。你的输出可能不同，但如果你检查整个日志，你应该会看到 SQL 语句。这表明增强了日志配置。
- en: The developer deployment uses environment variables and secrets for app configuration--the
    values specified in the Compose files and the config files get loaded into the
    container.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者部署使用环境变量和密钥进行应用配置--在 Compose 文件和配置文件中指定的值被加载到容器中。
- en: 'There’s also a test deployment that uses another approach supported by Compose:
    using environment variables on the host machine to provide values for the container.
    This makes the deployment more portable, because you can alter environments without
    changing the Compose files themselves. That’s useful if you want to spin up a
    second test environment on a different server with a different configuration.
    Listing 10.5 shows that in the specification for the `todo-web` service.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个使用另一种由 Compose 支持的方法的测试部署：使用主机机器上的环境变量为容器提供值。这使得部署更加便携，因为你可以更改环境而无需更改
    Compose 文件本身。如果你想在配置不同的服务器上启动第二个测试环境，这将非常有用。列表 10.5 展示了 `todo-web` 服务的规范。
- en: Listing 10.5 Using environment variables as values in Compose files
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.5 在 Compose 文件中使用环境变量作为值
- en: '`   todo-web:` `       ports:` `           - "${TODO_WEB_PORT}:80"` `       environment:`
    `           - Database:Provider=Postgres` `       env_file:` `           - ./config/logging.information.env`
    `       networks:` `             - app-net`'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`   todo-web:` `       ports:` `           - "${TODO_WEB_PORT}:80"` `       environment:`
    `           - Database:Provider=Postgres` `       env_file:` `           - ./config/logging.information.env`
    `       networks:` `             - app-net`'
- en: The dollar-and-curly-brace setting for the port gets replaced from the environment
    variable with that name. So if I have a variable set on the machine where I’m
    running Docker Compose with the name `TODO_WEB_PORT` and the value `8877` , then
    Compose injects that value, and the port specification actually becomes `"8877:80"`
    . This service specification is in the file `docker-compose-test.yml` , which
    also includes a service for the database and a secret to use for the connection
    to the database container.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 端口的美元和花括号设置会被替换为具有该名称的环境变量。所以如果我在运行 Docker Compose 的机器上设置了一个名为 `TODO_WEB_PORT`
    的变量，其值为 `8877`，那么 Compose 会注入这个值，端口规范实际上变为 `"8877:80"`。这个服务规范在文件 `docker-compose-test.yml`
    中，该文件还包括一个数据库服务和一个用于连接数据库容器的密钥。
- en: '![](../Images/10-9.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10-9.jpg)'
- en: Figure 10.9 Changing application behavior by applying configuration settings
    in Docker Compose
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9 通过在Docker Compose中应用配置设置来更改应用程序行为
- en: You can run the test environment by specifying the Compose files and project
    name in the same way as for the development environment, but there’s one final
    configuration feature of Compose that makes things easier. If Compose finds a
    file called `.env` in the current folder, it will treat that as an environment
    file and read the contents as a set of environment variables, populating them
    before it runs the command.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过与开发环境相同的方式指定Compose文件和项目名称来运行测试环境，但Compose有一个使事情更简单的最终配置功能。如果Compose在当前文件夹中找到一个名为`.env`的文件，它将将其视为环境文件，并在运行命令之前读取其内容作为一组环境变量，填充它们。
- en: 'Try it now Navigate to the directory for the configured to-do list application,
    and run it without specifying any parameters to Docker Compose:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 导航到配置好的待办事项应用程序的目录，并运行它，无需向Docker Compose指定任何参数：
- en: '` cd ./todo-list-configured`  ` # OR for Windows containers - using different
    file paths:` ` cd ./todo-list-configured-windows`  ` docker-compose up -d`'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '` cd ./todo-list-configured`  ` # 或者对于Windows容器 - 使用不同的文件路径：` ` cd ./todo-list-configured-windows` 
    ` docker-compose up -d`'
- en: Figure 10.10 shows that Compose has created web and database containers, although
    the core Compose file doesn’t specify a database service. It also used the project
    name `todo_ch10` , although I didn’t specify a name. The `.env` file sets up the
    Compose configuration to run the test environment by default, without you needing
    to specify the test override file.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10显示，Compose已创建了Web和数据库容器，尽管核心Compose文件没有指定数据库服务。它还使用了项目名称`todo_ch10`，尽管我没有指定名称。`.env`文件设置Compose配置以默认运行测试环境，无需你指定测试覆盖文件。
- en: '![](../Images/10-10.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/10-10.jpg)'
- en: Figure 10.10 Using an environment file to specify the default for Docker Compose
    files and project names
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10 使用环境文件指定Docker Compose文件和项目名称的默认值
- en: You can use a simple command here without specifying a filename, because the
    `.env` file contains a set of environment variables that can be used to configure
    Docker Compose. The first use is for container configuration settings, like the
    port for the web application; the second is for the Compose command itself, listing
    the files to use and the project name. Listing 10.6 shows the `.env` file in full.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以使用一个简单的命令而不指定文件名，因为`.env`文件包含了一组环境变量，这些变量可以用来配置Docker Compose。第一次使用是用于容器配置设置，例如Web应用的端口；第二次是用于Compose命令本身，列出要使用的文件和项目名称。列表10.6显示了完整的`.env`文件。
- en: Listing 10.6 Configuring containers and Compose using an environment file
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.6 使用环境文件配置容器和Compose
- en: '` # container configuration - ports to publish:` ` TODO_WEB_PORT=8877` ` TODO_DB_PORT=5432` 
    ` # compose configuration - files and project name:` ` COMPOSE_PATH_SEPARATOR=;`
    ` COMPOSE_FILE=docker-compose.yml;docker-compose-test.yml` ` COMPOSE_PROJECT_NAME=todo_ch10`'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '` # 容器配置 - 发布的端口：` ` TODO_WEB_PORT=8877` ` TODO_DB_PORT=5432`  ` # Compose配置
    - 文件和项目名称：` ` COMPOSE_PATH_SEPARATOR=;` ` COMPOSE_FILE=docker-compose.yml;docker-compose-test.yml`
    ` COMPOSE_PROJECT_NAME=todo_ch10`'
- en: The environment file captures the default Compose settings for the app in the
    test configuration--you could easily modify it so the development configuration
    was the default. Keeping an environment file alongside your Compose files helps
    to document which sets of files represent which environment, but be aware that
    Docker Compose only looks for a file called `.env` . You can’t specify a filename,
    so you can’t easily switch between environments with multiple environment files.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 环境文件捕获了测试配置中应用程序的默认Compose设置--你可以轻松地修改它，以便开发配置成为默认设置。将环境文件与你的Compose文件一起保存有助于记录哪些文件集代表哪个环境，但请注意，Docker
    Compose只寻找名为`.env`的文件。你不能指定文件名，因此你不能轻松地在多个环境文件之间切换。
- en: 'Touring the configuration options in Docker Compose has taken us a little while.
    You’ll be working with a lot of Compose files in your time with Docker, so you
    need to be familiar with all the options. I’ll summarize them all here, but some
    are more useful than others:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 探索Docker Compose的配置选项花了一些时间。在你的Docker使用过程中，你将处理很多Compose文件，所以你需要熟悉所有选项。我将在这里总结它们，但其中一些比其他更有用：
- en: Using the `environment` property to specify environment variables is the simplest
    option, and it makes your application configuration easy to read from the Compose
    file. Those settings are in plain text, though, so you shouldn’t use them for
    sensitive data like connection strings or API keys.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `environment` 属性来指定环境变量是最简单的选项，它使得从 Compose 文件中读取应用程序配置变得容易。然而，这些设置是纯文本，因此你不应该将它们用于敏感数据，如连接字符串或
    API 密钥。
- en: Loading configuration files with `secret` properties is the most flexible option,
    because it’s supported by all the container runtimes and it can be used for sensitive
    data. The source of the secret could be a local file when you’re using Compose,
    or it could be an encrypted secret stored in a Docker Swarm or Kubernetes cluster.
    Whatever the source, the contents of the secret get loaded into a file in the
    container for the application to read.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用具有 `secret` 属性的配置文件进行加载是最灵活的选项，因为它被所有容器运行时支持，并且可以用于敏感数据。当使用 Compose 时，秘密的来源可以是本地文件，也可以是存储在
    Docker Swarm 或 Kubernetes 集群中的加密秘密。无论来源如何，秘密的内容都会被加载到应用程序容器的文件中。
- en: Storing settings in a file and loading them into containers with the `environment
    _file` property is useful when you have lots of shared settings between services.
    Compose reads the file locally and sets the individual values as environment properties,
    so you can use local environment files when you’re connected to a remote Docker
    Engine.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当服务之间有很多共享设置时，使用 `environment_file` 属性将设置存储在文件中并将它们加载到容器中非常有用。Compose 会本地读取该文件，并将单个值设置为环境属性，因此当你连接到远程
    Docker Engine 时，可以使用本地环境文件。
- en: The Compose environment file, `.env` , is useful for capturing the setup for
    whichever environment you want to be the default deployment target.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Compose 环境文件 `.env` 对于捕获你想要作为默认部署目标的任何环境的设置非常有用。
- en: 10.4 Reducing duplication with extension fields
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.4 使用扩展字段减少重复
- en: At this point, you may well be thinking that Docker Compose has enough configuration
    options to satisfy any situation. But it’s actually quite a simple specification,
    and there are limitations you’ll come across as you work with it more. One of
    the most common problems is how to reduce the bloat of Compose files when you
    have services that share a lot of the same settings. In this section I’ll cover
    one final feature of Docker Compose that fixes this problem--using extension fields
    to define blocks of YAML in a single place, which you can reuse throughout the
    Compose file. Extension fields are a powerful but underused feature of Compose.
    They remove a lot of duplication and potential for errors, and they’re straightforward
    to use once you get accustomed to the YAML merge syntax.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能认为 Docker Compose 已经有足够的配置选项来满足任何情况。但实际上，它是一个非常简单的规范，并且在使用过程中你会遇到一些限制。其中最常见的问题之一是如何在服务共享大量相同设置时减少
    Compose 文件的冗余。在本节中，我将介绍 Docker Compose 的一个最终特性，它可以解决这个问题——使用扩展字段在单个位置定义 YAML 块，你可以在整个
    Compose 文件中重用这些块。扩展字段是 Compose 中一个强大但使用较少的功能。它们消除了许多重复和潜在的错误，一旦你习惯了 YAML 合并语法，它们的使用就非常直接。
- en: In the `image-gallery` folder for this chapter’s exercises, there’s a `docker-compose-prod.yml`
    file that makes use of extension fields. Listing 10.7 shows how you define extension
    fields, declaring them outside of any top-level blocks (services, networks, etc.)
    and giving them a name with the ampersand notation.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章练习的 `image-gallery` 文件夹中，有一个 `docker-compose-prod.yml` 文件，它使用了扩展字段。列表 10.7
    展示了如何定义扩展字段，将它们声明在任何顶级块（服务、网络等）之外，并使用带符号的命名法给它们命名。
- en: Listing 10.7 Defining extension fields at the top of a Docker Compose file
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.7 在 Docker Compose 文件顶部定义扩展字段
- en: '` x-labels: &logging` `   logging:` `       options:` `           max-size:
    ''100m''` `           max-file: ''10''`  ` x-labels: &labels` `     app-name:
    image-gallery`'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '` x-labels: &logging` `   logging:` `       options:` `           max-size:
    ''100m''` `           max-file: ''10''`  ` x-labels: &labels` `     app-name:
    image-gallery`'
- en: Extension fields are custom definitions; in this file there are two called `logging`
    and `labels` . By convention you prefix the block name with an “x”, so the `x-labels`
    block defines an extension called `labels` . The logging extension specifies settings
    for container logs, and it can be used inside a service definition. The labels
    extension specifies a key/value pair for a label that can be used inside an existing
    `labels` field in a service definition.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展字段是自定义定义；在这个文件中，有两个被称为 `logging` 和 `labels`。按照惯例，你需要在块名称前加上一个“x”，因此 `x-labels`
    块定义了一个名为 `labels` 的扩展。日志扩展指定了容器日志的设置，并且可以在服务定义中使用。标签扩展指定了一个键/值对，该键/值对可以在服务定义中现有的
    `labels` 字段中使用。
- en: You should note the difference between these definitions--the logging field
    includes the logging property, which means it can be used directly in the service.
    The labels field does not include the labels property, so it needs to be used
    inside an existing set of labels. Listing 10.8 makes that clear, with a service
    definition that uses both extensions.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该注意这些定义之间的区别——日志字段包括日志属性，这意味着它可以直接在服务中使用。标签字段不包括标签属性，因此需要在现有的标签集中使用。列表 10.8
    清楚地说明了这一点，其中包含了一个使用这两个扩展的服务定义。
- en: Listing 10.8 Using extensions inside a service definition with YAML merge
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.8 在服务定义中使用 YAML 合并扩展
- en: '` services:` `   iotd:` `       ports:` `           - 8080:80` `       <<:
    *logging` `       labels:` `           <<: *labels` `             public: api`'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '` services:` `   iotd:` `       ports:` `           - 8080:80` `       <<:
    *logging` `       labels:` `           <<: *labels` `             public: api`'
- en: Extension fields are used with the YAML merge syntax `<<:` followed by the field
    name, which is prefixed with an asterisk. So `<<:` `*logging` will merge in the
    value of the `logging` extension field at that point in the YAML file. When Compose
    processes this file, it will add the logging section to the service from the logging
    extension, and it will add an extra label to the existing labels section, merging
    in the value from the `labels` extension field.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展字段与 YAML 合并语法 `<<:` 一起使用，后跟字段名称，该名称以星号开头。因此 `<<:` `*logging` 将合并 YAML 文件该点的
    `logging` 扩展字段的值。当 Compose 处理此文件时，它将添加来自日志扩展的日志部分到服务中，并且它将在现有的标签部分中添加一个额外的标签，合并来自
    `labels` 扩展字段的值。
- en: 'Try it now We don’t need to run this app to see how Compose processes the file.
    Just running the `config` command will do. That validates all the inputs and prints
    out the final Compose file, with the extension fields merged into the service
    definitions:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 我们不需要运行此应用程序来查看 Compose 如何处理文件。只需运行 `config` 命令即可。这将验证所有输入并打印出最终的 Compose
    文件，其中扩展字段已合并到服务定义中：
- en: '` # browse to the image-gallery folder under ch10/exercises:` ` cd ../image-gallery` 
    ` # check config for the production override:` ` docker-compose -f ./docker-compose.yml
    -f ./docker-compose-prod.yml config`'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '` # 浏览到 ch10/exercises 下的 image-gallery 文件夹：` ` cd ../image-gallery`  ` # 检查生产覆盖的配置：`
    ` docker-compose -f ./docker-compose.yml -f ./docker-compose-prod.yml config`'
- en: My output is in figure 10.11--I haven’t shown the full output, just enough of
    the service definitions to show the extension fields being merged in.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我的输出在图 10.11 中——我没有显示完整的输出，只是足够的服务定义来显示扩展字段是如何合并的。
- en: '![](../Images/10-11.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10-11.jpg)'
- en: Figure 10.11 Using the `config` command to process files with extension fields
    and check the result
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.11 使用 `config` 命令处理具有扩展字段的文件并检查结果
- en: 'Extension fields are a useful way of ensuring best practices in your Compose
    files--using the same logging settings and container labels is a good example
    of setting standards for all services. It’s not something you’ll use for every
    app, but it’s good to have in your toolbox for those times when you’re about to
    copy and paste big chunks of YAML. Now you have a better approach. There is one
    big limitation, though: extension fields don’t apply across multiple Compose files,
    so you can’t define an extension in a core Compose file and then use it in an
    override. That’s a restriction of YAML rather than Compose, but it’s something
    to be aware of.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展字段是确保 Compose 文件中最佳实践的有用方式——使用相同的日志设置和容器标签是设置所有服务标准的好例子。这不是你会在每个应用程序中都使用的东西，但当你准备复制和粘贴大块
    YAML 时，拥有它是很好的。现在你有一个更好的方法。尽管如此，有一个大限制：扩展字段不适用于多个 Compose 文件，因此你无法在核心 Compose
    文件中定义一个扩展并在覆盖中使用它。这是 YAML 而不是 Compose 的限制，但这是你应该注意的事情。
- en: 10.5 Understanding the configuration workflow with Docker
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.5 理解 Docker 的配置工作流程
- en: It’s incredibly valuable to have the entire deployment configuration for a system
    captured in a set of artifacts that live in source control. It allows you to deploy
    any version of your application just by fetching the source at that version and
    running the deployment scripts. It also allows developers to quickly work on fixes
    by running the production stack locally and reproducing a bug in their own environment.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 将整个部署配置捕获在源控制中存在的一系列工件集中是非常有价值的。它允许您通过获取该版本的源代码并运行部署脚本来部署应用程序的任何版本。它还允许开发人员通过在本地运行生产堆栈并再现他们自己环境中的错误来快速修复问题。
- en: 'There are always variations between environments, and Docker Compose lets you
    capture the differences between environments while still giving you that set of
    deployment artifacts that live in source control. In this chapter we’ve looked
    at defining different environments with Docker Compose and focused on three key
    areas:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 环境之间总是存在差异，Docker Compose 允许您在仍然提供存在于源控制中的部署工件集的同时，捕获环境之间的差异。在本章中，我们探讨了使用 Docker
    Compose 定义不同的环境，并重点关注了三个关键领域：
- en: Application composition --Not every environment will run the whole stack. Features
    like the monitoring dashboard may not be used by developers, or applications may
    use containerized databases in the test environment but plug into a cloud database
    in production. Override files let you do this neatly, sharing common services
    and adding specific ones in each environment.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序组合 -- 并非每个环境都会运行整个堆栈。例如，监控仪表板可能不会被开发人员使用，或者应用程序可能在测试环境中使用容器化数据库，但在生产环境中连接到云数据库。覆盖文件允许您整洁地完成这项工作，共享通用服务并在每个环境中添加特定的服务。
- en: Container configuration --Properties need to change to match the requirements
    and capabilities of the environment. Published ports need to be unique so they
    don’t collide with other containers, and volume paths may use local drives in
    the test environment but shared storage in production. Overrides enable this,
    along with isolated Docker networks for each application, allowing you to run
    multiple environments on a single server.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器配置 -- 属性需要更改以匹配环境和功能的要求。发布的端口需要是唯一的，以免与其他容器冲突，并且卷路径可能在测试环境中使用本地驱动器，但在生产环境中使用共享存储。覆盖功能可以实现这一点，以及为每个应用程序提供隔离的
    Docker 网络，允许您在单个服务器上运行多个环境。
- en: Application configuration --The behavior of applications inside containers will
    change between environments. This could change the amount of logging the app does,
    or the size of the cache it uses to store local data, or whole features could
    be turned on or off. You can do this using Compose with any combination of override
    files, environment files, and secrets.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序配置 -- 容器内应用程序的行为将在不同环境之间发生变化。这可能会改变应用程序所做的日志记录量，或它用于存储本地数据的缓存大小，或者整个功能可能会被打开或关闭。您可以使用
    Compose 通过任何组合的覆盖文件、环境文件和密钥来实现这一点。
- en: 'Figure 10.12 shows that with the to-do list app we ran in section 10.3\. The
    development and test environments are completely different: in dev the app is
    configured to use a local database file, and in test Compose also runs a database
    container and the app is configured to use that. But each environment uses isolated
    networks and unique ports, so they can be run on the same machine, which is perfect
    if developers need to spin up a local test environment and see how it compares
    to their development version.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.12 显示了我们在第 10.3 节中运行的待办事项列表应用程序。开发和测试环境完全不同：在 dev 中，应用程序配置为使用本地数据库文件，而在测试中，Compose
    还运行了一个数据库容器，应用程序配置为使用该容器。但每个环境都使用隔离的网络和唯一的端口，因此它们可以在同一台机器上运行，这对于开发人员需要启动本地测试环境并查看其与开发版本的比较来说非常完美。
- en: '![](../Images/10-12.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10-12.jpg)'
- en: Figure 10.12 Defining very different environments for the same app using Docker
    Compose
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.12 使用 Docker Compose 为同一应用程序定义非常不同的环境
- en: The most important takeaway from this is that the configuration workflow uses
    the same Docker image in every environment. The build process will produce a tagged
    version of your container images, which have passed all the automated tests. That’s
    a release candidate that you deploy to the smoke-test environment using the configuration
    in your Compose files. When it passes the smoke test, it moves on to the next
    environment, which uses the same set of images and applies new configuration from
    Compose. Ultimately you’ll release that version if the tests all pass, when you’ll
    deploy those same container images to production using your Docker Swarm or Kubernetes
    deployment manifests. The software that gets released is exactly the same software
    that has passed all the tests, but now it has production behavior supplied from
    the container platform.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个实验中最重要的收获是配置工作流程在每一个环境中都使用相同的 Docker 镜像。构建过程将生成通过所有自动化测试的容器镜像的标记版本。这是一个发布候选版本，您将使用
    Compose 文件中的配置将其部署到烟雾测试环境。当它通过烟雾测试后，它将进入下一个环境，该环境使用相同的镜像集并应用来自 Compose 的新配置。最终，如果所有测试都通过，您将发布该版本，并将相同的容器镜像部署到生产环境中，使用您的
    Docker Swarm 或 Kubernetes 部署清单。发布的软件正是通过所有测试的相同软件，但现在它具有来自容器平台的生产行为。
- en: 10.6 Lab
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.6 实验室
- en: In this lab I’d like you to build your own set of environment definitions for
    the to-do app. You’re going to put together a development environment and a test
    environment, and make sure they can both run on the same machine.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实验室中，我希望您为待办事项应用程序构建自己的环境定义集。您将组合一个开发环境和测试环境，并确保它们都可以在同一台机器上运行。
- en: The development environment should be the default, which you can run with `docker-compose`
    `up` . The setup should
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 开发环境应该是默认的，您可以使用 `docker-compose` `up` 来运行它。设置应该是
- en: Use a local database file
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用本地数据库文件
- en: Publish to port `8089`
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布到端口 `8089`
- en: Run v2 of the to-do application
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行待办事项应用程序的 v2 版本
- en: The test environment will need to be run with specific Docker Compose files
    and a project name. Its setup should
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 测试环境需要使用特定的 Docker Compose 文件和项目名称来运行。其设置应该是
- en: Use a separate database container
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用独立的数据库容器
- en: Use a volume for the database storage
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用卷来存储数据库
- en: Publish to port `8080`
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布到端口 `8080`
- en: Use the latest to-do application image
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用最新的待办事项应用程序镜像
- en: There are similarities here to the Compose files in the `todo-list-configured`
    exercises for the chapter. The main difference is the volume--the database container
    uses an environment variable called `PGDATA` to set where the data files should
    be written. You can use that along with a volume specification in your Compose
    files.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里与本章“todo-list-configured”练习中的 Compose 文件有相似之处。主要区别在于容量——数据库容器使用名为 `PGDATA`
    的环境变量来设置数据文件应该写入的位置。您可以在您的 Compose 文件中使用该变量以及卷规格。
- en: 'As you’ve seen in this chapter, there are lots of ways you can solve this.
    My solution is on GitHub here: *[https://github.com/sixeyed/diamol/blob/master/ch10/lab/
    README.md](https://github.com/sixeyed/diamol/blob/master/ch10/lab/README.md)*
    .'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在本章中看到的，您有多种方法可以解决这个问题。我的解决方案在 GitHub 上：*[https://github.com/sixeyed/diamol/blob/master/ch10/lab/README.md](https://github.com/sixeyed/diamol/blob/master/ch10/lab/README.md)*。
