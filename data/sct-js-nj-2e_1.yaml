- en: Part 2\. Understanding functions
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二部分\. 理解函数
- en: Now that you’re mentally prepared and you understand the environment in which
    JavaScript code is executed, you’re ready to learn the fundamentals of the JavaScript
    features available to you.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经做好了心理准备，并且理解了JavaScript代码执行的 环境，你就可以学习JavaScript为你提供的功能基础了。
- en: 'In [chapter 3](kindle_split_014.html#ch03), you’ll learn all about the most
    important basic concept of JavaScript: no, not the object, but the function. This
    chapter will teach you why understanding JavaScript functions is the key to unlocking
    the secrets of the language.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第三章](kindle_split_014.html#ch03)中，你将了解JavaScript最重要的基本概念：不是对象，而是函数。本章将教你为什么理解JavaScript函数是解锁语言秘密的关键。
- en: '[Chapter 4](kindle_split_015.html#ch04) continues our in-depth exploration
    of functions by studying how functions are invoked, alongside all the ins and
    outs of implicit parameters that are accessible when executing function code.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[第四章](kindle_split_015.html#ch04)通过研究函数的调用以及执行函数代码时可以访问的所有隐式参数的来龙去脉，继续深入探索函数。'
- en: '[Chapter 5](kindle_split_016.html#ch05) takes functions to the next level with
    closures—probably one of the most misunderstood (and even unknown) aspects of
    the JavaScript language. As you’ll soon see, closures are closely tied to scopes.
    In this chapter, in addition to closures, we put a special focus on the scoping
    mechanisms in JavaScript.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[第五章](kindle_split_016.html#ch05) 通过闭包将函数提升到新的层次——这可能是JavaScript语言中最被误解（甚至未知）的方面之一。正如你很快就会看到的，闭包与作用域紧密相关。在本章中，除了闭包之外，我们还特别关注JavaScript中的作用域机制。'
- en: Our exploration of functions will be completed in [chapter 6](kindle_split_017.html#ch06),
    where we discuss a completely new type of function—the generator function—that
    has some special properties and is especially useful when dealing with asynchronous
    code.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对函数的探索将在[第六章](kindle_split_017.html#ch06)中完成，我们将讨论一种全新的函数类型——生成器函数，它具有一些特殊属性，在处理异步代码时特别有用。
- en: 'Chapter 3\. First-class functions for the novice: definitions and arguments'
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第三章\. 新手的优先级函数：定义和参数
- en: '*This chapter covers*'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Why understanding functions is so crucial
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解函数为什么如此关键
- en: How functions are first-class objects
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数是如何成为一等对象的
- en: The ways to define a function
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义函数的方法
- en: The secrets of how parameters are assigned
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数分配的秘密
- en: You might be surprised, upon turning to this part of the book dedicated to JavaScript
    fundamentals, to see that the first topic of discussion is *functions* rather
    than *objects*. We’ll certainly be paying plenty of attention to objects in [part
    3](kindle_split_018.html#part03) of the book, but when it comes down to brass
    tacks, the main difference between writing JavaScript code like the average Jill
    (or Joe) and writing it like a JavaScript ninja is understanding JavaScript as
    a *functional language*. The level of sophistication of all the code you’ll ever
    write in JavaScript hinges on this realization.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当你翻到这本书关于JavaScript基础的部分时，可能会感到惊讶，讨论的第一个主题是*函数*而不是*对象*。我们当然会在书的第三部分[第3部分](kindle_split_018.html#part03)中详细讨论对象，但归根结底，编写JavaScript代码与编写JavaScript忍者代码之间的主要区别在于理解JavaScript作为一种*函数式语言*。你将在JavaScript中编写的所有代码的复杂程度都取决于这一认识。
- en: If you’re reading this book, you’re not a rank beginner. We’re assuming that
    you know enough object fundamentals to get by (and we’ll be taking a look at more-advanced
    object concepts in [chapter 7](kindle_split_019.html#ch07)), but *really* understanding
    functions in JavaScript is the single most important weapon you can wield. So
    important, in fact, that this and the following three chapters are devoted to
    thoroughly understanding functions in JavaScript.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在阅读这本书，你不是一个初学者。我们假设你足够了解对象基础来应对（我们将在[第七章](kindle_split_019.html#ch07)中查看更高级的对象概念），但真正理解JavaScript中的函数是你能使用的最重要的武器。事实上，如此重要，以至于本章以及接下来的三个章节都致力于彻底理解JavaScript中的函数。
- en: Most important, in JavaScript, functions are *first-class objects,* or *first-class
    citizens* as they’re often called. They coexist with, and can be treated like,
    any other JavaScript object. Just like the more mundane JavaScript data types,
    they can be referenced by variables, declared with literals, and even passed as
    function parameters. In this chapter, we’ll first take a look at the difference
    that this orientation to functions brings, and you’ll see how this can help us
    write more compact and easy-to-understand code, by allowing us to define functions
    right where we need them. We’ll also explore how to take advantage of functions
    as first-class objects in order to write better-performing functions. You’ll see
    various ways of defining functions, even including some new types, such as *arrow*
    functions, which will help you write more elegant code. Finally, we’ll look at
    the difference between function parameters and function arguments, with a special
    focus on ES6 additions, such as the rest and default parameters.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，在JavaScript中，函数是一等对象，或者如人们常说的*一等公民*。它们与其他JavaScript对象共存，并且可以像其他JavaScript对象一样被对待。就像更平凡的JavaScript数据类型一样，它们可以通过变量引用，用字面量声明，甚至作为函数参数传递。在本章中，我们将首先探讨这种对函数的定位带来的差异，你将看到这如何帮助我们编写更紧凑、更易于理解的代码，通过允许我们在需要的地方定义函数。我们还将探讨如何利用函数作为一等对象来编写性能更好的函数。你将看到定义函数的各种方法，甚至包括一些新类型，如*箭头*函数，这将帮助你编写更优雅的代码。最后，我们将探讨函数参数和函数参数之间的区别，特别关注ES6新增的功能，如剩余参数和默认参数。
- en: Let’s start by going through some of the benefits of functional programming.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从探讨函数编程的一些好处开始。
- en: Do you know?
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你知道吗？
- en: '**Q1:**'
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Q1:**'
- en: ''
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In what situations might callback functions be used synchronously? Asynchronously?
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在什么情况下回调函数可能会同步使用？异步使用？
- en: '**Q2:**'
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Q2:**'
- en: ''
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What’s the difference between an arrow function and a function expression?
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 箭头函数和函数表达式之间的区别是什么？
- en: '**Q3:**'
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Q3:**'
- en: ''
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why might you need to use default parameter values in a function?
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么你可能需要在函数中使用默认参数值？
- en: 3.1\. What’s with the functional difference?
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1\. 功能差异是什么？
- en: One of the reasons that functions and functional concepts are so important in
    JavaScript is that functions are primary modular units of execution. Except for
    the global JavaScript code executed in the page-building phase, all of the script
    code that we’ll write for our pages will be within a function.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 函数和函数概念在JavaScript中如此重要的一个原因是函数是执行的主要模块单元。除了在页面构建阶段执行的全球JavaScript代码外，我们将为我们的页面编写的所有脚本代码都将在一个函数内部。
- en: 'Because most of our code will run as the result of a function invocation, you’ll
    see that having functions that are versatile and powerful constructs gives us
    a great deal of flexibility and sway when writing code. Significant chunks of
    this book explain just how the nature of functions as first-class objects can
    be exploited to our great benefit. But first, let’s take a look at some of the
    actions we can take with objects. In JavaScript, objects enjoy certain capabilities:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的大部分代码都将作为函数调用的结果运行，你会发现拥有灵活且强大的函数构造给我们编写代码带来了极大的灵活性和影响力。本书的很大一部分内容解释了如何利用函数作为一等对象的本质，以获得巨大的好处。但首先，让我们看看我们可以用对象执行的一些操作。在JavaScript中，对象享有某些能力：
- en: 'They can be created via literals: `{}`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以通过字面量创建：`{}`
- en: 'They can be assigned to variables, array entries, and properties of other objects:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以被分配给变量、数组条目和其他对象的属性：
- en: '![](035fig01.jpg)'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](035fig01.jpg)'
- en: 'They can be passed as arguments to functions:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以作为参数传递给函数：
- en: '![](035fig02.jpg)'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](035fig02.jpg)'
- en: 'They can be returned as values from functions:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以作为函数的返回值：
- en: '![](035fig03.jpg)'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](035fig03.jpg)'
- en: 'They can possess properties that can be dynamically created and assigned:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以拥有可以动态创建和分配的属性：
- en: '![](035fig04.jpg)'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](035fig04.jpg)'
- en: It turns out that, unlike in many other programming languages, in JavaScript
    we can do almost the exact same things with functions also.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，与许多其他编程语言不同，在JavaScript中，我们可以用函数做几乎完全相同的事情。
- en: 3.1.1\. Functions as first-class objects
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.1\. 函数作为一等对象
- en: Functions in JavaScript possess all the capabilities of objects and are thus
    treated like any other object in the language. We say that functions are *first-class*
    objects, which can also be
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的函数具有所有对象的能力，因此它们在语言中像任何其他对象一样被对待。我们说函数是*一等*对象，它们也可以被
- en: Created via literals
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过字面量创建
- en: '[PRE0]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Assigned to variables, array entries, and properties of other objects
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配给变量、数组条目和其他对象的属性
- en: '![](035fig05_alt.jpg)'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](035fig05_alt.jpg)'
- en: Passed as arguments to other functions
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为参数传递给其他函数
- en: '![](036fig01.jpg)'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](036fig01.jpg)'
- en: Returned as values from functions
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数返回的值
- en: '![](036fig02_alt.jpg)'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](036fig02_alt.jpg)'
- en: 'They can possess properties that can be dynamically created and assigned:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以拥有可以动态创建和分配的属性：
- en: '![](036fig03_alt.jpg)'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](036fig03_alt.jpg)'
- en: Whatever we can do with objects, we can do with functions as well. Functions
    *are* objects, just with an additional, special capability of being *invokable:*
    Functions can be called or invoked in order to perform an action.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用函数做任何可以用对象做的事情。函数*就是*对象，只是具有额外的、特殊的能力，即*可调用性*：函数可以被调用或调用以执行某个操作。
- en: '|  |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Functional programming in JavaScript**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript中的函数式编程**'
- en: Having functions as first-class objects is the first step toward *functional
    programming*, a style of programming that’s focused on solving problems by composing
    functions (instead of specifying sequences of steps, as in more mainstream, imperative
    programming). Functional programming can help us write code that’s easier to test,
    extend, and modularize. But it’s a big topic, and in this book we only give it
    a nod (for example, in [chapter 9](kindle_split_021.html#ch09)). If you’re interested
    in learning how to take advantage of functional programming concepts and apply
    them to your JavaScript programs, we recommend *Functional Programming in JavaScript*
    by Luis Atencio (Manning, 2016), available at [www.manning.com/books/functional-programming-in-javascript](http://www.manning.com/books/functional-programming-in-javascript).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数作为一等对象是迈向*函数式编程*的第一步，这是一种专注于通过组合函数（而不是像主流的命令式编程那样指定一系列步骤）来解决问题的编程风格。函数式编程可以帮助我们编写更容易测试、扩展和模块化的代码。但这是一个很大的主题，在这本书中我们只是简要地提到了它（例如，在第9章[kindle_split_021.html#ch09]）。如果你对学习如何利用函数式编程的概念并将其应用于JavaScript程序感兴趣，我们推荐Luis
    Atencio的《JavaScript函数式编程》（Manning，2016），可在[www.manning.com/books/functional-programming-in-javascript](http://www.manning.com/books/functional-programming-in-javascript)找到。
- en: '|  |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: One of the characteristics of first-class objects is that they can be passed
    to functions as arguments. In the case of functions, this means that we pass a
    function as an argument to another function that might, at a later point in application
    execution, call the passed-in function. This is an example of a more general concept
    known as a *callback function*. Let’s explore this important concept.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一等对象的一个特点是它们可以作为参数传递给函数。在函数的情况下，这意味着我们传递一个函数作为参数给另一个函数，该函数可能在应用程序执行过程中的某个时刻调用传入的函数。这是一个更一般概念——回调函数——的例子。让我们探讨这个重要概念。
- en: 3.1.2\. Callback functions
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.2. 回调函数
- en: Whenever we set up a function to be called at a later time, whether by the browser
    in the event-handling phase or by other code, we’re setting up a *callback*. The
    term stems from the fact that we’re establishing a function that other code will
    later “call back” at an appropriate point of execution.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们设置一个函数以便在以后的时间被调用，无论是浏览器在事件处理阶段还是其他代码，我们都是在设置一个*回调*。这个术语来源于我们正在建立一个函数，其他代码将在适当的执行点“回调”这个函数。
- en: Callbacks are an essential part of using JavaScript effectively, and we’re willing
    to bet that you already use them in your code a lot—whether executing code on
    a button click, receiving data from a server, or animating parts of your UI.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 回调是有效使用JavaScript的一个基本部分，我们敢打赌你已经在你的代码中大量使用了它们——无论是执行按钮点击时的代码、从服务器接收数据，还是动画化UI的某些部分。
- en: 'In this section, we’re about to look at how to use callbacks to handle events
    or to easily sort collections—typical real-world examples of how callbacks are
    used. But it’s a tad complex, so before diving in, let’s strip the callback concept
    completely naked and examine it in its simplest form. We’ll start with an illuminating
    example of a completely useless function that accepts a reference to another function
    as a parameter and calls that function as a callback:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何使用回调来处理事件或轻松地对集合进行排序——这是回调在现实世界中使用的典型例子。但这有点复杂，所以在深入之前，让我们将回调概念完全剥离开来，以最简单的形式来审视它。我们将从一个接受另一个函数引用作为参数并作为回调调用该函数的无用函数的例子开始：
- en: '[PRE1]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As useless as this function is, it demonstrates the ability to pass a function
    as an argument to another function, and to subsequently invoke that function through
    the passed parameter.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个函数毫无用处，但它展示了将函数作为参数传递给另一个函数，并随后通过传递的参数调用该函数的能力。
- en: We can test this useless function with the code in the following listing.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下列表中的代码来测试这个无用的函数。
- en: Listing 3.1\. A simple callback example
  id: totrans-64
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.1\. 一个简单的回调示例
- en: '![](037fig01_alt.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](037fig01_alt.jpg)'
- en: In this listing, we use a custom `report` function to output several messages
    as our code is being executed, so that we can track the execution of our program.
    We also use the `assert` testing function that we mentioned in [chapter 1](kindle_split_011.html#ch01).
    The `assert` function usually takes two arguments. The first argument is an expression
    whose premise is asserted. In this case, we want to establish whether the result
    of invoking our `useless` function with the argument `getText` returns a value
    that’s equal to the value of the variable `text` (`useless(getText) === text`).
    If the first argument evaluates to `true,` the assertion passes; otherwise, it’s
    considered a failure. The second argument is the associated message, which is
    usually logged with an appropriate pass/fail indicator. ([Appendix C](kindle_split_030.html#app03)
    discusses testing in general, as well as our own little implementation of the
    `assert` and `report` functions).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个列表中，我们使用自定义的 `report` 函数在代码执行过程中输出几条消息，这样我们就可以跟踪程序的执行。我们还使用了我们在[第1章](kindle_split_011.html#ch01)中提到的
    `assert` 测试函数。`assert` 函数通常接受两个参数。第一个参数是一个断言前提的表达式。在这种情况下，我们想要确定调用我们的 `useless`
    函数并传递参数 `getText` 返回的值是否等于变量 `text` 的值（`useless(getText) === text`）。如果第一个参数评估为
    `true`，则断言通过；否则，被视为失败。第二个参数是相关的消息，通常与适当的通过/失败指示器一起记录。([附录C](kindle_split_030.html#app03)讨论了测试的一般情况，以及我们自己的
    `assert` 和 `report` 函数的小型实现）。
- en: When we run this code, we end up with the result shown in [figure 3.1](#ch03fig01).
    As you can see, calling the `useless` function with our `getText` callback function
    as an argument returns the expected value.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这段代码时，最终得到[图3.1](#ch03fig01)中所示的结果。如图所示，使用我们的 `getText` 回调函数作为参数调用 `useless`
    函数返回了预期的值。
- en: Figure 3.1\. The result of running the code from [listing 3.1](#ch03ex01)
  id: totrans-68
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.1\. 运行[列表3.1](#ch03ex01)中代码的结果
- en: '![](03fig01.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](03fig01.jpg)'
- en: We can also take a look at how exactly this simple callback example is executed.
    As [figure 3.2](#ch03fig02) shows, we pass in the `getText` function to the `useless`
    function as an argument. This means that within the body of the `useless` function,
    the `getText` function can be referenced through the `callback` parameter. Then,
    by making the `callback()` call, we cause the execution of the `getText` function;
    the `getText` function, which we passed in as an argument, is called back by the
    `useless` function.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以查看这个简单的回调示例是如何具体执行的。如图3.2([#ch03fig02](#ch03fig02))所示，我们将 `getText` 函数作为参数传递给
    `useless` 函数。这意味着在 `useless` 函数的体内，可以通过 `callback` 参数引用 `getText` 函数。然后，通过调用 `callback()`，我们导致
    `getText` 函数的执行；我们作为参数传递的 `getText` 函数被 `useless` 函数回调。
- en: Figure 3.2\. The flow of execution when making the `useless(getText)` call.
    The `useless` function is called with `getText` as an argument. In the body of
    the `useless` function is a call to the passed-in function, which in this case
    triggers the execution of the `getText` function (we’ve “called back” to the `getText`
    function).
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.2\. 执行 `useless(getText)` 调用时的执行流程。`useless` 函数以 `getText` 作为参数被调用。在 `useless`
    函数的体内有一个对传入函数的调用，这在本例中触发了 `getText` 函数的执行（我们“回调”到 `getText` 函数）。
- en: '![](03fig02_alt.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](03fig02_alt.jpg)'
- en: 'This is easy, because JavaScript’s functional nature lets us deal with functions
    as first-class objects. We can even take the whole thing a step further, by rewriting
    our code in the following manner:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单，因为JavaScript的函数式特性让我们可以像处理一等对象一样处理函数。我们甚至可以更进一步，通过以下方式重写我们的代码：
- en: '![](038fig01_alt.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](038fig01_alt.jpg)'
- en: One of the most important features of JavaScript is the ability to create functions
    in the code anywhere an expression can appear. In addition to making the code
    more compact and easy to understand (by putting function definitions near where
    they’re used), this feature can also eliminate the need to pollute the global
    namespace with unnecessary names when a function isn’t going to be referenced
    from multiple places within the code.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript最重要的特性之一是能够在代码的任何位置创建函数，只要表达式可以出现的地方。除了使代码更加紧凑和易于理解（通过将函数定义放置在它们被使用的地方附近），这个特性还可以在函数不会在代码的多个地方被引用时，消除污染全局命名空间中不必要的名称的需求。
- en: 'In the preceding example of a callback, we called our own callback. But callbacks
    can also be called by the browser. Think back to [chapter 2](kindle_split_012.html#ch02),
    which has an example with the following snippet:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的回调示例中，我们调用了自己的回调。但回调也可以由浏览器调用。回想一下[第2章](kindle_split_012.html#ch02)，其中有一个包含以下片段的示例：
- en: '[PRE2]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: That’s also a callback function, one that’s defined as an event handler to the
    `mousemove` event, and that will be called by the browser when that event occurs.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是一个回调函数，它被定义为`mousemove`事件的处理器，并且当该事件发生时，浏览器会调用它。
- en: '|  |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: This section introduces callbacks as functions that other code will later “call
    back” at an appropriate point of execution. You’ve seen an example in which our
    own code immediately calls the provided callback (the `useless` function example),
    as well as an example in which the browser makes the call (the `mousemove` example)
    whenever a particular event happens. It’s important to note that, unlike us, some
    people believe that a callback has to be called asynchronously, and therefore
    that the first example isn’t really a callback. We mention this just in case you
    stumble upon some heated discussion.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了回调函数作为其他代码将在适当的执行点“回调”的函数。您已经看到了一个例子，其中我们的代码立即调用了提供的回调（`useless`函数示例），以及一个例子，其中浏览器在特定事件发生时进行调用（`mousemove`示例）。重要的是要注意，与我们的不同，有些人认为回调必须异步调用，因此第一个例子并不是真正的回调。我们只是提到这一点，以防您遇到一些热烈的讨论。
- en: '|  |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Now let’s consider a use of callbacks that will greatly simplify how we sort
    collections.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑一个回调的使用，这将极大地简化我们排序集合的方式。
- en: Sorting with a comparator
  id: totrans-84
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用比较器进行排序
- en: 'Almost as soon as we *have* a collection of data, odds are we’re going to need
    to sort it. Let’s say that we have an array of numbers in a random order: 0, 3,
    2, 5, 7, 4, 8, 1\. That order might be just fine, but chances are that, sooner
    or later, we’ll want to rearrange it.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎在我们拥有数据集合的同时，我们很可能会需要对其进行排序。假设我们有一个随机排序的数字数组：0, 3, 2, 5, 7, 4, 8, 1。这种顺序可能很好，但很可能会在某个时候想要重新排列它。
- en: Usually, implementing sorting algorithms isn’t the most trivial of programming
    tasks; we have to select the best algorithm for the job at hand, implement it,
    adapt it to our current need (so that the items are sorted in a particular order),
    and be careful not to introduce bugs. Out of these tasks, the only one that’s
    application specific is the sorting order. Luckily, all JavaScript arrays have
    access to the `sort` method that requires us only to define a comparison algorithm
    that tells the sort algorithm how the values should be ordered.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，实现排序算法并不是编程任务中最简单的；我们必须选择最适合当前任务的算法，实现它，适应我们的当前需求（以便项目按特定顺序排序），并且要小心不要引入错误。在这些任务中，唯一与特定应用相关的就是排序顺序。幸运的是，所有JavaScript数组都可以访问`sort`方法，它只需要我们定义一个比较算法，告诉排序算法如何对值进行排序。
- en: 'This is where callbacks jump in! Instead of letting the sort algorithm decide
    what values go before other values, *we’ll* provide a function that performs the
    comparison. We’ll give the sort algorithm access to this function as a callback,
    and the algorithm will call the callback whenever it needs to make a comparison.
    The callback is expected to return a positive number if the order of the passed
    values should be reversed, a negative number if not, and zero if the values are
    equal; subtracting the compared values produces the desired return value to sort
    the array:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是回调介入的地方！我们不会让排序算法决定哪些值应该排在其他值之前，*我们*将提供一个执行比较的函数。我们将给排序算法提供访问这个函数作为回调的权限，算法将在需要比较时调用回调。回调预期返回一个正数，如果传递的值的顺序应该被反转，返回一个负数，如果不应该反转，返回零，如果值相等；从比较的值中减去产生所需的返回值以对数组进行排序：
- en: '[PRE3]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: There’s no need to think about the low-level details of a sorting algorithm
    (or even which sorting algorithm to choose). We provide a callback that the JavaScript
    engine will call every time it needs to compare two items.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 没有必要考虑排序算法的低级细节（甚至不需要选择哪种排序算法）。我们提供了一个回调函数，JavaScript 引擎将在需要比较两个项目时调用它。
- en: The *functional* approach allows us to create a function as a standalone entity,
    just as we can any other object type, and to pass it as an argument to a method,
    just like any other object type, which can accept it as a parameter, just like
    any other object type. It’s that first-class status coming into play.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 功能性方法允许我们创建一个作为独立实体的函数，就像我们可以创建任何其他对象类型一样，并且可以将它作为参数传递给一个方法，就像任何其他对象类型一样，该方法可以将其作为参数接受，就像任何其他对象类型一样。这就是一等公民地位发挥作用的地方。
- en: 3.2\. Fun with functions as objects
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2. 函数作为对象的乐趣
- en: 'In this section, we’ll examine ways to exploit the similarities that functions
    share with other object types. One capability that might be surprising is that
    there’s nothing stopping us from attaching properties to functions:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨利用函数与其他对象类型共享的相似性的方法。一个可能令人惊讶的能力是，没有任何阻止我们将属性附加到函数上：
- en: '![](040fig01_alt.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](040fig01_alt.jpg)'
- en: 'Let’s look at a couple of the more interesting things that can be done with
    this capability:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用这种能力可以做的几件更有趣的事情：
- en: '*Storing functions in a collection* allows us to easily manage related functions—for
    example, callbacks that have to be invoked when something of interest occurs.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将函数存储在集合中*使我们能够轻松管理相关的函数——例如，当发生某些感兴趣的事情时必须调用的回调函数。'
- en: '*Memoization* allows the function to remember previously computed values, thereby
    improving the performance of subsequent invocations.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*记忆化*允许函数记住之前计算过的值，从而提高后续调用的性能。'
- en: Let’s get cracking.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: 3.2.1\. Storing functions
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.1. 存储函数
- en: In certain cases (for example, when we need to manage collections of callbacks
    that should be invoked when a certain event occurs), we want to store collections
    of unique functions. When adding functions to such a collection, a challenge we
    can face is determining which functions are new to the collection and should be
    added, and which are already resident and shouldn’t be added. In general, when
    managing callback collections, we don’t want any duplicates, because a single
    event would result in multiple calls to the same callback.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下（例如，当我们需要管理在发生特定事件时应该调用的回调函数集合时），我们希望存储一组独特的函数。向此类集合添加函数时，我们可能面临的一个挑战是确定哪些函数是集合中的新函数，应该添加，哪些函数已经存在，不应该添加。通常，在管理回调函数集合时，我们不希望有任何重复，因为单个事件会导致对同一回调函数的多次调用。
- en: An obvious, but naïve, technique is to store all the functions in an array and
    loop through the array, checking for duplicate functions. Unfortunately, this
    performs poorly, and as a ninja, we want to make things work *well*, not merely
    work. We can use function properties to achieve this with an appropriate level
    of sophistication, as shown in the next listing.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一种明显但天真技术是将所有函数存储在数组中，然后遍历数组，检查重复的函数。不幸的是，这表现不佳，作为一个忍者，我们希望事情能够**良好**地工作，而不仅仅是工作。我们可以使用函数属性以适当的复杂度实现这一点，如下一列表所示。
- en: Listing 3.2\. Storing a collection of unique functions
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.2. 存储一组独特的函数
- en: '![](041fig01_alt.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](041fig01_alt.jpg)'
- en: 'In this listing, we create an object assigned to the variable `store`, in which
    we’ll store a unique set of functions. This object has two data properties: one
    that stores a next available `id` value, and one within which we’ll `cache` the
    stored functions. Functions are added to this cache via the `add()` method:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个列表中，我们创建了一个对象，分配给变量`store`，我们将在这个对象中存储一组独特的函数。这个对象有两个数据属性：一个用于存储下一个可用的`id`值，另一个用于在其中`缓存`存储的函数。函数通过`add()`方法添加到这个缓存中：
- en: '[PRE4]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Within `add`, we first check to see whether the function has already been added
    to the collection by looking for the existence of the `id` property. If the current
    function has an `id` property, we assume that the function has already been processed
    and we ignore it. Otherwise, we assign an `id` property to the function (incrementing
    the `nextId` property along the way) and add the function as a property of the
    `cache`, using the `id` value as the property name. We then return the value `true`,
    so that we can tell when the function was added after a call to `add()`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在`add`函数内部，我们首先检查函数是否已经被添加到集合中，通过查找`id`属性的存在来确认。如果当前函数有一个`id`属性，我们假设该函数已经被处理，并忽略它。否则，我们将一个`id`属性分配给函数（同时递增`nextId`属性），并将函数作为`cache`的属性添加，使用`id`值作为属性名。然后我们返回值`true`，这样我们就可以在调用`add()`之后知道函数何时被添加。
- en: Running the page in the browser shows that when our tests try to add the `ninja()`
    function twice, the function is added only once, as shown in [figure 3.3](#ch03fig03).
    [Chapter 9](kindle_split_021.html#ch09) shows an even better technique for working
    with collections of unique items that utilize sets, a new type of object available
    in ES6.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中运行页面显示，当我们的测试尝试两次添加`ninja()`函数时，函数只被添加了一次，如图3.3所示。[第9章](kindle_split_021.html#ch09)展示了利用集合和ES6中可用的新类型对象集的更佳技术来处理唯一项集合。
- en: Figure 3.3\. By tacking a property onto a function, we can keep track of it.
    In that way, we can be sure that our function has been added only once.
  id: totrans-107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.3。通过将一个属性附加到一个函数上，我们可以跟踪它。这样，我们可以确保我们的函数只被添加了一次。
- en: '![](03fig03.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig03.jpg)'
- en: Another useful trick to pull out of our sleeves when using function properties
    is giving a function the ability to modify itself. This technique can be used
    to remember previously computed values, saving time during future computations.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用函数属性时，我们可以从袖子里拿出另一个有用的技巧，那就是给函数赋予修改自己的能力。这项技术可以用来记住之前计算过的值，在未来的计算中节省时间。
- en: 3.2.2\. Self-memoizing functions
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.2. 自记忆化函数
- en: As noted earlier, *memoization* (no, that’s not a typo) is the process of building
    a function that’s capable of remembering its previously computed values. In a
    nutshell, whenever a function computes its result, we store that result alongside
    the function arguments. In this way, when another invocation occurs for the same
    set of arguments, we can return the previously stored result, instead of calculating
    it anew. This can markedly increase performance by avoiding needless complex computations
    that have already been performed. Memoization is particularly useful when performing
    calculations for animations, searching data that doesn’t change that often, or
    any time-consuming math.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，*记忆化*（不，这不是一个打字错误）是构建一个能够记住之前计算值的函数的过程。简而言之，每当函数计算其结果时，我们都会将结果存储在函数参数旁边。这样，当另一个调用发生，并且参数相同，我们可以返回之前存储的结果，而不是重新计算。这可以通过避免已经执行的无用复杂计算来显著提高性能。记忆化在执行动画计算、搜索不经常变化的数据或任何耗时数学计算时特别有用。
- en: As an example, let’s look at a simplistic (and certainly not particularly efficient)
    algorithm for computing prime numbers. Although this is a simple example of a
    complex calculation, this technique is readily applicable to other expensive computations
    (such as deriving the MD5 hash for a string) that are too complex to present here.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看看一个简单（当然，也绝不是特别高效）的算法，用于计算素数。虽然这是一个复杂计算的简单示例，但这种技术可以轻松应用于其他复杂的计算（例如，计算字符串的MD5散列），而这些计算过于复杂，无法在此展示。
- en: From the outside, the function appears to be just like any normal function,
    but we’ll surreptitiously build in an answer cache in which the function will
    save the answers to the computations it performs. Look over the following code.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 从外部看，这个函数看起来就像任何正常函数一样，但我们将秘密地构建一个答案缓存，其中函数将保存它执行的计算的答案。请查看以下代码。
- en: Listing 3.3\. Memoizing previously computed values
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.3. 记忆化之前计算过的值
- en: '![](042fig01_alt.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](042fig01_alt.jpg)'
- en: 'Within the `isPrime` function, we start by checking whether the `answers` property
    that we’ll use as a cache has been created, and if not, we create it:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在`isPrime`函数内部，我们首先检查我们将用作缓存的`answers`属性是否已经创建，如果没有，我们创建它：
- en: '[PRE5]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The creation of this initially empty object will occur only on the first call
    to the function; after that, the cache will exist.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最初为空的对象的创建只会发生在对函数的第一次调用中；之后，缓存将存在。
- en: 'Then we check whether the result for the passed value has already been cached
    in `answers`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们检查传递的值的计算结果是否已经缓存在了`answers`中：
- en: '[PRE6]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Within this cache, we’ll store the computed answer (`true` or `false`) using
    the argument `value` as the property key. If we find a cached answer, we return
    it.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个缓存中，我们将使用`value`作为属性键来存储计算出的答案（`true`或`false`）。如果我们找到缓存的答案，我们就返回它。
- en: 'If no cached value is found, we go ahead and perform the calculations needed
    to determine whether the value is `prime` (which can be an expensive operation
    for larger values) and store the result in the cache as we return it:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找不到缓存的值，我们将继续执行所需的计算以确定该值是否为`质数`（对于较大的值，这可能是一项昂贵的操作），并在返回时将其结果存储在缓存中：
- en: '[PRE7]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Our cache is a property of the function itself, so it’s kept alive for as long
    as the function itself is alive.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的缓存是函数本身的属性，因此只要函数本身存在，它就会保持活跃。
- en: Finally, we test that the memoization is working!
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们测试一下缓存是否正常工作！
- en: '[PRE8]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This approach has two major advantages:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有两个主要优点：
- en: The end user enjoys performance benefits for function calls asking for a previously
    computed value.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终用户在请求之前已计算过的函数值时，会享受到性能上的好处。
- en: It happens seamlessly and behind the scenes; neither the end user nor the page
    author needs to perform any special requests or do any extra initialization in
    order to make it all work.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这一切都在幕后无缝进行；既不需要最终用户也不需要页面作者执行任何特殊请求或进行任何额外的初始化，以便使其正常工作。
- en: 'But it’s not all roses and violins; its disadvantages may need to be weighed
    against its advantages:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 但并非一切都如此美好；它的缺点可能需要权衡其优点：
- en: Any sort of caching will certainly sacrifice memory in favor of performance.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何形式的缓存都会牺牲内存以换取性能。
- en: Purists may consider that caching is a concern that shouldn’t be mixed with
    the business logic; a function or a method should do one thing and do it well.
    But don’t worry; in [chapter 8](kindle_split_020.html#ch08), you’ll see how to
    tackle this complaint.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯粹主义者可能会认为缓存是一个不应该与业务逻辑混合的问题；一个函数或方法应该只做一件事，并且做好。但别担心；在[第8章](kindle_split_020.html#ch08)中，你将看到如何处理这种抱怨。
- en: It’s difficult to load-test or measure the performance of an algorithm such
    as this one, because our results depend on the previous inputs to the function.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于这种类型的算法，很难进行负载测试或测量其性能，因为我们的结果取决于函数的先前输入。
- en: Now that you’ve seen some of the practical use cases of first-class functions,
    let’s explore the various ways of defining functions.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了一些一等函数的实际用例，让我们来探讨定义函数的各种方式。
- en: 3.3\. Defining functions
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3. 定义函数
- en: JavaScript functions are usually defined by using a *function literal* that
    creates a function value in the same way that, for example, a numeric literal
    creates a numeric value. Remember that as first-class objects, functions are values
    that can be used in the language just like other values, such as strings and numbers.
    And whether you realize it or not, you’ve been doing that all along.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript函数通常通过使用*函数字面量*来定义，它以与例如，数字字面量创建数字值相同的方式创建函数值。记住，作为一等对象，函数是可以在语言中使用，就像其他值一样，例如字符串和数字。而且无论你是否意识到，你一直在这样做。
- en: 'JavaScript provides a couple of ways to define functions, which can be divided
    into four groups:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript提供了几种定义函数的方法，可以分为四组：
- en: '*Function declarations* and *function expressions*—The two most common, yet
    subtly different ways of defining functions. Often people don’t even consider
    them as separate, but as you’ll see, being aware of their differences can help
    us understand when our functions are available for invocation:'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*函数声明*和*函数表达式*——定义函数最常见且细微不同的两种方式。人们通常甚至不把它们视为不同的，但正如你将看到的，了解它们之间的差异可以帮助我们理解何时我们的函数可以调用：'
- en: '[PRE9]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Arrow functions* (often called *lambda functions*)—A recent, ES6 addition
    to the JavaScript standard that enables us to define functions with far less syntactic
    clutter. They even solve one common problem with callback functions, but more
    on that later:'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*箭头函数*（通常称为*lambda函数*）——JavaScript标准中最近添加的ES6功能，使我们能够用更少的语法冗余来定义函数。它们甚至解决了回调函数的一个常见问题，但关于这一点稍后会更详细地讨论：'
- en: '[PRE10]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '***Function constructors—*** A not-so-often used way of defining functions
    that enables us to dynamically construct a new function from a string that can
    also be dynamically generated. This example dynamically creates a function with
    two parameters, `a` and `b`, that returns the sum of those two parameters:'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***函数构造函数—*** 一种不太常用的定义函数的方式，使我们能够从字符串动态构造一个新函数，该字符串也可以动态生成。以下示例动态创建了一个具有两个参数`a`和`b`的函数，该函数返回这两个参数的和：'
- en: '[PRE11]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '***Generator functions—*** This ES6 addition to JavaScript enable us to create
    functions that, unlike normal functions, can be exited and reentered later in
    the application execution, while keeping the values of their variables across
    these re-entrances. We can define generator versions of *function declarations*,
    *function expressions*, and *function constructors*:'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***生成器函数—*** 这是JavaScript中ES6的添加，使我们能够创建函数，与普通函数不同，可以在应用程序执行过程中退出并在稍后重新进入，同时保持这些变量在这些重新进入中的值。我们可以定义*函数声明*、*函数表达式*和*函数构造函数*的生成器版本：'
- en: '[PRE12]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It’s important that you understand these differences, because the way in which
    a function is defined significantly influences when the function is available
    to be invoked and how it behaves, as well as on which object the function can
    be invoked.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这些差异非常重要，因为函数的定义方式显著影响函数何时可以被调用以及它的行为，以及可以在哪个对象上调用函数。
- en: In this chapter, we’ll explore function declarations, function expressions,
    and arrow functions. You’ll learn their syntax and how they work, and we’ll come
    back to them multiple times throughout the book to explore their specifics. Generator
    functions, on the other hand, are rather peculiar and are significantly different
    from the standard functions. We’ll revisit them in detail in [chapter 6](kindle_split_017.html#ch06).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨函数声明、函数表达式和箭头函数。你将学习它们的语法以及它们是如何工作的，并且我们将在整本书中多次回到它们，以探讨它们的细节。另一方面，生成器函数相当独特，与标准函数有显著的不同。我们将在第6章中详细回顾它们。[第6章](kindle_split_017.html#ch06)。
- en: That leaves us with function constructors, a JavaScript feature that we’ll skip
    entirely. Although it has some interesting applications, especially when dynamically
    creating and evaluating code, we consider it a corner feature of the JavaScript
    language. If you want to know more about function constructors, visit [http://mng.bz/ZN8e](http://mng.bz/ZN8e).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这就留下了函数构造函数，这是一个JavaScript特性，我们将完全跳过。尽管它有一些有趣的应用，尤其是在动态创建和评估代码时，但我们认为它是JavaScript语言的边缘特性。如果你想了解更多关于函数构造函数的信息，请访问[http://mng.bz/ZN8e](http://mng.bz/ZN8e)。
- en: 'Let’s start with the simplest, most traditional ways of defining functions:
    *function declarations* and *function expressions*.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最简单、最传统的方式来定义函数开始：*函数声明*和*函数表达式*。
- en: 3.3.1\. Function declarations and function expressions
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.1\. 函数声明和函数表达式
- en: The two most common ways of defining functions in JavaScript are by using function
    declarations and function expressions. These two techniques are so similar that
    often we don’t even make a distinction between them, but as you’ll see in the
    following chapters, subtle differences exist.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中定义函数的两种最常见的方式是使用函数声明和函数表达式。这两种技术非常相似，以至于我们经常甚至不区分它们，但正如你将在以下章节中看到的，存在细微的差异。
- en: Function declarations
  id: totrans-152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 函数声明
- en: 'The most basic way of defining a function in JavaScript is by using function
    declarations (see [figure 3.4](#ch03fig04)). As you can see, every function declaration
    starts with a mandatory `function` keyword, followed by a mandatory function name
    and a list of optional comma-separated parameter names enclosed within mandatory
    parentheses. The function body, which is a potentially empty list of statements,
    must be enclosed within an opening and a closing brace. In addition to this form,
    which every function declaration must satisfy, there’s one more condition: A function
    declaration must be placed on its own, as a separate JavaScript statement (but
    can be contained within another function or a block of code; you’ll see exactly
    what we mean by that in the next section).'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中定义函数最基本的方式是使用函数声明（参见[图3.4](#ch03fig04)）。正如你所看到的，每个函数声明都以一个强制性的`function`关键字开始，后面跟着一个强制性的函数名和一个可选的、用强制性的括号括起来的逗号分隔的参数名列表。函数体，一个可能为空的状态列表，必须被一个开括号和一个闭括号包围。除了这个每个函数声明都必须满足的形式之外，还有一个额外的条件：函数声明必须单独放置，作为一个独立的JavaScript语句（但可以包含在其他函数或代码块中；你将在下一节中看到我们确切的意思）。
- en: Figure 3.4\. The function declaration stands on its own, as a separate block
    of JavaScript code! (It can be contained within other functions.)
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.4\. 函数声明独立地站立，作为一个单独的JavaScript代码块！（它可以包含在其他函数中。）
- en: '![](03fig04_alt.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图片](03fig04_alt.jpg)'
- en: A couple of function declaration examples are shown in the following listing.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表展示了几个函数声明的例子。
- en: Listing 3.4\. Examples of function declarations
  id: totrans-157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.4\. 函数声明的例子
- en: '![](046fig01.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图片](046fig01.jpg)'
- en: 'If you take a closer look, you’ll see something that you might not be accustomed
    to, if you haven’t had much exposure to functional languages: a function defined
    within another function!'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察，你会发现一些你可能不习惯的东西，如果你没有太多接触过函数式语言：在另一个函数内部定义的函数！
- en: '[PRE13]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In JavaScript, this is perfectly normal, and we’ve used it here to again emphasize
    the importance of functions in JavaScript.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，这是完全正常的，我们在这里再次强调函数在JavaScript中的重要性。
- en: '|  |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-163
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Having functions contained in other functions might raise some tricky questions
    regarding scope and identifier resolution, but save them for now, because we’ll
    revisit this case in detail in [chapter 5](kindle_split_016.html#ch05).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他函数中包含函数可能会引起一些关于作用域和标识符解析的棘手问题，但先暂时放下，因为我们将在[第5章](kindle_split_016.html#ch05)中详细回顾这个案例。
- en: '|  |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Function expressions
  id: totrans-166
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 函数表达式
- en: As we’ve already mentioned multiple times, functions in JavaScript are first-class
    objects, which, among other things, means that they can be created via literals,
    assigned to variables and properties, and used as arguments and return values
    to and from other functions. Because functions are such fundamental constructs,
    JavaScript enables us to treat them as any other expressions. So, just as we can
    use number literals, for example
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们多次提到的，JavaScript中的函数是一等对象，这意味着它们可以通过字面量创建，分配给变量和属性，并用作其他函数的参数和返回值。因为函数是如此基本的构造，JavaScript允许我们将它们视为任何其他表达式。所以，就像我们可以使用数字字面量一样
- en: '[PRE14]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: so too we can use function literals, in the same locations
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们也可以在相同的位置使用函数字面量。
- en: '[PRE15]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Such functions that are always a part of another statement (for example, as
    the right side of an assignment expression, or as an argument to another function)
    are called *function expressions*. Function expressions are great because they
    allow us to define functions exactly where we need them, in the process making
    our code easier to understand.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这种始终是另一个语句一部分的函数（例如，作为赋值表达式的右侧，或作为另一个函数的参数）被称为*函数表达式*。函数表达式很棒，因为它们允许我们在需要的地方精确地定义函数，从而使得我们的代码更容易理解。
- en: The following listing shows the differences between function declarations and
    function expressions.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了函数声明和函数表达式的区别。
- en: Listing 3.5\. Function declarations and function expressions
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.5\. 函数声明和函数表达式
- en: '![](047fig01_alt.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图片](047fig01_alt.jpg)'
- en: 'This example code begins with a standard function declaration that contains
    another inner function declaration:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例代码从一个标准的函数声明开始，其中包含另一个内部函数声明：
- en: '[PRE16]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here you can see how function declarations are separate statements of JavaScript
    code, but can be contained within the body of other functions.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你可以看到函数声明是如何作为JavaScript代码的独立语句，但可以包含在其他函数的体内的。
- en: 'In contrast are function expressions, which are always a part of another statement.
    They’re placed on the expression level, as the right side of a variable declaration
    (or an assignment):'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，函数表达式始终是另一个语句的一部分。它们放置在表达式级别，作为变量声明（或赋值）的右侧：
- en: '[PRE17]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Or as an argument to another function call, or as a function return value:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 或者作为另一个函数调用的参数，或者作为函数的返回值：
- en: '[PRE18]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Besides the position in code where they’re placed, there’s one more difference
    between function declarations and function expressions: For function declarations,
    the function name is *mandatory*, whereas for function expressions it’s completely
    *optional*.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 除了它们在代码中的位置，函数声明和函数表达式之间还有一个区别：对于函数声明，函数名称是*必需的*，而对于函数表达式，它是完全*可选的*。
- en: Function declarations must have a name defined because they stand on their own.
    Because one of the basic requirements for a function is that it has to be invokable,
    we have to have a way to reference it, and the only way to do this is through
    its name.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 函数声明必须有一个已定义的名称，因为它们是独立的。因为函数的一个基本要求是它必须可调用，我们必须有一种方式来引用它，而唯一的方法是通过它的名称。
- en: 'Function expressions, on the other hand, are parts of other JavaScript expressions,
    so we have alternative ways to invoke them. For example, if a function expression
    is assigned to a variable, we can use that variable to invoke the function:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，函数表达式是其他JavaScript表达式的部分，因此我们有其他方法来调用它们。例如，如果一个函数表达式被分配给一个变量，我们可以使用该变量来调用函数：
- en: '[PRE19]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Or, if it’s an argument to another function, we can invoke it within that function
    through the matching parameter name:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果它是另一个函数的参数，我们可以在该函数内部通过匹配的参数名来调用它：
- en: '[PRE20]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Immediate Functions
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 立即函数
- en: Function expressions can even be placed in positions where they look a bit weird
    at first, such as at a location where we’d normally expect a function identifier.
    Let’s stop and take a closer look at that construct (see [figure 3.5](#ch03fig05)).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 函数表达式甚至可以被放置在最初看起来有点奇怪的位置，例如在我们通常期望函数标识符的位置。让我们停下来仔细看看这个结构（见图3.5）。
- en: Figure 3.5\. A comparison of a standard function call and an immediate call
    to a function expression
  id: totrans-190
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.5\. 标准函数调用与对函数表达式的立即调用的比较
- en: '![](03fig05_alt.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig05_alt.jpg)'
- en: When we want to make a function call, we use an expression that evaluates to
    a function, followed by a pair of function call parentheses, which might contain
    arguments. In the most basic function call, we put an identifier that evaluates
    to a function, as on the left side of [figure 3.5](#ch03fig05). But the expression
    to the left of the calling parenthesis doesn’t have to be a simple identifier;
    it can be *any* expression that evaluates to a function. For example, a simple
    way to specify an expression that evaluates to a function is to use a function
    expression. So on the right side of [figure 3.5](#ch03fig05), we first create
    a function, and then we immediately invoke that newly created function. This,
    by the way, is called an *immediately invoked function expression* (IIFE), or
    *immediate function* for short, and is an important concept in JavaScript development
    because it allows us to mimic modules in JavaScript. We’ll focus on this application
    of IIFEs in [chapter 11](kindle_split_023.html#ch11).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要进行函数调用时，我们使用一个求值结果为函数的表达式，后面跟着一对函数调用括号，其中可能包含参数。在最基本的函数调用中，我们放置一个求值结果为函数的标识符，就像[图3.5](#ch03fig05)的左侧所示。但是调用括号左侧的表达式不一定是简单的标识符；它可以是任何求值结果为函数的表达式。例如，指定一个求值结果为函数的表达式的一个简单方法就是使用函数表达式。所以[图3.5](#ch03fig05)的右侧，我们首先创建一个函数，然后立即调用这个新创建的函数。顺便说一句，这被称为**立即调用的函数表达式**（IIFE），或简称为**立即函数**，它是JavaScript开发中的一个重要概念，因为它允许我们在JavaScript中模拟模块。我们将在[第11章](kindle_split_023.html#ch11)中关注IIFE的这种应用。
- en: '|  |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Parentheses around function expressions**'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数表达式周围的括号**'
- en: 'One more thing might be nagging you about the way we’ve immediately called
    our function expression: the parentheses around the function expression itself.
    Why do we even need those? The reason is purely syntactical. The JavaScript parser
    has to be able to easily differentiate between function declarations and function
    expressions. If we leave out the parentheses around the function expression, and
    put our immediate call as a separate statement `function(){}(3)`, the JavaScript
    parser will start processing it, and will conclude, because it’s a separate statement
    starting with the keyword `function`, that it’s dealing with a function declaration.
    Because every function declaration has to have a name (and here we didn’t specify
    one), an error will be thrown. To avoid this, we place the function expression
    within parentheses, signaling to the JavaScript parser that it’s dealing with
    an expression, and not a statement.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事可能让你对我们在函数表达式周围立即调用函数的方式感到困扰：函数表达式本身的括号。我们为什么需要这些括号呢？原因纯粹是语法上的。JavaScript解析器必须能够轻松区分函数声明和函数表达式。如果我们省略函数表达式周围的括号，并将立即调用作为一个单独的语句`function(){}(3)`，JavaScript解析器将开始处理它，并得出结论，因为它是一个以关键字`function`开始的单独语句，所以它正在处理一个函数声明。因为每个函数声明都必须有一个名称（而在这里我们没有指定一个），将会抛出一个错误。为了避免这种情况，我们将函数表达式放在括号内，向JavaScript解析器发出信号，表明它正在处理一个表达式，而不是一个语句。
- en: 'There’s also an alternative, even simpler way (yet, strangely, a little less
    often used) of achieving the same goal: (`function(){}(3))`. By wrapping the immediate
    function definition and call within parentheses, you can also notify the JavaScript
    parser that it’s dealing with an expression.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一种更简单的方法（虽然奇怪，但使用频率较低）可以达到相同的目的：（`function(){}(3)`）。通过将立即执行函数定义和调用包裹在括号内，你也可以通知
    JavaScript 解析器它正在处理一个表达式。
- en: '|  |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'The last four expressions in [listing 3.5](#ch03ex05) are variations of the
    same theme of immediately invoked function expressions often found in various
    JavaScript libraries:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 3.5](#ch03ex05) 中的最后四个表达式是立即调用函数表达式（IIFE）的变体，这种表达式在许多 JavaScript 库中经常可以看到：'
- en: '[PRE21]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This time, instead of using parentheses around the function expressions to
    differentiate them from function declarations, we can use unary operators: `+`,
    `-`, `!`, and `~`. We do this to signal to the JavaScript engine that it’s dealing
    with expressions and not statements. Notice how the results of applying these
    unary operators aren’t stored anywhere; from a computational perspective, they
    don’t really matter; only the calls to our IIFEs matter.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们不再使用括号来区分函数表达式和函数声明，而是可以使用一元运算符：`+`、`-`、`!` 和 `~`。我们这样做是为了向 JavaScript
    引擎发出信号，表明它正在处理表达式而不是语句。注意应用这些一元运算符的结果并没有被存储在任何地方；从计算的角度来看，它们并不重要；只有对 IIFE 的调用才是重要的。
- en: 'Now that we’ve studied the ins and outs of the two most basic ways of defining
    functions in JavaScript (function declarations and function expressions), let’s
    explore a new addition to the JavaScript standard: *arrow functions*.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经研究了 JavaScript 中定义函数的两种最基本的方法（函数声明和函数表达式）的细节，让我们探索 JavaScript 标准中的一个新特性：*箭头函数*。
- en: 3.3.2\. Arrow functions
  id: totrans-202
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.2\. 箭头函数
- en: '|  |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-204
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Arrow functions are an ES6 addition to the JavaScript standard (for browser
    compatibility, see [http://mng.bz/8bnH](http://mng.bz/8bnH)).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数是 JavaScript 标准中 ES6 的一个新增特性（关于浏览器兼容性，请参阅 [http://mng.bz/8bnH](http://mng.bz/8bnH)）。
- en: '|  |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Because in our JavaScript we use *a lot* of functions, it makes sense to add
    some syntactic sugar that enables us to create functions in a shorter, more succinct
    way, thus making our lives as developers more pleasant.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在我们的 JavaScript 中使用了 *很多* 函数，所以添加一些语法糖，使我们能够以更短、更简洁的方式创建函数，从而让我们的开发生活更加愉快，这是有意义的。
- en: 'In a lot of ways, arrow functions are a simplification of function expressions.
    Let’s revisit our sorting example from the first section of this chapter:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在很多方面，箭头函数是函数表达式的一种简化。让我们回顾一下本章第一部分中的排序示例：
- en: '[PRE22]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This example uses a callback function expression sent to the sort method of
    the array object; this callback will be invoked by the JavaScript engine to sort
    the values of the array in descending order.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子使用了一个回调函数表达式，它被发送到数组对象的 sort 方法；这个回调将由 JavaScript 引擎调用，以按降序对数组的值进行排序。
- en: 'Now let’s see how to do the exact same thing with arrow functions:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用箭头函数做完全相同的事情：
- en: '[PRE23]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: See how much more succinct this is?
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这有多简洁？
- en: 'There’s no clutter caused by the `function` keyword, the braces, or the `return`
    statement. In a much simpler way than a function expression can, the arrow function
    states: here’s a function that takes two arguments and returns their difference.
    Notice the introduction of a new operator, `=>`, the so-called *fat-arrow* operator
    (an equals sign immediately followed by a greater-than sign), that’s at the core
    of defining an arrow function.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 没有由 `function` 关键字、花括号或 `return` 语句引起的杂乱。与函数表达式相比，箭头函数以一种更简单的方式声明：这是一个接受两个参数并返回它们差值的函数。注意新操作符
    `=>` 的引入，即所谓的 *粗箭头* 操作符（一个等于号紧跟着一个大于号），这是定义箭头函数的核心。
- en: 'Now let’s deconstruct the syntax of an arrow function, starting with the simplest
    possible way:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们分解箭头函数的语法，从最简单的方式开始：
- en: '[PRE24]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This arrow function takes a parameter and returns the value of an expression.
    We can use this syntax as shown in the following listing.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这个箭头函数接受一个参数并返回一个表达式的值。我们可以使用以下示例中的语法来使用这种语法。
- en: Listing 3.6\. Comparing an arrow function and a function expression
  id: totrans-218
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.6\. 比较箭头函数和函数表达式
- en: '![](051fig01_alt.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](051fig01_alt.jpg)'
- en: Take a while to appreciate how arrow functions make code more succinct, without
    sacrificing clarity. That’s the simplest version of the arrow function syntax,
    but in general, the arrow function can be defined in two ways, as shown in [figure
    3.6](#ch03fig06).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细欣赏箭头函数如何使代码更加简洁，同时不失清晰。这是箭头函数语法的最简单版本，但通常，箭头函数可以用两种方式定义，如图3.6所示。
- en: Figure 3.6\. The syntax of an arrow function
  id: totrans-221
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.6。箭头函数的语法
- en: '![](03fig06_alt.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig06_alt.jpg)'
- en: As you can see, the arrow function definition starts with an optional comma-separated
    list of parameter names. If there are no parameters, or more than one parameter,
    this list must be enclosed within parentheses. But if we have only a single parameter,
    the parentheses are optional. This list of parameters is followed by a mandatory
    fat-arrow operator, which tells us and the JavaScript engine that we’re dealing
    with an arrow function.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，箭头函数的定义从可选的逗号分隔的参数名列表开始。如果没有参数，或者参数超过一个，这个列表必须用括号括起来。但是，如果我们只有一个参数，括号是可选的。这个参数列表后面跟着一个强制性的粗箭头操作符，它告诉我们和JavaScript引擎我们正在处理一个箭头函数。
- en: 'After the fat-arrow operator, we have two options. If it’s a simple function,
    we put an expression there (a mathematical operation, another function invocation,
    whatever), and the result of the function invocation will be the value of that
    expression. For instance, our first arrow function example has the following arrow
    function:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在粗箭头操作符之后，我们有两种选择。如果是一个简单函数，我们就在那里放一个表达式（一个数学运算，另一个函数调用，等等），函数调用的结果将是该表达式的值。例如，我们的第一个箭头函数示例具有以下箭头函数：
- en: '[PRE25]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The return value of the function is a concatenation of the string “`Greetings`”
    with the value of the `name` parameter.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的返回值是字符串“`Greetings`”与`name`参数值的连接。
- en: 'In other cases, when our arrow functions aren’t that simple and require more
    code, we can include a block of code after the arrow operator. For example:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，当我们的箭头函数不那么简单且需要更多代码时，我们可以在箭头操作符之后包含一段代码块。例如：
- en: '[PRE26]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this case, the return value of the arrow function behaves as in a standard
    function. If there’s no return statement, the result of the function invocation
    will be `undefined`, and if there is, the result will be the value of the return
    expression.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，箭头函数的返回值行为与标准函数相同。如果没有返回语句，函数调用的结果将是`undefined`，如果有，结果将是返回表达式的值。
- en: We’ll revisit arrow functions multiple times throughout this book. Among other
    things, we’ll present additional features of arrow functions that will help us
    evade subtle bugs that can occur with more standard functions.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在整本书中多次回顾箭头函数。在众多其他事情中，我们将展示箭头函数的附加功能，这将帮助我们避免与更标准函数相关的微妙错误。
- en: Arrow functions, like all other functions, can receive arguments in order to
    use them to perform their task. Let’s see what happens with the values that we
    pass to a function.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数，像所有其他函数一样，可以通过传递参数来接收它们以执行其任务。让我们看看我们传递给函数的值会发生什么。
- en: 3.4\. Arguments and function parameters
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4。参数和函数参数
- en: 'When discussing functions, we often use the terms *argument* and *parameter*
    almost interchangeably, as if they were more or less the same thing. But now,
    let’s be more formal:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论函数时，我们经常几乎互换使用术语*参数*和*参数*，好像它们是或多或少相同的东西。但现在，让我们更加正式：
- en: A *parameter* is a variable that we list as part of a function definition.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*参数*是我们将作为函数定义一部分列出的变量。'
- en: An *argument* is a value that we pass to the function when we invoke it.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*参数*是我们调用函数时传递给函数的值。'
- en: '[Figure 3.7](#ch03fig07) illustrates the difference.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.7](#ch03fig07)说明了这种区别。'
- en: Figure 3.7\. The difference between function parameters and function arguments
  id: totrans-237
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.7。函数参数和函数参数之间的区别
- en: '![](03fig07_alt.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig07_alt.jpg)'
- en: 'As you can see, a function parameter is specified with the definition of the
    function, and all types of functions can have parameters:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，函数参数是在函数定义中指定的，所有类型的函数都可以有参数：
- en: Function declarations (the `ninja` parameter to the `skulk` function)
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数声明（`skulk`函数的`ninja`参数）
- en: Function expressions (the `person` and `action` parameters to the `perform-Action`
    function)
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数表达式（`perform-Action`函数的`person`和`action`参数）
- en: Arrow functions (the `daimyo` parameter)
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箭头函数（`daimyo`参数）
- en: 'Arguments, on the other hand, are linked with the invocation of the function;
    they’re values passed to a function at the time of its invocation:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，参数与函数的调用相关联；它们是在函数调用时传递给函数的值：
- en: The string `Hattori` is passed as an argument to the `skulk` function.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串`Hattori`被传递为`skulk`函数的参数。
- en: The string `Oda Nobunaga` is passed as an argument to the `rule` function.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串`Oda Nobunaga`被传递为`rule`函数的参数。
- en: The parameter `ninja` of the `skulk` function is passed as an argument to the
    `performAction` function.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skulk`函数的`ninja`参数被传递为`performAction`函数的参数。'
- en: When a list of arguments is supplied as a part of a function invocation, these
    arguments are assigned to the parameters in the function definition in the order
    specified. The first argument gets assigned to the first parameter, the second
    argument to the second parameter, and so on.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当将参数列表作为函数调用的一部分提供时，这些参数将按照指定的顺序分配给函数定义中的参数。第一个参数被分配给第一个参数，第二个参数被分配给第二个参数，依此类推。
- en: If we have a different number of arguments than parameters, no error is raised.
    JavaScript is perfectly fine with this situation and deals with it in the following
    way. If more arguments are supplied than there are parameters, the “excess” arguments
    aren’t assigned to parameter names. For example, see [figure 3.8](#ch03fig08).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的参数数量与参数数量不同，不会引发错误。JavaScript对这种情况处理得很好，并按以下方式处理。如果提供的参数多于参数，则“多余的”参数不会被分配给参数名称。例如，请参阅[图3.8](#ch03fig08)。
- en: Figure 3.8\. Arguments are assigned to function parameters in the order specified.
    Excess arguments aren’t assigned to any parameters.
  id: totrans-249
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.8\. 参数按照指定的顺序分配给函数参数。多余的参数不会被分配给任何参数。
- en: '![](03fig08_alt.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig08_alt.jpg)'
- en: '[Figure 3.8](#ch03fig08) shows that if we were to call the `practice` function
    with `practice("Yoshi", "sword", "shadow sword", "katana")`, the arguments `Yoshi`,
    `sword`, and `shadow sword` would be assigned to the parameters `ninja`, `weapon`,
    and `technique`, respectively. The argument `katana` is an excess argument, and
    wouldn’t be assigned to any parameter. In the next chapter, you’ll see that even
    though some arguments aren’t assigned to parameter names, we still have a way
    to access them.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.8](#ch03fig08)显示，如果我们调用`practice`函数并使用`practice("Yoshi", "sword", "shadow
    sword", "katana")`，参数`Yoshi`、`sword`和`shadow sword`将分别分配给参数`ninja`、`weapon`和`technique`。参数`katana`是一个多余的参数，不会被分配给任何参数。在下一章中，您将看到即使某些参数没有被分配给参数名称，我们仍然有方法访问它们。'
- en: On the other hand, if we have more parameters than arguments, the parameters
    that have no corresponding argument are set to `undefined`. For example, if we
    were to make the call `practice("Yoshi")`, the parameter `ninja` would be assigned
    the value `Yoshi`, while the parameters `weapon` and `technique` would be set
    to `undefined`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们有比参数更多的参数，没有对应参数的参数将被设置为`undefined`。例如，如果我们调用`practice("Yoshi")`，参数`ninja`将被分配值`Yoshi`，而参数`weapon`和`technique`将被设置为`undefined`。
- en: 'Dealing with function arguments and parameters is as old as JavaScript itself,
    but now let’s explore two new features of JavaScript bestowed by ES6: rest and
    default parameters.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 处理函数参数与JavaScript本身一样古老，但现在让我们来探索ES6赋予JavaScript的两个新特性：剩余参数和默认参数。
- en: 3.4.1\. Rest parameters
  id: totrans-254
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.4.1\. 剩余参数
- en: '|  |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-256
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Rest parameters are added by the ES6 standard (for browser compatibility, see
    [http://mng.bz/3go1](http://mng.bz/3go1)).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ES6标准（为了浏览器兼容性，请参阅[http://mng.bz/3go1](http://mng.bz/3go1)）增加了剩余参数。
- en: '|  |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: For our next example, we’ll build a function that multiplies the first argument
    with the largest of the remaining arguments. This probably isn’t something that’s
    particularly applicable in our applications, but it’s an example of yet more techniques
    for dealing with arguments within a function.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一个例子中，我们将构建一个函数，该函数将第一个参数与剩余参数中的最大值相乘。这可能不是我们应用中特别适用的东西，但它是对函数内处理参数的更多技术的示例。
- en: 'This might seem simple enough: We’ll grab the first argument and multiply it
    by the biggest of the remaining argument values. In the old versions of JavaScript,
    this would require some workarounds (which we’ll look at in the next chapter).
    Luckily, in ES6, we don’t need to jump through any hoops. We can use *rest parameters,*
    as shown in the following listing.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来很简单：我们将获取第一个参数并将其与剩余参数值中的最大值相乘。在JavaScript的旧版本中，这需要一些工作（我们将在下一章中探讨）。幸运的是，在ES6中，我们不需要跳过任何障碍。我们可以使用*剩余参数*，如下面的列表所示。
- en: Listing 3.7\. Using rest parameters
  id: totrans-261
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.7\. 使用剩余参数
- en: '![](054fig01_alt.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![](054fig01_alt.jpg)'
- en: By prefixing the last-named argument of a function with an ellipsis (...), we
    turn it into an array called *the rest parameters*, which contains the remaining
    passed-in arguments.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在函数的最后一个命名参数前加上省略号（...），我们将其转换成一个名为*剩余参数*的数组，它包含所有传入的剩余参数。
- en: '[PRE27]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'For example, in this case, the `multiMax` function is called with four arguments:
    `multiMax(3, 1, 2, 3)`. In the body of the `multiMax` function, the value of the
    first argument, `3`, is assigned to the first `multiMax` function parameter, `first`.
    Because the second parameter of the function is the rest parameter, all remaining
    arguments (`1, 2, 3`) are placed in a new array: `remainingNumbers`. We then obtain
    the biggest number by sorting the array in descending order (notice how it’s simple
    to change the sorting order) and picking the largest number, which is in the first
    place of our sorted array. (This is far from the most efficient way of determining
    the largest number, but why not take advantage of the skills we gained earlier
    in the chapter?)'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在这种情况下，`multiMax` 函数使用四个参数被调用：`multiMax(3, 1, 2, 3)`。在 `multiMax` 函数体内，第一个参数的值，`3`，被分配给第一个
    `multiMax` 函数参数，`first`。因为函数的第二个参数是剩余参数，所以所有剩余的参数（`1, 2, 3`）都被放置在一个新的数组中：`remainingNumbers`。然后我们通过按降序排序数组（注意如何简单地更改排序顺序）并选择排序数组中的第一个数字来获取最大的数字，这个数字就是我们的排序数组中的第一个位置。（这远非确定最大数字的最有效方法，但为什么不利用我们在本章早期获得的知识呢？）
- en: '|  |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-267
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'Only the last function parameter can be a rest parameter. Trying to put the
    ellipsis in front of any parameter that isn’t last will bring us only sorrow,
    in the form of `SyntaxError: parameter after rest parameter`.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '只有最后一个函数参数可以是剩余参数。尝试在最后一个参数之前的任何参数前放置省略号将只会带来悲伤，以`SyntaxError: parameter after
    rest parameter`的形式。'
- en: '|  |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'In the next section, we’ll continue adding to our JavaScript tool belt with
    additional ES6 functionality: default parameters.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将继续丰富我们的 JavaScript 工具箱，添加额外的 ES6 功能：默认参数。
- en: 3.4.2\. Default parameters
  id: totrans-271
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.4.2\. 默认参数
- en: '|  |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-273
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Default parameters are added by the ES6 standard (for browser compatibility,
    see [http://mng.bz/wI8w](http://mng.bz/wI8w)).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 默认参数由 ES6 标准（为了浏览器兼容性，请参阅[http://mng.bz/wI8w](http://mng.bz/wI8w)）添加。
- en: '|  |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Many web UI components (especially jQuery plugins) can be configured. For example,
    if we’re developing a slider component, we might want to give our users an option
    to specify a timer interval after which one item is replaced with another, as
    well as an animation that will be used as the change occurs. At the same time,
    maybe some users don’t care and are happy to use whatever settings we offer. Default
    parameters are ideal for such situations!
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 Web UI 组件（尤其是 jQuery 插件）可以进行配置。例如，如果我们正在开发一个滑动组件，我们可能希望给我们的用户提供一个选项，指定一个计时器间隔，在此之后一个项目会被另一个项目替换，以及一个在变化发生时使用的动画。同时，也许有些用户并不关心，并且乐于使用我们提供的任何设置。默认参数是这种情况的理想选择！
- en: 'Our little example with slider component settings is just a specific case of
    a situation in which *almost* all function calls use the same value for a particular
    parameter (notice the emphasis on *almost)*. Consider a simpler case in which
    most of our ninjas are used to skulking around, but not Yagyu, who cares only
    about simple sneaking:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们关于滑动组件设置的简单示例只是以下情况的一个具体案例：在这种情况下，几乎所有函数调用都使用特定参数的相同值（注意对*几乎*的强调）。考虑一个更简单的情况，我们的大多数忍者都习惯于潜行，但柳生却只关心简单的潜行：
- en: '[PRE28]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Doesn’t it seem tedious to always have to repeat the same argument, `skulking`,
    simply because Yagyu is obstinate and refuses to act like a proper ninja?
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 总是重复相同的论点，`潜行`，仅仅因为柳生固执且拒绝像一名真正的忍者那样行动，这难道不觉得繁琐吗？
- en: In other programming languages, this problem is most often solved with function
    overloading (specifying additional functions with the same name but a different
    set of parameters). Unfortunately, JavaScript doesn’t support function overloading,
    so when faced with this situation in the past, developers often resorted to something
    like the following listing.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他编程语言中，这个问题通常通过函数重载（指定具有相同名称但参数集不同的额外函数）来解决。不幸的是，JavaScript 不支持函数重载，所以当过去遇到这种情况时，开发者通常会求助于以下列表。
- en: Listing 3.8\. Tackling default parameters before ES6
  id: totrans-281
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.8\. 在 ES6 之前处理默认参数
- en: '![](056fig01_alt.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![](056fig01_alt.jpg)'
- en: Here we define a `performAction` function, which checks whether the value of
    the `action` parameter is `undefined` (by using the `typeof` operator), and if
    it is, the function sets the value of the `action` variable to `skulking`. If
    the `action` parameter is sent through a function call (it’s not `undefined`),
    we keep the value.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个 `performAction` 函数，该函数检查 `action` 参数的值是否为 `undefined`（通过使用 `typeof`
    运算符），如果是，则函数将 `action` 变量的值设置为 `skulking`。如果 `action` 参数通过函数调用传递（它不是 `undefined`），我们保持其值。
- en: '|  |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-285
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The `typeof` operator returns a string indicating the type of the operand. If
    the operand isn’t defined (for example, if we haven’t supplied a matching argument
    for a function parameter), the return value is the string `undefined`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`typeof` 运算符返回一个字符串，指示操作数的类型。如果操作数未定义（例如，如果我们没有为函数参数提供匹配的参数），则返回值是字符串 `undefined`。'
- en: '|  |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: This is a commonly occurring pattern that’s tedious to write, so the ES6 standard
    has added support for *default parameters*, as shown in the following listing.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个常见的模式，编写起来很繁琐，因此 ES6 标准已经添加了对 *默认参数* 的支持，如下所示。
- en: Listing 3.9\. Tackling default parameters in ES6
  id: totrans-289
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.9. 在 ES6 中处理默认参数
- en: '![](057fig01_alt.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![图片](057fig01_alt.jpg)'
- en: 'Here you can see the syntax of default function parameters in JavaScript. To
    create a default parameter, we assign a value to a function parameter:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到 JavaScript 中默认函数参数的语法。要创建默认参数，我们给函数参数赋值：
- en: '[PRE29]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, when we make a function call and the matching argument value is left
    out, as with `Fuma`, `Yoshi`, and `Hattori`, the default value (in this case,
    `skulking`), is used:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当我们进行函数调用并且省略了匹配的参数值，就像 `Fuma`、`Yoshi` 和 `Hattori` 一样，将使用默认值（在这种情况下，`skulking`）：
- en: '[PRE30]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If, on the other hand, we specify the value, the default value is overridden:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们指定了值，则默认值将被覆盖：
- en: '[PRE31]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can assign any values to default parameters: simple, primitive values such
    as numbers or strings, but also complex types such as objects, arrays, and even
    functions. The values are evaluated on each function call, from left to right,
    and when assigning values to later default parameters, we can reference previous
    parameters, as in the following listing.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将任何值分配给默认参数：简单的原始值，如数字或字符串，也可以是复杂类型，如对象、数组，甚至是函数。这些值在每次函数调用时按从左到右的顺序进行评估，并且在将值分配给后续的默认参数时，我们可以引用前面的参数，如下所示。
- en: Listing 3.10\. Referencing previous default parameters
  id: totrans-298
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.10. 引用之前的默认参数
- en: '![](058fig01_alt.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![图片](058fig01_alt.jpg)'
- en: Even though JavaScript allows you to do something like this, we urge caution.
    In our opinion, this doesn’t enhance code readability and should be avoided, whenever
    possible. But moderate use of default parameters—as a means of avoiding null values,
    or as relatively simple flags that configure the behaviors of our functions—can
    lead to much simpler and more elegant code.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 JavaScript 允许你这样做，但我们强烈建议谨慎行事。在我们看来，这并不增强代码的可读性，并且应该尽可能避免。但是，适度使用默认参数——作为避免
    null 值的手段，或者作为相对简单的标志来配置我们函数的行为——可以导致更简单、更优雅的代码。
- en: 3.5\. Summary
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5. 摘要
- en: Writing sophisticated code hinges upon learning JavaScript as a functional language.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写复杂的代码取决于将 JavaScript 作为函数式语言来学习。
- en: Functions are first-class objects that are treated just like any other objects
    within JavaScript. Similar to any other object type, they can be
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数是第一类对象，在 JavaScript 中被当作任何其他对象一样对待。类似于任何其他对象类型，它们可以被
- en: Created via literals
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过字面量创建
- en: Assigned to variables or properties
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配给变量或属性
- en: Passed as parameters
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为参数传递
- en: Returned as function results
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为函数结果返回
- en: Assigned properties and methods
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配属性和方法
- en: Callback functions are functions that other code will later “call back,” and
    are often used, especially with event handling.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调函数是其他代码将后来“回调”的函数，并且通常在事件处理中使用。
- en: We can take advantage of the fact that functions can have properties and that
    those properties can be used to store any information; for example
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以利用函数可以具有属性，并且这些属性可以用来存储任何信息的事实；例如
- en: We can store functions in function properties for later reference and invocation.
  id: totrans-311
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将函数存储在函数属性中以供以后引用和调用。
- en: We can use function properties to create a cache (memoization), thereby avoiding
    unnecessary computations.
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用函数属性来创建缓存（记忆化），从而避免不必要的计算。
- en: 'There are different types of functions: function declarations, function expressions,
    arrow functions, and function generators.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有不同类型的函数：函数声明、函数表达式、箭头函数和函数生成器。
- en: Function declarations and function expressions are the two most common types
    of functions. Function declarations must have a name, and must be placed as separate
    statements in our code. Function expressions don’t have to be named, but do have
    to be a part of another code statement.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数声明和函数表达式是两种最常见的函数类型。函数声明必须有一个名称，并且必须作为单独的语句放置在我们的代码中。函数表达式不需要命名，但必须是另一个代码语句的一部分。
- en: Arrow functions are a new addition to JavaScript, enabling us to define functions
    in a much more succinct way than with standard functions.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箭头函数是JavaScript的新增功能，它使我们能够以比标准函数更简洁的方式定义函数。
- en: A parameter is a variable that we list as a part of a function definition, whereas
    an argument is a value that we pass to the function when we invoke it.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数是我们将作为函数定义一部分列出的变量，而参数是我们调用函数时传递给函数的值。
- en: 'A function’s parameter list and its argument list can be different lengths:'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的参数列表和其参数列表可以有不同的长度：
- en: Unassigned parameters evaluate as `undefined`.
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未分配的参数评估为`undefined`。
- en: Extra arguments aren’t bound to parameter names.
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 额外的参数不会绑定到参数名称。
- en: 'Rest parameters and default parameters are new additions to JavaScript:'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 休息参数和默认参数是JavaScript的新增功能：
- en: Rest parameters enable us to reference the remaining arguments that don’t have
    matching parameter names.
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 休息参数使我们能够引用没有匹配参数名称的剩余参数。
- en: Default parameters enable us to specify default parameter values that will be
    used if no value is supplied during function invocation.
  id: totrans-322
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认参数使我们能够指定默认参数值，当在函数调用期间未提供值时将使用这些值。
- en: 3.6\. Exercises
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6\. 练习
- en: '**1**'
  id: totrans-324
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**'
- en: ''
  id: totrans-325
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the following code snippet, which functions are callback functions?
  id: totrans-326
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在以下代码片段中，哪些是回调函数？
- en: ''
  id: totrans-327
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-328
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '**2**'
  id: totrans-329
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**'
- en: ''
  id: totrans-330
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the following snippet, categorize functions according to their type (function
    declaration, function expression, or arrow function).
  id: totrans-331
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在以下代码片段中，根据其类型（函数声明、函数表达式或箭头函数）对函数进行分类。
- en: ''
  id: totrans-332
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-333
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '**3**'
  id: totrans-334
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**'
- en: ''
  id: totrans-335
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: After executing the following code snippet, what are the values of variables
    `samurai` and `ninja`?
  id: totrans-336
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 执行以下代码片段后，变量`samurai`和`ninja`的值是什么？
- en: ''
  id: totrans-337
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-338
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '**4**'
  id: totrans-339
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**'
- en: ''
  id: totrans-340
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Within the body of the `test` function, what are the values of parameters `a`,
    `b`, and `c` for the two function calls?
  id: totrans-341
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在`test`函数体内部，对于两次函数调用，参数`a`、`b`和`c`的值是什么？
- en: ''
  id: totrans-342
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-343
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '**5**'
  id: totrans-344
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**5**'
- en: ''
  id: totrans-345
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: After executing the following code snippet, what are the values of the `message1`
    and `message2` variables?
  id: totrans-346
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 执行以下代码片段后，`message1`和`message2`变量的值是什么？
- en: ''
  id: totrans-347
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-348
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Chapter 4\. Functions for the journeyman: understanding function invocation'
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第四章\. 适合工匠的函数：理解函数调用
- en: '*This chapter covers*'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: 'Two implicit function parameters: arguments and this'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个隐式函数参数：arguments和this
- en: Ways of invoking functions
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用函数的方法
- en: Dealing with problems of function contexts
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理函数上下文的问题
- en: In the previous chapter, you saw that JavaScript is a programming language with
    significant functionally oriented characteristics. We explored the differences
    between function call arguments and function parameters, and how the values are
    transferred from call arguments to function parameters.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您了解到JavaScript是一种具有显著功能导向特性的编程语言。我们探讨了函数调用参数和函数参数之间的区别，以及值是如何从调用参数传递到函数参数的。
- en: 'This chapter continues in a similar vein, by first discussing something that
    we kept from you in the previous chapter: the implicit function parameters `this`
    and `arguments`. These are silently passed to functions and can be accessed just
    like any other explicitly named function parameter within the function’s body.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 本章继续以类似的方式展开，首先讨论我们在上一章中保留的内容：隐式函数参数`this`和`arguments`。这些参数被静默传递给函数，并且可以在函数体内部像任何其他显式命名的函数参数一样访问。
- en: The `this` parameter represents the function context, the object on which our
    function is invoked, whereas the `arguments` parameter represents all arguments
    that are passed in through a function call. Both parameters are vital in JavaScript
    code. The `this` parameter is one of the fundamental ingredients of object-oriented
    JavaScript, and the `arguments` parameter allows us to be creative with the arguments
    that are accepted by our functions. For this reason, we’ll explore some of the
    common pitfalls related to these implicit arguments.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '`this` 参数代表函数上下文，即我们的函数被调用的对象，而 `arguments` 参数代表通过函数调用传入的所有参数。这两个参数在 JavaScript
    代码中都非常重要。`this` 参数是面向对象 JavaScript 的基本成分之一，而 `arguments` 参数使我们能够对函数接受的参数进行创造性使用。因此，我们将探讨一些与这些隐含参数相关的常见陷阱。'
- en: We’ll then continue by exploring ways of invoking functions in JavaScript. The
    way in which we invoke a function has a great influence on how the implicit function
    parameters are determined.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将继续探讨在 JavaScript 中调用函数的方法。我们调用函数的方式对隐含函数参数的确定有很大影响。
- en: Finally, we’ll conclude the chapter by learning about common gotchas related
    to the function context, the `this` parameter. Without further ado, let’s start
    exploring!
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将通过学习与函数上下文、`this` 参数相关的常见问题来结束本章。无需多言，让我们开始探索吧！
- en: Do you know?
  id: totrans-359
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你知道吗？
- en: '**Q1:**'
  id: totrans-360
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Q1:**'
- en: ''
  id: totrans-361
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why is the `this` parameter known as the function *context*?
  id: totrans-362
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么 `this` 参数被称为函数 *上下文*？
- en: '**Q2:**'
  id: totrans-363
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Q2:**'
- en: ''
  id: totrans-364
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What’s the difference between a function and a method?
  id: totrans-365
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 函数和方法之间的区别是什么？
- en: '**Q3:**'
  id: totrans-366
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Q3:**'
- en: ''
  id: totrans-367
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What would happen if a constructor function explicitly returned an object?
  id: totrans-368
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果构造函数明确返回一个对象会发生什么？
- en: 4.1\. Using implicit function parameters
  id: totrans-369
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1\. 使用隐含函数参数
- en: 'In the preceding chapter, we explored the differences between function *parameters*
    (variables listed as part of a function definition) and function *arguments* (values
    passed to the function when we invoke it). But we didn’t mention that in addition
    to the parameters that we’ve explicitly stated in the function definition, function
    invocations are usually passed two implicit parameters: `arguments` and `this`.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了函数 *参数*（作为函数定义一部分列出的变量）和函数 *参数*（当我们调用函数时传递给函数的值）之间的区别。但我们没有提到，除了我们在函数定义中明确声明的参数之外，函数调用通常还传递两个隐含参数：`arguments`
    和 `this`。
- en: By *implicit*, we mean that these parameters aren’t explicitly listed in the
    function signature, but are silently passed to the function and accessible within
    the function. They can be referenced within the function just like any other explicitly
    named parameter. Let’s take a look at each of these implicit parameters in turn.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 *隐含的*，我们是指这些参数没有在函数签名中明确列出，但它们被默默地传递给函数，并在函数内部可访问。它们可以在函数内部像任何其他明确命名的参数一样被引用。让我们依次查看这些隐含参数。
- en: 4.1.1\. The arguments parameter
  id: totrans-372
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.1\. 参数
- en: The `arguments` parameter is a collection of all arguments passed to a function.
    It’s useful because it allows us to access all function arguments, regardless
    of whether the matching parameter is explicitly defined. This allows us to implement
    function overloading, a feature that JavaScript doesn’t natively support, and
    variadic functions that accept a variable number of arguments. To be honest, with
    `rest` parameters, introduced in the preceding chapter, the need for the `arguments`
    parameter has been greatly reduced. Still, it’s important to understand how the
    `arguments` parameter works, because you’re bound to run into it when dealing
    with legacy code.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '`arguments` 参数是传递给函数的所有参数的集合。它很有用，因为它允许我们访问所有函数参数，无论匹配的参数是否明确定义。这使我们能够实现函数重载，这是
    JavaScript 本身不支持的功能，以及接受可变数量参数的变长函数。说实话，由于上一章引入的 `rest` 参数，`arguments` 参数的需要已经大大减少。然而，了解
    `arguments` 参数的工作方式仍然很重要，因为当你处理遗留代码时，你很可能会遇到它。'
- en: The `arguments` object has a property named `length` that indicates the exact
    number of arguments. The individual argument values can be obtained by using array
    indexing notation; for example, `arguments[2]` would fetch the third parameter.
    Take a look at the following listing.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '`arguments` 对象有一个名为 `length` 的属性，表示参数的确切数量。可以通过数组索引表示法获取单个参数值；例如，`arguments[2]`
    将获取第三个参数。请看下面的列表。'
- en: Listing 4.1\. Using the arguments parameter
  id: totrans-375
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.1\. 使用参数
- en: '![](063fig01_alt.jpg)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: '![](063fig01_alt.jpg)'
- en: 'Here we have a `whatever` function that gets called with five arguments, `whatever
    (1,2,3,4,5)`, even though it has only three declared parameters, `a, b, c`:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个 `whatever` 函数，它被调用了五个参数，`whatever (1,2,3,4,5)`，尽管它只声明了三个参数，`a, b, c`：
- en: '[PRE37]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can access the first three arguments through their respective function parameters,
    `a`, `b`, and `c`:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过各自的功能参数 `a`、`b` 和 `c` 访问前三个参数：
- en: '[PRE38]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We can also check how many arguments in total were passed to the function by
    using the `arguments.length` property.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过使用 `arguments.length` 属性来检查传递给函数的总参数数。
- en: 'The `arguments` parameter can also be used to access each individual argument
    through array notation. It’s important to note that this also includes the excess
    arguments that aren’t associated with any function parameters:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '`arguments` 参数也可以用来通过数组表示法访问每个单独的参数。重要的是要注意，这也包括与任何函数参数都不相关的多余参数：'
- en: '[PRE39]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Throughout this section, we go out of our way to avoid calling the `arguments`
    parameter an *array*. You may be fooled into thinking that it’s an array; after
    all, it has a `length` parameter and its entries can be fetched using array notation.
    But it’s *not* a JavaScript array, and if you try to use array methods on `arguments`
    (for example, the `sort` method used in the previous chapter), you’ll find nothing
    but heartbreak and disappointment. Just think of `arguments` as an *array-like*
    construct, and exhibit restraint in its use.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们特意避免将 `arguments` 参数称为 *数组*。你可能会被误导，认为它是一个数组；毕竟，它有一个 `length` 参数，并且可以使用数组表示法获取其条目。但它
    *不是* 一个 JavaScript 数组，如果你尝试在 `arguments` 上使用数组方法（例如，在上一章中使用的 `sort` 方法），你会发现只有失望和心碎。只需将
    `arguments` 视为一个 *类似数组* 的结构，并在使用时保持克制。
- en: As we’ve already mentioned, the main point of the `arguments` object is to allow
    us to access all arguments that were passed to the function, regardless of whether
    a particular argument is associated with a function parameter. Let’s see how to
    do this by implementing a function that can calculate the sum of an arbitrary
    number of arguments.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，`arguments` 对象的主要目的是允许我们访问传递给函数的所有参数，无论特定参数是否与函数参数相关联。让我们通过实现一个可以计算任意数量参数的总和的函数来了解如何做到这一点。
- en: Listing 4.2\. Using the arguments object to perform operations on all function
    arguments
  id: totrans-386
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.2\. 使用参数对象对所有函数参数进行操作
- en: '![](064fig01_alt.jpg)'
  id: totrans-387
  prefs: []
  type: TYPE_IMG
  zh: '![](064fig01_alt.jpg)'
- en: Here we first define a `sum` function that doesn’t explicitly list any parameters.
    Regardless of this, we can still access all function arguments through the `arguments`
    object. We iterate through all the arguments and calculate their sum.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先定义了一个 `sum` 函数，它没有明确列出任何参数。尽管如此，我们仍然可以通过 `arguments` 对象访问所有函数参数。我们遍历所有参数并计算它们的总和。
- en: Now comes the payoff. We can call the function with any number of arguments,
    so we test a couple of cases to see if everything works. This is the true power
    of the `arguments` object. It allows us to write more versatile and flexible functions
    that can easily deal with different situations.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是回报的时候了。我们可以用任意数量的参数调用函数，所以我们对几个案例进行了测试，看看是否一切正常。这是 `arguments` 对象的真正力量。它允许我们编写更灵活、更通用的函数，这些函数可以轻松处理不同的情况。
- en: '|  |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-391
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: We mentioned earlier that in a lot of cases we can use the `rest` parameter
    instead of the `arguments` parameter. The `rest` parameter is a real array, which
    means that we can use all our favorite array methods on it. This gives it a certain
    advantage over the `arguments` object. As an exercise, rewrite [listing 4.2](#ch04ex02)
    to use the `rest` parameter instead of the `arguments` parameter.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到，在许多情况下，我们可以使用 `rest` 参数而不是 `arguments` 参数。`rest` 参数是一个真正的数组，这意味着我们可以使用所有我们喜欢的数组方法来操作它。这使它在某种程度上优于
    `arguments` 对象。作为一个练习，将 [列表 4.2](#ch04ex02) 重写为使用 `rest` 参数而不是 `arguments` 参数。
- en: '|  |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Now that we understand how the `arguments` object works, let’s explore some
    of its gotchas.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 `arguments` 对象的工作原理，让我们来探讨一些它的陷阱。
- en: Arguments object as an alias to function parameters
  id: totrans-395
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 参数对象作为函数参数的别名
- en: 'The `arguments` parameter has one curious feature: It aliases function parameters.
    If we set a new value to, for example, `arguments[0]`, the value of the first
    parameter will also be changed. Take a look at the following listing.'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '`arguments` 参数有一个奇特的功能：它将函数参数作为别名。如果我们为例如 `arguments[0]` 设置一个新值，第一个参数的值也会改变。请看以下列表。'
- en: Listing 4.3\. The arguments object aliases function parameters
  id: totrans-397
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.3\. 参数对象别名函数参数
- en: '![](065fig01_alt.jpg)'
  id: totrans-398
  prefs: []
  type: TYPE_IMG
  zh: '![](065fig01_alt.jpg)'
- en: 'You can see how the `arguments` object is an alias for the function parameters.
    We define a function, `infiltrate`, that takes a single parameter, `person`, and
    we invoke it with the argument `gardener`. We can access the value `gardener`
    through the function parameter `person` and through the `arguments` object:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到 `arguments` 对象是如何作为函数参数的代理的。我们定义了一个函数 `infiltrate`，它接受一个参数 `person`，并用参数
    `gardener` 调用它。我们可以通过函数参数 `person` 和 `arguments` 对象访问值 `gardener`：
- en: '[PRE40]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Because the `arguments` object is an alias for the function parameters, if
    we change the `arguments` object, the change is also reflected in the matching
    function parameter:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `arguments` 对象是函数参数的代理，如果我们改变 `arguments` 对象，这种改变也会反映在匹配的函数参数上：
- en: '[PRE41]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The same holds true in the other direction. If we change a parameter, the change
    can be observed in both the parameter and the `arguments` object:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的情况也适用于另一个方向。如果我们改变一个参数，这种改变可以在参数和 `arguments` 对象中观察到：
- en: '[PRE42]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Avoiding aliases
  id: totrans-405
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 避免代理
- en: The concept of aliasing function parameters through the `arguments` object can
    be confusing, so JavaScript provides a way to opt out of it by using *strict mode*.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `arguments` 对象代理函数参数的概念可能会令人困惑，因此JavaScript提供了一种通过使用 *严格模式* 来退出该模式的方法。
- en: '|  |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Strict mode**'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '**严格模式**'
- en: Strict mode is an ES5 addition to JavaScript that changes the behavior of JavaScript
    engines so that errors are thrown instead of silently picked up. The behavior
    of some language features is changed, and some unsafe language features are even
    completely banned (more on this later). One of the things that strict mode changes
    is that it disables `arguments` aliasing.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 严格模式是JavaScript ES5的一个新增功能，它改变了JavaScript引擎的行为，使得错误被抛出而不是静默地捕获。一些语言特性的行为发生了变化，甚至一些不安全的语言特性被完全禁止（关于这一点稍后还会提到）。严格模式改变的事情之一是它禁用了
    `arguments` 代理。
- en: '|  |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: As always, let’s take a look at a simple example.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，让我们看看一个简单的例子。
- en: Listing 4.4\. Using strict mode to avoid arguments aliasing
  id: totrans-412
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.4\. 使用严格模式避免参数代理
- en: '![](066fig01_alt.jpg)'
  id: totrans-413
  prefs: []
  type: TYPE_IMG
  zh: '![](066fig01_alt.jpg)'
- en: 'Here we start by placing the simple string `use strict` as the first line of
    code. This tells the JavaScript engine that we want to execute the following code
    in strict mode. In this example, strict mode changes the semantics of our program
    in a way that the `person` parameter and the first `argument` start with the same
    value:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将简单的字符串 `use strict` 作为代码的第一行。这告诉JavaScript引擎我们想要以严格模式执行以下代码。在这个例子中，严格模式改变了我们程序的含义，使得
    `person` 参数和第一个 `argument` 以相同的值开始：
- en: '[PRE43]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'But, unlike in nonstrict mode, this time around the `arguments` object doesn’t
    alias the parameters. If we change the value of the first argument, `arguments[0]
    = ''ninja''`, the first argument is changed, but the `person` parameter isn’t:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，与非严格模式不同，这次 `arguments` 对象并没有代理参数。如果我们改变第一个参数的值，`arguments[0] = 'ninja'`，第一个参数的值会改变，但
    `person` 参数不会：
- en: '[PRE44]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We’ll revisit the `arguments` object later in this book, but for now, let’s
    focus on another implicit parameter: `this`, which is in some ways even more interesting.'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的后面部分重新访问 `arguments` 对象，但到目前为止，让我们专注于另一个隐式参数：`this`，它在某些方面甚至更有趣。
- en: '4.1.2\. The this parameter: introducing the function context'
  id: totrans-419
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.2\. `this` 参数：介绍函数上下文
- en: When a function is invoked, in addition to the parameters that represent the
    explicit arguments provided in the function call, an implicit parameter named
    `this` is passed to the function. The `this` parameter, a vital ingredient in
    object-oriented JavaScript, refers to an object that’s associated with the function
    invocation. For this reason, it’s often termed the *function context*.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数被调用时，除了在函数调用中提供的显式参数之外，还会传递一个名为 `this` 的隐式参数给函数。`this` 参数是面向对象JavaScript中的一个重要组成部分，它指向与函数调用相关联的对象。因此，它通常被称为
    *函数上下文*。
- en: The function context is a notion that those coming from object-oriented languages
    such as Java might think that they understand. In such languages, `this` usually
    points to an instance of the class within which the method is defined.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 函数上下文是一个概念，那些来自像Java这样的面向对象语言的人可能会认为他们理解。在这些语言中，`this` 通常指向定义方法所在的类的实例。
- en: But beware! As we’ll soon see, in JavaScript, invoking a function as a *method*
    is only one way that a function can be invoked. And as it turns out, what the
    `this` parameter points to isn’t (as in Java or C#) defined only by how and where
    the function is defined; it can also be heavily influenced by how the function
    is *invoked*. Because understanding the exact nature of the `this` parameter is
    one of the most important pillars of object-oriented JavaScript, we’re about to
    look at various ways of invoking functions. You’ll see that one of the primary
    differences between them is how the value of `this` is determined. And then we’ll
    take a long and hard look at function contexts again in several following chapters,
    so don’t worry if things don’t gel right away.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 但要小心！正如我们很快就会看到的，在JavaScript中，将函数作为*方法*调用只是函数被调用的方式之一。而且，实际上，`this`参数指向的内容并不是（如在Java或C#中）仅由函数的定义方式和位置决定的；它还可以受到函数*调用*方式的影响。因为理解`this`参数的确切性质是面向对象JavaScript最重要的支柱之一，我们将探讨调用函数的各种方式。你会发现它们之间的一个主要区别在于`this`值的确定方式。然后，在接下来的几个章节中，我们将详细研究函数上下文，所以如果事情一开始没有完全弄清楚，请不要担心。
- en: Now let’s see, in great detail, how functions can be invoked.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将详细地看看函数是如何被调用的。
- en: 4.2\. Invoking functions
  id: totrans-424
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2\. 调用函数
- en: We’ve all called JavaScript functions, but have you ever stopped to wonder what
    really happens when a function is called? As it turns out, the manner in which
    a function is invoked has a huge impact on how the code within it operates, primarily
    in how the `this` parameter, the function context, is established. This difference
    is much more important than it might seem at first. We’ll examine it within this
    section and exploit it throughout the rest of this book to help elevate our code
    to the ninja level.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都调用过JavaScript函数，但你有没有停下来想过当函数被调用时实际上会发生什么？实际上，函数被调用的方式对函数内部代码的操作方式有巨大的影响，主要是在如何建立`this`参数、函数上下文方面。这种差异比最初看起来要重要得多。我们将在本节中对其进行研究，并在本书的其余部分利用它来帮助我们提升代码到忍者级别。
- en: 'We can invoke a function in four ways, each with its own nuances:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过四种方式调用一个函数，每种方式都有其独特的细微差别：
- en: '*As a function*—`skulk()`, in which the function is invoked in a straightforward
    manner'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*作为函数*—`skulk()`，其中函数以直接的方式被调用'
- en: '*As a method*—`ninja.skulk()`, which ties the invocation to an object, enabling
    object-oriented programming'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*作为方法*—`ninja.skulk()`，将调用与一个对象关联起来，从而实现面向对象编程'
- en: '*As a constructor*—`new Ninja()`, in which a new object is brought into being'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*作为构造函数*—`new Ninja()`，其中创建了一个新的对象'
- en: '*Via the function’s* `apply` *or* `call` *methods*—`skulk.call(ninja)`or `skulk.apply(ninja)`'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通过函数的* `apply` *或* `call` *方法*—`skulk.call(ninja)`或`skulk.apply(ninja)`'
- en: 'Here are examples:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些例子：
- en: '![](068fig01_alt.jpg)'
  id: totrans-432
  prefs: []
  type: TYPE_IMG
  zh: '![](068fig01_alt.jpg)'
- en: For all but the `call` and `apply` approaches, the function invocation operator
    is a set of parentheses following any expression that evaluates to a function
    reference.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 对于除了`call`和`apply`方法之外的所有方法，函数调用运算符是一组跟在评估为函数引用的任何表达式后面的括号。
- en: Let’s start our exploration with the simplest form, invoking functions as functions.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最简单的形式开始，将函数作为函数调用。
- en: 4.2.1\. Invocation as a function
  id: totrans-435
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.1\. 作为函数的调用
- en: 'Invocation as a function? Well, of course functions are invoked as *functions*.
    How silly to think otherwise. But in reality, we say that a function is invoked
    “as a function” to distinguish it from the other invocation mechanisms: methods,
    constructors, and `apply`/`call`. If a function isn’t invoked as a method, as
    a constructor, or via `apply` or `call`, it’s invoked as a function.'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 作为函数调用？当然，函数当然是以函数的方式被调用的。认为其他方式是愚蠢的。但在现实中，我们说函数是以“作为函数”的方式被调用的，以区别于其他调用机制：方法、构造函数和`apply`/`call`。如果一个函数不是作为方法、构造函数或通过`apply`或`call`调用，那么它就是作为函数被调用的。
- en: 'This type of invocation occurs when a function is invoked using the `()` operator,
    and the expression to which the `()` operator is applied doesn’t reference the
    function as a property of an object. (In that case, we’d have a method invocation,
    but we discuss that next.) Here are some simple examples:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`()`运算符调用函数，并且该运算符应用的表达式不引用函数作为对象的属性时，会发生这种类型的调用。（在这种情况下，我们将有一个方法调用，但我们将在下一节讨论。）以下是一些简单的例子：
- en: '![](068fig02_alt.jpg)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
  zh: '![](068fig02_alt.jpg)'
- en: 'When invoked in this manner, the function context (the value of the `this`
    keyword) can be two things: In nonstrict mode, it will be the global context (the
    `window` object), whereas in strict mode, it will be `undefined`.'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式调用时，函数上下文（`this`关键字的值）可以是两件事：在非严格模式中，它将是全局上下文（`window`对象），而在严格模式中，它将是`undefined`。
- en: The following listing illustrates the difference in behavior between strict
    and nonstrict modes.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表说明了严格模式和非常严格模式之间的行为差异。
- en: Listing 4.5\. Invocation as a function
  id: totrans-441
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.5\. 作为函数的调用
- en: '![](069fig01_alt.jpg)'
  id: totrans-442
  prefs: []
  type: TYPE_IMG
  zh: '![](069fig01_alt.jpg)'
- en: '|  |'
  id: totrans-443
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-444
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: As you can see, strict mode is, in most cases, much more straightforward than
    nonstrict mode. For example, when [listing 4.5](#ch04ex05) invokes a function
    as a function (as opposed to as a method), it hasn’t specified an object on which
    the function should be invoked. So, in our opinion, it makes more sense that the
    `this` keyword should be set to `undefined` (as in strict mode), as opposed to
    the global `window` object (as in nonstrict mode). In general, strict mode fixes
    a lot of these small JavaScript oddities. (Remember arguments aliasing from the
    beginning of the chapter?)
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，严格模式在大多数情况下比非严格模式更直接。例如，当[列表 4.5](#ch04ex05)将函数作为函数调用（而不是作为方法调用）时，它没有指定应该在该对象上调用该函数的对象。因此，我们认为将`this`关键字设置为`undefined`（如在严格模式中）比在非严格模式中的全局`window`对象更有意义。一般来说，严格模式解决了许多这些小的JavaScript怪异之处。（还记得章节开头提到的参数别名吗？）
- en: '|  |'
  id: totrans-446
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: You’ve likely written code such as this many times without giving it much thought.
    Now let’s step it up a notch by looking at how functions are invoked as *methods*.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经多次编写了这样的代码，但并没有过多思考。现在让我们提高一个档次，看看函数是如何作为*方法*被调用的。
- en: 4.2.2\. Invocation as a method
  id: totrans-448
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.2\. 作为方法的调用
- en: 'When a function is assigned to a property of an object *and* the invocation
    occurs by referencing the function using that property, then the function is invoked
    as a *method* of that object. Here’s an example:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数被分配给对象的属性，并且通过引用该属性来调用该函数时，那么该函数就是作为该对象的*方法*被调用的。以下是一个例子：
- en: '[PRE45]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Okay; so what? The function is called a *method* in this case, but what makes
    that interesting or useful? Well, if you come from an object-oriented background,
    you’ll remember that the object to which a method belongs is available within
    the body of the method as `this`. The same thing happens here. When we invoke
    a function as a *method* of an object, that object becomes the function context
    and is available within the function via the `this` parameter. This is one of
    the primary means by which JavaScript allows object-oriented code to be written.
    (Constructors are another, and we’ll get to them in short order.)
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧；那么这又意味着什么呢？在这种情况下，函数被称为*方法*，但那又有什么有趣或有用之处呢？嗯，如果你有面向对象背景，你会记得一个方法所属的对象可以在方法的主体中作为`this`使用。这里也是同样的情况。当我们把一个函数作为对象的*方法*调用时，该对象成为函数上下文，并且可以通过`this`参数在函数内部使用。这是JavaScript允许编写面向对象代码的主要方法之一。（构造函数是另一个，我们很快就会讨论到。）
- en: Let’s consider some test code in the next listing to illustrate the differences
    and similarities between invocation as a function and invocation as a method.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一个列表中考虑一些测试代码，以说明作为函数调用和作为方法调用之间的差异和相似之处。
- en: Listing 4.6\. The differences between function and method invocations
  id: totrans-453
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.6\. 函数调用和方法调用的差异
- en: '![](ch04ex06-0.jpg)'
  id: totrans-454
  prefs: []
  type: TYPE_IMG
  zh: '![](ch04ex06-0.jpg)'
- en: '![](ch04ex06-1.jpg)'
  id: totrans-455
  prefs: []
  type: TYPE_IMG
  zh: '![](ch04ex06-1.jpg)'
- en: This test sets up a function named `whatsMyContext` that we’ll use throughout
    the rest of the listing. The only thing that this function does is to return its
    function context so that we can see, from outside the function, what the function
    context for the invocation is. (Otherwise, we’d have a hard time knowing.)
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试设置了一个名为`whatsMyContext`的函数，我们将在列表的其余部分中使用它。这个函数唯一做的事情就是返回其函数上下文，这样我们就可以从函数外部看到调用时的函数上下文是什么。（否则，我们将很难知道。）
- en: '[PRE46]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'When we call the function directly by name, this is a case of invoking the
    function as a function, so we expect that the function context will be the global
    context (`window`), because we’re in nonstrict mode. We assert that this is so:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们直接通过名称调用函数时，这是一个将函数作为函数调用的例子，因此我们期望函数上下文将是全局上下文（`window`），因为我们处于非严格模式。我们断言这是正确的：
- en: '[PRE47]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Then we create a reference to the function `whatsMyContext` in a variable named
    `getMyThis: var getMyThis = whatsMyContext`. This doesn’t create a second instance
    of the function; it merely creates a reference to the same function (you know,
    first-class object and all).'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在一个名为 `getMyThis` 的变量中创建对函数 `whatsMyContext` 的引用：`var getMyThis = whatsMyContext`。这并没有创建函数的第二个实例；它仅仅创建了对同一个函数的引用（你知道，第一类对象和所有）。
- en: 'When we invoke the function via the variable—something we can do because the
    function invocation operator can be applied to any expression that evaluates to
    a function—we’re once again invoking the function as a function. As such, we again
    expect that the function context is `window`, and it is:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过变量调用函数时——我们可以这样做，因为函数调用操作符可以应用于任何求值结果为函数的表达式——我们再次将函数作为函数调用。因此，我们再次期望函数上下文是
    `window`，并且确实是这样的：
- en: '[PRE48]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, we get a bit trickier and define an object in variable `ninja1` with a
    property named `getMyThis` that receives a reference to the `whatsMyContext` function.
    By doing so, we say that we’ve created a *method* named `getMyThis` on the object.
    We don’t say that `whatsMyContext` has *become* a method of `ninja1`; it hasn’t.
    You’ve already seen that `whatsMyContext` is its own independent function that
    can be invoked in numerous ways:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，事情变得稍微复杂一些，我们在变量 `ninja1` 中定义了一个名为 `getMyThis` 的属性，它接收对 `whatsMyContext`
    函数的引用。通过这样做，我们说我们在对象上创建了一个名为 `getMyThis` 的 *方法*。我们并没有说 `whatsMyContext` 已经 *成为*
    `ninja1` 的一个方法；它并没有。你已经看到 `whatsMyContext` 是一个独立的函数，可以通过多种方式调用：
- en: '[PRE49]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'According to what we stated earlier, when we invoke the function via a method
    reference, we expect the function context to be the method’s object (in this case,
    `ninja1`) and we assert as much:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们之前所说的，当我们通过方法引用调用函数时，我们期望函数上下文是该方法的对象（在这种情况下，`ninja1`），我们这样断言：
- en: '[PRE50]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '|  |'
  id: totrans-467
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-468
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Invoking functions as methods is crucial to writing JavaScript in an object-oriented
    manner. Doing so enables you to use `this` within any method to reference the
    method’s “owning” object—a fundamental concept in object-oriented programming.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数作为方法调用对于编写面向对象的 JavaScript 至关重要。这样做使得你可以在任何方法中使用 `this` 来引用该方法的所有权对象——这是面向对象编程中的一个基本概念。
- en: '|  |'
  id: totrans-470
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'To drive that point home, we continue testing by creating yet another object,
    `ninja2`, also with a property named `getMyThis` that references the `whatsMyContext`
    function. Upon invoking this function through the `ninja2` object, we correctly
    assert that its function context is `ninja2`:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 为了强调这一点，我们继续通过创建另一个对象 `ninja2` 来进行测试，它也具有一个名为 `getMyThis` 的属性，该属性引用 `whatsMyContext`
    函数。通过 `ninja2` 对象调用此函数时，我们正确地断言其函数上下文是 `ninja2`：
- en: '[PRE51]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Even though the *same* function—`whatsMyContext`—is used throughout the example,
    the function context returned by `this` changes depending on how `whatsMyContext`
    is invoked. For example, the exact same function is shared by both `ninja1` and
    `ninja2`, yet when it’s executed, the function has access to, and can perform
    operations on, the object through which the method was invoked. We don’t need
    to create separate copies of a function to perform the exact same processing on
    different objects. This is a tenet of object-oriented programming.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在整个示例中使用了 *相同的* 函数——`whatsMyContext`，但 `this` 返回的函数上下文会根据 `whatsMyContext`
    的调用方式而改变。例如，完全相同的函数由 `ninja1` 和 `ninja2` 共享，但执行时，该函数可以通过调用方法的对象访问并操作对象。我们不需要为不同的对象创建函数的单独副本来执行完全相同的处理。这是面向对象编程的一个原则。
- en: Though a powerful capability, the manner in which it’s used in this example
    has limitations. Foremost, when we create the two ninja objects, we’re able to
    share the same function to be used as a method in each, but we have to use a bit
    of repeated code to set up the separate objects and their methods.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是一种强大的功能，但在本例中它的使用方式存在局限性。首先，当我们创建两个忍者对象时，我们可以共享同一个函数作为每个对象的方法，但我们必须使用一些重复的代码来设置单独的对象及其方法。
- en: 'But that’s nothing to despair over—JavaScript provides mechanisms to make creating
    objects from a single pattern much easier than in this example. We’ll explore
    those capabilities in depth in [chapter 7](kindle_split_019.html#ch07). But for
    now, let’s consider a part of that mechanism that relates to function invocations:
    the *constructor*.'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 但这并不是绝望的理由——JavaScript 提供了机制，使得从单个模式创建对象比本例中要容易得多。我们将在第 7 章（[kindle_split_019.html#ch07](https://kindle_split_019.html#ch07)）中深入探讨这些功能。但就目前而言，让我们考虑与函数调用相关的那部分机制：*构造函数*。
- en: 4.2.3\. Invocation as a constructor
  id: totrans-476
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.3. 作为构造函数的调用
- en: There’s nothing special about a function that’s going to be used as a constructor.
    *Constructor functions* are declared just like any other functions, and we can
    easily use function declarations and function expressions for constructing new
    objects. The only exception is the arrow function, which as you’ll see later in
    the chapter, works a bit differently. But, in any case, the main difference is
    in how the function is invoked.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 将要作为构造函数使用的函数没有什么特别之处。*构造函数*的声明方式与任何其他函数一样，我们可以轻松地使用函数声明和函数表达式来构造新对象。唯一的例外是箭头函数，你将在本章后面看到，它的工作方式略有不同。但无论如何，主要区别在于函数的调用方式。
- en: 'To invoke the function as a constructor, we precede the function invocation
    with the keyword `new`. For example, recall the `whatsMyContext` function from
    the previous section:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 要将函数作为构造函数调用，我们在函数调用之前加上关键字`new`。例如，回想一下上一节中的`whatsMyContext`函数：
- en: '[PRE52]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'If we want to invoke the `whatsMyContext` function as a constructor, we write
    this:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想将`whatsMyContext`函数作为构造函数调用，我们写这个：
- en: '[PRE53]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: But even though we can invoke `whatsMyContext` as a constructor, that function
    isn’t a particularly useful constructor. Let’s find out why by discussing what
    makes constructors special.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可以将`whatsMyContext`作为构造函数调用，但这个函数并不是一个特别有用的构造函数。让我们通过讨论使构造函数特殊的原因来找出原因。
- en: '|  |'
  id: totrans-483
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-484
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'Remember in [chapter 3](kindle_split_014.html#ch03), when we discussed ways
    of defining functions? Among function declarations, function expressions, arrow
    functions, and generator functions, we also mentioned *function constructors*,
    which enable us to construct new functions from strings. For example: `new Function(''a'',
    ''b'', ''return a + b'')` creates a new function with two parameters, `a` and
    `b`, that returns their sum. Be careful not to confuse these *function constructors*
    with *constructor functions*! The difference is subtle, yet significant. A function
    constructor enables us to create functions from dynamically created strings. On
    the other hand, *constructor functions,* the topic of this section, are functions
    that we use to create and initialize object instances.'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在[第3章](kindle_split_014.html#ch03)中，我们讨论了定义函数的方法吗？在函数声明、函数表达式、箭头函数和生成器函数中，我们还提到了*函数构造器*，它使我们能够从字符串中构造新的函数。例如：`new
    Function('a', 'b', 'return a + b')`创建了一个具有两个参数`a`和`b`的新函数，它返回它们的和。请注意不要将这些*函数构造器*与*构造函数*混淆！区别虽然微妙，但很重要。函数构造器使我们能够从动态创建的字符串中创建函数。另一方面，*构造函数*，本节的主题，是我们用来创建和初始化对象实例的函数。
- en: '|  |'
  id: totrans-486
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The superpowers of constructors
  id: totrans-487
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 构造函数的超级能力
- en: Invoking a function as a constructor is a powerful feature of JavaScript that
    we’ll explore in the following listing.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数作为构造函数调用是JavaScript的一个强大功能，我们将在下面的列表中探讨。
- en: Listing 4.7\. Using a constructor to set up common objects
  id: totrans-489
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.7\. 使用构造函数设置常见对象
- en: '![](073fig01_alt.jpg)'
  id: totrans-490
  prefs: []
  type: TYPE_IMG
  zh: '![](073fig01_alt.jpg)'
- en: In this example, we create a function named `Ninja` that we’ll use to construct,
    well, ninjas. When invoked with the keyword `new`, an empty object instance is
    created and passed to the function as its function context, the `this` parameter.
    The constructor creates a property named `skulk` on this object, which is assigned
    a function, making that function a method of the newly created object.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个名为`Ninja`的函数，我们将用它来构造，嗯，忍者。当使用关键字`new`调用时，会创建一个空的对象实例，并将其作为函数上下文（`this`参数）传递给函数。构造函数在这个对象上创建了一个名为`skulk`的属性，并将其分配了一个函数，使该函数成为新创建的对象的方法。
- en: 'In general, when a constructor is invoked, a couple of special actions take
    place, as shown in [figure 4.1](#ch04fig01). Calling a function with the keyword
    `new` triggers the following steps:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当调用构造函数时，会发生一些特殊操作，如图4.1所示。使用关键字`new`调用函数会触发以下步骤：
- en: A new empty object is created.
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个新的空对象被创建。
- en: This object is passed to the constructor as the `this` parameter, and thus becomes
    the constructor’s function context.
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此对象作为`this`参数传递给构造函数，因此成为构造函数的函数上下文。
- en: The newly constructed object is returned as the `new` operator’s value (with
    an exception that we’ll get to in short order).
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新构造的对象作为`new`运算符的值返回（但有一个例外，我们很快就会讨论到）。
- en: Figure 4.1\. When calling a function with a keyword `new`, a new empty object
    is created and set as the context of the constructor function, the `this` parameter.
  id: totrans-496
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.1\. 当使用关键字`new`调用函数时，会创建一个新的空对象，并将其设置为构造函数的上下文，即`this`参数。
- en: '![](04fig01_alt.jpg)'
  id: totrans-497
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig01_alt.jpg)'
- en: The last two points touch on why `whatsMyContext` in `new whatsMyContext()`
    makes for a lousy constructor. The purpose of a constructor is to cause a new
    object to be created, to set it up, and to return it as the constructor value.
    Anything that interferes with that intent isn’t appropriate for constructors.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两点涉及到为什么在`new whatsMyContext()`中的`whatsMyContext`使得构造函数变得糟糕。构造函数的目的是创建一个新的对象，对其进行设置，并将其作为构造函数的值返回。任何干扰这一意图的东西都不适合作为构造函数。
- en: 'Let’s consider a more appropriate constructor, `Ninja`, that sets up skulking
    ninjas, as shown in [listing 4.7](#ch04ex07):'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个更合适的构造函数，`Ninja`，它用于设置潜行的忍者，如[列表 4.7](#ch04ex07)所示：
- en: '[PRE54]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The `skulk` method performs the same operation as `whatsMyContext` in the previous
    sections, returning the function context so that we can test it externally.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '`skulk`方法执行与前面章节中`whatsMyContext`相同的操作，返回函数上下文，以便我们可以外部测试它。'
- en: 'With the constructor defined, we create two new `Ninja` objects by invoking
    the constructor twice. Note that the returned values from the invocations are
    stored in variables that become references to the newly created `Ninja`s:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数定义后，我们通过两次调用构造函数创建了两个新的`Ninja`对象。请注意，从调用中返回的值被存储在变量中，这些变量成为新创建的`Ninja`对象的引用：
- en: '[PRE55]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Then we run the tests that ensure that each invocation of the method operates
    on the expected object:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们运行确保每个方法调用都操作预期对象的测试：
- en: '[PRE56]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: That’s it! Now you know how to create and initialize new objects with constructor
    functions. Calling a function with the keyword `new` returns the newly created
    object. But let’s check whether that’s always exactly true.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是全部！现在你知道如何使用构造函数函数创建和初始化新对象了。用关键字`new`调用函数返回新创建的对象。但让我们检查这是否总是完全正确。
- en: Constructor return values
  id: totrans-507
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 构造函数返回值
- en: We mentioned earlier that constructors are intended to initialize newly created
    objects, and that the newly constructed object is returned as a result of a constructor
    invocation (via the `new` operator). But what happens when the constructor returns
    a value of its own? Let’s explore that situation in the following listing.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到，构造函数的目的是初始化新创建的对象，并且新构造的对象是构造函数调用的结果（通过`new`运算符）。但是当构造函数返回自己的值时会发生什么？让我们在下面的列表中探索这种情况。
- en: Listing 4.8\. Constructors returning primitive values
  id: totrans-509
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.8\. 返回原始值的构造函数
- en: '![](074fig01_alt.jpg)'
  id: totrans-510
  prefs: []
  type: TYPE_IMG
  zh: '![图片](074fig01_alt.jpg)'
- en: If we run this listing, we’ll see that all is fine and well. The fact that this
    `Ninja` function returns a simple number `1` has no significant influence on how
    the code behaves. If we call the `Ninja` function as a function, it returns `1`
    (just as we’d expect); and if we call it as a constructor, with the keyword `new`,
    a new `ninja` object is constructed and returned. So far, so good.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个列表，我们会看到一切正常。这个`Ninja`函数返回一个简单的数字`1`对代码的行为没有显著影响。如果我们像预期的那样将`Ninja`函数作为函数调用，它返回`1`；如果我们用关键字`new`将其作为构造函数调用，就会构建并返回一个新的`ninja`对象。到目前为止，一切顺利。
- en: But now let’s try something different, a constructor function that returns another
    object, as shown in the following listing.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在让我们尝试做一些不同的事情，一个构造函数函数返回另一个对象，如下面的列表所示。
- en: Listing 4.9\. Constructors explicitly returning object values
  id: totrans-513
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.9\. 显式返回对象值的构造函数
- en: '![](075fig01_alt.jpg)'
  id: totrans-514
  prefs: []
  type: TYPE_IMG
  zh: '![图片](075fig01_alt.jpg)'
- en: 'This listing takes a slightly different approach. We start by creating a `puppet`
    object with the property `rules` set to `false`:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表采取了一种稍微不同的方法。我们首先创建一个`puppet`对象，其`rules`属性设置为`false`：
- en: '[PRE57]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Then we define an `Emperor` function that adds a `rules` property to the newly
    constructed object and sets it to `true`. In addition, the `Emperor` function
    has one quirk; it returns the global `puppet` object:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们定义了一个`Emperor`函数，它向新构造的对象添加一个`rules`属性并将其设置为`true`。此外，`Emperor`函数有一个怪癖；它返回全局的`puppet`对象：
- en: '[PRE58]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Later, we call the `Emperor` function as a constructor, with the keyword `new`:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 后来，我们用关键字`new`将`Emperor`函数作为构造函数调用：
- en: '[PRE59]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'With this, we’ve set up an ambiguous situation: We get one object passed to
    the constructor as the function context in `this`, which we initialize, but then
    we return a completely different `puppet` object. Which object will reign supreme?'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们设置了一个模糊的情况：我们得到一个对象传递给构造函数作为函数上下文中的`this`，我们初始化它，但随后我们返回一个完全不同的`puppet`对象。哪个对象将统治？
- en: 'Let’s test it:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试它：
- en: '[PRE60]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: It turns out that our tests indicate that the `puppet` object is returned as
    the value of constructor invocation, and that the initialization that we performed
    on the function context in the constructor was all for naught. The `puppet` has
    been exposed!
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，我们的测试表明构造函数调用的值返回了 `puppet` 对象，而我们构造函数中在函数上下文中执行的所有初始化都是徒劳的。`puppet` 已经暴露了！
- en: 'Now that we’ve gone through some tests, let’s summarize our findings:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经进行了一些测试，让我们总结一下我们的发现：
- en: If the constructor returns an object, that object is returned as the value of
    the whole `new` expression, and the newly constructed object passed as `this`
    to the constructor is discarded.
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果构造函数返回一个对象，则该对象作为整个 `new` 表达式的值返回，而新创建的对象作为 `this` 传递给构造函数被丢弃。
- en: If, however, a nonobject is returned from the constructor, the returned value
    is ignored, and the newly created object is returned.
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果构造函数返回的不是对象，则返回值将被忽略，并返回新创建的对象。
- en: Because of these peculiarities, functions intended for use as constructors are
    generally coded differently from other functions. Let’s explore that in greater
    detail.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些特殊性，打算用作构造函数的函数通常以与其他函数不同的方式编写。让我们更详细地探讨这一点。
- en: Coding considerations for constructors
  id: totrans-529
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 构造函数的编码考虑因素
- en: The intent of constructors is to initialize the new object that will be created
    by the function invocation to initial conditions. And although such functions
    *can* be called as “normal” functions, or even assigned to object properties in
    order to be invoked as methods, they’re generally not useful as such. For example
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数的目的是初始化由函数调用创建的新对象到初始条件。尽管这样的函数 *可以* 作为“正常”函数调用，或者甚至分配给对象属性以便作为方法调用，但它们通常作为这样的用途并不太有用。例如
- en: '[PRE61]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We can call `Ninja` as a simple function, but the `skulk` property would be
    created on `window` in nonstrict mode—not a particularly useful operation. Things
    go even more awry in strict mode, as `this` would be undefined and our JavaScript
    application would crash. But this is a good thing; if we make this mistake in
    nonstrict mode, it might escape our notice (unless we had good tests), but there’s
    no missing the mistake in strict mode. This is a good example of why strict mode
    was introduced.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 `Ninja` 作为简单的函数调用，但在非严格模式下，`skulk` 属性将在 `window` 上创建——这不是一个特别有用的操作。在严格模式下，事情会变得更加糟糕，因为
    `this` 将是未定义的，我们的JavaScript应用程序将会崩溃。但这是好事；如果我们非严格模式下犯了这个错误，我们可能没有注意到（除非我们有很好的测试），但在严格模式下，错误是显而易见的。这是一个为什么引入严格模式的好例子。
- en: Because constructors are generally coded and used in a manner that’s different
    from other functions, and aren’t all that useful unless invoked as constructors,
    a naming convention has arisen to distinguish constructors from run-of-the-mill
    functions and methods. If you’ve been paying attention, you may have already noticed
    it.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 由于构造函数通常以与其他函数不同的方式编写和使用，并且除非作为构造函数调用，否则并不那么有用，因此出现了一种命名约定来区分构造函数和普通函数和方法。如果你一直很注意，你可能已经注意到了这一点。
- en: 'Functions and methods are generally named starting with a verb that describes
    what they do (`skulk`, `creep`, `sneak`, `doSomethingWonderful`, and so on) and
    start with a lowercase letter. Constructors, on the other hand, are usually named
    as a noun that describes the object that’s being constructed and start with an
    uppercase character: `Ninja`, `Samurai`, `Emperor`, `Ronin`, and so on.'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 函数和方法通常以描述它们所执行动作的动词开头（例如 `skulk`、`creep`、`sneak`、`doSomethingWonderful` 等），并且以小写字母开头。另一方面，构造函数通常以描述正在构建的对象的名词命名，并且以大写字母开头：`Ninja`、`Samurai`、`Emperor`、`Ronin`
    等。
- en: It’s easy to see how a constructor makes it more elegant to create multiple
    objects that conform to the same pattern without having to repeat the same code
    over and over. The common code is written just once, as the body of the constructor.
    In [chapter 7](kindle_split_019.html#ch07), you’ll see more about using constructors
    and about the other object-oriented mechanisms that JavaScript provides to make
    it even easier to set up object patterns.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易看出，构造函数如何使创建符合相同模式的多个对象变得更加优雅，而无需一遍又一遍地重复相同的代码。公共代码只编写一次，作为构造函数的主体。在 [第7章](kindle_split_019.html#ch07)
    中，你将了解更多关于使用构造函数以及JavaScript提供的其他面向对象机制，这些机制使设置对象模式变得更加容易。
- en: But we’re not finished with function invocations yet. There’s still another
    way that JavaScript lets us invoke functions that provides a great deal of control
    over the invocation details.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们还没有完成函数调用的讨论。JavaScript 还有一种让我们调用函数的方法，它提供了对调用细节的大量控制。
- en: 4.2.4\. Invocation with the apply and call methods
  id: totrans-537
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.4\. 使用 apply 和 call 方法进行调用
- en: So far, you’ve seen that one of the major differences between the types of function
    invocation is what object ends up as the function context referenced by the implicit
    `this` parameter that’s passed to the executing function. For methods, it’s the
    method’s owning object; for top-level functions, it’s either `window` or `undefined`
    (depending on the current strictness); for constructors, it’s a newly created
    object instance.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到函数调用类型之间一个主要的不同点在于最终成为执行函数中隐式 `this` 参数上下文的对象是什么。对于方法，它是拥有该方法的对象；对于顶层函数，它要么是
    `window`，要么是 `undefined`（取决于当前的严格性）；对于构造函数，它是一个新创建的对象实例。
- en: But what if we want to make the function context whatever we want? What if we
    want to set it explicitly? What if...well, why would we want to do such a thing?
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们想使函数上下文成为我们想要的任何东西呢？如果我们想显式地设置它呢？如果我们想……好吧，我们为什么要这样做呢？
- en: To get a glimpse of why we’d care about this ability, we’ll look at a practical
    example that illustrates a surprisingly common bug related to event handling.
    For now, consider that when an event handler is called, the function context is
    set to the object to which the event was bound. (Don’t worry if this seems vague;
    you’ll learn about event handling in great detail in [chapter 13](kindle_split_026.html#ch13).)
    Take a look at the following listing.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解我们为什么会对这种能力感兴趣，我们将查看一个实际例子，它说明了与事件处理相关的一个令人惊讶的常见错误。现在，考虑一下当事件处理器被调用时，函数上下文被设置为事件绑定到的对象。（如果你觉得这很模糊，不用担心；你将在第
    13 章中详细了解事件处理。）看看下面的列表。
- en: Listing 4.10\. Binding a specific context to a function
  id: totrans-541
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.10\. 将特定上下文绑定到函数
- en: '![](077fig01_alt.jpg)'
  id: totrans-542
  prefs: []
  type: TYPE_IMG
  zh: '![077fig01_alt.jpg](077fig01_alt.jpg)'
- en: 'In this example, we have a button, `<button id="test">Click Me!</button>`,
    and we want to know whether it has ever been clicked. To retain that state information,
    we use a constructor function to create a backing object named `button`, in which
    we’ll store the clicked state:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有一个按钮，`<button id="test">点击我！</button>`，我们想知道它是否曾被点击过。为了保留这种状态信息，我们使用构造函数创建一个名为
    `button` 的后端对象，我们将在此对象中存储点击状态：
- en: '[PRE62]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'In that object, we also define a `click` method that will serve as an event
    handler that fires when the button is clicked. The method sets the clicked property
    to `true` and then tests that the state was properly recorded in the backing object
    (we’ve intentionally used the `button` identifier instead of the `this` keyword—after
    all, they should refer to the same thing, or should they?). Finally, we establish
    the `button.click` method as a click handler for the button:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个对象中，我们还定义了一个 `click` 方法，它将在按钮被点击时作为事件处理器触发。该方法将点击属性设置为 `true`，然后测试状态是否已正确记录在后端对象中（我们有意使用了
    `button` 标识符而不是 `this` 关键字——毕竟，它们应该指向同一件事，对吧？）。最后，我们将 `button.click` 方法作为按钮的点击处理器建立起来：
- en: '[PRE63]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: When we load the example into a browser and click the button, we see by the
    display of [figure 4.2](#ch04fig02) that something is amiss; the stricken text
    indicates that the test has failed. The code in [listing 4.10](#ch04ex10) fails
    because the context of the `click` function *isn’t* referring to the `button`
    object as we intended.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将示例加载到浏览器中并点击按钮时，通过 [图 4.2](#ch04fig02) 的显示，我们可以看到有些不对劲；被划掉的文字表明测试失败了。在 [列表
    4.10](#ch04ex10) 中的代码失败了，因为 `click` 函数的上下文并没有按照我们的意图指向 `button` 对象。
- en: Figure 4.2\. Why did our test fail? Where did the change of state go? Usually,
    the event callback’s context is the object raising the event (in this case, the
    HTML button, and not the button object).
  id: totrans-548
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.2\. 为什么我们的测试失败了？状态变化去哪里了？通常，事件回调的上下文是引发事件的那个对象（在这种情况下，是 HTML 按钮，而不是按钮对象）。
- en: '![](04fig02.jpg)'
  id: totrans-549
  prefs: []
  type: TYPE_IMG
  zh: '![04fig02.jpg](04fig02.jpg)'
- en: Recalling the lessons of earlier in the chapter, if we had called the function
    via `button.click()`, the context *would* have been the button, because the function
    would be invoked as a method on the `button` object. But in this example, the
    event-handling system of the browser defines the context of the invocation to
    be the target element of the event, which causes the context to be the `<button>`
    element, not the `button` object. So we set our `click` state on the wrong object!
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下本章前面的课程，如果我们通过`button.click()`调用函数，上下文*将会*是按钮，因为函数将作为`button`对象上的方法被调用。但在这个例子中，浏览器的事件处理系统定义了调用的上下文为目标元素，这导致上下文是`<button>`元素，而不是`button`对象。因此，我们在错误的对象上设置了我们的`click`状态！
- en: This is a surprisingly common problem, and later in the chapter, you’ll see
    techniques for completely evading it. For now, let’s explore how to tackle it
    by examining how to explicitly set the function context by using the `apply` and
    `call` methods.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常常见的问题，在本章的后面部分，你将看到完全避免它的技术。现在，让我们通过检查如何使用`apply`和`call`方法显式设置函数上下文来探讨如何解决这个问题。
- en: Using the apply and call methods
  id: totrans-552
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用apply和call方法
- en: 'JavaScript provides a means for us to invoke a function and to explicitly specify
    any object we want as the function context. We do this through the use of one
    of two methods that exist for every function: `apply` and `call`.'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript为我们提供了一种调用函数并显式指定我们想要作为函数上下文的对象的方法。我们通过使用每个函数都存在的两种方法之一来实现这一点：`apply`和`call`。
- en: Yes, we said methods of functions. As first-class objects (created, by the way,
    by the built-in `Function` constructor), functions can have properties just like
    any other object type, including methods.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们说的是函数的方法。作为一等对象（顺便提一下，是由内置的`Function`构造函数创建的），函数可以像任何其他对象类型一样拥有属性，包括方法。
- en: 'To invoke a function by using its `apply` method, we pass two parameters to
    `apply`: the object to be used as the function context, and an array of values
    to be used as the invocation arguments. The `call` method is used in a similar
    manner, except that the arguments are passed directly in the argument list rather
    than as an array.'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`apply`方法调用函数，我们向`apply`传递两个参数：用作函数上下文的对象，以及用作调用参数的值数组。`call`方法以类似的方式使用，除了参数直接传递到参数列表中，而不是作为数组。
- en: The following listing shows both of these methods in action.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了这两种方法的作用。
- en: Listing 4.11\. Using the apply and call methods to supply the function context
  id: totrans-557
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.11。使用apply和call方法提供函数上下文
- en: '![](079fig01_alt.jpg)'
  id: totrans-558
  prefs: []
  type: TYPE_IMG
  zh: '![](079fig01_alt.jpg)'
- en: In this example, we set up a function named `juggle`, in which we define juggling
    as adding up all the arguments and storing them as a property named `result` on
    the function context (referenced by the `this` keyword). That may be a rather
    lame definition of juggling, but it *will* allow us to determine whether arguments
    were passed to the function correctly, and which object ended up as the function
    context.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们设置了一个名为`juggle`的函数，在其中我们将抛接定义为将所有参数相加并将它们存储在函数上下文（通过`this`关键字引用）上的一个名为`result`的属性中。这可能是一个相当蹩脚的抛接定义，但它*将*允许我们确定是否正确地将参数传递给了函数，以及哪个对象最终成为了函数上下文。
- en: 'We then set up two objects, `ninja1` and `ninja2`, that we’ll use as function
    contexts, passing the first to the function’s `apply` method, along with an *array*
    of arguments, and passing the second to the function’s `call` method, along with
    a *list* of other arguments:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们设置了两个对象`ninja1`和`ninja2`，我们将它们用作函数上下文，将第一个传递给函数的`apply`方法，并附带一个*数组*参数，将第二个传递给函数的`call`方法，并附带一个*列表*参数：
- en: '[PRE64]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Notice that the only difference between `apply` and `call` is how the arguments
    are supplied. In the case of `apply`, we use an array of arguments, and in the
    case of `call`, we list them as call arguments, after the function context. See
    [figure 4.3](#ch04fig03).
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`apply`和`call`之间的唯一区别在于参数的提供方式。在`apply`的情况下，我们使用一个参数数组，而在`call`的情况下，我们将其作为调用参数列出，在函数上下文之后。参见[图4.3](#ch04fig03)。
- en: Figure 4.3\. As the first argument, both the `call` and `apply` methods take
    the object that will be used as the function context. The difference is in the
    following arguments. `apply` takes only one additional argument, an array of argument
    values; `call` takes any number of arguments, which will be used as function arguments.
  id: totrans-563
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.3。`call`和`apply`方法都接受一个作为函数上下文使用的对象作为第一个参数。区别在于后面的参数。`apply`只接受一个额外的参数，即参数值的数组；`call`接受任意数量的参数，这些参数将用作函数参数。
- en: '![](04fig03.jpg)'
  id: totrans-564
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig03.jpg)'
- en: 'After we’ve supplied our function contexts and arguments, we continue by testing!
    First, we check that `ninja1`, which was called via `apply`, received a `result`
    property that’s the result of adding up all the argument values (`1`, `2`, `3`,
    `4`) in the passed array. Then we do the same for `ninja2`, which was called via
    `call`, where we check the result for arguments `5`, `6`, `7`, and `8`:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们提供了函数上下文和参数之后，我们继续测试！首先，我们检查通过 `apply` 调用的 `ninja1` 是否收到了一个 `result` 属性，该属性是传递数组中所有参数值（`1`，`2`，`3`，`4`）的总和。然后我们对通过
    `call` 调用的 `ninja2` 做同样的检查，检查参数 `5`，`6`，`7` 和 `8` 的结果：
- en: '[PRE65]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[Figure 4.4](#ch04fig04) provides a closer look at what’s going on in [listing
    4.11](#ch04ex11).'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4.4](#ch04fig04) 更详细地展示了 [列表 4.11](#ch04ex11) 中的内容。'
- en: Figure 4.4\. Manually setting a function context by using built-in `call` and
    `apply` from [listing 4.11](#ch04ex11) results in these combinations of function
    contexts (the `this` parameter) and `arguments`.
  id: totrans-568
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.4\. 通过使用内置的 `call` 和 `apply` 从 [列表 4.11](#ch04ex11) 手动设置函数上下文，产生了这些函数上下文（`this`
    参数）和 `arguments` 的组合。
- en: '![](04fig04_alt.jpg)'
  id: totrans-569
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig04_alt.jpg)'
- en: These two methods, `call` and `apply`, can come in handy whenever it’s expedient
    to usurp what would normally be the function context with an object of our own
    choosing—something that can be particularly useful when invoking callback functions.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法，`call` 和 `apply`，在需要用我们自己的对象来替代通常的函数上下文时非常有用——这在调用回调函数时尤其有用。
- en: Forcing the function context in callbacks
  id: totrans-571
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在回调函数中强制函数上下文
- en: Let’s consider a concrete example of forcing the function context to be an object
    of our own choosing. We’ll use a simple function to perform an operation on every
    entry of an array.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个具体的例子，强制函数上下文成为我们自己的对象。我们将使用一个简单的函数来对数组的每个条目执行操作。
- en: 'In imperative programming, it’s common to pass the array to a method and use
    a `for` loop to iterate over every entry, performing the operation on each entry:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令式编程中，将数组传递给一个方法并使用 `for` 循环遍历每个条目，对每个条目执行操作是很常见的：
- en: '[PRE66]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'In contrast, the functional approach is to create a function that operates
    on a single element and passes each entry to that function:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，函数式方法是为单个元素创建一个函数，并将每个条目传递给该函数：
- en: '[PRE67]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The difference lies in thinking at a level where functions are the main building
    blocks of the program. You might think that it’s moot, and that all you’re doing
    is moving the `for` loop out one level, but we’re not done massaging this example
    yet.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 差别在于思考的层面，在这个层面上，函数是程序的主要构建块。你可能认为这无关紧要，你只是在将 `for` 循环移动了一个层级，但我们还没有完全梳理这个例子。
- en: To facilitate a more functional style, all array objects have access to a `forEach`
    function that invokes a callback on each element within an array. This is often
    more succinct, and this style is preferred over the traditional `for` statement
    by those familiar with functional programming. Its organizational benefits will
    become even more evident (*cough*, code reuse, *cough*) after covering closures
    in [chapter 5](kindle_split_016.html#ch05). Such an iteration function *could*
    pass the current element to the callback as a parameter, but most make the current
    element the function context of the callback.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于更函数式风格的编程，所有数组对象都可以访问一个 `forEach` 函数，该函数会对数组中的每个元素调用回调函数。这种方法通常更简洁，熟悉函数式编程的人更倾向于使用这种方法而不是传统的
    `for` 循环语句。在第五章（kindle_split_016.html#ch05）介绍了闭包之后，这种组织上的好处将变得更加明显（咳嗽，代码重用，咳嗽）。这样的迭代函数
    *可以* 将当前元素作为参数传递给回调函数，但大多数情况下，它们将当前元素作为回调函数的函数上下文。
- en: Even though all modern JavaScript engines now support a `forEach` method on
    arrays, we’ll build our own (simplified) version of such a function in the next
    listing.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管现在所有现代的 JavaScript 引擎都支持数组上的 `forEach` 方法，但我们在下一个列表中仍将构建这样一个函数的（简化）版本。
- en: Listing 4.12\. Building a forEach function to demonstrate setting a function
    context
  id: totrans-580
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.12\. 构建一个 `forEach` 函数以演示设置函数上下文
- en: '![](082fig01_alt.jpg)'
  id: totrans-581
  prefs: []
  type: TYPE_IMG
  zh: '![](082fig01_alt.jpg)'
- en: 'The iteration function sports a simple signature that expects the array of
    objects to be iterated over as the first argument, and a callback function as
    the second. The function iterates over the array entries, invoking the callback
    function for each entry:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代函数具有简单的签名，它期望第一个参数是要迭代的对象数组，第二个参数是回调函数。该函数遍历数组条目，为每个条目调用回调函数：
- en: '[PRE68]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We use the `call` method of the callback function, passing the current iteration
    entry as the first parameter and the loop index as the second. This *should* cause
    the current entry to become the function context, and the index to be passed as
    the single parameter to the callback.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用回调函数的`call`方法，将当前迭代条目作为第一个参数，将循环索引作为第二个参数。这*应该*导致当前条目成为函数上下文，并将索引作为单个参数传递给回调。
- en: 'Now to test that! We set up a simple `weapons` array. Then we call the `forEach`
    function, passing the test array and a callback within which we test that the
    expected entry is set as the function context for each invocation of the callback:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来测试一下！我们设置了一个简单的`武器`数组。然后我们调用`forEach`函数，传递测试数组和回调函数，在回调函数内部我们检查预期的条目是否被设置为每次回调调用的函数上下文：
- en: '[PRE69]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[Figure 4.5](#ch04fig05) shows that our function works splendidly.'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4.5](#ch04fig05) 显示我们的函数工作得非常好。'
- en: Figure 4.5\. The test results show that we have the ability to make any object
    we please the function context of a callback invocation.
  id: totrans-588
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.5\. 测试结果显示，我们有能力将任何对象设置为回调调用上下文。
- en: '![](04fig05.jpg)'
  id: totrans-589
  prefs: []
  type: TYPE_IMG
  zh: '![图4.5](04fig05.jpg)'
- en: In a production-ready implementation of such a function, there’d be a lot more
    work to do. For example, what if the first argument isn’t an array? What if the
    second argument isn’t a function? How would you allow the page author to terminate
    the loop at any point? As an exercise, you can augment the function to handle
    these situations. Another exercise you could task yourself with is to enhance
    the function so that the page author can pass an arbitrary number of arguments
    to the callback in addition to the iteration index.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样一个函数的生产就绪实现中，还有很多工作要做。例如，如果第一个参数不是一个数组怎么办？如果第二个参数不是一个函数怎么办？你将如何允许页面作者在任何时候终止循环？作为一个练习，你可以增强这个函数以处理这些情况。另一个你可以自己尝试的练习是增强这个函数，使得页面作者可以向回调传递任意数量的参数，除了迭代索引。
- en: 'Given that `apply` and `call` do pretty much the same thing, here’s something
    you might be asking yourself at this point: How do we decide which to use? The
    high-level answer is the same as for many such questions: We use whichever one
    improves code clarity. A more practical answer is to use the one that best matches
    the arguments we have handy. If we have a bunch of unrelated values in variables
    or specified as literals, `call` lets us list them directly in its argument list.
    But if we already have the argument values in an array, or if it’s convenient
    to collect them as such, `apply` could be the better choice.'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 既然`apply`和`call`几乎做同样的事情，那么你现在可能会问自己一个问题：我们如何决定使用哪一个？高级答案与许多此类问题相同：我们使用任何一个可以提高代码清晰度的。一个更实际的答案是使用最适合我们手头参数的。如果我们有一堆无关的值在变量中或作为字面量指定，`call`允许我们直接在其参数列表中列出它们。但如果我们已经有了一组参数值在数组中，或者如果方便以这种方式收集它们，`apply`可能是更好的选择。
- en: 4.3\. Fixing the problem of function contexts
  id: totrans-592
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3\. 解决函数上下文问题
- en: 'In the preceding section, you saw some of the problems that can happen when
    dealing with function context in JavaScript. In callback functions (such as event
    handlers), the function context might not be exactly what we expect, but we can
    use the `call` and `apply` methods to get around it. In this section, you’ll see
    two other options: arrow functions and the `bind` method, which can, in certain
    cases, achieve the same effect, but in a much more elegant way.'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你看到了在处理JavaScript中的函数上下文时可能会遇到的一些问题。在回调函数（如事件处理器）中，函数上下文可能并不完全符合我们的预期，但我们可以使用`call`和`apply`方法来解决这个问题。在本节中，你将看到两种其他选项：箭头函数和`bind`方法，在某些情况下，它们可以达到相同的效果，但方式更加优雅。
- en: 4.3.1\. Using arrow functions to get around function contexts
  id: totrans-594
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.3.1\. 使用箭头函数绕过函数上下文
- en: 'Besides allowing us to create functions in a more elegant way than standard
    function declarations and function expressions, the arrow functions introduced
    in the previous chapter have one feature that makes them particularly good as
    callback functions: Arrow functions don’t have their own `this` value. Instead,
    they remember the value of the `this` parameter at the time of their definition.
    Let’s revisit our problem with button-click callbacks in the following listing.'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 除了允许我们以比标准函数声明和函数表达式更优雅的方式创建函数之外，上一章中引入的箭头函数还有一个特性使它们特别适合作为回调函数：箭头函数没有自己的`this`值。相反，它们会记住定义时`this`参数的值。让我们回顾一下以下列表中的按钮点击回调问题。
- en: Listing 4.13\. Using arrow functions to work around callback function contexts
  id: totrans-596
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.13。使用箭头函数绕过回调函数上下文
- en: '![](084fig01_alt.jpg)'
  id: totrans-597
  prefs: []
  type: TYPE_IMG
  zh: '![图片](084fig01_alt.jpg)'
- en: 'The only change, when compared to [listing 4.10](#ch04ex10), is that [listing
    4.13](#ch04ex13) uses an arrow function:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 与[列表4.10](#ch04ex10)相比，唯一的改变是[列表4.13](#ch04ex13)使用了一个箭头函数：
- en: '[PRE70]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Now, if we run the code, we’ll get the output shown in [figure 4.6](#ch04fig06).
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们运行代码，我们将得到[图4.6](#ch04fig06)中显示的输出。
- en: Figure 4.6\. Arrow functions don’t have their own context. Instead, the context
    is inherited from the function in which they’re defined. The `this` parameter
    in our arrow function callback refers to the button object.
  id: totrans-601
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.6。箭头函数没有它们自己的上下文。相反，上下文是从它们定义的函数中继承的。我们箭头函数回调中的`this`参数指向按钮对象。
- en: '![](04fig06.jpg)'
  id: totrans-602
  prefs: []
  type: TYPE_IMG
  zh: '![图片](04fig06.jpg)'
- en: 'As you can see, all is well now. The button object keeps track of the `clicked`
    state. What happened is that our click handler was created inside the `Button`
    constructor as an arrow function:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，现在一切正常。按钮对象跟踪`clicked`状态。发生的事情是我们的点击处理程序是在`Button`构造函数内部作为一个箭头函数创建的：
- en: '[PRE71]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: As we already mentioned, arrow functions don’t get their own implicit `this`
    parameter when we call them; instead they remember the value of the `this` parameter
    at the time they were created. In our case, the `click` arrow function was created
    inside a constructor function, where the `this` parameter is the newly constructed
    object, so whenever we (or the browser) call the `click` function, the value of
    the `this` parameter will always be bound to the newly constructed button object.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，当我们调用箭头函数时，箭头函数不会获得它们自己的隐式`this`参数；相反，它们会记住它们创建时的`this`参数的值。在我们的例子中，`click`箭头函数是在构造函数内部创建的，其中`this`参数是新构造的对象，所以无论我们（或浏览器）何时调用`click`函数，`this`参数的值都将始终绑定到新构造的按钮对象。
- en: 'Caveat: Arrow functions and object literals'
  id: totrans-606
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意：箭头函数和对象字面量
- en: Because the value of the `this` parameter is picked up at the moment that the
    arrow function is created, some seemingly strange behaviors can result. Let’s
    go back to our button-click handler example. Let’s say we’ve come to the conclusion
    that we don’t need a constructor function, because we have only one button. We
    replace it with a simple object literal, in the following way.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`this`参数的值是在箭头函数创建时获取的，因此可能会出现一些看似奇怪的行为。让我们回到我们的按钮点击处理程序示例。假设我们得出结论，我们不需要构造函数，因为我们只有一个按钮。我们用以下方式替换它为一个简单的对象字面量。
- en: Listing 4.14\. Arrow functions and object literals
  id: totrans-608
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.14。箭头函数和对象字面量
- en: '![](085fig01_alt.jpg)'
  id: totrans-609
  prefs: []
  type: TYPE_IMG
  zh: '![图片](085fig01_alt.jpg)'
- en: If we run [listing 4.14](#ch04ex14), we’ll again be disappointed, because the
    `button` object has once more failed to track the `clicked` state. See [figure
    4.7](#ch04fig07).
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行[列表4.14](#ch04ex14)，我们又会失望，因为`button`对象再次未能跟踪`clicked`状态。参见[图4.7](#ch04fig07)。
- en: Figure 4.7\. If an arrow function is defined within an object literal that’s
    defined in global code, the value of the `this` parameter associated with the
    arrow function is the global `window` object.
  id: totrans-611
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.7。如果一个箭头函数是在全局代码中定义的对象字面量内部定义的，那么与箭头函数关联的`this`参数的值是全局的`window`对象。
- en: '![](04fig07.jpg)'
  id: totrans-612
  prefs: []
  type: TYPE_IMG
  zh: '![图片](04fig07.jpg)'
- en: 'Luckily, we’ve scattered a couple of assertions throughout our code that will
    help. For example, we’ve placed the following directly in global code, in order
    to check the value of the `this` parameter:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们在代码中散布了一些断言，这将有助于我们。例如，我们将以下内容直接放置在全局代码中，以便检查`this`参数的值：
- en: '[PRE72]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Because the assertion passes, we can be sure that in global code `this` refers
    to the global `window` object.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 因为断言通过了，我们可以确信在全局代码中`this`指的是全局的`window`对象。
- en: 'We follow this by specifying that the `button` object literal has a `click`
    arrow function property:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着指定`button`对象字面量有一个`click`箭头函数属性：
- en: '[PRE73]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Now, we’ll again revisit our little rule: *Arrow functions pick up the value
    of the* `this` *parameter at the moment of their creation*. Because the `click`
    arrow function is created as a property value on an object literal, and the object
    literal is created in global code, the `this` value of the arrow function will
    be the `this` value of the global code. And, as we’ve seen from the first assertion
    placed in our global code'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将再次回顾我们的小规则：*箭头函数在创建时获取* `this` *参数的值*。因为`click`箭头函数作为一个属性值在对象字面量上创建，而对象字面量是在全局代码中创建的，所以箭头函数的`this`值将是全局代码的`this`值。而且，正如我们从我们在全局代码中放置的第一个断言中看到的
- en: '[PRE74]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'the value of the `this` parameter in global code is the global `window` object.
    Therefore, our `clicked` property will be defined on the global `window` object,
    and not on our `button` object. Just to be sure, in the end, we check that the
    `window` object has been assigned a `clicked` property:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 全局代码中 `this` 参数的值是全局的 `window` 对象。因此，我们的 `clicked` 属性将在全局 `window` 对象上定义，而不是在我们的
    `button` 对象上。为了确保这一点，最后我们检查 `window` 对象是否被分配了一个 `clicked` 属性：
- en: '[PRE75]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: As you can see, failing to keep in mind all the consequences of arrow functions
    can lead to some subtle bugs, so be careful!
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，未能记住所有箭头函数的后果可能会导致一些微妙的错误，所以请小心！
- en: Now that we’ve explored how arrow functions can be used to circumvent the problem
    of function contexts, let’s continue with another method for fixing the same problem.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了如何使用箭头函数来绕过函数上下文的问题，让我们继续使用另一种方法来解决这个问题。
- en: 4.3.2\. Using the bind method
  id: totrans-624
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.3.2\. 使用 `bind` 方法
- en: In this chapter, you’ve already met two methods that every function has access
    to, `call` and `apply`, and you’ve seen how to use them for greater control over
    the context and arguments of our function invocations.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经遇到了每个函数都可以访问的两个方法，`call` 和 `apply`，你也看到了如何使用它们来对我们的函数调用有更大的控制权。
- en: In addition to these methods, every function has access to the `bind` method
    that, in short, creates a new function. This function has the same body, but its
    context is *always* bound to a certain object, *regardless* of the way we invoke
    it.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些方法外，每个函数都可以访问 `bind` 方法，简而言之，它创建一个新的函数。这个函数有相同的主体，但它的上下文始终绑定到某个对象，*无论* 我们如何调用它。
- en: Let’s revisit our little problem with button-click handlers one last time.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次回顾一下我们的按钮点击处理器的小问题。
- en: Listing 4.15\. Binding a specific context to an event handler
  id: totrans-628
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.15\. 将特定上下文绑定到事件处理器
- en: '![](087fig01_alt.jpg)'
  id: totrans-629
  prefs: []
  type: TYPE_IMG
  zh: '![](087fig01_alt.jpg)'
- en: 'The secret sauce added here is the `bind()` method:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 这里添加的秘密成分是 `bind()` 方法：
- en: '[PRE76]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The `bind` method is available to all functions, and is designed to *create*
    and return a *new* function that’s bound to the passed-in object (in this case,
    the `button` object). The value of the `this` parameter is always set to that
    object, regardless of the way the bound function was invoked. Apart from that,
    the bound function behaves like the originating function, because it has the same
    code in its body.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: '`bind` 方法对所有函数都可用，并且旨在 *创建* 并返回一个 *新* 的函数，该函数绑定到传入的对象（在这种情况下，是 `button` 对象）。`this`
    参数的值始终设置为该对象，无论绑定函数是如何调用的。除此之外，绑定函数的行为与原始函数一样，因为它在其主体中有相同的代码。'
- en: Whenever the button is clicked, that bound function will be invoked with the
    `button` object as its context, because we’ve used that `button` object as an
    argument to `bind`.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 每次按钮被点击时，那个绑定函数都会以 `button` 对象作为其上下文被调用，因为我们已经将那个 `button` 对象作为 `bind` 的参数。
- en: 'Note that calling the `bind` method doesn’t modify the original function. It
    creates a completely new function, a fact asserted at the end of the example:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，调用 `bind` 方法不会修改原始函数。它创建了一个全新的函数，这在示例的末尾得到了证实：
- en: '[PRE77]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'With this, we’ll end our exploration of the function context. Rest for now,
    because in the next chapter, we’ll be dealing with one of the most important concepts
    in JavaScript: closures.'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们将结束对函数上下文的探索。现在休息一下，因为下一章，我们将处理JavaScript中最重要概念之一：闭包。
- en: 4.4\. Summary
  id: totrans-637
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4\. 总结
- en: 'When invoking a function, in addition to the parameters explicitly stated in
    the function definition, function invocations are passed in two implicit parameters:
    `arguments` and `this`:'
  id: totrans-638
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当调用一个函数时，除了在函数定义中明确声明的参数外，函数调用还传递了两个隐含参数：`arguments` 和 `this`：
- en: The `arguments` parameter is a collection of arguments passed to the function.
    It has a `length` property that indicates how many arguments were passed in, and
    it enables us to access the values of arguments that don’t have matching parameters.
    In nonstrict mode, the `arguments` object aliases the function parameters (changing
    the argument changes the value of the parameter, and vice versa). This can be
    avoided by using strict mode.
  id: totrans-639
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arguments` 参数是传递给函数的参数集合。它有一个 `length` 属性，表示传递了多少个参数，并且它使我们能够访问没有匹配参数的参数值。在非严格模式下，`arguments`
    对象是函数参数的别名（改变参数会改变参数的值，反之亦然）。这可以通过使用严格模式来避免。'
- en: The `this` parameter represents the function context, an object to which the
    function invocation is associated. How `this` is determined can depend on the
    way a function is defined as well as on how it’s invoked.
  id: totrans-640
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`this`参数表示函数上下文，一个与函数调用关联的对象。`this`是如何确定的，可以取决于函数的定义方式以及它的调用方式。'
- en: 'A function can be invoked in four ways:'
  id: totrans-641
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数可以通过四种方式被调用：
- en: 'As a function: `skulk()`'
  id: totrans-642
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为函数：`skulk()`
- en: 'As a method: `ninja.skulk()`'
  id: totrans-643
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为方法：`ninja.skulk()`
- en: 'As a constructor: `new Ninja()`'
  id: totrans-644
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为构造函数：`new Ninja()`
- en: 'Via its `apply` and `call` methods: `skulk.call(ninja)` or `skulk.apply(ninja)`'
  id: totrans-645
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过其`apply`和`call`方法：`skulk.call(ninja)`或`skulk.apply(ninja)`
- en: 'The way a function is invoked influences the value of the `this` parameter:'
  id: totrans-646
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的调用方式会影响`this`参数的值：
- en: If a function is invoked as a function, the value of the `this` parameter is
    usually the global `window` object in nonstrict mode, and `undefined` in strict
    mode.
  id: totrans-647
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个函数作为函数被调用，非严格模式下`this`参数的值通常是全局`window`对象，而在严格模式下是`undefined`。
- en: If a function is invoked as a method, the value of the `this` parameter is usually
    the object on which the function was invoked.
  id: totrans-648
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个函数作为方法被调用，`this`参数的值通常是调用该函数的对象。
- en: If a function is invoked as a constructor, the value of the `this` parameter
    is the newly constructed object.
  id: totrans-649
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个函数作为构造函数被调用，`this`参数的值是新构造的对象。
- en: If a function is invoked through `call` and `apply`, the value of the `this`
    parameter is the first argument supplied to `call` and `apply`.
  id: totrans-650
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个函数通过`call`和`apply`被调用，`this`参数的值是`call`和`apply`提供的第一个参数。
- en: Arrow functions don’t have their own value of the `this` parameter. Instead,
    they pick it up at the moment of their creation.
  id: totrans-651
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箭头函数没有自己的`this`参数值。相反，它们在创建时获取它。
- en: Use the `bind` method, available to all functions, to create a new function
    that’s always bound to the argument of the `bind` method. In all other aspects,
    the bound function behaves as the original function.
  id: totrans-652
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用所有函数都有的`bind`方法创建一个新的函数，该函数始终绑定到`bind`方法的参数。在其他所有方面，绑定函数的行为与原始函数相同。
- en: 4.5\. Exercises
  id: totrans-653
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5\. 练习
- en: '**1**'
  id: totrans-654
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**'
- en: ''
  id: totrans-655
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The following function calculates the sum of the passed-in arguments by using
    the `arguments` object:'
  id: totrans-656
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下函数通过使用`arguments`对象计算传入参数的总和：
- en: ''
  id: totrans-657
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-658
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE78]'
- en: ''
  id: totrans-659
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: By using the rest parameters introduced in the previous chapter, rewrite the
    `sum` function so that it doesn’t use the `arguments` object.
  id: totrans-660
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通过使用上一章中引入的剩余参数，重写`sum`函数，使其不使用`arguments`对象。
- en: '**2**'
  id: totrans-661
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**'
- en: ''
  id: totrans-662
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: After running the following code, what are the values of variables `ninja` and
    `samurai`?
  id: totrans-663
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在运行以下代码后，变量`ninja`和`samurai`的值是什么？
- en: ''
  id: totrans-664
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-665
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '**3**'
  id: totrans-666
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**'
- en: ''
  id: totrans-667
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When running the following code, which of the assertions will pass?
  id: totrans-668
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在运行以下代码时，哪个断言会通过？
- en: ''
  id: totrans-669
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-670
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '**4**'
  id: totrans-671
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**'
- en: ''
  id: totrans-672
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When running the following code, which of the assertions will pass?
  id: totrans-673
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在运行以下代码时，哪个断言会通过？
- en: ''
  id: totrans-674
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-675
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '**5**'
  id: totrans-676
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**5**'
- en: ''
  id: totrans-677
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When running the following code, which of the assertions will pass?
  id: totrans-678
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在运行以下代码时，哪个断言会通过？
- en: ''
  id: totrans-679
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-680
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '**6**'
  id: totrans-681
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**6**'
- en: ''
  id: totrans-682
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following assertions will pass?
  id: totrans-683
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪个断言会通过？
- en: ''
  id: totrans-684
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-685
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Chapter 5\. Functions for the master: closures and scopes'
  id: totrans-686
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第五章\. 为大师准备的函数：闭包和作用域
- en: '*This chapter covers*'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Using closures to simplify development
  id: totrans-688
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用闭包简化开发
- en: Tracking the execution of JavaScript programs with execution contexts
  id: totrans-689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用执行上下文跟踪JavaScript程序的执行
- en: Tracking variable scopes with lexical environments
  id: totrans-690
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用词法环境跟踪变量作用域
- en: Understanding types of variables
  id: totrans-691
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解变量类型
- en: Exploring how closures work
  id: totrans-692
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索闭包的工作原理
- en: Closely tied to the functions we learned about in previous chapters, closures
    are a defining feature of JavaScript. Although scores of JavaScript developers
    can write code without understanding the benefits of closures, their use can not
    only help us reduce the amount and complexity of code needed to add advanced features,
    but also enable us to do things that otherwise wouldn’t be possible, or would
    be too complex to be feasible. For example, any tasks involving callbacks, such
    as event handling or animations, would be significantly more complex without closures.
    Others, such as providing support for private object variables, would be outright
    impossible. The landscape of the language and the way we write our code is forever
    shaped by the inclusion of closures.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在前几章中学到的函数紧密相关，闭包是 JavaScript 的一个定义性特征。尽管许多 JavaScript 开发者可以编写代码而不理解闭包的好处，但闭包的使用不仅可以帮助我们减少添加高级功能所需的代码量和复杂性，而且还能使我们能够完成其他情况下不可能完成或过于复杂而无法实现的事情。例如，任何涉及回调的任务，如事件处理或动画，如果没有闭包，将会变得非常复杂。其他任务，如提供对私有对象变量的支持，将完全不可能。语言本身以及我们编写代码的方式，都因闭包的引入而永远改变。
- en: Traditionally, closures have been a feature of purely functional programming
    languages. Seeing them cross over into mainstream development is encouraging.
    It’s common to find closures permeating JavaScript libraries, along with other
    advanced code bases, because of their ability to drastically simplify complex
    operations.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，闭包是纯函数式编程语言的一个特性。看到它们跨越到主流开发中是令人鼓舞的。在 JavaScript 库和其他高级代码库中，闭包的普遍存在是因为它们能够极大地简化复杂的操作。
- en: Closures are a side effect of how scopes work in JavaScript. For this reason,
    we’ll explore the scoping rules of JavaScript, with a special focus on recent
    additions. This will help you understand how closures work behind the scenes.
    Let’s jump right in!
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包是 JavaScript 中作用域工作方式的副作用。因此，我们将探讨 JavaScript 的作用域规则，特别关注最近的新增功能。这将帮助你理解闭包在幕后是如何工作的。让我们直接进入正题！
- en: Do you know?
  id: totrans-696
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你知道吗？
- en: '**Q1:**'
  id: totrans-697
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Q1:**'
- en: ''
  id: totrans-698
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How many different scopes can a variable or method have, and what are they?
  id: totrans-699
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 变量或方法可以有多少个不同的作用域，它们是什么？
- en: '**Q2:**'
  id: totrans-700
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Q2:**'
- en: ''
  id: totrans-701
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How are identifiers and their values tracked?
  id: totrans-702
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 标识符及其值是如何追踪的？
- en: '**Q3:**'
  id: totrans-703
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Q3:**'
- en: ''
  id: totrans-704
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is a mutable variable, and how do you define one in JavaScript?
  id: totrans-705
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 什么是可变变量，如何在 JavaScript 中定义一个？
- en: 5.1\. Understanding closures
  id: totrans-706
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1\. 理解闭包
- en: A *closure* allows a function to access and manipulate variables that are external
    to that function. Closures allow a function to access all the variables, as well
    as other functions, that are in scope when the function itself is defined.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: '*闭包* 允许一个函数访问和操作该函数外部定义的变量。闭包允许一个函数访问在函数定义时作用域内的所有变量，以及其他函数。'
- en: '|  |'
  id: totrans-708
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-709
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You’re probably familiar with the concept of scopes, but just in case, a *scope*
    refers to the visibility of identifiers in certain parts of a program. A scope
    is a part of the program in which a certain name is bound to a certain variable.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能熟悉作用域的概念，但以防万一，*作用域* 指的是标识符在程序某些部分的可视性。作用域是程序的一部分，在这个部分中，某个名称绑定到某个变量上。
- en: '|  |'
  id: totrans-711
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: That may seem intuitive until you remember that a declared function can be called
    at any later time, even *after* the scope in which it was declared has gone away.
    This concept is probably best explained through code. But before we get into concrete
    examples that will help you develop more elegant animations in code or to define
    private object properties, let’s start small, with the following listing.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来很直观，直到你记得一个声明的函数可以在任何后来的时间被调用，甚至是在它声明的范围消失之后。这个概念最好通过代码来解释。但在我们具体讨论有助于你编写更优雅的动画代码或定义私有对象属性的示例之前，让我们从小处着手，从以下列表开始。
- en: Listing 5.1\. A simple closure
  id: totrans-713
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.1\. 一个简单的闭包
- en: '![](092fig01_alt.jpg)'
  id: totrans-714
  prefs: []
  type: TYPE_IMG
  zh: '![](092fig01_alt.jpg)'
- en: In this code example, we declare a variable `outerValue` and a function `outerFunction`
    in the same scope—in this case, the global scope. Afterward, we call `outerFunction`.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码示例中，我们在同一个作用域中声明了一个变量 `outerValue` 和一个函数 `outerFunction`——在这个例子中，是全局作用域。之后，我们调用了
    `outerFunction`。
- en: As you can see in [figure 5.1](#ch05fig01), the function is able to “see” and
    access the `outerValue` variable. You’ve likely written code such as this hundreds
    of times without realizing that you were creating a closure!
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在 [图 5.1](#ch05fig01) 中看到的，函数能够“看到”并访问 `outerValue` 变量。你可能已经编写了数百次这样的代码，而没有意识到你正在创建闭包！
- en: Figure 5.1\. Our function has found the ninja, who was hiding in plain sight.
  id: totrans-717
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.1\. 我们的功能已经找到了隐藏在明处的忍者。
- en: '![](05fig01.jpg)'
  id: totrans-718
  prefs: []
  type: TYPE_IMG
  zh: '![图片](05fig01.jpg)'
- en: Not impressed? Guess that’s not surprising. Because both `outerValue` and `outerFunction`
    are declared in global scope, that scope (which is a closure) never goes away
    (as long as our application is running). It’s not surprising that the function
    can access the variable, because it’s still in scope and viable.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 不太满意？猜这并不奇怪。因为`outerValue`和`outerFunction`都是在全局范围内声明的，这个范围（它是一个闭包）永远不会消失（只要我们的应用程序正在运行）。函数能够访问变量并不奇怪，因为它仍然在范围内且有效。
- en: Even though the closure exists, its benefits aren’t yet clear. Let’s spice it
    up in the next listing.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管闭包存在，但其好处还不明显。让我们在下一个列表中添加一些内容。
- en: Listing 5.2\. Another closure example
  id: totrans-721
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.2\. 另一个闭包示例
- en: '![](093fig01_alt.jpg)'
  id: totrans-722
  prefs: []
  type: TYPE_IMG
  zh: '![图片](093fig01_alt.jpg)'
- en: 'Let’s overanalyze the code in `innerFunction` and see whether we can predict
    what might happen:'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们过度分析`innerFunction`中的代码，看看我们是否能预测可能会发生什么：
- en: The first `assert` is certain to pass; `outerValue` is in the global scope and
    is visible to everything. But what about the second `assert`?
  id: totrans-724
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个`assert`肯定能通过；`outerValue`在全局范围内，对一切可见。但第二个`assert`呢？
- en: We’re executing `innerFunction` *after* `outerFunction` has been executed via
    the trick of copying a reference to the function to the global variable `later`.
  id: totrans-725
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是通过将函数的引用复制到全局变量`later`中，在`outerFunction`执行后执行`innerFunction`的。
- en: When `innerFunction` executes, the scope inside the outer function is long gone
    and not visible at the point at which we’re invoking the function through `later`.
  id: totrans-726
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`innerFunction`执行时，外函数内部的范围已经消失且在通过`later`调用函数的点上不可见。
- en: So we could very well expect `assert` to fail, as `innerValue` is sure to be
    `undefined`. Right?
  id: totrans-727
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，我们完全可以预期`assert`会失败，因为`innerValue`肯定会被赋予`undefined`。对吗？
- en: But when we run the test, we see the display in [figure 5.2](#ch05fig02).
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 但当我们运行测试时，我们看到的是[图5.2](#ch05fig02)中的显示。
- en: Figure 5.2\. Despite trying to hide inside a function, the ninja has been detected!
  id: totrans-729
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.2\. 尽管试图隐藏在函数内部，忍者已经被检测到！
- en: '![](05fig02.jpg)'
  id: totrans-730
  prefs: []
  type: TYPE_IMG
  zh: '![图片](05fig02.jpg)'
- en: How can that be? What magic allows the `innerValue` variable to still be “alive”
    when we execute the inner function, long after the scope in which it was created
    has gone away? The answer is closures.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 怎么会这样？什么魔法允许我们在执行内部函数时，即使在其创建的作用域已经消失很久之后，`innerValue`变量仍然“存活”？答案是闭包。
- en: When we declare `innerFunction` inside the outer function, not only is the function
    declaration defined, but a closure is created that encompasses the function definition
    as well as all variables in scope *at the point of function definition*. When
    `innerFunction` eventually executes, even if it’s executed *after* the scope in
    which it was declared goes away, it has access to the original scope in which
    it was declared through its closure, as shown in [figure 5.3](#ch05fig03).
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在外函数内部声明`innerFunction`时，不仅定义了函数声明，还创建了一个闭包，它包括函数定义以及函数定义点的作用域内的所有变量。当`innerFunction`最终执行时，即使它是在声明它的作用域消失之后执行的，它也可以通过其闭包访问其声明的原始作用域，如图5.3所示。
- en: Figure 5.3\. Like a protective bubble, the closure for `innerFunction` keeps
    the variables in the function’s scope alive for as long as the function exists.
  id: totrans-733
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.3\. 就像保护性的气泡一样，`innerFunction`的闭包使函数作用域内的变量在函数存在期间保持活跃。
- en: '![](05fig03.jpg)'
  id: totrans-734
  prefs: []
  type: TYPE_IMG
  zh: '![图片](05fig03.jpg)'
- en: That’s what closures are all about. They create a “safety bubble” of the function
    and the variables in scope at the point of the function’s definition, so that
    the function has all it needs to execute. This bubble, containing the function
    and its variables, stays around as long as the function does.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是闭包的全部内容。它们创建了一个“安全气泡”，包含函数及其在函数定义点的作用域内的变量，这样函数就有它执行所需的一切。这个包含函数及其变量的气泡，只要函数存在就会一直存在。
- en: Although all this structure isn’t readily visible (there’s no “closure” object
    holding all of this information that you can inspect), storing and referencing
    information in this way has a direct cost. It’s important to remember that each
    function that accesses information via a closure has a “ball and chain” attached
    to it, carrying this information around. So although closures are incredibly useful,
    they aren’t free of overhead. All that information needs to be held in memory
    until it’s absolutely clear to the JavaScript engine that it’s no longer needed
    (and is safe to garbage-collect), or until the page unloads.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管所有这些结构并不一目了然（没有“闭包”对象持有所有这些信息供你检查），以这种方式存储和引用信息是有直接成本的。重要的是要记住，每个通过闭包访问信息的函数都附有一个“球和链”，携带这些信息。因此，尽管闭包非常有用，但它们并非没有开销。所有这些信息都需要保留在内存中，直到
    JavaScript 引擎明确知道它不再需要（并且可以安全地进行垃圾回收），或者直到页面卸载。
- en: Don’t worry; this isn’t all that we have to say about how closures work. But
    before exploring the mechanisms that enable closures, let’s look at their practical
    uses.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 别担心；我们并非只有关于闭包工作原理的这些话要说。但在探索使闭包得以实现的机制之前，让我们先看看它们的实际用途。
- en: 5.2\. Putting closures to work
  id: totrans-738
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2\. 利用闭包
- en: Now that we have a high-level understanding of closures, let’s see how to put
    them to work in our JavaScript applications. For now, we’ll focus on their practical
    aspects and benefits. Later in the chapter, we’ll revisit the same examples to
    see exactly what’s going on behind the scenes.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对闭包有了高层次的理解，让我们看看如何在 JavaScript 应用程序中利用它们。现在，我们将关注它们的实际方面和好处。在本章的后面部分，我们将重新审视相同的示例，以了解幕后到底发生了什么。
- en: 5.2.1\. Mimicking private variables
  id: totrans-740
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.1\. 模拟私有变量
- en: Many programming languages use *private variables*—properties of an object that
    are hidden from outside parties. This is a useful feature, because we don’t want
    to overburden the users of our objects with unnecessary implementation details
    when accessing those objects from other parts of the code. Unfortunately, JavaScript
    doesn’t have native support for private variables. But by using a closure, we
    can achieve an acceptable approximation, as demonstrated by the following code.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 许多编程语言使用*私有变量*——对象属性，对外部方隐藏。这是一个有用的特性，因为我们不希望在使用对象时，让用户承受不必要的实现细节的负担。不幸的是，JavaScript
    没有对私有变量的原生支持。但通过使用闭包，我们可以实现一个可接受的近似，如下面的代码所示。
- en: Listing 5.3\. Using closures to approximate private variables
  id: totrans-742
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.3\. 使用闭包近似私有变量
- en: '![](ch05ex03-0.jpg)'
  id: totrans-743
  prefs: []
  type: TYPE_IMG
  zh: '![](ch05ex03-0.jpg)'
- en: '![](ch05ex03-1.jpg)'
  id: totrans-744
  prefs: []
  type: TYPE_IMG
  zh: '![](ch05ex03-1.jpg)'
- en: Here we create a function, `Ninja`, to serve as a constructor. We introduced
    using a function as a constructor in [chapter 3](kindle_split_014.html#ch03) (and
    we’ll take an in-depth look in [chapter 7](kindle_split_019.html#ch07)). For now,
    recall that when using the `new` keyword on a function, a new object instance
    is created, and the function is called with that new object as its context, to
    serve as a constructor to that object. So `this` within the function refers to
    a newly instantiated object.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建一个函数，`Ninja`，作为构造函数。我们在[第3章](kindle_split_014.html#ch03)中介绍了使用函数作为构造函数（我们将在[第7章](kindle_split_019.html#ch07)中深入探讨）。现在，请回忆一下，当在函数上使用`new`关键字时，会创建一个新的对象实例，并且该函数会以这个新对象作为上下文被调用，作为该对象的构造函数。因此，函数内的`this`指向一个新实例化的对象。
- en: 'Within the constructor, we define a variable to hold state, `feints`. The JavaScript
    scoping rules for this variable limit its accessibility to *within* the constructor.
    To give access to the value of the variable from code that’s outside the scope,
    we define an *accessor* method: `getFeints`, which can be used to read the private
    variable. (Accessor methods are frequently called *getters*.)'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们定义一个变量来保存状态，`feints`。这个变量的 JavaScript 作用域规则限制了其可访问性仅限于*构造函数内部*。为了从代码外部的作用域访问变量的值，我们定义了一个*访问器*方法：`getFeints`，它可以用来读取私有变量。（访问器方法通常被称为*获取器*。）
- en: '[PRE84]'
  id: totrans-747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: An implementation method, `feint`, is then created to give us control over the
    value of the variable. In a real-world application, this might be a business method,
    but in this example, it merely increments the value of `feints`.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 然后创建了一个实现方法，`feint`，以让我们控制变量的值。在实际应用中，这可能是业务方法，但在这个例子中，它只是增加`feints`的值。
- en: 'After the constructor has done its duty, we can call the `feint` method on
    the newly created `ninja1` object:'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数完成其任务后，我们可以在新创建的`ninja1`对象上调用`feint`方法：
- en: '[PRE85]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Our tests show that we can use the accessor method to obtain the value of the
    private variable but that we can’t access it directly. This prevents us from being
    able to make uncontrolled changes to the value of the variable, just as if it
    were a true private variable. This situation is depicted in [figure 5.4](#ch05fig04).
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试表明，我们可以使用访问器方法来获取私有变量的值，但我们不能直接访问它。这防止了我们能够无控制地更改变量的值，就像它是一个真正的私有变量一样。这种情况在[图5.4](#ch05fig04)中有所描述。
- en: Figure 5.4\. Hiding the variable inside the constructor keeps it invisible to
    the outer scope, but where it counts, the variable is alive and well, protected
    by the closure.
  id: totrans-752
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.4\. 将变量隐藏在构造函数中使其对外部作用域不可见，但在它起作用的地方，变量仍然活跃，并受到闭包的保护。
- en: '![](05fig04_alt.jpg)'
  id: totrans-753
  prefs: []
  type: TYPE_IMG
  zh: '![图片](05fig04_alt.jpg)'
- en: Using closures allows the state of the ninja to be maintained within a method,
    without letting it be directly accessed by a user of the method—because the variable
    is available to the inner methods via their closures, but not to code that lies
    outside the constructor.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 使用闭包可以让忍者的状态在方法内部保持，而不会让方法的使用者直接访问它——因为变量通过闭包对内部方法可用，但对外部构造函数之外的代码不可用。
- en: This is a glimpse into the world of object-oriented JavaScript, which we’ll
    explore in greater depth in [chapter 7](kindle_split_019.html#ch07). For now,
    let’s focus on another common use of closures.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对面向对象JavaScript世界的窥视，我们将在第7章中更深入地探讨。现在，让我们专注于闭包的另一种常见用途。
- en: 5.2.2\. Using closures with callbacks
  id: totrans-756
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.2\. 使用闭包与回调
- en: Another common use of closures occurs when dealing with callbacks—when a function
    is called at an unspecified later time. Often, within such functions, we frequently
    need to access outside data. The following listing shows an example that creates
    a simple animation with callback timers.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包的另一种常见用途发生在处理回调函数时——当函数在不确定的将来某个时间被调用时。通常，在这样的函数中，我们经常需要访问外部数据。以下列表显示了一个使用回调计时器创建简单动画的示例。
- en: Listing 5.4\. Using a closure in a timer interval callback
  id: totrans-758
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.4\. 在计时器间隔回调中使用闭包
- en: '![](ch05ex04-0.jpg)'
  id: totrans-759
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch05ex04-0.jpg)'
- en: '![](ch05ex04-1.jpg)'
  id: totrans-760
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch05ex04-1.jpg)'
- en: 'What’s especially important about this code is that it uses a single anonymous
    function, placed as a `setInterval` argument, to accomplish the animation of the
    target `div` element. That function accesses three variables: `elem`, `tick`,
    and `timer`, via a closure, to control the animation process. The three variables
    (the reference to the DOM element, `elem;` the tick counter, `tick;` and the timer
    reference, `timer`) all must be maintained *across* the steps of the animation.
    And we need to keep them out of the global scope.'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码特别重要的是它使用了一个匿名函数，作为`setInterval`的参数，来完成目标`div`元素的动画。该函数通过闭包访问三个变量：`elem`、`tick`和`timer`，以控制动画过程。这三个变量（DOM元素的引用`elem`；计数器`tick`；计时器引用`timer`）都必须在动画的各个步骤中保持。而且我们需要将它们保持在全局作用域之外。
- en: But the example will still work fine if we move the variables out of the `animateIt`
    function and into the global scope. So why all the arm flailing about not polluting
    the global scope?
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们把变量从`animateIt`函数移出并放入全局作用域，示例仍然可以正常工作。那么为什么还要大惊小怪，不去污染全局作用域呢？
- en: 'Go ahead and move the variables into the global scope and verify that the example
    still works. Now modify the example to animate two elements: Add another element
    with a unique ID, and call the `animateIt` function with that ID right after the
    original call.'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将变量移入全局作用域并验证示例是否仍然有效。现在修改示例以动画两个元素：添加另一个具有唯一ID的元素，并在原始调用之后立即使用该ID调用`animateIt`函数。
- en: The problem immediately becomes obvious. If we keep the variables in the global
    scope, we need a set of three variables for *each* animation. Otherwise, they’ll
    step all over each other, trying to use the same set of variables to keep track
    of multiple states.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 问题立即变得明显。如果我们保持变量在全局作用域中，我们需要为每个动画设置一组三个变量。否则，它们会相互覆盖，试图使用同一组变量来跟踪多个状态。
- en: By defining the variables *inside* the function, and by relying on closures
    to make them available to the timer callback invocations, each animation gets
    its own private “bubble” of variables, as shown in [figure 5.5](#ch05fig05).
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在函数内部定义变量，并依靠闭包使它们对计时器回调调用可用，每个动画都获得自己的私有“气泡”变量，如图5.5所示。
- en: Figure 5.5\. By keeping the variables for multiple instances of the function
    separate, we can do many things at once.
  id: totrans-766
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.5. 通过保持函数多个实例的变量分离，我们可以同时做很多事情。
- en: '![](05fig05_alt.jpg)'
  id: totrans-767
  prefs: []
  type: TYPE_IMG
  zh: '![图片](05fig05_alt.jpg)'
- en: Without closures, doing multiple things at once, whether event handling, animations,
    or even server requests, would be incredibly difficult. If you’ve been waiting
    for a reason to care about closures, this is it!
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 没有闭包，同时做很多事情，无论是事件处理、动画，甚至是服务器请求，都会非常困难。如果你一直在等待一个关心闭包的理由，那就是它了！
- en: This example is a particularly good one for demonstrating how closures are capable
    of producing some surprisingly intuitive and concise code. By including the variables
    in the `animateIt` function, we create an implied closure without needing any
    complex syntax.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子特别适合演示闭包如何产生一些令人惊讶直观和简洁的代码。通过在`animateIt`函数中包含变量，我们创建了一个隐式的闭包，而无需任何复杂的语法。
- en: There’s another important concept that this example makes clear. Not only can
    we see the values that these variables had at the time the closure was created,
    but we can update them within the closure while the function within the closure
    executes. The closure isn’t just a snapshot of the state of the scope at the time
    of creation, but an active encapsulation of that state that we can modify as long
    as the closure exists.
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子还清楚地说明了另一个重要概念。我们不仅可以看到闭包创建时这些变量的值，我们还可以在闭包内部执行函数时更新它们。闭包不仅仅是创建时作用域状态的快照，而是一个我们可以修改的活跃封装状态，只要闭包存在。
- en: Closures are closely related to scopes, so we’ll spend a good deal of this chapter
    exploring scoping rules in JavaScript. But first, we’ll start with the details
    of how code execution is tracked in JavaScript.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包与作用域密切相关，因此我们将在本章中花费大量时间探讨JavaScript中的作用域规则。但首先，我们将从JavaScript中代码执行跟踪的细节开始。
- en: 5.3\. Tracking code execution with execution contexts
  id: totrans-772
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3. 使用执行上下文跟踪代码执行
- en: In JavaScript, the fundamental unit of execution is a function. We use them
    all the time, to calculate something, to perform side effects such as changing
    the UI, to achieve code reuse, or to make our code easier to understand. To fulfill
    its purpose, a function can call another function, which in turn can call another
    function, and so on. And when a function does its thing, our program execution
    has to return to the position from which the function was called. But have you
    ever wondered how the JavaScript engine keeps track of all these executing functions
    and return positions?
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，执行的基本单位是函数。我们经常使用它们，用于计算某些东西，执行副作用，如更改UI，实现代码重用，或使我们的代码更容易理解。为了实现其目的，一个函数可以调用另一个函数，然后另一个函数可以调用另一个函数，依此类推。当一个函数执行其操作时，我们的程序执行必须返回到函数被调用的位置。但你有没有想过JavaScript引擎是如何跟踪所有这些正在执行的函数和返回位置的？
- en: 'As we mentioned in [chapter 2](kindle_split_012.html#ch02), there are two main
    types of JavaScript code: *global code*, placed outside all functions, and *function
    code*, contained in functions. When our code is being executed by the JavaScript
    engine, each statement is executed in a certain *execution context.*'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在[第2章](kindle_split_012.html#ch02)中提到的，JavaScript代码主要有两种类型：*全局代码*，放置在所有函数之外，和*函数代码*，包含在函数中。当我们的代码被JavaScript引擎执行时，每个语句都是在一定的*执行上下文*中执行的。
- en: 'And just as we have two types of code, we have two types of execution contexts:
    a *global execution context* and a *function execution context*. Here’s the significant
    difference: There’s only *one* global execution context, created when our JavaScript
    program starts executing, whereas a *new* function execution context is created
    on *each* function invocation.'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们有两种类型的代码，我们也有两种类型的执行上下文：一个*全局执行上下文*和一个*函数执行上下文*。这里有一个显著的区别：只有一个全局执行上下文，在我们JavaScript程序开始执行时创建，而每次函数调用都会创建一个新的*函数执行上下文*。
- en: '|  |'
  id: totrans-776
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-777
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You may recall from [chapter 4](kindle_split_015.html#ch04) that *function context*
    is the object on which our function is invoked, which can be accessed through
    the `this` keyword. An execution context, although it has a similar name, is a
    completely different thing. It’s an internal JavaScript concept that the JavaScript
    engine uses to track the execution of our functions.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得[第4章](kindle_split_015.html#ch04)中提到的，*函数上下文*是我们函数被调用的对象，可以通过`this`关键字访问。执行上下文，尽管名称相似，但完全是另一回事。它是一个JavaScript引擎用来跟踪我们函数执行的内部概念。
- en: '|  |'
  id: totrans-779
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'As we mentioned in [chapter 2](kindle_split_012.html#ch02), JavaScript is based
    on a single-threaded execution model: Only one piece of code can be executed at
    a time. Every time a function is invoked, the current execution context has to
    be stopped, and a new function execution context, in which the function code will
    be evaluated, has to be created. After the function performs its task, its function
    execution context is usually discarded, and the caller execution context restored.
    So there’s a need to keep track of all these execution contexts—both the one that’s
    executing and the ones that are patiently waiting. The easiest way to do this
    is by using a *stack*, called the *execution context stack* (or often called a
    *call stack*).'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在[第2章](kindle_split_012.html#ch02)中提到的，JavaScript基于单线程执行模型：一次只能执行一段代码。每次调用函数时，当前执行上下必须停止，并创建一个新的函数执行上下文，其中将评估函数代码。函数执行完其任务后，其函数执行上下文通常会被丢弃，并恢复调用者的执行上下文。因此，需要跟踪所有这些执行上下文——正在执行的以及耐心等待的。最简单的方法是使用一个*栈*，称为*执行上下文栈*（或通常称为*调用栈*）。
- en: '|  |'
  id: totrans-781
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-782
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: A stack is a fundamental data structure in which you can put new items only
    to the top and can take existing items only from the top. Think of a stack of
    trays in a cafeteria. When you want to take one, you pick one from the top. And
    a cafeteria worker who has a new clean one also puts it on the top.
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 栈是一种基本的数据结构，你只能将新项目放入顶部，只能从顶部取出现有项目。想象一下自助餐厅里的一摞托盘。当你想要取一个时，你从顶部取一个。而且，有一个新干净的托盘的自助餐厅工作人员也会把它放在顶部。
- en: '|  |'
  id: totrans-784
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: This might seem vague, so let’s look at the following code, which reports the
    activity of two skulking ninjas.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来有些模糊，那么让我们看看以下代码，它报告了两个潜行忍者的活动。
- en: Listing 5.5\. The creation of execution contexts
  id: totrans-786
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.5\. 执行上下文的创建
- en: '![](100fig01_alt.jpg)'
  id: totrans-787
  prefs: []
  type: TYPE_IMG
  zh: '![图片](100fig01_alt.jpg)'
- en: 'This code is straightforward; we define the `skulk` function, which calls the
    `report` function, which outputs a message. Then, from global code, we make two
    separate calls to the `skulk` function: `skulk("Kuma")` and `skulk("Yoshi")`.
    By using this code as a basis, we’ll explore the creation of execution contexts,
    as shown in [figure 5.6](#ch05fig06).'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码很简单；我们定义了一个`skulk`函数，它调用`report`函数，该函数输出一条消息。然后，从全局代码中，我们分别调用两次`skulk`函数：`skulk("Kuma")`和`skulk("Yoshi")`。以这段代码为基础，我们将探讨执行上下文的创建，如图5.6所示。
- en: Figure 5.6\. The behavior of the execution context stack
  id: totrans-789
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.6\. 执行上下文栈的行为
- en: '![](05fig06_alt.jpg)'
  id: totrans-790
  prefs: []
  type: TYPE_IMG
  zh: '![图片](05fig06_alt.jpg)'
- en: 'When executing the example code, the execution context behaves as follows:'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行示例代码时，执行上下文的行为如下：
- en: The execution context stack starts with the global execution context that’s
    created only once per JavaScript program (once per page in the case of web pages).
    The global execution context is the active execution context when executing global
    code.
  id: totrans-792
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行上下文栈以全局执行上下文开始，全局执行上下文在每个JavaScript程序中只创建一次（在网页的情况下，每页只创建一次）。全局执行上下文是执行全局代码时的活动执行上下文。
- en: 'In global code, the program first defines two functions: `skulk` and `report`,
    and then calls the `skulk` function with `skulk("Kuma")`. Because only one piece
    of code can be executed at once, the JavaScript engine pauses the execution of
    the global code, and goes to execute the `skulk` function code with `Kuma` as
    an argument. This is done by creating a *new* function execution context and pushing
    it on top of the stack.'
  id: totrans-793
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在全局代码中，程序首先定义了两个函数：`skulk`和`report`，然后调用`skulk`函数，并传递参数`skulk("Kuma")`。因为一次只能执行一段代码，JavaScript引擎暂停全局代码的执行，并转到执行带有参数`Kuma`的`skulk`函数代码。这是通过创建一个新的函数执行上下文并将其推到栈顶来完成的。
- en: The `skulk` function, in turn, calls the `report` function with the argument
    `Kuma skulking`. Again, because only one piece of code can be executed at a time,
    the `skulk` execution context is paused, and a new function execution context
    for the `report` function, with the argument `Kuma skulking,` is created and pushed
    onto the stack.
  id: totrans-794
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`skulk`函数反过来调用`report`函数，并传递参数`Kuma skulking`。同样，因为一次只能执行一段代码，`skulk`执行上下文被暂停，并为`report`函数创建一个新的函数执行上下文，参数为`Kuma
    skulking`，并将其推入栈中。'
- en: After the `report` function logs the message by using the built-in `console.log`
    function (see [appendix C](kindle_split_030.html#app03)) and finishes its execution,
    we have to go back to the `skulk` function. This is done by popping the `report`
    function execution context from the stack. The `skulk` function execution context
    is then reactivated, and the execution of the `skulk` function continues.
  id: totrans-795
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`report`函数通过内置的`console.log`函数（见[附录C](kindle_split_030.html#app03)）记录消息并完成其执行后，我们必须回到`skulk`函数。这是通过从栈中弹出`report`函数的执行上下文来完成的。然后重新激活`skulk`函数的执行上下文，并继续执行`skulk`函数。
- en: 'A similar thing happens when the `skulk` function finishes its execution: The
    function execution context of the `skulk` function is removed from the stack,
    and the global execution context, which has been patiently waiting this whole
    time, is restored as the active execution context. The execution of global JavaScript
    code is restored.'
  id: totrans-796
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`skulk`函数完成其执行时，也会发生类似的事情：`skulk`函数的函数执行上下文从栈中移除，整个过程中一直耐心等待的全局执行上下文被恢复为活动执行上下文。全局JavaScript代码的执行也被恢复。
- en: This whole process is repeated in a similar way for the second call to the `skulk`
    function, now with the argument `Yoshi`. Two new function execution contexts are
    created and pushed to the stack, `skulk("Yoshi")` and `report("Yoshi skulking")`,
    when the respective functions are called. These execution contexts are also popped
    off the stack when the program returns from the matching function.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 这个整个过程以类似的方式重复进行，对于`skulk`函数的第二次调用，现在带有参数`Yoshi`。当相应的函数被调用时，创建了两个新的函数执行上下文并推入栈中，分别是`skulk("Yoshi")`和`report("Yoshi
    skulking")`。当程序从匹配的函数返回时，这些执行上下文也会从栈中弹出。
- en: Even though the execution context stack is an internal JavaScript concept, you
    can explore it in any JavaScript debugger, where it’s referred to as a *call stack.*
    [Figure 5.7](#ch05fig07) shows the call stack in Chrome DevTools.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管执行上下文栈是JavaScript的一个内部概念，你可以在任何JavaScript调试器中探索它，在那里它被称为*调用栈*。[图5.7](#ch05fig07)展示了Chrome
    DevTools中的调用栈。
- en: Figure 5.7\. The current state of the execution context stack in Chrome DevTools
  id: totrans-799
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.7. Chrome DevTools中执行上下文栈的当前状态
- en: '![](05fig07_alt.jpg)'
  id: totrans-800
  prefs: []
  type: TYPE_IMG
  zh: '![](05fig07_alt.jpg)'
- en: '|  |'
  id: totrans-801
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-802
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: '[Appendix C](kindle_split_030.html#app03) gives a closer look at the debugging
    tools available in various browsers.'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: '[附录C](kindle_split_030.html#app03)提供了关于各种浏览器中可用调试工具的更详细说明。'
- en: '|  |'
  id: totrans-804
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Besides keeping track of the position in the application execution, the execution
    context is vital in *identifier resolution*, the process of figuring out which
    variable a certain identifier refers to. The execution context does this via the
    *lexical environment.*
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 除了跟踪应用程序执行中的位置，执行上下文在*标识符解析*中也非常重要，这是确定某个标识符引用哪个变量的过程。执行上下文通过*词法环境*来完成这项工作。
- en: 5.4\. Keeping track of identifiers with lexical environments
  id: totrans-806
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4. 使用词法环境跟踪标识符
- en: 'A *lexical environment* is an internal JavaScript engine construct used to
    keep track of the mapping from identifiers to specific variables. For example,
    consider the following code:'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: '*词法环境*是JavaScript引擎内部的一个结构，用于跟踪标识符到特定变量的映射。例如，考虑以下代码：'
- en: '[PRE86]'
  id: totrans-808
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The lexical environment is consulted when the `ninja` variable is accessed in
    the `console.log` statement.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 当在`console.log`语句中访问`ninja`变量时，会咨询词法环境。
- en: '|  |'
  id: totrans-810
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-811
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Lexical environments are an internal implementation of the JavaScript scoping
    mechanism, and people often colloquially refer to them as *scopes*.
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 词法环境是JavaScript作用域机制的内部实现，人们通常口语化地称它们为*作用域*。
- en: '|  |'
  id: totrans-813
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Usually, a lexical environment is associated with a specific structure of JavaScript
    code. It can be associated with a function, a block of code, or the `catch` part
    of a `try-catch` statement. Each of these structures (functions, blocks, and `catch`
    parts) can have its own separate identifier mappings.
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，词法环境与JavaScript代码的特定结构相关联。它可以与一个函数、一段代码或`try-catch`语句的`catch`部分相关联。这些结构（函数、块和`catch`部分）都可以有自己的独立的标识符映射。
- en: '|  |'
  id: totrans-815
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-816
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: In pre-ES6 versions of JavaScript, a lexical environment could be associated
    with only a function. Variables could be only function scoped. This caused a lot
    of confusion. Because JavaScript is a C-like language, people coming from other
    C-like languages (such as C++, C#, or Java) naturally expected some low-level
    concepts, such as the existence of block scopes, to be the same. With ES6, this
    is finally fixed.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES6 之前的 JavaScript 版本中，词法环境只能与一个函数关联。变量只能是函数作用域的。这造成了很多混淆。因为 JavaScript 是一种类似
    C 的语言，来自其他类似 C 的语言（如 C++、C# 或 Java）的人自然期望一些底层概念，如块作用域的存在，是相同的。随着 ES6 的推出，这个问题终于得到了解决。
- en: '|  |'
  id: totrans-818
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 5.4.1\. Code nesting
  id: totrans-819
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.1\. 代码嵌套
- en: Lexical environments are heavily based on *code nesting*, which enables one
    code structure to be contained within another. [Figure 5.8](#ch05fig08) shows
    various types of code nesting.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 词法环境在很大程度上基于 *代码嵌套*，这使得一个代码结构可以被包含在另一个代码结构中。[图 5.8](#ch05fig08) 展示了各种类型的代码嵌套。
- en: Figure 5.8\. Types of code nesting
  id: totrans-821
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.8\. 代码嵌套的类型
- en: '![](05fig08_alt.jpg)'
  id: totrans-822
  prefs: []
  type: TYPE_IMG
  zh: '![](05fig08_alt.jpg)'
- en: 'In this example, we can see the following:'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们可以看到以下内容：
- en: The `for` loop is nested within the `report` function.
  id: totrans-824
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for` 循环嵌套在 `report` 函数中。'
- en: The `report` function is nested within the `skulk` function.
  id: totrans-825
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`report` 函数嵌套在 `skulk` 函数中。'
- en: The `skulk` function is nested within global code.
  id: totrans-826
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skulk` 函数嵌套在全局代码中。'
- en: In terms of scopes, each of these code structures gets an associated lexical
    environment *every* time the code is evaluated. For example, on every invocation
    of the `skulk` function, a new function lexical environment is created.
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 在作用域方面，每次代码被评估时，每个代码结构都会获得一个相关的词法环境。例如，每次调用 `skulk` 函数时，都会创建一个新的函数词法环境。
- en: In addition, it’s important to emphasize that an inner code structure has access
    to the variables defined in outer code structures; for example, the `for` loop
    can access variables from the `report` function, the `skulk` function, and the
    global code; the `report` function can access variables from the `skulk` function
    and the global code; and the `skulk` function can access only additional variables
    from the global code.
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，重要的是要强调内部代码结构可以访问外部代码结构中定义的变量；例如，`for` 循环可以访问 `report` 函数、`skulk` 函数和全局代码中的变量；`report`
    函数可以访问 `skulk` 函数和全局代码中的变量；而 `skulk` 函数只能访问全局代码中的额外变量。
- en: There’s nothing special about this way of accessing variables; all of us have
    probably done it many times. But how does the JavaScript engine keep track of
    all these variables, and what’s accessible from where? This is where lexical environments
    jump in.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 这种访问变量的方式并没有什么特别之处；我们中的大多数人可能已经做过很多次了。但是，JavaScript 引擎是如何跟踪所有这些变量的，以及从哪里可以访问它们呢？这就是词法环境介入的地方。
- en: 5.4.2\. Code nesting and lexical environments
  id: totrans-830
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.2\. 代码嵌套和词法环境
- en: In addition to keeping track of local variables, function declarations, and
    function parameters, each lexical environment has to keep track of its *outer*
    (parent) lexical environment. This is necessary because we have to be able to
    access variables defined in outer code structures; if an identifier can’t be found
    in the current environment, the outer environment is searched. This stops either
    when the matching variable is found, or with a reference error if we’ve reached
    the global environment and there’s no sign of the searched-for identifier. [Figure
    5.9](#ch05fig09) shows an example; you can see how the identifiers `intro`, `action`,
    and `ninja` are resolved when executing the `report` function.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 除了跟踪局部变量、函数声明和函数参数之外，每个词法环境还必须跟踪其 *外部*（父级）词法环境。这是必要的，因为我们必须能够访问外部代码结构中定义的变量；如果在当前环境中找不到标识符，则会搜索外部环境。这会在找到匹配的变量时停止，或者如果已经达到全局环境且没有找到搜索的标识符，则会引发引用错误。[图
    5.9](#ch05fig09) 展示了一个示例；你可以看到在执行 `report` 函数时，标识符 `intro`、`action` 和 `ninja`
    是如何被解析的。
- en: Figure 5.9\. How JavaScript engines resolve the values of variables
  id: totrans-832
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.9\. JavaScript 引擎如何解析变量的值
- en: '![](05fig09_alt.jpg)'
  id: totrans-833
  prefs: []
  type: TYPE_IMG
  zh: '![](05fig09_alt.jpg)'
- en: In this example, the `report` function is called by the `skulk` function, which
    in turn is called by global code. Each execution context has a lexical environment
    associated with it that contains the mapping for all identifiers defined directly
    in that context. For example, the global environment holds the mapping for identifiers
    `ninja` and `skulk`, the `skulk` environment holds the mapping for the identifiers
    `action` and `report`, and the `report` environment holds the mapping for the
    `intro` identifier (the right side of [figure 5.9](#ch05fig09)).
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`report` 函数是由 `skulk` 函数调用的，而 `skulk` 函数又是由全局代码调用的。每个执行上下文都与一个词法环境相关联，该环境包含在该上下文中直接定义的所有标识符的映射。例如，全局环境包含标识符
    `ninja` 和 `skulk` 的映射，`skulk` 环境包含标识符 `action` 和 `report` 的映射，而 `report` 环境包含标识符
    `intro` 的映射（即[图 5.9](#ch05fig09) 的右侧）。
- en: In a particular execution context, besides accessing identifiers defined directly
    in the matching lexical environment, our programs often access other variables
    defined in outer environments. For example, in the body of the `report` function,
    we access the variable `action` of the outer `skulk` function, as well as the
    global `ninja` variable. To do this, we have to somehow keep track of these outer
    environments. JavaScript does this by taking advantage of functions as first-class
    objects.
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 在特定的执行上下文中，除了访问匹配词法环境中直接定义的标识符外，我们的程序通常还会访问外部环境中定义的其他变量。例如，在 `report` 函数的主体中，我们访问外部
    `skulk` 函数的 `action` 变量，以及全局的 `ninja` 变量。为了做到这一点，我们必须以某种方式跟踪这些外部环境。JavaScript
    通过利用函数作为一等对象来实现这一点。
- en: Whenever a function is created, a reference to the lexical environment in which
    the function was created is stored in an internal (meaning that you can’t access
    or manipulate it directly) property named `[[Environment]]`; double brackets is
    the notation that we’ll use to mark these internal properties. In our case, the
    `skulk` function will keep a reference to the global environment, and the `report`
    function will keep a reference to the `skulk` environment, because these were
    the environments in which the functions were created.
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 每当创建一个函数时，都会将函数创建时的词法环境引用存储在一个内部（这意味着你不能直接访问或操作它）属性中，该属性名为 `[[Environment]]`；双中括号是我们用来标记这些内部属性的符号。在我们的例子中，`skulk`
    函数将保留对全局环境的引用，而 `report` 函数将保留对 `skulk` 环境的引用，因为这些是函数创建的环境。
- en: '|  |'
  id: totrans-837
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-838
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: This might seem odd at first. Why don’t we just traverse the whole stack of
    execution contexts and search their matching environments for identifier mappings?
    Technically, this would work in our example. But remember, a JavaScript function
    can be passed around as any other object, so the position of the function definition
    and the position from where the function is called generally aren’t related (remember
    closures).
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 这一开始可能看起来有些奇怪。我们为什么不只是遍历整个执行上下文栈并搜索它们的匹配环境以查找标识符映射呢？技术上，在我们的例子中这会起作用。但记住，JavaScript
    函数可以被像任何其他对象一样传递，因此函数定义的位置和函数被调用的位置通常是不相关的（记住闭包）。
- en: '|  |'
  id: totrans-840
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Whenever a function is called, a new function execution context is created
    and pushed onto the execution context stack. In addition, a new associated lexical
    environment is created. Now comes the crucial part: For the outer environment
    of the newly created lexical environment, the JavaScript engine puts the environment
    referenced by the called function’s internal `[[Environment]]` property, the environment
    in which the now-called function was created!'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 每当调用一个函数时，都会创建一个新的函数执行上下文并将其推入执行上下文栈。此外，还会创建一个新的相关词法环境。现在到了关键部分：对于新创建的词法环境的外部环境，JavaScript
    引擎将调用函数内部 `[[Environment]]` 属性引用的环境，即现在被调用的函数创建时的环境！
- en: In our case, when the `skulk` function is called, the outer environment of the
    newly created `skulk` environment becomes the global environment (because it’s
    the environment in which the `skulk` function was created). Similarly, when calling
    the `report` function, the outer environment of the newly created `report` environment
    is set to the `skulk` environment.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，当调用 `skulk` 函数时，新创建的 `skulk` 环境的外部环境变为全局环境（因为它是 `skulk` 函数创建的环境）。同样，当调用
    `report` 函数时，新创建的 `report` 环境的外部环境被设置为 `skulk` 环境。
- en: 'Now let’s take a look at the `report` function:'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看 `report` 函数：
- en: '[PRE87]'
  id: totrans-844
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: When the first `assert` statement is being evaluated, we have to resolve the
    `intro` identifier. To do this, the JavaScript engine starts by checking the environment
    of the currently running execution context, the `report` environment. Because
    the `report` environment contains a reference to `intro`, the identifier is resolved.
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 当第一个 `assert` 语句正在评估时，我们必须解析 `intro` 标识符。为此，JavaScript 引擎首先检查当前运行执行上下文的环境，即
    `report` 环境。因为 `report` 环境包含对 `intro` 的引用，所以标识符被解析。
- en: 'Next, the second `assert` statement has to resolve the `action` identifier.
    Again, the environment of the currently running execution context is checked.
    But the `report` environment doesn’t contain a reference to the `action` identifier,
    so the JavaScript engine has to check the outer environment of the `report` environment:
    the `skulk` environment. Luckily, the `skulk` environment contains a reference
    to the `action` identifier, and the identifier is resolved. A similar process
    is followed when trying to resolve the `ninja` identifier (a little hint: the
    identifier can be found in the global environment).'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，第二个 `assert` 语句必须解析 `action` 标识符。同样，检查当前运行执行上下文的环境。但是 `report` 环境不包含对 `action`
    标识符的引用，所以 JavaScript 引擎必须检查 `report` 环境的外部环境：`skulk` 环境。幸运的是，`skulk` 环境包含对 `action`
    标识符的引用，并且标识符被解析。尝试解析 `ninja` 标识符时遵循类似的流程（一个小提示：标识符可以在全局环境中找到）。
- en: Now that you understand the fundamentals of identifier resolution, let’s look
    at the various ways a variable can be declared.
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了标识符解析的基础知识，让我们来看看变量可以声明的各种方式。
- en: 5.5\. Understanding types of JavaScript variables
  id: totrans-848
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5. 理解 JavaScript 变量的类型
- en: 'In JavaScript, we can use three keywords for defining variables: `var`, `let`,
    and `const`. They differ in two aspects: *mutability* and their relationship toward
    the lexical environment.'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，我们可以使用三个关键字来定义变量：`var`、`let` 和 `const`。它们在两个方面有所不同：*可变性*和它们与词法环境的关系。
- en: '|  |'
  id: totrans-850
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-851
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'The keyword `var` has been part of JavaScript since its beginning, whereas
    `let` and `const` are ES6 additions. You can check whether your browser supports
    `let` and `const` at the following links: [http://mng.bz/CGJ6](http://mng.bz/CGJ6)
    and [http://mng.bz/uUIT](http://mng.bz/uUIT).'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字 `var` 自 JavaScript 诞生以来就是其一部分，而 `let` 和 `const` 是 ES6 的新增功能。您可以在以下链接中检查您的浏览器是否支持
    `let` 和 `const`：[http://mng.bz/CGJ6](http://mng.bz/CGJ6) 和 [http://mng.bz/uUIT](http://mng.bz/uUIT)。
- en: '|  |'
  id: totrans-853
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 5.5.1\. Variable mutability
  id: totrans-854
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.5.1. 变量可变性
- en: If we were to divide variable declaration keywords by mutability, we’d put `const`
    on one side and `var` and `let` on the other side. All variables defined with
    `const` are immutable, meaning that their value can be set only once. On the other
    hand, variables defined with keywords `var` and `let` are typical run-of-the-mill
    variables, whose value we can change as many times as necessary.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要根据可变性来划分变量声明关键字，我们会把 `const` 放在一侧，而 `var` 和 `let` 放在另一侧。所有使用 `const` 定义的变量都是不可变的，这意味着它们的值只能设置一次。另一方面，使用关键字
    `var` 和 `let` 定义的变量是典型的常规变量，我们可以根据需要多次更改它们的值。
- en: Now, let’s delve into how `const` variables work and behave.
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解 `const` 变量的工作方式和行为。
- en: const variables
  id: totrans-857
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: const 变量
- en: A `const` “variable” is similar to a normal variable, with the exception that
    we have to provide an initialization value when it’s declared, and we can’t assign
    a completely new value to it afterward. Hmmm, not very *variable*, is it?
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `const` “变量”与普通变量类似，除了在声明时我们必须提供一个初始化值，并且之后不能为其分配一个全新的值。嗯，这不太像“变量”，对吧？
- en: '`Const` variables are often used for two slightly different purposes:'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: '`Const` 变量通常用于两个略有不同的目的：'
- en: Specifying variables that shouldn’t be reassigned (and in the rest of the book,
    we use them mostly in this regard).
  id: totrans-860
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定不应重新分配的变量（在本书的其余部分，我们主要用这种方式使用它们）。
- en: Referencing a fixed value, for example, the maximum number of ronin in a squad,
    `MAX_RONIN_COUNT`, by name, instead of using a literal number such as 234\. This
    makes our programs easier to understand and maintain. Our code isn’t filled with
    seemingly arbitrary literals (`234`), but with meaningful names (`MAX_RONIN_COUNT`)
    whose values are specified in only one place.
  id: totrans-861
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过名称引用一个固定值，例如，小队中浪人的最大数量 `MAX_RONIN_COUNT`，而不是使用一个字面量数字，如 234。这使得我们的程序更容易理解和维护。我们的代码不是充满了看似随机的字面量（`234`），而是充满了有意义的名称（`MAX_RONIN_COUNT`），其值只在一个地方指定。
- en: In either case, because `const` variables aren’t meant to be reassigned during
    program execution, we’ve safeguarded our code against unwanted or accidental modifications
    and we’ve even made it possible for the JavaScript engine to do some performance
    optimizations.
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，因为`const`变量在程序执行期间都不应该被重新赋值，所以我们已经保护了我们的代码免受未预期或意外的修改，甚至让JavaScript引擎能够进行一些性能优化。
- en: The following listing illustrates the behavior of `const` variables.
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表说明了`const`变量的行为。
- en: Listing 5.6\. The behavior of const variables
  id: totrans-864
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.6\. `const`变量的行为
- en: '![](ch05ex06-0.jpg)'
  id: totrans-865
  prefs: []
  type: TYPE_IMG
  zh: '![](ch05ex06-0.jpg)'
- en: '![](ch05ex06-1.jpg)'
  id: totrans-866
  prefs: []
  type: TYPE_IMG
  zh: '![](ch05ex06-1.jpg)'
- en: 'Here we first define a `const` variable named `firstConst` with a value `samurai`
    and test that the variable has been initialized, as expected:'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先定义了一个名为`firstConst`的`const`变量，其值为`samurai`，并测试该变量是否已按预期初始化：
- en: '[PRE88]'
  id: totrans-868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'We continue by trying to assign a completely new value, `ninja`, to our `firstConst`
    variable:'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续尝试将一个全新的值`ninja`赋给我们的`firstConst`变量：
- en: '[PRE89]'
  id: totrans-870
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Because the `firstConst` variable is, well, a constant, we can’t assign a new
    value to it, so the JavaScript engine throws an exception without modifying the
    variable’s value. Notice that we’re using two functions that we haven’t used so
    far: `fail` and `pass`. These two methods behave similarly to the `assert` method,
    except `fail` always fails and `pass` always passes. Here we use them to check
    whether an exception has occurred: If an exception occurs, the `catch` statement
    is activated and the `pass` method is executed. If there’s no exception, the `fail`
    method is executed, and we’ll be notified that something isn’t as it should be.
    We can check to verify that the exception happens, as shown in [figure 5.10](#ch05fig10).'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`firstConst`变量是一个常量，所以我们不能给它分配新的值，所以JavaScript引擎会抛出一个异常而不修改变量的值。注意，我们使用了之前没有使用过的两个函数：`fail`和`pass`。这两个方法的行为与`assert`方法类似，但`fail`总是失败，而`pass`总是通过。在这里，我们使用它们来检查是否发生了异常：如果发生异常，`catch`语句会被激活，并执行`pass`方法。如果没有异常，`fail`方法会被执行，我们会被告知某些事情并不像它应该的那样。我们可以检查以验证异常是否发生，如图5.10所示。
- en: Figure 5.10\. Checking the behavior of `const` variables. An exception occurs
    when we try to assign a completely new value to a `const` variable.
  id: totrans-872
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.10\. 检查`const`变量的行为。当我们尝试给`const`变量分配一个全新的值时，会发生异常。
- en: '![](05fig10.jpg)'
  id: totrans-873
  prefs: []
  type: TYPE_IMG
  zh: '![](05fig10.jpg)'
- en: 'Next, we define another `const` variable, this time initializing it to an empty
    object:'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义另一个`const`变量，这次将其初始化为一个空对象：
- en: '[PRE90]'
  id: totrans-875
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Now we’ll discuss an important feature of `const` variables. As you’ve already
    seen, we can’t assign a completely new value to a `const` variable. But there’s
    nothing stopping us from *modifying* the current one. For example, we can add
    new properites to the current object:'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将讨论`const`变量的重要特性。正如您已经看到的，我们无法给`const`变量分配一个全新的值。但没有任何阻止我们修改当前值。例如，我们可以向当前对象添加新的属性：
- en: '[PRE91]'
  id: totrans-877
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Or, if our `const` variable refers to an array, we can modify that array to
    any degree:'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们的`const`变量引用的是一个数组，我们可以修改这个数组到任何程度：
- en: '[PRE92]'
  id: totrans-879
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: And that’s about it. `const` variables aren’t that complicated to begin with.
    You only have to remember that a value of a `const` variable can be set only on
    initialization and that we can’t assign a completely new value later. We can still
    modify the existing value; we just can’t completely override it.
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。`const`变量本身并不复杂。您只需要记住，`const`变量的值只能在初始化时设置，并且我们以后不能分配一个全新的值。我们仍然可以修改现有值；我们只是不能完全覆盖它。
- en: Now that we’ve explored variable mutability, let’s consider the details of the
    relationships between various types of variables and lexical environments.
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了变量的可变性，让我们考虑不同类型变量和词法环境之间关系的细节。
- en: 5.5.2\. Variable definition keywords and lexical environments
  id: totrans-882
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.5.2\. 变量定义关键字和词法环境
- en: The three types of variable definitions—`var`, `let`, and `const`—can also be
    categorized by their relationship with the lexical environment (in other words,
    by their scope). In that case, we can put `var` on one side, and `let` and `const`
    on the other.
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 三种变量定义类型——`var`、`let`和`const`——也可以根据它们与词法环境的关系（换句话说，它们的范围）进行分类。在这种情况下，我们可以将`var`放在一边，而将`let`和`const`放在另一边。
- en: Using the var keyword
  id: totrans-884
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用`var`关键字
- en: When we use the `var` keyword, the variable is defined in the closest function
    or global lexical environment. (Note that blocks are ignored!) This is a long-standing
    detail of JavaScript that has tripped up many developers coming from other languages.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`var`关键字时，变量定义在最近的函数或全局词法环境中。（注意，块被忽略！）这是JavaScript的一个长期细节，让很多来自其他语言的开发者感到困惑。
- en: Consider the following listing.
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码示例。
- en: Listing 5.7\. Using the var keyword
  id: totrans-887
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.7\. 使用`var`关键字
- en: '![](109fig01_alt.jpg)'
  id: totrans-888
  prefs: []
  type: TYPE_IMG
  zh: '![](109fig01_alt.jpg)'
- en: We start by defining a global variable, `globalNinja`, which is followed by
    defining a `reportActivity` function that loops two times and notifies us about
    the jumping activity of our `globalNinja`. As you can see, within the body of
    the `for` loop, we can normally access both the block variables (`i` and `forMessage`),
    the function variables (`functionActivity`), and the global variables (`globalNinja`).
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一个全局变量`globalNinja`，然后定义一个`reportActivity`函数，该函数循环两次并通知我们`globalNinja`的跳跃活动。正如你所见，在`for`循环体中，我们可以正常访问块变量（`i`和`forMessage`），函数变量（`functionActivity`）和全局变量（`globalNinja`）。
- en: 'But what’s strange with JavaScript, and what confuses a lot of developers coming
    from other languages, is that we can access the variables defined with code blocks
    even outside those blocks:'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 但JavaScript中有些奇怪的地方，让很多来自其他语言的开发者感到困惑，那就是我们可以在代码块外部访问使用代码块定义的变量：
- en: '[PRE93]'
  id: totrans-891
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: This stems from the fact that variables declared with the keyword `var` are
    always registered in the closest function or global lexical environment, without
    paying any attention to blocks. [Figure 5.11](#ch05fig11) depicts this situation,
    by showing the state of lexical environments after the second iteration of the
    `for` loop in the `reportActivity` function.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 这源于使用`var`关键字声明的变量总是注册在最近的函数或全局词法环境中，而不考虑块。![图5.11](#ch05fig11)通过显示`reportActivity`函数中`for`循环第二次迭代后的词法环境状态来描述这种情况。
- en: Figure 5.11\. When defining variables with the keyword `var`, a variable is
    defined in the closest function or global environment (while ignoring block environments).
    In our case, the variables `forMessage` and `i` are registered in the `reportActivity`
    environment (the closest functional environment), even though they’re contained
    within a `for` loop.
  id: totrans-893
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.11\. 使用`var`关键字定义变量时，变量定义在最近的函数或全局环境中（同时忽略块环境）。在我们的例子中，变量`forMessage`和`i`注册在`reportActivity`环境中（最近的函数环境），尽管它们包含在`for`循环中。
- en: '![](05fig11_alt.jpg)'
  id: totrans-894
  prefs: []
  type: TYPE_IMG
  zh: '![](05fig11_alt.jpg)'
- en: 'Here we have three lexical environments:'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们有三个词法环境：
- en: The global environment in which the `globalNinja` variable is registered (because
    this is the closest function or global lexical environment)
  id: totrans-896
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册`globalNinja`变量的全局环境（因为这是最近的函数或全局词法环境）
- en: The `reportActivity` environment, created on the `reportActivity` function invocation,
    which contains the `functionActivity`, `i`, and `forMessage` variables, because
    they’re defined with the keyword `var`, and this is their closest function environment
  id: totrans-897
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reportActivity`函数调用时创建的`reportActivity`环境，其中包含`functionActivity`、`i`和`forMessage`变量，因为它们是用`var`关键字定义的，这是它们最近的函数环境'
- en: The `for` block environment, which is empty, because `var`-defined variables
    ignore blocks (even when contained within them)
  id: totrans-898
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for`块环境为空，因为用`var`定义的变量忽略了块（即使它们包含在其中）'
- en: 'Because this behavior is a bit strange, the ES6 version of JavaScript offers
    two new variable declaration keywords: `let` and `const`.'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种行为有点奇怪，ES6版本的JavaScript提供了两个新的变量声明关键字：`let`和`const`。
- en: Using let and const to specify block-scoped variables
  id: totrans-900
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用`let`和`const`指定块作用域变量
- en: Unlike `var`, which defines the variable in the closest function or global lexical
    environment, the `let` and `const` keywords are more straightforward. They define
    variables in the closest lexical environment (which can be a block environment,
    a loop environment, a function environment, or even the global environment). We
    can use `let` and `const` to define block-scoped, function-scoped, and global-scoped
    variables.
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 与定义变量在最近的函数或全局词法环境中的`var`不同，`let`和`const`关键字更为直接。它们在最近的词法环境中定义变量（这可以是块环境、循环环境、函数环境，甚至是全局环境）。我们可以使用`let`和`const`来定义块作用域、函数作用域和全局作用域变量。
- en: Let’s rewrite our previous example to use `const` and `let`.
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重写之前的例子，使用`const`和`let`。
- en: Listing 5.8\. Using const and let keywords
  id: totrans-903
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.8\. 使用`const`和`let`关键字
- en: '![](ch05ex08-0.jpg)'
  id: totrans-904
  prefs: []
  type: TYPE_IMG
  zh: '![](ch05ex08-0.jpg)'
- en: '![](ch05ex08-1.jpg)'
  id: totrans-905
  prefs: []
  type: TYPE_IMG
  zh: '![](ch05ex08-1.jpg)'
- en: '[Figure 5.12](#ch05fig12) illustrates the current situation, when finishing
    the execution of the second iteration of the `for` loop in the `reportActivity`
    function. We again have three lexical environments: the global environment (for
    global code outside all functions and blocks), the `reportActivity` environment
    bound to the `reportActivity` function, and the block environment for the `for`
    loop body. But because we’re using `let` and `const` keywords, the variables are
    defined in their closest lexical environment; the `GLOBAL_NINJA` variable is defined
    in the global environment, the `functionActivity` variable in the `reportActivity`
    environment, and the `i` and `forMessage` variables in the `for` block environment.'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.12](#ch05fig12)展示了当前情况，当`reportActivity`函数中`for`循环的第二次迭代执行完毕时。我们再次有三个词法环境：全局环境（用于所有函数和块之外的全局代码），与`reportActivity`函数绑定的`reportActivity`环境，以及`for`循环体块的块环境。但是因为我们使用了`let`和`const`关键字，变量定义在其最近的词法环境中；`GLOBAL_NINJA`变量定义在全局环境中，`functionActivity`变量在`reportActivity`环境中，而`i`和`forMessage`变量在`for`块环境中。'
- en: Figure 5.12\. When defining variables with keywords `let` and `const`, a variable
    is defined in the closest environment. In our case, variables `forMessage` and
    `i` are registered in the `for` block environment, the variable `functionActivity`
    in the `reportActivity` environment, and the `GLOBAL_NINJA` variable in the global
    environment (in every case, the closest environment to the respective variable).
  id: totrans-907
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.12。当使用`let`和`const`关键字定义变量时，变量定义在其最近的词法环境中。在我们的例子中，变量`forMessage`和`i`注册在`for`块环境中，变量`functionActivity`在`reportActivity`环境中，而`GLOBAL_NINJA`变量在全局环境中（在所有情况下，都是各自变量的最近词法环境）。
- en: '![](05fig12_alt.jpg)'
  id: totrans-908
  prefs: []
  type: TYPE_IMG
  zh: '![](05fig12_alt.jpg)'
- en: Now that `const` and `let` have been introduced, scores of new JavaScript developers
    who have recently come from other programming languages can be at peace. JavaScript
    finally supports the same scoping rules as other C-like languages. For this reason,
    from this point in this book, we almost always use `const` and `let` instead of
    `var`.
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，随着`const`和`let`的引入，大量最近从其他编程语言转来的新JavaScript开发者可以安心了。JavaScript终于支持与其他C-like语言相同的作用域规则。因此，从本书的这个点开始，我们几乎总是使用`const`和`let`而不是`var`。
- en: Now that we understand how identifier mappings are kept within lexical environments
    and how lexical environments are linked to program execution, let’s discuss the
    exact process by which identifiers are defined within lexical environments. This
    will help us better understand some commonly occurring bugs.
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了标识符映射如何在词法环境中保持，以及词法环境如何与程序执行相关联，让我们讨论标识符在词法环境中定义的确切过程。这将帮助我们更好地理解一些常见的错误。
- en: 5.5.3\. Registering identifiers within lexical environments
  id: totrans-911
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.5.3。在词法环境中注册标识符
- en: 'One of the driving principles behind the design of JavaScript as a programming
    language was its ease of use. That’s one of the main reasons for not specifying
    function return types, function parameter types, variable types, and so on. And
    you already know that JavaScript code is executed line by line, in a straightforward
    fashion. Consider the following:'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: 设计JavaScript作为编程语言背后的一个驱动原则是其易用性。这也是没有指定函数返回类型、函数参数类型、变量类型等原因之一。而且你已经知道JavaScript代码是逐行、直接执行。考虑以下内容：
- en: '[PRE94]'
  id: totrans-913
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The value `Kiyokawa` is assigned to the identifier `firstRonin`, and then the
    value `Kondo` is assigned to the identifier `secondRonin`. There’s nothing weird
    about that, right? But take a look at another example:'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 将值`Kiyokawa`分配给标识符`firstRonin`，然后值`Kondo`分配给标识符`secondRonin`。这没什么奇怪的，对吧？但是看看另一个例子：
- en: '[PRE95]'
  id: totrans-915
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: In this case, we assign the value `Kiyokawa` to the identifier `firstRonin`,
    and then we call the `check` function with the identifier `firstRonin` as a parameter.
    But hold on a second—if the code is executed line by line, should we be able to
    call the `check` function? Our program execution hasn’t reached its declaration,
    so the JavaScript engine shouldn’t even know about it.
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将值`Kiyokawa`分配给标识符`firstRonin`，然后我们用标识符`firstRonin`作为参数调用`check`函数。但是等等——如果代码逐行执行，我们是否应该能够调用`check`函数？我们的程序执行还没有达到其声明，所以JavaScript引擎甚至不应该知道它。
- en: But if we check, as shown in [figure 5.13](#ch05fig13), you see that all is
    fine and well. JavaScript isn’t too picky about where we define our functions.
    We can choose to place function declarations before or even after their respective
    calls. This isn’t something that the developer should need to fuss about.
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们检查，如图 5.13 所示，你会看到一切正常。JavaScript 对我们定义函数的位置并不太挑剔。我们可以选择在函数调用之前或之后放置函数声明。这不是开发者需要烦恼的事情。
- en: Figure 5.13\. The function is indeed visible, even before the execution reaches
    its definition.
  id: totrans-918
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.13\. 函数确实在执行达到其定义之前就已经可见了。
- en: '![](05fig13.jpg)'
  id: totrans-919
  prefs: []
  type: TYPE_IMG
  zh: '![](05fig13.jpg)'
- en: The process of registering identifiers
  id: totrans-920
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注册标识符的过程
- en: But ease of use aside, if code is executed line by line, how did the JavaScript
    engine know that a function named `check` exists? It turns out that the JavaScript
    engine “cheats” a little, and that execution of JavaScript code occurs in two
    phases.
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 但除了易用性之外，如果代码是逐行执行的，JavaScript 引擎是如何知道存在一个名为 `check` 的函数的呢？实际上，JavaScript 引擎“作弊”了一点点，JavaScript
    代码的执行发生在两个阶段。
- en: The first phase is activated whenever a new lexical environment is created.
    In this phase, the code isn’t executed, but the JavaScript engine visits and registers
    all declared variables and functions within the current lexical environment. The
    second phase, JavaScript execution, starts after this has been accomplished; the
    exact behavior depends on the type of variable (`let`, `var`, `const`, function
    declaration) and the type of environment (global, function, or block).
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 每当创建一个新的词法环境时，都会激活第一阶段。在这个阶段，代码不会执行，但 JavaScript 引擎会访问并注册当前词法环境内声明的所有变量和函数。第二阶段，JavaScript
    执行，在完成这一阶段后开始；具体行为取决于变量的类型（`let`、`var`、`const`、函数声明）和环境的类型（全局、函数或块）。
- en: 'The process is as follows:'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程如下：
- en: If we’re creating a function environment, the implicit `arguments` identifier
    is created, along with all formal function parameters and their argument values.
    If we’re dealing with a nonfunction environment, this step is skipped.
  id: totrans-924
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们正在创建一个函数环境，就会创建隐式的 `arguments` 标识符，以及所有形式参数及其参数值。如果我们处理的是一个非函数环境，这一步就会被跳过。
- en: If we’re creating a global or a function environment, the current code is scanned
    (without going into the body of other functions) for function declarations (but
    not function expressions or arrow functions!). For each discovered function declaration,
    a new function is created and bound to an identifier in the environment with the
    function’s name. If that identifier name already exists, its value is overwritten.
    If we’re dealing with block environments, this step is skipped.
  id: totrans-925
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们正在创建一个全局或函数环境，当前代码会被扫描（但不进入其他函数的主体）以查找函数声明（但不包括函数表达式或箭头函数！）。对于每个发现的函数声明，都会创建一个新的函数并将其绑定到环境中具有该函数名称的标识符。如果该标识符名称已经存在，其值将被覆盖。如果我们处理的是块环境，这一步会被跳过。
- en: The current code is scanned for variable declarations. In function and global
    environments, all variables declared with the keyword `var` and defined outside
    other functions (but they can be placed within blocks!) are found, and all variables
    declared with the keywords `let` and `const` defined outside other functions and
    blocks are found. In block environments, the code is scanned only for variables
    declared with the keywords `let` and `const`, directly in the current block. For
    each discovered variable, if the identifier doesn’t exist in the environment,
    the identifier is registered and its value initialized to `undefined`. But if
    the identifier exists, it’s left with its value.
  id: totrans-926
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当前代码会被扫描以查找变量声明。在函数和全局环境中，所有使用 `var` 关键字声明且在其他函数外部定义的变量（但它们可以放在块中！）都会被发现，以及所有使用
    `let` 和 `const` 关键字声明且在其他函数和块外部定义的变量都会被发现。在块环境中，代码只会扫描使用 `let` 和 `const` 关键字直接在当前块中声明的变量。对于每个发现的变量，如果标识符在环境中不存在，则注册该标识符并将其值初始化为
    `undefined`。但如果标识符存在，则保留其值。
- en: These steps are summarized in [figure 5.14](#ch05fig14).
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤总结在图 5.14 中。
- en: Figure 5.14\. The process of registering identifiers, depending on the type
    of environment
  id: totrans-928
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.14\. 根据环境类型注册标识符的过程
- en: '![](05fig14_alt.jpg)'
  id: totrans-929
  prefs: []
  type: TYPE_IMG
  zh: '![](05fig14_alt.jpg)'
- en: Now we’ll go through the implications of these rules. You’ll see some common
    JavaScript conundrums that can lead to weird bugs that are easy to create but
    tricky to understand. Let’s start with why we’re able to call a function before
    it’s even declared.
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将探讨这些规则的含义。您将看到一些常见的JavaScript难题，这些问题可能导致奇怪的错误，这些错误容易创建但难以理解。让我们从为什么我们能够在函数声明之前调用函数的原因开始。
- en: Calling functions before their declarations
  id: totrans-931
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在函数声明之前调用函数
- en: One of the features that makes JavaScript pleasant to use is that the order
    of function definitions doesn’t matter. Those who have used Pascal may not remember
    its rigid structural requirements fondly. In JavaScript, we can call a function
    even before it’s formally declared. Check out the following listing.
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 使JavaScript易于使用的一个特性是函数定义的顺序并不重要。那些使用过Pascal的人可能不会对它的严格结构要求有很好的回忆。在JavaScript中，我们甚至可以在正式声明函数之前就调用它。查看以下列表。
- en: Listing 5.9\. Accessing a function before its declaration
  id: totrans-933
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.9\. 在函数声明之前访问函数
- en: '![](115fig01_alt.jpg)'
  id: totrans-934
  prefs: []
  type: TYPE_IMG
  zh: '![](115fig01_alt.jpg)'
- en: We can access the function `fun` even before we’ve defined it. We can do this
    because `fun` is defined as a function declaration, and the second step (listed
    previously in this section) indicates that functions created with function declarations
    are created and their identifiers registered when the current lexical environment
    is created, *before* any JavaScript code is executed. So even before we start
    executing our `assert` call, the `fun` function already exists.
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以在定义函数`fun`之前就访问它。我们可以这样做，因为`fun`被定义为函数声明，而本节之前列出的第二步表明，使用函数声明创建的函数在当前词法环境创建时就已经创建并注册了标识符，*在*任何JavaScript代码执行之前。所以，在我们开始执行我们的`assert`调用之前，`fun`函数已经存在了。
- en: The JavaScript engine does this to make things easier for us as developers,
    allowing us to forward-reference functions and not burdening us with an exact
    order for placing functions. Functions already exist at the time our code starts
    executing.
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript引擎这样做是为了让我们作为开发者更容易，允许我们向前引用函数，而不必为我们放置函数的顺序施加精确的要求。函数在我们代码开始执行时就已经存在了。
- en: Notice that this holds only for function declarations. Function expressions
    and arrow functions aren’t part of this process, and are created when the program
    execution reaches their definitions. This is why we can’t access the `myFunExp`
    and `myArrow` functions.
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这仅适用于函数声明。函数表达式和箭头函数不是这个过程的一部分，而是在程序执行到达它们的定义时创建的。这就是为什么我们无法访问`myFunExp`和`myArrow`函数。
- en: Overriding functions
  id: totrans-938
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 覆盖函数
- en: The next conundrum to tackle is the problem of overriding function identifiers.
    Let’s take a look at another example.
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要解决的问题是如何覆盖函数标识符的问题。让我们看看另一个例子。
- en: Listing 5.10\. Overriding function identifiers
  id: totrans-940
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.10\. 覆盖函数标识符
- en: '![](116fig01_alt.jpg)'
  id: totrans-941
  prefs: []
  type: TYPE_IMG
  zh: '![](116fig01_alt.jpg)'
- en: 'In this example, a variable declaration and a function declaration have the
    same name: `fun`. If you run this code, you’ll see that both `assert`s pass. In
    the first `assert`, the identifier `fun` refers to a function; and in the second
    and third, `fun` refers to a number.'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，一个变量声明和一个函数声明有相同的名字：`fun`。如果您运行这段代码，您会看到两个`assert`都通过了。在第一个`assert`中，标识符`fun`指的是一个函数；而在第二个和第三个中，`fun`指的是一个数字。
- en: This behavior follows as a direct consequence of the steps taken when registering
    identifiers. In the second step of the outlined process, functions defined with
    function declarations are created and associated to their identifiers before any
    code is evaluated; and in the third step, variable declarations are processed,
    and the value `undefined` is associated to identifiers that haven’t yet been encountered
    in the current environment.
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为是直接后果于注册标识符时采取的步骤。在概述的过程的第二步中，使用函数声明定义的函数在评估任何代码之前就已经创建并与其标识符关联；在第三步中，处理变量声明，并将值`undefined`与当前环境中尚未遇到的标识符关联。
- en: In this case, because the identifier `fun` has been encountered in the second
    step when function declarations are registered, the value `undefined` isn’t assigned
    to the variable `fun`. This is why the first assertion, testing whether `fun`
    is a function, passes. After that, we have an assignment statement, `var fun =
    3`, which assigns the number 3 to the identifier `fun`. By doing this, we lose
    the reference to the function, and from then on, the identifier `fun` refers to
    a number.
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，因为标识符 `fun` 在函数声明注册的第二步中被遇到，所以没有将值 `undefined` 分配给变量 `fun`。这就是为什么第一个断言，测试
    `fun` 是否是函数，通过的原因。之后，我们有一个赋值语句，`var fun = 3`，它将数字 3 分配给标识符 `fun`。通过这样做，我们失去了对函数的引用，从那时起，标识符
    `fun` 指的是一个数字。
- en: During the actual program execution, function declarations are skipped, so the
    definition of the `fun` function doesn’t have any impact on the value of the `fun`
    identifier.
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际程序执行过程中，函数声明会被跳过，所以 `fun` 函数的定义对 `fun` 标识符的值没有任何影响。
- en: '|  |'
  id: totrans-946
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Variable hoisting**'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: '**变量提升**'
- en: If you’ve read a bunch of JavaScript blogs or books explaining identifier resolution,
    you’ve probably run into the term *hoisting*—for example, variable and function
    declarations are hoisted, or *lifted,* to the top of a function or global scope.
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你阅读了许多解释标识符解析的 JavaScript 博客或书籍，你可能已经遇到过术语 *提升*——例如，变量和函数声明会被提升，或者 *提升* 到函数或全局作用域的顶部。
- en: As you’ve seen, though, that’s a simplistic view. Variables and function declarations
    are technically not “moved” anywhere. They’re visited and registered in lexical
    environments before any code is executed. Although *hoisting,* as it’s most often
    defined, is enough to provide a basic understanding of how JavaScript scoping
    works, we’ve gone much deeper than that by looking at lexical environments, taking
    another step on the path of becoming a true JavaScript ninja.
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如你所见，这是一个过于简化的观点。变量和函数声明在技术上并不是“移动”到任何地方。在执行任何代码之前，它们在词法环境中被访问和注册。尽管 *提升*，正如它通常定义的那样，足以提供对
    JavaScript 作用域工作方式的基本理解，但我们通过查看词法环境，在成为真正的 JavaScript 大师的路上又迈出了新的一步。
- en: '|  |'
  id: totrans-950
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In the next section, all the concepts that we’ve explored so far in this chapter
    will help you better understand closures.
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨本章到目前为止所探讨的所有概念，这将帮助你更好地理解闭包。
- en: 5.6\. Exploring how closures work
  id: totrans-952
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.6\. 探索闭包的工作方式
- en: We started this chapter with closures, a mechanism that allows a function to
    access all variables that are in scope when the function itself is created. You’ve
    also seen some of the ways closures can help you—for example, by allowing us to
    mimic private object variables or by making our code more elegant when dealing
    with callbacks.
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从闭包开始本章，这是一种机制，允许函数在函数本身创建时访问所有作用域内的变量。你也看到了闭包如何帮助你的一些方式——例如，通过允许我们模拟私有对象变量或在我们处理回调时使我们的代码更加优雅。
- en: Closures are irrevocably tightly coupled with scopes. Closures are a straightforward
    side effect of the way scoping rules work in JavaScript. So in this section, we’ll
    revisit the closure examples from the beginning of the chapter. But this time
    you’ll take advantage of execution contexts and lexical environments that will
    enable you to grasp how closures work under the hood.
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包与作用域不可逆转地紧密耦合。闭包是 JavaScript 中作用域规则工作方式的直接副作用。因此，在本节中，我们将重新审视本章开头的闭包示例。但这次，你将利用执行上下文和词法环境，这将使你能够理解闭包在底层是如何工作的。
- en: 5.6.1\. Revisiting mimicking private variables with closures
  id: totrans-955
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.6.1\. 重新探讨使用闭包模拟私有变量
- en: As you’ve already seen, closures can help us mimic private variables. Now that
    we have a solid understanding of how scoping rules work in JavaScript, let’s revisit
    the private variables example. This time, we’ll focus on execution contexts and
    lexical environments. Just to make things easier, let’s repeat the listing.
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你之前已经看到的，闭包可以帮助我们模拟私有变量。现在，我们已经对 JavaScript 中作用域规则的工作方式有了坚实的理解，让我们重新审视私有变量示例。这次，我们将专注于执行上下文和词法环境。为了使事情更容易理解，让我们重复一下列表。
- en: Listing 5.11\. Approximate private variables with closures
  id: totrans-957
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.11\. 使用闭包近似私有变量
- en: '![](ch05ex11-0.jpg)'
  id: totrans-958
  prefs: []
  type: TYPE_IMG
  zh: '![](ch05ex11-0.jpg)'
- en: '![](ch05ex11-1.jpg)'
  id: totrans-959
  prefs: []
  type: TYPE_IMG
  zh: '![](ch05ex11-1.jpg)'
- en: Now we’ll analyze the state of the application after the first `Ninja` object
    has been created, as shown in [figure 5.15](#ch05fig15). We can use our knowledge
    of the intricacies of identifier resolution to better understand how closures
    come into play in this situation. JavaScript constructors are functions invoked
    with the keyword `new`. Therefore, *every* time we invoke a constructor function,
    we create a *new* lexical environment, which keeps track of variables local to
    the constructor. In this example, a new `Ninja` environment that keeps track of
    the `feints` variable is created.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将分析在创建第一个 `Ninja` 对象之后应用程序的状态，如图 5.15 所示。我们可以利用我们对标识符解析复杂性的了解，更好地理解在这种情况下闭包是如何起作用的。JavaScript
    构造函数是使用 `new` 关键字调用的函数。因此，每次我们调用构造函数时，我们都会创建一个新的词法环境，该环境跟踪构造函数的局部变量。在这个例子中，创建了一个新的
    `Ninja` 环境来跟踪 `feints` 变量。
- en: Figure 5.15\. Private variables are realized as closures that are created by
    object methods defined in the constructor.
  id: totrans-961
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.15\. 私有变量作为由构造函数中定义的对象方法创建的闭包来实现。
- en: '![](05fig15_alt.jpg)'
  id: totrans-962
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.15 代替](05fig15_alt.jpg)'
- en: 'In addition, whenever a function is created, it keeps a reference to the lexical
    environment in which it was created (through an internal `[[Environment]]` property).
    In this case, within the `Ninja` constructor function, we create two new functions:
    `getFeints` and `feint`, which get a reference to the `Ninja` environment, because
    this is the environment in which they were created.'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，每当创建一个函数时，它会保留对其创建时的词法环境的引用（通过内部的 `[[Environment]]` 属性）。在这种情况下，在 `Ninja`
    构造函数函数内部，我们创建了两个新的函数：`getFeints` 和 `feint`，它们获取对 `Ninja` 环境的引用，因为这是它们被创建的环境。
- en: The `getFeints` and `feint` functions are assigned as methods of the newly created
    `ninja` object (which, if you remember from the previous chapter, is accessible
    through the `this` keyword). Therefore, `getFeints` and `feint` will be accessible
    from outside the `Ninja` constructor function, which in turn leads to the fact
    that you’ve effectively created a closure around the `feints` variable.
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: '`getFeints` 和 `feint` 函数被分配为新创建的 `ninja` 对象的方法（如果你还记得上一章，可以通过 `this` 关键字访问）。因此，`getFeints`
    和 `feint` 将可以从 `Ninja` 构造函数函数外部访问，这又导致你实际上创建了一个围绕 `feints` 变量的闭包。'
- en: When we create another `Ninja` object, the `ninja2` object, the whole process
    is repeated. [Figure 5.16](#ch05fig16) shows the state of the application after
    creating the second `Ninja` object.
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建另一个 `Ninja` 对象，即 `ninja2` 对象时，整个过程会重复。图 5.16 展示了创建第二个 `Ninja` 对象后应用程序的状态。
- en: Figure 5.16\. The methods of each instance create closures around the “private”
    instance variables.
  id: totrans-966
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.16\. 每个实例的方法围绕“私有”实例变量创建闭包。
- en: '![](05fig16_alt.jpg)'
  id: totrans-967
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.16 代替](05fig16_alt.jpg)'
- en: Every object created with the `Ninja` constructor gets its own methods (the
    `ninja1.getFeints` method is different from the `ninja2.getFeints` method) that
    close around the variables defined when the constructor was invoked. These “private”
    variables are accessible only through object methods created within the constructor,
    and not directly!
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Ninja` 构造函数创建的每个对象都获得自己的方法（`ninja1.getFeints` 方法与 `ninja2.getFeints` 方法不同），这些方法围绕在构造函数调用时定义的变量周围。这些“私有”变量只能通过在构造函数内创建的对象方法访问，而不能直接访问！
- en: Now let’s see how things play out when making the `ninja2.getFeints()` call.
    [Figure 5.17](#ch05fig17) shows the details.
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下在调用 `ninja2.getFeints()` 时会发生什么。[图 5.17](#ch05fig17) 展示了详细信息。
- en: Figure 5.17\. The state of execution contexts and lexical environments when
    performing the `ninja2.getFeints()` call. A new `getFeints` environment is created
    that has the environment of the constructor function in which `ninja2` was created
    as its outer environment. `getFeints` can access the “private” `feints` variable.
  id: totrans-970
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.17\. 执行上下文和词法环境在执行 `ninja2.getFeints()` 调用时的状态。创建了一个新的 `getFeints` 环境作为其外部环境，该环境是
    `ninja2` 被创建的构造函数函数的环境。`getFeints` 可以访问“私有”的 `feints` 变量。
- en: '![](05fig17_alt.jpg)'
  id: totrans-971
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.17 代替](05fig17_alt.jpg)'
- en: Before making the `ninja2.getFeints()` call, our JavaScript engine is executing
    global code. Our program execution is in the global execution context, which is
    also the only context in the execution stack. At the same time, the only active
    lexical environment is the global environment, the environment associated with
    the global execution context.
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 `ninja2.getFeints()` 之前，我们的 JavaScript 引擎正在执行全局代码。我们的程序执行处于全局执行上下文中，这也是执行栈中的唯一上下文。同时，唯一的活跃词法环境是全局环境，与全局执行上下文相关联的环境。
- en: When making the `ninja2.getFeints()` call, we’re calling the `getFeints` method
    of the `ninja2` object. Because every function call causes the creation of a new
    execution context, a new `getFeints` execution context is created and pushed to
    the execution stack. This also leads to the creation of a new `getFeints` lexical
    environment, which is normally used to keep track of variables defined in this
    function. In addition, the `getFeints` lexical environment, as its outer environment,
    gets the environment in which the `getFeints` function was created, the `Ninja`
    environment that was active when the `ninja2` object was constructed.
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `ninja2.getFeints()` 时，我们正在调用 `ninja2` 对象的 `getFeints` 方法。因为每次函数调用都会导致创建一个新的执行上下文，所以会创建一个新的
    `getFeints` 执行上下文并将其推入执行栈。这也导致了新的 `getFeints` 词法环境的创建，这通常用于跟踪在此函数中定义的变量。此外，`getFeints`
    词法环境，作为其外部环境，获取了 `getFeints` 函数被创建时的环境，即当 `ninja2` 对象被构建时活动的 `Ninja` 环境。
- en: Now let’s see how things play out when we try to get the value of the `feints`
    variable. First, the currently active `getFeints` lexical environment is consulted.
    Because we haven’t defined any variables in the `getFeints` function, this lexical
    environment is empty and our targeted `feints` variable won’t be found in there.
    Next, the search continues in the *outer* environment of the current lexical environment—in
    our case, the `Ninja` environment is active when constructing the `ninja2` object.
    This time around, the `Ninja` environment has a reference to the `feints` variable,
    and the search is done. It’s as simple as that.
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看当我们尝试获取 `feints` 变量的值时会发生什么。首先，查询当前活动的 `getFeints` 词法环境。因为我们没有在 `getFeints`
    函数中定义任何变量，所以这个词法环境是空的，我们的目标 `feints` 变量不会在那里找到。接下来，搜索继续在当前词法环境的 *外部* 环境——在我们的例子中，当构建
    `ninja2` 对象时，`Ninja` 环境是活动的。这一次，`Ninja` 环境有一个对 `feints` 变量的引用，搜索完成。就这么简单。
- en: Now that we understand the role that execution contexts and lexical environments
    play when dealing with closures, we’d like to turn our attention to “private”
    variables and why we keep putting quotes around them. As you might have figured
    out by now, these “private” variables aren’t private properties of the object,
    but are variables kept alive by the object methods created in the constructor.
    Let’s take a look at one interesting side effect of this.
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了在处理闭包时执行上下文和词法环境所起的作用，我们想将注意力转向“私有”变量以及为什么我们总是将引号放在它们周围。正如你可能现在已经猜到的，这些“私有”变量不是对象的私有属性，而是由构造函数中创建的对象方法保持活跃的变量。让我们看看这个的一个有趣的副作用。
- en: 5.6.2\. Private variables caveat
  id: totrans-976
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.6.2\. 私有变量注意事项
- en: In JavaScript, there’s nothing stopping us from assigning properties created
    on one object to another object. For example, we can easily rewrite the code from
    [listing 5.11](#ch05ex11) into something like the following.
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，没有任何阻止我们将一个对象上创建的属性赋值给另一个对象。例如，我们可以轻松地将 [列表 5.11](#ch05ex11)
    中的代码重写为以下类似的形式。
- en: Listing 5.12\. Private variables are accessed through functions, not through
    objects!
  id: totrans-978
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.12\. 通过函数访问私有变量，而不是通过对象！
- en: '![](121fig01_alt.jpg)'
  id: totrans-979
  prefs: []
  type: TYPE_IMG
  zh: '![](121fig01_alt.jpg)'
- en: This listing modifies the source code in a way that it assigns the `ninja1.getFeints`
    method to a completely new `imposter` object. Then, when we call the `getFeints`
    function on the `imposter` object, we test that we can access the value of the
    variable `feints` created when `ninja1` was instantiated, thus proving that we’re
    faking this whole “private” variable thing. See [figure 5.18](#ch05fig18).
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表以修改源代码的方式，将 `ninja1.getFeints` 方法赋值给一个全新的 `imposter` 对象。然后，当我们对 `imposter`
    对象调用 `getFeints` 函数时，我们测试我们是否可以访问在 `ninja1` 实例化时创建的变量 `feints` 的值，从而证明我们是在伪造整个“私有”变量的事情。参见
    [图 5.18](#ch05fig18)。
- en: Figure 5.18\. We can access the “private” variables through functions, even
    if that function is attached to another object!
  id: totrans-981
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.18\. 我们可以通过函数访问“私有”变量，即使该函数附加到另一个对象上！
- en: '![](05fig18.jpg)'
  id: totrans-982
  prefs: []
  type: TYPE_IMG
  zh: '![](05fig18.jpg)'
- en: This example illustrates that there aren’t any private object variables in JavaScript,
    but that we can use closures created by object methods to have a “good enough”
    alternative. Still, even though it isn’t the real thing, lots of developers find
    this way of hiding information useful.
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子说明在 JavaScript 中没有私有对象变量，但我们可以使用由对象方法创建的闭包来有一个“足够好”的替代方案。尽管这不是真正的解决方案，但许多开发者发现这种隐藏信息的方式很有用。
- en: 5.6.3\. Revisiting the closures and callbacks example
  id: totrans-984
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.6.3\. 重新审视闭包和回调示例
- en: Let’s go back to our simple animations example with callback timers. This time,
    we’ll animate two objects, as shown in the following listing.
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的简单动画示例，这次我们将使用回调计时器来动画化两个对象，如下列所示。
- en: Listing 5.13\. Using a closure in a timer interval callback
  id: totrans-986
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.13\. 在计时器间隔回调中使用闭包
- en: '[PRE96]'
  id: totrans-987
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: As you saw earlier in the chapter, we use closures to simplify animating multiple
    objects on our pages. But now we’ll consider lexical environments, as shown in
    [figure 5.19](#ch05fig19).
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在本章前面所见，我们使用闭包来简化在页面上对多个对象的动画处理。但现在我们将考虑词法环境，如图 5.19 所示。
- en: Figure 5.19\. By creating multiple closures, we can do many things at once.
    Every time an interval expires, the callback function reactivates the environment
    that was active at the time of callback creation. The closure of each callback
    automatically keeps track of its own set of variables.
  id: totrans-989
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.19\. 通过创建多个闭包，我们可以同时做很多事情。每当间隔到期时，回调函数会重新激活回调创建时活跃的环境。每个回调的闭包会自动跟踪其自己的变量集。
- en: '![](05fig19_alt.jpg)'
  id: totrans-990
  prefs: []
  type: TYPE_IMG
  zh: '![](05fig19_alt.jpg)'
- en: Every time we call the `animateIt` function, a new function lexical environment
    is created ![](num-01.jpg) ![](num-02.jpg) that keeps track of the set of variables
    important for that animation (the `elementId`; `elem`, the element that’s being
    animated; `tick`, the current number of ticks; and `timer`, the ID of the timer
    doing the animation). That environment will be kept alive as long as there’s at
    least one function that works with its variables through closures. In this case,
    the browser will keep alive the `setInterval` callback until we call the `clearInterval`
    function. Later, when an interval expires, the browser calls the matching callback—and
    with it, through closures, come the variables defined when the callback was created.
    This enables us to avoid the trouble of manually mapping the callback and the
    active variables ![](num-03.jpg) ![](num-04.jpg) ![](num-05.jpg), thereby significantly
    simplifying our code.
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们调用 `animateIt` 函数时，都会创建一个新的函数词法环境 ![](num-01.jpg) ![](num-02.jpg)，该环境会跟踪对动画重要的变量集（`elementId`；`elem`，正在被动画化的元素；`tick`，当前的
    tick 数；以及 `timer`，执行动画的计时器 ID）。只要至少有一个函数通过闭包与这些变量一起工作，这个环境就会保持活跃。在这种情况下，浏览器会保持
    `setInterval` 回调的活跃状态，直到我们调用 `clearInterval` 函数。稍后，当间隔到期时，浏览器会调用相应的回调——通过闭包，回调创建时定义的变量也随之而来。这使我们能够避免手动映射回调和活动变量
    ![](num-03.jpg) ![](num-04.jpg) ![](num-05.jpg) 的麻烦，从而显著简化我们的代码。
- en: That’s all we have to say about closures and scopes. Now recap this chapter
    and meet us in the next one, where we’ll explore two completely new ES6 concepts,
    generators and promises, that can help when writing asynchronous code.
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 关于闭包和作用域，我们就说这么多。现在回顾本章内容，我们将在下一章中探讨两个全新的 ES6 概念：生成器和承诺，这些概念可以帮助我们编写异步代码。
- en: 5.7\. Summary
  id: totrans-993
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.7\. 摘要
- en: Closures allow a function to access all variables that are in scope when the
    function itself was defined. They create a “safety bubble” of the function and
    the variables that are in scope at the point of the function’s definition. This
    way, the function has all it needs to execute, even if the scope in which the
    function was created is long gone.
  id: totrans-994
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闭包允许函数访问在函数定义时处于作用域内的所有变量。它们为函数及其定义点处的作用域内的变量创建一个“安全气泡”。这样，即使函数创建的作用域已经消失，函数仍然拥有执行所需的一切。
- en: 'We can use function closures for these advanced uses:'
  id: totrans-995
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用函数闭包来实现这些高级用法：
- en: Mimic private object variables, by closing over constructor variables through
    method closures
  id: totrans-996
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过方法闭包封装构造函数变量，模拟私有对象变量
- en: Deal with callbacks, in a way that significantly simplifies our code
  id: totrans-997
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理回调，从而显著简化我们的代码
- en: JavaScript engines track function execution through an execution context stack
    (or a call stack). Every time a function is called, a new function execution context
    is created and placed on the stack. When a function is done executing, the matching
    execution context is popped from the stack.
  id: totrans-998
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 引擎通过执行上下文栈（或俗称调用栈）来跟踪函数执行。每次函数被调用时，都会创建一个新的函数执行上下文并将其放置在栈上。当函数执行完毕时，对应的执行上下文将从栈中弹出。
- en: JavaScript engines track identifiers with lexical environments (or colloquially,
    scopes).
  id: totrans-999
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 引擎使用词法环境（或俗称作用域）来跟踪标识符。
- en: In JavaScript, we can define globally-scoped, function-scoped, and even-block
    scoped variables.
  id: totrans-1000
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，我们可以定义全局作用域、函数作用域，甚至块作用域的变量。
- en: 'To define variables, we use `var`, `let`, and `const` keywords:'
  id: totrans-1001
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义变量时，我们使用 `var`、`let` 和 `const` 关键字：
- en: The `var` keyword defines a variable in the closest function or global scope
    (while ignoring blocks).
  id: totrans-1002
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`var` 关键字在最近的函数或全局作用域中定义变量（同时忽略块）。'
- en: '`let` and `const` keywords define a variable in the closest scope (including
    blocks), allowing us to create block-scoped variables, something that wasn’t possible
    in pre-ES6 JavaScript. In addition, the keyword `const` allows us to define “variables”
    whose value can be assigned only once.'
  id: totrans-1003
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`let` 和 `const` 关键字定义了最接近的作用域（包括块）中的变量，使我们能够创建块级作用域变量，这在 ES6 之前的 JavaScript
    中是不可能的。此外，关键字 `const` 允许我们定义“变量”，其值只能被赋值一次。'
- en: Closures are merely a side effect of JavaScript scoping rules. A function can
    be called even when the scope in which it was created is long gone.
  id: totrans-1004
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闭包仅仅是 JavaScript 作用域规则的副作用。一个函数可以在它被创建的作用域已经消失很久之后被调用。
- en: 5.8\. Exercises
  id: totrans-1005
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.8\. 练习
- en: '**1**'
  id: totrans-1006
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**'
- en: ''
  id: totrans-1007
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Closures allow functions to
  id: totrans-1008
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 闭包允许函数
- en: ''
  id: totrans-1009
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Access external variables that are in scope when the function is defined
  id: totrans-1010
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数定义时访问作用域内的外部变量
- en: Access external variables that are in scope when the function is called
  id: totrans-1011
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数被调用时访问作用域内的外部变量
- en: '**2**'
  id: totrans-1012
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**'
- en: ''
  id: totrans-1013
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Closures come with
  id: totrans-1014
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 闭包附带
- en: ''
  id: totrans-1015
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Code-size costs
  id: totrans-1016
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码大小成本
- en: Memory costs
  id: totrans-1017
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内存成本
- en: Processing costs
  id: totrans-1018
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理成本
- en: '**3**'
  id: totrans-1019
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**'
- en: ''
  id: totrans-1020
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In the following code example, mark the identifiers accessed through closures:'
  id: totrans-1021
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在以下代码示例中，标记通过闭包访问的标识符：
- en: ''
  id: totrans-1022
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-1023
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '**4**'
  id: totrans-1024
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**'
- en: ''
  id: totrans-1025
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the following code, how many execution contexts are created, and what’s the
    largest size of the execution context stack?
  id: totrans-1026
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在以下代码中，创建了多少执行上下文，以及执行上下文栈的最大大小是多少？
- en: ''
  id: totrans-1027
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-1028
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '**5**'
  id: totrans-1029
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**5**'
- en: ''
  id: totrans-1030
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which keyword in JavaScript allows us to define variables that can’t be reassigned
    to a completely new value?
  id: totrans-1031
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，哪个关键字允许我们定义不能重新赋值为完全新值的变量？
- en: '**6**'
  id: totrans-1032
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**6**'
- en: ''
  id: totrans-1033
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What’s the difference between `var` and `let`?
  id: totrans-1034
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`var` 和 `let` 之间的区别是什么？'
- en: '**7**'
  id: totrans-1035
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**7**'
- en: ''
  id: totrans-1036
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Where and why will the following code throw an exception?
  id: totrans-1037
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码将在哪里和为什么抛出异常？
- en: ''
  id: totrans-1038
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-1039
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Chapter 6\. Functions for the future: generators and promises'
  id: totrans-1040
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第6章\. 未来函数：生成器和承诺
- en: '*This chapter covers*'
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Continuing function execution with generators
  id: totrans-1042
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用生成器继续函数执行
- en: Handling asynchronous tasks with promises
  id: totrans-1043
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用承诺处理异步任务
- en: Achieving elegant asynchronous code by combining generators and promises
  id: totrans-1044
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过结合生成器和承诺实现优雅的异步代码
- en: In the previous three chapters, we focused on functions, specifically on how
    to define functions and how to use them to great effect. Although we’ve introduced
    some ES6 features, such as arrow functions and block scopes, we’ve mostly been
    exploring features that have been part of JavaScript for quite some time. This
    chapter tackles the cutting edge of ES6 by presenting *generators* and *promises*,
    two completely new JavaScript features.
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: 在前三个章节中，我们专注于函数，特别是如何定义函数以及如何有效地使用它们。尽管我们介绍了一些 ES6 特性，如箭头函数和块级作用域，但我们主要是在探索
    JavaScript 已经存在了一段时间的特性。本章通过介绍 *生成器* 和 *承诺*，即两个全新的 JavaScript 特性，来处理 ES6 的前沿技术。
- en: '|  |'
  id: totrans-1046
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-1047
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Generators and promises are both introduced by ES6\. You can check out current
    browser support at [http://mng.bz/sOs4](http://mng.bz/sOs4) and [http://mng.bz/Du38](http://mng.bz/Du38).
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器和承诺都是由 ES6 引入的。你可以查看当前浏览器的支持情况，请访问 [http://mng.bz/sOs4](http://mng.bz/sOs4)
    和 [http://mng.bz/Du38](http://mng.bz/Du38)。
- en: '|  |'
  id: totrans-1049
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '*Generators* are a special type of function. Whereas a standard function produces
    at most a single value while running its code from start to finish, generators
    produce multiple values, on a per request basis, while suspending their execution
    between these requests. Although new in JavaScript, generators have existed for
    quite some time in Python, PHP, and C#.'
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: '*生成器* 是一种特殊类型的函数。与标准函数在从头到尾运行其代码时最多产生一个值不同，生成器在每次请求的基础上产生多个值，在请求之间暂停其执行。尽管在
    JavaScript 中是新的，但生成器在 Python、PHP 和 C# 中已经存在了一段时间。'
- en: Generators are often considered an almost weird or fringe language feature not
    often used by the average programmer. Though most of this chapter’s examples are
    designed to teach you how generator functions work, we’ll also explore some practical
    aspects of generators. You’ll see how to use generators to simplify convoluted
    loops and how to take advantage of generators’ capability to suspend and resume
    their execution, which can help you write simpler and more elegant asynchronous
    code.
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器通常被认为是一种几乎怪异或边缘语言特性，普通程序员很少使用。尽管本章的大部分示例都是为了教你如何使用生成器函数，我们也会探讨一些生成器的实际应用。你会看到如何使用生成器简化复杂的循环，以及如何利用生成器暂停和恢复执行的能力，这可以帮助你编写更简单、更优雅的异步代码。
- en: '*Promises*, on the other hand, are a new, built-in type of object that help
    you work with asynchronous code. A promise is a placeholder for a value that we
    don’t have yet but will at some later point. They’re especially good for working
    with multiple asynchronous steps.'
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，*承诺*是一种新的内置对象类型，可以帮助你处理异步代码。承诺是一个占位符，代表我们目前还没有但将在某个未来的点拥有的值。它们特别适合处理多个异步步骤。
- en: In this chapter, you’ll see how both generators and promises work, and we’ll
    finish off by exploring how to combine them to greatly simplify our dealings with
    asynchronous code. But before going into the specifics, let’s take a sneak peek
    into how much more elegant our asynchronous code can be.
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解生成器和承诺是如何工作的，然后我们将通过探索如何将它们结合起来，极大地简化我们对异步代码的处理。但在深入具体细节之前，让我们先窥视一下我们的异步代码可以多么优雅。
- en: Do you know?
  id: totrans-1054
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你知道吗？
- en: '**Q1:**'
  id: totrans-1055
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Q1:**'
- en: ''
  id: totrans-1056
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What are some common uses for a generator function?
  id: totrans-1057
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 生成器函数有哪些常见的用途？
- en: '**Q2:**'
  id: totrans-1058
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Q2:**'
- en: ''
  id: totrans-1059
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why are promises better than simple callbacks for asynchronous code?
  id: totrans-1060
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么承诺对于异步代码来说比简单的回调更好？
- en: '**Q3:**'
  id: totrans-1061
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Q3:**'
- en: ''
  id: totrans-1062
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You start a number of long-running tasks with Promise.race. When does the promise
    resolve? When would it fail to resolve?
  id: totrans-1063
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你使用 `Promise.race` 开始一系列长时间运行的任务。承诺何时解决？它何时会失败而无法解决？
- en: 6.1\. Making our async code elegant with generators and promises
  id: totrans-1064
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1\. 使用生成器和承诺使我们的异步代码更优雅
- en: 'Imagine that you’re a developer working at [freelanceninja.com](http://freelanceninja.com),
    a popular freelance ninja recruitment site enabling customers to hire ninjas for
    stealth missions. Your task is to implement a functionality that lets users get
    details about the highest-rated mission done by the most popular ninja. The data
    representing the ninjas, the summaries of their missions, as well as the details
    of the missions are stored on a remote server, encoded in JSON. You might write
    something like this:'
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你是一名在 [freelanceninja.com](http://freelanceninja.com) 工作的开发商，这是一个流行的自由职业者忍者招聘网站，它使客户能够雇佣忍者执行秘密任务。你的任务是实现一个功能，让用户能够获取由最受欢迎的忍者完成的最高评分任务的详细信息。代表忍者的数据、他们任务的摘要以及任务详情都存储在一个远程服务器上，编码为
    JSON。你可能编写如下代码：
- en: '[PRE100]'
  id: totrans-1066
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'This code is relatively easy to understand, and if an error occurs in any of
    the steps, we can easily catch it in the `catch` block. But unfortunately, this
    code has a big problem. Getting data from a server is a long-running operation,
    and because JavaScript relies on a single-threaded execution model, we’ve just
    blocked our UI until the long-running operations finish. This leads to unresponsive
    applications and disappointed users. To solve this problem, we can rewrite it
    with callbacks, which will be invoked when a task finishes, without blocking the
    UI:'
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码相对容易理解，如果在任何步骤中发生错误，我们可以在 `catch` 块中轻松捕获它。但不幸的是，这段代码有一个大问题。从服务器获取数据是一个长时间运行的操作，由于
    JavaScript 依赖于单线程执行模型，我们刚刚阻塞了我们的 UI，直到长时间运行的操作完成。这导致了无响应的应用程序和失望的用户。为了解决这个问题，我们可以用回调重写它，当任务完成时将调用回调，而不会阻塞
    UI：
- en: '[PRE101]'
  id: totrans-1068
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Although this code will be much better received by our users, you’ll probably
    agree that it’s messy, it adds a lot of boilerplate error-handling code, and it’s
    plain ugly. This is where generators and promises jump in. By combining them,
    we can turn the nonblocking but awkward callback code into something much more
    elegant:'
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这段代码可能会受到我们用户的更好欢迎，但你可能会同意，它很混乱，添加了大量的样板错误处理代码，而且看起来很丑陋。这就是生成器和承诺介入的地方。通过将它们结合起来，我们可以将非阻塞但笨拙的回调代码转变为更加优雅的代码：
- en: '![](128fig01_alt.jpg)'
  id: totrans-1070
  prefs: []
  type: TYPE_IMG
  zh: '![](128fig01_alt.jpg)'
- en: Don’t worry if this example doesn’t make much sense or if you find some of the
    syntax (such as `function*` or `yield`) unfamiliar. By the end of this chapter,
    you’ll meet all the necessary ingredients. For now, it’s enough that you compare
    the elegance (or the lack thereof) of the nonblocking callback code and the nonblocking
    generators and promises code.
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个例子让你感到困惑，或者你发现某些语法（例如 `function*` 或 `yield`）不熟悉，请不要担心。到本章结束时，你将遇到所有必要的元素。现在，只要你能比较非阻塞回调代码和非阻塞生成器和承诺代码的优雅性（或缺乏优雅性）就足够了。
- en: Let’s start slowly by exploring generator functions, the first stepping stone
    toward elegant asynchronous code.
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从探索生成器函数开始，这是通向优雅异步代码的第一块垫脚石。
- en: 6.2\. Working with generator functions
  id: totrans-1073
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2\. 使用生成器函数
- en: Generators are a completely new type of function and are significantly different
    from standard, run-of-the-mill functions. A *generator* is a function that generates
    a sequence of values, but not all at once, as a standard function would, but on
    a per request basis. We have to explicitly ask the generator for a new value,
    and the generator will either respond with a value or notify us that it has no
    more values to produce. What’s even more curious is that after a value is produced,
    a generator function doesn’t end its execution, as a normal function would. Instead,
    a generator is merely suspended. Then, when a request for another value comes
    along, the generator resumes where it left off.
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器是一种全新的函数类型，与标准、普通的函数有显著的不同。一个 *生成器* 是一个生成一系列值的函数，但不是一次性生成，就像标准函数那样，而是在每次请求的基础上生成。我们必须明确请求生成器提供一个新值，生成器将返回一个值或通知我们它没有更多的值可以生成。更令人好奇的是，在生成一个值之后，生成器函数不会像普通函数那样结束执行。相反，生成器只是被挂起。然后，当有另一个值的请求时，生成器从上次停止的地方继续执行。
- en: The following listing provides a simple example of using a generator to generate
    a sequence of weapons.
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表提供了一个使用生成器生成武器序列的简单示例。
- en: Listing 6.1\. Using a generator function to generate a sequence of values
  id: totrans-1076
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.1\. 使用生成器函数生成一系列值
- en: '![](129fig01_alt.jpg)'
  id: totrans-1077
  prefs: []
  type: TYPE_IMG
  zh: '![](129fig01_alt.jpg)'
- en: 'We start by defining a generator that will produce a sequence of weapons. Creating
    a generator function is simple: We append an asterisk (`*`) after the `function`
    keyword. This enables us to use the new `yield` keyword within the body of the
    generator to produce individual values. [Figure 6.1](#ch06fig01) illustrates the
    syntax.'
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一个生成器，它将生成一系列武器。创建生成器函数很简单：我们在 `function` 关键字后添加一个星号 (`*`)。这使得我们可以在生成器的主体中使用新的
    `yield` 关键字来生成单个值。[图 6.1](#ch06fig01) 说明了语法。
- en: Figure 6.1\. Add an asterisk (*) after the function keyword to define a generator.
  id: totrans-1079
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.1\. 在函数关键字后添加一个星号 (*) 来定义生成器。
- en: '![](06fig01.jpg)'
  id: totrans-1080
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig01.jpg)'
- en: 'In this example, we create a generator called `WeaponGenerator` that produces
    a sequence of weapons: `Katana`, `Wakizashi`, and `Kusarigama`. One way of consuming
    that sequence of weapons is by using a new kind of loop, the `for-of` loop:'
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个名为 `WeaponGenerator` 的生成器，它生成一系列武器：`Katana`、`Wakizashi` 和 `Kusarigama`。消费这些武器序列的一种方法是通过使用一种新的循环类型，即
    `for-of` 循环：
- en: '[PRE102]'
  id: totrans-1082
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: The result of invoking this `for-of` loop is shown in [figure 6.2](#ch06fig02).
    (For now, don’t worry much about the `for-of` loop, as we’ll explore it later.)
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: 调用此 `for-of` 循环的结果显示在[图 6.2](#ch06fig02)中。（目前，不必过分担心 `for-of` 循环，因为我们将在稍后探讨它。）
- en: Figure 6.2\. The result of iterating over our `WeaponGenerator()`
  id: totrans-1084
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.2\. 遍历我们的 `WeaponGenerator()` 的结果
- en: '![](06fig02.jpg)'
  id: totrans-1085
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig02.jpg)'
- en: On the right side of the `for-of` loop, we’ve placed the result of invoking
    our generator. But if you take a closer look at the body of the `WeaponGenerator`
    function, you’ll see that there’s no `return` statement. What’s up with that?
    In this case, shouldn’t the right side of the `for-of loop` evaluate to `undefined`,
    as would be the case if we were dealing with a standard function?
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `for-of` 循环的右侧，我们放置了调用我们的生成器的结果。但是，如果您仔细查看 `WeaponGenerator` 函数的主体，您会看到没有
    `return` 语句。这是怎么回事？在这种情况下，`for-of` 循环的右侧不应该评估为 `undefined` 吗？就像我们处理标准函数那样？
- en: The truth is that generators are quite unlike standard functions. For starters,
    calling a generator doesn’t execute the generator function; instead it creates
    an object called an *iterator*. Let’s explore that object.
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，生成器与标准函数相当不同。首先，调用生成器不会执行生成器函数；相反，它创建了一个名为 *迭代器* 的对象。让我们来探索这个对象。
- en: 6.2.1\. Controlling the generator through the iterator object
  id: totrans-1088
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.1\. 通过迭代器对象控制生成器
- en: Making a call to a generator doesn’t mean that the body of the generator function
    will be executed. Instead, an iterator object is created, an object through which
    we can communicate with the generator. For example, we can use the iterator to
    request additional values. Let’s adjust our previous example to explore how the
    iterator object works.
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: 调用生成器并不意味着生成器函数的主体将被执行。相反，创建了一个迭代器对象，通过这个对象我们可以与生成器进行通信。例如，我们可以使用迭代器请求额外的值。让我们调整之前的示例来探索迭代器对象的工作方式。
- en: Listing 6.2\. Controlling a generator through an iterator object
  id: totrans-1090
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.2\. 通过迭代器对象控制生成器
- en: '![](ch06ex02-0.jpg)'
  id: totrans-1091
  prefs: []
  type: TYPE_IMG
  zh: '![](ch06ex02-0.jpg)'
- en: '![](ch06ex02-1.jpg)'
  id: totrans-1092
  prefs: []
  type: TYPE_IMG
  zh: '![](ch06ex02-1.jpg)'
- en: 'As you can see, when we call a generator, a new *iterator* is created:'
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，当我们调用生成器时，会创建一个新的 *迭代器*：
- en: '[PRE103]'
  id: totrans-1094
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'The iterator is used to control the execution of the generator. One of the
    fundamental things that the iterator object exposes is the `next` method, which
    we can use to control the generator by requesting a value from it:'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器用于控制生成器的执行。迭代器对象公开的一个基本功能是`next`方法，我们可以用它通过请求值来控制生成器：
- en: '[PRE104]'
  id: totrans-1096
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: As a response to that call, the generator executes its code until it reaches
    a `yield` keyword that produces an intermediary result (one item in the generated
    sequence of items), and returns a *new* object that encapsulates that result and
    tells us whether its work is done.
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对那个调用的响应，生成器执行其代码直到它达到一个`yield`关键字，该关键字产生一个中间结果（生成项序列中的一个项），并返回一个*新*对象，该对象封装了该结果并告诉我们其工作是否完成。
- en: As soon as the current value is produced, the generator suspends its execution
    without blocking and patiently waits for another value request. This is an incredibly
    powerful feature that standard functions don’t have, a feature that we’ll use
    later to great effect.
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦产生当前值，生成器会暂停其执行而不会阻塞，并耐心地等待另一个值请求。这是一个非常强大的特性，标准函数没有这个特性，我们将在后面用它产生很好的效果。
- en: In this case, the first call to the iterator’s `next` method executes the generator
    code to the first `yield` expression, `yield "Katana"`, and returns an object
    with the property `value` set to `Katana` and the property `done` set to `false`,
    signaling that there are more values to produce.
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，迭代器`next`方法的第一次调用会执行生成器的代码，直到第一个`yield`表达式`yield "Katana"`，然后返回一个具有`value`属性设置为`Katana`和`done`属性设置为`false`的对象，表示还有更多值要生成。
- en: 'Later, we request another value from the generator, by making another call
    to the `weaponIterator`’s `next` method:'
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: 后来，我们通过再次调用`weaponIterator`的`next`方法从生成器请求另一个值：
- en: '[PRE105]'
  id: totrans-1101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'This wakes up the generator from suspension, and the generator continues where
    it left off, executing its code until another intermediary value is reached: `yield
    "Wakizashi"`. This suspends the generator and produces an object carrying `Wakizashi`.'
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: 这将唤醒生成器从暂停状态，生成器继续从上次停止的地方开始执行其代码，直到达到另一个中间值：`yield "Wakizashi"`。这会暂停生成器并产生一个携带`Wakizashi`的对象。
- en: Finally, when we call the `next` method for the third time, the generator resumes
    its execution. But this time there’s no more code to execute, so the generator
    returns an object with `value` set to `undefined`, and `done` set to `true`, signaling
    that it’s done with its work.
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当我们第三次调用`next`方法时，生成器继续执行。但这次没有更多的代码可以执行，所以生成器返回一个`value`设置为`undefined`和`done`设置为`true`的对象，表示它已经完成了其工作。
- en: Now that you’ve seen how to control generators through iterators, you’re ready
    to learn how to iterate over the produced values.
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了如何通过迭代器控制生成器，你就可以学习如何迭代产生的值了。
- en: Iterating the iterator
  id: totrans-1105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 迭代迭代器
- en: The iterator, created by calling a generator, exposes a `next` method through
    which we can request a new value from the generator. The `next` method returns
    an object that carries the value produced by the generator, as well as the information
    stored in the `done` property that tells us whether the generator has additional
    values to produce.
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用生成器创建的迭代器通过`next`方法公开，我们可以从中请求新的值。`next`方法返回一个包含生成器产生的值的对象，以及存储在`done`属性中的信息，该属性告诉我们生成器是否有更多的值要产生。
- en: Now we’ll take advantage of these facts to use a plain old `while` loop to iterate
    over values produced by a generator. See the following listing.
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将利用这些事实来使用普通的`while`循环迭代生成器产生的值。请看下面的列表。
- en: Listing 6.3\. Iterating over generator results with a while loop
  id: totrans-1108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.3\. 使用`while`循环迭代生成器结果
- en: '![](132fig01_alt.jpg)'
  id: totrans-1109
  prefs: []
  type: TYPE_IMG
  zh: '![](132fig01_alt.jpg)'
- en: 'Here we again create an iterator object by calling a generator function:'
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们再次通过调用生成器函数来创建一个迭代器对象：
- en: '[PRE106]'
  id: totrans-1111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'We also create an `item` variable in which we’ll store individual values produced
    by the generator. We continue by specifying a `while` loop with a slightly complicated
    looping condition, which we’ll break down a bit:'
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一个`item`变量，我们将用它来存储生成器产生的单个值。我们继续通过指定一个稍微复杂的循环条件来执行`while`循环，我们将稍作分解：
- en: '[PRE107]'
  id: totrans-1113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: On each loop iteration, we fetch a value from the generator by calling the `next`
    method of our `weaponsIterator`, and we store that value in the `item` variable.
    Like all such objects, the object referenced by the `item` variable has a `value`
    property that stores the value returned from the generator, and a `done` property
    that signals whether the generator is finished producing values. If the generator
    isn’t done with its work, we go into another iteration of the loop; and if it
    is, we stop looping.
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次循环迭代中，我们通过调用 `weaponsIterator` 的 `next` 方法从生成器中获取一个值，并将其存储在 `item` 变量中。像所有这样的对象一样，`item`
    变量引用的对象有一个 `value` 属性，用于存储生成器返回的值，以及一个 `done` 属性，用于指示生成器是否已完成值的生成。如果生成器还没有完成其工作，我们将进入循环的另一个迭代；如果它已经完成，我们将停止循环。
- en: 'And that’s how the `for-of` loop, from our first generator example, works.
    The `for-of` loop is syntactic sugar for iterating over iterators:'
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的第一个生成器示例中的 `for-of` 循环是如何工作的。`for-of` 循环是迭代器迭代的语法糖：
- en: '[PRE108]'
  id: totrans-1116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Instead of manually calling the `next` method of the matching iterator and always
    checking whether we’re finished, we can use the `for-of` loop to do the exact
    same thing, only behind the scenes.
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `for-of` 循环来完成手动调用匹配迭代器的 `next` 方法以及始终检查我们是否完成的工作，只是在幕后进行。
- en: Yielding to another generator
  id: totrans-1118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 委托给另一个生成器
- en: Just as we often call one standard function from another standard function,
    in certain cases we want to be able to delegate the execution of one generator
    to another. Let’s take a look at an example that generates both warriors and ninjas.
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们经常从一个标准函数调用另一个标准函数一样，在某些情况下，我们希望能够将一个生成器的执行委托给另一个生成器。让我们看看一个同时生成武士和忍者的例子。
- en: Listing 6.4\. Using yield* to delegate to another generator
  id: totrans-1120
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.4\. 使用 yield* 将任务委托给另一个生成器
- en: '![](133fig01_alt.jpg)'
  id: totrans-1121
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](133fig01_alt.jpg)'
- en: If you run this code, you’ll see that the output is `Sun Tzu`, `Hattori`, `Yoshi`,
    `Genghis Khan`. Generating `Sun Tzu` probably doesn’t catch you off guard; it’s
    the first value yielded by the `WarriorGenerator`. But the second output, `Hattori`,
    deserves an explanation.
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这段代码，你会看到输出是 `Sun Tzu`、`Hattori`、`Yoshi`、`Genghis Khan`。生成 `Sun Tzu` 可能不会让你感到意外；它是
    `WarriorGenerator` 生成的第一个值。但第二个输出 `Hattori` 值得解释。
- en: By using the `yield*` operator on an iterator, we yield to another generator.
    In this example, from a `WarriorGenerator` we’re yielding to a new `NinjaGenerator`;
    all calls to the current `WarriorGenerator` iterator’s `next` method are rerouted
    to the `NinjaGenerator`. This holds until the `NinjaGenerator` has no work left
    to do. So in our example, after `Sun Tzu`, the program generates `Hattori` and
    `Yoshi.` Only when the `NinjaGenerator` is done with its work will the execution
    of the original iterator continue by outputting `Genghis Khan`. Notice that this
    is happening transparently to the code that calls the original generator. The
    `for-of` loop doesn’t care that the `WarriorGenerator` yields to another generator;
    it keeps calling `next` until it’s done.
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在迭代器上使用 `yield*` 操作符，我们可以委托给另一个生成器。在这个例子中，我们从 `WarriorGenerator` 委托给一个新的 `NinjaGenerator`；当前
    `WarriorGenerator` 迭代器的 `next` 方法的所有调用都被重定向到 `NinjaGenerator`。这会持续到 `NinjaGenerator`
    没有剩余的工作要做。所以，在我们的例子中，在 `Sun Tzu` 之后，程序生成 `Hattori` 和 `Yoshi`。只有当 `NinjaGenerator`
    完成其工作后，原始迭代器的执行才会继续，输出 `Genghis Khan`。请注意，这对调用原始生成器的代码来说是透明的。`for-of` 循环并不关心 `WarriorGenerator`
    是否委托给另一个生成器；它继续调用 `next` 直到完成。
- en: Now that you have a grasp of how generators work in general and how delegating
    to another generator works, let’s look at a couple of practical examples.
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了生成器的一般工作原理以及委托给另一个生成器的工作原理，让我们看看一些实际例子。
- en: 6.2.2\. Using generators
  id: totrans-1125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.2\. 使用生成器
- en: Generating sequences of items is all nice and dandy, but let’s get more practical,
    starting with a simple case of generating unique IDs.
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: 生成项目序列听起来很美好，但让我们更实际一些，从一个简单的生成唯一 ID 的例子开始。
- en: Using generators to generate IDs
  id: totrans-1127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用生成器生成 ID
- en: When creating certain objects, often we need to assign a unique ID to each object.
    The easiest way to do this is through a global counter variable, but that’s kind
    of ugly because the variable can be accidently messed up from anywhere in our
    code. Another option is to use a generator, as shown in the following listing.
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建某些对象时，我们通常需要为每个对象分配一个唯一的 ID。最简单的方法是通过全局计数器变量，但这有点丑陋，因为变量可能会在我们的代码的任何地方被意外破坏。另一种选择是使用生成器，如下面的列表所示。
- en: Listing 6.5\. Using generators for generating IDs
  id: totrans-1129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.5\. 使用生成器生成 ID
- en: '![](134fig01_alt.jpg)'
  id: totrans-1130
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](134fig01_alt.jpg)'
- en: 'This example starts with a generator that has one local variable, `id`, which
    represents our ID counter. The `id` variable is local to our generator; there’s
    no fear that someone will accidently modify it from somewhere else in the code.
    This is followed by an infinite `while` loop, which at each iteration yields a
    new `id` value and suspends its execution until a request for another ID comes
    along:'
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子从一个具有一个局部变量 `id` 的生成器开始，`id` 变量代表我们的 ID 计数器。`id` 变量是生成器本地的；不用担心有人会意外地从代码的其他地方修改它。这后面跟着一个无限的
    `while` 循环，在每次迭代中产生一个新的 `id` 值，并暂停其执行，直到有另一个 ID 请求到来：
- en: '[PRE109]'
  id: totrans-1132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '|  |'
  id: totrans-1133
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-1134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Writing infinite loops isn’t something that we generally want to do in a standard
    function. But with generators, everything is fine! Whenever the generator encounters
    a `yield` statement, the generator execution is suspended until the `next` method
    is called again. So every `next` call executes only one iteration of our infinite
    `while` loop and sends back the next ID value.
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准函数中编写无限循环并不是我们通常想要做的事情。但有了生成器，一切都很正常！每当生成器遇到 `yield` 语句时，生成器执行就会暂停，直到再次调用
    `next` 方法。所以每个 `next` 调用只执行无限 `while` 循环的一次迭代，并返回下一个 ID 值。
- en: '|  |'
  id: totrans-1136
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'After defining the generator, we create an iterator object:'
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义生成器之后，我们创建一个迭代器对象：
- en: '[PRE110]'
  id: totrans-1138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'This allows us to control the generator with calls to the `idIterator.next()`
    method. This executes the generator until a `yield` is encountered, returning
    a new ID value that we can use for our objects:'
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们通过调用 `idIterator.next()` 方法来控制生成器。这执行生成器直到遇到 `yield`，返回我们可以用于我们的对象的新 ID
    值：
- en: '[PRE111]'
  id: totrans-1140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: See how simple this is? No messy global variables whose value can be accidentally
    changed. Instead, we use an iterator to request values from a generator. In addition,
    if later we need another iterator for tracking the IDs of, for example, `samurai`,
    we can initialize a new generator for that.
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这是多么简单？没有可以意外更改值的混乱的全局变量。相反，我们使用迭代器从生成器请求值。此外，如果我们以后需要另一个迭代器来跟踪例如 `samurai`
    的 ID，我们可以为那个初始化一个新的生成器。
- en: Using generators to traverse the DOM
  id: totrans-1142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用生成器遍历 DOM
- en: As you saw in [chapter 2](kindle_split_012.html#ch02), the layout of a web page
    is based on the DOM, a tree-like structure of HTML nodes, in which every node,
    except the root one, has exactly one parent, and can have zero or more children.
    Because the DOM is such a fundamental structure in web development, a lot of our
    code is based around traversing it. One relatively easy way to do this is by implementing
    a recursive function that will be executed for each visited node. See the following
    code.
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[第 2 章](kindle_split_012.html#ch02)中看到的，网页布局基于 DOM，这是一个 HTML 节点的树状结构，其中每个节点（除了根节点）恰好有一个父节点，可以有零个或多个子节点。因为
    DOM 是网络开发中的基本结构，所以我们的很多代码都是围绕遍历它来编写的。一个相对简单的方法是实现一个递归函数，该函数将为每个访问的节点执行。请看下面的代码。
- en: Listing 6.6\. Recursive DOM traversal
  id: totrans-1144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.6\. 递归 DOM 遍历
- en: '![](135fig01_alt.jpg)'
  id: totrans-1145
  prefs: []
  type: TYPE_IMG
  zh: '![](135fig01_alt.jpg)'
- en: In this example, we use a recursive function to traverse all descendants of
    the element with the `id subtree`, in the process logging each type of node that
    we visit. In this case, the code outputs `DIV`, `FORM`, `INPUT`, `P`, and `SPAN`.
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用递归函数遍历具有 `id subtree` 的元素的子代，在这个过程中记录我们访问的每种节点类型。在这种情况下，代码输出 `DIV`、`FORM`、`INPUT`、`P`
    和 `SPAN`。
- en: We’ve been writing such DOM traversal code for a while now, and it has served
    us perfectly fine. But now that we have generators at our disposal, we can do
    it differently; see the following code.
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经编写了这样的 DOM 遍历代码一段时间了，它一直为我们服务得很好。但现在我们有了生成器，我们可以用不同的方式来做这件事；请看下面的代码。
- en: Listing 6.7\. Iterating over a DOM tree with generators
  id: totrans-1148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.7\. 使用生成器遍历 DOM 树
- en: '![](135fig02_alt.jpg)'
  id: totrans-1149
  prefs: []
  type: TYPE_IMG
  zh: '![](135fig02_alt.jpg)'
- en: This listing shows that we can achieve DOM traversals with generators, just
    as easily as with standard recursion, but with the aditional benefit of not having
    to use the slightly awkward syntax of callbacks. Instead of processing the subtree
    of each visited node by recursing another level, we create one generator function
    for each visited node and yield to it. This enables us to write what’s conceptually
    recursive code in iterable fashion. The benefit is that we can consume the generated
    sequence of nodes with a simple `for-of` loop, without resorting to nasty callbacks.
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例表明，我们可以像使用标准递归一样轻松地使用生成器进行DOM遍历，但还有一个额外的优点，就是不必使用稍微有些尴尬的回调语法。我们不是通过递归到另一个级别来处理每个访问节点的子树，而是为每个访问节点创建一个生成器函数并向它发送`yield`。这使得我们可以以可迭代的方式编写概念上递归的代码。好处是，我们可以使用简单的`for-of`循环来消费生成的节点序列，而不必求助于讨厌的回调。
- en: This example is a particulary good one, because it also shows how to use generators
    in order to separate the code that’s producing values (in this case, HTML nodes)
    from the code that’s consuming the sequence of generated values (in this case,
    the `for-of` loop that logs the visited nodes), without having to resort to callbacks.
    In addition, using iterations is, in certain cases, much more natural than recursion,
    so it’s always good to have our options open.
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子特别出色，因为它还展示了如何使用生成器来分离产生值的代码（在这种情况下，HTML节点）和消费生成值序列的代码（在这种情况下，记录访问节点的`for-of`循环），而不必求助于回调。此外，在某些情况下，使用迭代比递归更自然，所以总是好的，保持我们的选择开放。
- en: Now that we’ve explored some practical aspects of generators, let’s go back
    to a slighty more theoretical topic and see how to exchange data with a running
    generator.
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探索了一些生成器的实际应用方面，让我们回到一个稍微更理论性的话题，看看如何与正在运行的生成器交换数据。
- en: 6.2.3\. Communicating with a generator
  id: totrans-1153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.3\. 与生成器通信
- en: In the examples presented so far, you’ve seen how to return multiple values
    *from* a generator by using `yield` expressions. But generators are even more
    powerful than that! We can also send data *to* a generator, thereby achieving
    two-way communication! With a generator, we can produce an intermediary result,
    use that result to calculate something else from outside the generator, and then,
    whenever we’re ready, send completely new data back to the generator and resume
    its execution. We’ll use this feature to great effect at the end of the chapter
    to deal with asynchronous code, but for now, let’s keep it simple.
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面提供的示例中，你已经看到了如何使用`yield`表达式从生成器返回多个值。但生成器比这更强大！我们还可以将数据发送到生成器，从而实现双向通信！使用生成器，我们可以产生一个中间结果，使用该结果从生成器外部计算其他东西，然后，当我们准备好时，将完全新的数据发送回生成器并继续其执行。我们将在本章末尾使用这个特性来处理异步代码，但现在让我们保持简单。
- en: Sending values as generator function arguments
  id: totrans-1155
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将值作为生成器函数参数发送
- en: The easiest way to send data to a generator is by treating it like any other
    function and using function call arguments. Take a look at the following listing.
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: 向生成器发送数据最简单的方法是将它当作任何其他函数一样对待，并使用函数调用参数。请看下面的示例。
- en: Listing 6.8\. Sending data to and receiving data from a generator
  id: totrans-1157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.8\. 向生成器发送数据并从生成器接收数据
- en: '![](136fig01_alt.jpg)'
  id: totrans-1158
  prefs: []
  type: TYPE_IMG
  zh: '![](136fig01_alt.jpg)'
- en: A function receiving data is nothing special; plain old functions do it all
    the time. But remember, generators have this amazing power; they can be suspended
    and resumed. And it turns out that, unlike standard functions, generators can
    even receive data *after* their execution has started, whenever we resume them
    by requesting the next value.
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: 接收数据的函数没有什么特别之处；普通的函数一直在做这件事。但请记住，生成器有这种惊人的能力；它们可以被暂停和恢复。而且，事实证明，与标准函数不同，生成器甚至可以在它们的执行开始后接收数据，只要我们通过请求下一个值来恢复它们。
- en: Using the next method to send values into a generator
  id: totrans-1160
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用`next`方法向生成器发送值
- en: In addition to providing data when first invoking the generator, we can send
    data *into* a generator by passing arguments to the `next` method. In the process,
    we wake up the generator from suspension and resume its execution. This passed-in
    value is used by the generator as the value of the whole `yield` expression, in
    which the generator was currently suspended, as shown in [figure 6.3](#ch06fig03).
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在首次调用生成器时提供数据外，我们还可以通过向`next`方法传递参数将数据发送到生成器中。在这个过程中，我们唤醒了暂停的生成器并继续其执行。这个传入的值被生成器用作当前暂停的整个`yield`表达式的值，如[图6.3](#ch06fig03)所示。
- en: Figure 6.3\. The first call to `ninjaIterator.next()` requests a new value from
    the generator, which returns `Hattori skulk` and suspends the execution of the
    generator at the `yield` expression. The second call to `ninjaIterator.next("Hanzo")`
    requests a new value, but also sends the argument `Hanzo` into the generator.
    This value will be used as the value of the whole `yield` expression, and the
    variable `imposter` will now carry the value `Hanzo`.
  id: totrans-1162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.3\. 第一次调用 `ninjaIterator.next()` 从生成器请求一个新值，生成器返回 `Hattori skulk` 并在 `yield`
    表达式处暂停生成器的执行。第二次调用 `ninjaIterator.next("Hanzo")` 请求一个新值，同时也将参数 `Hanzo` 传递给生成器。这个值将用作整个
    `yield` 表达式的值，而变量 `imposter` 现在将携带 `Hanzo` 的值。
- en: '![](06fig03_alt.jpg)'
  id: totrans-1163
  prefs: []
  type: TYPE_IMG
  zh: '![图片](06fig03_alt.jpg)'
- en: In this example, we have two calls to the `ninjaIterator`’s `next` method. The
    first call, `ninjaIterator.next()`, requests the first value from the generator.
    Because our generator hasn’t started executing, this call starts the generator,
    which calculates the value of the expression `"Hattori " + action,` yields the
    `Hattori skulk` value, and suspends the generator’s execution. There’s nothing
    special about this; we’ve done something similar multiple times throughout this
    chapter.
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们对 `ninjaIterator` 的 `next` 方法进行了两次调用。第一次调用 `ninjaIterator.next()`，请求生成器的第一个值。因为我们的生成器还没有开始执行，这次调用启动了生成器，计算表达式
    `"Hattori " + action` 的值，产生 `Hattori skulk` 值，并暂停生成器的执行。这没有什么特别的；我们在本章中已经多次做过类似的事情。
- en: 'The interesting thing happens on the second call to the `ninjaIterator`’s `next`
    method: `ninjaIterator.next("Hanzo")`. This time, we’re using the `next` method
    to pass data back to the generator. Our generator function is patiently waiting,
    suspended at the expression `yield ("Hattori " + action)`, so the value `Hanzo`,
    passed as the argument to `next()`, is used as the value of the whole `yield`
    expression. In our case, this means that the variable `imposter` in `imposter
    = yield ("Hattori " + action)` will end up with the value `Hanzo`.'
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的事情发生在对 `ninjaIterator` 的 `next` 方法的第二次调用中：`ninjaIterator.next("Hanzo")`。这次，我们使用
    `next` 方法将数据传递回生成器。我们的生成器函数正耐心地等待，暂停在 `yield ("Hattori " + action)` 表达式处，因此传递给
    `next()` 的值 `Hanzo` 被用作整个 `yield` 表达式的值。在我们的例子中，这意味着 `imposter = yield ("Hattori
    " + action)` 中的变量 `imposter` 最终将获得 `Hanzo` 的值。
- en: That’s how we achieve two-way communication with a generator. We use `yield`
    to return data from a generator, and the `iterator`’s `next()` method to pass
    data back to the generator.
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们与生成器实现双向通信的方法。我们使用 `yield` 从生成器返回数据，并使用迭代器的 `next()` 方法将数据传递回生成器。
- en: '|  |'
  id: totrans-1167
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-1168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The `next` method supplies the value to the waiting `yield` expression, so if
    there’s no `yield` expression waiting, there’s nothing to supply the value to.
    For this reason, we *can’t* supply values over the first call to the `next` method.
    But remember, if you need to supply an initial value to the generator, you can
    do so when calling the generator itself, as we did with `NinjaGenerator("skulk")`.
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: '`next` 方法为等待的 `yield` 表达式提供值，所以如果没有等待的 `yield` 表达式，就没有值可以提供。因此，我们 *不能* 在第一次调用
    `next` 方法时提供值。但记住，如果你需要向生成器提供一个初始值，你可以在调用生成器本身时这样做，就像我们用 `NinjaGenerator("skulk")`
    所做的那样。'
- en: '|  |'
  id: totrans-1170
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Throwing exceptions
  id: totrans-1171
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 抛出异常
- en: 'There’s another, slightly less orthodox, way to supply a value to a generator:
    by throwing an exception. Each iterator, in addition to having a `next` method,
    has a `throw` method that we can use to throw an exception back to the generator.
    Again, let’s look at a simple example.'
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种，稍微不那么正统的方法，向生成器提供一个值：通过抛出异常。每个迭代器除了有一个 `next` 方法外，还有一个 `throw` 方法，我们可以用它来向生成器抛出异常。再次，让我们看看一个简单的例子。
- en: Listing 6.9\. Throwing exceptions to generators
  id: totrans-1173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.9\. 向生成器抛出异常
- en: '![](138fig01_alt.jpg)'
  id: totrans-1174
  prefs: []
  type: TYPE_IMG
  zh: '![图片](138fig01_alt.jpg)'
- en: '[Listing 6.9](#ch06ex09) starts similarly to [listing 6.8](#ch06ex08), by specifying
    a generator called `NinjaGenerator`. But this time, the body of the generator
    is slightly different. We’ve surrounded the whole function body code with a `try-catch`
    block:'
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 6.9](#ch06ex09) 与 [列表 6.8](#ch06ex08) 类似，通过指定一个名为 `NinjaGenerator` 的生成器开始。但这次，生成器的主体略有不同。我们用
    `try-catch` 块包围了整个函数主体代码：'
- en: '[PRE112]'
  id: totrans-1176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'We then continue by creating an iterator, and getting one value from the generator:'
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们继续创建一个迭代器，并从生成器中获取一个值：
- en: '[PRE113]'
  id: totrans-1178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Finally, we use the `throw` method, available on all iterators, to throw an
    exception back to the generator:'
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用所有迭代器都有的 `throw` 方法将异常抛回生成器：
- en: '[PRE114]'
  id: totrans-1180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: By running this listing, we can see that our exception throwing works as expected,
    as shown in [figure 6.4](#ch06fig04).
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行这个列表，我们可以看到我们的异常抛出工作如预期所示，如图6.4。
- en: Figure 6.4\. We can throw exceptions to generators from outside a generator.
  id: totrans-1182
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.4。我们可以从生成器外部向生成器抛出异常。
- en: '![](06fig04.jpg)'
  id: totrans-1183
  prefs: []
  type: TYPE_IMG
  zh: '![06fig04.jpg](06fig04.jpg)'
- en: This feature that enables us to throw exceptions back to generators might feel
    a bit strange at first. Why would we even want to do that? Don’t worry; we won’t
    keep you in the dark for long. At the end of this chapter, we’ll use this feature
    to improve asynchronous server-side communication. Just be patient a bit longer.
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性使我们能够将异常抛回到生成器，一开始可能会觉得有点奇怪。我们为什么要这样做呢？别担心，我们不会让你长时间处于黑暗中。在本章末尾，我们将使用这个特性来改进异步服务器端通信。只需再耐心一点。
- en: Now that you’ve seen several aspects of generators, we’re ready to take a look
    under the hood to see how generators work.
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了生成器的几个方面，我们准备深入底层看看生成器是如何工作的。
- en: 6.2.4\. Exploring generators under the hood
  id: totrans-1186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.4. 探索底层的生成器
- en: 'So far we know that calling a generator doesn’t execute it. Instead, it creates
    a new iterator that we can use to request values from the generator. After a generator
    produces (or yields) a value, it suspends its execution and waits for the next
    request. So in a way, a generator works almost like a small program, a state machine
    that moves between states:'
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们知道调用生成器并不会执行它。相反，它创建了一个新的迭代器，我们可以使用它来请求生成器的值。在生成器产生（或产生）一个值之后，它会暂停其执行并等待下一个请求。所以从某种意义上说，生成器几乎像一个小程序，一个在状态之间移动的状态机：
- en: '***Suspended start—*** When the generator is created, it starts in this state.
    None of the generator’s code is executed.'
  id: totrans-1188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***暂停开始——*** 当生成器被创建时，它从这个状态开始。生成器的任何代码都没有被执行。'
- en: '***Executing—*** The state in which the code of the generator is executed.
    The execution continues either from the beginning or from where the generator
    was last suspended. A generator moves to this state when the matching iterator’s
    `next` method is called, and there exists code to be executed.'
  id: totrans-1189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***执行中——*** 生成器代码被执行的状态。执行要么从开始处继续，要么从生成器上次暂停的地方继续。当调用匹配迭代器的`next`方法且存在要执行的代码时，生成器移动到这个状态。'
- en: '***Suspended yield—*** During execution, when a generator reaches a `yield`
    expression, it creates a new object carrying the return value, yields it, and
    suspends its execution. This is the state in which the generator is paused and
    is waiting to continue its execution.'
  id: totrans-1190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***暂停产生——*** 在执行过程中，当生成器达到一个`yield`表达式时，它创建一个新的携带返回值的对象，产生它，并暂停其执行。这是生成器暂停并等待继续执行的状态。'
- en: '***Completed—*** If during execution the generator either runs into a `return`
    statement or runs out of code to execute, the generator moves into this state.'
  id: totrans-1191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***完成——*** 如果在执行过程中生成器遇到了`return`语句或者没有更多的代码可以执行，生成器就会移动到这个状态。'
- en: '[Figure 6.5](#ch06fig05) illustrates these states.'
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6.5](#ch06fig05)说明了这些状态。'
- en: Figure 6.5\. During execution, a generator moves between states triggered by
    calls to the matching iterator’s `next` method.
  id: totrans-1193
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.5。在执行过程中，生成器在调用匹配迭代器的`next`方法时在状态之间移动。
- en: '![](06fig05_alt.jpg)'
  id: totrans-1194
  prefs: []
  type: TYPE_IMG
  zh: '![06fig05_alt.jpg](06fig05_alt.jpg)'
- en: Now let’s supplement this on an even deeper level, by seeing how the execution
    of generators is tracked with execution contexts.
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从更深层次补充这一点，通过查看生成器的执行是如何与执行上下文一起跟踪的。
- en: Tracking generators with execution contexts
  id: totrans-1196
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用执行上下文跟踪生成器
- en: 'In the previous chapter, we introduced the execution context, an internal JavaScript
    mechanism used to track the execution of functions. Although somewhat special,
    generators are still functions, so let’s take a closer look by exploring the relationship
    between them and execution contexts. We’ll start with a simple code fragment:'
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了执行上下文，这是一个内部JavaScript机制，用于跟踪函数的执行。尽管有些特殊，但生成器仍然是函数，让我们通过探索它们与执行上下文之间的关系来更深入地了解它们。我们将从一个简单的代码片段开始：
- en: '[PRE115]'
  id: totrans-1198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Here we reuse our generator that produces two values: `Hattori skulk` and `Yoshi
    skulk`.'
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们重用我们的生成器，它产生两个值：`Hattori skulk`和`Yoshi skulk`。
- en: Now, we’ll explore the state of the application, the execution context stack
    at various points in the application execution. [Figure 6.6](#ch06fig06) gives
    a snapshot at two positions in the application execution. The first snapshot shows
    the state of the application execution *before* calling the `NinjaGenerator` function
    ![](num-01.jpg). Because we’re executing global code, the execution context stack
    contains only the global execution context, which references the global environment
    in which our identifiers are kept. Only the `NinjaGenerator` identifier references
    a function, while the values of all other identifiers are `undefined`.
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将探索应用程序的状态，以及在应用程序执行过程中的各个点的执行上下文堆栈状态。[图6.6](#ch06fig06)给出了应用程序执行两个位置的快照。第一个快照显示了调用`NinjaGenerator`函数之前的应用程序执行状态
    ![num-01.jpg](num-01.jpg)。因为我们正在执行全局代码，所以执行上下文堆栈中只包含全局执行上下文，它引用了我们的标识符所保持的全局环境。只有`NinjaGenerator`标识符引用一个函数，而所有其他标识符的值都是`undefined`。
- en: Figure 6.6\. The state of the execution context stack *before* calling the `NinjaGenerator`
    function ![](num-01.jpg), and *when* calling the `NinjaGenerator` function ![](num-02.jpg)
  id: totrans-1201
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.6\. 在调用`NinjaGenerator`函数之前的状态 ![num-01.jpg](num-01.jpg)，以及调用`NinjaGenerator`函数时
    ![num-02.jpg](num-02.jpg)
- en: '![](06fig06_alt.jpg)'
  id: totrans-1202
  prefs: []
  type: TYPE_IMG
  zh: '![06fig06_alt.jpg](06fig06_alt.jpg)'
- en: When we make the call to the `NinjaGenerator` function ![](num-02.jpg)
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`NinjaGenerator`函数时 ![num-02.jpg](num-02.jpg)
- en: '[PRE116]'
  id: totrans-1204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: the control flow enters the generator and, as it happens when we enter any other
    function, a new `NinjaGenerator` execution context item is created (alongside
    the matching lexical environment) and pushed onto the stack. But because generators
    are special, *none* of the function code is executed. Instead, a new iterator,
    which we’ll refer to in the code as `ninjaIterator`, is created and returned.
    Because the iterator is used to control the execution of the generator, the iterator
    gets a reference to the execution context in which it was created.
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: 控制流进入生成器，就像我们进入任何其他函数时发生的情况一样，创建一个新的`NinjaGenerator`执行上下文项（以及匹配的词法环境）并将其推入堆栈。但由于生成器是特殊的，*没有任何*函数代码被执行。相反，创建了一个新的迭代器，我们在代码中将其称为`ninjaIterator`，并将其返回。因为迭代器用于控制生成器的执行，所以迭代器获得了对其创建时的执行上下文的引用。
- en: An interesting thing happens when the program execution leaves the generator,
    as shown in [figure 6.7](#ch06fig07). Typically, when program execution returns
    from a standard function, the matching execution context is popped from the stack
    and completely discarded. But this isn’t the case with generators.
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序执行离开生成器时，会发生有趣的事情，如图6.7所示。[图6.7](#ch06fig07)。通常，当程序执行从一个标准函数返回时，匹配的执行上下文会从堆栈中弹出并完全丢弃。但生成器的情况并非如此。
- en: Figure 6.7\. The state of the application when returning from the `NinjaGenerator`
    call
  id: totrans-1207
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.7\. 从`NinjaGenerator`调用返回时的应用程序状态
- en: '![](06fig07_alt.jpg)'
  id: totrans-1208
  prefs: []
  type: TYPE_IMG
  zh: '![06fig07_alt.jpg](06fig07_alt.jpg)'
- en: The matching `NinjaGenerator` stack item *is* popped from the stack, but it’s
    *not* discarded, because the `ninjaIterator` keeps a reference to it. You can
    see it as an analogue to closures. In closures, we need to keep alive the variables
    that are alive at the moment the function closure is created, so our functions
    keep a reference to the environment in which they were created. In this way, we
    make sure that the environment and its variables are alive as long as the function
    itself. Generators, on the other hand, have to be able to resume their execution.
    Because the execution of all functions is handled by execution contexts, the iterator
    keeps a reference to its execution context, so that it’s alive for as long as
    the iterator needs it.
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配的`NinjaGenerator`堆栈项确实从堆栈中弹出，但它并没有被丢弃，因为`ninjaIterator`保持对其的引用。你可以将其视为闭包的类似物。在闭包中，我们需要保持函数创建时活跃的变量的活跃状态，因此我们的函数会保持对其创建环境的引用。这样，我们确保环境及其变量在函数本身存在期间保持活跃。另一方面，生成器必须能够恢复其执行。因为所有函数的执行都由执行上下文处理，迭代器保持对其创建时的执行上下文的引用，以便在迭代器需要时保持活跃。
- en: 'Another interesting thing happens when we call the `next` method on the iterator:'
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在迭代器上调用`next`方法时，发生另一件有趣的事情：
- en: '[PRE117]'
  id: totrans-1211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: If this was a standard straightforward function call, this would cause the creation
    of a *new* `next()` execution context item, which would be placed on the stack.
    But as you might have noticed, generators are anything but standard, and a call
    to the `next` method of an iterator behaves a lot differently. It reactivates
    the matching execution context, in this case, the `NinjaGenerator` context, and
    places it on top of the stack, continuing the execution where it left off, as
    shown in [figure 6.8](#ch06fig08).
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是一个标准的直接函数调用，这将导致创建一个新的 `next()` 执行上下文项，并将其放置在栈上。但正如你可能已经注意到的，生成器根本不是标准的，对迭代器的
    `next` 方法的调用行为大不相同。它重新激活匹配的执行上下文，在这种情况下，是 `NinjaGenerator` 上下文，并将其放置在栈顶，继续上次停止的地方执行，如图6.8所示。
- en: Figure 6.8\. Calling the iterator’s `next` method reactivates the execution
    context stack item of the matching generator, pushes it on the stack, and continues
    where it left off the last time.
  id: totrans-1213
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.8。调用迭代器的 `next` 方法重新激活匹配生成器的执行上下文栈项，将其推入栈中，并从上次停止的地方继续执行。
- en: '![](06fig08_alt.jpg)'
  id: totrans-1214
  prefs: []
  type: TYPE_IMG
  zh: '![图6.9](06fig08_alt.jpg)'
- en: '[Figure 6.8](#ch06fig08) illustrates a crucial difference between standard
    functions and generators. Standard functions can only be called anew, and each
    call creates a *new* execution context. In contrast, the execution context of
    a generator can be temporarily suspended and resumed at will.'
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6.8](#ch06fig08) 展示了标准函数和生成器之间的重要区别。标准函数只能重新调用，并且每次调用都会创建一个新的执行上下文。相比之下，生成器的执行上下文可以被临时挂起并随意恢复。'
- en: 'In our example, because this is the first call to the `next` method, and the
    generator hasn’t started executing, the generator starts its execution and moves
    to the Executing state. The next interesting thing happens when our generator
    function reaches this point:'
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，因为这是对 `next` 方法的第一次调用，生成器还没有开始执行，所以生成器开始执行并移动到执行状态。当我们的生成器函数到达这个点时，接下来有趣的事情发生了：
- en: '[PRE118]'
  id: totrans-1217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'The generator determines that the expression equals `Hattori skulk`, and the
    evaluation reaches the `yield` keyword. This means that `Hattori skulk` is the
    first intermediary result of our generator and that we want to suspend the execution
    of the generator and return that value. In terms of the application state, a similar
    thing happens as before: the `NinjaGenerator` context is taken off the stack,
    but it’s not completely discarded, because `ninjaIterator` keeps a reference to
    it. The generator is now suspended, and has moved to the Suspended Yield state,
    without blocking. The program execution resumes in global code, by storing the
    yielded value to `result1`. The current state of the application is shown in [figure
    6.9](#ch06fig09).'
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器确定表达式等于 `Hattori skulk`，评估到达了 `yield` 关键字。这意味着 `Hattori skulk` 是我们生成器的第一个中间结果，并且我们想要挂起生成器的执行并返回该值。从应用程序状态的角度来看，发生的事情与之前类似：`NinjaGenerator`
    上下文从栈中移除，但它并未完全丢弃，因为 `ninjaIterator` 保留了对它的引用。现在生成器被挂起，并移动到挂起产生状态，没有阻塞。程序执行通过将产生的值存储到
    `result1` 中在全局代码中继续。应用程序的当前状态如图6.9所示。
- en: Figure 6.9\. After yielding a value, the generator’s execution context is popped
    from the stack (but isn’t discarded, because `ninjaIterator` keeps a reference
    to it), and the generator execution is suspended (the generator moves to the Suspended
    yield state).
  id: totrans-1219
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.9。在产生一个值后，生成器的执行上下文从栈中弹出（但并未丢弃，因为 `ninjaIterator` 保留了对它的引用），生成器的执行被挂起（生成器移动到挂起产生状态）。
- en: '![](06fig09_alt.jpg)'
  id: totrans-1220
  prefs: []
  type: TYPE_IMG
  zh: '![图6.9](06fig09_alt.jpg)'
- en: 'The code continues by reaching another iterator call:'
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: 代码继续执行，到达另一个迭代器调用：
- en: '[PRE119]'
  id: totrans-1222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'At this point, we go through the whole procedure once again: we reactivate
    the `NinjaGenerator` context referenced by `ninjaIterator`, push it onto the stack,
    and continue the execution where we left off. In this case, the generator evaluates
    the expression `"Yoshi " + action`. But this time there’s no `yield` expression,
    and instead the program encounters a `return` statement. This returns the value
    `Yoshi skulk` and completes the generator’s execution by moving the generator
    into the Completed state.'
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们再次走一遍整个流程：我们重新激活由 `ninjaIterator` 引用的 `NinjaGenerator` 上下文，将其推入栈中，并从上次停止的地方继续执行。在这种情况下，生成器评估表达式
    `"Yoshi " + action`。但这次没有 `yield` 表达式，而是程序遇到了一个 `return` 语句。这返回了值 `Yoshi skulk`
    并通过将生成器移动到完成状态来完成生成器的执行。
- en: Uff, this was something! We went deep into how generators work under the hood
    to show you that all the wonderful benefits of generators are a side effect of
    the fact that a generator’s execution context is kept alive if we yield from a
    generator, and not destroyed as is the case with return values and standard functions.
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: 哎，这真是个大发现！我们深入探讨了生成器在底层是如何工作的，以向您展示生成器的所有美妙好处都是由于如果我们从生成器中 `yield`，生成器的执行上下文会保持活跃，而不是像返回值和标准函数那样被销毁。
- en: 'Now we recommend that you take a quick breather before continuing on to the
    second key ingredient required for writing elegant asynchronous code: promises.'
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们建议您在继续学习编写优雅的异步代码的第二个关键要素——Promise 之前，先稍作休息。
- en: 6.3\. Working with promises
  id: totrans-1226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3. 使用 Promise
- en: 'In JavaScript, we rely a lot on asynchronous computations, computations whose
    results we don’t have yet but will at some later point. So ES6 has introduced
    a new concept that makes handling asynchronous tasks easier: promises.'
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，我们大量依赖于异步计算，这些计算的结果我们目前还没有，但将在某个未来的时刻获得。因此，ES6 引入了一个新的概念，使得处理异步任务变得更加容易：Promise。
- en: A *promise* is a placeholder for a value that we don’t have now but will have
    later; it’s a guarantee that we’ll eventually know the result of an asynchronous
    computation. If we make good on our promise, our result will be a value. If a
    problem occurs, our result will be an error, an excuse for why we couldn’t deliver.
    One great example of using promises is fetching data from a server; we promise
    that we’ll eventually get the data, but there’s always a chance that problems
    will occur.
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
  zh: '*Promise* 是一个占位符，用于表示我们现在没有但将来会有的值；它是对我们最终将知道异步计算结果的保证。如果我们履行我们的承诺，我们的结果将是一个值。如果发生问题，我们的结果将是一个错误，解释了我们为什么无法交付的理由。使用
    Promise 的一个很好的例子是从服务器获取数据；我们承诺我们最终会得到数据，但总有可能出现问题。'
- en: Creating a new promise is easy, as you can see in the following example.
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在以下示例中看到的那样，创建一个新的 Promise 很简单。
- en: Listing 6.10\. Creating a simple promise
  id: totrans-1230
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.10. 创建一个简单的 Promise
- en: '![](146fig01_alt.jpg)'
  id: totrans-1231
  prefs: []
  type: TYPE_IMG
  zh: '![](146fig01_alt.jpg)'
- en: 'To create a promise, we use the new, built-in `Promise` constructor, to which
    we pass a function, in this case an arrow function (but we could just as easily
    use a function expression). This function, called an *executor* function, has
    two parameters: `resolve` and `reject`. The executor is called *immediately* when
    constructing the `Promise` object with two built-in functions as arguments: `resolve`,
    which we manually call if we want the promise to resolve successfully, and `reject`,
    which we call if an error occurs.'
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个 Promise，我们使用新的内置 `Promise` 构造函数，我们向它传递一个函数，在这种情况下是一个箭头函数（但我们也可以简单地使用函数表达式）。这个函数被称为
    *执行器* 函数，它有两个参数：`resolve` 和 `reject`。当使用两个内置函数作为参数构造 `Promise` 对象时，执行器会被立即调用：`resolve`，如果我们想成功解析
    Promise，则手动调用它；`reject`，如果发生错误，则调用它。
- en: 'This code uses the promise by calling the built-in `then` method on the `Promise`
    object, a method to which we pass two callback functions: a *success* callback
    and a *failure* callback. The former is called if the promise is resolved successfully
    (if the `resolve` function is called on the promise), and the latter is called
    if there’s a problem (either an unhandled exception occurs or the `reject` function
    is called on a promise).'
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码通过在 `Promise` 对象上调用内置的 `then` 方法来使用 Promise，我们向该方法传递两个回调函数：一个 *成功* 回调和一个
    *失败* 回调。如果 Promise 成功解析（如果在 Promise 上调用了 `resolve` 函数），则调用前者；如果出现问题（要么发生未处理的异常，要么在
    Promise 上调用了 `reject` 函数），则调用后者。
- en: In our example code, we create a promise and immediately resolve it by calling
    the `resolve` function with the argument `Hattori`. Therefore, when we call the
    `then` method, the first, success, callback is executed and the test that outputs
    `We were promised Hattori!` passes.
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例代码中，我们创建了一个 Promise 并立即通过调用带有参数 `Hattori` 的 `resolve` 函数来解析它。因此，当我们调用
    `then` 方法时，第一个成功回调会被执行，并且输出 `We were promised Hattori!` 的测试通过。
- en: Now that we have a general idea of what promises are and how they work, let’s
    take a step back to see some of the problems that promises tackle.
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经对 Promise 是什么以及它是如何工作的有了大致的了解，让我们退一步来看看 Promise 解决的一些问题。
- en: 6.3.1\. Understanding the problems with simple callbacks
  id: totrans-1236
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.1. 理解简单回调的问题
- en: 'We use asynchronous code because we don’t want to block the execution of our
    application (thereby disappointing our users) while long-running tasks are executing.
    Currently, we solve this problem with callbacks: To a long-running task we provide
    a function, a callback that’s invoked when the task is finally done.'
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用异步代码，因为我们不希望在长时间运行的任务执行时阻塞我们应用程序的执行（从而让我们的用户失望）。目前，我们通过以下方式解决这个问题：向长时间运行的任务提供一个函数，一个回调，当任务最终完成时将被调用。
- en: 'For example, fetching a JSON file from a server is a long-running task, during
    which we don’t want to make the application unresponsive for our users. Therefore,
    we provide a callback that will be invoked when the task is done:'
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，从服务器获取JSON文件是一个长时间运行的任务，在这个过程中，我们不希望让我们的应用程序对用户无响应。因此，我们提供了一个回调，当任务完成时将被调用：
- en: '[PRE120]'
  id: totrans-1239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Naturally, during this long-running task, errors can happen. And the problem
    with callbacks is that you can’t use built-in language constructs, such as `try-catch`
    statements, in the following way:'
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，在长时间运行的任务期间，可能会发生错误。回调的问题是你不能以这种方式使用内置的语言结构，例如`try-catch`语句：
- en: '[PRE121]'
  id: totrans-1241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'This happens because the code invoking the callback usually isn’t executed
    in the same step of the event loop as the code that starts the long-running task
    (you’ll see exactly what this means when you learn more about the event loop in
    [chapter 13](kindle_split_026.html#ch13)). As a consequence, errors usually get
    lost. Many libraries, therefore, define their own conventions for reporting errors.
    For example, in the Node.js world, callbacks customarily take two arguments, `err`
    and `data`, where `err` will be a non-null value if an error occurs somewhere
    along the way. This leads to the first problem with callbacks: *difficult error
    handling*.'
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为调用回调的代码通常不会在事件循环的同一步骤中执行，与启动长时间运行任务的代码（当你学习到第13章中关于事件循环的更多内容时，你会确切地了解这是什么意思）。因此，错误通常会被丢失。因此，许多库定义了自己的约定来报告错误。例如，在Node.js的世界里，回调通常接受两个参数，`err`和`data`，其中如果过程中发生错误，`err`将不会是空值。这导致了回调的第一个问题：*错误处理困难*。
- en: 'After we’ve performed a long-running task, we often want to do something with
    the obtained data. This can lead to starting another long-running task, which
    can eventually trigger yet another long-running task, and so on—leading to a series
    of interdependent, asynchronous, callback-processed steps. For example, if we
    want to execute a sneaky plan to find all ninjas at our disposal, get the location
    of the first ninja, and send him some orders, we’d end up with something like
    this:'
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们执行了长时间运行的任务之后，我们通常想要对获得的数据做些处理。这可能导致启动另一个长时间运行的任务，这最终可能触发另一个长时间运行的任务，以此类推——导致一系列相互依赖的、异步的、回调处理的步骤。例如，如果我们想要执行一个秘密的计划来找到我们所有的忍者，获取第一个忍者的位置，并发送一些命令，我们最终会得到如下代码：
- en: '[PRE122]'
  id: totrans-1244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'You’ve probably ended up, at least once or twice, with similarly structured
    code—a bunch of nested callbacks that represent a series of steps that have to
    be made. You might notice that this code is difficult to understand, inserting
    new steps is a pain, and error handling complicates your code significantly. You
    get this “pyramid of doom” that keeps growing and is difficult to manage. This
    leads us to the second problem with callbacks: *performing sequences of steps
    is tricky.*'
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能至少一次或两次遇到过类似结构的代码——一系列嵌套的回调，代表了一系列必须执行的步骤。你可能注意到，这段代码很难理解，插入新步骤很痛苦，错误处理显著复杂化了你的代码。你得到了一个不断增长且难以管理的“灾难金字塔”。这导致我们面临回调的第二个问题：*执行一系列步骤很棘手*。
- en: 'Sometimes, the steps that we have to go through to get to the final result
    don’t depend on each other, so we don’t have to make them in sequence. Instead,
    to save precious milliseconds, we can do them in parallel. For example, if we
    want to set a plan in motion that requires us to know which ninjas we have at
    our disposal, the plan itself, and the location where our plan will play out,
    we could take advantage of jQuery’s `get` method and write something like this:'
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们得到最终结果所需的步骤之间没有相互依赖，所以我们不需要按顺序执行它们。相反，为了节省宝贵的时间，我们可以并行执行它们。例如，如果我们想要启动一个需要我们知道我们有哪些忍者的计划，计划本身，以及我们的计划将实施的位置，我们可以利用jQuery的`get`方法并编写如下代码：
- en: '[PRE123]'
  id: totrans-1247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'In this code, we execute the actions of getting the ninjas, getting the map
    info, and getting the plan in parallel, because these actions don’t depend on
    each other. We only care that, in the end, we have all the data at our disposal.
    Because we don’t know the order in which the data is received, every time we get
    some data, we have to check whether it’s the last piece of the puzzle that we’re
    missing. Finally, when all pieces are in place, we can set our plan in motion.
    Notice that we have to write a lot of boilerplate code just to do something as
    common as executing a number of actions in parallel. This leads us to the third
    problem with callbacks: *performing a number of steps in parallel is also tricky.*'
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们并行执行获取忍者、获取地图信息和获取计划的操作，因为这些操作之间没有依赖关系。我们只关心最终我们是否拥有所有可用的数据。因为我们不知道数据接收的顺序，所以每次我们获取一些数据时，我们必须检查它是否是我们缺少的最后一块拼图。最后，当所有部件都到位时，我们可以开始执行我们的计划。请注意，我们不得不编写大量的样板代码，仅仅是为了执行像并行执行多个操作这样常见的事情。这导致我们面临回调的第三个问题：*并行执行多个步骤也很棘手*。
- en: 'When presenting the first problem with callbacks—dealing with errors—we showed
    how we can’t use some of the fundamental language constructs, such as `try-catch`
    statements. A similar thing holds with loops: If you want to perform asynchronous
    actions for each item in a collection, you have to jump through some more hoops
    to get it done.'
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们展示回调的第一个问题——处理错误时，我们展示了我们无法使用一些基本语言结构，例如`try-catch`语句。与循环类似：如果你想要对集合中的每个项目执行异步操作，你必须跳过一些额外的步骤来完成它。
- en: It’s true that you can make a library to simplify dealing with all these problems
    (and many people have). But this often leads to a lot of slightly different ways
    of dealing with the same problems, so the people behind JavaScript have bestowed
    upon us *promises*, a standard approach for dealing with asynchronous computation.
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: 事实确实如此，你可以创建一个库来简化处理所有这些问题（许多人已经这样做了）。但这样做往往会导致处理相同问题的多种略微不同的方式，因此JavaScript背后的开发者赐予了我们**承诺**，这是一种处理异步计算的标准方法。
- en: Now that you understand most of the reasons behind the introduction of promises,
    as well as have a basic understanding of them, let’s take it up a notch.
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了引入承诺背后的大多数原因，以及对其有基本的了解，让我们更进一步。
- en: 6.3.2\. Diving into promises
  id: totrans-1252
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.2\. 深入理解承诺
- en: A promise is an object that serves as a placeholder for a result of an asynchronous
    task. It represents a value that we don’t have but hope to have in the future.
    For this reason, during its lifetime, a promise can go through a couple of states,
    as shown in [figure 6.10](#ch06fig10).
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺是一个对象，它作为异步任务结果的占位符。它代表一个我们目前没有但希望未来能拥有的值。因此，在其生命周期内，承诺可以经历几个状态，如图6.10所示。
- en: Figure 6.10\. States of a promise
  id: totrans-1254
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.10\. 承诺的状态
- en: '![](06fig10_alt.jpg)'
  id: totrans-1255
  prefs: []
  type: TYPE_IMG
  zh: '![图片](06fig10_alt.jpg)'
- en: A promise starts in the *pending* state, in which we know nothing about our
    promised value. That’s why a promise in the pending state is also called an `unresolved`
    promise. During program execution, if the promise’s `resolve` function is called,
    the promise moves into the *fulfilled* state, in which we’ve successfully obtained
    the promised value. On the other hand, if the promise’s `reject` function is called,
    or if an unhandled exception occurs during promise handling, the promise moves
    into the *rejected* state, in which we weren’t able to obtain the promised value,
    but in which we at least know why. Once a promise has reached either the *fulfilled*
    state or the *rejected* state, it can’t switch (a promise can’t go from fulfilled
    to rejected or vice versa), and it always stays in that state. We say that a promise
    is *resolved* (either successfully or not).
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺从**挂起**状态开始，我们对我们承诺的值一无所知。这就是为什么挂起状态的承诺也被称为`未解决`承诺。在程序执行过程中，如果调用承诺的`resolve`函数，承诺将进入**已解决**状态，这时我们已经成功获得了承诺的值。另一方面，如果调用承诺的`reject`函数，或者在处理承诺时发生未处理的异常，承诺将进入**拒绝**状态，这时我们无法获得承诺的值，但至少我们知道原因。一旦承诺达到**已解决**或**拒绝**状态之一，它就不能切换（承诺不能从已解决状态变为拒绝状态或反之亦然），并且它始终保持在那个状态。我们说承诺是**已解决**的（无论是成功还是不成功）。
- en: The following listing provides a closer look at what’s going on when we use
    promises.
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表提供了当我们使用承诺时发生情况的更详细说明。
- en: Listing 6.11\. A closer look at promise order of execution
  id: totrans-1258
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.11\. 深入了解承诺的执行顺序
- en: '![](ch06ex11-0.jpg)'
  id: totrans-1259
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch06ex11-0.jpg)'
- en: '![](ch06ex11-1.jpg)'
  id: totrans-1260
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch06ex11-1.jpg)'
- en: The code in [listing 6.11](#ch06ex11) outputs the results shown in [figure 6.11](#ch06fig11).
    As you can see, the code starts by logging the “At code start” message by using
    our custom-made `report` function ([appendix C](kindle_split_030.html#app03))
    that outputs the message onscreen. This enables us to easily track the order of
    execution.
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: '[代码清单6.11](#ch06ex11)中的代码输出了[图6.11](#ch06fig11)中显示的结果。正如你所见，代码首先通过我们定制的`report`函数（[附录C](kindle_split_030.html#app03)）记录了“代码开始”的消息，该函数将消息输出到屏幕上。这使得我们能够轻松跟踪执行顺序。'
- en: Figure 6.11\. The result of executing [listing 6.11](#ch06ex11)
  id: totrans-1262
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.11\. 执行[代码清单6.11](#ch06ex11)的结果
- en: '![](06fig11.jpg)'
  id: totrans-1263
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig11.jpg)'
- en: 'Next we create a new promise by calling the `Promise` constructor. This immediately
    invokes the executor function in which we set up a timeout:'
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过调用`Promise`构造函数创建一个新的承诺。这立即调用了设置超时的执行器函数：
- en: '[PRE124]'
  id: totrans-1265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: The timeout will resolve the promise after 500ms. This could have been any other
    asynchronous task, but we chose the humble timeout because of its simplicity.
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: 超时将在500毫秒后解析承诺。这可以是任何其他异步任务，但我们选择简单超时是因为它的简单性。
- en: After the `ninjaDelayedPromise` has been created, it still doesn’t know the
    value that it will eventually have, or whether it will even be successful. (Remember,
    it’s still waiting for the time-out that will resolve it.) So after construction,
    the `ninjaDelayedPromise` is in the first promise state, *pending*.
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建`ninjaDelayedPromise`之后，它仍然不知道它最终将具有的值，或者它是否甚至会被成功解析。（记住，它仍在等待解析它的超时。）因此，在构建之后，`ninjaDelayedPromise`处于第一个承诺状态，`pending`。
- en: 'Next we use the `then` method on the `ninjaDelayedPromise` to schedule a callback
    to be executed when the promise successfully resolves:'
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在`ninjaDelayedPromise`上使用`then`方法来安排一个回调，当承诺成功解析时执行：
- en: '[PRE125]'
  id: totrans-1269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: This callback will *always* be called asynchronously, regardless of the current
    state of the promise.
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: 这个回调*总是*会异步调用，无论承诺的当前状态如何。
- en: We continue by creating another promise, `ninjaImmediatePromise`, which is resolved
    immediately during its construction, by calling the `resolve` function. Unlike
    the `ninjaDelayedPromise`, which after construction is in the *pending* state,
    the `ninja-ImmediatePromise` finishes construction in the *resolved* state, and
    the promise already has the value `Yoshi`.
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续通过创建另一个承诺，`ninjaImmediatePromise`，在构建过程中立即通过调用`resolve`函数来解析它。与在构建后处于`pending`状态的`ninjaDelayedPromise`不同，`ninja-ImmediatePromise`在`resolved`状态下完成构建，并且承诺已经具有值`Yoshi`。
- en: Afterward, we use the `ninjaImmediatePromise`’s `then` method to register a
    callback that will be executed when the promise successfully resolves. But our
    promise is already settled; does this mean that the success callback will be immediately
    called or that it will be ignored? The answer is *neither*.
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们使用`ninjaImmediatePromise`的`then`方法注册一个回调，当承诺成功解析时执行。但我们的承诺已经确定；这意味着成功回调会被立即调用还是会被忽略？答案是*都不是*。
- en: Promises are designed to deal with asynchronous actions, so the JavaScript engine
    *always* resorts to asynchronous handling, to make the promise behavior predictable.
    The engine does this by executing the `then` callbacks after all the code in the
    current step of the event loop is executed (once again, we’ll explore exactly
    what this means in [chapter 13](kindle_split_026.html#ch13)). For this reason,
    if we study the output in [figure 6.11](#ch06fig11), we’ll see that we first log
    “At code end” and then we log that the `ninjaImmediatePromise` was resolved. In
    the end, after the 500ms timeout expires, the `ninjaDelayedPromise` is resolved,
    which causes the execution of the matching `then` callback.
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺被设计用来处理异步操作，因此JavaScript引擎*总是*求助于异步处理，以使承诺行为可预测。引擎通过在事件循环当前步骤的所有代码执行之后执行`then`回调来实现这一点（我们将在[第13章](kindle_split_026.html#ch13)中再次探讨这究竟意味着什么）。因此，如果我们研究[图6.11](#ch06fig11)中的输出，我们会看到我们首先记录“代码结束”，然后记录`ninjaImmediatePromise`已被解析。最后，在500毫秒超时到期后，`ninjaDelayedPromise`被解析，这导致匹配的`then`回调执行。
- en: In this example, for the sake of simplicity, we’ve worked only with the rosy
    scenario in which everything goes great. But the real world isn’t all sunshine
    and rainbows, so let’s see how to deal with all sorts of crazy problems that can
    occur.
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，为了简单起见，我们只处理了一切顺利的情景。但现实世界并非总是阳光明媚，所以让我们看看如何处理可能出现的各种疯狂问题。
- en: 6.3.3\. Rejecting promises
  id: totrans-1275
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.3\. 拒绝承诺
- en: 'There are two ways of rejecting a promise: *explicitly*, by calling the passed-in
    `reject` method in the executor function of a promise, and *implicitly*, if during
    the handling of a promise, an unhandled exception occurs. Let’s start our exploration
    with the following listing.'
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种拒绝承诺的方式：*显式地*，通过在承诺执行函数中调用传入的 `reject` 方法，以及*隐式地*，如果在处理承诺期间发生未处理的异常。让我们从以下列表开始我们的探索。
- en: Listing 6.12\. Explicitly rejecting promises
  id: totrans-1277
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.12\. 显式拒绝承诺
- en: '![](152fig01_alt.jpg)'
  id: totrans-1278
  prefs: []
  type: TYPE_IMG
  zh: '![](152fig01_alt.jpg)'
- en: 'We can explicitly reject a promise, by calling the passed-in `reject` method:
    `reject("Explicitly reject a promise!")`. If a promise is rejected, when registering
    callbacks through the `then` method, the second, error, callback will always be
    invoked.'
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用传入的 `reject` 方法显式地拒绝一个承诺：`reject("显式拒绝一个承诺!")`。如果一个承诺被拒绝，当通过 `then`
    方法注册回调时，第二个，错误，回调总是会调用。
- en: In addition, we can use an alternative syntax for handling promise rejections,
    by using the built-in `catch` method, as shown in the following listing.
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以使用一种替代语法来处理承诺拒绝，通过使用内置的 `catch` 方法，如下所示。
- en: Listing 6.13\. Chaining a catch method
  id: totrans-1281
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.13\. 链式调用 catch 方法
- en: '![](153fig01_alt.jpg)'
  id: totrans-1282
  prefs: []
  type: TYPE_IMG
  zh: '![](153fig01_alt.jpg)'
- en: As [listing 6.13](#ch06ex13) shows, we can chain in the `catch` method after
    the `then` method, to also provide an error callback that will be invoked when
    a promise gets rejected. In this example, this is a matter of personal style.
    Both options work equally well, but later, when working with chains of promises,
    we’ll see an example in which chaining the `catch` method is useful.
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [列表 6.13](#ch06ex13) 所示，我们可以在 `then` 方法之后链式调用 `catch` 方法，以提供当承诺被拒绝时将被调用的错误回调。在这个例子中，这是一个个人风格的问题。两种选项都同样有效，但稍后，当处理承诺链时，我们将看到一个其中链式调用
    `catch` 方法是有用的例子。
- en: In addition to explicit rejection (via the `reject` call), a promise can also
    be rejected implicitly, if an exception occurs during its processing. Take a look
    at the following example.
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: 除了显式拒绝（通过 `reject` 调用）之外，如果在其处理过程中发生异常，承诺也可以被隐式拒绝。看看以下示例。
- en: Listing 6.14\. Exceptions implicitly reject a promise
  id: totrans-1285
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.14\. 异常隐式拒绝一个承诺
- en: '![](153fig02_alt.jpg)'
  id: totrans-1286
  prefs: []
  type: TYPE_IMG
  zh: '![](153fig02_alt.jpg)'
- en: Within the body of the promise executor, we try to increment `undeclaredVariable`,
    a variable that isn’t defined in our program. As expected, this results in an
    exception. Because there’s no `try-catch` statement within the body of the executor,
    this results in an implicit rejection of the current promise, and the `catch`
    callback is eventually invoked. In this situation, we could have just as easily
    supplied the second callback to the `then` method, and the end effect would be
    the same.
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
  zh: 在承诺执行函数的主体中，我们尝试增加 `undeclaredVariable`，这是一个在我们的程序中没有定义的变量。不出所料，这导致了一个异常。因为执行函数的主体中没有
    `try-catch` 语句，这导致当前承诺的隐式拒绝，最终调用 `catch` 回调。在这种情况下，我们也可以同样容易地向 `then` 方法提供第二个回调，最终效果将是相同的。
- en: This way of treating all problems that happen while working with promises in
    a uniform way is extremely handy. Regardless of how the promise was rejected,
    whether explicitly by calling the `reject` method or even implicitly, if an exception
    occurs, all errors and rejection reasons are directed to our rejection callback.
    This makes our lives as developers a little easier.
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: 以统一的方式处理在处理承诺时发生的所有问题的方式非常方便。无论承诺是如何被拒绝的，无论是通过显式地调用 `reject` 方法，甚至是隐式地，如果发生异常，所有错误和拒绝原因都会被导向我们的拒绝回调。这使得我们的开发生活变得稍微容易一些。
- en: Now that we understand how promises work, and how to schedule success and failure
    callbacks, let’s take a real-world scenario, getting JSON-formatted data from
    a server, and “promisify” it.
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了承诺是如何工作的，以及如何安排成功和失败回调，让我们来看一个现实场景，从服务器获取 JSON 格式的数据，并将其“承诺化”。
- en: 6.3.4\. Creating our first real-world promise
  id: totrans-1290
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.4\. 创建我们的第一个现实世界的承诺
- en: One of the most common asynchronous actions on the client is fetching data from
    the server. As such, this is an excellent little case study on the use of promises.
    For the underlying implementation, we’ll use the built-in `XMLHttpRequest` object.
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端，最常见的异步操作之一是从服务器获取数据。因此，这是一个关于承诺使用的极好的小案例研究。对于底层实现，我们将使用内置的 `XMLHttpRequest`
    对象。
- en: Listing 6.15\. Creating a getJSON promise
  id: totrans-1292
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.15\. 创建一个 getJSON 承诺
- en: '![](ch06ex15-0.jpg)'
  id: totrans-1293
  prefs: []
  type: TYPE_IMG
  zh: '![](ch06ex15-0.jpg)'
- en: '![](ch06ex15-1.jpg)'
  id: totrans-1294
  prefs: []
  type: TYPE_IMG
  zh: '![](ch06ex15-1.jpg)'
- en: '|  |'
  id: totrans-1295
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-1296
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Executing this example, and all subsequent examples that reuse this function,
    requires a running server. You can, for example, use [www.npmjs.com/package/http-server](http://www.npmjs.com/package/http-server).
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此示例以及所有重用此函数的后续示例需要一个正在运行的服务器。例如，你可以使用[www.npmjs.com/package/http-server](http://www.npmjs.com/package/http-server)。
- en: '|  |'
  id: totrans-1298
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Our goal is to create a `getJSON` function that returns a promise that will
    enable us to register success and failure callbacks for asynchronously getting
    JSON-formatted data from the server. For the underlying implementation, we use
    the built-in `XMLHttpRequest` object that offers two events: `onload` and `onerror`.
    The `onload` event is triggered when the browser receives a response from the
    server, and `onerror` is triggered when an error in communication happens. These
    event handlers will be called asynchronously by the browser, as they occur.'
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目的是创建一个`getJSON`函数，该函数返回一个承诺，使我们能够为从服务器异步获取JSON格式数据注册成功和失败回调。对于底层实现，我们使用内置的`XMLHttpRequest`对象，它提供了两个事件：`onload`和`onerror`。`onload`事件在浏览器从服务器收到响应时触发，而`onerror`在通信发生错误时触发。这些事件处理程序将按异步方式由浏览器调用，就像它们发生时一样。
- en: 'If an error in the communication happens, we definitely won’t be able to get
    our data from the server, so the honest thing to do is to reject our promise:'
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生通信错误，我们肯定无法从服务器获取数据，所以诚实的做法是拒绝我们的承诺：
- en: '[PRE126]'
  id: totrans-1301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: If we receive a response from the server, we have to analyze that response and
    consider the exact situation. Without going into too much detail, a server can
    respond with various things, but in this case, we care only that the response
    is successful (status 200). If it isn’t, again we reject the promise.
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们收到服务器的响应，我们必须分析该响应并考虑具体情况。不深入细节，服务器可以响应各种内容，但在这个案例中，我们只关心响应是否成功（状态200）。如果不是，我们再次拒绝承诺。
- en: Even if the server has successfully responded with data, this still doesn’t
    mean that we’re in the clear. Because our goal was to get JSON-formatted objects
    from the server, the JSON code could always have syntax errors. This is why, when
    calling the `JSON.parse` method, we surround the code with a `try-catch` statement.
    If an exception occurs while parsing the server response, we also reject the promise.
    With this, we’ve taken care of all bad scenarios that can happen.
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
  zh: 即使服务器已经成功响应了数据，这并不意味着我们已经安全。因为我们的目标是获取来自服务器的JSON格式对象，JSON代码可能总是存在语法错误。这就是为什么，在调用`JSON.parse`方法时，我们用`try-catch`语句包围代码。如果在解析服务器响应时发生异常，我们也会拒绝承诺。这样，我们就处理了所有可能发生的糟糕情况。
- en: 'If everything goes according to plan, and we successfully obtain our objects,
    we can safely resolve the promise. Finally, we can use our `getJSON` function
    to fetch ninjas from the server:'
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切按计划进行，并且我们成功获取了我们的对象，我们可以安全地解析承诺。最后，我们可以使用我们的`getJSON`函数从服务器获取忍者：
- en: '[PRE127]'
  id: totrans-1305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'In this case, we have three potential sources of errors: errors in establishing
    the communication between the server and the client, the server responding with
    unanticipated data (invalid response status), and invalid JSON code. But from
    the perspective of the code that uses the `getJSON` function, we don’t care about
    the specifics of error sources. We only supply a callback that gets triggered
    if everything goes okay and the data is properly received, and a callback that
    gets triggered if any error occurs. This makes our lives as developers so much
    easier.'
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们有三个潜在的错误来源：服务器和客户端之间建立通信时的错误、服务器响应了未预料到的数据（无效的响应状态），以及无效的JSON代码。但从使用`getJSON`函数的代码的角度来看，我们并不关心错误的具体来源。我们只提供一个回调，当一切顺利且数据正确接收时触发，以及一个回调，当发生任何错误时触发。这使得我们的开发生活变得更加容易。
- en: 'Now we’re going to take it up a notch and explore another big advantage of
    promises: their elegant composition. We’ll start by chaining several promises
    in a series of distinct steps.'
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将更进一步，探索承诺的另一个重大优势：它们的优雅组合。我们将从一系列不同的步骤中链式连接几个承诺开始。
- en: 6.3.5\. Chaining promises
  id: totrans-1308
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.5. 链式承诺
- en: You’ve already seen how handling a sequence of interdependent steps leads to
    the pyramid of doom, a deeply nested and difficult-to-maintain sequence of callbacks.
    Promises are a step toward solving that problem, because they have the ability
    to be chained.
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了如何处理一系列相互依赖的步骤会导致“末日金字塔”，这是一个深度嵌套且难以维护的回调序列。承诺（Promises）是解决该问题的第一步，因为它们具有链式调用的能力。
- en: Earlier in the chapter, you saw how, by using the `then` method on a promise,
    we can register a callback that will be executed if a promise is successfully
    resolved. What we didn’t tell you is that calling the `then` method also returns
    a new promise. So there’s nothing stopping us from chaining as many `then` methods
    as we want; see the following code.
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面，您看到通过在承诺上使用 `then` 方法，我们可以注册一个回调，如果承诺成功解决，则执行该回调。我们没有告诉您的是，调用 `then` 方法也会返回一个新的承诺。因此，我们没有任何阻止我们链入任意数量的
    `then` 方法；请参见以下代码。
- en: Listing 6.16\. Chaining promises with then
  id: totrans-1311
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.16\. 使用 then 链接承诺
- en: '![](156fig01_alt.jpg)'
  id: totrans-1312
  prefs: []
  type: TYPE_IMG
  zh: '![图片](156fig01_alt.jpg)'
- en: 'This creates a sequence of promises that will be, if everything goes according
    to plan, resolved one after another. First, we use the `getJSON("data/ninjas.json")`
    method to fetch a list of ninjas from the file on the server. After we receive
    that list, we take the information about the first ninja, and we request a list
    of missions the ninja is assigned to: `getJSON(ninjas[0].missionsUrl)`. Later,
    when these missions come in, we make yet another request for the details of the
    first mission: `getJSON(missions[0].details-Url)`. Finally, we log the details
    of the mission.'
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一系列承诺，如果一切按计划进行，将依次解决。首先，我们使用 `getJSON("data/ninjas.json")` 方法从服务器上的文件获取忍者列表。收到该列表后，我们获取第一个忍者的信息，并请求该忍者分配的任务列表：`getJSON(ninjas[0].missionsUrl)`。稍后，当这些任务到来时，我们再次请求第一个任务的详细信息：`getJSON(missions[0].details-Url)`。最后，我们记录任务的详细信息。
- en: Writing such code using standard callbacks would result in a deeply nested sequence
    of callbacks. Identifying the exact sequence of steps wouldn’t be easy, and God
    forbid we decide to add in an extra step somewhere in the middle.
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标准回调编写此类代码会导致深度嵌套的回调序列。确定确切的步骤顺序可能不容易，而且我们绝对不希望在中途添加额外的步骤。
- en: Catching errors in chained promises
  id: totrans-1315
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 链接承诺中的错误捕获
- en: 'When dealing with sequences of asynchronous steps, an error can occur in any
    step. We already know that we either can provide a second, error callback to the
    `then` call, or can chain in a `catch` call that takes an error callback. When
    we care about only the success/failure of the entire sequence of steps, supplying
    each step with special error handling might be tedious. So, as shown in [listing
    6.16](#ch06ex16), we can take advantage of the `catch` method that you saw earlier:'
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理一系列异步步骤时，任何步骤都可能发生错误。我们已经知道，我们可以在 `then` 调用中提供一个第二个错误回调，或者可以链入一个带有错误回调的 `catch`
    调用。当我们只关心整个步骤序列的成功/失败时，为每个步骤提供特殊错误处理可能很繁琐。所以，如 [列表 6.16](#ch06ex16) 所示，我们可以利用之前看到的
    `catch` 方法：
- en: '[PRE128]'
  id: totrans-1317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: If a failure occurs in any of the previous promises, the `catch` method catches
    it. If no error occurs, the program flow continues through it, unobstructed.
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
  zh: 如果之前的任何承诺发生失败，`catch` 方法将捕获它。如果没有发生错误，程序流程将继续通过它，不受阻碍。
- en: Dealing with a sequence of steps is much nicer with promises than with regular
    callbacks, wouldn’t you agree? But it’s still not as elegant as it could be. We’ll
    get to that soon, but first let’s see how to use promises to take care of parallel
    asynchronous steps.
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
  zh: 与常规回调相比，使用承诺处理一系列步骤要方便得多，不是吗？但它仍然不如它本可以的那样优雅。我们很快就会看到这一点，但首先让我们看看如何使用承诺来处理并行异步步骤。
- en: 6.3.6\. Waiting for a number of promises
  id: totrans-1320
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.6\. 等待多个承诺
- en: In addition to helping us deal with sequences of interdependent, asynchronous
    steps, promises significantly reduce the burden of waiting for several independent
    asynchronous tasks. Let’s revisit our example in which we want to, in parallel,
    gather information about the ninjas at our disposal, the intricacies of the plan,
    and the map of the location where the plan will be set in motion. With promises,
    this is as simple as shown in the following listing.
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
  zh: 除了帮助我们处理一系列相互依赖的异步步骤外，承诺还显著减轻了等待多个独立异步任务的负担。让我们回顾一下我们的例子，其中我们想要并行收集关于我们可用的忍者的信息、计划的复杂性以及计划将启动的位置的地图。使用承诺，这就像以下列表中所示的那样简单。
- en: Listing 6.17\. Waiting for a number of promises with Promise.all
  id: totrans-1322
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.17\. 使用 Promise.all 等待多个承诺
- en: '![](157fig01_alt.jpg)'
  id: totrans-1323
  prefs: []
  type: TYPE_IMG
  zh: '![图片](157fig01_alt.jpg)'
- en: As you can see, we don’t have to care about the order in which tasks are executed,
    and whether some of them have finished, while others didn’t. We state that we
    want to wait for a number of promises by using the built-in `Promise.all` method.
    This method takes in an array of promises and creates a *new* promise that successfully
    resolves when all passed-in promises resolve, and rejects if even one of the promises
    fails. The succeed callback receives an array of succeed values, one for each
    of the passed-in promises, in order. Take a minute to appreciate the elegance
    of code that processes multiple parallel asynchronous tasks with promises.
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们不必关心任务执行的顺序，也不必关心其中一些任务是否已完成，而另一些任务尚未完成。我们通过使用内置的 `Promise.all` 方法来声明我们想要等待一定数量的承诺。此方法接受一个承诺数组，并创建一个*新*的承诺，当所有传入的承诺都成功解决时，该承诺成功解决，如果任何一个承诺失败，则拒绝。成功回调接收一个成功值数组，每个传入的承诺一个，按顺序排列。花一分钟来欣赏使用承诺处理多个并行异步任务的代码的优雅性。
- en: The `Promise.all` method waits for all promises in a list. But at times we have
    numerous promises, but we care only about the first one that succeeds (or fails).
    Meet the `Promise.race` method.
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise.all` 方法等待列表中的所有承诺。但有时我们有许多承诺，但我们只关心第一个成功（或失败）的承诺。认识一下 `Promise.race`
    方法。'
- en: Racing promises
  id: totrans-1326
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 竞赛承诺
- en: Imagine that we have a group of ninjas at our disposal, and that we want to
    give an assignment to the first ninja who answers our call. When dealing with
    promises, we can write something like the following listing.
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一组可供我们使用的忍者，并且我们想要将任务分配给第一个回应我们召唤的忍者。在处理承诺时，我们可以编写如下所示的内容。
- en: Listing 6.18\. Racing promises with Promise.race
  id: totrans-1328
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.18\. 使用 Promise.race 竞赛承诺
- en: '[PRE129]'
  id: totrans-1329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: It’s simple as that. There’s no need for manually tracking everything. We use
    the `Promise.race` method to take an array of promises and return a completely
    *new* promise that resolves or rejects as soon as the first of the promises resolves
    or rejects.
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: 如此简单。无需手动跟踪一切。我们使用 `Promise.race` 方法接受一个承诺数组，并返回一个完全*新*的承诺，该承诺在第一个承诺解决或拒绝时立即解决或拒绝。
- en: So far you’ve seen how promises work, and how we can use them to greatly simplify
    dealing with a series of asynchronous steps, either in series or in parallel.
    Although the improvements, when compared to plain old callbacks in terms of error
    handling and code elegance, are great, promisified code still isn’t on the same
    level of elegance as simple synchronous code. In the next section, the two big
    concepts that we’ve introduced in this chapter, *generators* and *promises*, come
    together to provide the simplicity of synchronous code with the nonblocking nature
    of asynchronous code.
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到了承诺是如何工作的，以及我们如何使用它们来极大地简化处理一系列异步步骤，无论是顺序还是并行。虽然与普通的回调相比，在错误处理和代码优雅性方面有所改进，但承诺化的代码仍然没有达到简单同步代码的优雅水平。在下一节中，我们将介绍本章中引入的两个主要概念，*生成器*和*承诺*，它们结合在一起提供了同步代码的简单性和异步代码的非阻塞特性。
- en: 6.4\. Combining generators and promises
  id: totrans-1332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4\. 结合生成器和承诺
- en: In this section, we’ll combine generators (and their capability to pause and
    resume their execution) with promises, in order to achieve more elegant asynchronous
    code. We’ll use the example of a functionality that enables users to get details
    of the highest-rated mission done by the most popular ninja. The data representing
    the ninjas, the summaries of their missions, as well as the details of the missions
    are stored on a remote server, encoded in JSON.
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将结合生成器（及其暂停和恢复执行的能力）与承诺，以实现更优雅的异步代码。我们将使用一个功能示例，该功能允许用户获取最受欢迎的忍者完成的最高评级任务的详细信息。代表忍者的数据、他们任务的摘要以及任务详情都存储在远程服务器上，编码为
    JSON 格式。
- en: 'All of these subtasks are long-running and mutually dependent. If we were to
    implement them in a synchronous fashion, we’d get the following straightforward
    code:'
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些子任务都是长时间运行且相互依赖的。如果我们以同步方式实现它们，我们会得到以下简单的代码：
- en: '[PRE130]'
  id: totrans-1335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Although this code is great for its simplicity and error handling, it blocks
    the UI, which results in unhappy users. Ideally, we’d like to change this code
    so that no blocking occurs during a long-running task. One way of doing this is
    by combining generators and promises.
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这段代码在简单性和错误处理方面很出色，但它会阻塞用户界面，导致用户不满。理想情况下，我们希望修改此代码，以便在长时间运行的任务期间不发生阻塞。实现这一目标的一种方法是将生成器和承诺结合起来。
- en: As we know, yielding from a generator suspends the execution of the generator
    without blocking. To wake up the generator and continue its execution, we have
    to call the `next` method on the generator’s iterator. Promises, on the other
    hand, allow us to specify a callback that will be triggered in case we were able
    to obtain the promised value, and a callback that will be triggered in case an
    error has occurred.
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，从生成器中产生会暂停生成器的执行，但不会阻塞。为了唤醒生成器并继续其执行，我们必须在生成器的迭代器上调用 `next` 方法。另一方面，承诺允许我们指定一个回调，当能够获取承诺的值时将被触发，以及一个回调，当发生错误时将被触发。
- en: 'The idea, then, is to combine generators and promises in the following way:
    We put the code that uses asynchronous tasks in a generator, and we execute that
    generator function. When we reach a point in the generator execution that calls
    an asynchronous task, we create a promise that represents the value of that asynchronous
    task. Because we have no idea when that promise will be resolved (or even if it
    will be resolved), at this point of generator execution, we yield from the generator,
    so that we don’t cause blocking. After a while, when the promise gets settled,
    we continue the execution of our generator by calling the iterator’s `next` method.
    We do this as many times as necessary. See the following listing for a practical
    example.'
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的想法是将生成器和承诺以以下方式结合：我们将使用异步任务的代码放在生成器中，并执行该生成器函数。当我们到达生成器执行中调用异步任务的位置时，我们创建一个代表该异步任务值的承诺。因为我们不知道这个承诺何时会解决（甚至是否会被解决），在这个生成器执行点，我们从生成器中产生，这样我们就不会造成阻塞。过了一段时间，当承诺得到解决后，我们通过调用迭代器的
    `next` 方法继续生成器的执行。我们根据需要这样做多次。请参见以下列表以获取实际示例。
- en: Listing 6.19\. Combining generators and promises
  id: totrans-1339
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.19\. 结合生成器和承诺
- en: '![](ch06ex19-0.jpg)'
  id: totrans-1340
  prefs: []
  type: TYPE_IMG
  zh: '![](ch06ex19-0.jpg)'
- en: '![](ch06ex19-1.jpg)'
  id: totrans-1341
  prefs: []
  type: TYPE_IMG
  zh: '![](ch06ex19-1.jpg)'
- en: The `async` function takes a generator, calls it, and creates an iterator that
    will be used to resume the generator execution. Inside the `async` function, we
    declare a `handle` function that handles one return value from the generator—one
    “iteration” of our iterator. If the generator result is a promise that gets resolved
    successfully, we use the iterator’s `next` method to send the promised value back
    to the generator and resume the generator’s execution. If an error occurs and
    the promise gets rejected, we throw that error to the generator by using the iterator’s
    `throw` method (told you it would come in handy). We keep doing this until the
    generator says it’s done.
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
  zh: '`async` 函数接受一个生成器，调用它，并创建一个迭代器，该迭代器将用于恢复生成器的执行。在 `async` 函数内部，我们声明一个 `handle`
    函数，该函数处理生成器的一个返回值——迭代器的一次“迭代”。如果生成器结果是一个成功解决的承诺，我们使用迭代器的 `next` 方法将承诺的值发送回生成器并恢复生成器的执行。如果发生错误并且承诺被拒绝，我们通过迭代器的
    `throw` 方法将错误抛给生成器（告诉过你会派上用场）。我们一直这样做，直到生成器表示它已完成。'
- en: '|  |'
  id: totrans-1343
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-1344
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: This is a rough sketch, a minimum amount of code needed to combine generators
    and promises. We don’t recommend that you use this code in production.
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个粗略的草图，结合生成器和承诺所需的最小代码量。我们不推荐在生产环境中使用此代码。
- en: '|  |'
  id: totrans-1346
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Now let’s take a closer look at the generator. On the first invocation of the
    iterator’s `next` method, the generator executes up to the first `getJSON("data/ninjas.json")`
    call. This call creates a promise that will eventually contain the list of information
    about our `ninjas`. Because this value is fetched asynchronously, we have no idea
    how much time it will take the browser to get it. But we know one thing: We don’t
    want to block the application execution while we’re waiting. For this reason,
    at this moment of execution, the generator yields control, which pauses the generator,
    and returns the control flow to the invocation of the `handle` function. Because
    the yielded value is a `getJSON` promise, in the `handle` function, by using the
    `then` and `catch` methods of the promise, we register a success and an error
    callback, and continue execution. With this, the control flow leaves the execution
    of the `handle` function and the body of the `async` function, and continues after
    the call to the `async` function (in our case, there’s no more code after, so
    it idles). During this time, our generator function patiently waits suspended,
    without blocking the program execution.'
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更仔细地看看生成器。在迭代器的`next`方法第一次被调用时，生成器会执行到第一个`getJSON("data/ninjas.json")`调用。这个调用创建了一个最终将包含我们`ninjas`信息列表的承诺。因为这个值是异步获取的，所以我们不知道浏览器获取它需要多少时间。但我们知道一件事：我们不希望在等待时阻塞应用程序的执行。正因为如此，在执行的这个时刻，生成器交出控制权，暂停生成器，并将控制流返回到`handle`函数的调用。因为产生的值是一个`getJSON`承诺，在`handle`函数中，通过使用承诺的`then`和`catch`方法，我们注册了一个成功和错误回调，并继续执行。有了这个，控制流离开了`handle`函数的执行和`async`函数的主体，并在调用`async`函数之后继续（在我们的例子中，之后没有更多的代码，所以它处于空闲状态）。在这段时间里，我们的生成器函数耐心地等待挂起，不会阻塞程序执行。
- en: Much, much later, when the browser receives a response (either a positive or
    a negative one), one of the promise callbacks is invoked. If the promise was resolved
    successfully, the success callback is invoked, which in turn causes the execution
    of the iterator’s `next` method, which asks the generator for another value. This
    brings back the generator from suspension and sends to it the value passed in
    by the callback. This means that we reenter the body of our generator, after the
    first `yield` expression, whose value becomes the `ninjas` list that was asynchronously
    fetched from the server. The execution of the generator function continues, and
    the value is assigned to the `plan` variable.
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: 在很久以后，当浏览器收到响应（无论是积极的还是消极的）时，其中一个承诺回调会被调用。如果承诺成功解决，则调用成功回调，这反过来又会导致迭代器的`next`方法的执行，该方法要求生成器提供另一个值。这意味着我们在第一次`yield`表达式之后重新进入生成器的主体，其值成为从服务器异步获取的`ninjas`列表。生成器函数的执行继续，并将值分配给`plan`变量。
- en: In the next line of the generator, we use some of the obtained data, `ninjas[0].missionUrl`,
    to make another `getJSON` call that creates another promise that should eventually
    contain a list of missions done by the most popular ninja. Again, because this
    is an asynchronous task, we have no idea how long it’s going to take, so we again
    yield the execution and repeat the whole process.
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成器的下一行中，我们使用一些获取到的数据，`ninjas[0].missionUrl`，来发起另一个`getJSON`调用，该调用创建另一个承诺，该承诺最终应包含最受欢迎的忍者完成的任务列表。同样，由于这是一个异步任务，我们不知道它将花费多长时间，所以我们再次交出执行并重复整个过程。
- en: This process is repeated as long as there are asynchronous tasks in the generator.
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程会一直重复，直到生成器中还有异步任务。
- en: 'This was a tad on the complex side, but we like this example because it combines
    a lot of things that you’ve learned so far:'
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点复杂，但我们喜欢这个例子，因为它结合了你迄今为止学到的大部分内容：
- en: '***Functions as first-class objects—*** We send a function as an argument to
    the `async` function.'
  id: totrans-1352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***函数作为一等对象—*** 我们将一个函数作为参数传递给`async`函数。'
- en: '***Generator functions—*** We use their ability to suspend and resume execution.'
  id: totrans-1353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***生成器函数—*** 我们使用它们暂停和恢复执行的能力。'
- en: '***Promises—*** They help us deal with asynchronous code.'
  id: totrans-1354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***承诺—*** 它们帮助我们处理异步代码。'
- en: '***Callbacks—*** We register success and failure callbacks on our promises.'
  id: totrans-1355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***回调—*** 我们在我们的承诺上注册成功和失败回调。'
- en: '***Arrow functions—*** Because of their simplicity, for callbacks we use arrow
    functions.'
  id: totrans-1356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***箭头函数—*** 由于它们的简单性，对于回调我们使用箭头函数。'
- en: '***Closures—*** The iterator, through which we control the generator, is created
    in the `async` function, and we access it, through closures, in the promise callbacks.'
  id: totrans-1357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***闭包——*** 通过`async`函数创建的迭代器，用于控制生成器，我们通过闭包在承诺回调中访问它。'
- en: 'Now that we’ve gone through the whole process, let’s take a minute to appreciate
    how much more elegant the code that implements our business logic is. Consider
    this:'
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了整个过程，让我们花一分钟来欣赏一下实现我们业务逻辑的代码是多么的优雅。考虑以下内容：
- en: '[PRE131]'
  id: totrans-1359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Instead of mixed control-flow and error handling, and slightly confusing code,
    we end up with something like this:'
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: 与混合控制流和错误处理以及稍微有些混乱的代码不同，我们最终得到如下内容：
- en: '[PRE132]'
  id: totrans-1361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: This end result combines the advantages of synchronous and asynchronous code.
    From synchronous code, we have the ease of understanding, and the ability to use
    all standard control-flow and exception-handling mechanisms such as loops and
    `try-catch` statements. From asynchronous code, we get the nonblocking nature;
    the execution of our application isn’t blocked while waiting for long-running
    asynchronous tasks.
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: 这种最终结果结合了同步和异步代码的优点。从同步代码中，我们有易于理解，以及使用所有标准控制流和异常处理机制的能力，如循环和`try-catch`语句。从异步代码中，我们得到非阻塞的特性；在等待长时间运行的异步任务时，我们的应用程序的执行不会被阻塞。
- en: 6.4.1\. Looking forward—the async function
  id: totrans-1363
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.4.1. 展望——异步函数
- en: Notice that we still had to write some boilerplate code; we had to develop an
    `async` function that takes care of handling promises and requesting values from
    the generator. Although we can write this function only once and then reuse it
    throughout our code, it would be even nicer if we didn’t have to think about it.
    The people in charge of JavaScript are well aware of the usefulness of the combination
    of generators and promises, and they want to make our lives even easier by building
    in direct language support for mixing generators and promises.
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们仍然不得不编写一些样板代码；我们必须开发一个`async`函数来处理承诺并从生成器请求值。虽然我们只能编写这个函数一次，然后在我们的代码中重用它，但如果我们可以不必考虑它，那就更好了。JavaScript的负责人非常清楚生成器和承诺结合的有用性，他们希望通过内置直接语言支持来混合生成器和承诺，从而使我们的生活更加轻松。
- en: 'For these situations, the current plan is to include two new keywords, `async`
    and `await`, that would take care of this boilerplate code. Soon, we’ll be able
    to write something like this:'
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些情况，目前的计划是包含两个新的关键字`async`和`await`，将处理这些样板代码。不久，我们将能够写出如下内容：
- en: '[PRE133]'
  id: totrans-1366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: We use the `async` keyword in front of the function keyword to specify that
    this function relies on asynchronous values, and at every place where we call
    an asynchronous task, we place the `await` keyword that says to the JavaScript
    engine, please wait for this result without blocking. In the background, everything
    happens as we’ve discussed previously throughout the chapter, but now we don’t
    need to worry about it.
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在函数关键字前使用`async`关键字来指定该函数依赖于异步值，在调用每个异步任务的地方，我们放置`await`关键字，告诉JavaScript引擎请等待此结果而不阻塞。在后台，一切正如我们在本章前面讨论的那样发生，但现在我们不需要担心它。
- en: '|  |'
  id: totrans-1368
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-1369
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Async functions will appear in the next installment of JavaScript. Currently
    no browser supports it, but you can use transpilers such as Babel or Traceur if
    you wish to use async in your code today.
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: 异步函数将在JavaScript的下一部分中介绍。目前没有浏览器支持它，但如果你想在代码中使用异步，可以使用Babel或Traceur等转换器。
- en: '|  |'
  id: totrans-1371
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 6.5\. Summary
  id: totrans-1372
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5. 摘要
- en: Generators are functions that generate sequences of values—not all at once,
    but on a per request basis.
  id: totrans-1373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器是生成值序列的函数——不是一次性生成，而是在每次请求的基础上生成。
- en: Unlike standard functions, generators can suspend and resume their execution.
    After a generator has generated a value, it suspends its execution without blocking
    the main thread and patiently waits for the next request.
  id: totrans-1374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与标准函数不同，生成器可以暂停和恢复它们的执行。生成器生成一个值后，它会暂停执行而不阻塞主线程，并耐心地等待下一个请求。
- en: A generator is declared by putting an asterisk (`*`) after the function keyword.
    Within the body of the generator, we can use the new `yield` keyword that yields
    a value and suspends the execution of the generator. If we want to yield to another
    generator, we use the `yield*` operator.
  id: totrans-1375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器通过在函数关键字后放置一个星号（`*`）来声明。在生成器的主体中，我们可以使用新的`yield`关键字，它产生一个值并暂停生成器的执行。如果我们想向另一个生成器产生值，我们使用`yield*`运算符。
- en: Calling a generator creates an iterator object through which we control the
    execution of the generator. We request new values from the generator by using
    the iterator’s `next` method, and we can even throw exceptions into the generator
    by calling the iterator’s `throw` method. In addition, the `next` method can be
    used to send in values to the generator.
  id: totrans-1376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用一个生成器会通过一个迭代器对象创建一个迭代器，我们可以通过这个迭代器控制生成器的执行。我们通过使用迭代器的 `next` 方法从生成器请求新值，甚至可以通过调用迭代器的
    `throw` 方法向生成器抛出异常。此外，`next` 方法还可以用来向生成器发送值。
- en: A promise is a placeholder for the results of a computation; it’s a guarantee
    that eventually we’ll know the result of the computation, most often an asynchronous
    computation. A promise can either succeed or fail, and after it has done so, there
    will be no more changes.
  id: totrans-1377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 承诺是计算结果的占位符；它保证我们最终会知道计算的结果，通常是异步计算的结果。承诺可以成功或失败，一旦完成，就不会再有变化。
- en: Promises significantly simplify our dealings with asynchronous tasks. We can
    easily work with sequences of interdependent asynchronous steps by using the `then`
    method to chain promises. Parallel handling of multiple asynchronous steps is
    also greatly simplified; we use the `Promise.all` method.
  id: totrans-1378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 承诺显著简化了我们处理异步任务的方式。我们可以通过使用 `then` 方法链承诺来轻松地处理一系列相互依赖的异步步骤。并行处理多个异步步骤也大大简化了；我们使用
    `Promise.all` 方法。
- en: We can combine generators and promises to deal with asynchronous tasks with
    the simplicity of synchronous code.
  id: totrans-1379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将生成器和承诺结合使用，以同步代码的简单性处理异步任务。
- en: 6.6\. Exercises
  id: totrans-1380
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.6. 练习
- en: '**1**'
  id: totrans-1381
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**'
- en: ''
  id: totrans-1382
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: After running the following code, what are the values of variables `a1` to `a4`?
  id: totrans-1383
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 运行以下代码后，变量 `a1` 到 `a4` 的值是什么？
- en: ''
  id: totrans-1384
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-1385
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '**2**'
  id: totrans-1386
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**'
- en: ''
  id: totrans-1387
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'What’s the content of the `ninjas` array after running the following code?
    (Hint: think about how the `for-of` loop can be implemented with a `while` loop.)'
  id: totrans-1388
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 运行以下代码后，`ninjas` 数组的内文是什么？（提示：考虑如何使用 `while` 循环实现 `for-of` 循环。）
- en: ''
  id: totrans-1389
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-1390
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '**3**'
  id: totrans-1391
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**'
- en: ''
  id: totrans-1392
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What are the values of variables `a1` and `a2`, after running the following
    code?
  id: totrans-1393
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 运行以下代码后，变量 `a1` 和 `a2` 的值是什么？
- en: ''
  id: totrans-1394
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-1395
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '**4**'
  id: totrans-1396
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**'
- en: ''
  id: totrans-1397
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What’s the output of the following code?
  id: totrans-1398
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: ''
  id: totrans-1399
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-1400
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '**5**'
  id: totrans-1401
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**5**'
- en: ''
  id: totrans-1402
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What’s the output of the following code?
  id: totrans-1403
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: ''
  id: totrans-1404
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-1405
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE138]'
