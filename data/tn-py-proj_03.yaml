- en: '2 The crow’s nest: Working with strings'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 鹰巢：处理字符串
- en: '| Avast, you corny-faced gollumpus! Ye are barrelman for this watch. D’ye ken
    what I mean, ye addle-pated blunderbuss?! Ah, landlubber ye be! OK, then, you
    are the lookout in the crow’s nest--the little bucket attached to the top of a
    mast of a sailing ship. Your job is to keep a lookout for interesting or dangerous
    things, like a ship to plunder or an iceberg to avoid. When you see something
    like a narwhal, you are supposed to cry out, “Ahoy, Captain, *a narwhal* off the
    larboard bow!” If you see an octopus, you’ll shout “Ahoy, Captain, *an octopus*
    off the larboard bow!” (We’ll assume everything is “off the larboard bow” for
    this exercise. It’s a great place for things to be.) | ![](../Images/2-unnumb-1.png)
    |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '| 警告，你那愚蠢的圆脸小丑！你是这个岗哨的桶匠。你懂我的意思吗，你这笨拙的傻瓜？！啊，你是陆地上的家伙！好吧，那么，你就是船上的瞭望员--系在帆船桅杆顶部的那个小桶。你的任务是观察有趣或危险的事物，比如可以掠夺的船或需要避免的冰山。当你看到像narwhal这样的东西时，你应该大声喊出，“Ahoy，船长，*a
    narwhal* 在左舷前方！”如果你看到章鱼，你会喊出“Ahoy，船长，*an octopus* 在左舷前方！”（我们将假设这个练习中一切都是“在左舷前方”。这是一个很好的地方。）
    | ![](../Images/2-unnumb-1.png) |'
- en: From this point on, each chapter will present a coding challenge that you should
    complete on your own. I will discuss the key ideas you’ll need to solve the problems
    as well as how to use the provided tests to determine when your program is correct.
    You should have a copy of the Git repository locally (see the setup instructions
    in the book’s introduction), and you should write each program in that chapter’s
    directory. For example, this chapter’s program should be written in the 02_crowsnest
    directory, where the tests for the program live.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，每一章都将提出一个编码挑战，你应该自己完成。我将讨论解决这些问题所需的关键思想，以及如何使用提供的测试来确定程序是否正确。你应该在本地有一个Git仓库的副本（参见书中引言中的设置说明），你应该在该章节的目录中编写每个程序。例如，本章的程序应该编写在02_crowsnest目录中，那里有程序的测试。
- en: In this chapter, we’re going to start working with strings. By the end, you
    will be able to
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始使用字符串。到本章结束时，你将能够
- en: Create a program that accepts a positional argument and produces usage documentation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个程序，接受一个位置参数并生成用法文档
- en: Create a new output string depending on the inputs to the program
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据程序的输入创建一个新的输出字符串
- en: Run a test suite
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行测试套件
- en: Your program should be called crowsnest.py. It will accept a single positional
    argument and will print the given argument inside the “Ahoy” bit, along with the
    word “a” or “an” depending on whether the argument starts with a consonant or
    a vowel.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你的程序应该命名为crowsnest.py。它将接受一个位置参数，并将给定的参数打印在“Ahoy”部分中，根据参数是否以辅音或元音开头，打印“a”或“an”。
- en: 'That is, if given “narwhal,” it should do this:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，如果输入“narwhal”，它应该这样做：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: And if given “octopus,”
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入“octopus”，
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This means you’re going to need to write a program that accepts some input on
    the command line, decides on the proper article (“a” or “an”) for the input, and
    prints out a string that puts those two values into the “Ahoy” phrase.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你需要编写一个程序，该程序可以在命令行接受一些输入，确定适当的冠词（“a”或“an”）用于输入，并打印出一个字符串，将这两个值放入“Ahoy”短语中。
- en: 2.1 Getting started
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 开始
- en: You’re probably ready to start writing the program! Well, hold on just a minute
    longer, ye duke of limbs. We need to discuss how you can use the tests to know
    when your program is working and how you might get started programming.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经准备好开始编写程序了！好吧，再等一会儿，四肢公爵。我们需要讨论你如何使用测试来知道你的程序何时在运行，以及你可能如何开始编程。
- en: 2.1.1 How to use the tests
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.1 如何使用测试
- en: “The greatest teacher, failure is.”
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: “最大的老师，失败是。”
- en: --Yoda
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: --Yoda
- en: 'In the code repository, I’ve included tests that will guide you in the writing
    of your program. Before you even write the first line of code, I’d like you to
    run the tests so you can look at the first failed test:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码仓库中，我包括了将指导你编写程序的测试。在你写下第一行代码之前，我希望你运行这些测试，这样你可以查看第一个失败的测试：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Instead of `make` `test` you could also run `pytest` `-xv` `test.py`. Among
    the output, you’ll see this line:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以用`pytest` `-xv` `test.py`来代替`make` `test`。在输出中，你会看到这样一行：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ① This test failed. There are more tests after this, but testing stops here
    because of the -x flag to pytest.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ① 这个测试失败了。在此之后还有更多的测试，但由于pytest的-x标志，测试在这里停止。
- en: You’ll also see lots of other output trying to convince you that the expected
    file, crowsnest.py, does not exist. Learning to read the test output is a skill
    in itself--it takes quite a bit of practice, so try not to feel overwhelmed. In
    my terminal (iTerm on a Mac), the output from `pytest` shows colors and bold print
    to highlight key failures. The text in bold, red letters is usually where I start,
    but your terminal may behave differently.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会看到很多其他输出，试图说服你预期的文件crowsnest.py不存在。学习阅读测试输出本身就是一个技能——它需要大量的练习，所以尽量不要感到不知所措。在我的终端（Mac上的iTerm），`pytest`的输出显示颜色和粗体打印以突出关键失败。粗体红色文字通常是我开始的地方，但你的终端可能会有不同的表现。
- en: Let’s take a gander at the output. It does look at bit daunting at first, but
    you’ll get used to reading the messages and finding your errors.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看输出。一开始可能看起来有点令人畏惧，但你会习惯于阅读消息并找到你的错误。
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ① This is the actual code inside test.py that is running. It’s a function called
    test_exists().
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ① 这是test.py中实际运行的代码。它是一个名为test_exists()的函数。
- en: ② The “>” at the beginning of this line indicates this is the line where the
    error starts. The test is checking if there is a file called crowsnest.py. If
    you haven’t created it, this will fail as expected.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ② 这行开头的大于号“>”表示错误开始于此行。测试正在检查是否存在名为crowsnest.py的文件。如果你还没有创建它，预期它会按预期失败。
- en: ③ The “E” at the beginning of this line is the “Error” you should read. It’s
    very difficult to understand what the test is trying to tell you, but essentially
    the ./crowsnest.py file does not exist.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 这行开头的大写字母“E”是你要阅读的“错误”。理解测试试图告诉你什么非常困难，但本质上./crowsnest.py文件不存在。
- en: ④ This warns that no more tests will run after the one failure. This is because
    we ran it with the flag to stop testing at the first failure.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 这警告说，在第一次失败之后将不再运行更多测试。这是因为我们使用带有停止在第一次失败时停止测试的标志来运行它。
- en: The first test for every program in the book checks that the expected file exists,
    so let’s create it!
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 书中每个程序的第一个测试都检查预期的文件是否存在，所以让我们创建它！
- en: 2.1.2 Creating programs with new.py
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.2 使用new.py创建程序
- en: In order to pass the first test, you need to create a file called crowsnest.py
    inside the 02_crowsnest directory where test.py is located. While it’s perfectly
    fine to start writing from scratch, I suggest you use the new.py program to print
    some useful boilerplate code that you’ll need in every exercise.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过第一个测试，你需要在test.py所在的02_crowsnest目录内创建一个名为crowsnest.py的文件。虽然从头开始编写是完全可行的，但我建议你使用new.py程序打印一些你将在每个练习中需要的有用样板代码。
- en: From the top level of the repository, you can run the following command to create
    the new program.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 从存储库的顶层，你可以运行以下命令来创建新的程序。
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you don’t want to use new.py, you can copy the template/template.py program:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想使用new.py，你可以复制template/template.py程序：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You should now have the outline of a working program that accepts command-line
    arguments. If you run your new crowsnest.py with no arguments, it will print a
    short usage statement like the following (notice how “usage” is the first word
    of the output):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该有一个工作程序的轮廓，该程序可以接受命令行参数。如果你不带参数运行你的new crowsnest.py，它将打印出如下简短的用法说明（注意“用法”是输出的第一个单词）：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Run it with `./crowsnest.py` `--help`. It will print a longer help message too.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 用`./crowsnest.py` `--help`运行它。它还会打印出更长的帮助信息。
- en: Note Those are not the correct parameters for our program, just the default
    examples supplied by new.py. You will need to modify them to suit this program.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：这些不是我们程序的正确参数，只是new.py提供的默认示例。你需要修改它们以适应这个程序。
- en: 2.1.3 Write, test, repeat
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.3 编写、测试、重复
- en: You just created the program, so you ought to be able to pass the first test.
    The cycle I hope you’ll develop is to write a very small amount of code--literally
    one or two lines at most--and then run the program or the tests to see how you’re
    doing.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚创建了程序，所以你应该能够通过第一个测试。我希望你将发展出的循环是写一小段代码——最多一或两行——然后运行程序或测试以查看你的进度。
- en: 'Let’s run the tests again:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次运行测试：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ① The expected file exists, so this test passes.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ① 预期的文件存在，所以这个测试通过了。
- en: ② The program will respond to -h and --help. The fact that the help is actually
    incorrect is not important at this point. The tests are only checking that you
    seem to have the outline of a program that will run and process the help flags.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ② 程序将响应-h和--help。帮助信息实际上是不正确的并不重要。测试只是在检查你似乎有一个可以运行并处理帮助标志的程序轮廓。
- en: ③ The test_consonant() test is failing. That’s OK! We haven’t even started writing
    the actual program, but at least we have a place to start.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ③ `test_consonant()` 测试失败。这没关系！我们甚至还没有开始编写实际的程序，但至少我们有一个开始的地方。
- en: 'As you can see, creating a new program with new.py will make you pass the first
    *two* tests:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，创建一个新的程序`new.py`将使你通过前两个测试：
- en: Does the program exist? Yes, you just created it.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序存在吗？是的，你刚刚创建了它。
- en: Does the program print a help message when you ask for help? Yes, you ran it
    above with no arguments and the `--help` flag, and you saw that it will produce
    help messages.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你请求帮助时，程序会打印帮助信息吗？是的，你之前没有参数地运行了它，并使用了`--help`标志，你看到了它会生成帮助信息。
- en: Now you have a working program that accepts some arguments (but not the right
    ones). Next you need to make your program accept the “narwhal” or “octopus” value
    that needs to be announced. We’ll use command-line arguments to do that.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有一个可以接受一些参数（但不是正确的参数）的工作程序。接下来，你需要让你的程序接受需要宣布的“独角兽”或“章鱼”值。我们将使用命令行参数来实现这一点。
- en: 2.1.4 Defining your arguments
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.4 定义你的参数
- en: Figure 2.1 is sure to shiver your timbers, showing the inputs (or *parameters*)
    and output of the program. We’ll use these diagrams throughout the book to imagine
    how code and data work together. In this program, the input is a word, and a phrase
    incorporating that word with the correct article is the output.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 一定会让你感到震惊，展示了程序的输入（或*参数*）和输出。我们将在这本书的整个过程中使用这些图表来想象代码和数据是如何一起工作的。在这个程序中，输入是一个单词，输出是与正确冠词结合的短语，包含该单词。
- en: '![](../Images/2-1.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2-1.png)'
- en: Figure 2.1 The input to the program is a word, and the output is that word plus
    its proper article (and some other stuff).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 程序的输入是一个单词，输出是这个单词加上它的正确冠词（以及一些其他内容）。
- en: We need to modify the part of the program that gets the arguments--the aptly
    named `get_args()` function. This function uses the `argparse` module to parse
    the command-line arguments, and our program needs to accept a single, positional
    argument. If you’re unsure what a “positional” argument is, be sure to read the
    appendix, especially section A.4.1.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要修改获取参数的程序部分——名为`get_args()`的合适函数。这个函数使用`argparse`模块来解析命令行参数，而我们的程序需要接受一个单一的、位置参数。如果你不确定“位置参数”是什么，请务必阅读附录，特别是A.4.1节。
- en: 'The `get_args()` function created by the template names the first argument
    `positional`. Remember that positional arguments are defined by their positions
    and don’t have names that start with dashes. You can delete all the arguments
    except for the positional `word`. Modify the `get_args()` part of your program
    until it will print this usage:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 模板创建的`get_args()`函数将第一个参数命名为`positional`。记住，位置参数是通过它们的顺序定义的，并且不以短横线开头命名。你可以删除除了位置参数`word`之外的所有参数。修改你的程序中的`get_args()`部分，直到它能够打印出这个用法：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Likewise, it should print longer usage documentation for the `-h` or `--help`
    flag:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，它应该为`-h`或`--help`标志打印更长的用法文档：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ① You need to define a word parameter. Notice that it is listed as a positional
    argument.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ① 你需要定义一个单词参数。注意，它被列为位置参数。
- en: ② The -h and --help flags are created automatically by argparse. You are not
    allowed to use these as options. They are used to create the documentation for
    your program.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ② `-h` 和 `--help` 标志是由`argparse`自动创建的。你不允许将这些用作选项。它们用于创建你程序的文档。
- en: '*Do not proceed until your usage matches the preceding!*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*不要继续，直到你的用法与前面的匹配！*'
- en: 'When your program prints the correct usage, you can get the `word` argument
    inside the `main` function. Modify your program so that it will print the `word`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的程序打印正确的用法时，你可以在`main`函数内部获取`word`参数。修改你的程序，使其能够打印`word`：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then test that it works:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然后测试它是否工作：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And now run your tests again. You should still be passing two and failing the
    third. Let’s read the test failure:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次运行你的测试。你应该仍然通过两个测试，而第三个测试失败。让我们看看测试失败的原因：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ① It’s not terribly important right now to understand this line, but the getoutput()
    function is running the program with a word. We’re going to talk about the f-string
    in this chapter. The output from running the program will go into the out variable,
    which will be used to see if the program created the correct output for a given
    word. None of the code in this function is anything you should worry about being
    able to write yet.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ① 现在理解这一行并不是非常重要，但 getoutput() 函数正在运行带有单词的程序。我们将在本章讨论 f-string。程序运行的输出将进入 out
    变量，该变量将用于查看程序是否为给定的单词创建了正确的输出。这个函数中的代码没有任何你应该担心能够编写的内容。
- en: ② The line starting with “>” shows the code that produced an error. The output
    of the program is compared to an expected string. Since it didn’t match, the assert
    produces an exception.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ② 以“>”开头的行显示了产生错误的代码。程序输出与预期字符串进行比较。由于它不匹配，断言产生了异常。
- en: ③ This line starts with “E” to indicate the error.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 这行以“E”开头，表示错误。
- en: ④ The line starting with a hyphen (-) is what the test got when it ran with
    the argument “brigantine”--it got back the word “brigantine.”
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 以连字符（-）开头的行是测试运行时使用参数“brigantine”得到的输出——它返回了单词“brigantine”。
- en: '⑤ The line starting with the plus sign (+) is what the test expected: “Ahoy,
    Captain, a brigantine off the larboard bow!”'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 以加号（+）开头的行是测试预期的内容：“Ahoy, Captain, a brigantine off the larboard bow!”
- en: So we need to get the `word` into the “Ahoy” phrase. How can we do that?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要将 `word` 放入“Ahoy”短语中。我们如何做到这一点？
- en: 2.1.5 Concatenating strings
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.5 连接字符串
- en: Putting strings together is called *concatenating* or *joining* strings. To
    demonstrate, I’ll enter some code directly into the Python interpreter. I want
    you to type along. No, really! Type everything you see, and try it for yourself.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 将字符串拼接在一起称为*连接*或*拼接*字符串。为了演示，我将直接将一些代码输入到 Python 解释器中。我希望你一起输入。不，真的！输入你看到的一切，并亲自尝试。
- en: 'Open a terminal and type `python3` or `ipython` to start a REPL. A REPL is
    a Read-Evaluate-Print-Loop--Python will *read* each line of input, *evaluate*
    it, and *print* the results in a *loop*. Here’s what it looks like on my system:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 打开终端并输入 `python3` 或 `ipython` 以启动交互式解释器。交互式解释器是一个读取-评估-打印-循环——Python 将会读取输入的每一行，评估它，并在循环中打印结果。以下是我系统上的样子：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The “>>>” is a prompt where you can type code. Remember *not* to type that part!
    To exit the REPL, either type `quit()` or press Ctrl-D (the Control key plus the
    letter *D*).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: “>>>” 是你可以输入代码的提示符。记住**不要**输入那部分！要退出交互式解释器，可以输入 `quit()` 或按 Ctrl-D（控制键加上字母 *D*）。
- en: Note You may prefer to use Python’s IDLE (integrated development and learning
    environment) program, IPython, or Jupyter Notebooks to interact with the language.
    I’ll stick to the python3 REPL throughout the book.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你可能更喜欢使用 Python 的 IDLE（集成开发和学习环境）程序、IPython 或 Jupyter 笔记本来与语言交互。我将在整本书中坚持使用
    python3 交互式解释器。
- en: 'Let’s start off by assigning the variable `word` to the value “narwhal.” In
    the REPL, type `word` `=` `''narwhal''` and press Enter:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从将变量 `word` 赋值为“narwhal”开始。在交互式解释器中，输入 `word` `=` `'narwhal'` 并按回车键：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that you can put as many (or no) spaces around the `=` as you like, but
    convention and readability (and tools like Pylint and Flake8 that help you find
    errors in your code) ask you to use exactly one space on either side.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你可以在 `=` 的周围放置任意多（或没有）空格，但传统、可读性（以及帮助你找到代码中错误的工具，如 Pylint 和 Flake8）要求你在两侧使用恰好一个空格。
- en: 'If you type `word` and press Enter, Python will print the current value of
    `word`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你输入 `word` 并按回车键，Python 将打印 `word` 的当前值：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now type `werd` and press Enter:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在输入 `werd` 并按回车键：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Warning There is no `werd` variable because we haven’t set `werd` to be anything.
    Using an undefined variable causes an *exception* that will crash your program.
    Python will happily create `werd` for you when you assign it a value.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：没有 `werd` 变量，因为我们还没有将 `werd` 设置为任何值。使用未定义的变量会导致异常，这会使你的程序崩溃。当你为它赋值时，Python
    会愉快地为你创建 `werd`。
- en: 'We need to insert the `word` between two other strings. The `+` operator can
    be used to join strings together:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在两个其他字符串之间插入 `word`。`+` 运算符可以用来连接字符串：
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you change your program to `print()` that string instead of just printing
    the `word`, you should be able to pass four tests:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将程序更改为 `print()` 该字符串而不是仅仅打印 `word`，你应该能够通过四个测试：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If you look closely at the failure, you’ll see this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察失败，你会看到这个：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We hardcoded the “a” before the `word`, but we really need to figure out whether
    to use “a” or “an” depending on whether the `word` starts with a vowel. How can
    we do that?
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`word`之前硬编码了“a”，但实际上我们需要确定是否根据`word`是否以元音字母开头来使用“a”或“an”。我们该如何做到这一点？
- en: 2.1.6 Variable types
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.6 变量类型
- en: Before we go much further, I need to take a small step back and point out that
    our `word` variable is a *string*. Every variable in Python has a *type* that
    describes the kind of data it holds. Because we put the value for `word` in quotes
    (`'narwhal'`), `word` holds a *string*, which Python represents with a class called
    `str`. (A *class* is a collection of code and functions that we can use.)
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进一步深入之前，我需要稍微退一步，指出我们的`word`变量是一个**字符串**。Python中的每个变量都有一个**类型**，它描述了它所持有的数据类型。因为我们把`word`的值放在引号中（`'narwhal'`），所以`word`包含一个**字符串**，Python用名为`str`的类来表示。（**类**是我们可以使用的一组代码和函数。）
- en: 'The `type()` function will tell you what kind of data Python thinks something
    is:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`type()`函数会告诉你Python认为某个数据是什么类型：'
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Whenever you put a value in single quotes (`''''`) or double quotes (`""`),
    Python will interpret it as a `str`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时你在单引号（''）或双引号（""）中放置一个值，Python都会将其解释为`str`：
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Warning If you forget the quotes, Python will look for some variable or function
    by that name. If there is no variable or function by that name, it will cause
    an exception:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 警告 如果你忘记了引号，Python将会寻找一些名为该名称的变量或函数。如果没有名为该名称的变量或函数，将会引发异常：
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Exceptions are bad, and we will try to write code that avoids them, or at least
    knows how to handle them gracefully.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 异常很不好，我们将尝试编写避免它们或至少能够优雅地处理它们的代码。
- en: 2.1.7 Getting just part of a string
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.7 获取字符串的一部分
- en: Back to our problem. We need to put either “a” or “an” in front of the `word`
    we’re given, based on whether the first character of `word` is a vowel or a consonant.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的问题。我们需要根据`word`的第一个字符是元音字母还是辅音字母，在给定的`word`前放置“a”或“an”。
- en: In Python, we can use square brackets and an *index* to get an individual character
    from a string. The index is the numeric position of an element in a sequence,
    and we must remember that indexing starts at `0`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们可以使用方括号和索引来从字符串中获取单个字符。索引是序列中元素的位置数值，我们必须记住索引是从`0`开始的。
- en: '|'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You can index into a literal string value too:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以对字面量字符串值进行索引：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '| ![](../Images/2-unnumb-2.png) |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| ![图片](../Images/2-unnumb-2.png) |'
- en: '| Because the index values start with 0, that means the last index is *one
    less than the length* of the string, which is often confusing. The length of “narwhal”
    is 7, but the last character is found at index `6`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '| 因为索引值从0开始，这意味着最后一个索引是字符串**长度减一**，这通常很令人困惑。 “narwhal”的长度是7，但最后一个字符是在索引`6`处找到的：'
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '| ![](../Images/2-unnumb-3.png) |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| ![图片](../Images/2-unnumb-3.png) |'
- en: '| You can also use negative index numbers to count backwards from the end,
    so the last index is also `-1`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '| 你也可以使用负索引数字从末尾开始计数，所以最后一个索引也是`-1`：'
- en: '[PRE27]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '| ![](../Images/2-unnumb-4.png) |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| ![图片](../Images/2-unnumb-4.png) |'
- en: '| You can use *slice notation* `[start:stop]` to get a range of characters.
    Both `start` and `stop` are optional. The default value for start is `0` (the
    beginning of the string), and the `stop` value is *not inclusive*:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '| 你可以使用**切片表示法** `[start:stop]` 来获取字符范围。`start`和`stop`都是可选的。`start`的默认值是`0`（字符串的开始），而`stop`的值**不包括**在内：'
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '| ![](../Images/2-unnumb-5.png) |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| ![图片](../Images/2-unnumb-5.png) |'
- en: 'The default value for `stop` is the end of the string:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`stop`的默认值是字符串的末尾：'
- en: '[PRE29]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the next chapter, you’ll see that this is the same as the syntax for slicing
    lists. A string is (sort of) a list of characters, so this isn’t too strange.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你会看到这与切片列表的语法相同。字符串（某种程度上）是字符的列表，所以这并不奇怪。
- en: 2.1.8 Finding help in the REPL
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.8 在REPL中寻找帮助
- en: 'The `str` class has a ton of functions we can use to handle strings, but what
    are they? A large part of programming is knowing how to ask questions and where
    to look for answers. A common refrain you may hear is “RTFM”--Read the Fine Manual.
    The Python community has created reams of documentation, which are all available
    at [https://docs.python.org/3/](https://docs.python.org/3/). You will need to
    refer to the documentation constantly to remind yourself (and discover) how to
    use certain functions. The docs for the string class are here: [https://docs.python.org/
    3/library/string.html](https://docs.python.org/3/library/string.html).'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`str` 类有很多我们可以用来处理字符串的函数，但它们是什么？编程的大部分内容是知道如何提问和在哪里寻找答案。你可能经常听到的一个常见说法是“RTFM”——阅读详细手册。Python
    社区已经创建了大量的文档，所有这些文档都可以在 [https://docs.python.org/3/](https://docs.python.org/3/)
    找到。你需要经常查阅文档来提醒自己（并发现）如何使用某些函数。字符串类的文档在这里：[https://docs.python.org/3/library/string.html](https://docs.python.org/3/library/string.html)。'
- en: '| I prefer to read the docs directly inside the REPL, in this case by typing
    `help(str)`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '| 我更喜欢直接在 REPL 中阅读文档，在这种情况下，通过输入 `help(str)`：'
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '| ![](../Images/2-unnumb-6.png) |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| ![](../Images/2-unnumb-6.png) |'
- en: Inside the `help`, you move up and down in the text using the up and down cursor
    arrows on your keyboard. You can also press the spacebar or the letter *F* (or
    sometimes Ctrl-F) to jump forward to the next page, and the letter *B* (or sometimes
    Ctrl-B) to jump backward. You can search through the documentation by pressing
    `/` and then the text you want to find. If you press *N* (for “next”) after a
    search, you will jump to the next place that string is found. To leave the help,
    press *Q* (for “quit”).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `help` 中，你可以使用键盘上的上箭头和下箭头在文本中上下移动。你也可以按空格键或字母 *F*（有时是 Ctrl-F）跳转到下一页，按字母 *B*（有时是
    Ctrl-B）跳转到上一页。你可以通过按 `/` 然后输入你想找到的文本来搜索文档。如果你在搜索后按 *N*（代表“下一个”），你会跳到下一个找到该字符串的地方。要离开帮助，请按
    *Q*（代表“退出”）。
- en: 2.1.9 String methods
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.9 字符串方法
- en: '| Now that we know `word` is a string (`str`), we have all these incredibly
    useful methods we can call on the variable. (A *method* is a function that belongs
    to a variable like `word`.)For instance, if I wanted to shout about the fact that
    we have a narwhal, I could print it in UPPERCASE LETTERS. If I search through
    the help, I will see that there is a function called `str.upper()`. Here is how
    you can *call* or *execute* that function:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '| 现在我们知道 `word` 是一个字符串 (`str`)，我们就可以调用变量上的所有这些非常有用的方法。（*方法* 是属于变量，如 `word`
    的函数。）例如，如果我想大声说出我们有一个独角鲸的事实，我可以用大写字母打印出来。如果我在帮助文档中搜索，我会看到有一个名为 `str.upper()` 的函数。下面是如何
    *调用* 或 *执行* 该函数的方法：'
- en: '[PRE31]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '| ![](../Images/2-unnumb-7.png) |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| ![](../Images/2-unnumb-7.png) |'
- en: 'You must include the parentheses, `()`, or else you’re talking about the *function
    itself*:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须包含括号，`()`，否则你就是在谈论 *函数本身*：
- en: '[PRE32]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'That will actually come in handy later, when we use functions like `map()`
    and `filter()`, but for now we want Python to execute the `str.upper()` function
    on the variable `word`, so we add the parentheses. Note that the function returns
    an uppercase version of the word but *does not* change the value of `word`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上在以后使用像 `map()` 和 `filter()` 这样的函数时会很有用，但就现在而言，我们希望 Python 在变量 `word` 上执行
    `str.upper()` 函数，所以我们添加了括号。请注意，该函数返回单词的大写版本，但 *不会* 改变 `word` 的值：
- en: '[PRE33]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'There is another `str` function with “upper” in the name called `str.isupper()`.
    The name helps you know that this will return a true/false type answer. Let’s
    try it:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 另有一个名为 `str.isupper()` 的 `str` 函数，其名称有助于你知道这将返回一个真/假类型的答案。让我们试一试：
- en: '[PRE34]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can chain methods together like so:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将方法链接在一起，如下所示：
- en: '[PRE35]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: That makes sense. If I convert `word` to uppercase, then `word.isupper()` returns
    `True`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有道理。如果我将 `word` 转换为大写，那么 `word.isupper()` 就会返回 `True`。
- en: '| I find it odd that the `str` class does not include a method to get the length
    of a string. For that, we must use a separate function called `len()`, short for
    “length”:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '| 我觉得 `str` 类没有包含一个获取字符串长度的方法很奇怪。为此，我们必须使用一个单独的函数，称为 `len()`，代表“长度”：'
- en: '[PRE36]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '| ![](../Images/2-unnumb-8.png) |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| ![](../Images/2-unnumb-8.png) |'
- en: Are you typing all this into Python yourself? I recommend you do! Find other
    methods in the `str` help, and try them out.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你是自己将这些内容输入到 Python 中的吗？我建议你这样做！在 `str` 的帮助文档中找到其他方法，并尝试使用它们。
- en: 2.1.10 String comparisons
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.10 字符串比较
- en: 'You now know how to get the first letter of `word` by using `word[0]`. Let’s
    assign it to the variable `char`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在知道如何通过使用 `word[0]` 来获取 `word` 的第一个字母。让我们将它赋值给变量 `char`：
- en: '[PRE37]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If you check the `type()` of your new `char` variable, it is a `str`. Even
    a single character is still considered by Python to be a string:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查新`char`变量的`type()`，它是一个`str`。即使是单个字符，Python也会将其视为字符串：
- en: '[PRE38]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now we need to figure out if `char` is a vowel or a consonant. We’ll say that
    the letters “a,” “e,” “i,” “o,” and “u” make up our set of “vowels.” You can use
    `==` to compare strings:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要弄清楚`char`是元音还是辅音。我们将说字母“a”、“e”、“i”、“o”和“u”构成了我们的“元音”集合。你可以使用`==`来比较字符串：
- en: '[PRE39]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note Be careful to always use one equal sign (`=`) when *assigning a value*
    to a variable, like `word` `=` `'narwhal'` and two equal signs (`==`, which, in
    my head, I pronounce “equal-equal”) when you *compare two values* like `word`
    `==` `'narwhal'`. The first is a statement that changes the value of `word`, and
    the second is an *expression* that returns `True` or `False` (see figure 2.2).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在给变量赋值时，如`word = 'narwhal'`，始终使用一个等号（`=`），而在比较两个值时，如`word == 'narwhal'`，使用两个等号（`==`，在我的脑海中，我将其读作“equal-equal”）。第一个是一个改变`word`值的语句，第二个是一个返回`True`或`False`的表达式（见图2.2）。
- en: '![](../Images/2-2.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2-2.png)'
- en: Figure 2.2 An expression returns a value. A statement does not.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 表达式返回一个值。语句不返回值。
- en: 'We need to compare our `char` to *all* the vowels. You can use `and` and `or`
    in such comparisons, and they will be combined according to standard Boolean algebra:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将我们的`char`与所有的元音进行比较。在这样的比较中，我们可以使用`and`和`or`，并且它们将根据标准的布尔代数进行组合：
- en: '[PRE40]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: What if the `word` is “Octopus” or “OCTOPUS”?
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`word`是“Octopus”或“OCTOPUS”会怎样？
- en: '[PRE41]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Do we have to make 10 comparisons in order to check the uppercase versions,
    too? What if we were to lowercase `word[0]`? Remember that `word[0]` returns a
    `str`, so we can chain other `str` methods onto that:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是否必须进行10次比较才能检查大写版本？如果我们把`word[0]`转换为小写会怎样？记住`word[0]`返回一个`str`，因此我们可以将其他`str`方法链接到它上面：
- en: '[PRE42]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '| An easier way to determine if `char` is a vowel would be to use Python’s
    `x` `in` `y` construct, which will tell us if the value `x` is in the collection
    `y`. We can ask whether the letter `''a''` is in the longer string `''aeiou''`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 确定一个字符`char`是否为元音的一个更简单的方法是使用Python的`x in y`构造，这将告诉我们值`x`是否在集合`y`中。我们可以询问字母`'a'`是否在较长的字符串`'aeiou'`中：
- en: '[PRE43]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '| ![](../Images/2-unnumb-9.png) |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| ![](../Images/2-unnumb-9.png) |'
- en: 'But the letter `''b''` is not:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 但字母`'b'`不是：
- en: '[PRE44]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Let’s use that to test the first character of the lowercased `word` (which
    is `''o''`):'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用这个来测试小写`word`的第一个字符（即`'o'`）：
- en: '[PRE45]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 2.1.11 Conditional branching
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.11 条件分支
- en: 'Once you have figured out if the first letter is a vowel, you will need to
    select an article. We’ll use a very simple rule: if the word starts with a vowel,
    choose “an”; otherwise, choose “a.” This misses exceptions like when the initial
    “h” in a word is silent. For instance, we say “a hat” but “an honor.” Nor will
    we consider the case where an initial vowel has a consonant sound, as in “union,”
    where the “u” sounds like a “y.”'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你弄清楚第一个字母是否为元音，你将需要选择一个冠词。我们将使用一个非常简单的规则：如果单词以元音开头，选择“an”；否则，选择“a。”这忽略了像单词开头的“h”是沉默的情况。例如，我们说“a
    hat”但“an honor。”我们也不会考虑初始元音有辅音发音的情况，例如在“union”中，“u”听起来像“y”。
- en: 'We can create a new variable called `article` that we will set to the empty
    string, and we’ll use an `if`/`else` statement to figure out what to put in it:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个新的变量`article`，并将其设置为空字符串，然后使用`if`/`else`语句来确定应该放入其中的内容：
- en: '[PRE46]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: ① Initialize article to the empty string.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ① 将文章初始化为空字符串。
- en: ② Check if the first, lowercased character of word is a vowel.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ② 检查单词的第一个小写字符是否为元音。
- en: ③ Set article to “an” if the first character is a vowel.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 如果第一个字符是元音，将文章设置为“an”。
- en: ④ Set article to “a” if the first character is not a vowel.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 如果第一个字符不是元音，将文章设置为“a”。
- en: Here is a much shorter way to write that with an `if` *expression* (expressions
    return values; statements do not). The `if` expression is written a little backwards.
    First comes the value if the test (or “predicate”) is `True`, then the predicate,
    and then the value if the predicate is `False` (figure 2.3).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`if`表达式（表达式返回值；语句不返回值）可以更简洁地写出这一点。`if`表达式写法稍微有些反常。首先来的是测试（或“谓词”）为`True`时的值，然后是谓词，最后是谓词为`False`时的值（见图2.3）。
- en: '![](../Images/2-3.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2-3.png)'
- en: Figure 2.3 The `if` expression will return the first value if the predicate
    is `True` and the second value otherwise.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 `if`表达式将在谓词为`True`时返回第一个值，否则返回第二个值。
- en: 'This approach is also safer because the `if` expression is *required* to have
    the `else`. There’s no chance that we could forget to handle both cases:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法也更安全，因为 `if` 表达式需要 `else`。我们不可能忘记处理两种情况：
- en: '[PRE47]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Let’s verify that we have the correct `article`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们验证一下我们是否得到了正确的 `article`：
- en: '[PRE48]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 2.1.12 String formatting
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.12 字符串格式化
- en: Now we have two variables, `article` and `word`, that need to be incorporated
    into our “Ahoy!” phrase. You saw earlier that we can use the plus sign (`+`) to
    concatenate strings. Another method for creating new strings from other strings
    is to use the `str.format()` method.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个变量，`article` 和 `word`，需要将它们合并到我们的“Ahoy！”短语中。你之前看到，我们可以使用加号（`+`）来连接字符串。从其他字符串创建新字符串的另一种方法是使用
    `str.format()` 方法。
- en: To do so, you create a string template with curly brackets `{}`, which indicate
    placeholders for values. The values that will be substituted are arguments to
    the `str.format()` method, and they are substituted in the same order that the
    `{}` appear (figure 2.4).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，你需要创建一个带有花括号 `{}` 的字符串模板，这些花括号表示值的占位符。将要替换的值是 `str.format()` 方法的参数，并且它们将按照
    `{}` 出现的顺序进行替换（图 2.4）。
- en: '![](../Images/2-4.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2-4.png)'
- en: Figure 2.4 The `str.format()` method is used to expand the values of variables
    inside strings.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 使用 `str.format()` 方法来扩展字符串中变量的值。
- en: 'Here it is in code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是代码的样子：
- en: '[PRE49]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Another method for combining strings uses the special “f-string” where you
    can put the variables directly into the curly brackets `{}`. It’s a matter of
    taste which approach you choose; I tend to prefer this style because I don’t have
    to think about which variable goes with which set of brackets:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种组合字符串的方法是使用特殊的“f-string”，你可以在花括号 `{}` 中直接放置变量。选择哪种方法取决于个人喜好；我倾向于选择这种风格，因为我不必考虑哪个变量与哪一组括号相对应：
- en: '[PRE50]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '| NOTE In some programming languages, you have to declare the variable’s name
    and what *type* of data it will hold. If a variable is declared to be a number,
    it can never hold a different type of value, like a string. This is called *static
    typing* because the type of the variable can never change.Python is a *dynamically
    typed* language, which means you do not have to declare a variable or what kind
    of data the variable will hold. You can change the value and type of data at any
    time. This could be either great or terrible news. As Hamlet says, “There is nothing
    either good or bad, but thinking makes it so.” | ![](../Images/2-unnumb-10.png)
    |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| 注意：在某些编程语言中，你必须声明变量的名称以及它将持有的 *类型* 数据。如果一个变量被声明为数字，它永远不能持有不同类型的值，比如字符串。这被称为
    *静态类型*，因为变量的类型永远不能改变。Python 是一种 *动态类型* 语言，这意味着你不需要声明变量或变量将持有的数据类型。你可以在任何时候更改值和数据类型。这可能是个好消息，也可能是坏消息。正如哈姆雷特所说：“世间本无善恶，思想使之如此。”
    | ![](../Images/2-unnumb-10.png) |'
- en: 2.1.13 Time to write
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.13 写作时间
- en: 'Here are a few hints for writing your solution:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是编写解决方案的一些提示：
- en: Start your program with new.py and fill in `get_args()` with a single positional
    argument called `word`.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `new.py` 开始你的程序，并在 `get_args()` 中填充一个名为 `word` 的单个位置参数。
- en: You can get the first character of the word by indexing it like a list, `word[0]`.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过像列表一样索引它来获取单词的第一个字符，`word[0]`。
- en: Unless you want to check both upper- and lowercase letters, you can use either
    the `str.lower()` or `str.upper()` method to force the input to one case for checking
    whether the first character is a vowel or consonant.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你不想检查大小写字母，你可以使用 `str.lower()` 或 `str.upper()` 方法强制输入为一种情况，以检查第一个字符是否为元音或辅音。
- en: There are fewer vowels (five, if you recall) than consonants, so it’s probably
    easier to check whether the first character is one of those.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元音（如果你还记得的话，有五个）比辅音少，所以检查第一个字符是否是那些中的一个可能更容易。
- en: You can use the `x` `in` `y` syntax to see if the element `x` is `in` the collection
    `y`, with the collection here being a `list`.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 `x in y` 语法来检查元素 `x` 是否在集合 `y` 中，这里的集合是一个 `list`。
- en: Use `str.format()` or f-strings to insert the correct article for the given
    word into the longer phrase.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `str.format()` 或 f-strings 将正确的冠词插入到给定的单词中，形成较长的短语。
- en: Run `make` `test` (or `pytest` `-xv` `test.py`) after *every* change to your
    program to ensure that your program compiles and is on the right track.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次更改程序后，运行 `make` `test`（或 `pytest` `-xv` `test.py`）以确保程序编译正确，并且处于正确的轨道。
- en: Now go write the program before you turn the page and study my solution. Look
    alive, you ill-tempered shabaroon!
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在翻页并研究我的解决方案之前，现在就开始编写程序吧。别再那么暴躁了，shabaroon！
- en: 2.2 Solution
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 解决方案
- en: 'Following is one way you could write a program that satisfies the test suite:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是满足测试套件的一种编写程序的方法：
- en: '[PRE51]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: ① Define the function get_args () to handle the command-line arguments. I like
    to put this first so I can see it right away when I’m reading the code.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ① 定义get_args()函数来处理命令行参数。我喜欢把它放在第一位，这样我可以在阅读代码时立即看到它。
- en: ② The parser will parse the arguments.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ② 解析器将解析参数。
- en: ③ The description shows in the usage to describe what the program does.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 描述显示在用法中，以描述程序的功能。
- en: ④ Show the default values for each parameter in the usage.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 在用法中显示每个参数的默认值。
- en: ⑤ Define a positional argument called word.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 定义一个名为word的位置参数。
- en: ⑥ The result of parsing the arguments will be returned to main().
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 解析参数的结果将返回给main()。
- en: ⑦ Define the main() function where the program will start.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 在程序开始的地方定义main()函数。
- en: ⑧ args contains the return value from the get_args() function.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ args包含来自get_args()函数的返回值。
- en: ⑨ Put the args.word value from the arguments into the word variable.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 将args.word值从参数中放入单词变量。
- en: ⑩ Choose the correct article, using an if expression to see if the lowercased,
    first character of word is or is not in the set of vowels.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ 使用if表达式检查单词的小写首字符是否在元音集合中。
- en: ⑪ Print the output string using an f-string to interpolate the article and word
    variables inside the string.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ⑪ 使用f-string打印输出字符串，在字符串中插入文章和单词变量。
- en: ⑫ Check if we are in the “main” namespace, which means the program is running.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ⑫ 检查我们是否在“main”命名空间中，这意味着程序正在运行。
- en: ⑬ If we are in the “main” namespace, call the main() function to make the program
    start.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ⑬ 如果我们在“main”命名空间中，调用main()函数以使程序开始。
- en: 2.3 Discussion
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 讨论
- en: I’d like to stress that the preceding listing is *a* solution, not *the* solution.
    There are many ways to express the same idea in Python. As long as your code passes
    the test suite, it is correct.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我想强调，前面列出的只是一个解决方案，而不是唯一的解决方案。在Python中，有许多表达相同想法的方法。只要你的代码通过了测试套件，它就是正确的。
- en: 'That said, I created my program with new.py, which automatically gives me two
    functions:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我用new.py创建了我的程序，这自动给我提供了两个函数：
- en: '`get_args()`, where I define the arguments to the program'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_args()`，我在其中定义了程序的参数'
- en: '`main()`, where the program starts'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main()`，程序从这里开始'
- en: Let’s talk about these two functions.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论这两个函数。
- en: 2.3.1 Defining the arguments with get_args()
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.1 使用get_args()定义参数
- en: I prefer to put the `get_args()` function first so that I can see right away
    what the program expects as input. You don’t have to define this as a separate
    function--you could put all this code inside `main()`, if you prefer. Eventually
    our programs are going to get longer, though, and I think it’s nice to keep this
    as a separate idea. Every program I present will have a `get_args()` function
    that will define and validate the input.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢将`get_args()`函数放在第一位，这样我就可以立即看到程序期望的输入。你不必将其定义为单独的函数--如果你愿意，你可以把所有这些代码放在`main()`中。然而，我们的程序最终会变得更长，我认为将其作为一个单独的想法来保持是很好的。我展示的每个程序都将有一个`get_args()`函数，该函数将定义和验证输入。
- en: 'Our program specifications (the “specs”) say that the program should accept
    one positional argument. I changed the `''positional''` argument name to `''word''`
    because I’m expecting a single word:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序规范（“规范”）说明程序应接受一个位置参数。我将`'positional'`参数名称更改为`'word'`，因为我期望一个单词：
- en: '[PRE52]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: I recommend you never leave the positional argument named `'positional'` because
    it is an entirely nondescriptive term. Naming your variables according to *what
    they are* will make your code more readable.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你永远不要使用名为`'positional'`的位置参数，因为它是一个完全不可描述的术语。根据*它们是什么*来命名你的变量会使你的代码更易于阅读。
- en: The program doesn’t need any of the other options created by new.py, so you
    can delete the rest of the `parser.add_argument()` calls.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 程序不需要new.py创建的其他选项，所以你可以删除其余的`parser.add_argument()`调用。
- en: 'The `get_args()` function will `return` the result of parsing the command-line
    arguments that I put into the variable `args`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_args()`函数将返回解析我放入变量`args`中的命令行参数的结果：'
- en: '[PRE53]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: If `argparse` is not able to parse the arguments--for example, if there are
    none--it will never `return` from `get_args()` but will instead print the “usage”
    for the user and exit with an error code to let the operating system know that
    the program exited without success. (On the command line, an exit value of `0`
    means there were 0 errors. Anything other than `0` is considered an error.)
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `argparse` 无法解析参数——例如，如果没有参数——它将永远不会从 `get_args()` 返回，而是会打印出用户的“用法”信息并带错误代码退出，让操作系统知道程序没有成功退出。（在命令行中，退出值为
    `0` 表示没有错误。任何非 `0` 的值都被视为错误。）
- en: 2.3.2 The main() thing
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.2 main() 的主要作用
- en: 'Many programming languages will automatically start from the `main()` function,
    so I always define a `main()` function and start my programs there. This is not
    a requirement, but it’s an extremely common idiom in Python. Every program I present
    will start with a `main()` function that will first call `get_args()` to get the
    program’s inputs:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 许多编程语言会自动从 `main()` 函数开始，所以我总是定义一个 `main()` 函数并在那里开始我的程序。这不是强制要求，但在 Python 中这是一个极其常见的习语。我展示的每个程序都将从一个
    `main()` 函数开始，该函数将首先调用 `get_args()` 来获取程序的输入：
- en: '[PRE54]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'I can now access the `word` by calling `args.word`. Note the lack of parentheses.
    It’s not `args.word()` because it is not a function call. Think of `args.word`
    as being like a slot where the value of the word lives:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在可以通过调用 `args.word` 来访问 `word`。注意没有括号。这不是 `args.word()`，因为它不是一个函数调用。将 `args.word`
    视为一个插槽，其中存储着单词的值：
- en: '[PRE55]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'I like to work through my ideas using the REPL, so I’m going to pretend that
    `word` has been set to “octopus”:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢使用 REPL 来实现我的想法，所以我将假装 `word` 已经被设置为“octopus”：
- en: '[PRE56]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 2.3.3 Classifying the first character of a word
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.3 对单词的第一个字符进行分类
- en: 'To figure out whether the article I choose should be `a` or `an`, I need to
    look at the first character of the `word`. In the introduction, we used this:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定我选择的文章应该是 `a` 还是 `an`，我需要查看 `word` 的第一个字符。在介绍中，我们使用了这个方法：
- en: '[PRE57]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'I can check if the first character is `in` the string of vowels, both lower-
    and uppercase:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以检查第一个字符是否在元音字符串中，无论是大写还是小写：
- en: '[PRE58]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'I can make this shorter, however, if I use the `word.lower()` function. Then
    I’d only have to check the lowercase vowels:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果使用 `word.lower()` 函数，我可以使它更短。然后我只需检查小写元音：
- en: '[PRE59]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Remember that the `x` `in` `y` form is a way to ask if element `x` is in the
    collection `y`. You can use it for letters in a longer string (like the list of
    vowels):'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`x in y` 的形式是询问元素 `x` 是否在集合 `y` 中。你可以用它来检查较长字符串（如元音字母列表）中的字母：
- en: '[PRE60]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '| You can use membership in the list of vowels as a condition to choose “an”;
    otherwise, we choose “a.” As mentioned in the introduction, the `if` expression
    is the shortest and safest way to make a *binary* choice (where there are only
    two possibilities):'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '| 你可以使用元音字母列表中的成员作为条件来选择“an”；否则，我们选择“a。”正如介绍中提到的，`if` 表达式是进行二进制选择（只有两种可能性）最短且最安全的方式：'
- en: '[PRE61]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '| ![](../Images/2-unnumb-11.png) |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| ![图片](../Images/2-unnumb-11.png) |'
- en: The safety of the `if` expression comes from the fact that Python will not even
    run this program if you forget the `else`. Try it and see what error you get.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` 表达式的安全性来源于 Python 即使你忘记了 `else` 也不会运行这个程序。试一试，看看你会得到什么错误。'
- en: 'Let’s change the value of `word` to “galleon” and check that it still works:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们改变 `word` 的值为“galleon”并检查它是否仍然有效：
- en: '[PRE62]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 2.3.4 Printing the results
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.4 打印结果
- en: 'Finally we need to print out the phrase with our article and word. As noted
    in the introduction, you can use the `str.format()` function to incorporate the
    variables into a string:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要打印出包含文章和单词的短语。正如介绍中提到的，你可以使用 `str.format()` 函数将变量合并到字符串中：
- en: '[PRE63]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Python’s f-strings will *interpolate* any code inside the `{}` placeholders,
    so variables get turned into their contents:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 f-strings 会将 `{}` 占位符内的任何代码进行插值，因此变量会被转换为其内容：
- en: '[PRE64]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: However you choose to print out the article and word is fine, as long as it
    passes the tests. While it’s a matter of personal taste which you choose, I find
    f-strings a bit easier to read, as my eyes don’t have to jump back and forth from
    the `{}` placeholders to the variables that will go inside them.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择如何打印文章和单词都行，只要它通过了测试。虽然选择哪种方式是个人品味的问题，但我发现 f-strings 读取起来更容易，因为我的眼睛不需要在
    `{}` 占位符和将要放入其中的变量之间来回跳跃。
- en: 2.3.5 Running the test suite
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.5 运行测试套件
- en: “A computer is like a mischievous genie. It will give you exactly what you ask
    for, but not always what you want.”
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: “计算机就像一个顽皮的精灵。它会给你你要求的东西，但并不总是你想要的东西。”
- en: --Joe Sondow
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: --Joe Sondow
- en: Computers are a bit like bad genies. They will do exactly what you tell them,
    but not necessarily what you *want*. In an episode of *The X-Files*, the character
    Mulder wishes for peace on Earth, and a genie removes all humans but him.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机有点像坏精灵。它们会做你告诉它们的事情，但不一定是你想做的事情。在《X档案》的一集中，角色 Mulder 愿望地球和平，一个精灵移除了所有人，只留下他。
- en: Tests are what we can use to verify that our programs are doing what we *actually*
    want them to do. Tests can never prove that our program is truly free from errors,
    only that the bugs we imagined or found while writing the program no longer exist.
    Still, we write and run tests because they are really quite effective and much
    better than not doing so.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是我们用来验证我们的程序是否真正按照我们 *实际上* 想要的方式运行的工具。测试永远不能证明我们的程序真正没有错误，只能证明我们在编写程序时想象或发现的错误不再存在。尽管如此，我们仍然编写和运行测试，因为它们确实非常有效，比不这样做要好得多。
- en: 'This is the idea behind *test-driven development*:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 *测试驱动开发* 的理念：
- en: Write tests *before* we write the software.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编写软件之前编写测试。
- en: Run the tests to verify that our as-yet-unwritten software fails to deliver
    on some task.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行测试以验证我们尚未编写的软件在执行某些任务时失败。
- en: Write the software to fulfill the request.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写软件以满足需求。
- en: Run the tests to check that it now *does* work.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行测试以检查它现在 *确实* 工作。
- en: Keep running all the tests to ensure that when we add some new code we do not
    break existing code.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续运行所有测试以确保当我们添加一些新代码时，不会破坏现有的代码。
- en: We won’t be discussing how to *write* tests just yet. That will come later.
    For now, I’ve written all the tests for you. I hope that by the end of this book,
    you will see the value of testing and will always start off by writing *tests
    first and code second*!
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在还不会讨论如何 *编写* 测试。这将在稍后进行。目前，我已经为你编写了所有测试。我希望到这本书的结尾，你将看到测试的价值，并且始终从编写 *测试优先，代码其次*
    开始！
- en: 2.4 Going further
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4 进一步探讨
- en: '|'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Have your program match the case of the incoming word (for example, “an octopus”
    and “An Octopus”). Copy an existing `test_` function in test.py to verify that
    your program works correctly while still passing all the other tests. Try writing
    the test first, and then make your program pass the test. That’s *test-driven
    development*!
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让你的程序匹配输入单词的大小写（例如，“an octopus” 和 “An Octopus”）。将 test.py 中的现有 `test_` 函数复制到测试中，以验证你的程序在通过所有其他测试的同时是否正确工作。先编写测试，然后再让程序通过测试。这就是
    *测试驱动开发*！
- en: Accept a new parameter that changes “larboard” (the left side of the boat) to
    “starboard” (the right side[1](#pgfId-1064604)). You could either make an option
    called `--side` that defaults to “larboard,” or you could make a `--starboard`
    flag that, if present, changes the side to “starboard.”
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受一个新的参数，将“larboard”（船的左侧）改为“starboard”（船的右侧[1](#pgfId-1064604)）。你可以创建一个名为 `--side`
    的选项，默认为“larboard”，或者你可以创建一个 `--starboard` 标志，如果存在，则将侧面改为“starboard”。
- en: The provided tests only give you words that start with an actual alphabetic
    character. Expand your code to handle words that start with numbers or punctuation.
    Should your program reject these? Add more tests to ensure that your program does
    what you intend.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供的测试只给你以实际字母字符开头的单词。扩展你的代码以处理以数字或标点符号开头的单词。你的程序应该拒绝这些吗？添加更多测试以确保你的程序做你打算做的事情。
- en: '| ![](../Images/2-unnumb-12.png) |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| ![](../Images/2-unnumb-12.png) |'
- en: Summary
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: All Python’s documentation is available at [https://docs.python.org/3/](https://docs.python.org/3/)
    and via the `help` command in the REPL.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有 Python 的文档都可以在 [https://docs.python.org/3/](https://docs.python.org/3/) 和通过
    REPL 中的 `help` 命令找到。
- en: Variables in Python are dynamically typed according to whatever value you assign
    them, and they come into existence when you assign a value to them.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 中的变量根据你为其分配的值动态类型化，并且在你为其分配值时创建。
- en: Strings have methods like `str.upper()` and `str.isupper()` that you can call
    to alter them or get information.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串有 `str.upper()` 和 `str.isupper()` 等方法，你可以调用它们来修改字符串或获取信息。
- en: You can get parts of a string by using square brackets and indexes like `[0]`
    for the first letter or `[-1]` for the last.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过使用方括号和索引如 `[0]` 用于第一个字母或 `[-1]` 用于最后一个字母来获取字符串的一部分。
- en: You can concatenate strings with the `+` operator.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 `+` 运算符连接字符串。
- en: The `str.format()` method allows you to create a template with `{}` placeholders
    that get filled in with arguments.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`str.format()` 方法允许你创建一个带有 `{}` 占位符的模板，这些占位符将被参数填充。'
- en: F-strings like `f'{article}` `{word}'` allow variables and code to go directly
    inside the brackets.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: F-字符串如 `f'{article}' {word}` 允许变量和代码直接放入括号内。
- en: The `x` `in` `y` expression will report whether the value `x` is present in
    the collection `y`.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x` `in` `y`这个表达式会报告值`x`是否存在于集合`y`中。'
- en: Statements like `if`/`else` do not return a value, whereas expressions like
    `x` `if` `y` `else` `z` do return a value.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if`/`else`这样的语句不返回值，而像`x` `if` `y` `else` `z`这样的表达式则返回值。'
- en: Test-driven development is a way to ensure programs meet some minimum criteria
    of correctness. Every feature of a program should have tests, and writing and
    running test suites should be an integral part of writing programs.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试驱动开发是一种确保程序满足某些最小正确性标准的方法。程序中的每个功能都应该有测试，编写和运行测试套件应该是编写程序的一个组成部分。
- en: '* * *'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 1 “Starboard” has nothing to do with stars but with the “steering board” or
    rudder, which typically was on the right side of the boat for right-handed sailors.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: “右舷”与星星无关，而是与“舵板”或舵有关，对于右手舵手来说，舵通常位于船的右侧。
