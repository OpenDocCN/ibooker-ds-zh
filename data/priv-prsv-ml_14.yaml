- en: Appendix A. More details about differential privacy
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录A. 差分隐私的更多细节
- en: As we discussed in chapter 2, differential privacy (DP) is one of the most popular
    and influential privacy protection schemes. It is based on the concept of making
    a dataset robust enough that any single substitution in the dataset does not reveal
    private data. This is typically achieved by calculating the patterns of groups
    within the dataset, which we call *complex statistics*, while withholding information
    about individuals in the dataset. The beauty of differential privacy is its mathematical
    provability and quantifiability. In the following sections, we will introduce
    the mathematical foundations and the formal definition of DP. If you are not interested
    in these mathematical foundations, you can bypass this now and come back to it
    when necessary.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第2章中讨论的，差分隐私（DP）是最受欢迎和最有影响力的隐私保护方案之一。它基于使数据集足够健壮的概念，以至于数据集中的任何单个替换都不会泄露私人数据。这通常是通过计算数据集中组内的模式来实现的，我们称之为
    *复杂统计*，同时保留数据集中个人的信息。差分隐私的美丽之处在于其数学可证明性和可量化性。在接下来的章节中，我们将介绍数学基础和差分隐私的正式定义。如果你对这些数学基础不感兴趣，你现在可以跳过这部分，并在需要时再回来。
- en: A.1 The formal definition of differential privacy
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.1 差分隐私的正式定义
- en: 'Before we introduce the formal definition of DP, let’s look at some essential
    terms originally defined by Dwork and Roth [1]:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们介绍差分隐私的正式定义之前，让我们看看一些最初由Dwork和Roth [1]定义的基本术语：
- en: '*Probability simplex*—Let *B* denote a discrete set. The probability simplex
    of *B*, denoted Δ(*B*), is defined to be Δ(B) = {x ∈ ℝ^(|B|) : x[i] ≥ 0 for all
    i and Σ^(|B|)[i=1] x[i] = 1. You can consider the probability simplex to be the
    space of a given probability distribution.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*概率单纯形*—令 *B* 表示一个离散集合。*B* 的概率单纯形，记为 Δ(*B*)，定义为 Δ(B) = {x ∈ ℝ^(|B|) : x[i]
    ≥ 0 for all i and Σ^(|B|)[i=1] x[i] = 1}。你可以将概率单纯形视为给定概率分布的空间。'
- en: '*Randomized algorithm*—A randomized algorithm *M* with domain *A* and discrete
    range *B* is associated with the mapping *M* : *A*→Δ(*B*). Given an input *a*
    ∈ *A*, the algorithm *M* outputs *M*(*a*) = *b* with probability (*M*(*a*))[b]
    for each *b* ∈ *B*. The probability space is over the coin flips of the algorithm
    *M*. We discussed how randomization in the algorithm happens with two coin flips
    in section 2.2.1.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*随机算法*—一个具有域 *A* 和离散范围 *B* 的随机算法 *M* 与映射 *M* : *A*→Δ(*B*) 相关联。给定一个输入 *a* ∈
    *A*，算法 *M* 以概率 (*M*(*a*))[b] 输出 *M*(*a*) = *b*，对于每个 *b* ∈ *B*。概率空间是算法 *M* 的硬币翻转。我们已经在第2.2.1节中讨论了算法中的随机化是如何发生的。'
- en: '*Database*—A database *x* is a collection of records that form a universe *X*.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数据库*—数据库 *x* 是形成宇宙 *X* 的记录集合。'
- en: For instance, let the universe *X* define the set of unique elements in the
    database. Then a database could be represented by the histograms of the elements
    within the database, x ∈ ℕ^(|X|), where each entry *x*[i] represents the number
    of elements in the database *x* of type *i* ∈ *X*.
  id: totrans-7
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，让全集 *X* 定义数据库中的唯一元素集合。那么一个数据库可以通过数据库内元素的直方图来表示，x ∈ ℕ^(|X|)，其中每个条目 *x*[i]
    代表数据库 *x* 中类型 *i* ∈ *X* 的元素数量。
- en: '*Distance between databases*—The *l*[1] norm of a database *x* is denoted ‖*x*‖[1]
    and is defined to be ‖x‖[1] = Σ^(|x|)[i=1] |xi|. Thus, the *l*[1] distance between
    two databases *x* and *y* is ‖*x* - *y*‖[1].'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数据库之间的距离*—数据库 *x* 的 *l*[1] 范数表示为 ‖*x*‖[1]，定义为 ‖x‖[1] = Σ^(|x|)[i=1] |xi|。因此，两个数据库
    *x* 和 *y* 之间的 *l*[1] 距离是 ‖*x* - *y*‖[1]。'
- en: '*Neighboring databases*—Two databases, *x*, *y*, are defined to be neighboring
    databases if they differ only in one row. For instance, for a pair of databases
    *x*, *y* ∈ *N*^(|X|), if ‖*x* - *y*‖[1] ≤ 1, we consider *x*, *y* to be neighboring
    databases.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*邻近数据库*—两个数据库 *x* 和 *y* 被定义为邻近数据库，如果它们只在一行上有所不同。例如，对于数据库对 *x*，*y* ∈ *N*^(|X|)，如果
    ‖*x* - *y*‖[1] ≤ 1，我们则认为 *x* 和 *y* 是邻近数据库。'
- en: Now we are ready to introduce the formal and most general definition of DP.
    It provides the mathematical guarantee of a randomized algorithm that will behave
    similarly on neighboring databases.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备介绍差分隐私的正式和最一般的定义。它为随机算法提供了在邻近数据库上表现相似的数学保证。
- en: (ϵ, *δ*)-*differential privacy*—A randomized algorithm *M* is (ϵ, *δ*)-DP if
    for every two neighboring databases, *x*, *y*, and for all *S* ⊆ *Range*(*M* ),
    we have
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (ϵ, *δ*)-*差分隐私*—一个随机算法 *M* 是 (ϵ, *δ*)-DP，如果对于每一对邻近数据库 *x*，*y* 和对于所有 *S* ⊆ *Range*(*M*
    )，我们有
- en: Pr[*M*(*x*) ∈ *S*] ≤ *e*^ε ⋅ Pr[*M*(*y*) ∈ *S*] + δ
  id: totrans-12
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Pr[*M*(*x*) ∈ *S*] ≤ *e*^ε ⋅ Pr[*M*(*y*) ∈ *S*] + δ
- en: where Pr[⋅] denotes the probability of an event, and *Range*(*M*) denotes the
    set of all possible outputs of the randomized algorithm *M*. The smaller ϵ and
    δ are, the closer Pr[*M*(*x*) ∈ *S*] and Pr[*M*(*y*) ∈ *S*] are, and the stronger
    the privacy protection is. When δ = 0, the algorithm *M* satisfies ϵ-DP, which
    is a stronger privacy guarantee than (ϵ, *δ*)-DP with δ > 0\. Usually people call
    ϵ the *privacy budget* in the definition of DP. A higher value of ϵ means that
    one has more privacy budget and thus can tolerate more privacy leakage. A lower
    value of ϵ means stronger privacy protection is required or provided. The privacy
    parameter, δ, represents a “failure probability” for the definition. With a probability
    of 1 - δ, we will get the same guarantee as pure DP (i.e., ϵ-DP, where δ = 0).
    With a probability of δ > 0, we get no guarantee. In other words,
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其中 Pr[⋅] 表示事件的概率，*Range*(M) 表示随机算法 M 所有可能输出的集合。当 ϵ 和 δ 越小，Pr[*M*(*x*) ∈ *S*]
    和 Pr[*M*(*y*) ∈ *S*] 越接近，隐私保护就越强。当 δ = 0 时，算法 *M* 满足 ϵ-DP，这比 (ϵ, *δ*)-DP（δ > 0）提供了更强的隐私保证。通常人们将
    ϵ 称为 DP 定义中的 *隐私预算*。ϵ 的值越高，意味着拥有更多的隐私预算，因此可以容忍更多的隐私泄露。ϵ 的值越低，意味着需要或提供的隐私保护越强。隐私参数
    δ 代表定义中的“失败概率”。以 1 - δ 的概率，我们将获得与纯 DP（即 ϵ-DP，其中 δ = 0）相同的保证。以 δ > 0 的概率，我们则没有任何保证。换句话说，
- en: With probability 1 - δ, we have Pr[*M*(*x*) ∈ *S*] ≤ *e*^ϵ⋅Pr[*M*(*y*) ∈ *S*].
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以 1 - δ 的概率，我们有 Pr[*M*(*x*) ∈ *S*] ≤ *e*^ϵ⋅Pr[*M*(*y*) ∈ *S*]。
- en: With probability δ, we get no guarantee at all.
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以 δ 的概率，我们根本没有任何保证。
- en: A.2 Other differential privacy mechanisms
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.2 其他差分隐私机制
- en: 'Chapter 2 discussed three of the most popular differential privacy mechanisms:
    binary, Laplace, and exponential. To recap, randomization in the binary mechanism
    comes from the binary response (the coin flip), which helps us to perturb the
    results. The Laplace mechanism achieves DP by adding random noise drawn from a
    Laplace distribution to the target queries or functions. The exponential mechanism
    helps us cater to scenarios where the utility is to select the best response but
    where adding noise directly to the output of the query function would fully destroy
    the utility. In this section we’ll discuss some other DP mechanisms.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 第二章讨论了三种最流行的差分隐私机制：二元、拉普拉斯和对数。为了回顾，二元机制中的随机化来自二元响应（抛硬币），这有助于我们扰动结果。拉普拉斯机制通过向目标查询或函数添加来自拉普拉斯分布的随机噪声来实现
    DP。对数机制帮助我们应对那些效用是选择最佳响应但直接向查询函数的输出添加噪声会完全破坏效用的场景。在本节中，我们将讨论一些其他的 DP 机制。
- en: A.2.1 Geometric mechanism
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.2.1 几何机制
- en: The Laplace mechanism (discussed in section 2.2.2) adds real-value noise to
    a query function’s outputs. It works best for query functions that output real
    values, because adding the noise directly to the outputs won’t make the outcomes
    meaningless. For query functions that output integers, you can still add Laplace
    noise but apply a discretization mechanism after that. However, this could reduce
    the outcomes’ utility.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 拉普拉斯机制（在第 2.2.2 节中讨论）向查询函数的输出添加实值噪声。它最适合输出实值的查询函数，因为直接将噪声添加到输出中不会使结果变得无意义。对于输出整数的查询函数，你仍然可以添加拉普拉斯噪声，但之后需要应用离散化机制。然而，这可能会降低结果的效用。
- en: 'This is where the geometric mechanism comes in [2]. It is designed to add the
    discrete counterpart of Laplace noise (drawn from the geometric distribution)
    to query functions that have only integer output values. These are the definitions
    of geometric distribution and geometric mechanism:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正是几何机制在这里发挥作用 [2]。它被设计用来向只有整数输出值的查询函数添加拉普拉斯噪声的离散对应物（从几何分布中抽取）。以下是几何分布和几何机制的定义：
- en: '*Geometric distribution*—Given a real number α > 1, the geometric distribution
    denoted as *Geom*(α) is a symmetric distribution that takes integer values such
    that the probability mass function at *k* is ((*α* – 1) /(*α* + 1)) ⋅ *α*^(-|k|)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*几何分布*—给定一个大于 1 的实数 α，几何分布表示为 *Geom*(α) 是一个对称分布，它取整数值，其概率质量函数在 *k* 处为 ((*α*
    – 1) /(*α* + 1)) ⋅ *α*^(-|k|)'
- en: The geometric distribution has properties similar to the Laplace distribution.
    The variance of random variables drawn from *Geom*(α) is σ² = 2α/(1 - α)².
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 几何分布具有与拉普拉斯分布相似的性质。从 *Geom*(α) 中抽取的随机变量的方差为 σ² = 2α/(1 - α)²。
- en: '*Geometric mechanism*—Given a numerical query function f: ℕ^(|^X|) → ℤ^k, the
    database, x ∈ ℕ^(|^X|) , and the privacy budget ϵ, the geometric mechanism is
    defined as'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*几何机制*—给定一个数值查询函数 f: ℕ^(|^X|) → ℤ^k，数据库 x ∈ ℕ^(|^X|) ，以及隐私预算 ϵ，几何机制定义为'
- en: '![zhuang-appA-eqs-18x](../../OEBPS/Images/AppA_zhuang_eqs_18x.png)'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![zhuang-appA-eqs-18x](../../OEBPS/Images/AppA_zhuang_eqs_18x.png)'
- en: where *Y*[1] are independent and identically distributed random variables drawn
    from Geom(ϵ/Δf), and Δ*f* is the *l*[1]-sensitivity of query function *f*.
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其中 *Y*[1] 是从 Geom(ϵ/Δf) 中抽取的独立同分布随机变量，Δ*f* 是查询函数 *f* 的 *l*[1]-敏感性。
- en: THEOREM A.1 The geometric mechanism satisfies (ϵ, 0)-DP.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 A.1 几何机制满足 (ϵ, 0)-DP。
- en: The geometric mechanism could be applied to all the examples involving the Laplace
    mechanism in section 2.2.2, giving slightly better utility.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 几何机制可以应用于第 2.2.2 节中涉及拉普拉斯机制的示例，提供略微更好的效用。
- en: A.2.2 Gaussian mechanism
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.2.2 高斯机制
- en: The Gaussian mechanism [1] is another alternative to the Laplace mechanism.
    Instead of adding Laplace noise, the Gaussian mechanism adds Gaussian noise and
    provides a slightly relaxed privacy guarantee.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 高斯机制 [1] 是拉普拉斯机制的另一种替代方案。它不是添加拉普拉斯噪声，而是添加高斯噪声，并提供略微放宽的隐私保证。
- en: 'The Gaussian mechanism scales its noise to the *l*[2] sensitivity (compared
    with the Laplace mechanism, which scales to the *l*[1] sensitivity), defined as
    follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 高斯机制将其噪声缩放到 *l*[2] 敏感性（与拉普拉斯机制相比，它缩放到 *l*[1] 敏感性），如下定义：
- en: '*l*[2]*-sensitivity*—Given a numerical query function f: ℕ^(|^X|) → ℝ^k, for
    all pairs of databases, x, y ∈ ℕ^(|^X|), its *l*[2]-sensitivity is ![_zhuang-appA-eqs-22x](../../OEBPS/Images/AppA_zhuang_eqs_22x.png)
    .'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*l*[2]*-敏感性*—给定一个数值查询函数 f: ℕ^(|^X|) → ℝ^k，对于所有数据库对，x, y ∈ ℕ^(|^X|)，其 *l*[2]-敏感性是
    ![_zhuang-appA-eqs-22x](../../OEBPS/Images/AppA_zhuang_eqs_22x.png)。'
- en: 'We can define the Gaussian mechanism based on Gaussian distribution and *l*[2]-sensitivity
    as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据高斯分布和 *l*[2]-敏感性定义高斯机制如下：
- en: '*Gaussian mechanism*—Given a numerical query function f: ℕ^(|^X|) → ℝ^k, the
    database, x ∈ ℕ^(|^X|) , and the privacy budget ϵ and δ, the Gaussian mechanism
    is defined as'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*高斯机制*—给定一个数值查询函数 f: ℕ^(|^X|) → ℝ^k，数据库，x ∈ ℕ^(|^X|) ，以及隐私预算 ϵ 和 δ，高斯机制定义为'
- en: '![_zhuang-appA-eqs-23x](../../OEBPS/Images/AppA_zhuang_eqs_23x.png)'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![_zhuang-appA-eqs-23x](../../OEBPS/Images/AppA_zhuang_eqs_23x.png)'
- en: where *Y*[i] are independent and identically distributed random variables drawn
    from the Gaussian distribution τ = Δf √(2ln (1.25/ δ)) / ε, and Δ*f* is the *l*[2]-sensitivity
    of query function *f*.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其中 *Y*[i] 是从高斯分布 τ = Δf √(2ln (1.25/ δ)) / ε 中抽取的独立同分布随机变量，Δ*f* 是查询函数 *f* 的
    *l*[2]-敏感性。
- en: Theorem a.2 The Gaussian mechanism satisfies (ϵ, δ)-DP.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 a.2 高斯机制满足 (ϵ, δ)-DP。
- en: 'Compared with other random noise, adding Gaussian noise has two advantages:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他随机噪声相比，添加高斯噪声有两个优点：
- en: Gaussian noise is the same as many other sources of noise (e.g., white noise
    in communication channels).
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高斯噪声与其他许多噪声源相同（例如，通信通道中的白噪声）。
- en: The sum of Gaussian random variables results in a new Gaussian random variable.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高斯随机变量的和导致一个新的高斯随机变量。
- en: Those advantages make it easier to analyze and correct privacy-preserving machine
    learning algorithms that apply the Gaussian mechanism.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这些优点使得分析并纠正应用高斯机制的保护隐私机器学习算法变得更加容易。
- en: A.2.3 Staircase mechanism
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.2.3 梯度机制
- en: The staircase mechanism [3] is a special case of the Laplace mechanism. It aims
    to optimize the error bounds of the classic Laplace mechanism by tuning the tradeoff
    between the Laplace mechanism (whose probability density function is continuous)
    and the geometric mechanism (whose probability density function is discrete).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 梯度机制 [3] 是拉普拉斯机制的一种特殊情况。它通过调整拉普拉斯机制（其概率密度函数是连续的）和几何机制（其概率密度函数是离散的）之间的权衡来优化经典拉普拉斯机制的错误界限。
- en: 'In the staircase mechanism, we usually define a loss function L(⋅) : ℝ → ℝ,
    that is a function of the additive noise, where given additive noise *n*, the
    loss becomes *L*(*n*). Let t ∈ ℝ denote the output of the query function *f* (
    ), and *P*[t] denotes the probability distribution of the random variable that
    generates the additive noise. Then, the expectation of the loss function would
    be'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '在梯度机制中，我们通常定义一个损失函数 L(⋅) : ℝ → ℝ，这是一个关于加性噪声的函数，其中给定加性噪声 *n*，损失变为 *L*(*n*)。令
    t ∈ ℝ 表示查询函数 *f* ( ) 的输出，*P*[t] 表示生成加性噪声的随机变量的概率分布。那么，损失函数的期望将是'
- en: '![_zhuang-appA-eqs-27x](../../OEBPS/Images/AppA_zhuang_eqs_27x.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![zhuang-appA-eqs-27x](../../OEBPS/Images/AppA_zhuang_eqs_27x.png)'
- en: 'The staircase mechanism aims to minimize the worst-case cost among all possible
    query output t ∈ ℝ:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 梯度机制旨在最小化所有可能的查询输出 t ∈ ℝ 中的最坏情况成本：
- en: '![_zhuang-appA-eqs-28x](../../OEBPS/Images/AppA_zhuang_eqs_28x.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![_zhuang-appA-eqs-28x](../../OEBPS/Images/AppA_zhuang_eqs_28x.png)'
- en: For more information about how to formulate and solve such optimization problems,
    please refer to the original paper by Geng and Viswanath [3].
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何构建和解决此类优化问题的更多信息，请参阅Geng和Viswanath的原论文[3]。
- en: 'The staircase mechanism can be specified by three parameters: ϵ, Δ*f*, and
    γ^*, which is determined by ϵ and the loss function *L*( ). Figure A.1 illustrates
    the probability density functions of the Laplace and staircase mechanisms.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 梯度机制可以通过三个参数指定：ϵ、Δ*f* 和 γ^*，它由 ϵ 和损失函数 *L*( ) 确定。图A.1展示了拉普拉斯和梯度机制的概率密度函数。
- en: '![APPA_F01_Zhuang](../../OEBPS/Images/APPA_F01_Zhuang.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![APPA_F01_Zhuang](../../OEBPS/Images/APPA_F01_Zhuang.png)'
- en: Figure A.1 Probability density functions of the Laplace and staircase mechanisms
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图A.1 拉普拉斯和梯度机制的概率密度函数
- en: A.2.4 Vector mechanism
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.2.4 向量机制
- en: The vector mechanism is designed to perturb vector-valued functions, such as
    the convex objective functions of many ML algorithms (linear regression, ridge
    regression, support vector machines, etc.).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 向量机制旨在扰动向量值函数，例如许多机器学习算法的凸目标函数（线性回归、岭回归、支持向量机等）。
- en: 'The vector mechanism scales its noise to the *l*[2] sensitivity of a vector-valued
    function defined as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 向量机制将其噪声缩放到以下定义的向量值函数的 *l*[2] 敏感性：
- en: '*l*[2]*-sensitivity of a vector-valued function*—Given a vector-valued query
    function *f*, its *l*[2]-sensitivity is defined as the maximum change in the *l*[2]
    norm of the value of the function when one input changes:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量值函数的 *l*[2]*-sensitivity*——给定一个向量值查询函数 *f*，其 *l*[2] 敏感性定义为当输入变化时函数值在 *l*[2]
    范数中的最大变化：
- en: '![APPA_F01_zhuang-appA-eqs-29x](../../OEBPS/Images/APPA_F01_zhuang-appA-eqs-29x.png)'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![APPA_F01_zhuang-appA-eqs-29x](../../OEBPS/Images/APPA_F01_zhuang-appA-eqs-29x.png)'
- en: Once the *l*[2]-sensitivity of a vector-valued function has been defined (even
    though formulating such sensitivities in real scenarios, such as ML algorithms,
    is non-trivial), we could define the vector mechanism using independent and identically
    distributed random variables drawn from any other mechanisms, such as Lap(Δf/ϵ),
    where Δ*f* is the *l*[2]-sensitivity of the vector-valued function *f*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了向量值函数的 *l*[2] 敏感性（尽管在现实场景中，如机器学习算法中，构建此类敏感性是非平凡的），我们就可以使用从任何其他机制（如Lap(Δf/ϵ)，其中Δ*f*是向量值函数
    *f* 的 *l*[2] 敏感性）抽取的独立同分布随机变量来定义向量机制。
- en: A.2.5 Wishart mechanism
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.2.5 维斯哈特机制
- en: The Wishart mechanism [4] is designed to achieve DP on second moment matrices,
    such as covariance matrices. The basic idea is to add a Wishart noise matrix generated
    from a Wishart distribution to the second moment matrices. Since a Wishart matrix
    is always positive semidefinite, and can be considered as the scatter matrix of
    some random Gaussian vectors, it is a natural source of noise to generate the
    differentially private covariance matrix while maintaining its meaning and utility
    (because covariance matrices are always positive semidefinite and are also scatter
    matrices). Figure A.2 illustrates pseudocode for applying the Wishart mechanism
    on covariance matrices, where *W*d(⋅,⋅) is the Wishart distribution.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 维斯哈特机制[4]旨在在二次矩矩阵（如协方差矩阵）上实现差分隐私。基本思想是将从维斯哈特分布生成的维斯哈特噪声矩阵添加到二次矩矩阵中。由于维斯哈特矩阵始终是正半定的，并且可以被认为是某些随机高斯向量的散布矩阵，因此它是生成具有其意义和有用性的差分隐私协方差矩阵的自然噪声源（因为协方差矩阵始终是正半定的，也是散布矩阵）。图A.2展示了在协方差矩阵上应用维斯哈特机制的伪代码，其中
    *W*d(⋅,⋅) 是维斯哈特分布。
- en: '![APPA_F02_Zhuang](../../OEBPS/Images/APPA_F02_Zhuang.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![APPA_F02_Zhuang](../../OEBPS/Images/APPA_F02_Zhuang.png)'
- en: Figure A.2 Pseudocode for applying the Wishart mechanism
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图A.2 应用维斯哈特机制的伪代码
- en: A.3 Formal definitions of composition properties of DP
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.3 差分隐私的组成属性的形式定义
- en: One very important and useful property of DP is its composition theorems. The
    rigorous mathematical design of DP enables the analysis and control of cumulative
    privacy loss over multiple differentially private computations. There are two
    main composition properties, and we discussed them in detail in section 2.3.3\.
    In this section we’ll explore the mathematical definitions of these properties.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 差分隐私的一个重要且有用的属性是其组成定理。差分隐私的严谨数学设计使得分析和控制多个差分隐私计算中的累积隐私损失成为可能。有两个主要组成属性，我们已在第2.3.3节中详细讨论了它们。在本节中，我们将探讨这些属性数学定义。
- en: A.3.1 The formal definition of sequential composition DP
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.3.1 序列组成的差分隐私的形式定义
- en: The sequential composition property of DP confirms that the cumulative privacy
    leakage from multiple queries on data is always higher than the single query leakage
    (figure A.3). For example, if the first query’s DP analysis is performed with
    a privacy budget of ϵ[1] = 0.1, and the second has a privacy budget of ϵ[2] =
    0.2, the two analyses can be viewed as a single analysis with a privacy loss parameter
    that is potentially larger than ϵ[1] or ϵ[2] but at most ϵ[3] = ϵ[1] + ϵ[2] =
    0.3.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: DP 的序列组合属性确认了从数据的多次查询中累积的隐私泄露总是高于单次查询的泄露（图 A.3）。例如，如果第一次查询的 DP 分析使用隐私预算 ϵ[1]
    = 0.1，第二次查询的隐私预算为 ϵ[2] = 0.2，这两个分析可以视为一个具有可能大于 ϵ[1] 或 ϵ[2] 但最多为 ϵ[3] = ϵ[1] +
    ϵ[2] = 0.3 的隐私损失参数的单次分析。
- en: '![APPA_F03_Zhuang](../../OEBPS/Images/APPA_F03_Zhuang.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![APPA_F03_Zhuang](../../OEBPS/Images/APPA_F03_Zhuang.png)'
- en: Figure A.3 Sequential composition
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A.3 序列组合
- en: We’ll start with a simple case, where there are two independent DP algorithms,
    an (ϵ[1], 0)-DP algorithm *M*[1] and an (ϵ[2], 0)-DP algorithm *M*[2]. If one
    applies *M*[1] and *M*[2] sequentially (where the output of *M*[1] becomes the
    input of *M*[2]), then it follows the two-sequential composition theorem that
    follows.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个简单的案例开始，其中有两个独立的差分隐私算法，一个(ϵ[1], 0)-DP算法 *M*[1] 和一个(ϵ[2], 0)-DP算法 *M*[2]。如果依次应用
    *M*[1] 和 *M*[2]（其中 *M*[1] 的输出成为 *M*[2] 的输入），那么它遵循以下的双序列组合定理。
- en: 'Theorem a.3 Two-sequential composition: Let M[1] : ℕ^(|X|) → R[1] denote a
    randomized algorithm that is (ϵ[1], 0)-DP, and let M[2] : ℕ^(|X|) → R[2] denote
    a randomized algorithm that is (ϵ[2], 0)-DP. The sequential composition of these
    two, denoted as M[1,2] : ℕ^(|X|) → R[1] × R[2] by the mapping M[1,2] (x) = (M[1](x),
    M[2](x)), satisfies (ϵ[1] + ϵ[2], 0)-DP.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 a.3 双序列组合：令 M[1] : ℕ^(|X|) → R[1] 表示一个(ϵ[1], 0)-DP的随机算法，令 M[2] : ℕ^(|X|)
    → R[2] 表示一个(ϵ[2], 0)-DP的随机算法。这两个算法的序列组合，表示为 M[1,2] : ℕ^(|X|) → R[1] × R[2]，通过映射
    M[1,2] (x) = (M[1](x), M[2](x))，满足(ϵ[1] + ϵ[2], 0)-DP。'
- en: Having seen the two-sequential composition theorem, it should not be hard to
    extend it to a multi-sequential composition theorem that works for multiple independent
    DP algorithms that cascade sequentially, as follows.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在看到双序列组合定理之后，将其扩展到适用于多个独立 DP 算法级联的多序列组合定理应该不难，如下所示。
- en: 'Theorem a.4 Multi-sequential composition 1.0: Let M[i] : ℕ^(|X|) → R[i] denote
    a randomized algorithm that is (ϵ[i], 0)-DP. The sequential composition of k DP
    algorithms, *M*[i], *i* = 1, 2, ... , *k*, denoted as M[(k)] : ℕ^(|X|) → Π^k[i=1]R[i]
    by the mapping *M*[[k]](*x*) = (*M*[1](*x*), *M*[2](*x*), ..., *M*[k](*x*)) satisfies
    (Σ^k[i=1] ε[i], 0).'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 a.4 多序列组合 1.0：令 M[i] : ℕ^(|X|) → R[i] 表示一个(ϵ[i], 0)-DP的随机算法。k 个 DP 算法的序列组合，*M*[i]，其中
    i = 1, 2, ... , *k*，表示为 M[(k)] : ℕ^(|X|) → Π^k[i=1]R[i]，通过映射 *M*[[k]](*x*) = (*M*[1](*x*),
    *M*[2](*x*), ..., *M*[k](*x*)) 满足 (Σ^k[i=1] ε[i], 0)。'
- en: What if δ ≠ 0? What would the sequential composition look like? Take a look
    at the following theorem.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 δ ≠ 0 会怎样？序列组合会是什么样子？看看以下定理。
- en: 'Theorem a.5 Multi-sequential composition 2.0: Let M[i] : ℕ^(|X|) → R[i] denote
    a randomized algorithm that is (ϵ[i], δ[i])-DP. The sequential composition of
    *k* DP algorithms, *M*[i], *i* = 1, 2, ... , *k*, denoted as M[(k)] : ℕ^(|X|)
    → Π^k[i=1]R[i] by the mapping *M*[[k]](*x*) = (*M*[1](*x*), *M*[2](*x*), ...,
    *M*[k](*x*)) satisfies Σ^k[i=1] ε[i], Σ^k[i=1] δ[i])-DP.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 a.5 多序列组合 2.0：令 M[i] : ℕ^(|X|) → R[i] 表示一个(ϵ[i], δ[i])-DP的随机算法。k 个 DP 算法的序列组合，*M*[i]，其中
    i = 1, 2, ... , *k*，表示为 M[(k)] : ℕ^(|X|) → Π^k[i=1]R[i]，通过映射 *M*[[k]](*x*) = (*M*[1](*x*),
    *M*[2](*x*), ..., *M*[k](*x*)) 满足 Σ^k[i=1] ε[i], Σ^k[i=1] δ[i])-DP。'
- en: A.3.2 The formal definition of parallel composition DP
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.3.2 并行组合 DP 的形式定义
- en: Now let’s move to the parallel composition of DP. To summarize, if algorithm
    F[1](x[1]) satisfies ϵ[1]-DP, and F[2](x[2]) satisfies ϵ[2]-DP, where (x[1], x[2])
    is a nonoverlapping partition of the whole dataset x (figure A.4), the parallel
    composition of F[1](x[1]) and F[2](x[2]) satisfies max(ϵ[1], ϵ[2])-DP.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们转向 DP 的并行组合。总结来说，如果算法 F[1](x[1]) 满足 ϵ[1]-DP，F[2](x[2]) 满足 ϵ[2]-DP，其中 (x[1],
    x[2]) 是整个数据集 x 的非重叠划分（图 A.4），F[1](x[1]) 和 F[2](x[2]) 的并行组合满足 max(ϵ[1], ϵ[2])-DP。
- en: '![APPA_F04_Zhuang](../../OEBPS/Images/APPA_F04_Zhuang.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![APPA_F04_Zhuang](../../OEBPS/Images/APPA_F04_Zhuang.png)'
- en: Figure A.4 Parallel composition
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A.4 并行组合
- en: Suppose a single database *x* has been portioned into *k* disjoint subsets,
    *x*[i]. Here, “disjoint” ensures that any pair of the subsets, *x*[i], *x*[j]
    are independent of each other. In this context there may be *k* independent DP
    algorithms, but all of them satisfy the same (ϵ, 0)-DP, and each algorithm *M*[i]
    exclusively takes care of one subset *x*[i]. The following parallel composition
    theorem will allow us to combine those *k* DP algorithms.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 假设单个数据库 *x* 已经被分割成 *k* 个不相交的子集，*x*[i]。在这里，“不相交”确保了任何两个子集，*x*[i] 和 *x*[j]，彼此独立。在这种情况下，可能有
    *k* 个独立的差分隐私算法，但它们都满足相同的 (ϵ, 0)-DP，并且每个算法 *M*[i] 专门负责一个子集 *x*[i]。以下并行组合定理将允许我们组合这
    *k* 个差分隐私算法。
- en: 'Theorem a.6 Parallel composition 1.0: Let M[i] : ℕ^(|X|) → R[i] denote a randomized
    algorithm that is (ϵ, 0)-DP, where *i* = 1, 2, ... , *k*. The parallel composition
    of *k* DP algorithms, *M*[i], *i* = 1, 2, ... , *k*, denoted as M[(k)] : ℕ^(|X|)
    → Π^k[i=1]R[i] by the mapping *M*[[k]](*x*) = (*M*[1](*x*[1]), *M*[2](*x*[2]),
    ..., *M*[k](*x*[k])), where *x*[i], *i* = 1, 2, ... , *k*, represent *k* disjoint
    subsets of database *x*, satisfies (ϵ, 0)-DP.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 a.6 并行组合 1.0：令 M[i] : ℕ^(|X|) → R[i] 表示一个随机算法，它是 (ϵ, 0)-DP，其中 *i* = 1, 2,
    ... , *k*。*k* 个差分隐私算法的并行组合，*M*[i]，*i* = 1, 2, ... , *k*，表示为 M[(k)] : ℕ^(|X|) →
    Π^k[i=1]R[i]，通过映射 *M*[[k]](*x*) = (*M*[1](*x*[1]), *M*[2](*x*[2]), ..., *M*[k](*x*[k]))，其中
    *x*[i]，*i* = 1, 2, ... , *k* 代表数据库 *x* 的 *k* 个不相交子集，满足 (ϵ, 0)-DP。'
- en: What if all the DP algorithms use DP budgets, thus satisfying different levels
    of DP in the parallel composition scenario? The following theorem provides the
    solution to this situation.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有差分隐私算法都使用差分隐私预算，从而在并行组合场景中满足不同级别的差分隐私，那会怎样？以下定理提供了这种情况的解决方案。
- en: 'Theorem a.7 Parallel composition 2.0: Let M[i] : ℕ^(|X|) → R[i] denote a randomized
    algorithm that is (ϵ[i], 0)-DP, where *i* = 1, 2, ... , *k*. The parallel composition
    of *k* DP algorithms, *M*[i] , *i* = 1, 2, ... , *k*, denoted as M[(k)] : ℕ^(|X|)
    → Π^k[i=1]R[i] by the mapping *M*[[][k][]](x) = (*M*[1](*x*[1]), *M*[2](*x*[2]),
    ..., *M*[k](*x*[k])), where *x*[i] , *i* = 1, 2, ... , *k*, represent *k* disjoint
    subsets of database *x*, satisfies (max ϵ[i], 0)-DP.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 a.7 并行组合 2.0：令 M[i] : ℕ^(|X|) → R[i] 表示一个随机算法，它是 (ϵ[i], 0)-DP，其中 *i* = 1,
    2, ... , *k*。*k* 个差分隐私算法的并行组合，*M*[i]，*i* = 1, 2, ... , *k*，表示为 M[(k)] : ℕ^(|X|)
    → Π^k[i=1]R[i]，通过映射 *M*[[][k][]](x) = (*M*[1](*x*[1]), *M*[2](*x*[2]), ..., *M*[k](*x*[k]))，其中
    *x*[i]，*i* = 1, 2, ... , *k* 代表数据库 *x* 的 *k* 个不相交子集，满足 (max ϵ[i], 0)-DP。'
