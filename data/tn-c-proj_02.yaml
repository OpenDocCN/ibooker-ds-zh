- en: 2 Daily greetings
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 每日问候
- en: 'Your computer day starts when you sign in. The original term was log in, but
    because trees are so scarce and signs are so plentiful, the term was changed by
    the Bush administration in 2007\. Regardless of such obnoxious federal overreach,
    your computer day can start with a cheerful greeting after you sign in or open
    a terminal window, customized by a tiny C program. To make it so, you will:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你的电脑一天从你登录开始。原始术语是登录，但由于树木如此稀少，标志如此众多，这个术语在 2007 年被布什政府所改变。不管这种令人讨厌的联邦过度干预，你可以在登录或打开终端窗口后，通过一个小小的
    C 程序定制一个愉快的问候。为了实现这一点，你需要：
- en: Review the Linux startup process.
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回顾 Linux 启动过程。
- en: Discover where in the shell script to add your greeting.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现在哪里添加你的问候信息。
- en: Write a simple greetings program.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个简单的问候程序。
- en: Modify your greetings program to add the time of day.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改你的问候程序以添加时间。
- en: Update the timestamp with the current moon phase.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新时间戳以显示当前月相。
- en: Enhance your greetings message with a bon mot.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用一句俏皮话增强你的问候信息。
- en: The programs created and expanded upon in this chapter are specific to Linux,
    macOS, and the Windows Subsystem for Linux (WSL), where a startup script is available
    for configuring the terminal window. A later section explains which startup scripts
    are available for the more popular shells. This chapter doesn’t go into creating
    a daily greeting message when the GUI shell starts.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章创建和扩展的程序特定于 Linux、macOS 和 Windows Subsystem for Linux (WSL)，在这些系统中，启动脚本可用于配置终端窗口。稍后的部分将解释哪些启动脚本适用于更流行的
    shell。本章不会涉及在 GUI shell 启动时创建每日问候信息。
- en: I suppose you could add a startup message for the Windows terminal screen, the
    command prompt. It’s possible, but the process bores me, and only hardcore Windows
    nerds would care, so I’m skipping the specifics. The greetings programs still
    run at the Windows command prompt, if that’s your desire. Otherwise, you may lodge
    your complaints with me personally; my email address is found in this book’s introduction.
    I promise not to answer a single email from a whiny Windows user.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我猜你可以在 Windows 终端屏幕、命令提示符中添加一条启动信息。这是可能的，但这个过程让我感到无聊，而且只有那些狂热的 Windows 极客才会关心，所以我就不具体说明了。如果你有这个愿望，问候程序仍然会在
    Windows 命令提示符中运行。否则，你可以直接向我个人提出投诉；我的电子邮件地址可以在本书的引言中找到。我保证不会回复任何抱怨的 Windows 用户发来的邮件。
- en: 2.1 The shell starts
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 shell 启动
- en: Linux has a long, involved, and thoroughly exciting boot process. I’m certain
    that you’re eager to read all the nitty-gritty details. But this book is about
    C programming. You must seek out a Linux book to know the complete, torrid steps
    involved with rousing a Linux computer. The exciting stuff relevant to creating
    a daily greeting happens later, after the operating system completes its morning
    routine, when the shell starts.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 的启动过程漫长、复杂且非常激动人心。我确信你急于阅读所有这些细节。但本书是关于 C 编程的。你必须寻找一本关于 Linux 的书籍，以了解唤醒
    Linux 计算机所涉及的完整、热烈的步骤。与创建每日问候相关的激动人心的事情发生在操作系统完成早晨例程之后，当 shell 开始运行时。
- en: 2.1.1 Understanding how the shell fits in
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.1 理解 shell 的位置
- en: Each user account on a Linux system is assigned a default shell. This shell
    was once the only interface for Linux. I recall booting into an early version
    of Red Hat Linux back in the 1990s and the first—and only—thing I saw was a text
    mode screen. Today things are graphical, and the shell has been shunted off to
    a terminal window. It’s still relevant at this location, which is great for C
    programming.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 系统上的每个用户账户都被分配了一个默认 shell。这个 shell 曾经是 Linux 的唯一接口。我记得在 1990 年代早期启动了一个
    Red Hat Linux 的早期版本，我看到的第一个——也是唯一一件事——就是一个文本模式的屏幕。今天事情都是图形化的，shell 被移到了一个终端窗口中。在这里它仍然很重要，这对于
    C 编程来说是个好消息。
- en: The default shell is configured by the something-or-other. I’m too lazy to write
    about it here. Again, this isn’t a Linux book. Suffice it to say that your account
    most likely uses the *bash* shell—a collision of the words “Bourne again shell,”
    so my writing “*bash* shell” is redundant (like ATM machine), but it looks awkward
    otherwise.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 默认 shell 是由某个东西配置的。我太懒了，不想在这里写关于它的事情。再次强调，这不是一本关于 Linux 的书。简单地说，你的账户很可能使用的是
    *bash* shell——这是“Bourne again shell”这个词的碰撞，所以我的“*bash* shell”写作是多余的（就像 ATM 机一样），但如果不这样写看起来又很别扭。
- en: 'To determine the default shell, start a terminal window. At the prompt, type
    the command **echo $SHELL**:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定默认 shell，启动一个终端窗口。在提示符下，输入命令 **echo $SHELL**：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, the output confirms that the assigned user shell is *bash*. The $SHELL
    argument represents the environment variable assigned to the startup shell, which
    is /bin/bash here. This output may not reflect the current shell—for example,
    if you’ve subsequently run the *sh* or *zsh* or similar command to start another
    shell.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，输出确认分配给用户的 shell 是 *bash*。$SHELL 参数代表分配给启动 shell 的环境变量，在这里是 /bin/bash。此输出可能不反映当前
    shell——例如，如果您随后运行了 *sh* 或 *zsh* 或类似命令以启动另一个 shell。
- en: 'To determine the current shell, type the command **ps -p $$**:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定当前 shell，请输入命令 **ps -p $$**：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This output shows the shell command is bash, meaning the current shell is *bash*
    regardless of the $SHELL variable’s assignment.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出显示 shell 命令是 bash，这意味着无论 $SHELL 变量的分配如何，当前 shell 都是 *bash*。
- en: To change the shell, use the *chsh* command. The command is followed by the
    new shell name. Changing the shell affects only your account and applies to any
    new terminal windows you open after issuing the command. That’s enough Linux for
    today.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改 shell，请使用 *chsh* 命令。命令后跟新的 shell 名称。更改 shell 只会影响您的账户，并适用于您在发出命令后打开的任何新终端窗口。今天关于
    Linux 的内容就到这里。
- en: 2.1.2 Exploring various shell startup scripts
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.2 探索各种 shell 启动脚本
- en: When a shell starts, it processes commands located in various startup scripts.
    Some of these scripts may be global, located in system directories. Others are
    specific to your account, located locally in your home folder.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当 shell 启动时，它会处理位于各种启动脚本中的命令。其中一些脚本可能是全局的，位于系统目录中。其他脚本可能特定于您的账户，位于您的主目录中。
- en: Startup scripts configure the terminal. They allow you to customize the horrid
    text-only experience, perhaps adding colors, creating shortcuts, and performing
    various tasks you may otherwise have to manually perform each time a terminal
    window opens. Any startup script file located in your home directory is yours
    to configure.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 启动脚本配置终端。它们允许您自定义令人讨厌的纯文本体验，例如添加颜色、创建快捷方式以及执行您可能需要每次打开终端窗口时手动执行的各种任务。位于您主目录中的任何启动脚本文件都是您可以配置的。
- en: Given all that, the general advice is not to mess with startup shell scripts.
    To drive home this point, the shell script files are hidden in your home directory.
    The filenames are prefixed with a single dot. The dot prefix hides files from
    appearing in a standard directory listing. This stealth allows the files to be
    handy yet concealed from a casual user’s attempts to meddle with them.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 综上所述，一般建议不要干涉启动 shell 脚本。为了强调这一点，shell 脚本文件隐藏在您的 home 目录中。文件名以单个点开头。点前缀隐藏文件，使其不会出现在标准目录列表中。这种隐蔽性使得文件便于使用，同时又能防止普通用户尝试干涉它们。
- en: Because you want to meddle with the shell startup script, specifically to add
    a personalized greeting, it’s necessary to know the script names. These names
    can differ, depending upon the shell, though the preferred startup script to edit
    appears in table 2.1.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 因为您想干涉 shell 启动脚本，特别是要添加个性化的问候语，所以有必要知道脚本名称。这些名称可能因 shell 而异，尽管在表 2.1 中显示的启动脚本通常是首选的。
- en: Table 2.1 Tediously dry info regarding Linux shell scripts
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.1 关于 Linux shell 脚本的枯燥信息
- en: '| Shell | Name | Command | Startup filename |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| Shell | 名称 | 命令 | 启动文件名 |'
- en: '| Bash | Bash, “Bourne again shell” | */bin/bash* | .bash_profile |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| Bash | Bash，“Bourne again shell” | */bin/bash* | .bash_profile |'
- en: '| Tsch | Tee C shell | */bin/tsch* | .tcshrc |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| Tsch | Tee C shell | */bin/tsch* | .tcshrc |'
- en: '| Csh | C shell | */bin/csh* | .cshrc |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| Csh | C shell | */bin/csh* | .cshrc |'
- en: '| Ksh | Korn shell | */bin/ksh* | .profile |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| Ksh | Korn shell | */bin/ksh* | .profile |'
- en: '| Sh | Bourne shell | */bin/sh* | .profile |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| Sh | Bourne shell | */bin/sh* | .profile |'
- en: '| Zsh | Z shell | */bin/zsh* | .zshrc |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| Zsh | Z shell | */bin/zsh* | .zshrc |'
- en: For example, for the *bash* shell, I recommend editing the startup script .bash_profile
    to add your greeting. Other startup scripts may run when the shell starts, but
    this is the script you can modify.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于 *bash* shell，我建议编辑启动脚本 .bash_profile 以添加您的问候语。其他启动脚本可能在 shell 启动时运行，但这是您可以修改的脚本。
- en: 'To view your shell’s startup script, use the *cat* command in a terminal window.
    Follow the command with the shell’s startup filename. For example:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看您的 shell 启动脚本，请在终端窗口中使用 *cat* 命令。在命令后跟 shell 的启动文件名。例如：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The ~/ pathname is a shortcut for your home directory. After you issue the preceding
    command, the contents of the shell startup script vomit all over the text screen.
    If not, the file may not exist and you need to create it.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ~/ 路径名是您主目录的快捷方式。在您发出前面的命令后，shell 启动脚本的内容会散布在文本屏幕上。如果不是这样，文件可能不存在，您需要创建它。
- en: When you see the file’s contents, somewhere in the morass you can stick your
    greetings program on a line by itself. The rest of the script shouldn’t be meddled
    with—unless you’re adept at coding in the scripting language and crafting brilliant
    startup scripts, which you probably aren’t.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当你看到文件内容时，你可以在混乱中单独放置你的问候程序。脚本的其他部分不应该被篡改——除非你擅长用脚本语言编码并制作出色的启动脚本，这你可能不是。
- en: 2.1.3 Editing the shell startup script
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.3 编辑shell启动脚本
- en: Shell startup scripts are plain text files. They consist of shell commands,
    program names, and various directives, which makes the script work like a programming
    language. The script is edited like any text file.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Shell启动脚本是纯文本文件。它们由shell命令、程序名称和各种指令组成，这使得脚本像编程语言一样工作。脚本像任何文本文件一样进行编辑。
- en: 'I could wax eloquent for several pages about shell scripting, but I have a
    dental appointment in an hour and this book is about C programming. Still, you
    should note two relevant aspects of a startup shell script: the very first line
    and the file’s permissions.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以就shell脚本写几页精彩的文字，但我有一个小时后要去看牙医，这本书是关于C编程的。尽管如此，你应该注意启动shell脚本的两个相关方面：第一行和文件的权限。
- en: 'To interpret the lines of text in a startup script, the very first line of
    the file directs the shell to use a specific program to process the remaining
    lines in the file. Traditionally, the first line of a Unix shell script is:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释启动脚本中的文本行，文件的第一行指示shell使用一个特定的程序来处理文件中剩余的行。传统上，Unix shell脚本的第一行是：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This line starts with the #, which makes it a comment. The exclamation point,
    which the cool kids tell me is pronounced “bang,” directs the shell to use the
    /bin/sh program (the original Bourne shell) to process the remaining lines of
    text in the file. The command could be anything, from a shell like bash to a utility
    like *expect*.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行以#开头，这使得它成为一条注释。感叹号，酷孩子们告诉我读作“bang”，指示shell使用/bin/sh程序（原始Bourne shell）来处理文件中剩余的文本行。命令可以是任何东西，从bash这样的shell到*expect*这样的实用程序。
- en: 'All shell scripts have their executable permissions bit set. If the file exists,
    this setting is already made. Otherwise, if you’re creating the shell script,
    you must bless it with the executable bit after the file is created. Use the chmod
    command with the +x switch, followed by the script filename:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 所有shell脚本都设置了可执行权限位。如果文件存在，这个设置已经完成。否则，如果你正在创建shell脚本，必须在文件创建后赋予它可执行位。使用chmod命令并带上+x开关，然后跟脚本文件名：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Issuing this command is required only when you initially create the script.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 发出此命令仅在你最初创建脚本时需要。
- en: 'Within the startup script, my recommendation is to set your greetings program
    on a line by itself at the end of the script. You can even prefix it with a comment,
    starting the line before with the # character. The cool kids have informed me
    that # is pronounced “hash.”'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动脚本中，我的建议是将你的问候程序单独放在脚本末尾的一行上。你甚至可以在该行之前加上注释，以#字符开始。酷孩子们告诉我#读作“hash”。
- en: 'For practice, edit the terminal window’s startup script: open a terminal window
    and use your favorite text editor to open the shell’s startup script, as noted
    in table 2.1\. For example, on my Linux system, I type:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了练习，编辑终端窗口的启动脚本：打开一个终端窗口，并使用你喜欢的文本编辑器打开shell的启动脚本，如表2.1中所述。例如，在我的Linux系统中，我输入：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add the following two lines at the bottom of the script, after all the stuff
    that looks impressive and tempting:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本底部添加以下两行，在所有看起来令人印象深刻和诱人的内容之后：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The first line is prefixed with a #. (I hope you said “hash” in your head.)
    This tag marks the line as a comment.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行以#开头。（我希望你在心里说的是“hash”。）这个标签将这一行标记为注释。
- en: The second line outputs the text "Hello" followed by the contents of environment
    variable $LOGNAME. This variable represents your login account name.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行输出文本“Hello”，后跟环境变量$LOGNAME的内容。这个变量代表你的登录账户名。
- en: 'Here’s sample output:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是示例输出：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: My account login is *dang*, as shown. This line of text is the final output
    generated by the shell startup script when the terminal window first opens. The
    C programs generated for the remainder of this chapter replace this line, outputting
    their cheerful and interesting messages.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我的账户登录名是*dang*，如所示。当终端窗口首次打开时，这一行文本是shell启动脚本生成的最终输出。本章剩余部分生成的C程序将替换这一行，输出它们愉快和有趣的消息。
- en: 'When adding your greetings program to the startup script, it’s important that
    you specify its pathname, lest the shell script interpreter freak out. The path
    can be full, as in:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当将你的问候语程序添加到启动脚本中时，指定其路径名非常重要，以免 shell 脚本解释器崩溃。路径可以是完整的，如下所示：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Or it can use the ~/ home directory shortcut:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 或者可以使用 ~/ 主目录快捷方式：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In both cases, the program is named greetings, and it dwells in the cprog directory.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，程序名为 greetings，它位于 cprog 目录中。
- en: 2.2 A simple greeting
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 简单问候
- en: All major programming projects start out simple and have a tendency to grow
    into complex, ugly monsters. I’m certain that Excel began its existence as a quick-and-dirty,
    text mode calculator—and now look at it. Regardless, it’s good programming practice
    not to begin a project by coding everything you need all at once. No, it’s best
    to grow the project, starting with something simple and stupid, which is the point
    of this section.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 所有主要的编程项目最初都很简单，并且倾向于发展成为复杂、丑陋的怪物。我确信 Excel 是作为一个快速而粗糙的文本模式计算器开始的——现在看看它。无论如何，良好的编程实践不是一开始就编写所有你需要的东西。不，最好的做法是从简单而愚蠢的东西开始，这正是本节的目的。
- en: 2.2.1 Coding a greeting
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.1 编写问候语
- en: The most basic greetings program you can make is a simple regurgitation of the
    silly *Hello World* program that ushers in the pages of every introductory C programming
    book since Moses. Listing 2.1 shows the version you could write for your greetings
    program.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你能制作的最基本的问候语程序是对每个自摩西以来每本C语言入门书籍中出现的愚蠢 *Hello World* 程序的简单重复。列表 2.1 展示了你可以为你的问候语程序编写的版本。
- en: Listing 2.1 Source code for greet01.c
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.1 greet01.c 的源代码
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Don’t build. Don’t run. If you do, use this command to build a program named
    greetings:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 不要构建。不要运行。如果你这样做，请使用以下命令构建一个名为 greetings 的程序：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You may substitute *clang* with your favorite-yet-inferior compiler. Upon success,
    the resulting program is named greetings. Set this program into your shell’s startup
    script, adding the last line that looks like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用你喜欢的但性能稍逊的编译器替换 *clang*。成功后，生成的程序命名为 greetings。将此程序添加到你的 shell 启动脚本中，添加最后一行，如下所示：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Ensure that you prefix the program name with a pathname—either the full pathname,
    like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在程序名称前加上路径名——无论是完整的路径名，如下所示：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'or a relative pathname:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 或者是一个相对路径名：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The startup script cannot magically locate program files, unless you specify
    a path, such as my personal ~/bin directory shown in the examples. (I also use
    my shell startup script to place my personal ~/bin directory on the search path—another
    Linux trick found in another book somewhere.)
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 启动脚本不能神奇地定位程序文件，除非你指定路径，例如示例中显示的我的个人 ~/bin 目录。（我还使用我的 shell 启动脚本将我的个人 ~/bin
    目录添加到搜索路径——这是在另一本书中找到的另一个 Linux 技巧。）
- en: 'After the startup script is updated, the next terminal window you open runs
    a startup script that outputs the following line, making your day more cheerful:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 启动脚本更新后，你打开的下一个终端窗口将运行一个启动脚本，输出以下行，让你的日子更加愉快：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: And if your name isn’t Dan, then the greeting is more puzzling than cheerful.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的名字不是 Dan，那么问候语比愉快更让人困惑。
- en: 2.2.2 Adding a name as an argument
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.2 添加名称作为参数
- en: The initial version of the greetings program is inflexible. That’s probably
    why you didn’t code it and are instead eager to modify it with some customization.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 问候语程序的初始版本不够灵活。这可能是你没有编写它，而是急于对其进行一些定制修改的原因。
- en: Consider the modest improvement offered in listing 2.2\. This update to the
    code allows you to present the program with an argument, allowing it to be flexible.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑列表 2.2 中提供的适度改进。此代码更新允许你向程序提供一个参数，使其更加灵活。
- en: Listing 2.2 Source code for greet02.c
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.2 greet02.c 的源代码
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ The argument count is always 1 for the program name; if so, a default message
    is output.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 程序名称的参数计数始终为 1；如果是这样，则输出默认消息。
- en: ❷ The first word typed after the program name is represented as argv[1] and
    is output here.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 程序名称后面的第一个单词表示为 argv[1]，并在此输出。
- en: 'Build this code into a program and thrust it into your shell’s startup script
    as written in the ancient scrolls but also in the preceding section:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码构建成一个程序，并将其按照古老卷轴中以及上一节中所述的方式放入你的 shell 启动脚本中。
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The program now outputs the following message when you open a new terminal
    window:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打开一个新的终端窗口时，程序现在输出以下消息：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This new message is far more cheerful than the original but still begging for
    some improvement.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这条新消息比原始消息更加愉快，但仍需一些改进。
- en: 2.3 The time of day
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 问候时间
- en: One of the first programs I wrote for my old DOS computer greeted me every time
    I turned on the computer. The program was similar to those created in the last
    two sections, which means it was boring. To spice it up, and inspired by my verbal
    interactions with humans I encounter in real life, I added code to make the greeting
    reflect the time of day. You can do so as well with varying degrees of accuracy.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我为我的旧 DOS 计算机编写的第一个程序是在每次开机时向我问候。这个程序与上一节中创建的程序类似，这意味着它很无聊。为了增加趣味性，并受我在现实生活中与人类互动的启发，我添加了代码，使问候语反映一天中的时间。你也可以这样做，并且可以以不同的精度实现。
- en: 2.3.1 Obtaining the current time
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.1 获取当前时间
- en: Does anyone really know what time it is? The computer can guess. It keeps semi-accurate
    time because it touches base with an internet time server every so often. Otherwise,
    the computer’s clock would be off by several minutes every day. Trust me, computers
    make lousy clocks, but this truth doesn’t stop you from plucking the current time
    from its innards.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 真的有谁知道现在是什么时间吗？计算机可以猜测。它通过每隔一段时间与互联网时间服务器接触来保持半准确的时间。否则，计算机的时钟每天都会偏差几分钟。相信我，计算机是糟糕的时钟，但这并不意味着你不能从其内部提取当前时间。
- en: The C library is rife with time functions, all defined in the time.h header
    file. The *time_t* data type is also defined in the header. This positive integer
    value (*long* data type, *printf()* placeholder %ld) stores the Unix epoch, the
    number of seconds ticking away since midnight January 1, 1970.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: C 库中充满了时间函数，所有这些函数都在 time.h 头文件中定义。*time_t* 数据类型也在该头文件中定义。这个正整数值（*long* 数据类型，*printf()*
    占位符 %ld）存储了 Unix 纪元，即自 1970 年 1 月 1 日午夜以来的滴答声秒数。
- en: 'The Unix epoch is a great value to use in your greetings program. For example,
    imagine your joy at seeing—every day when you start the terminal—the following
    jolly message:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Unix 纪元是在你的问候程序中可以使用的一个很好的值。例如，想象一下，每天当你启动终端时，看到以下愉快的消息：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Try to hold back any emotion.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量抑制任何情绪。
- en: Of course, the *time_t* value must be manipulated into something a bit more
    useful. Listing 2.3 shows some sample code. Be aware that many time functions,
    such as *time()* and *ctime()* used in the code for time01.c, require the address
    of the *time_t* variable. Yup, they’re pointers.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，必须将 *time_t* 值转换为更有用的东西。列表 2.3 展示了一些示例代码。请注意，许多时间函数，如 time01.c 代码中使用的 *time()*
    和 *ctime()*，需要 *time_t* 变量的地址。是的，它们是指针。
- en: Listing 2.3 Source code for time01.c
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.3 time01.c 的源代码
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ The time.h header file is required, lest the compiler become cross with you.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 需要 time.h 头文件，否则编译器会对你不满。
- en: ❷ The *time()* function requires the *time_t* variable’s address, prefixed here
    with the & address-of operator.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ *time()* 函数需要 *time_t* 变量的地址，这里用 & 地址运算符作为前缀。
- en: ❸ The ctime() function requires a pointer argument and returns a string appended
    with a newline.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ *ctime()* 函数需要一个指针参数，并返回一个附加了换行符的字符串。
- en: 'Here is sample output from the resulting program:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是程序输出的示例：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The output shows the number of seconds of tick-tocking since 1970\. This same
    value is swallowed by the *ctime()* function to output a formatted time string.
    This result may be acceptable in your greetings program, but time data can be
    customized further. The key to unlocking specific time details is found in the
    *localtime()* function, as the code in listing 2.4 demonstrates.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示了自 1970 年以来的滴答声秒数。这个相同的值被 *ctime()* 函数吞没，以输出格式化的时间字符串。这个结果在你的问候程序中可能是可以接受的，但时间数据可以进一步定制。解锁特定时间细节的关键在于
    *localtime()* 函数，正如列表 2.4 中的代码所展示的。
- en: Listing 2.4 Source code for time02.c
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.4 time02.c 的源代码
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ Because *localtime()* returns a pointer, it’s best to declare the structure
    as a pointer.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 因为 *localtime()* 返回一个指针，所以最好将结构声明为指针。
- en: ❷ The first day of the week is 0 for Sunday.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 一周的第一天是周日，值为 0。
- en: ❸ You must add 1900 to the tm_year member to get the current year; you will
    forget this.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 你必须将 1900 加到 tm_year 成员上以获取当前年份；你会忘记这一点。
- en: ❹ The tm_mon member ranges from 0 to 11.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ tm_mon 成员的范围是 0 到 11。
- en: 'I formatted the code in listing 2.4 with oodles of spaces so that you could
    easily identify the tm structure’s members. These variables represent the time
    tidbits that the *localtime()* function extracts from a time_t value. Ensure that
    you remember to adjust some values as shown in listing 2.4: the year value tm_year
    must be increased by 1900 to reflect the current, valid year; the month value
    tm_mon starts with zero, not one.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我用大量的空格格式化了列表 2.4 中的代码，这样你可以轻松地识别 tm 结构的成员。这些变量代表了 *localtime()* 函数从一个 time_t
    值中提取的时间片段。确保你记得根据列表 2.4 调整一些值：年值 tm_year 必须加 1900 以反映当前的有效年份；月份值 tm_mon 从零开始，而不是从一。
- en: The output is trivial, so I need not show it—unless you send me a check for
    $5\. Still, the point of the code is to show how you can obtain useful time information
    with which to properly pepper your terminal greetings.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 输出很简单，所以我无需展示——除非你给我一张 5 美元的支票。然而，代码的目的是展示你可以如何获取有用的时间信息，以便在终端问候中适当地点缀。
- en: 2.3.2 Mixing in the general time of day
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.2 混合一天中的通用时间
- en: The program I wrote years ago for my DOS computer was called GREET.COM. It was
    part of my computer’s AUTOEXEC.BAT program, which ran each time I started my trusty
    ol’ IBM PC. Because I’m fond of nostalgia, I’ve kept a copy of the program. Written
    in x86 Assembly, it still runs under DOSBox. Ah, the sweet perfume of the digital
    past. Smells like ozone.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我多年前为我的 DOS 计算机编写的程序叫做 GREET.COM。它是我的计算机 AUTOEXEC.BAT 程序的一部分，每次我启动我那可靠的旧 IBM
    PC 时都会运行。因为我喜欢怀旧，所以我保留了这个程序的副本。用 x86 汇编编写的它仍然可以在 DOSBox 下运行。啊，数字过去的甜美香气。闻起来像臭氧。
- en: 'Alas, I no longer have the source code for my GREET.COM program. From memory
    (and disassembly), I see that the code fetches the current hour of the day and
    outputs an appropriate time-of-day greeting: good morning, good afternoon, or
    good evening. You can code the same trick—though in C for your current computer
    and not in x86 Assembly for an ancient IBM PC.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 可惜，我不再拥有 GREET.COM 程序的源代码。根据记忆（和反汇编），我看到代码获取了当前的小时数，并输出相应的时间问候：早上好，下午好，或晚上好。你可以用同样的技巧编码——尽管是在为你的当前计算机编写的
    C 语言中，而不是在古老的 IBM PC 的 x86 汇编语言中。
- en: Pulling together resources from the first chunk of this chapter, listing 2.5
    shows a current version of my old greetings program.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章的第一部分汇集资源，列表 2.5 展示了我旧问候程序的当前版本。
- en: Listing 2.5 Source code for greet03.c
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.5 greet03.c 的源代码
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ This statement is a convenience to avoid using clock->tm_hour over and over.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这个语句是为了方便，避免反复使用 clock->tm_hour。
- en: ❷ Before noon, say “Good morning.”
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在中午之前，说“早上好”。
- en: ❸ From noon to 5:00 P.M., say “Good afternoon.”
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 从中午到下午 5:00，说“下午好”。
- en: ❹ Otherwise, it’s evening.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 否则，就是晚上。
- en: ❺ Check for and output the first command-line argument.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 检查并输出第一个命令行参数。
- en: 'Assuming that the built program is named greetings, that the user types in
    **Danny** as the command-line argument, and that it’s 4 o’clock in the afternoon,
    here is the code’s output:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 假设编译好的程序名为 greetings，用户输入 **Danny** 作为命令行参数，并且现在是下午 4 点，以下是代码的输出：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This code effectively replicates what I wrote decades ago as my GREET.COM program.
    The output is a cheery, time-relevant greeting given the current time of day.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码有效地复制了我几十年前编写的 GREET.COM 程序的内容。输出的是一个与当前时间相符的愉快问候。
- en: For extra humor, you can add a test for early hours, such as midnight to 4:00
    AM. Output some whimsical text such as “Working late?” or “Are you still up?”
    Oh, the jocularity! I hope your sides don’t hurt.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增加幽默感，你可以添加对早间时间的测试，比如午夜到凌晨 4:00。输出一些俏皮的文字，比如“工作到很晚吗？”或“你还在吗？”哦，多么的幽默！我希望你的肚子不会疼。
- en: 2.3.3 Adding specific time info
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.3 添加特定时间信息
- en: 'Another way to treat yourself when you open a terminal window is to output
    a detailed time string. The simple way to accomplish this task is to output the
    greeting followed by a time string generated by the *ctime()* function. Here are
    the two relevant lines of code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打开终端窗口时，另一种款待自己的方式是输出一个详细的时间字符串。完成这个任务的简单方法是输出问候语，然后是 *ctime()* 函数生成的时间字符串。以下是相关的两行代码：
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: These two statements reflect code presented earlier in this chapter, so you
    get the idea. Still, the program is lazy. Better to incorporate the *strftime()*
    function, which formats a timestamp string according to your specifications.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个语句反映了本章前面展示的代码，所以你能够理解。尽管如此，程序还是有点懒散。最好结合使用 *strftime()* 函数，该函数根据您的指定格式化时间戳字符串。
- en: The *strftime()* function works like *printf()*, with a special string that
    formats time information. The function’s output is saved in a buffer, which your
    code can use later. The code shown in listing 2.6 demonstrates.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*strftime()*函数的工作方式类似于*printf()*，它使用一个特殊的字符串来格式化时间信息。函数的输出被保存在一个缓冲区中，你的代码可以在以后使用。示例代码2.6展示了这一点。'
- en: Listing 2.6 Source code for greet04.c
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.6 greet04.c的源代码
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ Storage for the string filled by the *strftime()* function
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 由*strftime()*函数填充的字符串存储
- en: ❷ You must fill a localtime() tm structure to make the strftime() function work.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 你必须填充一个localtime() tm结构，才能使strftime()函数正常工作。
- en: 'You can review the *man* page for *strftime()* to discover all the fun placeholders
    and what they do. Like the *printf()* function, the placeholders are prefixed
    by a % character. Any other text in the formatting string is output as is. Here
    are the highlights from the *strftime()* statement in listing 2.6:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以查看*strftime()*的*man*页面，以发现所有有趣的占位符及其功能。就像*printf()*函数一样，占位符以%字符为前缀。格式化字符串中的任何其他文本都按原样输出。以下是示例代码2.6中*strftime()*语句的亮点：
- en: '![02-00_UN01](Images/02-00_UN01.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![02-00_UN01](Images/02-00_UN01.png)'
- en: 'The output reflects the time string generated and stored in the time_string[]
    buffer. The time string appears after the general greeting as covered earlier
    in this chapter:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 输出反映了生成并存储在time_string[]缓冲区中的时间字符串。时间字符串在前面章节中提到的通用问候语之后出现：
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: At this point, some neckbeard might say that all this output can easily be accomplished
    by using a shell scripting language, which is the native tongue of the shell startup
    and configuration file anyway. Yes, such people exist. Still, as a C programmer,
    your job is to offer more insight and power to the greeting. Such additions aren’t
    possible when using a sad little shell scripting language. So there.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一些“宅男”可能会说，所有这些输出都可以通过使用shell脚本语言轻松完成，因为shell启动和配置文件的母语就是shell脚本语言。是的，这样的人存在。然而，作为一个C程序员，你的任务是向问候语提供更多的洞察力和功能。使用悲伤的小shell脚本语言时，这些添加是不可能的。所以就这样。
- en: 2.4 The current moon phase
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4 当前月相
- en: My sense is that most programmers operate best at night. So why bother programming
    a moon phase greeting when you can just pop your head out a window and look up?
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我的直觉是大多数程序员在夜间工作效率最高。那么，当你可以只是伸出头来窗外仰望时，为什么还要费心编写一个月相问候呢？
- en: 'You’re correct: the effort is too much trouble, especially when you can write
    a C program to get a good approximation of the moon phase while remaining safely
    indoors. You can even delight yourself with this interesting tidbit every time
    you start a terminal window. Outside? It’s overrated.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你是对的：这种努力太麻烦了，尤其是当你可以编写一个C程序来在室内安全地获得月相的良好近似值时。你甚至可以在每次打开终端窗口时，用这个有趣的片段取悦自己。外面？那只是过誉了。
- en: 2.4.1 Observing moon phases
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.1 观察月相
- en: 'The ancient Mayans wrote the first moon phase algorithm, probably in COBOL.
    I’d print a copy of the code here, but it’s just easier to express the pictogram:
    it’s a little guy squatting on a rock, extending a long tongue, wearing a festive
    hat, and wearing an angry expression on his face. Programmers know this stance
    well.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 古代玛雅人编写了第一个月相算法，可能是在COBOL语言中。我本想在这里打印一段代码，但直接表达象形文字更简单：它是一个小个子蹲在石头上，伸出长长的舌头，戴着节日帽，脸上表情愤怒。程序员们对此姿势很熟悉。
- en: The moon goes through phases as it orbits the Earth. The phases are based on
    how much of the moon is exposed to sunlight as seen from Earth. Figure 2.1 illustrates
    the moon’s orbit. The sunny side always faces the sun, though from the Earth we
    see different portions of the moon illuminated. These are the moon’s phases.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 月球在绕地球运行时经过不同的相位。这些相位是基于从地球看到的月亮暴露在阳光下的程度。图2.1展示了月球的轨道。阳光的一面总是朝向太阳，尽管从地球上看，我们看到月亮的不同部分被照亮。这些就是月亮的相位。
- en: '![02-01](Images/02-01.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![02-01](Images/02-01.png)'
- en: Figure 2.1 The moon’s orbit affects how much of the illuminated side is visible
    from Earth.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 月球轨道影响从地球看到的照明侧面可见的部分。
- en: The phases as they appear from an earthling’s perspective are named and illustrated
    in figure 2.2\. During its 28-day journey, the moon’s phase changes from new (no
    illumination) to full and back to new again. Further, half the time, the moon
    is visible (often barely) during daylight hours.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 从地球人的视角看，月相被命名并如图2.2所示。在28天的旅程中，月亮的相位从新月（无照明）变为满月，然后再回到新月。此外，一半的时间，月亮在白天可见（通常几乎看不见）。
- en: '![02-02](Images/02-02.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![02-02](Images/02-02.png)'
- en: Figure 2.2 Moon phases as seen from Earth
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 从地球看到的月相
- en: The phases shown in figure 2.2 follow the moon’s progress from new to full and
    back again. The latter waning phases happen in the morning, which is why they’re
    only popular with men named Wayne.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 中显示的相位遵循月亮从新月到满月再回到新月的进程。后者衰减的相位发生在早晨，这也是为什么它们只受到名叫韦恩的男性的欢迎。
- en: 2.4.2 Writing the moon phase algorithm
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.2 编写月相算法
- en: Without looking outside right now, can you tell the moon phase?
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在不向外看，你能说出月相吗？
- en: Yes, I assume that you’re reading this book at night. Programmers are predictable.
    Congratulations if you’re reading this book during the day—outside, even. Regardless
    of the time, the moon has a current phase. Not a moody teenager phase, but one
    of the moon how-much-is-illuminated thingies covered in the preceding section.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我假设你现在在晚上读这本书。程序员是可以预测的。如果你在白天读这本书——甚至在户外——那就恭喜你了。不管时间如何，月亮都有一个当前的相位。不是情绪化的青少年相位，而是前面章节中提到的月亮多少被照亮的状态。
- en: To determine the moon phase without looking outside or in a reference, you use
    an algorithm. These are abundant and available on the internet as well as carved
    into Mayan tablets. The key is the moon’s predictable cycle, which can be mapped
    to days, months, and years. The degree of accuracy of the algorithm depends on
    a lot of things, such as your location and the time of day. And if you want to
    be exact, you must use complex geometry and messy stuff I don’t even want to look
    at through one eye half-shut.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定月相而无需向外看或查阅参考，你可以使用一个算法。这些算法在互联网上很常见，也刻在玛雅的石板上。关键是月亮的可预测周期，它可以映射到日、月和年。算法的精确度取决于许多因素，例如你的位置和一天中的时间。如果你想非常精确，你必须使用复杂的几何和混乱的东西，即使半闭一只眼我也不想看。
- en: 'Listing 2.7 shows the moon_phase() function. It contains an algorithm I found
    years ago, probably on the old ARPANET. My point is: I don’t know where it came
    from. It’s mostly accurate, which is what I find of typical moon phase algorithms
    that don’t use complex and frightening math functions.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.7 展示了 moon_phase() 函数。它包含了我多年前找到的算法，可能是在旧的 ARPANET 上。我的观点是：我不知道它从哪里来。它大部分是准确的，这是我典型的月相算法的特点，这些算法不使用复杂和令人恐惧的数学函数。
- en: Listing 2.7 The *moon_phase()* function
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.7：*moon_phase()* 函数
- en: '[PRE28]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The algorithm presented in listing 2.7 requires three arguments: the integers
    year, month, and day. These are the same as values found in the members of a *localtime()*
    tm structure: tm_year+1900 for the year, tm_mon for the month (which starts with
    0 for January), and tm_day for the day of the month, starting with 1.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.7 中提出的算法需要三个参数：整数 year（年）、month（月）和 day（日）。这些与 *localtime()* tm 结构的成员中的值相同：tm_year+1900
    表示年，tm_mon 表示月（从 1 月开始为 0），tm_day 表示月份中的日，从 1 开始。
- en: 'Here’s how I’m going to explain how the algorithm works: I’m not. Seriously,
    I have no clue what’s going on. I just copied down the formula from somewhere
    and—by golly—it mostly works. Mostly.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我将要解释算法如何工作的方法：我不会。说真的，我对此一无所知。我只是从某处抄下了公式，而且——天哪——它大部分是有效的。大部分。
- en: 'Insert the code from listing 2.7 into your favorite greetings program. If you
    paste it in above the *main()* function, it won’t require a prototype. Otherwise,
    prototype it as:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 将列表 2.7 中的代码插入到你的首选问候程序中。如果你在 *main()* 函数上方粘贴它，它就不需要原型。否则，将其原型化如下：
- en: '[PRE29]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The function returns an integer in the range of 0 to 7 representing the eight
    moon phases shown earlier in figure 2.2, and in that order. An array of strings
    representing these phases, matching up to the value returned by the *moon_phase()*
    function, looks like this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 函数返回一个范围在 0 到 7 之间的整数，代表前面图 2.2 中显示的八个月相，并按此顺序。一个表示这些相位的字符串数组，与 *moon_phase()*
    函数返回的值相匹配，如下所示：
- en: '[PRE30]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You can craft the rest of the code yourself. I’ve included it as moon.c in this
    book’s code repository as described in the introduction, which you haven’t read.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以自己编写剩余的代码。我在本书的代码仓库中包含了它，作为 moon.c，如引言中所述，但你还没有阅读过。
- en: With this knowledge in hand, you can easily add the moon phase as output to
    your terminal program’s initial greeting. One thing you don’t want to do, however,
    is use this moon phase algorithm to accurately predict the moon phase. Seriously,
    it’s for fun only. Don’t use this algorithm to launch a manned rocket to the moon.
    I’m looking at you, Italy.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有这些知识，你可以轻松地将月相作为输出添加到你的终端程序初始问候中。然而，有一件事你不想做，那就是使用这个月相算法来准确预测月相。说真的，这只是一种娱乐。不要用这个算法发射载人火箭到月球。我在看着你，意大利。
- en: 2.4.3 Adding the moon phase to your greeting
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.3 将月相添加到你的问候中
- en: You can add the *moon_phase()* function to any of the source code samples for
    the greetings series of programs listed in this chapter. You need to fetch time-based
    data, which the *moon_phase()* function requires to make its calculation. You
    also need an array of strings to output the current moon phase text based on the
    value the function returns.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将*moon_phase()*函数添加到本章中列出的问候系列程序中的任何源代码示例中。您需要获取基于时间的数据，这是*moon_phase()*函数进行计算所需的。您还需要一个字符串数组，根据函数返回的值输出当前的月相文本。
- en: 'Listing 2.6, showing the greet04.c source code, is the best candidate for modification.
    Make the following changes:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.6显示了greet04.c的源代码，是修改的最佳候选。进行以下更改：
- en: 'Add a declaration in the main() function for integer variable mp to hold the
    value returned from the *moon_phase()* function:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在main()函数中声明一个整数变量mp，用于存储从*moon_phase()*函数返回的值：
- en: '[PRE31]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Add the following two statements after the last *printf()* statement in the
    existing code, just before the *return*:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在现有代码中的最后一个*printf()*语句之后，在*return*之前添加以下两个语句：
- en: '[PRE32]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You could combine these statements into a single *printf()* statement, eliminating
    the need for the mp variable: Insert the *moon_phase()* function call (the first
    line) into the brackets in the *printf()* statement. The result is a painfully
    long line of code, which is why I split it up. I’d choose readability over a long
    line of code any day.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将这些语句合并为一个单独的*printf()*语句，从而消除对mp变量的需求：将*moon_phase()*函数调用（第一行）插入到*printf()*语句中的括号内。结果是代码行非常长，这就是为什么我将其拆分的原因。我宁愿选择可读性，也不愿选择长代码行。
- en: 'A final copy of greet05.c can be found in this book’s GitHub repository. Here
    is sample output:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的GitHub存储库中找到greet05.c的最终副本。以下是示例输出：
- en: '[PRE33]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Imagine the delight your users will have, seeing such a meaty message at the
    start of their terminal window day. They’ll lean back and smile, giving a thankful
    nod as they say, “I appreciate the scintillating details, my programmer friend.
    Glad I don’t have to venture outside tonight. Thank you.”
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下您的用户在终端窗口开始时看到这样丰富信息的喜悦。他们会靠在椅背上微笑，当他们说“我欣赏这些闪光的细节，我的程序员朋友。很高兴今晚不用外出。谢谢。”时，会点头表示感谢。
- en: 2.5 A pithy saying
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.5 一句箴言
- en: The fortune program has been a staple of shell startup scripts since the old
    days, back when some Unix terminals were treadle powered. It remains available
    today, easily installed from your distro’s package manager; search for “fortune.”
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运程序自早期以来一直是shell启动脚本的一部分，那时一些Unix终端还是脚踏式供电的。它今天仍然可用，可以从您发行版的包管理器中轻松安装；搜索“fortune”。
- en: The name “fortune” comes from the fortune cookie. The idea is to generate a
    pithy saying, or *bon mot*, which you can use as fresh motivation to start your
    day. These are inspired by the desserts provided at some Chinese restaurants,
    which serve the purpose of holding down the paper ticket more than they provide
    any nutritional value.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: “幸运”这个名字来自幸运饼干。想法是生成一句箴言，或*巧言妙语*，您可以用它作为新鲜的动力开始您的一天。这些灵感来自一些中国餐馆提供的甜点，它们的作用是固定纸条，而不是提供任何营养价值。
- en: 'Here is an example of a digital fortune cookie, output from the fortune program:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个数字幸运饼干的例子，来自幸运程序：
- en: '[PRE34]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: It’s possible to replicate the fortune program output, providing you have a
    database of pithy sayings and a program eager to pluck out a random one.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一个箴言数据库和一个渴望随机抽取一个的程序，您就可以复制幸运程序输出。
- en: 2.5.1 Creating a pithy phrase repository
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.1 创建箴言存储库
- en: The fortune program comes with one or more databases of witticisms. It’s from
    this database that the fortune cookie message is retrieved and output on the screen.
    You could borrow from this list, but that’s cheating. It’s also silly, because
    the fortune program is already written. You’d learn nothing. For shame!
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运程序附带一个或多个格言数据库。幸运饼干的信息就是从这里检索并输出到屏幕上的。您可以借鉴这个列表，但这是一种作弊行为。这也很愚蠢，因为幸运程序已经编写好了。您将一无所学。真丢脸！
- en: Your goal is to write your own version of the pithy phrase database. It need
    not be quotes or humor, either. The list could contain tips about using the computer,
    reminders about IT security, and other important information, like the current,
    trendy hairstyles.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 您的目标是编写您自己的箴言数据库版本。它不必是引言或幽默，也可以包含有关使用计算机的建议、关于IT安全的提醒以及其他重要信息，如当前的流行发型。
- en: 'I can imagine several ways to configure the list. This planning is vital to
    writing good code: a well-organized list means you have less coding to do. The
    goal is to pluck a random phrase from the repository, which means an organized
    file is a must. Figure 2.3 outlines the process for writing code to pluck a random,
    pithy phrase from a list or database.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以想象几种配置列表的方法。这种规划对于编写好的代码至关重要：一个组织良好的列表意味着你需要的编码工作更少。目标是随机从存储库中抽取一个短语，这意味着一个组织良好的文件是必须的。图
    2.3 概述了编写代码从列表或数据库中随机抽取简短短语的过程。
- en: '![02-03](Images/02-03.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![02-03](Images/02-03.png)'
- en: Figure 2.3 The process for reading a random, pithy quote from a file
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 从文件中读取随机简短引言的过程
- en: I can imagine several approaches to formatting the file, as covered in table
    2.2.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以想象几种格式化文件的方法，如表 2.2 所述。
- en: Table 2.2 Approaches to storing sayings for easy access
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.2 存储短语以方便访问的方法
- en: '| File format/data | Pros | Cons |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| 文件格式/数据 | 优点 | 缺点 |'
- en: '| Basic text file | Simple to maintain using existing tools | The file must
    be read and indexed every time the program runs. |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| 基本文本文件 | 使用现有工具简单维护 | 每次程序运行时都必须读取和索引文件。 |'
- en: '| Formatted file with an initial item count reflecting the number of entries
    | Item count can be read instantly | The item count must be updated as the list
    is modified. |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| 带有初始项目计数的格式化文件 | 项目计数可以立即读取 | 随着列表的修改，项目计数必须更新。 |'
- en: '| Hash table with indexed entries | Easy to read and access each record | You
    will most likely need a separate program to maintain the list, which is more coding
    to do. |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| 带索引条目的散列表 | 读取和访问每个记录都很容易 | 你可能需要一个单独的程序来维护列表，这将需要更多的编码工作。 |'
- en: I prefer the basic text file for my list, which means more overhead is required
    in order to fetch a random entry. It also means that I don’t need to write a list
    maintenance program. Another benefit is that anyone can edit the sayings file,
    adding and removing entries at their whim.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢使用基本文本文件来创建我的列表，这意味着需要更多的开销来获取一个随机条目。这也意味着我不需要编写列表维护程序。另一个好处是任何人都可以编辑短语文件，随意添加和删除条目。
- en: Eschewing all other options, my approach is to read the file a line at a time,
    storing and indexing each line in memory. The file needs to be read only once
    with this method, so it’s what I choose to do. The downside? I must manage memory
    locations, also known as *pointers*.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 不考虑其他所有选项，我的方法是逐行读取文件，将每一行存储和索引在内存中。使用这种方法，文件只需要读取一次，所以我选择这样做。缺点？我必须管理内存位置，也就是所说的*指针*。
- en: Fret not, gentle reader.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心，亲爱的读者。
- en: The bonus of my approach (forgetting pointers for the moment) is that you can
    use any text file for your list. Files with short lines of text work best; otherwise,
    you must wrap the text on the terminal screen, which is more work. The file pithy.txt
    can be found in this book’s GitHub repository.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我的方法（暂时忘记指针）的好处是你可以使用任何文本文件来创建你的列表。短行文本的文件效果最佳；否则，你必须在终端屏幕上换行，这会更多的工作。pithy.txt
    文件可以在本书的 GitHub 仓库中找到。
- en: 2.5.2 Randomly reading a pithy phrase
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.2 随机读取简短短语
- en: My pithy-phrase greetings program reads lines of text from the repository file,
    allocating storage space for each string read. As the lines are read and stored,
    an index is created. This index is a pointer array, but one created dynamically
    by allocating storage as the file is read. This approach is complex in that it
    involves those horrifying pointer-pointer things (two-asterisk notation) and liberal
    use of the *malloc*() and *realloc()* function. I find such activity enjoyable,
    but I also enjoy natto. So there.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我的短语问候程序从存储库文件中读取文本行，为每个读取的字符串分配存储空间。随着文本行的读取和存储，创建了一个索引。这个索引是一个指针数组，但它是通过在读取文件时动态分配存储空间创建的。这种方法很复杂，因为它涉及到那些令人恐惧的指针-指针东西（双星号表示）和大量使用
    *malloc*() 和 *realloc()* 函数。我发现这样的活动很有趣，但我同样喜欢纳豆。就是这样。
- en: As with any complex topic in programming, the best way to tackle the project
    is to code it one step at a time. The first step is to read a text file and output
    its contents. The code in listing 2.8 accomplishes this first task by reading
    lines of text from the file pithy.txt. Remember, this code is just the start.
    The pointer insanity is added later.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 就像编程中的任何复杂主题一样，处理项目的最佳方式是逐步编码。第一步是读取文本文件并输出其内容。列表 2.8 中的代码通过从 pithy.txt 文件中读取文本行来完成这个第一个任务。记住，这只是一个开始。指针疯狂是在之后添加的。
- en: Listing 2.8 Source code for pithy01.c
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.8 pithy01.c 的源代码
- en: '[PRE35]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: ❶ The file pithy.txt is assumed to be in the same directory as the program.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 假设文件 pithy.txt 与程序位于同一目录下。
- en: ❷ The buffer is used to read text from the file; the size is a guess, set as
    defined constant BSIZE (line 4).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 缓冲区用于从文件中读取文本；大小是一个猜测，设置为定义的常量`BSIZE`（第4行）。
- en: ❸ Loops as long as the file isn’t empty
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 循环直到文件不为空
- en: ❹ The variable r ensures that *fgets()* doesn’t mess up and read beyond the
    end of the file; if so, the loop stops.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 变量`r`确保`*fgets()*`不会搞乱并读取到文件末尾；如果是这样，循环停止。
- en: ❺ Outputs all the lines in the file
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 输出文件中的所有行
- en: The purpose of pithy01.c is to read all the lines from the file. That’s it.
    Each line is stored in char array buffer[] and then output. The same buffer is
    used over and over.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: pithy01.c的目的是从文件中读取所有行。仅此而已。每行存储在字符数组`buffer[]`中，然后输出。相同的缓冲区被反复使用。
- en: The program’s output is a dump of the contents of file pithy.txt. For a release
    program, your code must ensure that the proper path to pithy.txt (or whatever
    file you choose) is confirmed and made available.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出是文件`pithy.txt`的内容转储。对于一个发布程序，你的代码必须确保确认并使`pithy.txt`（或你选择的任何文件）的正确路径可用。
- en: 'Build and run to prove it works. Fix any problems. When it’s just right, move
    on to the next step: use a pointer and allocate memory to store the strings read.
    Remember, the final program stores all the file’s strings in memory. Because the
    number of strings is unknown, this allocation method works better than guessing
    an array size.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行以证明其工作。修复任何问题。当一切就绪时，继续下一步：使用指针并分配内存以存储读取的字符串。记住，最终的程序将所有文件中的字符串存储在内存中。因为字符串的数量是未知的，这种分配方法比猜测数组大小更有效。
- en: To proceed with the next improvement, a new variable entry is introduced. It’s
    a char pointer, which must be allocated based on the size of the line read from
    the file. Once allocated, the contents of buffer[] are copied into the memory
    chunk referenced by pointer entry. It’s this string that’s output, not the contents
    of buffer[].
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行下一个改进，引入一个新的变量`entry`。它是一个字符指针，必须根据从文件中读取的行的大小进行分配。一旦分配，`buffer[]`的内容就复制到由指针`entry`引用的内存块中。输出的是这个字符串，而不是`buffer[]`的内容。
- en: Another improvement is to count the number of items read from the file. For
    this task, the *int* variable items is added, initialized, and incremented within
    the *while* loop.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个改进是计算从文件中读取的项目数量。为此任务，在`*while*`循环中添加、初始化并递增`*int*`变量`items`。
- en: 'Here are the updates to the code: Add a line to include the string.h header
    file, required for the *strcpy()* function:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是代码的更新：添加一行以包含`string.h`头文件，这是`*strcpy()*`函数所需的：
- en: '[PRE36]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the variable declarations part of the code, add *char* pointer entry and
    *int* variable items:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的变量声明部分，添加`*char*`指针`entry`和`*int*`变量`items`：
- en: '[PRE37]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Before the *while* loop, initialize variable items to zero:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在`*while*`循环之前，将变量`items`初始化为零：
- en: '[PRE38]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Within the *while* loop, memory is allocated for variable entry. The pointer
    must be tested to ensure memory is available. Then the contents of buffer[] are
    copied to entry, the contents of entry output, and the items variable incremented.
    Here is the chunk of code to replace the existing *printf()* statement in the
    original program:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在`*while*`循环内部，为变量`entry`分配内存。必须测试指针以确保内存可用。然后将`buffer[]`的内容复制到`entry`中，输出`entry`的内容，并将`items`变量递增。以下是替换原始程序中现有的`*printf()*`语句的代码段：
- en: '[PRE39]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: ❶ Enough storage for the string, plus one for the null character
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 为字符串预留足够的存储空间，再加一个用于空字符
- en: These updates, found in the online repository in pithy02.c, only change the
    output by prefixing each line read with its item number, starting with zero for
    the first line read from the file. While this update may seem tiny, it’s necessary
    to continue with the next step, which is dynamically storing all the strings read
    from the file into memory.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更新可以在在线存储库中的`pithy02.c`中找到，它们只通过在每个读取的行前加上其项目编号来更改输出，从文件中读取的第一行开始编号为零。虽然这个更新看起来很小，但对于继续下一步，即动态地将从文件中读取的所有字符串存储到内存中，是必要的。
- en: As the program sits now, it allocates a series of buffers to store the strings
    read. Yet the addresses for these buffers are lost in memory. To resolve this
    issue, a pointer-pointer is required. The pointer-pointer, or address of a pointer,
    keeps track of all the string’s memory locations. This improvement is where the
    code earns its NC-17 rating.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在程序的状态是，它分配一系列缓冲区以存储读取的字符串。然而，这些缓冲区的地址在内存中丢失。为了解决这个问题，需要一个指针指针。指针指针，或指针的地址，跟踪所有字符串的内存位置。这种改进是代码获得NC-17评级的地方。
- en: 'To track the strings stored in memory, make these improvements to pithy02.c,
    which now becomes pithy03.c:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟踪存储在内存中的字符串，对 pithy02.c 进行以下改进，现在它变成了 pithy03.c：
- en: 'Add a second *int* variable, x, used in a later *for* loop. Also add the pointer-pointer
    variable list_base:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个第二个 *int* 变量 x，它将在后面的 *for* 循环中使用。还要添加指针-指针变量 list_base：
- en: '[PRE40]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The list_base variable keeps track of the entry pointers allocated later in
    the code. But first, the list_base pointer must be allocated itself. Insert this
    code just after the file is opened and before the *while* loop:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: list_base 变量跟踪代码中稍后分配的 entry 指针。但首先，list_base 指针本身必须被分配。在文件打开后和 *while* 循环之前插入此代码：
- en: '[PRE41]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The illustration in figure 2.4 shows what’s happening with the first statement
    allocating variable list_base. It’s a pointer to a pointer, which requires the
    ** notation. The items it references are character pointers. The size of the list
    is 100 entries, which is good enough—for now.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 说明了第一个语句分配变量 list_base 时发生的情况。它是一个指向指针的指针，需要使用 ** 符号。它引用的是字符指针。列表的大小为
    100 个条目，这对于现在来说已经足够了。
- en: '![02-04](Images/02-04.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![02-04](Images/02-04.png)'
- en: Figure 2.4 How the terrifying pointer-pointer buffer is allocated
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 指针-指针缓冲区的分配方式
- en: 'Within the *while* loop, remove the *printf()* statement. Outputting statements
    takes place outside the loop. In place of the *printf()* statement, add this statement
    below the *strcpy()* statement:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *while* 循环中，删除 *printf()* 语句。输出语句发生在循环之外。在 *strcpy()* 语句下面添加此语句：
- en: '[PRE42]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Using the offset provided by the items count, this statement copies the address
    stored in pointer variable entry into the list maintained at location list_base.
    Only the address is copied, not the entire string. This statement represents crazy
    pointer stuff—and it works. Figure 2.5 illustrates how the crazy kit ’n’ kaboodle
    looks.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 items 计数提供的偏移量，此语句将存储在指针变量 entry 中的地址复制到位于 list_base 位置的列表中。只复制地址，而不是整个字符串。这个语句代表了疯狂的指针操作——但它确实有效。图
    2.5 展示了疯狂的工具箱看起来是什么样子。
- en: '![02-05](Images/02-05.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![02-05](Images/02-05.png)'
- en: Figure 2.5 The list_base and items variables help store strings allocated by
    the entry pointer.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 list_base 和 items 变量帮助存储由 entry 指针分配的字符串。
- en: 'Finally, after the file is closed, output all the items with this *for* loop:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在关闭文件后，使用这个 *for* 循环输出所有项目：
- en: '[PRE43]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In this loop, variable x sets the offset in the list of addresses: *(list_base+x)
    references each line of text read from the file, now stored in memory.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个循环中，变量 x 设置列表中的偏移量：*(list_base+x) 引用从文件中读取并现在存储在内存中的每一行文本。
- en: At this point, the program effectively reads all the text from the file, stores
    the text in memory, and keeps track of each string. Before a random string can
    be plucked out of the lot, care must be taken to consider when more than 100 lines
    are read from the file.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，程序有效地从文件中读取所有文本，将文本存储在内存中，并跟踪每个字符串。在从文件中随机抽取字符串之前，必须注意当从文件中读取超过 100 行时的情况。
- en: When memory is allocated for the list_base variable, only 100 pointers can be
    stored in that memory chunk. If the value of variable items creeps above 100,
    a memory overflow occurs. To prevent this catastrophe, the code must reallocate
    memory for list_base. This way, if the file that’s read contains more than 100
    lines of text, they can be stored in memory without the program puking all over
    itself.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 当为 list_base 变量分配内存时，只能在该内存块中存储 100 个指针。如果变量 items 的值超过 100，就会发生内存溢出。为了防止这种灾难，代码必须重新分配
    list_base 的内存。这样，如果读取的文件包含超过 100 行的文本，它们可以在内存中存储，而不会让程序自己出问题。
- en: To reallocate memory, or to increase the size of an already-created buffer,
    use the *realloc()* function. Its arguments are the existing buffer’s pointer
    and the new buffer size. Upon success, the contents of the old buffer are copied
    into the new, larger buffer. For the size of list_base to be increased, it must
    be reallocated to another 100 char pointer-sized chunks.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 要重新分配内存或增加已创建缓冲区的大小，请使用 *realloc()* 函数。它的参数是现有缓冲区的指针和新缓冲区的大小。如果成功，旧缓冲区的内容将被复制到新的更大的缓冲区中。为了增加
    list_base 的大小，它必须重新分配到另一个 100 个 char 指针大小的块。
- en: 'Only one change is required in order to update the code. The following lines
    are inserted at the end of the *while* loop, just after the items variable is
    incremented:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 只需对代码进行一次修改即可更新。以下行被插入到 *while* 循环的末尾，就在 items 变量增加之后：
- en: '[PRE44]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: ❶ Every time items is exactly divisible by 100 . . .
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 每当 items 能被 100 整除时……
- en: ❷ . . . existing storage is increased by 100 pointer-size chunks.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ . . . 现有存储通过100个指针大小的块增加。
- en: This update is saved as pithy04.c. The code runs the same as the program generated
    from pithy03.c, though if the file that’s read contains more than 100 lines of
    text, each is properly allocated, stored, and referenced without disaster.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这次更新被保存为pithy04.c。代码运行与从pithy03.c生成的程序相同，尽管如果读取的文件包含超过100行的文本，每一行都会被正确地分配、存储和引用，而不会出现灾难。
- en: 'The program is now ready to do its job: to select and output a random item
    from the file. The final step is to remove the *for* loop at the end of the code;
    it’s no longer needed, as the program is required to output only one random line
    from the file.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 程序现在已准备好执行其任务：从文件中选择并输出一个随机项。最后一步是移除代码末尾的*for*循环；它不再需要，因为程序只需要从文件中输出一行随机文本。
- en: 'Start by including the time.h header file:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 首先包括time.h头文件：
- en: '[PRE45]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Replace the declaration for its *int* variable x with a declaration for new
    variable saying:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 将其*int*变量x的声明替换为对新变量的声明：
- en: '[PRE46]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Three lines are added to the end of the code, just above the *return* statement:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码末尾添加了三行，位于*return*语句之上：
- en: '[PRE47]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This is the final update to the code, available in the online repository as
    pithy05.c. When run, the program extracts a random line from the file, outputting
    its text.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码的最终更新，可在在线存储库中作为pithy05.c找到。运行时，程序从文件中提取一行随机文本，并输出其内容。
- en: As I wrote earlier in this section, this approach is only one way to resolve
    the problem. It’s quick and it works, which is good enough to add a pithy saying
    to your shell startup script.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在这部分之前所写的，这种方法只是解决问题的一种方式。它快速且有效，这对于在shell启动脚本中添加一句精炼的格言来说已经足够好了。
- en: 'One final note: the program doesn’t release any memory directly. Normally,
    the end of a function would be dotted with *free()* statements, one for each memory
    chunk allocated. Because the entire code dwells within the *main()* function,
    freeing memory isn’t necessary. The memory allocated is freed when the program
    quits. Had the allocation taken place in a function, however, it’s necessary to
    release the allocation or risk losing the memory chunk and potentially causing
    a memory overflow.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点：程序不会直接释放任何内存。通常，函数的末尾会有*free()*语句，每个分配的内存块一个。因为整个代码都位于*main()*函数中，所以释放内存不是必要的。分配的内存会在程序退出时释放。然而，如果分配发生在函数中，则必须释放分配，否则可能会丢失内存块并可能导致内存溢出。
- en: 2.5.3 Adding the phrase to your greeting code
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.3 将短语添加到问候代码中
- en: If your goal is to modify a single greetings program for the shell’s startup
    script, your next task is to add the code from the pithy series of programs into
    your greetings program. Such a task would keep all your efforts in a single program
    and all the output on a single line in the shell startup script.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的目标是修改一个用于shell启动脚本的单一问候程序，你的下一个任务就是将精简系列程序中的代码添加到你的问候程序中。这样的任务将使所有努力都集中在单个程序中，并且所有输出都将在shell启动脚本的单行中。
- en: Because the *pithy* program is kinda fun, I’m not incorporating it into my previous
    greetings program code. Instead, I’ll leave it as its own line in the shell startup
    script. That way, I can also run the program from the command prompt any time
    I need to be humored or am in need of levity. You can work to incorporate the
    pithy program into your greetings program on your own.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 因为*pithy*程序有点有趣，所以我不会将其整合到之前的问候程序代码中。相反，我将将其作为shell启动脚本中的一行单独留下。这样，我也可以在需要轻松或需要轻松时刻时从命令提示符运行程序。你可以自己尝试将*pithy*程序整合到你的问候程序中。
